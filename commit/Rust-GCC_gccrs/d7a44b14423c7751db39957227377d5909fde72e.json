{"sha": "d7a44b14423c7751db39957227377d5909fde72e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdhNDRiMTQ0MjNjNzc1MWRiMzk5NTcyMjczNzdkNTkwOWZkZTcyZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-23T08:29:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-23T08:29:15Z"}, "message": "[multiple changes]\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): When checking for\n\tpotential ambiguities with class-wide operations on synchronized\n\ttypes, attach the copied node properly to the tree, to prevent\n\terrors during expansion.\n\n2012-07-23  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Loop_Statement): Make sure the loop body\n\tis analyzed in Alfa mode.\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb: Adjust previous change.\n\n2012-07-23  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_ch9.adb (Allows_Lock_Free_Implementation): Flag\n\tLock_Free_Given renames previous flag Complain. Description\n\tupdated. Henceforth, catch every error messages issued by this\n\troutine when Lock_Free_Given is True.  Declaration restriction\n\tupdated: No non-elementary parameter instead (even in parameter)\n\tNew subprogram body restrictions implemented: No allocator,\n\tno address, import or export rep items, no delay statement,\n\tno goto statement, no quantified expression and no dereference\n\tof access value.\n\n2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Determine_Range): Add local variable Btyp. Handle\n\tthe case where the base type of an enumeration subtype is\n\tprivate. Replace all occurrences of Base_Type with Btyp.\n\t* exp_attr.adb (Attribute_Valid): Handle the case where the\n\tbase type of an enumeration subtype is private. Replace all\n\toccurrences of Base_Type with Btyp.\n\t* sem_util.adb (Get_Enum_Lit_From_Pos): Add local variable\n\tBtyp. Handle the case where the base type of an enumeration\n\tsubtype is private. Replace all occurrences of Base_Type with\n\tBtyp.\n\nFrom-SVN: r189775", "tree": {"sha": "fa206e9a194b8c244a908d5e6ea375765a2ea9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa206e9a194b8c244a908d5e6ea375765a2ea9a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7a44b14423c7751db39957227377d5909fde72e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a44b14423c7751db39957227377d5909fde72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a44b14423c7751db39957227377d5909fde72e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a44b14423c7751db39957227377d5909fde72e/comments", "author": null, "committer": null, "parents": [{"sha": "50878404473455327bb16a227beab6a742bcec41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50878404473455327bb16a227beab6a742bcec41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50878404473455327bb16a227beab6a742bcec41"}], "stats": {"total": 436, "additions": 342, "deletions": 94}, "files": [{"sha": "a25e8e1550542dfe1ffdc03bb8291782f7549ce9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -1,3 +1,44 @@\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): When checking for\n+\tpotential ambiguities with class-wide operations on synchronized\n+\ttypes, attach the copied node properly to the tree, to prevent\n+\terrors during expansion.\n+\n+2012-07-23  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Make sure the loop body\n+\tis analyzed in Alfa mode.\n+\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb: Adjust previous change.\n+\n+2012-07-23  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_ch9.adb (Allows_Lock_Free_Implementation): Flag\n+\tLock_Free_Given renames previous flag Complain. Description\n+\tupdated. Henceforth, catch every error messages issued by this\n+\troutine when Lock_Free_Given is True.  Declaration restriction\n+\tupdated: No non-elementary parameter instead (even in parameter)\n+\tNew subprogram body restrictions implemented: No allocator,\n+\tno address, import or export rep items, no delay statement,\n+\tno goto statement, no quantified expression and no dereference\n+\tof access value.\n+\n+2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Determine_Range): Add local variable Btyp. Handle\n+\tthe case where the base type of an enumeration subtype is\n+\tprivate. Replace all occurrences of Base_Type with Btyp.\n+\t* exp_attr.adb (Attribute_Valid): Handle the case where the\n+\tbase type of an enumeration subtype is private. Replace all\n+\toccurrences of Base_Type with Btyp.\n+\t* sem_util.adb (Get_Enum_Lit_From_Pos): Add local variable\n+\tBtyp. Handle the case where the base type of an enumeration\n+\tsubtype is private. Replace all occurrences of Base_Type with\n+\tBtyp.\n+\n 2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* par-ch6.adb (P_Mode): in Ada 2005, a mode indicator can apply"}, {"sha": "6ac553382deddbf0bc2811e091b7e2d08101d22d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -3151,6 +3151,9 @@ package body Checks is\n       Cindex : Cache_Index;\n       --  Used to search cache\n \n+      Btyp : Entity_Id;\n+      --  Base type\n+\n       function OK_Operands return Boolean;\n       --  Used for binary operators. Determines the ranges of the left and\n       --  right operands, and if they are both OK, returns True, and puts\n@@ -3267,6 +3270,15 @@ package body Checks is\n          Typ := Underlying_Type (Base_Type (Typ));\n       end if;\n \n+      --  Retrieve the base type. Handle the case where the base type is a\n+      --  private enumeration type.\n+\n+      Btyp := Base_Type (Typ);\n+\n+      if Is_Private_Type (Btyp) and then Present (Full_View (Btyp)) then\n+         Btyp := Full_View (Btyp);\n+      end if;\n+\n       --  We use the actual bound unless it is dynamic, in which case use the\n       --  corresponding base type bound if possible. If we can't get a bound\n       --  then we figure we can't determine the range (a peculiar case, that\n@@ -3280,8 +3292,8 @@ package body Checks is\n       if Compile_Time_Known_Value (Bound) then\n          Lo := Expr_Value (Bound);\n \n-      elsif Compile_Time_Known_Value (Type_Low_Bound (Base_Type (Typ))) then\n-         Lo := Expr_Value (Type_Low_Bound (Base_Type (Typ)));\n+      elsif Compile_Time_Known_Value (Type_Low_Bound (Btyp)) then\n+         Lo := Expr_Value (Type_Low_Bound (Btyp));\n \n       else\n          OK := False;\n@@ -3296,8 +3308,8 @@ package body Checks is\n       --  always be compile time known. Again, it is not clear that this\n       --  can ever be false, but no point in bombing.\n \n-      if Compile_Time_Known_Value (Type_High_Bound (Base_Type (Typ))) then\n-         Hbound := Expr_Value (Type_High_Bound (Base_Type (Typ)));\n+      if Compile_Time_Known_Value (Type_High_Bound (Btyp)) then\n+         Hbound := Expr_Value (Type_High_Bound (Btyp));\n          Hi := Hbound;\n \n       else\n@@ -4744,17 +4756,17 @@ package body Checks is\n             --  associated subtype.\n \n             Insert_Action (N,\n-               Make_Raise_Constraint_Error (Loc,\n-                 Condition =>\n-                    Make_Not_In (Loc,\n-                      Left_Opnd  =>\n-                        Convert_To (Base_Type (Etype (Sub)),\n-                          Duplicate_Subexpr_Move_Checks (Sub)),\n-                      Right_Opnd =>\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         => New_Reference_To (Etype (A), Loc),\n-                          Attribute_Name => Name_Range)),\n-                 Reason => CE_Index_Check_Failed));\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                   Make_Not_In (Loc,\n+                     Left_Opnd  =>\n+                       Convert_To (Base_Type (Etype (Sub)),\n+                         Duplicate_Subexpr_Move_Checks (Sub)),\n+                     Right_Opnd =>\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (Etype (A), Loc),\n+                         Attribute_Name => Name_Range)),\n+                Reason => CE_Index_Check_Failed));\n          end if;\n \n       --  General case\n@@ -4831,14 +4843,14 @@ package body Checks is\n                   end if;\n \n                   Insert_Action (N,\n-                     Make_Raise_Constraint_Error (Loc,\n-                       Condition =>\n-                          Make_Not_In (Loc,\n-                            Left_Opnd  =>\n-                              Convert_To (Base_Type (Etype (Sub)),\n-                                Duplicate_Subexpr_Move_Checks (Sub)),\n-                            Right_Opnd => Range_N),\n-                       Reason => CE_Index_Check_Failed));\n+                    Make_Raise_Constraint_Error (Loc,\n+                      Condition =>\n+                         Make_Not_In (Loc,\n+                           Left_Opnd  =>\n+                             Convert_To (Base_Type (Etype (Sub)),\n+                               Duplicate_Subexpr_Move_Checks (Sub)),\n+                           Right_Opnd => Range_N),\n+                      Reason => CE_Index_Check_Failed));\n                end if;\n \n                A_Idx := Next_Index (A_Idx);"}, {"sha": "ae7def7e3bd2781e0de44c1341a0bf990dd5d912", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -5372,6 +5372,13 @@ package body Exp_Attr is\n \n          Validity_Checks_On := False;\n \n+         --  Retrieve the base type. Handle the case where the base type is a\n+         --  private enumeration type.\n+\n+         if Is_Private_Type (Btyp) and then Present (Full_View (Btyp)) then\n+            Btyp := Full_View (Btyp);\n+         end if;\n+\n          --  Floating-point case. This case is handled by the Valid attribute\n          --  code in the floating-point attribute run-time library.\n \n@@ -5472,15 +5479,14 @@ package body Exp_Attr is\n          --       (X >= type(X)'First and then type(X)'Last <= X)\n \n          elsif Is_Enumeration_Type (Ptyp)\n-           and then Present (Enum_Pos_To_Rep (Base_Type (Ptyp)))\n+           and then Present (Enum_Pos_To_Rep (Btyp))\n          then\n             Tst :=\n               Make_Op_Ge (Loc,\n                 Left_Opnd =>\n                   Make_Function_Call (Loc,\n                     Name =>\n-                      New_Reference_To\n-                        (TSS (Base_Type (Ptyp), TSS_Rep_To_Pos), Loc),\n+                      New_Reference_To (TSS (Btyp, TSS_Rep_To_Pos), Loc),\n                     Parameter_Associations => New_List (\n                       Pref,\n                       New_Occurrence_Of (Standard_False, Loc))),"}, {"sha": "c8a3094c3209d2171c85330c5513fbcadd33859c", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -3188,7 +3188,7 @@ package body Exp_Ch9 is\n \n                   Rewrite (Stmt,\n                     Make_Implicit_If_Statement (N,\n-                      Condition =>\n+                      Condition       =>\n                         Make_Function_Call (Loc,\n                           Name                   =>\n                             New_Reference_To (Try_Write, Loc),\n@@ -3379,9 +3379,9 @@ package body Exp_Ch9 is\n               Make_Object_Renaming_Declaration (Loc,\n                 Defining_Identifier =>\n                   Defining_Identifier (Comp_Decl),\n-                Subtype_Mark      =>\n+                Subtype_Mark        =>\n                   New_Occurrence_Of (Comp_Type, Loc),\n-                Name              =>\n+                Name                =>\n                   New_Reference_To (Desired_Comp, Loc)));\n \n             --  Wrap any return or raise statements in Stmts in same the manner"}, {"sha": "ed046f4582086f3077872b5c107b5f118ddc01ae", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -4222,13 +4222,21 @@ package body Sem_Ch4 is\n \n                --  Duplicate the call. This is required to avoid problems with\n                --  the tree transformations performed by Try_Object_Operation.\n+               --  Set properly the parent of the copied call, because it is\n+               --  about to be reanalyzed.\n \n-              and then\n-                Try_Object_Operation\n-                  (N            => Sinfo.Name (New_Copy_Tree (Parent (N))),\n-                   CW_Test_Only => True)\n             then\n-               return;\n+               declare\n+                  Par : constant Node_Id := New_Copy_Tree (Parent (N));\n+\n+               begin\n+                  Set_Parent (Par, Parent (Parent (N)));\n+                  if Try_Object_Operation\n+                    (Sinfo.Name (Par), CW_Test_Only => True)\n+                  then\n+                     return;\n+                  end if;\n+               end;\n             end if;\n          end if;\n "}, {"sha": "da0e9011379b8d9668c57894ec3ee4f8fb0805b2", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -2633,14 +2633,14 @@ package body Sem_Ch5 is\n       --  types the actual subtype of the components will only be determined\n       --  when the cursor declaration is analyzed.\n \n-      --  If the expander is not active, then we want to analyze the loop body\n-      --  now even in the Ada 2012 iterator case, since the rewriting will not\n-      --  be done. Insert the loop variable in the current scope, if not done\n-      --  when analysing the iteration scheme.\n+      --  If the expander is not active, or in Alfa mode, then we want to\n+      --  analyze the loop body now even in the Ada 2012 iterator case, since\n+      --  the rewriting will not be done. Insert the loop variable in the\n+      --  current scope, if not done when analysing the iteration scheme.\n \n       if No (Iter)\n         or else No (Iterator_Specification (Iter))\n-        or else not Expander_Active\n+        or else not Full_Expander_Active\n       then\n          if Present (Iter)\n            and then Present (Iterator_Specification (Iter))"}, {"sha": "1420ba87bc0cff6fb4ed0ad5cfd7d8ef3f9c6674", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 224, "deletions": 51, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -68,24 +69,30 @@ package body Sem_Ch9 is\n \n    function Allows_Lock_Free_Implementation\n      (N        : Node_Id;\n-      Complain : Boolean := False) return Boolean;\n+      Lock_Free_Given : Boolean := False) return Boolean;\n    --  This routine returns True iff N satisfies the following list of lock-\n    --  free restrictions for protected type declaration and protected body:\n    --\n    --    1) Protected type declaration\n    --         May not contain entries\n-   --         Component types must support atomic compare and exchange\n+   --         Protected subprogram declarations may not have non-elementary\n+   --           parameters.\n    --\n    --    2) Protected Body\n    --         Each protected subprogram body within N must satisfy:\n    --            May reference only one protected component\n    --            May not reference non-constant entities outside the protected\n    --              subprogram scope.\n-   --            May not reference non-elementary out parameters\n-   --            May not contain loop statements or procedure calls\n+   --            May not contain address representation items, allocators and\n+   --              quantified expressions.\n+   --            May not contain delay, goto, loop and procedure call\n+   --              statements.\n+   --            May not contain exported and imported entities\n+   --            May not dereference access values\n    --            Function calls and attribute references must be static\n    --\n-   --  If Complain is True, an error message is issued when False is returned\n+   --  If Lock_Free_Given is True, an error message is issued when False is\n+   --  returned.\n \n    procedure Check_Max_Entries (D : Node_Id; R : All_Parameter_Restrictions);\n    --  Given either a protected definition or a task definition in D, check\n@@ -115,22 +122,32 @@ package body Sem_Ch9 is\n    -------------------------------------\n \n    function Allows_Lock_Free_Implementation\n-     (N        : Node_Id;\n-      Complain : Boolean := False) return Boolean\n+     (N               : Node_Id;\n+      Lock_Free_Given : Boolean := False) return Boolean\n    is\n+      Errors_Count : Nat;\n+      --  Errors_Count is a count of errors detected by the compiler so far\n+      --  when Lock_Free_Given is True.\n+\n    begin\n       pragma Assert (Nkind_In (N,\n                                N_Protected_Type_Declaration,\n                                N_Protected_Body));\n \n       --  The lock-free implementation is currently enabled through a debug\n-      --  flag. When Complain is True, an aspect Lock_Free forces the lock-free\n-      --  implementation. In that case, the debug flag is not needed.\n+      --  flag. When Lock_Free_Given is True, an aspect Lock_Free forces the\n+      --  lock-free implementation. In that case, the debug flag is not needed.\n \n-      if not Complain and then not Debug_Flag_9 then\n+      if not Lock_Free_Given and then not Debug_Flag_9 then\n          return False;\n       end if;\n \n+      --  Get the number of errors detected by the compiler so far\n+\n+      if Lock_Free_Given then\n+         Errors_Count := Serious_Errors_Detected;\n+      end if;\n+\n       --  Protected type declaration case\n \n       if Nkind (N) = N_Protected_Type_Declaration then\n@@ -150,14 +167,14 @@ package body Sem_Ch9 is\n                --  restrictions.\n \n                if Nkind (Decl) = N_Entry_Declaration then\n-                  if Complain then\n+                  if Lock_Free_Given then\n                      Error_Msg_N\n                        (\"entry not allowed when Lock_Free given\", Decl);\n+                  else\n+                     return False;\n                   end if;\n \n-                  return False;\n-\n-               --  Non-elementary out parameters in protected procedure are not\n+               --  Non-elementary parameters in protected procedure are not\n                --  allowed by the lock-free restrictions.\n \n                elsif Nkind (Decl) = N_Subprogram_Declaration\n@@ -176,18 +193,17 @@ package body Sem_Ch9 is\n                   begin\n                      Par := First (Par_Specs);\n                      while Present (Par) loop\n-                        if Out_Present (Par)\n-                          and then not Is_Elementary_Type\n-                                         (Etype (Parameter_Type (Par)))\n+                        if not Is_Elementary_Type\n+                                 (Etype (Defining_Identifier (Par)))\n                         then\n-                           if Complain then\n+                           if Lock_Free_Given then\n                               Error_Msg_NE\n-                                (\"non-elementary out parameter& not allowed \"\n+                                (\"non-elementary parameter& not allowed \"\n                                  & \"when Lock_Free given\",\n                                  Par, Defining_Identifier (Par));\n+                           else\n+                              return False;\n                            end if;\n-\n-                           return False;\n                         end if;\n \n                         Next (Par);\n@@ -240,6 +256,10 @@ package body Sem_Ch9 is\n                Comp : Entity_Id := Empty;\n                --  Track the current component which the body references\n \n+               Errors_Count : Nat;\n+               --  Errors_Count is a count of errors detected by the compiler\n+               --  so far when Lock_Free_Given is True.\n+\n                function Check_Node (N : Node_Id) return Traverse_Result;\n                --  Check that node N meets the lock free restrictions\n \n@@ -248,6 +268,7 @@ package body Sem_Ch9 is\n                ----------------\n \n                function Check_Node (N : Node_Id) return Traverse_Result is\n+                  Kind : constant Node_Kind := Nkind (N);\n \n                   --  The following function belongs in sem_eval ???\n \n@@ -310,51 +331,123 @@ package body Sem_Ch9 is\n \n                begin\n                   if Is_Procedure then\n-                     --  Attribute references must be static or denote a static\n-                     --  function.\n+                     --  Allocators restricted\n+\n+                     if Kind = N_Allocator then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"allocator not allowed\", N);\n+                           return Skip;\n+                        end if;\n+\n+                        return Abandon;\n+\n+                     --  Aspects Address, Export and Import restricted\n+\n+                     elsif Kind = N_Aspect_Specification then\n+                        declare\n+                           Asp_Name : constant Name_Id   :=\n+                                        Chars (Identifier (N));\n+                           Asp_Id   : constant Aspect_Id :=\n+                                        Get_Aspect_Id (Asp_Name);\n+\n+                        begin\n+                           if Asp_Id = Aspect_Address\n+                             or else Asp_Id = Aspect_Export\n+                             or else Asp_Id = Aspect_Import\n+                           then\n+                              Error_Msg_Name_1 := Asp_Name;\n+\n+                              if Lock_Free_Given then\n+                                 Error_Msg_N (\"aspect% not allowed\", N);\n+                                 return Skip;\n+                              end if;\n+\n+                              return Abandon;\n+                           end if;\n+                        end;\n+\n+                     --  Address attribute definition clause restricted\n+\n+                     elsif Kind = N_Attribute_Definition_Clause\n+                       and then Get_Attribute_Id (Chars (N)) =\n+                                  Attribute_Address\n+                     then\n+                        Error_Msg_Name_1 := Chars (N);\n+\n+                        if Lock_Free_Given then\n+                           if From_Aspect_Specification (N) then\n+                              Error_Msg_N (\"aspect% not allowed\", N);\n+                           else\n+                              Error_Msg_N (\"% clause not allowed\", N);\n+                           end if;\n+\n+                           return Skip;\n+                        end if;\n+\n+                        return Abandon;\n \n-                     if Nkind (N) = N_Attribute_Reference\n+                     --  Non-static Attribute references that don't denote a\n+                     --  static function restricted.\n+\n+                     elsif Kind = N_Attribute_Reference\n                        and then not Is_Static_Expression (N)\n                        and then not Is_Static_Function (N)\n                      then\n-                        if Complain then\n+                        if Lock_Free_Given then\n                            Error_Msg_N\n                              (\"non-static attribute reference not allowed\", N);\n+                           return Skip;\n                         end if;\n \n                         return Abandon;\n \n-                     --  Function calls must be static\n+                     --  Delay statements restricted\n \n-                     elsif Nkind (N) = N_Function_Call\n-                       and then not Is_Static_Expression (N)\n-                     then\n-                        if Complain then\n-                           Error_Msg_N (\"non-static function call not allowed\",\n-                                        N);\n+                     elsif Kind in N_Delay_Statement then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"delay not allowed\", N);\n+                           return Skip;\n                         end if;\n \n                         return Abandon;\n \n-                     --  Loop statements and procedure calls are prohibited\n+                     --  Explicit dereferences restricted (i.e. dereferences of\n+                     --  access values).\n \n-                     elsif Nkind (N) = N_Loop_Statement then\n-                        if Complain then\n-                           Error_Msg_N (\"loop not allowed\", N);\n+                     elsif Kind = N_Explicit_Dereference then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"explicit dereference not allowed\", N);\n+                           return Skip;\n                         end if;\n \n                         return Abandon;\n \n-                     elsif Nkind (N) = N_Procedure_Call_Statement then\n-                        if Complain then\n-                           Error_Msg_N (\"procedure call not allowed\", N);\n+                     --  Non-static function calls restricted\n+\n+                     elsif Kind = N_Function_Call\n+                       and then not Is_Static_Expression (N)\n+                     then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"non-static function call not allowed\",\n+                                        N);\n+                           return Skip;\n+                        end if;\n+\n+                        return Abandon;\n+\n+                     --  Goto statements restricted\n+\n+                     elsif Kind = N_Goto_Statement then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"goto statement not allowed\", N);\n+                           return Skip;\n                         end if;\n \n                         return Abandon;\n \n                      --  References\n \n-                     elsif Nkind (N) = N_Identifier\n+                     elsif Kind = N_Identifier\n                        and then Present (Entity (N))\n                      then\n                         declare\n@@ -372,23 +465,83 @@ package body Sem_Ch9 is\n                              and then not Scope_Within_Or_Same (Scope (Id),\n                                             Protected_Body_Subprogram (Sub_Id))\n                            then\n-                              if Complain then\n+                              if Lock_Free_Given then\n                                  Error_Msg_NE\n                                    (\"reference to global variable& not \" &\n                                     \"allowed\", N, Id);\n+                                 return Skip;\n+                              end if;\n+\n+                              return Abandon;\n+                           end if;\n+                        end;\n+\n+                     --  Loop statements restricted\n+\n+                     elsif Kind = N_Loop_Statement then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"loop not allowed\", N);\n+                           return Skip;\n+                        end if;\n+\n+                        return Abandon;\n+\n+                     --  Pragmas Export and Import restricted\n+\n+                     elsif Kind = N_Pragma then\n+                        declare\n+                           Prag_Name : constant Name_Id   := Pragma_Name (N);\n+                           Prag_Id   : constant Pragma_Id :=\n+                                         Get_Pragma_Id (Prag_Name);\n+\n+                        begin\n+                           if Prag_Id = Pragma_Export\n+                             or else Prag_Id = Pragma_Import\n+                           then\n+                              Error_Msg_Name_1 := Prag_Name;\n+\n+                              if Lock_Free_Given then\n+                                 if From_Aspect_Specification (N) then\n+                                    Error_Msg_N (\"aspect% not allowed\", N);\n+                                 else\n+                                    Error_Msg_N (\"pragma% not allowed\", N);\n+                                 end if;\n+\n+                                 return Skip;\n                               end if;\n \n                               return Abandon;\n                            end if;\n                         end;\n+\n+                     --  Procedure call statements restricted\n+\n+                     elsif Kind = N_Procedure_Call_Statement then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"procedure call not allowed\", N);\n+                           return Skip;\n+                        end if;\n+\n+                        return Abandon;\n+\n+                     --  Quantified expression restricted\n+\n+                     elsif Kind = N_Quantified_Expression then\n+                        if Lock_Free_Given then\n+                           Error_Msg_N (\"quantified expression not allowed\",\n+                                        N);\n+                           return Skip;\n+                        end if;\n+\n+                        return Abandon;\n                      end if;\n                   end if;\n \n                   --  A protected subprogram (function or procedure) may\n                   --  reference only one component of the protected type, plus\n                   --  the type of the component must support atomic operation.\n \n-                  if Nkind (N) = N_Identifier\n+                  if Kind = N_Identifier\n                     and then Present (Entity (N))\n                   then\n                      declare\n@@ -441,11 +594,12 @@ package body Sem_Ch9 is\n                                  when 8 | 16 | 32 | 64 =>\n                                     null;\n                                  when others           =>\n-                                    if Complain then\n+                                    if Lock_Free_Given then\n                                        Error_Msg_NE\n                                          (\"type of& must support atomic \" &\n                                           \"operations\",\n                                           N, Comp_Id);\n+                                       return Skip;\n                                     end if;\n \n                                     return Abandon;\n@@ -458,10 +612,11 @@ package body Sem_Ch9 is\n                                  Comp := Comp_Id;\n \n                               elsif Comp /= Comp_Id then\n-                                 if Complain then\n+                                 if Lock_Free_Given then\n                                     Error_Msg_N\n                                       (\"only one protected component allowed\",\n                                        N);\n+                                    return Skip;\n                                  end if;\n \n                                  return Abandon;\n@@ -479,7 +634,16 @@ package body Sem_Ch9 is\n             --  Start of processing for Satisfies_Lock_Free_Requirements\n \n             begin\n-               if Check_All_Nodes (Sub_Body) = OK then\n+               --  Get the number of errors detected by the compiler so far\n+\n+               if Lock_Free_Given then\n+                  Errors_Count := Serious_Errors_Detected;\n+               end if;\n+\n+               if Check_All_Nodes (Sub_Body) = OK\n+                 and then (not Lock_Free_Given\n+                            or else Errors_Count = Serious_Errors_Detected)\n+               then\n \n                   --  Establish a relation between the subprogram body and the\n                   --  unique protected component it references.\n@@ -503,19 +667,28 @@ package body Sem_Ch9 is\n                if Nkind (Decl) = N_Subprogram_Body\n                  and then not Satisfies_Lock_Free_Requirements (Decl)\n                then\n-                  if Complain then\n+                  if Lock_Free_Given then\n                      Error_Msg_N\n-                       (\"body not allowed when Lock_Free given\", Decl);\n+                       (\"illegal body when Lock_Free given\", Decl);\n+                  else\n+                     return False;\n                   end if;\n-\n-                  return False;\n                end if;\n \n                Next (Decl);\n             end loop;\n          end Protected_Body_Case;\n       end if;\n \n+      --  When Lock_Free is given, check if no error has been detected during\n+      --  the process.\n+\n+      if Lock_Free_Given\n+        and then Errors_Count /= Serious_Errors_Detected\n+      then\n+         return False;\n+      end if;\n+\n       return True;\n    end Allows_Lock_Free_Implementation;\n \n@@ -1611,7 +1784,7 @@ package body Sem_Ch9 is\n       --  otherwise Allows_Lock_Free_Implementation issues an error message.\n \n       if Uses_Lock_Free (Spec_Id) then\n-         if not Allows_Lock_Free_Implementation (N, Complain => True) then\n+         if not Allows_Lock_Free_Implementation (N, True) then\n             return;\n          end if;\n \n@@ -1886,7 +2059,7 @@ package body Sem_Ch9 is\n             end if;\n          end;\n \n-         if not Allows_Lock_Free_Implementation (N, Complain => True) then\n+         if not Allows_Lock_Free_Implementation (N, True) then\n             return;\n          end if;\n       end if;"}, {"sha": "65c64f2ec6bcbf01853013e62648391d306abf1f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -7071,15 +7071,18 @@ package body Sem_Res is\n       if Is_Overloaded (P) then\n \n          --  Use the context type to select the prefix that has the correct\n-         --  designated type.\n+         --  designated type. Keep the first match, which will be the inner-\n+         --  most.\n \n          Get_First_Interp (P, I, It);\n \n          while Present (It.Typ) loop\n             if Is_Access_Type (It.Typ)\n               and then Covers (Typ, Designated_Type (It.Typ))\n             then\n-               P_Typ := It.Typ;\n+               if No (P_Typ) then\n+                  P_Typ := It.Typ;\n+               end if;\n \n             --  Remove access types that do not match, but preserve access\n             --  to subprogram interpretations, in case a further dereference"}, {"sha": "8675d54d35a1f77c20a4b10e7afea61e2624c5a4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a44b14423c7751db39957227377d5909fde72e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d7a44b14423c7751db39957227377d5909fde72e", "patch": "@@ -4500,7 +4500,8 @@ package body Sem_Util is\n       Pos : Uint;\n       Loc : Source_Ptr) return Node_Id\n    is\n-      Lit : Node_Id;\n+      Btyp : Entity_Id := Base_Type (T);\n+      Lit  : Node_Id;\n \n    begin\n       --  In the case where the literal is of type Character, Wide_Character\n@@ -4522,7 +4523,11 @@ package body Sem_Util is\n       --\n \n       else\n-         Lit := First_Literal (Base_Type (T));\n+         if Is_Private_Type (Btyp) and then Present (Full_View (Btyp)) then\n+            Btyp := Full_View (Btyp);\n+         end if;\n+\n+         Lit := First_Literal (Btyp);\n          for J in 1 .. UI_To_Int (Pos) loop\n             Next_Literal (Lit);\n          end loop;"}]}