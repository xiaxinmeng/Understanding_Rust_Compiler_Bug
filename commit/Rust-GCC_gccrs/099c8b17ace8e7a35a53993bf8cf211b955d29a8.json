{"sha": "099c8b17ace8e7a35a53993bf8cf211b955d29a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk5YzhiMTdhY2U4ZTdhMzVhNTM5OTNiZjhjZjIxMWI5NTVkMjlhOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-06-06T01:57:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-06-06T01:57:49Z"}, "message": "dwarf2.h (DW_EH_PE_aligned): New.\n\n        * dwarf2.h (DW_EH_PE_aligned): New.\n        * dwarf2asm.c (eh_data_format_name): Name it.\n        (dw2_asm_output_encoded_addr_rtx): Align for it.\n        * dwarf2out.c (output_call_frame_info): Handle it for personality\n        routine and LSDA pointers.\n\n        * unwind-pe.h (DW_EH_PE_aligned): New.\n        (base_of_encoded_value): Handle it.\n        (read_encoded_value_with_base): Likewise.\n        * unwind-dw2-fde.c (base_from_object): Likewise.\n        (get_cie_encoding): Likewise.\n\n        * config/alpha/elf.h: Remove ecoff commentary.\n        * config/alpha/osf.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n\nFrom-SVN: r42926", "tree": {"sha": "7d58db2a4f6ec00eb20b149b79bc6fbe2e8c5a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d58db2a4f6ec00eb20b149b79bc6fbe2e8c5a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/099c8b17ace8e7a35a53993bf8cf211b955d29a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099c8b17ace8e7a35a53993bf8cf211b955d29a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/099c8b17ace8e7a35a53993bf8cf211b955d29a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099c8b17ace8e7a35a53993bf8cf211b955d29a8/comments", "author": null, "committer": null, "parents": [{"sha": "c51f6c6bd5a4177ee5dcb0afbfe9b27e4fda6478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c51f6c6bd5a4177ee5dcb0afbfe9b27e4fda6478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c51f6c6bd5a4177ee5dcb0afbfe9b27e4fda6478"}], "stats": {"total": 262, "additions": 179, "deletions": 83}, "files": [{"sha": "0dc127dad57c70fda60a30c60e44a8496f4965fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -1,3 +1,20 @@\n+2001-06-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2.h (DW_EH_PE_aligned): New.\n+\t* dwarf2asm.c (eh_data_format_name): Name it.\n+\t(dw2_asm_output_encoded_addr_rtx): Align for it.\n+\t* dwarf2out.c (output_call_frame_info): Handle it for personality\n+\troutine and LSDA pointers.\n+\n+\t* unwind-pe.h (DW_EH_PE_aligned): New.\n+\t(base_of_encoded_value): Handle it.\n+\t(read_encoded_value_with_base): Likewise.\n+\t* unwind-dw2-fde.c (base_from_object): Likewise.\n+\t(get_cie_encoding): Likewise.\n+\n+\t* config/alpha/elf.h: Remove ecoff commentary.\n+\t* config/alpha/osf.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n+\n 2001-06-05  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config.gcc, config/i386/bsd386.h:  Do not directly include\n@@ -327,7 +344,7 @@ Sat Jun  2 06:53:50 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* README: Update references to installation instructions.\n \n 2001-06-01  Laurent Guerby  <guerby@acm.org>\n-            Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n+\t    Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* doc/install.texi: Define srcdir when sources come from CVS.\n \tSignificantly improve markup.  Wrap overly long lines\n@@ -481,7 +498,7 @@ Thu May 31 19:09:53 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-05-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n-        * fixinc/fixtests.c: Declare entries in ENV_TABLE.\n+\t* fixinc/fixtests.c: Declare entries in ENV_TABLE.\n \n 2001-05-27  Bruce Korb  <bkorb@gnu.org>\n "}, {"sha": "78642e678dfda3fd0ee44ad11c435eea1cbe193c", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -686,8 +686,6 @@ void FN ()\t\t\t\t\t\\\n #undef UNALIGNED_INT_ASM_OP\n #undef UNALIGNED_DOUBLE_INT_ASM_OP\n \n-/* ??? This should be possible for ECOFF as well, since the relocations\n-   exist.  But the assembler doesn't seem to create them.  */\n /* Select a format to encode pointers in exception handling data.  CODE\n    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is\n    true if the symbol may be affected by dynamic relocations."}, {"sha": "b6e80d02bbf2ad290ff03ba2fd5ce192970915b4", "filename": "gcc/config/alpha/osf.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fconfig%2Falpha%2Fosf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fconfig%2Falpha%2Fosf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf.h?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -153,3 +153,17 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n #define HAS_INIT_SECTION\n #define LD_INIT_SWITCH \"-init\"\n #define LD_FINI_SWITCH \"-fini\"\n+\n+/* Select a format to encode pointers in exception handling data.  CODE\n+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is\n+   true if the symbol may be affected by dynamic relocations.\n+   \n+   We really ought to be using the SREL32 relocations that ECOFF has,\n+   but no version of the native assembler supports creating such things,\n+   and Compaq has no plans to rectify this.  Worse, the dynamic loader\n+   cannot handle unaligned relocations, so we have to make sure that\n+   things get padded appropriately.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)\t\t\t     \\\n+  (TARGET_GAS\t\t\t\t\t\t\t\t     \\\n+   ? (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4) \\\n+   : DW_EH_PE_aligned)"}, {"sha": "800bda2dc01b2f5329be37b02211e48f14311399", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -580,5 +580,6 @@ enum dwarf_macinfo_record_type\n #define DW_EH_PE_textrel\t0x20\n #define DW_EH_PE_datarel\t0x30\n #define DW_EH_PE_funcrel\t0x40\n+#define DW_EH_PE_aligned\t0x50\n \n #define DW_EH_PE_indirect\t0x80"}, {"sha": "15ae68dd21284f5c4c786d05384df649036b8754", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -490,6 +490,7 @@ eh_data_format_name (format)\n \n   S(DW_EH_PE_absptr, \"absolute\")\n   S(DW_EH_PE_omit, \"omit\")\n+  S(DW_EH_PE_aligned, \"aligned absolute\")\n \n   S(DW_EH_PE_uleb128, \"uleb128\")\n   S(DW_EH_PE_udata2, \"udata2\")\n@@ -947,6 +948,12 @@ dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n \n   size = size_of_encoded_value (encoding);\n \n+  if (encoding == DW_EH_PE_aligned)\n+    {\n+      assemble_align (POINTER_SIZE);\n+      encoding = DW_EH_PE_absptr;\n+    }\n+\n   /* NULL is _always_ represented as a plain zero.  */\n   if (addr == const0_rtx)\n     assemble_integer (addr, size, 1);"}, {"sha": "5d561840e6a1255eab896c7a95f16b46aa6ca1d7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -1820,6 +1820,28 @@ output_call_frame_info (for_eh)\n \t  augmentation[0] = 'z';\n           *p = '\\0';\n \t}\n+\n+      /* Ug.  Some platforms can't do unaligned dynamic relocations at all.  */\n+      if (eh_personality_libfunc && per_encoding == DW_EH_PE_aligned)\n+\t{\n+\t  int offset = (  4\t\t/* Length */\n+\t\t\t+ 4\t\t/* CIE Id */\n+\t\t\t+ 1\t\t/* CIE version */\n+\t\t\t+ strlen (augmentation) + 1\t/* Augmentation */\n+\t\t\t+ size_of_uleb128 (1)\t\t/* Code alignment */\n+\t\t\t+ size_of_sleb128 (DWARF_CIE_DATA_ALIGNMENT)\n+\t\t\t+ 1\t\t/* RA column */\n+\t\t\t+ 1\t\t/* Augmentation size */\n+\t\t\t+ 1\t\t/* Personality encoding */ );\n+\t  int pad = -offset & (PTR_SIZE - 1);\n+\n+\t  augmentation_size += pad;\n+\n+\t  /* Augmentations should be small, so there's scarce need to\n+\t     iterate for a solution.  Die if we exceed one uleb128 byte.  */\n+\t  if (size_of_uleb128 (augmentation_size) != 1)\n+\t    abort ();\n+\t}\n     }\n   dw2_asm_output_nstring (augmentation, -1, \"CIE Augmentation\");\n \n@@ -1909,8 +1931,22 @@ output_call_frame_info (for_eh)\n \t{\n \t  if (any_lsda_needed)\n \t    {\n-\t      dw2_asm_output_data_uleb128 (\n-\t\tsize_of_encoded_value (lsda_encoding), \"Augmentation size\");\n+\t      int size = size_of_encoded_value (lsda_encoding);\n+\n+\t      if (lsda_encoding == DW_EH_PE_aligned)\n+\t\t{\n+\t\t  int offset = (  4\t\t/* Length */\n+\t\t\t\t+ 4\t\t/* CIE offset */\n+\t\t\t\t+ 2 * size_of_encoded_value (fde_encoding)\n+\t\t\t\t+ 1\t\t/* Augmentation size */ );\n+\t\t  int pad = -offset & (PTR_SIZE - 1);\n+\n+\t\t  size += pad;\n+\t\t  if (size_of_uleb128 (size) != 1)\n+\t\t    abort ();\n+\t\t}\n+\n+\t      dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n \n \t      if (fde->uses_eh_lsda)\n \t        {\n@@ -1921,8 +1957,12 @@ output_call_frame_info (for_eh)\n \t\t \t\"Language Specific Data Area\");\n \t        }\n \t      else\n-\t        dw2_asm_output_data (size_of_encoded_value (lsda_encoding),\n-\t\t\t\t     0, \"Language Specific Data Area (none)\");\n+\t\t{\n+\t\t  if (lsda_encoding == DW_EH_PE_aligned)\n+\t\t    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));\n+\t\t  dw2_asm_output_data (size_of_encoded_value (lsda_encoding),\n+\t\t\t\t       0, \"Language Specific Data Area (none)\");\n+\t\t}\n \t    }\n \t  else\n \t    dw2_asm_output_data_uleb128 (0, \"Augmentation size\");"}, {"sha": "6da2c7384fd3169ceb6e28de46fa36d8f6342de3", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -233,6 +233,7 @@ base_from_object (unsigned char encoding, struct object *ob)\n     {\n     case DW_EH_PE_absptr:\n     case DW_EH_PE_pcrel:\n+    case DW_EH_PE_aligned:\n       return 0;\n \n     case DW_EH_PE_textrel:\n@@ -270,7 +271,12 @@ get_cie_encoding (struct dwarf_cie *cie)\n \treturn *p;\n       /* Personality encoding and pointer.  */\n       else if (*aug == 'P')\n-\tp = read_encoded_value_with_base (*p & 0xF, 0, p + 1, &dummy);\n+\t{\n+\t  /* ??? Avoid dereferencing indirect pointers, since we're\n+\t     faking the base address.  Gotta keep DW_EH_PE_aligned\n+\t     intact, however.  */\n+\t  p = read_encoded_value_with_base (*p & 0x7F, 0, p + 1, &dummy);\n+\t}\n       /* LSDA encoding.  */\n       else if (*aug == 'L')\n \tp++;"}, {"sha": "e952b7f83e453f8c4bb8a30d42f81fe6c16beea8", "filename": "gcc/unwind-pe.h", "status": "modified", "additions": 87, "deletions": 74, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Funwind-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099c8b17ace8e7a35a53993bf8cf211b955d29a8/gcc%2Funwind-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-pe.h?ref=099c8b17ace8e7a35a53993bf8cf211b955d29a8", "patch": "@@ -40,12 +40,13 @@\n #define DW_EH_PE_textrel        0x20\n #define DW_EH_PE_datarel        0x30\n #define DW_EH_PE_funcrel        0x40\n+#define DW_EH_PE_aligned        0x50\n \n #define DW_EH_PE_indirect\t0x80\n \f\n \n /* Given an encoding, return the number of bytes the format occupies.\n-   This is only defined for fixed-size encodings, and so does not \n+   This is only defined for fixed-size encodings, and so does not\n    include leb128.  */\n \n static unsigned int\n@@ -69,7 +70,7 @@ size_of_encoded_value (unsigned char encoding)\n }\n \n /* Given an encoding and an _Unwind_Context, return the base to which\n-   the encoding is relative.  This base may then be passed to \n+   the encoding is relative.  This base may then be passed to\n    read_encoded_value_with_base for use when the _Unwind_Context is\n    not available.  */\n \n@@ -83,6 +84,7 @@ base_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)\n     {\n     case DW_EH_PE_absptr:\n     case DW_EH_PE_pcrel:\n+    case DW_EH_PE_aligned:\n       return 0;\n \n     case DW_EH_PE_textrel:\n@@ -117,83 +119,94 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n   union unaligned *u = (union unaligned *) p;\n   _Unwind_Ptr result;\n \n-  switch (encoding & 0x0f)\n+  if (encoding == DW_EH_PE_aligned)\n     {\n-    case DW_EH_PE_absptr:\n-      result = (_Unwind_Ptr) u->ptr;\n-      p += sizeof (void *);\n-      break;\n-\n-    case DW_EH_PE_uleb128:\n-      {\n-\tunsigned int shift = 0;\n-\tunsigned char byte;\n-\n-\tresult = 0;\n-\tdo\n+      _Unwind_Ptr a = (_Unwind_Ptr)p;\n+      a = (a + sizeof (void *) - 1) & - sizeof(void *);\n+      result = *(_Unwind_Ptr *) a;\n+      p = (const unsigned char *)(a + sizeof (void *));\n+    }\n+  else\n+    {\n+      switch (encoding & 0x0f)\n+\t{\n+\tcase DW_EH_PE_absptr:\n+\t  result = (_Unwind_Ptr) u->ptr;\n+\t  p += sizeof (void *);\n+\t  break;\n+\n+\tcase DW_EH_PE_uleb128:\n \t  {\n-\t    byte = *p++;\n-\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n-\t    shift += 7;\n+\t    unsigned int shift = 0;\n+\t    unsigned char byte;\n+\n+\t    result = 0;\n+\t    do\n+\t      {\n+\t\tbyte = *p++;\n+\t\tresult |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t\tshift += 7;\n+\t      }\n+\t    while (byte & 0x80);\n \t  }\n-\twhile (byte & 0x80);\n-      }\n-      break;\n-\n-    case DW_EH_PE_sleb128:\n-      {\n-\tunsigned int shift = 0;\n-\tunsigned char byte;\n+\t  break;\n \n-\tresult = 0;\n-\tdo\n+\tcase DW_EH_PE_sleb128:\n \t  {\n-\t    byte = *p++;\n-\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n-\t    shift += 7;\n+\t    unsigned int shift = 0;\n+\t    unsigned char byte;\n+\n+\t    result = 0;\n+\t    do\n+\t      {\n+\t\tbyte = *p++;\n+\t\tresult |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t\tshift += 7;\n+\t      }\n+\t    while (byte & 0x80);\n+\n+\t    if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n+\t      result |= -(1L << shift);\n \t  }\n-\twhile (byte & 0x80);\n-\n-\tif (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n-\t  result |= -(1L << shift);\n-      }\n-      break;\n-\n-    case DW_EH_PE_udata2:\n-      result = u->u2;\n-      p += 2;\n-      break;\n-    case DW_EH_PE_udata4:\n-      result = u->u4;\n-      p += 4;\n-      break;\n-    case DW_EH_PE_udata8:\n-      result = u->u8;\n-      p += 8;\n-      break;\n-\n-    case DW_EH_PE_sdata2:\n-      result = u->s2;\n-      p += 2;\n-      break;\n-    case DW_EH_PE_sdata4:\n-      result = u->s4;\n-      p += 4;\n-      break;\n-    case DW_EH_PE_sdata8:\n-      result = u->s8;\n-      p += 8;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  if (result != 0)\n-    {\n-      result += ((encoding & 0x70) == DW_EH_PE_pcrel ? (_Unwind_Ptr)u : base);\n-      if (encoding & DW_EH_PE_indirect)\n-\tresult = *(_Unwind_Ptr *)result;\n+\t  break;\n+\n+\tcase DW_EH_PE_udata2:\n+\t  result = u->u2;\n+\t  p += 2;\n+\t  break;\n+\tcase DW_EH_PE_udata4:\n+\t  result = u->u4;\n+\t  p += 4;\n+\t  break;\n+\tcase DW_EH_PE_udata8:\n+\t  result = u->u8;\n+\t  p += 8;\n+\t  break;\n+\n+\tcase DW_EH_PE_sdata2:\n+\t  result = u->s2;\n+\t  p += 2;\n+\t  break;\n+\tcase DW_EH_PE_sdata4:\n+\t  result = u->s4;\n+\t  p += 4;\n+\t  break;\n+\tcase DW_EH_PE_sdata8:\n+\t  result = u->s8;\n+\t  p += 8;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      if (result != 0)\n+\t{\n+\t  result += ((encoding & 0x70) == DW_EH_PE_pcrel\n+\t\t     ? (_Unwind_Ptr)u : base);\n+\t  if (encoding & DW_EH_PE_indirect)\n+\t    result = *(_Unwind_Ptr *)result;\n+\t}\n     }\n \n   *val = result;\n@@ -207,7 +220,7 @@ static inline const unsigned char *\n read_encoded_value (struct _Unwind_Context *context, unsigned char encoding,\n \t\t    const unsigned char *p, _Unwind_Ptr *val)\n {\n-  return read_encoded_value_with_base (encoding, \n+  return read_encoded_value_with_base (encoding,\n \t\tbase_of_encoded_value (encoding, context),\n \t\tp, val);\n }"}]}