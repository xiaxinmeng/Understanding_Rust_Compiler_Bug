{"sha": "f3b331d117a3dd2e406d9746178f8c5644156fb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNiMzMxZDExN2EzZGQyZTQwNmQ5NzQ2MTc4ZjhjNTY0NDE1NmZiMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-09-13T12:42:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-09-13T12:42:04Z"}, "message": "re PR libgomp/58392 (internal compiler error: in expand_GOMP_SIMD_VF, at internal-fn.c (omp simd inside omp parallel))\n\n\tPR tree-optimization/58392\n\t* tree-cfg.c (move_sese_region_to_fn): Rename loop variable\n\tto avoid shadowing of outer loop variable.  If\n\tsaved_cfun->has_simduid_loops or saved_cfun->has_force_vect_loops,\n\treplace_by_duplicate_decl simduid of loops that have it set and\n\tset dest_cfun->has_simduid_loops and/or\n\tdest_cfun->has_force_vect_loops.\n\t* omp-low.c (build_outer_var_ref): Call maybe_lookup_decl_in_outer_ctx\n\tinstead of maybe_lookup_decl.\n\t* tree-inline.c (copy_loops): Change blocks_to_copy argument to id.\n\tUse id->blocks_to_copy instead of blocks_to_copy.  Adjust recursive\n\tcall.  Copy over force_vect and copy and remap simduid.  Set\n\tcfun->has_simduid_loops and/or cfun->has_force_vect_loops.\n\t(copy_cfg_body): Remove blocks_to_copy argument.  Use\n\tid->blocks_to_copy instead of blocks_to_copy.  Adjust copy_loops\n\tcaller.  Don't set cfun->has_simduid_loops and/or\n\tcfun->has_force_vect_loops here.\n\t(copy_body): Remove blocks_to_copy argument.  Adjust copy_cfg_body\n\tcaller.\n\t(expand_call_inline, tree_function_versioning): Adjust copy_body\n\tcallers.\n\nFrom-SVN: r202564", "tree": {"sha": "88eeb2b870640142e2694a00e1bb45b6744ce437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88eeb2b870640142e2694a00e1bb45b6744ce437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3b331d117a3dd2e406d9746178f8c5644156fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b331d117a3dd2e406d9746178f8c5644156fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3b331d117a3dd2e406d9746178f8c5644156fb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b331d117a3dd2e406d9746178f8c5644156fb0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae6d090748df54cb09a9bd7dc5d4d9b4668296f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6d090748df54cb09a9bd7dc5d4d9b4668296f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae6d090748df54cb09a9bd7dc5d4d9b4668296f9"}], "stats": {"total": 92, "additions": 71, "deletions": 21}, "files": [{"sha": "672c49e92dc5927b1769dc004ecff624e9256d4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3b331d117a3dd2e406d9746178f8c5644156fb0", "patch": "@@ -1,3 +1,27 @@\n+2013-09-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/58392\n+\t* tree-cfg.c (move_sese_region_to_fn): Rename loop variable\n+\tto avoid shadowing of outer loop variable.  If\n+\tsaved_cfun->has_simduid_loops or saved_cfun->has_force_vect_loops,\n+\treplace_by_duplicate_decl simduid of loops that have it set and\n+\tset dest_cfun->has_simduid_loops and/or\n+\tdest_cfun->has_force_vect_loops.\n+\t* omp-low.c (build_outer_var_ref): Call maybe_lookup_decl_in_outer_ctx\n+\tinstead of maybe_lookup_decl.\n+\t* tree-inline.c (copy_loops): Change blocks_to_copy argument to id.\n+\tUse id->blocks_to_copy instead of blocks_to_copy.  Adjust recursive\n+\tcall.  Copy over force_vect and copy and remap simduid.  Set\n+\tcfun->has_simduid_loops and/or cfun->has_force_vect_loops.\n+\t(copy_cfg_body): Remove blocks_to_copy argument.  Use\n+\tid->blocks_to_copy instead of blocks_to_copy.  Adjust copy_loops\n+\tcaller.  Don't set cfun->has_simduid_loops and/or\n+\tcfun->has_force_vect_loops here.\n+\t(copy_body): Remove blocks_to_copy argument.  Adjust copy_cfg_body\n+\tcaller.\n+\t(expand_call_inline, tree_function_versioning): Adjust copy_body\n+\tcallers.\n+\n 2013-09-13  Martin Jambor  <mjambor@suse.cz>\n \n \tPR bootstrap/58388"}, {"sha": "1783b46cae568b73719640c5d156d2833118f5d3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=f3b331d117a3dd2e406d9746178f8c5644156fb0", "patch": "@@ -942,7 +942,7 @@ build_outer_var_ref (tree var, omp_context *ctx)\n       if (ctx->outer && is_taskreg_ctx (ctx))\n \tx = lookup_decl (var, ctx->outer);\n       else if (ctx->outer)\n-\tx = maybe_lookup_decl (var, ctx->outer);\n+\tx = maybe_lookup_decl_in_outer_ctx (var, ctx);\n       if (x == NULL_TREE)\n \tx = var;\n     }"}, {"sha": "70930a3592a6ad81296567907f0e96487daec584", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f3b331d117a3dd2e406d9746178f8c5644156fb0", "patch": "@@ -6765,10 +6765,10 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n       if (bb->loop_father->header == bb\n \t  && loop_outer (bb->loop_father) == loop)\n \t{\n-\t  struct loop *loop = bb->loop_father;\n+\t  struct loop *this_loop = bb->loop_father;\n \t  flow_loop_tree_node_remove (bb->loop_father);\n-\t  flow_loop_tree_node_add (get_loop (dest_cfun, 0), loop);\n-\t  fixup_loop_arrays_after_move (saved_cfun, cfun, loop);\n+\t  flow_loop_tree_node_add (get_loop (dest_cfun, 0), this_loop);\n+\t  fixup_loop_arrays_after_move (saved_cfun, cfun, this_loop);\n \t}\n \n       /* Remove loop exits from the outlined region.  */\n@@ -6823,6 +6823,23 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n        outer; outer = loop_outer (outer))\n     outer->num_nodes -= bbs.length ();\n \n+  if (saved_cfun->has_simduid_loops || saved_cfun->has_force_vect_loops)\n+    {\n+      struct loop *aloop;\n+      for (i = 0; vec_safe_iterate (loops->larray, i, &aloop); i++)\n+\tif (aloop != NULL)\n+\t  {\n+\t    if (aloop->simduid)\n+\t      {\n+\t\treplace_by_duplicate_decl (&aloop->simduid, d.vars_map,\n+\t\t\t\t\t   d.to_context);\n+\t\tdest_cfun->has_simduid_loops = true;\n+\t      }\n+\t    if (aloop->force_vect)\n+\t      dest_cfun->has_force_vect_loops = true;\n+\t  }\n+    }\n+\n   /* Rewire BLOCK_SUBBLOCKS of orig_block.  */\n   if (orig_block)\n     {"}, {"sha": "ebfd34c6dcd5aa6a47834a3c748556f31b8720ad", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b331d117a3dd2e406d9746178f8c5644156fb0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f3b331d117a3dd2e406d9746178f8c5644156fb0", "patch": "@@ -2241,14 +2241,14 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n    as siblings of DEST_PARENT.  */\n \n static void\n-copy_loops (bitmap blocks_to_copy,\n+copy_loops (copy_body_data *id,\n \t    struct loop *dest_parent, struct loop *src_parent)\n {\n   struct loop *src_loop = src_parent->inner;\n   while (src_loop)\n     {\n-      if (!blocks_to_copy\n-\t  || bitmap_bit_p (blocks_to_copy, src_loop->header->index))\n+      if (!id->blocks_to_copy\n+\t  || bitmap_bit_p (id->blocks_to_copy, src_loop->header->index))\n \t{\n \t  struct loop *dest_loop = alloc_loop ();\n \n@@ -2272,8 +2272,19 @@ copy_loops (bitmap blocks_to_copy,\n \t  place_new_loop (cfun, dest_loop);\n \t  flow_loop_tree_node_add (dest_parent, dest_loop);\n \n+\t  if (src_loop->simduid)\n+\t    {\n+\t      dest_loop->simduid = remap_decl (src_loop->simduid, id);\n+\t      cfun->has_simduid_loops = true;\n+\t    }\n+\t  if (src_loop->force_vect)\n+\t    {\n+\t      dest_loop->force_vect = true;\n+\t      cfun->has_force_vect_loops = true;\n+\t    }\n+\n \t  /* Recurse.  */\n-\t  copy_loops (blocks_to_copy, dest_loop, src_loop);\n+\t  copy_loops (id, dest_loop, src_loop);\n \t}\n       src_loop = src_loop->next;\n     }\n@@ -2302,7 +2313,7 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n static tree\n copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t       basic_block entry_block_map, basic_block exit_block_map,\n-\t       bitmap blocks_to_copy, basic_block new_entry)\n+\t       basic_block new_entry)\n {\n   tree callee_fndecl = id->src_fn;\n   /* Original cfun for the callee, doesn't change.  */\n@@ -2366,7 +2377,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n-    if (!blocks_to_copy || bitmap_bit_p (blocks_to_copy, bb->index))\n+    if (!id->blocks_to_copy || bitmap_bit_p (id->blocks_to_copy, bb->index))\n       {\n \tbasic_block new_bb = copy_bb (id, bb, frequency_scale, count_scale);\n \tbb->aux = new_bb;\n@@ -2380,8 +2391,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   bool can_make_abormal_goto\n     = id->gimple_call && stmt_can_make_abnormal_goto (id->gimple_call);\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n-    if (!blocks_to_copy\n-        || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n+    if (!id->blocks_to_copy\n+\t|| (bb->index > 0 && bitmap_bit_p (id->blocks_to_copy, bb->index)))\n       need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map,\n \t\t\t\t\t       can_make_abormal_goto);\n \n@@ -2396,12 +2407,10 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   if (loops_for_fn (src_cfun) != NULL\n       && current_loops != NULL)\n     {\n-      copy_loops (blocks_to_copy, entry_block_map->loop_father,\n+      copy_loops (id, entry_block_map->loop_father,\n \t\t  get_loop (src_cfun, 0));\n       /* Defer to cfgcleanup to update loop-father fields of basic-blocks.  */\n       loops_state_set (LOOPS_NEED_FIXUP);\n-      cfun->has_force_vect_loops |= src_cfun->has_force_vect_loops;\n-      cfun->has_simduid_loops |= src_cfun->has_simduid_loops;\n     }\n \n   /* If the loop tree in the source function needed fixup, mark the\n@@ -2411,8 +2420,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   if (gimple_in_ssa_p (cfun))\n     FOR_ALL_BB_FN (bb, cfun_to_copy)\n-      if (!blocks_to_copy\n-\t  || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n+      if (!id->blocks_to_copy\n+\t  || (bb->index > 0 && bitmap_bit_p (id->blocks_to_copy, bb->index)))\n \tcopy_phis_for_bb (bb, id);\n \n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n@@ -2584,15 +2593,15 @@ copy_tree_body (copy_body_data *id)\n static tree\n copy_body (copy_body_data *id, gcov_type count, int frequency_scale,\n \t   basic_block entry_block_map, basic_block exit_block_map,\n-\t   bitmap blocks_to_copy, basic_block new_entry)\n+\t   basic_block new_entry)\n {\n   tree fndecl = id->src_fn;\n   tree body;\n \n   /* If this body has a CFG, walk CFG and copy.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fndecl)));\n   body = copy_cfg_body (id, count, frequency_scale, entry_block_map, exit_block_map,\n-\t\t        blocks_to_copy, new_entry);\n+\t\t\tnew_entry);\n   copy_debug_stmts (id);\n \n   return body;\n@@ -4201,7 +4210,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      duplicate our body before altering anything.  */\n   copy_body (id, bb->count,\n   \t     GCOV_COMPUTE_SCALE (cg_edge->frequency, CGRAPH_FREQ_BASE),\n-\t     bb, return_block, NULL, NULL);\n+\t     bb, return_block, NULL);\n \n   /* Reset the escaped solution.  */\n   if (cfun->gimple_df)\n@@ -5328,7 +5337,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   /* Copy the Function's body.  */\n   copy_body (&id, old_entry_block->count, REG_BR_PROB_BASE,\n-\t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, blocks_to_copy, new_entry);\n+\t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, new_entry);\n \n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (new_decl);"}]}