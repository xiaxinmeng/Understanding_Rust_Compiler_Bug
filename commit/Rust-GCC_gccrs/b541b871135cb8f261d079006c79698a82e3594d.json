{"sha": "b541b871135cb8f261d079006c79698a82e3594d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0MWI4NzExMzVjYjhmMjYxZDA3OTAwNmM3OTY5OGE4MmUzNTk0ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-07-08T22:13:50Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-07-08T22:59:59Z"}, "message": "Make memory copy functions scalar storage order barriers\n\nThis addresses the issue raised about the usage of memory copy functions\nto toggle the scalar storage order.  Recall that you cannot (the compiler\nerrors out) take the address of a scalar which is stored in reverse order,\nbut you can do it for the enclosing aggregate type., which means that you\ncan also pass it to the memory copy functions.  In this case, the optimizer\nmay rewrite the copy into a scalar copy, which is a no-no.\n\ngcc/c-family/ChangeLog:\n\t* c.opt (Wscalar-storage-order): Add explicit variable.\n\ngcc/c/ChangeLog:\n\t* c-typeck.c (convert_for_assignment): If -Wscalar-storage-order is\n\tset, warn for conversion between pointers that point to incompatible\n\tscalar storage orders.\n\ngcc/ChangeLog:\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Do not fold if\n\teither type has reverse scalar storage order.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Do not propagate through\n\ta memory copy if either type has reverse scalar storage order.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/sso-11.c: New test.\n\t* gcc.dg/sso/sso.exp: Pass -Wno-scalar-storage-order.\n\t* gcc.dg/sso/memcpy-1.c: New test.", "tree": {"sha": "ea67db21fcba13c246749cf5e8eed64e59f77442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea67db21fcba13c246749cf5e8eed64e59f77442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b541b871135cb8f261d079006c79698a82e3594d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b541b871135cb8f261d079006c79698a82e3594d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b541b871135cb8f261d079006c79698a82e3594d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b541b871135cb8f261d079006c79698a82e3594d/comments", "author": null, "committer": null, "parents": [{"sha": "a8b522311beef5e02de15427e924752ea02def2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b522311beef5e02de15427e924752ea02def2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b522311beef5e02de15427e924752ea02def2a"}], "stats": {"total": 194, "additions": 175, "deletions": 19}, "files": [{"sha": "21df0c10cfec86a56489aa95ec99da8571c57d9a", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -1072,7 +1072,7 @@ C ObjC C++ ObjC++ Var(warn_return_type) Warning LangEnabledBy(C ObjC C++ ObjC++,\n Warn whenever a function's return type defaults to \\\"int\\\" (C), or about inconsistent return types (C++).\n \n Wscalar-storage-order\n-C ObjC C++ ObjC++ Init(1) Warning\n+C ObjC C++ ObjC++ Var(warn_scalar_storage_order) Init(1) Warning\n Warn on suspicious constructs involving reverse scalar storage order.\n \n Wselector"}, {"sha": "b28c2c5ff620fdb28517dd919a7bd4b13e44c225", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -7151,6 +7151,41 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t  }\n \t}\n \n+      /* See if the pointers point to incompatible scalar storage orders.  */\n+      if (warn_scalar_storage_order\n+\t  && (AGGREGATE_TYPE_P (ttl) && TYPE_REVERSE_STORAGE_ORDER (ttl))\n+\t     != (AGGREGATE_TYPE_P (ttr) && TYPE_REVERSE_STORAGE_ORDER (ttr)))\n+\t{\n+\t  switch (errtype)\n+\t  {\n+\t  case ic_argpass:\n+\t    /* Do not warn for built-in functions, for example memcpy, since we\n+\t       control how they behave and they can be useful in this area.  */\n+\t    if (TREE_CODE (rname) != FUNCTION_DECL || !DECL_IS_BUILTIN (rname))\n+\t      warning_at (location, OPT_Wscalar_storage_order,\n+\t\t\t  \"passing argument %d of %qE from incompatible \"\n+\t\t\t  \"scalar storage order\", parmnum, rname);\n+\t    break;\n+\t  case ic_assign:\n+\t    warning_at (location, OPT_Wscalar_storage_order,\n+\t\t\t\"assignment to %qT from pointer type %qT with \"\n+\t\t\t\"incompatible scalar storage order\", type, rhstype);\n+\t    break;\n+\t  case ic_init:\n+\t    warning_at (location, OPT_Wscalar_storage_order,\n+\t\t\t\"initialization of %qT from pointer type %qT with \"\n+\t\t\t\"incompatible scalar storage order\", type, rhstype);\n+\t    break;\n+\t  case ic_return:\n+\t    warning_at (location, OPT_Wscalar_storage_order,\n+\t\t\t\"returning %qT from pointer type with incompatible \"\n+\t\t\t\"scalar storage order %qT\", rhstype, type);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\t}\n+\n       /* Any non-function converts to a [const][volatile] void *\n \t and vice versa; otherwise, targets must be the same.\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */"}, {"sha": "41b84ba3bb310326d331faba87bd18f5a6f7cee4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -740,15 +740,24 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n     }\n   else\n     {\n-      tree srctype, desttype, destvar, srcvar, srcoff;\n+      /* We cannot (easily) change the type of the copy if it is a storage\n+\t order barrier, i.e. is equivalent to a VIEW_CONVERT_EXPR that can\n+\t modify the storage order of objects (see storage_order_barrier_p).  */\n+      tree srctype\n+\t= POINTER_TYPE_P (TREE_TYPE (src))\n+\t  ? TREE_TYPE (TREE_TYPE (src)) : NULL_TREE;\n+      tree desttype\n+\t= POINTER_TYPE_P (TREE_TYPE (dest))\n+\t  ? TREE_TYPE (TREE_TYPE (dest)) : NULL_TREE;\n+      tree destvar, srcvar, srcoff;\n       unsigned int src_align, dest_align;\n-      tree off0;\n-      const char *tmp_str;\n       unsigned HOST_WIDE_INT tmp_len;\n+      const char *tmp_str;\n \n       /* Build accesses at offset zero with a ref-all character type.  */\n-      off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n-\t\t\t\t\t\t\t ptr_mode, true), 0);\n+      tree off0\n+\t= build_int_cst (build_pointer_type_for_mode (char_type_node,\n+\t\t\t\t\t\t      ptr_mode, true), 0);\n \n       /* If we can perform the copy efficiently with first doing all loads\n          and then all stores inline it that way.  Currently efficiently\n@@ -766,7 +775,13 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t     hack can be removed.  */\n \t  && !c_strlen (src, 1)\n \t  && !((tmp_str = c_getstr (src, &tmp_len)) != NULL\n-\t       && memchr (tmp_str, 0, tmp_len) == NULL))\n+\t       && memchr (tmp_str, 0, tmp_len) == NULL)\n+\t  && !(srctype\n+\t       && AGGREGATE_TYPE_P (srctype)\n+\t       && TYPE_REVERSE_STORAGE_ORDER (srctype))\n+\t  && !(desttype\n+\t       && AGGREGATE_TYPE_P (desttype)\n+\t       && TYPE_REVERSE_STORAGE_ORDER (desttype)))\n \t{\n \t  unsigned ilen = tree_to_uhwi (len);\n \t  if (pow2p_hwi (ilen))\n@@ -946,20 +961,23 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \n       if (!tree_fits_shwi_p (len))\n \treturn false;\n-      if (!POINTER_TYPE_P (TREE_TYPE (src))\n-\t  || !POINTER_TYPE_P (TREE_TYPE (dest)))\n+      if (!srctype\n+\t  || (AGGREGATE_TYPE_P (srctype)\n+\t      && TYPE_REVERSE_STORAGE_ORDER (srctype)))\n+\treturn false;\n+      if (!desttype\n+\t  || (AGGREGATE_TYPE_P (desttype)\n+\t      && TYPE_REVERSE_STORAGE_ORDER (desttype)))\n \treturn false;\n       /* In the following try to find a type that is most natural to be\n \t used for the memcpy source and destination and that allows\n \t the most optimization when memcpy is turned into a plain assignment\n \t using that type.  In theory we could always use a char[len] type\n \t but that only gains us that the destination and source possibly\n \t no longer will have their address taken.  */\n-      srctype = TREE_TYPE (TREE_TYPE (src));\n       if (TREE_CODE (srctype) == ARRAY_TYPE\n \t  && !tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n \tsrctype = TREE_TYPE (srctype);\n-      desttype = TREE_TYPE (TREE_TYPE (dest));\n       if (TREE_CODE (desttype) == ARRAY_TYPE\n \t  && !tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n \tdesttype = TREE_TYPE (desttype);"}, {"sha": "6b50a25485813f679efd59e4a90b9dbcb2953a0c", "filename": "gcc/testsuite/gcc.dg/sso-11.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-11.c?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -0,0 +1,36 @@\n+/* Test support of scalar_storage_order attribute */\n+\n+/* { dg-do compile } */\n+\n+struct __attribute__((scalar_storage_order(\"big-endian\"))) S1\n+{\n+  int i;\n+};\n+\n+struct __attribute__((scalar_storage_order(\"little-endian\"))) S2\n+{\n+  int i;\n+};\n+\n+extern int foo (void *);\n+\n+int incompatible_call (int which, struct S1 *s1, struct S2 *s2)\n+{\n+  if (which == 1) return foo (s1); else foo (s2); /* { dg-warning \"incompatible scalar storage order\" } */\n+}\n+\n+void incompatible_assign (struct S1 *s1, struct S2 *s2)\n+{\n+  void *p1, *p2;\n+  p1 = s1, p2 = s2; /* { dg-warning \"incompatible scalar storage order\" } */\n+}\n+\n+void incompatible_init (struct S1 *s1, struct S2 *s2)\n+{\n+  void *p1 = s1, *p2 = s2; /* { dg-warning \"incompatible scalar storage order\" } */\n+}\n+\n+void *incompatible_return (int which, struct S1 *s1, struct S2 *s2)\n+{\n+  if (which == 1) return s1; else return s2; /* { dg-warning \"incompatible scalar storage order\" } */\n+}"}, {"sha": "b4e1c8786d9de3343c627665c86ce952fb303407", "filename": "gcc/testsuite/gcc.dg/sso/memcpy-1.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fmemcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fmemcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fmemcpy-1.c?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+\n+typedef unsigned char uint8_t;\n+typedef unsigned int uint32_t;\n+\n+#define __big_endian__ scalar_storage_order(\"big-endian\")\n+#define __little_endian__ scalar_storage_order(\"little-endian\")\n+\n+typedef union\n+{\n+  uint32_t val;\n+  uint8_t v[4];\n+} __attribute__((__big_endian__)) upal_u32be_t;\n+\n+typedef union\n+{\n+  uint32_t val;\n+  uint8_t v[4];\n+} __attribute__((__little_endian__)) upal_u32le_t;\n+\n+static inline uint32_t native_to_big_endian(uint32_t t)\n+{\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  return t;\n+#else\n+  return __builtin_bswap32(t);\n+#endif\n+}\n+static inline uint32_t native_to_little_endian(uint32_t t)\n+{\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  return __builtin_bswap32(t);\n+#else\n+  return t;\n+#endif\n+}\n+#define test(p, p1, i) do { if (p[i] != p1[i]) __builtin_abort (); } while (0)\n+\n+#define tests(p, p1) do { test(p, p1, 0); test(p, p1, 1); \\\n+                          test(p, p1, 2); test(p, p1, 3); } while (0)\n+\n+int main(void)\n+{\n+  const uint32_t u = 0x12345678;\n+\n+  upal_u32be_t tempb;\n+  __builtin_memcpy (&tempb, &u, sizeof(uint32_t));\n+  uint32_t bu = tempb.val;\n+  uint32_t b1u = native_to_big_endian(u);\n+  tests (((uint8_t*)&bu), ((uint8_t*)&b1u));\n+\n+  upal_u32le_t templ;\n+  __builtin_memcpy (&templ, &u, sizeof(uint32_t));\n+  uint32_t lu = templ.val;\n+  uint32_t l1u = native_to_little_endian(u);\n+  tests (((uint8_t*)&lu), ((uint8_t*)&l1u));\n+\n+  return 0;\n+}"}, {"sha": "80f534be9225a273f594e8af45085aca425625ab", "filename": "gcc/testsuite/gcc.dg/sso/sso.exp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fsso.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fsso.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso%2Fsso.exp?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -27,12 +27,12 @@ torture-init\n dg-init\n \n set SSO_TORTURE_OPTIONS [list \\\n-\t{ -O0 } \\\n-\t{ -O1 -fno-inline } \\\n-\t{ -O2 } \\\n-\t{ -O3 -finline-functions } \\\n-\t{ -Os } \\\n-\t{ -Og -g } ]\n+\t{ -Wno-scalar-storage-order -O0 } \\\n+\t{ -Wno-scalar-storage-order -O1 -fno-inline } \\\n+\t{ -Wno-scalar-storage-order -O2 } \\\n+\t{ -Wno-scalar-storage-order -O3 -finline-functions } \\\n+\t{ -Wno-scalar-storage-order -Os } \\\n+\t{ -Wno-scalar-storage-order -Og -g } ]\n \n set-torture-options $SSO_TORTURE_OPTIONS\n "}, {"sha": "e269f7885f4b7757f8176cbc4248fa19dfb51e8e", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b541b871135cb8f261d079006c79698a82e3594d/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=b541b871135cb8f261d079006c79698a82e3594d", "patch": "@@ -3224,8 +3224,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       return NULL;\n     }\n \n-  /* 6) For memcpy copies translate the reference through them if\n-     the copy kills ref.  */\n+  /* 6) For memcpy copies translate the reference through them if the copy\n+     kills ref.  But we cannot (easily) do this translation if the memcpy is\n+     a storage order barrier, i.e. is equivalent to a VIEW_CONVERT_EXPR that\n+     can modify the storage order of objects (see storage_order_barrier_p).  */\n   else if (data->vn_walk_kind == VN_WALKREWRITE\n \t   && is_gimple_reg_type (vr->type)\n \t   /* ???  Handle BCOPY as well.  */\n@@ -3275,6 +3277,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t}\n       if (TREE_CODE (lhs) == ADDR_EXPR)\n \t{\n+\t  if (AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (lhs)))\n+\t      && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_TYPE (lhs))))\n+\t    return (void *)-1;\n \t  tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (lhs, 0),\n \t\t\t\t\t\t    &lhs_offset);\n \t  if (!tem)\n@@ -3303,6 +3308,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \trhs = vn_valueize (rhs);\n       if (TREE_CODE (rhs) == ADDR_EXPR)\n \t{\n+\t  if (AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (rhs)))\n+\t      && TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_TYPE (rhs))))\n+\t    return (void *)-1;\n \t  tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (rhs, 0),\n \t\t\t\t\t\t    &rhs_offset);\n \t  if (!tem)"}]}