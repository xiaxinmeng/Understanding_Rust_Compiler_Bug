{"sha": "1acba85b3706fd7063cbccded2d0c635ee76c445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFjYmE4NWIzNzA2ZmQ3MDYzY2JjY2RlZDJkMGM2MzVlZTc2YzQ0NQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2009-09-16T09:47:25Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2009-09-16T09:47:25Z"}, "message": "algobase.h: Uglify internal identifiers.\n\n2009-09-16  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/algobase.h: Uglify internal identifiers.\n        * include/parallel/algo.h: Likewise.\n        * include/parallel/algorithmfwd.h: Likewise.\n        * include/parallel/balanced_quicksort.h: Likewise.\n        * include/parallel/base.h: Likewise.\n        * include/parallel/checkers.h: Likewise.\n        * include/parallel/compatibility.h: Likewise.\n        * include/parallel/compiletime_settings.: Likewise.\n        * include/parallel/equally_split.h: Likewise.\n        * include/parallel/features.h: Likewise.\n        * include/parallel/find.h: Likewise.\n        * include/parallel/find_selectors.h: Likewise.\n        * include/parallel/for_each.h: Likewise.\n        * include/parallel/for_each_selectors.h: Likewise.\n        * include/parallel/iterator.h: Likewise.\n        * include/parallel/list_partition.h: Likewise.\n        * include/parallel/losertree.h: Likewise.\n        * include/parallel/merge.h: Likewise.\n        * include/parallel/multiseq_selection.h: Likewise.\n        * include/parallel/multiway_merge.h: Likewise.\n        * include/parallel/multiway_mergesort.h: Likewise.\n        * include/parallel/numeric: Likewise.\n        * include/parallel/numericfwd.h: Likewise.\n        * include/parallel/omp_loop.h: Likewise.\n        * include/parallel/omp_loop_static.h: Likewise.\n        * include/parallel/par_loop.h: Likewise.\n        * include/parallel/partial_sum.h: Likewise.\n        * include/parallel/partition.h: Likewise.\n        * include/parallel/queue.h: Likewise.\n        * include/parallel/quicksort.h: Likewise.\n        * include/parallel/random_number.h: Likewise.\n        * include/parallel/random_shuffle.h: Likewise.\n        * include/parallel/search.h: Likewise.\n        * include/parallel/set_operations.h: Likewise.\n        * include/parallel/settings.h: Likewise.\n        * include/parallel/sort.h: Likewise.\n        * include/parallel/tags.h: Likewise.\n        * include/parallel/types.h: Likewise.\n        * include/parallel/unique_copy.h: Likewise.\n        * include/parallel/workstealing.h: Likewise.\n\nFrom-SVN: r151741", "tree": {"sha": "bd809f1188e9404c9cb6732443463b6d2bbe8882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd809f1188e9404c9cb6732443463b6d2bbe8882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1acba85b3706fd7063cbccded2d0c635ee76c445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1acba85b3706fd7063cbccded2d0c635ee76c445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1acba85b3706fd7063cbccded2d0c635ee76c445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1acba85b3706fd7063cbccded2d0c635ee76c445/comments", "author": null, "committer": null, "parents": [{"sha": "4075e7e8dcbb00abdd1f02e54d3328ed86644fbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4075e7e8dcbb00abdd1f02e54d3328ed86644fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4075e7e8dcbb00abdd1f02e54d3328ed86644fbd"}], "stats": {"total": 14078, "additions": 7062, "deletions": 7016}, "files": [{"sha": "9d46458f3d4e2f7a72f8a43c5d8f1df4bb63e187", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -1,3 +1,49 @@\n+2009-09-16  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/algobase.h: Uglify internal identifiers.\n+        * include/parallel/algo.h: Likewise.\n+        * include/parallel/algorithm: Likewise.\n+        * include/parallel/algorithmfwd.h: Likewise.\n+        * include/parallel/balanced_quicksort.h: Likewise.\n+        * include/parallel/base.h: Likewise.\n+        * include/parallel/basic_iterator.h: Likewise.\n+        * include/parallel/checkers.h: Likewise.\n+        * include/parallel/compatibility.h: Likewise.\n+        * include/parallel/compiletime_settings.: Likewise.\n+        * include/parallel/equally_split.h: Likewise.\n+        * include/parallel/features.h: Likewise.\n+        * include/parallel/find.h: Likewise.\n+        * include/parallel/find_selectors.h: Likewise.\n+        * include/parallel/for_each.h: Likewise.\n+        * include/parallel/for_each_selectors.h: Likewise.\n+        * include/parallel/iterator.h: Likewise.\n+        * include/parallel/list_partition.h: Likewise.\n+        * include/parallel/losertree.h: Likewise.\n+        * include/parallel/merge.h: Likewise.\n+        * include/parallel/multiseq_selection.h: Likewise.\n+        * include/parallel/multiway_merge.h: Likewise.\n+        * include/parallel/multiway_mergesort.h: Likewise.\n+        * include/parallel/numeric: Likewise.\n+        * include/parallel/numericfwd.h: Likewise.\n+        * include/parallel/omp_loop.h: Likewise.\n+        * include/parallel/omp_loop_static.h: Likewise.\n+        * include/parallel/parallel.h: Likewise.\n+        * include/parallel/par_loop.h: Likewise.\n+        * include/parallel/partial_sum.h: Likewise.\n+        * include/parallel/partition.h: Likewise.\n+        * include/parallel/queue.h: Likewise.\n+        * include/parallel/quicksort.h: Likewise.\n+        * include/parallel/random_number.h: Likewise.\n+        * include/parallel/random_shuffle.h: Likewise.\n+        * include/parallel/search.h: Likewise.\n+        * include/parallel/set_operations.h: Likewise.\n+        * include/parallel/settings.h: Likewise.\n+        * include/parallel/sort.h: Likewise.\n+        * include/parallel/tags.h: Likewise.\n+        * include/parallel/types.h: Likewise.\n+        * include/parallel/unique_copy.h: Likewise.\n+        * include/parallel/workstealing.h: Likewise.\n+\n 2009-09-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/41037"}, {"sha": "7f32036aec6c112211226f85229e08ef18fd2e92", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 1438, "deletions": 1438, "changes": 2876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445"}, {"sha": "b50068d29674110a29336863f258a4b0ba0c929d", "filename": "libstdc++-v3/include/parallel/algobase.h", "status": "modified", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -50,230 +50,230 @@ namespace __parallel\n   // NB: equal and lexicographical_compare require mismatch.\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2>\n-    inline pair<InputIterator1, InputIterator2>\n-    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n+  template<typename _IIter1, typename _IIter2>\n+    inline pair<_IIter1, _IIter2>\n+    mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n \t     __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2); }\n+    { return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2); }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate>\n-    inline pair<InputIterator1, InputIterator2>\n-    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t     Predicate pred, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate>\n+    inline pair<_IIter1, _IIter2>\n+    mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n+\t     _Predicate __pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred); }\n \n   // Sequential fallback for input iterator case\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate, typename IteratorTag1, typename IteratorTag2>\n-    inline pair<InputIterator1, InputIterator2>\n-    mismatch_switch(InputIterator1 begin1, InputIterator1 end1, \n-\t\t    InputIterator2 begin2, Predicate pred, IteratorTag1, \n-\t\t    IteratorTag2)\n-    { return _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred); }\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>\n+    inline pair<_IIter1, _IIter2>\n+    __mismatch_switch(_IIter1 __begin1, _IIter1 __end1, \n+\t\t    _IIter2 __begin2, _Predicate __pred, _IteratorTag1, \n+\t\t    _IteratorTag2)\n+    { return _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred); }\n \n   // Parallel mismatch for random access iterators\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename Predicate>\n-    pair<RandomAccessIterator1, RandomAccessIterator2>\n-    mismatch_switch(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-\t\t    RandomAccessIterator2 begin2, Predicate pred, \n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _Predicate>\n+    pair<_RAIter1, _RAIter2>\n+    __mismatch_switch(_RAIter1 __begin1, _RAIter1 __end1,\n+\t\t    _RAIter2 __begin2, _Predicate __pred, \n \t\t    random_access_iterator_tag, random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n \t{\n-\t  RandomAccessIterator1 res =\n-\t    __gnu_parallel::find_template(begin1, end1, begin2, pred,\n+\t  _RAIter1 __res =\n+\t    __gnu_parallel::__find_template(__begin1, __end1, __begin2, __pred,\n \t\t\t\t\t  __gnu_parallel::\n-\t\t\t\t\t  mismatch_selector()).first;\n-\t  return make_pair(res , begin2 + (res - begin1));\n+\t\t\t\t\t  __mismatch_selector()).first;\n+\t  return make_pair(__res , __begin2 + (__res - __begin1));\n \t}\n       else\n-\treturn _GLIBCXX_STD_P::mismatch(begin1, end1, begin2, pred);\n+\treturn _GLIBCXX_STD_P::mismatch(__begin1, __end1, __begin2, __pred);\n     }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2>\n-    inline pair<InputIterator1, InputIterator2>\n-    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n+  template<typename _IIter1, typename _IIter2>\n+    inline pair<_IIter1, _IIter2>\n+    mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2)\n     {\n-      typedef std::iterator_traits<InputIterator1> iterator1_traits;\n-      typedef std::iterator_traits<InputIterator2> iterator2_traits;\n-      typedef typename iterator1_traits::value_type value1_type;\n-      typedef typename iterator2_traits::value_type value2_type;\n-      typedef typename iterator1_traits::iterator_category iterator1_category;\n-      typedef typename iterator2_traits::iterator_category iterator2_category;\n+      typedef std::iterator_traits<_IIter1> iterator1_traits;\n+      typedef std::iterator_traits<_IIter2> iterator2_traits;\n+      typedef typename iterator1_traits::value_type _ValueType1;\n+      typedef typename iterator2_traits::value_type _ValueType2;\n+      typedef typename iterator1_traits::iterator_category _IteratorCategory1;\n+      typedef typename iterator2_traits::iterator_category _IteratorCategory2;\n \n-      typedef __gnu_parallel::equal_to<value1_type, value2_type> equal_to_type;\n+      typedef __gnu_parallel::equal_to<_ValueType1, _ValueType2> equal_to_type;\n \n-      return mismatch_switch(begin1, end1, begin2, equal_to_type(),\n-\t\t\t     iterator1_category(), iterator2_category());\n+      return __mismatch_switch(__begin1, __end1, __begin2, equal_to_type(),\n+\t\t\t     _IteratorCategory1(), _IteratorCategory2());\n     }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate>\n-    inline pair<InputIterator1, InputIterator2>\n-    mismatch(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2,\n-\t     Predicate pred)\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate>\n+    inline pair<_IIter1, _IIter2>\n+    mismatch(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2,\n+\t     _Predicate __pred)\n     {\n-      typedef std::iterator_traits<InputIterator1> iterator1_traits;\n-      typedef std::iterator_traits<InputIterator2> iterator2_traits;\n-      typedef typename iterator1_traits::iterator_category iterator1_category;\n-      typedef typename iterator2_traits::iterator_category iterator2_category;\n+      typedef std::iterator_traits<_IIter1> iterator1_traits;\n+      typedef std::iterator_traits<_IIter2> iterator2_traits;\n+      typedef typename iterator1_traits::iterator_category _IteratorCategory1;\n+      typedef typename iterator2_traits::iterator_category _IteratorCategory2;\n \n-      return mismatch_switch(begin1, end1, begin2, pred, iterator1_category(), \n-\t\t\t     iterator2_category());\n+      return __mismatch_switch(__begin1, __end1, __begin2, __pred, _IteratorCategory1(), \n+\t\t\t     _IteratorCategory2());\n     }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2>\n+  template<typename _IIter1, typename _IIter2>\n     inline bool\n-    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n+    equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n \t  __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::equal(begin1, end1, begin2); }\n+    { return _GLIBCXX_STD_P::equal(__begin1, __end1, __begin2); }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate>\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate>\n     inline bool\n-    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\t  Predicate pred, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::equal(begin1, end1, begin2, pred); }\n+    equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n+\t  _Predicate __pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::equal(__begin1, __end1, __begin2, __pred); }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2>\n+  template<typename _IIter1, typename _IIter2>\n     inline bool\n-    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2)\n-    { return mismatch(begin1, end1, begin2).first == end1; }\n+    equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2)\n+    { return mismatch(__begin1, __end1, __begin2).first == __end1; }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate>\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate>\n     inline bool\n-    equal(InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, \n-\t  Predicate pred)\n-    { return mismatch(begin1, end1, begin2, pred).first == end1; }\n+    equal(_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, \n+\t  _Predicate __pred)\n+    { return mismatch(__begin1, __end1, __begin2, __pred).first == __end1; }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2>\n+  template<typename _IIter1, typename _IIter2>\n     inline bool\n-    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n-\t\t\t    InputIterator2 begin2, InputIterator2 end2, \n+    lexicographical_compare(_IIter1 __begin1, _IIter1 __end1, \n+\t\t\t    _IIter2 __begin2, _IIter2 __end2, \n \t\t\t    __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1,\n-\t\t\t\t\t\t     begin2, end2); }\n+    { return _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1,\n+\t\t\t\t\t\t     __begin2, __end2); }\n \n   // Sequential fallback\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate>\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate>\n     inline bool\n-    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1, \n-\t\t\t    InputIterator2 begin2, InputIterator2 end2, \n-\t\t\t    Predicate pred, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n-\t\t\t\t\t\t     begin2, end2, pred); }\n+    lexicographical_compare(_IIter1 __begin1, _IIter1 __end1, \n+\t\t\t    _IIter2 __begin2, _IIter2 __end2, \n+\t\t\t    _Predicate __pred, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1, \n+\t\t\t\t\t\t     __begin2, __end2, __pred); }\n \n   // Sequential fallback for input iterator case\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate, typename IteratorTag1, typename IteratorTag2>\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate, typename _IteratorTag1, typename _IteratorTag2>\n     inline bool\n-    lexicographical_compare_switch(InputIterator1 begin1, InputIterator1 end1, \n-\t\t\t\t   InputIterator2 begin2, InputIterator2 end2, \n-\t\t\t\t   Predicate pred, IteratorTag1, IteratorTag2)\n-    { return _GLIBCXX_STD_P::lexicographical_compare(begin1, end1, \n-\t\t\t\t\t\t     begin2, end2, pred); }\n+    __lexicographical_compare_switch(_IIter1 __begin1, _IIter1 __end1, \n+\t\t\t\t   _IIter2 __begin2, _IIter2 __end2, \n+\t\t\t\t   _Predicate __pred, _IteratorTag1, _IteratorTag2)\n+    { return _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1, \n+\t\t\t\t\t\t     __begin2, __end2, __pred); }\n \n   // Parallel lexicographical_compare for random access iterators\n   // Limitation: Both valuetypes must be the same\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename Predicate>\n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _Predicate>\n     bool\n-    lexicographical_compare_switch(RandomAccessIterator1 begin1, \n-\t\t\t\t   RandomAccessIterator1 end1, \n-\t\t\t\t   RandomAccessIterator2 begin2, \n-\t\t\t\t   RandomAccessIterator2 end2, Predicate pred, \n+    __lexicographical_compare_switch(_RAIter1 __begin1, \n+\t\t\t\t   _RAIter1 __end1, \n+\t\t\t\t   _RAIter2 __begin2, \n+\t\t\t\t   _RAIter2 __end2, _Predicate __pred, \n \t\t\t\t   random_access_iterator_tag, \n \t\t\t\t   random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(true))\n \t{\n-\t  typedef iterator_traits<RandomAccessIterator1> traits1_type;\n-\t  typedef typename traits1_type::value_type value1_type;\n+\t  typedef iterator_traits<_RAIter1> _TraitsType1;\n+\t  typedef typename _TraitsType1::value_type _ValueType1;\n \n-\t  typedef iterator_traits<RandomAccessIterator2> traits2_type;\n-\t  typedef typename traits2_type::value_type value2_type;\n+\t  typedef iterator_traits<_RAIter2> _TraitsType2;\n+\t  typedef typename _TraitsType2::value_type _ValueType2;\n \n-\t  typedef __gnu_parallel::equal_from_less<Predicate, value1_type,\n-\t                                          value2_type> equal_type;\n+\t  typedef __gnu_parallel::_EqualFromLess<_Predicate, _ValueType1,\n+\t                                          _ValueType2> _EqualFromLessCompare;\n \n \t  // Longer sequence in first place.\n-\t  if ((end1 - begin1) < (end2 - begin2))\n+\t  if ((__end1 - __begin1) < (__end2 - __begin2))\n \t    {\n-\t      typedef pair<RandomAccessIterator1, RandomAccessIterator2>\n-\t\tpair_type;\n-\t      pair_type mm = mismatch_switch(begin1, end1, begin2, \n-\t\t\t\t\t     equal_type(pred), \n+\t      typedef pair<_RAIter1, _RAIter2>\n+\t\t_SpotType;\n+\t      _SpotType __mm = __mismatch_switch(__begin1, __end1, __begin2, \n+\t\t\t\t\t     _EqualFromLessCompare(__pred), \n \t\t\t\t\t     random_access_iterator_tag(), \n \t\t\t\t\t     random_access_iterator_tag());\n \n-\t      return (mm.first == end1) || bool(pred(*mm.first, *mm.second));\n+\t      return (__mm.first == __end1) || bool(__pred(*__mm.first, *__mm.second));\n \t    }\n \t  else\n \t    {\n-\t      typedef pair<RandomAccessIterator2, RandomAccessIterator1>\n-\t\tpair_type;\n-\t      pair_type mm = mismatch_switch(begin2, end2, begin1, \n-\t\t\t\t\t     equal_type(pred), \n+\t      typedef pair<_RAIter2, _RAIter1>\n+\t\t_SpotType;\n+\t      _SpotType __mm = __mismatch_switch(__begin2, __end2, __begin1, \n+\t\t\t\t\t     _EqualFromLessCompare(__pred), \n \t\t\t\t\t     random_access_iterator_tag(), \n \t\t\t\t\t     random_access_iterator_tag());\n \n-\t      return (mm.first != end2) && bool(pred(*mm.second, *mm.first));\n+\t      return (__mm.first != __end2) && bool(__pred(*__mm.second, *__mm.first));\n \t    }\n \t}\n       else\n-\treturn _GLIBCXX_STD_P::lexicographical_compare(begin1, end1,\n-\t\t\t\t\t\t       begin2, end2, pred);\n+\treturn _GLIBCXX_STD_P::lexicographical_compare(__begin1, __end1,\n+\t\t\t\t\t\t       __begin2, __end2, __pred);\n     }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2>\n+  template<typename _IIter1, typename _IIter2>\n     inline bool\n-    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1,\n-\t\t\t    InputIterator2 begin2, InputIterator2 end2)\n+    lexicographical_compare(_IIter1 __begin1, _IIter1 __end1,\n+\t\t\t    _IIter2 __begin2, _IIter2 __end2)\n     {\n-      typedef iterator_traits<InputIterator1> traits1_type;\n-      typedef typename traits1_type::value_type value1_type;\n-      typedef typename traits1_type::iterator_category iterator1_category;\n-\n-      typedef iterator_traits<InputIterator2> traits2_type;\n-      typedef typename traits2_type::value_type value2_type;\n-      typedef typename traits2_type::iterator_category iterator2_category;\n-      typedef __gnu_parallel::less<value1_type, value2_type> less_type;\n-\n-      return lexicographical_compare_switch(begin1, end1, begin2, end2, \n-\t\t\t\t\t    less_type(), iterator1_category(), \n-\t\t\t\t\t    iterator2_category());\n+      typedef iterator_traits<_IIter1> _TraitsType1;\n+      typedef typename _TraitsType1::value_type _ValueType1;\n+      typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n+\n+      typedef iterator_traits<_IIter2> _TraitsType2;\n+      typedef typename _TraitsType2::value_type _ValueType2;\n+      typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n+      typedef __gnu_parallel::_Less<_ValueType1, _ValueType2> _LessType;\n+\n+      return __lexicographical_compare_switch(__begin1, __end1, __begin2, __end2, \n+\t\t\t\t\t    _LessType(), _IteratorCategory1(), \n+\t\t\t\t\t    _IteratorCategory2());\n     }\n \n   // Public interface\n-  template<typename InputIterator1, typename InputIterator2,\n-\t   typename Predicate>\n+  template<typename _IIter1, typename _IIter2,\n+\t   typename _Predicate>\n     inline bool\n-    lexicographical_compare(InputIterator1 begin1, InputIterator1 end1,\n-\t\t\t    InputIterator2 begin2, InputIterator2 end2,\n-\t\t\t    Predicate pred)\n+    lexicographical_compare(_IIter1 __begin1, _IIter1 __end1,\n+\t\t\t    _IIter2 __begin2, _IIter2 __end2,\n+\t\t\t    _Predicate __pred)\n     {\n-      typedef iterator_traits<InputIterator1> traits1_type;\n-      typedef typename traits1_type::iterator_category iterator1_category;\n+      typedef iterator_traits<_IIter1> _TraitsType1;\n+      typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n \n-      typedef iterator_traits<InputIterator2> traits2_type;\n-      typedef typename traits2_type::iterator_category iterator2_category;\n+      typedef iterator_traits<_IIter2> _TraitsType2;\n+      typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n \n-      return lexicographical_compare_switch(begin1, end1, begin2, end2, pred, \n-\t\t\t\t\t    iterator1_category(), \n-\t\t\t\t\t    iterator2_category());\n+      return __lexicographical_compare_switch(__begin1, __end1, __begin2, __end2, __pred, \n+\t\t\t\t\t    _IteratorCategory1(), \n+\t\t\t\t\t    _IteratorCategory2());\n     }\n } // end namespace\n } // end namespace"}, {"sha": "c85959ecf643a68574ddc7a99d33c79889825499", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -48,11 +48,11 @@ namespace __parallel\n \n   template<typename _FIter, typename _IterTag>\n     _FIter\n-    adjacent_find_switch(_FIter, _FIter, _IterTag);\n+    __adjacent_find_switch(_FIter, _FIter, _IterTag);\n \n   template<typename _RAIter>\n     _RAIter\n-    adjacent_find_switch(_RAIter, _RAIter, random_access_iterator_tag);\n+    __adjacent_find_switch(_RAIter, _RAIter, random_access_iterator_tag);\n \n \n   template<typename _FIter, typename _BiPredicate>\n@@ -66,11 +66,11 @@ namespace __parallel\n \n   template<typename _FIter, typename _BiPredicate, typename _IterTag>\n     _FIter\n-    adjacent_find_switch(_FIter, _FIter, _BiPredicate, _IterTag);\n+    __adjacent_find_switch(_FIter, _FIter, _BiPredicate, _IterTag);\n \n   template<typename _RAIter, typename _BiPredicate>\n     _RAIter\n-    adjacent_find_switch(_RAIter, _RAIter, _BiPredicate, \n+    __adjacent_find_switch(_RAIter, _RAIter, _BiPredicate, \n \t\t\t random_access_iterator_tag);\n \n \n@@ -88,12 +88,12 @@ namespace __parallel\n \n   template<typename _IIter, typename _Tp, typename _IterTag>\n     typename iterator_traits<_IIter>::difference_type\n-    count_switch(_IIter, _IIter, const _Tp&, _IterTag);\n+    __count_switch(_IIter, _IIter, const _Tp&, _IterTag);\n \n   template<typename _RAIter, typename _Tp>\n     typename iterator_traits<_RAIter>::difference_type\n-    count_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag,\n-\t\t __gnu_parallel::_Parallelism parallelism\n+    __count_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag,\n+\t\t __gnu_parallel::_Parallelism __parallelism\n \t\t = __gnu_parallel::parallel_unbalanced);\n \n \n@@ -111,47 +111,47 @@ namespace __parallel\n \n   template<typename _IIter, typename _Predicate, typename _IterTag>\n     typename iterator_traits<_IIter>::difference_type\n-    count_if_switch(_IIter, _IIter, _Predicate, _IterTag);\n+    __count_if_switch(_IIter, _IIter, _Predicate, _IterTag);\n \n   template<typename _RAIter, typename _Predicate>\n     typename iterator_traits<_RAIter>::difference_type\n-    count_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag,\n-\t\t    __gnu_parallel::_Parallelism parallelism\n+    __count_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag,\n+\t\t    __gnu_parallel::_Parallelism __parallelism\n \t\t    = __gnu_parallel::parallel_unbalanced);\n \n   // algobase.h\n   template<typename _IIter1, typename _IIter2>\n     bool\n     equal(_IIter1, _IIter1, _IIter2, __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     bool\n-    equal(_IIter1, _IIter1, _IIter2, Predicate,\n+    equal(_IIter1, _IIter1, _IIter2, _Predicate,\n \t  __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2>\n     bool\n     equal(_IIter1, _IIter1, _IIter2);\n \n-  template<typename _IIter1, typename _IIter2, typename Predicate>\n+  template<typename _IIter1, typename _IIter2, typename _Predicate>\n     bool\n-    equal(_IIter1, _IIter1, _IIter2, Predicate);\n+    equal(_IIter1, _IIter1, _IIter2, _Predicate);\n \n   template<typename _IIter, typename _Tp>\n     _IIter\n     find(_IIter, _IIter, const _Tp&, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _Tp>\n     _IIter\n-    find(_IIter, _IIter, const _Tp& val);\n+    find(_IIter, _IIter, const _Tp& __val);\n \n   template<typename _IIter, typename _Tp, typename _IterTag>\n     _IIter\n-    find_switch(_IIter, _IIter, const _Tp&, _IterTag);\n+    __find_switch(_IIter, _IIter, const _Tp&, _IterTag);\n \n   template<typename _RAIter, typename _Tp>\n     _RAIter\n-    find_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag);\n+    __find_switch(_RAIter, _RAIter, const _Tp&, random_access_iterator_tag);\n \n   template<typename _IIter, typename _Predicate>\n     _IIter\n@@ -163,11 +163,11 @@ namespace __parallel\n \n   template<typename _IIter, typename _Predicate, typename _IterTag>\n     _IIter\n-    find_if_switch(_IIter, _IIter, _Predicate, _IterTag);\n+    __find_if_switch(_IIter, _IIter, _Predicate, _IterTag);\n \n   template<typename _RAIter, typename _Predicate>\n     _RAIter\n-    find_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag);\n+    __find_if_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag);\n \n   template<typename _IIter, typename _FIter>\n     _IIter\n@@ -190,18 +190,18 @@ namespace __parallel\n   template<typename _IIter, typename _FIter,\n \t   typename _IterTag1, typename _IterTag2>\n     _IIter\n-    find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n+    __find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _IterTag1, _IterTag2);\n \n   template<typename _RAIter, typename _FIter, typename _BiPredicate,\n \t   typename _IterTag>\n     _RAIter\n-    find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, _BiPredicate,\n+    __find_first_of_switch(_RAIter, _RAIter, _FIter, _FIter, _BiPredicate,\n \t\t\t random_access_iterator_tag, _IterTag);\n \n   template<typename _IIter, typename _FIter, typename _BiPredicate,\n \t   typename _IterTag1, typename _IterTag2>\n     _IIter\n-    find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _BiPredicate,\n+    __find_first_of_switch(_IIter, _IIter, _FIter, _FIter, _BiPredicate,\n \t\t\t _IterTag1, _IterTag2);\n \n \n@@ -219,12 +219,12 @@ namespace __parallel\n \n   template<typename _IIter, typename _Function, typename _IterTag>\n     _Function\n-    for_each_switch(_IIter, _IIter, _Function, _IterTag);\n+    __for_each_switch(_IIter, _IIter, _Function, _IterTag);\n \n   template<typename _RAIter, typename _Function>\n     _Function\n-    for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag, \n-\t\t    __gnu_parallel::_Parallelism  parallelism\n+    __for_each_switch(_RAIter, _RAIter, _Function, random_access_iterator_tag, \n+\t\t    __gnu_parallel::_Parallelism  __parallelism\n \t\t    = __gnu_parallel::parallel_balanced);\n \n \n@@ -242,12 +242,12 @@ namespace __parallel\n \n   template<typename _FIter, typename _Generator, typename _IterTag>\n     void\n-    generate_switch(_FIter, _FIter, _Generator, _IterTag);\n+    __generate_switch(_FIter, _FIter, _Generator, _IterTag);\n \n   template<typename _RAIter, typename _Generator>\n     void\n-    generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag, \n-\t\t    __gnu_parallel::_Parallelism parallelism\n+    __generate_switch(_RAIter, _RAIter, _Generator, random_access_iterator_tag, \n+\t\t    __gnu_parallel::_Parallelism __parallelism\n \t\t    = __gnu_parallel::parallel_balanced);\n \n   template<typename _OIter, typename _Size, typename _Generator>\n@@ -265,12 +265,12 @@ namespace __parallel\n   template<typename _OIter, typename _Size, typename _Generator,\n \t   typename _IterTag>\n     _OIter\n-    generate_n_switch(_OIter, _Size, _Generator, _IterTag);\n+    __generate_n_switch(_OIter, _Size, _Generator, _IterTag);\n \n   template<typename _RAIter, typename _Size, typename _Generator>\n     _RAIter\n-    generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag, \n-\t\t      __gnu_parallel::_Parallelism parallelism\n+    __generate_n_switch(_RAIter, _Size, _Generator, random_access_iterator_tag, \n+\t\t      __gnu_parallel::_Parallelism __parallelism\n \t\t      = __gnu_parallel::parallel_balanced);\n \n   template<typename _IIter1, typename _IIter2>\n@@ -294,12 +294,12 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2,\n \t   typename _Predicate, typename _IterTag1, typename _IterTag2>\n     bool\n-    lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n+    __lexicographical_compare_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n \t\t\t\t   _Predicate, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n     bool\n-    lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+    __lexicographical_compare_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n \t\t\t\t   _Predicate, random_access_iterator_tag,\n \t\t\t\t   random_access_iterator_tag);\n \n@@ -324,12 +324,12 @@ namespace __parallel\n   template<typename _IIter1, typename _IIter2, typename _Predicate,\n \t   typename _IterTag1, typename _IterTag2>\n     pair<_IIter1, _IIter2>\n-    mismatch_switch(_IIter1, _IIter1, _IIter2, _Predicate,\n+    __mismatch_switch(_IIter1, _IIter1, _IIter2, _Predicate,\n \t\t    _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Predicate>\n     pair<_RAIter1, _RAIter2>\n-    mismatch_switch(_RAIter1, _RAIter1, _RAIter2, _Predicate,\n+    __mismatch_switch(_RAIter1, _RAIter1, _RAIter2, _Predicate,\n \t\t    random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2>\n@@ -351,23 +351,23 @@ namespace __parallel\n \n   template<typename _RAIter1, typename _RAIter2>\n     _RAIter1\n-    search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+    __search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n \t\t  random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2, typename _IterTag1,\n \t   typename _IterTag2>\n     _FIter1\n-    search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _IterTag1, _IterTag2);\n+    __search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _IterTag1, _IterTag2);\n \n   template<typename _RAIter1, typename _RAIter2, typename _BiPredicate>\n     _RAIter1\n-    search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _BiPredicate,\n+    __search_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _BiPredicate,\n \t\t  random_access_iterator_tag, random_access_iterator_tag);\n \n   template<typename _FIter1, typename _FIter2, typename _BiPredicate,\n \t   typename _IterTag1, typename _IterTag2>\n     _FIter1\n-    search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate,\n+    __search_switch(_FIter1, _FIter1, _FIter2, _FIter2, _BiPredicate,\n \t\t  _IterTag1, _IterTag2);\n \n   template<typename _FIter, typename _Integer, typename _Tp>\n@@ -393,42 +393,42 @@ namespace __parallel\n   template<typename _RAIter, typename _Integer, typename _Tp,\n \t   typename _BiPredicate>\n     _RAIter\n-    search_n_switch(_RAIter, _RAIter, _Integer, const _Tp&,\n+    __search_n_switch(_RAIter, _RAIter, _Integer, const _Tp&,\n \t\t    _BiPredicate, random_access_iterator_tag);\n \n   template<typename _FIter, typename _Integer, typename _Tp,\n \t   typename _BiPredicate, typename _IterTag>\n     _FIter\n-    search_n_switch(_FIter, _FIter, _Integer, const _Tp&,\n+    __search_n_switch(_FIter, _FIter, _Integer, const _Tp&,\n \t\t    _BiPredicate, _IterTag);\n \n \n-  template<typename _IIter, typename _OIter, typename UnaryOperation>\n+  template<typename _IIter, typename _OIter, typename _UnaryOperation>\n     _OIter\n-    transform(_IIter, _IIter, _OIter, UnaryOperation);\n+    transform(_IIter, _IIter, _OIter, _UnaryOperation);\n \n-  template<typename _IIter, typename _OIter, typename UnaryOperation>\n+  template<typename _IIter, typename _OIter, typename _UnaryOperation>\n     _OIter\n-    transform(_IIter, _IIter, _OIter, UnaryOperation, \n+    transform(_IIter, _IIter, _OIter, _UnaryOperation, \n \t      __gnu_parallel::sequential_tag);\n \n-  template<typename _IIter, typename _OIter, typename UnaryOperation>\n+  template<typename _IIter, typename _OIter, typename _UnaryOperation>\n     _OIter\n-    transform(_IIter, _IIter, _OIter, UnaryOperation, \n+    transform(_IIter, _IIter, _OIter, _UnaryOperation, \n \t      __gnu_parallel::_Parallelism);\n \n-  template<typename _IIter, typename _OIter, typename UnaryOperation,\n+  template<typename _IIter, typename _OIter, typename _UnaryOperation,\n \t   typename _IterTag1, typename _IterTag2>\n     _OIter\n-    transform1_switch(_IIter, _IIter, _OIter, UnaryOperation, \n+    __transform1_switch(_IIter, _IIter, _OIter, _UnaryOperation, \n \t\t      _IterTag1, _IterTag2);\n     \n \n-  template<typename _RAIIter, typename _RAOIter, typename UnaryOperation>\n+  template<typename _RAIIter, typename _RAOIter, typename _UnaryOperation>\n     _RAOIter\n-    transform1_switch(_RAIIter, _RAIIter, _RAOIter, UnaryOperation, \n+    __transform1_switch(_RAIIter, _RAIIter, _RAOIter, _UnaryOperation, \n \t\t      random_access_iterator_tag, random_access_iterator_tag, \n-\t\t      __gnu_parallel::_Parallelism parallelism\n+\t\t      __gnu_parallel::_Parallelism __parallelism\n \t\t      = __gnu_parallel::parallel_balanced);\n \n \n@@ -452,17 +452,17 @@ namespace __parallel\n   template<typename _RAIter1, typename _RAIter2, typename _RAIter3,\n \t   typename _BiOperation>\n     _RAIter3\n-    transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n+    __transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n \t\t      random_access_iterator_tag, random_access_iterator_tag, \n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::_Parallelism parallelism\n+\t\t      __gnu_parallel::_Parallelism __parallelism\n \t\t      = __gnu_parallel::parallel_balanced);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n \t   typename _BiOperation, typename _Tag1,\n \t   typename _Tag2, typename _Tag3>\n     _OIter\n-    transform2_switch(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n+    __transform2_switch(_IIter1, _IIter1, _IIter2, _OIter, _BiOperation, \n \t\t      _Tag1, _Tag2, _Tag3);\n \n \n@@ -482,11 +482,11 @@ namespace __parallel\n \n   template<typename _FIter, typename _Tp, typename _IterTag>\n     void\n-    replace_switch(_FIter, _FIter, const _Tp&, const _Tp&, _IterTag);\n+    __replace_switch(_FIter, _FIter, const _Tp&, const _Tp&, _IterTag);\n \n   template<typename _RAIter, typename _Tp>\n     void\n-    replace_switch(_RAIter, _RAIter, const _Tp&, const _Tp&, \n+    __replace_switch(_RAIter, _RAIter, const _Tp&, const _Tp&, \n \t\t   random_access_iterator_tag, __gnu_parallel::_Parallelism);\n \n \n@@ -507,11 +507,11 @@ namespace __parallel\n   template<typename _FIter, typename _Predicate, typename _Tp,\n \t   typename _IterTag>\n     void\n-    replace_if_switch(_FIter, _FIter, _Predicate, const _Tp&, _IterTag);\n+    __replace_if_switch(_FIter, _FIter, _Predicate, const _Tp&, _IterTag);\n  \n   template<typename _RAIter, typename _Predicate, typename _Tp>\n     void\n-    replace_if_switch(_RAIter, _RAIter, _Predicate, const _Tp&,\n+    __replace_if_switch(_RAIter, _RAIter, _Predicate, const _Tp&,\n \t\t      random_access_iterator_tag,\n \t\t      __gnu_parallel::_Parallelism);\n \n@@ -542,12 +542,12 @@ namespace __parallel\n \n   template<typename _FIter, typename _Compare, typename _IterTag>\n     _FIter\n-    max_element_switch(_FIter, _FIter, _Compare, _IterTag);\n+    __max_element_switch(_FIter, _FIter, _Compare, _IterTag);\n \n   template<typename _RAIter, typename _Compare>\n     _RAIter\n-    max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n-\t\t       __gnu_parallel::_Parallelism parallelism\n+    __max_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n+\t\t       __gnu_parallel::_Parallelism __parallelism\n \t\t       = __gnu_parallel::parallel_balanced);\n \n \n@@ -575,13 +575,13 @@ namespace __parallel\n \t   typename _Compare, typename _IterTag1, typename _IterTag2,\n \t   typename _IterTag3>\n     _OIter\n-    merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n+    __merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n \t\t _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n \t   typename _Compare>\n     _OIter\n-    merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n+    __merge_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare, \n \t\t random_access_iterator_tag, random_access_iterator_tag, \n \t\t random_access_iterator_tag);\n \n@@ -596,7 +596,7 @@ namespace __parallel\n \n   template<typename _FIter>\n     _FIter\n-    min_element(_FIter, _FIter, __gnu_parallel::_Parallelism parallelism_tag);\n+    min_element(_FIter, _FIter, __gnu_parallel::_Parallelism __parallelism_tag);\n \n   template<typename _FIter, typename _Compare>\n     _FIter\n@@ -612,12 +612,12 @@ namespace __parallel\n \n   template<typename _FIter, typename _Compare, typename _IterTag>\n     _FIter\n-    min_element_switch(_FIter, _FIter, _Compare, _IterTag);\n+    __min_element_switch(_FIter, _FIter, _Compare, _IterTag);\n \n   template<typename _RAIter, typename _Compare>\n     _RAIter\n-    min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n-\t\t       __gnu_parallel::_Parallelism parallelism\n+    __min_element_switch(_RAIter, _RAIter, _Compare, random_access_iterator_tag, \n+\t\t       __gnu_parallel::_Parallelism __parallelism\n \t\t       = __gnu_parallel::parallel_balanced);\n \n   template<typename _RAIter>\n@@ -654,21 +654,21 @@ namespace __parallel\n     void\n     partial_sort(_RAIter, _RAIter, _RAIter);\n \n-  template<typename _FIter, typename Predicate>\n+  template<typename _FIter, typename _Predicate>\n     _FIter\n-    partition(_FIter, _FIter, Predicate, __gnu_parallel::sequential_tag);\n+    partition(_FIter, _FIter, _Predicate, __gnu_parallel::sequential_tag);\n     \n-  template<typename _FIter, typename Predicate>\n+  template<typename _FIter, typename _Predicate>\n     _FIter\n-    partition(_FIter, _FIter, Predicate);\n+    partition(_FIter, _FIter, _Predicate);\n \n-  template<typename _FIter, typename Predicate, typename _IterTag>\n+  template<typename _FIter, typename _Predicate, typename _IterTag>\n     _FIter\n-    partition_switch(_FIter, _FIter, Predicate, _IterTag);\n+    __partition_switch(_FIter, _FIter, _Predicate, _IterTag);\n     \n-  template<typename _RAIter, typename Predicate>\n+  template<typename _RAIter, typename _Predicate>\n     _RAIter\n-    partition_switch(_RAIter, _RAIter, Predicate, random_access_iterator_tag);\n+    __partition_switch(_RAIter, _RAIter, _Predicate, random_access_iterator_tag);\n \n   template<typename _RAIter>\n     void\n@@ -693,9 +693,9 @@ namespace __parallel\n \t    __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n-\t   typename Predicate>\n+\t   typename _Predicate>\n     _OIter\n-    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, Predicate,\n+    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Predicate,\n \t      __gnu_parallel::sequential_tag);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter>\n@@ -711,13 +711,13 @@ namespace __parallel\n \t   typename _OIter, typename _IterTag1, typename _IterTag2,\n \t   typename _IterTag3>\n     _OIter\n-    set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+    __set_union_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n \t\t     _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n \t   typename _Predicate>\n     _Output_RAIter\n-    set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _Output_RAIter,\n+    __set_union_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2, _Output_RAIter,\n \t\t     _Predicate, random_access_iterator_tag,\n \t\t     random_access_iterator_tag, random_access_iterator_tag);\n \n@@ -745,13 +745,13 @@ namespace __parallel\n \t   typename _OIter, typename _IterTag1, typename _IterTag2,\n \t   typename _IterTag3>\n     _OIter\n-    set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+    __set_intersection_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n \t\t\t    _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n \t   typename _Predicate>\n     _Output_RAIter\n-    set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+    __set_intersection_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n \t\t\t    _Output_RAIter, _Predicate,\n \t\t\t    random_access_iterator_tag,\n \t\t\t    random_access_iterator_tag,\n@@ -782,14 +782,14 @@ namespace __parallel\n \t   typename _OIter, typename _IterTag1, typename _IterTag2,\n \t   typename _IterTag3>\n     _OIter\n-    set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n+    __set_symmetric_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2,\n \t\t\t\t    _OIter, _Predicate, _IterTag1, _IterTag2,\n \t\t\t\t    _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n \t   typename _Predicate>\n     _Output_RAIter\n-    set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+    __set_symmetric_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n \t\t\t\t    _Output_RAIter, _Predicate,\n \t\t\t\t    random_access_iterator_tag,\n \t\t\t\t    random_access_iterator_tag,\n@@ -820,13 +820,13 @@ namespace __parallel\n \t   typename _OIter, typename _IterTag1, typename _IterTag2,\n \t   typename _IterTag3>\n     _OIter\n-    set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n+    __set_difference_switch(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,\n \t\t\t  _Predicate, _IterTag1, _IterTag2, _IterTag3);\n \n   template<typename _RAIter1, typename _RAIter2, typename _Output_RAIter,\n \t   typename _Predicate>\n     _Output_RAIter\n-    set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n+    __set_difference_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter2,\n \t\t\t  _Output_RAIter, _Predicate,\n \t\t\t  random_access_iterator_tag,\n \t\t\t  random_access_iterator_tag,\n@@ -885,12 +885,12 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename _Predicate,\n \t   typename _IterTag1, typename _IterTag2>\n     _OIter\n-    unique_copy_switch(_IIter, _IIter, _OIter, _Predicate,\n+    __unique_copy_switch(_IIter, _IIter, _OIter, _Predicate,\n \t\t       _IterTag1, _IterTag2);\n \n   template<typename _RAIter, typename _RandomAccess_OIter, typename _Predicate>\n     _RandomAccess_OIter\n-    unique_copy_switch(_RAIter, _RAIter, _RandomAccess_OIter, _Predicate,\n+    __unique_copy_switch(_RAIter, _RAIter, _RandomAccess_OIter, _Predicate,\n \t\t       random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace __parallel\n } // end namespace std"}, {"sha": "2e939143e3d56105a15f494cfdd85e7bf1a525d9", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 208, "deletions": 208, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -58,347 +58,347 @@\n namespace __gnu_parallel\n {\n /** @brief Information local to one thread in the parallel quicksort run. */\n-template<typename RandomAccessIterator>\n-  struct QSBThreadLocal\n+template<typename _RAIter>\n+  struct _QSBThreadLocal\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n     /** @brief Continuous part of the sequence, described by an\n     iterator pair. */\n-    typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n+    typedef std::pair<_RAIter, _RAIter> _Piece;\n \n     /** @brief Initial piece to work on. */\n-    Piece initial;\n+    _Piece _M_initial;\n \n     /** @brief Work-stealing queue. */\n-    RestrictedBoundedConcurrentQueue<Piece> leftover_parts;\n+    _RestrictedBoundedConcurrentQueue<_Piece> _M_leftover_parts;\n \n     /** @brief Number of threads involved in this algorithm. */\n-    thread_index_t num_threads;\n+    _ThreadIndex __num_threads;\n \n     /** @brief Pointer to a counter of elements left over to sort. */\n-    volatile difference_type* elements_leftover;\n+    volatile _DifferenceType* _M_elements_leftover;\n \n     /** @brief The complete sequence to sort. */\n-    Piece global;\n+    _Piece _M_global;\n \n     /** @brief Constructor.\n-     *  @param queue_size Size of the work-stealing queue. */\n-    QSBThreadLocal(int queue_size) : leftover_parts(queue_size) { }\n+     *  @param __queue_size size of the work-stealing queue. */\n+    _QSBThreadLocal(int __queue_size) : _M_leftover_parts(__queue_size) { }\n   };\n \n /** @brief Balanced quicksort divide step.\n-  *  @param begin Begin iterator of subsequence.\n-  *  @param end End iterator of subsequence.\n-  *  @param comp Comparator.\n-  *  @param num_threads Number of threads that are allowed to work on\n+  *  @param __begin Begin iterator of subsequence.\n+  *  @param __end End iterator of subsequence.\n+  *  @param __comp Comparator.\n+  *  @param __num_threads Number of threads that are allowed to work on\n   *  this part.\n-  *  @pre @c (end-begin)>=1 */\n-template<typename RandomAccessIterator, typename Comparator>\n-  typename std::iterator_traits<RandomAccessIterator>::difference_type\n-  qsb_divide(RandomAccessIterator begin, RandomAccessIterator end,\n-             Comparator comp, thread_index_t num_threads)\n+  *  @pre @__c (__end-__begin)>=1 */\n+template<typename _RAIter, typename _Compare>\n+  typename std::iterator_traits<_RAIter>::difference_type\n+  __qsb_divide(_RAIter __begin, _RAIter __end,\n+             _Compare __comp, _ThreadIndex __num_threads)\n   {\n-    _GLIBCXX_PARALLEL_ASSERT(num_threads > 0);\n+    _GLIBCXX_PARALLEL_ASSERT(__num_threads > 0);\n \n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    RandomAccessIterator pivot_pos =\n-      median_of_three_iterators(begin, begin + (end - begin) / 2,\n-\t\t\t\tend  - 1, comp);\n+    _RAIter __pivot_pos =\n+      __median_of_three_iterators(__begin, __begin + (__end - __begin) / 2,\n+\t\t\t\t__end  - 1, __comp);\n \n #if defined(_GLIBCXX_ASSERTIONS)\n     // Must be in between somewhere.\n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n \n     _GLIBCXX_PARALLEL_ASSERT(\n-           (!comp(*pivot_pos, *begin) && !comp(*(begin + n / 2), *pivot_pos))\n-        || (!comp(*pivot_pos, *begin) && !comp(*(end - 1), *pivot_pos))\n-        || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*begin, *pivot_pos))\n-        || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*(end - 1), *pivot_pos))\n-        || (!comp(*pivot_pos, *(end - 1)) && !comp(*begin, *pivot_pos))\n-        || (!comp(*pivot_pos, *(end - 1)) && !comp(*(begin + n / 2), *pivot_pos)));\n+           (!__comp(*__pivot_pos, *__begin) && !__comp(*(__begin + __n / 2), *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *__begin) && !__comp(*(__end - 1), *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) && !__comp(*__begin, *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__begin + __n / 2)) && !__comp(*(__end - 1), *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__end - 1)) && !__comp(*__begin, *__pivot_pos))\n+        || (!__comp(*__pivot_pos, *(__end - 1)) && !__comp(*(__begin + __n / 2), *__pivot_pos)));\n #endif\n \n     // Swap pivot value to end.\n-    if (pivot_pos != (end - 1))\n-      std::swap(*pivot_pos, *(end - 1));\n-    pivot_pos = end - 1;\n+    if (__pivot_pos != (__end - 1))\n+      std::swap(*__pivot_pos, *(__end - 1));\n+    __pivot_pos = __end - 1;\n \n-    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n-        pred(comp, *pivot_pos);\n+    __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n+        __pred(__comp, *__pivot_pos);\n \n-    // Divide, returning end - begin - 1 in the worst case.\n-    difference_type split_pos = parallel_partition(\n-        begin, end - 1, pred, num_threads);\n+    // Divide, returning __end - __begin - 1 in the worst case.\n+    _DifferenceType __split_pos = __parallel_partition(\n+        __begin, __end - 1, __pred, __num_threads);\n \n     // Swap back pivot to middle.\n-    std::swap(*(begin + split_pos), *pivot_pos);\n-    pivot_pos = begin + split_pos;\n+    std::swap(*(__begin + __split_pos), *__pivot_pos);\n+    __pivot_pos = __begin + __split_pos;\n \n #if _GLIBCXX_ASSERTIONS\n-    RandomAccessIterator r;\n-    for (r = begin; r != pivot_pos; ++r)\n-      _GLIBCXX_PARALLEL_ASSERT(comp(*r, *pivot_pos));\n-    for (; r != end; ++r)\n-      _GLIBCXX_PARALLEL_ASSERT(!comp(*r, *pivot_pos));\n+    _RAIter __r;\n+    for (__r = __begin; __r != __pivot_pos; ++__r)\n+      _GLIBCXX_PARALLEL_ASSERT(__comp(*__r, *__pivot_pos));\n+    for (; __r != __end; ++__r)\n+      _GLIBCXX_PARALLEL_ASSERT(!__comp(*__r, *__pivot_pos));\n #endif\n \n-    return split_pos;\n+    return __split_pos;\n   }\n \n /** @brief Quicksort conquer step.\n-  *  @param tls Array of thread-local storages.\n-  *  @param begin Begin iterator of subsequence.\n-  *  @param end End iterator of subsequence.\n-  *  @param comp Comparator.\n-  *  @param iam Number of the thread processing this function.\n-  *  @param num_threads\n+  *  @param __tls Array of thread-local storages.\n+  *  @param __begin Begin iterator of subsequence.\n+  *  @param __end End iterator of subsequence.\n+  *  @param __comp Comparator.\n+  *  @param __iam Number of the thread processing this function.\n+  *  @param __num_threads\n   *          Number of threads that are allowed to work on this part. */\n-template<typename RandomAccessIterator, typename Comparator>\n+template<typename _RAIter, typename _Compare>\n   void\n-  qsb_conquer(QSBThreadLocal<RandomAccessIterator>** tls,\n-              RandomAccessIterator begin, RandomAccessIterator end,\n-              Comparator comp,\n-              thread_index_t iam, thread_index_t num_threads,\n-              bool parent_wait)\n+  __qsb_conquer(_QSBThreadLocal<_RAIter>** __tls,\n+              _RAIter __begin, _RAIter __end,\n+              _Compare __comp,\n+              _ThreadIndex __iam, _ThreadIndex __num_threads,\n+              bool __parent_wait)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n \n-    if (num_threads <= 1 || n <= 1)\n+    if (__num_threads <= 1 || __n <= 1)\n       {\n-        tls[iam]->initial.first  = begin;\n-        tls[iam]->initial.second = end;\n+        __tls[__iam]->_M_initial.first  = __begin;\n+        __tls[__iam]->_M_initial.second = __end;\n \n-        qsb_local_sort_with_helping(tls, comp, iam, parent_wait);\n+        __qsb_local_sort_with_helping(__tls, __comp, __iam, __parent_wait);\n \n         return;\n       }\n \n     // Divide step.\n-    difference_type split_pos = qsb_divide(begin, end, comp, num_threads);\n+    _DifferenceType __split_pos = __qsb_divide(__begin, __end, __comp, __num_threads);\n \n #if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(0 <= split_pos && split_pos < (end - begin));\n+    _GLIBCXX_PARALLEL_ASSERT(0 <= __split_pos && __split_pos < (__end - __begin));\n #endif\n \n-    thread_index_t num_threads_leftside =\n-        std::max<thread_index_t>(1, std::min<thread_index_t>(\n-                          num_threads - 1, split_pos * num_threads / n));\n+    _ThreadIndex __num_threads_leftside =\n+        std::max<_ThreadIndex>(1, std::min<_ThreadIndex>(\n+                          __num_threads - 1, __split_pos * __num_threads / __n));\n \n #   pragma omp atomic\n-    *tls[iam]->elements_leftover -= (difference_type)1;\n+    *__tls[__iam]->_M_elements_leftover -= (_DifferenceType)1;\n \n     // Conquer step.\n #   pragma omp parallel num_threads(2)\n     {\n-      bool wait;\n+      bool __wait;\n       if(omp_get_num_threads() < 2)\n-        wait = false;\n+        __wait = false;\n       else\n-        wait = parent_wait;\n+        __wait = __parent_wait;\n \n #     pragma omp sections\n         {\n #         pragma omp section\n             {\n-              qsb_conquer(tls, begin, begin + split_pos, comp,\n-                          iam,\n-                          num_threads_leftside,\n-                          wait);\n-              wait = parent_wait;\n+              __qsb_conquer(__tls, __begin, __begin + __split_pos, __comp,\n+                          __iam,\n+                          __num_threads_leftside,\n+                          __wait);\n+              __wait = __parent_wait;\n             }\n           // The pivot_pos is left in place, to ensure termination.\n #         pragma omp section\n             {\n-              qsb_conquer(tls, begin + split_pos + 1, end, comp,\n-                          iam + num_threads_leftside,\n-                          num_threads - num_threads_leftside,\n-                          wait);\n-              wait = parent_wait;\n+              __qsb_conquer(__tls, __begin + __split_pos + 1, __end, __comp,\n+                          __iam + __num_threads_leftside,\n+                          __num_threads - __num_threads_leftside,\n+                          __wait);\n+              __wait = __parent_wait;\n             }\n         }\n     }\n   }\n \n /**\n   *  @brief Quicksort step doing load-balanced local sort.\n-  *  @param tls Array of thread-local storages.\n-  *  @param comp Comparator.\n-  *  @param iam Number of the thread processing this function.\n+  *  @param __tls Array of thread-local storages.\n+  *  @param __comp Comparator.\n+  *  @param __iam Number of the thread processing this function.\n   */\n-template<typename RandomAccessIterator, typename Comparator>\n+template<typename _RAIter, typename _Compare>\n   void\n-  qsb_local_sort_with_helping(QSBThreadLocal<RandomAccessIterator>** tls,\n-                              Comparator& comp, int iam, bool wait)\n+  __qsb_local_sort_with_helping(_QSBThreadLocal<_RAIter>** __tls,\n+                              _Compare& __comp, int __iam, bool __wait)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef std::pair<_RAIter, _RAIter> _Piece;\n \n-    QSBThreadLocal<RandomAccessIterator>& tl = *tls[iam];\n+    _QSBThreadLocal<_RAIter>& __tl = *__tls[__iam];\n \n-    difference_type base_case_n =\n+    _DifferenceType __base_case_n =\n         _Settings::get().sort_qsb_base_case_maximal_n;\n-    if (base_case_n < 2)\n-      base_case_n = 2;\n-    thread_index_t num_threads = tl.num_threads;\n+    if (__base_case_n < 2)\n+      __base_case_n = 2;\n+    _ThreadIndex __num_threads = __tl.__num_threads;\n \n     // Every thread has its own random number generator.\n-    random_number rng(iam + 1);\n+    _RandomNumber __rng(__iam + 1);\n \n-    Piece current = tl.initial;\n+    _Piece __current = __tl._M_initial;\n \n-    difference_type elements_done = 0;\n+    _DifferenceType __elements_done = 0;\n #if _GLIBCXX_ASSERTIONS\n-    difference_type total_elements_done = 0;\n+    _DifferenceType __total_elements_done = 0;\n #endif\n \n     for (;;)\n       {\n-        // Invariant: current must be a valid (maybe empty) range.\n-        RandomAccessIterator begin = current.first, end = current.second;\n-        difference_type n = end - begin;\n+        // Invariant: __current must be a valid (maybe empty) range.\n+        _RAIter __begin = __current.first, __end = __current.second;\n+        _DifferenceType __n = __end - __begin;\n \n-        if (n > base_case_n)\n+        if (__n > __base_case_n)\n           {\n             // Divide.\n-            RandomAccessIterator pivot_pos = begin +  rng(n);\n+            _RAIter __pivot_pos = __begin +  __rng(__n);\n \n-            // Swap pivot_pos value to end.\n-            if (pivot_pos != (end - 1))\n-              std::swap(*pivot_pos, *(end - 1));\n-            pivot_pos = end - 1;\n+            // Swap __pivot_pos value to end.\n+            if (__pivot_pos != (__end - 1))\n+              std::swap(*__pivot_pos, *(__end - 1));\n+            __pivot_pos = __end - 1;\n \n             __gnu_parallel::binder2nd\n-                <Comparator, value_type, value_type, bool>\n-                pred(comp, *pivot_pos);\n+                <_Compare, _ValueType, _ValueType, bool>\n+                __pred(__comp, *__pivot_pos);\n \n             // Divide, leave pivot unchanged in last place.\n-            RandomAccessIterator split_pos1, split_pos2;\n-            split_pos1 = __gnu_sequential::partition(begin, end - 1, pred);\n+            _RAIter __split_pos1, __split_pos2;\n+            __split_pos1 = __gnu_sequential::partition(__begin, __end - 1, __pred);\n \n-            // Left side: < pivot_pos; right side: >= pivot_pos.\n+            // Left side: < __pivot_pos; __right side: >= __pivot_pos.\n #if _GLIBCXX_ASSERTIONS\n-            _GLIBCXX_PARALLEL_ASSERT(begin <= split_pos1 && split_pos1 < end);\n+            _GLIBCXX_PARALLEL_ASSERT(__begin <= __split_pos1 && __split_pos1 < __end);\n #endif\n             // Swap pivot back to middle.\n-            if (split_pos1 != pivot_pos)\n-              std::swap(*split_pos1, *pivot_pos);\n-            pivot_pos = split_pos1;\n+            if (__split_pos1 != __pivot_pos)\n+              std::swap(*__split_pos1, *__pivot_pos);\n+            __pivot_pos = __split_pos1;\n \n-            // In case all elements are equal, split_pos1 == 0.\n-            if ((split_pos1 + 1 - begin) < (n >> 7)\n-            || (end - split_pos1) < (n >> 7))\n+            // In case all elements are equal, __split_pos1 == 0.\n+            if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n+            || (__end - __split_pos1) < (__n >> 7))\n               {\n                 // Very unequal split, one part smaller than one 128th\n                 // elements not strictly larger than the pivot.\n-                __gnu_parallel::unary_negate<__gnu_parallel::binder1st\n-\t\t  <Comparator, value_type, value_type, bool>, value_type>\n-\t\t  pred(__gnu_parallel::binder1st\n-\t\t       <Comparator, value_type, value_type, bool>(comp,\n-\t\t\t\t\t\t\t\t  *pivot_pos));\n+                __gnu_parallel::__unary_negate<__gnu_parallel::__binder1st\n+\t\t  <_Compare, _ValueType, _ValueType, bool>, _ValueType>\n+\t\t  __pred(__gnu_parallel::__binder1st\n+\t\t       <_Compare, _ValueType, _ValueType, bool>(__comp,\n+\t\t\t\t\t\t\t\t  *__pivot_pos));\n \n                 // Find other end of pivot-equal range.\n-                split_pos2 = __gnu_sequential::partition(split_pos1 + 1,\n-\t\t\t\t\t\t\t end, pred);\n+                __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n+\t\t\t\t\t\t\t __end, __pred);\n               }\n             else\n               // Only skip the pivot.\n-              split_pos2 = split_pos1 + 1;\n+              __split_pos2 = __split_pos1 + 1;\n \n             // Elements equal to pivot are done.\n-            elements_done += (split_pos2 - split_pos1);\n+            __elements_done += (__split_pos2 - __split_pos1);\n #if _GLIBCXX_ASSERTIONS\n-            total_elements_done += (split_pos2 - split_pos1);\n+            __total_elements_done += (__split_pos2 - __split_pos1);\n #endif\n             // Always push larger part onto stack.\n-            if (((split_pos1 + 1) - begin) < (end - (split_pos2)))\n+            if (((__split_pos1 + 1) - __begin) < (__end - (__split_pos2)))\n               {\n                 // Right side larger.\n-                if ((split_pos2) != end)\n-                  tl.leftover_parts.push_front(std::make_pair(split_pos2,\n-\t\t\t\t\t\t\t      end));\n+                if ((__split_pos2) != __end)\n+                  __tl._M_leftover_parts.push_front(std::make_pair(__split_pos2,\n+\t\t\t\t\t\t\t      __end));\n \n-                //current.first = begin;\t//already set anyway\n-                current.second = split_pos1;\n+                //__current.first = __begin;\t//already set anyway\n+                __current.second = __split_pos1;\n                 continue;\n               }\n             else\n               {\n                 // Left side larger.\n-                if (begin != split_pos1)\n-                  tl.leftover_parts.push_front(std::make_pair(begin,\n-\t\t\t\t\t\t\t      split_pos1));\n+                if (__begin != __split_pos1)\n+                  __tl._M_leftover_parts.push_front(std::make_pair(__begin,\n+\t\t\t\t\t\t\t      __split_pos1));\n \n-                current.first = split_pos2;\n-                //current.second = end;\t//already set anyway\n+                __current.first = __split_pos2;\n+                //__current.second = __end;\t//already set anyway\n                 continue;\n               }\n           }\n         else\n           {\n-            __gnu_sequential::sort(begin, end, comp);\n-            elements_done += n;\n+            __gnu_sequential::sort(__begin, __end, __comp);\n+            __elements_done += __n;\n #if _GLIBCXX_ASSERTIONS\n-            total_elements_done += n;\n+            __total_elements_done += __n;\n #endif\n \n             // Prefer own stack, small pieces.\n-            if (tl.leftover_parts.pop_front(current))\n+            if (__tl._M_leftover_parts.pop_front(__current))\n               continue;\n \n #           pragma omp atomic\n-            *tl.elements_leftover -= elements_done;\n+            *__tl._M_elements_leftover -= __elements_done;\n \n-            elements_done = 0;\n+            __elements_done = 0;\n \n #if _GLIBCXX_ASSERTIONS\n-            double search_start = omp_get_wtime();\n+            double __search_start = omp_get_wtime();\n #endif\n \n             // Look for new work.\n-            bool successfully_stolen = false;\n-            while (wait && *tl.elements_leftover > 0 && !successfully_stolen\n+            bool __successfully_stolen = false;\n+            while (__wait && *__tl._M_elements_leftover > 0 && !__successfully_stolen\n #if _GLIBCXX_ASSERTIONS\n               // Possible dead-lock.\n-              && (omp_get_wtime() < (search_start + 1.0))\n+              && (omp_get_wtime() < (__search_start + 1.0))\n #endif\n               )\n               {\n-                thread_index_t victim;\n-                victim = rng(num_threads);\n+                _ThreadIndex __victim;\n+                __victim = __rng(__num_threads);\n \n                 // Large pieces.\n-                successfully_stolen = (victim != iam)\n-                    && tls[victim]->leftover_parts.pop_back(current);\n-                if (!successfully_stolen)\n-                  yield();\n+                __successfully_stolen = (__victim != __iam)\n+                    && __tls[__victim]->_M_leftover_parts.pop_back(__current);\n+                if (!__successfully_stolen)\n+                  __yield();\n #if !defined(__ICC) && !defined(__ECC)\n #               pragma omp flush\n #endif\n               }\n \n #if _GLIBCXX_ASSERTIONS\n-            if (omp_get_wtime() >= (search_start + 1.0))\n+            if (omp_get_wtime() >= (__search_start + 1.0))\n               {\n                 sleep(1);\n                 _GLIBCXX_PARALLEL_ASSERT(omp_get_wtime()\n-\t\t\t\t\t < (search_start + 1.0));\n+\t\t\t\t\t < (__search_start + 1.0));\n               }\n #endif\n-            if (!successfully_stolen)\n+            if (!__successfully_stolen)\n               {\n #if _GLIBCXX_ASSERTIONS\n-                _GLIBCXX_PARALLEL_ASSERT(*tl.elements_leftover == 0);\n+                _GLIBCXX_PARALLEL_ASSERT(*__tl._M_elements_leftover == 0);\n #endif\n                 return;\n               }\n@@ -407,70 +407,70 @@ template<typename RandomAccessIterator, typename Comparator>\n   }\n \n /** @brief Top-level quicksort routine.\n-  *  @param begin Begin iterator of sequence.\n-  *  @param end End iterator of sequence.\n-  *  @param comp Comparator.\n-  *  @param num_threads Number of threads that are allowed to work on\n+  *  @param __begin Begin iterator of sequence.\n+  *  @param __end End iterator of sequence.\n+  *  @param __comp Comparator.\n+  *  @param __num_threads Number of threads that are allowed to work on\n   *  this part.\n   */\n-template<typename RandomAccessIterator, typename Comparator>\n+template<typename _RAIter, typename _Compare>\n   void\n-  parallel_sort_qsb(RandomAccessIterator begin, RandomAccessIterator end,\n-                    Comparator comp,\n-                    thread_index_t num_threads)\n+  __parallel_sort_qsb(_RAIter __begin, _RAIter __end,\n+                    _Compare __comp,\n+                    _ThreadIndex __num_threads)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef std::pair<_RAIter, _RAIter> _Piece;\n \n-    typedef QSBThreadLocal<RandomAccessIterator> tls_type;\n+    typedef _QSBThreadLocal<_RAIter> _TLSType;\n \n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n \n-    if (n <= 1)\n+    if (__n <= 1)\n       return;\n \n     // At least one element per processor.\n-    if (num_threads > n)\n-      num_threads = static_cast<thread_index_t>(n);\n+    if (__num_threads > __n)\n+      __num_threads = static_cast<_ThreadIndex>(__n);\n \n     // Initialize thread local storage\n-    tls_type** tls = new tls_type*[num_threads];\n-    difference_type queue_size = num_threads * (thread_index_t)(log2(n) + 1);\n-    for (thread_index_t t = 0; t < num_threads; ++t)\n-      tls[t] = new QSBThreadLocal<RandomAccessIterator>(queue_size);\n+    _TLSType** __tls = new _TLSType*[__num_threads];\n+    _DifferenceType __queue_size = __num_threads * (_ThreadIndex)(log2(__n) + 1);\n+    for (_ThreadIndex __t = 0; __t < __num_threads; ++__t)\n+      __tls[__t] = new _QSBThreadLocal<_RAIter>(__queue_size);\n \n-    // There can never be more than ceil(log2(n)) ranges on the stack, because\n+    // There can never be more than ceil(log2(__n)) ranges on the stack, because\n     // 1. Only one processor pushes onto the stack\n-    // 2. The largest range has at most length n\n+    // 2. The largest range has at most length __n\n     // 3. Each range is larger than half of the range remaining\n-    volatile difference_type elements_leftover = n;\n-    for (int i = 0; i < num_threads; ++i)\n+    volatile _DifferenceType _M_elements_leftover = __n;\n+    for (int __i = 0; __i < __num_threads; ++__i)\n       {\n-        tls[i]->elements_leftover = &elements_leftover;\n-        tls[i]->num_threads = num_threads;\n-        tls[i]->global = std::make_pair(begin, end);\n+        __tls[__i]->_M_elements_leftover = &_M_elements_leftover;\n+        __tls[__i]->__num_threads = __num_threads;\n+        __tls[__i]->_M_global = std::make_pair(__begin, __end);\n \n         // Just in case nothing is left to assign.\n-        tls[i]->initial = std::make_pair(end, end);\n+        __tls[__i]->_M_initial = std::make_pair(__end, __end);\n       }\n \n     // Main recursion call.\n-    qsb_conquer(tls, begin, begin + n, comp, 0, num_threads, true);\n+    __qsb_conquer(__tls, __begin, __begin + __n, __comp, 0, __num_threads, true);\n \n #if _GLIBCXX_ASSERTIONS\n     // All stack must be empty.\n-    Piece dummy;\n-    for (int i = 1; i < num_threads; ++i)\n-      _GLIBCXX_PARALLEL_ASSERT(!tls[i]->leftover_parts.pop_back(dummy));\n+    _Piece __dummy;\n+    for (int __i = 1; __i < __num_threads; ++__i)\n+      _GLIBCXX_PARALLEL_ASSERT(!__tls[__i]->_M_leftover_parts.pop_back(__dummy));\n #endif\n \n-    for (int i = 0; i < num_threads; ++i)\n-      delete tls[i];\n-    delete[] tls;\n+    for (int __i = 0; __i < __num_threads; ++__i)\n+      delete __tls[__i];\n+    delete[] __tls;\n   }\n } // namespace __gnu_parallel\n "}, {"sha": "e09f05c76f8ae1faa9f71dbcc2936e97309b2718", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -82,193 +82,193 @@ namespace __gnu_parallel\n   // and active, which imples that the OpenMP runtime is actually\n   // going to be linked in.\n   inline int\n-  get_max_threads() \n+  __get_max_threads() \n   { \n     int __i = omp_get_max_threads();\n     return __i > 1 ? __i : 1; \n   }\n \n   \n   inline bool \n-  is_parallel(const _Parallelism __p) { return __p != sequential; }\n+  __is_parallel(const _Parallelism __p) { return __p != sequential; }\n \n \n   // XXX remove std::duplicates from here if possible,\n   // XXX but keep minimal dependencies.\n \n-/** @brief Calculates the rounded-down logarithm of @c n for base 2.\n-  *  @param n Argument.\n+/** @brief Calculates the rounded-down logarithm of @__c __n for base 2.\n+  *  @param __n Argument.\n   *  @return Returns 0 for any argument <1.\n   */\n-template<typename Size>\n-  inline Size\n-  __log2(Size n)\n+template<typename _Size>\n+  inline _Size\n+  __log2(_Size __n)\n     {\n-      Size k;\n-      for (k = 0; n > 1; n >>= 1)\n-        ++k;\n-      return k;\n+      _Size __k;\n+      for (__k = 0; __n > 1; __n >>= 1)\n+        ++__k;\n+      return __k;\n     }\n \n-/** @brief Encode two integers into one __gnu_parallel::lcas_t.\n-  *  @param a First integer, to be encoded in the most-significant @c\n-  *  lcas_t_bits/2 bits.\n-  *  @param b Second integer, to be encoded in the least-significant\n-  *  @c lcas_t_bits/2 bits.\n-  *  @return __gnu_parallel::lcas_t value encoding @c a and @c b.\n+/** @brief Encode two integers into one __gnu_parallel::_CASable.\n+  *  @param __a First integer, to be encoded in the most-significant @__c\n+  *  _CASable_bits/2 bits.\n+  *  @param __b Second integer, to be encoded in the least-significant\n+  *  @__c _CASable_bits/2 bits.\n+  *  @return __gnu_parallel::_CASable _M_value encoding @__c __a and @__c __b.\n   *  @see decode2\n   */\n-inline lcas_t\n-encode2(int a, int b)\t//must all be non-negative, actually\n+inline _CASable\n+__encode2(int __a, int __b)\t//must all be non-negative, actually\n {\n-  return (((lcas_t)a) << (lcas_t_bits / 2)) | (((lcas_t)b) << 0);\n+  return (((_CASable)__a) << (_CASable_bits / 2)) | (((_CASable)__b) << 0);\n }\n \n-/** @brief Decode two integers from one __gnu_parallel::lcas_t.\n-  *  @param x __gnu_parallel::lcas_t to decode integers from.\n-  *  @param a First integer, to be decoded from the most-significant\n-  *  @c lcas_t_bits/2 bits of @c x.\n-  *  @param b Second integer, to be encoded in the least-significant\n-  *  @c lcas_t_bits/2 bits of @c x.\n-  *  @see encode2\n+/** @brief Decode two integers from one __gnu_parallel::_CASable.\n+  *  @param __x __gnu_parallel::_CASable to decode integers from.\n+  *  @param __a First integer, to be decoded from the most-significant\n+  *  @__c _CASable_bits/2 bits of @__c __x.\n+  *  @param __b Second integer, to be encoded in the least-significant\n+  *  @__c _CASable_bits/2 bits of @__c __x.\n+  *  @see __encode2\n   */\n inline void\n-decode2(lcas_t x, int& a, int& b)\n+decode2(_CASable __x, int& __a, int& __b)\n {\n-  a = (int)((x >> (lcas_t_bits / 2)) & lcas_t_mask);\n-  b = (int)((x >>               0 ) & lcas_t_mask);\n+  __a = (int)((__x >> (_CASable_bits / 2)) & _CASable_mask);\n+  __b = (int)((__x >>               0 ) & _CASable_mask);\n }\n \n /** @brief Equivalent to std::min. */\n-template<typename T>\n-  const T&\n-  min(const T& a, const T& b)\n-  { return (a < b) ? a : b; }\n+template<typename _Tp>\n+  const _Tp&\n+  min(const _Tp& __a, const _Tp& __b)\n+  { return (__a < __b) ? __a : __b; }\n \n /** @brief Equivalent to std::max. */\n-template<typename T>\n-  const T&\n-  max(const T& a, const T& b)\n-  { return (a > b) ? a : b; }\n+template<typename _Tp>\n+  const _Tp&\n+  max(const _Tp& __a, const _Tp& __b)\n+  { return (__a > __b) ? __a : __b; }\n \n /** @brief Constructs predicate for equality from strict weak\n   *  ordering predicate\n   */\n // XXX comparator at the end, as per others\n-template<typename Comparator, typename T1, typename T2>\n-  class equal_from_less : public std::binary_function<T1, T2, bool>\n+template<typename _Compare, typename _T1, typename _T2>\n+  class _EqualFromLess : public std::binary_function<_T1, _T2, bool>\n   {\n   private:\n-    Comparator& comp;\n+    _Compare& __comp;\n \n   public:\n-    equal_from_less(Comparator& _comp) : comp(_comp) { }\n+    _EqualFromLess(_Compare& _comp) : __comp(_comp) { }\n \n-    bool operator()(const T1& a, const T2& b)\n+    bool operator()(const _T1& __a, const _T2& __b)\n     {\n-      return !comp(a, b) && !comp(b, a);\n+      return !__comp(__a, __b) && !__comp(__b, __a);\n     }\n   };\n \n \n-/** @brief Similar to std::binder1st,\n+/** @brief Similar to std::__binder1st,\n   *  but giving the argument types explicitly. */\n template<typename _Predicate, typename argument_type>\n-  class unary_negate\n+  class __unary_negate\n   : public std::unary_function<argument_type, bool>\n   {\n   protected:\n     _Predicate _M_pred;\n \n   public:\n     explicit\n-    unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n+    __unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n \n     bool\n     operator()(const argument_type& __x)\n     { return !_M_pred(__x); }\n   };\n \n-/** @brief Similar to std::binder1st,\n+/** @brief Similar to std::__binder1st,\n   *  but giving the argument types explicitly. */\n-template<typename _Operation, typename first_argument_type,\n-\t typename second_argument_type, typename result_type>\n-  class binder1st\n-  : public std::unary_function<second_argument_type, result_type>\n+template<typename _Operation, typename _FirstArgumentType,\n+\t typename _SecondArgumentType, typename _ResultType>\n+  class __binder1st\n+  : public std::unary_function<_SecondArgumentType, _ResultType>\n   {\n   protected:\n-    _Operation op;\n-    first_argument_type value;\n+    _Operation _M_op;\n+    _FirstArgumentType _M_value;\n \n   public:\n-    binder1st(const _Operation& __x,\n-              const first_argument_type& __y)\n-    : op(__x), value(__y) { }\n+    __binder1st(const _Operation& __x,\n+              const _FirstArgumentType& __y)\n+    : _M_op(__x), _M_value(__y) { }\n \n-    result_type\n-    operator()(const second_argument_type& __x)\n-    { return op(value, __x); }\n+    _ResultType\n+    operator()(const _SecondArgumentType& __x)\n+    { return _M_op(_M_value, __x); }\n \n     // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 109.  Missing binders for non-const sequence elements\n-    result_type\n-    operator()(second_argument_type& __x) const\n-    { return op(value, __x); }\n+    // 109.  Missing binders for non-const __sequence __elements\n+    _ResultType\n+    operator()(_SecondArgumentType& __x) const\n+    { return _M_op(_M_value, __x); }\n   };\n \n /**\n   *  @brief Similar to std::binder2nd, but giving the argument types\n   *  explicitly.\n   */\n-template<typename _Operation, typename first_argument_type,\n-\t typename second_argument_type, typename result_type>\n+template<typename _Operation, typename _FirstArgumentType,\n+\t typename _SecondArgumentType, typename _ResultType>\n   class binder2nd\n-  : public std::unary_function<first_argument_type, result_type>\n+  : public std::unary_function<_FirstArgumentType, _ResultType>\n   {\n   protected:\n-    _Operation op;\n-    second_argument_type value;\n+    _Operation _M_op;\n+    _SecondArgumentType _M_value;\n \n   public:\n     binder2nd(const _Operation& __x,\n-              const second_argument_type& __y)\n-    : op(__x), value(__y) { }\n+              const _SecondArgumentType& __y)\n+    : _M_op(__x), _M_value(__y) { }\n \n-    result_type\n-    operator()(const first_argument_type& __x) const\n-    { return op(__x, value); }\n+    _ResultType\n+    operator()(const _FirstArgumentType& __x) const\n+    { return _M_op(__x, _M_value); }\n \n     // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 109.  Missing binders for non-const sequence elements\n-    result_type\n-    operator()(first_argument_type& __x)\n-    { return op(__x, value); }\n+    // 109.  Missing binders for non-const __sequence __elements\n+    _ResultType\n+    operator()(_FirstArgumentType& __x)\n+    { return _M_op(__x, _M_value); }\n   };\n \n /** @brief Similar to std::equal_to, but allows two different types. */\n-template<typename T1, typename T2>\n-  struct equal_to : std::binary_function<T1, T2, bool>\n+template<typename _T1, typename _T2>\n+  struct equal_to : std::binary_function<_T1, _T2, bool>\n   {\n-    bool operator()(const T1& t1, const T2& t2) const\n-    { return t1 == t2; }\n+    bool operator()(const _T1& __t1, const _T2& __t2) const\n+    { return __t1 == __t2; }\n   };\n \n /** @brief Similar to std::less, but allows two different types. */\n-template<typename T1, typename T2>\n-  struct less : std::binary_function<T1, T2, bool>\n+template<typename _T1, typename _T2>\n+  struct _Less : std::binary_function<_T1, _T2, bool>\n   {\n     bool\n-    operator()(const T1& t1, const T2& t2) const\n-    { return t1 < t2; }\n+    operator()(const _T1& __t1, const _T2& __t2) const\n+    { return __t1 < __t2; }\n \n     bool\n-    operator()(const T2& t2, const T1& t1) const\n-    { return t2 < t1; }\n+    operator()(const _T2& __t2, const _T1& __t1) const\n+    { return __t2 < __t1; }\n   };\n \n // Partial specialization for one type. Same as std::less.\n template<typename _Tp>\n-struct less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n+struct _Less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n   {\n     bool\n     operator()(const _Tp& __x, const _Tp& __y) const\n@@ -278,189 +278,189 @@ struct less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n \n   /** @brief Similar to std::plus, but allows two different types. */\n template<typename _Tp1, typename _Tp2>\n-  struct plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+  struct _Plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n   {\n     typedef __typeof__(*static_cast<_Tp1*>(NULL)\n-\t\t       + *static_cast<_Tp2*>(NULL)) result;\n+\t\t       + *static_cast<_Tp2*>(NULL)) __result;\n \n-    result\n+    __result\n     operator()(const _Tp1& __x, const _Tp2& __y) const\n     { return __x + __y; }\n   };\n \n // Partial specialization for one type. Same as std::plus.\n template<typename _Tp>\n-  struct plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+  struct _Plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n   {\n     typedef __typeof__(*static_cast<_Tp*>(NULL)\n-\t\t       + *static_cast<_Tp*>(NULL)) result;\n+\t\t       + *static_cast<_Tp*>(NULL)) __result;\n \n-    result\n+    __result\n     operator()(const _Tp& __x, const _Tp& __y) const\n     { return __x + __y; }\n   };\n \n \n /** @brief Similar to std::multiplies, but allows two different types. */\n template<typename _Tp1, typename _Tp2>\n-  struct multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+  struct _Multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n   {\n     typedef __typeof__(*static_cast<_Tp1*>(NULL)\n-\t\t       * *static_cast<_Tp2*>(NULL)) result;\n+\t\t       * *static_cast<_Tp2*>(NULL)) __result;\n \n-    result\n+    __result\n     operator()(const _Tp1& __x, const _Tp2& __y) const\n     { return __x * __y; }\n   };\n \n // Partial specialization for one type. Same as std::multiplies.\n template<typename _Tp>\n-  struct multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+  struct _Multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n   {\n     typedef __typeof__(*static_cast<_Tp*>(NULL)\n-\t\t       * *static_cast<_Tp*>(NULL)) result;\n+\t\t       * *static_cast<_Tp*>(NULL)) __result;\n \n-    result\n+    __result\n     operator()(const _Tp& __x, const _Tp& __y) const\n     { return __x * __y; }\n   };\n \n \n-template<typename T, typename _DifferenceTp>\n-  class pseudo_sequence;\n+template<typename _Tp, typename _DifferenceTp>\n+  class _PseudoSequence;\n \n-/** @brief Iterator associated with __gnu_parallel::pseudo_sequence.\n+/** @brief _Iterator associated with __gnu_parallel::_PseudoSequence.\n   *  If features the usual random-access iterator functionality.\n-  *  @param T Sequence value type.\n-  *  @param difference_type Sequence difference type.\n+  *  @param _Tp Sequence _M_value type.\n+  *  @param _DifferenceType Sequence difference type.\n   */\n-template<typename T, typename _DifferenceTp>\n-  class pseudo_sequence_iterator\n+template<typename _Tp, typename _DifferenceTp>\n+  class _PseudoSequenceIterator\n   {\n   public:\n-    typedef _DifferenceTp difference_type;\n+    typedef _DifferenceTp _DifferenceType;\n \n   private:\n-    typedef pseudo_sequence_iterator<T, _DifferenceTp> type;\n+    typedef _PseudoSequenceIterator<_Tp, _DifferenceTp> _Self;\n \n-    const T& val;\n-    difference_type pos;\n+    const _Tp& _M_val;\n+    _DifferenceType _M_pos;\n \n   public:\n-    pseudo_sequence_iterator(const T& val, difference_type pos)\n-    : val(val), pos(pos) { }\n+    _PseudoSequenceIterator(const _Tp& _M_val, _DifferenceType _M_pos)\n+    : _M_val(_M_val), _M_pos(_M_pos) { }\n \n     // Pre-increment operator.\n-    type&\n+    _Self&\n     operator++()\n     {\n-      ++pos;\n+      ++_M_pos;\n       return *this;\n     }\n \n     // Post-increment operator.\n-    const type\n+    const _Self\n     operator++(int)\n-    { return type(pos++); }\n+    { return _Self(_M_pos++); }\n \n-    const T&\n+    const _Tp&\n     operator*() const\n-    { return val; }\n+    { return _M_val; }\n \n-    const T&\n-    operator[](difference_type) const\n-    { return val; }\n+    const _Tp&\n+    operator[](_DifferenceType) const\n+    { return _M_val; }\n \n     bool\n-    operator==(const type& i2)\n-    { return pos == i2.pos; }\n+    operator==(const _Self& __i2)\n+    { return _M_pos == __i2._M_pos; }\n \n-    difference_type\n-    operator!=(const type& i2)\n-    { return pos != i2.pos; }\n+    _DifferenceType\n+    operator!=(const _Self& __i2)\n+    { return _M_pos != __i2._M_pos; }\n \n-    difference_type\n-    operator-(const type& i2)\n-    { return pos - i2.pos; }\n+    _DifferenceType\n+    operator-(const _Self& __i2)\n+    { return _M_pos - __i2._M_pos; }\n   };\n \n /** @brief Sequence that conceptually consists of multiple copies of\n     the same element.\n   *  The copies are not stored explicitly, of course.\n-  *  @param T Sequence value type.\n-  *  @param difference_type Sequence difference type.\n+  *  @param _Tp Sequence _M_value type.\n+  *  @param _DifferenceType Sequence difference type.\n   */\n-template<typename T, typename _DifferenceTp>\n-  class pseudo_sequence\n+template<typename _Tp, typename _DifferenceTp>\n+  class _PseudoSequence\n   {\n-    typedef pseudo_sequence<T, _DifferenceTp> type;\n+    typedef _PseudoSequence<_Tp, _DifferenceTp> _Self;\n \n   public:\n-    typedef _DifferenceTp difference_type;\n+    typedef _DifferenceTp _DifferenceType;\n \n     // Better case down to uint64, than up to _DifferenceTp.\n-    typedef pseudo_sequence_iterator<T, uint64> iterator;\n+    typedef _PseudoSequenceIterator<_Tp, uint64> iterator;\n \n     /** @brief Constructor.\n-      *  @param val Element of the sequence.\n-      *  @param count Number of (virtual) copies.\n+      *  @param _M_val Element of the sequence.\n+      *  @param __count Number of (virtual) copies.\n       */\n-    pseudo_sequence(const T& val, difference_type count)\n-    : val(val), count(count)  { }\n+    _PseudoSequence(const _Tp& _M_val, _DifferenceType __count)\n+    : _M_val(_M_val), __count(__count)  { }\n \n     /** @brief Begin iterator. */\n     iterator\n     begin() const\n-    { return iterator(val, 0); }\n+    { return iterator(_M_val, 0); }\n \n     /** @brief End iterator. */\n     iterator\n     end() const\n-    { return iterator(val, count); }\n+    { return iterator(_M_val, __count); }\n \n   private:\n-    const T& val;\n-    difference_type count;\n+    const _Tp& _M_val;\n+    _DifferenceType __count;\n   };\n \n /** @brief Functor that does nothing */\n template<typename _ValueTp>\n-  class void_functor\n+  class _VoidFunctor\n   {\n     inline void\n-    operator()(const _ValueTp& v) const { }\n+    operator()(const _ValueTp& __v) const { }\n   };\n \n /** @brief Compute the median of three referenced elements,\n-    according to @c comp.\n-  *  @param a First iterator.\n-  *  @param b Second iterator.\n-  *  @param c Third iterator.\n-  *  @param comp Comparator.\n+    according to @__c __comp.\n+  *  @param __a First iterator.\n+  *  @param __b Second iterator.\n+  *  @param __c Third iterator.\n+  *  @param __comp Comparator.\n   */\n-template<typename RandomAccessIterator, typename Comparator>\n-  RandomAccessIterator\n-  median_of_three_iterators(RandomAccessIterator a, RandomAccessIterator b,\n-                            RandomAccessIterator c, Comparator& comp)\n+template<typename _RAIter, typename _Compare>\n+  _RAIter\n+  __median_of_three_iterators(_RAIter __a, _RAIter __b,\n+                            _RAIter __c, _Compare& __comp)\n   {\n-    if (comp(*a, *b))\n-      if (comp(*b, *c))\n-        return b;\n+    if (__comp(*__a, *__b))\n+      if (__comp(*__b, *__c))\n+        return __b;\n       else\n-        if (comp(*a, *c))\n-          return c;\n+        if (__comp(*__a, *__c))\n+          return __c;\n         else\n-          return a;\n+          return __a;\n     else\n       {\n-        // Just swap a and b.\n-        if (comp(*a, *c))\n-          return a;\n+        // Just swap __a and __b.\n+        if (__comp(*__a, *__c))\n+          return __a;\n         else\n-          if (comp(*b, *c))\n-            return c;\n+          if (__comp(*__b, *__c))\n+            return __c;\n           else\n-            return b;\n+            return __b;\n       }\n   }\n "}, {"sha": "47d21749a867d7fcb99b802374e616b7524151aa", "filename": "libstdc++-v3/include/parallel/checkers.h", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -39,115 +39,115 @@\n namespace __gnu_parallel\n {\n   /**\n-   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n-   * @param begin Begin iterator of sequence.\n-   * @param end End iterator of sequence.\n-   * @param comp Comparator.\n-   * @return @c true if sorted, @c false otherwise.\n+   * @brief Check whether @__c [__begin, @__c __end) is sorted according to @__c __comp.\n+   * @param __begin Begin iterator of sequence.\n+   * @param __end End iterator of sequence.\n+   * @param __comp Comparator.\n+   * @return @__c true if sorted, @__c false otherwise.\n    */\n-  // XXX Comparator default template argument\n-  template<typename InputIterator, typename Comparator>\n+  // XXX Compare default template argument\n+  template<typename _IIter, typename _Compare>\n     bool\n-    is_sorted(InputIterator begin, InputIterator end,\n-\t      Comparator comp\n-\t      = std::less<typename std::iterator_traits<InputIterator>::\n-\t      value_type>())\n+    __is_sorted(_IIter __begin, _IIter __end,\n+\t      _Compare __comp\n+\t      = std::less<typename std::iterator_traits<_IIter>::\n+\t      _ValueType>())\n     {\n-      if (begin == end)\n+      if (__begin == __end)\n \treturn true;\n \n-      InputIterator current(begin), recent(begin);\n+      _IIter __current(__begin), __recent(__begin);\n \n-      unsigned long long position = 1;\n-      for (current++; current != end; current++)\n+      unsigned long long __position = 1;\n+      for (__current++; __current != __end; __current++)\n \t{\n-\t  if (comp(*current, *recent))\n+\t  if (__comp(*__current, *__recent))\n \t    {\n-\t      printf(\"is_sorted: check failed before position %i.\\n\",\n-\t\t     position);\n+\t      printf(\"__is_sorted: check failed before position %__i.\\n\",\n+\t\t     __position);\n \t      return false;\n \t    }\n-\t  recent = current;\n-\t  position++;\n+\t  __recent = __current;\n+\t  __position++;\n \t}\n \n       return true;\n     }\n \n   /**\n-   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n+   * @brief Check whether @__c [__begin, @__c __end) is sorted according to @__c __comp.\n    * Prints the position in case an unordered pair is found.\n-   * @param begin Begin iterator of sequence.\n-   * @param end End iterator of sequence.\n-   * @param first_failure The first failure is returned in this variable.\n-   * @param comp Comparator.\n-   * @return @c true if sorted, @c false otherwise.\n+   * @param __begin Begin iterator of sequence.\n+   * @param __end End iterator of sequence.\n+   * @param __first_failure The first failure is returned in this variable.\n+   * @param __comp Comparator.\n+   * @return @__c true if sorted, @__c false otherwise.\n    */\n-  // XXX Comparator default template argument\n-  template<typename InputIterator, typename Comparator>\n+  // XXX Compare default template argument\n+  template<typename _IIter, typename _Compare>\n     bool\n-    is_sorted_failure(InputIterator begin, InputIterator end,\n-\t\t      InputIterator& first_failure,\n-\t\t      Comparator comp\n-\t\t      = std::less<typename std::iterator_traits<InputIterator>::\n-\t\t      value_type>())\n+    is_sorted_failure(_IIter __begin, _IIter __end,\n+\t\t      _IIter& __first_failure,\n+\t\t      _Compare __comp\n+\t\t      = std::less<typename std::iterator_traits<_IIter>::\n+\t\t      _ValueType>())\n     {\n-      if (begin == end)\n+      if (__begin == __end)\n \treturn true;\n \n-      InputIterator current(begin), recent(begin);\n+      _IIter __current(__begin), __recent(__begin);\n \n-      unsigned long long position = 1;\n-      for (current++; current != end; current++)\n+      unsigned long long __position = 1;\n+      for (__current++; __current != __end; __current++)\n \t{\n-\t  if (comp(*current, *recent))\n+\t  if (__comp(*__current, *__recent))\n \t    {\n-\t      first_failure = current;\n-\t      printf(\"is_sorted: check failed before position %lld.\\n\",\n-\t\t     position);\n+\t      __first_failure = __current;\n+\t      printf(\"__is_sorted: check failed before position %lld.\\n\",\n+\t\t     __position);\n \t      return false;\n \t    }\n-\t  recent = current;\n-\t  position++;\n+\t  __recent = __current;\n+\t  __position++;\n \t}\n \n-      first_failure = end;\n+      __first_failure = __end;\n       return true;\n     }\n \n   /**\n-   * @brief Check whether @c [begin, @c end) is sorted according to @c comp.\n+   * @brief Check whether @__c [__begin, @__c __end) is sorted according to @__c __comp.\n    * Prints all unordered pair, including the surrounding two elements.\n-   * @param begin Begin iterator of sequence.\n-   * @param end End iterator of sequence.\n-   * @param comp Comparator.\n-   * @return @c true if sorted, @c false otherwise.\n+   * @param __begin Begin iterator of sequence.\n+   * @param __end End iterator of sequence.\n+   * @param __comp Comparator.\n+   * @return @__c true if sorted, @__c false otherwise.\n    */\n-  template<typename InputIterator, typename Comparator>\n+  template<typename _IIter, typename _Compare>\n     bool\n-    // XXX Comparator default template argument\n-    is_sorted_print_failures(InputIterator begin, InputIterator end,\n-\t\t\t     Comparator comp\n+    // XXX Compare default template argument\n+    is_sorted_print_failures(_IIter __begin, _IIter __end,\n+\t\t\t     _Compare __comp\n \t\t\t     = std::less<typename std::iterator_traits\n-\t\t\t     <InputIterator>::value_type>())\n+\t\t\t     <_IIter>::value_type>())\n     {\n-      if (begin == end)\n+      if (__begin == __end)\n \treturn true;\n \n-      InputIterator recent(begin);\n-      bool ok = true;\n+      _IIter __recent(__begin);\n+      bool __ok = true;\n \n-      for (InputIterator pos(begin + 1); pos != end; pos++)\n+      for (_IIter __pos(__begin + 1); __pos != __end; __pos++)\n \t{\n-\t  if (comp(*pos, *recent))\n+\t  if (__comp(*__pos, *__recent))\n \t    {\n-\t      printf(\"%ld: %d %d %d %d\\n\", pos - begin, *(pos - 2),\n-\t\t     *(pos- 1), *pos, *(pos + 1));\n-\t      ok = false;\n+\t      printf(\"%ld: %d %d %d %d\\n\", __pos - __begin, *(__pos - 2),\n+\t\t     *(__pos- 1), *__pos, *(__pos + 1));\n+\t      __ok = false;\n \t    }\n-\t  recent = pos;\n+\t  __recent = __pos;\n \t}\n-      return ok;\n+      return __ok;\n     }\n }\n "}, {"sha": "2dc02a8898c7e47094e644a580b48636c5032602", "filename": "libstdc++-v3/include/parallel/compatibility.h", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -61,24 +61,24 @@ __attribute((dllimport)) void __attribute__((stdcall)) Sleep (unsigned long);\n namespace __gnu_parallel\n {\n #if defined(__ICC)\n-  template<typename must_be_int = int>\n-  int32 faa32(int32* x, int32 inc)\n+  template<typename _MustBeInt = int>\n+  int32 __faa32(int32* __x, int32 __inc)\n   {\n     asm volatile(\"lock xadd %0,%1\"\n-\t\t : \"=r\" (inc), \"=m\" (*x)\n-\t\t : \"0\" (inc)\n+\t\t : \"=__r\" (__inc), \"=__m\" (*__x)\n+\t\t : \"0\" (__inc)\n \t\t : \"memory\");\n-    return inc;\n+    return __inc;\n   }\n #if defined(__x86_64)\n-  template<typename must_be_int = int>\n-  int64 faa64(int64* x, int64 inc)\n+  template<typename _MustBeInt = int>\n+  int64 __faa64(int64* __x, int64 __inc)\n   {\n     asm volatile(\"lock xadd %0,%1\"\n-\t\t : \"=r\" (inc), \"=m\" (*x)\n-\t\t : \"0\" (inc)\n+\t\t : \"=__r\" (__inc), \"=__m\" (*__x)\n+\t\t : \"0\" (__inc)\n \t\t : \"memory\");\n-    return inc;\n+    return __inc;\n   }\n #endif\n #endif\n@@ -88,256 +88,256 @@ namespace __gnu_parallel\n   /** @brief Add a value to a variable, atomically.\n    *\n    *  Implementation is heavily platform-dependent.\n-   *  @param ptr Pointer to a 32-bit signed integer.\n-   *  @param addend Value to add.\n+   *  @param __ptr Pointer to a 32-bit signed integer.\n+   *  @param __addend Value to add.\n    */\n   inline int32\n-  fetch_and_add_32(volatile int32* ptr, int32 addend)\n+  __fetch_and_add_32(volatile int32* __ptr, int32 __addend)\n   {\n #if defined(__ICC)\t//x86 version\n-    return _InterlockedExchangeAdd((void*)ptr, addend);\n+    return _InterlockedExchangeAdd((void*)__ptr, __addend);\n #elif defined(__ECC)\t//IA-64 version\n-    return _InterlockedExchangeAdd((void*)ptr, addend);\n+    return _InterlockedExchangeAdd((void*)__ptr, __addend);\n #elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(ptr),\n-\t\t\t\t   addend);\n+    return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(__ptr),\n+\t\t\t\t   __addend);\n #elif defined(__GNUC__)\n-    return __sync_fetch_and_add(ptr, addend);\n+    return __sync_fetch_and_add(__ptr, __addend);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n-    volatile int32 before, after;\n+    volatile int32 __before, __after;\n     do\n       {\n-\tbefore = *ptr;\n-\tafter = before + addend;\n-      } while (atomic_cas_32((volatile unsigned int*)ptr, before,\n-\t\t\t     after) != before);\n-    return before;\n+\t__before = *__ptr;\n+\t__after = __before + __addend;\n+      } while (atomic_cas_32((volatile unsigned int*)__ptr, __before,\n+\t\t\t     __after) != __before);\n+    return __before;\n #else\t//fallback, slow\n-#pragma message(\"slow fetch_and_add_32\")\n-    int32 res;\n+#pragma message(\"slow __fetch_and_add_32\")\n+    int32 __res;\n #pragma omp critical\n     {\n-      res = *ptr;\n-      *(ptr) += addend;\n+      __res = *__ptr;\n+      *(__ptr) += __addend;\n     }\n-    return res;\n+    return __res;\n #endif\n   }\n \n   /** @brief Add a value to a variable, atomically.\n    *\n    *  Implementation is heavily platform-dependent.\n-   *  @param ptr Pointer to a 64-bit signed integer.\n-   *  @param addend Value to add.\n+   *  @param __ptr Pointer to a 64-bit signed integer.\n+   *  @param __addend Value to add.\n    */\n   inline int64\n-  fetch_and_add_64(volatile int64* ptr, int64 addend)\n+  __fetch_and_add_64(volatile int64* __ptr, int64 __addend)\n   {\n #if defined(__ICC) && defined(__x86_64)\t//x86 version\n-    return faa64<int>((int64*)ptr, addend);\n+    return __faa64<int>((int64*)__ptr, __addend);\n #elif defined(__ECC)\t//IA-64 version\n-    return _InterlockedExchangeAdd64((void*)ptr, addend);\n+    return _InterlockedExchangeAdd64((void*)__ptr, __addend);\n #elif defined(__ICL) || defined(_MSC_VER)\n #ifndef _WIN64\n     _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n     return 0;\n #else\n-    return _InterlockedExchangeAdd64(ptr, addend);\n+    return _InterlockedExchangeAdd64(__ptr, __addend);\n #endif\n #elif defined(__GNUC__) && defined(__x86_64)\n-    return __sync_fetch_and_add(ptr, addend);\n+    return __sync_fetch_and_add(__ptr, __addend);\n #elif defined(__GNUC__) && defined(__i386) &&\t\t\t\\\n   (defined(__i686) || defined(__pentium4) || defined(__athlon))\n-    return __sync_fetch_and_add(ptr, addend);\n+    return __sync_fetch_and_add(__ptr, __addend);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n-    volatile int64 before, after;\n+    volatile int64 __before, __after;\n     do\n       {\n-\tbefore = *ptr;\n-\tafter = before + addend;\n-      } while (atomic_cas_64((volatile unsigned long long*)ptr, before,\n-\t\t\t     after) != before);\n-    return before;\n+\t__before = *__ptr;\n+\t__after = __before + __addend;\n+      } while (atomic_cas_64((volatile unsigned long long*)__ptr, __before,\n+\t\t\t     __after) != __before);\n+    return __before;\n #else\t//fallback, slow\n #if defined(__GNUC__) && defined(__i386)\n-    // XXX doesn't work with -march=native\n+    // XXX doesn'__t work with -march=native\n     //#warning \"please compile with -march=i686 or better\"\n #endif\n-#pragma message(\"slow fetch_and_add_64\")\n-    int64 res;\n+#pragma message(\"slow __fetch_and_add_64\")\n+    int64 __res;\n #pragma omp critical\n     {\n-      res = *ptr;\n-      *(ptr) += addend;\n+      __res = *__ptr;\n+      *(__ptr) += __addend;\n     }\n-    return res;\n+    return __res;\n #endif\n   }\n \n   /** @brief Add a value to a variable, atomically.\n    *\n    *  Implementation is heavily platform-dependent.\n-   *  @param ptr Pointer to a signed integer.\n-   *  @param addend Value to add.\n+   *  @param __ptr Pointer to a signed integer.\n+   *  @param __addend Value to add.\n    */\n-  template<typename T>\n-  inline T\n-  fetch_and_add(volatile T* ptr, T addend)\n+  template<typename _Tp>\n+  inline _Tp\n+  __fetch_and_add(volatile _Tp* __ptr, _Tp __addend)\n   {\n-    if (sizeof(T) == sizeof(int32))\n-      return (T)fetch_and_add_32((volatile int32*) ptr, (int32)addend);\n-    else if (sizeof(T) == sizeof(int64))\n-      return (T)fetch_and_add_64((volatile int64*) ptr, (int64)addend);\n+    if (sizeof(_Tp) == sizeof(int32))\n+      return (_Tp)__fetch_and_add_32((volatile int32*) __ptr, (int32)__addend);\n+    else if (sizeof(_Tp) == sizeof(int64))\n+      return (_Tp)__fetch_and_add_64((volatile int64*) __ptr, (int64)__addend);\n     else\n       _GLIBCXX_PARALLEL_ASSERT(false);\n   }\n \n \n #if defined(__ICC)\n \n-  template<typename must_be_int = int>\n+  template<typename _MustBeInt = int>\n   inline int32\n-  cas32(volatile int32* ptr, int32 old, int32 nw)\n+  __cas32(volatile int32* __ptr, int32 __old, int32 __nw)\n   {\n-    int32 before;\n+    int32 __before;\n     __asm__ __volatile__(\"lock; cmpxchgl %1,%2\"\n-\t\t\t : \"=a\"(before)\n-\t\t\t : \"q\"(nw), \"m\"(*(volatile long long*)(ptr)), \"0\"(old)\n+\t\t\t : \"=a\"(__before)\n+\t\t\t : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)), \"0\"(__old)\n \t\t\t : \"memory\");\n-    return before;\n+    return __before;\n   }\n \n #if defined(__x86_64)\n-  template<typename must_be_int = int>\n+  template<typename _MustBeInt = int>\n   inline int64\n-  cas64(volatile int64 *ptr, int64 old, int64 nw)\n+  __cas64(volatile int64 *__ptr, int64 __old, int64 __nw)\n   {\n-    int64 before;\n+    int64 __before;\n     __asm__ __volatile__(\"lock; cmpxchgq %1,%2\"\n-\t\t\t : \"=a\"(before)\n-\t\t\t : \"q\"(nw), \"m\"(*(volatile long long*)(ptr)), \"0\"(old)\n+\t\t\t : \"=a\"(__before)\n+\t\t\t : \"q\"(__nw), \"__m\"(*(volatile long long*)(__ptr)), \"0\"(__old)\n \t\t\t : \"memory\");\n-    return before;\n+    return __before;\n   }\n #endif\n \n #endif\n \n-  /** @brief Compare @c *ptr and @c comparand. If equal, let @c\n-   * *ptr=replacement and return @c true, return @c false otherwise.\n+  /** @brief Compare @__c *__ptr and @__c __comparand. If equal, let @__c\n+   * *__ptr=__replacement and return @__c true, return @__c false otherwise.\n    *\n    *  Implementation is heavily platform-dependent.\n-   *  @param ptr Pointer to 32-bit signed integer.\n-   *  @param comparand Compare value.\n-   *  @param replacement Replacement value.\n+   *  @param __ptr Pointer to 32-bit signed integer.\n+   *  @param __comparand Compare value.\n+   *  @param __replacement Replacement value.\n    */\n   inline bool\n-  compare_and_swap_32(volatile int32* ptr, int32 comparand, int32 replacement)\n+  __compare_and_swap_32(volatile int32* __ptr, int32 __comparand, int32 __replacement)\n   {\n #if defined(__ICC)\t//x86 version\n-    return _InterlockedCompareExchange((void*)ptr, replacement,\n-\t\t\t\t       comparand) == comparand;\n+    return _InterlockedCompareExchange((void*)__ptr, __replacement,\n+\t\t\t\t       __comparand) == __comparand;\n #elif defined(__ECC)\t//IA-64 version\n-    return _InterlockedCompareExchange((void*)ptr, replacement,\n-\t\t\t\t       comparand) == comparand;\n+    return _InterlockedCompareExchange((void*)__ptr, __replacement,\n+\t\t\t\t       __comparand) == __comparand;\n #elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedCompareExchange(reinterpret_cast<volatile long*>(ptr),\n-\t\t\t\t       replacement, comparand) == comparand;\n+    return _InterlockedCompareExchange(reinterpret_cast<volatile long*>(__ptr),\n+\t\t\t\t       __replacement, __comparand) == __comparand;\n #elif defined(__GNUC__)\n-    return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n+    return __sync_bool_compare_and_swap(__ptr, __comparand, __replacement);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n-    return atomic_cas_32((volatile unsigned int*)ptr, comparand,\n-\t\t\t replacement) == comparand;\n+    return atomic_cas_32((volatile unsigned int*)__ptr, __comparand,\n+\t\t\t __replacement) == __comparand;\n #else\n-#pragma message(\"slow compare_and_swap_32\")\n-    bool res = false;\n+#pragma message(\"slow __compare_and_swap_32\")\n+    bool __res = false;\n #pragma omp critical\n     {\n-      if (*ptr == comparand)\n+      if (*__ptr == __comparand)\n \t{\n-\t  *ptr = replacement;\n-\t  res = true;\n+\t  *__ptr = __replacement;\n+\t  __res = true;\n \t}\n     }\n-    return res;\n+    return __res;\n #endif\n   }\n \n-  /** @brief Compare @c *ptr and @c comparand. If equal, let @c\n-   * *ptr=replacement and return @c true, return @c false otherwise.\n+  /** @brief Compare @__c *__ptr and @__c __comparand. If equal, let @__c\n+   * *__ptr=__replacement and return @__c true, return @__c false otherwise.\n    *\n    *  Implementation is heavily platform-dependent.\n-   *  @param ptr Pointer to 64-bit signed integer.\n-   *  @param comparand Compare value.\n-   *  @param replacement Replacement value.\n+   *  @param __ptr Pointer to 64-bit signed integer.\n+   *  @param __comparand Compare value.\n+   *  @param __replacement Replacement value.\n    */\n   inline bool\n-  compare_and_swap_64(volatile int64* ptr, int64 comparand, int64 replacement)\n+  __compare_and_swap_64(volatile int64* __ptr, int64 __comparand, int64 __replacement)\n   {\n #if defined(__ICC) && defined(__x86_64)\t//x86 version\n-    return cas64<int>(ptr, comparand, replacement) == comparand;\n+    return __cas64<int>(__ptr, __comparand, __replacement) == __comparand;\n #elif defined(__ECC)\t//IA-64 version\n-    return _InterlockedCompareExchange64((void*)ptr, replacement,\n-\t\t\t\t\t comparand) == comparand;\n+    return _InterlockedCompareExchange64((void*)__ptr, __replacement,\n+\t\t\t\t\t __comparand) == __comparand;\n #elif defined(__ICL) || defined(_MSC_VER)\n #ifndef _WIN64\n     _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n     return 0;\n #else\n-    return _InterlockedCompareExchange64(ptr, replacement,\n-\t\t\t\t\t comparand) == comparand;\n+    return _InterlockedCompareExchange64(__ptr, __replacement,\n+\t\t\t\t\t __comparand) == __comparand;\n #endif\n \n #elif defined(__GNUC__) && defined(__x86_64)\n-    return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n+    return __sync_bool_compare_and_swap(__ptr, __comparand, __replacement);\n #elif defined(__GNUC__) && defined(__i386) &&\t\t\t\\\n   (defined(__i686) || defined(__pentium4) || defined(__athlon))\n-    return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n+    return __sync_bool_compare_and_swap(__ptr, __comparand, __replacement);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n-    return atomic_cas_64((volatile unsigned long long*)ptr,\n-\t\t\t comparand, replacement) == comparand;\n+    return atomic_cas_64((volatile unsigned long long*)__ptr,\n+\t\t\t __comparand, __replacement) == __comparand;\n #else\n #if defined(__GNUC__) && defined(__i386)\n     // XXX -march=native\n     //#warning \"please compile with -march=i686 or better\"\n #endif\n-#pragma message(\"slow compare_and_swap_64\")\n-    bool res = false;\n+#pragma message(\"slow __compare_and_swap_64\")\n+    bool __res = false;\n #pragma omp critical\n     {\n-      if (*ptr == comparand)\n+      if (*__ptr == __comparand)\n \t{\n-\t  *ptr = replacement;\n-\t  res = true;\n+\t  *__ptr = __replacement;\n+\t  __res = true;\n \t}\n     }\n-    return res;\n+    return __res;\n #endif\n   }\n \n-  /** @brief Compare @c *ptr and @c comparand. If equal, let @c\n-   * *ptr=replacement and return @c true, return @c false otherwise.\n+  /** @brief Compare @__c *__ptr and @__c __comparand. If equal, let @__c\n+   * *__ptr=__replacement and return @__c true, return @__c false otherwise.\n    *\n    *  Implementation is heavily platform-dependent.\n-   *  @param ptr Pointer to signed integer.\n-   *  @param comparand Compare value.\n-   *  @param replacement Replacement value. */\n-  template<typename T>\n+   *  @param __ptr Pointer to signed integer.\n+   *  @param __comparand Compare value.\n+   *  @param __replacement Replacement value. */\n+  template<typename _Tp>\n   inline bool\n-  compare_and_swap(volatile T* ptr, T comparand, T replacement)\n+  __compare_and_swap(volatile _Tp* __ptr, _Tp __comparand, _Tp __replacement)\n   {\n-    if (sizeof(T) == sizeof(int32))\n-      return compare_and_swap_32((volatile int32*) ptr, (int32)comparand, (int32)replacement);\n-    else if (sizeof(T) == sizeof(int64))\n-      return compare_and_swap_64((volatile int64*) ptr, (int64)comparand, (int64)replacement);\n+    if (sizeof(_Tp) == sizeof(int32))\n+      return __compare_and_swap_32((volatile int32*) __ptr, (int32)__comparand, (int32)__replacement);\n+    else if (sizeof(_Tp) == sizeof(int64))\n+      return __compare_and_swap_64((volatile int64*) __ptr, (int64)__comparand, (int64)__replacement);\n     else\n       _GLIBCXX_PARALLEL_ASSERT(false);\n   }\n \n   /** @brief Yield the control to another thread, without waiting for\n       the end to the time slice. */\n   inline void\n-  yield()\n+  __yield()\n   {\n #if defined (_WIN32) && !defined (__CYGWIN__)\n     Sleep(0);"}, {"sha": "e375a94a9da9ece74f2d722d79b6b836295e4f09", "filename": "libstdc++-v3/include/parallel/compiletime_settings.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -38,15 +38,15 @@\n \n /** @def _GLIBCXX_CALL\n  *  @brief Macro to produce log message when entering a function.\n- *  @param n Input size.\n+ *  @param __n Input size.\n  *  @see _GLIBCXX_VERBOSE_LEVEL */\n #if (_GLIBCXX_VERBOSE_LEVEL == 0)\n-#define _GLIBCXX_CALL(n)\n+#define _GLIBCXX_CALL(__n)\n #endif\n #if (_GLIBCXX_VERBOSE_LEVEL == 1)\n-#define _GLIBCXX_CALL(n) \\\n-  printf(\"   %s:\\niam = %d, n = %ld, num_threads = %d\\n\", \\\n-  __PRETTY_FUNCTION__, omp_get_thread_num(), (n), get_max_threads());\n+#define _GLIBCXX_CALL(__n) \\\n+  printf(\"   %__s:\\niam = %d, __n = %ld, __num_threads = %d\\n\", \\\n+  __PRETTY_FUNCTION__, omp_get_thread_num(), (__n), __get_max_threads());\n #endif\n \n #ifndef _GLIBCXX_SCALE_DOWN_FPU\n@@ -64,12 +64,12 @@\n #ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n  *  Consider the size of the L1 cache for\n- *  __gnu_parallel::parallel_random_shuffle(). */\n+*  gnu_parallel::__parallel_random_shuffle(). */\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1 0\n #endif\n #ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n  *  Consider the size of the TLB for\n- *  __gnu_parallel::parallel_random_shuffle(). */\n+*  gnu_parallel::__parallel_random_shuffle(). */\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB 0\n #endif"}, {"sha": "11672c4579ac4eff607d2ae3a8b8f9b3ee2b75af", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -33,54 +33,54 @@\n \n namespace __gnu_parallel\n {\n-/** @brief Function to split a sequence into parts of almost equal size.\n+/** @brief function to split a sequence into parts of almost equal size.\n  *\n- *  The resulting sequence s of length num_threads+1 contains the splitting\n- *  positions when splitting the range [0,n) into parts of almost\n+ *  The resulting sequence __s of length __num_threads+1 contains the splitting\n+ *  positions when splitting the range [0,__n) into parts of almost\n  *  equal size (plus minus 1).  The first entry is 0, the last one\n- *  n. There may result empty parts.\n- *  @param n Number of elements\n- *  @param num_threads Number of parts\n- *  @param s Splitters\n- *  @returns End of splitter sequence, i. e. @c s+num_threads+1 */\n-template<typename difference_type, typename OutputIterator>\n-  OutputIterator\n-  equally_split(difference_type n, thread_index_t num_threads, OutputIterator s)\n+*  n. There may result empty parts.\n+ *  @param __n Number of elements\n+ *  @param __num_threads Number of parts\n+ *  @param __s Splitters\n+ *  @returns End of splitter sequence, i.e. @__c __s+__num_threads+1 */\n+template<typename _DifferenceType, typename _OutputIterator>\n+  _OutputIterator\n+  equally_split(_DifferenceType __n, _ThreadIndex __num_threads, _OutputIterator __s)\n   {\n-    difference_type chunk_length = n / num_threads;\n-    difference_type num_longer_chunks = n % num_threads;\n-    difference_type pos = 0;\n-    for (thread_index_t i = 0; i < num_threads; ++i)\n+    _DifferenceType __chunk_length = __n / __num_threads;\n+    _DifferenceType __num_longer_chunks = __n % __num_threads;\n+    _DifferenceType __pos = 0;\n+    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n       {\n-        *s++ = pos;\n-        pos += (i < num_longer_chunks) ? (chunk_length + 1) : chunk_length;\n+        *__s++ = __pos;\n+        __pos += (__i < __num_longer_chunks) ? (__chunk_length + 1) : __chunk_length;\n       }\n-    *s++ = n;\n-    return s;\n+    *__s++ = __n;\n+    return __s;\n   }\n \n \n-/** @brief Function to split a sequence into parts of almost equal size.\n+/** @brief function to split a sequence into parts of almost equal size.\n  *\n  *  Returns the position of the splitting point between\n- *  thread number thread_no (included) and\n- *  thread number thread_no+1 (excluded).\n- *  @param n Number of elements\n- *  @param num_threads Number of parts\n- *  @returns _SplittingAlgorithm point */\n-template<typename difference_type>\n-  difference_type\n-  equally_split_point(difference_type n,\n-                      thread_index_t num_threads,\n-                      thread_index_t thread_no)\n+ *  thread number __thread_no (included) and\n+ *  thread number __thread_no+1 (excluded).\n+ *  @param __n Number of elements\n+ *  @param __num_threads Number of parts\n+ *  @returns splitting point */\n+template<typename _DifferenceType>\n+  _DifferenceType\n+  equally_split_point(_DifferenceType __n,\n+                      _ThreadIndex __num_threads,\n+                      _ThreadIndex __thread_no)\n   {\n-    difference_type chunk_length = n / num_threads;\n-    difference_type num_longer_chunks = n % num_threads;\n-    if (thread_no < num_longer_chunks)\n-      return thread_no * (chunk_length + 1);\n+    _DifferenceType __chunk_length = __n / __num_threads;\n+    _DifferenceType __num_longer_chunks = __n % __num_threads;\n+    if (__thread_no < __num_longer_chunks)\n+      return __thread_no * (__chunk_length + 1);\n     else\n-      return num_longer_chunks * (chunk_length + 1)\n-          + (thread_no - num_longer_chunks) * chunk_length;\n+      return __num_longer_chunks * (__chunk_length + 1)\n+          + (__thread_no - __num_longer_chunks) * __chunk_length;\n   }\n }\n "}, {"sha": "077429f1688f123ec82cc0159d296b57fcfd9853", "filename": "libstdc++-v3/include/parallel/features.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -78,23 +78,23 @@\n #ifndef _GLIBCXX_TREE_INITIAL_SPLITTING\n /** @def _GLIBCXX_TREE_INITIAL_SPLITTING\n  *  @brief Include the initial splitting variant for\n- *  _Rb_tree::insert_unique(InputIterator beg, InputIterator end).\n+ *  _Rb_tree::insert_unique(_IIter beg, _IIter __end).\n  *  @see __gnu_parallel::_Rb_tree */\n #define _GLIBCXX_TREE_INITIAL_SPLITTING 1\n #endif\n \n #ifndef _GLIBCXX_TREE_DYNAMIC_BALANCING\n /** @def _GLIBCXX_TREE_DYNAMIC_BALANCING\n  *  @brief Include the dynamic balancing variant for\n- *  _Rb_tree::insert_unique(InputIterator beg, InputIterator end).\n+ *  _Rb_tree::insert_unique(_IIter beg, _IIter __end).\n  *  @see __gnu_parallel::_Rb_tree */\n #define _GLIBCXX_TREE_DYNAMIC_BALANCING 1\n #endif\n \n #ifndef _GLIBCXX_TREE_FULL_COPY\n /** @def _GLIBCXX_TREE_FULL_COPY\n  *  @brief In order to sort the input sequence of\n- *  _Rb_tree::insert_unique(InputIterator beg, InputIterator end) a\n+ *  _Rb_tree::insert_unique(_IIter beg, _IIter __end) a\n  *  full copy of the input elements is done.\n  *  @see __gnu_parallel::_Rb_tree */\n #define _GLIBCXX_TREE_FULL_COPY 1"}, {"sha": "da442f90e0a5a444feed33b3b47dea444fb23c48", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 178, "deletions": 178, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file parallel/find.h\n- *  @brief Parallel implementation base for std::find(), std::equal()\n+ *  @brief Parallel implementation __base for std::find(), std::equal()\n  *  and related functions.\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n@@ -44,117 +44,117 @@ namespace __gnu_parallel\n {\n /**\n  *  @brief Parallel std::find, switch for different algorithms.\n- *  @param begin1 Begin iterator of first sequence.\n- *  @param end1 End iterator of first sequence.\n- *  @param begin2 Begin iterator of second sequence. Must have same\n+ *  @param __begin1 Begin iterator of first sequence.\n+ *  @param __end1 End iterator of first sequence.\n+ *  @param __begin2 Begin iterator of second sequence. Must have same\n  *  length as first sequence.\n- *  @param pred Find predicate.\n- *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @param __pred Find predicate.\n+ *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n  */\n-template<typename RandomAccessIterator1,\n-\t typename RandomAccessIterator2,\n-\t typename Pred,\n-\t typename Selector>\n-  inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-                RandomAccessIterator2 begin2, Pred pred, Selector selector)\n+template<typename _RAIter1,\n+\t typename _RAIter2,\n+\t typename _Pred,\n+\t typename _Selector>\n+  inline std::pair<_RAIter1, _RAIter2>\n+  __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+                _RAIter2 __begin2, _Pred __pred, _Selector __selector)\n   {\n     switch (_Settings::get().find_algorithm)\n       {\n       case GROWING_BLOCKS:\n-        return find_template(begin1, end1, begin2, pred, selector,\n+        return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n \t\t\t     growing_blocks_tag());\n       case CONSTANT_SIZE_BLOCKS:\n-        return find_template(begin1, end1, begin2, pred, selector,\n+        return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n \t\t\t     constant_size_blocks_tag());\n       case EQUAL_SPLIT:\n-        return find_template(begin1, end1, begin2, pred, selector,\n+        return __find_template(__begin1, __end1, __begin2, __pred, __selector,\n \t\t\t     equal_split_tag());\n       default:\n         _GLIBCXX_PARALLEL_ASSERT(false);\n-        return std::make_pair(begin1, begin2);\n+        return std::make_pair(__begin1, __begin2);\n       }\n   }\n \n #if _GLIBCXX_FIND_EQUAL_SPLIT\n \n /**\n  *  @brief Parallel std::find, equal splitting variant.\n- *  @param begin1 Begin iterator of first sequence.\n- *  @param end1 End iterator of first sequence.\n- *  @param begin2 Begin iterator of second sequence. Second sequence\n+ *  @param __begin1 Begin iterator of first sequence.\n+ *  @param __end1 End iterator of first sequence.\n+ *  @param __begin2 Begin iterator of second sequence. Second __sequence\n  *  must have same length as first sequence.\n- *  @param pred Find predicate.\n- *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @param __pred Find predicate.\n+ *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n  */\n-template<typename RandomAccessIterator1,\n-\t typename RandomAccessIterator2,\n-\t typename Pred,\n-\t typename Selector>\n-  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-  find_template(RandomAccessIterator1 begin1,\n-                RandomAccessIterator1 end1,\n-                RandomAccessIterator2 begin2,\n-                Pred pred,\n-                Selector selector,\n+template<typename _RAIter1,\n+\t typename _RAIter2,\n+\t typename _Pred,\n+\t typename _Selector>\n+  std::pair<_RAIter1, _RAIter2>\n+  __find_template(_RAIter1 __begin1,\n+                _RAIter1 __end1,\n+                _RAIter2 __begin2,\n+                _Pred __pred,\n+                _Selector __selector,\n                 equal_split_tag)\n   {\n-    _GLIBCXX_CALL(end1 - begin1)\n+    _GLIBCXX_CALL(__end1 - __begin1)\n \n-    typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename traits_type::value_type value_type;\n+    typedef std::iterator_traits<_RAIter1> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename _TraitsType::value_type _ValueType;\n \n-    difference_type length = end1 - begin1;\n-    difference_type result = length;\n-    difference_type* borders;\n+    _DifferenceType __length = __end1 - __begin1;\n+    _DifferenceType __result = __length;\n+    _DifferenceType* __borders;\n \n-    omp_lock_t result_lock;\n-    omp_init_lock(&result_lock);\n+    omp_lock_t __result_lock;\n+    omp_init_lock(&__result_lock);\n \n-    thread_index_t num_threads = get_max_threads();\n-#   pragma omp parallel num_threads(num_threads)\n+    _ThreadIndex __num_threads = __get_max_threads();\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-            borders = new difference_type[num_threads + 1];\n-            equally_split(length, num_threads, borders);\n+            __num_threads = omp_get_num_threads();\n+            __borders = new _DifferenceType[__num_threads + 1];\n+            equally_split(__length, __num_threads, __borders);\n           } //single\n \n-        thread_index_t iam = omp_get_thread_num();\n-        difference_type start = borders[iam], stop = borders[iam + 1];\n+        _ThreadIndex __iam = omp_get_thread_num();\n+        _DifferenceType __start = __borders[__iam], __stop = __borders[__iam + 1];\n \n-        RandomAccessIterator1 i1 = begin1 + start;\n-        RandomAccessIterator2 i2 = begin2 + start;\n-        for (difference_type pos = start; pos < stop; ++pos)\n+        _RAIter1 __i1 = __begin1 + __start;\n+        _RAIter2 __i2 = __begin2 + __start;\n+        for (_DifferenceType __pos = __start; __pos < __stop; ++__pos)\n           {\n-            #pragma omp flush(result)\n+            #pragma omp flush(__result)\n             // Result has been set to something lower.\n-            if (result < pos)\n+            if (__result < __pos)\n               break;\n \n-            if (selector(i1, i2, pred))\n+            if (__selector(__i1, __i2, __pred))\n               {\n-                omp_set_lock(&result_lock);\n-                if (pos < result)\n-                  result = pos;\n-                omp_unset_lock(&result_lock);\n+                omp_set_lock(&__result_lock);\n+                if (__pos < __result)\n+                  __result = __pos;\n+                omp_unset_lock(&__result_lock);\n                 break;\n               }\n-            ++i1;\n-            ++i2;\n+            ++__i1;\n+            ++__i2;\n           }\n       } //parallel\n \n-    omp_destroy_lock(&result_lock);\n-    delete[] borders;\n+    omp_destroy_lock(&__result_lock);\n+    delete[] __borders;\n \n     return\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result,\n-\t\t\t\t\t\t\t      begin2 + result);\n+      std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n+\t\t\t\t\t\t\t      __begin2 + __result);\n   }\n \n #endif\n@@ -163,12 +163,12 @@ template<typename RandomAccessIterator1,\n \n /**\n  *  @brief Parallel std::find, growing block size variant.\n- *  @param begin1 Begin iterator of first sequence.\n- *  @param end1 End iterator of first sequence.\n- *  @param begin2 Begin iterator of second sequence. Second sequence\n+ *  @param __begin1 Begin iterator of first sequence.\n+ *  @param __end1 End iterator of first sequence.\n+ *  @param __begin2 Begin iterator of second sequence. Second __sequence\n  *  must have same length as first sequence.\n- *  @param pred Find predicate.\n- *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @param __pred Find predicate.\n+ *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n  *  @see __gnu_parallel::_Settings::find_sequential_search_size\n  *  @see __gnu_parallel::_Settings::find_initial_block_size\n@@ -183,105 +183,105 @@ template<typename RandomAccessIterator1,\n  *     for CSB, the blocks are allocated in a predetermined manner,\n  *     namely spacial round-robin.\n  */\n-template<typename RandomAccessIterator1,\n-\t typename RandomAccessIterator2,\n-\t typename Pred,\n-\t typename Selector>\n-  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-                RandomAccessIterator2 begin2, Pred pred, Selector selector,\n+template<typename _RAIter1,\n+\t typename _RAIter2,\n+\t typename _Pred,\n+\t typename _Selector>\n+  std::pair<_RAIter1, _RAIter2>\n+  __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+                _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n                 growing_blocks_tag)\n   {\n-    _GLIBCXX_CALL(end1 - begin1)\n+    _GLIBCXX_CALL(__end1 - __begin1)\n \n-    typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename traits_type::value_type value_type;\n+    typedef std::iterator_traits<_RAIter1> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename _TraitsType::value_type _ValueType;\n \n     const _Settings& __s = _Settings::get();\n \n-    difference_type length = end1 - begin1;\n+    _DifferenceType __length = __end1 - __begin1;\n \n-    difference_type sequential_search_size =\n-      std::min<difference_type>(length, __s.find_sequential_search_size);\n+    _DifferenceType __sequential_search_size =\n+      std::min<_DifferenceType>(__length, __s.find_sequential_search_size);\n \n     // Try it sequentially first.\n-    std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n-      selector.sequential_algorithm(\n-          begin1, begin1 + sequential_search_size, begin2, pred);\n+    std::pair<_RAIter1, _RAIter2> __find_seq_result =\n+      __selector._M_sequential_algorithm(\n+          __begin1, __begin1 + __sequential_search_size, __begin2, __pred);\n \n-    if (find_seq_result.first != (begin1 + sequential_search_size))\n-      return find_seq_result;\n+    if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n+      return __find_seq_result;\n \n     // Index of beginning of next free block (after sequential find).\n-    difference_type next_block_start = sequential_search_size;\n-    difference_type result = length;\n+    _DifferenceType __next_block_start = __sequential_search_size;\n+    _DifferenceType __result = __length;\n \n-    omp_lock_t result_lock;\n-    omp_init_lock(&result_lock);\n+    omp_lock_t __result_lock;\n+    omp_init_lock(&__result_lock);\n \n-    thread_index_t num_threads = get_max_threads();\n-#   pragma omp parallel shared(result) num_threads(num_threads)\n+    _ThreadIndex __num_threads = __get_max_threads();\n+#   pragma omp parallel shared(__result) num_threads(__num_threads)\n       {\n #       pragma omp single\n-          num_threads = omp_get_num_threads();\n+          __num_threads = omp_get_num_threads();\n \n-        // Not within first k elements -> start parallel.\n-        thread_index_t iam = omp_get_thread_num();\n+        // Not within first __k __elements -> start parallel.\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n-        difference_type block_size = __s.find_initial_block_size;\n-        difference_type start =\n-            fetch_and_add<difference_type>(&next_block_start, block_size);\n+        _DifferenceType __block_size = __s.find_initial_block_size;\n+        _DifferenceType __start =\n+            __fetch_and_add<_DifferenceType>(&__next_block_start, __block_size);\n \n         // Get new block, update pointer to next block.\n-        difference_type stop =\n-            std::min<difference_type>(length, start + block_size);\n+        _DifferenceType __stop =\n+            std::min<_DifferenceType>(__length, __start + __block_size);\n \n-        std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n+        std::pair<_RAIter1, _RAIter2> __local_result;\n \n-        while (start < length)\n+        while (__start < __length)\n           {\n-#           pragma omp flush(result)\n+#           pragma omp flush(__result)\n             // Get new value of result.\n-            if (result < start)\n+            if (__result < __start)\n               {\n                 // No chance to find first element.\n                 break;\n               }\n \n-            local_result = selector.sequential_algorithm(\n-                begin1 + start, begin1 + stop, begin2 + start, pred);\n-            if (local_result.first != (begin1 + stop))\n+            __local_result = __selector._M_sequential_algorithm(\n+                __begin1 + __start, __begin1 + __stop, __begin2 + __start, __pred);\n+            if (__local_result.first != (__begin1 + __stop))\n               {\n-                omp_set_lock(&result_lock);\n-                if ((local_result.first - begin1) < result)\n+                omp_set_lock(&__result_lock);\n+                if ((__local_result.first - __begin1) < __result)\n                   {\n-                    result = local_result.first - begin1;\n+                    __result = __local_result.first - __begin1;\n \n                     // Result cannot be in future blocks, stop algorithm.\n-                    fetch_and_add<difference_type>(&next_block_start, length);\n+                    __fetch_and_add<_DifferenceType>(&__next_block_start, __length);\n                   }\n-                  omp_unset_lock(&result_lock);\n+                  omp_unset_lock(&__result_lock);\n               }\n \n-            block_size =\n-\t      std::min<difference_type>(block_size * __s.find_increasing_factor,\n+            __block_size =\n+\t      std::min<_DifferenceType>(__block_size * __s.find_increasing_factor,\n \t\t\t\t\t__s.find_maximum_block_size);\n \n             // Get new block, update pointer to next block.\n-            start =\n-\t      fetch_and_add<difference_type>(&next_block_start, block_size);\n-            stop = ((length < (start + block_size))\n-\t\t    ? length : (start + block_size));\n+            __start =\n+\t      __fetch_and_add<_DifferenceType>(&__next_block_start, __block_size);\n+            __stop = ((__length < (__start + __block_size))\n+\t\t    ? __length : (__start + __block_size));\n           }\n       } //parallel\n \n-    omp_destroy_lock(&result_lock);\n+    omp_destroy_lock(&__result_lock);\n \n     // Return iterator on found element.\n     return\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result,\n-\t\t\t\t\t\t\t      begin2 + result);\n+      std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n+\t\t\t\t\t\t\t      __begin2 + __result);\n   }\n \n #endif\n@@ -290,12 +290,12 @@ template<typename RandomAccessIterator1,\n \n /**\n  *   @brief Parallel std::find, constant block size variant.\n- *  @param begin1 Begin iterator of first sequence.\n- *  @param end1 End iterator of first sequence.\n- *  @param begin2 Begin iterator of second sequence. Second sequence\n+ *  @param __begin1 Begin iterator of first sequence.\n+ *  @param __end1 End iterator of first sequence.\n+ *  @param __begin2 Begin iterator of second sequence. Second __sequence\n  *  must have same length as first sequence.\n- *  @param pred Find predicate.\n- *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @param __pred Find predicate.\n+ *  @param __selector _Functionality (e. g. std::find_if (), std::equal(),...)\n  *  @return Place of finding in both sequences.\n  *  @see __gnu_parallel::_Settings::find_sequential_search_size\n  *  @see __gnu_parallel::_Settings::find_block_size\n@@ -306,94 +306,94 @@ template<typename RandomAccessIterator1,\n  *  blocks are allocated in a predetermined manner, namely spacial\n  *  round-robin.\n  */\n-template<typename RandomAccessIterator1,\n-\t typename RandomAccessIterator2,\n-\t typename Pred,\n-\t typename Selector>\n-  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-                RandomAccessIterator2 begin2, Pred pred, Selector selector,\n+template<typename _RAIter1,\n+\t typename _RAIter2,\n+\t typename _Pred,\n+\t typename _Selector>\n+  std::pair<_RAIter1, _RAIter2>\n+  __find_template(_RAIter1 __begin1, _RAIter1 __end1,\n+                _RAIter2 __begin2, _Pred __pred, _Selector __selector,\n                 constant_size_blocks_tag)\n   {\n-    _GLIBCXX_CALL(end1 - begin1)\n-    typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename traits_type::value_type value_type;\n+    _GLIBCXX_CALL(__end1 - __begin1)\n+    typedef std::iterator_traits<_RAIter1> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename _TraitsType::value_type _ValueType;\n \n     const _Settings& __s = _Settings::get();\n \n-    difference_type length = end1 - begin1;\n+    _DifferenceType __length = __end1 - __begin1;\n \n-    difference_type sequential_search_size = std::min<difference_type>(\n-        length, __s.find_sequential_search_size);\n+    _DifferenceType __sequential_search_size = std::min<_DifferenceType>(\n+        __length, __s.find_sequential_search_size);\n \n     // Try it sequentially first.\n-    std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n-      selector.sequential_algorithm(begin1, begin1 + sequential_search_size,\n-                                    begin2, pred);\n+    std::pair<_RAIter1, _RAIter2> __find_seq_result =\n+      __selector._M_sequential_algorithm(__begin1, __begin1 + __sequential_search_size,\n+                                    __begin2, __pred);\n \n-    if (find_seq_result.first != (begin1 + sequential_search_size))\n-      return find_seq_result;\n+    if (__find_seq_result.first != (__begin1 + __sequential_search_size))\n+      return __find_seq_result;\n \n-    difference_type result = length;\n-    omp_lock_t result_lock;\n-    omp_init_lock(&result_lock);\n+    _DifferenceType __result = __length;\n+    omp_lock_t __result_lock;\n+    omp_init_lock(&__result_lock);\n \n-    // Not within first sequential_search_size elements -> start parallel.\n+    // Not within first __sequential_search_size elements -> start parallel.\n \n-    thread_index_t num_threads = get_max_threads();\n-#   pragma omp parallel shared(result) num_threads(num_threads)\n+    _ThreadIndex __num_threads = __get_max_threads();\n+#   pragma omp parallel shared(__result) num_threads(__num_threads)\n       {\n #       pragma omp single\n-          num_threads = omp_get_num_threads();\n+          __num_threads = omp_get_num_threads();\n \n-        thread_index_t iam = omp_get_thread_num();\n-        difference_type block_size = __s.find_initial_block_size;\n+        _ThreadIndex __iam = omp_get_thread_num();\n+        _DifferenceType __block_size = __s.find_initial_block_size;\n \n         // First element of thread's current iteration.\n-        difference_type iteration_start = sequential_search_size;\n+        _DifferenceType __iteration_start = __sequential_search_size;\n \n         // Where to work (initialization).\n-        difference_type start = iteration_start + iam * block_size;\n-        difference_type stop =\n-            std::min<difference_type>(length, start + block_size);\n+        _DifferenceType __start = __iteration_start + __iam * __block_size;\n+        _DifferenceType __stop =\n+            std::min<_DifferenceType>(__length, __start + __block_size);\n \n-        std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n+        std::pair<_RAIter1, _RAIter2> __local_result;\n \n-        while (start < length)\n+        while (__start < __length)\n           {\n             // Get new value of result.\n-#           pragma omp flush(result)\n+#           pragma omp flush(__result)\n             // No chance to find first element.\n-            if (result < start)\n+            if (__result < __start)\n               break;\n-            local_result = selector.sequential_algorithm(\n-                begin1 + start, begin1 + stop,\n-                begin2 + start, pred);\n-            if (local_result.first != (begin1 + stop))\n+            __local_result = __selector._M_sequential_algorithm(\n+                __begin1 + __start, __begin1 + __stop,\n+                __begin2 + __start, __pred);\n+            if (__local_result.first != (__begin1 + __stop))\n               {\n-                omp_set_lock(&result_lock);\n-                if ((local_result.first - begin1) < result)\n-                  result = local_result.first - begin1;\n-                omp_unset_lock(&result_lock);\n+                omp_set_lock(&__result_lock);\n+                if ((__local_result.first - __begin1) < __result)\n+                  __result = __local_result.first - __begin1;\n+                omp_unset_lock(&__result_lock);\n                 // Will not find better value in its interval.\n                 break;\n               }\n \n-            iteration_start += num_threads * block_size;\n+            __iteration_start += __num_threads * __block_size;\n \n             // Where to work.\n-            start = iteration_start + iam * block_size;\n-            stop = std::min<difference_type>(length, start + block_size);\n+            __start = __iteration_start + __iam * __block_size;\n+            __stop = std::min<_DifferenceType>(__length, __start + __block_size);\n           }\n       } //parallel\n \n-    omp_destroy_lock(&result_lock);\n+    omp_destroy_lock(&__result_lock);\n \n     // Return iterator on found element.\n     return\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result,\n-\t\t\t\t\t\t\t      begin2 + result);\n+      std::pair<_RAIter1, _RAIter2>(__begin1 + __result,\n+\t\t\t\t\t\t\t      __begin2 + __result);\n   }\n #endif\n } // end namespace"}, {"sha": "8f6db75cb6c9ba2bcd083b968cc139409979c5c1", "filename": "libstdc++-v3/include/parallel/find_selectors.h", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind_selectors.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file parallel/find_selectors.h\n- *  @brief Function objects representing different tasks to be plugged\n+ *  @brief _Function objects representing different tasks to be plugged\n  *  into the parallel find algorithm.\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n@@ -39,153 +39,153 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Base class of all __gnu_parallel::find_template selectors. */\n-  struct generic_find_selector\n+  /** @brief Base class of all __gnu_parallel::__find_template selectors. */\n+  struct __generic_find_selector\n   { };\n \n   /** \n    *  @brief Test predicate on a single element, used for std::find()\n    *  and std::find_if ().\n    */\n-  struct find_if_selector : public generic_find_selector\n+  struct __find_if_selector : public __generic_find_selector\n   {\n-    /** @brief Test on one position.\n-     * @param i1 Iterator on first sequence.\n-     * @param i2 Iterator on second sequence (unused).\n-     * @param pred Find predicate.\n+    /** @brief Test on one __position.\n+     * @param __i1 _Iterator on first sequence.\n+     * @param __i2 _Iterator on second sequence (unused).\n+     * @param __pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n       bool \n-      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n-      { return pred(*i1); }\n+      operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n+      { return __pred(*__i1); }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n-     *  @param begin1 Begin iterator of first sequence.\n-     *  @param end1 End iterator of first sequence.\n-     *  @param begin2 Begin iterator of second sequence.\n-     *  @param pred Find predicate.\n+     *  @param __begin1 Begin iterator of first sequence.\n+     *  @param __end1 End iterator of first sequence.\n+     *  @param __begin2 Begin iterator of second sequence.\n+     *  @param __pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2> \n-      sequential_algorithm(RandomAccessIterator1 begin1,\n-\t\t\t   RandomAccessIterator1 end1,\n-\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n-      { return std::make_pair(find_if(begin1, end1, pred,\n-\t\t\t\t      sequential_tag()), begin2); }\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n+      std::pair<_RAIter1, _RAIter2> \n+      _M_sequential_algorithm(_RAIter1 __begin1,\n+\t\t\t   _RAIter1 __end1,\n+\t\t\t   _RAIter2 __begin2, _Pred __pred)\n+      { return std::make_pair(find_if(__begin1, __end1, __pred,\n+\t\t\t\t      sequential_tag()), __begin2); }\n   };\n \n-  /** @brief Test predicate on two adjacent elements. */\n-  struct adjacent_find_selector : public generic_find_selector\n+  /** @brief Test predicate on two adjacent __elements. */\n+  struct __adjacent_find_selector : public __generic_find_selector\n   {\n-    /** @brief Test on one position.\n-     *  @param i1 Iterator on first sequence.\n-     *  @param i2 Iterator on second sequence (unused).\n-     *  @param pred Find predicate.\n+    /** @brief Test on one __position.\n+     *  @param __i1 _Iterator on first sequence.\n+     *  @param __i2 _Iterator on second sequence (unused).\n+     *  @param __pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n       bool \n-      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+      operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       {\n \t// Passed end iterator is one short.\n-\treturn pred(*i1, *(i1 + 1));\n+\treturn __pred(*__i1, *(__i1 + 1));\n       }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n-     *  @param begin1 Begin iterator of first sequence.\n-     *  @param end1 End iterator of first sequence.\n-     *  @param begin2 Begin iterator of second sequence.\n-     *  @param pred Find predicate.\n+     *  @param __begin1 Begin iterator of first sequence.\n+     *  @param __end1 End iterator of first sequence.\n+     *  @param __begin2 Begin iterator of second sequence.\n+     *  @param __pred Find predicate.\n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-      sequential_algorithm(RandomAccessIterator1 begin1,\n-\t\t\t   RandomAccessIterator1 end1,\n-\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n+      std::pair<_RAIter1, _RAIter2>\n+      _M_sequential_algorithm(_RAIter1 __begin1,\n+\t\t\t   _RAIter1 __end1,\n+\t\t\t   _RAIter2 __begin2, _Pred __pred)\n       {\n \t// Passed end iterator is one short.\n-\tRandomAccessIterator1 spot = adjacent_find(begin1, end1 + 1,\n-\t\t\t\t\t\t   pred, sequential_tag());\n-\tif (spot == (end1 + 1))\n-\t  spot = end1;\n-\treturn std::make_pair(spot, begin2);\n+\t_RAIter1 spot = adjacent_find(__begin1, __end1 + 1,\n+\t\t\t\t\t\t   __pred, sequential_tag());\n+\tif (spot == (__end1 + 1))\n+\t  spot = __end1;\n+\treturn std::make_pair(spot, __begin2);\n       }\n   };\n \n   /** @brief Test inverted predicate on a single element. */\n-  struct mismatch_selector : public generic_find_selector\n+  struct __mismatch_selector : public __generic_find_selector\n   {\n     /** \n-     *  @brief Test on one position.\n-     *  @param i1 Iterator on first sequence.\n-     *  @param i2 Iterator on second sequence (unused).\n-     *  @param pred Find predicate. \n+     *  @brief Test on one __position.\n+     *  @param __i1 _Iterator on first sequence.\n+     *  @param __i2 _Iterator on second sequence (unused).\n+     *  @param __pred Find predicate. \n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n       bool \n-      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n-      { return !pred(*i1, *i2); }\n+      operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n+      { return !__pred(*__i1, *__i2); }\n \n     /** \n      *  @brief Corresponding sequential algorithm on a sequence.\n-     *  @param begin1 Begin iterator of first sequence.\n-     *  @param end1 End iterator of first sequence.\n-     *  @param begin2 Begin iterator of second sequence.\n-     *  @param pred Find predicate. \n+     *  @param __begin1 Begin iterator of first sequence.\n+     *  @param __end1 End iterator of first sequence.\n+     *  @param __begin2 Begin iterator of second sequence.\n+     *  @param __pred Find predicate. \n      */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-      sequential_algorithm(RandomAccessIterator1 begin1,\n-\t\t\t   RandomAccessIterator1 end1,\n-\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n-      { return mismatch(begin1, end1, begin2, pred, sequential_tag()); }\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n+      std::pair<_RAIter1, _RAIter2>\n+      _M_sequential_algorithm(_RAIter1 __begin1,\n+\t\t\t   _RAIter1 __end1,\n+\t\t\t   _RAIter2 __begin2, _Pred __pred)\n+      { return mismatch(__begin1, __end1, __begin2, __pred, sequential_tag()); }\n   };\n \n \n-  /** @brief Test predicate on several elements. */\n-  template<typename ForwardIterator>\n-  struct find_first_of_selector : public generic_find_selector\n+  /** @brief Test predicate on several __elements. */\n+  template<typename _ForwardIterator>\n+  struct __find_first_of_selector : public __generic_find_selector\n   {\n-    ForwardIterator begin;\n-    ForwardIterator end;\n-\n-    explicit find_first_of_selector(ForwardIterator begin, ForwardIterator end)\n-    : begin(begin), end(end) { }\n-\n-    /** @brief Test on one position.\n-     *  @param i1 Iterator on first sequence.\n-     *  @param i2 Iterator on second sequence (unused).\n-     *  @param pred Find predicate. */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n+    _ForwardIterator __begin;\n+    _ForwardIterator __end;\n+\n+    explicit __find_first_of_selector(_ForwardIterator __begin, _ForwardIterator __end)\n+    : __begin(__begin), __end(__end) { }\n+\n+    /** @brief Test on one __position.\n+     *  @param __i1 _Iterator on first sequence.\n+     *  @param __i2 _Iterator on second sequence (unused).\n+     *  @param __pred Find predicate. */\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n       bool \n-      operator()(RandomAccessIterator1 i1, RandomAccessIterator2 i2, Pred pred)\n+      operator()(_RAIter1 __i1, _RAIter2 __i2, _Pred __pred)\n       {\n-\tfor (ForwardIterator pos_in_candidates = begin;\n-\t     pos_in_candidates != end; ++pos_in_candidates)\n-\t  if (pred(*i1, *pos_in_candidates))\n+\tfor (_ForwardIterator __pos_in_candidates = __begin;\n+\t     __pos_in_candidates != __end; ++__pos_in_candidates)\n+\t  if (__pred(*__i1, *__pos_in_candidates))\n \t    return true;\n \treturn false;\n       }\n \n     /** @brief Corresponding sequential algorithm on a sequence.\n-     *  @param begin1 Begin iterator of first sequence.\n-     *  @param end1 End iterator of first sequence.\n-     *  @param begin2 Begin iterator of second sequence.\n-     *  @param pred Find predicate. */\n-    template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t     typename Pred>\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-      sequential_algorithm(RandomAccessIterator1 begin1,\n-\t\t\t   RandomAccessIterator1 end1,\n-\t\t\t   RandomAccessIterator2 begin2, Pred pred)\n-      { return std::make_pair(find_first_of(begin1, end1, begin, end, pred,\n-\t\t\t\t\t    sequential_tag()), begin2); }\n+     *  @param __begin1 Begin iterator of first sequence.\n+     *  @param __end1 End iterator of first sequence.\n+     *  @param __begin2 Begin iterator of second sequence.\n+     *  @param __pred Find predicate. */\n+    template<typename _RAIter1, typename _RAIter2,\n+\t     typename _Pred>\n+      std::pair<_RAIter1, _RAIter2>\n+      _M_sequential_algorithm(_RAIter1 __begin1,\n+\t\t\t   _RAIter1 __end1,\n+\t\t\t   _RAIter2 __begin2, _Pred __pred)\n+      { return std::make_pair(find_first_of(__begin1, __end1, __begin, __end, __pred,\n+\t\t\t\t\t    sequential_tag()), __begin2); }\n   };\n }\n "}, {"sha": "77162ed07c632bf9ad4cab3511881ec2703ae3a4", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -42,55 +42,55 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Chose the desired algorithm by evaluating @c parallelism_tag.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param user_op A user-specified functor (comparator, predicate,\n+  /** @brief Chose the desired algorithm by evaluating @__c __parallelism_tag.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __user_op A user-specified functor (comparator, predicate,\n    *  associative operator,...)\n-   *  @param functionality functor to \"process\" an element with\n-   *  user_op (depends on desired functionality, e. g. accumulate,\n+   *  @param __functionality functor to \"process\" an element with\n+   *  __user_op (depends on desired functionality, e. g. accumulate,\n    *  for_each,...\n-   *  @param reduction Reduction functor.\n-   *  @param reduction_start Initial value for reduction.\n-   *  @param output Output iterator.\n-   *  @param bound Maximum number of elements processed.\n-   *  @param parallelism_tag Parallelization method */\n-  template<typename InputIterator, typename UserOp,\n-\t   typename Functionality, typename Red, typename Result>\n-    UserOp\n-    for_each_template_random_access(InputIterator begin, InputIterator end,\n-\t\t\t\t    UserOp user_op,\n-\t\t\t\t    Functionality& functionality,\n-\t\t\t\t    Red reduction, Result reduction_start,\n-\t\t\t\t    Result& output, typename\n-\t\t\t\t    std::iterator_traits<InputIterator>::\n-\t\t\t\t    difference_type bound,\n-\t\t\t\t    _Parallelism parallelism_tag)\n+   *  @param __reduction Reduction functor.\n+   *  @param __reduction_start Initial value for reduction.\n+   *  @param __output Output iterator.\n+   *  @param __bound Maximum number of elements processed.\n+   *  @param __parallelism_tag Parallelization method */\n+  template<typename _IIter, typename _UserOp,\n+\t   typename _Functionality, typename _Red, typename _Result>\n+    _UserOp\n+    __for_each_template_random_access(_IIter __begin, _IIter __end,\n+\t\t\t\t    _UserOp __user_op,\n+\t\t\t\t    _Functionality& __functionality,\n+\t\t\t\t    _Red __reduction, _Result __reduction_start,\n+\t\t\t\t    _Result& __output, typename\n+\t\t\t\t    std::iterator_traits<_IIter>::\n+\t\t\t\t    difference_type __bound,\n+\t\t\t\t    _Parallelism __parallelism_tag)\n     {\n-      if (parallelism_tag == parallel_unbalanced)\n-\treturn for_each_template_random_access_ed(begin, end, user_op,\n-\t\t\t\t\t\t  functionality, reduction,\n-\t\t\t\t\t\t  reduction_start,\n-\t\t\t\t\t\t  output, bound);\n-      else if (parallelism_tag == parallel_omp_loop)\n-\treturn for_each_template_random_access_omp_loop(begin, end, user_op,\n-\t\t\t\t\t\t\tfunctionality,\n-\t\t\t\t\t\t\treduction,\n-\t\t\t\t\t\t\treduction_start,\n-\t\t\t\t\t\t\toutput, bound);\n-      else if (parallelism_tag == parallel_omp_loop_static)\n-\treturn for_each_template_random_access_omp_loop(begin, end, user_op,\n-\t\t\t\t\t\t\tfunctionality,\n-\t\t\t\t\t\t\treduction,\n-\t\t\t\t\t\t\treduction_start,\n-\t\t\t\t\t\t\toutput, bound);\n+      if (__parallelism_tag == parallel_unbalanced)\n+\treturn for_each_template_random_access_ed(__begin, __end, __user_op,\n+\t\t\t\t\t\t  __functionality, __reduction,\n+\t\t\t\t\t\t  __reduction_start,\n+\t\t\t\t\t\t  __output, __bound);\n+      else if (__parallelism_tag == parallel_omp_loop)\n+\treturn for_each_template_random_access_omp_loop(__begin, __end, __user_op,\n+\t\t\t\t\t\t\t__functionality,\n+\t\t\t\t\t\t\t__reduction,\n+\t\t\t\t\t\t\t__reduction_start,\n+\t\t\t\t\t\t\t__output, __bound);\n+      else if (__parallelism_tag == parallel_omp_loop_static)\n+\treturn for_each_template_random_access_omp_loop(__begin, __end, __user_op,\n+\t\t\t\t\t\t\t__functionality,\n+\t\t\t\t\t\t\t__reduction,\n+\t\t\t\t\t\t\t__reduction_start,\n+\t\t\t\t\t\t\t__output, __bound);\n       else\t//e. g. parallel_balanced\n-\treturn for_each_template_random_access_workstealing(begin, end,\n-\t\t\t\t\t\t\t    user_op,\n-\t\t\t\t\t\t\t    functionality,\n-\t\t\t\t\t\t\t    reduction,\n-\t\t\t\t\t\t\t    reduction_start,\n-\t\t\t\t\t\t\t    output, bound);\n+\treturn for_each_template_random_access_workstealing(__begin, __end,\n+\t\t\t\t\t\t\t    __user_op,\n+\t\t\t\t\t\t\t    __functionality,\n+\t\t\t\t\t\t\t    __reduction,\n+\t\t\t\t\t\t\t    __reduction_start,\n+\t\t\t\t\t\t\t    __output, __bound);\n   }\n }\n "}, {"sha": "ed8728dc340fda5dd6508df03a46bf6e682db9ea", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -38,192 +38,192 @@\n namespace __gnu_parallel\n {\n \n-  /** @brief Generic selector for embarrassingly parallel functions. */\n-  template<typename It>\n-  struct generic_for_each_selector\n+  /** @brief Generic __selector for embarrassingly parallel functions. */\n+  template<typename _It>\n+  struct __generic_for_each_selector\n   {\n-    /** @brief Iterator on last element processed; needed for some\n+    /** @brief _Iterator on last element processed; needed for some\n      *  algorithms (e. g. std::transform()).\n      */\n-    It finish_iterator;\n+    _It finish_iterator;\n   };\n \n \n   /** @brief std::for_each() selector. */\n-  template<typename It>\n-    struct for_each_selector : public generic_for_each_selector<It>\n+  template<typename _It>\n+    struct __for_each_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator.\n-       *  @param i Iterator referencing object. */\n-      template<typename Op>\n+       *  @param __o Operator.\n+       *  @param __i iterator referencing object. */\n+      template<typename _Op>\n         bool\n-        operator()(Op& o, It i)\n+        operator()(_Op& __o, _It __i)\n \t{\n-\t  o(*i);\n+\t  __o(*__i);\n \t  return true;\n \t}\n     };\n \n   /** @brief std::generate() selector. */\n-  template<typename It>\n-    struct generate_selector : public generic_for_each_selector<It>\n+  template<typename _It>\n+    struct __generate_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator.\n-       *  @param i Iterator referencing object. */\n-      template<typename Op>\n+       *  @param __o Operator.\n+       *  @param __i iterator referencing object. */\n+      template<typename _Op>\n         bool\n-        operator()(Op& o, It i)\n+        operator()(_Op& __o, _It __i)\n         {\n-\t  *i = o();\n+\t  *__i = __o();\n \t  return true;\n \t}\n     };\n \n   /** @brief std::fill() selector. */\n-  template<typename It>\n-    struct fill_selector : public generic_for_each_selector<It>\n+  template<typename _It>\n+    struct __fill_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param v Current value.\n-       *  @param i Iterator referencing object. */\n+       *  @param __v Current value.\n+       *  @param __i iterator referencing object. */\n       template<typename Val>\n         bool\n-        operator()(Val& v, It i)\n+        operator()(Val& __v, _It __i)\n \t{\n-\t  *i = v;\n+\t  *__i = __v;\n \t  return true;\n \t}\n     };\n \n-  /** @brief std::transform() selector, one input sequence variant. */\n-  template<typename It>\n-    struct transform1_selector : public generic_for_each_selector<It>\n+  /** @brief std::transform() __selector, one input sequence variant. */\n+  template<typename _It>\n+    struct __transform1_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator.\n-       *  @param i Iterator referencing object. */\n-      template<typename Op>\n+       *  @param __o Operator.\n+       *  @param __i iterator referencing object. */\n+      template<typename _Op>\n         bool\n-        operator()(Op& o, It i)\n+        operator()(_Op& __o, _It __i)\n \t{\n-\t  *i.second = o(*i.first);\n+\t  *__i.second = __o(*__i.first);\n \t  return true;\n \t}\n     };\n \n-  /** @brief std::transform() selector, two input sequences variant. */\n-  template<typename It>\n-    struct transform2_selector : public generic_for_each_selector<It>\n+  /** @brief std::transform() __selector, two input sequences variant. */\n+  template<typename _It>\n+    struct __transform2_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator.\n-       *  @param i Iterator referencing object. */\n-      template<typename Op>\n+       *  @param __o Operator.\n+       *  @param __i iterator referencing object. */\n+      template<typename _Op>\n         bool\n-        operator()(Op& o, It i)\n+        operator()(_Op& __o, _It __i)\n \t{\n-\t  *i.third = o(*i.first, *i.second);\n+\t  *__i.__third = __o(*__i.__first, *__i.__second);\n \t  return true;\n \t}\n     };\n \n   /** @brief std::replace() selector. */\n-  template<typename It, typename T>\n-    struct replace_selector : public generic_for_each_selector<It>\n+  template<typename _It, typename _Tp>\n+    struct __replace_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Value to replace with. */\n-      const T& new_val;\n+      const _Tp& __new_val;\n \n       /** @brief Constructor\n-       *  @param new_val Value to replace with. */\n+       *  @param __new_val Value to replace with. */\n       explicit\n-      replace_selector(const T &new_val) : new_val(new_val) {}\n+      __replace_selector(const _Tp &__new_val) : __new_val(__new_val) {}\n \n       /** @brief Functor execution.\n-       *  @param v Current value.\n-       *  @param i Iterator referencing object. */\n+       *  @param __v Current value.\n+       *  @param __i iterator referencing object. */\n       bool\n-      operator()(T& v, It i)\n+      operator()(_Tp& __v, _It __i)\n       {\n-\tif (*i == v)\n-\t  *i = new_val;\n+\tif (*__i == __v)\n+\t  *__i = __new_val;\n \treturn true;\n       }\n     };\n \n   /** @brief std::replace() selector. */\n-  template<typename It, typename Op, typename T>\n-    struct replace_if_selector : public generic_for_each_selector<It>\n+  template<typename _It, typename _Op, typename _Tp>\n+    struct __replace_if_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Value to replace with. */\n-      const T& new_val;\n+      const _Tp& __new_val;\n \n       /** @brief Constructor.\n-       *  @param new_val Value to replace with. */\n+       *  @param __new_val Value to replace with. */\n       explicit\n-      replace_if_selector(const T &new_val) : new_val(new_val) { }\n+      __replace_if_selector(const _Tp &__new_val) : __new_val(__new_val) { }\n \n       /** @brief Functor execution.\n-       *  @param o Operator.\n-       *  @param i Iterator referencing object. */\n+       *  @param __o Operator.\n+       *  @param __i iterator referencing object. */\n       bool\n-      operator()(Op& o, It i)\n+      operator()(_Op& __o, _It __i)\n       {\n-\tif (o(*i))\n-\t  *i = new_val;\n+\tif (__o(*__i))\n+\t  *__i = __new_val;\n \treturn true;\n       }\n     };\n \n   /** @brief std::count() selector. */\n-  template<typename It, typename Diff>\n-    struct count_selector : public generic_for_each_selector<It>\n+  template<typename _It, typename _Diff>\n+    struct __count_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param v Current value.\n-       *  @param i Iterator referencing object.\n+       *  @param __v Current value.\n+       *  @param __i iterator referencing object.\n        *  @return 1 if count, 0 if does not count. */\n       template<typename Val>\n-        Diff\n-        operator()(Val& v, It i)\n-\t{ return (v == *i) ? 1 : 0; }\n+        _Diff\n+        operator()(Val& __v, _It __i)\n+\t{ return (__v == *__i) ? 1 : 0; }\n     };\n \n   /** @brief std::count_if () selector. */\n-  template<typename It, typename Diff>\n-    struct count_if_selector : public generic_for_each_selector<It>\n+  template<typename _It, typename _Diff>\n+    struct __count_if_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator.\n-       *  @param i Iterator referencing object.\n+       *  @param __o Operator.\n+       *  @param __i iterator referencing object.\n        *  @return 1 if count, 0 if does not count. */\n-      template<typename Op>\n-        Diff\n-        operator()(Op& o, It i)\n-\t{ return (o(*i)) ? 1 : 0; }\n+      template<typename _Op>\n+        _Diff\n+        operator()(_Op& __o, _It __i)\n+\t{ return (__o(*__i)) ? 1 : 0; }\n     };\n \n   /** @brief std::accumulate() selector. */\n-  template<typename It>\n-    struct accumulate_selector : public generic_for_each_selector<It>\n+  template<typename _It>\n+    struct __accumulate_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator (unused).\n-       *  @param i Iterator referencing object.\n+       *  @param __o Operator (unused).\n+       *  @param __i iterator referencing object.\n        *  @return The current value. */\n-      template<typename Op>\n-        typename std::iterator_traits<It>::value_type operator()(Op o, It i)\n-\t{ return *i; }\n+      template<typename _Op>\n+        typename std::iterator_traits<_It>::value_type operator()(_Op __o, _It __i)\n+\t{ return *__i; }\n     };\n \n   /** @brief std::inner_product() selector. */\n-  template<typename It, typename It2, typename T>\n-    struct inner_product_selector : public generic_for_each_selector<It>\n+  template<typename _It, typename It2, typename _Tp>\n+    struct __inner_product_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Begin iterator of first sequence. */\n-      It begin1_iterator;\n+      _It __begin1_iterator;\n \n       /** @brief Begin iterator of second sequence. */\n       It2 begin2_iterator;\n@@ -232,128 +232,128 @@ namespace __gnu_parallel\n        *  @param b1 Begin iterator of first sequence.\n        *  @param b2 Begin iterator of second sequence. */\n       explicit\n-      inner_product_selector(It b1, It2 b2)\n-      : begin1_iterator(b1), begin2_iterator(b2) { }\n+      __inner_product_selector(_It b1, It2 b2)\n+      : __begin1_iterator(b1), begin2_iterator(b2) { }\n \n       /** @brief Functor execution.\n-       *  @param mult Multiplication functor.\n-       *  @param current Iterator referencing object.\n-       *  @return Inner product elemental result. */\n-      template<typename Op>\n-        T\n-        operator()(Op mult, It current)\n+       *  @param __mult Multiplication functor.\n+       *  @param __current iterator referencing object.\n+       *  @return Inner product elemental __result. */\n+      template<typename _Op>\n+        _Tp\n+        operator()(_Op __mult, _It __current)\n \t{\n-\t  typename std::iterator_traits<It>::difference_type position\n-\t    = current - begin1_iterator;\n-\t  return mult(*current, *(begin2_iterator + position));\n+\t  typename std::iterator_traits<_It>::difference_type __position\n+\t    = __current - __begin1_iterator;\n+\t  return __mult(*__current, *(begin2_iterator + __position));\n \t}\n     };\n \n   /** @brief Selector that just returns the passed iterator. */\n-  template<typename It>\n-    struct identity_selector : public generic_for_each_selector<It>\n+  template<typename _It>\n+    struct __identity_selector : public __generic_for_each_selector<_It>\n     {\n       /** @brief Functor execution.\n-       *  @param o Operator (unused).\n-       *  @param i Iterator referencing object.\n+       *  @param __o Operator (unused).\n+       *  @param __i iterator referencing object.\n        *  @return Passed iterator. */\n-      template<typename Op>\n-        It\n-        operator()(Op o, It i)\n-\t{ return i; }\n+      template<typename _Op>\n+        _It\n+        operator()(_Op __o, _It __i)\n+\t{ return __i; }\n     };\n \n   /** @brief Selector that returns the difference between two adjacent\n-   *  elements.\n+   *  __elements.\n    */\n-  template<typename It>\n-    struct adjacent_difference_selector : public generic_for_each_selector<It>\n+  template<typename _It>\n+    struct __adjacent_difference_selector : public __generic_for_each_selector<_It>\n     {\n-      template<typename Op>\n+      template<typename _Op>\n         bool\n-        operator()(Op& o, It i)\n+        operator()(_Op& __o, _It __i)\n \t{\n-\t  typename It::first_type go_back_one = i.first;\n-\t  --go_back_one;\n-\t  *i.second = o(*i.first, *go_back_one);\n+\t  typename _It::first_type __go_back_one = __i.first;\n+\t  --__go_back_one;\n+\t  *__i.__second = __o(*__i.__first, *__go_back_one);\n \t  return true;\n \t}\n     };\n \n   // XXX move into type_traits?\n   /** @brief Functor doing nothing\n    *\n-   *  For some reduction tasks (this is not a function object, but is\n-   *  passed as selector dummy parameter.\n+   *  For some __reduction tasks (this is not a function object, but is\n+   *  passed as __selector __dummy parameter.\n    */\n-  struct nothing\n+  struct _Nothing\n   {\n     /** @brief Functor execution.\n-     *  @param i Iterator referencing object. */\n-    template<typename It>\n+     *  @param __i iterator referencing object. */\n+    template<typename _It>\n       void\n-      operator()(It i) { }\n+      operator()(_It __i) { }\n   };\n \n   /** @brief Reduction function doing nothing. */\n-  struct dummy_reduct\n+  struct _DummyReduct\n   {\n     bool\n-    operator()(bool /*x*/, bool /*y*/) const\n+    operator()(bool /*__x*/, bool /*__y*/) const\n     { return true; }\n   };\n \n   /** @brief Reduction for finding the maximum element, using a comparator. */\n-  template<typename Comp, typename It>\n-    struct min_element_reduct\n+  template<typename _Compare, typename _It>\n+    struct __min_element_reduct\n     {\n-      Comp& comp;\n+      _Compare& __comp;\n \n       explicit\n-      min_element_reduct(Comp &c) : comp(c) { }\n+      __min_element_reduct(_Compare &__c) : __comp(__c) { }\n \n-      It\n-      operator()(It x, It y)\n+      _It\n+      operator()(_It __x, _It __y)\n       {\n-\tif (comp(*x, *y))\n-\t  return x;\n+\tif (__comp(*__x, *__y))\n+\t  return __x;\n \telse\n-\t  return y;\n+\t  return __y;\n       }\n     };\n \n   /** @brief Reduction for finding the maximum element, using a comparator. */\n-  template<typename Comp, typename It>\n-    struct max_element_reduct\n+  template<typename _Compare, typename _It>\n+    struct __max_element_reduct\n     {\n-      Comp& comp;\n+      _Compare& __comp;\n \n       explicit\n-      max_element_reduct(Comp& c) : comp(c) { }\n+      __max_element_reduct(_Compare& __c) : __comp(__c) { }\n \n-      It\n-      operator()(It x, It y)\n+      _It\n+      operator()(_It __x, _It __y)\n       {\n-\tif (comp(*x, *y))\n-\t  return y;\n+\tif (__comp(*__x, *__y))\n+\t  return __y;\n \telse\n-\t  return x;\n+\t  return __x;\n       }\n     };\n \n   /** @brief General reduction, using a binary operator. */\n-  template<typename BinOp>\n-    struct accumulate_binop_reduct\n+  template<typename _BinOp>\n+    struct __accumulate_binop_reduct\n     {\n-      BinOp& binop;\n+      _BinOp& __binop;\n \n       explicit\n-      accumulate_binop_reduct(BinOp& b) : binop(b) { }\n+      __accumulate_binop_reduct(_BinOp& __b) : __binop(__b) { }\n \n-      template<typename Result, typename Addend>\n-        Result\n-        operator()(const Result& x, const Addend& y)\n-\t{ return binop(x, y); }\n+      template<typename _Result, typename _Addend>\n+        _Result\n+        operator()(const _Result& __x, const _Addend& __y)\n+\t{ return __binop(__x, __y); }\n     };\n }\n "}, {"sha": "1baade860c93460ed1af94afb1f9be8e0ad08a0d", "filename": "libstdc++-v3/include/parallel/iterator.h", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fiterator.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -40,160 +40,160 @@ namespace __gnu_parallel\n   /** @brief A pair of iterators. The usual iterator operations are\n    *  applied to both child iterators.\n    */\n-  template<typename Iterator1, typename Iterator2, typename IteratorCategory>\n-    class iterator_pair : public std::pair<Iterator1, Iterator2>\n+  template<typename _Iterator1, typename _Iterator2, typename _IteratorCategory>\n+    class _IteratorPair : public std::pair<_Iterator1, _Iterator2>\n     {\n     private:\n-      typedef iterator_pair<Iterator1, Iterator2, IteratorCategory> type;\n-      typedef std::pair<Iterator1, Iterator2> base_type;\n+      typedef _IteratorPair<_Iterator1, _Iterator2, _IteratorCategory> _Self;\n+      typedef std::pair<_Iterator1, _Iterator2> _Base;\n \n     public:\n-      typedef IteratorCategory iterator_category;\n+      typedef _IteratorCategory iterator_category;\n       typedef void value_type;\n \n-      typedef std::iterator_traits<Iterator1> traits_type;\n-      typedef typename traits_type::difference_type difference_type;\n-      typedef type* pointer;\n-      typedef type& reference;\n+      typedef std::iterator_traits<_Iterator1> _TraitsType;\n+      typedef typename _TraitsType::difference_type difference_type;\n+      typedef _Self* pointer;\n+      typedef _Self& reference;\n \n-      iterator_pair() { }\n+      _IteratorPair() { }\n \n-      iterator_pair(const Iterator1& first, const Iterator2& second) \n-      : base_type(first, second) { }\n+      _IteratorPair(const _Iterator1& __first, const _Iterator2& __second) \n+      : _Base(__first, __second) { }\n \n       // Pre-increment operator.\n-      type&\n+      _Self&\n       operator++()\n       {\n-\t++base_type::first;\n-\t++base_type::second;\n+\t++_Base::first;\n+\t++_Base::second;\n \treturn *this;\n       }\n \n       // Post-increment operator.\n-      const type\n+      const _Self\n       operator++(int)\n-      { return type(base_type::first++, base_type::second++); }\n+      { return _Self(_Base::first++, _Base::second++); }\n \n       // Pre-decrement operator.\n-      type&\n+      _Self&\n       operator--()\n       {\n-\t--base_type::first;\n-\t--base_type::second;\n+\t--_Base::first;\n+\t--_Base::second;\n \treturn *this;\n       }\n \n       // Post-decrement operator.\n-      const type\n+      const _Self\n       operator--(int)\n-      { return type(base_type::first--, base_type::second--); }\n+      { return _Self(_Base::first--, _Base::second--); }\n \n       // Type conversion.\n-      operator Iterator2() const\n-      { return base_type::second; }\n+      operator _Iterator2() const\n+      { return _Base::second; }\n \n-      type&\n-      operator=(const type& other)\n+      _Self&\n+      operator=(const _Self& __other)\n       {\n-\tbase_type::first = other.first;\n-\tbase_type::second = other.second;\n+\t_Base::first = __other.first;\n+\t_Base::second = __other.second;\n \treturn *this;\n       }\n \n-      type\n-      operator+(difference_type delta) const\n-      { return type(base_type::first + delta, base_type::second + delta); }\n+      _Self\n+      operator+(difference_type __delta) const\n+      { return _Self(_Base::first + __delta, _Base::second + __delta); }\n \n       difference_type\n-      operator-(const type& other) const\n-      { return base_type::first - other.first; }\n+      operator-(const _Self& __other) const\n+      { return _Base::first - __other.first; }\n   };\n \n \n   /** @brief A triple of iterators. The usual iterator operations are\n       applied to all three child iterators.\n    */\n-  template<typename Iterator1, typename Iterator2, typename Iterator3,\n-\t   typename IteratorCategory>\n-    class iterator_triple\n+  template<typename _Iterator1, typename _Iterator2, typename _Iterator3,\n+\t   typename _IteratorCategory>\n+    class _IteratorTriple\n     {\n     private:\n-      typedef iterator_triple<Iterator1, Iterator2, Iterator3,\n-\t\t\t      IteratorCategory> type;\n+      typedef _IteratorTriple<_Iterator1, _Iterator2, _Iterator3,\n+\t\t\t      _IteratorCategory> _Self;\n \n     public:\n-      typedef IteratorCategory iterator_category;\n+      typedef _IteratorCategory iterator_category;\n       typedef void value_type;\n-      typedef typename std::iterator_traits<Iterator1>::difference_type\n+      typedef typename std::iterator_traits<_Iterator1>::difference_type\n                                                             difference_type;\n-      typedef type* pointer;\n-      typedef type& reference;\n+      typedef _Self* pointer;\n+      typedef _Self& reference;\n \n-      Iterator1 first;\n-      Iterator2 second;\n-      Iterator3 third;\n+      _Iterator1 __first;\n+      _Iterator2 __second;\n+      _Iterator3 __third;\n \n-      iterator_triple() { }\n+      _IteratorTriple() { }\n \n-      iterator_triple(const Iterator1& _first, const Iterator2& _second,\n-\t\t      const Iterator3& _third)\n+      _IteratorTriple(const _Iterator1& _first, const _Iterator2& _second,\n+\t\t      const _Iterator3& _third)\n       {\n-\tfirst = _first;\n-\tsecond = _second;\n-\tthird = _third;\n+\t__first = _first;\n+\t__second = _second;\n+\t__third = _third;\n       }\n \n       // Pre-increment operator.\n-      type&\n+      _Self&\n       operator++()\n       {\n-\t++first;\n-\t++second;\n-\t++third;\n+\t++__first;\n+\t++__second;\n+\t++__third;\n \treturn *this;\n       }\n \n       // Post-increment operator.\n-      const type\n+      const _Self\n       operator++(int)\n-      { return type(first++, second++, third++); }\n+      { return _Self(__first++, __second++, __third++); }\n \n       // Pre-decrement operator.\n-      type&\n+      _Self&\n       operator--()\n       {\n-\t--first;\n-\t--second;\n-\t--third;\n+\t--__first;\n+\t--__second;\n+\t--__third;\n \treturn *this;\n       }\n \n       // Post-decrement operator.\n-      const type\n+      const _Self\n       operator--(int)\n-      { return type(first--, second--, third--); }\n+      { return _Self(__first--, __second--, __third--); }\n \n       // Type conversion.\n-      operator Iterator3() const\n-      { return third; }\n+      operator _Iterator3() const\n+      { return __third; }\n \n-      type&\n-      operator=(const type& other)\n+      _Self&\n+      operator=(const _Self& __other)\n       {\n-\tfirst = other.first;\n-\tsecond = other.second;\n-\tthird = other.third;\n+\t__first = __other.__first;\n+\t__second = __other.__second;\n+\t__third = __other.__third;\n \treturn *this;\n       }\n \n-      type\n-      operator+(difference_type delta) const\n-      { return type(first + delta, second + delta, third + delta); }\n+      _Self\n+      operator+(difference_type __delta) const\n+      { return _Self(__first + __delta, __second + __delta, __third + __delta); }\n \n       difference_type\n-      operator-(const type& other) const\n-      { return first - other.first; }\n+      operator-(const _Self& __other) const\n+      { return __first - __other.__first; }\n   };\n }\n "}, {"sha": "5065a86f9a0aeaca87256822a004bc26fa8defea", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -3,12 +3,12 @@\n // Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the terms\n+// software; you can redistribute __it and/or modify __it under the terms\n // of the GNU General Public License as published by the Free Software\n // Foundation; either version 3, or (at your option) any later\n // version.\n \n-// This library is distributed in the hope that it will be useful, but\n+// This library is distributed in the hope that __it will be useful, but\n // WITHOUT ANY WARRANTY; without even the implied warranty of\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n // General Public License for more details.\n@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file parallel/list_partition.h\n- *  @brief Functionality to split sequence referenced by only input\n+ *  @brief _Functionality to split __sequence referenced by only input\n  *  iterators.\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n@@ -39,137 +39,137 @@\n namespace __gnu_parallel\n {\n   /** @brief Shrinks and doubles the ranges.\n-   *  @param os_starts Start positions worked on (oversampled).\n-   *  @param count_to_two Counts up to 2.\n-   *  @param range_length Current length of a chunk.\n-   *  @param make_twice Whether the @c os_starts is allowed to be\n+   *  @param __os_starts Start positions worked on (oversampled).\n+   *  @param __count_to_two Counts up to 2.\n+   *  @param __range_length Current length of a chunk.\n+   *  @param __make_twice Whether the @__c __os_starts is allowed to be\n    *  grown or not\n    */\n-  template<typename InputIterator>\n+  template<typename _IIter>\n     void\n-    shrink_and_double(std::vector<InputIterator>& os_starts,\n-\t\t      size_t& count_to_two, size_t& range_length,\n-\t\t      const bool make_twice)\n+    __shrink_and_double(std::vector<_IIter>& __os_starts,\n+\t\t      size_t& __count_to_two, size_t& __range_length,\n+\t\t      const bool __make_twice)\n     {\n-      ++count_to_two;\n-      if (not make_twice or count_to_two < 2)\n-\tshrink(os_starts, count_to_two, range_length);\n+      ++__count_to_two;\n+      if (not __make_twice or __count_to_two < 2)\n+\t__shrink(__os_starts, __count_to_two, __range_length);\n       else\n \t{\n-\t  os_starts.resize((os_starts.size() - 1) * 2 + 1);\n-\t  count_to_two = 0;\n+\t  __os_starts.resize((__os_starts.size() - 1) * 2 + 1);\n+\t  __count_to_two = 0;\n \t}\n     }\n \n   /** @brief Combines two ranges into one and thus halves the number of ranges.\n-   *  @param os_starts Start positions worked on (oversampled).\n-   *  @param count_to_two Counts up to 2.\n-   *  @param range_length Current length of a chunk. */\n-  template<typename InputIterator>\n+   *  @param __os_starts Start positions worked on (oversampled).\n+   *  @param __count_to_two Counts up to 2.\n+   *  @param __range_length Current length of a chunk. */\n+  template<typename _IIter>\n     void\n-    shrink(std::vector<InputIterator>& os_starts, size_t& count_to_two,\n-\t   size_t& range_length)\n+    __shrink(std::vector<_IIter>& __os_starts, size_t& __count_to_two,\n+\t   size_t& __range_length)\n     {\n-      for (typename std::vector<InputIterator>::size_type i = 0;\n-\t   i <= (os_starts.size() / 2); ++i)\n-\tos_starts[i] = os_starts[i * 2];\n-      range_length *= 2;\n+      for (typename std::vector<_IIter>::size_type __i = 0;\n+\t   __i <= (__os_starts.size() / 2); ++__i)\n+\t__os_starts[__i] = __os_starts[__i * 2];\n+      __range_length *= 2;\n     }\n \n   /** @brief Splits a sequence given by input iterators into parts of\n    * almost equal size\n    *\n    *  The function needs only one pass over the sequence.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param starts Start iterators for the resulting parts, dimension\n-   *  @c num_parts+1. For convenience, @c starts @c [num_parts]\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __starts Start iterators for the resulting parts, dimension\n+   *  @__c __num_parts+1. For convenience, @__c __starts @__c [__num_parts]\n    *  contains the end iterator of the sequence.\n-   *  @param lengths Length of the resulting parts.\n-   *  @param num_parts Number of parts to split the sequence into.\n-   *  @param f Functor to be applied to each element by traversing it\n-   *  @param oversampling Oversampling factor. If 0, then the\n-   *  partitions will differ in at most @f$ \\sqrt{\\mathrm{end} -\n-   *  \\mathrm{begin}} @f$ elements. Otherwise, the ratio between the\n-   *  longest and the shortest part is bounded by @f$\n-   *  1/(\\mathrm{oversampling} \\cdot \\mathrm{num\\_parts}) @f$.\n+   *  @param __lengths Length of the resulting parts.\n+   *  @param __num_parts Number of parts to split the sequence into.\n+   *  @param __f Functor to be applied to each element by traversing __it\n+   *  @param __oversampling Oversampling factor. If 0, then the\n+   *  partitions will differ in at most @__f$ \\sqrt{\\mathrm{__end} -\n+   *  \\mathrm{__begin}} @__f$ __elements. Otherwise, the ratio between the\n+   *  longest and the shortest part is bounded by @__f$\n+   *  1/(\\mathrm{__oversampling} \\cdot \\mathrm{num\\_parts}) @__f$.\n    *  @return Length of the whole sequence.\n    */\n-  template<typename InputIterator, typename FunctorType>\n+  template<typename _IIter, typename _FunctorType>\n     size_t\n-    list_partition(const InputIterator begin, const InputIterator end,\n-\t\t   InputIterator* starts, size_t* lengths, const int num_parts,\n-\t\t   FunctorType& f, int oversampling = 0)\n+    list_partition(const _IIter __begin, const _IIter __end,\n+\t\t   _IIter* __starts, size_t* __lengths, const int __num_parts,\n+\t\t   _FunctorType& __f, int __oversampling = 0)\n     {\n-      bool make_twice = false;\n+      bool __make_twice = false;\n \n       // The resizing algorithm is chosen according to the oversampling factor.\n-      if (oversampling == 0)\n+      if (__oversampling == 0)\n \t{\n-\t  make_twice = true;\n-\t  oversampling = 1;\n+\t  __make_twice = true;\n+\t  __oversampling = 1;\n \t}\n \n-      std::vector<InputIterator> os_starts(2 * oversampling * num_parts + 1);\n+      std::vector<_IIter> __os_starts(2 * __oversampling * __num_parts + 1);\n \n-      os_starts[0]= begin;\n-      InputIterator prev = begin, it = begin;\n-      size_t dist_limit = 0, dist = 0;\n-      size_t cur = 1, next = 1;\n-      size_t range_length = 1;\n-      size_t count_to_two = 0;\n-      while (it != end)\n+      __os_starts[0]= __begin;\n+      _IIter __prev = __begin, __it = __begin;\n+      size_t __dist_limit = 0, __dist = 0;\n+      size_t __cur = 1, __next = 1;\n+      size_t __range_length = 1;\n+      size_t __count_to_two = 0;\n+      while (__it != __end)\n \t{\n-\t  cur = next;\n-\t  for (; cur < os_starts.size() and it != end; ++cur)\n+\t  __cur = __next;\n+\t  for (; __cur < __os_starts.size() and __it != __end; ++__cur)\n \t    {\n-\t      for (dist_limit += range_length;\n-\t\t   dist < dist_limit and it != end; ++dist)\n+\t      for (__dist_limit += __range_length;\n+\t\t   __dist < __dist_limit and __it != __end; ++__dist)\n \t\t{\n-\t\t  f(it);\n-\t\t  ++it;\n+\t\t  __f(__it);\n+\t\t  ++__it;\n \t\t}\n-\t      os_starts[cur] = it;\n+\t      __os_starts[__cur] = __it;\n \t    }\n \n-\t  // Must compare for end and not cur < os_starts.size() , because\n-\t  // cur could be == os_starts.size() as well\n-\t  if (it == end)\n+\t  // Must compare for end and not __cur < __os_starts.size() , because\n+\t  // __cur could be == __os_starts.size() as well\n+\t  if (__it == __end)\n \t    break;\n \n-\t  shrink_and_double(os_starts, count_to_two, range_length, make_twice);\n-\t  next = os_starts.size() / 2 + 1;\n+\t  __shrink_and_double(__os_starts, __count_to_two, __range_length, __make_twice);\n+\t  __next = __os_starts.size() / 2 + 1;\n \t}\n \n-      // Calculation of the parts (one must be extracted from current\n-      // because the partition beginning at end, consists only of\n+      // Calculation of the parts (one must be extracted from __current\n+      // because the partition beginning at __end, consists only of\n       // itself).\n-      size_t size_part = (cur - 1) / num_parts;\n-      int size_greater = static_cast<int>((cur - 1) % num_parts);\n-      starts[0] = os_starts[0];\n+      size_t __size_part = (__cur - 1) / __num_parts;\n+      int __size_greater = static_cast<int>((__cur - 1) % __num_parts);\n+      __starts[0] = __os_starts[0];\n \n-      size_t index = 0;\n+      size_t __index = 0;\n \n       // Smallest partitions.\n-      for (int i = 1; i < (num_parts + 1 - size_greater); ++i)\n+      for (int __i = 1; __i < (__num_parts + 1 - __size_greater); ++__i)\n \t{\n-\t  lengths[i - 1] =  size_part * range_length;\n-\t  index += size_part;\n-\t  starts[i] = os_starts[index];\n+\t  __lengths[__i - 1] =  __size_part * __range_length;\n+\t  __index += __size_part;\n+\t  __starts[__i] = __os_starts[__index];\n \t}\n \n       // Biggest partitions.\n-      for (int i = num_parts + 1 - size_greater; i <= num_parts; ++i)\n+      for (int __i = __num_parts + 1 - __size_greater; __i <= __num_parts; ++__i)\n \t{\n-\t  lengths[i - 1] =  (size_part+1) * range_length;\n-\t  index += (size_part+1);\n-\t  starts[i] = os_starts[index];\n+\t  __lengths[__i - 1] =  (__size_part+1) * __range_length;\n+\t  __index += (__size_part+1);\n+\t  __starts[__i] = __os_starts[__index];\n \t}\n \n       // Correction of the end size (the end iteration has not finished).\n-      lengths[num_parts - 1] -= (dist_limit - dist);\n+      __lengths[__num_parts - 1] -= (__dist_limit - __dist);\n \n-      return dist;\n+      return __dist;\n     }\n }\n "}, {"sha": "b98102572328c19784f94d1668409cb1920dc9f9", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 417, "deletions": 417, "changes": 834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -46,45 +46,45 @@ namespace __gnu_parallel\n  *\n  * The smallest element is at the top.\n  *\n- * Guarding is done explicitly through one flag sup per element,\n+ * Guarding is done explicitly through one flag _M_sup per element,\n  * inf is not needed due to a better initialization routine.  This\n  * is a well-performing variant.\n  *\n- * @param T the element type\n- * @param Comparator the comparator to use, defaults to std::less<T>\n+ * @param _Tp the element _Self\n+ * @param _Compare the comparator to use, defaults to std::less<_Tp>\n  */\n-template<typename T, typename Comparator>\n+template<typename _Tp, typename _Compare>\n class LoserTreeBase\n {\n protected:\n   /** @brief Internal representation of a LoserTree element. */\n-  struct Loser\n-  {\n-    /** @brief flag, true iff this is a \"maximum\" sentinel. */\n-    bool sup;\n-    /** @brief index of the source sequence. */\n-    int source;\n-    /** @brief key of the element in the LoserTree. */\n-    T key;\n+  struct _Loser\n+  {\n+    /** @brief flag, true iff this is a \"maximum\" __sentinel. */\n+    bool _M_sup;\n+    /** @brief __index of the _M_source __sequence. */\n+    int _M_source;\n+    /** @brief _M_key of the element in the LoserTree. */\n+    _Tp _M_key;\n   };\n \n-  unsigned int ik, k, offset;\n+  unsigned int __ik, __k, __offset;\n \n-  /** log_2{k} */\n+  /** log_2{__k} */\n   unsigned int _M_log_k;\n \n-  /** @brief LoserTree elements. */\n-  Loser* losers;\n+  /** @brief LoserTree __elements. */\n+  _Loser* __losers;\n \n-  /** @brief Comparator to use. */\n-  Comparator comp;\n+  /** @brief _Compare to use. */\n+  _Compare __comp;\n \n   /**\n    * @brief State flag that determines whether the LoserTree is empty.\n    *\n    * Only used for building the LoserTree.\n    */\n-  bool first_insert;\n+  bool __first_insert;\n \n public:\n   /**\n@@ -93,152 +93,152 @@ class LoserTreeBase\n    * @param _k The number of sequences to merge.\n    * @param _comp The comparator to use.\n    */\n-  LoserTreeBase(unsigned int _k, Comparator _comp)\n-  : comp(_comp)\n+  LoserTreeBase(unsigned int _k, _Compare _comp)\n+  : __comp(_comp)\n   {\n-    ik = _k;\n+    __ik = _k;\n \n-    // Compute log_2{k} for the Loser Tree\n-    _M_log_k = __log2(ik - 1) + 1;\n+    // Compute log_2{__k} for the _Loser Tree\n+    _M_log_k = __log2(__ik - 1) + 1;\n \n     // Next greater power of 2.\n-    k = 1 << _M_log_k;\n-    offset = k;\n+    __k = 1 << _M_log_k;\n+    __offset = __k;\n \n-    // Avoid default-constructing losers[].key\n-    losers = static_cast<Loser*>(::operator new(2 * k * sizeof(Loser)));\n-    for (unsigned int i = ik - 1; i < k; ++i)\n-      losers[i + k].sup = true;\n+    // Avoid default-constructing __losers[]._M_key\n+    __losers = static_cast<_Loser*>(::operator new(2 * __k * sizeof(_Loser)));\n+    for (unsigned int __i = __ik - 1; __i < __k; ++__i)\n+      __losers[__i + __k]._M_sup = true;\n \n-    first_insert = true;\n+    __first_insert = true;\n   }\n \n   /**\n    * @brief The destructor.\n    */\n   ~LoserTreeBase()\n-  { ::operator delete(losers); }\n+  { ::operator delete(__losers); }\n \n   /**\n-   * @brief Initializes the sequence \"source\" with the element \"key\".\n+   * @brief Initializes the sequence \"_M_source\" with the element \"_M_key\".\n    *\n-   * @param key the element to insert\n-   * @param source index of the source sequence\n-   * @param sup flag that determines whether the value to insert is an\n-   *   explicit supremum.\n+   * @param _M_key the element to insert\n+   * @param _M_source __index of the _M_source __sequence\n+   * @param _M_sup flag that determines whether the value to insert is an\n+   *   explicit __supremum.\n    */\n   inline void\n-  insert_start(const T& key, int source, bool sup)\n+  __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n   {\n-    unsigned int pos = k + source;\n+    unsigned int __pos = __k + _M_source;\n \n-    if(first_insert)\n+    if(__first_insert)\n       {\n         // Construct all keys, so we can easily deconstruct them.\n-        for (unsigned int i = 0; i < (2 * k); ++i)\n-          new(&(losers[i].key)) T(key);\n-        first_insert = false;\n+        for (unsigned int __i = 0; __i < (2 * __k); ++__i)\n+          new(&(__losers[__i]._M_key)) _Tp(_M_key);\n+        __first_insert = false;\n       }\n     else\n-      new(&(losers[pos].key)) T(key);\n+      new(&(__losers[__pos]._M_key)) _Tp(_M_key);\n \n-    losers[pos].sup = sup;\n-    losers[pos].source = source;\n+    __losers[__pos]._M_sup = _M_sup;\n+    __losers[__pos]._M_source = _M_source;\n   }\n \n   /**\n    * @return the index of the sequence with the smallest element.\n    */\n-  int get_min_source()\n-  { return losers[0].source; }\n+  int __get_min_source()\n+  { return __losers[0]._M_source; }\n };\n \n /**\n  * @brief Stable LoserTree variant.\n  *\n- * Provides the stable implementations of insert_start, init_winner,\n- * init and delete_min_insert.\n+ * Provides the stable implementations of insert_start, __init_winner,\n+ * __init and __delete_min_insert.\n  *\n  * Unstable variant is done using partial specialisation below.\n  */\n-template<bool stable/* default == true */, typename T, typename Comparator>\n-class LoserTree : public LoserTreeBase<T, Comparator>\n+template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n+class LoserTree : public LoserTreeBase<_Tp, _Compare>\n {\n-  typedef LoserTreeBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n-  using Base::first_insert;\n+  typedef LoserTreeBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n+  using Base::__first_insert;\n \n public:\n-  LoserTree(unsigned int _k, Comparator _comp)\n+  LoserTree(unsigned int _k, _Compare _comp)\n   : Base::LoserTreeBase(_k, _comp)\n   {}\n \n   unsigned int\n-  init_winner(unsigned int root)\n+  __init_winner(unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n-        if (losers[right].sup\n-            || (!losers[left].sup\n-              && !comp(losers[right].key, losers[left].key)))\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n+        if (__losers[__right]._M_sup\n+            || (!__losers[__left]._M_sup\n+              && !__comp(__losers[__right]._M_key, __losers[__left]._M_key)))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n-  void init()\n-  { losers[0] = losers[init_winner(1)]; }\n+  void __init()\n+  { __losers[0] = __losers[__init_winner(1)]; }\n \n   /**\n    * @brief Delete the smallest element and insert a new element from\n    *   the previously smallest element's sequence.\n    *\n    * This implementation is stable.\n    */\n-  // Do not pass a const reference since key will be used as local variable.\n-  void delete_min_insert(T key, bool sup)\n+  // Do not pass a const reference since _M_key will be used as local variable.\n+  void __delete_min_insert(_Tp _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n-        // The smaller one gets promoted, ties are broken by source.\n-        if ((sup && (!losers[pos].sup || losers[pos].source < source))\n-              || (!sup && !losers[pos].sup\n-                && ((comp(losers[pos].key, key))\n-                  || (!comp(key, losers[pos].key)\n-                    && losers[pos].source < source))))\n+        // The smaller one gets promoted, ties are broken by _M_source.\n+        if ((_M_sup && (!__losers[__pos]._M_sup || __losers[__pos]._M_source < _M_source))\n+              || (!_M_sup && !__losers[__pos]._M_sup\n+                && ((__comp(__losers[__pos]._M_key, _M_key))\n+                  || (!__comp(_M_key, __losers[__pos]._M_key)\n+                    && __losers[__pos]._M_source < _M_source))))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].sup, sup);\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].key, key);\n+            std::swap(__losers[__pos]._M_sup, _M_sup);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_key, _M_key);\n           }\n       }\n \n-    losers[0].sup = sup;\n-    losers[0].source = source;\n-    losers[0].key = key;\n+    __losers[0]._M_sup = _M_sup;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_key = _M_key;\n   }\n };\n \n@@ -247,141 +247,141 @@ class LoserTree : public LoserTreeBase<T, Comparator>\n  *\n  * Stability (non-stable here) is selected with partial specialization.\n  */\n-template<typename T, typename Comparator>\n-class LoserTree</* stable == */false, T, Comparator> :\n-    public LoserTreeBase<T, Comparator>\n+template<typename _Tp, typename _Compare>\n+class LoserTree</* __stable == */false, _Tp, _Compare> :\n+    public LoserTreeBase<_Tp, _Compare>\n {\n-  typedef LoserTreeBase<T, Comparator> Base;\n+  typedef LoserTreeBase<_Tp, _Compare> Base;\n   using Base::_M_log_k;\n-  using Base::k;\n-  using Base::losers;\n-  using Base::first_insert;\n+  using Base::__k;\n+  using Base::__losers;\n+  using Base::__first_insert;\n \n public:\n-  LoserTree(unsigned int _k, Comparator _comp)\n+  LoserTree(unsigned int _k, _Compare _comp)\n   : Base::LoserTreeBase(_k, _comp)\n   {}\n \n   /**\n-   * Computes the winner of the competition at position \"root\".\n+   * Computes the winner of the competition at __position \"__root\".\n    *\n    * Called recursively (starting at 0) to build the initial tree.\n    *\n-   * @param root index of the \"game\" to start.\n+   * @param __root __index of the \"game\" to start.\n    */\n   unsigned int\n-  init_winner (unsigned int root)\n+  __init_winner (unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n-        if (losers[right].sup ||\n-            (!losers[left].sup\n-              && !comp(losers[right].key, losers[left].key)))\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n+        if (__losers[__right]._M_sup ||\n+            (!__losers[__left]._M_sup\n+              && !__comp(__losers[__right]._M_key, __losers[__left]._M_key)))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n   inline void\n-  init()\n-  { losers[0] = losers[init_winner(1)]; }\n+  __init()\n+  { __losers[0] = __losers[__init_winner(1)]; }\n \n   /**\n-   * Delete the key smallest element and insert the element key instead.\n+   * Delete the _M_key smallest element and insert the element _M_key instead.\n    *\n-   * @param key the key to insert\n-   * @param sup true iff key is an explicitly marked supremum\n+   * @param _M_key the _M_key to insert\n+   * @param _M_sup true iff _M_key is an explicitly marked supremum\n    */\n-  // Do not pass a const reference since key will be used as local variable.\n+  // Do not pass a const reference since _M_key will be used as local variable.\n   inline void\n-  delete_min_insert(T key, bool sup)\n+  __delete_min_insert(_Tp _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n     {\n         // The smaller one gets promoted.\n-      if (sup || (!losers[pos].sup && comp(losers[pos].key, key)))\n+      if (_M_sup || (!__losers[__pos]._M_sup && __comp(__losers[__pos]._M_key, _M_key)))\n       {\n             // The other one is smaller.\n-        std::swap(losers[pos].sup, sup);\n-        std::swap(losers[pos].source, source);\n-        std::swap(losers[pos].key, key);\n+        std::swap(__losers[__pos]._M_sup, _M_sup);\n+        std::swap(__losers[__pos]._M_source, _M_source);\n+        std::swap(__losers[__pos]._M_key, _M_key);\n       }\n     }\n \n-    losers[0].sup = sup;\n-    losers[0].source = source;\n-    losers[0].key = key;\n+    __losers[0]._M_sup = _M_sup;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_key = _M_key;\n   }\n };\n \n \n /**\n- * @brief Base class of Loser Tree implementation using pointers.\n+ * @brief Base class of _Loser Tree implementation using pointers.\n  */\n-template<typename T, typename Comparator>\n-class LoserTreePointerBase\n+template<typename _Tp, typename _Compare>\n+class _LoserTreePointerBase\n {\n protected:\n-  /** @brief Internal representation of LoserTree elements. */\n-  struct Loser\n+  /** @brief Internal representation of LoserTree __elements. */\n+  struct _Loser\n   {\n-    bool sup;\n-    int source;\n-    const T* keyp;\n+    bool _M_sup;\n+    int _M_source;\n+    const _Tp* _M_keyp;\n   };\n \n-  unsigned int ik, k, offset;\n-  Loser* losers;\n-  Comparator comp;\n+  unsigned int __ik, __k, __offset;\n+  _Loser* __losers;\n+  _Compare __comp;\n \n public:\n-  LoserTreePointerBase(unsigned int _k, Comparator _comp = std::less<T>())\n-    : comp(_comp)\n+  _LoserTreePointerBase(unsigned int _k, _Compare _comp = std::less<_Tp>())\n+    : __comp(_comp)\n   {\n-    ik = _k;\n+    __ik = _k;\n \n     // Next greater power of 2.\n-    k = 1 << (__log2(ik - 1) + 1);\n-    offset = k;\n-    losers = new Loser[k * 2];\n-    for (unsigned int i = ik - 1; i < k; i++)\n-      losers[i + k].sup = true;\n+    __k = 1 << (__log2(__ik - 1) + 1);\n+    __offset = __k;\n+    __losers = new _Loser[__k * 2];\n+    for (unsigned int __i = __ik - 1; __i < __k; __i++)\n+      __losers[__i + __k]._M_sup = true;\n   }\n \n-  ~LoserTreePointerBase()\n-  { ::operator delete[](losers); }\n+  ~_LoserTreePointerBase()\n+  { ::operator delete[](__losers); }\n \n-  int get_min_source()\n-  { return losers[0].source; }\n+  int __get_min_source()\n+  { return __losers[0]._M_source; }\n \n-  void insert_start(const T& key, int source, bool sup)\n+  void __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n   {\n-    unsigned int pos = k + source;\n+    unsigned int __pos = __k + _M_source;\n \n-    losers[pos].sup = sup;\n-    losers[pos].source = source;\n-    losers[pos].keyp = &key;\n+    __losers[__pos]._M_sup = _M_sup;\n+    __losers[__pos]._M_source = _M_source;\n+    __losers[__pos]._M_keyp = &_M_key;\n   }\n };\n \n@@ -390,77 +390,77 @@ class LoserTreePointerBase\n  *\n  * The unstable variant is implemented using partial instantiation below.\n  */\n-template<bool stable/* default == true */, typename T, typename Comparator>\n-class LoserTreePointer : public LoserTreePointerBase<T, Comparator>\n+template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n+class _LoserTreePointer : public _LoserTreePointerBase<_Tp, _Compare>\n {\n-  typedef LoserTreePointerBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n+  typedef _LoserTreePointerBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n \n public:\n-  LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n-    : Base::LoserTreePointerBase(_k, _comp)\n+  _LoserTreePointer(unsigned int _k, _Compare _comp = std::less<_Tp>())\n+    : Base::_LoserTreePointerBase(_k, _comp)\n   {}\n \n   unsigned int\n-  init_winner(unsigned int root)\n+  __init_winner(unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n-        if (losers[right].sup\n-            || (!losers[left].sup && !comp(*losers[right].keyp,\n-                                          *losers[left].keyp)))\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n+        if (__losers[__right]._M_sup\n+            || (!__losers[__left]._M_sup && !__comp(*__losers[__right]._M_keyp,\n+                                          *__losers[__left]._M_keyp)))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n-  void init()\n-  { losers[0] = losers[init_winner(1)]; }\n+  void __init()\n+  { __losers[0] = __losers[__init_winner(1)]; }\n \n-  void delete_min_insert(const T& key, bool sup)\n+  void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    const T* keyp = &key;\n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    const _Tp* _M_keyp = &_M_key;\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n-        // The smaller one gets promoted, ties are broken by source.\n-        if ((sup && (!losers[pos].sup || losers[pos].source < source)) ||\n-              (!sup && !losers[pos].sup &&\n-              ((comp(*losers[pos].keyp, *keyp)) ||\n-                (!comp(*keyp, *losers[pos].keyp)\n-                && losers[pos].source < source))))\n+        // The smaller one gets promoted, ties are broken by _M_source.\n+        if ((_M_sup && (!__losers[__pos]._M_sup || __losers[__pos]._M_source < _M_source)) ||\n+              (!_M_sup && !__losers[__pos]._M_sup &&\n+              ((__comp(*__losers[__pos]._M_keyp, *_M_keyp)) ||\n+                (!__comp(*_M_keyp, *__losers[__pos]._M_keyp)\n+                && __losers[__pos]._M_source < _M_source))))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].sup, sup);\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].keyp, keyp);\n+            std::swap(__losers[__pos]._M_sup, _M_sup);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    losers[0].sup = sup;\n-    losers[0].source = source;\n-    losers[0].keyp = keyp;\n+    __losers[0]._M_sup = _M_sup;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_keyp = _M_keyp;\n   }\n };\n \n@@ -469,74 +469,74 @@ class LoserTreePointer : public LoserTreePointerBase<T, Comparator>\n  *\n  * The stable variant is above.\n  */\n-template<typename T, typename Comparator>\n-class LoserTreePointer</* stable == */false, T, Comparator> :\n-    public LoserTreePointerBase<T, Comparator>\n+template<typename _Tp, typename _Compare>\n+class _LoserTreePointer</* __stable == */false, _Tp, _Compare> :\n+    public _LoserTreePointerBase<_Tp, _Compare>\n {\n-  typedef LoserTreePointerBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n+  typedef _LoserTreePointerBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n \n public:\n-  LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n-    : Base::LoserTreePointerBase(_k, _comp)\n+  _LoserTreePointer(unsigned int _k, _Compare _comp = std::less<_Tp>())\n+    : Base::_LoserTreePointerBase(_k, _comp)\n   {}\n \n   unsigned int\n-  init_winner(unsigned int root)\n+  __init_winner(unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n-        if (losers[right].sup\n-              || (!losers[left].sup\n-                && !comp(*losers[right].keyp, *losers[left].keyp)))\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n+        if (__losers[__right]._M_sup\n+              || (!__losers[__left]._M_sup\n+                && !__comp(*__losers[__right]._M_keyp, *__losers[__left]._M_keyp)))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n-  void init()\n-  { losers[0] = losers[init_winner(1)]; }\n+  void __init()\n+  { __losers[0] = __losers[__init_winner(1)]; }\n \n-  void delete_min_insert(const T& key, bool sup)\n+  void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    const T* keyp = &key;\n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    const _Tp* _M_keyp = &_M_key;\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (sup || (!losers[pos].sup && comp(*losers[pos].keyp, *keyp)))\n+        if (_M_sup || (!__losers[__pos]._M_sup && __comp(*__losers[__pos]._M_keyp, *_M_keyp)))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].sup, sup);\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].keyp, keyp);\n+            std::swap(__losers[__pos]._M_sup, _M_sup);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    losers[0].sup = sup;\n-    losers[0].source = source;\n-    losers[0].keyp = keyp;\n+    __losers[0]._M_sup = _M_sup;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_keyp = _M_keyp;\n   }\n };\n \n@@ -545,66 +545,66 @@ class LoserTreePointer</* stable == */false, T, Comparator> :\n  * The whole element is copied into the tree structure.\n  *\n  * No guarding is done, therefore not a single input sequence must\n- * run empty.  Unused sequence heads are marked with a sentinel which\n+ * run empty.  Unused __sequence heads are marked with a sentinel which\n  * is &gt; all elements that are to be merged.\n  *\n  * This is a very fast variant.\n  */\n-template<typename T, typename Comparator>\n-class LoserTreeUnguardedBase\n+template<typename _Tp, typename _Compare>\n+class _LoserTreeUnguardedBase\n {\n protected:\n-  struct Loser\n+  struct _Loser\n   {\n-    int source;\n-    T key;\n+    int _M_source;\n+    _Tp _M_key;\n   };\n \n-  unsigned int ik, k, offset;\n-  Loser* losers;\n-  Comparator comp;\n+  unsigned int __ik, __k, __offset;\n+  _Loser* __losers;\n+  _Compare __comp;\n \n public:\n   inline\n-  LoserTreeUnguardedBase(unsigned int _k, const T _sentinel,\n-                         Comparator _comp = std::less<T>())\n-    : comp(_comp)\n+  _LoserTreeUnguardedBase(unsigned int _k, const _Tp _sentinel,\n+                         _Compare _comp = std::less<_Tp>())\n+    : __comp(_comp)\n   {\n-    ik = _k;\n+    __ik = _k;\n \n     // Next greater power of 2.\n-    k = 1 << (__log2(ik - 1) + 1);\n-    offset = k;\n-    // Avoid default-constructing losers[].key\n-    losers = static_cast<Loser*>(::operator new(2 * k * sizeof(Loser)));\n+    __k = 1 << (__log2(__ik - 1) + 1);\n+    __offset = __k;\n+    // Avoid default-constructing __losers[]._M_key\n+    __losers = static_cast<_Loser*>(::operator new(2 * __k * sizeof(_Loser)));\n \n-    for (unsigned int i = k + ik - 1; i < (2 * k); ++i)\n+    for (unsigned int __i = __k + __ik - 1; __i < (2 * __k); ++__i)\n       {\n-        losers[i].key = _sentinel;\n-        losers[i].source = -1;\n+        __losers[__i]._M_key = _sentinel;\n+        __losers[__i]._M_source = -1;\n       }\n   }\n \n-  inline ~LoserTreeUnguardedBase()\n-  { ::operator delete(losers); }\n+  inline ~_LoserTreeUnguardedBase()\n+  { ::operator delete(__losers); }\n \n   inline int\n-  get_min_source()\n+  __get_min_source()\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n-    return losers[0].source;\n+    return __losers[0]._M_source;\n   }\n \n   inline void\n-  insert_start(const T& key, int source, bool)\n+  __insert_start(const _Tp& _M_key, int _M_source, bool)\n   {\n-    unsigned int pos = k + source;\n+    unsigned int __pos = __k + _M_source;\n \n-    new(&(losers[pos].key)) T(key);\n-    losers[pos].source = source;\n+    new(&(__losers[__pos]._M_key)) _Tp(_M_key);\n+    __losers[__pos]._M_source = _M_source;\n   }\n };\n \n@@ -613,80 +613,80 @@ class LoserTreeUnguardedBase\n  *\n  * Unstable variant is selected below with partial specialization.\n  */\n-template<bool stable/* default == true */, typename T, typename Comparator>\n-class LoserTreeUnguarded : public LoserTreeUnguardedBase<T, Comparator>\n+template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n+class _LoserTreeUnguarded : public _LoserTreeUnguardedBase<_Tp, _Compare>\n {\n-  typedef LoserTreeUnguardedBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n+  typedef _LoserTreeUnguardedBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n \n public:\n-  LoserTreeUnguarded(unsigned int _k, const T _sentinel,\n-                     Comparator _comp = std::less<T>())\n-    : Base::LoserTreeUnguardedBase(_k, _sentinel, _comp)\n+  _LoserTreeUnguarded(unsigned int _k, const _Tp _sentinel,\n+                     _Compare _comp = std::less<_Tp>())\n+    : Base::_LoserTreeUnguardedBase(_k, _sentinel, _comp)\n   {}\n \n   unsigned int\n-  init_winner(unsigned int root)\n+  __init_winner(unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n-        if (!comp(losers[right].key, losers[left].key))\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n+        if (!__comp(__losers[__right]._M_key, __losers[__left]._M_key))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n   inline void\n-  init()\n+  __init()\n   {\n-    losers[0] = losers[init_winner(1)];\n+    __losers[0] = __losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n   }\n \n-  // Do not pass a const reference since key will be used as local variable.\n+  // Do not pass a const reference since _M_key will be used as local variable.\n   inline void\n-  delete_min_insert(T key, bool)\n+  __delete_min_insert(_Tp _M_key, bool)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n-        // The smaller one gets promoted, ties are broken by source.\n-        if (comp(losers[pos].key, key)\n-              || (!comp(key, losers[pos].key) && losers[pos].source < source))\n+        // The smaller one gets promoted, ties are broken by _M_source.\n+        if (__comp(__losers[__pos]._M_key, _M_key)\n+              || (!__comp(_M_key, __losers[__pos]._M_key) && __losers[__pos]._M_source < _M_source))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].key, key);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_key, _M_key);\n           }\n       }\n \n-    losers[0].source = source;\n-    losers[0].key = key;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_key = _M_key;\n   }\n };\n \n@@ -695,152 +695,152 @@ class LoserTreeUnguarded : public LoserTreeUnguardedBase<T, Comparator>\n  *\n  * Stable implementation is above.\n  */\n-template<typename T, typename Comparator>\n-class LoserTreeUnguarded</* stable == */false, T, Comparator> :\n-    public LoserTreeUnguardedBase<T, Comparator>\n+template<typename _Tp, typename _Compare>\n+class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n+    public _LoserTreeUnguardedBase<_Tp, _Compare>\n {\n-  typedef LoserTreeUnguardedBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n+  typedef _LoserTreeUnguardedBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n \n public:\n-  LoserTreeUnguarded(unsigned int _k, const T _sentinel,\n-                     Comparator _comp = std::less<T>())\n-    : Base::LoserTreeUnguardedBase(_k, _sentinel, _comp)\n+  _LoserTreeUnguarded(unsigned int _k, const _Tp _sentinel,\n+                     _Compare _comp = std::less<_Tp>())\n+    : Base::_LoserTreeUnguardedBase(_k, _sentinel, _comp)\n   {}\n \n   unsigned int\n-  init_winner (unsigned int root)\n+  __init_winner (unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n \n #if _GLIBCXX_ASSERTIONS\n-        // If left one is sentinel then right one must be, too.\n-        if (losers[left].source == -1)\n-          _GLIBCXX_PARALLEL_ASSERT(losers[right].source == -1);\n+        // If __left one is sentinel then __right one must be, too.\n+        if (__losers[__left]._M_source == -1)\n+          _GLIBCXX_PARALLEL_ASSERT(__losers[__right]._M_source == -1);\n #endif\n \n-        if (!comp(losers[right].key, losers[left].key))\n+        if (!__comp(__losers[__right]._M_key, __losers[__left]._M_key))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n   inline void\n-  init()\n+  __init()\n   {\n-    losers[0] = losers[init_winner(1)];\n+    __losers[0] = __losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n   }\n \n-  // Do not pass a const reference since key will be used as local variable.\n+  // Do not pass a const reference since _M_key will be used as local variable.\n   inline void\n-  delete_min_insert(T key, bool)\n+  __delete_min_insert(_Tp _M_key, bool)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (comp(losers[pos].key, key))\n+        if (__comp(__losers[__pos]._M_key, _M_key))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].key, key);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_key, _M_key);\n           }\n       }\n \n-    losers[0].source = source;\n-    losers[0].key = key;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_key = _M_key;\n   }\n };\n \n /** @brief Unguarded loser tree, keeping only pointers to the\n-* elements in the tree structure.\n+* __elements in the tree structure.\n *\n *  No guarding is done, therefore not a single input sequence must\n *  run empty.  This is a very fast variant.\n */\n-template<typename T, typename Comparator>\n+template<typename _Tp, typename _Compare>\n class LoserTreePointerUnguardedBase\n {\n protected:\n-  struct Loser\n+  struct _Loser\n   {\n-    int source;\n-    const T* keyp;\n+    int _M_source;\n+    const _Tp* _M_keyp;\n   };\n \n-  unsigned int ik, k, offset;\n-  Loser* losers;\n-  Comparator comp;\n+  unsigned int __ik, __k, __offset;\n+  _Loser* __losers;\n+  _Compare __comp;\n \n public:\n \n   inline\n-  LoserTreePointerUnguardedBase(unsigned int _k, const T& _sentinel,\n-      Comparator _comp = std::less<T>())\n-    : comp(_comp)\n+  LoserTreePointerUnguardedBase(unsigned int _k, const _Tp& _sentinel,\n+      _Compare _comp = std::less<_Tp>())\n+    : __comp(_comp)\n   {\n-    ik = _k;\n+    __ik = _k;\n \n     // Next greater power of 2.\n-    k = 1 << (__log2(ik - 1) + 1);\n-    offset = k;\n-    // Avoid default-constructing losers[].key\n-    losers = new Loser[2 * k];\n+    __k = 1 << (__log2(__ik - 1) + 1);\n+    __offset = __k;\n+    // Avoid default-constructing __losers[]._M_key\n+    __losers = new _Loser[2 * __k];\n \n-    for (unsigned int i = k + ik - 1; i < (2 * k); ++i)\n+    for (unsigned int __i = __k + __ik - 1; __i < (2 * __k); ++__i)\n       {\n-        losers[i].keyp = &_sentinel;\n-        losers[i].source = -1;\n+        __losers[__i]._M_keyp = &_sentinel;\n+        __losers[__i]._M_source = -1;\n       }\n   }\n \n   inline ~LoserTreePointerUnguardedBase()\n-  { delete[] losers; }\n+  { delete[] __losers; }\n \n   inline int\n-  get_min_source()\n+  __get_min_source()\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n-    return losers[0].source;\n+    return __losers[0]._M_source;\n   }\n \n   inline void\n-  insert_start(const T& key, int source, bool)\n+  __insert_start(const _Tp& _M_key, int _M_source, bool)\n   {\n-    unsigned int pos = k + source;\n+    unsigned int __pos = __k + _M_source;\n \n-    losers[pos].keyp = &key;\n-    losers[pos].source = source;\n+    __losers[__pos]._M_keyp = &_M_key;\n+    __losers[__pos]._M_source = _M_source;\n   }\n };\n \n@@ -849,81 +849,81 @@ class LoserTreePointerUnguardedBase\n  *\n  * Unstable variant is implemented below using partial specialization.\n  */\n-template<bool stable/* default == true */, typename T, typename Comparator>\n+template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n class LoserTreePointerUnguarded :\n-    public LoserTreePointerUnguardedBase<T, Comparator>\n+    public LoserTreePointerUnguardedBase<_Tp, _Compare>\n {\n-  typedef LoserTreePointerUnguardedBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n+  typedef LoserTreePointerUnguardedBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n \n public:\n-  LoserTreePointerUnguarded(unsigned int _k, const T& _sentinel,\n-      Comparator _comp = std::less<T>())\n+  LoserTreePointerUnguarded(unsigned int _k, const _Tp& _sentinel,\n+      _Compare _comp = std::less<_Tp>())\n     : Base::LoserTreePointerUnguardedBase(_k, _sentinel, _comp)\n   {}\n \n   unsigned int\n-  init_winner(unsigned int root)\n+  __init_winner(unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n-        if (!comp(*losers[right].keyp, *losers[left].keyp))\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n+        if (!__comp(*__losers[__right]._M_keyp, *__losers[__left]._M_keyp))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n   inline void\n-  init()\n+  __init()\n   {\n-    losers[0] = losers[init_winner(1)];\n+    __losers[0] = __losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n   }\n \n   inline void\n-  delete_min_insert(const T& key, bool sup)\n+  __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    const T* keyp = &key;\n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    const _Tp* _M_keyp = &_M_key;\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n-        // The smaller one gets promoted, ties are broken by source.\n-        if (comp(*losers[pos].keyp, *keyp)\n-          || (!comp(*keyp, *losers[pos].keyp) && losers[pos].source < source))\n+        // The smaller one gets promoted, ties are broken by _M_source.\n+        if (__comp(*__losers[__pos]._M_keyp, *_M_keyp)\n+          || (!__comp(*_M_keyp, *__losers[__pos]._M_keyp) && __losers[__pos]._M_source < _M_source))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].keyp, keyp);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    losers[0].source = source;\n-    losers[0].keyp = keyp;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_keyp = _M_keyp;\n   }\n };\n \n@@ -932,87 +932,87 @@ class LoserTreePointerUnguarded :\n  *\n  * Stable variant is above.\n  */\n-template<typename T, typename Comparator>\n-class LoserTreePointerUnguarded</* stable == */false, T, Comparator> :\n-    public LoserTreePointerUnguardedBase<T, Comparator>\n+template<typename _Tp, typename _Compare>\n+class LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare> :\n+    public LoserTreePointerUnguardedBase<_Tp, _Compare>\n {\n-  typedef LoserTreePointerUnguardedBase<T, Comparator> Base;\n-  using Base::k;\n-  using Base::losers;\n+  typedef LoserTreePointerUnguardedBase<_Tp, _Compare> Base;\n+  using Base::__k;\n+  using Base::__losers;\n \n public:\n-  LoserTreePointerUnguarded(unsigned int _k, const T& _sentinel,\n-      Comparator _comp = std::less<T>())\n+  LoserTreePointerUnguarded(unsigned int _k, const _Tp& _sentinel,\n+      _Compare _comp = std::less<_Tp>())\n     : Base::LoserTreePointerUnguardedBase(_k, _sentinel, _comp)\n   {}\n \n   unsigned int\n-  init_winner(unsigned int root)\n+  __init_winner(unsigned int __root)\n   {\n-    if (root >= k)\n+    if (__root >= __k)\n       {\n-        return root;\n+        return __root;\n       }\n     else\n       {\n-        unsigned int left = init_winner (2 * root);\n-        unsigned int right = init_winner (2 * root + 1);\n+        unsigned int __left = __init_winner (2 * __root);\n+        unsigned int __right = __init_winner (2 * __root + 1);\n \n #if _GLIBCXX_ASSERTIONS\n-        // If left one is sentinel then right one must be, too.\n-        if (losers[left].source == -1)\n-          _GLIBCXX_PARALLEL_ASSERT(losers[right].source == -1);\n+        // If __left one is sentinel then __right one must be, too.\n+        if (__losers[__left]._M_source == -1)\n+          _GLIBCXX_PARALLEL_ASSERT(__losers[__right]._M_source == -1);\n #endif\n \n-        if (!comp(*losers[right].keyp, *losers[left].keyp))\n+        if (!__comp(*__losers[__right]._M_keyp, *__losers[__left]._M_keyp))\n           {\n             // Left one is less or equal.\n-            losers[root] = losers[right];\n-            return left;\n+            __losers[__root] = __losers[__right];\n+            return __left;\n           }\n         else\n           {\n             // Right one is less.\n-            losers[root] = losers[left];\n-            return right;\n+            __losers[__root] = __losers[__left];\n+            return __right;\n           }\n       }\n   }\n \n   inline void\n-  init()\n+  __init()\n   {\n-    losers[0] = losers[init_winner(1)];\n+    __losers[0] = __losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n   }\n \n   inline void\n-  delete_min_insert(const T& key, bool sup)\n+  __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n   {\n #if _GLIBCXX_ASSERTIONS\n     // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(losers[0].source != -1);\n+    _GLIBCXX_PARALLEL_ASSERT(__losers[0]._M_source != -1);\n #endif\n \n-    const T* keyp = &key;\n-    int source = losers[0].source;\n-    for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n+    const _Tp* _M_keyp = &_M_key;\n+    int _M_source = __losers[0]._M_source;\n+    for (unsigned int __pos = (__k + _M_source) / 2; __pos > 0; __pos /= 2)\n       {\n         // The smaller one gets promoted.\n-        if (comp(*(losers[pos].keyp), *keyp))\n+        if (__comp(*(__losers[__pos]._M_keyp), *_M_keyp))\n           {\n             // The other one is smaller.\n-            std::swap(losers[pos].source, source);\n-            std::swap(losers[pos].keyp, keyp);\n+            std::swap(__losers[__pos]._M_source, _M_source);\n+            std::swap(__losers[__pos]._M_keyp, _M_keyp);\n           }\n       }\n \n-    losers[0].source = source;\n-    losers[0].keyp = keyp;\n+    __losers[0]._M_source = _M_source;\n+    __losers[0]._M_keyp = _M_keyp;\n   }\n };\n "}, {"sha": "7b61ca692e8ecc223e00c2885d5e4a997ba55a0b", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -37,224 +37,224 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Merge routine being able to merge only the @c max_length\n+  /** @brief Merge routine being able to merge only the @__c __max_length\n    * smallest elements.\n    *\n-   * The @c begin iterators are advanced accordingly, they might not\n-   * reach @c end, in contrast to the usual variant.\n-   * @param begin1 Begin iterator of first sequence.\n-   * @param end1 End iterator of first sequence.\n-   * @param begin2 Begin iterator of second sequence.\n-   * @param end2 End iterator of second sequence.\n-   * @param target Target begin iterator.\n-   * @param max_length Maximum number of elements to merge.\n-   * @param comp Comparator.\n+   * The @__c __begin iterators are advanced accordingly, they might not\n+   * reach @__c __end, in contrast to the usual variant.\n+   * @param __begin1 Begin iterator of first sequence.\n+   * @param __end1 End iterator of first sequence.\n+   * @param __begin2 Begin iterator of second sequence.\n+   * @param __end2 End iterator of second sequence.\n+   * @param __target Target begin iterator.\n+   * @param __max_length Maximum number of elements to merge.\n+   * @param __comp Comparator.\n    * @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename OutputIterator, typename _DifferenceTp,\n-\t   typename Comparator>\n-    OutputIterator\n-    merge_advance_usual(RandomAccessIterator1& begin1,\n-\t\t\tRandomAccessIterator1 end1,\n-\t\t\tRandomAccessIterator2& begin2,\n-\t\t\tRandomAccessIterator2 end2, OutputIterator target,\n-\t\t\t_DifferenceTp max_length, Comparator comp)\n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _OutputIterator, typename _DifferenceTp,\n+\t   typename _Compare>\n+    _OutputIterator\n+    __merge_advance_usual(_RAIter1& __begin1,\n+\t\t\t_RAIter1 __end1,\n+\t\t\t_RAIter2& __begin2,\n+\t\t\t_RAIter2 __end2, _OutputIterator __target,\n+\t\t\t_DifferenceTp __max_length, _Compare __comp)\n     {\n-      typedef _DifferenceTp difference_type;\n-      while (begin1 != end1 && begin2 != end2 && max_length > 0)\n+      typedef _DifferenceTp _DifferenceType;\n+      while (__begin1 != __end1 && __begin2 != __end2 && __max_length > 0)\n \t{\n-\t  // array1[i1] < array0[i0]\n-\t  if (comp(*begin2, *begin1))\n-\t    *target++ = *begin2++;\n+\t  // array1[__i1] < array0[i0]\n+\t  if (__comp(*__begin2, *__begin1))\n+\t    *__target++ = *__begin2++;\n \t  else\n-\t    *target++ = *begin1++;\n-\t  --max_length;\n+\t    *__target++ = *__begin1++;\n+\t  --__max_length;\n \t}\n \n-      if (begin1 != end1)\n+      if (__begin1 != __end1)\n \t{\n-\t  target = std::copy(begin1, begin1 + max_length, target);\n-\t  begin1 += max_length;\n+\t  __target = std::copy(__begin1, __begin1 + __max_length, __target);\n+\t  __begin1 += __max_length;\n \t}\n       else\n \t{\n-\t  target = std::copy(begin2, begin2 + max_length, target);\n-\t  begin2 += max_length;\n+\t  __target = std::copy(__begin2, __begin2 + __max_length, __target);\n+\t  __begin2 += __max_length;\n \t}\n-      return target;\n+      return __target;\n     }\n \n-  /** @brief Merge routine being able to merge only the @c max_length\n+  /** @brief Merge routine being able to merge only the @__c __max_length\n    * smallest elements.\n    *\n-   * The @c begin iterators are advanced accordingly, they might not\n-   * reach @c end, in contrast to the usual variant.\n+   * The @__c __begin iterators are advanced accordingly, they might not\n+   * reach @__c __end, in contrast to the usual variant.\n    * Specially designed code should allow the compiler to generate\n    * conditional moves instead of branches.\n-   * @param begin1 Begin iterator of first sequence.\n-   * @param end1 End iterator of first sequence.\n-   * @param begin2 Begin iterator of second sequence.\n-   * @param end2 End iterator of second sequence.\n-   * @param target Target begin iterator.\n-   * @param max_length Maximum number of elements to merge.\n-   * @param comp Comparator.\n+   * @param __begin1 Begin iterator of first sequence.\n+   * @param __end1 End iterator of first sequence.\n+   * @param __begin2 Begin iterator of second sequence.\n+   * @param __end2 End iterator of second sequence.\n+   * @param __target Target begin iterator.\n+   * @param __max_length Maximum number of elements to merge.\n+   * @param __comp Comparator.\n    * @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename OutputIterator, typename _DifferenceTp,\n-\t   typename Comparator>\n-    OutputIterator\n-    merge_advance_movc(RandomAccessIterator1& begin1,\n-\t\t       RandomAccessIterator1 end1,\n-\t\t       RandomAccessIterator2& begin2,\n-\t\t       RandomAccessIterator2 end2,\n-\t\t       OutputIterator target,\n-\t\t       _DifferenceTp max_length, Comparator comp)\n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _OutputIterator, typename _DifferenceTp,\n+\t   typename _Compare>\n+    _OutputIterator\n+    __merge_advance_movc(_RAIter1& __begin1,\n+\t\t       _RAIter1 __end1,\n+\t\t       _RAIter2& __begin2,\n+\t\t       _RAIter2 __end2,\n+\t\t       _OutputIterator __target,\n+\t\t       _DifferenceTp __max_length, _Compare __comp)\n     {\n-      typedef _DifferenceTp difference_type;\n-      typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+      typedef _DifferenceTp _DifferenceType;\n+      typedef typename std::iterator_traits<_RAIter1>::value_type\n \tvalue_type1;\n-      typedef typename std::iterator_traits<RandomAccessIterator2>::value_type\n+      typedef typename std::iterator_traits<_RAIter2>::value_type\n \tvalue_type2;\n \n #if _GLIBCXX_ASSERTIONS\n-      _GLIBCXX_PARALLEL_ASSERT(max_length >= 0);\n+      _GLIBCXX_PARALLEL_ASSERT(__max_length >= 0);\n #endif\n \n-      while (begin1 != end1 && begin2 != end2 && max_length > 0)\n+      while (__begin1 != __end1 && __begin2 != __end2 && __max_length > 0)\n \t{\n-\t  RandomAccessIterator1 next1 = begin1 + 1;\n-\t  RandomAccessIterator2 next2 = begin2 + 1;\n-\t  value_type1 element1 = *begin1;\n-\t  value_type2 element2 = *begin2;\n+\t  _RAIter1 __next1 = __begin1 + 1;\n+\t  _RAIter2 __next2 = __begin2 + 1;\n+\t  value_type1 __element1 = *__begin1;\n+\t  value_type2 __element2 = *__begin2;\n \n-\t  if (comp(element2, element1))\n+\t  if (__comp(__element2, __element1))\n \t    {\n-\t      element1 = element2;\n-\t      begin2 = next2;\n+\t      __element1 = __element2;\n+\t      __begin2 = __next2;\n \t    }\n \t  else\n-\t    begin1 = next1;\n+\t    __begin1 = __next1;\n \n-\t  *target = element1;\n+\t  *__target = __element1;\n \n-\t  ++target;\n-\t  --max_length;\n+\t  ++__target;\n+\t  --__max_length;\n \t}\n-      if (begin1 != end1)\n+      if (__begin1 != __end1)\n \t{\n-\t  target = std::copy(begin1, begin1 + max_length, target);\n-\t  begin1 += max_length;\n+\t  __target = std::copy(__begin1, __begin1 + __max_length, __target);\n+\t  __begin1 += __max_length;\n \t}\n       else\n \t{\n-\t  target = std::copy(begin2, begin2 + max_length, target);\n-\t  begin2 += max_length;\n+\t  __target = std::copy(__begin2, __begin2 + __max_length, __target);\n+\t  __begin2 += __max_length;\n \t}\n-      return target;\n+      return __target;\n     }\n \n-  /** @brief Merge routine being able to merge only the @c max_length\n+  /** @brief Merge routine being able to merge only the @__c __max_length\n    * smallest elements.\n    *\n-   *  The @c begin iterators are advanced accordingly, they might not\n-   *  reach @c end, in contrast to the usual variant.\n+   *  The @__c __begin iterators are advanced accordingly, they might not\n+   *  reach @__c __end, in contrast to the usual variant.\n    *  Static switch on whether to use the conditional-move variant.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence.\n-   *  @param end2 End iterator of second sequence.\n-   *  @param target Target begin iterator.\n-   *  @param max_length Maximum number of elements to merge.\n-   *  @param comp Comparator.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence.\n+   *  @param __end2 End iterator of second sequence.\n+   *  @param __target Target begin iterator.\n+   *  @param __max_length Maximum number of elements to merge.\n+   *  @param __comp Comparator.\n    *  @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename OutputIterator, typename _DifferenceTp,\n-\t   typename Comparator>\n-    inline OutputIterator\n-    merge_advance(RandomAccessIterator1& begin1, RandomAccessIterator1 end1,\n-\t\t  RandomAccessIterator2& begin2, RandomAccessIterator2 end2,\n-\t\t  OutputIterator target, _DifferenceTp max_length,\n-\t\t  Comparator comp)\n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _OutputIterator, typename _DifferenceTp,\n+\t   typename _Compare>\n+    inline _OutputIterator\n+    __merge_advance(_RAIter1& __begin1, _RAIter1 __end1,\n+\t\t  _RAIter2& __begin2, _RAIter2 __end2,\n+\t\t  _OutputIterator __target, _DifferenceTp __max_length,\n+\t\t  _Compare __comp)\n     {\n-      _GLIBCXX_CALL(max_length)\n+      _GLIBCXX_CALL(__max_length)\n \n-      return merge_advance_movc(begin1, end1, begin2, end2, target,\n-\t\t\t\tmax_length, comp);\n+      return __merge_advance_movc(__begin1, __end1, __begin2, __end2, __target,\n+\t\t\t\t__max_length, __comp);\n     }\n \n   /** @brief Merge routine fallback to sequential in case the\n       iterators of the two input sequences are of different type.\n-      *  @param begin1 Begin iterator of first sequence.\n-      *  @param end1 End iterator of first sequence.\n-      *  @param begin2 Begin iterator of second sequence.\n-      *  @param end2 End iterator of second sequence.\n-      *  @param target Target begin iterator.\n-      *  @param max_length Maximum number of elements to merge.\n-      *  @param comp Comparator.\n+      *  @param __begin1 Begin iterator of first sequence.\n+      *  @param __end1 End iterator of first sequence.\n+      *  @param __begin2 Begin iterator of second sequence.\n+      *  @param __end2 End iterator of second sequence.\n+      *  @param __target Target begin iterator.\n+      *  @param __max_length Maximum number of elements to merge.\n+      *  @param __comp Comparator.\n       *  @return Output end iterator. */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename RandomAccessIterator3, typename Comparator>\n-    inline RandomAccessIterator3\n-    parallel_merge_advance(RandomAccessIterator1& begin1,\n-\t\t\t   RandomAccessIterator1 end1,\n-\t\t\t   RandomAccessIterator2& begin2,\n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _RAIter3, typename _Compare>\n+    inline _RAIter3\n+    __parallel_merge_advance(_RAIter1& __begin1,\n+\t\t\t   _RAIter1 __end1,\n+\t\t\t   _RAIter2& __begin2,\n \t\t\t   // different iterators, parallel implementation\n \t\t\t   // not available\t\t\t   \n-\t\t\t   RandomAccessIterator2 end2,\n-\t\t\t   RandomAccessIterator3 target, typename\n-\t\t\t   std::iterator_traits<RandomAccessIterator1>::\n-\t\t\t   difference_type max_length, Comparator comp)\n-    { return merge_advance(begin1, end1, begin2, end2, target,\n-\t\t\t   max_length, comp); }\n+\t\t\t   _RAIter2 __end2,\n+\t\t\t   _RAIter3 __target, typename\n+\t\t\t   std::iterator_traits<_RAIter1>::\n+\t\t\t   difference_type __max_length, _Compare __comp)\n+    { return __merge_advance(__begin1, __end1, __begin2, __end2, __target,\n+\t\t\t   __max_length, __comp); }\n \n-  /** @brief Parallel merge routine being able to merge only the @c\n-   * max_length smallest elements.\n+  /** @brief Parallel merge routine being able to merge only the @__c\n+   * __max_length smallest elements.\n    *\n-   *  The @c begin iterators are advanced accordingly, they might not\n-   *  reach @c end, in contrast to the usual variant.\n+   *  The @__c __begin iterators are advanced accordingly, they might not\n+   *  reach @__c __end, in contrast to the usual variant.\n    *  The functionality is projected onto parallel_multiway_merge.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence.\n-   *  @param end2 End iterator of second sequence.\n-   *  @param target Target begin iterator.\n-   *  @param max_length Maximum number of elements to merge.\n-   *  @param comp Comparator.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence.\n+   *  @param __end2 End iterator of second sequence.\n+   *  @param __target Target begin iterator.\n+   *  @param __max_length Maximum number of elements to merge.\n+   *  @param __comp Comparator.\n    *  @return Output end iterator.\n    */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator3,\n-\t   typename Comparator>\n-    inline RandomAccessIterator3\n-    parallel_merge_advance(RandomAccessIterator1& begin1,\n-\t\t\t   RandomAccessIterator1 end1,\n-\t\t\t   RandomAccessIterator1& begin2,\n-\t\t\t   RandomAccessIterator1 end2,\n-\t\t\t   RandomAccessIterator3 target, typename\n-\t\t\t   std::iterator_traits<RandomAccessIterator1>::\n-\t\t\t   difference_type max_length, Comparator comp)\n+  template<typename _RAIter1, typename _RAIter3,\n+\t   typename _Compare>\n+    inline _RAIter3\n+    __parallel_merge_advance(_RAIter1& __begin1,\n+\t\t\t   _RAIter1 __end1,\n+\t\t\t   _RAIter1& __begin2,\n+\t\t\t   _RAIter1 __end2,\n+\t\t\t   _RAIter3 __target, typename\n+\t\t\t   std::iterator_traits<_RAIter1>::\n+\t\t\t   difference_type __max_length, _Compare __comp)\n     {\n       typedef typename\n-          std::iterator_traits<RandomAccessIterator1>::value_type value_type;\n-      typedef typename std::iterator_traits<RandomAccessIterator1>::\n-\tdifference_type difference_type1 /* == difference_type2 */;\n-      typedef typename std::iterator_traits<RandomAccessIterator3>::\n-\tdifference_type difference_type3;\n-      typedef typename std::pair<RandomAccessIterator1, RandomAccessIterator1>\n-        iterator_pair;\n+          std::iterator_traits<_RAIter1>::value_type _ValueType;\n+      typedef typename std::iterator_traits<_RAIter1>::\n+\tdifference_type _DifferenceType1 /* == difference_type2 */;\n+      typedef typename std::iterator_traits<_RAIter3>::\n+\tdifference_type _DifferenceType3;\n+      typedef typename std::pair<_RAIter1, _RAIter1>\n+        _IteratorPair;\n \n-      iterator_pair\n-\tseqs[2] = { std::make_pair(begin1, end1),\n-\t\t    std::make_pair(begin2, end2) };\n-      RandomAccessIterator3\n-        target_end = parallel_multiway_merge\n-          < /* stable = */ true, /* sentinels = */ false>(\n-            seqs, seqs + 2, target,\n+      _IteratorPair\n+\tseqs[2] = { std::make_pair(__begin1, __end1),\n+\t\t    std::make_pair(__begin2, __end2) };\n+      _RAIter3\n+        __target_end = parallel_multiway_merge\n+          < /* __stable = */ true, /* __sentinels = */ false>(\n+            seqs, seqs + 2, __target,\n             multiway_merge_exact_splitting\n-              < /* stable = */ true, iterator_pair*,\n-                Comparator, difference_type1>,\n-            max_length, comp, omp_get_max_threads());\n+              < /* __stable = */ true, _IteratorPair*,\n+                _Compare, _DifferenceType1>,\n+            __max_length, __comp, omp_get_max_threads());\n \n-      return target_end;\n+      return __target_end;\n     }\n }\t//namespace __gnu_parallel\n "}, {"sha": "353330e3f5ae6e222a85fdfa77e1fe826a19b2f7", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 309, "deletions": 309, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file parallel/multiseq_selection.h\n- *  @brief Functions to find elements of a certain global rank in\n+ *  @brief Functions to find elements of a certain global __rank in\n  *  multiple sorted sequences.  Also serves for splitting such\n  *  sequence sets.\n  *\n@@ -50,584 +50,584 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Compare a pair of types lexicographically, ascending. */\n-  template<typename T1, typename T2, typename Comparator>\n-    class lexicographic\n-    : public std::binary_function<std::pair<T1, T2>, std::pair<T1, T2>, bool>\n+  /** @brief Compare __a pair of types lexicographically, ascending. */\n+  template<typename _T1, typename _T2, typename _Compare>\n+    class _Lexicographic\n+    : public std::binary_function<std::pair<_T1, _T2>, std::pair<_T1, _T2>, bool>\n     {\n     private:\n-      Comparator& comp;\n+      _Compare& __comp;\n \n     public:\n-      lexicographic(Comparator& _comp) : comp(_comp) { }\n+      _Lexicographic(_Compare& _comp) : __comp(_comp) { }\n \n       bool\n-      operator()(const std::pair<T1, T2>& p1,\n-\t\t const std::pair<T1, T2>& p2) const\n+      operator()(const std::pair<_T1, _T2>& __p1,\n+\t\t const std::pair<_T1, _T2>& __p2) const\n       {\n-\tif (comp(p1.first, p2.first))\n+\tif (__comp(__p1.first, __p2.first))\n \t  return true;\n \n-\tif (comp(p2.first, p1.first))\n+\tif (__comp(__p2.first, __p1.first))\n \t  return false;\n \n \t// Firsts are equal.\n-\treturn p1.second < p2.second;\n+\treturn __p1.second < __p2.second;\n       }\n     };\n \n-  /** @brief Compare a pair of types lexicographically, descending. */\n-  template<typename T1, typename T2, typename Comparator>\n-    class lexicographic_reverse : public std::binary_function<T1, T2, bool>\n+  /** @brief Compare __a pair of types lexicographically, descending. */\n+  template<typename _T1, typename _T2, typename _Compare>\n+    class _LexicographicReverse : public std::binary_function<_T1, _T2, bool>\n     {\n     private:\n-      Comparator& comp;\n+      _Compare& __comp;\n \n     public:\n-      lexicographic_reverse(Comparator& _comp) : comp(_comp) { }\n+      _LexicographicReverse(_Compare& _comp) : __comp(_comp) { }\n \n       bool\n-      operator()(const std::pair<T1, T2>& p1,\n-\t\t const std::pair<T1, T2>& p2) const\n+      operator()(const std::pair<_T1, _T2>& __p1,\n+\t\t const std::pair<_T1, _T2>& __p2) const\n       {\n-\tif (comp(p2.first, p1.first))\n+\tif (__comp(__p2.first, __p1.first))\n \t  return true;\n \n-\tif (comp(p1.first, p2.first))\n+\tif (__comp(__p1.first, __p2.first))\n \t  return false;\n \n \t// Firsts are equal.\n-\treturn p2.second < p1.second;\n+\treturn __p2.second < __p1.second;\n       }\n     };\n \n   /** \n-   *  @brief Splits several sorted sequences at a certain global rank,\n+   *  @brief Splits several sorted sequences at __a certain global __rank,\n    *  resulting in a splitting point for each sequence.\n-   *  The sequences are passed via a sequence of random-access\n+   *  The sequences are passed via __a __sequence of random-access\n    *  iterator pairs, none of the sequences may be empty.  If there\n    *  are several equal elements across the split, the ones on the\n-   *  left side will be chosen from sequences with smaller number.\n-   *  @param begin_seqs Begin of the sequence of iterator pairs.\n-   *  @param end_seqs End of the sequence of iterator pairs.\n-   *  @param rank The global rank to partition at.\n-   *  @param begin_offsets A random-access sequence begin where the\n-   *  result will be stored in. Each element of the sequence is an\n+   *  __left side will be chosen from sequences with smaller number.\n+   *  @param __begin_seqs Begin of the sequence of iterator pairs.\n+   *  @param __end_seqs End of the sequence of iterator pairs.\n+   *  @param __rank The global __rank to partition at.\n+   *  @param __begin_offsets A random-access __sequence __begin where the\n+   *  __result will be stored in. Each element of the sequence is an\n    *  iterator that points to the first element on the greater part of\n-   *  the respective sequence.\n-   *  @param comp The ordering functor, defaults to std::less<T>. \n+   *  the respective __sequence.\n+   *  @param __comp The ordering functor, defaults to std::less<_Tp>. \n    */\n-  template<typename RanSeqs, typename RankType, typename RankIterator,\n-            typename Comparator>\n+  template<typename _RanSeqs, typename _RankType, typename _RankIterator,\n+            typename _Compare>\n     void\n-    multiseq_partition(RanSeqs begin_seqs, RanSeqs end_seqs,\n-                       RankType rank,\n-                       RankIterator begin_offsets,\n-                       Comparator comp = std::less<\n+    multiseq_partition(_RanSeqs __begin_seqs, _RanSeqs __end_seqs,\n+                       _RankType __rank,\n+                       _RankIterator __begin_offsets,\n+                       _Compare __comp = std::less<\n                        typename std::iterator_traits<typename\n-                       std::iterator_traits<RanSeqs>::value_type::\n-                       first_type>::value_type>()) // std::less<T>\n+                       std::iterator_traits<_RanSeqs>::value_type::\n+                       first_type>::value_type>()) // std::less<_Tp>\n     {\n-      _GLIBCXX_CALL(end_seqs - begin_seqs)\n+      _GLIBCXX_CALL(__end_seqs - __begin_seqs)\n \n-      typedef typename std::iterator_traits<RanSeqs>::value_type::first_type\n-        It;\n-      typedef typename std::iterator_traits<It>::difference_type\n-\t       difference_type;\n-      typedef typename std::iterator_traits<It>::value_type value_type;\n+      typedef typename std::iterator_traits<_RanSeqs>::value_type::first_type\n+        _It;\n+      typedef typename std::iterator_traits<_It>::difference_type\n+\t       _DifferenceType;\n+      typedef typename std::iterator_traits<_It>::value_type _ValueType;\n \n-      lexicographic<value_type, int, Comparator> lcomp(comp);\n-      lexicographic_reverse<value_type, int, Comparator> lrcomp(comp);\n+      _Lexicographic<_ValueType, int, _Compare> __lcomp(__comp);\n+      _LexicographicReverse<_ValueType, int, _Compare> __lrcomp(__comp);\n \n       // Number of sequences, number of elements in total (possibly\n       // including padding).\n-      difference_type m = std::distance(begin_seqs, end_seqs), N = 0,\n-                      nmax, n, r;\n+      _DifferenceType __m = std::distance(__begin_seqs, __end_seqs), __N = 0,\n+                      __nmax, __n, __r;\n \n-      for (int i = 0; i < m; i++)\n+      for (int __i = 0; __i < __m; __i++)\n         {\n-          N += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+          __N += std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n           _GLIBCXX_PARALLEL_ASSERT(\n-            std::distance(begin_seqs[i].first, begin_seqs[i].second) > 0);\n+            std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second) > 0);\n         }\n \n-      if (rank == N)\n+      if (__rank == __N)\n         {\n-          for (int i = 0; i < m; i++)\n-            begin_offsets[i] = begin_seqs[i].second; // Very end.\n-          // Return m - 1;\n+          for (int __i = 0; __i < __m; __i++)\n+            __begin_offsets[__i] = __begin_seqs[__i].second; // Very end.\n+          // Return __m - 1;\n           return;\n         }\n \n-      _GLIBCXX_PARALLEL_ASSERT(m != 0);\n-      _GLIBCXX_PARALLEL_ASSERT(N != 0);\n-      _GLIBCXX_PARALLEL_ASSERT(rank >= 0);\n-      _GLIBCXX_PARALLEL_ASSERT(rank < N);\n+      _GLIBCXX_PARALLEL_ASSERT(__m != 0);\n+      _GLIBCXX_PARALLEL_ASSERT(__N != 0);\n+      _GLIBCXX_PARALLEL_ASSERT(__rank >= 0);\n+      _GLIBCXX_PARALLEL_ASSERT(__rank < __N);\n \n-      difference_type* ns = new difference_type[m];\n-      difference_type* a = new difference_type[m];\n-      difference_type* b = new difference_type[m];\n-      difference_type l;\n+      _DifferenceType* __ns = new _DifferenceType[__m];\n+      _DifferenceType* __a = new _DifferenceType[__m];\n+      _DifferenceType* __b = new _DifferenceType[__m];\n+      _DifferenceType __l;\n \n-      ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n-      nmax = ns[0];\n-      for (int i = 0; i < m; i++)\n+      __ns[0] = std::distance(__begin_seqs[0].first, __begin_seqs[0].second);\n+      __nmax = __ns[0];\n+      for (int __i = 0; __i < __m; __i++)\n \t{\n-\t  ns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n-\t  nmax = std::max(nmax, ns[i]);\n+\t  __ns[__i] = std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n+\t  __nmax = std::max(__nmax, __ns[__i]);\n \t}\n \n-      r = __log2(nmax) + 1;\n+      __r = __log2(__nmax) + 1;\n \n-      // Pad all lists to this length, at least as long as any ns[i],\n-      // equality iff nmax = 2^k - 1.\n-      l = (1ULL << r) - 1;\n+      // Pad all lists to this length, at least as long as any ns[__i],\n+      // equality iff __nmax = 2^__k - 1.\n+      __l = (1ULL << __r) - 1;\n \n       // From now on, including padding.\n-      N = l * m;\n+      __N = __l * __m;\n \n-      for (int i = 0; i < m; i++)\n+      for (int __i = 0; __i < __m; __i++)\n \t{\n-\t  a[i] = 0;\n-\t  b[i] = l;\n+\t  __a[__i] = 0;\n+\t  __b[__i] = __l;\n \t}\n-      n = l / 2;\n+      __n = __l / 2;\n \n       // Invariants:\n-      // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n+      // 0 <= __a[__i] <= __ns[__i], 0 <= __b[__i] <= __l\n \n-#define S(i) (begin_seqs[i].first)\n+#define __S(__i) (__begin_seqs[__i].first)\n \n       // Initial partition.\n-      std::vector<std::pair<value_type, int> > sample;\n+      std::vector<std::pair<_ValueType, int> > __sample;\n \n-      for (int i = 0; i < m; i++)\n-\tif (n < ns[i])\t//sequence long enough\n-\t  sample.push_back(std::make_pair(S(i)[n], i));\n-      __gnu_sequential::sort(sample.begin(), sample.end(), lcomp);\n+      for (int __i = 0; __i < __m; __i++)\n+\tif (__n < __ns[__i])\t//__sequence long enough\n+\t  __sample.push_back(std::make_pair(__S(__i)[__n], __i));\n+      __gnu_sequential::sort(__sample.begin(), __sample.end(), __lcomp);\n \n-      for (int i = 0; i < m; i++)\t//conceptual infinity\n-\tif (n >= ns[i])\t//sequence too short, conceptual infinity\n-\t  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n+      for (int __i = 0; __i < __m; __i++)\t//conceptual infinity\n+\tif (__n >= __ns[__i])\t//__sequence too short, conceptual infinity\n+\t  __sample.push_back(std::make_pair(__S(__i)[0] /*__dummy element*/, __i));\n \n-      difference_type localrank = rank * m / N ;\n+      _DifferenceType localrank = __rank * __m / __N ;\n \n-      int j;\n-      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)\n-\ta[sample[j].second] += n + 1;\n-      for (; j < m; j++)\n-\tb[sample[j].second] -= n + 1;\n+      int __j;\n+      for (__j = 0; __j < localrank && ((__n + 1) <= __ns[__sample[__j].second]); ++__j)\n+\t__a[__sample[__j].second] += __n + 1;\n+      for (; __j < __m; __j++)\n+\t__b[__sample[__j].second] -= __n + 1;\n       \n       // Further refinement.\n-      while (n > 0)\n+      while (__n > 0)\n \t{\n-\t  n /= 2;\n+\t  __n /= 2;\n \n-\t  int lmax_seq = -1;\t// to avoid warning\n-\t  const value_type* lmax = NULL; // impossible to avoid the warning?\n-\t  for (int i = 0; i < m; i++)\n+\t  int __lmax_seq = -1;\t// to avoid warning\n+\t  const _ValueType* __lmax = NULL; // impossible to avoid the warning?\n+\t  for (int __i = 0; __i < __m; __i++)\n \t    {\n-\t      if (a[i] > 0)\n+\t      if (__a[__i] > 0)\n \t\t{\n-\t\t  if (!lmax)\n+\t\t  if (!__lmax)\n \t\t    {\n-\t\t      lmax = &(S(i)[a[i] - 1]);\n-\t\t      lmax_seq = i;\n+\t\t      __lmax = &(__S(__i)[__a[__i] - 1]);\n+\t\t      __lmax_seq = __i;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      // Max, favor rear sequences.\n-\t\t      if (!comp(S(i)[a[i] - 1], *lmax))\n+\t\t      if (!__comp(__S(__i)[__a[__i] - 1], *__lmax))\n \t\t\t{\n-\t\t\t  lmax = &(S(i)[a[i] - 1]);\n-\t\t\t  lmax_seq = i;\n+\t\t\t  __lmax = &(__S(__i)[__a[__i] - 1]);\n+\t\t\t  __lmax_seq = __i;\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \n-\t  int i;\n-\t  for (i = 0; i < m; i++)\n+\t  int __i;\n+\t  for (__i = 0; __i < __m; __i++)\n \t    {\n-\t      difference_type middle = (b[i] + a[i]) / 2;\n-\t      if (lmax && middle < ns[i] &&\n-\t\t  lcomp(std::make_pair(S(i)[middle], i),\n-\t\t\tstd::make_pair(*lmax, lmax_seq)))\n-\t\ta[i] = std::min(a[i] + n + 1, ns[i]);\n+\t      _DifferenceType __middle = (__b[__i] + __a[__i]) / 2;\n+\t      if (__lmax && __middle < __ns[__i] &&\n+\t\t  __lcomp(std::make_pair(__S(__i)[__middle], __i),\n+\t\t\tstd::make_pair(*__lmax, __lmax_seq)))\n+\t\t__a[__i] = std::min(__a[__i] + __n + 1, __ns[__i]);\n \t      else\n-\t\tb[i] -= n + 1;\n+\t\t__b[__i] -= __n + 1;\n \t    }\n \n-\t  difference_type leftsize = 0, total = 0;\n-\t  for (int i = 0; i < m; i++)\n+\t  _DifferenceType __leftsize = 0, __total = 0;\n+\t  for (int __i = 0; __i < __m; __i++)\n \t    {\n-\t      leftsize += a[i] / (n + 1);\n-\t      total += l / (n + 1);\n+\t      __leftsize += __a[__i] / (__n + 1);\n+\t      __total += __l / (__n + 1);\n \t    }\n \t  \n-\t  difference_type skew = static_cast<difference_type>\n-\t    (static_cast<uint64>(total) * rank / N - leftsize);\n+\t  _DifferenceType __skew = static_cast<_DifferenceType>\n+\t    (static_cast<uint64>(__total) * __rank / __N - __leftsize);\n \n-\t  if (skew > 0)\n+\t  if (__skew > 0)\n \t    {\n \t      // Move to the left, find smallest.\n-\t      std::priority_queue<std::pair<value_type, int>,\n-\t\tstd::vector<std::pair<value_type, int> >,\n-\t\tlexicographic_reverse<value_type, int, Comparator> >\n-\t\tpq(lrcomp);\n+\t      std::priority_queue<std::pair<_ValueType, int>,\n+\t\tstd::vector<std::pair<_ValueType, int> >,\n+\t\t_LexicographicReverse<_ValueType, int, _Compare> >\n+\t\t__pq(__lrcomp);\n \t      \n-\t      for (int i = 0; i < m; i++)\n-\t\tif (b[i] < ns[i])\n-\t\t  pq.push(std::make_pair(S(i)[b[i]], i));\n+\t      for (int __i = 0; __i < __m; __i++)\n+\t\tif (__b[__i] < __ns[__i])\n+\t\t  __pq.push(std::make_pair(__S(__i)[__b[__i]], __i));\n \n-\t      for (; skew != 0 && !pq.empty(); --skew)\n+\t      for (; __skew != 0 && !__pq.empty(); --__skew)\n \t\t{\n-\t\t  int source = pq.top().second;\n-\t\t  pq.pop();\n+\t\t  int source = __pq.top().second;\n+\t\t  __pq.pop();\n \n-\t\t  a[source] = std::min(a[source] + n + 1, ns[source]);\n-\t\t  b[source] += n + 1;\n+\t\t  __a[source] = std::min(__a[source] + __n + 1, __ns[source]);\n+\t\t  __b[source] += __n + 1;\n \n-\t\t  if (b[source] < ns[source])\n-\t\t    pq.push(std::make_pair(S(source)[b[source]], source));\n+\t\t  if (__b[source] < __ns[source])\n+\t\t    __pq.push(std::make_pair(__S(source)[__b[source]], source));\n \t\t}\n \t    }\n-\t  else if (skew < 0)\n+\t  else if (__skew < 0)\n \t    {\n \t      // Move to the right, find greatest.\n-\t      std::priority_queue<std::pair<value_type, int>,\n-\t\tstd::vector<std::pair<value_type, int> >,\n-\t\tlexicographic<value_type, int, Comparator> > pq(lcomp);\n+\t      std::priority_queue<std::pair<_ValueType, int>,\n+\t\tstd::vector<std::pair<_ValueType, int> >,\n+\t\t_Lexicographic<_ValueType, int, _Compare> > __pq(__lcomp);\n \n-\t      for (int i = 0; i < m; i++)\n-\t\tif (a[i] > 0)\n-\t\t  pq.push(std::make_pair(S(i)[a[i] - 1], i));\n+\t      for (int __i = 0; __i < __m; __i++)\n+\t\tif (__a[__i] > 0)\n+\t\t  __pq.push(std::make_pair(__S(__i)[__a[__i] - 1], __i));\n \n-\t      for (; skew != 0; ++skew)\n+\t      for (; __skew != 0; ++__skew)\n \t\t{\n-\t\t  int source = pq.top().second;\n-\t\t  pq.pop();\n+\t\t  int source = __pq.top().second;\n+\t\t  __pq.pop();\n \n-\t\t  a[source] -= n + 1;\n-\t\t  b[source] -= n + 1;\n+\t\t  __a[source] -= __n + 1;\n+\t\t  __b[source] -= __n + 1;\n \n-\t\t  if (a[source] > 0)\n-\t\t    pq.push(std::make_pair(S(source)[a[source] - 1], source));\n+\t\t  if (__a[source] > 0)\n+\t\t    __pq.push(std::make_pair(__S(source)[__a[source] - 1], source));\n \t\t}\n \t    }\n \t}\n \n       // Postconditions:\n-      // a[i] == b[i] in most cases, except when a[i] has been clamped\n+      // __a[__i] == __b[__i] in most cases, except when __a[__i] has been clamped\n       // because of having reached the boundary\n \n       // Now return the result, calculate the offset.\n \n       // Compare the keys on both edges of the border.\n \n       // Maximum of left edge, minimum of right edge.\n-      value_type* maxleft = NULL;\n-      value_type* minright = NULL;\n-      for (int i = 0; i < m; i++)\n+      _ValueType* __maxleft = NULL;\n+      _ValueType* __minright = NULL;\n+      for (int __i = 0; __i < __m; __i++)\n \t{\n-\t  if (a[i] > 0)\n+\t  if (__a[__i] > 0)\n \t    {\n-\t      if (!maxleft)\n-\t\tmaxleft = &(S(i)[a[i] - 1]);\n+\t      if (!__maxleft)\n+\t\t__maxleft = &(__S(__i)[__a[__i] - 1]);\n \t      else\n \t\t{\n \t\t  // Max, favor rear sequences.\n-\t\t  if (!comp(S(i)[a[i] - 1], *maxleft))\n-\t\t    maxleft = &(S(i)[a[i] - 1]);\n+\t\t  if (!__comp(__S(__i)[__a[__i] - 1], *__maxleft))\n+\t\t    __maxleft = &(__S(__i)[__a[__i] - 1]);\n \t\t}\n \t    }\n-\t  if (b[i] < ns[i])\n+\t  if (__b[__i] < __ns[__i])\n \t    {\n-\t      if (!minright)\n-\t\tminright = &(S(i)[b[i]]);\n+\t      if (!__minright)\n+\t\t__minright = &(__S(__i)[__b[__i]]);\n \t      else\n \t\t{\n \t\t  // Min, favor fore sequences.\n-\t\t  if (comp(S(i)[b[i]], *minright))\n-\t\t    minright = &(S(i)[b[i]]);\n+\t\t  if (__comp(__S(__i)[__b[__i]], *__minright))\n+\t\t    __minright = &(__S(__i)[__b[__i]]);\n \t\t}\n \t    }\n \t}\n \n-      int seq = 0;\n-      for (int i = 0; i < m; i++)\n-\tbegin_offsets[i] = S(i) + a[i];\n+      int __seq = 0;\n+      for (int __i = 0; __i < __m; __i++)\n+\t__begin_offsets[__i] = __S(__i) + __a[__i];\n \n-      delete[] ns;\n-      delete[] a;\n-      delete[] b;\n+      delete[] __ns;\n+      delete[] __a;\n+      delete[] __b;\n     }\n \n \n   /** \n-   *  @brief Selects the element at a certain global rank from several\n+   *  @brief Selects the element at __a certain global __rank from several\n    *  sorted sequences.\n    *\n-   *  The sequences are passed via a sequence of random-access\n+   *  The sequences are passed via __a __sequence of random-access\n    *  iterator pairs, none of the sequences may be empty.\n-   *  @param begin_seqs Begin of the sequence of iterator pairs.\n-   *  @param end_seqs End of the sequence of iterator pairs.\n-   *  @param rank The global rank to partition at.\n-   *  @param offset The rank of the selected element in the global\n+   *  @param __begin_seqs Begin of the sequence of iterator pairs.\n+   *  @param __end_seqs End of the sequence of iterator pairs.\n+   *  @param __rank The global __rank to partition at.\n+   *  @param __offset The rank of the selected element in the global\n    *  subsequence of elements equal to the selected element. If the\n    *  selected element is unique, this number is 0.\n-   *  @param comp The ordering functor, defaults to std::less. \n+   *  @param __comp The ordering functor, defaults to std::less. \n    */\n-  template<typename T, typename RanSeqs, typename RankType,\n-\t   typename Comparator>\n-    T\n-    multiseq_selection(RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank,\n-\t\t       RankType& offset, Comparator comp = std::less<T>())\n+  template<typename _Tp, typename _RanSeqs, typename _RankType,\n+\t   typename _Compare>\n+    _Tp\n+    multiseq_selection(_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank,\n+\t\t       _RankType& __offset, _Compare __comp = std::less<_Tp>())\n     {\n-      _GLIBCXX_CALL(end_seqs - begin_seqs)\n+      _GLIBCXX_CALL(__end_seqs - __begin_seqs)\n \n-      typedef typename std::iterator_traits<RanSeqs>::value_type::first_type\n-\tIt;\n-      typedef typename std::iterator_traits<It>::difference_type\n-\tdifference_type;\n+      typedef typename std::iterator_traits<_RanSeqs>::value_type::first_type\n+\t_It;\n+      typedef typename std::iterator_traits<_It>::difference_type\n+\t_DifferenceType;\n \n-      lexicographic<T, int, Comparator> lcomp(comp);\n-      lexicographic_reverse<T, int, Comparator> lrcomp(comp);\n+      _Lexicographic<_Tp, int, _Compare> __lcomp(__comp);\n+      _LexicographicReverse<_Tp, int, _Compare> __lrcomp(__comp);\n \n       // Number of sequences, number of elements in total (possibly\n       // including padding).\n-      difference_type m = std::distance(begin_seqs, end_seqs);\n-      difference_type N = 0;\n-      difference_type nmax, n, r;\n+      _DifferenceType __m = std::distance(__begin_seqs, __end_seqs);\n+      _DifferenceType __N = 0;\n+      _DifferenceType __nmax, __n, __r;\n \n-      for (int i = 0; i < m; i++)\n-\tN += std::distance(begin_seqs[i].first, begin_seqs[i].second);\n+      for (int __i = 0; __i < __m; __i++)\n+\t__N += std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n \n-      if (m == 0 || N == 0 || rank < 0 || rank >= N)\n+      if (__m == 0 || __N == 0 || __rank < 0 || __rank >= __N)\n \t{\n-\t  // Result undefined when there is no data or rank is outside bounds.\n+\t  // _Result undefined when there is no data or __rank is outside bounds.\n \t  throw std::exception();\n \t}\n \n \n-      difference_type* ns = new difference_type[m];\n-      difference_type* a = new difference_type[m];\n-      difference_type* b = new difference_type[m];\n-      difference_type l;\n+      _DifferenceType* __ns = new _DifferenceType[__m];\n+      _DifferenceType* __a = new _DifferenceType[__m];\n+      _DifferenceType* __b = new _DifferenceType[__m];\n+      _DifferenceType __l;\n \n-      ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n-      nmax = ns[0];\n-      for (int i = 0; i < m; ++i)\n+      __ns[0] = std::distance(__begin_seqs[0].first, __begin_seqs[0].second);\n+      __nmax = __ns[0];\n+      for (int __i = 0; __i < __m; ++__i)\n \t{\n-\t  ns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n-\t  nmax = std::max(nmax, ns[i]);\n+\t  __ns[__i] = std::distance(__begin_seqs[__i].first, __begin_seqs[__i].second);\n+\t  __nmax = std::max(__nmax, __ns[__i]);\n \t}\n \n-      r = __log2(nmax) + 1;\n+      __r = __log2(__nmax) + 1;\n \n-      // Pad all lists to this length, at least as long as any ns[i],\n-      // equality iff nmax = 2^k - 1\n-      l = pow2(r) - 1;\n+      // Pad all lists to this length, at least as long as any ns[__i],\n+      // equality iff __nmax = 2^__k - 1\n+      __l = pow2(__r) - 1;\n \n       // From now on, including padding.\n-      N = l * m;\n+      __N = __l * __m;\n \n-      for (int i = 0; i < m; ++i)\n+      for (int __i = 0; __i < __m; ++__i)\n \t{\n-\t  a[i] = 0;\n-\t  b[i] = l;\n+\t  __a[__i] = 0;\n+\t  __b[__i] = __l;\n \t}\n-      n = l / 2;\n+      __n = __l / 2;\n \n       // Invariants:\n-      // 0 <= a[i] <= ns[i], 0 <= b[i] <= l\n+      // 0 <= __a[__i] <= __ns[__i], 0 <= __b[__i] <= __l\n \n-#define S(i) (begin_seqs[i].first)\n+#define __S(__i) (__begin_seqs[__i].first)\n \n       // Initial partition.\n-      std::vector<std::pair<T, int> > sample;\n+      std::vector<std::pair<_Tp, int> > __sample;\n \n-      for (int i = 0; i < m; i++)\n-\tif (n < ns[i])\n-\t  sample.push_back(std::make_pair(S(i)[n], i));\n-      __gnu_sequential::sort(sample.begin(), sample.end(),\n-\t\t\t     lcomp, sequential_tag());\n+      for (int __i = 0; __i < __m; __i++)\n+\tif (__n < __ns[__i])\n+\t  __sample.push_back(std::make_pair(__S(__i)[__n], __i));\n+      __gnu_sequential::sort(__sample.begin(), __sample.end(),\n+\t\t\t     __lcomp, sequential_tag());\n \n       // Conceptual infinity.\n-      for (int i = 0; i < m; i++)\n-\tif (n >= ns[i])\n-\t  sample.push_back(std::make_pair(S(i)[0] /*dummy element*/, i));\n+      for (int __i = 0; __i < __m; __i++)\n+\tif (__n >= __ns[__i])\n+\t  __sample.push_back(std::make_pair(__S(__i)[0] /*__dummy element*/, __i));\n \n-      difference_type localrank = rank * m / N ;\n+      _DifferenceType localrank = __rank * __m / __N ;\n \n-      int j;\n-      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)\n-\ta[sample[j].second] += n + 1;\n-      for (; j < m; ++j)\n-\tb[sample[j].second] -= n + 1;\n+      int __j;\n+      for (__j = 0; __j < localrank && ((__n + 1) <= __ns[__sample[__j].second]); ++__j)\n+\t__a[__sample[__j].second] += __n + 1;\n+      for (; __j < __m; ++__j)\n+\t__b[__sample[__j].second] -= __n + 1;\n \n       // Further refinement.\n-      while (n > 0)\n+      while (__n > 0)\n \t{\n-\t  n /= 2;\n+\t  __n /= 2;\n \n-\t  const T* lmax = NULL;\n-\t  for (int i = 0; i < m; ++i)\n+\t  const _Tp* __lmax = NULL;\n+\t  for (int __i = 0; __i < __m; ++__i)\n \t    {\n-\t      if (a[i] > 0)\n+\t      if (__a[__i] > 0)\n \t\t{\n-\t\t  if (!lmax)\n-\t\t    lmax = &(S(i)[a[i] - 1]);\n+\t\t  if (!__lmax)\n+\t\t    __lmax = &(__S(__i)[__a[__i] - 1]);\n \t\t  else\n \t\t    {\n-\t\t      if (comp(*lmax, S(i)[a[i] - 1]))\t//max\n-\t\t\tlmax = &(S(i)[a[i] - 1]);\n+\t\t      if (__comp(*__lmax, __S(__i)[__a[__i] - 1]))\t//max\n+\t\t\t__lmax = &(__S(__i)[__a[__i] - 1]);\n \t\t    }\n \t\t}\n \t    }\n \n-\t  int i;\n-\t  for (i = 0; i < m; i++)\n+\t  int __i;\n+\t  for (__i = 0; __i < __m; __i++)\n \t    {\n-\t      difference_type middle = (b[i] + a[i]) / 2;\n-\t      if (lmax && middle < ns[i] && comp(S(i)[middle], *lmax))\n-\t\ta[i] = std::min(a[i] + n + 1, ns[i]);\n+\t      _DifferenceType __middle = (__b[__i] + __a[__i]) / 2;\n+\t      if (__lmax && __middle < __ns[__i] && __comp(__S(__i)[__middle], *__lmax))\n+\t\t__a[__i] = std::min(__a[__i] + __n + 1, __ns[__i]);\n \t      else\n-\t\tb[i] -= n + 1;\n+\t\t__b[__i] -= __n + 1;\n \t    }\n \n-\t  difference_type leftsize = 0, total = 0;\n-\t  for (int i = 0; i < m; ++i)\n+\t  _DifferenceType __leftsize = 0, __total = 0;\n+\t  for (int __i = 0; __i < __m; ++__i)\n \t    {\n-\t      leftsize += a[i] / (n + 1);\n-\t      total += l / (n + 1);\n+\t      __leftsize += __a[__i] / (__n + 1);\n+\t      __total += __l / (__n + 1);\n \t    }\n \n-\t  difference_type skew = ((unsigned long long)total * rank / N\n-\t\t\t\t  - leftsize);\n+\t  _DifferenceType __skew = ((unsigned long long)__total * __rank / __N\n+\t\t\t\t  - __leftsize);\n \n-\t  if (skew > 0)\n+\t  if (__skew > 0)\n \t    {\n \t      // Move to the left, find smallest.\n-\t      std::priority_queue<std::pair<T, int>,\n-\t\tstd::vector<std::pair<T, int> >,\n-\t\tlexicographic_reverse<T, int, Comparator> > pq(lrcomp);\n+\t      std::priority_queue<std::pair<_Tp, int>,\n+\t\tstd::vector<std::pair<_Tp, int> >,\n+\t\t_LexicographicReverse<_Tp, int, _Compare> > __pq(__lrcomp);\n \n-\t      for (int i = 0; i < m; ++i)\n-\t\tif (b[i] < ns[i])\n-\t\t  pq.push(std::make_pair(S(i)[b[i]], i));\n+\t      for (int __i = 0; __i < __m; ++__i)\n+\t\tif (__b[__i] < __ns[__i])\n+\t\t  __pq.push(std::make_pair(__S(__i)[__b[__i]], __i));\n \n-\t      for (; skew != 0 && !pq.empty(); --skew)\n+\t      for (; __skew != 0 && !__pq.empty(); --__skew)\n \t\t{\n-\t\t  int source = pq.top().second;\n-\t\t  pq.pop();\n+\t\t  int source = __pq.top().second;\n+\t\t  __pq.pop();\n \t\t  \n-\t\t  a[source] = std::min(a[source] + n + 1, ns[source]);\n-\t\t  b[source] += n + 1;\n+\t\t  __a[source] = std::min(__a[source] + __n + 1, __ns[source]);\n+\t\t  __b[source] += __n + 1;\n \t\t  \n-\t\t  if (b[source] < ns[source])\n-\t\t    pq.push(std::make_pair(S(source)[b[source]], source));\n+\t\t  if (__b[source] < __ns[source])\n+\t\t    __pq.push(std::make_pair(__S(source)[__b[source]], source));\n \t\t}\n \t    }\n-\t  else if (skew < 0)\n+\t  else if (__skew < 0)\n \t    {\n \t      // Move to the right, find greatest.\n-\t      std::priority_queue<std::pair<T, int>,\n-\t\tstd::vector<std::pair<T, int> >,\n-\t\tlexicographic<T, int, Comparator> > pq(lcomp);\n+\t      std::priority_queue<std::pair<_Tp, int>,\n+\t\tstd::vector<std::pair<_Tp, int> >,\n+\t\t_Lexicographic<_Tp, int, _Compare> > __pq(__lcomp);\n \n-\t      for (int i = 0; i < m; ++i)\n-\t\tif (a[i] > 0)\n-\t\t  pq.push(std::make_pair(S(i)[a[i] - 1], i));\n+\t      for (int __i = 0; __i < __m; ++__i)\n+\t\tif (__a[__i] > 0)\n+\t\t  __pq.push(std::make_pair(__S(__i)[__a[__i] - 1], __i));\n \n-\t      for (; skew != 0; ++skew)\n+\t      for (; __skew != 0; ++__skew)\n \t\t{\n-\t\t  int source = pq.top().second;\n-\t\t  pq.pop();\n+\t\t  int source = __pq.top().second;\n+\t\t  __pq.pop();\n \n-\t\t  a[source] -= n + 1;\n-\t\t  b[source] -= n + 1;\n+\t\t  __a[source] -= __n + 1;\n+\t\t  __b[source] -= __n + 1;\n \n-\t\t  if (a[source] > 0)\n-\t\t    pq.push(std::make_pair(S(source)[a[source] - 1], source));\n+\t\t  if (__a[source] > 0)\n+\t\t    __pq.push(std::make_pair(__S(source)[__a[source] - 1], source));\n \t\t}\n \t    }\n \t}\n \n       // Postconditions:\n-      // a[i] == b[i] in most cases, except when a[i] has been clamped\n+      // __a[__i] == __b[__i] in most cases, except when __a[__i] has been clamped\n       // because of having reached the boundary\n \n       // Now return the result, calculate the offset.\n \n       // Compare the keys on both edges of the border.\n \n       // Maximum of left edge, minimum of right edge.\n-      bool maxleftset = false, minrightset = false;\n+      bool __maxleftset = false, __minrightset = false;\n \n       // Impossible to avoid the warning?\n-      T maxleft, minright;\n-      for (int i = 0; i < m; ++i)\n+      _Tp __maxleft, __minright;\n+      for (int __i = 0; __i < __m; ++__i)\n \t{\n-\t  if (a[i] > 0)\n+\t  if (__a[__i] > 0)\n \t    {\n-\t      if (!maxleftset)\n+\t      if (!__maxleftset)\n \t\t{\n-\t\t  maxleft = S(i)[a[i] - 1];\n-\t\t  maxleftset = true;\n+\t\t  __maxleft = __S(__i)[__a[__i] - 1];\n+\t\t  __maxleftset = true;\n \t\t}\n \t      else\n \t\t{\n \t\t  // Max.\n-\t\t  if (comp(maxleft, S(i)[a[i] - 1]))\n-\t\t    maxleft = S(i)[a[i] - 1];\n+\t\t  if (__comp(__maxleft, __S(__i)[__a[__i] - 1]))\n+\t\t    __maxleft = __S(__i)[__a[__i] - 1];\n \t\t}\n \t    }\n-\t  if (b[i] < ns[i])\n+\t  if (__b[__i] < __ns[__i])\n \t    {\n-\t      if (!minrightset)\n+\t      if (!__minrightset)\n \t\t{\n-\t\t  minright = S(i)[b[i]];\n-\t\t  minrightset = true;\n+\t\t  __minright = __S(__i)[__b[__i]];\n+\t\t  __minrightset = true;\n \t\t}\n \t      else\n \t\t{\n \t\t  // Min.\n-\t\t  if (comp(S(i)[b[i]], minright))\n-\t\t    minright = S(i)[b[i]];\n+\t\t  if (__comp(__S(__i)[__b[__i]], __minright))\n+\t\t    __minright = __S(__i)[__b[__i]];\n \t\t}\n \t    }\n       }\n \n       // Minright is the splitter, in any case.\n \n-      if (!maxleftset || comp(minright, maxleft))\n+      if (!__maxleftset || __comp(__minright, __maxleft))\n \t{\n \t  // Good luck, everything is split unambiguously.\n-\t  offset = 0;\n+\t  __offset = 0;\n \t}\n       else\n \t{\n \t  // We have to calculate an offset.\n-\t  offset = 0;\n+\t  __offset = 0;\n \n-\t  for (int i = 0; i < m; ++i)\n+\t  for (int __i = 0; __i < __m; ++__i)\n \t    {\n-\t      difference_type lb = std::lower_bound(S(i), S(i) + ns[i],\n-\t\t\t\t\t\t    minright,\n-\t\t\t\t\t\t    comp) - S(i);\n-\t      offset += a[i] - lb;\n+\t      _DifferenceType lb = std::lower_bound(__S(__i), __S(__i) + __ns[__i],\n+\t\t\t\t\t\t    __minright,\n+\t\t\t\t\t\t    __comp) - __S(__i);\n+\t      __offset += __a[__i] - lb;\n \t    }\n \t}\n \n-      delete[] ns;\n-      delete[] a;\n-      delete[] b;\n+      delete[] __ns;\n+      delete[] __a;\n+      delete[] __b;\n \n-      return minright;\n+      return __minright;\n     }\n }\n \n-#undef S\n+#undef __S\n \n #endif /* _GLIBCXX_PARALLEL_MULTISEQ_SELECTION_H */"}, {"sha": "0aa661fe6dad6c2dc050cc8276b8dedff38e4717", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 1103, "deletions": 1103, "changes": 2206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445"}, {"sha": "1c2c7e445be5a7fdaf750278bc546a855b60220f", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 236, "deletions": 236, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -44,431 +44,431 @@ namespace __gnu_parallel\n \n /** @brief Subsequence description. */\n template<typename _DifferenceTp>\n-  struct Piece\n+  struct _Piece\n   {\n-    typedef _DifferenceTp difference_type;\n+    typedef _DifferenceTp _DifferenceType;\n \n     /** @brief Begin of subsequence. */\n-    difference_type begin;\n+    _DifferenceType __begin;\n \n     /** @brief End of subsequence. */\n-    difference_type end;\n+    _DifferenceType __end;\n   };\n \n /** @brief Data accessed by all threads.\n   *\n   *  PMWMS = parallel multiway mergesort */\n-template<typename RandomAccessIterator>\n-  struct PMWMSSortingData\n+template<typename _RAIter>\n+  struct _PMWMSSortingData\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n     /** @brief Number of threads involved. */\n-    thread_index_t num_threads;\n+    _ThreadIndex __num_threads;\n \n-    /** @brief Input begin. */\n-    RandomAccessIterator source;\n+    /** @brief Input __begin. */\n+    _RAIter _M_source;\n \n     /** @brief Start indices, per thread. */\n-    difference_type* starts;\n+    _DifferenceType* _M_starts;\n \n     /** @brief Storage in which to sort. */\n-    value_type** temporary;\n+    _ValueType** _M_temporary;\n \n     /** @brief Samples. */\n-    value_type* samples;\n+    _ValueType* _M_samples;\n \n     /** @brief Offsets to add to the found positions. */\n-    difference_type* offsets;\n+    _DifferenceType* _M_offsets;\n \n-    /** @brief Pieces of data to merge @c [thread][sequence] */\n-    std::vector<Piece<difference_type> >* pieces;\n+    /** @brief Pieces of data to merge @__c [thread][__sequence] */\n+    std::vector<_Piece<_DifferenceType> >* _M_pieces;\n };\n \n /**\n-  *  @brief Select samples from a sequence.\n-  *  @param sd Pointer to algorithm data. Result will be placed in\n-  *  @c sd->samples.\n-  *  @param num_samples Number of samples to select.\n+  *  @brief Select _M_samples from a sequence.\n+  *  @param __sd Pointer to algorithm data. _Result will be placed in\n+  *  @__c __sd->_M_samples.\n+  *  @param __num_samples Number of _M_samples to select.\n   */\n-template<typename RandomAccessIterator, typename _DifferenceTp>\n+template<typename _RAIter, typename _DifferenceTp>\n   void \n-  determine_samples(PMWMSSortingData<RandomAccessIterator>* sd,\n-                    _DifferenceTp num_samples)\n+  __determine_samples(_PMWMSSortingData<_RAIter>* __sd,\n+                    _DifferenceTp __num_samples)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef _DifferenceTp difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef _DifferenceTp _DifferenceType;\n \n-    thread_index_t iam = omp_get_thread_num();\n+    _ThreadIndex __iam = omp_get_thread_num();\n \n-    difference_type* es = new difference_type[num_samples + 2];\n+    _DifferenceType* __es = new _DifferenceType[__num_samples + 2];\n \n-    equally_split(sd->starts[iam + 1] - sd->starts[iam], \n-                  num_samples + 1, es);\n+    equally_split(__sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam], \n+                  __num_samples + 1, __es);\n \n-    for (difference_type i = 0; i < num_samples; ++i)\n-      ::new(&(sd->samples[iam * num_samples + i]))\n-\t  value_type(sd->source[sd->starts[iam] + es[i + 1]]);\n+    for (_DifferenceType __i = 0; __i < __num_samples; ++__i)\n+      ::new(&(__sd->_M_samples[__iam * __num_samples + __i]))\n+\t  _ValueType(__sd->_M_source[__sd->_M_starts[__iam] + __es[__i + 1]]);\n \n-    delete[] es;\n+    delete[] __es;\n   }\n \n /** @brief Split consistently. */\n-template<bool exact, typename RandomAccessIterator,\n-          typename Comparator, typename SortingPlacesIterator>\n-  struct split_consistently\n+template<bool __exact, typename _RAIter,\n+          typename _Compare, typename _SortingPlacesIterator>\n+  struct _SplitConsistently\n   {\n   };\n \n /** @brief Split by exact splitting. */\n-template<typename RandomAccessIterator, typename Comparator,\n-          typename SortingPlacesIterator>\n-  struct split_consistently\n-    <true, RandomAccessIterator, Comparator, SortingPlacesIterator>\n+template<typename _RAIter, typename _Compare,\n+          typename _SortingPlacesIterator>\n+  struct _SplitConsistently\n+    <true, _RAIter, _Compare, _SortingPlacesIterator>\n   {\n     void operator()(\n-      const thread_index_t iam,\n-      PMWMSSortingData<RandomAccessIterator>* sd,\n-      Comparator& comp,\n+      const _ThreadIndex __iam,\n+      _PMWMSSortingData<_RAIter>* __sd,\n+      _Compare& __comp,\n       const typename\n-        std::iterator_traits<RandomAccessIterator>::difference_type\n-          num_samples)\n+        std::iterator_traits<_RAIter>::difference_type\n+          __num_samples)\n       const\n   {\n #   pragma omp barrier\n \n-    std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n-        seqs(sd->num_threads);\n-    for (thread_index_t s = 0; s < sd->num_threads; s++)\n-      seqs[s] = std::make_pair(sd->temporary[s],\n-                                sd->temporary[s]\n-                                    + (sd->starts[s + 1] - sd->starts[s]));\n+    std::vector<std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n+        seqs(__sd->__num_threads);\n+    for (_ThreadIndex __s = 0; __s < __sd->__num_threads; __s++)\n+      seqs[__s] = std::make_pair(__sd->_M_temporary[__s],\n+                                __sd->_M_temporary[__s]\n+                                    + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]));\n \n-    std::vector<SortingPlacesIterator> offsets(sd->num_threads);\n+    std::vector<_SortingPlacesIterator> _M_offsets(__sd->__num_threads);\n \n     // if not last thread\n-    if (iam < sd->num_threads - 1)\n+    if (__iam < __sd->__num_threads - 1)\n       multiseq_partition(seqs.begin(), seqs.end(),\n-                          sd->starts[iam + 1], offsets.begin(), comp);\n+                          __sd->_M_starts[__iam + 1], _M_offsets.begin(), __comp);\n \n-    for (int seq = 0; seq < sd->num_threads; seq++)\n+    for (int __seq = 0; __seq < __sd->__num_threads; __seq++)\n       {\n         // for each sequence\n-        if (iam < (sd->num_threads - 1))\n-          sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n+        if (__iam < (__sd->__num_threads - 1))\n+          __sd->_M_pieces[__iam][__seq].__end = _M_offsets[__seq] - seqs[__seq].first;\n         else\n           // very end of this sequence\n-          sd->pieces[iam][seq].end =\n-              sd->starts[seq + 1] - sd->starts[seq];\n+          __sd->_M_pieces[__iam][__seq].__end =\n+              __sd->_M_starts[__seq + 1] - __sd->_M_starts[__seq];\n       }\n \n #   pragma omp barrier\n \n-    for (thread_index_t seq = 0; seq < sd->num_threads; seq++)\n+    for (_ThreadIndex __seq = 0; __seq < __sd->__num_threads; __seq++)\n       {\n         // For each sequence.\n-        if (iam > 0)\n-          sd->pieces[iam][seq].begin = sd->pieces[iam - 1][seq].end;\n+        if (__iam > 0)\n+          __sd->_M_pieces[__iam][__seq].__begin = __sd->_M_pieces[__iam - 1][__seq].__end;\n         else\n           // Absolute beginning.\n-          sd->pieces[iam][seq].begin = 0;\n+          __sd->_M_pieces[__iam][__seq].__begin = 0;\n       }\n   }   \n   };\n \n /** @brief Split by sampling. */ \n-template<typename RandomAccessIterator, typename Comparator,\n-          typename SortingPlacesIterator>\n-  struct split_consistently<false, RandomAccessIterator, Comparator,\n-                             SortingPlacesIterator>\n+template<typename _RAIter, typename _Compare,\n+          typename _SortingPlacesIterator>\n+  struct _SplitConsistently<false, _RAIter, _Compare,\n+                             _SortingPlacesIterator>\n   {\n     void operator()(\n-        const thread_index_t iam,\n-        PMWMSSortingData<RandomAccessIterator>* sd,\n-        Comparator& comp,\n+        const _ThreadIndex __iam,\n+        _PMWMSSortingData<_RAIter>* __sd,\n+        _Compare& __comp,\n         const typename\n-          std::iterator_traits<RandomAccessIterator>::difference_type\n-            num_samples)\n+          std::iterator_traits<_RAIter>::difference_type\n+            __num_samples)\n         const\n     {\n-      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      typedef typename traits_type::difference_type difference_type;\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-      determine_samples(sd, num_samples);\n+      __determine_samples(__sd, __num_samples);\n \n #     pragma omp barrier\n \n #     pragma omp single\n-      __gnu_sequential::sort(sd->samples,\n-                             sd->samples + (num_samples * sd->num_threads),\n-                             comp);\n+      __gnu_sequential::sort(__sd->_M_samples,\n+                             __sd->_M_samples + (__num_samples * __sd->__num_threads),\n+                             __comp);\n \n #     pragma omp barrier\n \n-      for (thread_index_t s = 0; s < sd->num_threads; ++s)\n+      for (_ThreadIndex __s = 0; __s < __sd->__num_threads; ++__s)\n         {\n           // For each sequence.\n-          if (num_samples * iam > 0)\n-            sd->pieces[iam][s].begin =\n-                std::lower_bound(sd->temporary[s],\n-                    sd->temporary[s]\n-                        + (sd->starts[s + 1] - sd->starts[s]),\n-                    sd->samples[num_samples * iam],\n-                    comp)\n-                - sd->temporary[s];\n+          if (__num_samples * __iam > 0)\n+            __sd->_M_pieces[__iam][__s].__begin =\n+                std::lower_bound(__sd->_M_temporary[__s],\n+                    __sd->_M_temporary[__s]\n+                        + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n+                    __sd->_M_samples[__num_samples * __iam],\n+                    __comp)\n+                - __sd->_M_temporary[__s];\n           else\n             // Absolute beginning.\n-            sd->pieces[iam][s].begin = 0;\n-\n-          if ((num_samples * (iam + 1)) < (num_samples * sd->num_threads))\n-            sd->pieces[iam][s].end =\n-                std::lower_bound(sd->temporary[s],\n-                        sd->temporary[s]\n-                            + (sd->starts[s + 1] - sd->starts[s]),\n-                        sd->samples[num_samples * (iam + 1)],\n-                        comp)\n-                - sd->temporary[s];\n+            __sd->_M_pieces[__iam][__s].__begin = 0;\n+\n+          if ((__num_samples * (__iam + 1)) < (__num_samples * __sd->__num_threads))\n+            __sd->_M_pieces[__iam][__s].__end =\n+                std::lower_bound(__sd->_M_temporary[__s],\n+                        __sd->_M_temporary[__s]\n+                            + (__sd->_M_starts[__s + 1] - __sd->_M_starts[__s]),\n+                        __sd->_M_samples[__num_samples * (__iam + 1)],\n+                        __comp)\n+                - __sd->_M_temporary[__s];\n           else\n-            // Absolute end.\n-            sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n+            // Absolute __end.\n+            __sd->_M_pieces[__iam][__s].__end = __sd->_M_starts[__s + 1] - __sd->_M_starts[__s];\n         }\n     }\n   };\n   \n-template<bool stable, typename RandomAccessIterator, typename Comparator>\n-  struct possibly_stable_sort\n+template<bool __stable, typename _RAIter, typename _Compare>\n+  struct __possibly_stable_sort\n   {\n   };\n \n-template<typename RandomAccessIterator, typename Comparator>\n-  struct possibly_stable_sort<true, RandomAccessIterator, Comparator>\n+template<typename _RAIter, typename _Compare>\n+  struct __possibly_stable_sort<true, _RAIter, _Compare>\n   {\n-    void operator()(const RandomAccessIterator& begin,\n-                     const RandomAccessIterator& end, Comparator& comp) const\n+    void operator()(const _RAIter& __begin,\n+                     const _RAIter& __end, _Compare& __comp) const\n     {\n-      __gnu_sequential::stable_sort(begin, end, comp); \n+      __gnu_sequential::stable_sort(__begin, __end, __comp); \n     }\n   };\n \n-template<typename RandomAccessIterator, typename Comparator>\n-  struct possibly_stable_sort<false, RandomAccessIterator, Comparator>\n+template<typename _RAIter, typename _Compare>\n+  struct __possibly_stable_sort<false, _RAIter, _Compare>\n   {\n-    void operator()(const RandomAccessIterator begin,\n-                     const RandomAccessIterator end, Comparator& comp) const\n+    void operator()(const _RAIter __begin,\n+                     const _RAIter __end, _Compare& __comp) const\n     {\n-      __gnu_sequential::sort(begin, end, comp); \n+      __gnu_sequential::sort(__begin, __end, __comp); \n     }\n   };\n \n-template<bool stable, typename SeqRandomAccessIterator,\n-          typename RandomAccessIterator, typename Comparator,\n+template<bool __stable, typename Seq_RAIter,\n+          typename _RAIter, typename _Compare,\n           typename DiffType>\n-  struct possibly_stable_multiway_merge\n+  struct __possibly_stable_multiway_merge\n   {\n   };\n \n-template<typename SeqRandomAccessIterator, typename RandomAccessIterator,\n-          typename Comparator, typename DiffType>\n-  struct possibly_stable_multiway_merge\n-    <true, SeqRandomAccessIterator, RandomAccessIterator, Comparator,\n+template<typename Seq_RAIter, typename _RAIter,\n+          typename _Compare, typename DiffType>\n+  struct __possibly_stable_multiway_merge\n+    <true, Seq_RAIter, _RAIter, _Compare,\n     DiffType>\n   {\n-    void operator()(const SeqRandomAccessIterator& seqs_begin,\n-                      const SeqRandomAccessIterator& seqs_end,\n-                      const RandomAccessIterator& target,\n-                      Comparator& comp,\n-                      DiffType length_am) const\n+    void operator()(const Seq_RAIter& __seqs_begin,\n+                      const Seq_RAIter& __seqs_end,\n+                      const _RAIter& __target,\n+                      _Compare& __comp,\n+                      DiffType __length_am) const\n     {\n-      stable_multiway_merge(seqs_begin, seqs_end, target, length_am, comp,\n+      stable_multiway_merge(__seqs_begin, __seqs_end, __target, __length_am, __comp,\n                        sequential_tag());\n     }\n   };\n \n-template<typename SeqRandomAccessIterator, typename RandomAccessIterator,\n-          typename Comparator, typename DiffType>\n-  struct possibly_stable_multiway_merge\n-    <false, SeqRandomAccessIterator, RandomAccessIterator, Comparator,\n+template<typename Seq_RAIter, typename _RAIter,\n+          typename _Compare, typename DiffType>\n+  struct __possibly_stable_multiway_merge\n+    <false, Seq_RAIter, _RAIter, _Compare,\n     DiffType>\n   {\n-    void operator()(const SeqRandomAccessIterator& seqs_begin,\n-                      const SeqRandomAccessIterator& seqs_end,\n-                      const RandomAccessIterator& target,\n-                      Comparator& comp,\n-                      DiffType length_am) const\n+    void operator()(const Seq_RAIter& __seqs_begin,\n+                      const Seq_RAIter& __seqs_end,\n+                      const _RAIter& __target,\n+                      _Compare& __comp,\n+                      DiffType __length_am) const\n     {\n-      multiway_merge(seqs_begin, seqs_end, target, length_am, comp,\n+      multiway_merge(__seqs_begin, __seqs_end, __target, __length_am, __comp,\n                        sequential_tag());\n     }\n   };\n \n /** @brief PMWMS code executed by each thread.\n-  *  @param sd Pointer to algorithm data.\n-  *  @param comp Comparator.\n+  *  @param __sd Pointer to algorithm data.\n+  *  @param __comp Comparator.\n   */\n-template<bool stable, bool exact, typename RandomAccessIterator,\n-          typename Comparator>\n+template<bool __stable, bool __exact, typename _RAIter,\n+          typename _Compare>\n   void \n-  parallel_sort_mwms_pu(PMWMSSortingData<RandomAccessIterator>* sd,\n-                        Comparator& comp)\n+  parallel_sort_mwms_pu(_PMWMSSortingData<_RAIter>* __sd,\n+                        _Compare& __comp)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    thread_index_t iam = omp_get_thread_num();\n+    _ThreadIndex __iam = omp_get_thread_num();\n \n     // Length of this thread's chunk, before merging.\n-    difference_type length_local = sd->starts[iam + 1] - sd->starts[iam];\n+    _DifferenceType __length_local = __sd->_M_starts[__iam + 1] - __sd->_M_starts[__iam];\n \n     // Sort in temporary storage, leave space for sentinel.\n \n-    typedef value_type* SortingPlacesIterator;\n+    typedef _ValueType* _SortingPlacesIterator;\n \n-    sd->temporary[iam] =\n-        static_cast<value_type*>(\n-        ::operator new(sizeof(value_type) * (length_local + 1)));\n+    __sd->_M_temporary[__iam] =\n+        static_cast<_ValueType*>(\n+        ::operator new(sizeof(_ValueType) * (__length_local + 1)));\n \n     // Copy there.\n-    std::uninitialized_copy(sd->source + sd->starts[iam],\n-                            sd->source + sd->starts[iam] + length_local,\n-                            sd->temporary[iam]);\n+    std::uninitialized_copy(__sd->_M_source + __sd->_M_starts[__iam],\n+                            __sd->_M_source + __sd->_M_starts[__iam] + __length_local,\n+                            __sd->_M_temporary[__iam]);\n \n-    possibly_stable_sort<stable, SortingPlacesIterator, Comparator>()\n-        (sd->temporary[iam], sd->temporary[iam] + length_local, comp);\n+    __possibly_stable_sort<__stable, _SortingPlacesIterator, _Compare>()\n+        (__sd->_M_temporary[__iam], __sd->_M_temporary[__iam] + __length_local, __comp);\n \n-    // Invariant: locally sorted subsequence in sd->temporary[iam],\n-    // sd->temporary[iam] + length_local.\n+    // Invariant: locally sorted subsequence in sd->_M_temporary[__iam],\n+    // __sd->_M_temporary[__iam] + __length_local.\n \n     // No barrier here: Synchronization is done by the splitting routine.\n \n-    difference_type num_samples =\n-        _Settings::get().sort_mwms_oversampling * sd->num_threads - 1;\n-    split_consistently\n-      <exact, RandomAccessIterator, Comparator, SortingPlacesIterator>()\n-        (iam, sd, comp, num_samples);\n+    _DifferenceType __num_samples =\n+        _Settings::get().sort_mwms_oversampling * __sd->__num_threads - 1;\n+    _SplitConsistently\n+      <__exact, _RAIter, _Compare, _SortingPlacesIterator>()\n+        (__iam, __sd, __comp, __num_samples);\n \n-    // Offset from target begin, length after merging.\n-    difference_type offset = 0, length_am = 0;\n-    for (thread_index_t s = 0; s < sd->num_threads; s++)\n+    // Offset from __target __begin, __length after merging.\n+    _DifferenceType __offset = 0, __length_am = 0;\n+    for (_ThreadIndex __s = 0; __s < __sd->__num_threads; __s++)\n       {\n-        length_am += sd->pieces[iam][s].end - sd->pieces[iam][s].begin;\n-        offset += sd->pieces[iam][s].begin;\n+        __length_am += __sd->_M_pieces[__iam][__s].__end - __sd->_M_pieces[__iam][__s].__begin;\n+        __offset += __sd->_M_pieces[__iam][__s].__begin;\n       }\n \n     typedef std::vector<\n-      std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n+      std::pair<_SortingPlacesIterator, _SortingPlacesIterator> >\n         seq_vector_type;\n-    seq_vector_type seqs(sd->num_threads);\n+    seq_vector_type seqs(__sd->__num_threads);\n \n-    for (int s = 0; s < sd->num_threads; ++s)\n+    for (int __s = 0; __s < __sd->__num_threads; ++__s)\n       {\n-        seqs[s] =\n-          std::make_pair(sd->temporary[s] + sd->pieces[iam][s].begin,\n-        sd->temporary[s] + sd->pieces[iam][s].end);\n+        seqs[__s] =\n+          std::make_pair(__sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s].__begin,\n+        __sd->_M_temporary[__s] + __sd->_M_pieces[__iam][__s].__end);\n       }\n \n-    possibly_stable_multiway_merge<\n-        stable,\n+    __possibly_stable_multiway_merge<\n+        __stable,\n         typename seq_vector_type::iterator,\n-        RandomAccessIterator,\n-        Comparator, difference_type>()\n+        _RAIter,\n+        _Compare, _DifferenceType>()\n           (seqs.begin(), seqs.end(),\n-           sd->source + offset, comp,\n-           length_am);\n+           __sd->_M_source + __offset, __comp,\n+           __length_am);\n \n #   pragma omp barrier\n \n-    ::operator delete(sd->temporary[iam]);\n+    ::operator delete(__sd->_M_temporary[__iam]);\n   }\n \n /** @brief PMWMS main call.\n-  *  @param begin Begin iterator of sequence.\n-  *  @param end End iterator of sequence.\n-  *  @param comp Comparator.\n-  *  @param n Length of sequence.\n-  *  @param num_threads Number of threads to use.\n+  *  @param __begin Begin iterator of sequence.\n+  *  @param __end End iterator of sequence.\n+  *  @param __comp Comparator.\n+  *  @param __n Length of sequence.\n+  *  @param __num_threads Number of threads to use.\n   */\n-template<bool stable, bool exact, typename RandomAccessIterator,\n-           typename Comparator>\n+template<bool __stable, bool __exact, typename _RAIter,\n+           typename _Compare>\n   void\n-  parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end,\n-                     Comparator comp,\n-                     thread_index_t num_threads)\n+  parallel_sort_mwms(_RAIter __begin, _RAIter __end,\n+                     _Compare __comp,\n+                     _ThreadIndex __num_threads)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n \n-    if (n <= 1)\n+    if (__n <= 1)\n       return;\n \n     // at least one element per thread\n-    if (num_threads > n)\n-      num_threads = static_cast<thread_index_t>(n);\n+    if (__num_threads > __n)\n+      __num_threads = static_cast<_ThreadIndex>(__n);\n \n     // shared variables\n-    PMWMSSortingData<RandomAccessIterator> sd;\n-    difference_type* starts;\n+    _PMWMSSortingData<_RAIter> __sd;\n+    _DifferenceType* _M_starts;\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n-        num_threads = omp_get_num_threads();  //no more threads than requested\n+        __num_threads = omp_get_num_threads();  //no more threads than requested\n \n #       pragma omp single\n           {\n-            sd.num_threads = num_threads;\n-            sd.source = begin;\n+            __sd.__num_threads = __num_threads;\n+            __sd._M_source = __begin;\n \n-            sd.temporary = new value_type*[num_threads];\n+            __sd._M_temporary = new _ValueType*[__num_threads];\n \n-            if (!exact)\n+            if (!__exact)\n               {\n-                difference_type size =\n-                    (_Settings::get().sort_mwms_oversampling * num_threads - 1)\n-                        * num_threads;\n-                sd.samples = static_cast<value_type*>(\n-                              ::operator new(size * sizeof(value_type)));\n+                _DifferenceType size =\n+                    (_Settings::get().sort_mwms_oversampling * __num_threads - 1)\n+                        * __num_threads;\n+                __sd._M_samples = static_cast<_ValueType*>(\n+                              ::operator new(size * sizeof(_ValueType)));\n               }\n             else\n-              sd.samples = NULL;\n-\n-            sd.offsets = new difference_type[num_threads - 1];\n-            sd.pieces = new std::vector<Piece<difference_type> >[num_threads];\n-            for (int s = 0; s < num_threads; ++s)\n-              sd.pieces[s].resize(num_threads);\n-            starts = sd.starts = new difference_type[num_threads + 1];\n-\n-            difference_type chunk_length = n / num_threads;\n-            difference_type split = n % num_threads;\n-            difference_type pos = 0;\n-            for (int i = 0; i < num_threads; ++i)\n+              __sd._M_samples = NULL;\n+\n+            __sd._M_offsets = new _DifferenceType[__num_threads - 1];\n+            __sd._M_pieces = new std::vector<_Piece<_DifferenceType> >[__num_threads];\n+            for (int __s = 0; __s < __num_threads; ++__s)\n+              __sd._M_pieces[__s].resize(__num_threads);\n+            _M_starts = __sd._M_starts = new _DifferenceType[__num_threads + 1];\n+\n+            _DifferenceType __chunk_length = __n / __num_threads;\n+            _DifferenceType __split = __n % __num_threads;\n+            _DifferenceType __pos = 0;\n+            for (int __i = 0; __i < __num_threads; ++__i)\n               {\n-                starts[i] = pos;\n-                pos += (i < split) ? (chunk_length + 1) : chunk_length;\n+                _M_starts[__i] = __pos;\n+                __pos += (__i < __split) ? (__chunk_length + 1) : __chunk_length;\n               }\n-            starts[num_threads] = pos;\n+            _M_starts[__num_threads] = __pos;\n           } //single\n \n         // Now sort in parallel.\n-        parallel_sort_mwms_pu<stable, exact>(&sd, comp);\n+        parallel_sort_mwms_pu<__stable, __exact>(&__sd, __comp);\n       } //parallel\n \n-    delete[] starts;\n-    delete[] sd.temporary;\n+    delete[] _M_starts;\n+    delete[] __sd._M_temporary;\n \n-    if (!exact)\n-      ::operator delete(sd.samples);\n+    if (!__exact)\n+      ::operator delete(__sd._M_samples);\n \n-    delete[] sd.offsets;\n-    delete[] sd.pieces;\n+    delete[] __sd._M_offsets;\n+    delete[] __sd._M_pieces;\n   }\n } //namespace __gnu_parallel\n "}, {"sha": "e355097edd67467ee80b8aa77b471f1252d5109c", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 290, "deletions": 290, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -51,448 +51,448 @@ namespace std\n namespace __parallel\n {\n   // Sequential fallback.\n-  template<typename InputIterator, typename T>\n-    inline T\n-    accumulate(InputIterator begin, InputIterator end, T init, \n+  template<typename _IIter, typename _Tp>\n+    inline _Tp\n+    accumulate(_IIter __begin, _IIter __end, _Tp __init, \n \t       __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::accumulate(begin, end, init); }\n+    { return _GLIBCXX_STD_P::accumulate(__begin, __end, __init); }\n \n-  template<typename InputIterator, typename T, typename BinaryOperation>\n-    inline T\n-    accumulate(InputIterator begin, InputIterator end, T init,\n-\t       BinaryOperation binary_op, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::accumulate(begin, end, init, binary_op); }\n+  template<typename _IIter, typename _Tp, typename _BinaryOperation>\n+    inline _Tp\n+    accumulate(_IIter __begin, _IIter __end, _Tp __init,\n+\t       _BinaryOperation __binary_op, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::accumulate(__begin, __end, __init, __binary_op); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename InputIterator, typename T, typename IteratorTag>\n-    inline T\n-    accumulate_switch(InputIterator begin, InputIterator end,\n-\t\t      T init, IteratorTag) \n-    { return accumulate(begin, end, init, __gnu_parallel::sequential_tag()); }\n-\n-  template<typename InputIterator, typename T, typename BinaryOperation,\n-\t   typename IteratorTag>\n-    inline T\n-    accumulate_switch(InputIterator begin, InputIterator end, T init, \n-\t\t      BinaryOperation binary_op, IteratorTag)\n-    { return accumulate(begin, end, init, binary_op, \n+  template<typename _IIter, typename _Tp, typename _IteratorTag>\n+    inline _Tp\n+    __accumulate_switch(_IIter __begin, _IIter __end,\n+\t\t      _Tp __init, _IteratorTag) \n+    { return accumulate(__begin, __end, __init, __gnu_parallel::sequential_tag()); }\n+\n+  template<typename _IIter, typename _Tp, typename _BinaryOperation,\n+\t   typename _IteratorTag>\n+    inline _Tp\n+    __accumulate_switch(_IIter __begin, _IIter __end, _Tp __init, \n+\t\t      _BinaryOperation __binary_op, _IteratorTag)\n+    { return accumulate(__begin, __end, __init, __binary_op, \n \t\t\t__gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename _RandomAccessIterator, typename T,\n-\t   typename BinaryOperation>\n-    T\n-    accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, \n-\t\t      T init, BinaryOperation binary_op, \n+  template<typename __RAIter, typename _Tp,\n+\t   typename _BinaryOperation>\n+    _Tp\n+    __accumulate_switch(__RAIter __begin, __RAIter __end, \n+\t\t      _Tp __init, _BinaryOperation __binary_op, \n \t\t      random_access_iterator_tag, \n-\t\t      __gnu_parallel::_Parallelism parallelism_tag  \n+\t\t      __gnu_parallel::_Parallelism __parallelism_tag  \n \t\t      = __gnu_parallel::parallel_unbalanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n \t    >= __gnu_parallel::_Settings::get().accumulate_minimal_n\n-\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n+\t    && __gnu_parallel::__is_parallel(__parallelism_tag)))\n \t{\n-\t  T res = init;\n-\t  __gnu_parallel::accumulate_selector<_RandomAccessIterator>\n-\t    my_selector;\n+\t  _Tp __res = __init;\n+\t  __gnu_parallel::__accumulate_selector<__RAIter>\n+\t    __my_selector;\n \t  __gnu_parallel::\n-\t    for_each_template_random_access_ed(begin, end,\n-\t\t\t\t\t    __gnu_parallel::nothing(),\n-\t\t\t\t\t    my_selector,\n+\t    for_each_template_random_access_ed(__begin, __end,\n+\t\t\t\t\t    __gnu_parallel::_Nothing(),\n+\t\t\t\t\t    __my_selector,\n \t\t\t\t\t    __gnu_parallel::\n-\t\t\t\t\t    accumulate_binop_reduct\n-\t\t\t\t\t    <BinaryOperation>(binary_op),\n-\t\t\t\t\t    res, res, -1);\n-\t  return res;\n+\t\t\t\t\t    __accumulate_binop_reduct\n+\t\t\t\t\t    <_BinaryOperation>(__binary_op),\n+\t\t\t\t\t    __res, __res, -1);\n+\t  return __res;\n \t}\n       else\n-\treturn accumulate(begin, end, init, binary_op, \n+\treturn accumulate(__begin, __end, __init, __binary_op, \n \t\t\t  __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n-  template<typename InputIterator, typename T>\n-    inline T\n-    accumulate(InputIterator begin, InputIterator end, T init, \n-\t       __gnu_parallel::_Parallelism parallelism_tag)\n+  template<typename _IIter, typename _Tp>\n+    inline _Tp\n+    accumulate(_IIter __begin, _IIter __end, _Tp __init, \n+\t       __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef std::iterator_traits<InputIterator> iterator_traits;\n-      typedef typename iterator_traits::value_type value_type;\n-      typedef typename iterator_traits::iterator_category iterator_category;\n+      typedef std::iterator_traits<_IIter> _IteratorTraits;\n+      typedef typename _IteratorTraits::value_type _ValueType;\n+      typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n \n-      return accumulate_switch(begin, end, init,\n-\t\t\t       __gnu_parallel::plus<T, value_type>(),\n-\t\t\t       iterator_category(), parallelism_tag);\n+      return __accumulate_switch(__begin, __end, __init,\n+\t\t\t       __gnu_parallel::_Plus<_Tp, _ValueType>(),\n+\t\t\t       _IteratorCategory(), __parallelism_tag);\n     }\n \n-  template<typename InputIterator, typename T>\n-    inline T\n-    accumulate(InputIterator begin, InputIterator end, T init)\n+  template<typename _IIter, typename _Tp>\n+    inline _Tp\n+    accumulate(_IIter __begin, _IIter __end, _Tp __init)\n     {\n-      typedef std::iterator_traits<InputIterator> iterator_traits;\n-      typedef typename iterator_traits::value_type value_type;\n-      typedef typename iterator_traits::iterator_category iterator_category;\n+      typedef std::iterator_traits<_IIter> _IteratorTraits;\n+      typedef typename _IteratorTraits::value_type _ValueType;\n+      typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n \n-      return accumulate_switch(begin, end, init,\n-\t\t\t       __gnu_parallel::plus<T, value_type>(),\n-\t\t\t       iterator_category());\n+      return __accumulate_switch(__begin, __end, __init,\n+\t\t\t       __gnu_parallel::_Plus<_Tp, _ValueType>(),\n+\t\t\t       _IteratorCategory());\n     }\n \n-  template<typename InputIterator, typename T, typename BinaryOperation>\n-    inline T\n-    accumulate(InputIterator begin, InputIterator end, T init, \n-\t       BinaryOperation binary_op, \n-\t       __gnu_parallel::_Parallelism parallelism_tag)\n+  template<typename _IIter, typename _Tp, typename _BinaryOperation>\n+    inline _Tp\n+    accumulate(_IIter __begin, _IIter __end, _Tp __init, \n+\t       _BinaryOperation __binary_op, \n+\t       __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<InputIterator> iterator_traits;\n-      typedef typename iterator_traits::iterator_category iterator_category;\n-      return accumulate_switch(begin, end, init, binary_op, \n-\t\t\t       iterator_category(), parallelism_tag);\n+      typedef iterator_traits<_IIter> _IteratorTraits;\n+      typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n+      return __accumulate_switch(__begin, __end, __init, __binary_op, \n+\t\t\t       _IteratorCategory(), __parallelism_tag);\n     }\n \n-  template<typename InputIterator, typename T, typename BinaryOperation>\n-    inline T\n-    accumulate(InputIterator begin, InputIterator end, T init, \n-\t       BinaryOperation binary_op) \n+  template<typename _IIter, typename _Tp, typename _BinaryOperation>\n+    inline _Tp\n+    accumulate(_IIter __begin, _IIter __end, _Tp __init, \n+\t       _BinaryOperation __binary_op) \n     {\n-      typedef iterator_traits<InputIterator> iterator_traits;\n-      typedef typename iterator_traits::iterator_category iterator_category;\n-      return accumulate_switch(begin, end, init, binary_op, \n-\t\t\t       iterator_category());\n+      typedef iterator_traits<_IIter> _IteratorTraits;\n+      typedef typename _IteratorTraits::iterator_category _IteratorCategory;\n+      return __accumulate_switch(__begin, __end, __init, __binary_op, \n+\t\t\t       _IteratorCategory());\n     }\n \n \n   // Sequential fallback.\n-  template<typename InputIterator1, typename InputIterator2, typename T>\n-    inline T\n-    inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\t  InputIterator2 first2, T init,\n+  template<typename _IIter1, typename _IIter2, typename _Tp>\n+    inline _Tp\n+    inner_product(_IIter1 __first1, _IIter1 __last1, \n+\t\t  _IIter2 __first2, _Tp __init,\n \t\t  __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init); }\n+    { return _GLIBCXX_STD_P::inner_product(__first1, __last1, __first2, __init); }\n \n-  template<typename InputIterator1, typename InputIterator2, typename T,\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n \t   typename BinaryFunction1, typename BinaryFunction2>\n-    inline T\n-    inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n-\t\t  BinaryFunction2 binary_op2, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, \n-\t\t\t\t\t   binary_op1, binary_op2); }\n+    inline _Tp\n+    inner_product(_IIter1 __first1, _IIter1 __last1, \n+\t\t  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n+\t\t  BinaryFunction2 __binary_op2, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::inner_product(__first1, __last1, __first2, __init, \n+\t\t\t\t\t   __binary_op1, __binary_op2); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n-\t   typename T, typename BinaryFunction1, typename BinaryFunction2>\n-    T\n-    inner_product_switch(RandomAccessIterator1 first1,\n-\t\t\t RandomAccessIterator1 last1,\n-\t\t\t RandomAccessIterator2 first2, T init,\n-\t\t\t BinaryFunction1 binary_op1,\n-\t\t\t BinaryFunction2 binary_op2,\n+  template<typename _RAIter1, typename _RAIter2,\n+\t   typename _Tp, typename BinaryFunction1, typename BinaryFunction2>\n+    _Tp\n+    __inner_product_switch(_RAIter1 __first1,\n+\t\t\t _RAIter1 __last1,\n+\t\t\t _RAIter2 __first2, _Tp __init,\n+\t\t\t BinaryFunction1 __binary_op1,\n+\t\t\t BinaryFunction2 __binary_op2,\n \t\t\t random_access_iterator_tag,\n \t\t\t random_access_iterator_tag,\n-\t\t\t __gnu_parallel::_Parallelism parallelism_tag\n+\t\t\t __gnu_parallel::_Parallelism __parallelism_tag\n \t\t\t = __gnu_parallel::parallel_unbalanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION((last1 - first1)\n+      if (_GLIBCXX_PARALLEL_CONDITION((__last1 - __first1)\n \t\t\t\t      >= __gnu_parallel::_Settings::get().\n \t\t\t\t      accumulate_minimal_n\n \t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+\t\t\t\t      __is_parallel(__parallelism_tag)))\n \t{\n-\t  T res = init;\n+\t  _Tp __res = __init;\n \t  __gnu_parallel::\n-\t    inner_product_selector<RandomAccessIterator1,\n-\t    RandomAccessIterator2, T> my_selector(first1, first2);\n+\t    __inner_product_selector<_RAIter1,\n+\t    _RAIter2, _Tp> __my_selector(__first1, __first2);\n \t  __gnu_parallel::\n-\t    for_each_template_random_access_ed(first1, last1, binary_op2,\n-\t\t\t\t\t    my_selector, binary_op1,\n-\t\t\t\t\t    res, res, -1);\n-\t  return res;\n+\t    for_each_template_random_access_ed(__first1, __last1, __binary_op2,\n+\t\t\t\t\t    __my_selector, __binary_op1,\n+\t\t\t\t\t    __res, __res, -1);\n+\t  return __res;\n \t}\n       else\n-\treturn inner_product(first1, last1, first2, init, \n+\treturn inner_product(__first1, __last1, __first2, __init, \n \t\t\t     __gnu_parallel::sequential_tag());\n     }\n \n   // No parallelism for input iterators.\n-  template<typename InputIterator1, typename InputIterator2, typename T,\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n \t   typename BinaryFunction1, typename BinaryFunction2,\n-\t   typename IteratorTag1, typename IteratorTag2>\n-    inline T\n-    inner_product_switch(InputIterator1 first1, InputIterator1 last1, \n-\t\t\t InputIterator2 first2, T init, \n-\t\t\t BinaryFunction1 binary_op1,\n-\t\t\t BinaryFunction2 binary_op2, \n-\t\t\t IteratorTag1, IteratorTag2)\n-    { return inner_product(first1, last1, first2, init,\n-\t\t\t   binary_op1, binary_op2,\n+\t   typename _IteratorTag1, typename _IteratorTag2>\n+    inline _Tp\n+    __inner_product_switch(_IIter1 __first1, _IIter1 __last1, \n+\t\t\t _IIter2 __first2, _Tp __init, \n+\t\t\t BinaryFunction1 __binary_op1,\n+\t\t\t BinaryFunction2 __binary_op2, \n+\t\t\t _IteratorTag1, _IteratorTag2)\n+    { return inner_product(__first1, __last1, __first2, __init,\n+\t\t\t   __binary_op1, __binary_op2,\n \t\t\t   __gnu_parallel::sequential_tag()); }\n \n-  template<typename InputIterator1, typename InputIterator2, typename T,\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n \t   typename BinaryFunction1, typename BinaryFunction2>\n-    inline T\n-    inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n-\t\t  BinaryFunction2 binary_op2, \n-\t\t  __gnu_parallel::_Parallelism parallelism_tag)\n+    inline _Tp\n+    inner_product(_IIter1 __first1, _IIter1 __last1, \n+\t\t  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n+\t\t  BinaryFunction2 __binary_op2, \n+\t\t  __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<InputIterator1> traits1_type;\n-      typedef typename traits1_type::iterator_category iterator1_category;\n+      typedef iterator_traits<_IIter1> _TraitsType1;\n+      typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n \n-      typedef iterator_traits<InputIterator2> traits2_type;\n-      typedef typename traits2_type::iterator_category iterator2_category;\n+      typedef iterator_traits<_IIter2> _TraitsType2;\n+      typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n \n-      return inner_product_switch(first1, last1, first2, init, binary_op1, \n-\t\t\t\t  binary_op2, iterator1_category(), \n-\t\t\t\t  iterator2_category(), parallelism_tag);\n+      return __inner_product_switch(__first1, __last1, __first2, __init, __binary_op1, \n+\t\t\t\t  __binary_op2, _IteratorCategory1(), \n+\t\t\t\t  _IteratorCategory2(), __parallelism_tag);\n     }\n \n-  template<typename InputIterator1, typename InputIterator2, typename T,\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n \t   typename BinaryFunction1, typename BinaryFunction2>\n-    inline T\n-    inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n-\t\t  BinaryFunction2 binary_op2)\n+    inline _Tp\n+    inner_product(_IIter1 __first1, _IIter1 __last1, \n+\t\t  _IIter2 __first2, _Tp __init, BinaryFunction1 __binary_op1, \n+\t\t  BinaryFunction2 __binary_op2)\n     {\n-      typedef iterator_traits<InputIterator1> traits1_type;\n-      typedef typename traits1_type::iterator_category iterator1_category;\n+      typedef iterator_traits<_IIter1> _TraitsType1;\n+      typedef typename _TraitsType1::iterator_category _IteratorCategory1;\n \n-      typedef iterator_traits<InputIterator2> traits2_type;\n-      typedef typename traits2_type::iterator_category iterator2_category;\n+      typedef iterator_traits<_IIter2> _TraitsType2;\n+      typedef typename _TraitsType2::iterator_category _IteratorCategory2;\n \n-      return inner_product_switch(first1, last1, first2, init, binary_op1, \n-\t\t\t\t  binary_op2, iterator1_category(),\n-\t\t\t\t  iterator2_category());\n+      return __inner_product_switch(__first1, __last1, __first2, __init, __binary_op1, \n+\t\t\t\t  __binary_op2, _IteratorCategory1(),\n+\t\t\t\t  _IteratorCategory2());\n     }\n \n-  template<typename InputIterator1, typename InputIterator2, typename T>\n-    inline T\n-    inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\t  InputIterator2 first2, T init, \n-\t\t  __gnu_parallel::_Parallelism parallelism_tag)\n+  template<typename _IIter1, typename _IIter2, typename _Tp>\n+    inline _Tp\n+    inner_product(_IIter1 __first1, _IIter1 __last1, \n+\t\t  _IIter2 __first2, _Tp __init, \n+\t\t  __gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<InputIterator1> traits_type1;\n+      typedef iterator_traits<_IIter1> traits_type1;\n       typedef typename traits_type1::value_type value_type1;\n-      typedef iterator_traits<InputIterator2> traits_type2;\n+      typedef iterator_traits<_IIter2> traits_type2;\n       typedef typename traits_type2::value_type value_type2;\n \n       typedef typename\n-\t__gnu_parallel::multiplies<value_type1, value_type2>::result\n-        multiplies_result_type;\n-      return inner_product(first1, last1, first2, init,\n-                           __gnu_parallel::plus<T, multiplies_result_type>(),\n+\t__gnu_parallel::_Multiplies<value_type1, value_type2>::__result\n+        _MultipliesResultType;\n+      return inner_product(__first1, __last1, __first2, __init,\n+                           __gnu_parallel::_Plus<_Tp, _MultipliesResultType>(),\n                            __gnu_parallel::\n-\t\t\t   multiplies<value_type1, value_type2>(),\n-                           parallelism_tag);\n+\t\t\t   _Multiplies<value_type1, value_type2>(),\n+                           __parallelism_tag);\n     }\n \n-  template<typename InputIterator1, typename InputIterator2, typename T>\n-    inline T\n-    inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\t  InputIterator2 first2, T init)\n+  template<typename _IIter1, typename _IIter2, typename _Tp>\n+    inline _Tp\n+    inner_product(_IIter1 __first1, _IIter1 __last1, \n+\t\t  _IIter2 __first2, _Tp __init)\n     {\n-      typedef iterator_traits<InputIterator1> traits_type1;\n+      typedef iterator_traits<_IIter1> traits_type1;\n       typedef typename traits_type1::value_type value_type1;\n-      typedef iterator_traits<InputIterator2> traits_type2;\n+      typedef iterator_traits<_IIter2> traits_type2;\n       typedef typename traits_type2::value_type value_type2;\n \n       typedef typename\n-\t__gnu_parallel::multiplies<value_type1, value_type2>::result\n-        multiplies_result_type;\n-      return inner_product(first1, last1, first2, init,\n-                           __gnu_parallel::plus<T, multiplies_result_type>(),\n+\t__gnu_parallel::_Multiplies<value_type1, value_type2>::__result\n+        _MultipliesResultType;\n+      return inner_product(__first1, __last1, __first2, __init,\n+                           __gnu_parallel::_Plus<_Tp, _MultipliesResultType>(),\n                            __gnu_parallel::\n-\t\t\t   multiplies<value_type1, value_type2>());\n+\t\t\t   _Multiplies<value_type1, value_type2>());\n     }\n \n   // Sequential fallback.\n-  template<typename InputIterator, typename OutputIterator>\n-    inline OutputIterator\n-    partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+  template<typename _IIter, typename _OutputIterator>\n+    inline _OutputIterator\n+    partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result,\n \t\t__gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::partial_sum(begin, end, result); }\n+    { return _GLIBCXX_STD_P::partial_sum(__begin, __end, __result); }\n \n   // Sequential fallback.\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    inline OutputIterator\n-    partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n-\t\tBinaryOperation bin_op, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op); }\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    inline _OutputIterator\n+    partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result,\n+\t\t_BinaryOperation __bin_op, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::partial_sum(__begin, __end, __result, __bin_op); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation, typename IteratorTag1,\n-\t   typename IteratorTag2>\n-    inline OutputIterator\n-    partial_sum_switch(InputIterator begin, InputIterator end,\n-\t\t       OutputIterator result, BinaryOperation bin_op,\n-\t\t       IteratorTag1, IteratorTag2)\n-    { return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op); }\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation, typename _IteratorTag1,\n+\t   typename _IteratorTag2>\n+    inline _OutputIterator\n+    __partial_sum_switch(_IIter __begin, _IIter __end,\n+\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n+\t\t       _IteratorTag1, _IteratorTag2)\n+    { return _GLIBCXX_STD_P::partial_sum(__begin, __end, __result, __bin_op); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    OutputIterator\n-    partial_sum_switch(InputIterator begin, InputIterator end,\n-\t\t       OutputIterator result, BinaryOperation bin_op,\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    __partial_sum_switch(_IIter __begin, _IIter __end,\n+\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n \t\t       random_access_iterator_tag, random_access_iterator_tag)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n \t    >= __gnu_parallel::_Settings::get().partial_sum_minimal_n))\n-\treturn __gnu_parallel::parallel_partial_sum(begin, end,\n-\t\t\t\t\t\t    result, bin_op);\n+\treturn __gnu_parallel::__parallel_partial_sum(__begin, __end,\n+\t\t\t\t\t\t    __result, __bin_op);\n       else\n-\treturn partial_sum(begin, end, result, bin_op,\n+\treturn partial_sum(__begin, __end, __result, __bin_op,\n \t\t\t   __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n-  template<typename InputIterator, typename OutputIterator>\n-    inline OutputIterator\n-    partial_sum(InputIterator begin, InputIterator end, OutputIterator result)\n+  template<typename _IIter, typename _OutputIterator>\n+    inline _OutputIterator\n+    partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result)\n     {\n-      typedef typename iterator_traits<InputIterator>::value_type value_type;\n-      return partial_sum(begin, end, result, std::plus<value_type>());\n+      typedef typename iterator_traits<_IIter>::value_type _ValueType;\n+      return partial_sum(__begin, __end, __result, std::plus<_ValueType>());\n     }\n \n   // Public interface\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    inline OutputIterator\n-    partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n-\t\tBinaryOperation binary_op)\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    inline _OutputIterator\n+    partial_sum(_IIter __begin, _IIter __end, _OutputIterator __result,\n+\t\t_BinaryOperation __binary_op)\n     {\n-      typedef iterator_traits<InputIterator> traitsi_type;\n-      typedef typename traitsi_type::iterator_category iteratori_category;\n+      typedef iterator_traits<_IIter> traitsi_type;\n+      typedef typename traitsi_type::iterator_category _IIteratorCategory;\n \n-      typedef iterator_traits<OutputIterator> traitso_type;\n-      typedef typename traitso_type::iterator_category iteratoro_category;\n+      typedef iterator_traits<_OutputIterator> _OTraitsType;\n+      typedef typename _OTraitsType::iterator_category _OIterCategory;\n \n-      return partial_sum_switch(begin, end, result, binary_op,\n-\t\t\t\titeratori_category(), iteratoro_category());\n+      return __partial_sum_switch(__begin, __end, __result, __binary_op,\n+\t\t\t\t_IIteratorCategory(), _OIterCategory());\n     }\n \n   // Sequential fallback.\n-  template<typename InputIterator, typename OutputIterator>\n-    inline OutputIterator\n-    adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t\tOutputIterator result, __gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::adjacent_difference(begin, end, result); }\n+  template<typename _IIter, typename _OutputIterator>\n+    inline _OutputIterator\n+    adjacent_difference(_IIter __begin, _IIter __end,\n+\t\t\t_OutputIterator __result, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::adjacent_difference(__begin, __end, __result); }\n \n   // Sequential fallback.\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    inline OutputIterator\n-    adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t\tOutputIterator result, BinaryOperation bin_op,\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    inline _OutputIterator\n+    adjacent_difference(_IIter __begin, _IIter __end,\n+\t\t\t_OutputIterator __result, _BinaryOperation __bin_op,\n \t\t\t__gnu_parallel::sequential_tag)\n-    { return _GLIBCXX_STD_P::adjacent_difference(begin, end, result, bin_op); }\n+    { return _GLIBCXX_STD_P::adjacent_difference(__begin, __end, __result, __bin_op); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation, typename IteratorTag1,\n-\t   typename IteratorTag2>\n-    inline OutputIterator\n-    adjacent_difference_switch(InputIterator begin, InputIterator end,\n-\t\t\t       OutputIterator result, BinaryOperation bin_op,\n-\t\t\t     IteratorTag1, IteratorTag2)\n-    { return adjacent_difference(begin, end, result, bin_op,  \n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation, typename _IteratorTag1,\n+\t   typename _IteratorTag2>\n+    inline _OutputIterator\n+    __adjacent_difference_switch(_IIter __begin, _IIter __end,\n+\t\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n+\t\t\t     _IteratorTag1, _IteratorTag2)\n+    { return adjacent_difference(__begin, __end, __result, __bin_op,  \n \t\t\t\t __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    OutputIterator\n-    adjacent_difference_switch(InputIterator begin, InputIterator end,\n-\t\t\t       OutputIterator result, BinaryOperation bin_op,\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    _OutputIterator\n+    __adjacent_difference_switch(_IIter __begin, _IIter __end,\n+\t\t\t       _OutputIterator __result, _BinaryOperation __bin_op,\n \t\t\t       random_access_iterator_tag, \n \t\t\t       random_access_iterator_tag,\n-\t\t\t       __gnu_parallel::_Parallelism parallelism_tag\n+\t\t\t       __gnu_parallel::_Parallelism __parallelism_tag\n \t\t\t       = __gnu_parallel::parallel_balanced)\n     {\n       if (_GLIBCXX_PARALLEL_CONDITION(\n-\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)\n \t    >= __gnu_parallel::_Settings::get().adjacent_difference_minimal_n\n-\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n+\t    && __gnu_parallel::__is_parallel(__parallelism_tag)))\n \t{\n-\t  bool dummy = true;\n-\t  typedef __gnu_parallel::iterator_pair<InputIterator, OutputIterator,\n-\t    random_access_iterator_tag> ip;\n-\t  *result = *begin;\n-\t  ip begin_pair(begin + 1, result + 1),\n-\t    end_pair(end, result + (end - begin));\n-\t  __gnu_parallel::adjacent_difference_selector<ip> functionality;\n+\t  bool __dummy = true;\n+\t  typedef __gnu_parallel::_IteratorPair<_IIter, _OutputIterator,\n+\t    random_access_iterator_tag> _ItTrip;\n+\t  *__result = *__begin;\n+\t  _ItTrip begin_pair(__begin + 1, __result + 1),\n+\t    end_pair(__end, __result + (__end - __begin));\n+\t  __gnu_parallel::__adjacent_difference_selector<_ItTrip> __functionality;\n \t  __gnu_parallel::\n-\t    for_each_template_random_access_ed(begin_pair, end_pair, bin_op,\n-\t\t\t\t\t    functionality,\n-\t\t\t\t\t    __gnu_parallel::dummy_reduct(),\n-\t\t\t\t\t    dummy, dummy, -1);\n-\t  return functionality.finish_iterator;\n+\t    for_each_template_random_access_ed(begin_pair, end_pair, __bin_op,\n+\t\t\t\t\t    __functionality,\n+\t\t\t\t\t    __gnu_parallel::_DummyReduct(),\n+\t\t\t\t\t    __dummy, __dummy, -1);\n+\t  return __functionality.finish_iterator;\n \t}\n       else\n-\treturn adjacent_difference(begin, end, result, bin_op, \n+\treturn adjacent_difference(__begin, __end, __result, __bin_op, \n \t\t\t\t   __gnu_parallel::sequential_tag());\n     }\n \n   // Public interface.\n-  template<typename InputIterator, typename OutputIterator>\n-    inline OutputIterator\n-    adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t\tOutputIterator result,\n-\t\t\t__gnu_parallel::_Parallelism parallelism_tag)\n+  template<typename _IIter, typename _OutputIterator>\n+    inline _OutputIterator\n+    adjacent_difference(_IIter __begin, _IIter __end,\n+\t\t\t_OutputIterator __result,\n+\t\t\t__gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<InputIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      return adjacent_difference(begin, end, result, std::minus<value_type>(),\n-\t\t\t\t parallelism_tag);\n+      typedef iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      return adjacent_difference(__begin, __end, __result, std::minus<_ValueType>(),\n+\t\t\t\t __parallelism_tag);\n     }\n \n-  template<typename InputIterator, typename OutputIterator>\n-    inline OutputIterator\n-    adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t\tOutputIterator result)\n+  template<typename _IIter, typename _OutputIterator>\n+    inline _OutputIterator\n+    adjacent_difference(_IIter __begin, _IIter __end,\n+\t\t\t_OutputIterator __result)\n     {\n-      typedef iterator_traits<InputIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      return adjacent_difference(begin, end, result, std::minus<value_type>());\n+      typedef iterator_traits<_IIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      return adjacent_difference(__begin, __end, __result, std::minus<_ValueType>());\n     }\n \n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    inline OutputIterator\n-    adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t\tOutputIterator result, BinaryOperation binary_op,\n-\t\t\t__gnu_parallel::_Parallelism parallelism_tag)\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    inline _OutputIterator\n+    adjacent_difference(_IIter __begin, _IIter __end,\n+\t\t\t_OutputIterator __result, _BinaryOperation __binary_op,\n+\t\t\t__gnu_parallel::_Parallelism __parallelism_tag)\n     {\n-      typedef iterator_traits<InputIterator> traitsi_type;\n-      typedef typename traitsi_type::iterator_category iteratori_category;\n+      typedef iterator_traits<_IIter> traitsi_type;\n+      typedef typename traitsi_type::iterator_category _IIteratorCategory;\n \n-      typedef iterator_traits<OutputIterator> traitso_type;\n-      typedef typename traitso_type::iterator_category iteratoro_category;\n+      typedef iterator_traits<_OutputIterator> _OTraitsType;\n+      typedef typename _OTraitsType::iterator_category _OIterCategory;\n \n-      return adjacent_difference_switch(begin, end, result, binary_op,\n-\t\t\t\t\titeratori_category(), \n-\t\t\t\t\titeratoro_category(), parallelism_tag);\n+      return __adjacent_difference_switch(__begin, __end, __result, __binary_op,\n+\t\t\t\t\t_IIteratorCategory(), \n+\t\t\t\t\t_OIterCategory(), __parallelism_tag);\n     }\n \n-  template<typename InputIterator, typename OutputIterator,\n-\t   typename BinaryOperation>\n-    inline OutputIterator\n-    adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t\tOutputIterator result, BinaryOperation binary_op)\n+  template<typename _IIter, typename _OutputIterator,\n+\t   typename _BinaryOperation>\n+    inline _OutputIterator\n+    adjacent_difference(_IIter __begin, _IIter __end,\n+\t\t\t_OutputIterator __result, _BinaryOperation __binary_op)\n     {\n-      typedef iterator_traits<InputIterator> traitsi_type;\n-      typedef typename traitsi_type::iterator_category iteratori_category;\n+      typedef iterator_traits<_IIter> traitsi_type;\n+      typedef typename traitsi_type::iterator_category _IIteratorCategory;\n \n-      typedef iterator_traits<OutputIterator> traitso_type;\n-      typedef typename traitso_type::iterator_category iteratoro_category;\n+      typedef iterator_traits<_OutputIterator> _OTraitsType;\n+      typedef typename _OTraitsType::iterator_category _OIterCategory;\n \n-      return adjacent_difference_switch(begin, end, result, binary_op,\n-\t\t\t\t\titeratori_category(), \n-\t\t\t\t\titeratoro_category());\n+      return __adjacent_difference_switch(__begin, __end, __result, __binary_op,\n+\t\t\t\t\t_IIteratorCategory(), \n+\t\t\t\t\t_OIterCategory());\n     }\n } // end namespace\n } // end namespace"}, {"sha": "754d5ba0d9efd54028ee728176119e6a27295a1d", "filename": "libstdc++-v3/include/parallel/numericfwd.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -52,7 +52,7 @@ namespace __parallel\n \n   template<typename _IIter, typename _Tp, typename _Tag>\n     _Tp\n-    accumulate_switch(_IIter, _IIter, _Tp, _Tag);\n+    __accumulate_switch(_IIter, _IIter, _Tp, _Tag);\n \n   template<typename _IIter, typename _Tp, typename _BinaryOper>\n     _Tp\n@@ -71,13 +71,13 @@ namespace __parallel\n   template<typename _IIter, typename _Tp, typename _BinaryOper,\n \t   typename _Tag>\n     _Tp\n-    accumulate_switch(_IIter, _IIter, _Tp, _BinaryOper, _Tag);\n+    __accumulate_switch(_IIter, _IIter, _Tp, _BinaryOper, _Tag);\n \n   template<typename _RAIter, typename _Tp, typename _BinaryOper>\n     _Tp\n-    accumulate_switch(_RAIter, _RAIter, _Tp, _BinaryOper,\n+    __accumulate_switch(_RAIter, _RAIter, _Tp, _BinaryOper,\n \t\t      random_access_iterator_tag,\n-\t\t      __gnu_parallel::_Parallelism parallelism\n+\t\t      __gnu_parallel::_Parallelism __parallelism\n \t\t      = __gnu_parallel::parallel_unbalanced);\n \n   template<typename _IIter, typename _OIter>\n@@ -111,15 +111,15 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename _BinaryOper,\n \t   typename _Tag1, typename _Tag2>\n     _OIter\n-    adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper,\n+    __adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper,\n \t\t\t       _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n-    adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n+    __adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n \t\t\t       random_access_iterator_tag, \n \t\t\t       random_access_iterator_tag, \n-\t\t\t       __gnu_parallel::_Parallelism parallelism\n+\t\t\t       __gnu_parallel::_Parallelism __parallelism\n \t\t\t       = __gnu_parallel::parallel_unbalanced);\n \n   template<typename _IIter1, typename _IIter2, typename _Tp>\n@@ -157,7 +157,7 @@ namespace __parallel\n   template<typename _RAIter1, typename _RAIter2, typename _Tp,\n \t   typename BinaryFunction1, typename BinaryFunction2>\n     _Tp\n-    inner_product_switch(_RAIter1, _RAIter1, _RAIter2, _Tp, BinaryFunction1, \n+    __inner_product_switch(_RAIter1, _RAIter1, _RAIter2, _Tp, BinaryFunction1, \n \t\t\t BinaryFunction2, random_access_iterator_tag, \n \t\t\t random_access_iterator_tag, \n \t\t\t __gnu_parallel::_Parallelism\n@@ -167,7 +167,7 @@ namespace __parallel\n \t   typename _BinaryFunction1, typename _BinaryFunction2,\n \t   typename _Tag1, typename _Tag2>\n     _Tp\n-    inner_product_switch(_IIter1, _IIter1, _IIter2, _Tp, _BinaryFunction1, \n+    __inner_product_switch(_IIter1, _IIter1, _IIter2, _Tp, _BinaryFunction1, \n \t\t\t _BinaryFunction2, _Tag1, _Tag2);\n \n \n@@ -182,7 +182,7 @@ namespace __parallel\n \n   template<typename _IIter, typename _OIter>\n     _OIter\n-    partial_sum(_IIter, _IIter, _OIter result);\n+    partial_sum(_IIter, _IIter, _OIter __result);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n@@ -191,11 +191,11 @@ namespace __parallel\n   template<typename _IIter, typename _OIter, typename _BinaryOper,\n \t   typename _Tag1, typename _Tag2>\n     _OIter\n-    partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n+    __partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n     _OIter\n-    partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper,\n+    __partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper,\n \t\t       random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace\n } // end namespace"}, {"sha": "55191d474d634111afe3ff813866ea9fb1ad324f", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -44,73 +44,73 @@ namespace __gnu_parallel\n /** @brief Embarrassingly parallel algorithm for random access\n   * iterators, using an OpenMP for loop.\n   *\n-  *  @param begin Begin iterator of element sequence.\n-  *  @param end End iterator of element sequence.\n-  *  @param o User-supplied functor (comparator, predicate, adding\n+  *  @param __begin Begin iterator of element __sequence.\n+  *  @param __end End iterator of element __sequence.\n+  *  @param __o User-supplied functor (comparator, predicate, adding\n   *  functor, etc.).\n-  *  @param f Functor to \"process\" an element with op (depends on\n+  *  @param __f Functor to \"process\" an element with __op (depends on\n   *  desired functionality, e. g. for std::for_each(), ...).\n-  *  @param r Functor to \"add\" a single result to the already\n-  *  processed elements (depends on functionality).\n-  *  @param base Base value for reduction.\n-  *  @param output Pointer to position where final result is written to\n-  *  @param bound Maximum number of elements processed (e. g. for\n+  *  @param __r Functor to \"add\" a single __result to the already\n+  *  processed __elements (depends on functionality).\n+  *  @param __base Base value for reduction.\n+  *  @param __output Pointer to position where final result is written to\n+  *  @param __bound Maximum number of elements processed (e. g. for\n   *  std::count_n()).\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n-template<typename RandomAccessIterator,\n-\t typename Op,\n-\t typename Fu,\n-\t typename Red,\n-\t typename Result>\n-  Op\n-  for_each_template_random_access_omp_loop(RandomAccessIterator begin,\n-\t\t\t\t\t   RandomAccessIterator end,\n-\t\t\t\t\t   Op o, Fu& f, Red r, Result base,\n-\t\t\t\t\t   Result& output,\n+template<typename _RAIter,\n+\t typename _Op,\n+\t typename _Fu,\n+\t typename _Red,\n+\t typename _Result>\n+  _Op\n+  for_each_template_random_access_omp_loop(_RAIter __begin,\n+\t\t\t\t\t   _RAIter __end,\n+\t\t\t\t\t   _Op __o, _Fu& __f, _Red __r, _Result __base,\n+\t\t\t\t\t   _Result& __output,\n \t\t\t\t\t   typename std::iterator_traits\n-\t\t\t\t\t   <RandomAccessIterator>::\n-\t\t\t\t\t   difference_type bound)\n+\t\t\t\t\t   <_RAIter>::\n+\t\t\t\t\t   difference_type __bound)\n   {\n     typedef typename\n-        std::iterator_traits<RandomAccessIterator>::difference_type\n-        difference_type;\n+        std::iterator_traits<_RAIter>::difference_type\n+        _DifferenceType;\n \n-    difference_type length = end - begin;\n-    thread_index_t num_threads =\n-      __gnu_parallel::min<difference_type>(get_max_threads(), length);\n+    _DifferenceType __length = __end - __begin;\n+    _ThreadIndex __num_threads =\n+      __gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n \n-    Result *thread_results;\n+    _Result *__thread_results;\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-            thread_results = new Result[num_threads];\n+            __num_threads = omp_get_num_threads();\n+            __thread_results = new _Result[__num_threads];\n \n-            for (thread_index_t i = 0; i < num_threads; ++i)\n-              thread_results[i] = Result();\n+            for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+              __thread_results[__i] = _Result();\n           }\n \n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n #      pragma omp for schedule(dynamic, _Settings::get().workstealing_chunk_size)\n-        for (difference_type pos = 0; pos < length; ++pos)\n-          thread_results[iam] =\n-              r(thread_results[iam], f(o, begin+pos));\n+        for (_DifferenceType __pos = 0; __pos < __length; ++__pos)\n+          __thread_results[__iam] =\n+              __r(__thread_results[__iam], __f(__o, __begin+__pos));\n       } //parallel\n \n-    for (thread_index_t i = 0; i < num_threads; ++i)\n-        output = r(output, thread_results[i]);\n+    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+        __output = __r(__output, __thread_results[__i]);\n \n-    delete [] thread_results;\n+    delete [] __thread_results;\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform).\n-    f.finish_iterator = begin + length;\n+    __f.finish_iterator = __begin + __length;\n \n-    return o;\n+    return __o;\n   }\n \n } // end namespace"}, {"sha": "5244d11494a0bec9764d832aa67ed66f60e4b4fb", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -44,72 +44,72 @@ namespace __gnu_parallel\n   /** @brief Embarrassingly parallel algorithm for random access\n    * iterators, using an OpenMP for loop with static scheduling.\n    *\n-   *  @param begin Begin iterator of element sequence.\n-   *  @param end End iterator of element sequence.\n-   *  @param o User-supplied functor (comparator, predicate, adding\n+   *  @param __begin Begin iterator of element __sequence.\n+   *  @param __end End iterator of element __sequence.\n+   *  @param __o User-supplied functor (comparator, predicate, adding\n    *  functor, ...).\n-   *  @param f Functor to \"process\" an element with op (depends on\n+   *  @param __f Functor to \"process\" an element with __op (depends on\n    *  desired functionality, e. g. for std::for_each(), ...).\n-   *  @param r Functor to \"add\" a single result to the already processed\n-   *  elements (depends on functionality).\n-   *  @param base Base value for reduction.\n-   *  @param output Pointer to position where final result is written to\n-   *  @param bound Maximum number of elements processed (e. g. for\n+   *  @param __r Functor to \"add\" a single __result to the already processed\n+   *  __elements (depends on functionality).\n+   *  @param __base Base value for reduction.\n+   *  @param __output Pointer to position where final result is written to\n+   *  @param __bound Maximum number of elements processed (e. g. for\n    *  std::count_n()).\n    *  @return User-supplied functor (that may contain a part of the result).\n    */\n-template<typename RandomAccessIterator,\n-\t typename Op,\n-\t typename Fu,\n-\t typename Red,\n-\t typename Result>\n-  Op\n-  for_each_template_random_access_omp_loop_static(RandomAccessIterator begin,\n-\t\t\t\t\t\t  RandomAccessIterator end,\n-\t\t\t\t\t\t  Op o, Fu& f, Red r,\n-\t\t\t\t\t\t  Result base, Result& output,\n+template<typename _RAIter,\n+\t typename _Op,\n+\t typename _Fu,\n+\t typename _Red,\n+\t typename _Result>\n+  _Op\n+  for_each_template_random_access_omp_loop_static(_RAIter __begin,\n+\t\t\t\t\t\t  _RAIter __end,\n+\t\t\t\t\t\t  _Op __o, _Fu& __f, _Red __r,\n+\t\t\t\t\t\t  _Result __base, _Result& __output,\n \t\t\t\t\t\t  typename std::iterator_traits\n-\t\t\t\t\t\t  <RandomAccessIterator>::\n-\t\t\t\t\t\t  difference_type bound)\n+\t\t\t\t\t\t  <_RAIter>::\n+\t\t\t\t\t\t  difference_type __bound)\n   {\n     typedef typename\n-      std::iterator_traits<RandomAccessIterator>::difference_type\n-      difference_type;\n+      std::iterator_traits<_RAIter>::difference_type\n+      _DifferenceType;\n \n-    difference_type length = end - begin;\n-    thread_index_t num_threads =\n-      std::min<difference_type>(get_max_threads(), length);\n+    _DifferenceType __length = __end - __begin;\n+    _ThreadIndex __num_threads =\n+      std::min<_DifferenceType>(__get_max_threads(), __length);\n \n-    Result *thread_results;\n+    _Result *__thread_results;\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-            thread_results = new Result[num_threads];\n+            __num_threads = omp_get_num_threads();\n+            __thread_results = new _Result[__num_threads];\n \n-            for (thread_index_t i = 0; i < num_threads; ++i)\n-              thread_results[i] = Result();\n+            for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+              __thread_results[__i] = _Result();\n           }\n \n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n #       pragma omp for schedule(static, _Settings::get().workstealing_chunk_size)\n-        for (difference_type pos = 0; pos < length; ++pos)\n-          thread_results[iam] = r(thread_results[iam], f(o, begin+pos));\n+        for (_DifferenceType __pos = 0; __pos < __length; ++__pos)\n+          __thread_results[__iam] = __r(__thread_results[__iam], __f(__o, __begin+__pos));\n       } //parallel\n \n-    for (thread_index_t i = 0; i < num_threads; ++i)\n-      output = r(output, thread_results[i]);\n+    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+      __output = __r(__output, __thread_results[__i]);\n \n-    delete [] thread_results;\n+    delete [] __thread_results;\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform).\n-    f.finish_iterator = begin + length;\n+    __f.finish_iterator = __begin + __length;\n \n-    return o;\n+    return __o;\n   }\n \n } // end namespace"}, {"sha": "0b5e47abb22a39de48f62c3203babc29569261fc", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -45,89 +45,89 @@ namespace __gnu_parallel\n   * iterators, using hand-crafted parallelization by equal splitting\n   * the work.\n   *\n-  *  @param begin Begin iterator of element sequence.\n-  *  @param end End iterator of element sequence.\n-  *  @param o User-supplied functor (comparator, predicate, adding\n+  *  @param __begin Begin iterator of element __sequence.\n+  *  @param __end End iterator of element __sequence.\n+  *  @param __o User-supplied functor (comparator, predicate, adding\n   *  functor, ...)\n-  *  @param f Functor to \"process\" an element with op (depends on\n+  *  @param __f Functor to \"process\" an element with __op (depends on\n   *  desired functionality, e. g. for std::for_each(), ...).\n-  *  @param r Functor to \"add\" a single result to the already\n-  *  processed elements (depends on functionality).\n-  *  @param base Base value for reduction.\n-  *  @param output Pointer to position where final result is written to\n-  *  @param bound Maximum number of elements processed (e. g. for\n+  *  @param __r Functor to \"add\" a single __result to the already\n+  *  processed __elements (depends on functionality).\n+  *  @param __base Base value for reduction.\n+  *  @param __output Pointer to position where final result is written to\n+  *  @param __bound Maximum number of elements processed (e. g. for\n   *  std::count_n()).\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n-template<typename RandomAccessIterator,\n-\t typename Op,\n-\t typename Fu,\n-\t typename Red,\n-\t typename Result>\n-  Op\n-  for_each_template_random_access_ed(RandomAccessIterator begin,\n-\t\t\t\t     RandomAccessIterator end,\n-\t\t\t\t     Op o, Fu& f, Red r, Result base,\n-\t\t\t\t     Result& output,\n+template<typename _RAIter,\n+\t typename _Op,\n+\t typename _Fu,\n+\t typename _Red,\n+\t typename _Result>\n+  _Op\n+  for_each_template_random_access_ed(_RAIter __begin,\n+\t\t\t\t     _RAIter __end,\n+\t\t\t\t     _Op __o, _Fu& __f, _Red __r, _Result __base,\n+\t\t\t\t     _Result& __output,\n \t\t\t\t     typename std::iterator_traits\n-\t\t\t\t     <RandomAccessIterator>::\n-\t\t\t\t     difference_type bound)\n+\t\t\t\t     <_RAIter>::\n+\t\t\t\t     difference_type __bound)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    const difference_type length = end - begin;\n-    Result *thread_results;\n-    bool* constructed;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    const _DifferenceType __length = __end - __begin;\n+    _Result *__thread_results;\n+    bool* __constructed;\n \n-    thread_index_t num_threads =\n-      __gnu_parallel::min<difference_type>(get_max_threads(), length);\n+    _ThreadIndex __num_threads =\n+      __gnu_parallel::min<_DifferenceType>(__get_max_threads(), __length);\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-            thread_results = static_cast<Result*>(\n-                                ::operator new(num_threads * sizeof(Result)));\n-            constructed = new bool[num_threads];\n+            __num_threads = omp_get_num_threads();\n+            __thread_results = static_cast<_Result*>(\n+                                ::operator new(__num_threads * sizeof(_Result)));\n+            __constructed = new bool[__num_threads];\n           }\n \n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n         // Neutral element.\n-        Result* reduct = static_cast<Result*>(::operator new(sizeof(Result)));\n+        _Result* __reduct = static_cast<_Result*>(::operator new(sizeof(_Result)));\n \n-        difference_type\n-            start = equally_split_point(length, num_threads, iam),\n-            stop = equally_split_point(length, num_threads, iam + 1);\n+        _DifferenceType\n+            __start = equally_split_point(__length, __num_threads, __iam),\n+            __stop = equally_split_point(__length, __num_threads, __iam + 1);\n \n-        if (start < stop)\n+        if (__start < __stop)\n           {\n-            new(reduct) Result(f(o, begin + start));\n-            ++start;\n-            constructed[iam] = true;\n+            new(__reduct) _Result(__f(__o, __begin + __start));\n+            ++__start;\n+            __constructed[__iam] = true;\n           }\n         else\n-          constructed[iam] = false;\n+          __constructed[__iam] = false;\n \n-        for (; start < stop; ++start)\n-          *reduct = r(*reduct, f(o, begin + start));\n+        for (; __start < __stop; ++__start)\n+          *__reduct = __r(*__reduct, __f(__o, __begin + __start));\n \n-        thread_results[iam] = *reduct;\n+        __thread_results[__iam] = *__reduct;\n       } //parallel\n \n-    for (thread_index_t i = 0; i < num_threads; ++i)\n-        if (constructed[i])\n-            output = r(output, thread_results[i]);\n+    for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n+        if (__constructed[__i])\n+            __output = __r(__output, __thread_results[__i]);\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform).\n-    f.finish_iterator = begin + length;\n+    __f.finish_iterator = __begin + __length;\n \n-    delete[] thread_results;\n-    delete[] constructed;\n+    delete[] __thread_results;\n+    delete[] __constructed;\n \n-    return o;\n+    return __o;\n   }\n \n } // end namespace"}, {"sha": "40f6299d37bfd4cee965e36c3a3c0643c3f84830", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -23,8 +23,8 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file parallel/partial_sum.h\n- *  @brief Parallel implementation of std::partial_sum(), i. e. prefix\n- *  sums.\n+ *  @brief Parallel implementation of std::partial_sum(), i.e. prefix\n+*  sums.\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n \n@@ -44,175 +44,175 @@ namespace __gnu_parallel\n   // Problem: there is no 0-element given.\n \n /** @brief Base case prefix sum routine.\n-  *  @param begin Begin iterator of input sequence.\n-  *  @param end End iterator of input sequence.\n-  *  @param result Begin iterator of output sequence.\n-  *  @param bin_op Associative binary function.\n-  *  @param value Start value. Must be passed since the neutral\n+  *  @param __begin Begin iterator of input sequence.\n+  *  @param __end End iterator of input sequence.\n+  *  @param __result Begin iterator of output sequence.\n+  *  @param __bin_op Associative binary function.\n+  *  @param __value Start value. Must be passed since the neutral\n   *  element is unknown in general.\n   *  @return End iterator of output sequence. */\n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename BinaryOperation>\n-  OutputIterator\n-  parallel_partial_sum_basecase(InputIterator begin, InputIterator end,\n-\t\t\t\tOutputIterator result, BinaryOperation bin_op,\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _BinaryOperation>\n+  _OutputIterator\n+  __parallel_partial_sum_basecase(_IIter __begin, _IIter __end,\n+\t\t\t\t_OutputIterator __result, _BinaryOperation __bin_op,\n \t\t\t\ttypename std::iterator_traits\n-\t\t\t\t<InputIterator>::value_type value)\n+\t\t\t\t<_IIter>::value_type __value)\n   {\n-    if (begin == end)\n-      return result;\n+    if (__begin == __end)\n+      return __result;\n \n-    while (begin != end)\n+    while (__begin != __end)\n       {\n-        value = bin_op(value, *begin);\n-        *result = value;\n-        ++result;\n-        ++begin;\n+        __value = __bin_op(__value, *__begin);\n+        *__result = __value;\n+        ++__result;\n+        ++__begin;\n       }\n-    return result;\n+    return __result;\n   }\n \n /** @brief Parallel partial sum implementation, two-phase approach,\n     no recursion.\n-    *  @param begin Begin iterator of input sequence.\n-    *  @param end End iterator of input sequence.\n-    *  @param result Begin iterator of output sequence.\n-    *  @param bin_op Associative binary function.\n-    *  @param n Length of sequence.\n-    *  @param num_threads Number of threads to use.\n+    *  @param __begin Begin iterator of input sequence.\n+    *  @param __end End iterator of input sequence.\n+    *  @param __result Begin iterator of output sequence.\n+    *  @param __bin_op Associative binary function.\n+    *  @param __n Length of sequence.\n+    *  @param __num_threads Number of threads to use.\n     *  @return End iterator of output sequence.\n     */\n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename BinaryOperation>\n-  OutputIterator\n-  parallel_partial_sum_linear(InputIterator begin, InputIterator end,\n-\t\t\t      OutputIterator result, BinaryOperation bin_op,\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _BinaryOperation>\n+  _OutputIterator\n+  __parallel_partial_sum_linear(_IIter __begin, _IIter __end,\n+\t\t\t      _OutputIterator __result, _BinaryOperation __bin_op,\n \t\t\t      typename std::iterator_traits\n-\t\t\t      <InputIterator>::difference_type n)\n+\t\t\t      <_IIter>::difference_type __n)\n   {\n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    if (begin == end)\n-      return result;\n+    if (__begin == __end)\n+      return __result;\n \n-    thread_index_t num_threads =\n-        std::min<difference_type>(get_max_threads(), n - 1);\n+    _ThreadIndex __num_threads =\n+        std::min<_DifferenceType>(__get_max_threads(), __n - 1);\n \n-    if (num_threads < 2)\n+    if (__num_threads < 2)\n       {\n-        *result = *begin;\n-        return parallel_partial_sum_basecase(\n-            begin + 1, end, result + 1, bin_op, *begin);\n+        *__result = *__begin;\n+        return __parallel_partial_sum_basecase(\n+            __begin + 1, __end, __result + 1, __bin_op, *__begin);\n       }\n \n-    difference_type* borders;\n-    value_type* sums;\n+    _DifferenceType* __borders;\n+    _ValueType* __sums;\n \n     const _Settings& __s = _Settings::get();\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n+            __num_threads = omp_get_num_threads();\n \n-            borders = new difference_type[num_threads + 2];\n+            __borders = new _DifferenceType[__num_threads + 2];\n \n             if (__s.partial_sum_dilation == 1.0f)\n-              equally_split(n, num_threads + 1, borders);\n+              equally_split(__n, __num_threads + 1, __borders);\n             else\n               {\n-                difference_type chunk_length =\n-                    ((double)n\n-\t\t     / ((double)num_threads + __s.partial_sum_dilation)),\n-\t\t  borderstart = n - num_threads * chunk_length;\n-                borders[0] = 0;\n-                for (int i = 1; i < (num_threads + 1); ++i)\n+                _DifferenceType __chunk_length =\n+                    ((double)__n\n+\t\t     / ((double)__num_threads + __s.partial_sum_dilation)),\n+\t\t  __borderstart = __n - __num_threads * __chunk_length;\n+                __borders[0] = 0;\n+                for (int __i = 1; __i < (__num_threads + 1); ++__i)\n                   {\n-                    borders[i] = borderstart;\n-                    borderstart += chunk_length;\n+                    __borders[__i] = __borderstart;\n+                    __borderstart += __chunk_length;\n                   }\n-                borders[num_threads + 1] = n;\n+                __borders[__num_threads + 1] = __n;\n               }\n \n-            sums = static_cast<value_type*>(::operator new(sizeof(value_type)\n-\t\t\t\t\t\t\t   * num_threads));\n-            OutputIterator target_end;\n+            __sums = static_cast<_ValueType*>(::operator new(sizeof(_ValueType)\n+\t\t\t\t\t\t\t   * __num_threads));\n+            _OutputIterator __target_end;\n           } //single\n \n-        thread_index_t iam = omp_get_thread_num();\n-        if (iam == 0)\n+        _ThreadIndex __iam = omp_get_thread_num();\n+        if (__iam == 0)\n           {\n-            *result = *begin;\n-            parallel_partial_sum_basecase(begin + 1, begin + borders[1],\n-\t\t\t\t\t  result + 1, bin_op, *begin);\n-            ::new(&(sums[iam])) value_type(*(result + borders[1] - 1));\n+            *__result = *__begin;\n+            __parallel_partial_sum_basecase(__begin + 1, __begin + __borders[1],\n+\t\t\t\t\t  __result + 1, __bin_op, *__begin);\n+            ::new(&(__sums[__iam])) _ValueType(*(__result + __borders[1] - 1));\n           }\n         else\n           {\n-            ::new(&(sums[iam]))\n-\t      value_type(std::accumulate(begin + borders[iam] + 1,\n-\t\t\t\t\t begin + borders[iam + 1],\n-\t\t\t\t\t *(begin + borders[iam]),\n-\t\t\t\t\t bin_op,\n+            ::new(&(__sums[__iam]))\n+\t      _ValueType(std::accumulate(__begin + __borders[__iam] + 1,\n+\t\t\t\t\t __begin + __borders[__iam + 1],\n+\t\t\t\t\t *(__begin + __borders[__iam]),\n+\t\t\t\t\t __bin_op,\n \t\t\t\t\t __gnu_parallel::sequential_tag()));\n           }\n \n #       pragma omp barrier\n \n #       pragma omp single\n-          parallel_partial_sum_basecase(\n-              sums + 1, sums + num_threads, sums + 1, bin_op, sums[0]);\n+          __parallel_partial_sum_basecase(\n+              __sums + 1, __sums + __num_threads, __sums + 1, __bin_op, __sums[0]);\n \n #       pragma omp barrier\n \n         // Still same team.\n-        parallel_partial_sum_basecase(begin + borders[iam + 1],\n-\t\t\t\t      begin + borders[iam + 2],\n-\t\t\t\t      result + borders[iam + 1], bin_op,\n-\t\t\t\t      sums[iam]);\n+        __parallel_partial_sum_basecase(__begin + __borders[__iam + 1],\n+\t\t\t\t      __begin + __borders[__iam + 2],\n+\t\t\t\t      __result + __borders[__iam + 1], __bin_op,\n+\t\t\t\t      __sums[__iam]);\n       } //parallel\n \n-    ::operator delete(sums);\n-    delete[] borders;\n+    ::operator delete(__sums);\n+    delete[] __borders;\n \n-    return result + n;\n+    return __result + __n;\n   }\n \n-/** @brief Parallel partial sum front-end.\n-  *  @param begin Begin iterator of input sequence.\n-  *  @param end End iterator of input sequence.\n-  *  @param result Begin iterator of output sequence.\n-  *  @param bin_op Associative binary function.\n+/** @brief Parallel partial sum front-__end.\n+  *  @param __begin Begin iterator of input sequence.\n+  *  @param __end End iterator of input sequence.\n+  *  @param __result Begin iterator of output sequence.\n+  *  @param __bin_op Associative binary function.\n   *  @return End iterator of output sequence. */\n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename BinaryOperation>\n-  OutputIterator\n-  parallel_partial_sum(InputIterator begin, InputIterator end,\n-                       OutputIterator result, BinaryOperation bin_op)\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _BinaryOperation>\n+  _OutputIterator\n+  __parallel_partial_sum(_IIter __begin, _IIter __end,\n+                       _OutputIterator __result, _BinaryOperation __bin_op)\n   {\n-    _GLIBCXX_CALL(begin - end)\n+    _GLIBCXX_CALL(__begin - __end)\n \n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n \n     switch (_Settings::get().partial_sum_algorithm)\n       {\n       case LINEAR:\n-        // Need an initial offset.\n-        return parallel_partial_sum_linear(begin, end, result, bin_op, n);\n+        // Need an initial __offset.\n+        return __parallel_partial_sum_linear(__begin, __end, __result, __bin_op, __n);\n       default:\n     // Partial_sum algorithm not implemented.\n         _GLIBCXX_PARALLEL_ASSERT(0);\n-        return result + n;\n+        return __result + __n;\n       }\n   }\n }"}, {"sha": "81b72998b5fe93dc2ff3e4ed109a375a1008ba85", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 202, "deletions": 202, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -45,381 +45,381 @@\n namespace __gnu_parallel\n {\n /** @brief Parallel implementation of std::partition.\n-  *  @param begin Begin iterator of input sequence to split.\n-  *  @param end End iterator of input sequence to split.\n-  *  @param pred Partition predicate, possibly including some kind of pivot.\n-  *  @param num_threads Maximum number of threads to use for this task.\n+  *  @param __begin Begin iterator of input sequence to split.\n+  *  @param __end End iterator of input sequence to split.\n+  *  @param __pred Partition predicate, possibly including some kind of pivot.\n+  *  @param __num_threads Maximum number of threads to use for this task.\n   *  @return Number of elements not fulfilling the predicate. */\n-template<typename RandomAccessIterator, typename Predicate>\n-  typename std::iterator_traits<RandomAccessIterator>::difference_type\n-  parallel_partition(RandomAccessIterator begin, RandomAccessIterator end,\n-                     Predicate pred, thread_index_t num_threads)\n+template<typename _RAIter, typename _Predicate>\n+  typename std::iterator_traits<_RAIter>::difference_type\n+  __parallel_partition(_RAIter __begin, _RAIter __end,\n+                     _Predicate __pred, _ThreadIndex __num_threads)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n \n-    _GLIBCXX_CALL(n)\n+    _GLIBCXX_CALL(__n)\n \n     const _Settings& __s = _Settings::get();\n \n     // Shared.\n-    _GLIBCXX_VOLATILE difference_type left = 0, right = n - 1;\n-    _GLIBCXX_VOLATILE difference_type leftover_left, leftover_right;\n-    _GLIBCXX_VOLATILE difference_type leftnew, rightnew;\n+    _GLIBCXX_VOLATILE _DifferenceType __left = 0, __right = __n - 1;\n+    _GLIBCXX_VOLATILE _DifferenceType __leftover_left, __leftover_right;\n+    _GLIBCXX_VOLATILE _DifferenceType __leftnew, __rightnew;\n \n-    bool* reserved_left = NULL, * reserved_right = NULL;\n+    bool* __reserved_left = NULL, * __reserved_right = NULL;\n \n-    difference_type chunk_size;\n+    _DifferenceType __chunk_size;\n \n-    omp_lock_t result_lock;\n-    omp_init_lock(&result_lock);\n+    omp_lock_t __result_lock;\n+    omp_init_lock(&__result_lock);\n \n-    //at least two chunks per thread\n-    if(right - left + 1 >= 2 * num_threads * chunk_size)\n-#   pragma omp parallel num_threads(num_threads)\n+    //at least two __chunks per thread\n+    if(__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-            reserved_left = new bool[num_threads];\n-            reserved_right = new bool[num_threads];\n+            __num_threads = omp_get_num_threads();\n+            __reserved_left = new bool[__num_threads];\n+            __reserved_right = new bool[__num_threads];\n \n             if (__s.partition_chunk_share > 0.0)\n-              chunk_size = std::max<difference_type>(__s.partition_chunk_size,\n-\t\t\t\t    (double)n * __s.partition_chunk_share\n-\t\t\t\t\t\t     / (double)num_threads);\n+              __chunk_size = std::max<_DifferenceType>(__s.partition_chunk_size,\n+\t\t\t\t    (double)__n * __s.partition_chunk_share\n+\t\t\t\t\t\t     / (double)__num_threads);\n             else\n-              chunk_size = __s.partition_chunk_size;\n+              __chunk_size = __s.partition_chunk_size;\n           }\n \n-        while (right - left + 1 >= 2 * num_threads * chunk_size)\n+        while (__right - __left + 1 >= 2 * __num_threads * __chunk_size)\n           {\n #           pragma omp single\n               {\n-                difference_type num_chunks = (right - left + 1) / chunk_size;\n+                _DifferenceType __num_chunks = (__right - __left + 1) / __chunk_size;\n \n-                for (int r = 0; r < num_threads; ++r)\n+                for (int __r = 0; __r < __num_threads; ++__r)\n                   {\n-                    reserved_left[r] = false;\n-                    reserved_right[r] = false;\n+                    __reserved_left[__r] = false;\n+                    __reserved_right[__r] = false;\n                   }\n-                leftover_left = 0;\n-                leftover_right = 0;\n+                __leftover_left = 0;\n+                __leftover_right = 0;\n               } //implicit barrier\n \n             // Private.\n-            difference_type thread_left, thread_left_border,\n-                            thread_right, thread_right_border;\n-            thread_left = left + 1;\n+            _DifferenceType __thread_left, __thread_left_border,\n+                            thread_right, __thread_right_border;\n+            __thread_left = __left + 1;\n \n             // Just to satisfy the condition below.\n-            thread_left_border = thread_left - 1;\n-            thread_right = n - 1;\n-            thread_right_border = thread_right + 1;\n+            __thread_left_border = __thread_left - 1;\n+            thread_right = __n - 1;\n+            __thread_right_border = thread_right + 1;\n \n-            bool iam_finished = false;\n-            while (!iam_finished)\n+            bool __iam_finished = false;\n+            while (!__iam_finished)\n               {\n-                if (thread_left > thread_left_border)\n+                if (__thread_left > __thread_left_border)\n                   {\n-                    omp_set_lock(&result_lock);\n-                    if (left + (chunk_size - 1) > right)\n-                      iam_finished = true;\n+                    omp_set_lock(&__result_lock);\n+                    if (__left + (__chunk_size - 1) > __right)\n+                      __iam_finished = true;\n                     else\n                       {\n-                        thread_left = left;\n-                        thread_left_border = left + (chunk_size - 1);\n-                        left += chunk_size;\n+                        __thread_left = __left;\n+                        __thread_left_border = __left + (__chunk_size - 1);\n+                        __left += __chunk_size;\n                       }\n-                    omp_unset_lock(&result_lock);\n+                    omp_unset_lock(&__result_lock);\n                   }\n \n-                if (thread_right < thread_right_border)\n+                if (thread_right < __thread_right_border)\n                   {\n-                    omp_set_lock(&result_lock);\n-                    if (left > right - (chunk_size - 1))\n-                      iam_finished = true;\n+                    omp_set_lock(&__result_lock);\n+                    if (__left > __right - (__chunk_size - 1))\n+                      __iam_finished = true;\n                     else\n                       {\n-                        thread_right = right;\n-                        thread_right_border = right - (chunk_size - 1);\n-                        right -= chunk_size;\n+                        thread_right = __right;\n+                        __thread_right_border = __right - (__chunk_size - 1);\n+                        __right -= __chunk_size;\n                       }\n-                    omp_unset_lock(&result_lock);\n+                    omp_unset_lock(&__result_lock);\n                   }\n \n-                if (iam_finished)\n+                if (__iam_finished)\n                   break;\n \n                 // Swap as usual.\n-                while (thread_left < thread_right)\n+                while (__thread_left < thread_right)\n                   {\n-                    while (pred(begin[thread_left])\n-                            && thread_left <= thread_left_border)\n-                      ++thread_left;\n-                    while (!pred(begin[thread_right])\n-                            && thread_right >= thread_right_border)\n+                    while (__pred(__begin[__thread_left])\n+                            && __thread_left <= __thread_left_border)\n+                      ++__thread_left;\n+                    while (!__pred(__begin[thread_right])\n+                            && thread_right >= __thread_right_border)\n                       --thread_right;\n \n-                    if (thread_left > thread_left_border\n-                        || thread_right < thread_right_border)\n-                      // Fetch new chunk(s).\n+                    if (__thread_left > __thread_left_border\n+                        || thread_right < __thread_right_border)\n+                      // Fetch new chunk(__s).\n                       break;\n \n-                    std::swap(begin[thread_left], begin[thread_right]);\n-                    ++thread_left;\n+                    std::swap(__begin[__thread_left], __begin[thread_right]);\n+                    ++__thread_left;\n                     --thread_right;\n                   }\n               }\n \n             // Now swap the leftover chunks to the right places.\n-            if (thread_left <= thread_left_border)\n+            if (__thread_left <= __thread_left_border)\n #             pragma omp atomic\n-              ++leftover_left;\n-            if (thread_right >= thread_right_border)\n+              ++__leftover_left;\n+            if (thread_right >= __thread_right_border)\n #             pragma omp atomic\n-              ++leftover_right;\n+              ++__leftover_right;\n \n #           pragma omp barrier\n \n #           pragma omp single\n               {\n-                leftnew = left - leftover_left * chunk_size;\n-                rightnew = right + leftover_right * chunk_size;\n+                __leftnew = __left - __leftover_left * __chunk_size;\n+                __rightnew = __right + __leftover_right * __chunk_size;\n               }\n \n #           pragma omp barrier\n \n-            // <=> thread_left_border + (chunk_size - 1) >= leftnew\n-            if (thread_left <= thread_left_border\n-                && thread_left_border >= leftnew)\n+            // <=> __thread_left_border + (__chunk_size - 1) >= __leftnew\n+            if (__thread_left <= __thread_left_border\n+                && __thread_left_border >= __leftnew)\n               {\n                 // Chunk already in place, reserve spot.\n-                reserved_left[(left - (thread_left_border + 1)) / chunk_size]\n+                __reserved_left[(__left - (__thread_left_border + 1)) / __chunk_size]\n                     = true;\n               }\n \n-            // <=> thread_right_border - (chunk_size - 1) <= rightnew\n-            if (thread_right >= thread_right_border\n-                && thread_right_border <= rightnew)\n+            // <=> __thread_right_border - (__chunk_size - 1) <= __rightnew\n+            if (thread_right >= __thread_right_border\n+                && __thread_right_border <= __rightnew)\n               {\n                 // Chunk already in place, reserve spot.\n-                reserved_right[((thread_right_border - 1) - right)\n-\t\t\t       / chunk_size] = true;\n+                __reserved_right[((__thread_right_border - 1) - __right)\n+\t\t\t       / __chunk_size] = true;\n               }\n \n #           pragma omp barrier\n \n-            if (thread_left <= thread_left_border\n-                && thread_left_border < leftnew)\n+            if (__thread_left <= __thread_left_border\n+                && __thread_left_border < __leftnew)\n               {\n                 // Find spot and swap.\n-                difference_type swapstart = -1;\n-                omp_set_lock(&result_lock);\n-                for (int r = 0; r < leftover_left; ++r)\n-                  if (!reserved_left[r])\n+                _DifferenceType __swapstart = -1;\n+                omp_set_lock(&__result_lock);\n+                for (int __r = 0; __r < __leftover_left; ++__r)\n+                  if (!__reserved_left[__r])\n                     {\n-                      reserved_left[r] = true;\n-                      swapstart = left - (r + 1) * chunk_size;\n+                      __reserved_left[__r] = true;\n+                      __swapstart = __left - (__r + 1) * __chunk_size;\n                       break;\n                     }\n-                omp_unset_lock(&result_lock);\n+                omp_unset_lock(&__result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n-                _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n+                _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n #endif\n \n-                std::swap_ranges(begin + thread_left_border\n-\t\t\t\t - (chunk_size - 1),\n-\t\t\t\t begin + thread_left_border + 1,\n-\t\t\t\t begin + swapstart);\n+                std::swap_ranges(__begin + __thread_left_border\n+\t\t\t\t - (__chunk_size - 1),\n+\t\t\t\t __begin + __thread_left_border + 1,\n+\t\t\t\t __begin + __swapstart);\n               }\n \n-            if (thread_right >= thread_right_border\n-                && thread_right_border > rightnew)\n+            if (thread_right >= __thread_right_border\n+                && __thread_right_border > __rightnew)\n               {\n                 // Find spot and swap\n-                difference_type swapstart = -1;\n-                omp_set_lock(&result_lock);\n-                for (int r = 0; r < leftover_right; ++r)\n-                  if (!reserved_right[r])\n+                _DifferenceType __swapstart = -1;\n+                omp_set_lock(&__result_lock);\n+                for (int __r = 0; __r < __leftover_right; ++__r)\n+                  if (!__reserved_right[__r])\n                     {\n-                      reserved_right[r] = true;\n-                      swapstart = right + r * chunk_size + 1;\n+                      __reserved_right[__r] = true;\n+                      __swapstart = __right + __r * __chunk_size + 1;\n                       break;\n                     }\n-                omp_unset_lock(&result_lock);\n+                omp_unset_lock(&__result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n-                _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n+                _GLIBCXX_PARALLEL_ASSERT(__swapstart != -1);\n #endif\n \n-                std::swap_ranges(begin + thread_right_border,\n-\t\t\t\t begin + thread_right_border + chunk_size,\n-\t\t\t\t begin + swapstart);\n+                std::swap_ranges(__begin + __thread_right_border,\n+\t\t\t\t __begin + __thread_right_border + __chunk_size,\n+\t\t\t\t __begin + __swapstart);\n               }\n #if _GLIBCXX_ASSERTIONS\n #             pragma omp barrier\n \n #             pragma omp single\n                 {\n-                  for (int r = 0; r < leftover_left; ++r)\n-                    _GLIBCXX_PARALLEL_ASSERT(reserved_left[r]);\n-                  for (int r = 0; r < leftover_right; ++r)\n-                    _GLIBCXX_PARALLEL_ASSERT(reserved_right[r]);\n+                  for (int __r = 0; __r < __leftover_left; ++__r)\n+                    _GLIBCXX_PARALLEL_ASSERT(__reserved_left[__r]);\n+                  for (int __r = 0; __r < __leftover_right; ++__r)\n+                    _GLIBCXX_PARALLEL_ASSERT(__reserved_right[__r]);\n                 }\n \n #             pragma omp barrier\n #endif\n \n #             pragma omp barrier\n \n-              left = leftnew;\n-              right = rightnew;\n+              __left = __leftnew;\n+              __right = __rightnew;\n           }\n-#         pragma omp flush(left, right)\n+#         pragma omp flush(__left, __right)\n       } // end \"recursion\" //parallel\n \n-    difference_type final_left = left, final_right = right;\n+    _DifferenceType __final_left = __left, __final_right = __right;\n \n-    while (final_left < final_right)\n+    while (__final_left < __final_right)\n       {\n         // Go right until key is geq than pivot.\n-        while (pred(begin[final_left]) && final_left < final_right)\n-          ++final_left;\n+        while (__pred(__begin[__final_left]) && __final_left < __final_right)\n+          ++__final_left;\n \n         // Go left until key is less than pivot.\n-        while (!pred(begin[final_right]) && final_left < final_right)\n-          --final_right;\n+        while (!__pred(__begin[__final_right]) && __final_left < __final_right)\n+          --__final_right;\n \n-        if (final_left == final_right)\n+        if (__final_left == __final_right)\n           break;\n-        std::swap(begin[final_left], begin[final_right]);\n-        ++final_left;\n-        --final_right;\n+        std::swap(__begin[__final_left], __begin[__final_right]);\n+        ++__final_left;\n+        --__final_right;\n       }\n \n     // All elements on the left side are < piv, all elements on the\n     // right are >= piv\n-    delete[] reserved_left;\n-    delete[] reserved_right;\n+    delete[] __reserved_left;\n+    delete[] __reserved_right;\n \n-    omp_destroy_lock(&result_lock);\n+    omp_destroy_lock(&__result_lock);\n \n-    // Element \"between\" final_left and final_right might not have\n+    // Element \"between\" __final_left and __final_right might not have\n     // been regarded yet\n-    if (final_left < n && !pred(begin[final_left]))\n+    if (__final_left < __n && !__pred(__begin[__final_left]))\n       // Really swapped.\n-      return final_left;\n+      return __final_left;\n     else\n-      return final_left + 1;\n+      return __final_left + 1;\n   }\n \n /**\n   *  @brief Parallel implementation of std::nth_element().\n-  *  @param begin Begin iterator of input sequence.\n-  *  @param nth Iterator of element that must be in position afterwards.\n-  *  @param end End iterator of input sequence.\n-  *  @param comp Comparator.\n+  *  @param __begin Begin iterator of input sequence.\n+  *  @param __nth _Iterator of element that must be in position afterwards.\n+  *  @param __end End iterator of input sequence.\n+  *  @param __comp Comparator.\n   */\n-template<typename RandomAccessIterator, typename Comparator>\n+template<typename _RAIter, typename _Compare>\n   void \n-  parallel_nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n-\t\t       RandomAccessIterator end, Comparator comp)\n+  parallel_nth_element(_RAIter __begin, _RAIter __nth, \n+\t\t       _RAIter __end, _Compare __comp)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    RandomAccessIterator split;\n-    random_number rng;\n+    _RAIter __split;\n+    _RandomNumber __rng;\n \n-    difference_type minimum_length =\n-      std::max<difference_type>(2, _Settings::get().partition_minimal_n);\n+    _DifferenceType minimum_length =\n+      std::max<_DifferenceType>(2, _Settings::get().partition_minimal_n);\n \n     // Break if input range to small.\n-    while (static_cast<sequence_index_t>(end - begin) >= minimum_length)\n+    while (static_cast<_SequenceIndex>(__end - __begin) >= minimum_length)\n       {\n-        difference_type n = end - begin;\n+        _DifferenceType __n = __end - __begin;\n \n-        RandomAccessIterator pivot_pos = begin +  rng(n);\n+        _RAIter __pivot_pos = __begin +  __rng(__n);\n \n-        // Swap pivot_pos value to end.\n-        if (pivot_pos != (end - 1))\n-          std::swap(*pivot_pos, *(end - 1));\n-        pivot_pos = end - 1;\n+        // Swap __pivot_pos value to end.\n+        if (__pivot_pos != (__end - 1))\n+          std::swap(*__pivot_pos, *(__end - 1));\n+        __pivot_pos = __end - 1;\n \n-        // XXX Comparator must have first_value_type, second_value_type,\n-\t// result_type\n-        // Comparator == __gnu_parallel::lexicographic<S, int,\n-\t// __gnu_parallel::less<S, S> >\n-        // pivot_pos == std::pair<S, int>*\n-        // XXX binder2nd only for RandomAccessIterators??\n-        __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n-\t  pred(comp, *pivot_pos);\n+        // XXX _Compare must have first__ValueType, second__ValueType,\n+\t// _ResultType\n+        // _Compare == __gnu_parallel::_Lexicographic<S, int,\n+\t// __gnu_parallel::_Less<S, S> >\n+        // __pivot_pos == std::pair<S, int>*\n+        // XXX binder2nd only for _RAIters??\n+        __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n+\t  __pred(__comp, *__pivot_pos);\n \n         // Divide, leave pivot unchanged in last place.\n-        RandomAccessIterator split_pos1, split_pos2;\n-        split_pos1 = begin + parallel_partition(begin, end - 1, pred,\n-\t\t\t\t\t\tget_max_threads());\n+        _RAIter __split_pos1, __split_pos2;\n+        __split_pos1 = __begin + __parallel_partition(__begin, __end - 1, __pred,\n+\t\t\t\t\t\t__get_max_threads());\n \n-        // Left side: < pivot_pos; right side: >= pivot_pos\n+        // Left side: < __pivot_pos; __right side: >= __pivot_pos\n \n         // Swap pivot back to middle.\n-        if (split_pos1 != pivot_pos)\n-          std::swap(*split_pos1, *pivot_pos);\n-        pivot_pos = split_pos1;\n+        if (__split_pos1 != __pivot_pos)\n+          std::swap(*__split_pos1, *__pivot_pos);\n+        __pivot_pos = __split_pos1;\n \n-        // In case all elements are equal, split_pos1 == 0\n-        if ((split_pos1 + 1 - begin) < (n >> 7)\n-\t    || (end - split_pos1) < (n >> 7))\n+        // In case all elements are equal, __split_pos1 == 0\n+        if ((__split_pos1 + 1 - __begin) < (__n >> 7)\n+\t    || (__end - __split_pos1) < (__n >> 7))\n           {\n             // Very unequal split, one part smaller than one 128th\n             // elements not strictly larger than the pivot.\n-            __gnu_parallel::unary_negate<__gnu_parallel::\n-\t      binder1st<Comparator, value_type, value_type, bool>, value_type>\n-\t      pred(__gnu_parallel::binder1st<Comparator, value_type,\n-\t\t   value_type, bool>(comp, *pivot_pos));\n+            __gnu_parallel::__unary_negate<__gnu_parallel::\n+\t      __binder1st<_Compare, _ValueType, _ValueType, bool>, _ValueType>\n+\t      __pred(__gnu_parallel::__binder1st<_Compare, _ValueType,\n+\t\t   _ValueType, bool>(__comp, *__pivot_pos));\n \n             // Find other end of pivot-equal range.\n-            split_pos2 = __gnu_sequential::partition(split_pos1 + 1,\n-\t\t\t\t\t\t     end, pred);\n+            __split_pos2 = __gnu_sequential::partition(__split_pos1 + 1,\n+\t\t\t\t\t\t     __end, __pred);\n           }\n         else\n           // Only skip the pivot.\n-          split_pos2 = split_pos1 + 1;\n+          __split_pos2 = __split_pos1 + 1;\n \n         // Compare iterators.\n-        if (split_pos2 <= nth)\n-          begin = split_pos2;\n-        else if (nth < split_pos1)\n-          end = split_pos1;\n+        if (__split_pos2 <= __nth)\n+          __begin = __split_pos2;\n+        else if (__nth < __split_pos1)\n+          __end = __split_pos1;\n         else\n           break;\n       }\n \n-    // Only at most _Settings::partition_minimal_n elements left.\n-    __gnu_sequential::sort(begin, end, comp);\n+    // Only at most _Settings::partition_minimal_n __elements __left.\n+    __gnu_sequential::sort(__begin, __end, __comp);\n   }\n \n /** @brief Parallel implementation of std::partial_sort().\n-*  @param begin Begin iterator of input sequence.\n-*  @param middle Sort until this position.\n-*  @param end End iterator of input sequence.\n-*  @param comp Comparator. */\n-template<typename RandomAccessIterator, typename Comparator>\n+*  @param __begin Begin iterator of input sequence.\n+*  @param __middle Sort until this position.\n+*  @param __end End iterator of input sequence.\n+*  @param __comp Comparator. */\n+template<typename _RAIter, typename _Compare>\n   void\n-  parallel_partial_sort(RandomAccessIterator begin,\n-\t\t\tRandomAccessIterator middle,\n-\t\t\tRandomAccessIterator end, Comparator comp)\n+  parallel_partial_sort(_RAIter __begin,\n+\t\t\t_RAIter __middle,\n+\t\t\t_RAIter __end, _Compare __comp)\n   {\n-    parallel_nth_element(begin, middle, end, comp);\n-    std::sort(begin, middle, comp);\n+    parallel_nth_element(__begin, __middle, __end, __comp);\n+    std::sort(__begin, __middle, __comp);\n   }\n \n } //namespace __gnu_parallel"}, {"sha": "ab6e2d3a291d774b503f538774a6959a5b70bb56", "filename": "libstdc++-v3/include/parallel/queue.h", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -45,99 +45,99 @@ namespace __gnu_parallel\n    *  atomic access.  push_front() and pop_front() must not be called\n    *  concurrently to each other, while pop_back() can be called\n    *  concurrently at all times.\n-   *  @c empty(), @c size(), and @c top() are intentionally not provided.\n+   *  @__c empty(), @__c size(), and @__c top() are intentionally not provided.\n    *  Calling them would not make sense in a concurrent setting.\n-   *  @param T Contained element type. */\n-  template<typename T>\n-    class RestrictedBoundedConcurrentQueue\n+   *  @param _Tp Contained element type. */\n+  template<typename _Tp>\n+    class _RestrictedBoundedConcurrentQueue\n     {\n     private:\n       /** @brief Array of elements, seen as cyclic buffer. */\n-      T* base;\n+      _Tp* _M_base;\n \n       /** @brief Maximal number of elements contained at the same time. */\n-      sequence_index_t max_size;\n+      _SequenceIndex _M_max_size;\n \n-      /** @brief Cyclic begin and end pointers contained in one\n+      /** @brief Cyclic __begin and __end pointers contained in one\n \t  atomically changeable value. */\n-      _GLIBCXX_VOLATILE lcas_t borders;\n+      _GLIBCXX_VOLATILE _CASable _M_borders;\n \n     public:\n       /** @brief Constructor. Not to be called concurrent, of course.\n-       *  @param max_size Maximal number of elements to be contained. */\n-      RestrictedBoundedConcurrentQueue(sequence_index_t max_size)\n+       *  @param _M_max_size Maximal number of elements to be contained. */\n+      _RestrictedBoundedConcurrentQueue(_SequenceIndex _M_max_size)\n       {\n-\tthis->max_size = max_size;\n-\tbase = new T[max_size];\n-\tborders = encode2(0, 0);\n+\tthis->_M_max_size = _M_max_size;\n+\t_M_base = new _Tp[_M_max_size];\n+\t_M_borders = __encode2(0, 0);\n #pragma omp flush\n       }\n \n       /** @brief Destructor. Not to be called concurrent, of course. */\n-      ~RestrictedBoundedConcurrentQueue()\n-      { delete[] base; }\n+      ~_RestrictedBoundedConcurrentQueue()\n+      { delete[] _M_base; }\n \n-      /** @brief Pushes one element into the queue at the front end.\n+      /** @brief Pushes one element into the queue at the front __end.\n        *  Must not be called concurrently with pop_front(). */\n       void\n-      push_front(const T& t)\n+      push_front(const _Tp& __t)\n       {\n-\tlcas_t former_borders = borders;\n-\tint former_front, former_back;\n-\tdecode2(former_borders, former_front, former_back);\n-\t*(base + former_front % max_size) = t;\n+\t_CASable __former_borders = _M_borders;\n+\tint __former_front, __former_back;\n+\tdecode2(__former_borders, __former_front, __former_back);\n+\t*(_M_base + __former_front % _M_max_size) = __t;\n #if _GLIBCXX_ASSERTIONS\n-\t// Otherwise: front - back > max_size eventually.\n-\t_GLIBCXX_PARALLEL_ASSERT(((former_front + 1) - former_back)\n-\t\t\t\t <= max_size);\n+\t// Otherwise: front - back > _M_max_size eventually.\n+\t_GLIBCXX_PARALLEL_ASSERT(((__former_front + 1) - __former_back)\n+\t\t\t\t <= _M_max_size);\n #endif\n-\tfetch_and_add(&borders, encode2(1, 0));\n+\t__fetch_and_add(&_M_borders, __encode2(1, 0));\n       }\n \n-      /** @brief Pops one element from the queue at the front end.\n+      /** @brief Pops one element from the queue at the front __end.\n        *  Must not be called concurrently with pop_front(). */\n       bool\n-      pop_front(T& t)\n+      pop_front(_Tp& __t)\n       {\n-\tint former_front, former_back;\n+\tint __former_front, __former_back;\n #pragma omp flush\n-\tdecode2(borders, former_front, former_back);\n-\twhile (former_front > former_back)\n+\tdecode2(_M_borders, __former_front, __former_back);\n+\twhile (__former_front > __former_back)\n \t  {\n \t    // Chance.\n-\t    lcas_t former_borders = encode2(former_front, former_back);\n-\t    lcas_t new_borders = encode2(former_front - 1, former_back);\n-\t    if (compare_and_swap(&borders, former_borders, new_borders))\n+\t    _CASable __former_borders = __encode2(__former_front, __former_back);\n+\t    _CASable __new_borders = __encode2(__former_front - 1, __former_back);\n+\t    if (__compare_and_swap(&_M_borders, __former_borders, __new_borders))\n \t      {\n-\t\tt = *(base + (former_front - 1) % max_size);\n+\t\t__t = *(_M_base + (__former_front - 1) % _M_max_size);\n \t\treturn true;\n \t      }\n #pragma omp flush\n-\t    decode2(borders, former_front, former_back);\n+\t    decode2(_M_borders, __former_front, __former_back);\n \t  }\n \treturn false;\n       }\n \n-      /** @brief Pops one element from the queue at the front end.\n+      /** @brief Pops one element from the queue at the front __end.\n        *  Must not be called concurrently with pop_front(). */\n       bool\n-      pop_back(T& t)\t//queue behavior\n+      pop_back(_Tp& __t)\t//queue behavior\n       {\n-\tint former_front, former_back;\n+\tint __former_front, __former_back;\n #pragma omp flush\n-\tdecode2(borders, former_front, former_back);\n-\twhile (former_front > former_back)\n+\tdecode2(_M_borders, __former_front, __former_back);\n+\twhile (__former_front > __former_back)\n \t  {\n \t    // Chance.\n-\t    lcas_t former_borders = encode2(former_front, former_back);\n-\t    lcas_t new_borders = encode2(former_front, former_back + 1);\n-\t    if (compare_and_swap(&borders, former_borders, new_borders))\n+\t    _CASable __former_borders = __encode2(__former_front, __former_back);\n+\t    _CASable __new_borders = __encode2(__former_front, __former_back + 1);\n+\t    if (__compare_and_swap(&_M_borders, __former_borders, __new_borders))\n \t      {\n-\t\tt = *(base + former_back % max_size);\n+\t\t__t = *(_M_base + __former_back % _M_max_size);\n \t\treturn true;\n \t      }\n #pragma omp flush\n-\t    decode2(borders, former_front, former_back);\n+\t    decode2(_M_borders, __former_front, __former_back);\n \t  }\n \treturn false;\n       }"}, {"sha": "60f4b23bcd81d67240026772f270aa9afd208d4d", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -38,140 +38,140 @@\n namespace __gnu_parallel\n {\n   /** @brief Unbalanced quicksort divide step.\n-   *  @param begin Begin iterator of subsequence.\n-   *  @param end End iterator of subsequence.\n-   *  @param comp Comparator.\n-   *  @param pivot_rank Desired rank of the pivot.\n-   *  @param num_samples Choose pivot from that many samples.\n-   *  @param num_threads Number of threads that are allowed to work on\n+   *  @param __begin Begin iterator of subsequence.\n+   *  @param __end End iterator of subsequence.\n+   *  @param __comp Comparator.\n+   *  @param __pivot_rank Desired __rank of the pivot.\n+   *  @param __num_samples Choose pivot from that many samples.\n+   *  @param __num_threads Number of threads that are allowed to work on\n    *  this part.\n    */\n-  template<typename RandomAccessIterator, typename Comparator>\n-    typename std::iterator_traits<RandomAccessIterator>::difference_type\n-    parallel_sort_qs_divide(RandomAccessIterator begin,\n-\t\t\t    RandomAccessIterator end,\n-\t\t\t    Comparator comp, typename std::iterator_traits\n-\t\t\t    <RandomAccessIterator>::difference_type pivot_rank,\n+  template<typename _RAIter, typename _Compare>\n+    typename std::iterator_traits<_RAIter>::difference_type\n+    __parallel_sort_qs_divide(_RAIter __begin,\n+\t\t\t    _RAIter __end,\n+\t\t\t    _Compare __comp, typename std::iterator_traits\n+\t\t\t    <_RAIter>::difference_type __pivot_rank,\n \t\t\t    typename std::iterator_traits\n-\t\t\t    <RandomAccessIterator>::difference_type\n-\t\t\t    num_samples, thread_index_t num_threads)\n+\t\t\t    <_RAIter>::difference_type\n+\t\t\t    __num_samples, _ThreadIndex __num_threads)\n     {\n-      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      typedef typename traits_type::difference_type difference_type;\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-      difference_type n = end - begin;\n-      num_samples = std::min(num_samples, n);\n+      _DifferenceType __n = __end - __begin;\n+      __num_samples = std::min(__num_samples, __n);\n \n       // Allocate uninitialized, to avoid default constructor.\n-      value_type* samples =\n-\tstatic_cast<value_type*>(::operator new(num_samples\n-\t\t\t\t\t\t* sizeof(value_type)));\n+      _ValueType* __samples =\n+\tstatic_cast<_ValueType*>(::operator new(__num_samples\n+\t\t\t\t\t\t* sizeof(_ValueType)));\n \n-      for (difference_type s = 0; s < num_samples; ++s)\n+      for (_DifferenceType __s = 0; __s < __num_samples; ++__s)\n \t{\n-\t  const unsigned long long index = static_cast<unsigned long long>(s)\n-\t    * n / num_samples;\n-\t  ::new(&(samples[s])) value_type(begin[index]);\n+\t  const unsigned long long __index = static_cast<unsigned long long>(__s)\n+\t    * __n / __num_samples;\n+\t  ::new(&(__samples[__s])) _ValueType(__begin[__index]);\n \t}\n \n-      __gnu_sequential::sort(samples, samples + num_samples, comp);\n+      __gnu_sequential::sort(__samples, __samples + __num_samples, __comp);\n \n-      value_type& pivot = samples[pivot_rank * num_samples / n];\n+      _ValueType& pivot = __samples[__pivot_rank * __num_samples / __n];\n \n-      __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n-        pred(comp, pivot);\n-      difference_type split =\n-          parallel_partition(begin, end, pred, num_threads);\n+      __gnu_parallel::binder2nd<_Compare, _ValueType, _ValueType, bool>\n+        __pred(__comp, pivot);\n+      _DifferenceType __split =\n+          __parallel_partition(__begin, __end, __pred, __num_threads);\n \n-      ::operator delete(samples);\n+      ::operator delete(__samples);\n \n-      return split;\n+      return __split;\n     }\n \n   /** @brief Unbalanced quicksort conquer step.\n-   *  @param begin Begin iterator of subsequence.\n-   *  @param end End iterator of subsequence.\n-   *  @param comp Comparator.\n-   *  @param num_threads Number of threads that are allowed to work on\n+   *  @param __begin Begin iterator of subsequence.\n+   *  @param __end End iterator of subsequence.\n+   *  @param __comp Comparator.\n+   *  @param __num_threads Number of threads that are allowed to work on\n    *  this part.\n    */\n-  template<typename RandomAccessIterator, typename Comparator>\n+  template<typename _RAIter, typename _Compare>\n     void\n-    parallel_sort_qs_conquer(RandomAccessIterator begin,\n-\t\t\t     RandomAccessIterator end,\n-\t\t\t     Comparator comp,\n-\t\t\t     thread_index_t num_threads)\n+    __parallel_sort_qs_conquer(_RAIter __begin,\n+\t\t\t     _RAIter __end,\n+\t\t\t     _Compare __comp,\n+\t\t\t     _ThreadIndex __num_threads)\n     {\n-      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      typedef typename traits_type::difference_type difference_type;\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-      if (num_threads <= 1)\n+      if (__num_threads <= 1)\n \t{\n-\t  __gnu_sequential::sort(begin, end, comp);\n+\t  __gnu_sequential::sort(__begin, __end, __comp);\n \t  return;\n \t}\n \n-      difference_type n = end - begin, pivot_rank;\n+      _DifferenceType __n = __end - __begin, __pivot_rank;\n \n-      if (n <= 1)\n+      if (__n <= 1)\n \treturn;\n \n-      thread_index_t num_threads_left;\n+      _ThreadIndex __num_threads_left;\n \n-      if ((num_threads % 2) == 1)\n-\tnum_threads_left = num_threads / 2 + 1;\n+      if ((__num_threads % 2) == 1)\n+\t__num_threads_left = __num_threads / 2 + 1;\n       else\n-\tnum_threads_left = num_threads / 2;\n+\t__num_threads_left = __num_threads / 2;\n \n-      pivot_rank = n * num_threads_left / num_threads;\n+      __pivot_rank = __n * __num_threads_left / __num_threads;\n \n-      difference_type split =\n-\tparallel_sort_qs_divide(begin, end, comp, pivot_rank,\n+      _DifferenceType __split =\n+\t__parallel_sort_qs_divide(__begin, __end, __comp, __pivot_rank,\n \t\t\t\t_Settings::get().sort_qs_num_samples_preset,\n-\t\t\t\tnum_threads);\n+\t\t\t\t__num_threads);\n \n #pragma omp parallel sections num_threads(2)\n       {\n #pragma omp section\n-\tparallel_sort_qs_conquer(begin, begin + split,\n-\t\t\t\t comp, num_threads_left);\n+\t__parallel_sort_qs_conquer(__begin, __begin + __split,\n+\t\t\t\t __comp, __num_threads_left);\n #pragma omp section\n-\tparallel_sort_qs_conquer(begin + split, end,\n-\t\t\t\t comp, num_threads - num_threads_left);\n+\t__parallel_sort_qs_conquer(__begin + __split, __end,\n+\t\t\t\t __comp, __num_threads - __num_threads_left);\n       }\n     }\n \n \n \n   /** @brief Unbalanced quicksort main call.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator input sequence, ignored.\n-   *  @param comp Comparator.\n-   *  @param num_threads Number of threads that are allowed to work on\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator input sequence, ignored.\n+   *  @param __comp Comparator.\n+   *  @param __num_threads Number of threads that are allowed to work on\n    *  this part.\n    */\n-  template<typename RandomAccessIterator, typename Comparator>\n+  template<typename _RAIter, typename _Compare>\n     void\n-    parallel_sort_qs(RandomAccessIterator begin,\n-\t\t     RandomAccessIterator end,\n-\t\t     Comparator comp,\n-\t\t     thread_index_t num_threads)\n+    __parallel_sort_qs(_RAIter __begin,\n+\t\t     _RAIter __end,\n+\t\t     _Compare __comp,\n+\t\t     _ThreadIndex __num_threads)\n     {\n-      _GLIBCXX_CALL(n)\n+      _GLIBCXX_CALL(__n)\n \n-      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      typedef typename traits_type::difference_type difference_type;\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n-      difference_type n = end - begin;\n+      _DifferenceType __n = __end - __begin;\n \n       // At least one element per processor.\n-      if (num_threads > n)\n-        num_threads = static_cast<thread_index_t>(n);\n+      if (__num_threads > __n)\n+        __num_threads = static_cast<_ThreadIndex>(__n);\n \n-      parallel_sort_qs_conquer(begin, begin + n, comp, num_threads);\n+      __parallel_sort_qs_conquer(__begin, __begin + __n, __comp, __num_threads);\n     }\n \n } //namespace __gnu_parallel"}, {"sha": "69cbc94cc2230c366a2c1eafca31f0f07ea4e131", "filename": "libstdc++-v3/include/parallel/random_number.h", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -38,84 +38,84 @@\n namespace __gnu_parallel\n {\n   /** @brief Random number generator, based on the Mersenne twister. */\n-  class random_number\n+  class _RandomNumber\n   {\n   private:\n-    std::tr1::mt19937 \tmt;\n-    uint64 \t\tsupremum;\n-    uint64 \t\tRAND_SUP;\n-    double \t\tsupremum_reciprocal;\n-    double \t\tRAND_SUP_REC;\n+    std::tr1::mt19937 \t_M_mt;\n+    uint64 \t\t_M_supremum;\n+    uint64 \t\t_RAND_SUP;\n+    double \t\t_M_supremum_reciprocal;\n+    double \t\t_RAND_SUP_REC;\n \n     // Assumed to be twice as long as the usual random number.\n-    uint64 \t\tcache;  \n+    uint64 \t\t__cache;  \n \n     // Bit results.\n-    int bits_left;\n+    int __bits_left;\n     \n     static uint32\n-    scale_down(uint64 x,\n+    __scale_down(uint64 __x,\n #if _GLIBCXX_SCALE_DOWN_FPU\n-\t       uint64 /*supremum*/, double supremum_reciprocal)\n+\t       uint64 /*_M_supremum*/, double _M_supremum_reciprocal)\n #else\n-               uint64 supremum, double /*supremum_reciprocal*/)\n+               uint64 _M_supremum, double /*_M_supremum_reciprocal*/)\n #endif\n \t{\n #if _GLIBCXX_SCALE_DOWN_FPU\n-\t  return uint32(x * supremum_reciprocal);\n+\t  return uint32(__x * _M_supremum_reciprocal);\n #else\n-\t  return static_cast<uint32>(x % supremum);\n+\t  return static_cast<uint32>(__x % _M_supremum);\n #endif\n \t}\n \n   public:\n     /** @brief Default constructor. Seed with 0. */\n-    random_number()\n-    : mt(0), supremum(0x100000000ULL),\n-      RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n-      supremum_reciprocal(double(supremum) / double(RAND_SUP)),\n-      RAND_SUP_REC(1.0 / double(RAND_SUP)),\n-      cache(0), bits_left(0) { }\n+    _RandomNumber()\n+    : _M_mt(0), _M_supremum(0x100000000ULL),\n+      _RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n+      _M_supremum_reciprocal(double(_M_supremum) / double(_RAND_SUP)),\n+      _RAND_SUP_REC(1.0 / double(_RAND_SUP)),\n+      __cache(0), __bits_left(0) { }\n \n     /** @brief Constructor.\n-     *  @param seed Random seed.\n-     *  @param supremum Generate integer random numbers in the\n-     *                  interval @c [0,supremum). */\n-    random_number(uint32 seed, uint64 supremum = 0x100000000ULL)\n-    : mt(seed), supremum(supremum),\n-      RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n-      supremum_reciprocal(double(supremum) / double(RAND_SUP)),\n-      RAND_SUP_REC(1.0 / double(RAND_SUP)),\n-      cache(0), bits_left(0) { }\n+     *  @param __seed Random __seed.\n+     *  @param _M_supremum Generate integer random numbers in the\n+     *                  interval @__c [0,_M_supremum). */\n+    _RandomNumber(uint32 __seed, uint64 _M_supremum = 0x100000000ULL)\n+    : _M_mt(__seed), _M_supremum(_M_supremum),\n+      _RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n+      _M_supremum_reciprocal(double(_M_supremum) / double(_RAND_SUP)),\n+      _RAND_SUP_REC(1.0 / double(_RAND_SUP)),\n+      __cache(0), __bits_left(0) { }\n \n     /** @brief Generate unsigned random 32-bit integer. */\n     uint32\n     operator()()\n-    { return scale_down(mt(), supremum, supremum_reciprocal); }\n+    { return __scale_down(_M_mt(), _M_supremum, _M_supremum_reciprocal); }\n \n     /** @brief Generate unsigned random 32-bit integer in the\n-\tinterval @c [0,local_supremum). */\n+\tinterval @__c [0,local_supremum). */\n     uint32\n     operator()(uint64 local_supremum)\n     {\n-      return scale_down(mt(), local_supremum,\n-\t\t\tdouble(local_supremum * RAND_SUP_REC));\n+      return __scale_down(_M_mt(), local_supremum,\n+\t\t\tdouble(local_supremum * _RAND_SUP_REC));\n     }\n \n     /** @brief Generate a number of random bits, run-time parameter.\n      *  @param bits Number of bits to generate. */\n     unsigned long\n-    genrand_bits(int bits)\n+    __genrand_bits(int bits)\n     {\n-      unsigned long res = cache & ((1 << bits) - 1);\n-      cache = cache >> bits;\n-      bits_left -= bits;\n-      if (bits_left < 32)\n+      unsigned long __res = __cache & ((1 << bits) - 1);\n+      __cache = __cache >> bits;\n+      __bits_left -= bits;\n+      if (__bits_left < 32)\n \t{\n-\t  cache |= ((uint64(mt())) << bits_left);\n-\t  bits_left += 32;\n+\t  __cache |= ((uint64(_M_mt())) << __bits_left);\n+\t  __bits_left += 32;\n \t}\n-      return res;\n+      return __res;\n     }\n };\n "}, {"sha": "5d6bfcec374e607b90b5a43ad4f5fd017b0009c3", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 261, "deletions": 261, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -41,477 +41,477 @@ namespace __gnu_parallel\n {\n /** @brief Type to hold the index of a bin.\n   *\n-  *  Since many variables of this type are allocated, it should be\n+  *  Since many variables of this _Self are allocated, it should be\n   *  chosen as small as possible.\n   */\n-typedef unsigned short bin_index;\n+typedef unsigned short _BinIndex;\n \n /** @brief Data known to every thread participating in\n-    __gnu_parallel::parallel_random_shuffle(). */\n-template<typename RandomAccessIterator>\n-  struct DRandomShufflingGlobalData\n+    __gnu_parallel::__parallel_random_shuffle(). */\n+template<typename _RAIter>\n+  struct _DRandomShufflingGlobalData\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    /** @brief Begin iterator of the source. */\n-    RandomAccessIterator& source;\n+    /** @brief Begin iterator of the _M_source. */\n+    _RAIter& _M_source;\n \n     /** @brief Temporary arrays for each thread. */\n-    value_type** temporaries;\n+    _ValueType** _M_temporaries;\n \n     /** @brief Two-dimensional array to hold the thread-bin distribution.\n      *\n-     *  Dimensions (num_threads + 1) x (num_bins + 1). */\n-    difference_type** dist;\n+     *  Dimensions (__num_threads + 1) __x (_M_num_bins + 1). */\n+    _DifferenceType** _M_dist;\n \n-    /** @brief Start indexes of the threads' chunks. */\n-    difference_type* starts;\n+    /** @brief Start indexes of the threads' __chunks. */\n+    _DifferenceType* _M_starts;\n \n     /** @brief Number of the thread that will further process the\n \tcorresponding bin. */\n-    thread_index_t* bin_proc;\n+    _ThreadIndex* _M_bin_proc;\n \n     /** @brief Number of bins to distribute to. */\n-    int num_bins;\n+    int _M_num_bins;\n \n     /** @brief Number of bits needed to address the bins. */\n-    int num_bits;\n+    int _M_num_bits;\n \n     /** @brief Constructor. */\n-    DRandomShufflingGlobalData(RandomAccessIterator& _source)\n-    : source(_source) { }\n+    _DRandomShufflingGlobalData(_RAIter& _source)\n+    : _M_source(_source) { }\n   };\n \n /** @brief Local data for a thread participating in\n-    __gnu_parallel::parallel_random_shuffle().\n+    __gnu_parallel::__parallel_random_shuffle().\n   */\n-template<typename RandomAccessIterator, typename RandomNumberGenerator>\n-  struct DRSSorterPU\n+template<typename _RAIter, typename RandomNumberGenerator>\n+  struct _DRSSorterPU\n   {\n     /** @brief Number of threads participating in total. */\n-    int num_threads;\n+    int __num_threads;\n \n-    /** @brief Begin index for bins taken care of by this thread. */\n-    bin_index bins_begin;\n+    /** @brief Begin __index for bins taken care of by this thread. */\n+    _BinIndex _M_bins_begin;\n \n-    /** @brief End index for bins taken care of by this thread. */\n-    bin_index bins_end;\n+    /** @brief End __index for bins taken care of by this thread. */\n+    _BinIndex __bins_end;\n \n-    /** @brief Random seed for this thread. */\n-    uint32 seed;\n+    /** @brief Random _M_seed for this thread. */\n+    uint32 _M_seed;\n \n     /** @brief Pointer to global data. */\n-    DRandomShufflingGlobalData<RandomAccessIterator>* sd;\n+    _DRandomShufflingGlobalData<_RAIter>* _M_sd;\n   };\n \n-/** @brief Generate a random number in @c [0,2^logp).\n-  *  @param logp Logarithm (basis 2) of the upper range bound.\n-  *  @param rng Random number generator to use.\n+/** @brief Generate a random number in @__c [0,2^logp).\n+  *  @param logp Logarithm (basis 2) of the upper range __bound.\n+  *  @param __rng Random number generator to use.\n   */\n template<typename RandomNumberGenerator>\n   inline int\n-  random_number_pow2(int logp, RandomNumberGenerator& rng)\n-  { return rng.genrand_bits(logp); }\n+  __random_number_pow2(int logp, RandomNumberGenerator& __rng)\n+  { return __rng.__genrand_bits(logp); }\n \n /** @brief Random shuffle code executed by each thread.\n-  *  @param pus Array of thread-local data records. */\n-template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+  *  @param __pus Array of thread-local data records. */\n+template<typename _RAIter, typename RandomNumberGenerator>\n   void \n-  parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator,\n-                                 RandomNumberGenerator>* pus)\n+  __parallel_random_shuffle_drs_pu(_DRSSorterPU<_RAIter,\n+                                 RandomNumberGenerator>* __pus)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    thread_index_t iam = omp_get_thread_num();\n-    DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* d = &pus[iam];\n-    DRandomShufflingGlobalData<RandomAccessIterator>* sd = d->sd;\n+    _ThreadIndex __iam = omp_get_thread_num();\n+    _DRSSorterPU<_RAIter, RandomNumberGenerator>* d = &__pus[__iam];\n+    _DRandomShufflingGlobalData<_RAIter>* _M_sd = d->_M_sd;\n \n-    // Indexing: dist[bin][processor]\n-    difference_type length = sd->starts[iam + 1] - sd->starts[iam];\n-    bin_index* oracles = new bin_index[length];\n-    difference_type* dist = new difference_type[sd->num_bins + 1];\n-    bin_index* bin_proc = new bin_index[sd->num_bins];\n-    value_type** temporaries = new value_type*[d->num_threads];\n+    // Indexing: _M_dist[bin][processor]\n+    _DifferenceType __length = _M_sd->_M_starts[__iam + 1] - _M_sd->_M_starts[__iam];\n+    _BinIndex* __oracles = new _BinIndex[__length];\n+    _DifferenceType* _M_dist = new _DifferenceType[_M_sd->_M_num_bins + 1];\n+    _BinIndex* _M_bin_proc = new _BinIndex[_M_sd->_M_num_bins];\n+    _ValueType** _M_temporaries = new _ValueType*[d->__num_threads];\n \n     // Compute oracles and count appearances.\n-    for (bin_index b = 0; b < sd->num_bins + 1; ++b)\n-      dist[b] = 0;\n-    int num_bits = sd->num_bits;\n+    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n+      _M_dist[__b] = 0;\n+    int _M_num_bits = _M_sd->_M_num_bits;\n \n-    random_number rng(d->seed);\n+    _RandomNumber __rng(d->_M_seed);\n \n     // First main loop.\n-    for (difference_type i = 0; i < length; ++i)\n+    for (_DifferenceType __i = 0; __i < __length; ++__i)\n       {\n-        bin_index oracle = random_number_pow2(num_bits, rng);\n-        oracles[i] = oracle;\n+        _BinIndex __oracle = __random_number_pow2(_M_num_bits, __rng);\n+        __oracles[__i] = __oracle;\n \n         // To allow prefix (partial) sum.\n-        ++(dist[oracle + 1]);\n+        ++(_M_dist[__oracle + 1]);\n       }\n \n-    for (bin_index b = 0; b < sd->num_bins + 1; ++b)\n-      sd->dist[b][iam + 1] = dist[b];\n+    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n+      _M_sd->_M_dist[__b][__iam + 1] = _M_dist[__b];\n \n #   pragma omp barrier\n \n #   pragma omp single\n     {\n-      // Sum up bins, sd->dist[s + 1][d->num_threads] now contains the\n-      // total number of items in bin s\n-      for (bin_index s = 0; s < sd->num_bins; ++s)\n-        __gnu_sequential::partial_sum(sd->dist[s + 1],\n-                                      sd->dist[s + 1] + d->num_threads + 1,\n-                                      sd->dist[s + 1]);\n+      // Sum up bins, _M_sd->_M_dist[__s + 1][d->__num_threads] now contains the\n+      // total number of items in bin __s\n+      for (_BinIndex __s = 0; __s < _M_sd->_M_num_bins; ++__s)\n+        __gnu_sequential::partial_sum(_M_sd->_M_dist[__s + 1],\n+                                      _M_sd->_M_dist[__s + 1] + d->__num_threads + 1,\n+                                      _M_sd->_M_dist[__s + 1]);\n     }\n \n #   pragma omp barrier\n \n-    sequence_index_t offset = 0, global_offset = 0;\n-    for (bin_index s = 0; s < d->bins_begin; ++s)\n-      global_offset += sd->dist[s + 1][d->num_threads];\n+    _SequenceIndex __offset = 0, __global_offset = 0;\n+    for (_BinIndex __s = 0; __s < d->_M_bins_begin; ++__s)\n+      __global_offset += _M_sd->_M_dist[__s + 1][d->__num_threads];\n \n #   pragma omp barrier\n \n-    for (bin_index s = d->bins_begin; s < d->bins_end; ++s)\n+    for (_BinIndex __s = d->_M_bins_begin; __s < d->__bins_end; ++__s)\n       {\n-\tfor (int t = 0; t < d->num_threads + 1; ++t)\n-\t  sd->dist[s + 1][t] += offset;\n-\toffset = sd->dist[s + 1][d->num_threads];\n+\tfor (int __t = 0; __t < d->__num_threads + 1; ++__t)\n+\t  _M_sd->_M_dist[__s + 1][__t] += __offset;\n+\t__offset = _M_sd->_M_dist[__s + 1][d->__num_threads];\n       }\n \n-    sd->temporaries[iam] = static_cast<value_type*>(\n-      ::operator new(sizeof(value_type) * offset));\n+    _M_sd->_M_temporaries[__iam] = static_cast<_ValueType*>(\n+      ::operator new(sizeof(_ValueType) * __offset));\n \n #   pragma omp barrier\n \n     // Draw local copies to avoid false sharing.\n-    for (bin_index b = 0; b < sd->num_bins + 1; ++b)\n-      dist[b] = sd->dist[b][iam];\n-    for (bin_index b = 0; b < sd->num_bins; ++b)\n-      bin_proc[b] = sd->bin_proc[b];\n-    for (thread_index_t t = 0; t < d->num_threads; ++t)\n-      temporaries[t] = sd->temporaries[t];\n+    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins + 1; ++__b)\n+      _M_dist[__b] = _M_sd->_M_dist[__b][__iam];\n+    for (_BinIndex __b = 0; __b < _M_sd->_M_num_bins; ++__b)\n+      _M_bin_proc[__b] = _M_sd->_M_bin_proc[__b];\n+    for (_ThreadIndex __t = 0; __t < d->__num_threads; ++__t)\n+      _M_temporaries[__t] = _M_sd->_M_temporaries[__t];\n \n-    RandomAccessIterator source = sd->source;\n-    difference_type start = sd->starts[iam];\n+    _RAIter _M_source = _M_sd->_M_source;\n+    _DifferenceType __start = _M_sd->_M_starts[__iam];\n \n     // Distribute according to oracles, second main loop.\n-    for (difference_type i = 0; i < length; ++i)\n+    for (_DifferenceType __i = 0; __i < __length; ++__i)\n       {\n-        bin_index target_bin = oracles[i];\n-        thread_index_t target_p = bin_proc[target_bin];\n+        _BinIndex target_bin = __oracles[__i];\n+        _ThreadIndex target_p = _M_bin_proc[target_bin];\n \n-        // Last column [d->num_threads] stays unchanged.\n-        ::new(&(temporaries[target_p][dist[target_bin + 1]++]))\n-\t    value_type(*(source + i + start));\n+        // Last column [d->__num_threads] stays unchanged.\n+        ::new(&(_M_temporaries[target_p][_M_dist[target_bin + 1]++]))\n+\t    _ValueType(*(_M_source + __i + __start));\n       }\n \n-    delete[] oracles;\n-    delete[] dist;\n-    delete[] bin_proc;\n-    delete[] temporaries;\n+    delete[] __oracles;\n+    delete[] _M_dist;\n+    delete[] _M_bin_proc;\n+    delete[] _M_temporaries;\n \n #   pragma omp barrier\n \n     // Shuffle bins internally.\n-    for (bin_index b = d->bins_begin; b < d->bins_end; ++b)\n+    for (_BinIndex __b = d->_M_bins_begin; __b < d->__bins_end; ++__b)\n       {\n-        value_type* begin =\n-                    sd->temporaries[iam] +\n-                    ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]),\n-                  * end =\n-                    sd->temporaries[iam] + sd->dist[b + 1][d->num_threads];\n-        sequential_random_shuffle(begin, end, rng);\n-        std::copy(begin, end, sd->source + global_offset +\n-            ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]));\n+        _ValueType* __begin =\n+                    _M_sd->_M_temporaries[__iam] +\n+                    ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->__num_threads]),\n+                  * __end =\n+                    _M_sd->_M_temporaries[__iam] + _M_sd->_M_dist[__b + 1][d->__num_threads];\n+        __sequential_random_shuffle(__begin, __end, __rng);\n+        std::copy(__begin, __end, _M_sd->_M_source + __global_offset +\n+            ((__b == d->_M_bins_begin) ? 0 : _M_sd->_M_dist[__b][d->__num_threads]));\n       }\n \n-    ::operator delete(sd->temporaries[iam]);\n+    ::operator delete(_M_sd->_M_temporaries[__iam]);\n   }\n \n /** @brief Round up to the next greater power of 2.\n-  *  @param x Integer to round up */\n-template<typename T>\n-  T \n-  round_up_to_pow2(T x)\n+  *  @param __x _Integer to round up */\n+template<typename _Tp>\n+  _Tp \n+  __round_up_to_pow2(_Tp __x)\n   {\n-    if (x <= 1)\n+    if (__x <= 1)\n       return 1;\n     else\n-      return (T)1 << (__log2(x - 1) + 1);\n+      return (_Tp)1 << (__log2(__x - 1) + 1);\n   }\n \n /** @brief Main parallel random shuffle step.\n-  *  @param begin Begin iterator of sequence.\n-  *  @param end End iterator of sequence.\n-  *  @param n Length of sequence.\n-  *  @param num_threads Number of threads to use.\n-  *  @param rng Random number generator to use.\n+  *  @param __begin Begin iterator of sequence.\n+  *  @param __end End iterator of sequence.\n+  *  @param __n Length of sequence.\n+  *  @param __num_threads Number of threads to use.\n+  *  @param __rng Random number generator to use.\n   */\n-template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+template<typename _RAIter, typename RandomNumberGenerator>\n   void\n-  parallel_random_shuffle_drs(RandomAccessIterator begin,\n-\t\t\t      RandomAccessIterator end,\n+  __parallel_random_shuffle_drs(_RAIter __begin,\n+\t\t\t      _RAIter __end,\n \t\t\t      typename std::iterator_traits\n-\t\t\t      <RandomAccessIterator>::difference_type n,\n-\t\t\t      thread_index_t num_threads,\n-\t\t\t      RandomNumberGenerator& rng)\n+\t\t\t      <_RAIter>::difference_type __n,\n+\t\t\t      _ThreadIndex __num_threads,\n+\t\t\t      RandomNumberGenerator& __rng)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _GLIBCXX_CALL(n)\n+    _GLIBCXX_CALL(__n)\n \n     const _Settings& __s = _Settings::get();\n \n-    if (num_threads > n)\n-      num_threads = static_cast<thread_index_t>(n);\n+    if (__num_threads > __n)\n+      __num_threads = static_cast<_ThreadIndex>(__n);\n \n-    bin_index num_bins, num_bins_cache;\n+    _BinIndex _M_num_bins, __num_bins_cache;\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n     // Try the L1 cache first.\n \n     // Must fit into L1.\n-    num_bins_cache = std::max<difference_type>(\n-        1, n / (__s.L1_cache_size_lb / sizeof(value_type)));\n-    num_bins_cache = round_up_to_pow2(num_bins_cache);\n+    __num_bins_cache = std::max<_DifferenceType>(\n+        1, __n / (__s.L1_cache_size_lb / sizeof(_ValueType)));\n+    __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n \n     // No more buckets than TLB entries, power of 2\n     // Power of 2 and at least one element per bin, at most the TLB size.\n-    num_bins = std::min<difference_type>(n, num_bins_cache);\n+    _M_num_bins = std::min<_DifferenceType>(__n, __num_bins_cache);\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n     // 2 TLB entries needed per bin.\n-    num_bins = std::min<difference_type>(__s.TLB_size / 2, num_bins);\n+    _M_num_bins = std::min<_DifferenceType>(__s.TLB_size / 2, _M_num_bins);\n #endif\n-    num_bins = round_up_to_pow2(num_bins);\n+    _M_num_bins = __round_up_to_pow2(_M_num_bins);\n \n-    if (num_bins < num_bins_cache)\n+    if (_M_num_bins < __num_bins_cache)\n       {\n #endif\n         // Now try the L2 cache\n         // Must fit into L2\n-        num_bins_cache = static_cast<bin_index>(std::max<difference_type>(\n-            1, n / (__s.L2_cache_size / sizeof(value_type))));\n-        num_bins_cache = round_up_to_pow2(num_bins_cache);\n+        __num_bins_cache = static_cast<_BinIndex>(std::max<_DifferenceType>(\n+            1, __n / (__s.L2_cache_size / sizeof(_ValueType))));\n+        __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n \n         // No more buckets than TLB entries, power of 2.\n-        num_bins = static_cast<bin_index>(\n-            std::min(n, static_cast<difference_type>(num_bins_cache)));\n+        _M_num_bins = static_cast<_BinIndex>(\n+            std::min(__n, static_cast<_DifferenceType>(__num_bins_cache)));\n         // Power of 2 and at least one element per bin, at most the TLB size.\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n         // 2 TLB entries needed per bin.\n-        num_bins = std::min(\n-            static_cast<difference_type>(__s.TLB_size / 2), num_bins);\n+        _M_num_bins = std::min(\n+            static_cast<_DifferenceType>(__s.TLB_size / 2), _M_num_bins);\n #endif\n-          num_bins = round_up_to_pow2(num_bins);\n+          _M_num_bins = __round_up_to_pow2(_M_num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n       }\n #endif\n \n-    num_threads = std::min<bin_index>(num_threads, num_bins);\n+    __num_threads = std::min<_BinIndex>(__num_threads, _M_num_bins);\n \n-    if (num_threads <= 1)\n-      return sequential_random_shuffle(begin, end, rng);\n+    if (__num_threads <= 1)\n+      return __sequential_random_shuffle(__begin, __end, __rng);\n \n-    DRandomShufflingGlobalData<RandomAccessIterator> sd(begin);\n-    DRSSorterPU<RandomAccessIterator, random_number >* pus;\n-    difference_type* starts;\n+    _DRandomShufflingGlobalData<_RAIter> _M_sd(__begin);\n+    _DRSSorterPU<_RAIter, _RandomNumber >* __pus;\n+    _DifferenceType* _M_starts;\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n-        thread_index_t num_threads = omp_get_num_threads();\n+        _ThreadIndex __num_threads = omp_get_num_threads();\n #       pragma omp single\n           {\n-            pus = new DRSSorterPU<RandomAccessIterator, random_number>\n-                [num_threads];\n-\n-            sd.temporaries = new value_type*[num_threads];\n-            sd.dist = new difference_type*[num_bins + 1];\n-            sd.bin_proc = new thread_index_t[num_bins];\n-            for (bin_index b = 0; b < num_bins + 1; ++b)\n-              sd.dist[b] = new difference_type[num_threads + 1];\n-            for (bin_index b = 0; b < (num_bins + 1); ++b)\n+            __pus = new _DRSSorterPU<_RAIter, _RandomNumber>\n+                [__num_threads];\n+\n+            _M_sd._M_temporaries = new _ValueType*[__num_threads];\n+            _M_sd._M_dist = new _DifferenceType*[_M_num_bins + 1];\n+            _M_sd._M_bin_proc = new _ThreadIndex[_M_num_bins];\n+            for (_BinIndex __b = 0; __b < _M_num_bins + 1; ++__b)\n+              _M_sd._M_dist[__b] = new _DifferenceType[__num_threads + 1];\n+            for (_BinIndex __b = 0; __b < (_M_num_bins + 1); ++__b)\n               {\n-                sd.dist[0][0] = 0;\n-                sd.dist[b][0] = 0;\n+                _M_sd._M_dist[0][0] = 0;\n+                _M_sd._M_dist[__b][0] = 0;\n               }\n-            starts = sd.starts = new difference_type[num_threads + 1];\n+            _M_starts = _M_sd._M_starts = new _DifferenceType[__num_threads + 1];\n             int bin_cursor = 0;\n-            sd.num_bins = num_bins;\n-            sd.num_bits = __log2(num_bins);\n-\n-            difference_type chunk_length = n / num_threads,\n-                            split = n % num_threads, start = 0;\n-            difference_type bin_chunk_length = num_bins / num_threads,\n-                            bin_split = num_bins % num_threads;\n-            for (thread_index_t i = 0; i < num_threads; ++i)\n+            _M_sd._M_num_bins = _M_num_bins;\n+            _M_sd._M_num_bits = __log2(_M_num_bins);\n+\n+            _DifferenceType __chunk_length = __n / __num_threads,\n+                            __split = __n % __num_threads, __start = 0;\n+            _DifferenceType bin_chunk_length = _M_num_bins / __num_threads,\n+                            bin_split = _M_num_bins % __num_threads;\n+            for (_ThreadIndex __i = 0; __i < __num_threads; ++__i)\n               {\n-                starts[i] = start;\n-                start += (i < split) ? (chunk_length + 1) : chunk_length;\n-                int j = pus[i].bins_begin = bin_cursor;\n+                _M_starts[__i] = __start;\n+                __start += (__i < __split) ? (__chunk_length + 1) : __chunk_length;\n+                int __j = __pus[__i]._M_bins_begin = bin_cursor;\n \n                 // Range of bins for this processor.\n-                bin_cursor += (i < bin_split) ?\n+                bin_cursor += (__i < bin_split) ?\n                     (bin_chunk_length + 1) : bin_chunk_length;\n-                pus[i].bins_end = bin_cursor;\n-                for (; j < bin_cursor; ++j)\n-                  sd.bin_proc[j] = i;\n-                pus[i].num_threads = num_threads;\n-                pus[i].seed = rng(std::numeric_limits<uint32>::max());\n-                pus[i].sd = &sd;\n+                __pus[__i].__bins_end = bin_cursor;\n+                for (; __j < bin_cursor; ++__j)\n+                  _M_sd._M_bin_proc[__j] = __i;\n+                __pus[__i].__num_threads = __num_threads;\n+                __pus[__i]._M_seed = __rng(std::numeric_limits<uint32>::max());\n+                __pus[__i]._M_sd = &_M_sd;\n               }\n-            starts[num_threads] = start;\n+            _M_starts[__num_threads] = __start;\n           } //single\n         // Now shuffle in parallel.\n-        parallel_random_shuffle_drs_pu(pus);\n+        __parallel_random_shuffle_drs_pu(__pus);\n       }  // parallel\n \n-    delete[] starts;\n-    delete[] sd.bin_proc;\n-    for (int s = 0; s < (num_bins + 1); ++s)\n-      delete[] sd.dist[s];\n-    delete[] sd.dist;\n-    delete[] sd.temporaries;\n+    delete[] _M_starts;\n+    delete[] _M_sd._M_bin_proc;\n+    for (int __s = 0; __s < (_M_num_bins + 1); ++__s)\n+      delete[] _M_sd._M_dist[__s];\n+    delete[] _M_sd._M_dist;\n+    delete[] _M_sd._M_temporaries;\n \n-    delete[] pus;\n+    delete[] __pus;\n   }\n \n-/** @brief Sequential cache-efficient random shuffle.\n- *  @param begin Begin iterator of sequence.\n- *  @param end End iterator of sequence.\n- *  @param rng Random number generator to use.\n+/** @brief Sequential __cache-efficient random shuffle.\n+ *  @param __begin Begin iterator of sequence.\n+ *  @param __end End iterator of sequence.\n+ *  @param __rng Random number generator to use.\n  */\n-template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+template<typename _RAIter, typename RandomNumberGenerator>\n   void\n-  sequential_random_shuffle(RandomAccessIterator begin, \n-                            RandomAccessIterator end,\n-                            RandomNumberGenerator& rng)\n+  __sequential_random_shuffle(_RAIter __begin, \n+                            _RAIter __end,\n+                            RandomNumberGenerator& __rng)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    difference_type n = end - begin;\n+    _DifferenceType __n = __end - __begin;\n     const _Settings& __s = _Settings::get();\n \n-    bin_index num_bins, num_bins_cache;\n+    _BinIndex _M_num_bins, __num_bins_cache;\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n     // Try the L1 cache first, must fit into L1.\n-    num_bins_cache =\n-        std::max<difference_type>\n-            (1, n / (__s.L1_cache_size_lb / sizeof(value_type)));\n-    num_bins_cache = round_up_to_pow2(num_bins_cache);\n+    __num_bins_cache =\n+        std::max<_DifferenceType>\n+            (1, __n / (__s.L1_cache_size_lb / sizeof(_ValueType)));\n+    __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n \n     // No more buckets than TLB entries, power of 2\n     // Power of 2 and at least one element per bin, at most the TLB size\n-    num_bins = std::min(n, (difference_type)num_bins_cache);\n+    _M_num_bins = std::min(__n, (_DifferenceType)__num_bins_cache);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n     // 2 TLB entries needed per bin\n-    num_bins = std::min((difference_type)__s.TLB_size / 2, num_bins);\n+    _M_num_bins = std::min((_DifferenceType)__s.TLB_size / 2, _M_num_bins);\n #endif\n-    num_bins = round_up_to_pow2(num_bins);\n+    _M_num_bins = __round_up_to_pow2(_M_num_bins);\n \n-    if (num_bins < num_bins_cache)\n+    if (_M_num_bins < __num_bins_cache)\n       {\n #endif\n         // Now try the L2 cache, must fit into L2.\n-        num_bins_cache =\n-            static_cast<bin_index>(std::max<difference_type>(\n-                1, n / (__s.L2_cache_size / sizeof(value_type))));\n-        num_bins_cache = round_up_to_pow2(num_bins_cache);\n+        __num_bins_cache =\n+            static_cast<_BinIndex>(std::max<_DifferenceType>(\n+                1, __n / (__s.L2_cache_size / sizeof(_ValueType))));\n+        __num_bins_cache = __round_up_to_pow2(__num_bins_cache);\n \n         // No more buckets than TLB entries, power of 2\n         // Power of 2 and at least one element per bin, at most the TLB size.\n-        num_bins = static_cast<bin_index>\n-            (std::min(n, static_cast<difference_type>(num_bins_cache)));\n+        _M_num_bins = static_cast<_BinIndex>\n+            (std::min(__n, static_cast<_DifferenceType>(__num_bins_cache)));\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n         // 2 TLB entries needed per bin\n-        num_bins =\n-            std::min<difference_type>(__s.TLB_size / 2, num_bins);\n+        _M_num_bins =\n+            std::min<_DifferenceType>(__s.TLB_size / 2, _M_num_bins);\n #endif\n-        num_bins = round_up_to_pow2(num_bins);\n+        _M_num_bins = __round_up_to_pow2(_M_num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n       }\n #endif\n \n-    int num_bits = __log2(num_bins);\n+    int _M_num_bits = __log2(_M_num_bins);\n \n-    if (num_bins > 1)\n+    if (_M_num_bins > 1)\n       {\n-        value_type* target = static_cast<value_type*>(\n-          ::operator new(sizeof(value_type) * n));\n-        bin_index* oracles = new bin_index[n];\n-        difference_type* dist0 = new difference_type[num_bins + 1],\n-                       * dist1 = new difference_type[num_bins + 1];\n+        _ValueType* __target = static_cast<_ValueType*>(\n+          ::operator new(sizeof(_ValueType) * __n));\n+        _BinIndex* __oracles = new _BinIndex[__n];\n+        _DifferenceType* __dist0 = new _DifferenceType[_M_num_bins + 1],\n+                       * __dist1 = new _DifferenceType[_M_num_bins + 1];\n \n-        for (int b = 0; b < num_bins + 1; ++b)\n-          dist0[b] = 0;\n+        for (int __b = 0; __b < _M_num_bins + 1; ++__b)\n+          __dist0[__b] = 0;\n \n-        random_number bitrng(rng(0xFFFFFFFF));\n+        _RandomNumber bitrng(__rng(0xFFFFFFFF));\n \n-        for (difference_type i = 0; i < n; ++i)\n+        for (_DifferenceType __i = 0; __i < __n; ++__i)\n           {\n-            bin_index oracle = random_number_pow2(num_bits, bitrng);\n-            oracles[i] = oracle;\n+            _BinIndex __oracle = __random_number_pow2(_M_num_bits, bitrng);\n+            __oracles[__i] = __oracle;\n \n             // To allow prefix (partial) sum.\n-            ++(dist0[oracle + 1]);\n+            ++(__dist0[__oracle + 1]);\n           }\n \n         // Sum up bins.\n-        __gnu_sequential::partial_sum(dist0, dist0 + num_bins + 1, dist0);\n+        __gnu_sequential::partial_sum(__dist0, __dist0 + _M_num_bins + 1, __dist0);\n \n-        for (int b = 0; b < num_bins + 1; ++b)\n-          dist1[b] = dist0[b];\n+        for (int __b = 0; __b < _M_num_bins + 1; ++__b)\n+          __dist1[__b] = __dist0[__b];\n \n         // Distribute according to oracles.\n-        for (difference_type i = 0; i < n; ++i)\n-          ::new(&(target[(dist0[oracles[i]])++])) value_type(*(begin + i));\n+        for (_DifferenceType __i = 0; __i < __n; ++__i)\n+          ::new(&(__target[(__dist0[__oracles[__i]])++])) _ValueType(*(__begin + __i));\n \n-        for (int b = 0; b < num_bins; ++b)\n+        for (int __b = 0; __b < _M_num_bins; ++__b)\n           {\n-            sequential_random_shuffle(target + dist1[b],\n-                                      target + dist1[b + 1],\n-                                      rng);\n+            __sequential_random_shuffle(__target + __dist1[__b],\n+                                      __target + __dist1[__b + 1],\n+                                      __rng);\n           }\n \n         // Copy elements back.\n-        std::copy(target, target + n, begin);\n+        std::copy(__target, __target + __n, __begin);\n \n-        delete[] dist0;\n-        delete[] dist1;\n-        delete[] oracles;\n-        ::operator delete(target);\n+        delete[] __dist0;\n+        delete[] __dist1;\n+        delete[] __oracles;\n+        ::operator delete(__target);\n       }\n     else\n-      __gnu_sequential::random_shuffle(begin, end, rng);\n+      __gnu_sequential::random_shuffle(__begin, __end, __rng);\n   }\n \n /** @brief Parallel random public call.\n- *  @param begin Begin iterator of sequence.\n- *  @param end End iterator of sequence.\n- *  @param rng Random number generator to use.\n+ *  @param __begin Begin iterator of sequence.\n+ *  @param __end End iterator of sequence.\n+ *  @param __rng Random number generator to use.\n  */\n-template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+template<typename _RAIter, typename RandomNumberGenerator>\n   inline void\n-  parallel_random_shuffle(RandomAccessIterator begin,\n-                          RandomAccessIterator end,\n-                          RandomNumberGenerator rng = random_number())\n+  __parallel_random_shuffle(_RAIter __begin,\n+                          _RAIter __end,\n+                          RandomNumberGenerator __rng = _RandomNumber())\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    difference_type n = end - begin;\n-    parallel_random_shuffle_drs(begin, end, n, get_max_threads(), rng) ;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    _DifferenceType __n = __end - __begin;\n+    __parallel_random_shuffle_drs(__begin, __end, __n, __get_max_threads(), __rng) ;\n   }\n \n }"}, {"sha": "b0a9f6918bf8bb56622dd8ac4745757db0cdcc34", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file parallel/search.h\n- *  @brief Parallel implementation base for std::search() and\n+ *  @brief Parallel implementation __base for std::search() and\n  *  std::search_n().\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  */\n@@ -42,130 +42,130 @@\n namespace __gnu_parallel\n {\n   /**\n-   *  @brief Precalculate advances for Knuth-Morris-Pratt algorithm.\n-   *  @param elements Begin iterator of sequence to search for.\n-   *  @param length Length of sequence to search for.\n-   *  @param advances Returned offsets. \n+   *  @brief Precalculate __advances for Knuth-Morris-Pratt algorithm.\n+   *  @param __elements Begin iterator of sequence to search for.\n+   *  @param __length Length of sequence to search for.\n+   *  @param __advances Returned __offsets. \n    */\n-template<typename RandomAccessIterator, typename _DifferenceTp>\n+template<typename _RAIter, typename _DifferenceTp>\n   void\n-  calc_borders(RandomAccessIterator elements, _DifferenceTp length, \n-              _DifferenceTp* off)\n+  __calc_borders(_RAIter __elements, _DifferenceTp __length, \n+              _DifferenceTp* __off)\n   {\n-    typedef _DifferenceTp difference_type;\n+    typedef _DifferenceTp _DifferenceType;\n \n-    off[0] = -1;\n-    if (length > 1)\n-      off[1] = 0;\n-    difference_type k = 0;\n-    for (difference_type j = 2; j <= length; j++)\n+    __off[0] = -1;\n+    if (__length > 1)\n+      __off[1] = 0;\n+    _DifferenceType __k = 0;\n+    for (_DifferenceType __j = 2; __j <= __length; __j++)\n       {\n-        while ((k >= 0) && !(elements[k] == elements[j-1]))\n-          k = off[k];\n-        off[j] = ++k;\n+        while ((__k >= 0) && !(__elements[__k] == __elements[__j-1]))\n+          __k = __off[__k];\n+        __off[__j] = ++__k;\n       }\n   }\n \n   // Generic parallel find algorithm (requires random access iterator).\n \n   /** @brief Parallel std::search.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence.\n-   *  @param end2 End iterator of second sequence.\n-   *  @param pred Find predicate.\n+   *  @param __begin1 Begin iterator of first sequence.\n+   *  @param __end1 End iterator of first sequence.\n+   *  @param __begin2 Begin iterator of second sequence.\n+   *  @param __end2 End iterator of second sequence.\n+   *  @param __pred Find predicate.\n    *  @return Place of finding in first sequences. */\n-template<typename _RandomAccessIterator1,\n-\t typename _RandomAccessIterator2,\n-\t typename Pred>\n-  _RandomAccessIterator1\n-  search_template(_RandomAccessIterator1 begin1, _RandomAccessIterator1 end1,\n-                  _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2,\n-                  Pred pred)\n+template<typename __RAIter1,\n+\t typename __RAIter2,\n+\t typename _Pred>\n+  __RAIter1\n+  __search_template(__RAIter1 __begin1, __RAIter1 __end1,\n+                  __RAIter2 __begin2, __RAIter2 __end2,\n+                  _Pred __pred)\n   {\n-    typedef std::iterator_traits<_RandomAccessIterator1> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<__RAIter1> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    _GLIBCXX_CALL((end1 - begin1) + (end2 - begin2));\n+    _GLIBCXX_CALL((__end1 - __begin1) + (__end2 - __begin2));\n \n-    difference_type pattern_length = end2 - begin2;\n+    _DifferenceType __pattern_length = __end2 - __begin2;\n \n     // Pattern too short.\n-    if(pattern_length <= 0)\n-      return end1;\n+    if(__pattern_length <= 0)\n+      return __end1;\n \n     // Last point to start search.\n-    difference_type input_length = (end1 - begin1) - pattern_length;\n+    _DifferenceType __input_length = (__end1 - __begin1) - __pattern_length;\n \n     // Where is first occurrence of pattern? defaults to end.\n-    difference_type result = (end1 - begin1);\n-    difference_type *splitters;\n+    _DifferenceType __result = (__end1 - __begin1);\n+    _DifferenceType *__splitters;\n \n     // Pattern too long.\n-    if (input_length < 0)\n-      return end1;\n+    if (__input_length < 0)\n+      return __end1;\n \n-    omp_lock_t result_lock;\n-    omp_init_lock(&result_lock);\n+    omp_lock_t __result_lock;\n+    omp_init_lock(&__result_lock);\n \n-    thread_index_t num_threads =\n-        std::max<difference_type>(1,\n-            std::min<difference_type>(input_length, get_max_threads()));\n+    _ThreadIndex __num_threads =\n+        std::max<_DifferenceType>(1,\n+            std::min<_DifferenceType>(__input_length, __get_max_threads()));\n \n-    difference_type advances[pattern_length];\n-    calc_borders(begin2, pattern_length, advances);\n+    _DifferenceType __advances[__pattern_length];\n+    __calc_borders(__begin2, __pattern_length, __advances);\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-            splitters = new difference_type[num_threads + 1];\n-            equally_split(input_length, num_threads, splitters);\n+            __num_threads = omp_get_num_threads();\n+            __splitters = new _DifferenceType[__num_threads + 1];\n+            equally_split(__input_length, __num_threads, __splitters);\n           }\n \n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n-        difference_type start = splitters[iam], stop = splitters[iam + 1];\n+        _DifferenceType __start = __splitters[__iam], __stop = __splitters[__iam + 1];\n \n-        difference_type pos_in_pattern = 0;\n-        bool found_pattern = false;\n+        _DifferenceType __pos_in_pattern = 0;\n+        bool __found_pattern = false;\n \n-        while (start <= stop && !found_pattern)\n+        while (__start <= __stop && !__found_pattern)\n           {\n             // Get new value of result.\n-            #pragma omp flush(result)\n+            #pragma omp flush(__result)\n             // No chance for this thread to find first occurrence.\n-            if (result < start)\n+            if (__result < __start)\n               break;\n-            while (pred(begin1[start + pos_in_pattern],\n-                         begin2[pos_in_pattern]))\n+            while (__pred(__begin1[__start + __pos_in_pattern],\n+                         __begin2[__pos_in_pattern]))\n               {\n-                ++pos_in_pattern;\n-                if (pos_in_pattern == pattern_length)\n+                ++__pos_in_pattern;\n+                if (__pos_in_pattern == __pattern_length)\n                   {\n                     // Found new candidate for result.\n-                            omp_set_lock(&result_lock);\n-                    result = std::min(result, start);\n-                            omp_unset_lock(&result_lock);\n+                            omp_set_lock(&__result_lock);\n+                    __result = std::min(__result, __start);\n+                            omp_unset_lock(&__result_lock);\n \n-                    found_pattern = true;\n+                    __found_pattern = true;\n                     break;\n                   }\n               }\n             // Make safe jump.\n-            start += (pos_in_pattern - advances[pos_in_pattern]);\n-            pos_in_pattern =\n-                (advances[pos_in_pattern] < 0) ? 0 : advances[pos_in_pattern];\n+            __start += (__pos_in_pattern - __advances[__pos_in_pattern]);\n+            __pos_in_pattern =\n+                (__advances[__pos_in_pattern] < 0) ? 0 : __advances[__pos_in_pattern];\n           }\n       } //parallel\n \n-    omp_destroy_lock(&result_lock);\n+    omp_destroy_lock(&__result_lock);\n \n-    delete[] splitters;\n+    delete[] __splitters;\n \n     // Return iterator on found element.\n-    return (begin1 + result);\n+    return (__begin1 + __result);\n   }\n } // end namespace\n "}, {"sha": "a726d309ce441a14276887a91307098a3d2a4943", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 278, "deletions": 278, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -41,482 +41,482 @@\n \n namespace __gnu_parallel\n {\n-template<typename InputIterator, typename OutputIterator>\n-  OutputIterator\n-  copy_tail(std::pair<InputIterator, InputIterator> b,\n-            std::pair<InputIterator, InputIterator> e, OutputIterator r)\n+template<typename _IIter, typename _OutputIterator>\n+  _OutputIterator\n+  copy_tail(std::pair<_IIter, _IIter> __b,\n+            std::pair<_IIter, _IIter> __e, _OutputIterator __r)\n   {\n-    if (b.first != e.first)\n+    if (__b.first != __e.first)\n       {\n         do\n           {\n-            *r++ = *b.first++;\n+            *__r++ = *__b.first++;\n           }\n-        while (b.first != e.first);\n+        while (__b.first != __e.first);\n       }\n     else\n       {\n-        while (b.second != e.second)\n-          *r++ = *b.second++;\n+        while (__b.second != __e.second)\n+          *__r++ = *__b.second++;\n       }\n-    return r;\n+    return __r;\n   }\n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n   struct symmetric_difference_func\n   {\n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    symmetric_difference_func(Comparator c) : comp(c) {}\n+    symmetric_difference_func(_Compare __c) : __comp(__c) {}\n \n-    Comparator comp;\n+    _Compare __comp;\n \n-    OutputIterator\n-    invoke(InputIterator a, InputIterator b,\n-\t   InputIterator c, InputIterator d,\n-\t   OutputIterator r) const\n+    _OutputIterator\n+    _M_invoke(_IIter __a, _IIter __b,\n+\t   _IIter __c, _IIter d,\n+\t   _OutputIterator __r) const\n     {\n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n+          if (__comp(*__a, *__c))\n             {\n-              *r = *a;\n-              ++a;\n-              ++r;\n+              *__r = *__a;\n+              ++__a;\n+              ++__r;\n             }\n-          else if (comp(*c, *a))\n+          else if (__comp(*__c, *__a))\n             {\n-              *r = *c;\n-              ++c;\n-              ++r;\n+              *__r = *__c;\n+              ++__c;\n+              ++__r;\n             }\n           else\n             {\n-              ++a;\n-              ++c;\n+              ++__a;\n+              ++__c;\n             }\n         }\n-      return std::copy(c, d, std::copy(a, b, r));\n+      return std::copy(__c, d, std::copy(__a, __b, __r));\n     }\n \n-    difference_type\n-    count(InputIterator a, InputIterator b,\n-\t  InputIterator c, InputIterator d) const\n+    _DifferenceType\n+    __count(_IIter __a, _IIter __b,\n+\t  _IIter __c, _IIter d) const\n     {\n-      difference_type counter = 0;\n+      _DifferenceType __counter = 0;\n \n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n+          if (__comp(*__a, *__c))\n             {\n-              ++a;\n-              ++counter;\n+              ++__a;\n+              ++__counter;\n             }\n-          else if (comp(*c, *a))\n+          else if (__comp(*__c, *__a))\n             {\n-              ++c;\n-              ++counter;\n+              ++__c;\n+              ++__counter;\n             }\n           else\n             {\n-              ++a;\n-              ++c;\n+              ++__a;\n+              ++__c;\n             }\n         }\n \n-      return counter + (b - a) + (d - c);\n+      return __counter + (__b - __a) + (d - __c);\n     }\n \n-    OutputIterator\n-    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n-    { return std::copy(c, d, out); }\n+    _OutputIterator\n+    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n+    { return std::copy(__c, d, __out); }\n \n-    OutputIterator\n-    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n-    { return std::copy(a, b, out); }\n+    _OutputIterator\n+    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+    { return std::copy(__a, __b, __out); }\n   };\n \n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n-  struct difference_func\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n+  struct __difference_func\n   {\n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    difference_func(Comparator c) : comp(c) {}\n+    __difference_func(_Compare __c) : __comp(__c) {}\n \n-    Comparator comp;\n+    _Compare __comp;\n \n-    OutputIterator\n-    invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n-          OutputIterator r) const\n+    _OutputIterator\n+    _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n+          _OutputIterator __r) const\n     {\n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n+          if (__comp(*__a, *__c))\n             {\n-              *r = *a;\n-              ++a;\n-              ++r;\n+              *__r = *__a;\n+              ++__a;\n+              ++__r;\n             }\n-          else if (comp(*c, *a))\n-            { ++c; }\n+          else if (__comp(*__c, *__a))\n+            { ++__c; }\n           else\n             {\n-              ++a;\n-              ++c;\n+              ++__a;\n+              ++__c;\n             }\n         }\n-      return std::copy(a, b, r);\n+      return std::copy(__a, __b, __r);\n     }\n \n-    difference_type\n-    count(InputIterator a, InputIterator b,\n-\t  InputIterator c, InputIterator d) const\n+    _DifferenceType\n+    __count(_IIter __a, _IIter __b,\n+\t  _IIter __c, _IIter d) const\n     {\n-      difference_type counter = 0;\n+      _DifferenceType __counter = 0;\n \n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n+          if (__comp(*__a, *__c))\n             {\n-              ++a;\n-              ++counter;\n+              ++__a;\n+              ++__counter;\n             }\n-          else if (comp(*c, *a))\n-            { ++c; }\n+          else if (__comp(*__c, *__a))\n+            { ++__c; }\n           else\n-            { ++a; ++c; }\n+            { ++__a; ++__c; }\n         }\n \n-      return counter + (b - a);\n+      return __counter + (__b - __a);\n     }\n \n-    inline OutputIterator\n-    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n-    { return out; }\n+    inline _OutputIterator\n+    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n+    { return __out; }\n \n-    inline OutputIterator\n-    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n-    { return std::copy(a, b, out); }\n+    inline _OutputIterator\n+    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+    { return std::copy(__a, __b, __out); }\n   };\n \n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n-  struct intersection_func\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n+  struct __intersection_func\n   {\n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    intersection_func(Comparator c) : comp(c) {}\n+    __intersection_func(_Compare __c) : __comp(__c) {}\n \n-    Comparator comp;\n+    _Compare __comp;\n \n-    OutputIterator\n-    invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n-          OutputIterator r) const\n+    _OutputIterator\n+    _M_invoke(_IIter __a, _IIter __b, _IIter __c, _IIter d,\n+          _OutputIterator __r) const\n     {\n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n-            { ++a; }\n-          else if (comp(*c, *a))\n-            { ++c; }\n+          if (__comp(*__a, *__c))\n+            { ++__a; }\n+          else if (__comp(*__c, *__a))\n+            { ++__c; }\n           else\n             {\n-              *r = *a;\n-              ++a;\n-              ++c;\n-              ++r;\n+              *__r = *__a;\n+              ++__a;\n+              ++__c;\n+              ++__r;\n             }\n         }\n \n-      return r;\n+      return __r;\n     }\n \n-    difference_type\n-    count(InputIterator a, InputIterator b,\n-\t  InputIterator c, InputIterator d) const\n+    _DifferenceType\n+    __count(_IIter __a, _IIter __b,\n+\t  _IIter __c, _IIter d) const\n     {\n-      difference_type counter = 0;\n+      _DifferenceType __counter = 0;\n \n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n-            { ++a; }\n-          else if (comp(*c, *a))\n-            { ++c; }\n+          if (__comp(*__a, *__c))\n+            { ++__a; }\n+          else if (__comp(*__c, *__a))\n+            { ++__c; }\n           else\n             {\n-              ++a;\n-              ++c;\n-              ++counter;\n+              ++__a;\n+              ++__c;\n+              ++__counter;\n             }\n         }\n \n-      return counter;\n+      return __counter;\n     }\n \n-    inline OutputIterator\n-    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n-    { return out; }\n+    inline _OutputIterator\n+    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n+    { return __out; }\n \n-    inline OutputIterator\n-    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n-    { return out; }\n+    inline _OutputIterator\n+    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+    { return __out; }\n   };\n \n-template<class InputIterator, class OutputIterator, class Comparator>\n-  struct union_func\n+template<class _IIter, class _OutputIterator, class _Compare>\n+  struct __union_func\n   {\n-    typedef typename std::iterator_traits<InputIterator>::difference_type\n-    difference_type;\n+    typedef typename std::iterator_traits<_IIter>::difference_type\n+    _DifferenceType;\n \n-    union_func(Comparator c) : comp(c) {}\n+    __union_func(_Compare __c) : __comp(__c) {}\n \n-    Comparator comp;\n+    _Compare __comp;\n \n-    OutputIterator\n-    invoke(InputIterator a, const InputIterator b, InputIterator c,\n-          const InputIterator d, OutputIterator r) const\n+    _OutputIterator\n+    _M_invoke(_IIter __a, const _IIter __b, _IIter __c,\n+          const _IIter d, _OutputIterator __r) const\n     {\n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n+          if (__comp(*__a, *__c))\n             {\n-              *r = *a;\n-              ++a;\n+              *__r = *__a;\n+              ++__a;\n             }\n-          else if (comp(*c, *a))\n+          else if (__comp(*__c, *__a))\n             {\n-              *r = *c;\n-              ++c;\n+              *__r = *__c;\n+              ++__c;\n             }\n           else\n             {\n-              *r = *a;\n-              ++a;\n-              ++c;\n+              *__r = *__a;\n+              ++__a;\n+              ++__c;\n             }\n-          ++r;\n+          ++__r;\n         }\n-      return std::copy(c, d, std::copy(a, b, r));\n+      return std::copy(__c, d, std::copy(__a, __b, __r));\n     }\n \n-    difference_type\n-    count(InputIterator a, InputIterator b,\n-\t  InputIterator c, InputIterator d) const\n+    _DifferenceType\n+    __count(_IIter __a, _IIter __b,\n+\t  _IIter __c, _IIter d) const\n     {\n-      difference_type counter = 0;\n+      _DifferenceType __counter = 0;\n \n-      while (a != b && c != d)\n+      while (__a != __b && __c != d)\n         {\n-          if (comp(*a, *c))\n-            { ++a; }\n-          else if (comp(*c, *a))\n-            { ++c; }\n+          if (__comp(*__a, *__c))\n+            { ++__a; }\n+          else if (__comp(*__c, *__a))\n+            { ++__c; }\n           else\n             {\n-              ++a;\n-              ++c;\n+              ++__a;\n+              ++__c;\n             }\n-          ++counter;\n+          ++__counter;\n         }\n \n-      counter += (b - a);\n-      counter += (d - c);\n-      return counter;\n+      __counter += (__b - __a);\n+      __counter += (d - __c);\n+      return __counter;\n     }\n \n-    inline OutputIterator\n-    first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n-    { return std::copy(c, d, out); }\n+    inline _OutputIterator\n+    __first_empty(_IIter __c, _IIter d, _OutputIterator __out) const\n+    { return std::copy(__c, d, __out); }\n \n-    inline OutputIterator\n-    second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n-    { return std::copy(a, b, out); }\n+    inline _OutputIterator\n+    __second_empty(_IIter __a, _IIter __b, _OutputIterator __out) const\n+    { return std::copy(__a, __b, __out); }\n   };\n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n+template<typename _IIter,\n+\t typename _OutputIterator,\n \t typename Operation>\n-  OutputIterator\n-  parallel_set_operation(InputIterator begin1, InputIterator end1,\n-                         InputIterator begin2, InputIterator end2,\n-                         OutputIterator result, Operation op)\n+  _OutputIterator\n+  __parallel_set_operation(_IIter __begin1, _IIter __end1,\n+                         _IIter __begin2, _IIter __end2,\n+                         _OutputIterator __result, Operation __op)\n   {\n-    _GLIBCXX_CALL((end1 - begin1) + (end2 - begin2))\n+    _GLIBCXX_CALL((__end1 - __begin1) + (__end2 - __begin2))\n \n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n-    typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n+    typedef typename std::pair<_IIter, _IIter> _IteratorPair;\n \n-    if (begin1 == end1)\n-      return op.first_empty(begin2, end2, result);\n+    if (__begin1 == __end1)\n+      return __op.__first_empty(__begin2, __end2, __result);\n \n-    if (begin2 == end2)\n-      return op.second_empty(begin1, end1, result);\n+    if (__begin2 == __end2)\n+      return __op.__second_empty(__begin1, __end1, __result);\n \n-    const difference_type size = (end1 - begin1) + (end2 - begin2);\n+    const _DifferenceType size = (__end1 - __begin1) + (__end2 - __begin2);\n \n-    const iterator_pair sequence[ 2 ] =\n-        { std::make_pair(begin1, end1), std::make_pair(begin2, end2) } ;\n-    OutputIterator return_value = result;\n-    difference_type *borders;\n-    iterator_pair *block_begins;\n-    difference_type* lengths;\n+    const _IteratorPair __sequence[ 2 ] =\n+        { std::make_pair(__begin1, __end1), std::make_pair(__begin2, __end2) } ;\n+    _OutputIterator return_value = __result;\n+    _DifferenceType *__borders;\n+    _IteratorPair *__block_begins;\n+    _DifferenceType* __lengths;\n \n-    thread_index_t num_threads =\n-        std::min<difference_type>(get_max_threads(),\n-            std::min(end1 - begin1, end2 - begin2));\n+    _ThreadIndex __num_threads =\n+        std::min<_DifferenceType>(__get_max_threads(),\n+            std::min(__end1 - __begin1, __end2 - __begin2));\n \n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n-\n-            borders = new difference_type[num_threads + 2];\n-            equally_split(size, num_threads + 1, borders);\n-            block_begins = new iterator_pair[num_threads + 1];\n-            // Very start.\n-            block_begins[0] = std::make_pair(begin1, begin2);\n-            lengths = new difference_type[num_threads];\n+            __num_threads = omp_get_num_threads();\n+\n+            __borders = new _DifferenceType[__num_threads + 2];\n+            equally_split(size, __num_threads + 1, __borders);\n+            __block_begins = new _IteratorPair[__num_threads + 1];\n+            // Very __start.\n+            __block_begins[0] = std::make_pair(__begin1, __begin2);\n+            __lengths = new _DifferenceType[__num_threads];\n           } //single\n \n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n-        // Result from multiseq_partition.\n-        InputIterator offset[2];\n-        const difference_type rank = borders[iam + 1];\n+        // _Result from multiseq_partition.\n+        _IIter __offset[2];\n+        const _DifferenceType __rank = __borders[__iam + 1];\n \n-        multiseq_partition(sequence, sequence + 2, rank, offset, op.comp);\n+        multiseq_partition(__sequence, __sequence + 2, __rank, __offset, __op.__comp);\n \n         // allowed to read?\n         // together\n-        // *(offset[ 0 ] - 1) == *offset[ 1 ]\n-        if (offset[ 0 ] != begin1 && offset[ 1 ] != end2\n-            && !op.comp(*(offset[ 0 ] - 1), *offset[ 1 ])\n-            && !op.comp(*offset[ 1 ], *(offset[ 0 ] - 1)))\n+        // *(__offset[ 0 ] - 1) == *__offset[ 1 ]\n+        if (__offset[ 0 ] != __begin1 && __offset[ 1 ] != __end2\n+            && !__op.__comp(*(__offset[ 0 ] - 1), *__offset[ 1 ])\n+            && !__op.__comp(*__offset[ 1 ], *(__offset[ 0 ] - 1)))\n           {\n             // Avoid split between globally equal elements: move one to\n             // front in first sequence.\n-            --offset[ 0 ];\n+            --__offset[ 0 ];\n           }\n \n-        iterator_pair block_end = block_begins[ iam + 1 ] =\n-            iterator_pair(offset[ 0 ], offset[ 1 ]);\n+        _IteratorPair block_end = __block_begins[ __iam + 1 ] =\n+            _IteratorPair(__offset[ 0 ], __offset[ 1 ]);\n \n         // Make sure all threads have their block_begin result written out.\n #       pragma omp barrier\n \n-        iterator_pair block_begin = block_begins[ iam ];\n+        _IteratorPair __block_begin = __block_begins[ __iam ];\n \n         // Begin working for the first block, while the others except\n         // the last start to count.\n-        if (iam == 0)\n+        if (__iam == 0)\n           {\n             // The first thread can copy already.\n-            lengths[ iam ] = op.invoke(block_begin.first, block_end.first,\n-                                       block_begin.second, block_end.second,\n-                                       result)\n-                              - result;\n+            __lengths[ __iam ] = __op._M_invoke(__block_begin.first, block_end.first,\n+                                       __block_begin.second, block_end.second,\n+                                       __result)\n+                              - __result;\n           }\n         else\n           {\n-            lengths[ iam ] = op.count(block_begin.first, block_end.first,\n-                        block_begin.second, block_end.second);\n+            __lengths[ __iam ] = __op.__count(__block_begin.first, block_end.first,\n+                        __block_begin.second, block_end.second);\n           }\n \n         // Make sure everyone wrote their lengths.\n #       pragma omp barrier\n \n-        OutputIterator r = result;\n+        _OutputIterator __r = __result;\n \n-        if (iam == 0)\n+        if (__iam == 0)\n           {\n             // Do the last block.\n-            for (int i = 0; i < num_threads; ++i)\n-              r += lengths[i];\n+            for (int __i = 0; __i < __num_threads; ++__i)\n+              __r += __lengths[__i];\n \n-            block_begin = block_begins[num_threads];\n+            __block_begin = __block_begins[__num_threads];\n \n             // Return the result iterator of the last block.\n-            return_value = op.invoke(\n-                block_begin.first, end1, block_begin.second, end2, r);\n+            return_value = __op._M_invoke(\n+                __block_begin.first, __end1, __block_begin.second, __end2, __r);\n \n           }\n         else\n           {\n-            for (int i = 0; i < iam; ++i)\n-              r += lengths[ i ];\n+            for (int __i = 0; __i < __iam; ++__i)\n+              __r += __lengths[ __i ];\n \n             // Reset begins for copy pass.\n-            op.invoke(block_begin.first, block_end.first,\n-                  block_begin.second, block_end.second, r);\n+            __op._M_invoke(__block_begin.first, block_end.first,\n+                  __block_begin.second, block_end.second, __r);\n           }\n       }\n     return return_value;\n   }\n \n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n-  inline OutputIterator\n-  parallel_set_union(InputIterator begin1, InputIterator end1,\n-                     InputIterator begin2, InputIterator end2,\n-                     OutputIterator result, Comparator comp)\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n+  inline _OutputIterator\n+  __parallel_set_union(_IIter __begin1, _IIter __end1,\n+                     _IIter __begin2, _IIter __end2,\n+                     _OutputIterator __result, _Compare __comp)\n   {\n-    return parallel_set_operation(begin1, end1, begin2, end2, result,\n-        union_func< InputIterator, OutputIterator, Comparator>(comp));\n+    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n+        __union_func< _IIter, _OutputIterator, _Compare>(__comp));\n   }\n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n-  inline OutputIterator\n-  parallel_set_intersection(InputIterator begin1, InputIterator end1,\n-                            InputIterator begin2, InputIterator end2,\n-                            OutputIterator result, Comparator comp)\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n+  inline _OutputIterator\n+  __parallel_set_intersection(_IIter __begin1, _IIter __end1,\n+                            _IIter __begin2, _IIter __end2,\n+                            _OutputIterator __result, _Compare __comp)\n   {\n-    return parallel_set_operation(begin1, end1, begin2, end2, result,\n-        intersection_func<InputIterator, OutputIterator, Comparator>(comp));\n+    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n+        __intersection_func<_IIter, _OutputIterator, _Compare>(__comp));\n   }\n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n-  inline OutputIterator\n-  parallel_set_difference(InputIterator begin1, InputIterator end1,\n-                          InputIterator begin2, InputIterator end2,\n-                          OutputIterator result, Comparator comp)\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n+  inline _OutputIterator\n+  __parallel_set_difference(_IIter __begin1, _IIter __end1,\n+                          _IIter __begin2, _IIter __end2,\n+                          _OutputIterator __result, _Compare __comp)\n   {\n-    return parallel_set_operation(begin1, end1, begin2, end2, result,\n-        difference_func<InputIterator, OutputIterator, Comparator>(comp));\n+    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n+        __difference_func<_IIter, _OutputIterator, _Compare>(__comp));\n   }\n \n-template<typename InputIterator,\n-\t typename OutputIterator,\n-\t typename Comparator>\n-  inline OutputIterator\n-  parallel_set_symmetric_difference(InputIterator begin1, InputIterator end1,\n-                                    InputIterator begin2, InputIterator end2,\n-                                    OutputIterator result, Comparator comp)\n+template<typename _IIter,\n+\t typename _OutputIterator,\n+\t typename _Compare>\n+  inline _OutputIterator\n+  __parallel_set_symmetric_difference(_IIter __begin1, _IIter __end1,\n+                                    _IIter __begin2, _IIter __end2,\n+                                    _OutputIterator __result, _Compare __comp)\n   {\n-    return parallel_set_operation(begin1, end1, begin2, end2, result,\n-        symmetric_difference_func<InputIterator, OutputIterator, Comparator>\n-            (comp));\n+    return __parallel_set_operation(__begin1, __end1, __begin2, __end2, __result,\n+        symmetric_difference_func<_IIter, _OutputIterator, _Compare>\n+            (__comp));\n   }\n \n }"}, {"sha": "525bd9e6445136d948261575ba7a2c13cb974e5a", "filename": "libstdc++-v3/include/parallel/settings.h", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -30,7 +30,7 @@\n  *  @section parallelization_decision \n  *  The decision whether to run an algorithm in parallel.\n  *\n- *  There are several ways the user can switch on and off the parallel\n+ *  There are several ways the user can switch on and __off the parallel\n  *  execution of an algorithm, both at compile- and run-time.\n  *\n  *  Only sequential execution can be forced at compile-time.  This\n@@ -46,11 +46,11 @@\n  *\n  *  To force sequential execution of an algorithm ultimately at\n  *  compile-time, the user must add the tag\n- *  __gnu_parallel::sequential_tag() to the end of the parameter list,\n+*  gnu_parallel::sequential_tag() to the end of the parameter list,\n  *  e. g.\n  *\n  *  \\code\n- *  std::sort(v.begin(), v.end(), __gnu_parallel::sequential_tag());\n+ *  std::sort(__v.begin(), __v.end(), __gnu_parallel::sequential_tag());\n  *  \\endcode\n  *\n  *  This is compatible with all overloaded algorithm variants.  No\n@@ -60,18 +60,18 @@\n  *  If the algorithm call is not forced to be executed sequentially\n  *  at compile-time, the decision is made at run-time.\n  *  The global variable __gnu_parallel::_Settings::algorithm_strategy\n- *  is checked. It is a tristate variable corresponding to:\n+ *  is checked. _It is a tristate variable corresponding to:\n  *\n  *  a. force_sequential, meaning the sequential algorithm is executed.\n- *  b. force_parallel, meaning the parallel algorithm is executed.\n- *  c. heuristic\n+*  b. force_parallel, meaning the parallel algorithm is executed.\n+*  c. heuristic\n  *\n  *  For heuristic, the parallel algorithm implementation is called\n  *  only if the input size is sufficiently large.  For most\n  *  algorithms, the input size is the (combined) length of the input\n- *  sequence(s).  The threshold can be set by the user, individually\n+*  sequence(__s).  The threshold can be set by the user, individually\n  *  for each algorithm.  The according variables are called\n- *  __gnu_parallel::_Settings::[algorithm]_minimal_n .\n+*  gnu_parallel::_Settings::[algorithm]_minimal_n .\n  *\n  *  For some of the algorithms, there are even more tuning options,\n  *  e. g. the ability to choose from multiple algorithm variants.  See\n@@ -88,24 +88,24 @@\n /** \n   * @brief Determine at compile(?)-time if the parallel variant of an\n   * algorithm should be called.\n-  * @param c A condition that is convertible to bool that is overruled by\n+  * @param __c A condition that is convertible to bool that is overruled by\n   * __gnu_parallel::_Settings::algorithm_strategy. Usually a decision\n   * based on the input size.\n   */\n-#define _GLIBCXX_PARALLEL_CONDITION(c) (__gnu_parallel::_Settings::get().algorithm_strategy != __gnu_parallel::force_sequential && ((__gnu_parallel::get_max_threads() > 1 && (c)) || __gnu_parallel::_Settings::get().algorithm_strategy == __gnu_parallel::force_parallel))\n+#define _GLIBCXX_PARALLEL_CONDITION(__c) (__gnu_parallel::_Settings::get().algorithm_strategy != __gnu_parallel::force_sequential && ((__gnu_parallel::__get_max_threads() > 1 && (__c)) || __gnu_parallel::_Settings::get().algorithm_strategy == __gnu_parallel::force_parallel))\n \n /*\n inline bool\n-parallel_condition(bool c)\n+parallel_condition(bool __c)\n {\n   bool ret = false;\n-  const _Settings& s = _Settings::get();\n-  if (s.algorithm_strategy != force_seqential)\n+  const _Settings& __s = _Settings::get();\n+  if (__s.algorithm_strategy != force_seqential)\n     {\n-      if (s.algorithm_strategy == force_parallel)\n+      if (__s.algorithm_strategy == force_parallel)\n \tret = true;\n       else\n-\tret = get_max_threads() > 1 && c;\n+\tret = __get_max_threads() > 1 && __c;\n     }\n   return ret;\n }\n@@ -131,49 +131,49 @@ namespace __gnu_parallel\n     // Per-algorithm settings.\n \n     /// Minimal input size for accumulate.\n-    sequence_index_t \t\taccumulate_minimal_n;\n+    _SequenceIndex \t\taccumulate_minimal_n;\n \n     /// Minimal input size for adjacent_difference.\n     unsigned int \t\tadjacent_difference_minimal_n;\n \n     /// Minimal input size for count and count_if.\n-    sequence_index_t \t\tcount_minimal_n;\n+    _SequenceIndex \t\tcount_minimal_n;\n \n     /// Minimal input size for fill.\n-    sequence_index_t \t\tfill_minimal_n;\n+    _SequenceIndex \t\tfill_minimal_n;\n \n     /// Block size increase factor for find.\n     double \t\t\tfind_increasing_factor;\n \n     /// Initial block size for find.\n-    sequence_index_t \t\tfind_initial_block_size;\n+    _SequenceIndex \t\tfind_initial_block_size;\n \n     /// Maximal block size for find.\n-    sequence_index_t \t\tfind_maximum_block_size;\n+    _SequenceIndex \t\tfind_maximum_block_size;\n \n     /// Start with looking for this many elements sequentially, for find.\n-    sequence_index_t \t\tfind_sequential_search_size;\n+    _SequenceIndex \t\tfind_sequential_search_size;\n \n     /// Minimal input size for for_each.\n-    sequence_index_t \t\tfor_each_minimal_n;\n+    _SequenceIndex \t\tfor_each_minimal_n;\n \n     /// Minimal input size for generate.\n-    sequence_index_t \t\tgenerate_minimal_n;\n+    _SequenceIndex \t\tgenerate_minimal_n;\n \n     /// Minimal input size for max_element.\n-    sequence_index_t \t\tmax_element_minimal_n;\n+    _SequenceIndex \t\tmax_element_minimal_n;\n \n     /// Minimal input size for merge.\n-    sequence_index_t \t\tmerge_minimal_n;\n+    _SequenceIndex \t\tmerge_minimal_n;\n \n     /// Oversampling factor for merge.\n     unsigned int \t\tmerge_oversampling;\n \n     /// Minimal input size for min_element.\n-    sequence_index_t \t\tmin_element_minimal_n;\n+    _SequenceIndex \t\tmin_element_minimal_n;\n \n     /// Minimal input size for multiway_merge.\n-    sequence_index_t \t\tmultiway_merge_minimal_n;\n+    _SequenceIndex \t\tmultiway_merge_minimal_n;\n \n     /// Oversampling factor for multiway_merge.\n     int \t\t\tmultiway_merge_minimal_k;\n@@ -182,22 +182,22 @@ namespace __gnu_parallel\n     unsigned int \t\tmultiway_merge_oversampling;\n \n     /// Minimal input size for nth_element.\n-    sequence_index_t \t\tnth_element_minimal_n;\n+    _SequenceIndex \t\tnth_element_minimal_n;\n \n     /// Chunk size for partition.\n-    sequence_index_t \t\tpartition_chunk_size;\n+    _SequenceIndex \t\tpartition_chunk_size;\n \n     /// Chunk size for partition, relative to input size.  If > 0.0,\n     /// this value overrides partition_chunk_size.\n     double \t\t\tpartition_chunk_share;\n \n     /// Minimal input size for partition.\n-    sequence_index_t \t\tpartition_minimal_n;\n+    _SequenceIndex \t\tpartition_minimal_n;\n \n     /// Minimal input size for partial_sort.\n-    sequence_index_t \t\tpartial_sort_minimal_n;\n+    _SequenceIndex \t\tpartial_sort_minimal_n;\n \n-    /// Ratio for partial_sum. Assume \"sum and write result\" to be\n+    /// Ratio for partial_sum. Assume \"sum and write __result\" to be\n     /// this factor slower than just \"sum\".\n     float \t\t\tpartial_sum_dilation;\n \n@@ -208,61 +208,61 @@ namespace __gnu_parallel\n     unsigned int \t\trandom_shuffle_minimal_n;\n \n     /// Minimal input size for replace and replace_if.\n-    sequence_index_t \t\treplace_minimal_n;\n+    _SequenceIndex \t\treplace_minimal_n;\n \n     /// Minimal input size for set_difference.\n-    sequence_index_t \t\tset_difference_minimal_n;\n+    _SequenceIndex \t\tset_difference_minimal_n;\n \n     /// Minimal input size for set_intersection.\n-    sequence_index_t \t\tset_intersection_minimal_n;\n+    _SequenceIndex \t\tset_intersection_minimal_n;\n \n     /// Minimal input size for set_symmetric_difference.\n-    sequence_index_t \t\tset_symmetric_difference_minimal_n;\n+    _SequenceIndex \t\tset_symmetric_difference_minimal_n;\n \n     /// Minimal input size for set_union.\n-    sequence_index_t \t\tset_union_minimal_n;\n+    _SequenceIndex \t\tset_union_minimal_n;\n \n     /// Minimal input size for parallel sorting.\n-    sequence_index_t \t\tsort_minimal_n;\n+    _SequenceIndex \t\tsort_minimal_n;\n \n     /// Oversampling factor for parallel std::sort (MWMS).\n     unsigned int \t\tsort_mwms_oversampling;\n \n     /// Such many samples to take to find a good pivot (quicksort).\n     unsigned int \t\tsort_qs_num_samples_preset;\n \n-    /// Maximal subsequence length to switch to unbalanced base case.\n+    /// Maximal subsequence __length to switch to unbalanced __base case.\n     /// Applies to std::sort with dynamically load-balanced quicksort.\n-    sequence_index_t \t\tsort_qsb_base_case_maximal_n;\n+    _SequenceIndex \t\tsort_qsb_base_case_maximal_n;\n \n     /// Minimal input size for parallel std::transform.\n-    sequence_index_t \t\ttransform_minimal_n;\n+    _SequenceIndex \t\ttransform_minimal_n;\n \n     /// Minimal input size for unique_copy. \n-    sequence_index_t \t\tunique_copy_minimal_n;\n+    _SequenceIndex \t\tunique_copy_minimal_n;\n \n-    sequence_index_t \t\tworkstealing_chunk_size;\n+    _SequenceIndex \t\tworkstealing_chunk_size;\n \n     // Hardware dependent tuning parameters.\n \n-    /// Size of the L1 cache in bytes (underestimation).\n+    /// size of the L1 cache in bytes (underestimation).\n     unsigned long long \t\tL1_cache_size;\n \n-    /// Size of the L2 cache in bytes (underestimation).\n+    /// size of the L2 cache in bytes (underestimation).\n     unsigned long long \t\tL2_cache_size;\n \n-    /// Size of the Translation Lookaside Buffer (underestimation).\n+    /// size of the Translation Lookaside Buffer (underestimation).\n     unsigned int \t\tTLB_size;\n \n     /// Overestimation of cache line size.  Used to avoid false\n-    /// sharing, i. e. elements of different threads are at least this\n+    /// sharing, i.e. elements of different threads are at least this\n     /// amount apart.\n     unsigned int \t\tcache_line_size;\n \n     // Statistics.\n \n     /// The number of stolen ranges in load-balanced quicksort.\n-    sequence_index_t \t\tqsb_steals;\n+    _SequenceIndex \t\tqsb_steals;\n \n     /// Get the global settings.\n     _GLIBCXX_CONST static const _Settings&"}, {"sha": "a34d773474d442229ad531cc1cce458fba79b32f", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -55,174 +55,174 @@\n namespace __gnu_parallel\n {\n \t//prototype\n-  template<bool stable, typename RandomAccessIterator,\n-           typename Comparator, typename Parallelism>\n+  template<bool __stable, typename _RAIter,\n+           typename _Compare, typename _Parallelism>\n   void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-  Comparator comp, Parallelism parallelism);\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+  _Compare __comp, _Parallelism __parallelism);\n \t\n   /** \n    *  @brief Choose multiway mergesort, splitting variant at run-time,\n    *  for parallel sorting.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n   inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-    Comparator comp, multiway_mergesort_tag parallelism)\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+    _Compare __comp, multiway_mergesort_tag __parallelism)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n     if(_Settings::get().sort_splitting == EXACT)\n-      parallel_sort_mwms<stable, true>\n-        (begin, end, comp, parallelism.get_num_threads());\n+      parallel_sort_mwms<__stable, true>\n+        (__begin, __end, __comp, __parallelism.__get_num_threads());\n     else\n-      parallel_sort_mwms<stable, false>\n-        (begin, end, comp, parallelism.get_num_threads());\n+      parallel_sort_mwms<__stable, false>\n+        (__begin, __end, __comp, __parallelism.__get_num_threads());\n   }\n \n   /** \n-   *  @brief Choose multiway mergesort with exact splitting,\n+   *  @brief Choose multiway mergesort with __exact splitting,\n    *  for parallel sorting.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n   inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-    Comparator comp, multiway_mergesort_exact_tag parallelism)\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+    _Compare __comp, multiway_mergesort_exact_tag __parallelism)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-      parallel_sort_mwms<stable, true>\n-        (begin, end, comp, parallelism.get_num_threads());\n+      parallel_sort_mwms<__stable, true>\n+        (__begin, __end, __comp, __parallelism.__get_num_threads());\n   }\n \n   /** \n    *  @brief Choose multiway mergesort with splitting by sampling,\n    *  for parallel sorting.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n   inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-    Comparator comp, multiway_mergesort_sampling_tag parallelism)\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+    _Compare __comp, multiway_mergesort_sampling_tag __parallelism)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    parallel_sort_mwms<stable, false>\n-      (begin, end, comp, parallelism.get_num_threads());\n+    parallel_sort_mwms<__stable, false>\n+      (__begin, __end, __comp, __parallelism.__get_num_threads());\n   }\n \n   /**\n    *  @brief Choose quicksort for parallel sorting.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n   inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-    Comparator comp, quicksort_tag parallelism)\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+    _Compare __comp, quicksort_tag __parallelism)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    _GLIBCXX_PARALLEL_ASSERT(stable == false);\n+    _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n \n-    parallel_sort_qs(begin, end, comp, parallelism.get_num_threads());\n+    __parallel_sort_qs(__begin, __end, __comp, __parallelism.__get_num_threads());\n   }\n \n   /**\n    *  @brief Choose balanced quicksort for parallel sorting.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n-   *  @param stable Sort stable.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n+   *  @param __stable Sort __stable.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n   inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-    Comparator comp, balanced_quicksort_tag parallelism)\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+    _Compare __comp, balanced_quicksort_tag __parallelism)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    _GLIBCXX_PARALLEL_ASSERT(stable == false);\n+    _GLIBCXX_PARALLEL_ASSERT(__stable == false);\n \n-    parallel_sort_qsb(begin, end, comp, parallelism.get_num_threads());\n+    __parallel_sort_qsb(__begin, __end, __comp, __parallelism.__get_num_threads());\n   }\n \n \n   /** \n-   *  @brief Choose multiway mergesort with exact splitting,\n+   *  @brief Choose multiway mergesort with __exact splitting,\n    *  for parallel sorting.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n   inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-    Comparator comp, default_parallel_tag parallelism)\n+  parallel_sort(_RAIter __begin, _RAIter __end,\n+    _Compare __comp, default_parallel_tag __parallelism)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    parallel_sort<stable>\n-      (begin, end, comp,\n-        multiway_mergesort_exact_tag(parallelism.get_num_threads()));\n+    parallel_sort<__stable>\n+      (__begin, __end, __comp,\n+        multiway_mergesort_exact_tag(__parallelism.__get_num_threads()));\n   }\n \n \n   /**\n    *  @brief Choose a parallel sorting algorithm.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator.\n-   *  @param stable Sort stable.\n+   *  @param __begin Begin iterator of input sequence.\n+   *  @param __end End iterator of input sequence.\n+   *  @param __comp Comparator.\n+   *  @param __stable Sort __stable.\n    *  @callgraph \n    */\n-  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  template<bool __stable, typename _RAIter, typename _Compare>\n     inline void\n-    parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-                  Comparator comp, parallel_tag parallelism)\n+    parallel_sort(_RAIter __begin, _RAIter __end,\n+                  _Compare __comp, parallel_tag __parallelism)\n     {\n-      _GLIBCXX_CALL(end - begin)\n-      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-      typedef typename traits_type::value_type value_type;\n-      typedef typename traits_type::difference_type difference_type;\n+      _GLIBCXX_CALL(__end - __begin)\n+      typedef std::iterator_traits<_RAIter> _TraitsType;\n+      typedef typename _TraitsType::value_type _ValueType;\n+      typedef typename _TraitsType::difference_type _DifferenceType;\n \n       if (false) ;\n #if _GLIBCXX_MERGESORT\n-      else if (stable || _Settings::get().sort_algorithm == MWMS)\n+      else if (__stable || _Settings::get().sort_algorithm == MWMS)\n         {\n           if(_Settings::get().sort_splitting == EXACT)\n-            parallel_sort_mwms<stable, true>\n-              (begin, end, comp, parallelism.get_num_threads());\n+            parallel_sort_mwms<__stable, true>\n+              (__begin, __end, __comp, __parallelism.__get_num_threads());\n           else\n             parallel_sort_mwms<false, false>\n-              (begin, end, comp, parallelism.get_num_threads());\n+              (__begin, __end, __comp, __parallelism.__get_num_threads());\n         }\n #endif\n #if _GLIBCXX_QUICKSORT\n       else if (_Settings::get().sort_algorithm == QS)\n-        parallel_sort_qs(begin, end, comp, parallelism.get_num_threads());\n+        __parallel_sort_qs(__begin, __end, __comp, __parallelism.__get_num_threads());\n #endif\n #if _GLIBCXX_BAL_QUICKSORT\n       else if (_Settings::get().sort_algorithm == QS_BALANCED)\n-        parallel_sort_qsb(begin, end, comp, parallelism.get_num_threads());\n+        __parallel_sort_qsb(__begin, __end, __comp, __parallelism.__get_num_threads());\n #endif\n       else\n-        __gnu_sequential::sort(begin, end, comp);\n+        __gnu_sequential::sort(__begin, __end, __comp);\n     }\n } // end namespace __gnu_parallel\n "}, {"sha": "ae0c2027833d13114233128baceffbe989cee1a5", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -46,37 +46,37 @@ namespace __gnu_parallel\n   struct parallel_tag\n   {\n     private:\n-      thread_index_t num_threads;\n+      _ThreadIndex __num_threads;\n \n     public:\n       /** @brief Default constructor. Use default number of threads. */\n       parallel_tag()\n       {\n-        this->num_threads = 0;\n+        this->__num_threads = 0;\n       }\n \n       /** @brief Default constructor. Recommend number of threads to use.\n-       *  @param num_threads Desired number of threads. */\n-      parallel_tag(thread_index_t num_threads)\n+       *  @param __num_threads Desired number of threads. */\n+      parallel_tag(_ThreadIndex __num_threads)\n       {\n-        this->num_threads = num_threads;\n+        this->__num_threads = __num_threads;\n       }\n \n-      /** @brief Find out desired number of threads.\n+      /** @brief Find __out desired number of threads.\n        *  @return Desired number of threads. */\n-      inline thread_index_t get_num_threads()\n+      inline _ThreadIndex __get_num_threads()\n       {\n-        if(num_threads == 0)\n+        if(__num_threads == 0)\n           return omp_get_max_threads();\n         else\n-          return num_threads;\n+          return __num_threads;\n       }\n \n       /** @brief Set the desired number of threads.\n-       *  @param num_threads Desired number of threads. */\n-      inline void set_num_threads(thread_index_t num_threads)\n+       *  @param __num_threads Desired number of threads. */\n+      inline void set_num_threads(_ThreadIndex __num_threads)\n       {\n-        this->num_threads = num_threads;\n+        this->__num_threads = __num_threads;\n       }\n   };\n \n@@ -85,8 +85,8 @@ namespace __gnu_parallel\n   struct default_parallel_tag : public parallel_tag\n   {\n       default_parallel_tag() { }\n-      default_parallel_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      default_parallel_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Recommends parallel execution using dynamic\n@@ -111,21 +111,21 @@ namespace __gnu_parallel\n \n \n   /** @brief Forces parallel merging\n-   *  with exact splitting, at compile time. */\n+   *  with __exact splitting, at compile time. */\n   struct exact_tag : public parallel_tag\n   {\n       exact_tag() { }\n-      exact_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      exact_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel merging\n-   *  with exact splitting, at compile time. */\n+   *  with __exact splitting, at compile time. */\n   struct sampling_tag : public parallel_tag\n   {\n       sampling_tag() { }\n-      sampling_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      sampling_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n \n@@ -134,44 +134,44 @@ namespace __gnu_parallel\n   struct multiway_mergesort_tag : public parallel_tag\n   {\n       multiway_mergesort_tag() { }\n-      multiway_mergesort_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      multiway_mergesort_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using multiway mergesort\n-   *  with exact splitting at compile time. */\n+   *  with __exact splitting at compile time. */\n   struct multiway_mergesort_exact_tag : public parallel_tag\n   {\n       multiway_mergesort_exact_tag() { }\n-      multiway_mergesort_exact_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      multiway_mergesort_exact_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using multiway mergesort\n    *  with splitting by sampling at compile time. */\n   struct multiway_mergesort_sampling_tag : public parallel_tag\n   {\n       multiway_mergesort_sampling_tag() { }\n-      multiway_mergesort_sampling_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      multiway_mergesort_sampling_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using unbalanced quicksort\n    *  at compile time. */\n   struct quicksort_tag : public parallel_tag\n   {\n       quicksort_tag() { }\n-      quicksort_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      quicksort_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n   /** @brief Forces parallel sorting using balanced quicksort\n    *  at compile time. */\n   struct balanced_quicksort_tag : public parallel_tag\n   {\n       balanced_quicksort_tag() { }\n-      balanced_quicksort_tag(thread_index_t num_threads)\n-          : parallel_tag(num_threads) { }\n+      balanced_quicksort_tag(_ThreadIndex __num_threads)\n+          : parallel_tag(__num_threads) { }\n   };\n \n "}, {"sha": "70bfb64120a2b459340e8102ca5a5fb7f2422255", "filename": "libstdc++-v3/include/parallel/types.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftypes.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -79,7 +79,7 @@ namespace __gnu_parallel\n     };\n \n   /// Merging algorithms: \n-  // bubblesort-alike, loser-tree variants, enum sentinel.\n+  // bubblesort-alike, loser-tree variants, enum __sentinel.\n   enum _MultiwayMergeAlgorithm\n     {\n       LOSER_TREE\n@@ -92,7 +92,7 @@ namespace __gnu_parallel\n       LINEAR \n     };\n \n-  /// Sorting/merging algorithms: sampling, exact.\n+  /// Sorting/merging algorithms: sampling, __exact.\n   enum _SplittingAlgorithm \n     { \n       SAMPLING, \n@@ -108,7 +108,7 @@ namespace __gnu_parallel\n       EQUAL_SPLIT \n     };\n \n-  /// Integer Types.\n+  /// _Integer Types.\n   // XXX need to use <cstdint>\n   /** @brief 16-bit signed integer. */\n   typedef short int16;\n@@ -129,27 +129,27 @@ namespace __gnu_parallel\n   typedef unsigned long long uint64;\n \n   /**\n-   * @brief Unsigned integer to index elements.\n+   * @brief Unsigned integer to index __elements.\n    * The total number of elements for each algorithm must fit into this type.\n    */\n-  typedef uint64 sequence_index_t;\n+  typedef uint64 _SequenceIndex;\n \n   /**\n    * @brief Unsigned integer to index a thread number.\n    * The maximum thread number (for each processor) must fit into this type.\n    */\n-  typedef uint16 thread_index_t;\n+  typedef uint16 _ThreadIndex;\n \n   // XXX atomics interface?\n   /// Longest compare-and-swappable integer type on this platform.\n-  typedef int64 lcas_t;\n+  typedef int64 _CASable;\n \n   // XXX numeric_limits::digits?\n-  /// Number of bits of ::lcas_t.\n-  static const int lcas_t_bits = sizeof(lcas_t) * 8;\n+  /// Number of bits of ::_CASable.\n+  static const int _CASable_bits = sizeof(_CASable) * 8;\n \n-  /// ::lcas_t with the right half of bits set to 1.\n-  static const lcas_t lcas_t_mask = ((lcas_t(1) << (lcas_t_bits / 2)) - 1);\n+  /// ::_CASable with the right half of bits set to 1.\n+  static const _CASable _CASable_mask = ((_CASable(1) << (_CASable_bits / 2)) - 1);\n }\n \n #endif /* _GLIBCXX_PARALLEL_TYPES_H */"}, {"sha": "db2e820a708363e5a741eca14af832d6fb680632", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -38,153 +38,153 @@\n namespace __gnu_parallel\n {\n \n-/** @brief Parallel std::unique_copy(), w/o explicit equality predicate.\n-  *  @param first Begin iterator of input sequence.\n-  *  @param last End iterator of input sequence.\n-  *  @param result Begin iterator of result sequence.\n-  *  @param binary_pred Equality predicate.\n-  *  @return End iterator of result sequence. */\n-template<typename InputIterator,\n-\t class OutputIterator,\n-\t class BinaryPredicate>\n-  OutputIterator\n-  parallel_unique_copy(InputIterator first, InputIterator last,\n-                       OutputIterator result, BinaryPredicate binary_pred)\n+/** @brief Parallel std::unique_copy(), w/__o explicit equality predicate.\n+  *  @param __first Begin iterator of input sequence.\n+  *  @param __last End iterator of input sequence.\n+  *  @param __result Begin iterator of result __sequence.\n+  *  @param __binary_pred Equality predicate.\n+  *  @return End iterator of result __sequence. */\n+template<typename _IIter,\n+\t class _OutputIterator,\n+\t class _BinaryPredicate>\n+  _OutputIterator\n+  __parallel_unique_copy(_IIter __first, _IIter __last,\n+                       _OutputIterator __result, _BinaryPredicate __binary_pred)\n   {\n-    _GLIBCXX_CALL(last - first)\n+    _GLIBCXX_CALL(__last - __first)\n \n-    typedef std::iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_IIter> _TraitsType;\n+    typedef typename _TraitsType::value_type _ValueType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n \n-    difference_type size = last - first;\n+    _DifferenceType size = __last - __first;\n \n     if (size == 0)\n-      return result;\n+      return __result;\n \n     // Let the first thread process two parts.\n-    difference_type *counter;\n-    difference_type *borders;\n+    _DifferenceType *__counter;\n+    _DifferenceType *__borders;\n \n-    thread_index_t num_threads = get_max_threads();\n+    _ThreadIndex __num_threads = __get_max_threads();\n     // First part contains at least one element.\n-#   pragma omp parallel num_threads(num_threads)\n+#   pragma omp parallel num_threads(__num_threads)\n       {\n #       pragma omp single\n           {\n-\t    num_threads = omp_get_num_threads();\n-\t    borders = new difference_type[num_threads + 2];\n-\t    equally_split(size, num_threads + 1, borders);\n-\t    counter = new difference_type[num_threads + 1];\n+\t    __num_threads = omp_get_num_threads();\n+\t    __borders = new _DifferenceType[__num_threads + 2];\n+\t    equally_split(size, __num_threads + 1, __borders);\n+\t    __counter = new _DifferenceType[__num_threads + 1];\n           }\n \n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n-        difference_type begin, end;\n+        _DifferenceType __begin, __end;\n \n         // Check for length without duplicates\n         // Needed for position in output\n-        difference_type i = 0;\n-        OutputIterator out = result;\n+        _DifferenceType __i = 0;\n+        _OutputIterator __out = __result;\n \n-        if (iam == 0)\n+        if (__iam == 0)\n         {\n-          begin = borders[0] + 1;\t// == 1\n-          end = borders[iam + 1];\n+          __begin = __borders[0] + 1;\t// == 1\n+          __end = __borders[__iam + 1];\n \n-          ++i;\n-          *out++ = *first;\n+          ++__i;\n+          *__out++ = *__first;\n \n-          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n             {\n-              if (!binary_pred(*iter, *(iter-1)))\n+              if (!__binary_pred(*iter, *(iter-1)))\n                 {\n-                  ++i;\n-                  *out++ = *iter;\n+                  ++__i;\n+                  *__out++ = *iter;\n                 }\n             }\n         }\n       else\n         {\n-          begin = borders[iam]; //one part\n-          end = borders[iam + 1];\n+          __begin = __borders[__iam]; //one part\n+          __end = __borders[__iam + 1];\n \n-          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n             {\n-              if (!binary_pred(*iter, *(iter - 1)))\n-\t\t++i;\n+              if (!__binary_pred(*iter, *(iter - 1)))\n+\t\t++__i;\n \t    }\n         }\n-      counter[iam] = i;\n+      __counter[__iam] = __i;\n \n       // Last part still untouched.\n-      difference_type begin_output;\n+      _DifferenceType __begin_output;\n \n #     pragma omp barrier\n \n       // Store result in output on calculated positions.\n-      begin_output = 0;\n+      __begin_output = 0;\n \n-      if (iam == 0)\n+      if (__iam == 0)\n         {\n-          for (int t = 0; t < num_threads; ++t)\n-            begin_output += counter[t];\n+          for (int __t = 0; __t < __num_threads; ++__t)\n+            __begin_output += __counter[__t];\n \n-          i = 0;\n+          __i = 0;\n \n-          OutputIterator iter_out = result + begin_output;\n+          _OutputIterator __iter_out = __result + __begin_output;\n \n-          begin = borders[num_threads];\n-          end = size;\n+          __begin = __borders[__num_threads];\n+          __end = size;\n \n-          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n             {\n-              if (iter == first || !binary_pred(*iter, *(iter - 1)))\n+              if (iter == __first || !__binary_pred(*iter, *(iter - 1)))\n                 {\n-                  ++i;\n-                  *iter_out++ = *iter;\n+                  ++__i;\n+                  *__iter_out++ = *iter;\n                 }\n             }\n \n-          counter[num_threads] = i;\n+          __counter[__num_threads] = __i;\n         }\n       else\n         {\n-          for (int t = 0; t < iam; t++)\n-            begin_output += counter[t];\n+          for (int __t = 0; __t < __iam; __t++)\n+            __begin_output += __counter[__t];\n \n-          OutputIterator iter_out = result + begin_output;\n-          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+          _OutputIterator __iter_out = __result + __begin_output;\n+          for (_IIter iter = __first + __begin; iter < __first + __end; ++iter)\n             {\n-              if (!binary_pred(*iter, *(iter-1)))\n-\t\t*iter_out++ = *iter;\n+              if (!__binary_pred(*iter, *(iter-1)))\n+\t\t*__iter_out++ = *iter;\n \t    }\n         }\n     }\n \n-    difference_type end_output = 0;\n-    for (int t = 0; t < num_threads + 1; t++)\n-      end_output += counter[t];\n+    _DifferenceType __end_output = 0;\n+    for (int __t = 0; __t < __num_threads + 1; __t++)\n+      __end_output += __counter[__t];\n \n-    delete[] borders;\n+    delete[] __borders;\n \n-    return result + end_output;\n+    return __result + __end_output;\n   }\n \n /** @brief Parallel std::unique_copy(), without explicit equality predicate\n-  *  @param first Begin iterator of input sequence.\n-  *  @param last End iterator of input sequence.\n-  *  @param result Begin iterator of result sequence.\n-  *  @return End iterator of result sequence. */\n-template<typename InputIterator, class OutputIterator>\n-  inline OutputIterator\n-  parallel_unique_copy(InputIterator first, InputIterator last,\n-                       OutputIterator result)\n+  *  @param __first Begin iterator of input sequence.\n+  *  @param __last End iterator of input sequence.\n+  *  @param __result Begin iterator of result __sequence.\n+  *  @return End iterator of result __sequence. */\n+template<typename _IIter, class _OutputIterator>\n+  inline _OutputIterator\n+  __parallel_unique_copy(_IIter __first, _IIter __last,\n+                       _OutputIterator __result)\n   {\n-    typedef typename std::iterator_traits<InputIterator>::value_type\n-      value_type;\n-    return parallel_unique_copy(first, last, result,\n-\t\t\t\tstd::equal_to<value_type>());\n+    typedef typename std::iterator_traits<_IIter>::value_type\n+      _ValueType;\n+    return __parallel_unique_copy(__first, __last, __result,\n+\t\t\t\tstd::equal_to<_ValueType>());\n   }\n \n }//namespace __gnu_parallel"}, {"sha": "a43c261ebc3c59bdb313f3f3e3cb8fcf2c71881e", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1acba85b3706fd7063cbccded2d0c635ee76c445/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=1acba85b3706fd7063cbccded2d0c635ee76c445", "patch": "@@ -49,257 +49,257 @@ namespace __gnu_parallel\n \n #define _GLIBCXX_JOB_VOLATILE volatile\n \n-/** @brief One job for a certain thread. */\n+/** @brief One __job for a certain thread. */\n template<typename _DifferenceTp>\n-  struct Job\n+  struct _Job\n   {\n-    typedef _DifferenceTp difference_type;\n+    typedef _DifferenceTp _DifferenceType;\n \n     /** @brief First element.\n      *\n      *  Changed by owning and stealing thread. By stealing thread,\n      *  always incremented. */\n-    _GLIBCXX_JOB_VOLATILE difference_type first;\n+    _GLIBCXX_JOB_VOLATILE _DifferenceType __first;\n \n     /** @brief Last element.\n      *\n      *  Changed by owning thread only. */\n-    _GLIBCXX_JOB_VOLATILE difference_type last;\n+    _GLIBCXX_JOB_VOLATILE _DifferenceType __last;\n \n-    /** @brief Number of elements, i. e. @c last-first+1.\n+    /** @brief Number of elements, i.e. @__c __last-__first+1.\n      *\n      *  Changed by owning thread only. */\n-    _GLIBCXX_JOB_VOLATILE difference_type load;\n+    _GLIBCXX_JOB_VOLATILE _DifferenceType __load;\n   };\n \n /** @brief Work stealing algorithm for random access iterators.\n   *\n-  *  Uses O(1) additional memory. Synchronization at job lists is\n+  *  Uses O(1) additional memory. Synchronization at __job lists is\n   *  done with atomic operations.\n-  *  @param begin Begin iterator of element sequence.\n-  *  @param end End iterator of element sequence.\n-  *  @param op User-supplied functor (comparator, predicate, adding\n+  *  @param __begin Begin iterator of element __sequence.\n+  *  @param __end End iterator of element __sequence.\n+  *  @param __op User-supplied functor (comparator, predicate, adding\n   *  functor, ...).\n-  *  @param f Functor to \"process\" an element with op (depends on\n+  *  @param __f Functor to \"process\" an element with __op (depends on\n   *  desired functionality, e. g. for std::for_each(), ...).\n-  *  @param r Functor to \"add\" a single result to the already\n-  *  processed elements (depends on functionality).\n-  *  @param base Base value for reduction.\n-  *  @param output Pointer to position where final result is written to\n-  *  @param bound Maximum number of elements processed (e. g. for\n+  *  @param __r Functor to \"add\" a single __result to the already\n+  *  processed __elements (depends on functionality).\n+  *  @param __base Base value for reduction.\n+  *  @param __output Pointer to position where final result is written to\n+  *  @param __bound Maximum number of elements processed (e. g. for\n   *  std::count_n()).\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n-template<typename RandomAccessIterator,\n-\t typename Op,\n-\t typename Fu,\n-\t typename Red,\n-\t typename Result>\n-  Op\n-  for_each_template_random_access_workstealing(RandomAccessIterator begin,\n-\t\t\t\t\t       RandomAccessIterator end,\n-\t\t\t\t\t       Op op, Fu& f, Red r,\n-\t\t\t\t\t       Result base, Result& output,\n+template<typename _RAIter,\n+\t typename _Op,\n+\t typename _Fu,\n+\t typename _Red,\n+\t typename _Result>\n+  _Op\n+  for_each_template_random_access_workstealing(_RAIter __begin,\n+\t\t\t\t\t       _RAIter __end,\n+\t\t\t\t\t       _Op __op, _Fu& __f, _Red __r,\n+\t\t\t\t\t       _Result __base, _Result& __output,\n \t\t\t\t\t       typename std::iterator_traits\n-\t\t\t\t\t       <RandomAccessIterator>::\n-\t\t\t\t\t       difference_type bound)\n+\t\t\t\t\t       <_RAIter>::\n+\t\t\t\t\t       difference_type __bound)\n   {\n-    _GLIBCXX_CALL(end - begin)\n+    _GLIBCXX_CALL(__end - __begin)\n \n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef std::iterator_traits<_RAIter> _TraitsType;\n+    typedef typename _TraitsType::difference_type _DifferenceType;\n     \n     const _Settings& __s = _Settings::get();\n \n-    difference_type chunk_size = static_cast<difference_type>(__s.workstealing_chunk_size);\n+    _DifferenceType __chunk_size = static_cast<_DifferenceType>(__s.workstealing_chunk_size);\n \n     // How many jobs?\n-    difference_type length = (bound < 0) ? (end - begin) : bound;\n+    _DifferenceType __length = (__bound < 0) ? (__end - __begin) : __bound;\n \n     // To avoid false sharing in a cache line.\n-    const int stride = __s.cache_line_size * 10 / sizeof(Job<difference_type>) + 1;\n+    const int __stride = __s.cache_line_size * 10 / sizeof(_Job<_DifferenceType>) + 1;\n \n     // Total number of threads currently working.\n-    thread_index_t busy = 0;\n+    _ThreadIndex __busy = 0;\n \n-    Job<difference_type> *job;\n+    _Job<_DifferenceType> *__job;\n \n-    omp_lock_t output_lock;\n-    omp_init_lock(&output_lock);\n+    omp_lock_t __output_lock;\n+    omp_init_lock(&__output_lock);\n \n-    // Write base value to output.\n-    output = base;\n+    // Write __base __value to output.\n+    __output = __base;\n \n     // No more threads than jobs, at least one thread.\n-    thread_index_t num_threads =\n-        __gnu_parallel::max<thread_index_t>(1,\n-            __gnu_parallel::min<difference_type>(length, get_max_threads()));\n+    _ThreadIndex __num_threads =\n+        __gnu_parallel::max<_ThreadIndex>(1,\n+            __gnu_parallel::min<_DifferenceType>(__length, __get_max_threads()));\n \n-#   pragma omp parallel shared(busy) num_threads(num_threads)\n+#   pragma omp parallel shared(__busy) num_threads(__num_threads)\n       {\n \n #       pragma omp single\n           {\n-            num_threads = omp_get_num_threads();\n+            __num_threads = omp_get_num_threads();\n \n-            // Create job description array.\n-            job = new Job<difference_type>[num_threads * stride];\n+            // Create __job description array.\n+            __job = new _Job<_DifferenceType>[__num_threads * __stride];\n           }\n \n         // Initialization phase.\n \n         // Flags for every thread if it is doing productive work.\n-        bool iam_working = false;\n+        bool __iam_working = false;\n \n         // Thread id.\n-        thread_index_t iam = omp_get_thread_num();\n+        _ThreadIndex __iam = omp_get_thread_num();\n \n-        // This job.\n-        Job<difference_type>& my_job = job[iam * stride];\n+        // This __job.\n+        _Job<_DifferenceType>& __my_job = __job[__iam * __stride];\n \n         // Random number (for work stealing).\n-        thread_index_t victim;\n+        _ThreadIndex __victim;\n \n         // Local value for reduction.\n-        Result result = Result();\n+        _Result __result = _Result();\n \n         // Number of elements to steal in one attempt.\n-        difference_type steal;\n+        _DifferenceType __steal;\n \n         // Every thread has its own random number generator\n-        // (modulo num_threads).\n-        random_number rand_gen(iam, num_threads);\n+        // (modulo __num_threads).\n+        _RandomNumber rand_gen(__iam, __num_threads);\n \n         // This thread is currently working.\n #       pragma omp atomic\n-          ++busy;\n+          ++__busy;\n \n-        iam_working = true;\n+        __iam_working = true;\n \n         // How many jobs per thread? last thread gets the rest.\n-        my_job.first =\n-            static_cast<difference_type>(iam * (length / num_threads));\n+        __my_job.__first =\n+            static_cast<_DifferenceType>(__iam * (__length / __num_threads));\n \n-        my_job.last = (iam == (num_threads - 1)) ?\n-            (length - 1) : ((iam + 1) * (length / num_threads) - 1);\n-        my_job.load = my_job.last - my_job.first + 1;\n+        __my_job.__last = (__iam == (__num_threads - 1)) ?\n+            (__length - 1) : ((__iam + 1) * (__length / __num_threads) - 1);\n+        __my_job.__load = __my_job.__last - __my_job.__first + 1;\n \n-        // Init result with first value (to have a base value for reduction).\n-        if (my_job.first <= my_job.last)\n+        // Init __result with __first __value (to have a base value for reduction).\n+        if (__my_job.__first <= __my_job.__last)\n           {\n             // Cannot use volatile variable directly.\n-            difference_type my_first = my_job.first;\n-            result = f(op, begin + my_first);\n-            ++my_job.first;\n-            --my_job.load;\n+            _DifferenceType __my_first = __my_job.__first;\n+            __result = __f(__op, __begin + __my_first);\n+            ++__my_job.__first;\n+            --__my_job.__load;\n           }\n \n-        RandomAccessIterator current;\n+        _RAIter __current;\n \n #       pragma omp barrier\n \n         // Actual work phase\n-        // Work on own or stolen start\n-        while (busy > 0)\n+        // Work on own or stolen __start\n+        while (__busy > 0)\n           {\n-            // Work until no productive thread left.\n-#           pragma omp flush(busy)\n+            // Work until no productive thread __left.\n+#           pragma omp flush(__busy)\n \n             // Thread has own work to do\n-            while (my_job.first <= my_job.last)\n+            while (__my_job.__first <= __my_job.__last)\n               {\n                 // fetch-and-add call\n-                // Reserve current job block (size chunk_size) in my queue.\n-                difference_type current_job =\n-                  fetch_and_add<difference_type>(&(my_job.first), chunk_size);\n-\n-                // Update load, to make the three values consistent,\n-                // first might have been changed in the meantime\n-                my_job.load = my_job.last - my_job.first + 1;\n-                for (difference_type job_counter = 0;\n-                     job_counter < chunk_size && current_job <= my_job.last;\n+                // Reserve __current __job block (size __chunk_size) in my queue.\n+                _DifferenceType current_job =\n+                  __fetch_and_add<_DifferenceType>(&(__my_job.__first), __chunk_size);\n+\n+                // Update __load, to make the three values consistent,\n+                // __first might have been changed in the meantime\n+                __my_job.__load = __my_job.__last - __my_job.__first + 1;\n+                for (_DifferenceType job_counter = 0;\n+                     job_counter < __chunk_size && current_job <= __my_job.__last;\n                      ++job_counter)\n                   {\n                     // Yes: process it!\n-                    current = begin + current_job;\n+                    __current = __begin + current_job;\n                     ++current_job;\n \n                     // Do actual work.\n-                    result = r(result, f(op, current));\n+                    __result = __r(__result, __f(__op, __current));\n                   }\n \n-#               pragma omp flush(busy)\n+#               pragma omp flush(__busy)\n               }\n \n-            // After reaching this point, a thread's job list is empty.\n-            if (iam_working)\n+            // After reaching this point, a thread's __job list is empty.\n+            if (__iam_working)\n               {\n                 // This thread no longer has work.\n #               pragma omp atomic\n-                --busy;\n+                --__busy;\n \n-                iam_working = false;\n+                __iam_working = false;\n               }\n \n-            difference_type supposed_first, supposed_last, supposed_load;\n+            _DifferenceType __supposed_first, __supposed_last, __supposed_load;\n             do\n               {\n                 // Find random nonempty deque (not own), do consistency check.\n-                yield();\n-#               pragma omp flush(busy)\n-                victim = rand_gen();\n-                supposed_first = job[victim * stride].first;\n-                supposed_last = job[victim * stride].last;\n-                supposed_load = job[victim * stride].load;\n+                __yield();\n+#               pragma omp flush(__busy)\n+                __victim = rand_gen();\n+                __supposed_first = __job[__victim * __stride].__first;\n+                __supposed_last = __job[__victim * __stride].__last;\n+                __supposed_load = __job[__victim * __stride].__load;\n               }\n-            while (busy > 0\n-              && ((supposed_load <= 0)\n-                || ((supposed_first + supposed_load - 1) != supposed_last)));\n+            while (__busy > 0\n+              && ((__supposed_load <= 0)\n+                || ((__supposed_first + __supposed_load - 1) != __supposed_last)));\n \n-            if (busy == 0)\n+            if (__busy == 0)\n               break;\n \n-            if (supposed_load > 0)\n+            if (__supposed_load > 0)\n               {\n                 // Has work and work to do.\n                 // Number of elements to steal (at least one).\n-                steal = (supposed_load < 2) ? 1 : supposed_load / 2;\n+                __steal = (__supposed_load < 2) ? 1 : __supposed_load / 2;\n \n-                // Push victim's start forward.\n-                difference_type stolen_first =\n-                    fetch_and_add<difference_type>(\n-                        &(job[victim * stride].first), steal);\n-                difference_type stolen_try =\n-                    stolen_first + steal - difference_type(1);\n+                // Push __victim's __start forward.\n+                _DifferenceType __stolen_first =\n+                    __fetch_and_add<_DifferenceType>(\n+                        &(__job[__victim * __stride].__first), __steal);\n+                _DifferenceType stolen_try =\n+                    __stolen_first + __steal - _DifferenceType(1);\n \n-                my_job.first = stolen_first;\n-                my_job.last = __gnu_parallel::min(stolen_try, supposed_last);\n-                my_job.load = my_job.last - my_job.first + 1;\n+                __my_job.__first = __stolen_first;\n+                __my_job.__last = __gnu_parallel::min(stolen_try, __supposed_last);\n+                __my_job.__load = __my_job.__last - __my_job.__first + 1;\n \n                 // Has potential work again.\n #               pragma omp atomic\n-                  ++busy;\n-                iam_working = true;\n+                  ++__busy;\n+                __iam_working = true;\n \n-#               pragma omp flush(busy)\n+#               pragma omp flush(__busy)\n               }\n-#           pragma omp flush(busy)\n-          } // end while busy > 0\n-            // Add accumulated result to output.\n-        omp_set_lock(&output_lock);\n-        output = r(output, result);\n-        omp_unset_lock(&output_lock);\n+#           pragma omp flush(__busy)\n+          } // end while __busy > 0\n+            // Add accumulated __result to output.\n+        omp_set_lock(&__output_lock);\n+        __output = __r(__output, __result);\n+        omp_unset_lock(&__output_lock);\n       }\n \n-    delete[] job;\n+    delete[] __job;\n \n     // Points to last element processed (needed as return value for\n     // some algorithms like transform)\n-    f.finish_iterator = begin + length;\n+    __f.finish_iterator = __begin + __length;\n \n-    omp_destroy_lock(&output_lock);\n+    omp_destroy_lock(&__output_lock);\n \n-    return op;\n+    return __op;\n   }\n } // end namespace\n "}]}