{"sha": "caf29de78e1a609a86f4f883db628e97f51b96c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmMjlkZTc4ZTFhNjA5YTg2ZjRmODgzZGI2MjhlOTdmNTFiOTZjOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-04T08:42:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-04T08:42:06Z"}, "message": "tree.c (iterate_hash_expr): Optimize, avoid use of iterative_hash_object.\n\n\t* tree.c (iterate_hash_expr): Optimize, avoid use of iterative_hash_object.\n\t(mix): New macro copied from hashtab.c\n\t(iterative_hash_hashval_t, iterative_hash_pointer,\n\titerative_hash_host_wide_int): New functions based on hashtab.c\n\timplementation.\n\nFrom-SVN: r87078", "tree": {"sha": "3dccd3cd8b006c45b99d19aa8d43934930449d11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dccd3cd8b006c45b99d19aa8d43934930449d11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caf29de78e1a609a86f4f883db628e97f51b96c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf29de78e1a609a86f4f883db628e97f51b96c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf29de78e1a609a86f4f883db628e97f51b96c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf29de78e1a609a86f4f883db628e97f51b96c8/comments", "author": null, "committer": null, "parents": [{"sha": "e83adf94fd6c4dfeeebb6ffd4c14a1600c4ea5f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e83adf94fd6c4dfeeebb6ffd4c14a1600c4ea5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e83adf94fd6c4dfeeebb6ffd4c14a1600c4ea5f4"}], "stats": {"total": 229, "additions": 150, "deletions": 79}, "files": [{"sha": "93ed7fde8d7cf4a47d9879fa0741ccaf83f83a76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf29de78e1a609a86f4f883db628e97f51b96c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf29de78e1a609a86f4f883db628e97f51b96c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=caf29de78e1a609a86f4f883db628e97f51b96c8", "patch": "@@ -1,3 +1,11 @@\n+2004-09-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.c (iterate_hash_expr): Optimize, avoid use of iterative_hash_object.\n+\t(mix): New macro copied from hashtab.c\n+\t(iterative_hash_hashval_t, iterative_hash_pointer,\n+\titerative_hash_host_wide_int): New functions based on hashtab.c\n+\timplementation.\n+\n 2004-09-04  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (mask): New mode attribute."}, {"sha": "95f5ccbecb13d1263cc14113a33319c6357baa92", "filename": "gcc/tree.c", "status": "modified", "additions": 142, "deletions": 79, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf29de78e1a609a86f4f883db628e97f51b96c8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf29de78e1a609a86f4f883db628e97f51b96c8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=caf29de78e1a609a86f4f883db628e97f51b96c8", "patch": "@@ -2766,6 +2766,74 @@ build_decl_attribute_variant (tree ddecl, tree attribute)\n   return ddecl;\n }\n \n+/* Borrowed from hashtab.c iterative_hash implementation.  */\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= b; a -= c; a ^= (c>>13); \\\n+  b -= c; b -= a; b ^= (a<< 8); \\\n+  c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \\\n+  a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \\\n+  b -= c; b -= a; b = (b ^ (a<<16)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>> 5)) & 0xffffffff; \\\n+  a -= b; a -= c; a = (a ^ (c>> 3)) & 0xffffffff; \\\n+  b -= c; b -= a; b = (b ^ (a<<10)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>>15)) & 0xffffffff; \\\n+}\n+\n+\n+/* Produce good hash value combining VAL and VAL2.  */\n+static inline hashval_t\n+iterative_hash_hashval_t (hashval_t val, hashval_t val2)\n+{\n+  /* the golden ratio; an arbitrary value.  */\n+  hashval_t a = 0x9e3779b9;\n+\n+  mix (a, val, val2);\n+  return val2;\n+}\n+\n+/* Produce good hash value combining PTR and VAL2.  */\n+static inline hashval_t\n+iterative_hash_pointer (void *ptr, hashval_t val2)\n+{\n+  if (sizeof (ptr) == sizeof (hashval_t))\n+    return iterative_hash_hashval_t ((size_t) ptr, val2);\n+  else\n+    {\n+      hashval_t a = (hashval_t) (size_t) ptr;\n+      /* Avoid warnings about shifting of more than the width of the type on\n+         hosts that won't execute this path.  */\n+      int zero = 0;\n+      hashval_t b = (hashval_t) ((size_t) ptr >> (sizeof (hashval_t) * 8 + zero));\n+      mix (a, b, val2);\n+      return val2;\n+    }\n+}\n+\n+/* Produce good hash value combining VAL and VAL2.  */\n+static inline hashval_t\n+iterative_hash_host_wide_int (HOST_WIDE_INT val, hashval_t val2)\n+{\n+  if (sizeof (HOST_WIDE_INT) == sizeof (hashval_t))\n+    return iterative_hash_hashval_t (val, val2);\n+  else\n+    {\n+      hashval_t a = (hashval_t) val;\n+      /* Avoid warnings about shifting of more than the width of the type on\n+         hosts that won't execute this path.  */\n+      int zero = 0;\n+      hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 8 + zero));\n+      mix (a, b, val2);\n+      if (sizeof (HOST_WIDE_INT) > 2 * sizeof (hashval_t))\n+\t{\n+\t  hashval_t a = (hashval_t) (val >> (sizeof (hashval_t) * 16 + zero));\n+\t  hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 24 + zero));\n+\t  mix (a, b, val2);\n+\t}\n+      return val2;\n+    }\n+}\n+\n /* Return a type like TTYPE except that its TYPE_ATTRIBUTE\n    is ATTRIBUTE.\n \n@@ -3908,97 +3976,92 @@ iterative_hash_expr (tree t, hashval_t val)\n   char class;\n \n   if (t == NULL_TREE)\n-    return iterative_hash_object (t, val);\n+    return iterative_hash_pointer (t, val);\n \n   code = TREE_CODE (t);\n-  class = TREE_CODE_CLASS (code);\n \n-  if (class == 'd'\n-      || TREE_CODE (t) == VALUE_HANDLE)\n-    {\n-      /* Decls we can just compare by pointer.  */\n-      val = iterative_hash_object (t, val);\n-    }\n-  else if (class == 'c')\n+  switch (code)\n     {\n-      /* Alas, constants aren't shared, so we can't rely on pointer\n-\t identity.  */\n-      if (code == INTEGER_CST)\n-\t{\n-\t  val = iterative_hash_object (TREE_INT_CST_LOW (t), val);\n-\t  val = iterative_hash_object (TREE_INT_CST_HIGH (t), val);\n-\t}\n-      else if (code == REAL_CST)\n-\t{\n-\t  unsigned int val2 = real_hash (TREE_REAL_CST_PTR (t));\n+    /* Alas, constants aren't shared, so we can't rely on pointer\n+       identity.  */\n+    case INTEGER_CST:\n+      val = iterative_hash_host_wide_int (TREE_INT_CST_LOW (t), val);\n+      return iterative_hash_host_wide_int (TREE_INT_CST_HIGH (t), val);\n+    case REAL_CST:\n+      {\n+\tunsigned int val2 = real_hash (TREE_REAL_CST_PTR (t));\n \n-\t  val = iterative_hash (&val2, sizeof (unsigned int), val);\n-\t}\n-      else if (code == STRING_CST)\n-\tval = iterative_hash (TREE_STRING_POINTER (t),\n-\t\t\t      TREE_STRING_LENGTH (t), val);\n-      else if (code == COMPLEX_CST)\n+\treturn iterative_hash_hashval_t (val2, val);\n+      }\n+    case STRING_CST:\n+      return iterative_hash (TREE_STRING_POINTER (t),\n+\t\t\t     TREE_STRING_LENGTH (t), val);\n+    case COMPLEX_CST:\n+      val = iterative_hash_expr (TREE_REALPART (t), val);\n+      return iterative_hash_expr (TREE_IMAGPART (t), val);\n+    case VECTOR_CST:\n+      return iterative_hash_expr (TREE_VECTOR_CST_ELTS (t), val);\n+\n+    case SSA_NAME:\n+    case VALUE_HANDLE:\n+      /* we can just compare by pointer.  */\n+      return iterative_hash_pointer (t, val);\n+\n+    case TREE_LIST:\n+      /* A list of expressions, for a CALL_EXPR or as the elements of a\n+\t VECTOR_CST.  */\n+      for (; t; t = TREE_CHAIN (t))\n+\tval = iterative_hash_expr (TREE_VALUE (t), val);\n+      return val;\n+    default:\n+      class = TREE_CODE_CLASS (code);\n+\n+      if (class == 'd')\n \t{\n-\t  val = iterative_hash_expr (TREE_REALPART (t), val);\n-\t  val = iterative_hash_expr (TREE_IMAGPART (t), val);\n+\t  /* Decls we can just compare by pointer.  */\n+\t  val = iterative_hash_pointer (t, val);\n \t}\n-      else if (code == VECTOR_CST)\n-\tval = iterative_hash_expr (TREE_VECTOR_CST_ELTS (t), val);\n-      else\n-\tabort ();\n-    }\n-  else if (IS_EXPR_CODE_CLASS (class))\n-    {\n-      val = iterative_hash_object (code, val);\n-\n-      /* Don't hash the type, that can lead to having nodes which\n-\t compare equal according to operand_equal_p, but which\n-\t have different hash codes.  */\n-      if (code == NOP_EXPR\n-\t  || code == CONVERT_EXPR\n-\t  || code == NON_LVALUE_EXPR)\n+      else if (IS_EXPR_CODE_CLASS (class))\n \t{\n-\t  /* Make sure to include signness in the hash computation.  */\n-\t  val += TYPE_UNSIGNED (TREE_TYPE (t));\n-\t  val = iterative_hash_expr (TREE_OPERAND (t, 0), val);\n-\t}\n+\t  val = iterative_hash_object (code, val);\n+\n+\t  /* Don't hash the type, that can lead to having nodes which\n+\t     compare equal according to operand_equal_p, but which\n+\t     have different hash codes.  */\n+\t  if (code == NOP_EXPR\n+\t      || code == CONVERT_EXPR\n+\t      || code == NON_LVALUE_EXPR)\n+\t    {\n+\t      /* Make sure to include signness in the hash computation.  */\n+\t      val += TYPE_UNSIGNED (TREE_TYPE (t));\n+\t      val = iterative_hash_expr (TREE_OPERAND (t, 0), val);\n+\t    }\n \n-      if (commutative_tree_code (code))\n-\t{\n-\t  /* It's a commutative expression.  We want to hash it the same\n-\t     however it appears.  We do this by first hashing both operands\n-\t     and then rehashing based on the order of their independent\n-\t     hashes.  */\n-\t  hashval_t one = iterative_hash_expr (TREE_OPERAND (t, 0), 0);\n-\t  hashval_t two = iterative_hash_expr (TREE_OPERAND (t, 1), 0);\n-\t  hashval_t t;\n-\n-\t  if (one > two)\n-\t    t = one, one = two, two = t;\n-\n-\t  val = iterative_hash_object (one, val);\n-\t  val = iterative_hash_object (two, val);\n+\t  else if (commutative_tree_code (code))\n+\t    {\n+\t      /* It's a commutative expression.  We want to hash it the same\n+\t\t however it appears.  We do this by first hashing both operands\n+\t\t and then rehashing based on the order of their independent\n+\t\t hashes.  */\n+\t      hashval_t one = iterative_hash_expr (TREE_OPERAND (t, 0), 0);\n+\t      hashval_t two = iterative_hash_expr (TREE_OPERAND (t, 1), 0);\n+\t      hashval_t t;\n+\n+\t      if (one > two)\n+\t\tt = one, one = two, two = t;\n+\n+\t      val = iterative_hash_hashval_t (one, val);\n+\t      val = iterative_hash_hashval_t (two, val);\n+\t    }\n+\t  else\n+\t    for (i = first_rtl_op (code) - 1; i >= 0; --i)\n+\t      val = iterative_hash_expr (TREE_OPERAND (t, i), val);\n \t}\n       else\n-\tfor (i = first_rtl_op (code) - 1; i >= 0; --i)\n-\t  val = iterative_hash_expr (TREE_OPERAND (t, i), val);\n-    }\n-  else if (code == TREE_LIST)\n-    {\n-      /* A list of expressions, for a CALL_EXPR or as the elements of a\n-\t VECTOR_CST.  */\n-      for (; t; t = TREE_CHAIN (t))\n-\tval = iterative_hash_expr (TREE_VALUE (t), val);\n-    }\n-  else if (code == SSA_NAME)\n-    {\n-      val = iterative_hash_object (SSA_NAME_VERSION (t), val);\n-      val = iterative_hash_expr (SSA_NAME_VAR (t), val);\n+\tabort ();\n+      return val;\n+      break;\n     }\n-  else\n-    abort ();\n-\n-  return val;\n }\n \f\n /* Constructors for pointer, array and function types."}]}