{"sha": "a8c9daebabca42a0f8809bb696632e76102fea52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjOWRhZWJhYmNhNDJhMGY4ODA5YmI2OTY2MzJlNzYxMDJmZWE1Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T11:27:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T11:27:52Z"}, "message": "Add prototypes for all static functions and clean up some definitions.\n\n(struct decompose): Move to before function declarations.\n(secondary_memlocs_elim): One per operand, not per mode.\n(get_secondary_mem): Accept and use reload description (opnum and type).\n(push_reload): Accept and use new reload description instead of old NEEDED_FOR.\nDefine two new macros: MERGEABLE_RELOADS and MERGE_TO_OTHER.\nUse these macros to see if reloads can be merged and how to do it.\n(transfer_replacements): New function.\n(combine_reloads): Refine when we can combine reloads.\n(find_reloads): Use new method of tracking what a reload is for.\nWhen we make a CLOBBER insn, do so with DImode.\nMerge cases of making optional reloads, avoid making output-only optional\nreloads, refine when we may not make in-out optional reloads, and make an\noptional reload for a pair of matching operands.\n(find_reloads_toplev, find_reloads_address{,_1, part}): Accept and use reload\ndescription.\n(forget_volatility): Delete long-obsolete function.\n\nFrom-SVN: r3911", "tree": {"sha": "73ac34e92ed61ba3c48bfbdc82a2f3149f38159b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73ac34e92ed61ba3c48bfbdc82a2f3149f38159b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8c9daebabca42a0f8809bb696632e76102fea52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c9daebabca42a0f8809bb696632e76102fea52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c9daebabca42a0f8809bb696632e76102fea52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c9daebabca42a0f8809bb696632e76102fea52/comments", "author": null, "committer": null, "parents": [{"sha": "546b63fb94a89bdae2e8ec1ac74ea77a809458df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546b63fb94a89bdae2e8ec1ac74ea77a809458df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546b63fb94a89bdae2e8ec1ac74ea77a809458df"}], "stats": {"total": 1045, "additions": 614, "deletions": 431}, "files": [{"sha": "9952296650b1d7a556884c0662aedc8ea41673ac", "filename": "gcc/reload.c", "status": "modified", "additions": 614, "deletions": 431, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c9daebabca42a0f8809bb696632e76102fea52/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c9daebabca42a0f8809bb696632e76102fea52/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a8c9daebabca42a0f8809bb696632e76102fea52", "patch": "@@ -113,9 +113,6 @@ a register with any other reload.  */\n \t\t\t   when reloaded, on input.\n    reload_outmode\t  enum machine_mode; mode this operand should have\n \t\t\t   when reloaded, on output.\n-   reload_strict_low\t  char; currently always zero; used to mean that this\n-\t\t\t  reload is inside a STRICT_LOW_PART, but we don't\n-\t\t\t  need to know this anymore.\n    reload_optional\t  char, nonzero for an optional reload.\n \t\t\t   Optional reloads are ignored unless the\n \t\t\t   value is already sitting in a register.\n@@ -134,11 +131,12 @@ a register with any other reload.  */\n \t\t\t   reload_inmode or reload_outmode.\n    reload_nocombine\t  char, nonzero if this reload shouldn't be\n \t\t\t   combined with another reload.\n-   reload_needed_for      rtx, operand this reload is needed for address of.\n-\t\t\t   0 means it isn't needed for addressing.\n-   reload_needed_for_multiple\n-\t\t\t  int, 1 if this reload needed for more than one thing.\n-   reload_when_needed     enum, classifies reload as needed either for\n+   reload_opnum\t\t  int, operand number being reloaded.  This is\n+\t\t\t   used to group related reloads and need not always\n+\t\t\t   be equal to the actual operand number in the insn,\n+\t\t\t   though it current will be; for in-out operands, it\n+\t\t\t   is one of the two operand numbers.\n+   reload_when_needed    enum, classifies reload as needed either for\n \t\t\t   addressing an input reload, addressing an output,\n \t\t\t   for addressing a non-reloaded mem ref,\n \t\t\t   or for unspecified purposes (i.e., more than one\n@@ -159,15 +157,13 @@ rtx reload_out[MAX_RELOADS];\n enum reg_class reload_reg_class[MAX_RELOADS];\n enum machine_mode reload_inmode[MAX_RELOADS];\n enum machine_mode reload_outmode[MAX_RELOADS];\n-char reload_strict_low[MAX_RELOADS];\n rtx reload_reg_rtx[MAX_RELOADS];\n char reload_optional[MAX_RELOADS];\n int reload_inc[MAX_RELOADS];\n rtx reload_in_reg[MAX_RELOADS];\n char reload_nocombine[MAX_RELOADS];\n-int reload_needed_for_multiple[MAX_RELOADS];\n-rtx reload_needed_for[MAX_RELOADS];\n-enum reload_when_needed reload_when_needed[MAX_RELOADS];\n+int reload_opnum[MAX_RELOADS];\n+enum reload_type reload_when_needed[MAX_RELOADS];\n int reload_secondary_reload[MAX_RELOADS];\n int reload_secondary_p[MAX_RELOADS];\n enum insn_code reload_secondary_icode[MAX_RELOADS];\n@@ -177,6 +173,8 @@ enum insn_code reload_secondary_icode[MAX_RELOADS];\n int n_earlyclobbers;\n rtx reload_earlyclobbers[MAX_RECOG_OPERANDS];\n \n+int reload_n_operands;\n+\n /* Replacing reloads.\n \n    If `replace_reloads' is nonzero, then as each reload is recorded\n@@ -202,6 +200,16 @@ static struct replacement replacements[MAX_RECOG_OPERANDS * ((MAX_REGS_PER_ADDRE\n /* Number of replacements currently recorded.  */\n static int n_replacements;\n \n+/* Used to track what is modified by an operand.  */\n+struct decomposition\n+{\n+  int reg_flag;\t\t/* Nonzero if referencing a register. */\n+  int safe;\t\t/* Nonzero if this can't conflict with anything. */\n+  rtx base;\t\t/* Base adddress for MEM. */\n+  HOST_WIDE_INT start;\t/* Starting offset or register number. */\n+  HOST_WIDE_INT end;\t/* Endinf offset or register number.  */\n+};\n+\n /* MEM-rtx's created for pseudo-regs in stack slots not directly addressable;\n    (see reg_equiv_address).  */\n static rtx memlocs[MAX_RECOG_OPERANDS * ((MAX_REGS_PER_ADDRESS * 2) + 1)];\n@@ -212,10 +220,13 @@ static int n_memlocs;\n /* Save MEMs needed to copy from one class of registers to another.  One MEM\n    is used per mode, but normally only one or two modes are ever used.  \n \n-   We keep two versions, before and after register elimination.  */\n+   We keep two versions, before and after register elimination.  The one \n+   after register elimination is record separately for each operand.  This\n+   is done in case the address is not valid to be sure that we separately\n+   reload each.  */\n \n static rtx secondary_memlocs[NUM_MACHINE_MODES];\n-static rtx secondary_memlocs_elim[NUM_MACHINE_MODES];\n+static rtx secondary_memlocs_elim[MAX_RECOG_OPERANDS];\n #endif\n \n /* The instruction we are doing reloads for;\n@@ -243,19 +254,36 @@ static int subst_reg_equivs_changed;\n    operand, which can be different for that from the input operand.  */\n static int output_reloadnum;\n \n-static int alternative_allows_memconst ();\n-static rtx find_dummy_reload ();\n-static rtx find_reloads_toplev ();\n-static int find_reloads_address ();\n-static int find_reloads_address_1 ();\n-static void find_reloads_address_part ();\n-static int hard_reg_set_here_p ();\n-/* static rtx forget_volatility (); */\n-static rtx subst_reg_equivs ();\n-static rtx subst_indexed_address ();\n-void copy_replacements ();\n-rtx find_equiv_reg ();\n-static int find_inc_amount ();\n+static enum reg_class find_secondary_reload PROTO((rtx, enum reg_class,\n+\t\t\t\t\t\t   enum machine_mode, int,\n+\t\t\t\t\t\t   enum insn_code *,\n+\t\t\t\t\t\t   enum machine_mode *,\n+\t\t\t\t\t\t   enum reg_class *,\n+\t\t\t\t\t\t   enum insn_code *,\n+\t\t\t\t\t\t   enum machine_mode *));\n+static int push_reload\t\tPROTO((rtx, rtx, rtx *, rtx *, enum reg_class,\n+\t\t\t\t       enum machine_mode, enum machine_mode,\n+\t\t\t\t       int, int, int, enum reload_type));\n+static void push_replacement\tPROTO((rtx *, int, enum machine_mode));\n+static void combine_reloads\tPROTO((void));\n+static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n+\t\t\t\t       enum reg_class, int));\n+static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n+static struct decomposition decompose PROTO((rtx));\n+static int immune_p\t\tPROTO((rtx, rtx, struct decomposition));\n+static int alternative_allows_memconst PROTO((char *, int));\n+static rtx find_reloads_toplev\tPROTO((rtx, int, enum reload_type, int, int));\n+static rtx make_memloc\t\tPROTO((rtx, int));\n+static int find_reloads_address\tPROTO((enum machine_mode, rtx *, rtx, rtx *,\n+\t\t\t\t       int, enum reload_type, int));\n+static rtx subst_reg_equivs\tPROTO((rtx));\n+static rtx subst_indexed_address PROTO((rtx));\n+static int find_reloads_address_1 PROTO((rtx, int, rtx *, int,\n+\t\t\t\t\t enum reload_type,int));\n+static void find_reloads_address_part PROTO((rtx, rtx *, enum reg_class,\n+\t\t\t\t\t     enum machine_mode, int,\n+\t\t\t\t\t     enum reload_type, int));\n+static int find_inc_amount\tPROTO((rtx, rtx));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n \n@@ -388,9 +416,11 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n    call find_reloads_address on the location being returned.  */\n \n rtx\n-get_secondary_mem (x, mode)\n+get_secondary_mem (x, mode, opnum, type)\n      rtx x;\n      enum machine_mode mode;\n+     int opnum;\n+     enum reload_type type;\n {\n   rtx loc;\n   int mem_valid;\n@@ -404,9 +434,9 @@ get_secondary_mem (x, mode)\n   if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n     mode = mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0);\n \n-  /* If we already have made a MEM for this insn, return it.  */\n-  if (secondary_memlocs_elim[(int) mode] != 0)\n-    return secondary_memlocs_elim[(int) mode];\n+  /* If we already have made a MEM for this operand, return it.  */\n+  if (secondary_memlocs_elim[opnum] != 0)\n+    return secondary_memlocs_elim[opnum];\n \n   /* If this is the first time we've tried to get a MEM for this mode, \n      allocate a new one.  `something_changed' in reload will get set\n@@ -425,25 +455,30 @@ get_secondary_mem (x, mode)\n   /* Get a version of the address doing any eliminations needed.  If that\n      didn't give us a new MEM, make a new one if it isn't valid.  */\n \n-  loc = eliminate_regs (secondary_memlocs[(int) mode], 0, NULL_RTX);\n+  loc = eliminate_regs (secondary_memlocs[(int) mode], VOIDmode, NULL_RTX);\n   mem_valid = strict_memory_address_p (mode, XEXP (loc, 0));\n \n   if (! mem_valid && loc == secondary_memlocs[(int) mode])\n     loc = copy_rtx (loc);\n \n   /* The only time the call below will do anything is if the stack\n      offset is too large.  In that case IND_LEVELS doesn't matter, so we\n-     can just pass a zero.  */\n-  if (! mem_valid)\n-    find_reloads_address (mode, NULL_PTR, XEXP (loc, 0), &XEXP (loc, 0), x, 0);\n+     can just pass a zero.  Adjust the type to be the address of the\n+     corresponding object.  If the address was valid, save the eliminated\n+     address.  If it wasn't valid, we need to make a reload each time, so\n+     don't save it.  */\n \n-  /* If the address was not valid to begin with, we can not save it, because\n-     there is no guarantee that the reloads needed to make it valid will\n-     occur before every use of this address.  */\n+  if (! mem_valid)\n+    {\n+      type =  (type == RELOAD_FOR_INPUT ? RELOAD_FOR_INPUT_ADDRESS\n+\t       : type == RELOAD_FOR_OUTPUT ? RELOAD_FOR_OUTPUT_ADDRESS\n+\t       : RELOAD_OTHER);\n \n-  else\n-    secondary_memlocs_elim[(int) mode] = loc;\n+      find_reloads_address (mode, NULL_PTR, XEXP (loc, 0), &XEXP (loc, 0),\n+\t\t\t    opnum, type, 0);\n+    }\n \n+  secondary_memlocs_elim[opnum] = loc;\n   return loc;\n }\n \n@@ -459,12 +494,15 @@ clear_secondary_mem ()\n }\n #endif /* SECONDARY_MEMORY_NEEDED */\n \f\n-/* Record one (sometimes two) reload that needs to be performed.\n+/* Record one reload that needs to be performed.\n    IN is an rtx saying where the data are to be found before this instruction.\n    OUT says where they must be stored after the instruction.\n    (IN is zero for data not read, and OUT is zero for data not written.)\n    INLOC and OUTLOC point to the places in the instructions where\n    IN and OUT were found.\n+   If IN and OUT are both non-zero, it means the same register must be used\n+   to reload both IN and OUT.\n+\n    CLASS is a register class required for the reloaded data.\n    INMODE is the machine mode that the instruction requires\n    for the reg that replaces IN and OUTMODE is likewise for OUT.\n@@ -477,6 +515,8 @@ clear_secondary_mem ()\n    OPTIONAL nonzero means this reload does not need to be performed:\n    it can be discarded if that is more convenient.\n \n+   OPNUM and TYPE say what the purpose of this reload is.\n+\n    The return value is the reload-number for this reload.\n \n    If both IN and OUT are nonzero, in some rare cases we might\n@@ -489,14 +529,15 @@ clear_secondary_mem ()\n \n static int\n push_reload (in, out, inloc, outloc, class,\n-\t     inmode, outmode, strict_low, optional, needed_for)\n+\t     inmode, outmode, strict_low, optional, opnum, type)\n      register rtx in, out;\n      rtx *inloc, *outloc;\n      enum reg_class class;\n      enum machine_mode inmode, outmode;\n      int strict_low;\n      int optional;\n-     rtx needed_for;\n+     int opnum;\n+     enum reload_type type;\n {\n   register int i;\n   int dont_share = 0;\n@@ -510,6 +551,25 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t? GET_CODE (y) == REG && REGNO (x) == REGNO (y)\t\\\n \t\t\t: rtx_equal_p (x, y) && ! side_effects_p (x))))\n \n+  /* Indicates if two reloads purposes are for similar enough things that we\n+     can merge their reloads.  */\n+#define MERGABLE_RELOADS(when1, when2, op1, op2) \\\n+  ((when1) == RELOAD_OTHER || (when2) == RELOAD_OTHER\t\\\n+   || ((when1) == (when2) && (op1) == (op2))\t\t\\\n+   || ((when1) == RELOAD_FOR_INPUT && (when2) == RELOAD_FOR_INPUT) \\\n+   || ((when1) == RELOAD_FOR_OPERAND_ADDRESS\t\t\\\n+       && (when2) == RELOAD_FOR_OPERAND_ADDRESS)\t\\\n+   || ((when1) == RELOAD_FOR_OTHER_ADDRESS\t\t\\\n+       && (when2) == RELOAD_FOR_OTHER_ADDRESS))\n+\n+  /* Nonzero if these two reload purposes produce RELOAD_OTHER when merged.  */\n+#define MERGE_TO_OTHER(when1, when2, op1, op2) \\\n+  ((when1) != (when2)\t\t\t\t\t\\\n+   || ! ((op1) == (op2)\t\t\t\t\t\\\n+\t || (when1) == RELOAD_FOR_INPUT\t\t\t\\\n+\t || (when1) == RELOAD_FOR_OPERAND_ADDRESS\t\\\n+\t || (when1) == RELOAD_FOR_OTHER_ADDRESS))\n+\n   /* INMODE and/or OUTMODE could be VOIDmode if no mode\n      has been specified for the operand.  In that case,\n      use the operand's mode as the mode to reload.  */\n@@ -649,10 +709,6 @@ push_reload (in, out, inloc, outloc, class,\n       outmode = GET_MODE (out);\n     }\n \n-  /* That's all we use STRICT_LOW for, so clear it.  At some point,\n-     we may want to get rid of reload_strict_low.  */\n-  strict_low = 0;\n-\n   /* If IN appears in OUT, we can't share any input-only reload for IN.  */\n   if (in != 0 && out != 0 && GET_CODE (out) == MEM\n       && (GET_CODE (in) == REG || GET_CODE (in) == MEM)\n@@ -745,11 +801,15 @@ push_reload (in, out, inloc, outloc, class,\n   /* We can use an existing reload if the class is right\n      and at least one of IN and OUT is a match\n      and the other is at worst neutral.\n-     (A zero compared against anything is neutral.)  */\n+     (A zero compared against anything is neutral.) \n+\n+     If SMALL_REGISTER_CLASSES, don't use existing reloads unless they are\n+     for the same thing since that can cause us to need more reload registers\n+     than we otherwise would.  */\n+\n   for (i = 0; i < n_reloads; i++)\n     if ((reg_class_subset_p (class, reload_reg_class[i])\n \t || reg_class_subset_p (reload_reg_class[i], class))\n-\t&& reload_strict_low[i] == strict_low\n \t/* If the existing reload has a register, it must fit our class.  */\n \t&& (reload_reg_rtx[i] == 0\n \t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n@@ -758,7 +818,14 @@ push_reload (in, out, inloc, outloc, class,\n \t     && (out == 0 || reload_out[i] == 0 || MATCHES (reload_out[i], out)))\n \t    ||\n \t    (out != 0 && MATCHES (reload_out[i], out)\n-\t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in)))))\n+\t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in))))\n+\t&& (reg_class_size[(int) class] == 1\n+#ifdef SMALL_REGISTER_CLASSES\n+\t    || 1\n+#endif\n+\t    )\n+\t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n+\t\t\t     opnum, reload_opnum[i]))\n       break;\n \n   /* Reloading a plain reg for input can match a reload to postincrement\n@@ -774,7 +841,6 @@ push_reload (in, out, inloc, outloc, class,\n \t  && (reload_reg_rtx[i] == 0\n \t      || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n \t\t\t\t    true_regnum (reload_reg_rtx[i])))\n-\t  && reload_strict_low[i] == strict_low\n \t  && out == 0 && reload_out[i] == 0 && reload_in[i] != 0\n \t  && ((GET_CODE (in) == REG\n \t       && (GET_CODE (reload_in[i]) == POST_INC\n@@ -788,7 +854,14 @@ push_reload (in, out, inloc, outloc, class,\n \t\t   || GET_CODE (in) == POST_DEC\n \t\t   || GET_CODE (in) == PRE_INC\n \t\t   || GET_CODE (in) == PRE_DEC)\n-\t       && MATCHES (XEXP (in, 0), reload_in[i]))))\n+\t       && MATCHES (XEXP (in, 0), reload_in[i])))\n+\t  && (reg_class_size[(int) class] == 1\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      || 1\n+#endif\n+\t      )\n+\t  && MERGABLE_RELOADS (type, reload_when_needed[i],\n+\t\t\t       opnum, reload_opnum[i]))\n \t{\n \t  /* Make sure reload_in ultimately has the increment,\n \t     not the plain register.  */\n@@ -837,7 +910,9 @@ push_reload (in, out, inloc, outloc, class,\n \n       /* We can only record one secondary and one tertiary reload.  If both\n \t IN and OUT need secondary reloads, we can only make an in-out\n-\t reload if neither need an insn and if the classes are compatible.  */\n+\t reload if neither need an insn and if the classes are compatible.\n+\t If they aren't, all we can do is abort since making two separate\n+\t reloads is invalid.  */\n \n       if (secondary_class != NO_REGS && secondary_out_class != NO_REGS\n \t  && reg_class_subset_p (secondary_out_class, secondary_class))\n@@ -847,13 +922,7 @@ push_reload (in, out, inloc, outloc, class,\n \t  && (! reg_class_subset_p (secondary_class, secondary_out_class)\n \t      || secondary_icode != CODE_FOR_nothing\n \t      || secondary_out_icode != CODE_FOR_nothing))\n-\t{\n-\t  push_reload (NULL_RTX, out, NULL_PTR, outloc, class,\n-\t\t       VOIDmode, outmode, strict_low, optional, needed_for);\n-\t  out = 0;\n-\t  outloc = 0;\n-\t  outmode = VOIDmode;\n-\t}\n+\tabort ();\n \n       /* If we need a secondary reload for OUT but not IN, copy the\n \t information.  */\n@@ -868,6 +937,18 @@ push_reload (in, out, inloc, outloc, class,\n \n       if (secondary_class != NO_REGS)\n \t{\n+\t  /* Secondary reloads don't conflict as badly as the primary object\n+\t     being reload.  Specifically, we can always treat them as\n+\t     being for an input or output address and hence allowed to be\n+\t     reused in the same manner such address components could be\n+\t     reused.  This is used as the reload_type for our secondary\n+\t     reloads.  */\n+\n+\t  enum reload_type secondary_type\n+\t    = (type == RELOAD_FOR_INPUT ? RELOAD_FOR_INPUT_ADDRESS\n+\t       : type == RELOAD_FOR_OUTPUT ? RELOAD_FOR_OUTPUT_ADDRESS\n+\t       : type);\n+\n \t  /* If we need a tertiary reload, see if we have one we can reuse\n \t     or else make one.  */\n \n@@ -885,8 +966,15 @@ push_reload (in, out, inloc, outloc, class,\n \t\t    && ((reload_outmode[tertiary_reload] == tertiary_mode)\n \t\t\t|| reload_outmode[tertiary_reload] == VOIDmode)\n \t\t    && (reload_secondary_icode[tertiary_reload]\n-\t\t\t== CODE_FOR_nothing))\n-\t\t    \n+\t\t\t== CODE_FOR_nothing)\n+\t\t    && (reg_class_size[(int) tertiary_class] == 1\n+#ifdef SMALL_REGISTER_CLASSES\n+\t\t\t|| 1\n+#endif\n+\t\t\t)\n+\t\t    && MERGABLE_RELOADS (secondary_type,\n+\t\t\t\t\t reload_when_needed[tertiary_reload],\n+\t\t\t\t\t opnum, reload_opnum[tertiary_reload]))\n \t\t  {\n \t\t    if (tertiary_mode != VOIDmode)\n \t\t      reload_inmode[tertiary_reload] = tertiary_mode;\n@@ -895,8 +983,13 @@ push_reload (in, out, inloc, outloc, class,\n \t\t    if (reg_class_subset_p (tertiary_class,\n \t\t\t\t\t    reload_reg_class[tertiary_reload]))\n \t\t      reload_reg_class[tertiary_reload] = tertiary_class;\n-\t\t    if (reload_needed_for[tertiary_reload] != needed_for)\n-\t\t      reload_needed_for_multiple[tertiary_reload] = 1;\n+\t\t    if (MERGE_TO_OTHER (secondary_type,\n+\t\t\t\t\treload_when_needed[tertiary_reload],\n+\t\t\t\t\topnum,\n+\t\t\t\t\treload_opnum[tertiary_reload]))\n+\t\t      reload_when_needed[tertiary_reload] = RELOAD_OTHER;\n+\t\t    reload_opnum[tertiary_reload]\n+\t\t      = MIN (reload_opnum[tertiary_reload], opnum);\n \t\t    reload_optional[tertiary_reload] &= optional;\n \t\t    reload_secondary_p[tertiary_reload] = 1;\n \t\t  }\n@@ -912,12 +1005,11 @@ push_reload (in, out, inloc, outloc, class,\n \t\t  reload_reg_rtx[tertiary_reload] = 0;\n \t\t  reload_optional[tertiary_reload] = optional;\n \t\t  reload_inc[tertiary_reload] = 0;\n-\t\t  reload_strict_low[tertiary_reload] = 0;\n \t\t  /* Maybe we could combine these, but it seems too tricky.  */\n \t\t  reload_nocombine[tertiary_reload] = 1;\n \t\t  reload_in_reg[tertiary_reload] = 0;\n-\t\t  reload_needed_for[tertiary_reload] = needed_for;\n-\t\t  reload_needed_for_multiple[tertiary_reload] = 0;\n+\t\t  reload_opnum[tertiary_reload] = opnum;\n+\t\t  reload_when_needed[tertiary_reload] = secondary_type;\n \t\t  reload_secondary_reload[tertiary_reload] = -1;\n \t\t  reload_secondary_icode[tertiary_reload] = CODE_FOR_nothing;\n \t\t  reload_secondary_p[tertiary_reload] = 1;\n@@ -940,7 +1032,15 @@ push_reload (in, out, inloc, outloc, class,\n \t\t&& ((reload_outmode[secondary_reload] == secondary_out_mode)\n \t\t    || reload_outmode[secondary_reload] == VOIDmode)\n \t\t&& reload_secondary_reload[secondary_reload] == tertiary_reload\n-\t\t&& reload_secondary_icode[secondary_reload] == tertiary_icode)\n+\t\t&& reload_secondary_icode[secondary_reload] == tertiary_icode\n+\t\t&& (reg_class_size[(int) secondary_class] == 1\n+#ifdef SMALL_REGISTER_CLASSES\n+\t\t    || 1\n+#endif\n+\t\t    )\n+\t\t&& MERGABLE_RELOADS (secondary_type,\n+\t\t\t\t     reload_when_needed[secondary_reload],\n+\t\t\t\t     opnum, reload_opnum[secondary_reload]))\n \t      {\n \t\tif (secondary_mode != VOIDmode)\n \t\t  reload_inmode[secondary_reload] = secondary_mode;\n@@ -949,8 +1049,12 @@ push_reload (in, out, inloc, outloc, class,\n \t\tif (reg_class_subset_p (secondary_class,\n \t\t\t\t\treload_reg_class[secondary_reload]))\n \t\t  reload_reg_class[secondary_reload] = secondary_class;\n-\t\tif (reload_needed_for[secondary_reload] != needed_for)\n-\t\t  reload_needed_for_multiple[secondary_reload] = 1;\n+\t\tif (MERGE_TO_OTHER (secondary_type,\n+\t\t\t\t    reload_when_needed[secondary_reload],\n+\t\t\t\t    opnum, reload_opnum[secondary_reload]))\n+\t\t  reload_when_needed[secondary_reload] = RELOAD_OTHER;\n+\t\treload_opnum[secondary_reload]\n+\t\t  = MIN (reload_opnum[secondary_reload], opnum);\n \t\treload_optional[secondary_reload] &= optional;\n \t\treload_secondary_p[secondary_reload] = 1;\n \t      }\n@@ -966,12 +1070,11 @@ push_reload (in, out, inloc, outloc, class,\n \t      reload_reg_rtx[secondary_reload] = 0;\n \t      reload_optional[secondary_reload] = optional;\n \t      reload_inc[secondary_reload] = 0;\n-\t      reload_strict_low[secondary_reload] = 0;\n \t      /* Maybe we could combine these, but it seems too tricky.  */\n \t      reload_nocombine[secondary_reload] = 1;\n \t      reload_in_reg[secondary_reload] = 0;\n-\t      reload_needed_for[secondary_reload] = needed_for;\n-\t      reload_needed_for_multiple[secondary_reload] = 0;\n+\t      reload_opnum[secondary_reload] = opnum;\n+\t      reload_when_needed[secondary_reload] = secondary_type;\n \t      reload_secondary_reload[secondary_reload] = tertiary_reload;\n \t      reload_secondary_icode[secondary_reload] = tertiary_icode;\n \t      reload_secondary_p[secondary_reload] = 1;\n@@ -985,11 +1088,11 @@ push_reload (in, out, inloc, outloc, class,\n \n \t      if (in != 0 && secondary_icode == CODE_FOR_nothing\n \t\t  && SECONDARY_MEMORY_NEEDED (secondary_class, class, inmode))\n-\t\tget_secondary_mem (in, inmode);\n+\t\tget_secondary_mem (in, inmode, opnum, type);\n \n \t      if (out != 0 && secondary_icode == CODE_FOR_nothing\n \t\t  && SECONDARY_MEMORY_NEEDED (class, secondary_class, outmode))\n-\t\tget_secondary_mem (out, outmode);\n+\t\tget_secondary_mem (out, outmode, opnum, type);\n #endif\n \t    }\n \t}\n@@ -1006,11 +1109,10 @@ push_reload (in, out, inloc, outloc, class,\n       reload_reg_rtx[i] = 0;\n       reload_optional[i] = optional;\n       reload_inc[i] = 0;\n-      reload_strict_low[i] = strict_low;\n       reload_nocombine[i] = 0;\n       reload_in_reg[i] = inloc ? *inloc : 0;\n-      reload_needed_for[i] = needed_for;\n-      reload_needed_for_multiple[i] = 0;\n+      reload_opnum[i] = opnum;\n+      reload_when_needed[i] = type;\n       reload_secondary_reload[i] = secondary_reload;\n       reload_secondary_icode[i] = secondary_icode;\n       reload_secondary_p[i] = 0;\n@@ -1023,13 +1125,13 @@ push_reload (in, out, inloc, outloc, class,\n \t  && REGNO (in) < FIRST_PSEUDO_REGISTER\n \t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (in)),\n \t\t\t\t     class, inmode))\n-\tget_secondary_mem (in, inmode);\n+\tget_secondary_mem (in, inmode, opnum, type);\n \n       if (out != 0 && GET_CODE (out) == REG\n \t  && REGNO (out) < FIRST_PSEUDO_REGISTER\n \t  && SECONDARY_MEMORY_NEEDED (class, REGNO_REG_CLASS (REGNO (out)),\n \t\t\t\t      outmode))\n-\tget_secondary_mem (out, outmode);\n+\tget_secondary_mem (out, outmode, opnum, type);\n #endif\n     }\n   else\n@@ -1050,8 +1152,10 @@ push_reload (in, out, inloc, outloc, class,\n       if (reg_class_subset_p (class, reload_reg_class[i]))\n \treload_reg_class[i] = class;\n       reload_optional[i] &= optional;\n-      if (reload_needed_for[i] != needed_for)\n-\treload_needed_for_multiple[i] = 1;\n+      if (MERGE_TO_OTHER (type, reload_when_needed[i],\n+\t\t\t  opnum, reload_opnum[i]))\n+\treload_when_needed[i] = RELOAD_OTHER;\n+      reload_opnum[i] = MIN (reload_opnum[i], opnum);\n     }\n \n   /* If the ostensible rtx being reload differs from the rtx found\n@@ -1205,6 +1309,20 @@ push_replacement (loc, reloadnum, mode)\n     }\n }\n \f\n+/* Transfer all replacements that used to be in reload FROM to be in\n+   reload TO.  */\n+\n+void\n+transfer_replacements (to, from)\n+     int to, from;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_replacements; i++)\n+    if (replacements[i].what == from)\n+      replacements[i].what = to;\n+}\n+\f\n /* If there is only one output reload, and it is not for an earlyclobber\n    operand, try to combine it with a (logically unrelated) input reload\n    to reduce the number of reload registers needed.\n@@ -1254,20 +1372,32 @@ combine_reloads ()\n   for (i = 0; i < n_reloads; i++)\n     if (reload_in[i] && ! reload_optional[i] && ! reload_nocombine[i]\n \t/* Life span of this reload must not extend past main insn.  */\n-\t&& reload_when_needed[i] != RELOAD_FOR_OUTPUT_RELOAD_ADDRESS\n-\t&& ! reload_needed_for_multiple[i]\n-\t&& reload_inmode[i] == reload_outmode[output_reload]\n+\t&& reload_when_needed[i] != RELOAD_FOR_OUTPUT_ADDRESS\n+\t&& reload_when_needed[i] != RELOAD_OTHER\n+\t&& (CLASS_MAX_NREGS (reload_reg_class[i], reload_inmode[i])\n+\t    == CLASS_MAX_NREGS (reload_reg_class[output_reload],\n+\t\t\t\treload_outmode[output_reload]))\n \t&& reload_inc[i] == 0\n \t&& reload_reg_rtx[i] == 0\n-\t&& reload_strict_low[i] == 0\n \t/* Don't combine two reloads with different secondary reloads. */\n \t&& (reload_secondary_reload[i] == reload_secondary_reload[output_reload]\n \t    || reload_secondary_reload[i] == -1\n \t    || reload_secondary_reload[output_reload] == -1)\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t/* Likewise for different secondary memory locations.  */\n+\t&& (secondary_memlocs_elim[reload_opnum[i]] == 0\n+\t    || secondary_memlocs_elim[reload_opnum[output_reload]] == 0\n+\t    || rtx_equal_p (secondary_memlocs_elim[reload_opnum[i]],\n+\t\t\t    secondary_memlocs_elim[reload_opnum[output_reload]]))\n+#endif\n+#ifdef SMALL_REGISTER_CLASSES\n+\t&& reload_reg_class[i] == reload_reg_class[output_reload]\n+#else\n \t&& (reg_class_subset_p (reload_reg_class[i],\n \t\t\t\treload_reg_class[output_reload])\n \t    || reg_class_subset_p (reload_reg_class[output_reload],\n \t\t\t\t   reload_reg_class[i]))\n+#endif\n \t&& (MATCHES (reload_in[i], reload_out[output_reload])\n \t    /* Args reversed because the first arg seems to be\n \t       the one that we imagine being modified\n@@ -1282,7 +1412,16 @@ combine_reloads ()\n \t\t   will clobber the address of the memory ref.  */\n \t\t&& ! (GET_CODE (reload_in[i]) == REG\n \t\t      && reg_overlap_mentioned_for_reload_p (reload_in[i],\n-\t\t\t\t\t\t\t     reload_out[output_reload])))))\n+\t\t\t\t\t\t\t     reload_out[output_reload]))))\n+\t&& (reg_class_size[(int) reload_reg_class[i]]\n+#ifdef SMALL_REGISTER_CLASSES\n+\t     || 1\n+#endif\n+\t    )\n+\t/* We will allow making things slightly worse by combining an\n+\t   input and an output, but no worse than that.  */\n+\t&& (reload_when_needed[i] == RELOAD_FOR_INPUT\n+\t    || reload_when_needed[i] == RELOAD_FOR_OUTPUT))\n       {\n \tint j;\n \n@@ -1292,11 +1431,16 @@ combine_reloads ()\n \t/* Mark the old output reload as inoperative.  */\n \treload_out[output_reload] = 0;\n \t/* The combined reload is needed for the entire insn.  */\n-\treload_needed_for_multiple[i] = 1;\n \treload_when_needed[i] = RELOAD_OTHER;\n \t/* If the output reload had a secondary reload, copy it. */\n \tif (reload_secondary_reload[output_reload] != -1)\n \t  reload_secondary_reload[i] = reload_secondary_reload[output_reload];\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t/* Copy any secondary MEM.  */\n+\tif (secondary_memlocs_elim[reload_opnum[output_reload]] != 0)\n+\t  secondary_memlocs_elim[reload_opnum[i]]\n+\t    = secondary_memlocs_elim[reload_opnum[output_reload]];\n+#endif\n \t/* If required, minimize the register class. */\n \tif (reg_class_subset_p (reload_reg_class[output_reload],\n \t\t\t\treload_reg_class[i]))\n@@ -1544,7 +1688,6 @@ strict_memory_address_p (mode, addr)\n  win:\n   return 1;\n }\n-\n \f\n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n    if they are the same hard reg, and has special hacks for\n@@ -1698,15 +1841,6 @@ n_occurrences (c, s)\n   return n;\n }\n \f\n-struct decomposition\n-{\n-  int reg_flag;\n-  int safe;\n-  rtx base;\n-  HOST_WIDE_INT start;\n-  HOST_WIDE_INT end;\n-};\n-\n /* Describe the range of registers or memory referenced by X.\n    If X is a register, set REG_FLAG and put the first register \n    number into START and the last plus one into END.\n@@ -1919,14 +2053,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      int live_known;\n      short *reload_reg_p;\n {\n-  rtx non_reloaded_operands[MAX_RECOG_OPERANDS];\n-  int n_non_reloaded_operands = 0;\n #ifdef REGISTER_CONSTRAINTS\n \n-  enum reload_modified { RELOAD_NOTHING, RELOAD_READ, RELOAD_READ_WRITE, RELOAD_WRITE };\n-\n   register int insn_code_number;\n-  register int i;\n+  register int i, j;\n   int noperands;\n   /* These are the constraints for the insn.  We don't change them.  */\n   char *constraints1[MAX_RECOG_OPERANDS];\n@@ -1939,6 +2069,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   char pref_or_nothing[MAX_RECOG_OPERANDS];\n   /* Nonzero for a MEM operand whose entire address needs a reload.  */\n   int address_reloaded[MAX_RECOG_OPERANDS];\n+  /* Value of enum reload_type to use for operand.  */\n+  enum reload_type operand_type[MAX_RECOG_OPERANDS];\n+  /* Value of enum reload_type to use within address of operand.  */\n+  enum reload_type address_type[MAX_RECOG_OPERANDS];\n+  /* Save the usage of each operand.  */\n+  enum reload_usage { RELOAD_READ, RELOAD_READ_WRITE, RELOAD_WRITE } modified[MAX_RECOG_OPERANDS];\n   int no_input_reloads = 0, no_output_reloads = 0;\n   int n_alternatives;\n   int this_alternative[MAX_RECOG_OPERANDS];\n@@ -1957,7 +2093,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   char goal_alternative_offmemok[MAX_RECOG_OPERANDS];\n   char goal_alternative_earlyclobber[MAX_RECOG_OPERANDS];\n   int goal_alternative_swapped;\n-  enum reload_modified modified[MAX_RECOG_OPERANDS];\n   int best;\n   int commutative;\n   char operands_match[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n@@ -2027,7 +2162,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \treturn;\n     case PARALLEL:\n     case ASM_OPERANDS:\n-      noperands = asm_noperands (body);\n+      reload_n_operands = noperands = asm_noperands (body);\n       if (noperands >= 0)\n \t{\n \t  /* This insn is an `asm' with operands.  */\n@@ -2068,7 +2203,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       if (insn_code_number < 0)\n \tfatal_insn_not_found (insn);\n \n-      noperands = insn_n_operands[insn_code_number];\n+      reload_n_operands = noperands = insn_n_operands[insn_code_number];\n       n_alternatives = insn_n_alternatives[insn_code_number];\n       /* Just return \"no reloads\" if insn has no operands with constraints.  */\n       if (n_alternatives == 0)\n@@ -2100,65 +2235,73 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       substed_operand[i] = recog_operand[i];\n       p = constraints[i];\n \n-      /* Scan this operand's constraint to see if it should match another.  */\n+      modified[i] = RELOAD_READ;\n+\n+      /* Scan this operand's constraint to see if it is an output operand, \n+\t an in-out operand, is commutative, or should match another.  */\n \n       while (c = *p++)\n-\tif (c == '%')\n-\t  {\n-\t    /* The last operand should not be marked commutative.  */\n-\t    if (i == noperands - 1)\n-\t      {\n-\t\tif (this_insn_is_asm)\n-\t\t  warning_for_asm (this_insn,\n-\t\t\t\t   \"`%%' constraint used with last operand\");\n-\t\telse\n-\t\t  abort ();\n-\t      }\n-\t    else\n-\t      commutative = i;\n-\t  }\n-\telse if (c >= '0' && c <= '9')\n-\t  {\n-\t    c -= '0';\n-\t    operands_match[c][i]\n-\t      = operands_match_p (recog_operand[c], recog_operand[i]);\n+\t{\n+\t  if (c == '=')\n+\t    modified[i] = RELOAD_WRITE;\n+\t  else if (c == '+')\n+\t    modified[i] = RELOAD_READ_WRITE;\n+\t  else if (c == '%')\n+\t    {\n+\t      /* The last operand should not be marked commutative.  */\n+\t      if (i == noperands - 1)\n+\t\t{\n+\t\t  if (this_insn_is_asm)\n+\t\t    warning_for_asm (this_insn,\n+\t\t\t\t     \"`%%' constraint used with last operand\");\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t      else\n+\t\tcommutative = i;\n+\t    }\n+\t  else if (c >= '0' && c <= '9')\n+\t    {\n+\t      c -= '0';\n+\t      operands_match[c][i]\n+\t\t= operands_match_p (recog_operand[c], recog_operand[i]);\n \n-\t    /* An operand may not match itself.  */\n-\t    if (c == i)\n-\t      {\n-\t\tif (this_insn_is_asm)\n-\t\t  warning_for_asm (this_insn,\n-\t\t\t\t   \"operand %d has constraint %d\", i, c);\n-\t\telse\n-\t\t  abort ();\n-\t      }\n+\t      /* An operand may not match itself.  */\n+\t      if (c == i)\n+\t\t{\n+\t\t  if (this_insn_is_asm)\n+\t\t    warning_for_asm (this_insn,\n+\t\t\t\t     \"operand %d has constraint %d\", i, c);\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n \n-\t    /* If C can be commuted with C+1, and C might need to match I,\n-\t       then C+1 might also need to match I.  */\n-\t    if (commutative >= 0)\n-\t      {\n-\t\tif (c == commutative || c == commutative + 1)\n-\t\t  {\n-\t\t    int other = c + (c == commutative ? 1 : -1);\n-\t\t    operands_match[other][i]\n-\t\t      = operands_match_p (recog_operand[other], recog_operand[i]);\n-\t\t  }\n-\t\tif (i == commutative || i == commutative + 1)\n-\t\t  {\n-\t\t    int other = i + (i == commutative ? 1 : -1);\n-\t\t    operands_match[c][other]\n-\t\t      = operands_match_p (recog_operand[c], recog_operand[other]);\n-\t\t  }\n-\t\t/* Note that C is supposed to be less than I.\n-\t\t   No need to consider altering both C and I\n-\t\t   because in that case we would alter one into the other.  */\n-\t      }\n-\t  }\n+\t      /* If C can be commuted with C+1, and C might need to match I,\n+\t\t then C+1 might also need to match I.  */\n+\t      if (commutative >= 0)\n+\t\t{\n+\t\t  if (c == commutative || c == commutative + 1)\n+\t\t    {\n+\t\t      int other = c + (c == commutative ? 1 : -1);\n+\t\t      operands_match[other][i]\n+\t\t\t= operands_match_p (recog_operand[other], recog_operand[i]);\n+\t\t    }\n+\t\t  if (i == commutative || i == commutative + 1)\n+\t\t    {\n+\t\t      int other = i + (i == commutative ? 1 : -1);\n+\t\t      operands_match[c][other]\n+\t\t\t= operands_match_p (recog_operand[c], recog_operand[other]);\n+\t\t    }\n+\t\t  /* Note that C is supposed to be less than I.\n+\t\t     No need to consider altering both C and I because in\n+\t\t     that case we would alter one into the other.  */\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   /* Examine each operand that is a memory reference or memory address\n      and reload parts of the addresses into index registers.\n-     While we are at it, initialize the array `modified'.\n      Also here any references to pseudo regs that didn't get hard regs\n      but are equivalent to constants get replaced in the insn itself\n      with those constants.  Nobody will ever see them again. \n@@ -2168,14 +2311,21 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   for (i = 0; i < noperands; i++)\n     {\n       register RTX_CODE code = GET_CODE (recog_operand[i]);\n-      modified[i] = RELOAD_READ;\n+\n       address_reloaded[i] = 0;\n+      operand_type[i] = (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT\n+\t\t\t : modified[i] == RELOAD_WRITE ? RELOAD_FOR_OUTPUT\n+\t\t\t : RELOAD_OTHER);\n+      address_type[i]\n+\t= (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT_ADDRESS\n+\t   : modified[i] == RELOAD_WRITE ? RELOAD_FOR_OUTPUT_ADDRESS\n+\t   : RELOAD_OTHER);\n \n       if (constraints[i][0] == 'p')\n \t{\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n-\t\t\t\trecog_operand[i], ind_levels);\n+\t\t\t\ti, operand_type[i], ind_levels);\n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t}\n       else if (code == MEM)\n@@ -2184,13 +2334,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t    recog_operand_loc[i],\n \t\t\t\t    XEXP (recog_operand[i], 0),\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n-\t\t\t\t    recog_operand[i], ind_levels))\n+\t\t\t\t    i, address_type[i], ind_levels))\n \t    address_reloaded[i] = 1;\n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t}\n       else if (code == SUBREG)\n \tsubsted_operand[i] = recog_operand[i] = *recog_operand_loc[i]\n-\t  = find_reloads_toplev (recog_operand[i], ind_levels,\n+\t  = find_reloads_toplev (recog_operand[i], i, address_type[i],\n+\t\t\t\t ind_levels,\n \t\t\t\t set != 0\n \t\t\t\t && &SET_DEST (set) == recog_operand_loc[i]);\n       else if (code == REG)\n@@ -2222,11 +2373,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\taddress = copy_rtx (address);\n \n \t      /* If this is an output operand, we must output a CLOBBER\n-\t\t after INSN so find_equiv_reg knows REGNO is being written. */\n-\t      if (constraints[i][0] == '='\n-\t\t  || constraints[i][0] == '+')\n-\t\temit_insn_after (gen_rtx (CLOBBER, VOIDmode, recog_operand[i]),\n-\t\t\t\t insn);\n+\t\t after INSN so find_equiv_reg knows REGNO is being written. \n+\t\t Mark this insn specially, do we can put our output reloads\n+\t\t after it.  */\n+\n+\t      if (modified[i] != RELOAD_READ)\n+\t\tPUT_MODE (emit_insn_after (gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t\t    recog_operand[i]),\n+\t\t\t\t\t   insn),\n+\t\t\t  DImode);\n \n \t      *recog_operand_loc[i] = recog_operand[i]\n \t\t= gen_rtx (MEM, GET_MODE (recog_operand[i]), address);\n@@ -2236,7 +2391,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t    recog_operand_loc[i],\n \t\t\t\t    XEXP (recog_operand[i], 0),\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n-\t\t\t\t    recog_operand[i], ind_levels);\n+\t\t\t\t    i, address_type[i], ind_levels);\n \t      substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t    }\n \t}\n@@ -2378,13 +2533,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    switch (c)\n \t      {\n \t      case '=':\n-\t\tmodified[i] = RELOAD_WRITE;\n-\t\tbreak;\n-\n \t      case '+':\n-\t\tmodified[i] = RELOAD_READ_WRITE;\n-\t\tbreak;\n-\n \t      case '*':\n \t\tbreak;\n \n@@ -2685,8 +2834,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      /* Alternative loses if it requires a type of reload not\n \t\t permitted for this insn.  We can always reload SCRATCH\n \t\t and objects with a REG_UNUSED note.  */\n-\t      if (GET_CODE (operand) != SCRATCH && modified[i] != RELOAD_READ\n-\t\t  && no_output_reloads\n+\t      if (GET_CODE (operand) != SCRATCH\n+\t\t  && modified[i] != RELOAD_READ && no_output_reloads\n \t\t  && ! find_reg_note (insn, REG_UNUSED, operand))\n \t\tbad = 1;\n \t      else if (modified[i] != RELOAD_WRITE && no_input_reloads)\n@@ -2754,7 +2903,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    && this_alternative_win[i])\n \t  {\n \t    struct decomposition early_data; \n-\t    int j;\n \n \t    early_data = decompose (recog_operand[i]);\n \n@@ -2947,7 +3095,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       goal_alternative_matched[goal_alternative_matches[i]] = i;\n \n   /* If the best alternative is with operands 1 and 2 swapped,\n-     consider them swapped before reporting the reloads.  */\n+     consider them swapped before reporting the reloads.  Update the\n+     operand numbers of any reloads already pushed.  */\n \n   if (goal_alternative_swapped)\n     {\n@@ -2959,6 +3108,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       tem = recog_operand[commutative];\n       recog_operand[commutative] = recog_operand[commutative + 1];\n       recog_operand[commutative + 1] = tem;\n+\n+      for (i = 0; i < n_reloads; i++)\n+\t{\n+\t  if (reload_opnum[i] == commutative)\n+\t    reload_opnum[i] = commutative + 1;\n+\t  else if (reload_opnum[i] == commutative + 1)\n+\t    reload_opnum[i] = commutative;\n+\t}\n     }\n \n   /* Perform whatever substitutions on the operands we are supposed\n@@ -2970,6 +3127,26 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       *recog_operand_loc[i] = substed_operand[i];\n       /* While we are looping on operands, initialize this.  */\n       operand_reloadnum[i] = -1;\n+\n+      /* If this is an earlyclobber operand, we need to widen the scope.\n+\t The reload must remain valid from the start of the insn being\n+\t reloaded until after the operand is stored into its destination.\n+\t We approximate this with RELOAD_OTHER even though we know that we\n+\t do not conflict with RELOAD_FOR_INPUT_ADDRESS reloads.\n+\n+\t One special case that is worth checking is when we have an\n+\t output that is earlyclobber but isn't used past the insn (typically\n+\t a SCRATCH).  In this case, we only need have the reload live \n+\t through the insn itself, but not for any of our input or output\n+\t reloads. \n+\n+\t In any case, anything needed to address this operand can remain\n+\t however they were previously categorized.  */\n+\n+      if (goal_alternative_earlyclobber[i])\n+\toperand_type[i]\n+\t  = (find_reg_note (insn, REG_UNUSED, recog_operand[i])\n+\t     ? RELOAD_FOR_INSN : RELOAD_OTHER);\n     }\n \n   /* Any constants that aren't allowed and can't be reloaded\n@@ -2985,7 +3162,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t*recog_operand_loc[i] = recog_operand[i]\n \t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n \t\t\t\t\t\t  recog_operand[i]),\n-\t\t\t\t ind_levels, 0);\n+\t\t\t\t i, address_type[i], ind_levels, 0);\n \tif (alternative_allows_memconst (constraints1[i],\n \t\t\t\t\t goal_alternative_number))\n \t  goal_alternative_win[i] = 1;\n@@ -3009,22 +3186,36 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      = push_reload (XEXP (recog_operand[i], 0), NULL_RTX,\n \t\t\t     &XEXP (recog_operand[i], 0), NULL_PTR,\n \t\t\t     BASE_REG_CLASS, GET_MODE (XEXP (recog_operand[i], 0)),\n-\t\t\t     VOIDmode, 0, 0, NULL_RTX);\n+\t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n \t    reload_inc[operand_reloadnum[i]]\n \t      = GET_MODE_SIZE (GET_MODE (recog_operand[i]));\n+\n+\t    /* If this operand is an output, we will have made any\n+\t       reloads for its address as RELOAD_FOR_OUTPUT_ADDRESS, but\n+\t       now we are treating part of the operand as an input, so\n+\t       we must change these to RELOAD_FOR_INPUT_ADDRESS.  */\n+\n+\t    if (operand_type[i] == RELOAD_FOR_OUTPUT)\n+\t      for (j = 0; j < n_reloads; j++)\n+\t\tif (reload_opnum[j] == i\n+\t\t    && reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t\t  reload_when_needed[j] = RELOAD_FOR_INPUT_ADDRESS;\n \t  }\n \telse if (goal_alternative_matched[i] == -1)\n \t  operand_reloadnum[i] =\n \t    push_reload (modified[i] != RELOAD_WRITE ? recog_operand[i] : 0,\n \t\t\t modified[i] != RELOAD_READ ? recog_operand[i] : 0,\n-\t\t\t modified[i] != RELOAD_WRITE ? recog_operand_loc[i] : 0,\n+\t\t\t (modified[i] != RELOAD_WRITE ?\n+\t\t\t  recog_operand_loc[i] : 0),\n \t\t\t modified[i] != RELOAD_READ ? recog_operand_loc[i] : 0,\n \t\t\t (enum reg_class) goal_alternative[i],\n-\t\t\t (modified[i] == RELOAD_WRITE ? VOIDmode : operand_mode[i]),\n-\t\t\t (modified[i] == RELOAD_READ ? VOIDmode : operand_mode[i]),\n+\t\t\t (modified[i] == RELOAD_WRITE\n+\t\t\t  ? VOIDmode : operand_mode[i]),\n+\t\t\t (modified[i] == RELOAD_READ\n+\t\t\t  ? VOIDmode : operand_mode[i]),\n \t\t\t (insn_code_number < 0 ? 0\n \t\t\t  : insn_operand_strict_low[insn_code_number][i]),\n-\t\t\t 0, NULL_RTX);\n+\t\t\t 0, i, operand_type[i]);\n \t/* In a matching pair of operands, one must be input only\n \t   and the other must be output only.\n \t   Pass the input operand as IN and the other as OUT.  */\n@@ -3039,7 +3230,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     operand_mode[i],\n \t\t\t     operand_mode[goal_alternative_matched[i]],\n-\t\t\t     0, 0, NULL_RTX);\n+\t\t\t     0, 0, i, RELOAD_OTHER);\n \t    operand_reloadnum[goal_alternative_matched[i]] = output_reloadnum;\n \t  }\n \telse if (modified[i] == RELOAD_WRITE\n@@ -3053,7 +3244,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     operand_mode[goal_alternative_matched[i]],\n \t\t\t     operand_mode[i],\n-\t\t\t     0, 0, NULL_RTX);\n+\t\t\t     0, 0, i, RELOAD_OTHER);\n \t    operand_reloadnum[i] = output_reloadnum;\n \t  }\n \telse if (insn_code_number >= 0)\n@@ -3071,58 +3262,70 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     && goal_alternative_matches[i] < 0\n \t     && optimize)\n       {\n-\trtx operand = recog_operand[i];\n-\t/* For each non-matching operand that's a pseudo-register \n+\t/* For each non-matching operand that's a MEM or a pseudo-register \n \t   that didn't get a hard register, make an optional reload.\n \t   This may get done even if the insn needs no reloads otherwise.  */\n-\t/* (It would be safe to make an optional reload for a matching pair\n-\t   of operands, but we don't bother yet.)  */\n+\n+\trtx operand = recog_operand[i];\n+\n \twhile (GET_CODE (operand) == SUBREG)\n \t  operand = XEXP (operand, 0);\n-\tif (GET_CODE (operand) == REG\n-\t    && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t    && reg_renumber[REGNO (operand)] < 0\n+\tif ((GET_CODE (operand) == MEM\n+\t     || (GET_CODE (operand) == REG\n+\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n \t    && (enum reg_class) goal_alternative[i] != NO_REGS\n-\t    /* Don't make optional output reloads for jump insns\n-\t       (such as aobjeq on the vax).  */\n+\t    && ! no_input_reloads\n+\t    /* Optional output reloads don't do anything and we mustn't\n+\t       make in-out reloads on insns that are not permitted output\n+\t       reloads.  */\n \t    && (modified[i] == RELOAD_READ\n-\t\t|| GET_CODE (insn) != JUMP_INSN))\n+\t\t|| (modified[i] == RELOAD_READ_WRITE && ! no_output_reloads)))\n \t  operand_reloadnum[i]\n \t    = push_reload (modified[i] != RELOAD_WRITE ? recog_operand[i] : 0,\n \t\t\t   modified[i] != RELOAD_READ ? recog_operand[i] : 0,\n-\t\t\t   modified[i] != RELOAD_WRITE ? recog_operand_loc[i] : 0,\n-\t\t\t   modified[i] != RELOAD_READ ? recog_operand_loc[i] : 0,\n+\t\t\t   (modified[i] != RELOAD_WRITE\n+\t\t\t    ? recog_operand_loc[i] : 0),\n+\t\t\t   (modified[i] != RELOAD_READ\n+\t\t\t    ? recog_operand_loc[i] : 0),\n \t\t\t   (enum reg_class) goal_alternative[i],\n-\t\t\t   (modified[i] == RELOAD_WRITE ? VOIDmode : operand_mode[i]),\n-\t\t\t   (modified[i] == RELOAD_READ ? VOIDmode : operand_mode[i]),\n+\t\t\t   (modified[i] == RELOAD_WRITE\n+\t\t\t    ? VOIDmode : operand_mode[i]),\n+\t\t\t   (modified[i] == RELOAD_READ\n+\t\t\t    ? VOIDmode : operand_mode[i]),\n \t\t\t   (insn_code_number < 0 ? 0\n \t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n-\t\t\t   1, NULL_RTX);\n-\t/* Make an optional reload for an explicit mem ref.  */\n-\telse if (GET_CODE (operand) == MEM\n-\t\t && (enum reg_class) goal_alternative[i] != NO_REGS\n-\t\t /* Don't make optional output reloads for jump insns\n-\t\t    (such as aobjeq on the vax).  */\n-\t\t && (modified[i] == RELOAD_READ\n-\t\t     || GET_CODE (insn) != JUMP_INSN))\n-\t  operand_reloadnum[i]\n-\t    = push_reload (modified[i] != RELOAD_WRITE ? recog_operand[i] : 0,\n-\t\t\t   modified[i] != RELOAD_READ ? recog_operand[i] : 0,\n-\t\t\t   modified[i] != RELOAD_WRITE ? recog_operand_loc[i] : 0,\n-\t\t\t   modified[i] != RELOAD_READ ? recog_operand_loc[i] : 0,\n-\t\t\t   (enum reg_class) goal_alternative[i],\n-\t\t\t   (modified[i] == RELOAD_WRITE ? VOIDmode : operand_mode[i]),\n-\t\t\t   (modified[i] == RELOAD_READ ? VOIDmode : operand_mode[i]),\n-\t\t\t   (insn_code_number < 0 ? 0\n-\t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n-\t\t\t   1, NULL_RTX);\n-\telse\n-\t  non_reloaded_operands[n_non_reloaded_operands++] = recog_operand[i];\n+\t\t\t   1, i, operand_type[i]);\n       }\n-    else if (goal_alternative_matched[i] < 0\n-\t     && goal_alternative_matches[i] < 0)\n-      non_reloaded_operands[n_non_reloaded_operands++] = recog_operand[i];\n+    else if (goal_alternative_matches[i] >= 0\n+\t     && goal_alternative_win[goal_alternative_matches[i]]\n+\t     && modified[i] == RELOAD_READ\n+\t     && modified[goal_alternative_matches[i]] == RELOAD_WRITE\n+\t     && ! no_input_reloads && ! no_output_reloads\n+\t     && optimize)\n+      {\n+\t/* Similarly, make an optional reload for a pair of matching\n+\t   objects that are in MEM or a pseudo that didn't get a hard reg.  */\n+\n+\trtx operand = recog_operand[i];\n \n+\twhile (GET_CODE (operand) == SUBREG)\n+\t  operand = XEXP (operand, 0);\n+\tif ((GET_CODE (operand) == MEM\n+\t     || (GET_CODE (operand) == REG\n+\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n+\t    && ((enum reg_class) goal_alternative[goal_alternative_matches[i]]\n+\t\t!= NO_REGS))\n+\t  operand_reloadnum[i] = operand_reloadnum[goal_alternative_matches[i]]\n+\t    = push_reload (recog_operand[goal_alternative_matches[i]],\n+\t\t\t   recog_operand[i],\n+\t\t\t   recog_operand_loc[goal_alternative_matches[i]],\n+\t\t\t   recog_operand_loc[i],\n+\t\t\t   (enum reg_class) goal_alternative[goal_alternative_matches[i]],\n+\t\t\t   operand_mode[goal_alternative_matches[i]],\n+\t\t\t   operand_mode[i],\n+\t\t\t   0, 1, goal_alternative_matches[i], RELOAD_OTHER);\n+      }\n+  \n   /* Record the values of the earlyclobber operands for the caller.  */\n   if (goal_earlyclobber)\n     for (i = 0; i < noperands; i++)\n@@ -3173,6 +3376,101 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       }\n #endif\n \n+  /* Perhaps an output reload can be combined with another\n+     to reduce needs by one.  */\n+  if (!goal_earlyclobber)\n+    combine_reloads ();\n+\n+  /* If we have a pair of reloads for parts of an address, they are reloading\n+     the same object, the operands themselves were not reloaded, and they\n+     are for two operands that are supposed to match, merge the reloads and\n+     change the type of the surviving reload to RELOAD_FOR_OPERAND_ADDRESS. */\n+\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      int k;\n+\n+      for (j = i + 1; j < n_reloads; j++)\n+\tif ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t     || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t    && (reload_when_needed[j] == RELOAD_FOR_INPUT_ADDRESS\n+\t\t|| reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t    && rtx_equal_p (reload_in[i], reload_in[j])\n+\t    && (operand_reloadnum[reload_opnum[i]] < 0\n+\t\t|| reload_optional[operand_reloadnum[reload_opnum[i]]])\n+\t    && (operand_reloadnum[reload_opnum[j]] < 0\n+\t\t|| reload_optional[operand_reloadnum[reload_opnum[j]]])\n+\t    && (goal_alternative_matches[reload_opnum[i]] == reload_opnum[j]\n+\t\t|| (goal_alternative_matches[reload_opnum[j]]\n+\t\t    == reload_opnum[i])))\n+\t  {\n+\t    for (k = 0; k < n_replacements; k++)\n+\t      if (replacements[k].what == j)\n+\t\treplacements[k].what = i;\n+\n+\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\t    reload_in[j] = 0;\n+\t  }\n+    }\n+\n+  /* Scan all the reloads and update their type. \n+     If a reload is for the address of an operand and we didn't reload\n+     that operand, change the type.  Similarly, change the operand number\n+     of a reload when two operands match.  If a reload is optional, treat it\n+     as though the operand isn't reloaded.\n+\n+     ??? This latter case is somewhat odd because if we do the optional\n+     reload, it means the object is hanging around.  Thus we need only\n+     do the address reload if the optional reload was NOT done.\n+\n+     Change secondary reloads to be the address type of their operand, not\n+     the normal type.\n+\n+     If an operand's reload is now RELOAD_OTHER, change any\n+     RELOAD_FOR_INPUT_ADDRESS reloads of that operand to\n+     RELOAD_FOR_OTHER_ADDRESS.  */\n+\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      if (reload_secondary_p[i]\n+\t  && reload_when_needed[i] == operand_type[reload_opnum[i]])\n+\treload_when_needed[i] = address_type[reload_opnum[i]];\n+\n+      if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t   || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t  && (operand_reloadnum[reload_opnum[i]] < 0\n+\t      || reload_optional[operand_reloadnum[reload_opnum[i]]]))\n+\treload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\n+      if (reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t  && operand_reloadnum[reload_opnum[i]] >= 0\n+\t  && (reload_when_needed[operand_reloadnum[reload_opnum[i]]] \n+\t      == RELOAD_OTHER))\n+\treload_when_needed[i] = RELOAD_FOR_OTHER_ADDRESS;\n+\n+      if (goal_alternative_matches[reload_opnum[i]] >= 0)\n+\treload_opnum[i] = goal_alternative_matches[reload_opnum[i]];\n+    }\n+\n+  /* See if we have any reloads that are now allowed to be merged\n+     because we've changed when the reload is needed to\n+     RELOAD_FOR_OPERAND_ADDRESS or RELOAD_FOR_OTHER_ADDRESS.  Only\n+     check for the most common cases.  */\n+\n+  for (i = 0; i < n_reloads; i++)\n+    if (reload_in[i] != 0 && reload_out[i] == 0\n+\t&& (reload_when_needed[i] == RELOAD_FOR_OPERAND_ADDRESS\n+\t    || reload_when_needed[i] == RELOAD_FOR_OTHER_ADDRESS))\n+      for (j = 0; j < n_reloads; j++)\n+\tif (i != j && reload_in[j] != 0 && reload_out[j] == 0\n+\t    && reload_when_needed[j] == reload_when_needed[i]\n+\t    && MATCHES (reload_in[i], reload_in[j]))\n+\t  {\n+\t    reload_opnum[i] = MIN (reload_opnum[i], reload_opnum[j]);\n+\t    transfer_replacements (i, j);\n+\t    reload_in[j] = 0;\n+\t  }\n+\n #else /* no REGISTER_CONSTRAINTS */\n   int noperands;\n   int insn_code_number;\n@@ -3242,16 +3540,22 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tif (insn_operand_address_p[insn_code_number][i])\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n-\t\t\t\trecog_operand[i], ind_levels);\n+\t\t\t\ti, RELOAD_FOR_INPUT, ind_levels);\n+\n+      /* In these cases, we can't tell if the operand is an input\n+\t or an output, so be conservative.  In practice it won't be\n+\t problem.  */\n+\n       if (code == MEM)\n \tfind_reloads_address (GET_MODE (recog_operand[i]),\n \t\t\t      recog_operand_loc[i],\n \t\t\t      XEXP (recog_operand[i], 0),\n \t\t\t      &XEXP (recog_operand[i], 0),\n-\t\t\t      recog_operand[i], ind_levels);\n+\t\t\t      i, RELOAD_OTHER, ind_levels);\n       if (code == SUBREG)\n \trecog_operand[i] = *recog_operand_loc[i]\n-\t  = find_reloads_toplev (recog_operand[i], ind_levels, is_set_dest);\n+\t  = find_reloads_toplev (recog_operand[i], i, RELOAD_OTHER,\n+\t\t\t\t ind_levels, is_set_dest);\n       if (code == REG)\n \t{\n \t  register int regno = REGNO (recog_operand[i]);\n@@ -3265,85 +3569,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      = reg_equiv_mem[regno];\n #endif\n \t}\n-      /* All operands are non-reloaded.  */\n-      non_reloaded_operands[n_non_reloaded_operands++] = recog_operand[i];\n-    }\n-#endif /* no REGISTER_CONSTRAINTS */\n-\n-  /* Determine which part of the insn each reload is needed for,\n-     based on which operand the reload is needed for.\n-     Reloads of entire operands are classified as RELOAD_OTHER.\n-     So are reloads for which a unique purpose is not known.  */\n-\n-  for (i = 0; i < n_reloads; i++)\n-    {\n-      reload_when_needed[i] = RELOAD_OTHER;\n-\n-      if (reload_needed_for[i] != 0 && ! reload_needed_for_multiple[i])\n-\t{\n-\t  int j;\n-\t  int output_address = 0;\n-\t  int input_address = 0;\n-\t  int operand_address = 0;\n-\n-\t  /* This reload is needed only for the address of something.\n-\t     Determine whether it is needed for addressing an operand\n-\t     being reloaded for input, whether it is needed for an\n-\t     operand being reloaded for output, and whether it is needed\n-\t     for addressing an operand that won't really be reloaded.\n-\n-\t     Note that we know that this reload is needed in only one address,\n-\t     but we have not yet checked for the case where that same address\n-\t     is used in both input and output reloads.\n-\t     The following code detects this case.  */\n-\n-\t  for (j = 0; j < n_reloads; j++)\n-\t    if (reload_needed_for[i] == reload_in[j]\n-\t\t|| reload_needed_for[i] == reload_out[j])\n-\t      {\n-\t\tif (reload_optional[j])\n-\t\t  operand_address = 1;\n-\t\telse\n-\t\t  {\n-\t\t    if (reload_needed_for[i] == reload_in[j])\n-\t\t      input_address = 1;\n-\t\t    if (reload_needed_for[i] == reload_out[j])\n-\t\t      output_address = 1;\n-\t\t  }\n-\t      }\n-\t  /* Don't ignore memrefs without optional reloads.  */\n-\t  for (j = 0; j < n_non_reloaded_operands; j++)\n-\t    if (reload_needed_for[i] == non_reloaded_operands[j])\n-\t      operand_address = 1;\n-\n-\t  /* If it is needed for only one of those, record which one.  */\n-\n-\t  if (input_address && ! output_address && ! operand_address)\n-\t    reload_when_needed[i] = RELOAD_FOR_INPUT_RELOAD_ADDRESS;\n-\t  if (output_address && ! input_address && ! operand_address)\n-\t    reload_when_needed[i] = RELOAD_FOR_OUTPUT_RELOAD_ADDRESS;\n-\t  if (operand_address && ! input_address && ! output_address)\n-\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n-\n-\t  /* Indicate those RELOAD_OTHER reloads which, though they have\n-\t     0 for reload_output, still cannot overlap an output reload.  */\n-\n-\t  if (output_address && reload_when_needed[i] == RELOAD_OTHER)\n-\t    reload_needed_for_multiple[i] = 1;\n-\n-\t  /* If we have earlyclobbers, make sure nothing overlaps them.  */\n-\t  if (n_earlyclobbers > 0)\n-\t    {\n-\t      reload_when_needed[i] = RELOAD_OTHER;\n-\t      reload_needed_for_multiple[i] = 1;\n-\t    }\n-\t}\n     }\n \n   /* Perhaps an output reload can be combined with another\n      to reduce needs by one.  */\n   if (!goal_earlyclobber)\n     combine_reloads ();\n+#endif /* no REGISTER_CONSTRAINTS */\n }\n \n /* Return 1 if alternative number ALTNUM in constraint-string CONSTRAINT\n@@ -3379,12 +3611,16 @@ alternative_allows_memconst (constraint, altnum)\n    IND_LEVELS says how many levels of indirect addressing this machine\n    supports.\n \n+   OPNUM and TYPE identify the purpose of the reload.\n+\n    IS_SET_DEST is true if X is the destination of a SET, which is not\n    appropriate to be replaced by a constant.  */\n \n static rtx\n-find_reloads_toplev (x, ind_levels, is_set_dest)\n+find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n      rtx x;\n+     int opnum;\n+     enum reload_type type;\n      int ind_levels;\n      int is_set_dest;\n {\n@@ -3417,15 +3653,15 @@ find_reloads_toplev (x, ind_levels, is_set_dest)\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), x, ind_levels);\n+\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels);\n \t}\n       return x;\n     }\n   if (code == MEM)\n     {\n       rtx tem = x;\n       find_reloads_address (GET_MODE (x), &tem, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    x, ind_levels);\n+\t\t\t    opnum, type, ind_levels);\n       return tem;\n     }\n \n@@ -3502,15 +3738,15 @@ find_reloads_toplev (x, ind_levels, is_set_dest)\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), x, ind_levels);\n+\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels);\n \t}\n \n     }\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tXEXP (x, i) = find_reloads_toplev (XEXP (x, i),\n+\tXEXP (x, i) = find_reloads_toplev (XEXP (x, i), opnum, type,\n \t\t\t\t\t   ind_levels, is_set_dest);\n     }\n   return x;\n@@ -3544,7 +3780,7 @@ make_memloc (ad, regno)\n    Note that we take shortcuts assuming that no multi-reg machine mode\n    occurs as part of an address.\n \n-   OPERAND is the operand of the insn within which this address appears.\n+   OPNUM and TYPE specify the purpose of this reload.\n \n    IND_LEVELS says how many levels of indirect addressing this machine\n    supports.\n@@ -3559,12 +3795,13 @@ make_memloc (ad, regno)\n    to a hard register, and frame pointer elimination.  */\n \n static int\n-find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n+find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n      enum machine_mode mode;\n      rtx *memrefloc;\n      rtx ad;\n      rtx *loc;\n-     rtx operand;\n+     int opnum;\n+     enum reload_type type;\n      int ind_levels;\n {\n   register int regno;\n@@ -3589,10 +3826,10 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t{\n \t  tem = make_memloc (ad, regno);\n \t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n-\t\t\t\t&XEXP (tem, 0), operand, ind_levels);\n+\t\t\t\t&XEXP (tem, 0), opnum, type, ind_levels);\n \t  push_reload (tem, NULL_RTX, loc, NULL_PTR, BASE_REG_CLASS,\n \t\t       GET_MODE (ad), VOIDmode, 0, 0,\n-\t\t       operand);\n+\t\t       opnum, type);\n \t  return 1;\n \t}\n \n@@ -3613,7 +3850,7 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n       push_reload (ad, NULL_RTX, loc, NULL_PTR, BASE_REG_CLASS,\n-\t\t   GET_MODE (ad), VOIDmode, 0, 0, operand);\n+\t\t   GET_MODE (ad), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n \n@@ -3656,18 +3893,15 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t indirect addresses are valid, reload the MEM into a register.  */\n       tem = ad;\n       find_reloads_address (GET_MODE (ad), &tem, XEXP (ad, 0), &XEXP (ad, 0),\n-\t\t\t    operand, ind_levels == 0 ? 0 : ind_levels - 1);\n+\t\t\t    opnum, type, ind_levels == 0 ? 0 : ind_levels - 1);\n \n       /* If tem was changed, then we must create a new memory reference to\n \t hold it and store it back into memrefloc.  */\n       if (tem != ad && memrefloc)\n \t{\n-\t  rtx oldref = *memrefloc;\n \t  *memrefloc = copy_rtx (*memrefloc);\n \t  copy_replacements (tem, XEXP (*memrefloc, 0));\n \t  loc = &XEXP (*memrefloc, 0);\n-\t  if (operand == oldref)\n-\t    operand = *memrefloc;\n \t}\n \n       /* Check similar cases as for indirect addresses as above except\n@@ -3686,7 +3920,7 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t     have any subexpressions reloaded, if needed.  */\n \t  push_reload (tem, NULL_RTX, loc, NULL_PTR,\n \t\t       BASE_REG_CLASS, GET_MODE (tem), VOIDmode, 0,\n-\t\t       0, operand);\n+\t\t       0, opnum, type);\n \t  return 1;\n \t}\n       else\n@@ -3709,8 +3943,6 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t  rtx oldref = *memrefloc;\n \t  *memrefloc = copy_rtx (*memrefloc);\n \t  loc = &XEXP (*memrefloc, 0);\n-\t  if (operand == oldref)\n-\t    operand = *memrefloc;\n \t}\n       if (double_reg_address_ok)\n \t{\n@@ -3719,16 +3951,16 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t  /* Reload the displacement into an index reg.\n \t     We assume the frame pointer or arg pointer is a base reg.  */\n \t  find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),\n-\t\t\t\t     INDEX_REG_CLASS, GET_MODE (ad), operand,\n-\t\t\t\t     ind_levels);\n+\t\t\t\t     INDEX_REG_CLASS, GET_MODE (ad), opnum,\n+\t\t\t\t     type, ind_levels);\n \t}\n       else\n \t{\n \t  /* If the sum of two regs is not necessarily valid,\n \t     reload the sum into a base reg.\n \t     That will at least work.  */\n \t  find_reloads_address_part (ad, loc, BASE_REG_CLASS, Pmode,\n-\t\t\t\t     operand, ind_levels);\n+\t\t\t\t     opnum, type, ind_levels);\n \t}\n       return 1;\n     }\n@@ -3776,8 +4008,8 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t\t\t\t\t  INTVAL (XEXP (ad, 1))),\n \t\t\t   XEXP (XEXP (ad, 0), 1));\n       find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0), BASE_REG_CLASS,\n-\t\t\t\t GET_MODE (ad), operand, ind_levels);\n-      find_reloads_address_1 (XEXP (ad, 1), 1, &XEXP (ad, 1), operand, 0);\n+\t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n+      find_reloads_address_1 (XEXP (ad, 1), 1, &XEXP (ad, 1), opnum, type, 0);\n \n       return 1;\n     }\n@@ -3796,8 +4028,8 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t\t\t\t\t  INTVAL (XEXP (ad, 1))),\n \t\t\t   XEXP (XEXP (ad, 0), 0));\n       find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0), BASE_REG_CLASS,\n-\t\t\t\t GET_MODE (ad), operand, ind_levels);\n-      find_reloads_address_1 (XEXP (ad, 1), 1, &XEXP (ad, 1), operand, 0);\n+\t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n+      find_reloads_address_1 (XEXP (ad, 1), 1, &XEXP (ad, 1), opnum, type, 0);\n \n       return 1;\n     }\n@@ -3837,16 +4069,14 @@ find_reloads_address (mode, memrefloc, ad, loc, operand, ind_levels)\n \t  rtx oldref = *memrefloc;\n \t  *memrefloc = copy_rtx (*memrefloc);\n \t  loc = &XEXP (*memrefloc, 0);\n-\t  if (operand == oldref)\n-\t    operand = *memrefloc;\n \t}\n \n-      find_reloads_address_part (ad, loc, BASE_REG_CLASS, Pmode, operand,\n+      find_reloads_address_part (ad, loc, BASE_REG_CLASS, Pmode, opnum, type,\n \t\t\t\t ind_levels);\n       return 1;\n     }\n \n-  return find_reloads_address_1 (ad, 0, loc, operand, ind_levels);\n+  return find_reloads_address_1 (ad, 0, loc, opnum, type, ind_levels);\n }\n \f\n /* Find all pseudo regs appearing in AD\n@@ -4008,7 +4238,7 @@ subst_indexed_address (addr)\n    CONTEXT = 1 means we are considering regs as index regs,\n    = 0 means we are considering them as base regs.\n \n-   OPERAND is the operand of the insn within which this address appears.\n+   OPNUM and TYPE specify the purpose of any reloads made.\n \n    IND_LEVELS says how many levels of indirect addressing are\n    supported at this point in the address.\n@@ -4022,11 +4252,12 @@ subst_indexed_address (addr)\n    could have addressing modes that this does not handle right.  */\n \n static int\n-find_reloads_address_1 (x, context, loc, operand, ind_levels)\n+find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n      rtx x;\n      int context;\n      rtx *loc;\n-     rtx operand;\n+     int opnum;\n+     enum reload_type type;\n      int ind_levels;\n {\n   register RTX_CODE code = GET_CODE (x);\n@@ -4039,24 +4270,24 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n       register RTX_CODE code1 = GET_CODE (op1);\n       if (code0 == MULT || code0 == SIGN_EXTEND || code1 == MEM)\n \t{\n-\t  find_reloads_address_1 (op0, 1, &XEXP (x, 0), operand, ind_levels);\n-\t  find_reloads_address_1 (op1, 0, &XEXP (x, 1), operand, ind_levels);\n+\t  find_reloads_address_1 (op0, 1, &XEXP (x, 0), opnum, type,\n+\t\t\t\t  ind_levels);\n+\t  find_reloads_address_1 (op1, 0, &XEXP (x, 1), opnum, type,\n+\t\t\t\t  ind_levels);\n \t}\n       else if (code1 == MULT || code1 == SIGN_EXTEND || code0 == MEM)\n \t{\n-\t  find_reloads_address_1 (op0, 0, &XEXP (x, 0), operand, ind_levels);\n-\t  find_reloads_address_1 (op1, 1, &XEXP (x, 1), operand, ind_levels);\n+\t  find_reloads_address_1 (op0, 0, &XEXP (x, 0), opnum, type,\n+\t\t\t\t  ind_levels);\n+\t  find_reloads_address_1 (op1, 1, &XEXP (x, 1), opnum, type,\n+\t\t\t\t  ind_levels);\n \t}\n       else if (code0 == CONST_INT || code0 == CONST\n \t       || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t{\n-\t  find_reloads_address_1 (op1, 0, &XEXP (x, 1), operand, ind_levels);\n-\t}\n+\tfind_reloads_address_1 (op1, 0, &XEXP (x, 1), opnum, type, ind_levels);\n       else if (code1 == CONST_INT || code1 == CONST\n \t       || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t{\n-\t  find_reloads_address_1 (op0, 0, &XEXP (x, 0), operand, ind_levels);\n-\t}\n+\tfind_reloads_address_1 (op0, 0, &XEXP (x, 0), opnum, type, ind_levels);\n       else if (code0 == REG && code1 == REG)\n \t{\n \t  if (REG_OK_FOR_INDEX_P (op0)\n@@ -4066,30 +4297,38 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t      && REG_OK_FOR_BASE_P (op0))\n \t    return 0;\n \t  else if (REG_OK_FOR_BASE_P (op1))\n-\t    find_reloads_address_1 (op0, 1, &XEXP (x, 0), operand, ind_levels);\n+\t    find_reloads_address_1 (op0, 1, &XEXP (x, 0), opnum, type, \n+\t\t\t\t    ind_levels);\n \t  else if (REG_OK_FOR_BASE_P (op0))\n-\t    find_reloads_address_1 (op1, 1, &XEXP (x, 1), operand, ind_levels);\n+\t    find_reloads_address_1 (op1, 1, &XEXP (x, 1), opnum, type,\n+\t\t\t\t    ind_levels);\n \t  else if (REG_OK_FOR_INDEX_P (op1))\n-\t    find_reloads_address_1 (op0, 0, &XEXP (x, 0), operand, ind_levels);\n+\t    find_reloads_address_1 (op0, 0, &XEXP (x, 0), opnum, type,\n+\t\t\t\t    ind_levels);\n \t  else if (REG_OK_FOR_INDEX_P (op0))\n-\t    find_reloads_address_1 (op1, 0, &XEXP (x, 1), operand, ind_levels);\n+\t    find_reloads_address_1 (op1, 0, &XEXP (x, 1), opnum, type,\n+\t\t\t\t    ind_levels);\n \t  else\n \t    {\n-\t      find_reloads_address_1 (op0, 1, &XEXP (x, 0), operand,\n+\t      find_reloads_address_1 (op0, 1, &XEXP (x, 0), opnum, type,\n \t\t\t\t      ind_levels);\n-\t      find_reloads_address_1 (op1, 0, &XEXP (x, 1), operand,\n+\t      find_reloads_address_1 (op1, 0, &XEXP (x, 1), opnum, type,\n \t\t\t\t      ind_levels);\n \t    }\n \t}\n       else if (code0 == REG)\n \t{\n-\t  find_reloads_address_1 (op0, 1, &XEXP (x, 0), operand, ind_levels);\n-\t  find_reloads_address_1 (op1, 0, &XEXP (x, 1), operand, ind_levels);\n+\t  find_reloads_address_1 (op0, 1, &XEXP (x, 0), opnum, type,\n+\t\t\t\t  ind_levels);\n+\t  find_reloads_address_1 (op1, 0, &XEXP (x, 1), opnum, type,\n+\t\t\t\t  ind_levels);\n \t}\n       else if (code1 == REG)\n \t{\n-\t  find_reloads_address_1 (op1, 1, &XEXP (x, 1), operand, ind_levels);\n-\t  find_reloads_address_1 (op0, 0, &XEXP (x, 0), operand, ind_levels);\n+\t  find_reloads_address_1 (op1, 1, &XEXP (x, 1), opnum, type,\n+\t\t\t\t  ind_levels);\n+\t  find_reloads_address_1 (op0, 0, &XEXP (x, 0), opnum, type,\n+\t\t\t\t  ind_levels);\n \t}\n     }\n   else if (code == POST_INC || code == POST_DEC\n@@ -4113,7 +4352,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t      rtx tem = make_memloc (XEXP (x, 0), regno);\n \t      /* First reload the memory location's address.  */\n \t      find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n-\t\t\t\t    &XEXP (tem, 0), operand, ind_levels);\n+\t\t\t\t    &XEXP (tem, 0), opnum, type, ind_levels);\n \t      /* Put this inside a new increment-expression.  */\n \t      x = gen_rtx (GET_CODE (x), GET_MODE (x), tem);\n \t      /* Proceed to reload that, as if it contained a register.  */\n@@ -4141,7 +4380,8 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t      int reloadnum\n \t\t= push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t\t       GET_MODE (x), GET_MODE (x), VOIDmode, 0, operand);\n+\t\t\t       GET_MODE (x), GET_MODE (x), VOIDmode, 0,\n+\t\t\t       opnum, type);\n \t      reload_inc[reloadnum]\n \t\t= find_inc_amount (PATTERN (this_insn), XEXP (x_orig, 0));\n \n@@ -4177,11 +4417,11 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t     reload1.c here.  */\n \t  find_reloads_address (GET_MODE (x), &XEXP (x, 0),\n \t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n-\t\t\t\toperand, ind_levels);\n+\t\t\t\topnum, type, ind_levels);\n \n \t  reloadnum = push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, operand);\n+\t\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  reload_inc[reloadnum]\n \t    = find_inc_amount (PATTERN (this_insn), XEXP (x, 0));\n \n@@ -4207,11 +4447,11 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t reload1.c here.  */\n \n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    operand, ind_levels);\n+\t\t\t    opnum, type, ind_levels);\n \n       push_reload (*loc, NULL_RTX, loc, NULL_PTR,\n \t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t   GET_MODE (x), VOIDmode, 0, 0, operand);\n+\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n   else if (code == REG)\n@@ -4223,7 +4463,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t  find_reloads_address_part (reg_equiv_constant[regno], loc, \n \t\t\t\t     (context ? INDEX_REG_CLASS\n \t\t\t\t      : BASE_REG_CLASS),\n-\t\t\t\t     GET_MODE (x), operand, ind_levels);\n+\t\t\t\t     GET_MODE (x), opnum, type, ind_levels);\n \t  return 1;\n \t}\n \n@@ -4233,15 +4473,15 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t{\n \t  push_reload (reg_equiv_mem[regno], NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n+\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  return 1;\n \t}\n #endif\n       if (reg_equiv_address[regno] != 0)\n \t{\n \t  x = make_memloc (x, regno);\n \t  find_reloads_address (GET_MODE (x), 0, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t\toperand, ind_levels);\n+\t\t\t\topnum, type, ind_levels);\n \t}\n \n       if (reg_renumber[regno] >= 0)\n@@ -4252,7 +4492,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t{\n \t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n+\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  return 1;\n \t}\n \n@@ -4264,7 +4504,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t{\n \t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t       GET_MODE (x), VOIDmode, 0, 0, operand);\n+\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t  return 1;\n \t}\n     }\n@@ -4276,7 +4516,7 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \t{\n \t  if (fmt[i] == 'e')\n \t    find_reloads_address_1 (XEXP (x, i), context, &XEXP (x, i),\n-\t\t\t\t    operand, ind_levels);\n+\t\t\t\t    opnum, type, ind_levels);\n \t}\n     }\n \n@@ -4293,18 +4533,19 @@ find_reloads_address_1 (x, context, loc, operand, ind_levels)\n \n    MODE is the mode to use, in case X is an integer constant.\n \n-   NEEDED_FOR says which operand this reload is needed for.\n+   OPNUM and TYPE describe the purpose of any reloads made.\n \n    IND_LEVELS says how many levels of indirect addressing this machine\n    supports.  */\n \n static void\n-find_reloads_address_part (x, loc, class, mode, needed_for, ind_levels)\n+find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n      rtx x;\n      rtx *loc;\n      enum reg_class class;\n      enum machine_mode mode;\n-     rtx needed_for;\n+     int opnum;\n+     enum reload_type type;\n      int ind_levels;\n {\n   if (CONSTANT_P (x)\n@@ -4313,7 +4554,7 @@ find_reloads_address_part (x, loc, class, mode, needed_for, ind_levels)\n     {\n       rtx tem = x = force_const_mem (mode, x);\n       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),\n-\t\t\t    needed_for, ind_levels);\n+\t\t\t    opnum, type, ind_levels);\n     }\n \n   else if (GET_CODE (x) == PLUS\n@@ -4325,14 +4566,14 @@ find_reloads_address_part (x, loc, class, mode, needed_for, ind_levels)\n \n       x = gen_rtx (PLUS, GET_MODE (x), XEXP (x, 0), tem);\n       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),\n-\t\t\t    needed_for, ind_levels);\n+\t\t\t    opnum, type, ind_levels);\n     }\n \n   push_reload (x, NULL_RTX, loc, NULL_PTR, class,\n-\t       mode, VOIDmode, 0, 0, needed_for);\n+\t       mode, VOIDmode, 0, 0, opnum, type);\n }\n \f\n-/* Substitute into X the registers into which we have reloaded\n+/* Substitute into the current INSN the registers into which we have reloaded\n    the things that need reloading.  The array `replacements'\n    says contains the locations of all pointers that must be changed\n    and says what to replace them with.\n@@ -4661,65 +4902,6 @@ refers_to_mem_for_reload_p (x)\n   return 0;\n }\n \f\n-#if 0\n-\n-/* [[This function is currently obsolete, now that volatility\n-   is represented by a special bit `volatil' so VOLATILE is never used;\n-   and UNCHANGING has never been brought into use.]]\n-\n-   Alter X by eliminating all VOLATILE and UNCHANGING expressions.\n-   Each of them is replaced by its operand.\n-   Thus, (PLUS (VOLATILE (MEM (REG 5))) (CONST_INT 4))\n-   becomes (PLUS (MEM (REG 5)) (CONST_INT 4)).\n-\n-   If X is itself a VOLATILE expression,\n-   we return the expression that should replace it\n-   but we do not modify X.  */\n-\n-static rtx\n-forget_volatility (x)\n-     register rtx x;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  register char *fmt;\n-  register int i;\n-  register rtx value = 0;\n-\n-  switch (code)\n-    {\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case REG:\n-    case CC0:\n-    case PC:\n-      return x;\n-\n-    case VOLATILE:\n-    case UNCHANGING:\n-      return XEXP (x, 0);\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tXEXP (x, i) = forget_volatility (XEXP (x, i));\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    XVECEXP (x, i, j) = forget_volatility (XVECEXP (x, i, j));\n-\t}\n-    }\n-\n-  return x;\n-}\n-\n-#endif\n-\f\n /* Check the insns before INSN to see if there is a suitable register\n    containing the same value as GOAL.\n    If OTHER is -1, look for a register in class CLASS.\n@@ -4820,7 +5002,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \treturn 0;\n       if (GET_CODE (p) == INSN\n \t  /* If we don't want spill regs ... */\n-\t  && (! (reload_reg_p != 0 && reload_reg_p != (short *)1)\n+\t  && (! (reload_reg_p != 0\n+\t\t && reload_reg_p != (short *) (HOST_WIDE_INT) 1)\n \t  /* ... then ignore insns introduced by reload; they aren't useful\n \t     and can cause results in reload_as_needed to be different\n \t     from what they were when calculating the need for spills.\n@@ -4935,7 +5118,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n      (Now that insns introduced by reload are ignored above,\n      this case shouldn't happen, but I'm not positive.)  */\n \n-  if (reload_reg_p != 0 && reload_reg_p != (short *)1\n+  if (reload_reg_p != 0 && reload_reg_p != (short *) (HOST_WIDE_INT) 1\n       && reload_reg_p[valueno] >= 0)\n     return 0;\n "}]}