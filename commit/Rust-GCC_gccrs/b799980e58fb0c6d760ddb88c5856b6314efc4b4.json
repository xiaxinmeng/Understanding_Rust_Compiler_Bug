{"sha": "b799980e58fb0c6d760ddb88c5856b6314efc4b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc5OTk4MGU1OGZiMGM2ZDc2MGRkYjg4YzU4NTZiNjMxNGVmYzRiNA==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2010-10-12T12:44:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T12:44:52Z"}, "message": "g-comlin.adb, [...] (Display_Help, [...]): New subprograms.\n\n2010-10-12  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-comlin.adb, g-comlin.ads (Display_Help, Getopt, Current_Section,\n\tSet_Usage): New subprograms.\n\t(Define_Switch): Change profile to add support for help messages and\n\tlong switches.\n\nFrom-SVN: r165370", "tree": {"sha": "82c248403d4fa257fe2bdf754d4ed1cac550966d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82c248403d4fa257fe2bdf754d4ed1cac550966d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b799980e58fb0c6d760ddb88c5856b6314efc4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b799980e58fb0c6d760ddb88c5856b6314efc4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b799980e58fb0c6d760ddb88c5856b6314efc4b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b799980e58fb0c6d760ddb88c5856b6314efc4b4/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83e350f71b09d18d74f752218754165cd11bb794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e350f71b09d18d74f752218754165cd11bb794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e350f71b09d18d74f752218754165cd11bb794"}], "stats": {"total": 1720, "additions": 1401, "deletions": 319}, "files": [{"sha": "4705aee0a78cabbf4aff3feb0d3a0adf917d9aa1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b799980e58fb0c6d760ddb88c5856b6314efc4b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b799980e58fb0c6d760ddb88c5856b6314efc4b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b799980e58fb0c6d760ddb88c5856b6314efc4b4", "patch": "@@ -1,3 +1,10 @@\n+2010-10-12  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-comlin.adb, g-comlin.ads (Display_Help, Getopt, Current_Section,\n+\tSet_Usage): New subprograms.\n+\t(Define_Switch): Change profile to add support for help messages and\n+\tlong switches.\n+\n 2010-10-12  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch6.adb (New_Overloaded_Entity): Add missing decoration of"}, {"sha": "e5aa6dd183d258806b7617151aee7a239e233180", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 1087, "deletions": 234, "changes": 1321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b799980e58fb0c6d760ddb88c5856b6314efc4b4/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b799980e58fb0c6d760ddb88c5856b6314efc4b4/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=b799980e58fb0c6d760ddb88c5856b6314efc4b4", "patch": "@@ -29,10 +29,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Unchecked_Deallocation;\n+with Ada.Characters.Handling;   use Ada.Characters.Handling;\n with Ada.Strings.Unbounded;\n-\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n+with Ada.Text_IO;               use Ada.Text_IO;\n+with Ada.Unchecked_Deallocation;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n package body GNAT.Command_Line is\n \n@@ -112,6 +114,29 @@ package body GNAT.Command_Line is\n    --  Add a new element to Line. If Before is True, the item is inserted at\n    --  the beginning, else it is appended.\n \n+   procedure Add (Config : in out Command_Line_Configuration;\n+                  Switch : Switch_Definition);\n+   procedure Add (Def : in out Alias_Definitions_List;\n+                  Alias  : Alias_Definition);\n+   --  Add a new element to Def.\n+\n+   procedure Initialize_Switch_Def\n+     (Def         : out Switch_Definition;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\");\n+   --  Initialize [Def] with the contents of the other parameters.\n+   --  This also checks consistency of the switch parameters, and will raise\n+   --  Invalid_Switch if they do not match.\n+\n+   procedure Decompose_Switch\n+     (Switch         : String;\n+      Parameter_Type : out Switch_Parameter_Type;\n+      Switch_Last    : out Integer);\n+   --  Given a switch definition (\"name:\" for instance), extracts the type of\n+   --  parameter that is expected, and the name of the switch\n+\n    function Can_Have_Parameter (S : String) return Boolean;\n    --  True if S can have a parameter\n \n@@ -122,9 +147,14 @@ package body GNAT.Command_Line is\n    --  Remove any possible trailing '!', ':', '?' and '='\n \n    generic\n-      with procedure Callback (Simple_Switch : String; Parameter : String);\n+      with procedure Callback\n+        (Simple_Switch : String;\n+         Separator     : String;\n+         Parameter     : String;\n+         Index         : Integer);  --  Index in Config.Switches, or -1\n    procedure For_Each_Simple_Switch\n-     (Cmd       : Command_Line;\n+     (Config    : Command_Line_Configuration;\n+      Section   : String;\n       Switch    : String;\n       Parameter : String  := \"\";\n       Unalias   : Boolean := True);\n@@ -161,6 +191,13 @@ package body GNAT.Command_Line is\n    --  Return True if the characters starting at Index in Type_Str are\n    --  equivalent to Substring.\n \n+   procedure Foreach_Switch\n+     (Config   : Command_Line_Configuration;\n+      Callback : access function (S : String; Index : Integer) return Boolean;\n+      Section  : String);\n+   --  Iterate over all switches defined in Config, for a specific section.\n+   --  Index is set to the index in Config.Switches\n+\n    --------------\n    -- Argument --\n    --------------\n@@ -197,7 +234,6 @@ package body GNAT.Command_Line is\n    ---------------\n \n    function Expansion (Iterator : Expansion_Iterator) return String is\n-      use GNAT.Directory_Operations;\n       type Pointer is access all Expansion_Iterator;\n \n       It   : constant Pointer := Iterator'Unrestricted_Access;\n@@ -286,6 +322,28 @@ package body GNAT.Command_Line is\n       end loop;\n    end Expansion;\n \n+   ---------------------\n+   -- Current_Section --\n+   ---------------------\n+\n+   function Current_Section\n+     (Parser : Opt_Parser := Command_Line_Parser) return String is\n+   begin\n+      if Parser.Current_Section = 1 then\n+         return \"\";\n+      end if;\n+\n+      for Index in reverse 1 .. Integer'Min (Parser.Current_Argument - 1,\n+                                             Parser.Section'Last)\n+      loop\n+         if Parser.Section (Index) = 0 then\n+            return Argument (Parser, Index);\n+         end if;\n+      end loop;\n+\n+      return \"\";\n+   end Current_Section;\n+\n    -----------------\n    -- Full_Switch --\n    -----------------\n@@ -394,6 +452,35 @@ package body GNAT.Command_Line is\n       return Argument (Parser, Parser.Current_Argument - 1);\n    end Get_Argument;\n \n+   ----------------------\n+   -- Decompose_Switch --\n+   ----------------------\n+\n+   procedure Decompose_Switch\n+     (Switch         : String;\n+      Parameter_Type : out Switch_Parameter_Type;\n+      Switch_Last    : out Integer)\n+   is\n+   begin\n+      case Switch (Switch'Last) is\n+         when ':'    =>\n+            Parameter_Type := Parameter_With_Optional_Space;\n+            Switch_Last    := Switch'Last - 1;\n+         when '='    =>\n+            Parameter_Type := Parameter_With_Space_Or_Equal;\n+            Switch_Last    := Switch'Last - 1;\n+         when '!'    =>\n+            Parameter_Type := Parameter_No_Space;\n+            Switch_Last    := Switch'Last - 1;\n+         when '?'    =>\n+            Parameter_Type := Parameter_Optional;\n+            Switch_Last    := Switch'Last - 1;\n+         when others =>\n+            Parameter_Type := Parameter_None;\n+            Switch_Last    := Switch'Last;\n+      end case;\n+   end Decompose_Switch;\n+\n    ----------------------------------\n    -- Find_Longest_Matching_Switch --\n    ----------------------------------\n@@ -407,6 +494,7 @@ package body GNAT.Command_Line is\n    is\n       Index  : Natural;\n       Length : Natural := 1;\n+      Last   : Natural;\n       P      : Switch_Parameter_Type;\n \n    begin\n@@ -432,37 +520,26 @@ package body GNAT.Command_Line is\n             Length := Length + 1;\n          end loop;\n \n+         --  Length now marks the separator after the current switch\n+         --  Last will mark the last character of the name of the switch\n+\n          if Length = Index + 1 then\n             P := Parameter_None;\n+            Last := Index;\n          else\n-            case Switches (Length - 1) is\n-               when ':'    =>\n-                  P      := Parameter_With_Optional_Space;\n-                  Length := Length - 1;\n-               when '='    =>\n-                  P      := Parameter_With_Space_Or_Equal;\n-                  Length := Length - 1;\n-               when '!'    =>\n-                  P      := Parameter_No_Space;\n-                  Length := Length - 1;\n-               when '?'    =>\n-                  P      := Parameter_Optional;\n-                  Length := Length - 1;\n-               when others =>\n-                  P      := Parameter_None;\n-            end case;\n+            Decompose_Switch (Switches (Index .. Length - 1), P, Last);\n          end if;\n \n          --  If it is the one we searched, it may be a candidate\n \n-         if Arg'First + Length - 1 - Index <= Arg'Last\n-           and then Switches (Index .. Length - 1) =\n-                      Arg (Arg'First .. Arg'First + Length - 1 - Index)\n-           and then Length - Index > Switch_Length\n+         if Arg'First + Last - Index <= Arg'Last\n+           and then Switches (Index .. Last) =\n+                      Arg (Arg'First .. Arg'First + Last - Index)\n+           and then Last - Index + 1 > Switch_Length\n          then\n             Param             := P;\n             Index_In_Switches := Index;\n-            Switch_Length     := Length - Index;\n+            Switch_Length     := Last - Index + 1;\n          end if;\n \n          --  Look for the next switch in Switches\n@@ -599,8 +676,9 @@ package body GNAT.Command_Line is\n               (Parser.The_Switch,\n                Arg_Num => Parser.Current_Argument,\n                First   => Parser.Current_Index,\n-               Last    => End_Index);\n+               Last    => Arg'Last);\n             Parser.Current_Index := End_Index + 1;\n+\n             raise Invalid_Switch;\n          end if;\n \n@@ -1076,15 +1154,19 @@ package body GNAT.Command_Line is\n    procedure Define_Alias\n      (Config   : in out Command_Line_Configuration;\n       Switch   : String;\n-      Expanded : String)\n+      Expanded : String;\n+      Section  : String := \"\")\n    is\n+      Def    : Alias_Definition;\n    begin\n       if Config = null then\n          Config := new Command_Line_Configuration_Record;\n       end if;\n \n-      Add (Config.Aliases,    new String'(Switch));\n-      Add (Config.Expansions, new String'(Expanded));\n+      Def.Alias     := new String'(Switch);\n+      Def.Expansion := new String'(Expanded);\n+      Def.Section   := new String'(Section);\n+      Add (Config.Aliases, Def);\n    end Define_Alias;\n \n    -------------------\n@@ -1103,20 +1185,187 @@ package body GNAT.Command_Line is\n       Add (Config.Prefixes, new String'(Prefix));\n    end Define_Prefix;\n \n+   ---------\n+   -- Add --\n+   ---------\n+\n+   procedure Add (Config : in out Command_Line_Configuration;\n+                  Switch : Switch_Definition)\n+   is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Switch_Definitions, Switch_Definitions_List);\n+      Tmp : Switch_Definitions_List;\n+   begin\n+      if Config = null then\n+         Config := new Command_Line_Configuration_Record;\n+      end if;\n+\n+      Tmp := Config.Switches;\n+\n+      if Tmp = null then\n+         Config.Switches := new Switch_Definitions (1 .. 1);\n+      else\n+         Config.Switches := new Switch_Definitions (1 .. Tmp'Length + 1);\n+         Config.Switches (1 .. Tmp'Length) := Tmp.all;\n+         Unchecked_Free (Tmp);\n+      end if;\n+\n+      Config.Switches (Config.Switches'Last) := Switch;\n+   end Add;\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   procedure Add (Def : in out Alias_Definitions_List;\n+                  Alias : Alias_Definition)\n+   is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Alias_Definitions, Alias_Definitions_List);\n+      Tmp : Alias_Definitions_List := Def;\n+   begin\n+      if Tmp = null then\n+         Def := new Alias_Definitions (1 .. 1);\n+      else\n+         Def := new Alias_Definitions (1 .. Tmp'Length + 1);\n+         Def (1 .. Tmp'Length) := Tmp.all;\n+         Unchecked_Free (Tmp);\n+      end if;\n+\n+      Def (Def'Last) := Alias;\n+   end Add;\n+\n+   ---------------------------\n+   -- Initialize_Switch_Def --\n+   ---------------------------\n+\n+   procedure Initialize_Switch_Def\n+     (Def : out Switch_Definition;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\")\n+   is\n+      P1, P2 : Switch_Parameter_Type := Parameter_None;\n+      Last1, Last2 : Integer;\n+   begin\n+      if Switch /= \"\" then\n+         Def.Switch := new String'(Switch);\n+         Decompose_Switch (Switch, P1, Last1);\n+      end if;\n+\n+      if Long_Switch /= \"\" then\n+         Def.Long_Switch := new String'(Long_Switch);\n+         Decompose_Switch (Long_Switch, P2, Last2);\n+      end if;\n+\n+      if Switch /= \"\" and then Long_Switch /= \"\" then\n+         if (P1 = Parameter_None and then P2 /= P1)\n+           or else (P2 = Parameter_None and then P1 /= P2)\n+           or else (P1 = Parameter_Optional and then P2 /= P1)\n+           or else (P2 = Parameter_Optional and then P2 /= P1)\n+         then\n+            raise Invalid_Switch\n+              with \"Inconsistent parameter types for \"\n+                & Switch & \" and \" & Long_Switch;\n+         end if;\n+      end if;\n+\n+      if Section /= \"\" then\n+         Def.Section := new String'(Section);\n+      end if;\n+\n+      if Help /= \"\" then\n+         Def.Help := new String'(Help);\n+      end if;\n+   end Initialize_Switch_Def;\n+\n    -------------------\n    -- Define_Switch --\n    -------------------\n \n    procedure Define_Switch\n-     (Config : in out Command_Line_Configuration;\n-      Switch : String)\n+     (Config      : in out Command_Line_Configuration;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\")\n    is\n+      Def    : Switch_Definition;\n    begin\n-      if Config = null then\n-         Config := new Command_Line_Configuration_Record;\n+      if Switch /= \"\" or else Long_Switch /= \"\" then\n+         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Add (Config, Def);\n       end if;\n+   end Define_Switch;\n \n-      Add (Config.Switches, new String'(Switch));\n+   -------------------\n+   -- Define_Switch --\n+   -------------------\n+\n+   procedure Define_Switch\n+     (Config      : in out Command_Line_Configuration;\n+      Output      : access Boolean;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\";\n+      Value       : Boolean := True)\n+   is\n+      Def : Switch_Definition (Switch_Boolean);\n+   begin\n+      if Switch /= \"\" or else Long_Switch /= \"\" then\n+         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Def.Boolean_Output := Output.all'Unchecked_Access;\n+         Def.Boolean_Value  := Value;\n+         Add (Config, Def);\n+      end if;\n+   end Define_Switch;\n+\n+   -------------------\n+   -- Define_Switch --\n+   -------------------\n+\n+   procedure Define_Switch\n+     (Config      : in out Command_Line_Configuration;\n+      Output      : access Integer;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\";\n+      Initial     : Integer := 0;\n+      Default     : Integer := 1)\n+   is\n+      Def : Switch_Definition (Switch_Integer);\n+   begin\n+      if Switch /= \"\" or else Long_Switch /= \"\" then\n+         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Def.Integer_Output  := Output.all'Unchecked_Access;\n+         Def.Integer_Default := Default;\n+         Def.Integer_Initial := Initial;\n+         Add (Config, Def);\n+      end if;\n+   end Define_Switch;\n+\n+   -------------------\n+   -- Define_Switch --\n+   -------------------\n+\n+   procedure Define_Switch\n+     (Config      : in out Command_Line_Configuration;\n+      Output      : access GNAT.Strings.String_Access;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\")\n+   is\n+      Def : Switch_Definition (Switch_String);\n+   begin\n+      if Switch /= \"\" or else Long_Switch /= \"\" then\n+         Initialize_Switch_Def (Def, Switch, Long_Switch, Help, Section);\n+         Def.String_Output  := Output.all'Unchecked_Access;\n+         Add (Config, Def);\n+      end if;\n    end Define_Switch;\n \n    --------------------\n@@ -1135,37 +1384,98 @@ package body GNAT.Command_Line is\n       Add (Config.Sections, new String'(Section));\n    end Define_Section;\n \n+   --------------------\n+   -- Foreach_Switch --\n+   --------------------\n+\n+   procedure Foreach_Switch\n+     (Config   : Command_Line_Configuration;\n+      Callback : access function (S : String; Index : Integer) return Boolean;\n+      Section  : String)\n+   is\n+   begin\n+      if Config /= null and then Config.Switches /= null then\n+         for J in Config.Switches'Range loop\n+            if (Section = \"\" and then Config.Switches (J).Section = null)\n+              or else\n+                (Config.Switches (J).Section /= null\n+                 and then Config.Switches (J).Section.all = Section)\n+            then\n+               exit when Config.Switches (J).Switch /= null\n+                 and then not Callback (Config.Switches (J).Switch.all, J);\n+\n+               exit when Config.Switches (J).Long_Switch /= null\n+                 and then\n+                   not Callback (Config.Switches (J).Long_Switch.all, J);\n+            end if;\n+         end loop;\n+      end if;\n+   end Foreach_Switch;\n+\n    ------------------\n    -- Get_Switches --\n    ------------------\n \n    function Get_Switches\n      (Config      : Command_Line_Configuration;\n-      Switch_Char : Character)\n-      return String\n+      Section     : String := \"\";\n+      Switch_Char : Character := '-') return String\n    is\n       Ret : Ada.Strings.Unbounded.Unbounded_String;\n-      use type Ada.Strings.Unbounded.Unbounded_String;\n+      use Ada.Strings.Unbounded;\n \n-   begin\n-      if Config = null or else Config.Switches = null then\n-         return \"\";\n-      end if;\n+      function Add_Switch (S : String; Index : Integer) return Boolean;\n+      --  Add a switch to Ret\n \n-      for J in Config.Switches'Range loop\n-         if Config.Switches (J) (Config.Switches (J)'First) = Switch_Char then\n-            Ret :=\n-              Ret & \" \" &\n-                Config.Switches (J)\n-                  (Config.Switches (J)'First + 1 .. Config.Switches (J)'Last);\n+      function Add_Switch (S : String; Index : Integer) return Boolean is\n+         pragma Unreferenced (Index);\n+      begin\n+         if S = \"*\" then\n+            Ret := \"*\" & Ret;  --  Always first\n+         elsif S (S'First) = Switch_Char then\n+            Append (Ret, \" \" & S (S'First + 1 .. S'Last));\n          else\n-            Ret := Ret & \" \" & Config.Switches (J).all;\n+            Append (Ret, \" \" & S);\n          end if;\n-      end loop;\n+         return True;\n+      end Add_Switch;\n+\n+      Tmp : Boolean;\n+      pragma Unreferenced (Tmp);\n+   begin\n+      Foreach_Switch (Config, Add_Switch'Access, Section => Section);\n \n-      return Ada.Strings.Unbounded.To_String (Ret);\n+      --  Adding relevant aliases\n+      if Config.Aliases /= null then\n+         for A in Config.Aliases'Range loop\n+            if Config.Aliases (A).Section.all = Section then\n+               Tmp := Add_Switch (Config.Aliases (A).Alias.all, -1);\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return To_String (Ret);\n    end Get_Switches;\n \n+   ------------------------\n+   -- Section_Delimiters --\n+   ------------------------\n+\n+   function Section_Delimiters\n+     (Config      : Command_Line_Configuration) return String\n+   is\n+      use Ada.Strings.Unbounded;\n+      Result : Unbounded_String;\n+   begin\n+      if Config /= null and then Config.Sections /= null then\n+         for S in Config.Sections'Range loop\n+            Append (Result, \" \" & Config.Sections (S).all);\n+         end loop;\n+      end if;\n+\n+      return To_String (Result);\n+   end Section_Delimiters;\n+\n    -----------------------\n    -- Set_Configuration --\n    -----------------------\n@@ -1275,24 +1585,17 @@ package body GNAT.Command_Line is\n                         --  Add_Switch if -gnaty3 is actually provided.\n \n                         if Separator (Parser) = ASCII.NUL then\n-                           Add_Switch\n-                             (Cmd, Sw & Parameter (Parser), \"\", ASCII.NUL);\n+                           Add_Switch (Cmd, Sw & Parameter (Parser), \"\");\n                         else\n-                           Add_Switch\n-                             (Cmd, Sw, Parameter (Parser), Separator (Parser));\n+                           Add_Switch (Cmd, Sw, Parameter (Parser));\n                         end if;\n                      else\n                         if Separator (Parser) = ASCII.NUL then\n                            Add_Switch\n-                             (Cmd, Sw & Parameter (Parser), \"\",\n-                              Separator (Parser),\n-                              Section.all);\n+                             (Cmd, Sw & Parameter (Parser), \"\", Section.all);\n                         else\n                            Add_Switch\n-                             (Cmd, Sw,\n-                              Parameter (Parser),\n-                              Separator (Parser),\n-                              Section.all);\n+                             (Cmd, Sw, Parameter (Parser), Section.all);\n                         end if;\n                      end if;\n                   end if;\n@@ -1310,12 +1613,10 @@ package body GNAT.Command_Line is\n \n                   if Section = null then\n                      Add_Switch\n-                       (Cmd, Switch_Char & Full_Switch (Parser),\n-                        Separator => Separator (Parser));\n+                       (Cmd, Switch_Char & Full_Switch (Parser));\n                   else\n                      Add_Switch\n                        (Cmd, Switch_Char & Full_Switch (Parser),\n-                        Separator => Separator (Parser),\n                         Section   => Section.all);\n                   end if;\n             end;\n@@ -1397,7 +1698,8 @@ package body GNAT.Command_Line is\n    ----------------------------\n \n    procedure For_Each_Simple_Switch\n-     (Cmd       : Command_Line;\n+     (Config    : Command_Line_Configuration;\n+      Section   : String;\n       Switch    : String;\n       Parameter : String := \"\";\n       Unalias   : Boolean := True)\n@@ -1407,6 +1709,17 @@ package body GNAT.Command_Line is\n          Group  : String) return Boolean;\n       --  Perform the analysis of a group of switches\n \n+      Found_In_Config : Boolean := False;\n+      function Is_In_Config\n+        (Config_Switch : String; Index : Integer) return Boolean;\n+      --  If Switch is the same as Config_Switch, run the callback and sets\n+      --  Found_In_Config to True\n+\n+      function Starts_With\n+        (Config_Switch : String; Index : Integer) return Boolean;\n+      --  if Switch starts with Config_Switch, sets Found_In_Config to True.\n+      --  The return value is for the Foreach_Switch iterator\n+\n       --------------------\n       -- Group_Analysis --\n       --------------------\n@@ -1418,117 +1731,210 @@ package body GNAT.Command_Line is\n          Idx   : Natural;\n          Found : Boolean;\n \n-      begin\n-         Idx := Group'First;\n-         while Idx <= Group'Last loop\n-            Found := False;\n+         function Analyze_Simple_Switch\n+           (Switch : String; Index : Integer) return Boolean;\n \n-            for S in Cmd.Config.Switches'Range loop\n-               declare\n-                  Sw              : constant String :=\n-                                      Actual_Switch\n-                                        (Cmd.Config.Switches (S).all);\n-                  Full            : constant String :=\n-                                      Prefix & Group (Idx .. Group'Last);\n-                  Last            : Natural;\n-                  Param           : Natural;\n+         function Analyze_Simple_Switch\n+           (Switch : String; Index : Integer) return Boolean\n+         is\n+            pragma Unreferenced (Index);\n \n-               begin\n-                  if Sw'Length >= Prefix'Length\n+            Full  : constant String := Prefix & Group (Idx .. Group'Last);\n+            Sw    : constant String := Actual_Switch (Switch);\n+            Last  : Natural;\n+            Param : Natural;\n \n-                     --  Verify that sw starts with Prefix\n+         begin\n+            if Sw'Length >= Prefix'Length\n \n-                     and then Looking_At (Sw, Sw'First, Prefix)\n+            --  Verify that sw starts with Prefix\n \n-                     --  Verify that the group starts with sw\n+              and then Looking_At (Sw, Sw'First, Prefix)\n \n-                     and then Looking_At (Full, Full'First, Sw)\n-                  then\n-                     Last := Idx + Sw'Length - Prefix'Length - 1;\n-                     Param := Last + 1;\n+            --  Verify that the group starts with sw\n \n-                     if Can_Have_Parameter (Cmd.Config.Switches (S).all) then\n+              and then Looking_At (Full, Full'First, Sw)\n+            then\n+               Last  := Idx + Sw'Length - Prefix'Length - 1;\n+               Param := Last + 1;\n \n-                        --  Include potential parameter to the recursive call.\n-                        --  Only numbers are allowed.\n+               if Can_Have_Parameter (Switch) then\n \n-                        while Last < Group'Last\n-                          and then Group (Last + 1) in '0' .. '9'\n-                        loop\n-                           Last := Last + 1;\n-                        end loop;\n-                     end if;\n+                  --  Include potential parameter to the recursive call.\n+                  --  Only numbers are allowed.\n \n-                     if not Require_Parameter (Cmd.Config.Switches (S).all)\n-                       or else Last >= Param\n-                     then\n-                        if Idx = Group'First\n-                          and then Last = Group'Last\n-                          and then Last < Param\n-                        then\n-                           --  The group only concerns a single switch. Do not\n-                           --  perform recursive call.\n-\n-                           --  Note that we still perform a recursive call if\n-                           --  a parameter is detected in the switch, as this\n-                           --  is a way to correctly identify such a parameter\n-                           --  in aliases.\n-\n-                           return False;\n-                        end if;\n+                  while Last < Group'Last\n+                    and then Group (Last + 1) in '0' .. '9'\n+                  loop\n+                     Last := Last + 1;\n+                  end loop;\n+               end if;\n \n-                        Found := True;\n+               if not Require_Parameter (Switch)\n+                 or else Last >= Param\n+               then\n+                  if Idx = Group'First\n+                    and then Last = Group'Last\n+                    and then Last < Param\n+                  then\n+                     --  The group only concerns a single switch. Do not\n+                     --  perform recursive call.\n \n-                        --  Recursive call, using the detected parameter if any\n+                     --  Note that we still perform a recursive call if\n+                     --  a parameter is detected in the switch, as this\n+                     --  is a way to correctly identify such a parameter\n+                     --  in aliases.\n \n-                        if Last >= Param then\n-                           For_Each_Simple_Switch\n-                             (Cmd,\n-                              Prefix & Group (Idx .. Param - 1),\n-                              Group (Param .. Last));\n-                        else\n-                           For_Each_Simple_Switch\n-                             (Cmd, Prefix & Group (Idx .. Last), \"\");\n-                        end if;\n+                     return False;\n+                  end if;\n \n-                        Idx := Last + 1;\n-                        exit;\n-                     end if;\n+                  Found := True;\n+\n+                  --  Recursive call, using the detected parameter if any\n+\n+                  if Last >= Param then\n+                     For_Each_Simple_Switch\n+                       (Config,\n+                        Section,\n+                        Prefix & Group (Idx .. Param - 1),\n+                        Group (Param .. Last));\n+                  else\n+                     For_Each_Simple_Switch\n+                       (Config, Section, Prefix & Group (Idx .. Last), \"\");\n                   end if;\n-               end;\n-            end loop;\n+\n+                  Idx := Last + 1;\n+                  return False;\n+               end if;\n+            end if;\n+            return True;\n+         end Analyze_Simple_Switch;\n+\n+      begin\n+         Idx := Group'First;\n+         while Idx <= Group'Last loop\n+            Found := False;\n+\n+            Foreach_Switch (Config, Analyze_Simple_Switch'Access, Section);\n \n             if not Found then\n-               For_Each_Simple_Switch (Cmd, Prefix & Group (Idx), \"\");\n+               For_Each_Simple_Switch\n+                 (Config, Section, Prefix & Group (Idx), \"\");\n                Idx := Idx + 1;\n             end if;\n          end loop;\n \n          return True;\n       end Group_Analysis;\n \n+      ------------------\n+      -- Is_In_Config --\n+      ------------------\n+\n+      function Is_In_Config\n+        (Config_Switch : String; Index : Integer) return Boolean\n+      is\n+         Last  : Natural;\n+         P     : Switch_Parameter_Type;\n+      begin\n+         Decompose_Switch (Config_Switch, P, Last);\n+\n+         if Config_Switch (Config_Switch'First .. Last) = Switch then\n+            case P is\n+               when Parameter_None =>\n+                  if Parameter = \"\" then\n+                     Callback (Switch, \"\", \"\", Index => Index);\n+                     Found_In_Config := True;\n+                     return False;\n+                  end if;\n+\n+               when Parameter_With_Optional_Space\n+                  | Parameter_With_Space_Or_Equal =>\n+                  if Parameter /= \"\" then\n+                     Callback (Switch, \" \", Parameter, Index => Index);\n+                     Found_In_Config := True;\n+                     return False;\n+                  end if;\n+\n+               when Parameter_No_Space =>\n+                  if Parameter /= \"\" then\n+                     Callback (Switch, \"\", Parameter, Index);\n+                     Found_In_Config := True;\n+                     return False;\n+                  end if;\n+\n+               when Parameter_Optional =>\n+                  Callback (Switch, \"\", Parameter, Index);\n+                  Found_In_Config := True;\n+                  return False;\n+            end case;\n+         end if;\n+         return True;\n+      end Is_In_Config;\n+\n+      -----------------\n+      -- Starts_With --\n+      -----------------\n+\n+      function Starts_With\n+        (Config_Switch : String; Index : Integer) return Boolean\n+      is\n+         Last  : Natural;\n+         Param : Natural;\n+         P     : Switch_Parameter_Type;\n+      begin\n+         --  This function is called when we believe the parameter was\n+         --  specified as part of the switch, instead of separately. Thus we\n+         --  look in the config to find all possible switches.\n+\n+         Decompose_Switch (Config_Switch, P, Last);\n+         if Looking_At\n+           (Switch, Switch'First, Config_Switch (Config_Switch'First .. Last))\n+         then\n+            Param := Switch'First + Last;   --  First char of parameter\n+            Last  := Switch'First + Last - Config_Switch'First;\n+            --  last char of Switch\n+\n+            case P is\n+               when Parameter_None =>\n+                  null;  --  Already handled in Is_In_Config\n+               when Parameter_With_Space_Or_Equal =>\n+                  if Switch (Param) = ' '\n+                    or else Switch (Param) = '='\n+                  then\n+                     Callback (Switch (Switch'First .. Last),\n+                               \"=\", Switch (Param + 1 .. Switch'Last), Index);\n+                     Found_In_Config := True;\n+                     return False;\n+                  end if;\n+\n+               when Parameter_With_Optional_Space =>\n+                  if Switch (Param) = ' '  then\n+                     Param := Param + 1;\n+                  end if;\n+\n+                  Callback (Switch (Switch'First .. Last),\n+                            \" \", Switch (Param .. Switch'Last), Index);\n+                  Found_In_Config := True;\n+                  return False;\n+\n+               when Parameter_No_Space | Parameter_Optional =>\n+                  Callback (Switch (Switch'First .. Last),\n+                            \"\", Switch (Param .. Switch'Last), Index);\n+                  Found_In_Config := True;\n+                  return False;\n+            end case;\n+         end if;\n+         return True;\n+      end Starts_With;\n+\n    begin\n       --  First determine if the switch corresponds to one belonging to the\n       --  configuration. If so, run callback and exit.\n \n-      if Cmd.Config /= null and then Cmd.Config.Switches /= null then\n-         for S in Cmd.Config.Switches'Range loop\n-            declare\n-               Config_Switch : String renames Cmd.Config.Switches (S).all;\n-            begin\n-               if Actual_Switch (Config_Switch) = Switch\n-                    and then\n-                  ((Can_Have_Parameter (Config_Switch)\n-                      and then Parameter /= \"\")\n-                   or else\n-                   (not Require_Parameter (Config_Switch)\n-                       and then Parameter = \"\"))\n-               then\n-                  Callback (Switch, Parameter);\n-                  return;\n-               end if;\n-            end;\n-         end loop;\n+      Foreach_Switch (Config, Is_In_Config'Access, Section);\n+      if Found_In_Config then\n+         return;\n       end if;\n \n       --  If adding a switch that can in fact be expanded through aliases,\n@@ -1540,13 +1946,16 @@ package body GNAT.Command_Line is\n       --  be checked for a common prefix and split into simple switches.\n \n       if Unalias\n-        and then Cmd.Config /= null\n-        and then Cmd.Config.Aliases /= null\n+        and then Config /= null\n+        and then Config.Aliases /= null\n       then\n-         for A in Cmd.Config.Aliases'Range loop\n-            if Cmd.Config.Aliases (A).all = Switch and then Parameter = \"\" then\n+         for A in Config.Aliases'Range loop\n+            if Config.Aliases (A).Section.all = Section\n+              and then Config.Aliases (A).Alias.all = Switch\n+              and then Parameter = \"\"\n+            then\n                For_Each_Simple_Switch\n-                 (Cmd, Cmd.Config.Expansions (A).all, \"\");\n+                 (Config, Section, Config.Aliases (A).Expansion.all, \"\");\n                return;\n             end if;\n          end loop;\n@@ -1555,86 +1964,57 @@ package body GNAT.Command_Line is\n       --  If adding a switch grouping several switches, add each of the simple\n       --  switches instead.\n \n-      if Cmd.Config /= null and then Cmd.Config.Prefixes /= null then\n-         for P in Cmd.Config.Prefixes'Range loop\n-            if Switch'Length > Cmd.Config.Prefixes (P)'Length + 1\n+      if Config /= null and then Config.Prefixes /= null then\n+         for P in Config.Prefixes'Range loop\n+            if Switch'Length > Config.Prefixes (P)'Length + 1\n               and then Looking_At\n-                (Switch, Switch'First, Cmd.Config.Prefixes (P).all)\n+                (Switch, Switch'First, Config.Prefixes (P).all)\n             then\n                --  Alias expansion will be done recursively\n \n-               if Cmd.Config.Switches = null then\n-                  for S in Switch'First + Cmd.Config.Prefixes (P)'Length\n+               if Config.Switches = null then\n+                  for S in Switch'First + Config.Prefixes (P)'Length\n                             .. Switch'Last\n                   loop\n                      For_Each_Simple_Switch\n-                       (Cmd, Cmd.Config.Prefixes (P).all & Switch (S), \"\");\n+                       (Config, Section,\n+                        Config.Prefixes (P).all & Switch (S), \"\");\n                   end loop;\n \n                   return;\n \n                elsif Group_Analysis\n-                 (Cmd.Config.Prefixes (P).all,\n+                 (Config.Prefixes (P).all,\n                   Switch\n-                    (Switch'First + Cmd.Config.Prefixes (P)'Length\n-                      .. Switch'Last))\n+                    (Switch'First + Config.Prefixes (P)'Length .. Switch'Last))\n                then\n                   --  Recursive calls already done on each switch of the group:\n                   --  Return without executing Callback.\n-\n                   return;\n                end if;\n             end if;\n          end loop;\n       end if;\n \n       --  Test if added switch is a known switch with parameter attached\n+      --  instead of being specified separately\n \n       if Parameter = \"\"\n-        and then Cmd.Config /= null\n-        and then Cmd.Config.Switches /= null\n+        and then Config /= null\n+        and then Config.Switches /= null\n       then\n-         for S in Cmd.Config.Switches'Range loop\n-            declare\n-               Sw    : constant String :=\n-                         Actual_Switch (Cmd.Config.Switches (S).all);\n-               Last  : Natural;\n-               Param : Natural;\n-\n-            begin\n-               --  Verify that switch starts with Sw\n-               --  What if the \"verification\" fails???\n-\n-               if Switch'Length >= Sw'Length\n-                 and then Looking_At (Switch, Switch'First, Sw)\n-               then\n-                  Param := Switch'First + Sw'Length - 1;\n-                  Last := Param;\n-\n-                  if Can_Have_Parameter (Cmd.Config.Switches (S).all) then\n-                     while Last < Switch'Last\n-                       and then Switch (Last + 1) in '0' .. '9'\n-                     loop\n-                        Last := Last + 1;\n-                     end loop;\n-                  end if;\n-\n-                  --  If full Switch is a known switch with attached parameter\n-                  --  then we use this parameter in the callback.\n-\n-                  if Last = Switch'Last then\n-                     Callback\n-                       (Switch (Switch'First .. Param),\n-                        Switch (Param + 1 .. Last));\n-                     return;\n-\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n+         Found_In_Config := False;\n+         Foreach_Switch (Config, Starts_With'Access, Section);\n+         if Found_In_Config then\n+            return;\n+         end if;\n       end if;\n \n-      Callback (Switch, Parameter);\n+      --  The switch is invalid in the config, but we still want to report it.\n+      --  The config could, for instance, include \"*\" to specify it accepts\n+      --  all switches.\n+\n+      Callback (Switch, \" \", Parameter, Index => -1);\n    end For_Each_Simple_Switch;\n \n    ----------------\n@@ -1645,15 +2025,14 @@ package body GNAT.Command_Line is\n      (Cmd        : in out Command_Line;\n       Switch     : String;\n       Parameter  : String    := \"\";\n-      Separator  : Character := ' ';\n       Section    : String    := \"\";\n       Add_Before : Boolean   := False)\n    is\n       Success : Boolean;\n       pragma Unreferenced (Success);\n    begin\n       Add_Switch\n-        (Cmd, Switch, Parameter, Separator, Section, Add_Before, Success);\n+        (Cmd, Switch, Parameter, Section, Add_Before, Success);\n    end Add_Switch;\n \n    ----------------\n@@ -1664,20 +2043,23 @@ package body GNAT.Command_Line is\n      (Cmd        : in out Command_Line;\n       Switch     : String;\n       Parameter  : String := \"\";\n-      Separator  : Character := ' ';\n       Section    : String := \"\";\n       Add_Before : Boolean := False;\n       Success    : out Boolean)\n    is\n-      procedure Add_Simple_Switch (Simple : String; Param : String);\n+      procedure Add_Simple_Switch\n+        (Simple, Separator, Param : String; Index : Integer);\n       --  Add a new switch that has had all its aliases expanded, and switches\n       --  ungrouped. We know there are no more aliases in Switches.\n \n       -----------------------\n       -- Add_Simple_Switch --\n       -----------------------\n \n-      procedure Add_Simple_Switch (Simple : String; Param : String) is\n+      procedure Add_Simple_Switch\n+        (Simple, Separator, Param : String; Index : Integer)\n+      is\n+         pragma Unreferenced (Index);\n       begin\n          if Cmd.Expanded = null then\n             Cmd.Expanded := new Argument_List'(1 .. 1 => new String'(Simple));\n@@ -1751,7 +2133,7 @@ package body GNAT.Command_Line is\n       end Add_Simple_Switch;\n \n       procedure Add_Simple_Switches is\n-         new For_Each_Simple_Switch (Add_Simple_Switch);\n+        new For_Each_Simple_Switch (Add_Simple_Switch);\n \n    --  Start of processing for Add_Switch\n \n@@ -1771,7 +2153,7 @@ package body GNAT.Command_Line is\n       end if;\n \n       Success := False;\n-      Add_Simple_Switches (Cmd, Switch, Parameter);\n+      Add_Simple_Switches (Cmd.Config, Section, Switch, Parameter);\n       Free (Cmd.Coalesce);\n    end Add_Switch;\n \n@@ -1857,16 +2239,19 @@ package body GNAT.Command_Line is\n       Section       : String  := \"\";\n       Success       : out Boolean)\n    is\n-      procedure Remove_Simple_Switch (Simple : String; Param : String);\n+      procedure Remove_Simple_Switch\n+        (Simple, Separator, Param : String; Index : Integer);\n       --  Removes a simple switch, with no aliasing or grouping\n \n       --------------------------\n       -- Remove_Simple_Switch --\n       --------------------------\n \n-      procedure Remove_Simple_Switch (Simple : String; Param : String) is\n+      procedure Remove_Simple_Switch\n+        (Simple, Separator, Param : String; Index : Integer)\n+      is\n          C : Integer;\n-         pragma Unreferenced (Param);\n+         pragma Unreferenced (Param, Separator, Index);\n \n       begin\n          if Cmd.Expanded /= null then\n@@ -1904,7 +2289,8 @@ package body GNAT.Command_Line is\n \n    begin\n       Success := False;\n-      Remove_Simple_Switches (Cmd, Switch, \"\", Unalias => not Has_Parameter);\n+      Remove_Simple_Switches\n+        (Cmd.Config, Section, Switch, \"\", Unalias => not Has_Parameter);\n       Free (Cmd.Coalesce);\n    end Remove_Switch;\n \n@@ -1918,14 +2304,18 @@ package body GNAT.Command_Line is\n       Parameter : String;\n       Section   : String  := \"\")\n    is\n-      procedure Remove_Simple_Switch (Simple : String; Param : String);\n+      procedure Remove_Simple_Switch\n+        (Simple, Separator, Param : String; Index : Integer);\n       --  Removes a simple switch, with no aliasing or grouping\n \n       --------------------------\n       -- Remove_Simple_Switch --\n       --------------------------\n \n-      procedure Remove_Simple_Switch (Simple : String; Param : String) is\n+      procedure Remove_Simple_Switch\n+        (Simple, Separator, Param : String; Index : Integer)\n+      is\n+         pragma Unreferenced (Separator, Index);\n          C : Integer;\n \n       begin\n@@ -1968,12 +2358,12 @@ package body GNAT.Command_Line is\n       end Remove_Simple_Switch;\n \n       procedure Remove_Simple_Switches is\n-         new For_Each_Simple_Switch (Remove_Simple_Switch);\n+        new For_Each_Simple_Switch (Remove_Simple_Switch);\n \n    --  Start of processing for Remove_Switch\n \n    begin\n-      Remove_Simple_Switches (Cmd, Switch, Parameter);\n+      Remove_Simple_Switches (Cmd.Config, Switch, Parameter);\n       Free (Cmd.Coalesce);\n    end Remove_Switch;\n \n@@ -2113,17 +2503,24 @@ package body GNAT.Command_Line is\n       Found : Boolean;\n       First : Natural;\n \n-      procedure Check_Cb (Switch : String; Param : String);\n-      --  Comment required ???\n+      procedure Check_Cb (Switch, Separator, Param : String; Index : Integer);\n+      --  Checks whether the command line contains [Switch].\n+      --  Sets the global variable [Found] appropriately.\n+      --  This will be called for each simple switch that make up an alias, to\n+      --  know whether the alias should be applied.\n \n-      procedure Remove_Cb (Switch : String; Param : String);\n-      --  Comment required ???\n+      procedure Remove_Cb (Switch, Separator, Param : String; Index : Integer);\n+      --  Remove the simple switch [Switch] from the command line, since it is\n+      --  part of a simpler alias\n \n       --------------\n       -- Check_Cb --\n       --------------\n \n-      procedure Check_Cb (Switch : String; Param : String) is\n+      procedure Check_Cb\n+        (Switch, Separator, Param : String; Index : Integer)\n+      is\n+         pragma Unreferenced (Separator, Index);\n       begin\n          if Found then\n             for E in Result'Range loop\n@@ -2146,7 +2543,9 @@ package body GNAT.Command_Line is\n       -- Remove_Cb --\n       ---------------\n \n-      procedure Remove_Cb (Switch : String; Param : String) is\n+      procedure Remove_Cb (Switch, Separator, Param : String; Index : Integer)\n+      is\n+         pragma Unreferenced (Separator, Index);\n       begin\n          for E in Result'Range loop\n             if Result (E) /= null\n@@ -2185,12 +2584,16 @@ package body GNAT.Command_Line is\n          --  then check whether the expanded command line has all of them.\n \n          Found := True;\n-         Check_All (Cmd, Cmd.Config.Expansions (A).all);\n+         Check_All (Cmd.Config,\n+                    Switch  => Cmd.Config.Aliases (A).Expansion.all,\n+                    Section => Cmd.Config.Aliases (A).Section.all);\n \n          if Found then\n             First := Integer'Last;\n-            Remove_All (Cmd, Cmd.Config.Expansions (A).all);\n-            Result (First) := new String'(Cmd.Config.Aliases (A).all);\n+            Remove_All (Cmd.Config,\n+                        Switch  => Cmd.Config.Aliases (A).Expansion.all,\n+                        Section => Cmd.Config.Aliases (A).Section.all);\n+            Result (First) := new String'(Cmd.Config.Aliases (A).Alias.all);\n          end if;\n       end loop;\n    end Alias_Switches;\n@@ -2257,6 +2660,8 @@ package body GNAT.Command_Line is\n             end if;\n          end loop;\n       end loop;\n+\n+      Unchecked_Free (Sections_List);\n    end Sort_Sections;\n \n    -----------\n@@ -2288,13 +2693,15 @@ package body GNAT.Command_Line is\n             Cmd.Coalesce (E) := new String'(Cmd.Expanded (E).all);\n          end loop;\n \n+         Free (Cmd.Coalesce_Sections);\n          Cmd.Coalesce_Sections := new Argument_List (Cmd.Sections'Range);\n          for E in Cmd.Sections'Range loop\n             Cmd.Coalesce_Sections (E) :=\n               (if Cmd.Sections (E) = null then null\n                else new String'(Cmd.Sections (E).all));\n          end loop;\n \n+         Free (Cmd.Coalesce_Params);\n          Cmd.Coalesce_Params := new Argument_List (Cmd.Params'Range);\n          for E in Cmd.Params'Range loop\n             Cmd.Coalesce_Params (E) :=\n@@ -2453,13 +2860,37 @@ package body GNAT.Command_Line is\n    ----------\n \n    procedure Free (Config : in out Command_Line_Configuration) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Switch_Definitions, Switch_Definitions_List);\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Alias_Definitions, Alias_Definitions_List);\n    begin\n       if Config /= null then\n-         Free (Config.Aliases);\n-         Free (Config.Expansions);\n          Free (Config.Prefixes);\n          Free (Config.Sections);\n-         Free (Config.Switches);\n+         Free (Config.Usage);\n+         Free (Config.Help);\n+\n+         if Config.Aliases /= null then\n+            for A in Config.Aliases'Range loop\n+               Free (Config.Aliases (A).Alias);\n+               Free (Config.Aliases (A).Expansion);\n+               Free (Config.Aliases (A).Section);\n+            end loop;\n+            Unchecked_Free (Config.Aliases);\n+         end if;\n+\n+         if Config.Switches /= null then\n+            for S in Config.Switches'Range loop\n+               Free (Config.Switches (S).Switch);\n+               Free (Config.Switches (S).Long_Switch);\n+               Free (Config.Switches (S).Help);\n+               Free (Config.Switches (S).Section);\n+            end loop;\n+\n+            Unchecked_Free (Config.Switches);\n+         end if;\n+\n          Unchecked_Free (Config);\n       end if;\n    end Free;\n@@ -2472,7 +2903,429 @@ package body GNAT.Command_Line is\n    begin\n       Free (Cmd.Expanded);\n       Free (Cmd.Coalesce);\n+      Free (Cmd.Coalesce_Sections);\n+      Free (Cmd.Coalesce_Params);\n       Free (Cmd.Params);\n+      Free (Cmd.Sections);\n    end Free;\n \n+   ---------------\n+   -- Set_Usage --\n+   ---------------\n+\n+   procedure Set_Usage\n+     (Config : in out Command_Line_Configuration;\n+      Usage  : String := \"[switches] [arguments]\";\n+      Help   : String := \"\")\n+   is\n+   begin\n+      if Config = null then\n+         Config := new Command_Line_Configuration_Record;\n+      end if;\n+\n+      Free (Config.Usage);\n+      Config.Usage := new String'(Usage);\n+      Config.Help  := new String'(Help);\n+   end Set_Usage;\n+\n+   ------------------\n+   -- Display_Help --\n+   ------------------\n+\n+   procedure Display_Help (Config : Command_Line_Configuration) is\n+      function Switch_Name\n+        (Def : Switch_Definition; Section : String) return String;\n+      --  Return the \"-short, --long=ARG\" string for Def.\n+      --  Returns \"\" if the switch is not in the section\n+\n+      function Param_Name\n+        (P : Switch_Parameter_Type; Name : String := \"ARG\") return String;\n+      --  Return the display for a switch parameter\n+\n+      procedure Display_Section_Help (Section : String);\n+      --  Display the help for a specific section (\"\" is the default section)\n+\n+      function Param_Name\n+        (P : Switch_Parameter_Type; Name : String := \"ARG\") return String is\n+      begin\n+         case P is\n+            when Parameter_None =>\n+               return \"\";\n+\n+            when Parameter_With_Optional_Space =>\n+               return \" \" & To_Upper (Name);\n+\n+            when Parameter_With_Space_Or_Equal =>\n+               return \"=\" & To_Upper (Name);\n+\n+            when Parameter_No_Space =>\n+               return To_Upper (Name);\n+\n+            when Parameter_Optional =>\n+               return '[' & To_Upper (Name) & ']';\n+         end case;\n+      end Param_Name;\n+\n+      function Switch_Name\n+        (Def : Switch_Definition; Section : String) return String\n+      is\n+         use Ada.Strings.Unbounded;\n+         Result       : Unbounded_String;\n+         P1, P2       : Switch_Parameter_Type;\n+         Last1, Last2 : Integer := 0;\n+      begin\n+         if (Section = \"\" and then Def.Section = null)\n+           or else (Def.Section /= null and then Def.Section.all = Section)\n+         then\n+            if Def.Switch /= null\n+              and then Def.Switch.all = \"*\"\n+            then\n+               return \"[any switch]\";\n+            end if;\n+\n+            if Def.Switch /= null then\n+               Decompose_Switch (Def.Switch.all, P1, Last1);\n+               Append (Result, Def.Switch (Def.Switch'First .. Last1));\n+\n+               if Def.Long_Switch /= null then\n+                  Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n+                  Append (Result, \", \"\n+                          & Def.Long_Switch (Def.Long_Switch'First .. Last2));\n+                  Append (Result, Param_Name (P2, \"ARG\"));\n+\n+               else\n+                  Append (Result, Param_Name (P1, \"ARG\"));\n+               end if;\n+\n+            else  --  Long_Switch necessarily not null\n+               Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n+               Append (Result,\n+                       Def.Long_Switch (Def.Long_Switch'First .. Last2));\n+               Append (Result, Param_Name (P2, \"ARG\"));\n+            end if;\n+         end if;\n+\n+         return To_String (Result);\n+      end Switch_Name;\n+\n+      procedure Display_Section_Help (Section : String) is\n+         Max_Len : Natural := 0;\n+      begin\n+         --  ??? Special display for \"*\"\n+\n+         New_Line;\n+\n+         if Section /= \"\" then\n+            Put_Line (\"Switches after \" & Section);\n+         end if;\n+\n+         --  Compute size of the switches column\n+\n+         for S in Config.Switches'Range loop\n+            Max_Len := Natural'Max\n+              (Max_Len, Switch_Name (Config.Switches (S), Section)'Length);\n+         end loop;\n+\n+         if Config.Aliases /= null then\n+            for A in Config.Aliases'Range loop\n+               if Config.Aliases (A).Section.all = Section then\n+                  Max_Len := Natural'Max\n+                    (Max_Len, Config.Aliases (A).Alias'Length);\n+               end if;\n+            end loop;\n+         end if;\n+\n+         --  Display the switches\n+\n+         for S in Config.Switches'Range loop\n+            declare\n+               N : constant String :=\n+                 Switch_Name (Config.Switches (S), Section);\n+            begin\n+               if N /= \"\" then\n+                  Put (\" \");\n+                  Put (N);\n+                  Put ((1 .. Max_Len - N'Length + 1 => ' '));\n+\n+                  if Config.Switches (S).Help /= null then\n+                     Put (Config.Switches (S).Help.all);\n+                  end if;\n+\n+                  New_Line;\n+               end if;\n+            end;\n+         end loop;\n+\n+         --  Display the aliases\n+\n+         if Config.Aliases /= null then\n+            for A in Config.Aliases'Range loop\n+               if Config.Aliases (A).Section.all = Section then\n+                  Put (\" \");\n+                  Put (Config.Aliases (A).Alias.all);\n+                  Put ((1 .. Max_Len - Config.Aliases (A).Alias'Length + 1\n+                       => ' '));\n+                  Put (\"Equivalent to \" & Config.Aliases (A).Expansion.all);\n+                  New_Line;\n+               end if;\n+            end loop;\n+         end if;\n+      end Display_Section_Help;\n+\n+   begin\n+      if Config = null then\n+         return;\n+      end if;\n+\n+      if Config.Usage /= null then\n+         Put_Line (\"Usage: \"\n+                   & Base_Name\n+                     (Ada.Command_Line.Command_Name) & \" \" & Config.Usage.all);\n+      else\n+         Put_Line (\"Usage: \" & Base_Name (Ada.Command_Line.Command_Name)\n+                   & \" [switches] [arguments]\");\n+      end if;\n+\n+      if Config.Help /= null and then Config.Help.all /= \"\" then\n+         Put_Line (Config.Help.all);\n+      end if;\n+\n+      Display_Section_Help (\"\");\n+      if Config.Sections /= null and then Config.Switches /= null then\n+         for S in Config.Sections'Range loop\n+            Display_Section_Help (Config.Sections (S).all);\n+         end loop;\n+      end if;\n+   end Display_Help;\n+\n+   ------------\n+   -- Getopt --\n+   ------------\n+\n+   procedure Getopt\n+     (Config   : Command_Line_Configuration;\n+      Callback : Switch_Handler := null;\n+      Parser   : Opt_Parser := Command_Line_Parser)\n+   is\n+      Getopt_Switches : String_Access;\n+      C   : Character := ASCII.NUL;\n+\n+      Empty_Name : aliased constant String := \"\";\n+      Current_Section : Integer := -1;\n+      Section_Name : not null access constant String := Empty_Name'Access;\n+\n+      procedure Simple_Callback\n+        (Simple_Switch, Separator, Parameter : String; Index : Integer);\n+      procedure Do_Callback (Switch, Parameter : String; Index : Integer);\n+\n+      procedure Do_Callback (Switch, Parameter : String; Index : Integer) is\n+      begin\n+         --  Do automatic handling when possible\n+\n+         if Index /= -1 then\n+            case Config.Switches (Index).Typ is\n+               when Switch_Untyped =>\n+                  null;   --  no automatic handling\n+\n+               when Switch_Boolean =>\n+                  Config.Switches (Index).Boolean_Output.all :=\n+                    Config.Switches (Index).Boolean_Value;\n+                  return;\n+\n+               when Switch_Integer =>\n+                  begin\n+                     if Parameter = \"\" then\n+                        Config.Switches (Index).Integer_Output.all :=\n+                          Config.Switches (Index).Integer_Default;\n+                     else\n+                        Config.Switches (Index).Integer_Output.all :=\n+                          Integer'Value (Parameter);\n+                     end if;\n+                  exception\n+                     when Constraint_Error =>\n+                        raise Invalid_Parameter\n+                          with \"Expected integer parameter for '\"\n+                            & Switch & \"'\";\n+                  end;\n+\n+               when Switch_String =>\n+                  Free (Config.Switches (Index).String_Output.all);\n+                  Config.Switches (Index).String_Output.all :=\n+                    new String'(Parameter);\n+            end case;\n+         end if;\n+\n+         --  Otherwise calls the user callback if one was defined\n+\n+         if Callback /= null then\n+            Callback (Switch    => Switch,\n+                      Parameter => Parameter,\n+                      Section   => Section_Name.all);\n+         end if;\n+      end Do_Callback;\n+\n+      procedure Simple_Callback\n+        (Simple_Switch, Separator, Parameter : String; Index : Integer)\n+      is\n+         pragma Unreferenced (Separator);\n+      begin\n+         Do_Callback (Switch    => Simple_Switch,\n+                      Parameter => Parameter,\n+                      Index     => Index);\n+      end Simple_Callback;\n+\n+      procedure For_Each_Simple\n+        is new For_Each_Simple_Switch (Simple_Callback);\n+\n+   begin\n+      --  Initialize sections\n+\n+      if Config.Sections = null then\n+         Config.Sections := new Argument_List'(1 .. 0 => null);\n+      end if;\n+\n+      Internal_Initialize_Option_Scan\n+        (Parser                   => Parser,\n+         Switch_Char              => Parser.Switch_Character,\n+         Stop_At_First_Non_Switch => Parser.Stop_At_First,\n+         Section_Delimiters       => Section_Delimiters (Config));\n+\n+      Getopt_Switches := new String'\n+        (Get_Switches (Config, Section_Name.all, Parser.Switch_Character)\n+         & \" h -help\");\n+\n+      --  Initialize output values for automatically handled switches\n+\n+      for S in Config.Switches'Range loop\n+         case Config.Switches (S).Typ is\n+            when Switch_Untyped =>\n+               null;   --  Nothing to do\n+\n+            when Switch_Boolean =>\n+               Config.Switches (S).Boolean_Output.all :=\n+                 not Config.Switches (S).Boolean_Value;\n+\n+            when Switch_Integer =>\n+               Config.Switches (S).Integer_Output.all :=\n+                 Config.Switches (S).Integer_Initial;\n+\n+            when Switch_String =>\n+               Config.Switches (S).String_Output.all := new String'(\"\");\n+         end case;\n+      end loop;\n+\n+      --  For all sections, and all switches within those sections\n+\n+      loop\n+         C := Getopt (Switches    => Getopt_Switches.all,\n+                      Concatenate => True,\n+                      Parser      => Parser);\n+\n+         if C = '*' then\n+            --  Full_Switch already includes the leading '-'\n+\n+            Do_Callback (Switch    => Full_Switch (Parser),\n+                         Parameter => Parameter (Parser),\n+                         Index     => -1);\n+\n+         elsif C /= ASCII.NUL then\n+            if Full_Switch (Parser) = \"h\"\n+              or else Full_Switch (Parser) = \"-help\"\n+            then\n+               Display_Help (Config);\n+               raise Exit_From_Command_Line;\n+            end if;\n+\n+            --  Do switch expansion if needed\n+            For_Each_Simple\n+              (Config,\n+               Section   => Section_Name.all,\n+               Switch    => Parser.Switch_Character & Full_Switch (Parser),\n+               Parameter => Parameter (Parser));\n+\n+         else\n+            if Current_Section = -1 then\n+               Current_Section := Config.Sections'First;\n+            else\n+               Current_Section := Current_Section + 1;\n+            end if;\n+\n+            exit when Current_Section > Config.Sections'Last;\n+\n+            Section_Name := Config.Sections (Current_Section);\n+            Goto_Section (Section_Name.all, Parser);\n+\n+            Free (Getopt_Switches);\n+            Getopt_Switches := new String'\n+              (Get_Switches\n+                 (Config, Section_Name.all, Parser.Switch_Character));\n+         end if;\n+      end loop;\n+\n+      Free (Getopt_Switches);\n+\n+   exception\n+      when Invalid_Switch =>\n+         Free (Getopt_Switches);\n+\n+         --  Message inspired by \"ls\" on Unix\n+         Put_Line (Standard_Error,\n+                   Base_Name (Ada.Command_Line.Command_Name)\n+                   & \": unrecognized option '\"\n+                   & Parser.Switch_Character & Full_Switch (Parser)\n+                   & \"'\");\n+         Put_Line (Standard_Error,\n+                   \"Try `\"\n+                   & Base_Name (Ada.Command_Line.Command_Name)\n+                   & \" --help` for more information.\");\n+\n+         raise;\n+\n+      when others =>\n+         Free (Getopt_Switches);\n+         raise;\n+   end Getopt;\n+\n+   -----------\n+   -- Build --\n+   -----------\n+\n+   procedure Build\n+     (Line        : in out Command_Line;\n+      Args        : out GNAT.OS_Lib.Argument_List_Access;\n+      Expanded    : Boolean := False;\n+      Switch_Char : Character := '-')\n+   is\n+      Iter  : Command_Line_Iterator;\n+      Count : Natural := 0;\n+   begin\n+      Start (Line, Iter, Expanded => Expanded);\n+      while Has_More (Iter) loop\n+         if Is_New_Section (Iter) then\n+            Count := Count + 1;\n+         end if;\n+\n+         Count := Count + 1;\n+         Next (Iter);\n+      end loop;\n+\n+      Args := new Argument_List (1 .. Count);\n+      Count := Args'First;\n+\n+      Start (Line, Iter, Expanded => Expanded);\n+      while Has_More (Iter) loop\n+         if Is_New_Section (Iter) then\n+            Args (Count) := new String'\n+              (Switch_Char & Current_Section (Iter));\n+            Count := Count + 1;\n+         end if;\n+\n+         Args (Count) := new String'(Current_Switch (Iter)\n+                                     & Current_Separator (Iter)\n+                                     & Current_Parameter (Iter));\n+         Count := Count + 1;\n+         Next (Iter);\n+      end loop;\n+   end Build;\n+\n end GNAT.Command_Line;"}, {"sha": "7caf0fa75507520cd60b87449bd3ed982b03490f", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 307, "deletions": 85, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b799980e58fb0c6d760ddb88c5856b6314efc4b4/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b799980e58fb0c6d760ddb88c5856b6314efc4b4/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=b799980e58fb0c6d760ddb88c5856b6314efc4b4", "patch": "@@ -42,12 +42,15 @@\n --  As shown in the example below, one should first retrieve the switches\n --  (special command line arguments starting with '-' by default) and their\n --  parameters, and then the rest of the command line arguments.\n-\n---  This package is flexible enough to accommodate various needs: optional\n---  switch parameters, various characters to separate a switch and its\n---  parameter, whether to stop the parsing at the first non-switch argument\n---  encountered, etc.\n-\n+--\n+--  While it may appear easy to parse the command line arguments with\n+--  Ada.Command_Line, there are in fact lots of special cases to handle in some\n+--  applications. Those are fully managed by GNAT.Command_Line. Among these are\n+--  switches with optional parameters, grouping switches (for instance \"-ab\"\n+--  might mean the same as \"-a -b\"), various characters to separate a switch\n+--  and its parameter (or none: \"-a 1\" and \"-a1\" are generally the same, which\n+--  can introduce confusion with grouped switches),...\n+--\n --  begin\n --     loop\n --        case Getopt (\"a b: ad\") is  -- Accepts '-a', '-ad', or '-b argument'\n@@ -60,8 +63,7 @@\n --                    Put_Line (\"Got ad\");\n --                 end if;\n \n---           when 'b' =>\n---              Put_Line (\"Got b + \" & Parameter);\n+--           when 'b' => Put_Line (\"Got b + \" & Parameter);\n \n --           when others =>\n --              raise Program_Error;         -- cannot occur!\n@@ -143,17 +145,13 @@\n --  end;\n \n ----------------------------------------------\n---  Creating and manipulating the command line\n+--  High level command line configuration\n ----------------------------------------------\n \n---  This package provides mechanisms to create and modify command lines by\n---  adding or removing arguments from them. The resulting command line is kept\n---  as short as possible by coalescing arguments whenever possible.\n-\n---  Complex command lines can thus be constructed, for example from a GUI\n---  (although this package does not by itself depend upon any specific GUI\n---  toolkit). For instance, if you are configuring the command line to use when\n---  spawning a tool with the following characteristics:\n+--  As shown above, the code is still relatively low-level. For instance, there\n+--  is no way to indicate which switches are related (thus if \"-l\" and \"--long\"\n+--  should have the same effect, your code will need to test for both cases).\n+--  Likewise, it is difficult to handle more advanced constructs, like:\n \n --    * Specifying -gnatwa is the same as specifying -gnatwu -gnatwv, but\n --      shorter and more readable\n@@ -163,23 +161,81 @@\n --      Of course, this can be combined with the above and -gnatwacd is the\n --      same as -gnatwc -gnatwd -gnatwu -gnatwv\n \n---    * The switch -T is the same as -gnatwAB\n+--    * The switch -T is the same as -gnatwAB (same as -gnatwA -gnatwB)\n \n---    * A switch -foo takes one mandatory parameter\n+--  With the above form of Getopt, you would receive \"-gnatwa\", \"-T\" or\n+--  \"-gnatwcd\" in the examples above, and thus you require additional manual\n+--  parsing of the switch.\n \n---  These properties can be configured through this package with the following\n---  calls:\n+--  Instead, this package provides the type Command_Line_Configuration, which\n+--  stores all the knowledge above. For instance:\n \n --     Config : Command_Line_Configuration;\n+--     Define_Alias  (Config, \"-gnatwa\", \"-gnatwu -gnatwv\");\n --     Define_Prefix (Config, \"-gnatw\");\n---     Define_Alias  (Config, \"-gnatwa\", \"-gnatwuv\");\n --     Define_Alias  (Config, \"-T\",      \"-gnatwAB\");\n \n---  Using this configuration, one can then construct a command line for the\n---  tool with:\n+--  You then need to specify all possible switches in your application by\n+--  calling Define_Switch, for instance:\n+\n+--     Define_Switch (Config, \"-gnatwu\", Help => \"warn on unused entities\");\n+--     Define_Switch (Config, \"-gnatwv\", Help => \"warn on unassigned var\");\n+--     ...\n+\n+--  Specifying the help message is optional, but makes it easy to then call\n+--  the function\n+--     Display_Help (Config);\n+--  that will display a properly formatted help message for your application,\n+--  listing all possible switches. That way you have a single place in which\n+--  to maintain the list of switches and their meaning, rather than maintaing\n+--  both the string to pass to Getopt and a subprogram to display the help.\n+--  Both will properly stay synchronized.\n+\n+--  Once you have this Config, you just have to call\n+--     Getopt (Config, Callback'Access);\n+--  to parse the command line. The Callback will be called for each switch\n+--  found on the command line (in the case of our example, that is \"-gnatwu\"\n+--  and then \"-gnatwv\", not \"-gnatwa\" itself). This simplifies command line\n+--  parsing a lot.\n+\n+--  In fact, this can be further automated for the most command case where the\n+--  parameter passed to a switch is stored in a variable in the application.\n+--  When a switch is defined, you only have to indicate where to store the\n+--  value, and let Getopt do the rest. For instance:\n+\n+--     Optimization : aliased Integer;\n+--     Verbose      : aliased Boolean;\n+--\n+--     Define_Switch (Config, Verbose'Access,\n+--                    \"-v\", Long_Switch => \"--verbose\",\n+--                    Help => \"Output extra verbose information\");\n+--     Define_Switch (Config, Optimization'Access,\n+--                    \"-O?\", Help => \"Optimization level\");\n+--\n+--     Getopt (Config);  --  No callback\n+\n+--  Since all switches are handled automatically, we don't even need to pass\n+--  a callback to Getopt. Once getopt has been called, the two variables\n+--  Optimization and Verbose have been properly initialized, either to the\n+--  default value or to the value found on the command line.\n+\n+----------------------------------------------\n+--  Creating and manipulating the command line\n+----------------------------------------------\n+\n+--  This package provides mechanisms to create and modify command lines by\n+--  adding or removing arguments from them. The resulting command line is kept\n+--  as short as possible by coalescing arguments whenever possible.\n+\n+--  Complex command lines can thus be constructed, for example from a GUI\n+--  (although this package does not by itself depend upon any specific GUI\n+--  toolkit).\n+\n+--  Using the configuration defined earlier, one can then construct a command\n+--  line for the tool with:\n \n --     Cmd : Command_Line;\n---     Set_Configuration (Cmd, Config);\n+--     Set_Configuration (Cmd, Config);   --  Config created earlier\n --     Add_Switch (Cmd, \"-bar\");\n --     Add_Switch (Cmd, \"-gnatwu\");\n --     Add_Switch (Cmd, \"-gnatwv\");  --  will be grouped with the above\n@@ -219,44 +275,11 @@\n --  This ensures that \"arg1\" will always be treated as the argument to -foo,\n --  and will not be grouped with other parts of the command line.\n \n----------------------------------------------------\n---  Parsing the command line with grouped arguments\n----------------------------------------------------\n-\n---  The command line construction facility can also be used in conjunction with\n---  Getopt to interpret a command line. For example when implementing the tool\n---  described above, you would do a first loop with Getopt to pass the switches\n---  and their arguments, and create a temporary representation of the command\n---  line as a Command_Line object. Finally, you can query each individual\n---  switch from that object. For instance:\n-\n---    declare\n---      Cmd  : Command_Line;\n---      Iter : Command_Line_Iterator;\n-\n---    begin\n---      while Getopt (\"foo: gnatw! T bar\") /= ASCII.NUL loop\n---         Add_Switch (Cmd, Full_Switch, Parameter);\n---      end loop;\n-\n---      Start (Cmd, Iter, Expanded => True);\n---      while Has_More (Iter) loop\n---        if Current_Switch (Iter) = \"-gnatwu\" then\n---           ...\n---        elsif Current_Switch (Iter) = \"-gnatwv\" then\n---           ...\n---        end if;\n---        Next (Iter);\n---      end loop;\n-\n---  The above means that your tool does not have to handle on its own whether\n---  the user passed -gnatwa (in which case -gnatwu was indeed selected), or\n---  just -gnatwu, or a combination of -gnatw switches as in -gnatwuv.\n-\n with Ada.Command_Line;\n with GNAT.Directory_Operations;\n with GNAT.OS_Lib;\n with GNAT.Regexp;\n+with GNAT.Strings;\n \n package GNAT.Command_Line is\n \n@@ -343,6 +366,11 @@ package GNAT.Command_Line is\n    --  first character). Does not include the Switch_Char ('-' by default),\n    --  unless the \"*\" option of Getopt is used (see below).\n \n+   function Current_Section\n+     (Parser : Opt_Parser := Command_Line_Parser) return String;\n+   --  Return the name of the current section.\n+   --  The list of valid sections is defined through Initialize_Option_Scan\n+\n    function Getopt\n      (Switches    : String;\n       Concatenate : Boolean := True;\n@@ -519,14 +547,28 @@ package GNAT.Command_Line is\n \n    type Command_Line_Configuration is private;\n \n+   procedure Define_Section\n+     (Config  : in out Command_Line_Configuration;\n+      Section : String);\n+   --  Indicates a new switch section. All switches belonging to the same\n+   --  section are ordered together, preceded by the section. They are placed\n+   --  at the end of the command line (as in \"gnatmake somefile.adb -cargs -g\")\n+   --  The section name should not include the leading '-'.\n+   --  So for instance in the case of gnatmake we would use:\n+   --      Define_Section (Config, \"cargs\");\n+   --      Define_Section (Config, \"bargs\");\n+\n    procedure Define_Alias\n      (Config   : in out Command_Line_Configuration;\n       Switch   : String;\n-      Expanded : String);\n+      Expanded : String;\n+      Section  : String := \"\");\n    --  Indicates that whenever Switch appears on the command line, it should\n    --  be expanded as Expanded. For instance, for the GNAT compiler switches,\n    --  we would define \"-gnatwa\" as an alias for \"-gnatwcfijkmopruvz\", ie some\n    --  default warnings to be activated.\n+   --  This expansion is only done within the specified section, which must\n+   --  have been defined first through a call to [Define_Section].\n \n    procedure Define_Prefix\n      (Config   : in out Command_Line_Configuration;\n@@ -539,29 +581,150 @@ package GNAT.Command_Line is\n    --  alphabetically.\n \n    procedure Define_Switch\n-     (Config : in out Command_Line_Configuration;\n-      Switch : String);\n+     (Config      : in out Command_Line_Configuration;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\");\n    --  Indicates a new switch. The format of this switch follows the getopt\n    --  format (trailing ':', '?', etc for defining a switch with parameters).\n-   --  The switches defined in the Command_Line_Configuration object are used\n+   --\n+   --  Switch should also start with the leading '-' (or any other characters).\n+   --  They should all start with the same character, though. If this\n+   --  character is not '-', you will need to call Initialize_Option_Scan to\n+   --  set the proper character for the parser.\n+   --\n+   --  The switches defined in the command_line_configuration object are used\n    --  when ungrouping switches with more that one character after the prefix.\n+   --\n+   --  Switch and Long_Switch (when specified) are aliases and can be used\n+   --  interchangeably. There is no check that they both take an argument or\n+   --  both take no argument.\n+   --  Switch can be set to \"*\" to indicate that any switch is supported (in\n+   --  which case Getopt will return '*', see its documentation).\n+   --\n+   --  Help is used by the Display_Help procedure to describe the supported\n+   --  switches.\n+   --\n+   --  In_Section indicates in which section the switch is valid (you need to\n+   --  first define the section through a call to Define_Section).\n \n-   procedure Define_Section\n-     (Config  : in out Command_Line_Configuration;\n-      Section : String);\n-   --  Indicates a new switch section. All switches belonging to the same\n-   --  section are ordered together, preceded by the section. They are placed\n-   --  at the end of the command line (as in \"gnatmake somefile.adb -cargs -g\")\n+   procedure Define_Switch\n+     (Config      : in out Command_Line_Configuration;\n+      Output      : access Boolean;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\";\n+      Value       : Boolean := True);\n+   --  See Define_Switch for a description of the parameters.\n+   --  When the switch is found on the command line, Getopt will set\n+   --  Output.all to Value.\n+   --  Output is always initially set to \"not Value\", so that if the switch is\n+   --  not found on the command line, Output still has a valid value.\n+   --  The switch must not take any parameter.\n+   --  Output must exist at least as long as Config, otherwise erroneous memory\n+   --  access may happen.\n+\n+   procedure Define_Switch\n+     (Config      : in out Command_Line_Configuration;\n+      Output      : access Integer;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\";\n+      Initial     : Integer := 0;\n+      Default     : Integer := 1);\n+   --  See Define_Switch for a description of the parameters.\n+   --  When the switch is found on the command line, Getopt will set\n+   --  Output.all to the value of the switch's parameter. If the parameter is\n+   --  not an integer, Invalid_Parameter is raised.\n+   --  Output is always initialized to Initial. If the switch has an optional\n+   --  argument which isn't specified by the user, then Output will be set to\n+   --  Default.\n+\n+   procedure Define_Switch\n+     (Config      : in out Command_Line_Configuration;\n+      Output      : access GNAT.Strings.String_Access;\n+      Switch      : String := \"\";\n+      Long_Switch : String := \"\";\n+      Help        : String := \"\";\n+      Section     : String := \"\");\n+   --  Set Output to the value of the switch's parameter when the switch is\n+   --  found on the command line.\n+   --  Output is always initialized to the empty string.\n+\n+   procedure Set_Usage\n+     (Config : in out Command_Line_Configuration;\n+      Usage  : String := \"[switches] [arguments]\";\n+      Help   : String := \"\");\n+   --  Defines the general format of the call to the application, and a short\n+   --  help text. These are both displayed by Display_Help\n+\n+   procedure Display_Help (Config : Command_Line_Configuration);\n+   --  Display the help for the tool (ie its usage, and its supported switches)\n \n    function Get_Switches\n      (Config      : Command_Line_Configuration;\n-      Switch_Char : Character) return String;\n-   --  Get the switches list as expected by Getopt. This list is built using\n-   --  all switches defined previously via Define_Switch above.\n+      Section     : String := \"\";\n+      Switch_Char : Character := '-') return String;\n+   --  Get the switches list as expected by Getopt, for a specific section of\n+   --  the command line. This list is built using all switches defined\n+   --  previously via Define_Switch above.\n+\n+   function Section_Delimiters\n+     (Config      : Command_Line_Configuration) return String;\n+   --  Return a string suitable for use in Initialize_Option_Scan\n \n    procedure Free (Config : in out Command_Line_Configuration);\n    --  Free the memory used by Config\n \n+   type Switch_Handler is access procedure\n+     (Switch    : String;\n+      Parameter : String;\n+      Section   : String);\n+   --  Called when a switch is found on the command line.\n+   --  [Switch] includes any leading '-' that was specified in Define_Switch.\n+   --  This is slightly different from the functional version of Getopt above,\n+   --  for which Full_Switch omits the first leading '-'.\n+\n+   Exit_From_Command_Line : exception;\n+   --  Emitted when the program should exit.\n+   --  This is called when Getopt below has seen -h, --help or an invalid\n+   --  switch.\n+\n+   procedure Getopt\n+     (Config   : Command_Line_Configuration;\n+      Callback : Switch_Handler := null;\n+      Parser   : Opt_Parser := Command_Line_Parser);\n+   --  Similar to the standard Getopt function.\n+   --  For each switch found on the command line, this calls Callback.\n+   --\n+   --  The list of valid switches are the ones from the configuration. The\n+   --  switches that were declared through Define_Switch with an Output\n+   --  parameter are never returned (and result in a modification of the Output\n+   --  variable). This function will in fact never call [Callback] if all\n+   --  switches were handled automatically and there is nothing left to do.\n+   --\n+   --  This procedure automatically adds -h and --help to the valid switches,\n+   --  to display the help message and raises Exit_From_Command_Line.\n+   --  If an invalid switch is specified on the command line, this procedure\n+   --  will display an error message and raises Invalid_Switch again.\n+   --\n+   --  This function automatically expands switches:\n+   --   * If Define_Prefix was called (for instance \"-gnaty\") and the user\n+   --     specifies \"-gnatycb\" on the command line, then Getopt returns\n+   --     \"-gnatyc\" and \"-gnatyb\" separately.\n+   --   * If Define_Alias was called (for instance \"-gnatya = -gnatycb\") then\n+   --     the latter is returned (in this case it also expands -gnaty as per\n+   --     the above.\n+   --  The goal is to make handling as easy as possible by leaving as much\n+   --  work as possible to this package.\n+   --\n+   --  As opposed to the standard Getopt, this one will analyze all sections\n+   --  as defined by Define_Section, and automatically jump from one section to\n+   --  the next.\n+\n    ------------------------------\n    -- Generating command lines --\n    ------------------------------\n@@ -572,6 +735,24 @@ package GNAT.Command_Line is\n    --  subprograms will properly take care of grouping switches when possible,\n    --  so as to keep the command line as short as possible. They also provide a\n    --  way to remove a switch from an existing command line.\n+   --  For instance:\n+   --      declare\n+   --         Config : Command_Line_Configuration;\n+   --         Line : Command_Line;\n+   --         Args : Argument_List_Access;\n+   --      begin\n+   --         Define_Switch (Config, \"-gnatyc\");\n+   --         Define_Switch (Config, ...);  --  for all valid switches\n+   --         Define_Prefix (Config, \"-gnaty\");\n+   --\n+   --         Set_Configuration (Line, Config);\n+   --         Add_Switch (Line, \"-O2\");\n+   --         Add_Switch (Line, \"-gnatyc\");\n+   --         Add_Switch (Line, \"-gnatyd\");\n+   --\n+   --         Build (Line, Args);\n+   --         --   Args is now  [\"-O2\", \"-gnatycd\"]\n+   --      end;\n \n    type Command_Line is private;\n \n@@ -609,7 +790,6 @@ package GNAT.Command_Line is\n      (Cmd        : in out Command_Line;\n       Switch     : String;\n       Parameter  : String    := \"\";\n-      Separator  : Character := ' ';\n       Section    : String    := \"\";\n       Add_Before : Boolean   := False);\n    --  Add a new switch to the command line, and combine/group it with existing\n@@ -631,10 +811,6 @@ package GNAT.Command_Line is\n    --  A Switch with a parameter will never be grouped with another switch to\n    --  avoid ambiguities as to what the parameter applies to.\n    --\n-   --  Separator is the character that goes between the switches and its\n-   --  parameter on the command line. If it is set to ASCII.NUL, then no\n-   --  separator is applied, and they are concatenated.\n-   --\n    --  If the switch is part of a section, then it should be specified so that\n    --  the switch is correctly placed in the command line, and the section\n    --  added if not already present. For example, to add the -g switch into the\n@@ -650,7 +826,6 @@ package GNAT.Command_Line is\n      (Cmd        : in out Command_Line;\n       Switch     : String;\n       Parameter  : String    := \"\";\n-      Separator  : Character := ' ';\n       Section    : String    := \"\";\n       Add_Before : Boolean   := False;\n       Success    : out Boolean);\n@@ -740,6 +915,17 @@ package GNAT.Command_Line is\n    procedure Next (Iter : in out Command_Line_Iterator);\n    --  Move to the next switch\n \n+   procedure Build\n+     (Line        : in out Command_Line;\n+      Args        : out GNAT.OS_Lib.Argument_List_Access;\n+      Expanded    : Boolean := False;\n+      Switch_Char : Character := '-');\n+   --  This is a wrapper using the Command_Line_Iterator.\n+   --  It provides a simple way to get all switches (grouped as much as\n+   --  possible), and possibly create an Opt_Parser.\n+   --  [Args] must be freed by the caller.\n+   --  [Expanded] has the same meaning as in [Start].\n+\n private\n \n    Max_Depth : constant := 100;\n@@ -841,18 +1027,54 @@ private\n    Command_Line_Parser : constant Opt_Parser :=\n                            Command_Line_Parser_Data'Access;\n \n+   type Switch_Type is (Switch_Untyped,\n+                        Switch_Boolean,\n+                        Switch_Integer,\n+                        Switch_String);\n+\n+   type Switch_Definition (Typ : Switch_Type := Switch_Untyped) is record\n+      Switch      : GNAT.OS_Lib.String_Access;\n+      Long_Switch : GNAT.OS_Lib.String_Access;\n+      Section     : GNAT.OS_Lib.String_Access;\n+      Help        : GNAT.OS_Lib.String_Access;\n+\n+      case Typ is\n+         when Switch_Untyped =>\n+            null;\n+         when Switch_Boolean =>\n+            Boolean_Output : access Boolean;\n+            Boolean_Value  : Boolean;  --  will set Output to that value\n+         when Switch_Integer =>\n+            Integer_Output  : access Integer;\n+            Integer_Initial : Integer;\n+            Integer_Default : Integer;\n+         when Switch_String =>\n+            String_Output   : access GNAT.Strings.String_Access;\n+      end case;\n+   end record;\n+   type Switch_Definitions is array (Natural range <>) of Switch_Definition;\n+   type Switch_Definitions_List is access all Switch_Definitions;\n+   --  [Switch] includes the leading '-'\n+\n+   type Alias_Definition is record\n+      Alias       : GNAT.OS_Lib.String_Access;\n+      Expansion   : GNAT.OS_Lib.String_Access;\n+      Section     : GNAT.OS_Lib.String_Access;\n+   end record;\n+   type Alias_Definitions is array (Natural range <>) of Alias_Definition;\n+   type Alias_Definitions_List is access all Alias_Definitions;\n+\n    type Command_Line_Configuration_Record is record\n-      Prefixes : GNAT.OS_Lib.Argument_List_Access;\n+      Prefixes          : GNAT.OS_Lib.Argument_List_Access;\n       --  The list of prefixes\n \n-      Sections : GNAT.OS_Lib.Argument_List_Access;\n+      Sections          : GNAT.OS_Lib.Argument_List_Access;\n       --  The list of sections\n \n-      Aliases    : GNAT.OS_Lib.Argument_List_Access;\n-      Expansions : GNAT.OS_Lib.Argument_List_Access;\n-      --  The aliases (Both arrays have the same bounds)\n-\n-      Switches : GNAT.OS_Lib.Argument_List_Access;\n+      Aliases           : Alias_Definitions_List;\n+      Usage             : GNAT.OS_Lib.String_Access;\n+      Help              : GNAT.OS_Lib.String_Access;\n+      Switches          : Switch_Definitions_List;\n       --  List of expected switches (Used when expanding switch groups)\n    end record;\n    type Command_Line_Configuration is access Command_Line_Configuration_Record;"}]}