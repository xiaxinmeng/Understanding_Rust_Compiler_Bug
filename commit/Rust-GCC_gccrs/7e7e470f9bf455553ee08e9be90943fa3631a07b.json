{"sha": "7e7e470f9bf455553ee08e9be90943fa3631a07b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U3ZTQ3MGY5YmY0NTU1NTNlZTA4ZTliZTkwOTQzZmEzNjMxYTA3Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-02-12T00:26:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-02-12T00:26:57Z"}, "message": "tree-complex.c (expand_complex_libcall): New.\n\n        * tree-complex.c (expand_complex_libcall): New.\n        (expand_complex_multiplication): Use it for c99 compliance.\n        (expand_complex_division): Likewise.\n        * fold-const.c (fold_complex_add, fold_complex_mult): New.\n        (fold): Call them.\n        * builtins.c (built_in_names): Remove const.\n        * tree.c (build_common_builtin_nodes): Build complex arithmetic\n        builtins.\n        * tree.h (BUILT_IN_COMPLEX_MUL_MIN, BUILT_IN_COMPLEX_MUL_MAX): New.\n        (BUILT_IN_COMPLEX_DIV_MIN, BUILT_IN_COMPLEX_DIV_MAX): New.\n        (built_in_names): Remove const.\n        * c-common.c (c_common_type_for_mode): Handle complex modes.\n        * flags.h, toplev.c (flag_complex_method): Rename from\n        flag_complex_divide_method.\n        * libgcc2.c (__divsc3, __divdc3, __divxc3, __divtc3,\n        __mulsc3, __muldc3, __mulxc3, __multc3): New.\n        * libgcc2.h: Declare them.\n        * libgcc-std.ver: Export them.\n        * mklibgcc.in (lib2funcs): Build them.\n\nFrom-SVN: r94909", "tree": {"sha": "d07cd0c8b8b5189a1a0ffc5396fe8bf7003febf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d07cd0c8b8b5189a1a0ffc5396fe8bf7003febf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e7e470f9bf455553ee08e9be90943fa3631a07b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7e470f9bf455553ee08e9be90943fa3631a07b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7e470f9bf455553ee08e9be90943fa3631a07b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7e470f9bf455553ee08e9be90943fa3631a07b/comments", "author": null, "committer": null, "parents": [{"sha": "17e1f1a36faa0f8a07de8b5b7b9a4eb27df96399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e1f1a36faa0f8a07de8b5b7b9a4eb27df96399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e1f1a36faa0f8a07de8b5b7b9a4eb27df96399"}], "stats": {"total": 580, "additions": 568, "deletions": 12}, "files": [{"sha": "71e5b1510552df1d0f7827406d86068aa01eadfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -1,3 +1,25 @@\n+2005-02-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-complex.c (expand_complex_libcall): New.\n+\t(expand_complex_multiplication): Use it for c99 compliance.\n+\t(expand_complex_division): Likewise.\n+\t* fold-const.c (fold_complex_add, fold_complex_mult): New.\n+\t(fold): Call them.\n+\t* builtins.c (built_in_names): Remove const.\n+\t* tree.c (build_common_builtin_nodes): Build complex arithmetic\n+\tbuiltins.\n+\t* tree.h (BUILT_IN_COMPLEX_MUL_MIN, BUILT_IN_COMPLEX_MUL_MAX): New.\n+\t(BUILT_IN_COMPLEX_DIV_MIN, BUILT_IN_COMPLEX_DIV_MAX): New.\n+\t(built_in_names): Remove const.\n+\t* c-common.c (c_common_type_for_mode): Handle complex modes.\n+\t* flags.h, toplev.c (flag_complex_method): Rename from\n+\tflag_complex_divide_method.\n+\t* libgcc2.c (__divsc3, __divdc3, __divxc3, __divtc3,\n+\t__mulsc3, __muldc3, __mulxc3, __multc3): New.\n+\t* libgcc2.h: Declare them.\n+ \t* libgcc-std.ver: Export them.\n+\t* mklibgcc.in (lib2funcs): Build them.\n+\n 2005-02-11  Steven Bosscher  <stevenb@suse.de>\n \n \tPR tree-optimization/19876"}, {"sha": "420e5dee522f108b378e858a404472f1326186aa", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -60,7 +60,7 @@ const char *const built_in_class_names[4]\n   = {\"NOT_BUILT_IN\", \"BUILT_IN_FRONTEND\", \"BUILT_IN_MD\", \"BUILT_IN_NORMAL\"};\n \n #define DEF_BUILTIN(X, N, C, T, LT, B, F, NA, AT, IM, COND) #X,\n-const char *const built_in_names[(int) END_BUILTINS] =\n+const char * built_in_names[(int) END_BUILTINS] =\n {\n #include \"builtins.def\"\n };"}, {"sha": "b414915bc872ca18bba608fa9343672c7e9dbdd2", "filename": "gcc/c-common.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -1611,7 +1611,27 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n   if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n     return unsignedp ? make_unsigned_type (mode) : make_signed_type (mode);\n \n-  if (VECTOR_MODE_P (mode))\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      enum machine_mode inner_mode;\n+      tree inner_type;\n+\n+      if (mode == TYPE_MODE (complex_float_type_node))\n+\treturn complex_float_type_node;\n+      if (mode == TYPE_MODE (complex_double_type_node))\n+\treturn complex_double_type_node;\n+      if (mode == TYPE_MODE (complex_long_double_type_node))\n+\treturn complex_long_double_type_node;\n+\n+      if (mode == TYPE_MODE (complex_integer_type_node) && !unsignedp)\n+\treturn complex_integer_type_node;\n+\n+      inner_mode = GET_MODE_INNER (mode);\n+      inner_type = c_common_type_for_mode (inner_mode, unsignedp);\n+      if (inner_type != NULL_TREE)\n+\treturn build_complex_type (inner_type);\n+    }\n+  else if (VECTOR_MODE_P (mode))\n     {\n       enum machine_mode inner_mode = GET_MODE_INNER (mode);\n       tree inner_type = c_common_type_for_mode (inner_mode, unsignedp);"}, {"sha": "cb8c100350ee5a1600b52c584632b787dc3c6b9e", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -145,9 +145,9 @@ extern int flag_pcc_struct_return;\n \n /* 0 means straightforward implementation of complex divide acceptable.\n    1 means wide ranges of inputs must work for complex divide.\n-   2 means C99-like requirements for complex divide (not yet implemented).  */\n+   2 means C99-like requirements for complex multiply and divide.  */\n \n-extern int flag_complex_divide_method;\n+extern int flag_complex_method;\n \n /* Nonzero means that we don't want inlining by virtue of -fno-inline,\n    not just because the tree inliner turned us off.  */"}, {"sha": "5d6e5c5085467247c1f9f34607c811fce47de56a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -6306,6 +6306,168 @@ fold_to_nonsharp_ineq_using_bound (tree ineq, tree bound)\n   return fold (build2 (GE_EXPR, type, a, y));\n }\n \n+/* Fold complex addition when both components are accessible by parts.\n+   Return non-null if successful.  CODE should be PLUS_EXPR for addition,\n+   or MINUS_EXPR for subtraction.  */\n+\n+static tree\n+fold_complex_add (tree type, tree ac, tree bc, enum tree_code code)\n+{\n+  tree ar, ai, br, bi, rr, ri, inner_type;\n+\n+  if (TREE_CODE (ac) == COMPLEX_EXPR)\n+    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n+  else if (TREE_CODE (ac) == COMPLEX_CST)\n+    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n+  else\n+    return NULL;\n+\n+  if (TREE_CODE (bc) == COMPLEX_EXPR)\n+    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n+  else if (TREE_CODE (bc) == COMPLEX_CST)\n+    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n+  else\n+    return NULL;\n+\n+  inner_type = TREE_TYPE (type);\n+\n+  rr = fold (build2 (code, inner_type, ar, br));  \n+  ri = fold (build2 (code, inner_type, ai, bi));  \n+\n+  return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n+}\n+\n+/* Perform some simplifications of complex multiplication when one or more\n+   of the components are constants or zeros.  Return non-null if successful.  */\n+\n+static tree\n+fold_complex_mult (tree type, tree ac, tree bc)\n+{\n+  tree ar, ai, br, bi, rr, ri, inner_type, zero;\n+  bool ar0, ai0, br0, bi0, bi1;\n+\n+  if (TREE_CODE (ac) == COMPLEX_EXPR)\n+    ar = TREE_OPERAND (ac, 0), ai = TREE_OPERAND (ac, 1);\n+  else if (TREE_CODE (ac) == COMPLEX_CST)\n+    ar = TREE_REALPART (ac), ai = TREE_IMAGPART (ac);\n+  else\n+    return NULL;\n+\n+  if (TREE_CODE (bc) == COMPLEX_EXPR)\n+    br = TREE_OPERAND (bc, 0), bi = TREE_OPERAND (bc, 1);\n+  else if (TREE_CODE (bc) == COMPLEX_CST)\n+    br = TREE_REALPART (bc), bi = TREE_IMAGPART (bc);\n+  else\n+    return NULL;\n+\n+  inner_type = TREE_TYPE (type);\n+  zero = NULL;\n+\n+  if (SCALAR_FLOAT_TYPE_P (inner_type))\n+    {\n+      ar0 = ai0 = br0 = bi0 = bi1 = false;\n+\n+      /* We're only interested in +0.0 here, thus we don't use real_zerop.  */\n+\n+      if (TREE_CODE (ar) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ar), dconst0))\n+\tar0 = true, zero = ar;\n+\n+      if (TREE_CODE (ai) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ai), dconst0))\n+\tai0 = true, zero = ai;\n+\n+      if (TREE_CODE (br) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (br), dconst0))\n+\tbr0 = true, zero = br;\n+\n+      if (TREE_CODE (bi) == REAL_CST)\n+\t{\n+\t  if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst0))\n+\t    bi0 = true, zero = bi;\n+\t  else if (REAL_VALUES_IDENTICAL (TREE_REAL_CST (bi), dconst1))\n+\t    bi1 = true;\n+\t}\n+    }\n+  else\n+    {\n+      ar0 = integer_zerop (ar);\n+      if (ar0)\n+\tzero = ar;\n+      ai0 = integer_zerop (ai);\n+      if (ai0)\n+\tzero = ai;\n+      br0 = integer_zerop (br);\n+      if (br0)\n+\tzero = br;\n+      bi0 = integer_zerop (bi);\n+      if (bi0)\n+\t{\n+\t  zero = bi;\n+\t  bi1 = false;\n+\t}\n+      else\n+\tbi1 = integer_onep (bi);\n+    }\n+\n+  /* We won't optimize anything below unless something is zero.  */\n+  if (zero == NULL)\n+    return NULL;\n+\n+  if (ai0 && br0 && bi1)\n+    {\n+      rr = zero;\n+      ri = ar;\n+    }\n+  else if (ai0 && bi0)\n+    {\n+      rr = fold (build2 (MULT_EXPR, inner_type, ar, br));\n+      ri = zero;\n+    }\n+  else if (ai0 && br0)\n+    {\n+      rr = zero;\n+      ri = fold (build2 (MULT_EXPR, inner_type, ar, bi));\n+    }\n+  else if (ar0 && bi0)\n+    {\n+      rr = zero;\n+      ri = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+    }\n+  else if (ar0 && br0)\n+    {\n+      rr = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+      rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n+      ri = zero;\n+    }\n+  else if (bi0)\n+    {\n+      rr = fold (build2 (MULT_EXPR, inner_type, ar, br));\n+      ri = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+    }\n+  else if (ai0)\n+    {\n+      rr = fold (build2 (MULT_EXPR, inner_type, ar, br));\n+      ri = fold (build2 (MULT_EXPR, inner_type, ar, bi));\n+    }\n+  else if (br0)\n+    {\n+      rr = fold (build2 (MULT_EXPR, inner_type, ai, bi));\n+      rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n+      ri = fold (build2 (MULT_EXPR, inner_type, ar, bi));\n+    }\n+  else if (ar0)\n+    {\n+      rr = fold (build2 (MULT_EXPR, inner_type, ai, bi));\n+      rr = fold (build1 (NEGATE_EXPR, inner_type, rr));\n+      ri = fold (build2 (MULT_EXPR, inner_type, ai, br));\n+    }\n+  else\n+    return NULL;\n+\n+  return fold (build2 (COMPLEX_EXPR, type, rr, ri));\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -6833,6 +6995,14 @@ fold (tree expr)\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1))\n \treturn fold (build2 (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0)));\n+\n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold_complex_add (type, arg0, arg1, PLUS_EXPR);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -7264,6 +7434,13 @@ fold (tree expr)\n \treturn fold (build2 (MINUS_EXPR, type, negate_expr (arg1),\n \t\t\t     TREE_OPERAND (arg0, 0)));\n \n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold_complex_add (type, arg0, arg1, MINUS_EXPR);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (! wins && integer_zerop (arg0))\n@@ -7392,6 +7569,13 @@ fold (tree expr)\n \t\t\t     negate_expr (arg0),\n \t\t\t     TREE_OPERAND (arg1, 0)));\n \n+      if (TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tem = fold_complex_mult (type, arg0, arg1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))"}, {"sha": "341cf7a481bc27029905899882fe3e2db11ef4c0", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -241,4 +241,14 @@ GCC_4.0.0 {\n   __powidf2\n   __powixf2\n   __powitf2\n-}\n\\ No newline at end of file\n+\n+  # c99 compliant complex arithmetic\n+  __divsc3\n+  __divdc3\n+  __divxc3\n+  __divtc3\n+  __mulsc3\n+  __muldc3\n+  __mulxc3\n+  __multc3\n+}"}, {"sha": "df2ecb7a4e536d94dfb235798c94b485d7c19130", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 202, "deletions": 1, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -1501,6 +1501,208 @@ NAME (TYPE x, Wtype m)\n \n #endif\n \f\n+#if defined(L_mulsc3) || defined(L_divsc3) \\\n+    || defined(L_muldc3) || defined(L_divdc3) \\\n+    || (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80 \\\n+\t&& (defined(L_mulxc3) || defined(L_divxc3))) \\\n+    || (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128 \\\n+\t&& (defined(L_multc3) || defined(L_divtc3)))\n+\n+#undef float\n+#undef double\n+#undef long\n+\n+#if defined(L_mulsc3) || defined(L_divsc3)\n+# define MTYPE\tSFtype\n+# define CTYPE\tSCtype\n+# define MODE\tsc\n+# define CEXT\tf\n+# define NOTRUNC __FLT_EVAL_METHOD__ == 0\n+#elif defined(L_muldc3) || defined(L_divdc3)\n+# define MTYPE\tDFtype\n+# define CTYPE\tDCtype\n+# define MODE\tdc\n+# if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n+#  define CEXT\tl\n+#  define NOTRUNC 1\n+# else\n+#  define CEXT\n+#  define NOTRUNC __FLT_EVAL_METHOD__ == 0 || __FLT_EVAL_METHOD__ == 1\n+# endif\n+#elif defined(L_mulxc3) || defined(L_divxc3)\n+# define MTYPE\tXFtype\n+# define CTYPE\tXCtype\n+# define MODE\txc\n+# define CEXT\tl\n+# define NOTRUNC 1\n+#elif defined(L_multc3) || defined(L_divtc3)\n+# define MTYPE\tTFtype\n+# define CTYPE\tTCtype\n+# define MODE\ttc\n+# define CEXT\tl\n+# define NOTRUNC 1\n+#else\n+# error\n+#endif\n+\n+#define CONCAT3(A,B,C)\t_CONCAT3(A,B,C)\n+#define _CONCAT3(A,B,C)\tA##B##C\n+\n+#define CONCAT2(A,B)\t_CONCAT2(A,B)\n+#define _CONCAT2(A,B)\tA##B\n+\n+/* All of these would be present in a full C99 implementation of <math.h>\n+   and <complex.h>.  Our problem is that only a few systems have such full\n+   implementations.  Further, libgcc_s.so isn't currenly linked against\n+   libm.so, and even for systems that do provide full C99, the extra overhead\n+   of all programs using libgcc having to link against libm.  So avoid it.  */\n+\n+#define isnan(x)\t__builtin_expect ((x) != (x), 0)\n+#define isfinite(x)\t__builtin_expect (!isnan((x) - (x)), 1)\n+#define isinf(x)\t__builtin_expect (!isnan(x) & !isfinite(x), 0)\n+\n+#define INFINITY\tCONCAT2(__builtin_inf, CEXT) ()\n+#define I\t\t1i\n+\n+/* Helpers to make the following code slightly less gross.  */\n+#define COPYSIGN\tCONCAT2(__builtin_copysign, CEXT)\n+#define FABS\t\tCONCAT2(__builtin_fabs, CEXT)\n+\n+/* Verify that MTYPE matches up with CEXT.  */\n+extern void *compile_type_assert[sizeof(INFINITY) == sizeof(MTYPE) ? 1 : -1];\n+\n+/* Ensure that we've lost any extra precision.  */\n+#if NOTRUNC\n+# define TRUNC(x)\n+#else\n+# define TRUNC(x)\t__asm__ (\"\" : \"=m\"(x) : \"m\"(x))\n+#endif\n+\n+#if defined(L_mulsc3) || defined(L_muldc3) \\\n+    || defined(L_mulxc3) || defined(L_multc3)\n+\n+CTYPE\n+CONCAT3(__mul,MODE,3) (MTYPE a, MTYPE b, MTYPE c, MTYPE d)\n+{\n+  MTYPE ac, bd, ad, bc, x, y;\n+\n+  ac = a * c;\n+  bd = b * d;\n+  ad = a * d;\n+  bc = b * c;\n+\n+  TRUNC (ac);\n+  TRUNC (bd);\n+  TRUNC (ad);\n+  TRUNC (bc);\n+\n+  x = ac - bd;\n+  y = ad + bc;\n+\n+  if (isnan (x) && isnan (y))\n+    {\n+      /* Recover infinities that computed as NaN + iNaN.  */\n+      _Bool recalc = 0;\n+      if (isinf (a) || isinf (b))\n+\t{\n+\t  /* z is infinite.  \"Box\" the infinity and change NaNs in\n+\t     the other factor to 0.  */\n+\t  a = COPYSIGN (isinf (a) ? 1 : 0, a);\n+\t  b = COPYSIGN (isinf (b) ? 1 : 0, b);\n+\t  if (isnan (c)) c = COPYSIGN (0, c);\n+\t  if (isnan (d)) d = COPYSIGN (0, d);\n+          recalc = 1;\n+\t}\n+     if (isinf (c) || isinf (d))\n+\t{\n+\t  /* w is infinite.  \"Box\" the infinity and change NaNs in\n+\t     the other factor to 0.  */\n+\t  c = COPYSIGN (isinf (c) ? 1 : 0, c);\n+\t  d = COPYSIGN (isinf (d) ? 1 : 0, d);\n+\t  if (isnan (a)) a = COPYSIGN (0, a);\n+\t  if (isnan (b)) b = COPYSIGN (0, b);\n+\t  recalc = 1;\n+\t}\n+     if (!recalc\n+\t  && (isinf (ac) || isinf (bd)\n+\t      || isinf (ad) || isinf (bc)))\n+\t{\n+\t  /* Recover infinities from overflow by changing NaNs to 0.  */\n+\t  if (isnan (a)) a = COPYSIGN (0, a);\n+\t  if (isnan (b)) b = COPYSIGN (0, b);\n+\t  if (isnan (c)) c = COPYSIGN (0, c);\n+\t  if (isnan (d)) d = COPYSIGN (0, d);\n+\t  recalc = 1;\n+\t}\n+      if (recalc)\n+\t{\n+\t  x = INFINITY * (a * c - b * d);\n+\t  y = INFINITY * (a * d + b * c);\n+\t}\n+    }\n+\n+  return x + I * y;\n+}\n+#endif /* complex multiply */\n+\n+#if defined(L_divsc3) || defined(L_divdc3) \\\n+    || defined(L_divxc3) || defined(L_divtc3)\n+\n+CTYPE\n+CONCAT3(__div,MODE,3) (MTYPE a, MTYPE b, MTYPE c, MTYPE d)\n+{\n+  MTYPE denom, ratio, x, y;\n+\n+  /* ??? We can get better behaviour from logrithmic scaling instead of \n+     the division.  But that would mean starting to link libgcc against\n+     libm.  We could implement something akin to ldexp/frexp as gcc builtins\n+     fairly easily...  */\n+  if (FABS (c) < FABS (d))\n+    {\n+      ratio = c / d;\n+      denom = (c * ratio) + d;\n+      x = ((a * ratio) + b) / denom;\n+      y = ((b * ratio) - a) / denom;\n+    }\n+  else\n+    {\n+      ratio = d / c;\n+      denom = (d * ratio) + c;\n+      x = ((b * ratio) + a) / denom;\n+      y = (b - (a * ratio)) / denom;\n+    }\n+\n+  /* Recover infinities and zeros that computed as NaN+iNaN; the only cases\n+     are non-zero/zero, infinite/finite, and finite/infinite.  */\n+  if (isnan (x) && isnan (y))\n+    {\n+      if (denom == 0.0 && (!isnan (a) || !isnan (b)))\n+\t{\n+\t  x = COPYSIGN (INFINITY, c) * a;\n+\t  y = COPYSIGN (INFINITY, c) * b;\n+\t}\n+      else if ((isinf (a) || isinf (b)) && isfinite (c) && isfinite (d))\n+\t{\n+\t  a = COPYSIGN (isinf (a) ? 1 : 0, a);\n+\t  b = COPYSIGN (isinf (b) ? 1 : 0, b);\n+\t  x = INFINITY * (a * c + b * d);\n+\t  y = INFINITY * (b * c - a * d);\n+\t}\n+      else if ((isinf (c) || isinf (d)) && isfinite (a) && isfinite (b))\n+\t{\n+\t  c = COPYSIGN (isinf (c) ? 1 : 0, c);\n+\t  d = COPYSIGN (isinf (d) ? 1 : 0, d);\n+\t  x = 0.0 * (a * c + b * d);\n+\t  y = 0.0 * (b * c - a * d);\n+\t}\n+    }\n+\n+  return x + I * y;\n+}\n+#endif /* complex divide */\n+\n+#endif /* all complex float routines */\n+\f\n /* From here on down, the routines use normal data types.  */\n \n #define SItype bogus_type\n@@ -1772,4 +1974,3 @@ func_ptr __DTOR_LIST__[2];\n #endif\n #endif /* no INIT_SECTION_ASM_OP and not CTOR_LISTS_DEFINED_EXTERNALLY */\n #endif /* L_ctors */\n-"}, {"sha": "165787316364e970491a751a9b8e514276f699d4", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -92,12 +92,16 @@ typedef unsigned int UTItype\t__attribute__ ((mode (TI)));\n \n typedef \tfloat SFtype\t__attribute__ ((mode (SF)));\n typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n+typedef _Complex float SCtype\t__attribute__ ((mode (SC)));\n+typedef _Complex float DCtype\t__attribute__ ((mode (DC)));\n \n #if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80\n typedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n+typedef _Complex float XCtype\t__attribute__ ((mode (XC)));\n #endif\n #if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n typedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n+typedef _Complex float TCtype\t__attribute__ ((mode (TC)));\n #endif\n \n #else /* BITS_PER_UNIT != 8 */\n@@ -308,19 +312,28 @@ extern DWtype __fixunssfDI (SFtype);\n extern SFtype __powisf2 (SFtype, Wtype);\n extern DFtype __powidf2 (DFtype, Wtype);\n \n+extern SCtype __divsc3 (SFtype, SFtype, SFtype, SFtype);\n+extern SCtype __mulsc3 (SFtype, SFtype, SFtype, SFtype);\n+extern DCtype __divdc3 (DFtype, DFtype, DFtype, DFtype);\n+extern DCtype __muldc3 (DFtype, DFtype, DFtype, DFtype);\n+\n #if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80\n extern DWtype __fixxfdi (XFtype);\n extern DWtype __fixunsxfDI (XFtype);\n extern XFtype __floatdixf (DWtype);\n extern UWtype __fixunsxfSI (XFtype);\n extern XFtype __powixf2 (XFtype, Wtype);\n+extern XCtype __divxc3 (XFtype, XFtype, XFtype, XFtype);\n+extern XCtype __mulxc3 (XFtype, XFtype, XFtype, XFtype);\n #endif\n \n #if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n extern DWtype __fixunstfDI (TFtype);\n extern DWtype __fixtfdi (TFtype);\n extern TFtype __floatditf (DWtype);\n extern TFtype __powitf2 (TFtype, Wtype);\n+extern TCtype __divtc3 (TFtype, TFtype, TFtype, TFtype);\n+extern TCtype __multc3 (TFtype, TFtype, TFtype, TFtype);\n #endif\n #endif /* BITS_PER_UNIT == 8 */\n "}, {"sha": "c88fca98186cb4fc1c8345e24d7c2714a49441ef", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -62,7 +62,8 @@ lib2funcs='_muldi3 _negdi2 _lshrdi3 _ashldi3 _ashrdi3\n \t_addvdi3 _subvsi3 _subvdi3 _mulvsi3 _mulvdi3 _negvsi2 _negvdi2 _ctors\n \t_ffssi2 _ffsdi2 _clz _clzsi2 _clzdi2 _ctzsi2 _ctzdi2 _popcount_tab\n \t_popcountsi2 _popcountdi2 _paritysi2 _paritydi2 _powisf2 _powidf2\n-\t_powixf2 _powitf2'\n+\t_powixf2 _powitf2 _mulsc3 _muldc3 _mulxc3 _multc3 _divsc3 _divdc3\n+\t_divxc3 _divtc3'\n \n # Disable SHLIB_LINK if shared libgcc not enabled.\n if [ \"@enable_shared@\" = \"no\" ]; then"}, {"sha": "99704a4309053134360d2c114ee1785afda98c0f", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -267,9 +267,9 @@ int flag_pcc_struct_return = DEFAULT_PCC_STRUCT_RETURN;\n \n /* 0 means straightforward implementation of complex divide acceptable.\n    1 means wide ranges of inputs must work for complex divide.\n-   2 means C99-like requirements for complex divide (not yet implemented).  */\n+   2 means C99-like requirements for complex multiply and divide.  */\n \n-int flag_complex_divide_method = 0;\n+int flag_complex_method = 0;\n \n /* Nonzero means that we don't want inlining by virtue of -fno-inline,\n    not just because the tree inliner turned us off.  */"}, {"sha": "a5708f39a8e186f275a78392cfe26bf336a2132b", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -105,6 +105,40 @@ expand_complex_addition (block_stmt_iterator *bsi, tree inner_type,\n   update_complex_assignment (bsi, rr, ri);\n }\n \n+/* Expand a complex multiplication or division to a libcall to the c99\n+   compliant routines.  */\n+\n+static void\n+expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n+\t\t\ttree br, tree bi, enum tree_code code)\n+{\n+  enum machine_mode mode;\n+  enum built_in_function bcode;\n+  tree args, fn, stmt, type;\n+\n+  args = tree_cons (NULL, bi, NULL);\n+  args = tree_cons (NULL, br, args);\n+  args = tree_cons (NULL, ai, args);\n+  args = tree_cons (NULL, ar, args);\n+\n+  stmt = bsi_stmt (*bsi);\n+  type = TREE_TYPE (TREE_OPERAND (stmt, 1));\n+\n+  mode = TYPE_MODE (type);\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n+  if (code == MULT_EXPR)\n+    bcode = BUILT_IN_COMPLEX_MUL_MIN + mode - MIN_MODE_COMPLEX_FLOAT;\n+  else if (code == RDIV_EXPR)\n+    bcode = BUILT_IN_COMPLEX_DIV_MIN + mode - MIN_MODE_COMPLEX_FLOAT;\n+  else\n+    gcc_unreachable ();\n+  fn = built_in_decls[bcode];\n+\n+  TREE_OPERAND (stmt, 1)\n+    = build3 (CALL_EXPR, type, build_fold_addr_expr (fn), args, NULL);\n+  modify_stmt (stmt);\n+}\n+\n /* Expand complex multiplication to scalars:\n \ta * b = (ar*br - ai*bi) + i(ar*bi + br*ai)\n */\n@@ -115,6 +149,12 @@ expand_complex_multiplication (block_stmt_iterator *bsi, tree inner_type,\n {\n   tree t1, t2, t3, t4, rr, ri;\n \n+  if (flag_complex_method == 2 && SCALAR_FLOAT_TYPE_P (inner_type))\n+    {\n+      expand_complex_libcall (bsi, ar, ai, br, bi, MULT_EXPR);\n+      return;\n+    }\n+\n   t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n   t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n   t3 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, bi);\n@@ -311,18 +351,27 @@ expand_complex_division (block_stmt_iterator *bsi, tree inner_type,\n \t\t\t tree ar, tree ai, tree br, tree bi,\n \t\t\t enum tree_code code)\n {\n-  switch (flag_complex_divide_method)\n+  switch (flag_complex_method)\n     {\n     case 0:\n       /* straightforward implementation of complex divide acceptable.  */\n       expand_complex_div_straight (bsi, inner_type, ar, ai, br, bi, code);\n       break;\n+\n+    case 2:\n+      if (SCALAR_FLOAT_TYPE_P (inner_type))\n+\t{\n+\t  expand_complex_libcall (bsi, ar, ai, br, bi, code);\n+\t  return;\n+\t}\n+      /* FALLTHRU */\n+\n     case 1:\n       /* wide ranges of inputs must work for complex divide.  */\n       expand_complex_div_wide (bsi, inner_type, ar, ai, br, bi, code);\n       break;\n+\n     default:\n-      /* C99-like requirements for complex divide (not yet implemented).  */\n       gcc_unreachable ();\n     }\n }"}, {"sha": "3a0054c507e76d1d6a5397af6a3959e46748ea72", "filename": "gcc/tree.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -5903,6 +5903,48 @@ build_common_builtin_nodes (void)\n \t\t\tBUILT_IN_PROFILE_FUNC_ENTER, \"profile_func_enter\", 0);\n   local_define_builtin (\"__builtin_profile_func_exit\", ftype,\n \t\t\tBUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\", 0);\n+\n+  /* Complex multiplication and division.  These are handled as builtins\n+     rather than optabs because emit_library_call_value doesn't support\n+     complex.  Further, we can do slightly better with folding these \n+     beasties if the real and complex parts of the arguments are separate.  */\n+  {\n+    enum machine_mode mode;\n+\n+    for (mode = MIN_MODE_COMPLEX_FLOAT; mode <= MAX_MODE_COMPLEX_FLOAT; ++mode)\n+      {\n+\tchar mode_name_buf[4], *q;\n+\tconst char *p;\n+\tenum built_in_function mcode, dcode;\n+\ttree type, inner_type;\n+\n+\ttype = lang_hooks.types.type_for_mode (mode, 0);\n+\tif (type == NULL)\n+\t  continue;\n+\tinner_type = TREE_TYPE (type);\n+\n+\ttmp = tree_cons (NULL_TREE, inner_type, void_list_node);\n+\ttmp = tree_cons (NULL_TREE, inner_type, tmp);\n+\ttmp = tree_cons (NULL_TREE, inner_type, tmp);\n+\ttmp = tree_cons (NULL_TREE, inner_type, tmp);\n+\tftype = build_function_type (type, tmp);\n+\n+        mcode = BUILT_IN_COMPLEX_MUL_MIN + mode - MIN_MODE_COMPLEX_FLOAT;\n+        dcode = BUILT_IN_COMPLEX_DIV_MIN + mode - MIN_MODE_COMPLEX_FLOAT;\n+\n+        for (p = GET_MODE_NAME (mode), q = mode_name_buf; *p; p++, q++)\n+\t  *q = TOLOWER (*p);\n+\t*q = '\\0';\n+\n+\tbuilt_in_names[mcode] = concat (\"__mul\", mode_name_buf, \"3\", NULL);\n+        local_define_builtin (built_in_names[mcode], ftype, mcode,\n+\t\t\t      built_in_names[mcode], ECF_CONST | ECF_NOTHROW);\n+\n+\tbuilt_in_names[dcode] = concat (\"__div\", mode_name_buf, \"3\", NULL);\n+        local_define_builtin (built_in_names[dcode], ftype, dcode,\n+\t\t\t      built_in_names[dcode], ECF_CONST | ECF_NOTHROW);\n+      }\n+  }\n }\n \n /* HACK.  GROSS.  This is absolutely disgusting.  I wish there was a"}, {"sha": "dea3136e009bb67ed1ec2805e1328ae8bd02aed2", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7e470f9bf455553ee08e9be90943fa3631a07b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7e7e470f9bf455553ee08e9be90943fa3631a07b", "patch": "@@ -187,13 +187,27 @@ enum built_in_function\n {\n #include \"builtins.def\"\n \n+  /* Complex division routines in libgcc.  These are done via builtins\n+     because emit_library_call_value can't handle complex values.  */\n+  BUILT_IN_COMPLEX_MUL_MIN,\n+  BUILT_IN_COMPLEX_MUL_MAX\n+    = BUILT_IN_COMPLEX_MUL_MIN\n+      + MAX_MODE_COMPLEX_FLOAT\n+      - MIN_MODE_COMPLEX_FLOAT,\n+\n+  BUILT_IN_COMPLEX_DIV_MIN,\n+  BUILT_IN_COMPLEX_DIV_MAX\n+    = BUILT_IN_COMPLEX_DIV_MIN\n+      + MAX_MODE_COMPLEX_FLOAT\n+      - MIN_MODE_COMPLEX_FLOAT,\n+\n   /* Upper bound on non-language-specific builtins.  */\n   END_BUILTINS\n };\n #undef DEF_BUILTIN\n \n /* Names for the above.  */\n-extern const char *const built_in_names[(int) END_BUILTINS];\n+extern const char * built_in_names[(int) END_BUILTINS];\n \n /* Helper macros for math builtins.  */\n "}]}