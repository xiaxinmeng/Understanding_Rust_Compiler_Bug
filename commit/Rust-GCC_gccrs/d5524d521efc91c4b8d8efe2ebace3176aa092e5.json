{"sha": "d5524d521efc91c4b8d8efe2ebace3176aa092e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU1MjRkNTIxZWZjOTFjNGI4ZDhlZmUyZWJhY2UzMTc2YWEwOTJlNQ==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2015-06-10T07:50:59Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2015-06-10T07:50:59Z"}, "message": "Add ARM/thumb attribute target\n\n\tPR target/52144\n\n\t* config/arm/arm.opt (THUMB, arm_restrict_it, inline_asm_unified): Save.\n\t* config/arm/arm-protos.h (arm_valid_target_attribute_tree): Declare.\n\t(arm_reset_previous_fndecl, arm_change_mode_p): Likewise.\n\t* config/arm/arm.h (SWITCHABLE_TARGET): Define.\n\t* config/arm/arm.c (arm_reset_previous_fndecl): New functions.\n\t(arm_valid_target_attribute_tree, arm_change_mode_p): Likewise.\n\t(arm_valid_target_attribute_p): Likewise.\n\t(arm_set_current_function, arm_can_inline_p): Likewise.\n\t(arm_valid_target_attribute_rec): Likewise.\n\t(arm_previous_fndecl): New variable.\n\t(TARGET_SET_CURRENT_FUNCTION, TARGET_OPTION_VALID_ATTRIBUTE_P): Define.\n\t(TARGET_CAN_INLINE_P): Define.\n\t(arm_asm_trampoline_template): Emit mode.\n\t(arm_file_start): Don't set unified syntax.\n\t(arm_declare_function_name): Set unified syntax and mode.\n\t(arm_option_override): Init target_option_default_node.\n\tand target_option_current_node.\n\t* config/arm/arm.md (*call_value_symbol): Set mode when possible.\n\t(*call_symbol): Likewise.\n\t* doc/extend.texi: Document ARM/Thumb target attribute.\n\t* doc/invoke.texi: Likewise.\n\n\t* gcc.target/arm/attr_arm.c: New test\n\t* gcc.target/arm/attr_arm-err.c: New test\n\t* gcc.target/arm/attr_thumb.c: New test\n\t* gcc.target/arm/attr_thumb-static.c: New test\n\nFrom-SVN: r224314", "tree": {"sha": "1f17c4692550cddef894f009b22e9e45c99ab8d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f17c4692550cddef894f009b22e9e45c99ab8d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5524d521efc91c4b8d8efe2ebace3176aa092e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5524d521efc91c4b8d8efe2ebace3176aa092e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5524d521efc91c4b8d8efe2ebace3176aa092e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5524d521efc91c4b8d8efe2ebace3176aa092e5/comments", "author": null, "committer": null, "parents": [{"sha": "eb071c6bdc37cc6ba41611bf2c0cb96de376e39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb071c6bdc37cc6ba41611bf2c0cb96de376e39e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb071c6bdc37cc6ba41611bf2c0cb96de376e39e"}], "stats": {"total": 412, "additions": 400, "deletions": 12}, "files": [{"sha": "a73afaa6b28fb1c85549e410e60f32e4bc00f7f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -1,3 +1,28 @@\n+2015-06-09  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/52144\n+\t* config/arm/arm.opt (THUMB, arm_restrict_it, inline_asm_unified): Save.\n+\t* config/arm/arm-protos.h (arm_valid_target_attribute_tree): Declare.\n+\t(arm_reset_previous_fndecl, arm_change_mode_p): Likewise.\n+\t* config/arm/arm.h (SWITCHABLE_TARGET): Define.\n+\t* config/arm/arm.c (arm_reset_previous_fndecl): New functions.\n+\t(arm_valid_target_attribute_tree, arm_change_mode_p): Likewise.\n+\t(arm_valid_target_attribute_p): Likewise.\n+\t(arm_set_current_function, arm_can_inline_p): Likewise.\n+\t(arm_valid_target_attribute_rec): Likewise.\n+\t(arm_previous_fndecl): New variable.\n+\t(TARGET_SET_CURRENT_FUNCTION, TARGET_OPTION_VALID_ATTRIBUTE_P): Define.\n+\t(TARGET_CAN_INLINE_P): Define.\n+\t(arm_asm_trampoline_template): Emit mode.\n+\t(arm_file_start): Don't set unified syntax.\n+\t(arm_declare_function_name): Set unified syntax and mode.\n+\t(arm_option_override): Init target_option_default_node.\n+\tand target_option_current_node.\n+\t* config/arm/arm.md (*call_value_symbol): Set mode when possible.\n+\t(*call_symbol): Likewise.\n+\t* doc/extend.texi: Document ARM/Thumb target attribute.\n+\t* doc/invoke.texi: Likewise.\n+\n 2015-06-09  Alexandre Oliva <aoliva@redhat.com>\n \n \tRevert:"}, {"sha": "3092b1a0592e454c0ff32d031bb67989f865a7de", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -210,6 +210,9 @@ extern int arm_dllexport_p (tree);\n extern int arm_dllimport_p (tree);\n extern void arm_mark_dllexport (tree);\n extern void arm_mark_dllimport (tree);\n+extern bool arm_change_mode_p (tree);\n+extern tree arm_valid_target_attribute_tree (tree, struct gcc_options *,\n+\t\t\t\t\t     struct gcc_options *);\n #endif\n \n extern void arm_pr_long_calls (struct cpp_reader *);\n@@ -326,6 +329,8 @@ extern bool arm_autoinc_modes_ok_p (machine_mode, enum arm_auto_incmodes);\n \n extern void arm_emit_eabi_attribute (const char *, int, int);\n \n+extern void arm_reset_previous_fndecl (void);\n+\n /* Defined in gcc/common/config/arm-common.c.  */\n extern const char *arm_rewrite_selected_cpu (const char *name);\n "}, {"sha": "353c2c599d90e167dd072c689aa39c1678604fdc", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 250, "deletions": 7, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -81,6 +81,7 @@\n #include \"opts.h\"\n #include \"dumpfile.h\"\n #include \"gimple-expr.h\"\n+#include \"target-globals.h\"\n #include \"builtins.h\"\n #include \"tm-constrs.h\"\n #include \"rtl-iter.h\"\n@@ -252,6 +253,9 @@ static tree arm_build_builtin_va_list (void);\n static void arm_expand_builtin_va_start (tree, rtx);\n static tree arm_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n static void arm_option_override (void);\n+static void arm_set_current_function (tree);\n+static bool arm_can_inline_p (tree, tree);\n+static bool arm_valid_target_attribute_p (tree, tree, tree, int);\n static unsigned HOST_WIDE_INT arm_shift_truncation_mask (machine_mode);\n static bool arm_macro_fusion_p (void);\n static bool arm_cannot_copy_insn_p (rtx_insn *);\n@@ -400,6 +404,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef  TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE arm_output_function_epilogue\n \n+#undef TARGET_CAN_INLINE_P\n+#define TARGET_CAN_INLINE_P arm_can_inline_p\n+\n #undef  TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE arm_option_override\n \n@@ -418,6 +425,12 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef  TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST arm_adjust_cost\n \n+#undef TARGET_SET_CURRENT_FUNCTION\n+#define TARGET_SET_CURRENT_FUNCTION arm_set_current_function\n+\n+#undef TARGET_OPTION_VALID_ATTRIBUTE_P\n+#define TARGET_OPTION_VALID_ATTRIBUTE_P arm_valid_target_attribute_p\n+\n #undef TARGET_SCHED_REORDER\n #define TARGET_SCHED_REORDER arm_sched_reorder\n \n@@ -2778,6 +2791,9 @@ arm_option_params_internal (struct gcc_options *opts)\n     max_insns_skipped = current_tune->max_insns_skipped;\n }\n \n+/* Options after initial target override.  */\n+static GTY(()) tree init_optimize;\n+\n /* Reset options between modes that the user has specified.  */\n static void\n arm_option_override_internal (struct gcc_options *opts,\n@@ -2800,23 +2816,29 @@ arm_option_override_internal (struct gcc_options *opts,\n   if (TARGET_THUMB_P (opts->x_target_flags) && TARGET_CALLEE_INTERWORKING)\n     opts->x_target_flags |= MASK_INTERWORK;\n \n+  /* need to remember initial values so combinaisons of options like\n+     -mflip-thumb -mthumb -fno-schedule-insns work for any attribute.  */\n+  cl_optimization *to = TREE_OPTIMIZATION (init_optimize);\n+\n   if (! opts_set->x_arm_restrict_it)\n     opts->x_arm_restrict_it = arm_arch8;\n \n   if (!TARGET_THUMB2_P (opts->x_target_flags))\n     opts->x_arm_restrict_it = 0;\n \n+  /* Don't warn since it's on by default in -O2.  */\n   if (TARGET_THUMB1_P (opts->x_target_flags))\n-    {\n-      /* Don't warn since it's on by default in -O2.  */\n-      opts->x_flag_schedule_insns = 0;\n-    }\n+    opts->x_flag_schedule_insns = 0;\n+  else\n+    opts->x_flag_schedule_insns = to->x_flag_schedule_insns;\n \n   /* Disable shrink-wrap when optimizing function for size, since it tends to\n      generate additional returns.  */\n   if (optimize_function_for_size_p (cfun)\n       && TARGET_THUMB2_P (opts->x_target_flags))\n     opts->x_flag_shrink_wrap = false;\n+  else\n+    opts->x_flag_shrink_wrap = to->x_flag_shrink_wrap;\n \n   /* In Thumb1 mode, we emit the epilogue in RTL, but the last insn\n      - epilogue_insns - does not accurately model the corresponding insns\n@@ -2828,6 +2850,8 @@ arm_option_override_internal (struct gcc_options *opts,\n      fipa-ra.  */\n   if (TARGET_THUMB1_P (opts->x_target_flags))\n     opts->x_flag_ipa_ra = 0;\n+  else\n+    opts->x_flag_ipa_ra = to->x_flag_ipa_ra;\n \n   /* Thumb2 inline assembly code should always use unified syntax.\n      This will apply to ARM and Thumb1 eventually.  */\n@@ -3330,12 +3354,20 @@ arm_option_override (void)\n       && (!arm_arch7 || !current_tune->prefer_ldrd_strd))\n     flag_schedule_fusion = 0;\n \n+  /* Need to remember initial options before they are overriden.  */\n+  init_optimize = build_optimization_node (&global_options);\n+\n   arm_option_override_internal (&global_options, &global_options_set);\n   arm_option_check_internal (&global_options);\n   arm_option_params_internal (&global_options);\n \n   /* Register global variables with the garbage collector.  */\n   arm_add_gc_roots ();\n+\n+  /* Save the initial options in case the user does function specific\n+     options.  */\n+  target_option_default_node = target_option_current_node\n+    = build_target_option_node (&global_options);\n }\n \n static void\n@@ -3489,13 +3521,20 @@ arm_warn_func_return (tree decl)\n static void\n arm_asm_trampoline_template (FILE *f)\n {\n+  if (TARGET_UNIFIED_ASM)\n+    fprintf (f, \"\\t.syntax unified\\n\");\n+  else\n+    fprintf (f, \"\\t.syntax divided\\n\");\n+\n   if (TARGET_ARM)\n     {\n+      fprintf (f, \"\\t.arm\\n\");\n       asm_fprintf (f, \"\\tldr\\t%r, [%r, #0]\\n\", STATIC_CHAIN_REGNUM, PC_REGNUM);\n       asm_fprintf (f, \"\\tldr\\t%r, [%r, #0]\\n\", PC_REGNUM, PC_REGNUM);\n     }\n   else if (TARGET_THUMB2)\n     {\n+      fprintf (f, \"\\t.thumb\\n\");\n       /* The Thumb-2 trampoline is similar to the arm implementation.\n \t Unlike 16-bit Thumb, we enter the stub in thumb mode.  */\n       asm_fprintf (f, \"\\tldr.w\\t%r, [%r, #4]\\n\",\n@@ -24193,6 +24232,24 @@ arm_init_expanders (void)\n     mark_reg_pointer (arg_pointer_rtx, PARM_BOUNDARY);\n }\n \n+/* Check that FUNC is called with a different mode.  */\n+\n+bool\n+arm_change_mode_p (tree func)\n+{\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return false;\n+\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (func);\n+\n+  if (!callee_tree)\n+    callee_tree = target_option_default_node;\n+\n+  struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n+  int flags = callee_opts->x_target_flags;\n+\n+  return (TARGET_THUMB_P (flags) != TARGET_THUMB);\n+}\n \n /* Like arm_compute_initial_elimination offset.  Simpler because there\n    isn't an ABI specified frame pointer for Thumb.  Instead, we set it\n@@ -25520,9 +25577,6 @@ arm_file_start (void)\n {\n   int val;\n \n-  if (TARGET_UNIFIED_ASM)\n-    asm_fprintf (asm_out_file, \"\\t.syntax unified\\n\");\n-\n   if (TARGET_BPABI)\n     {\n       const char *fpu_name;\n@@ -29269,9 +29323,196 @@ arm_is_constant_pool_ref (rtx x)\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)));\n }\n \n+/* Remember the last target of arm_set_current_function.  */\n+static GTY(()) tree arm_previous_fndecl;\n+\n+/* Invalidate arm_previous_fndecl.  */\n+void\n+arm_reset_previous_fndecl (void)\n+{\n+  arm_previous_fndecl = NULL_TREE;\n+}\n+\n+/* Establish appropriate back-end context for processing the function\n+   FNDECL.  The argument might be NULL to indicate processing at top\n+   level, outside of any function scope.  */\n+static void\n+arm_set_current_function (tree fndecl)\n+{\n+  if (!fndecl || fndecl == arm_previous_fndecl)\n+    return;\n+\n+  tree old_tree = (arm_previous_fndecl\n+\t\t   ? DECL_FUNCTION_SPECIFIC_TARGET (arm_previous_fndecl)\n+\t\t   : NULL_TREE);\n+\n+  tree new_tree = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);\n+\n+  arm_previous_fndecl = fndecl;\n+  if (old_tree == new_tree)\n+    ;\n+\n+  else if (new_tree)\n+    {\n+      cl_target_option_restore (&global_options,\n+\t\t\t\tTREE_TARGET_OPTION (new_tree));\n+\n+      if (TREE_TARGET_GLOBALS (new_tree))\n+\trestore_target_globals (TREE_TARGET_GLOBALS (new_tree));\n+      else\n+\tTREE_TARGET_GLOBALS (new_tree)\n+\t  = save_target_globals_default_opts ();\n+    }\n+\n+  else if (old_tree)\n+    {\n+      new_tree = target_option_current_node;\n+\n+      cl_target_option_restore (&global_options,\n+\t\t\t\tTREE_TARGET_OPTION (new_tree));\n+      if (TREE_TARGET_GLOBALS (new_tree))\n+\trestore_target_globals (TREE_TARGET_GLOBALS (new_tree));\n+      else if (new_tree == target_option_default_node)\n+\trestore_target_globals (&default_target_globals);\n+      else\n+\tTREE_TARGET_GLOBALS (new_tree)\n+\t  = save_target_globals_default_opts ();\n+    }\n+\n+  arm_option_params_internal (&global_options);\n+}\n+\n+/* Hook to determine if one function can safely inline another.  */\n+\n+static bool\n+arm_can_inline_p (tree caller ATTRIBUTE_UNUSED, tree callee ATTRIBUTE_UNUSED)\n+{\n+  /* Overidde default hook: Always OK to inline between different modes. \n+     Function with mode specific instructions, e.g using asm, must be explicitely \n+     protected with noinline.  */\n+  return true;\n+}\n+\n+/* Inner function to process the attribute((target(...))), take an argument and\n+   set the current options from the argument.  If we have a list, recursively\n+   go over the list.  */\n+\n+static bool\n+arm_valid_target_attribute_rec (tree args,  struct gcc_options *opts)\n+{\n+  if (TREE_CODE (args) == TREE_LIST)\n+    {\n+      bool ret = true;\n+      for (; args; args = TREE_CHAIN (args))\n+\tif (TREE_VALUE (args)\n+\t    && !arm_valid_target_attribute_rec (TREE_VALUE (args), opts))\n+\t  ret = false;\n+      return ret;\n+    }\n+\n+  else if (TREE_CODE (args) != STRING_CST)\n+    {\n+      error (\"attribute %<target%> argument not a string\");\n+      return false;\n+    }\n+\n+  char *argstr = ASTRDUP (TREE_STRING_POINTER (args));\n+  while (argstr && *argstr != '\\0')\n+    {\n+      while (ISSPACE (*argstr))\n+\targstr++;\n+\n+      if (!strcmp (argstr, \"thumb\"))\n+\t{\n+\t  opts->x_target_flags |= MASK_THUMB;\n+\t  arm_option_check_internal (opts);\n+\t  return true;\n+\t}\n+\n+      if (!strcmp (argstr, \"arm\"))\n+\t{\n+\t  opts->x_target_flags &= ~MASK_THUMB;\n+\t  arm_option_check_internal (opts);\n+\t  return true;\n+\t}\n+\n+      warning (0, \"attribute(target(\\\"%s\\\")) is unknown\", argstr);\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return a TARGET_OPTION_NODE tree of the target options listed or NULL.  */\n+\n+tree\n+arm_valid_target_attribute_tree (tree args, struct gcc_options *opts,\n+\t\t\t\t struct gcc_options *opts_set)\n+{\n+  if (!arm_valid_target_attribute_rec (args, opts))\n+    return NULL_TREE;\n+\n+  /* Do any overrides, such as global options arch=xxx.  */\n+  arm_option_override_internal (opts, opts_set);\n+\n+  return build_target_option_node (opts);\n+}\n+\n+/* Hook to validate attribute((target(\"string\"))).  */\n+\n+static bool\n+arm_valid_target_attribute_p (tree fndecl, tree ARG_UNUSED (name),\n+\t\t\t      tree args, int ARG_UNUSED (flags))\n+{\n+  bool ret = true;\n+  struct gcc_options func_options;\n+  tree cur_tree, new_optimize;\n+  gcc_assert ((fndecl != NULL_TREE) && (args != NULL_TREE));\n+\n+  /* Get the optimization options of the current function.  */\n+  tree func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n+\n+  /* If the function changed the optimization levels as well as setting target\n+     options, start with the optimizations specified.  */\n+  if (!func_optimize)\n+    func_optimize = optimization_default_node;\n+\n+  /* Init func_options.  */\n+  memset (&func_options, 0, sizeof (func_options));\n+  init_options_struct (&func_options, NULL);\n+  lang_hooks.init_options_struct (&func_options);\n+\n+  /* Initialize func_options to the defaults.  */\n+  cl_optimization_restore (&func_options,\n+\t\t\t   TREE_OPTIMIZATION (func_optimize));\n+\n+  cl_target_option_restore (&func_options,\n+\t\t\t    TREE_TARGET_OPTION (target_option_default_node));\n+\n+  /* Set func_options flags with new target mode.  */\n+  cur_tree = arm_valid_target_attribute_tree (args, &func_options,\n+\t\t\t\t\t      &global_options_set);\n+\n+  if (cur_tree == NULL_TREE)\n+    ret = false;\n+\n+  new_optimize = build_optimization_node (&func_options);\n+\n+  DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = cur_tree;\n+\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;\n+\n+  return ret;\n+}\n+\n void\n arm_declare_function_name (FILE *stream, const char *name, tree decl)\n {\n+  if (TARGET_UNIFIED_ASM)\n+    fprintf (stream, \"\\t.syntax unified\\n\");\n+  else\n+    fprintf (stream, \"\\t.syntax divided\\n\");\n+\n   if (TARGET_THUMB)\n     {\n       if (is_called_in_ARM_mode (decl)\n@@ -29283,6 +29524,8 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)\n       else\n \tfprintf (stream, \"\\t.thumb\\n\\t.thumb_func\\n\");\n     }\n+  else\n+    fprintf (stream, \"\\t.arm\\n\");\n \n   if (TARGET_POKE_FUNCTION_NAME)\n     arm_poke_function_name (stream, (const char *) name);"}, {"sha": "b24b4fb7d0a88bfc46e4aa11202ac8b0d649747c", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -2258,4 +2258,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define DRIVER_SELF_SPECS MCPU_MTUNE_NATIVE_SPECS\n #define TARGET_SUPPORTS_WIDE_INT 1\n+\n+/* For switching between functions with different target attributes.  */\n+#define SWITCHABLE_TARGET 1\n+\n #endif /* ! GCC_ARM_H */"}, {"sha": "1ac8af099ce1e2cef0d1aefae898e96d32f2ef97", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -7787,6 +7787,13 @@\n    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))\"\n   \"*\n   {\n+   rtx op = operands[0];\n+\n+   /* Switch mode now when possible.  */\n+   if (SYMBOL_REF_DECL (op) && !TREE_PUBLIC (SYMBOL_REF_DECL (op))\n+        && arm_arch5 && arm_change_mode_p (SYMBOL_REF_DECL (op)))\n+      return NEED_PLT_RELOC ? \\\"blx%?\\\\t%a0(PLT)\\\" : \\\"blx%?\\\\t(%a0)\\\";\n+\n     return NEED_PLT_RELOC ? \\\"bl%?\\\\t%a0(PLT)\\\" : \\\"bl%?\\\\t%a0\\\";\n   }\"\n   [(set_attr \"type\" \"call\")]\n@@ -7804,6 +7811,13 @@\n    && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))\"\n   \"*\n   {\n+   rtx op = operands[1];\n+\n+   /* Switch mode now when possible.  */\n+   if (SYMBOL_REF_DECL (op) && !TREE_PUBLIC (SYMBOL_REF_DECL (op))\n+        && arm_arch5 && arm_change_mode_p (SYMBOL_REF_DECL (op)))\n+      return NEED_PLT_RELOC ? \\\"blx%?\\\\t%a0(PLT)\\\" : \\\"blx%?\\\\t(%a0)\\\";\n+\n     return NEED_PLT_RELOC ? \\\"bl%?\\\\t%a1(PLT)\\\" : \\\"bl%?\\\\t%a1\\\";\n   }\"\n   [(set_attr \"type\" \"call\")]"}, {"sha": "59e5385803ea09979a07c8589dc416e31ebb9519", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -182,7 +182,7 @@ Target RejectNegative Joined UInteger Var(arm_structure_size_boundary) Init(DEFA\n Specify the minimum bit alignment of structures\n \n mthumb\n-Target Report RejectNegative Mask(THUMB)\n+Target Report RejectNegative Mask(THUMB) Save\n Generate code for Thumb state\n \n mthumb-interwork\n@@ -246,7 +246,7 @@ Target Report Var(target_word_relocations) Init(TARGET_DEFAULT_WORD_RELOCATIONS)\n Only generate absolute relocations on word sized values.\n \n mrestrict-it\n-Target Report Var(arm_restrict_it) Init(2)\n+Target Report Var(arm_restrict_it) Init(2) Save\n Generate IT blocks appropriate for ARMv8.\n \n mold-rtx-costs\n@@ -275,5 +275,5 @@ Target Report Var(target_slow_flash_data) Init(0)\n Assume loading data from flash is slower than fetching instructions.\n \n masm-syntax-unified\n-Target Report Var(inline_asm_unified) Init(0)\n+Target Report Var(inline_asm_unified) Init(0) Save\n Assume unified syntax for Thumb inline assembly code."}, {"sha": "9ad2b680ea51c6a2d47160e311d32e4e08b88fbf", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -3098,8 +3098,9 @@ strings separated by commas to specify multiple options,\n or separate the options with a comma (@samp{,}) within a single string.\n \n The options supported are specific to each target; refer to @ref{x86\n-Function Attributes}, @ref{PowerPC Function Attributes}, and\n-@ref{Nios II Function Attributes}, for details.\n+Function Attributes}, @ref{PowerPC Function Attributes},\n+@ref{ARM Function Attributes},and @ref{Nios II Function Attributes},\n+for details.\n \n @item unused\n @cindex @code{unused} function attribute\n@@ -3448,6 +3449,27 @@ double f2d (float) __attribute__((pcs(\"aapcs\")));\n \n Variadic functions always use the @code{\"aapcs\"} calling convention and\n the compiler rejects attempts to specify an alternative.\n+\n+@item target (@var{options})\n+@cindex @code{target} function attribute\n+As discussed in @ref{Common Function Attributes}, this attribute \n+allows specification of target-specific compilation options.\n+\n+On ARM, the following options are allowed:\n+\n+@table @samp\n+@item thumb\n+@cindex @code{target(\"thumb\")} function attribute, ARM\n+Force code generation in the Thumb (T16/T32) ISA, depending on the\n+architecture level.\n+\n+@item arm\n+@cindex @code{target(\"arm\")} function attribute, ARM\n+Force code generation in the ARM (A32) ISA.\n+@end table\n+\n+Functions from different modes can be inlined in the caller's mode.\n+\n @end table\n \n @node AVR Function Attributes"}, {"sha": "5903c751579873da42dbf0901c6b2ae73b988607", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -13512,6 +13512,10 @@ that executes in ARM state, but the default can be changed by\n configuring GCC with the @option{--with-mode=}@var{state}\n configure option.\n \n+You can also override the ARM and Thumb mode for each function\n+by using the @code{target(\"thumb\")} and @code{target(\"arm\")} function attributes\n+(@pxref{ARM Function Attributes}) or pragmas (@pxref{Function Specific Option Pragmas}).\n+\n @item -mtpcs-frame\n @opindex mtpcs-frame\n Generate a stack frame that is compliant with the Thumb Procedure Call"}, {"sha": "d0527f70e3a84875517adfd30a9f7a772d754a64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -1,3 +1,11 @@\n+2015-06-09  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/52144\n+\t* gcc.target/arm/attr_arm.c: New test\n+\t* gcc.target/arm/attr_arm-err.c: New test\n+\t* gcc.target/arm/attr_thumb.c: New test\n+\t* gcc.target/arm/attr_thumb-static.c: New test\n+\n 2015-06-10  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/66200"}, {"sha": "630c06a03b121b9705e1422556bad8952885fc28", "filename": "gcc/testsuite/gcc.target/arm/attr_arm-err.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_arm-err.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_arm-err.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_arm-err.c?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -0,0 +1,13 @@\n+/* Check that attribute target arm is rejected for M profile.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arm_ok } */\n+/* { dg-skip-if \"avoid conflicting multilib options\" { *-*-* } { \"-march=*\" } { \"-march=armv6-m\" } } */\n+/* { dg-add-options arm_arch_v6m } */\n+\n+int __attribute__((target(\"arm\")))\n+foo(int a)\n+{  /* { dg-error \"does not support\" } */\n+  return a ? 1 : 5;\n+}\n+\n+"}, {"sha": "7e8d53d68c55d355a6d506980649daeeff5445b1", "filename": "gcc/testsuite/gcc.target/arm/attr_arm.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_arm.c?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -0,0 +1,13 @@\n+/* Check that attribute target arm is recogniwed.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arm_ok } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \".arm\" } } */\n+/* { dg-final { scan-assembler-not \"ite\" } } */\n+\n+int __attribute__((target(\"arm\")))\n+foo(int a)\n+{\n+  return a ? 1 : 5;\n+}\n+"}, {"sha": "8dc6451e0255862280aebc662c155da9cbbb4449", "filename": "gcc/testsuite/gcc.target/arm/attr_thumb-static.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_thumb-static.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_thumb-static.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_thumb-static.c?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -0,0 +1,24 @@\n+/* Check that a change mode to a static function is correctly handled. */\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+\n+static void\n+ __attribute__((__noinline__)) \n+foo (void)\n+{\n+  __asm__ (\"\");\n+}\n+\n+static void\n+__attribute__((__noinline__)) \n+__attribute__((target(\"thumb\")))\n+bar (void)\n+{\n+  __asm__ (\"\");\n+}\n+\n+int main()\n+{\n+  foo();\n+  bar();\n+}"}, {"sha": "013402190ff34d7a1e07e4abdd534f17c98b9183", "filename": "gcc/testsuite/gcc.target/arm/attr_thumb.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_thumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5524d521efc91c4b8d8efe2ebace3176aa092e5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_thumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fattr_thumb.c?ref=d5524d521efc91c4b8d8efe2ebace3176aa092e5", "patch": "@@ -0,0 +1,13 @@\n+/* Check that attribute target thumb is recogniwed. */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \".thumb\" } } */\n+/* { dg-final { scan-assembler \"ite\" } } */\n+\n+int __attribute__((target(\"thumb\")))\n+foo(int a)\n+{\n+  return a ? 1 : 5;\n+}\n+"}]}