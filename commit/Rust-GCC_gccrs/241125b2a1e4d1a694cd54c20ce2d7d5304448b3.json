{"sha": "241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxMTI1YjJhMWU0ZDFhNjk0Y2Q1NGMyMGNlMmQ3ZDUzMDQ0NDhiMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-26T19:40:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-26T19:40:18Z"}, "message": "ada-tree.h (DECL_GLOBAL_NONCONSTANT_RENAMING_P): Delete\n\n\t* gcc-interface/ada-tree.h (DECL_GLOBAL_NONCONSTANT_RENAMING_P): Delete\n\t(DECL_RENAMED_OBJECT): Adjust comment.\n\t* gcc-interface/gigi.h (record_global_nonconstant_renaming): Delete.\n\t(invalidate_global_nonconstant_renamings): Likewise.\n\t(gnat_constant_reference_p): Likewise.\n\t(rewrite_fn): New function type.\n\t(gnat_rewrite_reference): Declare.\n\t(call_is_atomic_load): New inline predicate.\n\t* gcc-interface/decl.c (elaborate_reference_1): New function.\n\t(elaborate_reference): Likewise.\n\t(gnat_to_gnu_entity): Call elaborate_reference to elaborate renamings\n\tand simplify associated code.  Set const_flag to true consistently in\n \tconjunction with used_by_ref.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Always replace renaming\n\tpointers by renamed objects.\n\t(outer_atomic_access_required_p): Deal with renamings.\n\t(Compilation_Unit_to_gnu): Do not call\n\tinvalidate_global_nonconstant_renamings.\n\t(gnat_to_gnu) <N_Object_Renaming_Declaration>: Adjust comment.\n\t(gnat_gimplify_expr): Deal with atomic loads.\n\t* gcc-interface/utils.c (global_nonconstant_renamings): Delete.\n\t(destroy_gnat_utils): Do not call\n\tinvalidate_global_nonconstant_renamings.\n\t(record_global_nonconstant_renaming): Delete.\n\t(invalidate_global_nonconstant_renamings): Likewise.\n\t* gcc-interface/utils2.c (call_is_atomic_load): Move to gigi.h.\n\t(build_load_modify_store): Build a copy of the destination.\n\t(gnat_stabilize_reference_1): Adjust.\n\t(gnat_stabilize_reference): Call gnat_stabilize_reference_1 through\n\tgnat_rewrite_reference and move bulk of code to...\n\t(gnat_rewrite_reference): ...here.  New global function.\n\t(gnat_constant_reference_p): Delete.\n\nFrom-SVN: r223709", "tree": {"sha": "327efcc70b8f4f364b4effa1ab951f534b11e419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327efcc70b8f4f364b4effa1ab951f534b11e419"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/comments", "author": null, "committer": null, "parents": [{"sha": "7194767cdf77212e8c736f41b426e3f636f52ca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7194767cdf77212e8c736f41b426e3f636f52ca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7194767cdf77212e8c736f41b426e3f636f52ca3"}], "stats": {"total": 434, "additions": 236, "deletions": 198}, "files": [{"sha": "12953b8ff22697bcb474a562f7f2271650a15411", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -1,3 +1,38 @@\n+2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_GLOBAL_NONCONSTANT_RENAMING_P): Delete\n+\t(DECL_RENAMED_OBJECT): Adjust comment.\n+\t* gcc-interface/gigi.h (record_global_nonconstant_renaming): Delete.\n+\t(invalidate_global_nonconstant_renamings): Likewise.\n+\t(gnat_constant_reference_p): Likewise.\n+\t(rewrite_fn): New function type.\n+\t(gnat_rewrite_reference): Declare.\n+\t(call_is_atomic_load): New inline predicate.\n+\t* gcc-interface/decl.c (elaborate_reference_1): New function.\n+\t(elaborate_reference): Likewise.\n+\t(gnat_to_gnu_entity): Call elaborate_reference to elaborate renamings\n+\tand simplify associated code.  Set const_flag to true consistently in\n+ \tconjunction with used_by_ref.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Always replace renaming\n+\tpointers by renamed objects.\n+\t(outer_atomic_access_required_p): Deal with renamings.\n+\t(Compilation_Unit_to_gnu): Do not call\n+\tinvalidate_global_nonconstant_renamings.\n+\t(gnat_to_gnu) <N_Object_Renaming_Declaration>: Adjust comment.\n+\t(gnat_gimplify_expr): Deal with atomic loads.\n+\t* gcc-interface/utils.c (global_nonconstant_renamings): Delete.\n+\t(destroy_gnat_utils): Do not call\n+\tinvalidate_global_nonconstant_renamings.\n+\t(record_global_nonconstant_renaming): Delete.\n+\t(invalidate_global_nonconstant_renamings): Likewise.\n+\t* gcc-interface/utils2.c (call_is_atomic_load): Move to gigi.h.\n+\t(build_load_modify_store): Build a copy of the destination.\n+\t(gnat_stabilize_reference_1): Adjust.\n+\t(gnat_stabilize_reference): Call gnat_stabilize_reference_1 through\n+\tgnat_rewrite_reference and move bulk of code to...\n+\t(gnat_rewrite_reference): ...here.  New global function.\n+\t(gnat_constant_reference_p): Delete.\n+\n 2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (gnat_stabilize_reference): Adjust prototype."}, {"sha": "5f6d0a1054021117d644a83f77ddbde5359f9812", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -394,10 +394,6 @@ do {\t\t\t\t\t\t   \\\n    is readonly.  */\n #define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n \n-/* Nonzero in a VAR_DECL if it is a global non-constant renaming.  */\n-#define DECL_GLOBAL_NONCONSTANT_RENAMING_P(NODE) \\\n-  DECL_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n-\n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n@@ -439,8 +435,7 @@ do {\t\t\t\t\t\t   \\\n   SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n \n /* In a VAR_DECL without the DECL_LOOP_PARM_P flag set and that is a renaming\n-   pointer, points to the object being renamed, if any.  Note that this object\n-   is guaranteed to be protected against multiple evaluations.  */\n+   pointer, points to the object being renamed, if any.  */\n #define DECL_RENAMED_OBJECT(NODE) \\\n   GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n #define SET_DECL_RENAMED_OBJECT(NODE, X) \\"}, {"sha": "4a8c4d0c35eca685a66c6fa3e44f6aa2cf1b238c", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 97, "deletions": 81, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -179,6 +179,7 @@ static bool type_has_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, const char *, bool, bool);\n static tree elaborate_expression_2 (tree, Entity_Id, const char *, bool, bool,\n \t\t\t\t    unsigned int);\n+static tree elaborate_reference (tree, Entity_Id, bool);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n@@ -557,11 +558,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  break;\n \t}\n \n-      /* If we have an external constant that we are not defining, get the\n-\t expression that is was defined to represent.  We may throw it away\n-\t later if it is not a constant.  But do not retrieve the expression\n-\t if it is an allocator because the designated type might be dummy\n-\t at this point.  */\n+      /* If we have a constant that we are not defining, get the expression it\n+\t was defined to represent.  This is necessary to avoid generating dumb\n+\t elaboration code in simple cases, but we may throw it away later if it\n+\t is not a constant.  But do not retrieve it if it is an allocator since\n+\t the designated type might still be dummy at this point.  */\n       if (!definition\n \t  && !No_Initialization (Declaration_Node (gnat_entity))\n \t  && Present (Expression (Declaration_Node (gnat_entity)))\n@@ -995,32 +996,31 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       before the call to \"=\".  */\n \t    if (TREE_CODE (inner) == TRUTH_ANDIF_EXPR)\n \t      inner = TREE_OPERAND (inner, 1);\n-\t    if (TREE_CODE (inner) == CALL_EXPR\n-\t        || TREE_CODE (inner) == NULL_EXPR\n-\t        || TREE_CODE (inner) == CONSTRUCTOR\n+\t    if ((TREE_CODE (inner) == CALL_EXPR\n+\t\t && !call_is_atomic_load (inner))\n+\t\t|| TREE_CODE (inner) == NULL_EXPR\n+\t\t|| TREE_CODE (inner) == CONSTRUCTOR\n \t\t|| CONSTANT_CLASS_P (inner))\n \t      ;\n \n \t    /* Case 2: if the renaming entity need not be materialized, use\n-\t       the stabilized renamed expression for the renaming.  At the\n-\t       global level, we can do this only if we know no SAVE_EXPRs\n-\t       need be made, because otherwise the expression would be tied\n-\t       to a specific elaboration routine.  */\n-\t    else if (!Materialize_Entity (gnat_entity)\n-\t\t     && (!global_bindings_p ()\n-\t\t\t || (staticp (gnu_expr)\n-\t\t\t     && !TREE_SIDE_EFFECTS (gnu_expr))))\n+\t       the elaborated renamed expression for the renaming.  But this\n+\t       means that the caller is responsible for evaluating the address\n+\t       of the renaming at the correct spot in the definition case to\n+\t       instantiate the SAVE_EXPRs.  */\n+\t    else if (!Materialize_Entity (gnat_entity))\n \t      {\n-\t\tgnu_decl = gnat_stabilize_reference (gnu_expr, true);\n+\t\tgnu_decl\n+\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition);\n \n-\t\t/* ??? No DECL_EXPR is created so we need to mark\n-\t\t   the expression manually lest it is shared.  */\n+\t\t/* No DECL_EXPR will be created so the expression needs to be\n+\t\t   marked manually because it will likely be shared.  */\n \t\tif (global_bindings_p ())\n \t\t  MARK_VISITED (gnu_decl);\n \n-\t\t/* This assertion will fail if the renamed object isn't\n-\t\t   aligned enough as to make it possible to honor the\n-\t\t   alignment set on the renaming.  */\n+\t\t/* This assertion will fail if the renamed object isn't aligned\n+\t\t   enough as to make it possible to honor the alignment set on\n+\t\t   the renaming.  */\n \t\tif (align)\n \t\t  {\n \t\t    unsigned int ralign = DECL_P (gnu_decl)\n@@ -1036,52 +1036,41 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \n \t    /* Case 3: otherwise, make a constant pointer to the object we\n-\t       are to rename and attach the object to the pointer after it\n-\t       is stabilized.\n-\n-\t       From the proper scope, attached objects will be referenced\n-\t       directly instead of indirectly via the pointer to avoid\n-\t       subtle aliasing problems with non-addressable entities.\n-\t       They have to be stable because we must not evaluate the\n-\t       variables in the expression every time the renaming is used.\n-\t       The pointer is called a \"renaming\" pointer in this case.\n-\n-\t       Note that we need to preserve the volatility of the renamed\n-\t       object through the indirection.  */\n+\t       are renaming and attach the object to the pointer after it is\n+\t       elaborated.  The object will be referenced directly instead\n+\t       of indirectly via the pointer to avoid aliasing problems with\n+\t       non-addressable entities.  The pointer is called a \"renaming\"\n+\t       pointer in this case.  Note that we also need to preserve the\n+\t       volatility of the renamed object through the indirection.  */\n \t    else\n \t      {\n \t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n \t\t  gnu_type\n \t\t    = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n+\n \t\tgnu_type = build_reference_type (gnu_type);\n-\t\tinner_const_flag = TREE_READONLY (gnu_expr);\n+\t\tused_by_ref = true;\n \t\tconst_flag = true;\n+\t\tinner_const_flag = TREE_READONLY (gnu_expr);\n+\t\tgnu_size = NULL_TREE;\n \n-\t\t/* Stabilize and attach the expression to the pointer.\n-\n-\t\t   Note that this might introduce SAVE_EXPRs and we don't\n-\t\t   check whether we are at the global level or not.  This\n-\t\t   is fine since we are building a pointer initializer and\n-\t\t   neither the pointer nor the initializing expression can\n-\t\t   be accessed before the pointer elaboration has taken\n-\t\t   place in a correct program.\n+\t\trenamed_obj\n+\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition);\n \n-\t\t   These SAVE_EXPRs will be evaluated at the right place\n-\t\t   by either the evaluation of the initializer for the\n-\t\t   non-global case or the elaboration code for the global\n-\t\t   case, and will be attached to the elaboration procedure\n-\t\t   in the latter case.  */\n-\t\trenamed_obj = gnat_stabilize_reference (gnu_expr, true);\n+\t\t/* If we are not defining the entity, the expression will not\n+\t\t   be attached through DECL_INITIAL so it needs to be marked\n+\t\t   manually because it will likely be shared.  Likewise for a\n+\t\t   dereference as it will be folded by the ADDR_EXPR below.  */\n+\t\tif ((!definition || TREE_CODE (renamed_obj) == INDIRECT_REF)\n+\t\t    && global_bindings_p ())\n+\t\t  MARK_VISITED (renamed_obj);\n \n \t\tif (type_annotate_only\n- \t\t    && TREE_CODE (renamed_obj) == ERROR_MARK)\n+\t\t    && TREE_CODE (renamed_obj) == ERROR_MARK)\n \t\t  gnu_expr = NULL_TREE;\n \t\telse\n \t\t  gnu_expr\n \t\t    = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n-\n-\t\tgnu_size = NULL_TREE;\n-\t\tused_by_ref = true;\n \t      }\n \t  }\n \n@@ -1173,9 +1162,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n-\t    /* Ignore the size.  It's either meaningless or was handled\n-\t       above.  */\n-\t    gnu_size = NULL_TREE;\n \t    /* Convert the type of the object to a reference type that can\n \t       alias everything as per 13.3(19).  */\n \t    gnu_type\n@@ -1185,6 +1171,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    const_flag\n \t      = !Is_Public (gnat_entity)\n \t\t|| compile_time_known_address_p (gnat_expr);\n+\t    gnu_size = NULL_TREE;\n \n \t    /* If this is a deferred constant, the initializer is attached to\n \t       the full view.  */\n@@ -1221,6 +1208,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       alias everything as per 13.3(19).  */\n \t    gnu_type\n \t      = build_reference_type_for_mode (gnu_type, ptr_mode, true);\n+\t    used_by_ref = true;\n \t    gnu_size = NULL_TREE;\n \n \t    /* No point in taking the address of an initializing expression\n@@ -1241,8 +1229,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    const_flag = true;\n \t\t  }\n \t      }\n-\n-\t    used_by_ref = true;\n \t  }\n \n \t/* If we are at top level and this object is of variable size,\n@@ -1269,8 +1255,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t|| static_p)))\n \t  {\n \t    gnu_type = build_reference_type (gnu_type);\n-\t    gnu_size = NULL_TREE;\n \t    used_by_ref = true;\n+\t    const_flag = true;\n+\t    gnu_size = NULL_TREE;\n \n \t    /* In case this was a aliased object whose nominal subtype is\n \t       unconstrained, the pointer above will be a thin pointer and\n@@ -1313,13 +1300,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_expr\n \t\t  = build_allocator (gnu_alloc_type, gnu_expr, gnu_type,\n \t\t\t\t     Empty, Empty, gnat_entity, mutable_p);\n-\t\tconst_flag = true;\n \t      }\n \t    else\n-\t      {\n-\t\tgnu_expr = NULL_TREE;\n-\t\tconst_flag = false;\n-\t      }\n+\t      gnu_expr = NULL_TREE;\n \t  }\n \n \t/* If this object would go into the stack and has an alignment larger\n@@ -1357,9 +1340,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t build_component_ref (gnu_new_var, NULL_TREE,\n \t\t\t\t      TYPE_FIELDS (gnu_new_type), false));\n \n-\t    gnu_size = NULL_TREE;\n \t    used_by_ref = true;\n \t    const_flag = true;\n+\t    gnu_size = NULL_TREE;\n \t  }\n \n \t/* If this is an aliased object with an unconstrained nominal subtype,\n@@ -1389,10 +1372,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_unc_var);\n \t\tTREE_CONSTANT (gnu_expr) = 1;\n \n-\t\tgnu_size = NULL_TREE;\n \t\tused_by_ref = true;\n-\t\tinner_const_flag = TREE_READONLY (gnu_unc_var);\n \t\tconst_flag = true;\n+\t\tinner_const_flag = TREE_READONLY (gnu_unc_var);\n+\t\tgnu_size = NULL_TREE;\n \t      }\n \n \t    gnu_type\n@@ -1481,20 +1464,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (kind == E_Loop_Parameter)\n \t  DECL_LOOP_PARM_P (gnu_decl) = 1;\n \n-\t/* If this is a renaming pointer, attach the renamed object to it and\n-\t   register it if we are at the global level and the renamed object\n-\t   is a non-constant reference.  */\n+\t/* If this is a renaming pointer, attach the renamed object to it.  */\n \tif (renamed_obj)\n-\t  {\n-\t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n-\n-\t    if (global_bindings_p ()\n-\t\t&& !gnat_constant_reference_p (renamed_obj))\n-\t      {\n-\t\tDECL_GLOBAL_NONCONSTANT_RENAMING_P (gnu_decl) = 1;\n-\t\trecord_global_nonconstant_renaming (gnu_decl);\n-\t      }\n-\t  }\n+\t  SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n \n \t/* If this is a constant and we are defining it or it generates a real\n \t   symbol at the object level and we are referencing it, we may want\n@@ -6109,7 +6081,7 @@ prepend_attributes (struct attrib **attr_list, Entity_Id gnat_entity)\n /* Given a GNAT tree GNAT_EXPR, for an expression which is a value within a\n    type definition (either a bound or a discriminant value) for GNAT_ENTITY,\n    return the GCC tree to use for that expression.  S is the suffix to use\n-   if a variable needs to be created and DEFINITION is true if this is made\n+   if a variable needs to be created and DEFINITION is true if this is done\n    for a definition of GNAT_ENTITY.  If NEED_VALUE is true, we need a result;\n    otherwise, we are just elaborating the expression for side-effects.  If\n    NEED_DEBUG is true, we need a variable for debugging purposes even if it\n@@ -6250,6 +6222,50 @@ elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t\t\t\t\tneed_debug),\n \t\tunit_align);\n }\n+\n+/* Structure to hold internal data for elaborate_reference.  */\n+\n+struct er_data\n+{\n+  Entity_Id entity;\n+  bool definition;\n+};\n+\n+/* Wrapper function around elaborate_expression_1 for elaborate_reference.  */\n+\n+static tree\n+elaborate_reference_1 (tree ref, void *data, int n)\n+{\n+  struct er_data *er = (struct er_data *)data;\n+  char suffix[16];\n+\n+  /* This is what elaborate_expression_1 does if NEED_DEBUG is false.  */\n+  if (TREE_CONSTANT (ref))\n+    return ref;\n+\n+  /* If this is a COMPONENT_REF of a fat pointer, elaborate the entire fat\n+     pointer.  This may be more efficient, but will also allow us to more\n+     easily find the match for the PLACEHOLDER_EXPR.  */\n+  if (TREE_CODE (ref) == COMPONENT_REF\n+      && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (ref, 0))))\n+    return build3 (COMPONENT_REF, TREE_TYPE (ref),\n+\t\t   elaborate_reference_1 (TREE_OPERAND (ref, 0), data, n),\n+\t\t   TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n+\n+  sprintf (suffix, \"EXP%d\", n);\n+  return\n+    elaborate_expression_1 (ref, er->entity, suffix, er->definition, false);\n+}\n+\n+/* Elaborate the reference REF to be used as renamed object for GNAT_ENTITY.\n+   DEFINITION is true if this is done for a definition of GNAT_ENTITY.  */\n+\n+static tree\n+elaborate_reference (tree ref, Entity_Id gnat_entity, bool definition)\n+{\n+  struct er_data er = { gnat_entity, definition };\n+  return gnat_rewrite_reference (ref, elaborate_reference_1, &er);\n+}\n \f\n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */"}, {"sha": "b75cc35395bebb8ffc2e531102e4e41588533772", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -712,12 +712,6 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t     const_flag, public_flag, extern_flag,\t\t\\\n \t\t     static_flag, false, attr_list, gnat_node)\n \n-/* Record DECL as a global non-constant renaming.  */\n-extern void record_global_nonconstant_renaming (tree decl);\n-\n-/* Invalidate the global non-constant renamings.  */\n-extern void invalidate_global_nonconstant_renamings (void);\n-\n /* Return a FIELD_DECL node.  FIELD_NAME is the field's name, FIELD_TYPE is\n    its type and RECORD_TYPE is the type of the enclosing record.  If SIZE is\n    nonzero, it is the specified size of the field.  If POS is nonzero, it is\n@@ -968,15 +962,19 @@ extern tree gnat_protect_expr (tree exp);\n    force evaluation of everything.  */\n extern tree gnat_stabilize_reference (tree ref, bool force);\n \n+/* Rewrite reference REF and call FUNC on each expression within REF in the\n+   process.  DATA is passed unmodified to FUNC and N is bumped each time it\n+   is passed to FUNC, so FUNC is guaranteed to see a given N only once per\n+   reference to be rewritten.  */\n+typedef tree (*rewrite_fn) (tree, void *, int);\n+extern tree gnat_rewrite_reference (tree ref, rewrite_fn func, void *data,\n+\t\t\t\t    int n = 1);\n+\n /* This is equivalent to get_inner_reference in expr.c but it returns the\n    ultimate containing object only if the reference (lvalue) is constant,\n    i.e. if it doesn't depend on the context in which it is evaluated.  */\n extern tree get_inner_constant_reference (tree exp);\n \n-/* Return true if REF is a constant reference, i.e. a reference (lvalue) that\n-   doesn't depend on the context in which it is evaluated.  */\n-extern bool gnat_constant_reference_p (tree ref);\n-\n /* If EXPR is an expression that is invariant in the current function, in the\n    sense that it can be evaluated anywhere in the function and any number of\n    times, return EXPR or an equivalent expression.  Otherwise return NULL.  */\n@@ -1073,3 +1071,17 @@ ceil_pow2 (unsigned HOST_WIDE_INT x)\n {\n   return (unsigned HOST_WIDE_INT) 1 << (floor_log2 (x - 1) + 1);\n }\n+\n+/* Return true if EXP, a CALL_EXPR, is an atomic load.  */\n+\n+static inline bool\n+call_is_atomic_load (tree exp)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+\n+  if (!(fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL))\n+    return false;\n+\n+  enum built_in_function code = DECL_FUNCTION_CODE (fndecl);\n+  return BUILT_IN_ATOMIC_LOAD_N <= code && code <= BUILT_IN_ATOMIC_LOAD_16;\n+}"}, {"sha": "b3258091947250baa5782110ef6a8591500345ad", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -1163,15 +1163,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t\t\t  true, false)))\n \tgnu_result = DECL_INITIAL (gnu_result);\n \n-      /* If it's a renaming pointer and not a global non-constant renaming or\n-\t we are at the global level, the we can reference the renamed object\n-\t directly, since it is either constant or has been protected against\n-\t multiple evaluations.  */\n+      /* If it's a renaming pointer, get to the renamed object.  */\n       if (TREE_CODE (gnu_result) == VAR_DECL\n           && !DECL_LOOP_PARM_P (gnu_result)\n-\t  && DECL_RENAMED_OBJECT (gnu_result)\n-\t  && (!DECL_GLOBAL_NONCONSTANT_RENAMING_P (gnu_result)\n-\t      || global_bindings_p ()))\n+\t  && DECL_RENAMED_OBJECT (gnu_result))\n \tgnu_result = DECL_RENAMED_OBJECT (gnu_result);\n \n       /* Otherwise, do the final dereference.  */\n@@ -3975,16 +3970,32 @@ outer_atomic_access_required_p (Node_Id gnat_node)\n {\n   gnat_node = gnat_strip_type_conversion (gnat_node);\n \n-  while (Nkind (gnat_node) == N_Indexed_Component\n-\t || Nkind (gnat_node) == N_Selected_Component\n-\t || Nkind (gnat_node) == N_Slice)\n+  while (true)\n     {\n-      gnat_node = gnat_strip_type_conversion (Prefix (gnat_node));\n-      if (node_has_volatile_full_access (gnat_node))\n-\treturn true;\n+      switch (Nkind (gnat_node))\n+\t{\n+\tcase N_Identifier:\n+\tcase N_Expanded_Name:\n+\t  if (No (Renamed_Object (Entity (gnat_node))))\n+\t    return false;\n+\t  gnat_node\n+\t    = gnat_strip_type_conversion (Renamed_Object (Entity (gnat_node)));\n+\t  break;\n+\n+\tcase N_Indexed_Component:\n+\tcase N_Selected_Component:\n+\tcase N_Slice:\n+\t  gnat_node = gnat_strip_type_conversion (Prefix (gnat_node));\n+\t  if (node_has_volatile_full_access (gnat_node))\n+\t    return true;\n+\t  break;\n+\n+\tdefault:\n+\t  return false;\n+\t}\n     }\n \n-  return false;\n+  gcc_unreachable ();\n }\n \n /* Return true if GNAT_NODE requires atomic access and set SYNC according to\n@@ -5290,11 +5301,6 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   info->gnat_node = gnat_node;\n   elab_info_list = info;\n \n-  /* Invalidate the global non-constant renamings.  This is necessary because\n-     stabilization of the renamed entities may create SAVE_EXPRs which have\n-     been tied to a specific elaboration routine just above.  */\n-  invalidate_global_nonconstant_renamings ();\n-\n   /* Force the processing for all nodes that remain in the queue.  */\n   process_deferred_decl_context (true);\n }\n@@ -5838,8 +5844,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  tree gnu_temp\n \t    = gnat_to_gnu_entity (gnat_temp,\n \t\t\t\t  gnat_to_gnu (Renamed_Object (gnat_temp)), 1);\n-\t  /* We need to make sure that the side-effects of the renamed object\n-\t     are evaluated at this point, so we evaluate its address.  */\n+\t  /* See case 2 of renaming in gnat_to_gnu_entity.  */\n \t  if (TREE_SIDE_EFFECTS (gnu_temp))\n \t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n \t}\n@@ -7933,6 +7938,26 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t  return GS_ALL_DONE;\n \t}\n \n+      /* Replace atomic loads with their first argument.  That's necessary\n+\t because the gimplifier would create a temporary otherwise.  */\n+      if (TREE_SIDE_EFFECTS (op))\n+\twhile (handled_component_p (op) || CONVERT_EXPR_P (op))\n+\t  {\n+\t    tree inner = TREE_OPERAND (op, 0);\n+\t    if (TREE_CODE (inner) == CALL_EXPR && call_is_atomic_load (inner))\n+\t      {\n+\t\ttree t = CALL_EXPR_ARG (inner, 0);\n+\t\tif (TREE_CODE (t) == NOP_EXPR)\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\tif (TREE_CODE (t) == ADDR_EXPR)\n+\t\t  TREE_OPERAND (op, 0) = TREE_OPERAND (t, 0);\n+\t\telse\n+\t\t  TREE_OPERAND (op, 0) = build_fold_indirect_ref (t);\n+\t      }\n+\t    else\n+\t      op = inner;\n+\t  }\n+\n       return GS_UNHANDLED;\n \n     case VIEW_CONVERT_EXPR:"}, {"sha": "f9840981a9ef4b1f12b795962aab764fafb077e2", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -233,9 +233,6 @@ static GTY(()) vec<tree, va_gc> *global_decls;\n /* An array of builtin function declarations.  */\n static GTY(()) vec<tree, va_gc> *builtin_decls;\n \n-/* An array of global non-constant renamings.  */\n-static GTY(()) vec<tree, va_gc> *global_nonconstant_renamings;\n-\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n@@ -322,9 +319,6 @@ destroy_gnat_utils (void)\n   /* Destroy the hash table of padded types.  */\n   pad_type_hash_table->empty ();\n   pad_type_hash_table = NULL;\n-\n-  /* Invalidate the global non-constant renamings.   */\n-  invalidate_global_nonconstant_renamings ();\n }\n \f\n /* GNAT_ENTITY is a GNAT tree node for an entity.  Associate GNU_DECL, a GCC\n@@ -2717,33 +2711,6 @@ process_attributes (tree *node, struct attrib **attr_list, bool in_place,\n \n   *attr_list = NULL;\n }\n-\f\n-/* Record DECL as a global non-constant renaming.  */\n-\n-void\n-record_global_nonconstant_renaming (tree decl)\n-{\n-  gcc_assert (!DECL_LOOP_PARM_P (decl) && DECL_RENAMED_OBJECT (decl));\n-  vec_safe_push (global_nonconstant_renamings, decl);\n-}\n-\n-/* Invalidate the global non-constant renamings, lest their renamed object\n-   contains SAVE_EXPRs tied to an elaboration routine.  */\n-\n-void\n-invalidate_global_nonconstant_renamings (void)\n-{\n-  unsigned int i;\n-  tree iter;\n-\n-  if (global_nonconstant_renamings == NULL)\n-    return;\n-\n-  FOR_EACH_VEC_ELT (*global_nonconstant_renamings, i, iter)\n-    SET_DECL_RENAMED_OBJECT (iter, NULL_TREE);\n-\n-  vec_free (global_nonconstant_renamings);\n-}\n \n /* Return true if VALUE is a known to be a multiple of FACTOR, which must be\n    a power of 2. */"}, {"sha": "edbcc539fa86dfb5bc8502d4756d1de1ac4e201f", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 35, "deletions": 47, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241125b2a1e4d1a694cd54c20ce2d7d5304448b3/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=241125b2a1e4d1a694cd54c20ce2d7d5304448b3", "patch": "@@ -738,27 +738,15 @@ build_atomic_store (tree dest, tree src, bool sync)\n   return build_call_expr (t, 3, addr, src, mem_model);\n }\n \n-/* Return true if EXP, a CALL_EXPR, is an atomic load.  */\n-\n-static bool\n-call_is_atomic_load (tree exp)\n-{\n-  tree fndecl = get_callee_fndecl (exp);\n-\n-  if (!(fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL))\n-    return false;\n-\n-  enum built_in_function code = DECL_FUNCTION_CODE (fndecl);\n-  return BUILT_IN_ATOMIC_LOAD_N <= code && code <= BUILT_IN_ATOMIC_LOAD_16;\n-}\n-\n /* Build a load-modify-store sequence from SRC to DEST.  GNAT_NODE is used for\n-   the location of the sequence.  Note that, even if the load and the store are\n-   both atomic, the sequence itself is not atomic.  */\n+   the location of the sequence.  Note that, even though the load and the store\n+   are both atomic, the sequence itself is not atomic.  */\n \n tree\n build_load_modify_store (tree dest, tree src, Node_Id gnat_node)\n {\n+  /* We will be modifying DEST below so we build a copy.  */\n+  dest = copy_node (dest);\n   tree ref = dest;\n \n   while (handled_component_p (ref))\n@@ -812,6 +800,7 @@ build_load_modify_store (tree dest, tree src, Node_Id gnat_node)\n \t    }\n \t}\n \n+      TREE_OPERAND (ref, 0) = copy_node (TREE_OPERAND (ref, 0));\n       ref = TREE_OPERAND (ref, 0);\n     }\n \n@@ -2674,8 +2663,9 @@ gnat_protect_expr (tree exp)\n    argument to force evaluation of everything.  */\n \n static tree\n-gnat_stabilize_reference_1 (tree e, bool force)\n+gnat_stabilize_reference_1 (tree e, void *data, int n)\n {\n+  const bool force = *(bool *)data;\n   enum tree_code code = TREE_CODE (e);\n   tree type = TREE_TYPE (e);\n   tree result;\n@@ -2698,7 +2688,7 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \t  && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n \tresult\n \t  = build3 (code, type,\n-\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n+\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data, n),\n \t\t    TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n       /* If the expression has side-effects, then encase it in a SAVE_EXPR\n \t so that it will only be evaluated once.  */\n@@ -2714,15 +2704,15 @@ gnat_stabilize_reference_1 (tree e, bool force)\n       /* Recursively stabilize each operand.  */\n       result\n \t= build2 (code, type,\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), force));\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data, n),\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), data, n));\n       break;\n \n     case tcc_unary:\n       /* Recursively stabilize each operand.  */\n       result\n \t= build1 (code, type,\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force));\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), data, n));\n       break;\n \n     default:\n@@ -2742,6 +2732,17 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \n tree\n gnat_stabilize_reference (tree ref, bool force)\n+{\n+  return gnat_rewrite_reference (ref, gnat_stabilize_reference_1, &force);\n+}\n+\n+/* Rewrite reference REF and call FUNC on each expression within REF in the\n+   process.  DATA is passed unmodified to FUNC and N is bumped each time it\n+   is passed to FUNC, so FUNC is guaranteed to see a given N only once per\n+   reference to be rewritten.  */\n+\n+tree\n+gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, int n)\n {\n   tree type = TREE_TYPE (ref);\n   enum tree_code code = TREE_CODE (ref);\n@@ -2762,34 +2763,36 @@ gnat_stabilize_reference (tree ref, bool force)\n     case VIEW_CONVERT_EXPR:\n       result\n \t= build1 (code, type,\n-\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force));\n+\t\t  gnat_rewrite_reference (TREE_OPERAND (ref, 0), func, data,\n+\t\t\t\t\t  n));\n       break;\n \n     case INDIRECT_REF:\n     case UNCONSTRAINED_ARRAY_REF:\n-      result = build1 (code, type,\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\t   force));\n+      result = build1 (code, type, func (TREE_OPERAND (ref, 0), data, n));\n       break;\n \n     case COMPONENT_REF:\n       result = build3 (COMPONENT_REF, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t       gnat_rewrite_reference (TREE_OPERAND (ref, 0), func,\n+\t\t\t\t\t       data, n),\n \t\t       TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n       result = build3 (BIT_FIELD_REF, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t       gnat_rewrite_reference (TREE_OPERAND (ref, 0), func,\n+\t\t\t\t\t       data, n),\n \t\t       TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n       break;\n \n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n       result\n \t= build4 (code, type,\n-\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1), force),\n+\t\t  gnat_rewrite_reference (TREE_OPERAND (ref, 0), func, data,\n+\t\t\t\t\t  n + 1),\n+\t\t  func (TREE_OPERAND (ref, 1), data, n),\n \t\t  TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n@@ -2804,9 +2807,10 @@ gnat_stabilize_reference (tree ref, bool force)\n \t  t = TREE_OPERAND (t, 0);\n \tif (TREE_CODE (t) == ADDR_EXPR)\n \t  t = build1 (ADDR_EXPR, TREE_TYPE (t),\n-\t\t      gnat_stabilize_reference (TREE_OPERAND (t, 0), force));\n+\t\t      gnat_rewrite_reference (TREE_OPERAND (t, 0), func, data,\n+\t\t\t\t\t      n));\n \telse\n-\t  t = gnat_stabilize_reference_1 (t, force);\n+\t  t = func (t, data, n);\n \tt = fold_convert (TREE_TYPE (CALL_EXPR_ARG (ref, 0)), t);\n \n \tresult = build_call_expr (TREE_OPERAND (CALL_EXPR_FN (ref), 0), 2,\n@@ -2895,22 +2899,6 @@ get_inner_constant_reference (tree exp)\n   return exp;\n }\n \n-/* Return true if REF is a constant reference, i.e. a reference (lvalue) that\n-   doesn't depend on the context in which it is evaluated.  */\n-\n-bool\n-gnat_constant_reference_p (tree ref)\n-{\n-  if (handled_component_p (ref))\n-    {\n-      ref = get_inner_constant_reference (ref);\n-      if (!ref)\n-\treturn false;\n-    }\n-\n-  return DECL_P (ref);\n-}\n-\n /* If EXPR is an expression that is invariant in the current function, in the\n    sense that it can be evaluated anywhere in the function and any number of\n    times, return EXPR or an equivalent expression.  Otherwise return NULL.  */"}]}