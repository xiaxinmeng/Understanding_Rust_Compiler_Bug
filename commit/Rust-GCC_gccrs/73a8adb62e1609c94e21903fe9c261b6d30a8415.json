{"sha": "73a8adb62e1609c94e21903fe9c261b6d30a8415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhOGFkYjYyZTE2MDljOTRlMjE5MDNmZTljMjYxYjZkMzBhODQxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-04T05:27:52Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-04T05:27:52Z"}, "message": "class.c (build_vtable): Do not set DECL_VISIBILITY here.\n\n\t* class.c (build_vtable): Do not set DECL_VISIBILITY here.\n\t(check_field_decls): Or here.\n\t(check_methods): Or here.\n\t(initialize_array): Don't mess with DECL_CONTEXT.\n\t* cp-tree.h (start_decl): Adjust prototype.\n\t(determine_visibility): New function.\n\t* decl.c (duplicate_decls): Remove checks for hidden \"operator\n\tnew\".\n\t(build_library_fn_1): Give all library functions default\n\tvisibility.\n\t(start_decl): Add pop_scope_p parameter.  Tidy.\n\t(cp_finish_decl): Do not pop scopes here.  Call\n\tdetermine_visibility for variable definitions.\n\t(start_preparsed_function): Call determine_visibility.\n\t* decl2.c (determine_visibility): New function.\n\t* method.c (use_thunk): Fix formatting.\n\t* parser.c (cp_parser_condition): Adjust calls to start_decl.\n\t(cp_parser_init_declarator): Likewise.\n\t* pt.c (instantiate_decl): Always call pop_nested_class.\n\t* rtti.c (get_tinfo_decl): Do not set DECL_VISIBILITY.\n\t(tinfo_base_init): Likewise.\n\n\t* g++.dg/ext/visibility/assign1.C: New test.\n\t* g++.dg/ext/visibility/new1.C: Likewise.\n\nFrom-SVN: r85543", "tree": {"sha": "dc4c187d7c4a64c15aab2950413405f2b750eaf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc4c187d7c4a64c15aab2950413405f2b750eaf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a8adb62e1609c94e21903fe9c261b6d30a8415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a8adb62e1609c94e21903fe9c261b6d30a8415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a8adb62e1609c94e21903fe9c261b6d30a8415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a8adb62e1609c94e21903fe9c261b6d30a8415/comments", "author": null, "committer": null, "parents": [{"sha": "aed6152d8c55eb6e756b7459733a8bfda3dd00a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed6152d8c55eb6e756b7459733a8bfda3dd00a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed6152d8c55eb6e756b7459733a8bfda3dd00a3"}], "stats": {"total": 327, "additions": 167, "deletions": 160}, "files": [{"sha": "e82e5005d00b78885d31146115e61fc6b2148298", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -1,3 +1,27 @@\n+2004-08-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (build_vtable): Do not set DECL_VISIBILITY here.\n+\t(check_field_decls): Or here.\n+\t(check_methods): Or here.\n+\t(initialize_array): Don't mess with DECL_CONTEXT.\n+\t* cp-tree.h (start_decl): Adjust prototype.\n+\t(determine_visibility): New function.\n+\t* decl.c (duplicate_decls): Remove checks for hidden \"operator\n+\tnew\".\n+\t(build_library_fn_1): Give all library functions default\n+\tvisibility.\n+\t(start_decl): Add pop_scope_p parameter.  Tidy.\n+\t(cp_finish_decl): Do not pop scopes here.  Call\n+\tdetermine_visibility for variable definitions.\n+\t(start_preparsed_function): Call determine_visibility.\n+\t* decl2.c (determine_visibility): New function.\n+\t* method.c (use_thunk): Fix formatting.\n+\t* parser.c (cp_parser_condition): Adjust calls to start_decl.\n+\t(cp_parser_init_declarator): Likewise.\n+\t* pt.c (instantiate_decl): Always call pop_nested_class.\n+\t* rtti.c (get_tinfo_decl): Do not set DECL_VISIBILITY.\n+\t(tinfo_base_init): Likewise.\n+\n 2004-08-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16707"}, {"sha": "e0bae52179f65981a008d888804568085e69b076", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -659,11 +659,6 @@ build_vtable (tree class_type, tree name, tree vtable_type)\n        require more intrusive changes to the g++ front end.  */\n     DECL_IGNORED_P (decl) = 1;\n \n-  /* The vtable's visibility is the class visibility.  There is no way\n-     to override the visibility for just the vtable. */\n-  DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n-  DECL_VISIBILITY_SPECIFIED (decl) = CLASSTYPE_VISIBILITY_SPECIFIED (class_type);\n-\n   return decl;\n }\n \n@@ -2971,25 +2966,7 @@ check_field_decls (tree t, tree *access_decls,\n \tcontinue;\n \t  \n       if (TREE_CODE (x) == CONST_DECL || TREE_CODE (x) == VAR_DECL)\n-\t{\n-\t  /* Apply the class's visibility attribute to static members\n-\t     which do not have a visibility attribute. */\n-\t  if (! lookup_attribute (\"visibility\", DECL_ATTRIBUTES (x)))\n-            {\n-              if (visibility_options.inlines_hidden && DECL_INLINE (x))\n-                {\n-                  DECL_VISIBILITY (x) = VISIBILITY_HIDDEN;\n-                  DECL_VISIBILITY_SPECIFIED (x) = 1;\n-                }\n-              else\n-                {\n-                  DECL_VISIBILITY (x) = CLASSTYPE_VISIBILITY (current_class_type);\n-                  DECL_VISIBILITY_SPECIFIED (x) = CLASSTYPE_VISIBILITY_SPECIFIED (current_class_type);\n-                }\n-            }\n-\n-\t  continue;\n-\t}\n+\tcontinue;\n \n       /* Now it can only be a FIELD_DECL.  */\n \n@@ -3744,23 +3721,6 @@ check_methods (tree t)\n       check_for_override (x, t);\n       if (DECL_PURE_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n \tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n- \n-      /* Apply the class's visibility attribute to methods which do\n-\t not have a visibility attribute. */\n-      if (! lookup_attribute (\"visibility\", DECL_ATTRIBUTES (x)))\n-        {\n-          if (visibility_options.inlines_hidden && DECL_INLINE (x))\n-            {\n-              DECL_VISIBILITY (x) = VISIBILITY_HIDDEN;\n-              DECL_VISIBILITY_SPECIFIED (x) = 1;\n-            }\n-          else\n-            {\n-              DECL_VISIBILITY (x) = CLASSTYPE_VISIBILITY (current_class_type);\n-              DECL_VISIBILITY_SPECIFIED (x) = CLASSTYPE_VISIBILITY_SPECIFIED (current_class_type);\n-            }\n-        }\n-\n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n       if (DECL_VINDEX (x))\n@@ -6740,13 +6700,8 @@ initialize_vtable (tree binfo, tree inits)\n static void\n initialize_array (tree decl, tree inits)\n {\n-  tree context;\n-\n-  context = DECL_CONTEXT (decl);\n-  DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = build_constructor (NULL_TREE, inits);\n   cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n-  DECL_CONTEXT (decl) = context;\n }\n \n /* Build the VTT (virtual table table) for T."}, {"sha": "5b4992562386f34db78e7e4c3f8a824c68c6f0a0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -3740,7 +3740,7 @@ extern int init_type_desc\t\t\t(void);\n extern tree check_tag_decl\t\t\t(cp_decl_specifier_seq *);\n extern tree shadow_tag\t\t\t\t(cp_decl_specifier_seq *);\n extern tree groktypename\t\t\t(cp_decl_specifier_seq *, const cp_declarator *);\n-extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree);\n+extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int, tree, tree, bool *);\n extern void start_decl_1\t\t\t(tree);\n extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n@@ -3825,6 +3825,7 @@ extern tree finish_table (tree, tree, tree, int);\n extern tree coerce_new_type (tree);\n extern tree coerce_delete_type (tree);\n extern void comdat_linkage (tree);\n+extern void determine_visibility (tree);\n extern void import_export_decl (tree);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree     (tree, tree);"}, {"sha": "8c85e71003d24cb5298674f382d761aca2f84804", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 60, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -1881,11 +1881,12 @@ duplicate_decls (tree newdecl, tree olddecl)\n   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n \n   /* Warn about conflicting visibility specifications.  */\n-  if (DECL_VISIBILITY_SPECIFIED (olddecl) && DECL_VISIBILITY_SPECIFIED (newdecl)\n+  if (DECL_VISIBILITY_SPECIFIED (olddecl) \n+      && DECL_VISIBILITY_SPECIFIED (newdecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n       warning (\"%J'%D': visibility attribute ignored because it\",\n-        newdecl, newdecl);\n+\t       newdecl, newdecl);\n       warning (\"%Jconflicts with previous declaration here\", olddecl);\n     }\n   /* Choose the declaration which specified visibility.  */\n@@ -1894,21 +1895,6 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n       DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n     }\n-  /* If it's a definition of a global operator new or operator\n-     delete, it must be default visibility.  */\n-  if (NEW_DELETE_OPNAME_P (DECL_NAME (newdecl)) && DECL_INITIAL (newdecl) != NULL_TREE)\n-    {\n-      if (!DECL_FUNCTION_MEMBER_P (newdecl) && VISIBILITY_DEFAULT != DECL_VISIBILITY (newdecl))\n-        {\n-          warning (\"%J`%D': ignoring non-default symbol\",\n-            newdecl, newdecl);\n-          warning (\"%Jvisibility on global operator new or delete\", newdecl);\n-          DECL_VISIBILITY (olddecl) = VISIBILITY_DEFAULT;\n-          DECL_VISIBILITY_SPECIFIED (olddecl) = 1;\n-          DECL_VISIBILITY (newdecl) = VISIBILITY_DEFAULT;\n-          DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n-        }\n-    }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -3276,6 +3262,10 @@ build_library_fn_1 (tree name, enum tree_code operator_code, tree type)\n   TREE_NOTHROW (fn) = 1;\n   SET_OVERLOADED_OPERATOR_CODE (fn, operator_code);\n   SET_DECL_LANGUAGE (fn, lang_c);\n+  /* Runtime library routines are, by definition, available in an\n+     external shared object.  */\n+  DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;\n+  DECL_VISIBILITY_SPECIFIED (fn) = 1;\n   return fn;\n }\n \n@@ -3607,7 +3597,8 @@ start_decl (const cp_declarator *declarator,\n \t    cp_decl_specifier_seq *declspecs,\n             int initialized,\n             tree attributes,\n-            tree prefix_attributes)\n+            tree prefix_attributes, \n+\t    bool *pop_scope_p)\n {\n   tree decl;\n   tree type, tem;\n@@ -3642,14 +3633,11 @@ start_decl (const cp_declarator *declarator,\n \n   context = DECL_CONTEXT (decl);\n \n-  if (initialized && context && TREE_CODE (context) == NAMESPACE_DECL\n-      && context != current_namespace && TREE_CODE (decl) == VAR_DECL)\n-    {\n-      /* When parsing the initializer, lookup should use the object's\n-\t namespace.  */\n-      push_decl_namespace (context);\n-    }\n-\n+  if (context)\n+    *pop_scope_p = push_scope (context);\n+  else\n+    *pop_scope_p = false;\n+  \n   /* We are only interested in class contexts, later.  */\n   if (context && TREE_CODE (context) == NAMESPACE_DECL)\n     context = NULL_TREE;\n@@ -3705,8 +3693,6 @@ start_decl (const cp_declarator *declarator,\n \n   if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n-      push_nested_class (context);\n-\n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  tree field = lookup_field (context, DECL_NAME (decl), 0, false);\n@@ -4715,20 +4701,10 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n       && (DECL_INITIAL (decl) || init))\n     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;\n \n-  if (TREE_CODE (decl) == VAR_DECL\n-      && DECL_CONTEXT (decl)\n-      && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL\n-      && DECL_CONTEXT (decl) != current_namespace\n-      && init)\n-    {\n-      /* Leave the namespace of the object.  */\n-      pop_decl_namespace ();\n-    }\n-\n   type = TREE_TYPE (decl);\n \n   if (type == error_mark_node)\n-    goto finish_end0;\n+    goto finish_end;\n \n   if (TYPE_HAS_MUTABLE_P (type))\n     TREE_READONLY (decl) = 0;\n@@ -4745,7 +4721,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  && !DECL_PRETTY_FUNCTION_P (decl)\n \t  && !dependent_type_p (TREE_TYPE (decl)))\n \tmaybe_deduce_size_from_array_init (decl, init);\n-      goto finish_end0;\n+      goto finish_end;\n     }\n \n   /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */\n@@ -4833,6 +4809,9 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  /* Remember that the initialization for this variable has\n \t     taken place.  */\n \t  DECL_INITIALIZED_P (decl) = 1;\n+\t  /* The variable is being defined, so determine its\n+\t     visibility.  */\n+\t  determine_visibility (decl);\n \t}\n       /* If the variable has an array type, lay out the type, even if\n \t there is no initializer.  It is valid to index through the\n@@ -4899,26 +4878,6 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  if (TREE_STATIC (decl))\n \t    expand_static_init (decl, init);\n \t}\n-    finish_end0:\n-\n-      /* Undo call to `pushclass' that was done in `start_decl'\n-\t due to initialization of qualified member variable.\n-\t I.e., Foo::x = 10;  */\n-      {\n-\ttree context = CP_DECL_CONTEXT (decl);\n-\tif (context\n-\t    && TYPE_P (context)\n-\t    && (TREE_CODE (decl) == VAR_DECL\n-\t\t/* We also have a pushclass done that we need to undo here\n-\t\t   if we're at top level and declare a method.  */\n-\t\t|| TREE_CODE (decl) == FUNCTION_DECL)\n-\t    /* If size hasn't been set, we're still defining it,\n-\t       and therefore inside the class body; don't pop\n-\t       the binding level..  */\n-\t    && COMPLETE_TYPE_P (context)\n-\t    && context == current_class_type)\n-\t  pop_nested_class ();\n-      }\n     }\n \n   /* If a CLEANUP_STMT was created to destroy a temporary bound to a\n@@ -9663,6 +9622,9 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       && lookup_attribute (\"noinline\", attrs))\n     warning (\"%Jinline function '%D' given attribute noinline\", decl1, decl1);\n \n+  /* Determine the ELF visibility attribute for the function.  */\n+  determine_visibility (decl1);\n+\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))\n     /* This is a constructor, we must ensure that any default args\n        introduced by this definition are propagated to the clones"}, {"sha": "53060dd16faff1e9e3a1f3f2c14091b3eb1920e5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -1616,6 +1616,59 @@ maybe_emit_vtables (tree ctype)\n   return true;\n }\n \n+/* Determine the ELF symbol visibility for DECL.  */\n+\n+void\n+determine_visibility (tree decl)\n+{\n+  tree class_type;\n+\n+  /* Cloned constructors and destructors get the same visibility as\n+     the underlying function.  That should be set up in\n+     maybe_clone_body.  */\n+  if (DECL_CLONED_FUNCTION_P (decl))\n+    return;\n+\n+  if (DECL_CLASS_SCOPE_P (decl))\n+    class_type = DECL_CONTEXT (decl);\n+  else if (TREE_CODE (decl) == VAR_DECL\n+\t   && DECL_TINFO_P (decl)\n+\t   && CLASS_TYPE_P (TREE_TYPE (DECL_NAME (decl))))\n+    class_type = TREE_TYPE (DECL_NAME (decl));\n+  else\n+    {\n+      /* Virtual tables have DECL_CONTEXT set to their associated class,\n+\t so they are automatically handled above.  */\n+      my_friendly_assert (!(TREE_CODE (decl) == VAR_DECL\n+\t\t\t    && DECL_VTABLE_OR_VTT_P (decl)), 20040803);\n+      /* Entities not associated with any class just get the\n+\t visibility specified by their attributes.  */\n+      return;\n+    }\n+\n+  /* By default, static data members and function members receive\n+     the visibility of their containing class.  */\n+  if (class_type\n+      && (TREE_CODE (decl) == VAR_DECL \n+\t  || TREE_CODE (decl) == FUNCTION_DECL)\n+      && !lookup_attribute (\"visibility\", DECL_ATTRIBUTES (decl)))\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && DECL_DECLARED_INLINE_P (decl)\n+\t  && visibility_options.inlines_hidden)\n+\t{\n+\t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+\t  DECL_VISIBILITY_SPECIFIED (decl) = 1;\n+\t}\n+      else\n+\t{\n+\t  DECL_VISIBILITY (decl) = CLASSTYPE_VISIBILITY (class_type);\n+\t  DECL_VISIBILITY_SPECIFIED (decl)\n+\t    = CLASSTYPE_VISIBILITY_SPECIFIED (class_type);\n+\t}\n+    }\n+}\n+\n /* DECL is a FUNCTION_DECL or VAR_DECL.  If the object file linkage\n    for DECL has not already been determined, do so now by setting\n    DECL_EXTERNAL, DECL_COMDAT and other related flags.  Until this"}, {"sha": "7a2a7624fd809d6616d6230d4229f38b9c213dac", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -368,7 +368,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n      rewrite.  */\n   TREE_PUBLIC (thunk_fndecl) = TREE_PUBLIC (function);\n   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);\n-  DECL_VISIBILITY_SPECIFIED (thunk_fndecl) = DECL_VISIBILITY_SPECIFIED (function);\n+  DECL_VISIBILITY_SPECIFIED (thunk_fndecl) \n+    = DECL_VISIBILITY_SPECIFIED (function);\n   if (flag_weak && TREE_PUBLIC (thunk_fndecl))\n     comdat_linkage (thunk_fndecl);\n "}, {"sha": "d6aadb37cd783afcb8a15ab51e383c88bfa4ef38", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -6312,10 +6312,13 @@ cp_parser_condition (cp_parser* parser)\n \t for sure.  */\n       if (cp_parser_parse_definitely (parser))\n \t{\n+\t  bool pop_p;\n+\n \t  /* Create the declaration.  */\n \t  decl = start_decl (declarator, &type_specifiers,\n \t\t\t     /*initialized_p=*/true,\n-\t\t\t     attributes, /*prefix_attributes=*/NULL_TREE);\n+\t\t\t     attributes, /*prefix_attributes=*/NULL_TREE,\n+\t\t\t     &pop_p);\n \t  /* Parse the assignment-expression.  */\n \t  initializer = cp_parser_assignment_expression (parser);\n \n@@ -6324,6 +6327,8 @@ cp_parser_condition (cp_parser* parser)\n \t\t\t  initializer,\n \t\t\t  asm_specification,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n+\t  if (pop_p)\n+\t    pop_scope (DECL_CONTEXT (decl));\n \n \t  return convert_from_reference (decl);\n \t}\n@@ -10630,12 +10635,12 @@ cp_parser_init_declarator (cp_parser* parser,\n \t  have_extern_spec = false;\n \t}\n       decl = start_decl (declarator, decl_specifiers,\n-\t\t\t is_initialized, attributes, prefix_attributes);\n+\t\t\t is_initialized, attributes, prefix_attributes,\n+\t\t\t &pop_p);\n     }\n-\n-  /* Enter the SCOPE.  That way unqualified names appearing in the\n-     initializer will be looked up in SCOPE.  */\n-  if (scope)\n+  else if (scope)\n+    /* Enter the SCOPE.  That way unqualified names appearing in the\n+       initializer will be looked up in SCOPE.  */\n     pop_p = push_scope (scope);\n \n   /* Perform deferred access control checks, now that we know in which\n@@ -10682,17 +10687,12 @@ cp_parser_init_declarator (cp_parser* parser,\n     if (cp_parser_attributes_opt (parser))\n       warning (\"attributes after parenthesized initializer ignored\");\n \n-  /* Leave the SCOPE, now that we have processed the initializer.  It\n-     is important to do this before calling cp_finish_decl because it\n-     makes decisions about whether to create DECL_EXPRs or not based\n-     on the current scope.  */\n-  if (pop_p)\n-    pop_scope (scope);\n-\n   /* For an in-class declaration, use `grokfield' to create the\n      declaration.  */\n   if (member_p)\n     {\n+      if (pop_p)\n+\tpop_scope (scope);\n       decl = grokfield (declarator, decl_specifiers,\n \t\t\tinitializer, /*asmspec=*/NULL_TREE,\n \t\t\t/*attributes=*/NULL_TREE);\n@@ -10703,15 +10703,19 @@ cp_parser_init_declarator (cp_parser* parser,\n   /* Finish processing the declaration.  But, skip friend\n      declarations.  */\n   if (!friend_p && decl)\n-    cp_finish_decl (decl,\n-\t\t    initializer,\n-\t\t    asm_specification,\n-\t\t    /* If the initializer is in parentheses, then this is\n-\t\t       a direct-initialization, which means that an\n-\t\t       `explicit' constructor is OK.  Otherwise, an\n-\t\t       `explicit' constructor cannot be used.  */\n-\t\t    ((is_parenthesized_init || !is_initialized)\n+    {\n+      cp_finish_decl (decl,\n+\t\t      initializer,\n+\t\t      asm_specification,\n+\t\t      /* If the initializer is in parentheses, then this is\n+\t\t\t a direct-initialization, which means that an\n+\t\t\t `explicit' constructor is OK.  Otherwise, an\n+\t\t\t `explicit' constructor cannot be used.  */\n+\t\t      ((is_parenthesized_init || !is_initialized)\n \t\t     ? 0 : LOOKUP_ONLYCONVERTING));\n+      if (pop_p)\n+\tpop_scope (DECL_CONTEXT (decl));\n+    }\n \n   /* Remember whether or not variables were initialized by\n      constant-expressions.  */"}, {"sha": "14b0c837cf24a9bea4a21a25c20a5015b5d1bdba", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -11162,20 +11162,13 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n \t we have a chance to determine linkage.  */\n       DECL_EXTERNAL (d) = 0;\n \n-      /* This is done in analogous to `start_decl'.  It is required\n-\t for correct access checking.  */\n+      /* Enter the scope of D so that access-checking works correctly.  */\n       push_nested_class (DECL_CONTEXT (d));\n       cp_finish_decl (d, \n \t\t      (!DECL_INITIALIZED_IN_CLASS_P (d) \n \t\t       ? DECL_INITIAL (d) : NULL_TREE),\n \t\t      NULL_TREE, 0);\n-      /* Normally, pop_nested_class is called by cp_finish_decl above.\n-\t But when instantiate_decl is triggered during\n-\t instantiate_class_template processing, its DECL_CONTEXT is\n-\t still not completed yet, and pop_nested_class isn't\n-\t called.  */\n-      if (!COMPLETE_TYPE_P (DECL_CONTEXT (d)))\n-\tpop_nested_class ();\n+      pop_nested_class ();\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {"}, {"sha": "a59af79460b1f10c9bade3ffeaaa15932dd02906", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -346,6 +346,8 @@ get_tinfo_decl (tree type)\n \n       d = build_lang_decl (VAR_DECL, name, TINFO_PSEUDO_TYPE (var_desc));\n       SET_DECL_ASSEMBLER_NAME (d, name);\n+      /* Remember the type it is for.  */\n+      TREE_TYPE (name) = type;\n       DECL_TINFO_P (d) = 1;\n       DECL_ARTIFICIAL (d) = 1;\n       TREE_READONLY (d) = 1;\n@@ -354,20 +356,11 @@ get_tinfo_decl (tree type)\n \t define it later if we need to do so.  */\n       DECL_EXTERNAL (d) = 1;\n       DECL_NOT_REALLY_EXTERN (d) = 1;\n+      if (CLASS_TYPE_P (type))\n+\tCLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type)) = d;\n       set_linkage_according_to_type (type, d);\n-\n       pushdecl_top_level_and_finish (d, NULL_TREE);\n \n-      if (CLASS_TYPE_P (type))\n-\t{\n-\t  CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (type)) = d;\n-\t  DECL_VISIBILITY (d) = CLASSTYPE_VISIBILITY (type);\n-\t  DECL_VISIBILITY_SPECIFIED (d) = CLASSTYPE_VISIBILITY_SPECIFIED (type);\n-\t}\n-\n-      /* Remember the type it is for.  */\n-      TREE_TYPE (name) = type;\n-\n       /* Add decl to the global array of tinfo decls.  */\n       my_friendly_assert (unemitted_tinfo_decls != 0, 20030312);\n       VARRAY_PUSH_TREE (unemitted_tinfo_decls, d);\n@@ -791,18 +784,12 @@ tinfo_base_init (tree desc, tree target)\n     TREE_TYPE (name_name) = target;\n \n     name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n-    \n+    SET_DECL_ASSEMBLER_NAME (name_decl, name_name);\n     DECL_ARTIFICIAL (name_decl) = 1;\n     TREE_READONLY (name_decl) = 1;\n     TREE_STATIC (name_decl) = 1;\n     DECL_EXTERNAL (name_decl) = 0;\n     DECL_TINFO_P (name_decl) = 1;\n-    if (CLASS_TYPE_P (target))\n-      {\n-        DECL_VISIBILITY (name_decl) = CLASSTYPE_VISIBILITY (target);\n-        DECL_VISIBILITY_SPECIFIED (name_decl) \n-\t  = CLASSTYPE_VISIBILITY_SPECIFIED (target);\n-      }\n     if (involves_incomplete_p (target))\n       {\n \tTREE_PUBLIC (name_decl) = 0;\n@@ -811,10 +798,6 @@ tinfo_base_init (tree desc, tree target)\n     else\n       set_linkage_according_to_type (target, name_decl);\n     import_export_decl (name_decl);\n-    /* External name of the string containing the type's name has a\n-       special name.  */\n-    SET_DECL_ASSEMBLER_NAME (name_decl,\n-\t\t\t     mangle_typeinfo_string_for_type (target));\n     DECL_INITIAL (name_decl) = name_string;\n     mark_used (name_decl);\n     pushdecl_top_level_and_finish (name_decl, name_string);"}, {"sha": "6d7392fd04bcee628de20f4fa5e24bbecc3a1d68", "filename": "gcc/testsuite/g++.dg/ext/visibility/assign1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fassign1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fassign1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fassign1.C?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-visibility \"\" } */\n+/* { dg-final { scan-assembler \"\\\\.hidden.*_ZN1DaSERKS_\" } } */\n+\n+struct B {\n+  B& operator=(const B&);\n+};\n+\n+struct D : public B {\n+  // The implicit assignment operator should be hidden.\n+} __attribute__((visibility(\"hidden\")));\n+\n+D d1, d2;\n+\n+void f() {\n+  d1 = d2;\n+}"}, {"sha": "0f0be5148da8ab76eb3ffac3fff85a0773892dad", "filename": "gcc/testsuite/g++.dg/ext/visibility/new1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fnew1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a8adb62e1609c94e21903fe9c261b6d30a8415/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fnew1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvisibility%2Fnew1.C?ref=73a8adb62e1609c94e21903fe9c261b6d30a8415", "patch": "@@ -0,0 +1,14 @@\n+// { dg-require-visibility }\n+// { dg-do compile }\n+// { dg-options \"-fvisibility=hidden\" }\n+// { dg-final { scan-assembler-not \"\\\\.hidden\\[^\\n\\]*_Znwj\" } }\n+\n+void f() {\n+  new int;\n+}\n+\n+void *g();\n+\n+void *operator new(__SIZE_TYPE__) {\n+  return g();\n+}"}]}