{"sha": "db06a76e9a00cf4ec715a685dd5ca722826f783f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwNmE3NmU5YTAwY2Y0ZWM3MTVhNjg1ZGQ1Y2E3MjI4MjZmNzgzZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-01-24T07:19:49Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-01-24T07:19:49Z"}, "message": "re PR fortran/88929 (ICE on building MPICH 3.2 with GCC 9 with ISO_Fortran_binding)\n\n2019-01-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/88929\n\t* trans-array.c (gfc_conv_descriptor_elem_len): New function.\n\t* trans-array.h : Add prototype for above.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Take account of\n\tassumed rank arrays being flagged by rank = -1 in expressions.\n\tIntent in arrays need a pointer to a copy of the data to be\n\tassigned to the descriptor passed for conversion. This should\n\tthen be freed, together with the CFI descriptor on return from\n\tthe C call.\n\n2019-01-24  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/88929\n\t* gfortran.dg/ISO_Fortran_binding_3.f90 : New test\n\t* gfortran.dg/ISO_Fortran_binding_3.c : Subsidiary source.\n\nFrom-SVN: r268231", "tree": {"sha": "ab6ba45df5faf589744fea7764bd01fa7204d8b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab6ba45df5faf589744fea7764bd01fa7204d8b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db06a76e9a00cf4ec715a685dd5ca722826f783f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db06a76e9a00cf4ec715a685dd5ca722826f783f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db06a76e9a00cf4ec715a685dd5ca722826f783f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db06a76e9a00cf4ec715a685dd5ca722826f783f/comments", "author": null, "committer": null, "parents": [{"sha": "52c9cfeb083c7fff0c5049c772285131175f7d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c9cfeb083c7fff0c5049c772285131175f7d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c9cfeb083c7fff0c5049c772285131175f7d0c"}], "stats": {"total": 189, "additions": 179, "deletions": 10}, "files": [{"sha": "d728c27ffa7a4f8e1208875645e392c71dd1838f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -1,3 +1,15 @@\n+2019-01-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/88929\n+\t* trans-array.c (gfc_conv_descriptor_elem_len): New function.\n+\t* trans-array.h : Add prototype for above.\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Take account of\n+\tassumed rank arrays being flagged by rank = -1 in expressions.\n+\tIntent in arrays need a pointer to a copy of the data to be\n+\tassigned to the descriptor passed for conversion. This should\n+\tthen be freed, together with the CFI descriptor on return from\n+\tthe C call.\n+\n 2019-01-22  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/88579"}, {"sha": "6d7c3d221542787d5fe870e530d9f07609cd9802", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -285,13 +285,31 @@ gfc_conv_descriptor_rank (tree desc)\n \n   dtype = gfc_conv_descriptor_dtype (desc);\n   tmp = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (dtype)), GFC_DTYPE_RANK);\n-  gcc_assert (tmp!= NULL_TREE\n+  gcc_assert (tmp != NULL_TREE\n \t      && TREE_TYPE (tmp) == signed_char_type_node);\n   return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n \t\t\t  dtype, tmp, NULL_TREE);\n }\n \n \n+/* Return the element length from the descriptor dtype field.  */\n+\n+tree\n+gfc_conv_descriptor_elem_len (tree desc)\n+{\n+  tree tmp;\n+  tree dtype;\n+\n+  dtype = gfc_conv_descriptor_dtype (desc);\n+  tmp = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (dtype)),\n+\t\t\t   GFC_DTYPE_ELEM_LEN);\n+  gcc_assert (tmp != NULL_TREE\n+\t      && TREE_TYPE (tmp) == size_type_node);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t  dtype, tmp, NULL_TREE);\n+}\n+\n+\n tree\n gfc_conv_descriptor_attribute (tree desc)\n {"}, {"sha": "8c2d51838d4728faf34dcafc03c23f3ed4308275", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -169,6 +169,7 @@ tree gfc_conv_descriptor_offset_get (tree);\n tree gfc_conv_descriptor_span_get (tree);\n tree gfc_conv_descriptor_dtype (tree);\n tree gfc_conv_descriptor_rank (tree);\n+tree gfc_conv_descriptor_elem_len (tree);\n tree gfc_conv_descriptor_attribute (tree);\n tree gfc_get_descriptor_dimension (tree);\n tree gfc_conv_descriptor_stride_get (tree, tree);"}, {"sha": "1cbef7f4c292bf7415717cf5871665e79e093ba5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -4924,6 +4924,8 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   tree tmp;\n   tree cfi_desc_ptr;\n   tree gfc_desc_ptr;\n+  tree ptr = NULL_TREE;\n+  tree size;\n   tree type;\n   int attribute;\n   symbol_attribute attr = gfc_expr_attr (e);\n@@ -4939,7 +4941,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \tattribute = 1;\n     }\n \n-  if (e->rank)\n+  if (e->rank != 0)\n     {\n       gfc_conv_expr_descriptor (parmse, e);\n \n@@ -4950,9 +4952,14 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n       /* All the temporary descriptors are marked as DECL_ARTIFICIAL. If\n \t the expression type is different from the descriptor type, then\n \t the offset must be found (eg. to a component ref or substring)\n-\t and the dtype updated.  */\n-      type = gfc_typenode_for_spec (&e->ts);\n-      if (DECL_ARTIFICIAL (parmse->expr)\n+\t and the dtype updated.  Assumed type entities are only allowed\n+\t to be dummies in Fortran. They therefore lack the decl specific\n+\t appendiges and so must be treated differently from other fortran\n+\t entities passed to CFI descriptors in the interface decl.  */\n+      type = e->ts.type != BT_ASSUMED ? gfc_typenode_for_spec (&e->ts) :\n+\t\t\t\t\tNULL_TREE;\n+\n+      if (type && DECL_ARTIFICIAL (parmse->expr)\n \t  && type != gfc_get_element_type (TREE_TYPE (parmse->expr)))\n \t{\n \t  /* Obtain the offset to the data.  */\n@@ -4964,15 +4971,44 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \t\t\t  gfc_conv_descriptor_dtype (parmse->expr),\n \t\t\t  gfc_get_dtype_rank_type (e->rank, type));\n \t}\n-      else if (!is_subref_array (e) && !DECL_ARTIFICIAL (parmse->expr))\n+      else if (type == NULL_TREE\n+\t       || (!is_subref_array (e) && !DECL_ARTIFICIAL (parmse->expr)))\n \t{\n \t  /* Make sure that the span is set for expressions where it\n \t     might not have been done already.  */\n-\t  tmp = TREE_TYPE (parmse->expr);\n-\t  tmp = TYPE_SIZE_UNIT (gfc_get_element_type (tmp));\n+\t  tmp = gfc_conv_descriptor_elem_len (parmse->expr);\n \t  tmp = fold_convert (gfc_array_index_type, tmp);\n \t  gfc_conv_descriptor_span_set (&parmse->pre, parmse->expr, tmp);\n \t}\n+\n+      /* INTENT(IN) requires a temporary for the data. Assumed types do not\n+\t work with the standard temporary generation schemes. */\n+      if (e->expr_type == EXPR_VARIABLE && fsym->attr.intent == INTENT_IN)\n+\t{\n+\t  /* Fix the descriptor and determine the size of the data.  */\n+\t  parmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n+\t  size = build_call_expr_loc (input_location,\n+\t\t\t\tgfor_fndecl_size0, 1,\n+\t\t\t\tgfc_build_addr_expr (NULL, parmse->expr));\n+\t  size = fold_convert (size_type_node, size);\n+\t  tmp = gfc_conv_descriptor_span_get (parmse->expr);\n+\t  tmp = fold_convert (size_type_node, tmp);\n+\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t  size_type_node, size, tmp);\n+\t  /* Fix the size and allocate.  */\n+\t  size = gfc_evaluate_now (size, &parmse->pre);\n+\t  tmp = builtin_decl_explicit (BUILT_IN_MALLOC);\n+\t  ptr = build_call_expr_loc (input_location, tmp, 1, size);\n+\t  ptr = gfc_evaluate_now (ptr, &parmse->pre);\n+\t  /* Copy the data to the temporary descriptor.  */\n+\t  tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+\t  tmp = build_call_expr_loc (input_location, tmp, 3, ptr,\n+\t\t\t\tgfc_conv_descriptor_data_get (parmse->expr),\n+\t\t\t\tsize);\n+\t  gfc_add_expr_to_block (&parmse->pre, tmp);\n+\t  gfc_conv_descriptor_data_set (&parmse->pre, parmse->expr, ptr);\n+\t}\n+\n     }\n   else\n     {\n@@ -4982,7 +5018,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \tparmse->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t    parmse->expr);\n \n-      /* Copy the scalar for INTENT_IN.  */\n+      /* Copy the scalar for INTENT(IN).  */\n       if (e->expr_type == EXPR_VARIABLE && fsym->attr.intent == INTENT_IN)\n \tparmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n       parmse->expr = gfc_conv_scalar_to_descriptor (parmse,\n@@ -5012,6 +5048,17 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   /* The CFI descriptor is passed to the bind_C procedure.  */\n   parmse->expr = cfi_desc_ptr;\n \n+  if (ptr)\n+    {\n+      /* Free both the temporary data and the CFI descriptor for\n+\t INTENT(IN) arrays.  */\n+      tmp = gfc_call_free (ptr);\n+      gfc_prepend_expr_to_block (&parmse->post, tmp);\n+      tmp = gfc_call_free (cfi_desc_ptr);\n+      gfc_prepend_expr_to_block (&parmse->post, tmp);\n+      return;\n+    }\n+\n   /* Transfer values back to gfc descriptor and free the CFI descriptor.  */\n   tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n   tmp = build_call_expr_loc (input_location,"}, {"sha": "158c47137e7db4f253fb6238f8e7ae3e200bc519", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -1,3 +1,9 @@\n+2019-01-24  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/88929\n+\t* gfortran.dg/ISO_Fortran_binding_3.f90 : New test\n+\t* gfortran.dg/ISO_Fortran_binding_3.c : Subsidiary source.\n+\n 2019-01-23  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR libgcc/88931\n@@ -218,7 +224,7 @@\n \n 2019-01-20  Kewen Lin  <linkw@gcc.gnu.org>\n \n-\t* gcc.target/powerpc/altivec_vld_vst_addr.c: Remove, split into \n+\t* gcc.target/powerpc/altivec_vld_vst_addr.c: Remove, split into\n \taltivec_vld_vst_addr-1.c and altivec_vld_vst_addr-2.c.\n \t* gcc.target/powerpc/altivec_vld_vst_addr-1.c: New test.\n \t* gcc.target/powerpc/altivec_vld_vst_addr-2.c: Ditto."}, {"sha": "a9f64cd5cf106b3746a06627a2f773516c929fc2", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.c?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -0,0 +1,32 @@\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* Part of the test for the fix of PR88929 - see ISO_Fortran_binding_3.f90. */\n+\n+int c_test (CFI_cdesc_t * a_desc)\n+{\n+  CFI_index_t idx[2];\n+  int *res_addr;\n+  int err = 1; /* this error code represents all errors */\n+\n+  if (a_desc->rank != 2)\n+    return err;\n+\n+  if (a_desc->type != CFI_type_int)\n+    return err;\n+\n+  err = 0;\n+  for (idx[0] = 0; idx[0] < a_desc->dim[0].extent; idx[0]++)\n+    for (idx[1] = 0; idx[1] < a_desc->dim[1].extent; idx[1]++)\n+      {\n+\tres_addr = CFI_address (a_desc, idx);\n+\terr += *res_addr;\n+\t*res_addr = *res_addr + 1;\n+      }\n+\n+  if (err != 10) return 1;\n+\n+  return 0;\n+}\n+"}, {"sha": "4870ca0edcb09ce03d7b1fed6008d8885b028705", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_3.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db06a76e9a00cf4ec715a685dd5ca722826f783f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_3.f90?ref=db06a76e9a00cf4ec715a685dd5ca722826f783f", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+! { dg-additional-sources ISO_Fortran_binding_3.c }\n+!\n+! Test the fix for PR88929.\n+!\n+  integer, dimension (:,:), allocatable :: actual\n+  integer, dimension(2,2) :: src = reshape ([1,2,3,4], [2,2])\n+\n+  allocate (actual, source = src)\n+  ier = test1 (actual)\n+  if (ier .ne. 0) stop 1\n+! C call is INTENT(IN). 'c_test' increments elements of 'src'.\n+  if (any (actual .ne. src)) stop 2\n+\n+  ier = test2 (actual)\n+  if (ier .ne. 0) stop 1\n+! C call is INTENT(INOUT) 'c_test' increments elements of 'src'.\n+  if (any (actual .ne. src + 1)) stop 2\n+\n+contains\n+\n+  function test1 (arg) RESULT(err)\n+    USE, INTRINSIC :: ISO_C_BINDING\n+    INTEGER(C_INT) :: err\n+    type(*), dimension(..), intent(inOUT) :: arg\n+    interface\n+      function test_c (a) BIND(C, NAME=\"c_test\") RESULT(err)\n+          USE, INTRINSIC :: ISO_C_BINDING\n+          type(*), dimension(..), intent(in) :: a\n+          INTEGER(C_INT) :: err\n+      end function\n+    end interface\n+\n+    err = test_c (arg) ! This used to ICE\n+\n+  end function test1\n+\n+  function test2 (arg) RESULT(err)\n+    USE, INTRINSIC :: ISO_C_BINDING\n+    INTEGER(C_INT) :: err\n+    type(*), dimension(..), intent(inout) :: arg\n+    interface\n+      function test_c (a) BIND(C, NAME=\"c_test\") RESULT(err)\n+          USE, INTRINSIC :: ISO_C_BINDING\n+          type(*), dimension(..), intent(inout) :: a\n+          INTEGER(C_INT) :: err\n+      end function\n+    end interface\n+\n+    err = test_c (arg) ! This used to ICE\n+\n+  end function test2\n+end\n\\ No newline at end of file"}]}