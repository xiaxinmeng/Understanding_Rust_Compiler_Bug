{"sha": "63bb59a32cd54454a3ece47024f81d2c7d313a27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNiYjU5YTMyY2Q1NDQ1NGEzZWNlNDcwMjRmODFkMmM3ZDMxM2EyNw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-12-06T20:22:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-12-06T20:22:01Z"}, "message": "re PR tree-optimization/18601 (tree cfglceanup is slow)\n\n\tPR tree-optimization/18601\n\t* tree-cfg.c (thread_jumps, thread_jumps_from_bb): Removed.\n\t(tree_forwarder_block_p): Do not consider blocks that are its own\n\tsuccessors forwarders.\n\t(cleanup_forwarder_blocks, remove_forwarder_block): New functions.\n\t(cleanup_tree_cfg): Use cleanup_forwarder_blocks instead of\n\tthread_jumps.\n\t* tree-flow.h (bb_ann_d): Remove forwardable.\n\nCo-Authored-By: Kazu Hirata <kazu@cs.umass.edu>\n\nFrom-SVN: r91787", "tree": {"sha": "dace042ac1038b54261308967be3feafe51a51ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dace042ac1038b54261308967be3feafe51a51ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63bb59a32cd54454a3ece47024f81d2c7d313a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63bb59a32cd54454a3ece47024f81d2c7d313a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63bb59a32cd54454a3ece47024f81d2c7d313a27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63bb59a32cd54454a3ece47024f81d2c7d313a27/comments", "author": null, "committer": null, "parents": [{"sha": "c4cfdac0e6d0009e99c04b3466dd0f30acb5b49f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4cfdac0e6d0009e99c04b3466dd0f30acb5b49f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4cfdac0e6d0009e99c04b3466dd0f30acb5b49f"}], "stats": {"total": 391, "additions": 151, "deletions": 240}, "files": [{"sha": "6ce5433f135fb83cd11b50b59aca131aef0a1628", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb59a32cd54454a3ece47024f81d2c7d313a27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb59a32cd54454a3ece47024f81d2c7d313a27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63bb59a32cd54454a3ece47024f81d2c7d313a27", "patch": "@@ -1,3 +1,15 @@\n+2004-12-06  Zdenek Dvorak  <dvorakz@suse.cz>\n+\t    Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR tree-optimization/18601\n+\t* tree-cfg.c (thread_jumps, thread_jumps_from_bb): Removed.\n+\t(tree_forwarder_block_p): Do not consider blocks that are its own\n+\tsuccessors forwarders.\n+\t(cleanup_forwarder_blocks, remove_forwarder_block): New functions.\n+\t(cleanup_tree_cfg): Use cleanup_forwarder_blocks instead of\n+\tthread_jumps.\n+\t* tree-flow.h (bb_ann_d): Remove forwardable.\n+\n 2004-12-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* expr.c (expand_expr_real_1): Remove an \"if\" whose condition"}, {"sha": "db12f98929d1119ad63a31596a552d7998033b5b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 139, "deletions": 236, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb59a32cd54454a3ece47024f81d2c7d313a27/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb59a32cd54454a3ece47024f81d2c7d313a27/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=63bb59a32cd54454a3ece47024f81d2c7d313a27", "patch": "@@ -119,7 +119,6 @@ static void split_critical_edges (void);\n static inline bool stmt_starts_bb_p (tree, tree);\n static int tree_verify_flow_info (void);\n static void tree_make_forwarder_block (edge);\n-static bool thread_jumps (void);\n static bool tree_forwarder_block_p (basic_block);\n static void tree_cfg2vcg (FILE *);\n \n@@ -133,6 +132,7 @@ static edge find_taken_edge_cond_expr (basic_block, tree);\n static edge find_taken_edge_switch_expr (basic_block, tree);\n static tree find_case_label_for_value (tree, tree);\n static bool phi_alternatives_equal (basic_block, edge, edge);\n+static bool cleanup_forwarder_blocks (void);\n \n \n /*---------------------------------------------------------------------------\n@@ -900,19 +900,20 @@ cleanup_tree_cfg (void)\n   retval = cleanup_control_flow ();\n   retval |= delete_unreachable_blocks ();\n \n-  /* thread_jumps can redirect edges out of SWITCH_EXPRs, which can get\n-     expensive.  So we want to enable recording of edge to CASE_LABEL_EXPR\n-     mappings around the call to thread_jumps.  */\n+  /* cleanup_forwarder_blocks can redirect edges out of SWITCH_EXPRs,\n+     which can get expensive.  So we want to enable recording of edge\n+     to CASE_LABEL_EXPR mappings around the call to\n+     cleanup_forwarder_blocks.  */\n   start_recording_case_labels ();\n-  retval |= thread_jumps ();\n+  retval |= cleanup_forwarder_blocks ();\n   end_recording_case_labels ();\n \n #ifdef ENABLE_CHECKING\n   if (retval)\n     {\n       gcc_assert (!cleanup_control_flow ());\n       gcc_assert (!delete_unreachable_blocks ());\n-      gcc_assert (!thread_jumps ());\n+      gcc_assert (!cleanup_forwarder_blocks ());\n     }\n #endif\n \n@@ -3891,6 +3892,8 @@ tree_forwarder_block_p (basic_block bb)\n       || phi_nodes (bb)\n       /* BB may not be a predecessor of EXIT_BLOCK_PTR.  */\n       || EDGE_SUCC (bb, 0)->dest == EXIT_BLOCK_PTR\n+      /* Nor should this be an infinite loop.  */\n+      || EDGE_SUCC (bb, 0)->dest == bb\n       /* BB may not have an abnormal outgoing edge.  */\n       || (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL))\n     return false; \n@@ -3923,282 +3926,182 @@ tree_forwarder_block_p (basic_block bb)\n   return true;\n }\n \n-/* Thread jumps from BB.  */\n+/* Return true if BB has at least one abnormal incoming edge.  */\n+\n+static inline bool\n+has_abnormal_incoming_edge_p (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_ABNORMAL)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Removes forwarder block BB.  Returns false if this failed.  If new\n+   forwarder block is created due to redirection of edges, it is\n+   stored to worklist.  */\n \n static bool\n-thread_jumps_from_bb (basic_block bb)\n+remove_forwarder_block (basic_block bb, basic_block **worklist)\n {\n+  edge succ = EDGE_SUCC (bb, 0), e, s;\n+  basic_block dest = succ->dest;\n+  tree label;\n+  tree phi;\n   edge_iterator ei;\n-  edge e;\n-  bool retval = false;\n+  block_stmt_iterator bsi, bsi_to;\n+  bool seen_abnormal_edge = false;\n \n-  /* Examine each of our block's successors to see if it is\n-     forwardable.  */\n-  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+  /* We check for infinite loops already in tree_forwarder_block_p.\n+     However it may happen that the infinite loop is created\n+     afterwards due to removal of forwarders.  */\n+  if (dest == bb)\n+    return false;\n+\n+  /* If the destination block consists of an nonlocal label, do not merge\n+     it.  */\n+  label = first_stmt (bb);\n+  if (label\n+      && TREE_CODE (label) == LABEL_EXPR\n+      && DECL_NONLOCAL (LABEL_EXPR_LABEL (label)))\n+    return false;\n+\n+  /* If there is an abnormal edge to basic block BB, but not into\n+     dest, problems might occur during removal of the phi node at out\n+     of ssa due to overlapping live ranges of registers.\n+\n+     If there is an abnormal edge in DEST, the problems would occur\n+     anyway since cleanup_dead_labels would then merge the labels for\n+     two different eh regions, and rest of exception handling code\n+     does not like it.\n+     \n+     So if there is an abnormal edge to BB, proceed only if there is\n+     no abnormal edge to DEST and there are no phi nodes in DEST.  */\n+  if (has_abnormal_incoming_edge_p (bb))\n     {\n-      int freq;\n-      gcov_type count;\n-      edge last, old;\n-      basic_block dest, tmp, curr, old_dest;\n-      tree phi;\n+      seen_abnormal_edge = true;\n \n-      /* If the edge is abnormal or its destination is not\n-\t forwardable, then there's nothing to do.  */\n-      if ((e->flags & EDGE_ABNORMAL)\n-\t  || !bb_ann (e->dest)->forwardable)\n-\t{\n-\t  ei_next (&ei);\n-\t  continue;\n-\t}\n+      if (has_abnormal_incoming_edge_p (dest)\n+\t  || phi_nodes (dest) != NULL_TREE)\n+\treturn false;\n+    }\n \n-      /* Now walk through as many forwarder blocks as possible to find\n-\t the ultimate destination we want to thread our jump to.  */\n-      last = EDGE_SUCC (e->dest, 0);\n-      bb_ann (e->dest)->forwardable = 0;\n-      for (dest = EDGE_SUCC (e->dest, 0)->dest;\n-\t   bb_ann (dest)->forwardable;\n-\t   last = EDGE_SUCC (dest, 0),\n-\t     dest = EDGE_SUCC (dest, 0)->dest)\n-\tbb_ann (dest)->forwardable = 0;\n-\n-      /* Reset the forwardable marks to 1.  */\n-      for (tmp = e->dest;\n-\t   tmp != dest;\n-\t   tmp = EDGE_SUCC (tmp, 0)->dest)\n-\tbb_ann (tmp)->forwardable = 1;\n-\n-      if (dest == e->dest)\n+  /* If there are phi nodes in DEST, and some of the blocks that are\n+     predecessors of BB are also predecessors of DEST, check that the\n+     phi node arguments match.  */\n+  if (phi_nodes (dest))\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n-\t  ei_next (&ei);\n-\t  continue;\n+\t  s = find_edge (e->src, dest);\n+\t  if (!s)\n+\t    continue;\n+\n+\t  if (!phi_alternatives_equal (dest, succ, s))\n+\t    return false;\n \t}\n+    }\n \n-      old = find_edge (bb, dest);\n-      if (old)\n+  /* Redirect the edges.  */\n+  for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n+    {\n+      if (e->flags & EDGE_ABNORMAL)\n \t{\n-\t  /* If there already is an edge, check whether the values in\n-\t     phi nodes differ.  */\n-\t  if (!phi_alternatives_equal (dest, last, old))\n-\t    {\n-\t      /* The previous block is forwarder.  Redirect our jump\n-\t\t to that target instead since we know it has no PHI\n-\t\t nodes that will need updating.  */\n-\t      dest = last->src;\n-\n-\t      /* That might mean that no forwarding at all is\n-\t\t possible.  */\n-\t      if (dest == e->dest)\n-\t\t{\n-\t\t  ei_next (&ei);\n-\t\t  continue;\n-\t\t}\n-\n-\t      old = find_edge (bb, dest);\n-\t    }\n+\t  /* If there is an abnormal edge, redirect it anyway, and\n+\t     move the labels to the new block to make it legal.  */\n+\t  s = redirect_edge_succ_nodup (e, dest);\n \t}\n+      else\n+\ts = redirect_edge_and_branch (e, dest);\n \n-      /* Perform the redirection.  */\n-      retval = true;\n-      count = e->count;\n-      freq = EDGE_FREQUENCY (e);\n-      old_dest = e->dest;\n-      e = redirect_edge_and_branch (e, dest);\n-\n-      /* Update the profile.  */\n-      if (profile_status != PROFILE_ABSENT)\n-\tfor (curr = old_dest;\n-\t     curr != dest;\n-\t     curr = EDGE_SUCC (curr, 0)->dest)\n-\t  {\n-\t    curr->frequency -= freq;\n-\t    if (curr->frequency < 0)\n-\t      curr->frequency = 0;\n-\t    curr->count -= count;\n-\t    if (curr->count < 0)\n-\t      curr->count = 0;\n-\t    EDGE_SUCC (curr, 0)->count -= count;\n-\t    if (EDGE_SUCC (curr, 0)->count < 0)\n-\t      EDGE_SUCC (curr, 0)->count = 0;\n-\t  }\n-\n-      if (!old)\n+      if (s == e)\n \t{\n-\t  /* Update PHI nodes.  We know that the new argument should\n-\t     have the same value as the argument associated with LAST.\n-\t     Otherwise we would have changed our target block\n-\t     above.  */\n-\t  int arg = last->dest_idx;\n-\n+\t  /* Create arguments for the phi nodes, since the edge was not\n+\t     here before.  */\n \t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n-\t    {\n-\t      tree def = PHI_ARG_DEF (phi, arg);\n-\t      gcc_assert (def != NULL_TREE);\n-\t      add_phi_arg (phi, def, e);\n-\t    }\n+\t    add_phi_arg (phi, PHI_ARG_DEF (phi, succ->dest_idx), s);\n \t}\n-\n-      /* Remove the unreachable blocks (observe that if all blocks\n-\t were reachable before, only those in the path we threaded\n-\t over and did not have any predecessor outside of the path\n-\t become unreachable).  */\n-      for (; old_dest != dest; old_dest = tmp)\n+      else\n \t{\n-\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n-\n-\t  if (EDGE_COUNT (old_dest->preds) > 0)\n-\t    break;\n-\n-\t  delete_basic_block (old_dest);\n+\t  /* The source basic block might become a forwarder.  We know\n+\t     that it was not a forwarder before, since it used to have\n+\t     at least two outgoing edges, so we may just add it to\n+\t     worklist.  */\n+\t  if (tree_forwarder_block_p (s->src))\n+\t    *(*worklist)++ = s->src;\n \t}\n+    }\n \n-      /* Update the dominators.  */\n-      if (dom_info_available_p (CDI_DOMINATORS))\n-\t{\n-\t  /* If the dominator of the destination was in the\n-\t     path, set its dominator to the start of the\n-\t     redirected edge.  */\n-\t  if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)\n-\t    set_immediate_dominator (CDI_DOMINATORS, old_dest, bb);\n-\n-\t  /* Now proceed like if we forwarded just over one edge at a\n-\t     time.  Algorithm for forwarding edge S --> A over\n-\t     edge A --> B then is\n-\n-\t     if (idom (B) == A\n-\t         && !dominated_by (S, B))\n-\t       idom (B) = idom (A);\n-\t     recount_idom (A);  */\n-\n-\t  for (; old_dest != dest; old_dest = tmp)\n-\t    {\n-\t      basic_block dom;\n-\n-\t      tmp = EDGE_SUCC (old_dest, 0)->dest;\n-\n-\t      if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest\n-\t\t  && !dominated_by_p (CDI_DOMINATORS, bb, tmp))\n-\t\t{\n-\t\t  dom = get_immediate_dominator (CDI_DOMINATORS, old_dest);\n-\t\t  set_immediate_dominator (CDI_DOMINATORS, tmp, dom);\n-\t\t}\n+  if (seen_abnormal_edge)\n+    {\n+      /* Move the labels to the new block, so that the redirection of\n+\t the abnormal edges works.  */\n \n-\t      dom = recount_dominator (CDI_DOMINATORS, old_dest);\n-\t      set_immediate_dominator (CDI_DOMINATORS, old_dest, dom);\n-\t    }\n+      bsi_to = bsi_start (dest);\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n+\t{\n+\t  label = bsi_stmt (bsi);\n+\t  gcc_assert (TREE_CODE (label) == LABEL_EXPR);\n+\t  bsi_remove (&bsi);\n+\t  bsi_insert_before (&bsi_to, label, BSI_CONTINUE_LINKING);\n \t}\n     }\n \n-  return retval;\n-}\n+  /* Update the dominators.  */\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    {\n+      basic_block dom, dombb, domdest;\n+\n+      dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      domdest = get_immediate_dominator (CDI_DOMINATORS, dest);\n+      if (domdest == bb)\n+\t{\n+\t  /* Shortcut to avoid calling (relatively expensive)\n+\t     nearest_common_dominator unless necessary.  */\n+\t  dom = dombb;\n+\t}\n+      else\n+\tdom = nearest_common_dominator (CDI_DOMINATORS, domdest, dombb);\n \n+      set_immediate_dominator (CDI_DOMINATORS, dest, dom);\n+    }\n \n-/* Thread jumps over empty statements.\n+  /* And kill the forwarder block.  */\n+  delete_basic_block (bb);\n \n-   This code should _not_ thread over obviously equivalent conditions\n-   as that requires nontrivial updates to the SSA graph.\n+  return true;\n+}\n \n-   As a precondition, we require that all basic blocks be reachable.\n-   That is, there should be no opportunities left for\n-   delete_unreachable_blocks.  */\n+/* Removes forwarder blocks.  */\n \n static bool\n-thread_jumps (void)\n+cleanup_forwarder_blocks (void)\n {\n   basic_block bb;\n-  bool retval = false;\n+  bool changed = false;\n   basic_block *worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n   basic_block *current = worklist;\n \n   FOR_EACH_BB (bb)\n     {\n-      bb_ann (bb)->forwardable = tree_forwarder_block_p (bb);\n-      bb->flags &= ~BB_VISITED;\n+      if (tree_forwarder_block_p (bb))\n+\t*current++ = bb;\n     }\n \n-  /* We pretend to have ENTRY_BLOCK_PTR in WORKLIST.  This way,\n-     ENTRY_BLOCK_PTR will never be entered into WORKLIST.  */\n-  ENTRY_BLOCK_PTR->flags |= BB_VISITED;\n-\n-  /* Initialize WORKLIST by putting non-forwarder blocks that\n-     immediately precede forwarder blocks because those are the ones\n-     that we know we can thread jumps from.  We use BB_VISITED to\n-     indicate whether a given basic block is in WORKLIST or not,\n-     thereby avoiding duplicates in WORKLIST.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      edge_iterator ei;\n-      edge e;\n-\n-      /* We are not interested in finding non-forwarder blocks\n-\t directly.  We want to find non-forwarder blocks as\n-\t predecessors of a forwarder block.  */\n-      if (!bb_ann (bb)->forwardable)\n-\tcontinue;\n-\n-      /* Now we know BB is a forwarder block.  Visit each of its\n-\t incoming edges and add to WORKLIST all non-forwarder blocks\n-\t among BB's predecessors.  */\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  /* We don't want to put a duplicate into WORKLIST.  */\n-\t  if ((e->src->flags & BB_VISITED) == 0\n-\t      /* We are not interested in threading jumps from a forwarder\n-\t\t block.  */\n-\t      && !bb_ann (e->src)->forwardable)\n-\t    {\n-\t      e->src->flags |= BB_VISITED;\n-\t      *current++ = e->src;\n-\t    }\n-\t}\n-    }\n-\n-  /* Now let's drain WORKLIST.  */\n-  while (worklist != current)\n+  while (current != worklist)\n     {\n       bb = *--current;\n-\n-      /* BB is no longer in WORKLIST, so clear BB_VISITED.  */\n-      bb->flags &= ~BB_VISITED;\n-\n-      if (thread_jumps_from_bb (bb))\n-\t{\n-\t  retval = true;\n-\n-\t  if (tree_forwarder_block_p (bb))\n-\t    {\n-\t      edge_iterator ej;\n-\t      edge f;\n-\n-\t      bb_ann (bb)->forwardable = true;\n-\n-\t      /* Attempts to thread through BB may have been blocked\n-\t\t because BB was not a forwarder block before.  Now\n-\t\t that BB is a forwarder block, we should revisit BB's\n-\t\t predecessors.  */\n-\t      FOR_EACH_EDGE (f, ej, bb->preds)\n-\t\t{\n-\t\t  /* We don't want to put a duplicate into WORKLIST.  */\n-\t\t  if ((f->src->flags & BB_VISITED) == 0\n-\t\t      /* We are not interested in threading jumps from a\n-\t\t\t forwarder block.  */\n-\t\t      && !bb_ann (f->src)->forwardable)\n-\t\t    {\n-\t\t      f->src->flags |= BB_VISITED;\n-\t\t      *current++ = f->src;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+      changed |= remove_forwarder_block (bb, &current);\n     }\n \n-  ENTRY_BLOCK_PTR->flags &= ~BB_VISITED;\n-\n   free (worklist);\n-\n-  return retval;\n+  return changed;\n }\n \n-\n /* Return a non-special label in the head of basic block BLOCK.\n    Create one if it doesn't exist.  */\n "}, {"sha": "9952f8a1ae0b479835c80c43ff34352153b48f6b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63bb59a32cd54454a3ece47024f81d2c7d313a27/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63bb59a32cd54454a3ece47024f81d2c7d313a27/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=63bb59a32cd54454a3ece47024f81d2c7d313a27", "patch": "@@ -345,10 +345,6 @@ struct bb_ann_d GTY(())\n   /* Chain of PHI nodes for this block.  */\n   tree phi_nodes;\n \n-  /* Nonzero if this block is forwardable during cfg cleanups.  This is also\n-     used to detect loops during cfg cleanups.  */\n-  unsigned forwardable: 1;\n-\n   /* Nonzero if this block contains an escape point (see is_escape_site).  */\n   unsigned has_escape_site : 1;\n "}]}