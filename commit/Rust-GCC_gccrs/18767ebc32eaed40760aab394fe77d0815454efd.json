{"sha": "18767ebc32eaed40760aab394fe77d0815454efd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3NjdlYmMzMmVhZWQ0MDc2MGFhYjM5NGZlNzdkMDgxNTQ1NGVmZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-07-29T15:44:00Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-07-29T15:44:00Z"}, "message": "cfgloop.h (struct loop): New field constraints.\n\n\t* cfgloop.h (struct loop): New field constraints.\n\t(LOOP_C_INFINITE, LOOP_C_FINITE): New macros.\n\t(loop_constraint_set, loop_constraint_clr, loop_constraint_set_p): New\n\tfunctions.\n\t* cfgloop.c (alloc_loop): Initialize new field.\n\t* cfgloopmanip.c (copy_loop_info): Copy constraints.\n\t* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions):\n\tAdjust niter analysis wrto loop constraints.\n\t* doc/loop.texi (@node Number of iterations): Add description for loop\n\tconstraints.\n\nFrom-SVN: r238876", "tree": {"sha": "a1a32cebdc504645bd7b6aa9f95e65a49b16c9a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1a32cebdc504645bd7b6aa9f95e65a49b16c9a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18767ebc32eaed40760aab394fe77d0815454efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18767ebc32eaed40760aab394fe77d0815454efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18767ebc32eaed40760aab394fe77d0815454efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18767ebc32eaed40760aab394fe77d0815454efd/comments", "author": null, "committer": null, "parents": [{"sha": "f6c7a248d5eb50e3cfcf15e552c2be698ebea34b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6c7a248d5eb50e3cfcf15e552c2be698ebea34b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6c7a248d5eb50e3cfcf15e552c2be698ebea34b"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "62a75c9c2d9b046de6cca800cfb76f9efb9049d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18767ebc32eaed40760aab394fe77d0815454efd", "patch": "@@ -1,3 +1,16 @@\n+2016-07-29  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* cfgloop.h (struct loop): New field constraints.\n+\t(LOOP_C_INFINITE, LOOP_C_FINITE): New macros.\n+\t(loop_constraint_set, loop_constraint_clr, loop_constraint_set_p): New\n+\tfunctions.\n+\t* cfgloop.c (alloc_loop): Initialize new field.\n+\t* cfgloopmanip.c (copy_loop_info): Copy constraints.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions):\n+\tAdjust niter analysis wrto loop constraints.\n+\t* doc/loop.texi (@node Number of iterations): Add description for loop\n+\tconstraints.\n+\n 2016-07-29  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/7652"}, {"sha": "205562fe3fa6ecac61280fd5bbef08dc643b45ab", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=18767ebc32eaed40760aab394fe77d0815454efd", "patch": "@@ -339,6 +339,7 @@ alloc_loop (void)\n   loop->exits = ggc_cleared_alloc<loop_exit> ();\n   loop->exits->next = loop->exits->prev = loop->exits;\n   loop->can_be_parallel = false;\n+  loop->constraints = 0;\n   loop->nb_iterations_upper_bound = 0;\n   loop->nb_iterations_likely_upper_bound = 0;\n   loop->nb_iterations_estimate = 0;"}, {"sha": "5c202eb1256dda58ee6ae95bf8d2300b848108d7", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=18767ebc32eaed40760aab394fe77d0815454efd", "patch": "@@ -188,6 +188,29 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      of the loop can be safely evaluated concurrently.  */\n   int safelen;\n \n+  /* Constraints are generally set by consumers and affect certain\n+     semantics of niter analyzer APIs.  Currently the APIs affected are\n+     number_of_iterations_exit* functions and their callers.  One typical\n+     use case of constraints is to vectorize possibly infinite loop:\n+\n+       1) Compute niter->assumptions by calling niter analyzer API and\n+\t  record it as possible condition for loop versioning.\n+       2) Clear buffered result of niter/scev analyzer.\n+       3) Set constraint LOOP_C_FINITE assuming the loop is finite.\n+       4) Analyze data references.  Since data reference analysis depends\n+\t  on niter/scev analyzer, the point is that niter/scev analysis\n+\t  is done under circumstance of LOOP_C_FINITE constraint.\n+       5) Version the loop with niter->assumptions computed in step 1).\n+       6) Vectorize the versioned loop in which niter->assumptions is\n+\t  checked to be true.\n+       7) Update constraints in versioned loops so that niter analyzer\n+\t  in following passes can use it.\n+\n+     Note consumers are usually the loop optimizers and it is consumers'\n+     responsibility to set/clear constraints correctly.  Failing to do\n+     that might result in hard to track down bugs in niter/scev consumers.  */\n+  unsigned constraints;\n+\n   /* True if this loop should never be vectorized.  */\n   bool dont_vectorize;\n \n@@ -221,6 +244,32 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   basic_block former_header;\n };\n \n+/* Set if the loop is known to be infinite.  */\n+#define LOOP_C_INFINITE\t\t(1 << 0)\n+/* Set if the loop is known to be finite without any assumptions.  */\n+#define LOOP_C_FINITE\t\t(1 << 1)\n+\n+/* Set C to the LOOP constraint.  */\n+static inline void\n+loop_constraint_set (struct loop *loop, unsigned c)\n+{\n+  loop->constraints |= c;\n+}\n+\n+/* Clear C from the LOOP constraint.  */\n+static inline void\n+loop_constraint_clear (struct loop *loop, unsigned c)\n+{\n+  loop->constraints &= ~c;\n+}\n+\n+/* Check if C is set in the LOOP constraint.  */\n+static inline bool\n+loop_constraint_set_p (struct loop *loop, unsigned c)\n+{\n+  return (loop->constraints & c) == c;\n+}\n+\n /* Flags for state of loop structure.  */\n enum\n {"}, {"sha": "20476d70459dc3e68ce4fa27c92f917139dcbcab", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=18767ebc32eaed40760aab394fe77d0815454efd", "patch": "@@ -1015,6 +1015,7 @@ copy_loop_info (struct loop *loop, struct loop *target)\n   target->any_estimate = loop->any_estimate;\n   target->nb_iterations_estimate = loop->nb_iterations_estimate;\n   target->estimate_state = loop->estimate_state;\n+  target->constraints = loop->constraints;\n   target->warned_aggressive_loop_optimizations\n     |= loop->warned_aggressive_loop_optimizations;\n   target->in_oacc_kernels_region = loop->in_oacc_kernels_region;"}, {"sha": "44b528d538e1cd2417d52847cee76152ff130faa", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=18767ebc32eaed40760aab394fe77d0815454efd", "patch": "@@ -476,6 +476,32 @@ The function @code{number_of_cond_exit_executions} can be used to\n determine number of executions of the exit condition of a single-exit\n loop (i.e., the @code{number_of_latch_executions} increased by one).\n \n+On GIMPLE, below constraint flags affect semantics of some APIs of number\n+of iterations analyzer:\n+\n+@itemize\n+@item @code{LOOP_C_INFINITE}: If this constraint flag is set, the loop\n+is known to be infinite.  APIs like @code{number_of_iterations_exit} can\n+return false directly without doing any analysis.\n+@item @code{LOOP_C_FINITE}: If this constraint flag is set, the loop is\n+known to be finite, in other words, loop's number of iterations can be\n+computed with @code{assumptions} be true.\n+@end itemize\n+\n+Generally, the constraint flags are set/cleared by consumers which are\n+loop optimizers.  It's also the consumers' responsibility to set/clear\n+constraints correctly.  Failing to do that might result in hard to track\n+down bugs in scev/niter consumers.  One typical use case is vectorizer:\n+it drives number of iterations analyzer by setting @code{LOOP_C_FINITE}\n+and vectorizes possibly infinite loop by versioning loop with analysis\n+result.  In return, constraints set by consumers can also help number of\n+iterations analyzer in following optimizers.  For example, @code{niter}\n+of a loop versioned under @code{assumptions} is valid unconditionally.\n+\n+Other constraints may be added in the future, for example, a constraint\n+indicating that loops' latch must roll thus @code{may_be_zero} would be\n+false unconditionally.\n+\n @node Dependency analysis\n @section Data Dependency Analysis\n @cindex Data Dependency Analysis"}, {"sha": "191a07185158a8b28d1074392d3103ed98bc9edc", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18767ebc32eaed40760aab394fe77d0815454efd/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=18767ebc32eaed40760aab394fe77d0815454efd", "patch": "@@ -2151,6 +2151,10 @@ number_of_iterations_exit_assumptions (struct loop *loop, edge exit,\n   affine_iv iv0, iv1;\n   bool safe;\n \n+  /* Nothing to analyze if the loop is known to be infinite.  */\n+  if (loop_constraint_set_p (loop, LOOP_C_INFINITE))\n+    return false;\n+\n   safe = dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src);\n \n   if (every_iteration && !safe)\n@@ -2236,6 +2240,11 @@ number_of_iterations_exit_assumptions (struct loop *loop, edge exit,\n \tniter->max = wi::to_widest (iv_niters);\n     }\n \n+  /* There is no assumptions if the loop is known to be finite.  */\n+  if (!integer_zerop (niter->assumptions)\n+      && loop_constraint_set_p (loop, LOOP_C_FINITE))\n+    niter->assumptions = boolean_true_node;\n+\n   if (optimize >= 3)\n     {\n       niter->assumptions = simplify_using_outer_evolutions (loop,"}]}