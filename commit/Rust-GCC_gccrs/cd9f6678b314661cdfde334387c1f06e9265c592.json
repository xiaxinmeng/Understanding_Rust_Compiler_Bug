{"sha": "cd9f6678b314661cdfde334387c1f06e9265c592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q5ZjY2NzhiMzE0NjYxY2RmZGUzMzQzODdjMWYwNmU5MjY1YzU5Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-14T20:29:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-14T20:29:06Z"}, "message": "cp-tree.h (DECL_LOCAL_FUCNTION_P): New macro.\n\n\t* cp-tree.h (DECL_LOCAL_FUCNTION_P): New macro.\n\t* call.c (equal_functions): Use DECL_LOCAL_FUCNTION_P, not\n\tTREE_PERMANENT.\n\t* decl.c (pushdecl): Set DECL_LOCAL_FUNCTION_P.\n\t* decl2.c (lookup_arg_dependent): Use it.\n\n\t* cp-tree.h (cp_finish_decl): Change prototype.\n\t(finish_static_data_member_decl): Likewise.\n\t(push_permanent_obstack): Remove declaration.\n\t(push_expression_obstack): Likewise.\n\t(push_scratch_obstack): Likewise.\n\t(DECL_TEMPLATE_PARM_P): Robustify.\n\t(SET_DECL_TEMPLATE_PARM_P): New macro.\n\t* class.c (add_method): Don't manipulate obstacks.\n\t(finish_vtbls): Likewise.\n\t* cvt.c (build_up_reference): Adjust calls to cp_finish_decl.\n\t* decl.c (binding_for_name): Don't manipulate obstacks.\n\t(maybe_push_to_top_level): Likewise.\n\t(pop_from_top_level): Likewise.\n\t(duplicate_decls): Likewise.\n\t(pushdecl): Likewise.\n\t(implicitly_declare): Likewise.\n\t(build_typename_type): Likewise.\n\t(start_decl): Likewise.\n\t(cp_finish_decl): Likewise.\n\t(finish_decl): Likewise.\n\t(destroy_local_static): Likewise.\n\t(expand_static_init): Likewise.\n\t(complete_array_type): Likewise.\n\t(grokvardecl): Likewise.\n\t(build_ptrmemfnc_type): Likewise.\n\t(grokdeclarator): Likewise.\n\t(xref_tag): Likewise.\n\t(xref_basetypes): Likewise.\n\t(start_enum): Likewise.\n\t(finish_enum): Likewise.\n\t(start_function): Likewise.\n\t(finish_function): Likewise.\n\t(start_method): Adjust call to cp_finish_decl.\n\t* decl2.c (finish_static_data_member_decl): Don't manipulate\n\tobstacks.\n\t(grokfield): Likewise.\n\t(grokbitfield): Likewise.\n\t(get_temp_name): Likewise.\n\t(get_sentry): Likewise.\n\t(fnish_file): Likewise.\n\t(lookup_arg_dependent): Likewise.\n\t* except.c (call_eh_info): Likewise.\n\t(push_eh_info): Likewise.\n\t(do_pop_exception): Likewise.\n\t(initialize_handler_parm): Likewise.\n\t(expand_end_eh_spec): Likewise.\n\t(alloc_eh_object): Likewise.\n\t(expand_throw): Likewise.\n\t* expr.c (extract_scalar_init): Likewise.\n\t* init.c (build_java_class_ref): Likewise.\n\t* lex.c (get_time_identifier): Likewise.\n\t(snarf_defarg): Likewise.\n\t(add_defarg_fn): Likewise.\n\t(is_global): Simplify.\n\t(do_identifier): Don't check TREE_PERMANENT.\n\t* method.c (emit_thunk): Don't manipulate obstacks.\n\t* parse.y (condition): Adjust call to cp_finish_decl.\n\t(primary): Likewise.\n\t(initdcl): Likewise.\n\t(initdcl0_innards): Likewise.\n\t(nomods_initdcl0): Likewise.\n\t* pt.c (push_inline_template_parms_recursive): Use\n\tSET_DECL_TEMPLATE_PARM_P.\n\t(process_template_parm): Likewise.\n\t(lookup_template_class): Don't manipulate obstacks.\n\t(instantiate_class_template): Adjust call to\n\tfinish_static_data_member_decl.\n\t(tsubst_decl): Don't manipulate obstacks.\n\t(tsubst_expr): Likewise.\n\t(instantiate_template): Likewise.\n\t(instantiate_decl): Adjust calls to cp_finish_decl.\n\t* rtti.c (call_void_fn): Don't manipulate obstacks.\n\t(get_tinfo_var): Likewise.\n\t(get_tinfo_fn_unused): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t(expand_si_desc): Likewise.\n\t(expand_class_desc): Likewise.\n\t(expand_ptr_desc): Likewise.\n\t(expand_attr_desc): Likewise.\n\t(expand_generic_desc): Likewise.\n\t(synthesize_tinfo_fn): Likewise.\n\t* search.c (expand_upcast_fixups): Likewise.\n\t* semantics.c (finish_asm_stmt): Likewise.\n\t(finish_named_return_value): Likewise.\n\t(begin_class_definition): Likewise.\n\t(finish_class_definition): Likewise.\n\t(finish_typeof): Likewise.\n\t* tree.c (build_cplus_method_type): Likewise.\n\t(reverse_path): Likewise.\n\t(copy_template_template_parm): Likewise.\n\t(build_expr_ptr_wrapper): Likewise.\n\t(push_expression_obstack): Remove.\n\t(push_permanent_obstack): Likewise.\n\t* typeck.c (mark_addressable): Likewise.\n\nFrom-SVN: r30527", "tree": {"sha": "a3705bb81504816d3cc96124d755d7380e587405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3705bb81504816d3cc96124d755d7380e587405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd9f6678b314661cdfde334387c1f06e9265c592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9f6678b314661cdfde334387c1f06e9265c592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9f6678b314661cdfde334387c1f06e9265c592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9f6678b314661cdfde334387c1f06e9265c592/comments", "author": null, "committer": null, "parents": [{"sha": "ef835bb0c34abed46e891257dc9bb12abc8b926d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef835bb0c34abed46e891257dc9bb12abc8b926d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef835bb0c34abed46e891257dc9bb12abc8b926d"}], "stats": {"total": 1606, "additions": 718, "deletions": 888}, "files": [{"sha": "b7402235be9a8dba45dd10485794541fc235f3cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -1,3 +1,106 @@\n+1999-11-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (DECL_LOCAL_FUCNTION_P): New macro.\n+\t* call.c (equal_functions): Use DECL_LOCAL_FUCNTION_P, not\n+\tTREE_PERMANENT.\n+\t* decl.c (pushdecl): Set DECL_LOCAL_FUNCTION_P.\n+\t* decl2.c (lookup_arg_dependent): Use it.\n+\t\n+\t* cp-tree.h (cp_finish_decl): Change prototype.\n+\t(finish_static_data_member_decl): Likewise.\n+\t(push_permanent_obstack): Remove declaration.\n+\t(push_expression_obstack): Likewise.\n+\t(push_scratch_obstack): Likewise.\n+\t(DECL_TEMPLATE_PARM_P): Robustify.\n+\t(SET_DECL_TEMPLATE_PARM_P): New macro.\n+\t* class.c (add_method): Don't manipulate obstacks.\n+\t(finish_vtbls): Likewise.\n+\t* cvt.c (build_up_reference): Adjust calls to cp_finish_decl.\n+\t* decl.c (binding_for_name): Don't manipulate obstacks.\n+\t(maybe_push_to_top_level): Likewise.\n+\t(pop_from_top_level): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(pushdecl): Likewise.\n+\t(implicitly_declare): Likewise.\n+\t(build_typename_type): Likewise.\n+\t(start_decl): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(finish_decl): Likewise.\n+\t(destroy_local_static): Likewise.\n+\t(expand_static_init): Likewise.\n+\t(complete_array_type): Likewise.\n+\t(grokvardecl): Likewise.\n+\t(build_ptrmemfnc_type): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(xref_tag): Likewise.\n+\t(xref_basetypes): Likewise.\n+\t(start_enum): Likewise.\n+\t(finish_enum): Likewise.\n+\t(start_function): Likewise.\n+\t(finish_function): Likewise.\n+\t(start_method): Adjust call to cp_finish_decl.\n+\t* decl2.c (finish_static_data_member_decl): Don't manipulate\n+\tobstacks.\n+\t(grokfield): Likewise.\n+\t(grokbitfield): Likewise.\n+\t(get_temp_name): Likewise.\n+\t(get_sentry): Likewise.\n+\t(fnish_file): Likewise.\n+\t(lookup_arg_dependent): Likewise.\n+\t* except.c (call_eh_info): Likewise.\n+\t(push_eh_info): Likewise.\n+\t(do_pop_exception): Likewise.\n+\t(initialize_handler_parm): Likewise.\n+\t(expand_end_eh_spec): Likewise.\n+\t(alloc_eh_object): Likewise.\n+\t(expand_throw): Likewise.\n+\t* expr.c (extract_scalar_init): Likewise.\n+\t* init.c (build_java_class_ref): Likewise.\n+\t* lex.c (get_time_identifier): Likewise.\n+\t(snarf_defarg): Likewise.\n+\t(add_defarg_fn): Likewise.\n+\t(is_global): Simplify.\n+\t(do_identifier): Don't check TREE_PERMANENT.\n+\t* method.c (emit_thunk): Don't manipulate obstacks.\n+\t* parse.y (condition): Adjust call to cp_finish_decl.\n+\t(primary): Likewise.\n+\t(initdcl): Likewise.\n+\t(initdcl0_innards): Likewise.\n+\t(nomods_initdcl0): Likewise.\n+\t* pt.c (push_inline_template_parms_recursive): Use\n+\tSET_DECL_TEMPLATE_PARM_P.\n+\t(process_template_parm): Likewise.\n+\t(lookup_template_class): Don't manipulate obstacks.\n+\t(instantiate_class_template): Adjust call to\n+\tfinish_static_data_member_decl.\n+\t(tsubst_decl): Don't manipulate obstacks.\n+\t(tsubst_expr): Likewise.\n+\t(instantiate_template): Likewise.\n+\t(instantiate_decl): Adjust calls to cp_finish_decl.\n+\t* rtti.c (call_void_fn): Don't manipulate obstacks.\n+\t(get_tinfo_var): Likewise.\n+\t(get_tinfo_fn_unused): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t(expand_si_desc): Likewise.\n+\t(expand_class_desc): Likewise.\n+\t(expand_ptr_desc): Likewise.\n+\t(expand_attr_desc): Likewise.\n+\t(expand_generic_desc): Likewise.\n+\t(synthesize_tinfo_fn): Likewise.\n+\t* search.c (expand_upcast_fixups): Likewise.\n+\t* semantics.c (finish_asm_stmt): Likewise.\n+\t(finish_named_return_value): Likewise.\n+\t(begin_class_definition): Likewise.\n+\t(finish_class_definition): Likewise.\n+\t(finish_typeof): Likewise.\n+\t* tree.c (build_cplus_method_type): Likewise.\n+\t(reverse_path): Likewise.\n+\t(copy_template_template_parm): Likewise.\n+\t(build_expr_ptr_wrapper): Likewise.\n+\t(push_expression_obstack): Remove.\n+\t(push_permanent_obstack): Likewise.\n+\t* typeck.c (mark_addressable): Likewise.\n+\t\n 1999-11-13  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (build_conditional_expr): Use build_target_expr_with_type."}, {"sha": "e597e53b10d57bb638e316e3049ff116b0b8f683", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -4832,15 +4832,14 @@ add_warning (winner, loser)\n }\n \n /* Returns true iff functions are equivalent. Equivalent functions are\n-   not identical only if one is a function-local extern function.\n-   This assumes that function-locals don't have TREE_PERMANENT.  */\n+   not identical only if one is a function-local extern function.  */\n \n static inline int\n equal_functions (fn1, fn2)\n      tree fn1;\n      tree fn2;\n {\n-  if (!TREE_PERMANENT (fn1) || !TREE_PERMANENT (fn2))\n+  if (DECL_LOCAL_FUNCTION_P (fn1) || DECL_LOCAL_FUNCTION_P (fn2))\n     return decls_match (fn1, fn2);\n   return fn1 == fn2;\n }"}, {"sha": "a3b37f786dfb25a66c834ef5b3009e5f73ebc1a5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -1067,8 +1067,6 @@ void\n add_method (type, fields, method)\n      tree type, *fields, method;\n {\n-  push_permanent_obstack ();\n-\n   /* Setting the DECL_CONTEXT and DECL_CLASS_CONTEXT here is probably\n      redundant.  */\n   DECL_CONTEXT (method) = type;\n@@ -1239,7 +1237,6 @@ add_method (type, fields, method)\n \tpush_class_level_binding (DECL_NAME (method),\n \t\t\t\t  TREE_VEC_ELT (method_vec, slot));\n     }\n-  pop_obstacks ();\n }\n \n /* Subroutines of finish_struct.  */\n@@ -2233,7 +2230,7 @@ finish_vtbls (binfo, do_self, t)\n \t  context = DECL_CONTEXT (decl);\n \t  DECL_CONTEXT (decl) = 0;\n \t  DECL_INITIAL (decl) = build_vtbl_initializer (binfo);\n-\t  cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n+\t  cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n \t  DECL_CONTEXT (decl) = context;\n \t}\n       CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);"}, {"sha": "c73e86972b09274a95747b400bbe6508417c8b90", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -85,6 +85,7 @@ Boston, MA 02111-1307, USA.  */\n    Usage of DECL_LANG_FLAG_?:\n    0: DECL_ERROR_REPORTED (in VAR_DECL).\n       DECL_TEMPLATE_PARM_P (in CONST_DECL, TYPE_DECL, or TEMPLATE_DECL)\n+      DECL_LOCAL_FUNCTION_P (in FUNCTION_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n@@ -2095,6 +2096,11 @@ extern int flag_new_for_scope;\n    if we already emitted a warning about using it.  */\n #define DECL_ERROR_REPORTED(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n \n+/* Nonzero if NODE is a FUNCTION_DECL (for a function with global\n+   scope) declared in a local scope.  */\n+#define DECL_LOCAL_FUNCTION_P(NODE) \\\n+  DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n+\n /* This _DECL represents a compiler-generated entity.  */\n #define SET_DECL_ARTIFICIAL(NODE) (DECL_ARTIFICIAL (NODE) = 1)\n \n@@ -2478,9 +2484,17 @@ extern int flag_new_for_scope;\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n \n /* Nonzero for a DECL which is actually a template parameter.  */\n-#define DECL_TEMPLATE_PARM_P(NODE) \\\n-  DECL_LANG_FLAG_0 (NODE)\n+#define DECL_TEMPLATE_PARM_P(NODE) \t\t\\\n+  (DECL_LANG_FLAG_0 (NODE)\t\t\t\\\n+   && (TREE_CODE (NODE) == CONST_DECL\t\t\\\n+       || TREE_CODE (NODE) == TYPE_DECL\t\t\\\n+       || TREE_CODE (NODE) == TEMPLATE_DECL))\n+\n+/* Mark NODE as a template parameter.  */\n+#define SET_DECL_TEMPLATE_PARM_P(NODE) \\\n+  (DECL_LANG_FLAG_0 (NODE) = 1)\n \n+/* Nonzero if NODE is a template template parameter.  */\n #define DECL_TEMPLATE_TEMPLATE_PARM_P(NODE) \\\n   (TREE_CODE (NODE) == TEMPLATE_DECL && DECL_TEMPLATE_PARM_P (NODE))\n \n@@ -3448,7 +3462,7 @@ extern void shadow_tag\t\t\t\tPROTO((tree));\n extern tree groktypename\t\t\tPROTO((tree));\n extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree, tree));\n extern void start_decl_1\t\t\tPROTO((tree));\n-extern void cp_finish_decl\t\t\tPROTO((tree, tree, tree, int, int));\n+extern void cp_finish_decl\t\t\tPROTO((tree, tree, tree, int));\n extern void finish_decl\t\t\t\tPROTO((tree, tree, tree));\n extern void maybe_inject_for_scope_var          PROTO((tree));\n extern void initialize_local_var                PROTO((tree, tree, int));\n@@ -3569,7 +3583,7 @@ extern void check_default_args\t\t\tPROTO((tree));\n extern void mark_used\t\t\t\tPROTO((tree));\n extern tree handle_class_head\t\t\tPROTO((tree, tree, tree));\n extern tree lookup_arg_dependent                PROTO((tree, tree, tree));\n-extern void finish_static_data_member_decl      PROTO((tree, tree, tree, int, int));\n+extern void finish_static_data_member_decl      PROTO((tree, tree, tree, int));\n \n /* in parse.y */\n extern void cp_parse_init\t\t\tPROTO((void));\n@@ -3999,8 +4013,6 @@ extern int cp_tree_equal\t\t\tPROTO((tree, tree));\n extern int can_free\t\t\t\tPROTO((struct obstack *, tree));\n extern tree no_linkage_check\t\t\tPROTO((tree));\n extern void debug_binfo\t\t\t\tPROTO((tree));\n-extern void push_expression_obstack\t\tPROTO((void));\n-extern void push_permanent_obstack              PROTO((void));\n extern tree build_dummy_object\t\t\tPROTO((tree));\n extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n extern int is_dummy_object\t\t\tPROTO((tree));\n@@ -4014,7 +4026,6 @@ extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n \n #define scratchalloc expralloc\n #define build_scratch_list build_expr_list\n-#define push_scratch_obstack push_expression_obstack\n \n /* in typeck.c */\n extern int string_conv_p\t\t\tPROTO((tree, tree, int));"}, {"sha": "d07c1d25725917c5326e165052a435d455631058", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -357,7 +357,7 @@ build_up_reference (type, arg, flags)\n \n       /* Process the initializer for the declaration.  */\n       DECL_INITIAL (arg) = targ;\n-      cp_finish_decl (arg, targ, NULL_TREE, 0,\n+      cp_finish_decl (arg, targ, NULL_TREE, \n \t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n     }\n   else if (!(flags & DIRECT_BIND) && ! lvalue_p (arg))"}, {"sha": "8b5d8bd199f86724e427e438e4514ba63540ca6a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 137, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -2043,15 +2043,13 @@ binding_for_name (name, scope)\n     }\n   if (b && (result = find_binding (name, scope)))\n     return result;\n-  /* Not found, make a new permanent one. */\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  /* Not found, make a new one. */\n   result = make_node (CPLUS_BINDING);\n   TREE_CHAIN (result) = b;\n   IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n   BINDING_SCOPE (result) = scope;\n   BINDING_TYPE (result) = NULL_TREE;\n   BINDING_VALUE (result) = NULL_TREE;\n-  pop_obstacks ();\n   return result;\n }\n \n@@ -2382,8 +2380,6 @@ maybe_push_to_top_level (pseudo)\n   current_lang_name = lang_name_cplusplus;\n   strict_prototype = strict_prototypes_lang_cplusplus;\n   current_namespace = global_namespace;\n-\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n }\n \n void\n@@ -2402,8 +2398,6 @@ pop_from_top_level ()\n   if (previous_class_type)\n     invalidate_class_lookup_cache ();\n \n-  pop_obstacks ();\n-\n   VARRAY_FREE (current_lang_base);\n \n   scope_chain = s->prev;\n@@ -3310,12 +3304,6 @@ duplicate_decls (newdecl, olddecl)\n       tree oldtype = TREE_TYPE (olddecl);\n       tree newtype;\n \n-      /* Make sure we put the new type in the same obstack as the old one.  */\n-      if (oldtype)\n-\tpush_obstacks (TYPE_OBSTACK (oldtype), TYPE_OBSTACK (oldtype));\n-      else\n-\tpush_permanent_obstack ();\n-\n       /* Merge the data types specified in the two decls.  */\n       newtype = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n \n@@ -3387,8 +3375,6 @@ duplicate_decls (newdecl, olddecl)\n \n       /* Keep the old rtl since we can safely use it.  */\n       DECL_RTL (newdecl) = DECL_RTL (olddecl);\n-\n-      pop_obstacks ();\n     }\n   /* If cannot merge, then use the new type and qualifiers,\n      and don't preserve the old rtl.  */\n@@ -3632,6 +3618,15 @@ pushdecl (x)\n \tDECL_CONTEXT (x) = current_function_decl;\n       if (!DECL_CONTEXT (x))\n \tDECL_CONTEXT (x) = FROB_CONTEXT (current_namespace);\n+\n+      /* If this is the declaration for a namespace-scope function,\n+\t but the declaration itself is in a local scope, mark the\n+\t declaration.  */\n+      if (TREE_CODE (x) == FUNCTION_DECL \n+\t  && DECL_NAMESPACE_SCOPE_P (x)\n+\t  && current_function_decl\n+\t  && x != current_function_decl)\n+\tDECL_LOCAL_FUNCTION_P (x) = 1;\n     }\n \n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n@@ -3799,15 +3794,11 @@ pushdecl (x)\n \t\t   && (!TYPE_NAME (type) \n \t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n             {\n-\t      push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n-\n \t      DECL_ORIGINAL_TYPE (x) = type;\n               type = build_type_copy (type);\n \t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n               TYPE_NAME (type) = x;\n               TREE_TYPE (x) = type;\n-\n-\t      pop_obstacks ();\n             }\n \n \t  if (type != error_mark_node\n@@ -4469,15 +4460,6 @@ implicitly_declare (functionid)\n      tree functionid;\n {\n   register tree decl;\n-  int temp = allocation_temporary_p ();\n-\n-  push_obstacks_nochange ();\n-\n-  /* Save the decl permanently so we can warn if definition follows.\n-     In ANSI C, warn_implicit is usually false, so the saves little space.\n-     But in C++, it's usually true, hence the extra code.  */\n-  if (temp && (! warn_implicit || toplevel_bindings_p ()))\n-    end_temporary_allocation ();\n \n   /* We used to reuse an old implicit decl here,\n      but this loses with inline functions because it can clobber\n@@ -4501,8 +4483,6 @@ implicitly_declare (functionid)\n \n   SET_IDENTIFIER_IMPLICIT_DECL (functionid, decl);\n \n-  pop_obstacks ();\n-\n   return decl;\n }\n \n@@ -5227,8 +5207,6 @@ build_typename_type (context, name, fullname, base_type)\n \n   static struct hash_table ht;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   if (!ht.table)\n     {\n       static struct hash_table *h = &ht;\n@@ -5259,8 +5237,6 @@ build_typename_type (context, name, fullname, base_type)\n     /* Insert the type into the table.  */\n     hash_lookup (&ht, t, /*create=*/true, /*copy=*/0);\n \n-  pop_obstacks ();\n-\n   return t;\n }\n \n@@ -6807,14 +6783,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   tem = maybe_push_decl (decl);\n \n   if (processing_template_decl)\n-    {\n-      if (at_function_scope_p ())\n-\tpush_permanent_obstack ();\n-      tem = push_template_decl (tem);\n-      if (at_function_scope_p ())\n-\tpop_obstacks ();\n-    }\n-\n+    tem = push_template_decl (tem);\n \n #if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n   /* Tell the back-end to use or not use .common as appropriate.  If we say\n@@ -6828,9 +6797,6 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   if (! processing_template_decl)\n     start_decl_1 (tem);\n \n-  /* Corresponding pop_obstacks is done in `cp_finish_decl'.  */\n-  push_obstacks_nochange ();\n-\n   return tem;\n }\n \n@@ -7610,8 +7576,6 @@ emit_local_var (decl)\n    If the length of an array type is not known before,\n    it must be determined now, from the initial value, or it is an error.\n \n-   Call `pop_obstacks' iff NEED_POP is nonzero.\n-\n    For C++, `cp_finish_decl' must be fairly evasive:  it must keep initializers\n    for aggregates that have constructors alive on the permanent obstack,\n    so that the global initializing functions can be written at the end.\n@@ -7628,15 +7592,13 @@ emit_local_var (decl)\n    ambiguity as it goes.  This can be sped up later.  */\n \n void\n-cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n+cp_finish_decl (decl, init, asmspec_tree, flags)\n      tree decl, init;\n      tree asmspec_tree;\n-     int need_pop;\n      int flags;\n {\n   register tree type;\n   tree ttype = NULL_TREE;\n-  int temporary = allocation_temporary_p ();\n   const char *asmspec = NULL;\n   int was_readonly = 0;\n \n@@ -7678,12 +7640,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   type = TREE_TYPE (decl);\n \n   if (type == error_mark_node)\n-    {\n-      if (toplevel_bindings_p () && temporary)\n-\tend_temporary_allocation ();\n-\n-      return;\n-    }\n+    return;\n \n   /* Add this declaration to the statement-tree.  */\n   if (building_stmt_tree () \n@@ -7763,14 +7720,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \n   GNU_xref_decl (current_function_decl, decl);\n \n-  /* For top-level declaration, the initial value was read in\n-     the temporary obstack.  MAXINDEX, rtl, etc. to be made below\n-     must go in the permanent obstack; but don't discard the\n-     temporary data yet.  */\n-\n-  if (toplevel_bindings_p () && temporary)\n-    end_temporary_allocation ();\n-\n   if (TREE_CODE (decl) == VAR_DECL)\n     layout_var_decl (decl);\n \n@@ -7875,12 +7824,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t}\n     }\n \n-  if (need_pop)\n-    /* Resume permanent allocation, if not within a function.  The\n-       corresponding push_obstacks_nochange is in start_decl,\n-       start_method, groktypename, and in grokfield.  */\n-    pop_obstacks ();\n-\n   if (was_readonly)\n     TREE_READONLY (decl) = 1;\n }\n@@ -7892,7 +7835,7 @@ finish_decl (decl, init, asmspec_tree)\n      tree decl, init;\n      tree asmspec_tree;\n {\n-  cp_finish_decl (decl, init, asmspec_tree, 1, 0);\n+  cp_finish_decl (decl, init, asmspec_tree, 0);\n }\n \n /* Generate code to handle the destruction of the function-scoped\n@@ -7909,8 +7852,7 @@ destroy_local_static (decl)\n   if (atexit_node == 0)\n     {\n       tree atexit_fndecl, PFV, pfvlist;\n-      /* Remember this information until end of file.  */\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n       PFV = build_pointer_type (build_function_type\n \t\t\t\t(void_type_node, void_list_node));\n \n@@ -7928,7 +7870,6 @@ destroy_local_static (decl)\n       mark_used (atexit_fndecl);\n       atexit_node = default_conversion (atexit_fndecl);\n       pop_lang_context ();\n-      pop_obstacks ();\n     }\n \t      \n   /* Call build_cleanup before we enter the anonymous function so that\n@@ -7985,9 +7926,6 @@ expand_static_init (decl, init)\n       tree assignment;\n       tree temp_init;\n \n-      /* Remember this information until end of file.  */\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n       /* Emit code to perform this initialization but once.  This code\n \t looks like:\n \n@@ -8061,9 +7999,6 @@ expand_static_init (decl, init)\n       finish_compound_stmt (/*has_no_scope=*/0, then_clause);\n       finish_then_clause (if_stmt);\n       finish_if_stmt ();\n-\n-      /* Resume old (possibly temporary) allocation.  */\n-      pop_obstacks ();\n     }\n   else\n     {\n@@ -8111,9 +8046,6 @@ complete_array_type (type, initial_value, do_default)\n   register tree maxindex = NULL_TREE;\n   int value = 0;\n   \n-  /* Allocate on the same obstack as TYPE.  */\n-  push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n-  \n   if (initial_value)\n     {\n       /* Note MAXINDEX  is really the maximum index,\n@@ -8181,8 +8113,6 @@ complete_array_type (type, initial_value, do_default)\n \tTYPE_DOMAIN (TYPE_MAIN_VARIANT (type)) = domain;\n     }\n \n-  pop_obstacks();\n-  \n   /* Lay out the type now that we can get the real answer.  */\n \n   layout_type (type);\n@@ -8575,13 +8505,9 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \tcontext = NULL_TREE;\n \n       if (processing_template_decl) \n-\t{\n-\t  /* If we're in a template, we need DECL_LANG_SPECIFIC so that\n-\t     we can call push_template_decl.  */\n-\t  push_permanent_obstack ();\n-\t  decl = build_lang_decl (VAR_DECL, declarator, type);\n-\t  pop_obstacks ();\n-\t}\n+\t/* If we're in a template, we need DECL_LANG_SPECIFIC so that\n+\t   we can call push_template_decl.  */\n+\tdecl = build_lang_decl (VAR_DECL, declarator, type);\n       else\n \tdecl = build_decl (VAR_DECL, declarator, type);\n \n@@ -8671,8 +8597,6 @@ build_ptrmemfunc_type (type)\n     unqualified_variant \n       = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n \n-  push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n-\n   u = make_lang_type (UNION_TYPE);\n   SET_IS_AGGR_TYPE (u, 0);\n   fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n@@ -8695,8 +8619,6 @@ build_ptrmemfunc_type (type)\n   fields[2] = build_lang_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n   finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n \n-  pop_obstacks ();\n-\n   /* Zap out the name so that the back-end will give us the debugging\n      information for this anonymous RECORD_TYPE.  */\n   TYPE_NAME (t) = NULL_TREE;\n@@ -10517,14 +10439,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t{\n \t  /* Make sure this typedef lives as long as its type,\n \t     since it might be used as a template parameter. */\n-\t  if (type != error_mark_node)\n-\t    push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n \t  if (processing_template_decl)\n \t    decl = build_lang_decl (TYPE_DECL, declarator, type);\n \t  else\n \t    decl = build_decl (TYPE_DECL, declarator, type);\n-\t  if (type != error_mark_node)\n-\t    pop_obstacks ();\n \t}\n \n       /* If the user declares \"typedef struct {...} foo\" then the\n@@ -11976,7 +11894,6 @@ xref_tag (code_type_node, name, globalize)\n {\n   enum tag_types tag_code;\n   enum tree_code code;\n-  int temp = 0;\n   register tree ref, t;\n   struct binding_level *b = current_binding_level;\n   int got_type = 0;\n@@ -12117,22 +12034,12 @@ xref_tag (code_type_node, name, globalize)\n \t}\n     }\n \n-  push_obstacks_nochange ();\n-\n   if (! ref)\n     {\n       /* If no such tag is yet defined, create a forward-reference node\n \t and record it as the \"definition\".\n \t When a real declaration of this type is found,\n \t the forward-reference will be altered into a real type.  */\n-\n-      /* In C++, since these migrate into the global scope, we must\n-\t build them on the permanent obstack.  */\n-\n-      temp = allocation_temporary_p ();\n-      if (temp)\n-\tend_temporary_allocation ();\n-\n       if (code == ENUMERAL_TYPE)\n \t{\n \t  cp_error (\"use of enum `%#D' without previous declaration\", name);\n@@ -12197,8 +12104,6 @@ xref_tag (code_type_node, name, globalize)\n \tCLASSTYPE_DECLARED_CLASS (ref) = 0;\n     }\n \n-  pop_obstacks ();\n-\n   TREE_TYPE (ref) = attributes;\n \n   return ref;\n@@ -12250,7 +12155,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n     }\n \n   len = list_length (binfo);\n-  push_obstacks (TYPE_OBSTACK (ref), TYPE_OBSTACK (ref));\n \n   /* First, make sure that any templates in base-classes are\n      instantiated.  This ensures that if we call ourselves recursively\n@@ -12392,8 +12296,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n   /* Now that we know all the base-classes, set up the list of virtual\n      bases.  */\n   CLASSTYPE_VBASECLASSES (ref) = get_vbase_types (ref);\n-\n-  pop_obstacks ();\n }\n   \n \f\n@@ -12410,10 +12312,6 @@ start_enum (name)\n   register tree enumtype = NULL_TREE;\n   struct binding_level *b = current_binding_level;\n \n-  /* We are wasting space here and putting these on the permanent_obstack so\n-     that typeid(local enum) will work correctly. */\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n      forward reference.  */\n@@ -12567,9 +12465,6 @@ finish_enum (enumtype)\n       rest_of_type_compilation (enumtype, namespace_bindings_p ());\n     }\n \n-  /* In start_enum we pushed obstacks.  Here, we must pop them.  */\n-  pop_obstacks ();\n-\n   return enumtype;\n }\n \n@@ -13113,13 +13008,6 @@ start_function (declspecs, declarator, attrs, flags)\n       TREE_THIS_VOLATILE (DECL_RESULT (decl1)) = CP_TYPE_VOLATILE_P (restype);\n     }\n \n-  /* Allocate further tree nodes temporarily during compilation\n-     of this function only.  Tiemann moved up here from bottom of fn.  */\n-  /* If this is a nested function, then we must continue to allocate RTL\n-     on the permanent obstack in case we need to inline it later.  */\n-  if (! hack_decl_function_context (decl1))\n-    temporary_allocation ();\n-  \n   ++function_depth;\n \n   if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1))\n@@ -13806,12 +13694,6 @@ finish_function (lineno, flags)\n \n   --function_depth;\n \n-  /* Free all the tree nodes making up this function.  */\n-  /* Switch back to allocating nodes permanently\n-     until we start another function.  */\n-  if (! nested)\n-    permanent_allocation (1);\n-\n   if (!DECL_SAVED_INSNS (fndecl) && !DECL_SAVED_FUNCTION_DATA (fndecl))\n     {\n       tree t;\n@@ -13927,7 +13809,7 @@ start_method (declspecs, declarator, attrlist)\n \tgrok_op_properties (fndecl, DECL_VIRTUAL_P (fndecl), 0);\n     }\n \n-  cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0);\n \n   /* Make a place for the parms */\n   pushlevel (0);"}, {"sha": "8e3d2323c360d9616272cf90b19fff760118018c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -1454,14 +1454,13 @@ check_classfn (ctype, function)\n /* We have just processed the DECL, which is a static data member.\n    Its initializer, if present, is INIT.  The ASMSPEC_TREE, if\n    present, is the assembly-language name for the data member.\n-   NEED_POP and FLAGS are as for cp_finish_decl.  */\n+   FLAGS is as for cp_finish_decl.  */\n \n void\n-finish_static_data_member_decl (decl, init, asmspec_tree, need_pop, flags)\n+finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n      tree decl;\n      tree init;\n      tree asmspec_tree;\n-     int need_pop;\n      int flags;\n {\n   const char *asmspec = 0;\n@@ -1512,7 +1511,7 @@ finish_static_data_member_decl (decl, init, asmspec_tree, need_pop, flags)\n   DECL_CONTEXT (decl) = current_class_type;\n   DECL_CLASS_CONTEXT (decl) = current_class_type;\n \n-  cp_finish_decl (decl, init, asmspec_tree, need_pop, flags);\n+  cp_finish_decl (decl, init, asmspec_tree, flags);\n }\n \n /* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n@@ -1670,9 +1669,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t}\n     }\n \n-  /* The corresponding pop_obstacks is in cp_finish_decl.  */\n-  push_obstacks_nochange ();\n-\n   if (processing_template_decl && ! current_function_decl\n       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n     value = push_template_decl (value);\n@@ -1684,7 +1680,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (TREE_CODE (value) == VAR_DECL)\n     {\n       finish_static_data_member_decl (value, init, asmspec_tree, \n-\t\t\t\t      /*need_pop=*/1, flags);\n+\t\t\t\t      flags);\n       return value;\n     }\n   if (TREE_CODE (value) == FIELD_DECL)\n@@ -1698,7 +1694,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t}\n       if (DECL_INITIAL (value) == error_mark_node)\n \tinit = error_mark_node;\n-      cp_finish_decl (value, init, asmspec_tree, 1, flags);\n+      cp_finish_decl (value, init, asmspec_tree, flags);\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n@@ -1712,7 +1708,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t  DECL_RTL (value) = NULL_RTX;\n \t  DECL_ASSEMBLER_NAME (value) = get_identifier (asmspec);\n \t}\n-      cp_finish_decl (value, init, asmspec_tree, 1, flags);\n+      cp_finish_decl (value, init, asmspec_tree, flags);\n \n       /* Pass friends back this way.  */\n       if (DECL_FRIEND_P (value))\n@@ -1773,7 +1769,7 @@ grokbitfield (declarator, declspecs, width)\n       cp_error (\"static member `%D' cannot be a bitfield\", value);\n       return NULL_TREE;\n     }\n-  cp_finish_decl (value, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (value, NULL_TREE, NULL_TREE, 0);\n \n   if (width != error_mark_node)\n     {\n@@ -1994,10 +1990,8 @@ get_temp_name (type, staticp)\n   tree decl;\n   int toplev = toplevel_bindings_p ();\n \n-  push_obstacks_nochange ();\n   if (toplev || staticp)\n     {\n-      end_temporary_allocation ();\n       sprintf (buf, AUTO_TEMP_FORMAT, global_temp_name_counter++);\n       decl = pushdecl_top_level (build_decl (VAR_DECL, get_identifier (buf), type));\n     }\n@@ -2019,7 +2013,6 @@ get_temp_name (type, staticp)\n       my_friendly_assert (DECL_INITIAL (decl) == NULL_TREE,\n \t\t\t  19990826);\n     }\n-  pop_obstacks ();\n \n   return decl;\n }\n@@ -2750,16 +2743,14 @@ get_sentry (base)\n   tree sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n   if (! sentry)\n     {\n-      push_permanent_obstack ();\n       sentry = build_decl (VAR_DECL, sname, integer_type_node);\n       TREE_PUBLIC (sentry) = 1;\n       DECL_ARTIFICIAL (sentry) = 1;\n       TREE_STATIC (sentry) = 1;\n       TREE_USED (sentry) = 1;\n       DECL_COMMON (sentry) = 1;\n       pushdecl_top_level (sentry);\n-      cp_finish_decl (sentry, NULL_TREE, NULL_TREE, 0, 0);\n-      pop_obstacks ();\n+      cp_finish_decl (sentry, NULL_TREE, NULL_TREE, 0);\n     }\n   return sentry;\n }\n@@ -3428,7 +3419,6 @@ finish_file ()\n   parse_time -= this_time - start_time;\n   varconst_time += this_time - start_time;\n   start_time = get_run_time ();\n-  permanent_allocation (1);\n \n   do \n     {\n@@ -4806,14 +4796,12 @@ lookup_arg_dependent (name, fns, args)\n \n   /* Note that we've already looked at some namespaces during normal\n      unqualified lookup, unless we found a decl in function scope.  */\n-  if (fns && ! TREE_PERMANENT (OVL_CURRENT (fns)))\n+  if (fns && DECL_LOCAL_FUNCTION_P (OVL_CURRENT (fns)))\n     k.namespaces = NULL_TREE;\n   else\n     unqualified_namespace_lookup (name, 0, &k.namespaces);\n \n-  push_scratch_obstack ();\n   arg_assoc_args (&k, args);\n-  pop_obstacks ();\n   return k.functions;\n }\n "}, {"sha": "3d29ad70581c7e5832283becdd540d92716426b9", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -192,7 +192,6 @@ call_eh_info ()\n \n       /* Declare cp_eh_info * __start_cp_handler (void),\n \t as defined in exception.cc. */\n-      push_permanent_obstack ();\n \n       /* struct cp_eh_info.  This must match exception.cc.  Note that this\n \t type is not pushed anywhere.  */\n@@ -251,7 +250,6 @@ call_eh_info ()\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n   mark_used (fn);\n   return build_function_call (fn, NULL_TREE);\n@@ -272,7 +270,7 @@ push_eh_info ()\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_INITIAL (decl) = fn;\n   decl = pushdecl (decl);\n-  cp_finish_decl (decl, fn, NULL_TREE, 0, 0);\n+  cp_finish_decl (decl, fn, NULL_TREE, 0);\n }\n \n /* Returns a reference to the cp_eh_info node for the current exception.  */\n@@ -414,7 +412,6 @@ do_pop_exception ()\n     {\n       /* Declare void __cp_pop_exception (void *),\n \t as defined in exception.cc. */\n-      push_permanent_obstack ();\n       fn = build_lang_decl\n \t(FUNCTION_DECL, fn,\n \t build_function_type (void_type_node, tree_cons\n@@ -424,7 +421,6 @@ do_pop_exception ()\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -501,7 +497,7 @@ initialize_handler_parm (decl)\n   decl = pushdecl (decl);\n \n   start_decl_1 (decl);\n-  cp_finish_decl (decl, init, NULL_TREE, 0,\n+  cp_finish_decl (decl, init, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n }\n \n@@ -619,7 +615,7 @@ expand_end_eh_spec (raises, try_block)\n   decl = build_decl (VAR_DECL, NULL_TREE, tmp);\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_INITIAL (decl) = types;\n-  cp_finish_decl (decl, types, NULL_TREE, 0, 0);\n+  cp_finish_decl (decl, types, NULL_TREE, 0);\n \n   decl = decay_conversion (decl);\n \n@@ -628,8 +624,6 @@ expand_end_eh_spec (raises, try_block)\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      push_permanent_obstack ();\n-\n       tmp = tree_cons\n \t(NULL_TREE, integer_type_node, tree_cons\n \t (NULL_TREE, TREE_TYPE (decl), void_list_node));\n@@ -642,7 +636,6 @@ expand_end_eh_spec (raises, try_block)\n       TREE_THIS_VOLATILE (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -750,7 +743,6 @@ alloc_eh_object (type)\n     {\n       /* Declare __eh_alloc (size_t), as defined in exception.cc.  */\n       tree tmp;\n-      push_permanent_obstack ();\n       tmp = tree_cons (NULL_TREE, sizetype, void_list_node);\n       fn = build_lang_decl (FUNCTION_DECL, fn,\n \t\t\t    build_function_type (ptr_type_node, tmp));\n@@ -759,7 +751,6 @@ alloc_eh_object (type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -841,7 +832,7 @@ expand_throw (exp)\n \t    {\n \t      tree temp = create_temporary_var (TREE_TYPE (exp));\n \t      DECL_INITIAL (temp) = exp;\n-\t      cp_finish_decl (temp, exp, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n+\t      cp_finish_decl (temp, exp, NULL_TREE, LOOKUP_ONLYCONVERTING);\n \t      exp = temp;\n \t    }\n \n@@ -894,7 +885,6 @@ expand_throw (exp)\n \t  /* Declare __cp_push_exception (void*, void*, void (*)(void*, int)),\n \t     as defined in exception.cc.  */\n \t  tree tmp;\n-\t  push_permanent_obstack ();\n \t  tmp = tree_cons\n \t    (NULL_TREE, ptr_type_node, tree_cons\n \t     (NULL_TREE, ptr_type_node, tree_cons\n@@ -906,7 +896,6 @@ expand_throw (exp)\n \t  DECL_ARTIFICIAL (fn) = 1;\n \t  pushdecl_top_level (fn);\n \t  make_function_rtl (fn);\n-\t  pop_obstacks ();\n \t}\n \n       mark_used (fn);\n@@ -928,7 +917,6 @@ expand_throw (exp)\n \t{\n \t  /* Declare void __uncatch_exception (void)\n \t     as defined in exception.cc. */\n-\t  push_permanent_obstack ();\n \t  fn = build_lang_decl (FUNCTION_DECL, fn,\n \t\t\t\tbuild_function_type (void_type_node,\n \t\t\t\t\t\t     void_list_node));\n@@ -937,7 +925,6 @@ expand_throw (exp)\n \t  DECL_ARTIFICIAL (fn) = 1;\n \t  pushdecl_top_level (fn);\n \t  make_function_rtl (fn);\n-\t  pop_obstacks ();\n \t}\n \n       mark_used (fn);"}, {"sha": "094ba501cd7841bc3224b57080964805d9eb03a1", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -311,14 +311,12 @@ extract_scalar_init (decl, init)\n   extern struct obstack temporary_obstack;\n   tree t = NULL_TREE;\n \n-  push_obstacks (&temporary_obstack, &temporary_obstack);\n   start_sequence ();\n   value = expand_expr (init, NULL_RTX, VOIDmode, 0);\n   insns = get_insns ();\n   end_sequence ();\n   reg_scan (insns, max_reg_num (), 0);\n   jump_optimize (insns, 0, 0, 1);\n-  pop_obstacks ();\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     {"}, {"sha": "a54137f7a2f197e0b6cb15e2a92956b2ac3df866", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -2076,7 +2076,6 @@ build_java_class_ref (type)\n   class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n   if (class_decl == NULL_TREE)\n     {\n-      push_permanent_obstack ();\n       class_decl = build_decl (VAR_DECL, name, TREE_TYPE (jclass_node));\n       TREE_STATIC (class_decl) = 1;\n       DECL_EXTERNAL (class_decl) = 1;\n@@ -2085,7 +2084,6 @@ build_java_class_ref (type)\n       DECL_IGNORED_P (class_decl) = 1;\n       pushdecl_top_level (class_decl);\n       make_decl_rtl (class_decl, NULL_PTR, 1);\n-      pop_obstacks ();\n     }\n   return class_decl;\n }"}, {"sha": "c3bdcd9faabb7c00e6ba0877bf65364a4d177184", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -379,13 +379,11 @@ get_time_identifier (name)\n   time_identifier = get_identifier (buf);\n   if (TIME_IDENTIFIER_TIME (time_identifier) == NULL_TREE)\n     {\n-      push_permanent_obstack ();\n       TIME_IDENTIFIER_TIME (time_identifier) = build_int_2 (0, 0);\n       TIME_IDENTIFIER_FILEINFO (time_identifier) \n \t= build_int_2 (0, 1);\n       SET_IDENTIFIER_GLOBAL_VALUE (time_identifier, filename_times);\n       filename_times = time_identifier;\n-      pop_obstacks ();\n     }\n   return time_identifier;\n }\n@@ -1851,11 +1849,9 @@ snarf_defarg ()\n   len = obstack_object_size (&inline_text_obstack);\n   buf = obstack_finish (&inline_text_obstack);\n \n-  push_obstacks (&inline_text_obstack, &inline_text_obstack);\n   arg = make_node (DEFAULT_ARG);\n   DEFARG_LENGTH (arg) = len - 1;\n   DEFARG_POINTER (arg) = buf;\n-  pop_obstacks ();\n \n   return arg;\n }\n@@ -1872,11 +1868,7 @@ add_defarg_fn (decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     TREE_VALUE (defarg_fns) = decl;\n   else\n-    {\n-      push_obstacks (&inline_text_obstack, &inline_text_obstack);\n-      defarg_fns = tree_cons (current_class_type, decl, defarg_fns);  \n-      pop_obstacks ();\n-    }\n+    defarg_fns = tree_cons (current_class_type, decl, defarg_fns);  \n }\n \n /* Helper for do_pending_defargs.  Starts the parsing of a default arg.  */\n@@ -3058,13 +3050,7 @@ is_global (d)\n       default:\n         my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (d)) == 'd', 980629);\n \n-\t/* A template parameter is not really global, even though it\n-\t   has no enclosing scope.  */\n-\tif (DECL_TEMPLATE_PARM_P (d))\n-\t  return 0;\n-\n-        d = CP_DECL_CONTEXT (d);\n-        return TREE_CODE (d) == NAMESPACE_DECL;\n+\treturn DECL_NAMESPACE_SCOPE_P (d);\n       }\n }\n \n@@ -3216,10 +3202,6 @@ do_identifier (token, parsing, args)\n      local variables and then finding matching instantiations.  */\n   if (current_template_parms\n       && (is_overloaded_fn (id) \n-\t  /* If it's not going to be around at instantiation time, we\n-\t     look it up then.  This is a hack, and should go when we\n-\t     really get dependent/independent name lookup right.  */\n-\t  || !TREE_PERMANENT (id)\n \t  /* Some local VAR_DECLs (such as those for local variables\n \t     in member functions of local classes) are built on the\n \t     permanent obstack.  */\n@@ -4491,11 +4473,7 @@ real_yylex ()\n \t/* We have read the entire constant.\n \t   Construct a STRING_CST for the result.  */\n \n-\tif (processing_template_decl)\n-\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n \tyylval.ttype = build_string (p - (token_buffer + 1), token_buffer + 1);\n-\tif (processing_template_decl)\n-\t  pop_obstacks ();\n \n \tif (wide_flag)\n \t  TREE_TYPE (yylval.ttype) = wchar_array_type_node;"}, {"sha": "7373f06c811348d925a1866dfef5121993c1ed5c", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -2149,7 +2149,6 @@ emit_thunk (thunk_fndecl)\n       /* Make sure we build up its RTL before we go onto the\n \t temporary obstack.  */\n       make_function_rtl (thunk_fndecl);\n-      temporary_allocation ();\n       DECL_RESULT (thunk_fndecl)\n \t= build_decl (RESULT_DECL, 0, integer_type_node);\n       fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n@@ -2158,7 +2157,6 @@ emit_thunk (thunk_fndecl)\n       assemble_start_function (thunk_fndecl, fnname);\n       ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n       assemble_end_function (thunk_fndecl, fnname);\n-      permanent_allocation (1);\n       current_function_decl = 0;\n       current_function = 0;\n     }\n@@ -2211,10 +2209,7 @@ emit_thunk (thunk_fndecl)\n \n     /* Don't let the backend defer this function.  */\n     if (DECL_DEFER_OUTPUT (thunk_fndecl))\n-      {\n-\toutput_inline_function (thunk_fndecl);\n-\tpermanent_allocation (1);\n-      }\n+      output_inline_function (thunk_fndecl);\n   }\n #endif /* ASM_OUTPUT_MI_THUNK */\n "}, {"sha": "794777ac0119a8c786f6b70ba8a55481a566a84d", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 542, "deletions": 546, "changes": 1088, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -681,64 +681,64 @@ static const short yyrline[] = { 0,\n   1259,  1261,  1263,  1267,  1269,  1271,  1288,  1291,  1293,  1294,\n   1295,  1296,  1297,  1300,  1312,  1315,  1319,  1322,  1324,  1329,\n   1331,  1332,  1335,  1337,  1345,  1347,  1349,  1351,  1355,  1358,\n-  1362,  1366,  1367,  1368,  1372,  1380,  1381,  1382,  1396,  1398,\n-  1401,  1403,  1414,  1419,  1421,  1423,  1425,  1427,  1429,  1431,\n-  1434,  1436,  1447,  1448,  1452,  1456,  1460,  1464,  1466,  1470,\n-  1472,  1474,  1482,  1484,  1486,  1488,  1492,  1494,  1496,  1498,\n-  1503,  1505,  1507,  1509,  1512,  1514,  1516,  1560,  1563,  1567,\n-  1570,  1574,  1577,  1582,  1584,  1588,  1597,  1600,  1607,  1613,\n-  1617,  1619,  1624,  1626,  1633,  1635,  1639,  1643,  1649,  1653,\n-  1656,  1660,  1663,  1673,  1675,  1678,  1682,  1685,  1688,  1691,\n-  1694,  1700,  1706,  1708,  1713,  1715,  1733,  1736,  1738,  1741,\n-  1747,  1749,  1759,  1763,  1766,  1769,  1774,  1777,  1785,  1787,\n-  1789,  1791,  1794,  1797,  1812,  1831,  1834,  1836,  1839,  1841,\n-  1845,  1847,  1851,  1853,  1857,  1860,  1864,  1870,  1871,  1883,\n-  1889,  1891,  1897,  1902,  1907,  1913,  1914,  1922,  1925,  1929,\n-  1932,  1936,  1941,  1944,  1948,  1951,  1953,  1955,  1957,  1964,\n-  1966,  1967,  1968,  1972,  1975,  1979,  1982,  1988,  1990,  1993,\n-  1996,  1999,  2005,  2008,  2011,  2013,  2015,  2019,  2026,  2032,\n-  2037,  2043,  2045,  2050,  2053,  2056,  2058,  2060,  2064,  2068,\n-  2074,  2077,  2083,  2086,  2089,  2095,  2097,  2109,  2113,  2118,\n-  2142,  2144,  2147,  2149,  2154,  2156,  2158,  2160,  2162,  2164,\n-  2168,  2176,  2179,  2181,  2185,  2192,  2198,  2204,  2210,  2220,\n-  2226,  2230,  2237,  2265,  2275,  2281,  2284,  2287,  2289,  2293,\n-  2295,  2299,  2302,  2306,  2309,  2312,  2314,  2318,  2329,  2343,\n-  2344,  2345,  2346,  2349,  2358,  2363,  2369,  2371,  2376,  2378,\n-  2380,  2382,  2384,  2386,  2389,  2399,  2406,  2431,  2437,  2440,\n-  2443,  2445,  2456,  2461,  2464,  2469,  2472,  2479,  2489,  2492,\n-  2499,  2509,  2511,  2514,  2516,  2519,  2526,  2534,  2541,  2547,\n-  2553,  2561,  2565,  2570,  2574,  2577,  2582,  2584,  2592,  2594,\n-  2598,  2601,  2606,  2610,  2615,  2625,  2628,  2632,  2636,  2645,\n-  2648,  2650,  2652,  2658,  2660,  2669,  2672,  2674,  2676,  2678,\n-  2682,  2685,  2688,  2690,  2692,  2694,  2698,  2701,  2712,  2722,\n-  2724,  2725,  2729,  2737,  2739,  2747,  2750,  2752,  2754,  2756,\n-  2760,  2763,  2766,  2768,  2770,  2772,  2776,  2779,  2782,  2784,\n-  2786,  2788,  2790,  2797,  2801,  2806,  2810,  2815,  2817,  2821,\n-  2824,  2826,  2829,  2831,  2832,  2835,  2837,  2839,  2846,  2857,\n-  2863,  2869,  2883,  2885,  2889,  2903,  2905,  2907,  2911,  2917,\n-  2930,  2933,  2938,  2951,  2957,  2959,  2960,  2961,  2969,  2974,\n-  2983,  2984,  2988,  2991,  2997,  3003,  3006,  3008,  3010,  3012,\n-  3016,  3020,  3024,  3027,  3031,  3033,  3042,  3045,  3047,  3049,\n-  3051,  3053,  3055,  3057,  3059,  3063,  3067,  3071,  3075,  3077,\n-  3079,  3081,  3083,  3085,  3087,  3089,  3091,  3099,  3101,  3102,\n-  3103,  3106,  3112,  3114,  3119,  3121,  3124,  3137,  3140,  3143,\n-  3147,  3150,  3157,  3159,  3162,  3164,  3166,  3169,  3172,  3175,\n-  3178,  3180,  3183,  3187,  3189,  3195,  3197,  3198,  3200,  3205,\n-  3207,  3209,  3211,  3213,  3216,  3217,  3219,  3222,  3223,  3226,\n-  3226,  3229,  3229,  3232,  3232,  3234,  3236,  3238,  3240,  3246,\n-  3252,  3255,  3258,  3264,  3266,  3267,  3270,  3272,  3273,  3274,\n-  3276,  3279,  3282,  3285,  3291,  3295,  3297,  3300,  3302,  3305,\n-  3309,  3311,  3314,  3316,  3319,  3336,  3344,  3347,  3349,  3351,\n-  3355,  3358,  3359,  3367,  3371,  3375,  3378,  3379,  3385,  3388,\n-  3391,  3393,  3397,  3402,  3405,  3415,  3420,  3421,  3428,  3431,\n-  3434,  3436,  3439,  3441,  3451,  3465,  3469,  3472,  3474,  3478,\n-  3482,  3485,  3488,  3490,  3494,  3496,  3503,  3510,  3513,  3517,\n-  3521,  3525,  3531,  3535,  3540,  3542,  3545,  3550,  3556,  3567,\n-  3570,  3572,  3576,  3584,  3587,  3591,  3594,  3596,  3598,  3604,\n-  3609,  3612,  3614,  3616,  3618,  3620,  3622,  3624,  3626,  3628,\n-  3630,  3632,  3634,  3636,  3638,  3640,  3642,  3644,  3646,  3648,\n-  3650,  3652,  3654,  3656,  3658,  3660,  3662,  3664,  3666,  3668,\n-  3670,  3672,  3674,  3677,  3679\n+  1362,  1366,  1367,  1368,  1372,  1380,  1381,  1382,  1392,  1394,\n+  1397,  1399,  1410,  1415,  1417,  1419,  1421,  1423,  1425,  1427,\n+  1430,  1432,  1443,  1444,  1448,  1452,  1456,  1460,  1462,  1466,\n+  1468,  1470,  1478,  1480,  1482,  1484,  1488,  1490,  1492,  1494,\n+  1499,  1501,  1503,  1505,  1508,  1510,  1512,  1556,  1559,  1563,\n+  1566,  1570,  1573,  1578,  1580,  1584,  1593,  1596,  1603,  1609,\n+  1613,  1615,  1620,  1622,  1629,  1631,  1635,  1639,  1645,  1649,\n+  1652,  1656,  1659,  1669,  1671,  1674,  1678,  1681,  1684,  1687,\n+  1690,  1696,  1702,  1704,  1709,  1711,  1729,  1732,  1734,  1737,\n+  1743,  1745,  1755,  1759,  1762,  1765,  1770,  1773,  1781,  1783,\n+  1785,  1787,  1790,  1793,  1808,  1827,  1830,  1832,  1835,  1837,\n+  1841,  1843,  1847,  1849,  1853,  1856,  1860,  1866,  1867,  1879,\n+  1885,  1887,  1893,  1898,  1903,  1909,  1910,  1918,  1921,  1925,\n+  1928,  1932,  1937,  1940,  1944,  1947,  1949,  1951,  1953,  1960,\n+  1962,  1963,  1964,  1968,  1971,  1975,  1978,  1984,  1986,  1989,\n+  1992,  1995,  2001,  2004,  2007,  2009,  2011,  2015,  2022,  2028,\n+  2033,  2039,  2041,  2046,  2049,  2052,  2054,  2056,  2060,  2064,\n+  2070,  2073,  2079,  2082,  2085,  2091,  2093,  2105,  2109,  2114,\n+  2138,  2140,  2143,  2145,  2150,  2152,  2154,  2156,  2158,  2160,\n+  2164,  2172,  2175,  2177,  2181,  2188,  2194,  2200,  2206,  2216,\n+  2222,  2226,  2233,  2261,  2271,  2277,  2280,  2283,  2285,  2289,\n+  2291,  2295,  2298,  2302,  2305,  2308,  2310,  2314,  2325,  2339,\n+  2340,  2341,  2342,  2345,  2354,  2359,  2365,  2367,  2372,  2374,\n+  2376,  2378,  2380,  2382,  2385,  2395,  2402,  2427,  2433,  2436,\n+  2439,  2441,  2452,  2457,  2460,  2465,  2468,  2475,  2485,  2488,\n+  2495,  2505,  2507,  2510,  2512,  2515,  2522,  2530,  2537,  2543,\n+  2549,  2557,  2561,  2566,  2570,  2573,  2578,  2580,  2588,  2590,\n+  2594,  2597,  2602,  2606,  2611,  2621,  2624,  2628,  2632,  2641,\n+  2644,  2646,  2648,  2654,  2656,  2665,  2668,  2670,  2672,  2674,\n+  2678,  2681,  2684,  2686,  2688,  2690,  2694,  2697,  2708,  2718,\n+  2720,  2721,  2725,  2733,  2735,  2743,  2746,  2748,  2750,  2752,\n+  2756,  2759,  2762,  2764,  2766,  2768,  2772,  2775,  2778,  2780,\n+  2782,  2784,  2786,  2793,  2797,  2802,  2806,  2811,  2813,  2817,\n+  2820,  2822,  2825,  2827,  2828,  2831,  2833,  2835,  2842,  2853,\n+  2859,  2865,  2879,  2881,  2885,  2899,  2901,  2903,  2907,  2913,\n+  2926,  2929,  2934,  2947,  2953,  2955,  2956,  2957,  2965,  2970,\n+  2979,  2980,  2984,  2987,  2993,  2999,  3002,  3004,  3006,  3008,\n+  3012,  3016,  3020,  3023,  3027,  3029,  3038,  3041,  3043,  3045,\n+  3047,  3049,  3051,  3053,  3055,  3059,  3063,  3067,  3071,  3073,\n+  3075,  3077,  3079,  3081,  3083,  3085,  3087,  3095,  3097,  3098,\n+  3099,  3102,  3108,  3110,  3115,  3117,  3120,  3133,  3136,  3139,\n+  3143,  3146,  3153,  3155,  3158,  3160,  3162,  3165,  3168,  3171,\n+  3174,  3176,  3179,  3183,  3185,  3191,  3193,  3194,  3196,  3201,\n+  3203,  3205,  3207,  3209,  3212,  3213,  3215,  3218,  3219,  3222,\n+  3222,  3225,  3225,  3228,  3228,  3230,  3232,  3234,  3236,  3242,\n+  3248,  3251,  3254,  3260,  3262,  3263,  3266,  3268,  3269,  3270,\n+  3272,  3275,  3278,  3281,  3287,  3291,  3293,  3296,  3298,  3301,\n+  3305,  3307,  3310,  3312,  3315,  3332,  3340,  3343,  3345,  3347,\n+  3351,  3354,  3355,  3363,  3367,  3371,  3374,  3375,  3381,  3384,\n+  3387,  3389,  3393,  3398,  3401,  3411,  3416,  3417,  3424,  3427,\n+  3430,  3432,  3435,  3437,  3447,  3461,  3465,  3468,  3470,  3474,\n+  3478,  3481,  3484,  3486,  3490,  3492,  3499,  3506,  3509,  3513,\n+  3517,  3521,  3527,  3531,  3536,  3538,  3541,  3546,  3552,  3563,\n+  3566,  3568,  3572,  3580,  3583,  3587,  3590,  3592,  3594,  3600,\n+  3605,  3608,  3610,  3612,  3614,  3616,  3618,  3620,  3622,  3624,\n+  3626,  3628,  3630,  3632,  3634,  3636,  3638,  3640,  3642,  3644,\n+  3646,  3648,  3650,  3652,  3654,  3656,  3658,  3660,  3662,  3664,\n+  3666,  3668,  3670,  3673,  3675\n };\n #endif\n \n@@ -5236,7 +5236,7 @@ case 200:\n case 201:\n #line 1035 \"parse.y\"\n { \n-\t\t  cp_finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-3].ttype, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  cp_finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-3].ttype, LOOKUP_ONLYCONVERTING);\n \t\t  yyval.ttype = convert_from_reference (yyvsp[-1].ttype); \n \t\t  if (TREE_CODE (TREE_TYPE (yyval.ttype)) == ARRAY_TYPE)\n \t\t    cp_error (\"definition of array `%#D' in condition\", yyval.ttype); \n@@ -5639,34 +5639,30 @@ case 305:\n case 308:\n #line 1383 \"parse.y\"\n {\n-\t\t  if (processing_template_decl)\n-\t\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n \t\t  yyval.ttype = combine_strings (yyval.ttype);\n \t\t  /* combine_strings doesn't set up TYPE_MAIN_VARIANT of\n \t\t     a const array the way we want, so fix it.  */\n \t\t  if (flag_const_strings)\n \t\t    TREE_TYPE (yyval.ttype) = build_cplus_array_type\n \t\t      (TREE_TYPE (TREE_TYPE (yyval.ttype)),\n \t\t       TYPE_DOMAIN (TREE_TYPE (yyval.ttype)));\n-\t\t  if (processing_template_decl)\n-\t\t    pop_obstacks ();\n \t\t;\n     break;}\n case 309:\n-#line 1397 \"parse.y\"\n+#line 1393 \"parse.y\"\n { yyval.ttype = finish_parenthesized_expr (yyvsp[-1].ttype); ;\n     break;}\n case 310:\n-#line 1399 \"parse.y\"\n+#line 1395 \"parse.y\"\n { yyvsp[-1].ttype = reparse_decl_as_expr (NULL_TREE, yyvsp[-1].ttype);\n \t\t  yyval.ttype = finish_parenthesized_expr (yyvsp[-1].ttype); ;\n     break;}\n case 311:\n-#line 1402 \"parse.y\"\n+#line 1398 \"parse.y\"\n { yyval.ttype = error_mark_node; ;\n     break;}\n case 312:\n-#line 1404 \"parse.y\"\n+#line 1400 \"parse.y\"\n { tree scope = current_scope ();\n \t\t  if (!scope || TREE_CODE (scope) != FUNCTION_DECL)\n \t\t    {\n@@ -5679,43 +5675,43 @@ case 312:\n \t\t;\n     break;}\n case 313:\n-#line 1415 \"parse.y\"\n+#line 1411 \"parse.y\"\n { yyval.ttype = finish_stmt_expr (yyvsp[-2].ttype); ;\n     break;}\n case 314:\n-#line 1420 \"parse.y\"\n+#line 1416 \"parse.y\"\n { yyval.ttype = finish_call_expr (yyvsp[-3].ttype, yyvsp[-1].ttype, 1); ;\n     break;}\n case 315:\n-#line 1422 \"parse.y\"\n+#line 1418 \"parse.y\"\n { yyval.ttype = finish_call_expr (yyvsp[-1].ttype, NULL_TREE, 1); ;\n     break;}\n case 316:\n-#line 1424 \"parse.y\"\n+#line 1420 \"parse.y\"\n { yyval.ttype = finish_call_expr (yyvsp[-3].ttype, yyvsp[-1].ttype, 0); ;\n     break;}\n case 317:\n-#line 1426 \"parse.y\"\n+#line 1422 \"parse.y\"\n { yyval.ttype = finish_call_expr (yyvsp[-1].ttype, NULL_TREE, 0); ;\n     break;}\n case 318:\n-#line 1428 \"parse.y\"\n+#line 1424 \"parse.y\"\n { yyval.ttype = grok_array_decl (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 319:\n-#line 1430 \"parse.y\"\n+#line 1426 \"parse.y\"\n { yyval.ttype = finish_increment_expr (yyvsp[-1].ttype, POSTINCREMENT_EXPR); ;\n     break;}\n case 320:\n-#line 1432 \"parse.y\"\n+#line 1428 \"parse.y\"\n { yyval.ttype = finish_increment_expr (yyvsp[-1].ttype, POSTDECREMENT_EXPR); ;\n     break;}\n case 321:\n-#line 1435 \"parse.y\"\n+#line 1431 \"parse.y\"\n { yyval.ttype = finish_this_expr (); ;\n     break;}\n case 322:\n-#line 1437 \"parse.y\"\n+#line 1433 \"parse.y\"\n {\n \t\t  /* This is a C cast in C++'s `functional' notation\n \t\t     using the \"implicit int\" extension so that:\n@@ -5728,49 +5724,49 @@ case 322:\n \t\t;\n     break;}\n case 324:\n-#line 1449 \"parse.y\"\n+#line 1445 \"parse.y\"\n { tree type = groktypename (yyvsp[-4].ftype.t);\n \t\t  check_for_new_type (\"dynamic_cast\", yyvsp[-4].ftype);\n \t\t  yyval.ttype = build_dynamic_cast (type, yyvsp[-1].ttype); ;\n     break;}\n case 325:\n-#line 1453 \"parse.y\"\n+#line 1449 \"parse.y\"\n { tree type = groktypename (yyvsp[-4].ftype.t);\n \t\t  check_for_new_type (\"static_cast\", yyvsp[-4].ftype);\n \t\t  yyval.ttype = build_static_cast (type, yyvsp[-1].ttype); ;\n     break;}\n case 326:\n-#line 1457 \"parse.y\"\n+#line 1453 \"parse.y\"\n { tree type = groktypename (yyvsp[-4].ftype.t);\n \t\t  check_for_new_type (\"reinterpret_cast\", yyvsp[-4].ftype);\n \t\t  yyval.ttype = build_reinterpret_cast (type, yyvsp[-1].ttype); ;\n     break;}\n case 327:\n-#line 1461 \"parse.y\"\n+#line 1457 \"parse.y\"\n { tree type = groktypename (yyvsp[-4].ftype.t);\n \t\t  check_for_new_type (\"const_cast\", yyvsp[-4].ftype);\n \t\t  yyval.ttype = build_const_cast (type, yyvsp[-1].ttype); ;\n     break;}\n case 328:\n-#line 1465 \"parse.y\"\n+#line 1461 \"parse.y\"\n { yyval.ttype = build_x_typeid (yyvsp[-1].ttype); ;\n     break;}\n case 329:\n-#line 1467 \"parse.y\"\n+#line 1463 \"parse.y\"\n { tree type = groktypename (yyvsp[-1].ftype.t);\n \t\t  check_for_new_type (\"typeid\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = get_typeid (TYPE_MAIN_VARIANT (type)); ;\n     break;}\n case 330:\n-#line 1471 \"parse.y\"\n+#line 1467 \"parse.y\"\n { yyval.ttype = do_scoped_id (yyvsp[0].ttype, 1); ;\n     break;}\n case 331:\n-#line 1473 \"parse.y\"\n+#line 1469 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 332:\n-#line 1475 \"parse.y\"\n+#line 1471 \"parse.y\"\n {\n \t\t  got_scope = NULL_TREE;\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n@@ -5780,321 +5776,321 @@ case 332:\n \t\t;\n     break;}\n case 333:\n-#line 1483 \"parse.y\"\n+#line 1479 \"parse.y\"\n { yyval.ttype = build_offset_ref (OP0 (yyval.ttype), OP1 (yyval.ttype)); ;\n     break;}\n case 334:\n-#line 1485 \"parse.y\"\n+#line 1481 \"parse.y\"\n { yyval.ttype = finish_qualified_call_expr (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 335:\n-#line 1487 \"parse.y\"\n+#line 1483 \"parse.y\"\n { yyval.ttype = finish_qualified_call_expr (yyvsp[-1].ttype, NULL_TREE); ;\n     break;}\n case 336:\n-#line 1489 \"parse.y\"\n+#line 1485 \"parse.y\"\n { \n \t\t  yyval.ttype = build_x_component_ref (yyval.ttype, yyvsp[0].ttype, NULL_TREE, 1); \n \t\t;\n     break;}\n case 337:\n-#line 1493 \"parse.y\"\n+#line 1489 \"parse.y\"\n { yyval.ttype = finish_object_call_expr (yyvsp[-3].ttype, yyvsp[-4].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 338:\n-#line 1495 \"parse.y\"\n+#line 1491 \"parse.y\"\n { yyval.ttype = finish_object_call_expr (yyvsp[-1].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 339:\n-#line 1497 \"parse.y\"\n+#line 1493 \"parse.y\"\n { yyval.ttype = build_x_component_ref (yyval.ttype, yyvsp[0].ttype, NULL_TREE, 1); ;\n     break;}\n case 340:\n-#line 1499 \"parse.y\"\n+#line 1495 \"parse.y\"\n { if (processing_template_decl)\n \t\t    yyval.ttype = build_min_nt (COMPONENT_REF, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  else\n \t\t    yyval.ttype = build_object_ref (yyval.ttype, OP0 (yyvsp[0].ttype), OP1 (yyvsp[0].ttype)); ;\n     break;}\n case 341:\n-#line 1504 \"parse.y\"\n+#line 1500 \"parse.y\"\n { yyval.ttype = finish_object_call_expr (yyvsp[-3].ttype, yyvsp[-4].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 342:\n-#line 1506 \"parse.y\"\n+#line 1502 \"parse.y\"\n { yyval.ttype = finish_object_call_expr (yyvsp[-1].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 343:\n-#line 1508 \"parse.y\"\n+#line 1504 \"parse.y\"\n { yyval.ttype = finish_qualified_object_call_expr (yyvsp[-3].ttype, yyvsp[-4].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 344:\n-#line 1510 \"parse.y\"\n+#line 1506 \"parse.y\"\n { yyval.ttype = finish_qualified_object_call_expr (yyvsp[-1].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 345:\n-#line 1513 \"parse.y\"\n+#line 1509 \"parse.y\"\n { yyval.ttype = finish_pseudo_destructor_call_expr (yyvsp[-3].ttype, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 346:\n-#line 1515 \"parse.y\"\n+#line 1511 \"parse.y\"\n { yyval.ttype = finish_pseudo_destructor_call_expr (yyvsp[-5].ttype, yyvsp[-4].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 347:\n-#line 1517 \"parse.y\"\n+#line 1513 \"parse.y\"\n {\n \t\t  yyval.ttype = error_mark_node;\n \t\t;\n     break;}\n case 348:\n-#line 1562 \"parse.y\"\n+#line 1558 \"parse.y\"\n { yyval.itype = 0; ;\n     break;}\n case 349:\n-#line 1564 \"parse.y\"\n+#line 1560 \"parse.y\"\n { got_scope = NULL_TREE; yyval.itype = 1; ;\n     break;}\n case 350:\n-#line 1569 \"parse.y\"\n+#line 1565 \"parse.y\"\n { yyval.itype = 0; ;\n     break;}\n case 351:\n-#line 1571 \"parse.y\"\n+#line 1567 \"parse.y\"\n { got_scope = NULL_TREE; yyval.itype = 1; ;\n     break;}\n case 352:\n-#line 1576 \"parse.y\"\n+#line 1572 \"parse.y\"\n { yyval.ttype = boolean_true_node; ;\n     break;}\n case 353:\n-#line 1578 \"parse.y\"\n+#line 1574 \"parse.y\"\n { yyval.ttype = boolean_false_node; ;\n     break;}\n case 355:\n-#line 1585 \"parse.y\"\n+#line 1581 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 356:\n-#line 1590 \"parse.y\"\n+#line 1586 \"parse.y\"\n {\n \t\t  if (! current_function_parms_stored)\n \t\t    store_parm_decls ();\n \t\t  setup_vtbl_ptr ();\n \t\t;\n     break;}\n case 357:\n-#line 1599 \"parse.y\"\n+#line 1595 \"parse.y\"\n { got_object = TREE_TYPE (yyval.ttype); ;\n     break;}\n case 358:\n-#line 1601 \"parse.y\"\n+#line 1597 \"parse.y\"\n {\n \t\t  yyval.ttype = build_x_arrow (yyval.ttype); \n \t\t  got_object = TREE_TYPE (yyval.ttype);\n \t\t;\n     break;}\n case 359:\n-#line 1609 \"parse.y\"\n+#line 1605 \"parse.y\"\n {\n \t\t  if (yyvsp[-2].ftype.t && IS_AGGR_TYPE_CODE (TREE_CODE (yyvsp[-2].ftype.t)))\n \t\t    note_got_semicolon (yyvsp[-2].ftype.t);\n \t\t;\n     break;}\n case 360:\n-#line 1614 \"parse.y\"\n+#line 1610 \"parse.y\"\n {\n \t\t  note_list_got_semicolon (yyvsp[-2].ftype.t);\n \t\t;\n     break;}\n case 361:\n-#line 1618 \"parse.y\"\n+#line 1614 \"parse.y\"\n {;\n     break;}\n case 362:\n-#line 1620 \"parse.y\"\n+#line 1616 \"parse.y\"\n {\n \t\t  shadow_tag (yyvsp[-1].ftype.t);\n \t\t  note_list_got_semicolon (yyvsp[-1].ftype.t);\n \t\t;\n     break;}\n case 363:\n-#line 1625 \"parse.y\"\n+#line 1621 \"parse.y\"\n { warning (\"empty declaration\"); ;\n     break;}\n case 364:\n-#line 1627 \"parse.y\"\n+#line 1623 \"parse.y\"\n { pedantic = yyvsp[-1].itype; ;\n     break;}\n case 367:\n-#line 1641 \"parse.y\"\n+#line 1637 \"parse.y\"\n { yyval.ttype = make_call_declarator (NULL_TREE, empty_parms (),\n \t\t\t\t\t     NULL_TREE, NULL_TREE); ;\n     break;}\n case 368:\n-#line 1644 \"parse.y\"\n+#line 1640 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, empty_parms (), NULL_TREE,\n \t\t\t\t\t     NULL_TREE); ;\n     break;}\n case 369:\n-#line 1651 \"parse.y\"\n+#line 1647 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 370:\n-#line 1654 \"parse.y\"\n+#line 1650 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 371:\n-#line 1657 \"parse.y\"\n+#line 1653 \"parse.y\"\n { yyval.ftype.t = build_decl_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 372:\n-#line 1661 \"parse.y\"\n+#line 1657 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[0].ftype.t, NULL_TREE);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 373:\n-#line 1664 \"parse.y\"\n+#line 1660 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[0].ftype.t, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 376:\n-#line 1680 \"parse.y\"\n+#line 1676 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[0].ftype.t, yyvsp[-1].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 377:\n-#line 1683 \"parse.y\"\n+#line 1679 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 378:\n-#line 1686 \"parse.y\"\n+#line 1682 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-2].ftype.t, chainon (yyvsp[-1].ttype, yyvsp[0].ttype)); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-2].ftype.new_type_flag; ;\n     break;}\n case 379:\n-#line 1689 \"parse.y\"\n+#line 1685 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-1].ftype.t, chainon (yyvsp[0].ttype, yyvsp[-2].ttype)); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 380:\n-#line 1692 \"parse.y\"\n+#line 1688 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-1].ftype.t, chainon (yyvsp[0].ttype, yyvsp[-2].ttype)); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 381:\n-#line 1695 \"parse.y\"\n+#line 1691 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-2].ftype.t,\n \t\t\t\t\t chainon (yyvsp[-1].ttype, chainon (yyvsp[0].ttype, yyvsp[-3].ttype))); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-2].ftype.new_type_flag; ;\n     break;}\n case 382:\n-#line 1702 \"parse.y\"\n+#line 1698 \"parse.y\"\n { if (extra_warnings)\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER (yyval.ttype));\n \t\t  yyval.ttype = build_decl_list (NULL_TREE, yyval.ttype); ;\n     break;}\n case 383:\n-#line 1707 \"parse.y\"\n+#line 1703 \"parse.y\"\n { yyval.ttype = decl_tree_cons (NULL_TREE, yyvsp[0].ftype.t, yyval.ttype); ;\n     break;}\n case 384:\n-#line 1709 \"parse.y\"\n+#line 1705 \"parse.y\"\n { if (extra_warnings)\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER (yyvsp[0].ttype));\n \t\t  yyval.ttype = decl_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 385:\n-#line 1714 \"parse.y\"\n+#line 1710 \"parse.y\"\n { yyval.ttype = decl_tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 386:\n-#line 1716 \"parse.y\"\n+#line 1712 \"parse.y\"\n { yyval.ttype = decl_tree_cons (yyvsp[0].ttype, NULL_TREE, NULL_TREE); ;\n     break;}\n case 387:\n-#line 1735 \"parse.y\"\n+#line 1731 \"parse.y\"\n { yyval.ttype = yyvsp[0].ftype.t; TREE_STATIC (yyval.ttype) = 1; ;\n     break;}\n case 388:\n-#line 1737 \"parse.y\"\n+#line 1733 \"parse.y\"\n { yyval.ttype = hash_tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 389:\n-#line 1739 \"parse.y\"\n+#line 1735 \"parse.y\"\n { yyval.ttype = hash_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype);\n \t\t  TREE_STATIC (yyval.ttype) = 1; ;\n     break;}\n case 390:\n-#line 1742 \"parse.y\"\n+#line 1738 \"parse.y\"\n { if (extra_warnings && TREE_STATIC (yyval.ttype))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER (yyvsp[0].ttype));\n \t\t  yyval.ttype = hash_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype);\n \t\t  TREE_STATIC (yyval.ttype) = TREE_STATIC (yyvsp[-1].ttype); ;\n     break;}\n case 391:\n-#line 1748 \"parse.y\"\n+#line 1744 \"parse.y\"\n { yyval.ttype = hash_tree_cons (yyvsp[0].ttype, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 392:\n-#line 1750 \"parse.y\"\n+#line 1746 \"parse.y\"\n { yyval.ttype = hash_tree_cons (yyvsp[0].ttype, NULL_TREE, NULL_TREE); ;\n     break;}\n case 393:\n-#line 1761 \"parse.y\"\n+#line 1757 \"parse.y\"\n { yyval.ftype.t = build_decl_list (NULL_TREE, yyvsp[0].ftype.t); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 394:\n-#line 1764 \"parse.y\"\n+#line 1760 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[0].ftype.t, yyvsp[-1].ftype.t); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 395:\n-#line 1767 \"parse.y\"\n+#line 1763 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 396:\n-#line 1770 \"parse.y\"\n+#line 1766 \"parse.y\"\n { yyval.ftype.t = decl_tree_cons (NULL_TREE, yyvsp[-1].ftype.t, chainon (yyvsp[0].ttype, yyvsp[-2].ftype.t)); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-2].ftype.new_type_flag; ;\n     break;}\n case 397:\n-#line 1776 \"parse.y\"\n+#line 1772 \"parse.y\"\n { yyval.ttype = build_decl_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 398:\n-#line 1778 \"parse.y\"\n+#line 1774 \"parse.y\"\n { yyval.ttype = decl_tree_cons (NULL_TREE, yyvsp[0].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 400:\n-#line 1788 \"parse.y\"\n+#line 1784 \"parse.y\"\n { yyval.ftype.t = yyvsp[0].ttype; yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 401:\n-#line 1790 \"parse.y\"\n+#line 1786 \"parse.y\"\n { yyval.ftype.t = yyvsp[0].ttype; yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 402:\n-#line 1792 \"parse.y\"\n+#line 1788 \"parse.y\"\n { yyval.ftype.t = finish_typeof (yyvsp[-1].ttype);\n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 403:\n-#line 1795 \"parse.y\"\n+#line 1791 \"parse.y\"\n { yyval.ftype.t = groktypename (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 404:\n-#line 1798 \"parse.y\"\n+#line 1794 \"parse.y\"\n { tree type = TREE_TYPE (yyvsp[-1].ttype);\n \n                   yyval.ftype.new_type_flag = 0;\n@@ -6111,7 +6107,7 @@ case 404:\n \t\t;\n     break;}\n case 405:\n-#line 1813 \"parse.y\"\n+#line 1809 \"parse.y\"\n { tree type = groktypename (yyvsp[-1].ftype.t);\n \n                   yyval.ftype.new_type_flag = 0;\n@@ -6128,282 +6124,282 @@ case 405:\n \t\t;\n     break;}\n case 406:\n-#line 1833 \"parse.y\"\n+#line 1829 \"parse.y\"\n { yyval.ftype.t = yyvsp[0].ttype; yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 407:\n-#line 1835 \"parse.y\"\n+#line 1831 \"parse.y\"\n { yyval.ftype.t = yyvsp[0].ttype; yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 410:\n-#line 1842 \"parse.y\"\n+#line 1838 \"parse.y\"\n { check_multiple_declarators (); ;\n     break;}\n case 412:\n-#line 1848 \"parse.y\"\n+#line 1844 \"parse.y\"\n { check_multiple_declarators (); ;\n     break;}\n case 414:\n-#line 1854 \"parse.y\"\n+#line 1850 \"parse.y\"\n { check_multiple_declarators (); ;\n     break;}\n case 415:\n-#line 1859 \"parse.y\"\n+#line 1855 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 416:\n-#line 1861 \"parse.y\"\n+#line 1857 \"parse.y\"\n { if (TREE_CHAIN (yyvsp[-1].ttype)) yyvsp[-1].ttype = combine_strings (yyvsp[-1].ttype); yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 417:\n-#line 1866 \"parse.y\"\n+#line 1862 \"parse.y\"\n { yyval.ttype = start_decl (yyvsp[-3].ttype, current_declspecs, 1,\n \t\t\t\t\t  yyvsp[-1].ttype, prefix_attributes); ;\n     break;}\n case 418:\n-#line 1870 \"parse.y\"\n-{ cp_finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype, 1, LOOKUP_ONLYCONVERTING); ;\n+#line 1866 \"parse.y\"\n+{ cp_finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype, LOOKUP_ONLYCONVERTING); ;\n     break;}\n case 419:\n-#line 1872 \"parse.y\"\n+#line 1868 \"parse.y\"\n { yyval.ttype = start_decl (yyvsp[-2].ttype, current_declspecs, 0,\n \t\t\t\t\t  yyvsp[0].ttype, prefix_attributes);\n-\t\t  cp_finish_decl (yyval.ttype, NULL_TREE, yyvsp[-1].ttype, 1, 0); ;\n+\t\t  cp_finish_decl (yyval.ttype, NULL_TREE, yyvsp[-1].ttype, 0); ;\n     break;}\n case 420:\n-#line 1885 \"parse.y\"\n+#line 1881 \"parse.y\"\n { parse_decl (yyvsp[-3].ttype, yyvsp[-4].ttype, yyvsp[-1].ttype, 1, &yyval.ttype); ;\n     break;}\n case 421:\n-#line 1889 \"parse.y\"\n-{ cp_finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype, 1,\n+#line 1885 \"parse.y\"\n+{ cp_finish_decl (yyvsp[-1].ttype, yyvsp[0].ttype, yyvsp[-4].ttype,\n \t\t\t\t  LOOKUP_ONLYCONVERTING); ;\n     break;}\n case 422:\n-#line 1892 \"parse.y\"\n+#line 1888 \"parse.y\"\n { tree d;\n \t\t  parse_decl (yyvsp[-2].ttype, yyvsp[-3].ttype, yyvsp[0].ttype, 0, &d);\n-\t\t  cp_finish_decl (d, NULL_TREE, yyvsp[-1].ttype, 1, 0); ;\n+\t\t  cp_finish_decl (d, NULL_TREE, yyvsp[-1].ttype, 0); ;\n     break;}\n case 423:\n-#line 1899 \"parse.y\"\n+#line 1895 \"parse.y\"\n {;\n     break;}\n case 424:\n-#line 1904 \"parse.y\"\n+#line 1900 \"parse.y\"\n {;\n     break;}\n case 425:\n-#line 1909 \"parse.y\"\n+#line 1905 \"parse.y\"\n { /* Set things up as initdcl0_innards expects.  */\n \t      yyvsp[0].ttype = yyvsp[-1].ttype; \n               yyvsp[-1].ttype = NULL_TREE; ;\n     break;}\n case 426:\n-#line 1913 \"parse.y\"\n+#line 1909 \"parse.y\"\n {;\n     break;}\n case 427:\n-#line 1915 \"parse.y\"\n+#line 1911 \"parse.y\"\n { tree d;\n \t\t  parse_decl(yyvsp[-2].ttype, NULL_TREE, yyvsp[0].ttype, 0, &d);\n-\t\t  cp_finish_decl (d, NULL_TREE, yyvsp[-1].ttype, 1, 0); ;\n+\t\t  cp_finish_decl (d, NULL_TREE, yyvsp[-1].ttype, 0); ;\n     break;}\n case 428:\n-#line 1924 \"parse.y\"\n+#line 1920 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 429:\n-#line 1926 \"parse.y\"\n+#line 1922 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 430:\n-#line 1931 \"parse.y\"\n+#line 1927 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 431:\n-#line 1933 \"parse.y\"\n+#line 1929 \"parse.y\"\n { yyval.ttype = chainon (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 432:\n-#line 1938 \"parse.y\"\n+#line 1934 \"parse.y\"\n { yyval.ttype = yyvsp[-2].ttype; ;\n     break;}\n case 433:\n-#line 1943 \"parse.y\"\n+#line 1939 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 434:\n-#line 1945 \"parse.y\"\n+#line 1941 \"parse.y\"\n { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 435:\n-#line 1950 \"parse.y\"\n+#line 1946 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 436:\n-#line 1952 \"parse.y\"\n+#line 1948 \"parse.y\"\n { yyval.ttype = build_tree_list (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 437:\n-#line 1954 \"parse.y\"\n+#line 1950 \"parse.y\"\n { yyval.ttype = build_tree_list (yyvsp[-3].ttype, build_tree_list (NULL_TREE, yyvsp[-1].ttype)); ;\n     break;}\n case 438:\n-#line 1956 \"parse.y\"\n+#line 1952 \"parse.y\"\n { yyval.ttype = build_tree_list (yyvsp[-5].ttype, tree_cons (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype)); ;\n     break;}\n case 439:\n-#line 1958 \"parse.y\"\n+#line 1954 \"parse.y\"\n { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 444:\n-#line 1974 \"parse.y\"\n+#line 1970 \"parse.y\"\n { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 445:\n-#line 1976 \"parse.y\"\n+#line 1972 \"parse.y\"\n { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 446:\n-#line 1981 \"parse.y\"\n+#line 1977 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 447:\n-#line 1983 \"parse.y\"\n+#line 1979 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 449:\n-#line 1991 \"parse.y\"\n+#line 1987 \"parse.y\"\n { yyval.ttype = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);\n \t\t  TREE_HAS_CONSTRUCTOR (yyval.ttype) = 1; ;\n     break;}\n case 450:\n-#line 1994 \"parse.y\"\n+#line 1990 \"parse.y\"\n { yyval.ttype = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (yyvsp[-1].ttype));\n \t\t  TREE_HAS_CONSTRUCTOR (yyval.ttype) = 1; ;\n     break;}\n case 451:\n-#line 1997 \"parse.y\"\n+#line 1993 \"parse.y\"\n { yyval.ttype = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (yyvsp[-2].ttype));\n \t\t  TREE_HAS_CONSTRUCTOR (yyval.ttype) = 1; ;\n     break;}\n case 452:\n-#line 2000 \"parse.y\"\n+#line 1996 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 453:\n-#line 2007 \"parse.y\"\n+#line 2003 \"parse.y\"\n { yyval.ttype = build_tree_list (NULL_TREE, yyval.ttype); ;\n     break;}\n case 454:\n-#line 2009 \"parse.y\"\n+#line 2005 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 455:\n-#line 2012 \"parse.y\"\n+#line 2008 \"parse.y\"\n { yyval.ttype = build_expr_list (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 456:\n-#line 2014 \"parse.y\"\n+#line 2010 \"parse.y\"\n { yyval.ttype = build_expr_list (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 457:\n-#line 2016 \"parse.y\"\n+#line 2012 \"parse.y\"\n { yyval.ttype = tree_cons (yyvsp[-2].ttype, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 458:\n-#line 2021 \"parse.y\"\n+#line 2017 \"parse.y\"\n { start_function (NULL_TREE, yyvsp[0].pi->fndecl, NULL_TREE, \n \t\t\t\t  (SF_DEFAULT | SF_PRE_PARSED \n \t\t\t\t   | SF_INCLASS_INLINE));\n \t\t  reinit_parse_for_function (); ;\n     break;}\n case 459:\n-#line 2028 \"parse.y\"\n+#line 2024 \"parse.y\"\n {\n \t\t  expand_body (finish_function (lineno, (int)yyvsp[-1].itype | 2));\n \t\t  process_next_inline (yyvsp[-3].pi);\n \t\t;\n     break;}\n case 460:\n-#line 2033 \"parse.y\"\n+#line 2029 \"parse.y\"\n { \n \t\t  expand_body (finish_function (lineno, (int)yyvsp[0].itype | 2)); \n                   process_next_inline (yyvsp[-2].pi);\n \t\t;\n     break;}\n case 461:\n-#line 2038 \"parse.y\"\n+#line 2034 \"parse.y\"\n { \n \t\t  finish_function (lineno, 2); \n \t\t  process_next_inline (yyvsp[-2].pi); ;\n     break;}\n case 464:\n-#line 2052 \"parse.y\"\n+#line 2048 \"parse.y\"\n { replace_defarg (yyvsp[-2].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 465:\n-#line 2054 \"parse.y\"\n+#line 2050 \"parse.y\"\n { replace_defarg (yyvsp[-2].ttype, error_mark_node); ;\n     break;}\n case 467:\n-#line 2059 \"parse.y\"\n+#line 2055 \"parse.y\"\n { do_pending_defargs (); ;\n     break;}\n case 468:\n-#line 2061 \"parse.y\"\n+#line 2057 \"parse.y\"\n { do_pending_defargs (); ;\n     break;}\n case 469:\n-#line 2066 \"parse.y\"\n+#line 2062 \"parse.y\"\n { yyval.ttype = current_enum_type;\n \t\t  current_enum_type = start_enum (yyvsp[-1].ttype); ;\n     break;}\n case 470:\n-#line 2069 \"parse.y\"\n+#line 2065 \"parse.y\"\n { TYPE_VALUES (current_enum_type) = yyvsp[-1].ttype;\n \t\t  yyval.ftype.t = finish_enum (current_enum_type);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t  current_enum_type = yyvsp[-2].ttype;\n \t\t  check_for_missing_semicolon (yyval.ftype.t); ;\n     break;}\n case 471:\n-#line 2075 \"parse.y\"\n+#line 2071 \"parse.y\"\n { yyval.ttype = current_enum_type;\n \t\t  current_enum_type = start_enum (make_anon_name ()); ;\n     break;}\n case 472:\n-#line 2078 \"parse.y\"\n+#line 2074 \"parse.y\"\n { TYPE_VALUES (current_enum_type) = yyvsp[-1].ttype;\n \t\t  yyval.ftype.t = finish_enum (current_enum_type);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t  current_enum_type = yyvsp[-2].ttype;\n \t\t  check_for_missing_semicolon (yyval.ftype.t); ;\n     break;}\n case 473:\n-#line 2084 \"parse.y\"\n+#line 2080 \"parse.y\"\n { yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 474:\n-#line 2087 \"parse.y\"\n+#line 2083 \"parse.y\"\n { yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 475:\n-#line 2090 \"parse.y\"\n+#line 2086 \"parse.y\"\n { yyval.ftype.t = yyvsp[0].ttype;\n \t\t  yyval.ftype.new_type_flag = 0; \n \t\t  if (!processing_template_decl)\n \t\t    cp_pedwarn (\"using `typename' outside of template\"); ;\n     break;}\n case 476:\n-#line 2096 \"parse.y\"\n+#line 2092 \"parse.y\"\n { yyvsp[-1].ftype.t = begin_class_definition (yyvsp[-1].ftype.t); ;\n     break;}\n case 477:\n-#line 2098 \"parse.y\"\n+#line 2094 \"parse.y\"\n { \n \t\t  int semi;\n \n@@ -6416,21 +6412,21 @@ case 477:\n \t\t;\n     break;}\n case 478:\n-#line 2109 \"parse.y\"\n+#line 2105 \"parse.y\"\n {\n \t\t  begin_inline_definitions ();\n \t\t;\n     break;}\n case 479:\n-#line 2113 \"parse.y\"\n+#line 2109 \"parse.y\"\n {\n \t\t  finish_inline_definitions ();\n \t\t  yyval.ftype.t = yyvsp[-3].ttype;\n \t\t  yyval.ftype.new_type_flag = 1; \n \t\t;\n     break;}\n case 480:\n-#line 2119 \"parse.y\"\n+#line 2115 \"parse.y\"\n {\n \t\t  if (yyvsp[0].ftype.new_type_flag && yyvsp[0].ftype.t != error_mark_node)\n \t\t    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (yyvsp[0].ftype.t)));\n@@ -6454,83 +6450,83 @@ case 480:\n \t\t;\n     break;}\n case 484:\n-#line 2150 \"parse.y\"\n+#line 2146 \"parse.y\"\n { if (pedantic && !in_system_header)\n \t\t    pedwarn (\"comma at end of enumerator list\"); ;\n     break;}\n case 486:\n-#line 2157 \"parse.y\"\n+#line 2153 \"parse.y\"\n { error (\"storage class specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER (yyvsp[0].ttype)); ;\n     break;}\n case 487:\n-#line 2159 \"parse.y\"\n+#line 2155 \"parse.y\"\n { error (\"type specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER (yyvsp[0].ttype)); ;\n     break;}\n case 488:\n-#line 2161 \"parse.y\"\n+#line 2157 \"parse.y\"\n { error (\"type qualifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER (yyvsp[0].ttype)); ;\n     break;}\n case 489:\n-#line 2163 \"parse.y\"\n+#line 2159 \"parse.y\"\n { error (\"no body nor ';' separates two class, struct or union declarations\"); ;\n     break;}\n case 490:\n-#line 2165 \"parse.y\"\n+#line 2161 \"parse.y\"\n { yyval.ttype = build_decl_list (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 491:\n-#line 2170 \"parse.y\"\n+#line 2166 \"parse.y\"\n { \n \t\t  current_aggr = yyvsp[-1].ttype; \n \t\t  yyval.ttype = yyvsp[0].ttype; \n \t\t;\n     break;}\n case 492:\n-#line 2178 \"parse.y\"\n+#line 2174 \"parse.y\"\n { current_aggr = yyval.ttype; yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 493:\n-#line 2180 \"parse.y\"\n+#line 2176 \"parse.y\"\n { yyungetc ('{', 1); ;\n     break;}\n case 494:\n-#line 2182 \"parse.y\"\n+#line 2178 \"parse.y\"\n { yyungetc (':', 1); ;\n     break;}\n case 495:\n-#line 2187 \"parse.y\"\n+#line 2183 \"parse.y\"\n {\n \t\t  current_aggr = yyvsp[-2].ttype;\n \t\t  yyval.ftype.t = handle_class_head (yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t;\n     break;}\n case 496:\n-#line 2193 \"parse.y\"\n+#line 2189 \"parse.y\"\n {\n \t\t  current_aggr = yyvsp[-3].ttype;\n \t\t  yyval.ftype.t = handle_class_head (yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t;\n     break;}\n case 497:\n-#line 2199 \"parse.y\"\n+#line 2195 \"parse.y\"\n {\n \t\t  current_aggr = yyvsp[-2].ttype;\n \t\t  yyval.ftype.t = handle_class_head (yyvsp[-2].ttype, NULL_TREE, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = 1;\n \t\t;\n     break;}\n case 498:\n-#line 2205 \"parse.y\"\n+#line 2201 \"parse.y\"\n { \n \t\t  current_aggr = yyvsp[-1].ttype; \n \t\t  yyval.ftype.t = yyvsp[0].ttype;\n \t\t  yyval.ftype.new_type_flag = 0;\n \t\t;\n     break;}\n case 499:\n-#line 2211 \"parse.y\"\n+#line 2207 \"parse.y\"\n { \n \t\t  current_aggr = yyvsp[-2].ttype; \n \t\t  yyval.ftype.t = yyvsp[0].ttype;\n@@ -6540,18 +6536,18 @@ case 499:\n \t\t;\n     break;}\n case 500:\n-#line 2222 \"parse.y\"\n+#line 2218 \"parse.y\"\n { \n \t\t  yyval.ftype.t = xref_tag (current_aggr, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0;\n \t\t;\n     break;}\n case 501:\n-#line 2227 \"parse.y\"\n+#line 2223 \"parse.y\"\n { yyval.ttype = xref_tag (current_aggr, yyvsp[0].ttype, 0); ;\n     break;}\n case 502:\n-#line 2231 \"parse.y\"\n+#line 2227 \"parse.y\"\n { \n \t\t  yyval.ftype.t = yyvsp[-1].ttype;\n \t\t  yyval.ftype.new_type_flag = 0;\n@@ -6560,7 +6556,7 @@ case 502:\n \t\t;\n     break;}\n case 503:\n-#line 2239 \"parse.y\"\n+#line 2235 \"parse.y\"\n { \n \t\t  if (yyvsp[-1].ftype.t != error_mark_node)\n \t\t    {\n@@ -6587,53 +6583,53 @@ case 503:\n \t\t;\n     break;}\n case 504:\n-#line 2267 \"parse.y\"\n+#line 2263 \"parse.y\"\n { yyval.ttype = xref_tag (yyval.ttype, make_anon_name (), 0);\n \t\t  yyungetc ('{', 1); ;\n     break;}\n case 505:\n-#line 2277 \"parse.y\"\n+#line 2273 \"parse.y\"\n {\n \t\t  yyval.ftype.t = yyvsp[0].ttype;\n \t\t  yyval.ftype.new_type_flag = 0;\n \t\t;\n     break;}\n case 507:\n-#line 2286 \"parse.y\"\n+#line 2282 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 508:\n-#line 2288 \"parse.y\"\n+#line 2284 \"parse.y\"\n { yyungetc(':', 1); yyval.ttype = NULL_TREE; ;\n     break;}\n case 509:\n-#line 2290 \"parse.y\"\n+#line 2286 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 511:\n-#line 2296 \"parse.y\"\n+#line 2292 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 512:\n-#line 2301 \"parse.y\"\n+#line 2297 \"parse.y\"\n { yyval.ttype = finish_base_specifier (access_default_node, yyvsp[0].ttype); ;\n     break;}\n case 513:\n-#line 2303 \"parse.y\"\n+#line 2299 \"parse.y\"\n { yyval.ttype = finish_base_specifier (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 514:\n-#line 2308 \"parse.y\"\n+#line 2304 \"parse.y\"\n { if (yyval.ttype != error_mark_node) yyval.ttype = TYPE_MAIN_DECL (yyvsp[0].ttype); ;\n     break;}\n case 517:\n-#line 2315 \"parse.y\"\n+#line 2311 \"parse.y\"\n { if (yyvsp[-1].ttype != ridpointers[(int)RID_VIRTUAL])\n \t\t    cp_error (\"`%D' access\", yyvsp[-1].ttype);\n \t\t  yyval.ttype = access_default_virtual_node; ;\n     break;}\n case 518:\n-#line 2319 \"parse.y\"\n+#line 2315 \"parse.y\"\n {\n \t\t  if (yyvsp[-2].ttype != access_default_virtual_node)\n \t\t    error (\"multiple access specifiers\");\n@@ -6646,7 +6642,7 @@ case 518:\n \t\t;\n     break;}\n case 519:\n-#line 2330 \"parse.y\"\n+#line 2326 \"parse.y\"\n { if (yyvsp[-1].ttype != ridpointers[(int)RID_VIRTUAL])\n \t\t    cp_error (\"`%D' access\", yyvsp[-1].ttype);\n \t\t  else if (yyval.ttype == access_public_node)\n@@ -6660,55 +6656,55 @@ case 519:\n \t\t;\n     break;}\n case 524:\n-#line 2351 \"parse.y\"\n+#line 2347 \"parse.y\"\n {\n \t\t  current_access_specifier = yyvsp[-1].ttype;\n                 ;\n     break;}\n case 525:\n-#line 2360 \"parse.y\"\n+#line 2356 \"parse.y\"\n { \n \t\t  finish_member_declaration (yyvsp[0].ttype);\n \t\t;\n     break;}\n case 526:\n-#line 2364 \"parse.y\"\n+#line 2360 \"parse.y\"\n { \n \t\t  finish_member_declaration (yyvsp[0].ttype);\n \t\t;\n     break;}\n case 528:\n-#line 2372 \"parse.y\"\n+#line 2368 \"parse.y\"\n { error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0); ;\n     break;}\n case 529:\n-#line 2377 \"parse.y\"\n+#line 2373 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 530:\n-#line 2379 \"parse.y\"\n+#line 2375 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 531:\n-#line 2381 \"parse.y\"\n+#line 2377 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 532:\n-#line 2383 \"parse.y\"\n+#line 2379 \"parse.y\"\n { yyval.ttype = finish_method (yyval.ttype); ;\n     break;}\n case 533:\n-#line 2385 \"parse.y\"\n+#line 2381 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 534:\n-#line 2387 \"parse.y\"\n+#line 2383 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype;\n \t\t  pedantic = yyvsp[-1].itype; ;\n     break;}\n case 535:\n-#line 2390 \"parse.y\"\n+#line 2386 \"parse.y\"\n {  \n \t\t  if (yyvsp[0].ttype)\n \t\t    yyval.ttype = finish_member_template_decl (yyvsp[0].ttype);\n@@ -6720,14 +6716,14 @@ case 535:\n \t\t;\n     break;}\n case 536:\n-#line 2400 \"parse.y\"\n+#line 2396 \"parse.y\"\n { \n \t\t  yyval.ttype = finish_member_class_template (yyvsp[-1].ftype.t); \n \t\t  finish_template_decl (yyvsp[-2].ttype);\n \t\t;\n     break;}\n case 537:\n-#line 2411 \"parse.y\"\n+#line 2407 \"parse.y\"\n {\n \t\t  /* Most of the productions for component_decl only\n \t\t     allow the creation of one new member, so we call\n@@ -6750,53 +6746,53 @@ case 537:\n \t\t;\n     break;}\n case 538:\n-#line 2432 \"parse.y\"\n+#line 2428 \"parse.y\"\n { \n \t\t  if (!yyvsp[0].itype)\n \t\t    grok_x_components (yyvsp[-1].ttype);\n \t\t  yyval.ttype = NULL_TREE; \n \t\t;\n     break;}\n case 539:\n-#line 2438 \"parse.y\"\n+#line 2434 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 540:\n-#line 2441 \"parse.y\"\n+#line 2437 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 541:\n-#line 2444 \"parse.y\"\n+#line 2440 \"parse.y\"\n { yyval.ttype = grokbitfield (NULL_TREE, NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 542:\n-#line 2446 \"parse.y\"\n+#line 2442 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 543:\n-#line 2457 \"parse.y\"\n+#line 2453 \"parse.y\"\n { tree specs, attrs;\n \t\t  split_specs_attrs (yyvsp[-4].ttype, &specs, &attrs);\n \t\t  yyval.ttype = grokfield (yyvsp[-3].ttype, specs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, attrs)); ;\n     break;}\n case 544:\n-#line 2462 \"parse.y\"\n+#line 2458 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, NULL_TREE, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, NULL_TREE)); ;\n     break;}\n case 545:\n-#line 2465 \"parse.y\"\n+#line 2461 \"parse.y\"\n { yyval.ttype = do_class_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 546:\n-#line 2471 \"parse.y\"\n+#line 2467 \"parse.y\"\n { yyval.itype = 0; ;\n     break;}\n case 547:\n-#line 2473 \"parse.y\"\n+#line 2469 \"parse.y\"\n { \n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    yyvsp[0].ttype = finish_member_template_decl (yyvsp[0].ttype);\n@@ -6805,7 +6801,7 @@ case 547:\n \t\t;\n     break;}\n case 548:\n-#line 2480 \"parse.y\"\n+#line 2476 \"parse.y\"\n { \n \t\t  check_multiple_declarators ();\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n@@ -6815,11 +6811,11 @@ case 548:\n \t\t;\n     break;}\n case 549:\n-#line 2491 \"parse.y\"\n+#line 2487 \"parse.y\"\n { yyval.itype = 0; ;\n     break;}\n case 550:\n-#line 2493 \"parse.y\"\n+#line 2489 \"parse.y\"\n { \n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t    yyvsp[0].ttype = finish_member_template_decl (yyvsp[0].ttype);\n@@ -6828,7 +6824,7 @@ case 550:\n \t\t;\n     break;}\n case 551:\n-#line 2500 \"parse.y\"\n+#line 2496 \"parse.y\"\n { \n \t\t  check_multiple_declarators ();\n \t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n@@ -6838,106 +6834,106 @@ case 551:\n \t\t;\n     break;}\n case 556:\n-#line 2521 \"parse.y\"\n+#line 2517 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 557:\n-#line 2527 \"parse.y\"\n+#line 2523 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 558:\n-#line 2536 \"parse.y\"\n+#line 2532 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 559:\n-#line 2542 \"parse.y\"\n+#line 2538 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 560:\n-#line 2548 \"parse.y\"\n+#line 2544 \"parse.y\"\n { split_specs_attrs (yyvsp[-4].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-4].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 561:\n-#line 2554 \"parse.y\"\n+#line 2550 \"parse.y\"\n { split_specs_attrs (yyvsp[-3].ttype, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  yyvsp[-3].ttype = current_declspecs;\n \t\t  yyval.ttype = grokbitfield (NULL_TREE, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 562:\n-#line 2563 \"parse.y\"\n+#line 2559 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 563:\n-#line 2566 \"parse.y\"\n+#line 2562 \"parse.y\"\n { yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 564:\n-#line 2572 \"parse.y\"\n+#line 2568 \"parse.y\"\n { yyval.ttype = grokfield (yyval.ttype, current_declspecs, yyvsp[0].ttype, yyvsp[-2].ttype,\n \t\t\t\t  build_tree_list (yyvsp[-1].ttype, prefix_attributes)); ;\n     break;}\n case 565:\n-#line 2575 \"parse.y\"\n+#line 2571 \"parse.y\"\n { yyval.ttype = grokbitfield (yyval.ttype, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 566:\n-#line 2578 \"parse.y\"\n+#line 2574 \"parse.y\"\n { yyval.ttype = grokbitfield (NULL_TREE, current_declspecs, yyvsp[-1].ttype);\n \t\t  cplus_decl_attributes (yyval.ttype, yyvsp[0].ttype, prefix_attributes); ;\n     break;}\n case 568:\n-#line 2585 \"parse.y\"\n+#line 2581 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 570:\n-#line 2595 \"parse.y\"\n+#line 2591 \"parse.y\"\n { TREE_CHAIN (yyvsp[0].ttype) = yyval.ttype; yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 571:\n-#line 2600 \"parse.y\"\n+#line 2596 \"parse.y\"\n { yyval.ttype = build_enumerator (yyval.ttype, NULL_TREE, current_enum_type); ;\n     break;}\n case 572:\n-#line 2602 \"parse.y\"\n+#line 2598 \"parse.y\"\n { yyval.ttype = build_enumerator (yyval.ttype, yyvsp[0].ttype, current_enum_type); ;\n     break;}\n case 573:\n-#line 2608 \"parse.y\"\n+#line 2604 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 574:\n-#line 2611 \"parse.y\"\n+#line 2607 \"parse.y\"\n { yyval.ftype.t = build_decl_list (yyvsp[0].ftype.t, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 575:\n-#line 2616 \"parse.y\"\n+#line 2612 \"parse.y\"\n {\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n@@ -6947,93 +6943,93 @@ case 575:\n \t\t;\n     break;}\n case 576:\n-#line 2627 \"parse.y\"\n+#line 2623 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 577:\n-#line 2629 \"parse.y\"\n+#line 2625 \"parse.y\"\n { yyval.ttype = decl_tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 578:\n-#line 2634 \"parse.y\"\n+#line 2630 \"parse.y\"\n { yyval.ftype.t = hash_tree_cons (NULL_TREE, yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 579:\n-#line 2637 \"parse.y\"\n+#line 2633 \"parse.y\"\n { yyval.ftype.t = hash_tree_cons (NULL_TREE, yyvsp[0].ttype, yyvsp[-1].ftype.t); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 580:\n-#line 2647 \"parse.y\"\n+#line 2643 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 581:\n-#line 2649 \"parse.y\"\n+#line 2645 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 582:\n-#line 2651 \"parse.y\"\n+#line 2647 \"parse.y\"\n { yyval.ttype = empty_parms (); ;\n     break;}\n case 583:\n-#line 2653 \"parse.y\"\n+#line 2649 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 585:\n-#line 2661 \"parse.y\"\n+#line 2657 \"parse.y\"\n {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n \t\t  yyval.ttype = decl_tree_cons (yyvsp[-1].ttype, yyvsp[0].ttype, NULL_TREE);\n \t\t;\n     break;}\n case 586:\n-#line 2671 \"parse.y\"\n+#line 2667 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 587:\n-#line 2673 \"parse.y\"\n+#line 2669 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 588:\n-#line 2675 \"parse.y\"\n+#line 2671 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 589:\n-#line 2677 \"parse.y\"\n+#line 2673 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 590:\n-#line 2679 \"parse.y\"\n+#line 2675 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 592:\n-#line 2687 \"parse.y\"\n+#line 2683 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 593:\n-#line 2689 \"parse.y\"\n+#line 2685 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 594:\n-#line 2691 \"parse.y\"\n+#line 2687 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 595:\n-#line 2693 \"parse.y\"\n+#line 2689 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 596:\n-#line 2695 \"parse.y\"\n+#line 2691 \"parse.y\"\n { push_nested_class (yyvsp[-1].ttype, 3);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype);\n \t\t  TREE_COMPLEXITY (yyval.ttype) = current_class_depth; ;\n     break;}\n case 598:\n-#line 2703 \"parse.y\"\n+#line 2699 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    {\n@@ -7045,7 +7041,7 @@ case 598:\n \t\t;\n     break;}\n case 599:\n-#line 2713 \"parse.y\"\n+#line 2709 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = IDENTIFIER_GLOBAL_VALUE (yyvsp[0].ttype);\n@@ -7055,139 +7051,139 @@ case 599:\n \t\t;\n     break;}\n case 602:\n-#line 2726 \"parse.y\"\n+#line 2722 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 603:\n-#line 2731 \"parse.y\"\n+#line 2727 \"parse.y\"\n { yyval.ttype = get_type_decl (yyvsp[0].ttype); ;\n     break;}\n case 605:\n-#line 2740 \"parse.y\"\n+#line 2736 \"parse.y\"\n {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n \t\t  yyval.ttype = decl_tree_cons (yyvsp[-1].ttype, yyvsp[0].ttype, NULL_TREE);\n \t\t;\n     break;}\n case 606:\n-#line 2749 \"parse.y\"\n+#line 2745 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 607:\n-#line 2751 \"parse.y\"\n+#line 2747 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 608:\n-#line 2753 \"parse.y\"\n+#line 2749 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 609:\n-#line 2755 \"parse.y\"\n+#line 2751 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 610:\n-#line 2757 \"parse.y\"\n+#line 2753 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 612:\n-#line 2765 \"parse.y\"\n+#line 2761 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 613:\n-#line 2767 \"parse.y\"\n+#line 2763 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 614:\n-#line 2769 \"parse.y\"\n+#line 2765 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 615:\n-#line 2771 \"parse.y\"\n+#line 2767 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 616:\n-#line 2773 \"parse.y\"\n+#line 2769 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 618:\n-#line 2781 \"parse.y\"\n+#line 2777 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-2].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 619:\n-#line 2783 \"parse.y\"\n+#line 2779 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 620:\n-#line 2785 \"parse.y\"\n+#line 2781 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 621:\n-#line 2787 \"parse.y\"\n+#line 2783 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 622:\n-#line 2789 \"parse.y\"\n+#line 2785 \"parse.y\"\n { enter_scope_of (yyvsp[0].ttype); ;\n     break;}\n case 623:\n-#line 2791 \"parse.y\"\n+#line 2787 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  enter_scope_of (yyval.ttype);\n \t\t;\n     break;}\n case 624:\n-#line 2799 \"parse.y\"\n+#line 2795 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 625:\n-#line 2802 \"parse.y\"\n+#line 2798 \"parse.y\"\n { got_scope = NULL_TREE;\n  \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 626:\n-#line 2808 \"parse.y\"\n+#line 2804 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 627:\n-#line 2811 \"parse.y\"\n+#line 2807 \"parse.y\"\n { got_scope = NULL_TREE;\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 629:\n-#line 2818 \"parse.y\"\n+#line 2814 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 630:\n-#line 2823 \"parse.y\"\n+#line 2819 \"parse.y\"\n { yyval.ttype = build_functional_cast (yyvsp[-3].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 631:\n-#line 2825 \"parse.y\"\n+#line 2821 \"parse.y\"\n { yyval.ttype = reparse_decl_as_expr (yyvsp[-3].ftype.t, yyvsp[-1].ttype); ;\n     break;}\n case 632:\n-#line 2827 \"parse.y\"\n+#line 2823 \"parse.y\"\n { yyval.ttype = reparse_absdcl_as_expr (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 637:\n-#line 2838 \"parse.y\"\n+#line 2834 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 638:\n-#line 2840 \"parse.y\"\n+#line 2836 \"parse.y\"\n { got_scope = yyval.ttype \n \t\t    = make_typename_type (yyvsp[-3].ttype, yyvsp[-1].ttype, /*complain=*/1); ;\n     break;}\n case 639:\n-#line 2848 \"parse.y\"\n+#line 2844 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) == IDENTIFIER_NODE)\n \t\t    {\n@@ -7199,31 +7195,31 @@ case 639:\n \t\t;\n     break;}\n case 640:\n-#line 2858 \"parse.y\"\n+#line 2854 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype = TREE_TYPE (yyval.ttype);\n \t\t;\n     break;}\n case 641:\n-#line 2864 \"parse.y\"\n+#line 2860 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyval.ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype;\n \t\t;\n     break;}\n case 642:\n-#line 2870 \"parse.y\"\n+#line 2866 \"parse.y\"\n { got_scope = yyval.ttype = complete_type (TREE_TYPE (yyvsp[-1].ttype)); ;\n     break;}\n case 644:\n-#line 2886 \"parse.y\"\n+#line 2882 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 645:\n-#line 2891 \"parse.y\"\n+#line 2887 \"parse.y\"\n {\n \t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype, /*complain=*/1);\n@@ -7238,26 +7234,26 @@ case 645:\n \t\t;\n     break;}\n case 646:\n-#line 2904 \"parse.y\"\n+#line 2900 \"parse.y\"\n { yyval.ttype = TREE_TYPE (yyvsp[0].ttype); ;\n     break;}\n case 647:\n-#line 2906 \"parse.y\"\n+#line 2902 \"parse.y\"\n { yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype, /*complain=*/1); ;\n     break;}\n case 648:\n-#line 2908 \"parse.y\"\n+#line 2904 \"parse.y\"\n { yyval.ttype = make_typename_type (yyvsp[-2].ttype, yyvsp[0].ttype, /*complain=*/1); ;\n     break;}\n case 649:\n-#line 2913 \"parse.y\"\n+#line 2909 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", yyvsp[0].ttype);\n \t\t;\n     break;}\n case 650:\n-#line 2918 \"parse.y\"\n+#line 2914 \"parse.y\"\n {\n \t\t  if (TREE_CODE_CLASS (TREE_CODE (yyvsp[-1].ttype)) == 't')\n \t\t    yyval.ttype = make_typename_type (yyvsp[-1].ttype, yyvsp[0].ttype, /*complain=*/1);\n@@ -7272,17 +7268,17 @@ case 650:\n \t\t;\n     break;}\n case 651:\n-#line 2931 \"parse.y\"\n+#line 2927 \"parse.y\"\n { got_scope = yyval.ttype \n \t\t    = make_typename_type (yyvsp[-2].ttype, yyvsp[-1].ttype, /*complain=*/1); ;\n     break;}\n case 652:\n-#line 2934 \"parse.y\"\n+#line 2930 \"parse.y\"\n { got_scope = yyval.ttype \n \t\t    = make_typename_type (yyvsp[-3].ttype, yyvsp[-1].ttype, /*complain=*/1); ;\n     break;}\n case 653:\n-#line 2940 \"parse.y\"\n+#line 2936 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) != IDENTIFIER_NODE)\n \t\t    yyvsp[-1].ttype = lastiddecl;\n@@ -7296,31 +7292,31 @@ case 653:\n \t\t;\n     break;}\n case 654:\n-#line 2952 \"parse.y\"\n+#line 2948 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[-1].ttype) != IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype = complete_type (TREE_TYPE (yyval.ttype));\n \t\t;\n     break;}\n case 655:\n-#line 2958 \"parse.y\"\n+#line 2954 \"parse.y\"\n { got_scope = yyval.ttype = complete_type (TREE_TYPE (yyval.ttype)); ;\n     break;}\n case 658:\n-#line 2962 \"parse.y\"\n+#line 2958 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyval.ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = lastiddecl;\n \t\t  got_scope = yyval.ttype;\n \t\t;\n     break;}\n case 659:\n-#line 2971 \"parse.y\"\n+#line 2967 \"parse.y\"\n { yyval.ttype = build_min_nt (TEMPLATE_ID_EXPR, yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 660:\n-#line 2976 \"parse.y\"\n+#line 2972 \"parse.y\"\n {\n \t\t  if (TREE_CODE (yyvsp[0].ttype) == IDENTIFIER_NODE)\n \t\t    yyval.ttype = IDENTIFIER_GLOBAL_VALUE (yyvsp[0].ttype);\n@@ -7330,156 +7326,156 @@ case 660:\n \t\t;\n     break;}\n case 662:\n-#line 2985 \"parse.y\"\n+#line 2981 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 663:\n-#line 2990 \"parse.y\"\n+#line 2986 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 664:\n-#line 2992 \"parse.y\"\n+#line 2988 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; got_scope = NULL_TREE; ;\n     break;}\n case 665:\n-#line 2999 \"parse.y\"\n+#line 2995 \"parse.y\"\n { got_scope = void_type_node; ;\n     break;}\n case 666:\n-#line 3005 \"parse.y\"\n+#line 3001 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 667:\n-#line 3007 \"parse.y\"\n+#line 3003 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 668:\n-#line 3009 \"parse.y\"\n+#line 3005 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 669:\n-#line 3011 \"parse.y\"\n+#line 3007 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[0].ttype, NULL_TREE); ;\n     break;}\n case 670:\n-#line 3013 \"parse.y\"\n+#line 3009 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, arg);\n \t\t;\n     break;}\n case 671:\n-#line 3017 \"parse.y\"\n+#line 3013 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 673:\n-#line 3026 \"parse.y\"\n+#line 3022 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 674:\n-#line 3028 \"parse.y\"\n+#line 3024 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 676:\n-#line 3034 \"parse.y\"\n+#line 3030 \"parse.y\"\n {\n \t\t  /* Provide support for '(' attributes '*' declarator ')'\n \t\t     etc */\n \t\t  yyval.ttype = decl_tree_cons (yyvsp[-1].ttype, yyvsp[0].ttype, NULL_TREE);\n \t\t;\n     break;}\n case 677:\n-#line 3044 \"parse.y\"\n+#line 3040 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 678:\n-#line 3046 \"parse.y\"\n+#line 3042 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 679:\n-#line 3048 \"parse.y\"\n+#line 3044 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[0].ftype.t, NULL_TREE); ;\n     break;}\n case 680:\n-#line 3050 \"parse.y\"\n+#line 3046 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (NULL_TREE, NULL_TREE); ;\n     break;}\n case 681:\n-#line 3052 \"parse.y\"\n+#line 3048 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 682:\n-#line 3054 \"parse.y\"\n+#line 3050 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 683:\n-#line 3056 \"parse.y\"\n+#line 3052 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[0].ftype.t, NULL_TREE); ;\n     break;}\n case 684:\n-#line 3058 \"parse.y\"\n+#line 3054 \"parse.y\"\n { yyval.ttype = make_reference_declarator (NULL_TREE, NULL_TREE); ;\n     break;}\n case 685:\n-#line 3060 \"parse.y\"\n+#line 3056 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[0].ttype, NULL_TREE);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-1].ttype, arg);\n \t\t;\n     break;}\n case 686:\n-#line 3064 \"parse.y\"\n+#line 3060 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 688:\n-#line 3073 \"parse.y\"\n+#line 3069 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 689:\n-#line 3076 \"parse.y\"\n+#line 3072 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 690:\n-#line 3078 \"parse.y\"\n+#line 3074 \"parse.y\"\n { yyval.ttype = make_call_declarator (yyval.ttype, empty_parms (), yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 691:\n-#line 3080 \"parse.y\"\n+#line 3076 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 692:\n-#line 3082 \"parse.y\"\n+#line 3078 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, yyval.ttype, NULL_TREE); ;\n     break;}\n case 693:\n-#line 3084 \"parse.y\"\n+#line 3080 \"parse.y\"\n { yyval.ttype = make_call_declarator (NULL_TREE, yyvsp[-3].ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 694:\n-#line 3086 \"parse.y\"\n+#line 3082 \"parse.y\"\n { set_quals_and_spec (yyval.ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 695:\n-#line 3088 \"parse.y\"\n+#line 3084 \"parse.y\"\n { set_quals_and_spec (yyval.ttype, yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 696:\n-#line 3090 \"parse.y\"\n+#line 3086 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 697:\n-#line 3092 \"parse.y\"\n+#line 3088 \"parse.y\"\n { yyval.ttype = build_parse_node (ARRAY_REF, NULL_TREE, NULL_TREE); ;\n     break;}\n case 704:\n-#line 3115 \"parse.y\"\n+#line 3111 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids label declarations\"); ;\n     break;}\n case 707:\n-#line 3126 \"parse.y\"\n+#line 3122 \"parse.y\"\n { \n \t\t  while (yyvsp[-1].ttype)\n \t\t    {\n@@ -7489,352 +7485,352 @@ case 707:\n \t\t;\n     break;}\n case 708:\n-#line 3139 \"parse.y\"\n+#line 3135 \"parse.y\"\n {;\n     break;}\n case 710:\n-#line 3145 \"parse.y\"\n+#line 3141 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 711:\n-#line 3147 \"parse.y\"\n+#line 3143 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 712:\n-#line 3152 \"parse.y\"\n+#line 3148 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_if_stmt ();\n \t\t  cond_stmt_keyword = \"if\";\n \t\t;\n     break;}\n case 713:\n-#line 3157 \"parse.y\"\n+#line 3153 \"parse.y\"\n { finish_if_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 714:\n-#line 3159 \"parse.y\"\n+#line 3155 \"parse.y\"\n { yyval.ttype = finish_then_clause (yyvsp[-3].ttype); ;\n     break;}\n case 716:\n-#line 3164 \"parse.y\"\n+#line 3160 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 717:\n-#line 3166 \"parse.y\"\n+#line 3162 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 718:\n-#line 3171 \"parse.y\"\n+#line 3167 \"parse.y\"\n {;\n     break;}\n case 720:\n-#line 3177 \"parse.y\"\n+#line 3173 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 721:\n-#line 3179 \"parse.y\"\n+#line 3175 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 722:\n-#line 3181 \"parse.y\"\n+#line 3177 \"parse.y\"\n { begin_else_clause (); ;\n     break;}\n case 723:\n-#line 3183 \"parse.y\"\n+#line 3179 \"parse.y\"\n { \n \t\t  finish_else_clause (yyvsp[-3].ttype); \n \t\t  finish_if_stmt ();\n \t\t;\n     break;}\n case 724:\n-#line 3188 \"parse.y\"\n+#line 3184 \"parse.y\"\n { finish_if_stmt (); ;\n     break;}\n case 725:\n-#line 3190 \"parse.y\"\n+#line 3186 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_while_stmt ();\n \t\t  cond_stmt_keyword = \"while\";\n \t\t;\n     break;}\n case 726:\n-#line 3195 \"parse.y\"\n+#line 3191 \"parse.y\"\n { finish_while_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 727:\n-#line 3197 \"parse.y\"\n+#line 3193 \"parse.y\"\n { finish_while_stmt (yyvsp[-3].ttype); ;\n     break;}\n case 728:\n-#line 3199 \"parse.y\"\n+#line 3195 \"parse.y\"\n { yyval.ttype = begin_do_stmt (); ;\n     break;}\n case 729:\n-#line 3201 \"parse.y\"\n+#line 3197 \"parse.y\"\n {\n \t\t  finish_do_body (yyvsp[-2].ttype);\n \t\t  cond_stmt_keyword = \"do\";\n \t\t;\n     break;}\n case 730:\n-#line 3206 \"parse.y\"\n+#line 3202 \"parse.y\"\n { finish_do_stmt (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 731:\n-#line 3208 \"parse.y\"\n+#line 3204 \"parse.y\"\n { yyval.ttype = begin_for_stmt (); ;\n     break;}\n case 732:\n-#line 3210 \"parse.y\"\n+#line 3206 \"parse.y\"\n { finish_for_init_stmt (yyvsp[-2].ttype); ;\n     break;}\n case 733:\n-#line 3212 \"parse.y\"\n+#line 3208 \"parse.y\"\n { finish_for_cond (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 734:\n-#line 3214 \"parse.y\"\n+#line 3210 \"parse.y\"\n { finish_for_expr (yyvsp[-1].ttype, yyvsp[-8].ttype); ;\n     break;}\n case 735:\n-#line 3216 \"parse.y\"\n+#line 3212 \"parse.y\"\n { finish_for_stmt (yyvsp[-3].ttype, yyvsp[-10].ttype); ;\n     break;}\n case 736:\n-#line 3218 \"parse.y\"\n+#line 3214 \"parse.y\"\n { yyval.ttype = begin_switch_stmt (); ;\n     break;}\n case 737:\n-#line 3220 \"parse.y\"\n+#line 3216 \"parse.y\"\n { finish_switch_cond (yyvsp[-1].ttype, yyvsp[-3].ttype); ;\n     break;}\n case 738:\n-#line 3222 \"parse.y\"\n+#line 3218 \"parse.y\"\n { finish_switch_stmt (yyvsp[-3].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 739:\n-#line 3224 \"parse.y\"\n+#line 3220 \"parse.y\"\n { finish_case_label (yyvsp[-1].ttype, NULL_TREE); ;\n     break;}\n case 741:\n-#line 3227 \"parse.y\"\n+#line 3223 \"parse.y\"\n { finish_case_label (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 743:\n-#line 3230 \"parse.y\"\n+#line 3226 \"parse.y\"\n { finish_case_label (NULL_TREE, NULL_TREE); ;\n     break;}\n case 745:\n-#line 3233 \"parse.y\"\n+#line 3229 \"parse.y\"\n { finish_break_stmt (); ;\n     break;}\n case 746:\n-#line 3235 \"parse.y\"\n+#line 3231 \"parse.y\"\n { finish_continue_stmt (); ;\n     break;}\n case 747:\n-#line 3237 \"parse.y\"\n+#line 3233 \"parse.y\"\n { finish_return_stmt (NULL_TREE); ;\n     break;}\n case 748:\n-#line 3239 \"parse.y\"\n+#line 3235 \"parse.y\"\n { finish_return_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 749:\n-#line 3241 \"parse.y\"\n+#line 3237 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 750:\n-#line 3247 \"parse.y\"\n+#line 3243 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 751:\n-#line 3253 \"parse.y\"\n+#line 3249 \"parse.y\"\n { finish_asm_stmt (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 752:\n-#line 3257 \"parse.y\"\n+#line 3253 \"parse.y\"\n { finish_asm_stmt (yyvsp[-10].ttype, yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype); ;\n     break;}\n case 753:\n-#line 3259 \"parse.y\"\n+#line 3255 \"parse.y\"\n { \n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n \t\t  finish_goto_stmt (yyvsp[-1].ttype);\n \t\t;\n     break;}\n case 754:\n-#line 3265 \"parse.y\"\n+#line 3261 \"parse.y\"\n { finish_goto_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 756:\n-#line 3268 \"parse.y\"\n+#line 3264 \"parse.y\"\n { error (\"label must be followed by statement\");\n \t\t  yyungetc ('}', 0); ;\n     break;}\n case 757:\n-#line 3271 \"parse.y\"\n+#line 3267 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 760:\n-#line 3275 \"parse.y\"\n+#line 3271 \"parse.y\"\n { do_local_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 762:\n-#line 3281 \"parse.y\"\n+#line 3277 \"parse.y\"\n { yyval.ttype = begin_function_try_block (); ;\n     break;}\n case 763:\n-#line 3283 \"parse.y\"\n+#line 3279 \"parse.y\"\n { finish_function_try_block (yyvsp[-2].ttype); ;\n     break;}\n case 764:\n-#line 3285 \"parse.y\"\n+#line 3281 \"parse.y\"\n {\n \t\t  finish_function_handler_sequence (yyvsp[-4].ttype);\n \t\t  yyval.itype = yyvsp[-3].itype;\n \t\t;\n     break;}\n case 765:\n-#line 3293 \"parse.y\"\n+#line 3289 \"parse.y\"\n { yyval.ttype = begin_try_block (); ;\n     break;}\n case 766:\n-#line 3295 \"parse.y\"\n+#line 3291 \"parse.y\"\n { finish_try_block (yyvsp[-1].ttype); ;\n     break;}\n case 767:\n-#line 3297 \"parse.y\"\n+#line 3293 \"parse.y\"\n { finish_handler_sequence (yyvsp[-3].ttype); ;\n     break;}\n case 770:\n-#line 3307 \"parse.y\"\n+#line 3303 \"parse.y\"\n { yyval.ttype = begin_handler(); ;\n     break;}\n case 771:\n-#line 3309 \"parse.y\"\n+#line 3305 \"parse.y\"\n { yyval.ttype = finish_handler_parms (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 772:\n-#line 3311 \"parse.y\"\n+#line 3307 \"parse.y\"\n { finish_handler (yyvsp[-1].ttype, yyvsp[-3].ttype); ;\n     break;}\n case 775:\n-#line 3321 \"parse.y\"\n+#line 3317 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 776:\n-#line 3337 \"parse.y\"\n+#line 3333 \"parse.y\"\n { \n \t\t  check_for_new_type (\"inside exception declarations\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = start_handler_parms (TREE_PURPOSE (yyvsp[-1].ftype.t),\n \t\t\t\t\t    TREE_VALUE (yyvsp[-1].ftype.t));\n \t\t;\n     break;}\n case 777:\n-#line 3346 \"parse.y\"\n+#line 3342 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 778:\n-#line 3348 \"parse.y\"\n+#line 3344 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 779:\n-#line 3350 \"parse.y\"\n+#line 3346 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 780:\n-#line 3352 \"parse.y\"\n+#line 3348 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 781:\n-#line 3357 \"parse.y\"\n+#line 3353 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 783:\n-#line 3360 \"parse.y\"\n+#line 3356 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 784:\n-#line 3369 \"parse.y\"\n+#line 3365 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 785:\n-#line 3372 \"parse.y\"\n+#line 3368 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 786:\n-#line 3377 \"parse.y\"\n+#line 3373 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 788:\n-#line 3380 \"parse.y\"\n+#line 3376 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 789:\n-#line 3387 \"parse.y\"\n+#line 3383 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 792:\n-#line 3394 \"parse.y\"\n+#line 3390 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 793:\n-#line 3399 \"parse.y\"\n+#line 3395 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 794:\n-#line 3404 \"parse.y\"\n+#line 3400 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 795:\n-#line 3406 \"parse.y\"\n+#line 3402 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 796:\n-#line 3417 \"parse.y\"\n+#line 3413 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 798:\n-#line 3422 \"parse.y\"\n+#line 3418 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 799:\n-#line 3430 \"parse.y\"\n+#line 3426 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 800:\n-#line 3432 \"parse.y\"\n+#line 3428 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 801:\n-#line 3435 \"parse.y\"\n+#line 3431 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 802:\n-#line 3437 \"parse.y\"\n+#line 3433 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 803:\n-#line 3440 \"parse.y\"\n+#line 3436 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 804:\n-#line 3442 \"parse.y\"\n+#line 3438 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7846,7 +7842,7 @@ case 804:\n \t\t;\n     break;}\n case 805:\n-#line 3452 \"parse.y\"\n+#line 3448 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7859,99 +7855,99 @@ case 805:\n \t\t;\n     break;}\n case 806:\n-#line 3467 \"parse.y\"\n+#line 3463 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 807:\n-#line 3469 \"parse.y\"\n+#line 3465 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 810:\n-#line 3480 \"parse.y\"\n+#line 3476 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 811:\n-#line 3483 \"parse.y\"\n+#line 3479 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 812:\n-#line 3486 \"parse.y\"\n+#line 3482 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 813:\n-#line 3489 \"parse.y\"\n+#line 3485 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 814:\n-#line 3491 \"parse.y\"\n+#line 3487 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 816:\n-#line 3497 \"parse.y\"\n+#line 3493 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 817:\n-#line 3507 \"parse.y\"\n+#line 3503 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 818:\n-#line 3511 \"parse.y\"\n+#line 3507 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 819:\n-#line 3514 \"parse.y\"\n+#line 3510 \"parse.y\"\n { yyval.ftype.t = build_tree_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 820:\n-#line 3518 \"parse.y\"\n+#line 3514 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 821:\n-#line 3522 \"parse.y\"\n+#line 3518 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 822:\n-#line 3526 \"parse.y\"\n+#line 3522 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 823:\n-#line 3533 \"parse.y\"\n+#line 3529 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 824:\n-#line 3536 \"parse.y\"\n+#line 3532 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 827:\n-#line 3547 \"parse.y\"\n+#line 3543 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 828:\n-#line 3552 \"parse.y\"\n+#line 3548 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 829:\n-#line 3557 \"parse.y\"\n+#line 3553 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7962,192 +7958,192 @@ case 829:\n \t\t;\n     break;}\n case 830:\n-#line 3569 \"parse.y\"\n+#line 3565 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 831:\n-#line 3571 \"parse.y\"\n+#line 3567 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 832:\n-#line 3573 \"parse.y\"\n+#line 3569 \"parse.y\"\n { yyval.ttype = empty_except_spec; ;\n     break;}\n case 833:\n-#line 3578 \"parse.y\"\n+#line 3574 \"parse.y\"\n {\n \t\t  check_for_new_type (\"exception specifier\", yyvsp[0].ftype);\n \t\t  yyval.ttype = groktypename (yyvsp[0].ftype.t);\n \t\t;\n     break;}\n case 834:\n-#line 3586 \"parse.y\"\n+#line 3582 \"parse.y\"\n { yyval.ttype = add_exception_specifier (NULL_TREE, yyvsp[0].ttype, 1); ;\n     break;}\n case 835:\n-#line 3588 \"parse.y\"\n+#line 3584 \"parse.y\"\n { yyval.ttype = add_exception_specifier (yyvsp[-2].ttype, yyvsp[0].ttype, 1); ;\n     break;}\n case 836:\n-#line 3593 \"parse.y\"\n+#line 3589 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 837:\n-#line 3595 \"parse.y\"\n+#line 3591 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 838:\n-#line 3597 \"parse.y\"\n+#line 3593 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 839:\n-#line 3599 \"parse.y\"\n+#line 3595 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 840:\n-#line 3606 \"parse.y\"\n+#line 3602 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 841:\n-#line 3611 \"parse.y\"\n+#line 3607 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 842:\n-#line 3613 \"parse.y\"\n+#line 3609 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 843:\n-#line 3615 \"parse.y\"\n+#line 3611 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 844:\n-#line 3617 \"parse.y\"\n+#line 3613 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 845:\n-#line 3619 \"parse.y\"\n+#line 3615 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 846:\n-#line 3621 \"parse.y\"\n+#line 3617 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 847:\n-#line 3623 \"parse.y\"\n+#line 3619 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 848:\n-#line 3625 \"parse.y\"\n+#line 3621 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 849:\n-#line 3627 \"parse.y\"\n+#line 3623 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 850:\n-#line 3629 \"parse.y\"\n+#line 3625 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 851:\n-#line 3631 \"parse.y\"\n+#line 3627 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 852:\n-#line 3633 \"parse.y\"\n+#line 3629 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 853:\n-#line 3635 \"parse.y\"\n+#line 3631 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 854:\n-#line 3637 \"parse.y\"\n+#line 3633 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 855:\n-#line 3639 \"parse.y\"\n+#line 3635 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 856:\n-#line 3641 \"parse.y\"\n+#line 3637 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 857:\n-#line 3643 \"parse.y\"\n+#line 3639 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 858:\n-#line 3645 \"parse.y\"\n+#line 3641 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 859:\n-#line 3647 \"parse.y\"\n+#line 3643 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 860:\n-#line 3649 \"parse.y\"\n+#line 3645 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 861:\n-#line 3651 \"parse.y\"\n+#line 3647 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 862:\n-#line 3653 \"parse.y\"\n+#line 3649 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 863:\n-#line 3655 \"parse.y\"\n+#line 3651 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 864:\n-#line 3657 \"parse.y\"\n+#line 3653 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 865:\n-#line 3659 \"parse.y\"\n+#line 3655 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 866:\n-#line 3661 \"parse.y\"\n+#line 3657 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 867:\n-#line 3663 \"parse.y\"\n+#line 3659 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 868:\n-#line 3665 \"parse.y\"\n+#line 3661 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 869:\n-#line 3667 \"parse.y\"\n+#line 3663 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 870:\n-#line 3669 \"parse.y\"\n+#line 3665 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 871:\n-#line 3671 \"parse.y\"\n+#line 3667 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 872:\n-#line 3673 \"parse.y\"\n+#line 3669 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 873:\n-#line 3675 \"parse.y\"\n+#line 3671 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 874:\n-#line 3678 \"parse.y\"\n+#line 3674 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 875:\n-#line 3680 \"parse.y\"\n+#line 3676 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -8372,7 +8368,7 @@ case 875:\n     }\n   return 1;\n }\n-#line 3683 \"parse.y\"\n+#line 3679 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "5e31354b58d1283d6bb74eeb6dcd7464fcd13449", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -1033,7 +1033,7 @@ condition:\n \t\t}\n \t  init\n \t\t{ \n-\t\t  cp_finish_decl ($<ttype>6, $7, $4, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  cp_finish_decl ($<ttype>6, $7, $4, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = convert_from_reference ($<ttype>6); \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n \t\t    cp_error (\"definition of array `%#D' in condition\", $$); \n@@ -1381,17 +1381,13 @@ primary:\n \t| boolean.literal\n \t| string\n \t\t{\n-\t\t  if (processing_template_decl)\n-\t\t    push_obstacks (&permanent_obstack, &permanent_obstack);\n \t\t  $$ = combine_strings ($$);\n \t\t  /* combine_strings doesn't set up TYPE_MAIN_VARIANT of\n \t\t     a const array the way we want, so fix it.  */\n \t\t  if (flag_const_strings)\n \t\t    TREE_TYPE ($$) = build_cplus_array_type\n \t\t      (TREE_TYPE (TREE_TYPE ($$)),\n \t\t       TYPE_DOMAIN (TREE_TYPE ($$)));\n-\t\t  if (processing_template_decl)\n-\t\t    pop_obstacks ();\n \t\t}\n \t| '(' expr ')'\n \t\t{ $$ = finish_parenthesized_expr ($2); }\n@@ -1867,11 +1863,11 @@ initdcl:\n \t\t\t\t\t  $3, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING); }\n+\t\t{ cp_finish_decl ($<ttype>5, $6, $2, LOOKUP_ONLYCONVERTING); }\n \t| declarator maybeasm maybe_attribute\n \t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0,\n \t\t\t\t\t  $3, prefix_attributes);\n-\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 1, 0); }\n+\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 0); }\n \t;\n \n         /* This rule assumes a certain configuration of the parser stack.\n@@ -1886,12 +1882,12 @@ initdcl0_innards:\n           /* Note how the declaration of the variable is in effect\n \t     while its init is parsed! */ \n \t  init\n-\t\t{ cp_finish_decl ($<ttype>3, $4, $<ttype>0, 1,\n+\t\t{ cp_finish_decl ($<ttype>3, $4, $<ttype>0,\n \t\t\t\t  LOOKUP_ONLYCONVERTING); }\n \t| maybe_attribute\n \t\t{ tree d;\n \t\t  parse_decl ($<ttype>-1, $<ttype>-2, $1, 0, &d);\n-\t\t  cp_finish_decl (d, NULL_TREE, $<ttype>0, 1, 0); }\n+\t\t  cp_finish_decl (d, NULL_TREE, $<ttype>0, 0); }\n   \t;\n   \n initdcl0:\n@@ -1914,7 +1910,7 @@ nomods_initdcl0:\n \t| constructor_declarator maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  parse_decl($1, NULL_TREE, $3, 0, &d);\n-\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n+\t\t  cp_finish_decl (d, NULL_TREE, $2, 0); }\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax"}, {"sha": "8e2a9f241cd58e2f94623889c4febfc99aef5273", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -336,7 +336,7 @@ push_inline_template_parms_recursive (parmlist, levels)\n \t\t\t\t    TREE_TYPE (parm));\n \t    SET_DECL_ARTIFICIAL (decl);\n \t    DECL_INITIAL (decl) = DECL_INITIAL (parm);\n-\t    DECL_TEMPLATE_PARM_P (decl) = 1;\n+\t    SET_DECL_TEMPLATE_PARM_P (decl);\n \t    pushdecl (decl);\n \t  }\n \t  break;\n@@ -1815,7 +1815,7 @@ process_template_parm (list, next)\n \t\t\t\t     decl, TREE_TYPE (parm));\n     }\n   SET_DECL_ARTIFICIAL (decl);\n-  DECL_TEMPLATE_PARM_P (decl) = 1;\n+  SET_DECL_TEMPLATE_PARM_P (decl);\n   pushdecl (decl);\n   parm = build_tree_list (defval, parm);\n   return chainon (list, parm);\n@@ -3888,11 +3888,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t\t\t\t      /*globalize=*/1);\n \t  return found;\n \t}\n-\t\t\t\t    \n-      /* Since we didn't find the type, we'll have to create it.\n-\t Since we'll be saving this type on the\n-\t DECL_TEMPLATE_INSTANTIATIONS list, it must be permanent.  */\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       \n       /* Create the type.  */\n       if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n@@ -4000,9 +3995,6 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t   the instantiation and exit above.  */\n \ttsubst_enum (template_type, t, arglist);\n \n-      /* We're done with the permanent obstack, now.  */\n-      pop_obstacks ();\n-\n       /* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO\n \t is set up.  */\n       if (TREE_CODE (t) != ENUMERAL_TYPE)\n@@ -4970,7 +4962,6 @@ instantiate_class_template (type)\n \n \t    finish_static_data_member_decl (r, init,\n \t\t\t\t\t    /*asmspec_tree=*/NULL_TREE, \n-\t\t\t\t\t    /*need_pop=*/0,\n \t\t\t\t\t    /*flags=*/0);\n \n \t    if (DECL_DEFINED_IN_CLASS_P (r))\n@@ -5894,10 +5885,7 @@ tsubst_decl (t, args, type, in_decl)\n \n \t/* This declaration is going to have to be around for a while,\n \t   so me make sure it is on a saveable obstack.  */\n-\tpush_obstacks_nochange ();\n-\tsaveable_allocation ();\n \tr = copy_node (t);\n-\tpop_obstacks ();\n \n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n@@ -7119,7 +7107,7 @@ tsubst_expr (t, args, complain, in_decl)\n \t    if (TREE_CODE (decl) == VAR_DECL)\n \t      DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n \t    maybe_push_decl (decl);\n-\t    cp_finish_decl (decl, init, NULL_TREE, 0, 0);\n+\t    cp_finish_decl (decl, init, NULL_TREE, 0);\n \t  }\n \treturn decl;\n       }\n@@ -7350,8 +7338,6 @@ instantiate_template (tmpl, targ_ptr)\n   tree gen_tmpl;\n   tree spec;\n   int i, len;\n-  struct obstack *old_fmp_obstack;\n-  extern struct obstack *function_maybepermanent_obstack;\n   tree inner_args;\n \n   if (tmpl == error_mark_node)\n@@ -7381,10 +7367,6 @@ instantiate_template (tmpl, targ_ptr)\n   else\n     gen_tmpl = tmpl;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-  old_fmp_obstack = function_maybepermanent_obstack;\n-  function_maybepermanent_obstack = &permanent_obstack;\n-\n   len = DECL_NTPARMS (gen_tmpl);\n   inner_args = innermost_args (targ_ptr);\n   i = len;\n@@ -7414,9 +7396,6 @@ instantiate_template (tmpl, targ_ptr)\n     add_pending_template (fndecl);\n \n  out:\n-  function_maybepermanent_obstack = old_fmp_obstack;\n-  pop_obstacks ();\n-\n   return fndecl;\n }\n \n@@ -9540,7 +9519,7 @@ instantiate_decl (d)\n \t  DECL_EXTERNAL (d) = 1;\n \t  DECL_NOT_REALLY_EXTERN (d) = 1;\n \t}\n-      cp_finish_decl (d, DECL_INITIAL (d), NULL_TREE, 0, 0);\n+      cp_finish_decl (d, DECL_INITIAL (d), NULL_TREE, 0);\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {"}, {"sha": "3f8300ff6e33e3965f60426b93bebe622856d209", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -143,16 +143,13 @@ call_void_fn (name)\n     d = IDENTIFIER_GLOBAL_VALUE (d);\n   else\n     {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n       type = build_function_type (void_type_node, void_list_node);\n       d = build_lang_decl (FUNCTION_DECL, d, type);\n       DECL_EXTERNAL (d) = 1;\n       TREE_PUBLIC (d) = 1;\n       DECL_ARTIFICIAL (d) = 1;\n       pushdecl_top_level (d);\n       make_function_rtl (d);\n-      pop_obstacks ();\n     }\n \n   mark_used (d);\n@@ -340,8 +337,6 @@ get_tinfo_var (type)\n   else\n     size = 2 * POINTER_SIZE;\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   /* The type for a character array of the appropriate size.  */\n   arrtype = build_cplus_array_type\n     (unsigned_char_type_node,\n@@ -353,11 +348,9 @@ get_tinfo_var (type)\n   DECL_ARTIFICIAL (tdecl) = 1;\n   push_to_top_level ();\n   pushdecl (tdecl);\n-  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0);\n   pop_from_top_level ();\n \n-  pop_obstacks ();\n-\n   return tdecl;\n }\n \n@@ -390,8 +383,6 @@ get_tinfo_fn_unused (type)\n   if (IDENTIFIER_GLOBAL_VALUE (name))\n     return IDENTIFIER_GLOBAL_VALUE (name);\n \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-\n   d = build_lang_decl (FUNCTION_DECL, name, tinfo_fn_type);\n   DECL_EXTERNAL (d) = 1;\n   TREE_PUBLIC (d) = 1;\n@@ -403,7 +394,6 @@ get_tinfo_fn_unused (type)\n   pushdecl_top_level (d);\n   make_function_rtl (d);\n   mark_inline_for_output (d);\n-  pop_obstacks ();\n \n   return d;\n }\n@@ -674,7 +664,6 @@ build_dynamic_cast_1 (type, expr)\n \t    {\n \t      tree tmp;\n \n-\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n \t      tmp = tree_cons\n \t\t(NULL_TREE, TREE_TYPE (td1), tree_cons\n \t\t (NULL_TREE, TREE_TYPE (td1), tree_cons\n@@ -689,7 +678,6 @@ build_dynamic_cast_1 (type, expr)\n \t      DECL_ARTIFICIAL (dcast_fn) = 1;\n \t      pushdecl_top_level (dcast_fn);\n \t      make_function_rtl (dcast_fn);\n-\t      pop_obstacks ();\n \t    }\n \t  \n \t  mark_used (dcast_fn);\n@@ -774,7 +762,6 @@ expand_si_desc (tdecl, type)\n   else\n     {\n       tree tmp;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       tmp = tree_cons\n \t(NULL_TREE, ptr_type_node, tree_cons\n \t (NULL_TREE, const_string_type_node, tree_cons\n@@ -788,7 +775,6 @@ expand_si_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -825,7 +811,6 @@ expand_class_desc (tdecl, type)\n \n       /* A reasonably close approximation of __class_type_info::base_info */\n \n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       base_info_type_node = make_lang_type (RECORD_TYPE);\n \n       /* Actually const __user_type_info * */\n@@ -852,7 +837,6 @@ expand_class_desc (tdecl, type)\n \n       finish_builtin_type (base_info_type_node, \"__base_info\", fields,\n \t\t\t   3, ptr_type_node);\n-      pop_obstacks ();\n     }\n \n   while (--i >= 0)\n@@ -955,7 +939,6 @@ expand_class_desc (tdecl, type)\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       tmp = tree_cons\n \t(NULL_TREE, ptr_type_node, tree_cons\n \t (NULL_TREE, const_string_type_node, tree_cons\n@@ -969,7 +952,6 @@ expand_class_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -1002,7 +984,6 @@ expand_ptr_desc (tdecl, type)\n   else\n     {\n       tree tmp;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       tmp = tree_cons\n \t(NULL_TREE, ptr_type_node, tree_cons\n \t (NULL_TREE, const_string_type_node, tree_cons\n@@ -1016,7 +997,6 @@ expand_ptr_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -1049,7 +1029,6 @@ expand_attr_desc (tdecl, type)\n   else\n     {\n       tree tmp;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       tmp = tree_cons\n \t(NULL_TREE, ptr_type_node, tree_cons\n \t (NULL_TREE, const_string_type_node, tree_cons\n@@ -1064,7 +1043,6 @@ expand_attr_desc (tdecl, type)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -1092,7 +1070,6 @@ expand_generic_desc (tdecl, type, fnname)\n   else\n     {\n       tree tmp;\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n       tmp = tree_cons\n \t(NULL_TREE, ptr_type_node, tree_cons\n \t (NULL_TREE, const_string_type_node, void_list_node));\n@@ -1104,7 +1081,6 @@ expand_generic_desc (tdecl, type, fnname)\n       DECL_ARTIFICIAL (fn) = 1;\n       pushdecl_top_level (fn);\n       make_function_rtl (fn);\n-      pop_obstacks ();\n     }\n \n   mark_used (fn);\n@@ -1149,7 +1125,7 @@ synthesize_tinfo_fn (fndecl)\n   DECL_COMMON (tdecl) = 1;\n   TREE_USED (tdecl) = 1;\n   DECL_ALIGN (tdecl) = TYPE_ALIGN (ptr_type_node);\n-  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+  cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0);\n \n   /* Begin processing the function.  */\n   start_function (NULL_TREE, fndecl, NULL_TREE, "}, {"sha": "060855b4d2cf9dfc8a7629df47acba62af3f1730", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -2670,7 +2670,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t      DECL_ARTIFICIAL (nvtbl) = 1;\n \t      nvtbl = pushdecl (nvtbl);\n \t      init = NULL_TREE;\n-\t      cp_finish_decl (nvtbl, init, NULL_TREE, 0,\n+\t      cp_finish_decl (nvtbl, init, NULL_TREE,\n \t\t\t      LOOKUP_ONLYCONVERTING);\n \n \t      /* We don't set DECL_VIRTUAL_P and DECL_CONTEXT on nvtbl"}, {"sha": "0f201f67d61d24e6bfa9553cbf21f4cf399b2ac7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -992,17 +992,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n      tree clobbers;\n {\n   if (TREE_CHAIN (string))\n-    {\n-      if (building_stmt_tree ())\n-\t/* We need to build the combined string on the permanent\n-\t   obstack so that we can use it during instantiations.  */\n-\tpush_permanent_obstack ();\n-\n-      string = combine_strings (string);\n-\n-      if (building_stmt_tree ())\n-\tpop_obstacks ();\n-    }\n+    string = combine_strings (string);\n \n   if (cv_qualifier != NULL_TREE\n       && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n@@ -1163,7 +1153,7 @@ finish_named_return_value (return_id, init)\n \tadd_tree (build_min_nt (RETURN_INIT, return_id, init));\n       else\n \t{\n-\t  cp_finish_decl (decl, init, NULL_TREE, 0, 0);\n+\t  cp_finish_decl (decl, init, NULL_TREE, 0);\n \t  store_return_init (decl);\n \t}\n     }\n@@ -1749,8 +1739,6 @@ tree\n begin_class_definition (t)\n      tree t;\n {\n-  push_permanent_obstack ();\n-\n   if (t == error_mark_node\n       || ! IS_AGGR_TYPE (t))\n     {\n@@ -1972,8 +1960,6 @@ finish_class_definition (t, attributes, semi, pop_scope_p)\n \tnote_got_semicolon (t);\n     }\n \n-  pop_obstacks ();\n-\n   if (! semi)\n     check_for_missing_semicolon (t); \n   if (pop_scope_p)\n@@ -2164,10 +2150,8 @@ finish_typeof (expr)\n     {\n       tree t;\n \n-      push_permanent_obstack ();\n       t = make_lang_type (TYPEOF_TYPE);\n       TYPE_FIELDS (t) = expr;\n-      pop_obstacks ();\n \n       return t;\n     }"}, {"sha": "15f66daf527b4484a8e53f8b4b36a1adf0f3b769", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -464,11 +464,9 @@ build_cplus_method_type (basetype, rettype, argtypes)\n      which is \"this\".  Put it into the list of argument types.  Make\n      sure that the new argument list is allocated on the same obstack\n      as the type.  */\n-  push_obstacks (TYPE_OBSTACK (t), TYPE_OBSTACK (t));\n   argtypes = tree_cons (NULL_TREE, ptype, argtypes);\n   TYPE_ARG_TYPES (t) = argtypes;\n   TREE_SIDE_EFFECTS (argtypes) = 1;  /* Mark first argtype as \"artificial\".  */\n-  pop_obstacks ();\n \n   /* If we already have such a type, use the old one and free this one.\n      Note that it also frees up the above cons cell if found.  */\n@@ -1278,14 +1276,12 @@ reverse_path (path)\n      tree path;\n {\n   register tree prev = NULL_TREE, cur;\n-  push_expression_obstack ();\n   for (cur = path; cur; cur = BINFO_INHERITANCE_CHAIN (cur))\n     {\n       tree r = copy_node (cur);\n       BINFO_INHERITANCE_CHAIN (r) = prev;\n       prev = r;\n     }\n-  pop_obstacks ();\n   return prev;\n }\n \n@@ -1538,15 +1534,10 @@ copy_template_template_parm (t)\n   tree template = TYPE_NAME (t);\n   tree t2;\n \n-  /* Make sure these end up on the permanent_obstack.  */\n-  push_permanent_obstack ();\n-  \n   t2 = make_lang_type (TEMPLATE_TEMPLATE_PARM);\n   template = copy_node (template);\n   copy_lang_decl (template);\n \n-  pop_obstacks ();\n-\n   TREE_TYPE (template) = t2;\n   TYPE_NAME (t2) = template;\n   TYPE_STUB_DECL (t2) = template;\n@@ -2325,11 +2316,7 @@ tree\n build_expr_ptr_wrapper (ptr)\n      void *ptr;\n {\n-  tree t;\n-  push_expression_obstack ();\n-  t = build_ptr_wrapper (ptr);\n-  pop_obstacks ();\n-  return t;\n+  return build_ptr_wrapper (ptr);\n }\n \n /* Build a wrapper around some integer I so we can use it as a tree.  */\n@@ -2363,24 +2350,6 @@ build_srcloc_here ()\n   return build_srcloc (input_filename, lineno);\n }\n \n-void\n-push_expression_obstack ()\n-{\n-  push_obstacks_nochange ();\n-  current_obstack = expression_obstack;\n-}\n-\n-/* Begin allocating on the permanent obstack.  When you're done\n-   allocating there, call pop_obstacks to return to the previous set\n-   of obstacks.  */\n-\n-void\n-push_permanent_obstack ()\n-{\n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-}\n-\n /* The type of ARG when used as an lvalue.  */\n \n tree"}, {"sha": "dc6c9c97d85c2ec35776b87b7103605bdd1c8356", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9f6678b314661cdfde334387c1f06e9265c592/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cd9f6678b314661cdfde334387c1f06e9265c592", "patch": "@@ -4979,19 +4979,13 @@ mark_addressable (exp)\n \t    && DECL_RTL (x) != 0\n \t    && ! DECL_IN_MEMORY_P (x))\n \t  {\n-\t    /* We thought this would make a good constant variable,\n-\t       but we were wrong.  */\n-\t    push_permanent_obstack ();\n-\n \t    TREE_ASM_WRITTEN (x) = 0;\n \t    DECL_RTL (x) = 0;\n \t    rest_of_decl_compilation (x, 0, \n \t\t\t\t      !DECL_FUNCTION_SCOPE_P (x),\n \t\t\t\t      0);\n \t    TREE_ADDRESSABLE (x) = 1;\n \n-\t    pop_obstacks ();\n-\n \t    return 1;\n \t  }\n \t/* Caller should not be trying to mark initialized"}]}