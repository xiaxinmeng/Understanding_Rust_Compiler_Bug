{"sha": "47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkOGYxOGRhMmEzOWJmODE2YzA1ZGZiMmM4MTgxMTI5MmQ4ZGMzYQ==", "commit": {"author": {"name": "Jie Zhang", "email": "jie@codesourcery.com", "date": "2010-09-20T16:00:29Z"}, "committer": {"name": "Jie Zhang", "email": "jiez@gcc.gnu.org", "date": "2010-09-20T16:00:29Z"}, "message": "arm.c (arm_address_offset_is_imm): New.\n\n\t* config/arm/arm.c (arm_address_offset_is_imm): New.\n\t(arm_early_store_addr_dep): New.\n\t(arm_early_load_addr_dep): New.\n\t* config/arm/arm-protos.h (arm_early_store_addr_dep): Declare.\n\t(arm_early_load_addr_dep): Declare.\n\t(arm_address_offset_is_imm): Declare.\n\t* config/arm/cortex-m4.md: New file.\n\t* config/arm/cortex-m4-fpu.md: New file.\n\t* config/arm/arm.md: Include cortex-m4.md and cortex-m4-fpu.md.\n\t(attr generic_sched): Exclude cortexm4.\n\t(attr generic_vfp): Exclude cortexm4.\n\nFrom-SVN: r164440", "tree": {"sha": "9e1533a822d09b7256c6a8ad526af3f0481e8c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e1533a822d09b7256c6a8ad526af3f0481e8c00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/comments", "author": null, "committer": null, "parents": [{"sha": "06baaba377b39dbc49f3dcd8289df5d0657a01c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06baaba377b39dbc49f3dcd8289df5d0657a01c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06baaba377b39dbc49f3dcd8289df5d0657a01c4"}], "stats": {"total": 309, "additions": 305, "deletions": 4}, "files": [{"sha": "5f45a594fafb195f88caba5717544a0c785c60e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "patch": "@@ -1,3 +1,17 @@\n+2010-09-20  Jie Zhang  <jie@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_address_offset_is_imm): New.\n+\t(arm_early_store_addr_dep): New.\n+\t(arm_early_load_addr_dep): New.\n+\t* config/arm/arm-protos.h (arm_early_store_addr_dep): Declare.\n+\t(arm_early_load_addr_dep): Declare.\n+\t(arm_address_offset_is_imm): Declare.\n+\t* config/arm/cortex-m4.md: New file.\n+\t* config/arm/cortex-m4-fpu.md: New file.\n+\t* config/arm/arm.md: Include cortex-m4.md and cortex-m4-fpu.md.\n+\t(attr generic_sched): Exclude cortexm4.\n+\t(attr generic_vfp): Exclude cortexm4.\n+\n 2010-09-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/45704"}, {"sha": "9229afac1c947f3e35210194bd6d0566bcaeee11", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "patch": "@@ -86,6 +86,8 @@ extern int arm_coproc_mem_operand (rtx, bool);\n extern int neon_vector_mem_operand (rtx, int);\n extern int neon_struct_mem_operand (rtx);\n extern int arm_no_early_store_addr_dep (rtx, rtx);\n+extern int arm_early_store_addr_dep (rtx, rtx);\n+extern int arm_early_load_addr_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n extern int arm_no_early_mul_dep (rtx, rtx);\n@@ -127,6 +129,7 @@ extern const char *output_move_quad (rtx *);\n extern const char *output_move_vfp (rtx *operands);\n extern const char *output_move_neon (rtx *operands);\n extern int arm_attr_length_move_neon (rtx);\n+extern int arm_address_offset_is_imm (rtx);\n extern const char *output_add_immediate (rtx *);\n extern const char *arithmetic_instr (rtx, int);\n extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);"}, {"sha": "7cb3186dc014e3303ac3786523518eb3a2907243", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "patch": "@@ -13345,6 +13345,34 @@ arm_attr_length_move_neon (rtx insn)\n     return 4;\n }\n \n+/* Return nonzero if the offset in the address is an immediate.  Otherwise,\n+   return zero.  */\n+\n+int\n+arm_address_offset_is_imm (rtx insn)\n+{\n+  rtx mem, addr;\n+\n+  extract_insn_cached (insn);\n+\n+  if (REG_P (recog_data.operand[0]))\n+    return 0;\n+\n+  mem = recog_data.operand[0];\n+\n+  gcc_assert (MEM_P (mem));\n+\n+  addr = XEXP (mem, 0);\n+\n+  if (GET_CODE (addr) == REG\n+      || (GET_CODE (addr) == PLUS\n+\t  && GET_CODE (XEXP (addr, 0)) == REG\n+\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n /* Output an ADD r, s, #n where n may be too big for one instruction.\n    If adding zero to one register, output nothing.  */\n const char *\n@@ -21503,6 +21531,38 @@ arm_no_early_store_addr_dep (rtx producer, rtx consumer)\n   return !reg_overlap_mentioned_p (value, addr);\n }\n \n+/* Return nonzero if the CONSUMER instruction (a store) does need\n+   PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_early_store_addr_dep (rtx producer, rtx consumer)\n+{\n+  return !arm_no_early_store_addr_dep (producer, consumer);\n+}\n+\n+/* Return nonzero if the CONSUMER instruction (a load) does need\n+   PRODUCER's value to calculate the address.  */\n+\n+int\n+arm_early_load_addr_dep (rtx producer, rtx consumer)\n+{\n+  rtx value = PATTERN (producer);\n+  rtx addr = PATTERN (consumer);\n+\n+  if (GET_CODE (value) == COND_EXEC)\n+    value = COND_EXEC_CODE (value);\n+  if (GET_CODE (value) == PARALLEL)\n+    value = XVECEXP (value, 0, 0);\n+  value = XEXP (value, 0);\n+  if (GET_CODE (addr) == COND_EXEC)\n+    addr = COND_EXEC_CODE (addr);\n+  if (GET_CODE (addr) == PARALLEL)\n+    addr = XVECEXP (addr, 0, 0);\n+  addr = XEXP (addr, 1);\n+\n+  return reg_overlap_mentioned_p (value, addr);\n+}\n+\n /* Return nonzero if the CONSUMER instruction (an ALU op) does not\n    have an early register shift value or amount dependency on the\n    result of PRODUCER.  */"}, {"sha": "ba5f928b085092445cc9c78c7709d472e0d84e18", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "patch": "@@ -497,16 +497,16 @@\n ;; True if the generic scheduling description should be used.\n \n (define_attr \"generic_sched\" \"yes,no\"\n-  (const (if_then_else \n-          (ior (eq_attr \"tune\" \"arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa5,cortexa8,cortexa9\")\n-\t      (eq_attr \"tune_cortexr4\" \"yes\"))\n+  (const (if_then_else\n+          (ior (eq_attr \"tune\" \"arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs,cortexa5,cortexa8,cortexa9,cortexm4\")\n+\t       (eq_attr \"tune_cortexr4\" \"yes\"))\n           (const_string \"no\")\n           (const_string \"yes\"))))\n \n (define_attr \"generic_vfp\" \"yes,no\"\n   (const (if_then_else\n \t  (and (eq_attr \"fpu\" \"vfp\")\n-\t       (eq_attr \"tune\" \"!arm1020e,arm1022e,cortexa5,cortexa8,cortexa9\")\n+\t       (eq_attr \"tune\" \"!arm1020e,arm1022e,cortexa5,cortexa8,cortexa9,cortexm4\")\n \t       (eq_attr \"tune_cortexr4\" \"no\"))\n \t  (const_string \"yes\")\n \t  (const_string \"no\"))))\n@@ -521,6 +521,8 @@\n (include \"cortex-a9.md\")\n (include \"cortex-r4.md\")\n (include \"cortex-r4f.md\")\n+(include \"cortex-m4.md\")\n+(include \"cortex-m4-fpu.md\")\n (include \"vfp11.md\")\n \n \f"}, {"sha": "7de115c52091169bef50c69c193da56e417ca6c7", "filename": "gcc/config/arm/cortex-m4-fpu.md", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Fcortex-m4-fpu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Fcortex-m4-fpu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-m4-fpu.md?ref=47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "patch": "@@ -0,0 +1,111 @@\n+;; ARM Cortex-M4 FPU pipeline description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Contributed by CodeSourcery.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Use an artifial unit to model FPU.\n+(define_cpu_unit \"cortex_m4_v\" \"cortex_m4\")\n+\n+(define_reservation \"cortex_m4_ex_v\" \"cortex_m4_ex+cortex_m4_v\")\n+\n+;; Integer instructions following VDIV or VSQRT complete out-of-order.\n+(define_insn_reservation \"cortex_m4_fdivs\" 15\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"fdivs\"))\n+  \"cortex_m4_ex_v,cortex_m4_v*13\")\n+\n+(define_insn_reservation \"cortex_m4_vmov_1\" 1\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"fcpys,fconsts\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_vmov_2\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_2_r,r_2_f\"))\n+  \"cortex_m4_ex_v*2\")\n+\n+(define_insn_reservation \"cortex_m4_fmuls\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"fmuls\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_fmacs\" 4\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"fmacs\"))\n+  \"cortex_m4_ex_v*3\")\n+\n+(define_insn_reservation \"cortex_m4_ffariths\" 1\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"ffariths\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_fadds\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"fadds\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_fcmps\" 1\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"fcmps\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_f_flag\" 1\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_flag\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_f_cvt\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_cvt\"))\n+  \"cortex_m4_ex_v\")\n+\n+(define_insn_reservation \"cortex_m4_f_load\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_load\"))\n+  \"cortex_m4_ex_v*2\")\n+\n+(define_insn_reservation \"cortex_m4_f_store\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_store\"))\n+  \"cortex_m4_ex_v*2\")\n+\n+(define_insn_reservation \"cortex_m4_f_loadd\" 3\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_loadd\"))\n+  \"cortex_m4_ex_v*3\")\n+\n+(define_insn_reservation \"cortex_m4_f_stored\" 3\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"f_stored\"))\n+  \"cortex_m4_ex_v*3\")\n+\n+;; MAC instructions consume their addend one cycle later. If the result\n+;; of an arithmetic instruction is consumed as the addend of the following\n+;; MAC instruction, the latency can be decreased by one.\n+\n+(define_bypass 1 \"cortex_m4_fadds,cortex_m4_fmuls,cortex_m4_f_cvt\"\n+\t\t \"cortex_m4_fmacs\"\n+\t\t \"arm_no_early_mul_dep\")\n+\n+(define_bypass 3 \"cortex_m4_fmacs\"\n+\t\t \"cortex_m4_fmacs\"\n+\t\t \"arm_no_early_mul_dep\")\n+\n+(define_bypass 14 \"cortex_m4_fdivs\"\n+\t\t  \"cortex_m4_fmacs\"\n+\t\t  \"arm_no_early_mul_dep\")"}, {"sha": "b71037585d0b8c57e57a1649511a57b74101557e", "filename": "gcc/config/arm/cortex-m4.md", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Fcortex-m4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d8f18da2a39bf816c05dfb2c81811292d8dc3a/gcc%2Fconfig%2Farm%2Fcortex-m4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-m4.md?ref=47d8f18da2a39bf816c05dfb2c81811292d8dc3a", "patch": "@@ -0,0 +1,111 @@\n+;; ARM Cortex-M4 pipeline description\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Contributed by CodeSourcery.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"cortex_m4\")\n+\n+;; We model the pipelining of LDR instructions by using two artificial units.\n+\n+(define_cpu_unit \"cortex_m4_a\" \"cortex_m4\")\n+\n+(define_cpu_unit \"cortex_m4_b\" \"cortex_m4\")\n+\n+(define_reservation \"cortex_m4_ex\" \"cortex_m4_a+cortex_m4_b\")\n+\n+;; ALU and multiply is one cycle.\n+(define_insn_reservation \"cortex_m4_alu\" 1\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"alu,alu_shift,alu_shift_reg,mult\"))\n+  \"cortex_m4_ex\")\n+\n+;; Byte, half-word and word load is two cycles.\n+(define_insn_reservation \"cortex_m4_load1\" 2\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"load_byte,load1\"))\n+  \"cortex_m4_a, cortex_m4_b\")\n+\n+;; str rx, [ry, #imm] is always one cycle.\n+(define_insn_reservation \"cortex_m4_store1_1\" 1\n+  (and (and (eq_attr \"tune\" \"cortexm4\")\n+\t    (eq_attr \"type\" \"store1\"))\n+       (ne (symbol_ref (\"arm_address_offset_is_imm (insn)\")) (const_int 0)))\n+  \"cortex_m4_a\")\n+\n+;; Other byte, half-word and word load is two cycles.\n+(define_insn_reservation \"cortex_m4_store1_2\" 2\n+  (and (and (eq_attr \"tune\" \"cortexm4\")\n+\t    (eq_attr \"type\" \"store1\"))\n+       (eq (symbol_ref (\"arm_address_offset_is_imm (insn)\")) (const_int 0)))\n+  \"cortex_m4_a*2\")\n+\n+(define_insn_reservation \"cortex_m4_load2\" 3\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"load2\"))\n+  \"cortex_m4_ex*3\")\n+\n+(define_insn_reservation \"cortex_m4_store2\" 3\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"store2\"))\n+  \"cortex_m4_ex*3\")\n+\n+(define_insn_reservation \"cortex_m4_load3\" 4\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"load3\"))\n+  \"cortex_m4_ex*4\")\n+\n+(define_insn_reservation \"cortex_m4_store3\" 4\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"store3\"))\n+  \"cortex_m4_ex*4\")\n+\n+(define_insn_reservation \"cortex_m4_load4\" 5\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"load4\"))\n+  \"cortex_m4_ex*5\")\n+\n+(define_insn_reservation \"cortex_m4_store4\" 5\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"store4\"))\n+  \"cortex_m4_ex*5\")\n+\n+;; If the address of load or store depends on the result of the preceding\n+;; instruction, the latency is increased by one.\n+\n+(define_bypass 2 \"cortex_m4_alu\"\n+\t\t \"cortex_m4_load1\"\n+\t\t \"arm_early_load_addr_dep\")\n+\n+(define_bypass 2 \"cortex_m4_alu\"\n+\t\t \"cortex_m4_store1_1,cortex_m4_store1_2\"\n+\t\t \"arm_early_store_addr_dep\")\n+\n+(define_insn_reservation \"cortex_m4_branch\" 3\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"branch\"))\n+  \"cortex_m4_ex*3\")\n+\n+(define_insn_reservation \"cortex_m4_call\" 3\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"call\"))\n+  \"cortex_m4_ex*3\")\n+\n+(define_insn_reservation \"cortex_m4_block\" 1\n+  (and (eq_attr \"tune\" \"cortexm4\")\n+       (eq_attr \"type\" \"block\"))\n+  \"cortex_m4_ex\")"}]}