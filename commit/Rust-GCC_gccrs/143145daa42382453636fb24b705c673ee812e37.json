{"sha": "143145daa42382453636fb24b705c673ee812e37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQzMTQ1ZGFhNDIzODI0NTM2MzZmYjI0YjcwNWM2NzNlZTgxMmUzNw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-05-13T02:16:22Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-05-13T02:16:22Z"}, "message": "sources.am, [...]: Rebuilt.\n\n\t* sources.am, Makefile.in: Rebuilt.\n\t* java/util/logging/LogManager.java: Removed.\n\t* java/util/logging/Logger.java (resetLogger): New method, from\n\tClasspath.\n\t* java/io/RandomAccessFile.java: Removed.\n\t* gnu/java/nio/channels/FileChannelImpl.java (create): New\n\tmethod.\n\t(FileChannelImpl): Now private.\n\t* java/io/FileInputStream.java: Removed.\n\t* java/io/FileOutputStream.java: Removed.\n\t* java/security/AccessControlContext.java: Removed.\n\t* java/lang/ThreadLocal.java: Removed.\n\t* java/lang/InheritableThreadLocal.java: Removed.\n\t* java/lang/Thread.java (locals): New field.\n\t(getThreadLocals): New method.\n\t* java/lang/natThread.cc (finish_): Clear 'locals'.\n\nFrom-SVN: r113735", "tree": {"sha": "86bc2116f67a8c7a59e8cb0a7732f0fb34197168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86bc2116f67a8c7a59e8cb0a7732f0fb34197168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/143145daa42382453636fb24b705c673ee812e37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143145daa42382453636fb24b705c673ee812e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143145daa42382453636fb24b705c673ee812e37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143145daa42382453636fb24b705c673ee812e37/comments", "author": null, "committer": null, "parents": [{"sha": "a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762"}], "stats": {"total": 3027, "additions": 102, "deletions": 2925}, "files": [{"sha": "d8fb754da4c23f13d85483f25eec4c32508c41f5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -1,3 +1,22 @@\n+2006-05-12  Tom Tromey  <tromey@redhat.com>\n+\n+\t* sources.am, Makefile.in: Rebuilt.\n+\t* java/util/logging/LogManager.java: Removed.\n+\t* java/util/logging/Logger.java (resetLogger): New method, from\n+\tClasspath.\n+\t* java/io/RandomAccessFile.java: Removed.\n+\t* gnu/java/nio/channels/FileChannelImpl.java (create): New\n+\tmethod.\n+\t(FileChannelImpl): Now private.\n+\t* java/io/FileInputStream.java: Removed.\n+\t* java/io/FileOutputStream.java: Removed.\n+\t* java/security/AccessControlContext.java: Removed.\n+\t* java/lang/ThreadLocal.java: Removed.\n+\t* java/lang/InheritableThreadLocal.java: Removed.\n+\t* java/lang/Thread.java (locals): New field.\n+\t(getThreadLocals): New method.\n+\t* java/lang/natThread.cc (finish_): Clear 'locals'.\n+\n 2006-05-11  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* gnu/gcj/runtime/NameFinder.java (lookup): If exec'ing addr2line"}, {"sha": "fcbe2cf402da87f38479792238cc9d776e063a9b", "filename": "libjava/Makefile.in", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.6 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -17,8 +17,6 @@\n \n \n \n-SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) $(lib_gnu_java_awt_peer_gtk_la_SOURCES) $(lib_gnu_java_awt_peer_qt_la_SOURCES) $(libgcj_la_SOURCES) $(libgcjawt_la_SOURCES) $(libgij_la_SOURCES) $(gcj_dbtool_SOURCES) $(gen_from_JIS_SOURCES) $(gij_SOURCES) $(grmic_SOURCES) $(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n-\n srcdir = @srcdir@\n top_srcdir = @top_srcdir@\n VPATH = @srcdir@\n@@ -3512,9 +3510,9 @@ classpath/java/io/Externalizable.java \\\n java/io/File.java \\\n classpath/java/io/FileDescriptor.java \\\n classpath/java/io/FileFilter.java \\\n-java/io/FileInputStream.java \\\n+classpath/java/io/FileInputStream.java \\\n classpath/java/io/FileNotFoundException.java \\\n-java/io/FileOutputStream.java \\\n+classpath/java/io/FileOutputStream.java \\\n classpath/java/io/FilePermission.java \\\n classpath/java/io/FileReader.java \\\n classpath/java/io/FileWriter.java \\\n@@ -3554,7 +3552,7 @@ java/io/PrintStream.java \\\n classpath/java/io/PrintWriter.java \\\n classpath/java/io/PushbackInputStream.java \\\n classpath/java/io/PushbackReader.java \\\n-java/io/RandomAccessFile.java \\\n+classpath/java/io/RandomAccessFile.java \\\n classpath/java/io/Reader.java \\\n classpath/java/io/SequenceInputStream.java \\\n classpath/java/io/Serializable.java \\\n@@ -3607,7 +3605,7 @@ classpath/java/lang/IllegalStateException.java \\\n classpath/java/lang/IllegalThreadStateException.java \\\n classpath/java/lang/IncompatibleClassChangeError.java \\\n classpath/java/lang/IndexOutOfBoundsException.java \\\n-java/lang/InheritableThreadLocal.java \\\n+classpath/java/lang/InheritableThreadLocal.java \\\n classpath/java/lang/InstantiationError.java \\\n classpath/java/lang/InstantiationException.java \\\n classpath/java/lang/Integer.java \\\n@@ -3647,7 +3645,7 @@ java/lang/System.java \\\n java/lang/Thread.java \\\n classpath/java/lang/ThreadDeath.java \\\n classpath/java/lang/ThreadGroup.java \\\n-java/lang/ThreadLocal.java \\\n+classpath/java/lang/ThreadLocal.java \\\n classpath/java/lang/Throwable.java \\\n classpath/java/lang/TypeNotPresentException.java \\\n classpath/java/lang/UnknownError.java \\\n@@ -3935,7 +3933,7 @@ classpath/java/rmi/server/Unreferenced.java\n \n java_rmi_server_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_rmi_server_source_files)))\n java_security_source_files = \\\n-java/security/AccessControlContext.java \\\n+classpath/java/security/AccessControlContext.java \\\n classpath/java/security/AccessControlException.java \\\n java/security/AccessController.java \\\n classpath/java/security/AlgorithmParameterGenerator.java \\\n@@ -4236,7 +4234,7 @@ classpath/java/util/logging/Filter.java \\\n classpath/java/util/logging/Formatter.java \\\n classpath/java/util/logging/Handler.java \\\n classpath/java/util/logging/Level.java \\\n-java/util/logging/LogManager.java \\\n+classpath/java/util/logging/LogManager.java \\\n classpath/java/util/logging/LogRecord.java \\\n java/util/logging/Logger.java \\\n classpath/java/util/logging/LoggingPermission.java \\\n@@ -7994,7 +7992,13 @@ uninstall-toolexecmainlibDATA:\n #     (which will cause the Makefiles to be regenerated when you run `make');\n # (2) otherwise, pass the desired values on the `make' command line.\n $(RECURSIVE_TARGETS):\n-\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n+\t@failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n \tdot_seen=no; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\\n \tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n@@ -8006,15 +8010,21 @@ $(RECURSIVE_TARGETS):\n \t    local_target=\"$$target\"; \\\n \t  fi; \\\n \t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\t  || eval $$failcom; \\\n \tdone; \\\n \tif test \"$$dot_seen\" = \"no\"; then \\\n \t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n \tfi; test -z \"$$fail\"\n \n mostlyclean-recursive clean-recursive distclean-recursive \\\n maintainer-clean-recursive:\n-\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n+\t@failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n \tdot_seen=no; \\\n \tcase \"$@\" in \\\n \t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n@@ -8035,7 +8045,7 @@ maintainer-clean-recursive:\n \t    local_target=\"$$target\"; \\\n \t  fi; \\\n \t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\t  || eval $$failcom; \\\n \tdone && test -z \"$$fail\"\n tags-recursive:\n \tlist='$(SUBDIRS)'; for subdir in $$list; do \\"}, {"sha": "db68b59691020c614c91faf48e380d0a3bfba041", "filename": "libjava/gnu/java/nio/channels/FileChannelImpl.java", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2Fchannels%2FFileChannelImpl.java?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -1,5 +1,5 @@\n /* FileChannelImpl.java -- \n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -103,7 +103,16 @@ public FileChannelImpl ()\n   }\n \n   /* Open a file.  MODE is a combination of the above mode flags. */\n-  public FileChannelImpl (File file, int mode) throws FileNotFoundException\n+  /* This is a static factory method, so that VM implementors can decide\n+   * substitute subclasses of FileChannelImpl. */\n+  public static FileChannelImpl create(File file, int mode)\n+    throws FileNotFoundException\n+  {\n+    return new FileChannelImpl(file, mode);\n+  }\n+\n+  /* Open a file.  MODE is a combination of the above mode flags. */\n+  private FileChannelImpl (File file, int mode) throws FileNotFoundException\n   {\n     final String path = file.getPath();\n     fd = open (path, mode);"}, {"sha": "f6a8faa8004f13de0caee9b00681479c209c3717", "filename": "libjava/java/io/FileInputStream.java", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fio%2FFileInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fio%2FFileInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileInputStream.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,309 +0,0 @@\n-/* FileInputStream.java -- An input stream that reads from disk files.\n-   Copyright (C) 1998, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.io;\n-\n-import gnu.java.nio.channels.FileChannelImpl;\n-\n-import java.nio.channels.FileChannel;\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n-/**\n- * This class is a stream that reads its bytes from a file. \n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Warren Levy (warrenl@cygnus.com)\n- */\n-public class FileInputStream extends InputStream\n-{\n-  /**\n-   * This is the native file handle for the file this stream is reading from\n-   */\n-  private FileDescriptor fd;\n-\n-  private FileChannelImpl ch;\n-\n-  /**\n-   * This method initializes a <code>FileInputStream</code> to read from the\n-   * specified named file.  A security check is first made to determine\n-   * whether or not access to this file is allowed.  This is done by\n-   * calling the <code>checkRead()</code> method of the \n-   * <code>SecurityManager</code>\n-   * (if one exists) with the name of this file.  An exception is thrown\n-   * if reading is not allowed.  If the file does not exist, an exception\n-   * is also thrown.\n-   *\n-   * @param name The name of the file this stream should read from\n-   *\n-   * @exception SecurityException If read access to the file is not allowed\n-   * @exception FileNotFoundException If the file does not exist \n-   * or if it is a directory\n-   */\n-  public FileInputStream(String name) throws FileNotFoundException\n-  {\n-    this(new File(name));\n-  }\n-\n-  /**\n-   * This method initializes a <code>FileInputStream</code> to read from the\n-   * specified <code>File</code> object.  A security check is first\n-   * made to determine\n-   * whether or not access to this file is allowed.  This is done by\n-   * calling the <code>checkRead()</code> method of the\n-   * <code>SecurityManager</code>\n-   * (if one exists) with the name of this file.  An exception is thrown\n-   * if reading is not allowed.  If the file does not exist, an exception\n-   * is also thrown.\n-   *\n-   * @param file The <code>File</code> object this stream should read from\n-   *\n-   * @exception SecurityException If read access to the file is not allowed\n-   * @exception FileNotFoundException If the file does not exist\n-   * or if it is a directory.\n-   */\n-  public FileInputStream(File file) throws FileNotFoundException\n-  {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkRead(file.getPath());\n-\n-    ch = new FileChannelImpl (file, FileChannelImpl.READ);\n-  }\n-\n-  /**\n-   * This method initializes a <code>FileInputStream</code> to read from the\n-   * specified <code>FileDescriptor</code> object.  A security\n-   * check is first made to\n-   * determine whether or not access to this file is allowed.  This is done by\n-   * calling the <code>checkRead()</code> method of the \n-   * <code>SecurityManager</code>\n-   * (if one exists) with the specified <code>FileDescriptor</code>  \n-   * An exception is \n-   * thrown if reading is not allowed.\n-   *\n-   * @param fdObj The <code>FileDescriptor</code> object this stream \n-   * should read from\n-   *\n-   * @exception SecurityException If read access to the file is not allowed\n-   */\n-  public FileInputStream(FileDescriptor fdObj)\n-  {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkRead(fdObj);\n-\n-    fd = fdObj;\n-    ch = (FileChannelImpl) fdObj.channel;\n-  }\n-\n-  FileInputStream(FileChannelImpl ch)\n-  {\n-    this.ch = ch;\n-  }\n-\n-  /**\n-   * This method returns the number of bytes that can be read from this\n-   * stream before a read can block.  A return of 0 indicates that blocking\n-   * might (or might not) occur on the very next read attempt.\n-   * <p>\n-   * This method returns the number of unread bytes remaining in the file if\n-   * the descriptor being read from is an actual file.  If this method is\n-   * reading from a ''special'' file such a the standard input, this method\n-   * will return the appropriate value for the stream being read.\n-   * <p>\n-   * Be aware that reads on plain files that do not reside locally might\n-   * possibly block even if this method says they should not.  For example,\n-   * a remote server might crash, preventing an NFS mounted file from being\n-   * read.\n-   *\n-   * @return The number of bytes that can be read before blocking could occur\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public int available() throws IOException\n-  {\n-    return ch.available();\n-  }\n-\n-  /**\n-   * This method closes the stream.  Any futher attempts to read from the\n-   * stream will likely generate an IOException since the underlying file\n-   * will be closed.\n-   *\n-   * @exception IOException If an error occurs.\n-   */\n-  public void close() throws IOException\n-  {\n-    ch.close();\n-  }\n-\n-  protected void finalize() throws IOException\n-  {\n-    // We don't actually need this, but we include it because it is\n-    // mentioned in the JCL.\n-  }\n-\n-  /**\n-   * This method returns a <code>FileDescriptor</code> object representing the\n-   * underlying native file handle of the file this stream is reading\n-   * from\n-   *\n-   * @return A <code>FileDescriptor</code> for this stream\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final FileDescriptor getFD() throws IOException\n-  {\n-    synchronized (this)\n-      {\n-\tif (fd == null)\n-\t  fd = new FileDescriptor (ch);\n-\treturn fd;\n-      }\n-  }\n-\n-  /**\n-   * This method reads an unsigned byte from the input stream and returns it\n-   * as an int in the range of 0-255.  This method also will return -1 if\n-   * the end of the stream has been reached.\n-   * <p>\n-   * This method will block until the byte can be read.\n-   *\n-   * @return The byte read or -1 if end of stream\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public int read() throws IOException\n-  {\n-    return ch.read();\n-  }\n-\n-  /**\n-   * This method reads bytes from a stream and stores them into a caller\n-   * supplied buffer.  This method attempts to completely fill the buffer,\n-   * but can return before doing so.  The actual number of bytes read is\n-   * returned as an int.  A -1 is returned to indicate the end of the stream.\n-   * <p>\n-   * This method will block until some data can be read.\n-   * <p>\n-   * This method operates by calling an overloaded read method like so:\n-   * <code>read(buf, 0, buf.length)</code>\n-   *\n-   * @param buf The buffer into which the bytes read will be stored.\n-   *\n-   * @return The number of bytes read or -1 if end of stream.\n-   *\n-   * @exception IOException If an error occurs.\n-   */\n-  public int read(byte[] buf) throws IOException\n-  {\n-    return read(buf, 0, buf.length);\n-  }\n-\n-  /**\n-   * This method read bytes from a stream and stores them into a caller\n-   * supplied buffer.  It starts storing the data at index \n-   * <code>offset</code> into\n-   * the buffer and attempts to read <code>len</code> bytes.  This method can\n-   * return before reading the number of bytes requested.  The actual number\n-   * of bytes read is returned as an int.  A -1 is returned to indicate the\n-   * end of the stream.\n-   * <p>\n-   * This method will block until some data can be read.\n-   *\n-   * @param buf The array into which the bytes read should be stored\n-   * @param offset The offset into the array to start storing bytes\n-   * @param len The requested number of bytes to read\n-   *\n-   * @return The actual number of bytes read, or -1 if end of stream.\n-   *\n-   * @exception IOException If an error occurs.\n-   */\n-  public int read(byte[] buf, int offset, int len) throws IOException\n-  {\n-    if (offset < 0\n-        || len < 0\n-        || offset + len > buf.length)\n-      throw new ArrayIndexOutOfBoundsException();\n-\n-    return ch.read(buf, offset, len);\n-  }\n-\n-  /**\n-   * This method skips the specified number of bytes in the stream.  It\n-   * returns the actual number of bytes skipped, which may be less than the\n-   * requested amount.\n-   * <p>\n-   * @param numBytes The requested number of bytes to skip\n-   *\n-   * @return The actual number of bytes skipped.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public synchronized long skip (long numBytes) throws IOException\n-  {\n-    if (numBytes < 0)\n-      throw new IllegalArgumentException (\"Can't skip negative bytes: \" + \n-                                          numBytes);\n-\n-    if (numBytes == 0)\n-      return 0;\n-\n-    long oldPos = ch.position ();\n-    ch.position(oldPos + numBytes);\n-    return ch.position() - oldPos;\n-  }\n-\n-  /**\n-   * This method creates a java.nio.channels.FileChannel.\n-   * Nio does not allow one to create a file channel directly.\n-   * A file channel must be created by first creating an instance of\n-   * Input/Output/RandomAccessFile and invoking the getChannel() method on it.\n-   */\n-  public synchronized FileChannel getChannel () \n-  {\n-    return ch;\n-  }\n-\n-} // class FileInputStream\n-"}, {"sha": "40e72aff7daa33c3f7a86081e1c4f161277103a4", "filename": "libjava/java/io/FileOutputStream.java", "status": "removed", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fio%2FFileOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fio%2FFileOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileOutputStream.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,296 +0,0 @@\n-/* FileOutputStream.java -- Writes to a file on disk.\n-   Copyright (C) 1998, 2001, 2003, 2004, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.io;\n-\n-import gnu.java.nio.channels.FileChannelImpl;\n-\n-import java.nio.channels.FileChannel;\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status:  Complete to version 1.1.\n- */\n-\n-/**\n- * This classes allows a stream of data to be written to a disk file or\n- * any open <code>FileDescriptor</code>.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Tom Tromey (tromey@cygnus.com)\n- */\n-public class FileOutputStream extends OutputStream\n-{\n-  private FileDescriptor fd;\n-\n-  private FileChannelImpl ch;\n-\n-  /**\n-   * This method initializes a <code>FileOutputStream</code> object to write\n-   * to the named file.  The file is created if it does not exist, and\n-   * the bytes written are written starting at the beginning of the file if\n-   * the <code>append</code> argument is <code>false</code> or at the end\n-   * of the file if the <code>append</code> argument is true.\n-   * <p>\n-   * Before opening a file, a security check is performed by calling the\n-   * <code>checkWrite</code> method of the <code>SecurityManager</code> (if\n-   * one exists) with the name of the file to be opened.  An exception is\n-   * thrown if writing is not allowed. \n-   *\n-   * @param path The name of the file this stream should write to\n-   * @param append <code>true</code> to append bytes to the end of the file,\n-   * or <code>false</code> to write bytes to the beginning\n-   *\n-   * @exception SecurityException If write access to the file is not allowed\n-   * @exception FileNotFoundException If a non-security error occurs\n-   */\n-  public FileOutputStream (String path, boolean append)\n-    throws SecurityException, FileNotFoundException\n-  {\n-    this (new File(path), append);\n-  }\n-\n-  /**\n-   * This method initializes a <code>FileOutputStream</code> object to write\n-   * to the named file.  The file is created if it does not exist, and\n-   * the bytes written are written starting at the beginning of the file.\n-   * <p>\n-   * Before opening a file, a security check is performed by calling the\n-   * <code>checkWrite</code> method of the <code>SecurityManager</code> (if\n-   * one exists) with the name of the file to be opened.  An exception is\n-   * thrown if writing is not allowed. \n-   *\n-   * @param path The name of the file this stream should write to\n-   *\n-   * @exception SecurityException If write access to the file is not allowed\n-   * @exception FileNotFoundException If a non-security error occurs\n-   */\n-  public FileOutputStream (String path)\n-    throws SecurityException, FileNotFoundException\n-  {\n-    this (path, false);\n-  }\n-\n-  /**\n-   * This method initializes a <code>FileOutputStream</code> object to write\n-   * to the specified <code>File</code> object.  The file is created if it \n-   * does not exist, and the bytes written are written starting at the \n-   * beginning of the file.\n-   * <p>\n-   * Before opening a file, a security check is performed by calling the\n-   * <code>checkWrite</code> method of the <code>SecurityManager</code> (if\n-   * one exists) with the name of the file to be opened.  An exception is\n-   * thrown if writing is not allowed. \n-   *\n-   * @param file The <code>File</code> object this stream should write to\n-   *\n-   * @exception SecurityException If write access to the file is not allowed\n-   * @exception FileNotFoundException If a non-security error occurs\n-   */\n-  public FileOutputStream (File file)\n-    throws SecurityException, FileNotFoundException\n-  {\n-    this (file, false);\n-  }\n-\n-  /**\n-   * This method initializes a <code>FileOutputStream</code> object to write\n-   * to the specified <code>File</code> object.  The file is created if it \n-   * does not exist, and the bytes written are written starting at the \n-   * beginning of the file if the <code>append</code> parameter is \n-   * <code>false</code>.  Otherwise bytes are written at the end of the\n-   * file.\n-   * <p>\n-   * Before opening a file, a security check is performed by calling the\n-   * <code>checkWrite</code> method of the <code>SecurityManager</code> (if\n-   * one exists) with the name of the file to be opened.  An exception is\n-   * thrown if writing is not allowed. \n-   *\n-   * @param file The <code>File</code> object this stream should write to\n-   * @param append <code>true</code> to append bytes to the end of the file,\n-   * or <code>false</code> to write bytes to the beginning\n-   *\n-   * @exception SecurityException If write access to the file is not allowed\n-   * @exception FileNotFoundException If a non-security error occurs\n-   */\n-  public FileOutputStream (File file, boolean append)\n-    throws FileNotFoundException\n-  {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkWrite(file.getPath());\n-\n-   ch = new FileChannelImpl (file, (append\n-\t\t\t\t    ? FileChannelImpl.WRITE\n-\t\t\t\t    | FileChannelImpl.APPEND\n-\t\t\t\t    : FileChannelImpl.WRITE));\n-  }\n-\n-  /**\n-   * This method initializes a <code>FileOutputStream</code> object to write\n-   * to the file represented by the specified <code>FileDescriptor</code>\n-   * object.  This method does not create any underlying disk file or\n-   * reposition the file pointer of the given descriptor.  It assumes that\n-   * this descriptor is ready for writing as is.\n-   * <p>\n-   * Before opening a file, a security check is performed by calling the\n-   * <code>checkWrite</code> method of the <code>SecurityManager</code> (if\n-   * one exists) with the specified <code>FileDescriptor</code> as an argument.\n-   * An exception is thrown if writing is not allowed. \n-   *\n-   * @param fdObj The <code>FileDescriptor</code> this stream should write to\n-   *\n-   * @exception SecurityException If write access to the file is not allowed\n-   */\n-  public FileOutputStream (FileDescriptor fdObj)\n-    throws SecurityException\n-  {\n-    // Hmm, no other exception but this one to throw, but if the descriptor\n-    // isn't valid, we surely don't have \"permission\" to write to it.\n-    if (!fdObj.valid())\n-      throw new SecurityException(\"Invalid FileDescriptor\");\n-\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkWrite(fdObj);\n-\n-    fd = fdObj;\n-    ch = (FileChannelImpl) fdObj.channel;\n-  }\n-\n-  FileOutputStream(FileChannelImpl ch)\n-  {\n-    this.ch = ch;\n-  }\n-\n-  protected void finalize () throws IOException\n-  {\n-    // We don't actually need this, but we include it because it is\n-    // mentioned in the JCL.\n-  }\n-\n-  /**\n-   * This method returns a <code>FileDescriptor</code> object representing\n-   * the file that is currently being written to\n-   *\n-   * @return A <code>FileDescriptor</code> object for this stream\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final FileDescriptor getFD () throws IOException\n-  {\n-    synchronized (this)\n-      {\n-\tif (fd == null)\n-\t  fd = new FileDescriptor (ch);\n-\treturn fd;\n-      }\n-  }\n-\n-  /**\n-   * This method writes a single byte of data to the file.  \n-   *\n-   * @param b The byte of data to write, passed as an <code>int</code>\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void write (int b) throws IOException\n-  {\n-    ch.write (b);\n-  }\n-\n-  /**\n-   * This method writes all the bytes in the specified array to the\n-   * file.\n-   *\n-   * @param buf The array of bytes to write to the file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void write (byte[] buf)\n-    throws IOException\n-  {\n-    write (buf, 0, buf.length);\n-  }\n-\n-  /**\n-   * This method writes <code>len</code> bytes from the byte array \n-   * <code>buf</code> to the file starting at index <code>offset</code>.\n-   *\n-   * @param buf The array of bytes to write to the file\n-   * @param offset The offset into the array to start writing bytes from\n-   * @param len The number of bytes to write to the file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void write (byte[] buf, int offset, int len)\n-    throws IOException\n-  {\n-    if (offset < 0\n-        || len < 0\n-        || offset + len > buf.length)\n-      throw new ArrayIndexOutOfBoundsException ();\n-    \n-    ch.write (buf, offset, len);\n-  }\n-\n-  /**\n-   * This method closes the underlying file.  Any further attempts to\n-   * write to this stream will likely generate an exception since the\n-   * file is closed.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void close () throws IOException\n-  {\n-    ch.close();\n-  }\n-\n-  /**\n-   * This method creates a java.nio.channels.FileChannel.\n-   * Nio does not allow one to create a file channel directly.\n-   * A file channel must be created by first creating an instance of\n-   * Input/Output/RandomAccessFile and invoking the getChannel() method on it.\n-   */\n-  public synchronized FileChannel getChannel() \n-  {\n-    return ch;\n-  }\n-\n-} // class FileOutputStream\n-"}, {"sha": "129d6b642cf2778380e9cbbe058187d461537689", "filename": "libjava/java/io/RandomAccessFile.java", "status": "removed", "additions": 0, "deletions": 991, "changes": 991, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FRandomAccessFile.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,991 +0,0 @@\n-/* RandomAccessFile.java -- Class supporting random file I/O\n-   Copyright (C) 1998, 1999, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.io;\n-\n-import gnu.java.nio.channels.FileChannelImpl;\n-\n-import java.nio.channels.FileChannel;\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * Status: Believe complete and correct to 1.1.\n- */\n-\n-/**\n- * This class allows reading and writing of files at random locations.\n- * Most Java I/O classes are either pure sequential input or output.  This\n- * class fulfills the need to be able to read the bytes of a file in an\n- * arbitrary order.  In addition, this class implements the\n- * <code>DataInput</code> and <code>DataOutput</code> interfaces to allow\n- * the reading and writing of Java primitives.\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Tom Tromey (tromey@cygnus.com)\n- */\n-public class RandomAccessFile implements DataOutput, DataInput\n-{\n-\n-  // The underlying file.\n-  private FileChannelImpl ch;\n-  private FileDescriptor fd;\n-  // The corresponding input and output streams.\n-  private DataOutputStream out;\n-  private DataInputStream in;\n-  \n-  \n-  /**\n-   * This method initializes a new instance of <code>RandomAccessFile</code>\n-   * to read from the specified <code>File</code> object with the specified \n-   * access mode.   The access mode is either \"r\" for read only access or \"rw\" \n-   * for read-write access.\n-   * <p>\n-   * Note that a <code>SecurityManager</code> check is made prior to\n-   * opening the file to determine whether or not this file is allowed to\n-   * be read or written.\n-   *\n-   * @param file The <code>File</code> object to read and/or write.\n-   * @param mode \"r\" for read only or \"rw\" for read-write access to the file\n-   *\n-   * @exception IllegalArgumentException If <code>mode</code> has an \n-   * illegal value\n-   * @exception SecurityException If the requested access to the file \n-   * is not allowed\n-   * @exception FileNotFoundException If the file is a directory, or \n-   * any other error occurs\n-   */\n-  public RandomAccessFile (File file, String mode)\n-    throws FileNotFoundException\n-  {\n-    int fdmode;\n-    if (mode.equals(\"r\"))\n-      fdmode = FileChannelImpl.READ;\n-    else if (mode.equals(\"rw\"))\n-      fdmode = FileChannelImpl.READ | FileChannelImpl.WRITE;\n-    else if (mode.equals(\"rws\"))\n-      {\n-\tfdmode = (FileChannelImpl.READ | FileChannelImpl.WRITE\n-\t\t  | FileChannelImpl.SYNC);\n-      }\n-    else if (mode.equals(\"rwd\"))\n-      {\n-\tfdmode = (FileChannelImpl.READ | FileChannelImpl.WRITE\n-\t\t  | FileChannelImpl.DSYNC);\n-      }\n-    else\n-      throw new IllegalArgumentException (\"invalid mode: \" + mode);\n-\n-    final String fileName = file.getPath();\n-\n-    // The obligatory SecurityManager stuff\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      {\n-        s.checkRead(fileName);\n-\n-        if ((fdmode & FileChannelImpl.WRITE) != 0)\n-          s.checkWrite(fileName);\n-      }\n-\n-    ch = new FileChannelImpl (file, fdmode);\n-    fd = new FileDescriptor(ch);\n-    out = new DataOutputStream (new FileOutputStream (fd));\n-    in = new DataInputStream (new FileInputStream (fd));\n-  }\n-\n-  /**\n-   * This method initializes a new instance of <code>RandomAccessFile</code>\n-   * to read from the specified file name with the specified access mode.\n-   * The access mode is either \"r\" for read only access, \"rw\" for read\n-   * write access, \"rws\" for synchronized read/write access of both\n-   * content and metadata, or \"rwd\" for read/write access\n-   * where only content is required to be synchronous.\n-   * <p>\n-   * Note that a <code>SecurityManager</code> check is made prior to\n-   * opening the file to determine whether or not this file is allowed to\n-   * be read or written.\n-   *\n-   * @param fileName The name of the file to read and/or write\n-   * @param mode \"r\", \"rw\", \"rws\", or \"rwd\"\n-   *\n-   * @exception IllegalArgumentException If <code>mode</code> has an \n-   * illegal value\n-   * @exception SecurityException If the requested access to the file \n-   * is not allowed\n-   * @exception FileNotFoundException If the file is a directory or \n-   * any other error occurs\n-   */\n-  public RandomAccessFile (String fileName, String mode)\n-    throws FileNotFoundException\n-  {\n-    this (new File(fileName), mode);\n-  }\n-\n-  /**\n-   * This method closes the file and frees up all file related system\n-   * resources.  Since most operating systems put a limit on how many files\n-   * may be opened at any given time, it is a good idea to close all files\n-   * when no longer needed to avoid hitting this limit\n-   */\n-  public void close () throws IOException\n-  {\n-    ch.close();\n-  }\n-\n-  /**\n-   * This method returns a <code>FileDescriptor</code> object that \n-   * represents the native file handle for this file.\n-   *\n-   * @return The <code>FileDescriptor</code> object for this file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final FileDescriptor getFD () throws IOException\n-  {\n-    synchronized (this)\n-      {\n-\tif (fd == null)\n-\t  fd = new FileDescriptor (ch);\n-\treturn fd;\n-      }\n-  }\n-\n-  /**\n-   * This method returns the current offset in the file at which the next\n-   * read or write will occur\n-   *\n-   * @return The current file position\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public long getFilePointer () throws IOException\n-  {\n-    return ch.position();\n-  }\n-\n-  /**\n-   * This method sets the length of the file to the specified length.\n-   * If the currently length of the file is longer than the specified\n-   * length, then the file is truncated to the specified length (the\n-   * file position is set to the end of file in this case).  If the\n-   * current length of the file is shorter than the specified length,\n-   * the file is extended with bytes of an undefined value (the file\n-   * position is unchanged in this case).\n-   * <p>\n-   * The file must be open for write access for this operation to succeed.\n-   *\n-   * @param newLen The new length of the file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void setLength (long newLen) throws IOException\n-  {\n-    // FIXME: Extending a file should probably be done by one method call.\n-\n-    // FileChannel.truncate() can only shrink a file.\n-    // To expand it we need to seek forward and write at least one byte.\n-    if (newLen < length())\n-      ch.truncate (newLen);\n-    else if (newLen > length())\n-      {\n-\tlong pos = getFilePointer();\n-\tseek(newLen - 1);\n-\twrite(0);\n-\tseek(pos);\n-      }\n-  }\n-\n-  /**\n-   * This method returns the length of the file in bytes\n-   *\n-   * @return The length of the file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public long length () throws IOException\n-  {\n-    return ch.size();\n-  }\n-\n-  /**\n-   * This method reads a single byte of data from the file and returns it\n-   * as an integer.\n-   *\n-   * @return The byte read as an int, or -1 if the end of the file was reached.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public int read () throws IOException\n-  {\n-    return in.read();\n-  }\n-\n-  /**\n-   * This method reads bytes from the file into the specified array.  The\n-   * bytes are stored starting at the beginning of the array and up to \n-   * <code>buf.length</code> bytes can be read.\n-   *\n-   * @param buffer The buffer to read bytes from the file into\n-   *\n-   * @return The actual number of bytes read or -1 if end of file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public int read (byte[] buffer) throws IOException\n-  {\n-    return in.read (buffer);\n-  }\n-\n-  /**\n-   * This methods reads up to <code>len</code> bytes from the file into the\n-   * specified array starting at position <code>offset</code> into the array.\n-   *\n-   * @param buffer The array to read the bytes into\n-   * @param offset The index into the array to start storing bytes\n-   * @param len The requested number of bytes to read\n-   *\n-   * @return The actual number of bytes read, or -1 if end of file\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public int read (byte[] buffer, int offset, int len) throws IOException\n-  {\n-    return in.read (buffer, offset, len);\n-  }\n-\n-  /**\n-   * This method reads a Java boolean value from an input stream.  It does\n-   * so by reading a single byte of data.  If that byte is zero, then the\n-   * value returned is <code>false</code>  If the byte is non-zero, then\n-   * the value returned is <code>true</code>\n-   * <p>\n-   * This method can read a <code>boolean</code> written by an object \n-   * implementing the\n-   * <code>writeBoolean()</code> method in the <code>DataOutput</code> \n-   * interface.\n-   *\n-   * @return The <code>boolean</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading the \n-   * boolean\n-   * @exception IOException If any other error occurs\n-   */\n-  public final boolean readBoolean () throws IOException\n-  {\n-    return in.readBoolean ();\n-  }\n-\n-  /**\n-   * This method reads a Java byte value from an input stream.  The value\n-   * is in the range of -128 to 127.\n-   * <p>\n-   * This method can read a <code>byte</code> written by an object \n-   * implementing the \n-   * <code>writeByte()</code> method in the <code>DataOutput</code> interface.\n-   *\n-   * @return The <code>byte</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading the byte\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final byte readByte () throws IOException\n-  {\n-    return in.readByte ();\n-  }\n-\n-  /**\n-   * This method reads a Java <code>char</code> value from an input stream.  \n-   * It operates by reading two bytes from the stream and converting them to \n-   * a single 16-bit Java <code>char</code>  The two bytes are stored most\n-   * significant byte first (i.e., \"big endian\") regardless of the native\n-   * host byte ordering. \n-   * <p>\n-   * As an example, if <code>byte1</code> and <code>byte2</code> represent \n-   * the first\n-   * and second byte read from the stream respectively, they will be\n-   * transformed to a <code>char</code> in the following manner:\n-   * <p>\n-   * <code>(char)(((byte1 &amp; 0xFF) &lt;&lt; 8) | (byte2 &amp; 0xFF)</code>\n-   * <p>\n-   * This method can read a <code>char</code> written by an object \n-   * implementing the\n-   * <code>writeChar()</code> method in the <code>DataOutput</code> interface.\n-   *\n-   * @return The <code>char</code> value read \n-   *\n-   * @exception EOFException If end of file is reached before reading the char\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final char readChar () throws IOException\n-  {\n-    return in.readChar();\n-  }\n-\n-  /**\n-   * This method reads a Java double value from an input stream.  It operates\n-   * by first reading a <code>logn</code> value from the stream by calling the\n-   * <code>readLong()</code> method in this interface, then \n-   * converts that <code>long</code>\n-   * to a <code>double</code> using the <code>longBitsToDouble</code> \n-   * method in the class <code>java.lang.Double</code>\n-   * <p>\n-   * This method can read a <code>double</code> written by an object \n-   * implementing the\n-   * <code>writeDouble()</code> method in the <code>DataOutput</code> \n-   * interface.\n-   *\n-   * @return The <code>double</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading \n-   * the double\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see java.lang.Double\n-   * @see DataOutput\n-   */\n-  public final double readDouble () throws IOException\n-  {\n-    return in.readDouble ();\n-  }\n-\n-  /**\n-   * This method reads a Java float value from an input stream.  It operates\n-   * by first reading an <code>int</code> value from the stream by calling the\n-   * <code>readInt()</code> method in this interface, then converts \n-   * that <code>int</code>\n-   * to a <code>float</code> using the <code>intBitsToFloat</code> method in \n-   * the class <code>java.lang.Float</code>\n-   * <p>\n-   * This method can read a <code>float</code> written by an object \n-   * implementing the\n-   * <code>writeFloat()</code> method in the <code>DataOutput</code> interface.\n-   *\n-   * @return The <code>float</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading the float\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see java.lang.Float\n-   * @see DataOutput\n-   */\n-  public final float readFloat () throws IOException\n-  {\n-    return in.readFloat();\n-  }\n-\n-  /**\n-   * This method reads raw bytes into the passed array until the array is\n-   * full.  Note that this method blocks until the data is available and\n-   * throws an exception if there is not enough data left in the stream to\n-   * fill the buffer\n-   *\n-   * @param buffer The buffer into which to read the data\n-   *\n-   * @exception EOFException If end of file is reached before filling the \n-   * buffer\n-   * @exception IOException If any other error occurs\n-   */\n-  public final void readFully (byte[] buffer) throws IOException\n-  {\n-    in.readFully(buffer);\n-  }\n-\n-  /**\n-   * This method reads raw bytes into the passed array <code>buf</code> \n-   * starting\n-   * <code>offset</code> bytes into the buffer.  The number of bytes read \n-   * will be\n-   * exactly <code>len</code>  Note that this method blocks until the data is \n-   * available and throws an exception if there is not enough data left in \n-   * the stream to read <code>len</code> bytes.\n-   *\n-   * @param buffer The buffer into which to read the data\n-   * @param offset The offset into the buffer to start storing data\n-   * @param count The number of bytes to read into the buffer\n-   *\n-   * @exception EOFException If end of file is reached before filling \n-   * the buffer\n-   * @exception IOException If any other error occurs\n-   */\n-  public final void readFully (byte[] buffer, int offset, int count)\n-    throws IOException\n-  {\n-    in.readFully (buffer, offset, count);\n-  }\n-\n-  /**\n-   * This method reads a Java <code>int</code> value from an input stream\n-   * It operates by reading four bytes from the stream and converting them to \n-   * a single Java <code>int</code>  The bytes are stored most\n-   * significant byte first (i.e., \"big endian\") regardless of the native\n-   * host byte ordering. \n-   * <p>\n-   * As an example, if <code>byte1</code> through <code>byte4</code> \n-   * represent the first\n-   * four bytes read from the stream, they will be\n-   * transformed to an <code>int</code> in the following manner:\n-   * <p>\n-   * <code>(int)(((byte1 &amp; 0xFF) &lt;&lt; 24) + ((byte2 &amp; 0xFF) &lt;&lt; 16) + \n-   * ((byte3 &amp; 0xFF) &lt;&lt; 8) + (byte4 &amp; 0xFF)))</code>\n-   * <p>\n-   * The value returned is in the range of 0 to 65535.\n-   * <p>\n-   * This method can read an <code>int</code> written by an object \n-   * implementing the\n-   * <code>writeInt()</code> method in the <code>DataOutput</code> interface.\n-   *\n-   * @return The <code>int</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading the int\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final int readInt () throws IOException\n-  {\n-    return in.readInt();\n-  }\n-\n-  /**\n-   * This method reads the next line of text data from an input stream.\n-   * It operates by reading bytes and converting those bytes to \n-   * <code>char</code>\n-   * values by treating the byte read as the low eight bits of the \n-   * <code>char</code>\n-   * and using <code>0</code> as the high eight bits.  Because of this, it does\n-   * not support the full 16-bit Unicode character set.\n-   * <p>\n-   * The reading of bytes ends when either the end of file or a line terminator\n-   * is encountered.  The bytes read are then returned as a <code>String</code>\n-   * A line terminator is a byte sequence consisting of either \n-   * <code>\\r</code> <code>\\n</code> or <code>\\r\\n</code>  These \n-   * termination charaters are\n-   * discarded and are not returned as part of the string.\n-   * <p>\n-   * This method can read data that was written by an object implementing the\n-   * <code>writeLine()</code> method in <code>DataOutput</code>\n-   *\n-   * @return The line read as a <code>String</code>\n-   *\n-   * @exception IOException If an error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final String readLine () throws IOException\n-  {\n-    return in.readLine ();\n-  }\n-\n-  /**\n-   * This method reads a Java long value from an input stream\n-   * It operates by reading eight bytes from the stream and converting them to \n-   * a single Java <code>long</code>  The bytes are stored most\n-   * significant byte first (i.e., \"big endian\") regardless of the native\n-   * host byte ordering. \n-   * <p>\n-   * As an example, if <code>byte1</code> through <code>byte8</code> \n-   * represent the first\n-   * eight bytes read from the stream, they will be\n-   * transformed to an <code>long</code> in the following manner:\n-   * <p>\n-   * <code>\n-   * (long)((((long)byte1 &amp; 0xFF) &lt;&lt; 56) + (((long)byte2 &amp; 0xFF) &lt;&lt; 48) + \n-   * (((long)byte3 &amp; 0xFF) &lt;&lt; 40) + (((long)byte4 &amp; 0xFF) &lt;&lt; 32) + \n-   * (((long)byte5 &amp; 0xFF) &lt;&lt; 24) + (((long)byte6 &amp; 0xFF) &lt;&lt; 16) + \n-   * (((long)byte7 &amp; 0xFF) &lt;&lt; 8) + ((long)byte9 &amp; 0xFF)))</code>\n-   * <p>\n-   * The value returned is in the range of 0 to 65535.\n-   * <p>\n-   * This method can read an <code>long</code> written by an object \n-   * implementing the\n-   * <code>writeLong()</code> method in the <code>DataOutput</code> interface.\n-   *\n-   * @return The <code>long</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading the long\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final long readLong () throws IOException\n-  {\n-    return in.readLong();\n-  }\n-\n-  /**\n-   * This method reads a signed 16-bit value into a Java in from the stream.\n-   * It operates by reading two bytes from the stream and converting them to \n-   * a single 16-bit Java <code>short</code>  The two bytes are stored most\n-   * significant byte first (i.e., \"big endian\") regardless of the native\n-   * host byte ordering. \n-   * <p>\n-   * As an example, if <code>byte1</code> and <code>byte2</code> \n-   * represent the first\n-   * and second byte read from the stream respectively, they will be\n-   * transformed to a <code>short</code> in the following manner:\n-   * <p>\n-   * <code>(short)(((byte1 &amp; 0xFF) &lt;&lt; 8) | (byte2 &amp; 0xFF)</code>\n-   * <p>\n-   * The value returned is in the range of -32768 to 32767.\n-   * <p>\n-   * This method can read a <code>short</code> written by an object \n-   * implementing the\n-   * <code>writeShort()</code> method in the <code>DataOutput</code> interface.\n-   *\n-   * @return The <code>short</code> value read\n-   *\n-   * @exception EOFException If end of file is reached before reading the value\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final short readShort () throws IOException\n-  {\n-    return in.readShort();\n-  }\n-\n-  /**\n-   * This method reads 8 unsigned bits into a Java <code>int</code> value \n-   * from the \n-   * stream. The value returned is in the range of 0 to 255.\n-   * <p>\n-   * This method can read an unsigned byte written by an object implementing \n-   * the <code>writeUnsignedByte()</code> method in the \n-   * <code>DataOutput</code> interface.\n-   *\n-   * @return The unsigned bytes value read as a Java <code>int</code>\n-   *\n-   * @exception EOFException If end of file is reached before reading the value\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final int readUnsignedByte () throws IOException\n-  {\n-    return in.readUnsignedByte();\n-  }\n-\n-  /**\n-   * This method reads 16 unsigned bits into a Java int value from the stream.\n-   * It operates by reading two bytes from the stream and converting them to \n-   * a single Java <code>int</code>  The two bytes are stored most\n-   * significant byte first (i.e., \"big endian\") regardless of the native\n-   * host byte ordering. \n-   * <p>\n-   * As an example, if <code>byte1</code> and <code>byte2</code> \n-   * represent the first\n-   * and second byte read from the stream respectively, they will be\n-   * transformed to an <code>int</code> in the following manner:\n-   * <p>\n-   * <code>(int)(((byte1 &amp; 0xFF) &lt;&lt; 8) + (byte2 &amp; 0xFF))</code>\n-   * <p>\n-   * The value returned is in the range of 0 to 65535.\n-   * <p>\n-   * This method can read an unsigned short written by an object implementing\n-   * the <code>writeUnsignedShort()</code> method in the \n-   * <code>DataOutput</code> interface.\n-   *\n-   * @return The unsigned short value read as a Java <code>int</code>\n-   *\n-   * @exception EOFException If end of file is reached before reading the value\n-   * @exception IOException If any other error occurs\n-   */\n-  public final int readUnsignedShort () throws IOException\n-  {\n-    return in.readUnsignedShort();\n-  }\n-\n-  /**\n-   * This method reads a <code>String</code> from an input stream that \n-   * is encoded in\n-   * a modified UTF-8 format.  This format has a leading two byte sequence\n-   * that contains the remaining number of bytes to read.  This two byte\n-   * sequence is read using the <code>readUnsignedShort()</code> method of this\n-   * interface.\n-   * <p>\n-   * After the number of remaining bytes have been determined, these bytes\n-   * are read an transformed into <code>char</code> values.  \n-   * These <code>char</code> values\n-   * are encoded in the stream using either a one, two, or three byte format.\n-   * The particular format in use can be determined by examining the first\n-   * byte read.  \n-   * <p>\n-   * If the first byte has a high order bit of 0 then\n-   * that character consists on only one byte.  This character value consists\n-   * of seven bits that are at positions 0 through 6 of the byte.  As an\n-   * example, if <code>byte1</code> is the byte read from the stream, it would\n-   * be converted to a <code>char</code> like so:\n-   * <p>\n-   * <code>(char)byte1</code>\n-   * <p>\n-   * If the first byte has <code>110</code> as its high order bits, then the \n-   * character consists of two bytes.  The bits that make up the character\n-   * value are in positions 0 through 4 of the first byte and bit positions\n-   * 0 through 5 of the second byte.  (The second byte should have \n-   * 10 as its high order bits).  These values are in most significant\n-   * byte first (i.e., \"big endian\") order.\n-   * <p>\n-   * As an example, if <code>byte1</code> and <code>byte2</code> \n-   * are the first two bytes\n-   * read respectively, and the high order bits of them match the patterns\n-   * which indicate a two byte character encoding, then they would be\n-   * converted to a Java <code>char</code> like so:\n-   * <p>\n-   * <code>(char)(((byte1 & 0x1F) << 6) | (byte2 & 0x3F))</code>\n-   * <p>\n-   * If the first byte has a <code>1110</code> as its high order bits, then the\n-   * character consists of three bytes.  The bits that make up the character\n-   * value are in positions 0 through 3 of the first byte and bit positions\n-   * 0 through 5 of the other two bytes.  (The second and third bytes should\n-   * have <code>10</code> as their high order bits).  These values are in most\n-   * significant byte first (i.e., \"big endian\") order.\n-   * <p>\n-   * As an example, if <code>byte1</code> <code>byte2</code> \n-   * and <code>byte3</code> are the\n-   * three bytes read, and the high order bits of them match the patterns\n-   * which indicate a three byte character encoding, then they would be\n-   * converted to a Java <code>char</code> like so:\n-   * <p>\n-   * <code>(char)(((byte1 & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | \n-   * (byte3 & 0x3F))</code>\n-   * <p>\n-   * Note that all characters are encoded in the method that requires the\n-   * fewest number of bytes with the exception of the character with the\n-   * value of <code>&#92;u0000</code> which is encoded as two bytes.  This is \n-   * a  modification of the UTF standard used to prevent C language style\n-   * <code>NUL</code> values from appearing in the byte stream.\n-   * <p>\n-   * This method can read data that was written by an object implementing the\n-   * <code>writeUTF()</code> method in <code>DataOutput</code>\n-   * \n-   * @return The <code>String</code> read\n-   *\n-   * @exception EOFException If end of file is reached before reading the \n-   * String\n-   * @exception UTFDataFormatException If the data is not in UTF-8 format\n-   * @exception IOException If any other error occurs\n-   *\n-   * @see DataOutput\n-   */\n-  public final String readUTF () throws IOException\n-  {\n-    return in.readUTF();\n-  }\n-\n-  /**\n-   * This method sets the current file position to the specified offset \n-   * from the beginning of the file.  Note that some operating systems will\n-   * allow the file pointer to be set past the current end of the file.\n-   *\n-   * @param pos The offset from the beginning of the file at which to set \n-   * the file pointer\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void seek (long pos) throws IOException\n-  {\n-    ch.position(pos);\n-  }\n-\n-  /**\n-   * This method attempts to skip and discard the specified number of bytes \n-   * in the input stream.  It may actually skip fewer bytes than requested. \n-   * The actual number of bytes skipped is returned.  This method will not\n-   * skip any bytes if passed a negative number of bytes to skip.\n-   *\n-   * @param numBytes The requested number of bytes to skip.\n-   *\n-   * @return The number of bytes actually skipped.\n-   *\n-   * @exception IOException If an error occurs.\n-   */\n-  public int skipBytes (int numBytes) throws IOException\n-  {\n-    if (numBytes < 0)\n-      throw new IllegalArgumentException (\"Can't skip negative bytes: \" +\n-                                          numBytes);\n-    \n-    if (numBytes == 0)\n-      return 0;\n-    \n-    long oldPos = ch.position();\n-    long newPos = oldPos + numBytes;\n-    long size = ch.size();\n-    if (newPos > size)\n-      newPos = size;\n-    ch.position(newPos);\n-    return (int) (ch.position() - oldPos);\n-  }\n-\n-  /**\n-   * This method writes a single byte of data to the file. The file must\n-   * be open for read-write in order for this operation to succeed.\n-   *\n-   * @param oneByte The byte of data to write, passed as an int.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void write (int oneByte) throws IOException\n-  {\n-    out.write(oneByte);\n-  }\n-\n-  /**\n-   * This method writes all the bytes in the specified array to the file.\n-   * The file must be open read-write in order for this operation to succeed.\n-   *\n-   * @param buffer The array of bytes to write to the file\n-   */\n-  public void write (byte[] buffer) throws IOException\n-  {\n-    out.write(buffer);\n-  }\n-\n-  /**\n-   * This method writes <code>len</code> bytes to the file from the specified\n-   * array starting at index <code>offset</code> into the array.\n-   *\n-   * @param buffer The array of bytes to write to the file\n-   * @param offset The index into the array to start writing file\n-   * @param len The number of bytes to write\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public void write (byte[] buffer, int offset, int len) throws IOException\n-  {\n-    out.write (buffer, offset, len);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>boolean</code> to the underlying output \n-   * stream. For a value of <code>true</code>, 1 is written to the stream.\n-   * For a value of <code>false</code>, 0 is written.\n-   *\n-   * @param val The <code>boolean</code> value to write to the stream\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeBoolean (boolean val) throws IOException\n-  {\n-    out.writeBoolean(val);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>byte</code> value to the underlying\n-   * output stream.\n-   *\n-   * @param val The <code>byte</code> to write to the stream, passed \n-   * as an <code>int</code>.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeByte (int val) throws IOException\n-  {\n-    out.writeByte(val);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>short</code> to the stream, high byte\n-   * first.  This method requires two bytes to encode the value.\n-   *\n-   * @param val The <code>short</code> value to write to the stream, \n-   * passed as an <code>int</code>.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeShort (int val) throws IOException\n-  {\n-    out.writeShort(val);\n-  }\n-\n-  /**\n-   * This method writes a single <code>char</code> value to the stream,\n-   * high byte first.\n-   *\n-   * @param val The <code>char</code> value to write, passed as \n-   * an <code>int</code>.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeChar (int val) throws IOException\n-  {\n-    out.writeChar(val);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>int</code> to the stream, high bytes\n-   * first.  This method requires four bytes to encode the value.\n-   *\n-   * @param val The <code>int</code> value to write to the stream.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeInt (int val) throws IOException\n-  {\n-    out.writeInt(val);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>long</code> to the stream, high bytes\n-   * first.  This method requires eight bytes to encode the value.\n-   *\n-   * @param val The <code>long</code> value to write to the stream.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeLong (long val) throws IOException\n-  {\n-    out.writeLong(val);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>float</code> value to the stream.  This\n-   * value is written by first calling the method \n-   * <code>Float.floatToIntBits</code>\n-   * to retrieve an <code>int</code> representing the floating point number,\n-   * then writing this <code>int</code> value to the stream exactly the same\n-   * as the <code>writeInt()</code> method does.\n-   *\n-   * @param val The floating point number to write to the stream.\n-   *\n-   * @exception IOException If an error occurs\n-   *\n-   * @see #writeInt(int)\n-   */\n-  public final void writeFloat (float val) throws IOException\n-  {\n-    out.writeFloat(val);\n-  }\n-\n-  /**\n-   * This method writes a Java <code>double</code> value to the stream.  This\n-   * value is written by first calling the method \n-   * <code>Double.doubleToLongBits</code>\n-   * to retrieve an <code>long</code> representing the floating point number,\n-   * then writing this <code>long</code> value to the stream exactly the same\n-   * as the <code>writeLong()</code> method does.\n-   *\n-   * @param val The double precision floating point number to write to the \n-   * stream.\n-   *\n-   * @exception IOException If an error occurs\n-   *\n-   * @see #writeLong(long)\n-   */\n-  public final void writeDouble (double val) throws IOException\n-  {\n-    out.writeDouble(val);\n-  }\n-\n-  /**\n-   * This method writes all the bytes in a <code>String</code> out to the\n-   * stream.  One byte is written for each character in the <code>String</code>.\n-   * The high eight bits of each character are discarded.\n-   *\n-   * @param val The <code>String</code> to write to the stream\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeBytes (String val) throws IOException\n-  {\n-    out.writeBytes(val);\n-  }\n-  \n-  /**\n-   * This method writes all the characters in a <code>String</code> to the\n-   * stream.  There will be two bytes for each character value.  The high\n-   * byte of the character will be written first.\n-   *\n-   * @param val The <code>String</code> to write to the stream.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeChars (String val) throws IOException\n-  {\n-    out.writeChars(val);\n-  }\n-  \n-  /**\n-   * This method writes a Java <code>String</code> to the stream in a modified\n-   * UTF-8 format.  First, two bytes are written to the stream indicating the\n-   * number of bytes to follow.  Note that this is the number of bytes in the\n-   * encoded <code>String</code> not the <code>String</code> length.  Next\n-   * come the encoded characters.  Each character in the <code>String</code>\n-   * is encoded as either one, two or three bytes.  For characters in the\n-   * range of <code>&#92;u0001</code> to <code>&#92;u007F</code>, \n-   * one byte is used.  The character\n-   * value goes into bits 0-7 and bit eight is 0.  For characters in the range\n-   * of <code>&#92;u0080</code> to <code>&#92;u007FF</code>, two \n-   * bytes are used.  Bits\n-   * 6-10 of the character value are encoded bits 0-4 of the first byte, with\n-   * the high bytes having a value of \"110\".  Bits 0-5 of the character value\n-   * are stored in bits 0-5 of the second byte, with the high bits set to\n-   * \"10\".  This type of encoding is also done for the null character\n-   * <code>&#92;u0000</code>.  This eliminates any C style NUL character values\n-   * in the output.  All remaining characters are stored as three bytes.\n-   * Bits 12-15 of the character value are stored in bits 0-3 of the first\n-   * byte.  The high bits of the first bytes are set to \"1110\".  Bits 6-11\n-   * of the character value are stored in bits 0-5 of the second byte.  The\n-   * high bits of the second byte are set to \"10\".  And bits 0-5 of the\n-   * character value are stored in bits 0-5 of byte three, with the high bits\n-   * of that byte set to \"10\".\n-   *\n-   * @param val The <code>String</code> to write to the output in UTF format\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public final void writeUTF (String val) throws IOException\n-  {\n-    out.writeUTF(val);\n-  }\n-  \n-  /**\n-   * This method creates a java.nio.channels.FileChannel.\n-   * Nio does not allow one to create a file channel directly.\n-   * A file channel must be created by first creating an instance of\n-   * Input/Output/RandomAccessFile and invoking the getChannel() method on it.\n-   */\n-  public final synchronized FileChannel getChannel ()\n-  {\n-    return ch;\n-  }\n-}"}, {"sha": "b58c5bca24c2542b94b2d4bca7b4c9f2421c802b", "filename": "libjava/java/lang/InheritableThreadLocal.java", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Flang%2FInheritableThreadLocal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Flang%2FInheritableThreadLocal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInheritableThreadLocal.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,142 +0,0 @@\n-/* InheritableThreadLocal -- a ThreadLocal which inherits values across threads\n-   Copyright (C) 2000, 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.lang;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-\n-/**\n- * A ThreadLocal whose value is inherited by child Threads. The value of the\n- * InheritableThreadLocal associated with the (parent) Thread is copied to\n- * the new (child) Thread at the moment of creation.\n- *\n- * <p>It is possible to make the value associated with the child Thread a\n- * function of the value that is associated with the parent Thread by\n- * overriding the <code>childValue()</code> method. The utility of this class\n- * is in transferring items like User ID or Transaction ID across threads\n- * automatically.\n- *\n- * @author Mark Wielaard (mark@klomp.org)\n- * @author Eric Blake (ebb9@email.byu.edu)\n- * @see ThreadLocal\n- * @since 1.2\n- * @status updated to 1.4\n- */\n-public class InheritableThreadLocal extends ThreadLocal\n-{\n-  /**\n-   * Maps Threads to a List of InheritableThreadLocals (the heritage of that\n-   * Thread). Uses a WeakHashMap so if the Thread is garbage collected the\n-   * List can be collected, too. Maps to a list in case the user overrides\n-   * equals.\n-   */\n-  private static final Map threadMap\n-\t  = Collections.synchronizedMap(new WeakHashMap());\n-\n-  /**\n-   * Creates a new InheritableThreadLocal that has no values associated\n-   * with it yet.\n-   */\n-  public InheritableThreadLocal()\n-  {\n-    Thread currentThread = Thread.currentThread();\n-    // Note that we don't have to synchronize, as only this thread will\n-    // ever modify the returned heritage and threadMap is a synchronizedMap.\n-    List heritage = (List) threadMap.get(currentThread);\n-    if (heritage == null)\n-      {\n-        heritage = new ArrayList();\n-        threadMap.put(currentThread, heritage);\n-      }\n-    heritage.add(this);\n-  }\n-\n-  /**\n-   * Determines the value associated with a newly created child Thread as a\n-   * function of the value associated with the currently executing (parent)\n-   * Thread. The default implementation just returns the parentValue.\n-   *\n-   * @param parentValue the value of this object in the parent thread at\n-   *        the moment of creation of the child\n-   * @return the initial value for the child thread\n-   */\n-  protected Object childValue(Object parentValue)\n-  {\n-    return parentValue;\n-  }\n-\n-  /**\n-   * Generates the childValues of all <code>InheritableThreadLocal</code>s\n-   * that are in the heritage of the current Thread for the newly created\n-   * childThread. Should be called from the contructor Thread.\n-   *\n-   * @param childThread the newly created thread, to inherit from this thread\n-   * @see Thread#Thread(ThreadGroup, Runnable, String)\n-   */\n-  static void newChildThread(Thread childThread)\n-  {\n-    // The currentThread is the parent of the new thread.\n-    Thread parentThread = Thread.currentThread();\n-    // Note that we don't have to synchronize, as only this thread will\n-    // ever modify the returned heritage and threadMap is a synchronizedMap. \n-    ArrayList heritage = (ArrayList) threadMap.get(parentThread);\n-    if (heritage != null)\n-      {\n-        threadMap.put(childThread, heritage.clone());\n-        // Perform the inheritance.\n-        Iterator it = heritage.iterator();\n-        int i = heritage.size();\n-        while (--i >= 0)\n-          {\n-            InheritableThreadLocal local = (InheritableThreadLocal) it.next();\n-            Object parentValue = local.valueMap.get(parentThread);\n-            if (parentValue != null)\n-              {\n-                Object childValue = local.childValue(parentValue == NULL\n-                                                     ? null : parentValue);\n-                local.valueMap.put(childThread, (childValue == null\n-                                                 ? NULL : parentValue));\n-              }\n-          }\n-      }\n-  }\n-}"}, {"sha": "7938498ed49e26adf90bdab5e056b2572a98b9f1", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -1,5 +1,5 @@\n /* Thread -- an independent thread of executable code\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation\n \n This file is part of GNU Classpath.\n@@ -41,6 +41,8 @@\n \n import gnu.gcj.RawData;\n import gnu.gcj.RawDataManaged;\n+import gnu.java.util.WeakIdentityHashMap;\n+import java.util.Map;\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n@@ -125,6 +127,11 @@ public class Thread implements Runnable\n   /** The context classloader for this Thread. */\n   private ClassLoader contextClassLoader;\n \n+  /** Thread local storage. Package accessible for use by\n+    * InheritableThreadLocal.\n+    */\n+  WeakIdentityHashMap locals;\n+\n   // This describes the top-most interpreter frame for this thread.\n   RawData interp_frame;\n \n@@ -914,4 +921,18 @@ public String toString()\n   private final native void initialize_native();\n \n   private final native static String gen_name();\n+\n+  /**\n+   * Returns the map used by ThreadLocal to store the thread local values.\n+   */\n+  static Map getThreadLocals()\n+  {\n+    Thread thread = currentThread();\n+    Map locals = thread.locals;\n+    if (locals == null)\n+      {\n+        locals = thread.locals = new WeakIdentityHashMap();\n+      }\n+    return locals;\n+  }\n }"}, {"sha": "9ef182e08a7fbac3ca708763d5bbe6d395eb6e75", "filename": "libjava/java/lang/ThreadLocal.java", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Flang%2FThreadLocal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Flang%2FThreadLocal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThreadLocal.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,169 +0,0 @@\n-/* ThreadLocal -- a variable with a unique value per thread\n-   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.lang;\n-\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-\n-\n-/**\n- * ThreadLocal objects have a different state associated with every\n- * Thread that accesses them. Every access to the ThreadLocal object\n- * (through the <code>get()</code> and <code>set()</code> methods)\n- * only affects the state of the object as seen by the currently\n- * executing Thread.\n- *\n- * <p>The first time a ThreadLocal object is accessed on a particular\n- * Thread, the state for that Thread's copy of the local variable is set by\n- * executing the method <code>initialValue()</code>.\n- * </p>\n- *\n- * <p>An example how you can use this:\n- * </p>\n- *\n- * <pre>\n- * class Connection\n- * {\n- *   private static ThreadLocal owner = new ThreadLocal()\n- *     {\n- *       public Object initialValue()\n- *       {\n- *         return(\"nobody\");\n- *       }\n- *     };\n- * ...\n- * }\n- * </pre>\n- *\n- * <p>Now all instances of connection can see who the owner of the currently\n- * executing Thread is by calling <code>owner.get()</code>. By default any\n- * Thread would be associated with 'nobody'. But the Connection object could\n- * offer a method that changes the owner associated with the Thread on\n- * which the method was called by calling <code>owner.put(\"somebody\")</code>.\n- * (Such an owner changing method should then be guarded by security checks.)\n- * </p>\n- *\n- * <p>When a Thread is garbage collected all references to values of\n- * the ThreadLocal objects associated with that Thread are removed.\n- * </p>\n- *\n- * @author Mark Wielaard (mark@klomp.org)\n- * @author Eric Blake (ebb9@email.byu.edu)\n- * @since 1.2\n- * @status updated to 1.4\n- */\n-public class ThreadLocal\n-{\n-  /**\n-   * Placeholder to distinguish between uninitialized and null set by the\n-   * user. Do not expose this to the public. Package visible for use by\n-   * InheritableThreadLocal\n-   */\n-  static final Object NULL = new Object();\n-\n-  /**\n-   * The stored value. Package visible for use by InheritableThreadLocal. */\n-  Object value;\n-\t\n-  /**\n-   * Maps Threads to values. Uses a WeakHashMap so if a Thread is garbage\n-   * collected the reference to the Value will disappear. A null value means\n-   * uninitialized, while NULL means a user-specified null. Only the\n-   * <code>set(Thread, Object)</code> and <code>get(Thread)</code> methods\n-   * access it. Package visible for use by InheritableThreadLocal.\n-   */\n-  final Map valueMap = Collections.synchronizedMap(new WeakHashMap());\n-\t\n-  /**\n-   * Creates a ThreadLocal object without associating any value to it yet.\n-   */\n-  public ThreadLocal()\n-  {\n-  }\n-\n-  /**\n-   * Called once per thread on the first invocation of get(), if set() was\n-   * not already called. The default implementation returns <code>null</code>.\n-   * Often, this method is overridden to create the appropriate initial object\n-   * for the current thread's view of the ThreadLocal.\n-   *\n-   * @return the initial value of the variable in this thread\n-   */\n-  protected Object initialValue()\n-  {\n-    return null;\n-  }\n-\n-  /**\n-   * Gets the value associated with the ThreadLocal object for the currently\n-   * executing Thread. If this is the first time the current thread has called\n-   * get(), and it has not already called set(), the value is obtained by\n-   * <code>initialValue()</code>.\n-   *\n-   * @return the value of the variable in this thread\n-   */\n-  public Object get()\n-  {\n-    Thread currentThread = Thread.currentThread();\n-    // Note that we don't have to synchronize, as only this thread will\n-    // ever modify the returned value and valueMap is a synchronizedMap.\n-    Object value = valueMap.get(currentThread);\n-    if (value == null)\n-      {\n-        value = initialValue();\n-        valueMap.put(currentThread, value == null ? NULL : value);\n-      }\n-    return value == NULL ? null : value;\n-  }\n-\n-  /**\n-   * Sets the value associated with the ThreadLocal object for the currently\n-   * executing Thread. This overrides any existing value associated with the\n-   * current Thread and prevents <code>initialValue()</code> from being\n-   * called if this is the first access to this ThreadLocal in this Thread.\n-   *\n-   * @param value the value to set this thread's view of the variable to\n-   */\n-  public void set(Object value)\n-  {\n-    // Note that we don't have to synchronize, as only this thread will\n-    // ever modify the returned value and valueMap is a synchronizedMap.\n-    valueMap.put(Thread.currentThread(), value == null ? NULL : value);\n-  }\n-}"}, {"sha": "2879df8e91c8fd9bb80d30cc745b7abb4152a342", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -216,6 +216,9 @@ java::lang::Thread::finish_ ()\n   // If a method cache was created, free it.\n   _Jv_FreeMethodCache();\n \n+  // Clear out thread locals.\n+  locals = NULL;\n+\n   // Signal any threads that are waiting to join() us.\n   _Jv_MutexLock (&nt->join_mutex);\n "}, {"sha": "1c329313bc828068ca56efb042259cceaff98ee5", "filename": "libjava/java/security/AccessControlContext.java", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fsecurity%2FAccessControlContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Fsecurity%2FAccessControlContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAccessControlContext.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,173 +0,0 @@\n-/* AccessControlContext.java --- Access Control Context Class\n-   Copyright (C) 1999, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.security;\n-\n-/**\n- * AccessControlContext makes system resource access decsion \n- * based on permission rights.  \n- *\n- * It is used for a specific context and has only one method\n- * checkPermission. It is similar to AccessController except\n- * that it makes decsions based on the current context instead\n- * of the the current thread.\n- *\n- * It is created by call AccessController.getContext method.\n- *\n- * @author Mark Benvenuto\n- * @since 1.2\n- */\n-public final class AccessControlContext\n-{\n-  private ProtectionDomain[] protectionDomains;\n-  private DomainCombiner combiner;\n-\n-  /**\n-   * Construct a new AccessControlContext with the specified\n-   * ProtectionDomains. <code>context</code> must not be \n-   * null and duplicates will be removed.\n-   *\n-   * @param context The ProtectionDomains to use\n-   */\n-  public AccessControlContext(ProtectionDomain[] context)\n-  {\n-    int i, j, k, count = context.length, count2 = 0;\n-    for (i = 0, j = 0; i < count; i++)\n-      {\n-\tfor (k = 0; k < i; k++)\n-\t  if (context[k] == protectionDomains[i])\n-\t    break;\n-\tif (k != i)\t\t//it means previous loop did not complete\n-\t  continue;\n-\n-\tcount2++;\n-      }\n-\n-    protectionDomains = new ProtectionDomain[count2];\n-    for (i = 0, j = 0; i < count2; i++)\n-      {\n-\tfor (k = 0; k < i; k++)\n-\t  if (context[k] == protectionDomains[i])\n-\t    break;\n-\tif (k != i)\t\t//it means previous loop did not complete\n-\t  continue;\n-\n-\tprotectionDomains[j++] = context[i];\n-      }\n-  }\n-\n-  /**\n-   * Construct a new AccessControlContext with the specified\n-   * ProtectionDomains and DomainCombiner\n-   *\n-   * @since 1.3\n-   */\n-  public AccessControlContext(AccessControlContext acc,\n-\t\t\t      DomainCombiner combiner)\n-  {\n-    this(acc.protectionDomains);\n-    this.combiner = combiner;\n-  }\n-\n-  /**\n-   * Returns the Domain Combiner associated with the AccessControlContext\n-   *\n-   * @return the DomainCombiner\n-   */\n-  public DomainCombiner getDomainCombiner()\n-  {\n-    return combiner;\n-  }\n-\n-  /**\n-   * Determines whether or not the specific permission is granted\n-   * depending on the context it is within. \n-   *\n-   * @param perm a permission to check\n-   *\n-   * @throws AccessControlException if the permssion is not permitted\n-   */\n-  public void checkPermission(Permission perm) throws AccessControlException\n-  {\n-    for (int i = 0; i < protectionDomains.length; i++)\n-      if (protectionDomains[i].implies(perm) == true)\n-\treturn;\n-\n-    throw new AccessControlException(\"Permission not granted\");\n-  }\n-\n-  /**\n-   * Checks if two AccessControlContexts are equal.\n-   *\n-   * It first checks if obj is an AccessControlContext class, and\n-   * then checks if each ProtectionDomain matches.\n-   *\n-   * @param obj The object to compare this class to\n-   *\n-   * @return true if equal, false otherwise\n-   */\n-  public boolean equals(Object obj)\n-  {\n-    if (obj instanceof AccessControlContext)\n-      {\n-\tAccessControlContext acc = (AccessControlContext) obj;\n-\n-\tif (acc.protectionDomains.length != protectionDomains.length)\n-\t  return false;\n-\n-\tfor (int i = 0; i < protectionDomains.length; i++)\n-\t  if (acc.protectionDomains[i] != protectionDomains[i])\n-\t    return false;\n-        return true;\n-      }\n-    return false;\n-  }\n-\n-  /**\n-   * Computes a hash code of this class\n-   *\n-   * @return a hash code representing this class\n-   */\n-  public int hashCode()\n-  {\n-    int h = 0;\n-    for (int i = 0; i < protectionDomains.length; i++)\n-      h ^= protectionDomains[i].hashCode();\n-\n-    return h;\n-  }\n-}"}, {"sha": "67dc76b7a42d620b803cf36651e2215b2fefe7dd", "filename": "libjava/java/util/logging/LogManager.java", "status": "removed", "additions": 0, "deletions": 819, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2038cd64d107fbd9d52d1b3cd57a3933f9b9762/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java?ref=a2038cd64d107fbd9d52d1b3cd57a3933f9b9762", "patch": "@@ -1,819 +0,0 @@\n-/* LogManager.java -- a class for maintaining Loggers and managing\n-   configuration properties\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util.logging;\n-\n-import java.beans.PropertyChangeListener;\n-import java.beans.PropertyChangeSupport;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.ref.WeakReference;\n-import java.net.URL;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.StringTokenizer;\n-\n-/**\n- * The <code>LogManager</code> maintains a hierarchical namespace\n- * of Logger objects and manages properties for configuring the logging\n- * framework. There exists only one single <code>LogManager</code>\n- * per virtual machine. This instance can be retrieved using the\n- * static method {@link #getLogManager()}.\n- *\n- * <p><strong>Configuration Process:</strong> The global LogManager\n- * object is created and configured when the class\n- * <code>java.util.logging.LogManager</code> is initialized.\n- * The configuration process includes the subsequent steps:\n- *\n- * <ul>\n- * <li>If the system property <code>java.util.logging.manager</code>\n- *     is set to the name of a subclass of\n- *     <code>java.util.logging.LogManager</code>, an instance of\n- *     that subclass is created and becomes the global LogManager.\n- *     Otherwise, a new instance of LogManager is created.</li>\n- * <li>The <code>LogManager</code> constructor tries to create\n- *     a new instance of the class specified by the system\n- *     property <code>java.util.logging.config.class</code>.\n- *     Typically, the constructor of this class will call\n- *     <code>LogManager.getLogManager().readConfiguration(java.io.InputStream)</code>\n- *     for configuring the logging framework.\n- *     The configuration process stops at this point if\n- *     the system property <code>java.util.logging.config.class</code>\n- *     is set (irrespective of whether the class constructor\n- *     could be called or an exception was thrown).</li>\n- *\n- * <li>If the system property <code>java.util.logging.config.class</code>\n- *     is <em>not</em> set, the configuration parameters are read in from\n- *     a file and passed to\n- *     {@link #readConfiguration(java.io.InputStream)}.\n- *     The name and location of this file are specified by the system\n- *     property <code>java.util.logging.config.file</code>.</li>\n- * <li>If the system property <code>java.util.logging.config.file</code>\n- *     is not set, however, the contents of the URL\n- *     \"{gnu.classpath.home.url}/logging.properties\" are passed to\n- *     {@link #readConfiguration(java.io.InputStream)}.\n- *     Here, \"{gnu.classpath.home.url}\" stands for the value of\n- *     the system property <code>gnu.classpath.home.url</code>.</li>\n- * </ul>\n- *\n- * @author Sascha Brawer (brawer@acm.org)\n- */\n-public class LogManager\n-{\n-  /**\n-   * The singleton LogManager instance.\n-   */\n-  private static LogManager logManager;\n-\n-  /**\n-   * The registered named loggers; maps the name of a Logger to\n-   * a WeakReference to it.\n-   */\n-  private Map loggers;\n-  final Logger rootLogger;\n-\n-  /**\n-   * The properties for the logging framework which have been\n-   * read in last.\n-   */\n-  private Properties properties;\n-\n-  /**\n-   * A delegate object that provides support for handling\n-   * PropertyChangeEvents.  The API specification does not\n-   * mention which bean should be the source in the distributed\n-   * PropertyChangeEvents, but Mauve test code has determined that\n-   * the Sun J2SE 1.4 reference implementation uses the LogManager\n-   * class object. This is somewhat strange, as the class object\n-   * is not the bean with which listeners have to register, but\n-   * there is no reason for the GNU Classpath implementation to\n-   * behave differently from the reference implementation in\n-   * this case.\n-   */\n-  private final PropertyChangeSupport pcs = new PropertyChangeSupport( /* source bean */\n-  LogManager.class);\n-\n-  protected LogManager()\n-  {\n-    if (logManager != null)\n-      throw new IllegalStateException(\"there can be only one LogManager; use LogManager.getLogManager()\");\n-\n-    logManager = this;\n-    loggers = new java.util.HashMap();\n-    rootLogger = new Logger(\"\", null);\n-    addLogger(rootLogger);\n-\n-    /* Make sure that Logger.global has the rootLogger as its parent.\n-     *\n-     * Logger.global is set during class initialization of Logger,\n-     * which may or may not be before this code is being executed.\n-     * For example, on the Sun 1.3.1 and 1.4.0 JVMs, Logger.global\n-     * has been set before this code is being executed. In contrast,\n-     * Logger.global still is null on GCJ 3.2.  Since the LogManager\n-     * and Logger classes are mutually dependent, both behaviors are\n-     * correct.\n-     *\n-     * This means that we cannot depend on Logger.global to have its\n-     * value when this code executes, although that variable is final.\n-     * Since Logger.getLogger will always return the same logger for\n-     * the same name, the subsequent line works fine irrespective of\n-     * the order in which classes are initialized.\n-     */\n-    Logger.getLogger(\"global\").setParent(rootLogger);\n-    Logger.getLogger(\"global\").setUseParentHandlers(true);\n-  }\n-\n-  /**\n-   * Returns the globally shared LogManager instance.\n-   */\n-  public static LogManager getLogManager()\n-  {\n-    return logManager;\n-  }\n-\n-  static\n-    {\n-      makeLogManager();\n-\n-      /* The Javadoc description of the class explains\n-       * what is going on here.\n-       */\n-      Object configurator = createInstance(System.getProperty(\"java.util.logging.config.class\"),\n-                                           /* must be instance of */ Object.class);\n-\n-      try\n-        {\n-\t  if (configurator == null)\n-\t    getLogManager().readConfiguration();\n-        }\n-      catch (IOException ex)\n-        {\n-\t  /* FIXME: Is it ok to ignore exceptions here? */\n-        }\n-    }\n-\n-  private static LogManager makeLogManager()\n-  {\n-    String managerClassName;\n-    LogManager manager;\n-\n-    managerClassName = System.getProperty(\"java.util.logging.manager\");\n-    manager = (LogManager) createInstance(managerClassName, LogManager.class);\n-    if (manager != null)\n-      return manager;\n-\n-    if (managerClassName != null)\n-      System.err.println(\"WARNING: System property \\\"java.util.logging.manager\\\"\"\n-                         + \" should be the name of a subclass of java.util.logging.LogManager\");\n-\n-    return new LogManager();\n-  }\n-\n-  /**\n-   * Registers a listener which will be notified when the\n-   * logging properties are re-read.\n-   */\n-  public synchronized void addPropertyChangeListener(PropertyChangeListener listener)\n-  {\n-    /* do not register null. */\n-    listener.getClass();\n-\n-    pcs.addPropertyChangeListener(listener);\n-  }\n-\n-  /**\n-   * Unregisters a listener.\n-   *\n-   * If <code>listener</code> has not been registered previously,\n-   * nothing happens.  Also, no exception is thrown if\n-   * <code>listener</code> is <code>null</code>.\n-   */\n-  public synchronized void removePropertyChangeListener(PropertyChangeListener listener)\n-  {\n-    if (listener != null)\n-      pcs.removePropertyChangeListener(listener);\n-  }\n-\n-  /**\n-   * Adds a named logger.  If a logger with the same name has\n-   * already been registered, the method returns <code>false</code>\n-   * without adding the logger.\n-   *\n-   * <p>The <code>LogManager</code> only keeps weak references\n-   * to registered loggers.  Therefore, names can become available\n-   * after automatic garbage collection.\n-   *\n-   * @param logger the logger to be added.\n-   *\n-   * @return <code>true</code>if <code>logger</code> was added,\n-   *         <code>false</code> otherwise.\n-   *\n-   * @throws NullPointerException if <code>name</code> is\n-   *         <code>null</code>.\n-   */\n-  public synchronized boolean addLogger(Logger logger)\n-  {\n-    /* To developers thinking about to remove the 'synchronized'\n-     * declaration from this method: Please read the comment\n-     * in java.util.logging.Logger.getLogger(String, String)\n-     * and make sure that whatever you change wrt. synchronization\n-     * does not endanger thread-safety of Logger.getLogger.\n-     * The current implementation of Logger.getLogger assumes\n-     * that LogManager does its synchronization on the globally\n-     * shared instance of LogManager.\n-     */\n-    String name;\n-    WeakReference ref;\n-\n-    /* This will throw a NullPointerException if logger is null,\n-     * as required by the API specification.\n-     */\n-    name = logger.getName();\n-\n-    ref = (WeakReference) loggers.get(name);\n-    if (ref != null)\n-      {\n-\tif (ref.get() != null)\n-\t  return false;\n-\n-\t/* There has been a logger under this name in the past,\n-\t * but it has been garbage collected.\n-\t */\n-\tloggers.remove(ref);\n-      }\n-\n-    /* Adding a named logger requires a security permission. */\n-    if ((name != null) && ! name.equals(\"\"))\n-      checkAccess();\n-\n-    Logger parent = findAncestor(logger);\n-    loggers.put(name, new WeakReference(logger));\n-    if (parent != logger.getParent())\n-      logger.setParent(parent);\n-\n-    /* It can happen that existing loggers should be children of\n-     * the newly added logger. For example, assume that there\n-     * already exist loggers under the names \"\", \"foo\", and \"foo.bar.baz\".\n-     * When adding \"foo.bar\", the logger \"foo.bar.baz\" should change\n-     * its parent to \"foo.bar\".\n-     */\n-    if (parent != rootLogger)\n-      {\n-\tfor (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n-\t  {\n-\t    Logger possChild = (Logger) ((WeakReference) loggers.get(iter.next()))\n-\t                       .get();\n-\t    if ((possChild == null) || (possChild == logger)\n-\t        || (possChild.getParent() != parent))\n-\t      continue;\n-\n-\t    if (! possChild.getName().startsWith(name))\n-\t      continue;\n-\n-\t    if (possChild.getName().charAt(name.length()) != '.')\n-\t      continue;\n-\n-\t    possChild.setParent(logger);\n-\t  }\n-      }\n-\n-    return true;\n-  }\n-\n-  /**\n-   * Finds the closest ancestor for a logger among the currently\n-   * registered ones.  For example, if the currently registered\n-   * loggers have the names \"\", \"foo\", and \"foo.bar\", the result for\n-   * \"foo.bar.baz\" will be the logger whose name is \"foo.bar\".\n-   *\n-   * @param child a logger for whose name no logger has been\n-   *        registered.\n-   *\n-   * @return the closest ancestor for <code>child</code>,\n-   *         or <code>null</code> if <code>child</code>\n-   *         is the root logger.\n-   *\n-   * @throws NullPointerException if <code>child</code>\n-   *         is <code>null</code>.\n-   */\n-  private synchronized Logger findAncestor(Logger child)\n-  {\n-    String childName = child.getName();\n-    int childNameLength = childName.length();\n-    Logger best = rootLogger;\n-    int bestNameLength = 0;\n-\n-    Logger cand;\n-    String candName;\n-    int candNameLength;\n-\n-    if (child == rootLogger)\n-      return null;\n-\n-    for (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n-      {\n-\tcandName = (String) iter.next();\n-\tcandNameLength = candName.length();\n-\n-\tif (candNameLength > bestNameLength\n-\t    && childNameLength > candNameLength\n-\t    && childName.startsWith(candName)\n-\t    && childName.charAt(candNameLength) == '.')\n-\t  {\n-\t    cand = (Logger) ((WeakReference) loggers.get(candName)).get();\n-\t    if ((cand == null) || (cand == child))\n-\t      continue;\n-\n-\t    bestNameLength = candName.length();\n-\t    best = cand;\n-\t  }\n-      }\n-\n-    return best;\n-  }\n-\n-  /**\n-   * Returns a Logger given its name.\n-   *\n-   * @param name the name of the logger.\n-   *\n-   * @return a named Logger, or <code>null</code> if there is no\n-   *     logger with that name.\n-   *\n-   * @throw java.lang.NullPointerException if <code>name</code>\n-   *     is <code>null</code>.\n-   */\n-  public synchronized Logger getLogger(String name)\n-  {\n-    WeakReference ref;\n-\n-    /* Throw a NullPointerException if name is null. */\n-    name.getClass();\n-\n-    ref = (WeakReference) loggers.get(name);\n-    if (ref != null)\n-      return (Logger) ref.get();\n-    else\n-      return null;\n-  }\n-\n-  /**\n-   * Returns an Enumeration of currently registered Logger names.\n-   * Since other threads can register loggers at any time, the\n-   * result could be different any time this method is called.\n-   *\n-   * @return an Enumeration with the names of the currently\n-   *    registered Loggers.\n-   */\n-  public synchronized Enumeration getLoggerNames()\n-  {\n-    return Collections.enumeration(loggers.keySet());\n-  }\n-\n-  /**\n-   * Resets the logging configuration by removing all handlers for\n-   * registered named loggers and setting their level to <code>null</code>.\n-   * The level of the root logger will be set to <code>Level.INFO</code>.\n-   *\n-   * @throws SecurityException if a security manager exists and\n-   *         the caller is not granted the permission to control\n-   *         the logging infrastructure.\n-   */\n-  public synchronized void reset() throws SecurityException\n-  {\n-    /* Throw a SecurityException if the caller does not have the\n-     * permission to control the logging infrastructure.\n-     */\n-    checkAccess();\n-\n-    properties = new Properties();\n-\n-    Iterator iter = loggers.values().iterator();\n-    while (iter.hasNext())\n-      {\n-\tWeakReference ref;\n-\tLogger logger;\n-\n-\tref = (WeakReference) iter.next();\n-\tif (ref != null)\n-\t  {\n-\t    logger = (Logger) ref.get();\n-\n-\t    if (logger == null)\n-\t      iter.remove();\n-\t    else if (logger != rootLogger)\n-\t      logger.setLevel(null);\n-\t  }\n-      }\n-\n-    rootLogger.setLevel(Level.INFO);\n-  }\n-\n-  /**\n-   * Configures the logging framework by reading a configuration file.\n-   * The name and location of this file are specified by the system\n-   * property <code>java.util.logging.config.file</code>.  If this\n-   * property is not set, the URL\n-   * \"{gnu.classpath.home.url}/logging.properties\" is taken, where\n-   * \"{gnu.classpath.home.url}\" stands for the value of the system\n-   * property <code>gnu.classpath.home.url</code>.\n-   *\n-   * <p>The task of configuring the framework is then delegated to\n-   * {@link #readConfiguration(java.io.InputStream)}, which will\n-   * notify registered listeners after having read the properties.\n-   *\n-   * @throws SecurityException if a security manager exists and\n-   *         the caller is not granted the permission to control\n-   *         the logging infrastructure, or if the caller is\n-   *         not granted the permission to read the configuration\n-   *         file.\n-   *\n-   * @throws IOException if there is a problem reading in the\n-   *         configuration file.\n-   */\n-  public synchronized void readConfiguration()\n-    throws IOException, SecurityException\n-  {\n-    String path;\n-    InputStream inputStream;\n-\n-    path = System.getProperty(\"java.util.logging.config.file\");\n-    if ((path == null) || (path.length() == 0))\n-      {\n-\tString url = (System.getProperty(\"gnu.classpath.home.url\")\n-\t             + \"/logging.properties\");\n-\tinputStream = new URL(url).openStream();\n-      }\n-    else\n-      inputStream = new java.io.FileInputStream(path);\n-\n-    try\n-      {\n-\treadConfiguration(inputStream);\n-      }\n-    finally\n-      {\n-\t/* Close the stream in order to save\n-\t * resources such as file descriptors.\n-\t */\n-\tinputStream.close();\n-      }\n-  }\n-\n-  public synchronized void readConfiguration(InputStream inputStream)\n-    throws IOException, SecurityException\n-  {\n-    Properties newProperties;\n-    Enumeration keys;\n-\n-    checkAccess();\n-    newProperties = new Properties();\n-    newProperties.load(inputStream);\n-    this.properties = newProperties;\n-    keys = newProperties.propertyNames();\n-\n-    while (keys.hasMoreElements())\n-      {\n-\tString key = ((String) keys.nextElement()).trim();\n-\tString value = newProperties.getProperty(key);\n-\n-\tif (value == null)\n-\t  continue;\n-\n-\tvalue = value.trim();\n-\n-\tif (\"handlers\".equals(key))\n-\t  {\n-\t    StringTokenizer tokenizer = new StringTokenizer(value);\n-\t    while (tokenizer.hasMoreTokens())\n-\t      {\n-\t\tString handlerName = tokenizer.nextToken();\n-\t\ttry\n-\t\t  {\n-\t\t    Class handlerClass = Class.forName(handlerName);\n-\t\t    getLogger(\"\").addHandler((Handler) handlerClass\n-\t\t                             .newInstance());\n-\t\t  }\n-\t\tcatch (ClassCastException ex)\n-\t\t  {\n-\t\t    System.err.println(\"[LogManager] class \" + handlerName\n-\t\t                       + \" is not subclass of java.util.logging.Handler\");\n-\t\t  }\n-\t\tcatch (Exception ex)\n-\t\t  {\n-\t\t    //System.out.println(\"[LogManager.readConfiguration]\"+ex);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\tif (key.endsWith(\".level\"))\n-\t  {\n-\t    String loggerName = key.substring(0, key.length() - 6);\n-\t    Logger logger = getLogger(loggerName);\n-\n-\t    if (logger == null)\n-\t      {\n-\t\tlogger = Logger.getLogger(loggerName);\n-\t\taddLogger(logger);\n-\t      }\n-\t    try\n-\t      {\n-\t\tlogger.setLevel(Level.parse(value));\n-\t      }\n-\t    catch (Exception _)\n-\t      {\n-\t\t//System.out.println(\"[LogManager.readConfiguration] \"+_);\n-\t      }\n-\t    continue;\n-\t  }\n-      }\n-\n-    /* The API specification does not talk about the\n-     * property name that is distributed with the\n-     * PropertyChangeEvent.  With test code, it could\n-     * be determined that the Sun J2SE 1.4 reference\n-     * implementation uses null for the property name.\n-     */\n-    pcs.firePropertyChange(null, null, null);\n-  }\n-\n-  /**\n-   * Returns the value of a configuration property as a String.\n-   */\n-  public synchronized String getProperty(String name)\n-  {\n-    if (properties != null)\n-      return properties.getProperty(name);\n-    else\n-      return null;\n-  }\n-\n-  /**\n-   * Returns the value of a configuration property as an integer.\n-   * This function is a helper used by the Classpath implementation\n-   * of java.util.logging, it is <em>not</em> specified in the\n-   * logging API.\n-   *\n-   * @param name the name of the configuration property.\n-   *\n-   * @param defaultValue the value that will be returned if the\n-   *        property is not defined, or if its value is not an integer\n-   *        number.\n-   */\n-  static int getIntProperty(String name, int defaultValue)\n-  {\n-    try\n-      {\n-\treturn Integer.parseInt(getLogManager().getProperty(name));\n-      }\n-    catch (Exception ex)\n-      {\n-\treturn defaultValue;\n-      }\n-  }\n-\n-  /**\n-   * Returns the value of a configuration property as an integer,\n-   * provided it is inside the acceptable range.\n-   * This function is a helper used by the Classpath implementation\n-   * of java.util.logging, it is <em>not</em> specified in the\n-   * logging API.\n-   *\n-   * @param name the name of the configuration property.\n-   *\n-   * @param minValue the lowest acceptable value.\n-   *\n-   * @param maxValue the highest acceptable value.\n-   *\n-   * @param defaultValue the value that will be returned if the\n-   *        property is not defined, or if its value is not an integer\n-   *        number, or if it is less than the minimum value,\n-   *        or if it is greater than the maximum value.\n-   */\n-  static int getIntPropertyClamped(String name, int defaultValue,\n-                                   int minValue, int maxValue)\n-  {\n-    int val = getIntProperty(name, defaultValue);\n-    if ((val < minValue) || (val > maxValue))\n-      val = defaultValue;\n-    return val;\n-  }\n-\n-  /**\n-   * Returns the value of a configuration property as a boolean.\n-   * This function is a helper used by the Classpath implementation\n-   * of java.util.logging, it is <em>not</em> specified in the\n-   * logging API.\n-   *\n-   * @param name the name of the configuration property.\n-   *\n-   * @param defaultValue the value that will be returned if the\n-   *        property is not defined, or if its value is neither\n-   *        <code>\"true\"</code> nor <code>\"false\"</code>.\n-   */\n-  static boolean getBooleanProperty(String name, boolean defaultValue)\n-  {\n-    try\n-      {\n-\treturn (new Boolean(getLogManager().getProperty(name))).booleanValue();\n-      }\n-    catch (Exception ex)\n-      {\n-\treturn defaultValue;\n-      }\n-  }\n-\n-  /**\n-   * Returns the value of a configuration property as a Level.\n-   * This function is a helper used by the Classpath implementation\n-   * of java.util.logging, it is <em>not</em> specified in the\n-   * logging API.\n-   *\n-   * @param propertyName the name of the configuration property.\n-   *\n-   * @param defaultValue the value that will be returned if the\n-   *        property is not defined, or if\n-   *        {@link Level.parse(java.lang.String)} does not like\n-   *        the property value.\n-   */\n-  static Level getLevelProperty(String propertyName, Level defaultValue)\n-  {\n-    try\n-      {\n-\treturn Level.parse(getLogManager().getProperty(propertyName));\n-      }\n-    catch (Exception ex)\n-      {\n-\treturn defaultValue;\n-      }\n-  }\n-\n-  /**\n-   * Returns the value of a configuration property as a Class.\n-   * This function is a helper used by the Classpath implementation\n-   * of java.util.logging, it is <em>not</em> specified in the\n-   * logging API.\n-   *\n-   * @param propertyName the name of the configuration property.\n-   *\n-   * @param defaultValue the value that will be returned if the\n-   *        property is not defined, or if it does not specify\n-   *        the name of a loadable class.\n-   */\n-  static final Class getClassProperty(String propertyName, Class defaultValue)\n-  {\n-    Class usingClass = null;\n-\n-    try\n-      {\n-\tString propertyValue = logManager.getProperty(propertyName);\n-\tif (propertyValue != null)\n-\t  usingClass = Class.forName(propertyValue);\n-\tif (usingClass != null)\n-\t  return usingClass;\n-      }\n-    catch (Exception _)\n-      {\n-      }\n-\n-    return defaultValue;\n-  }\n-\n-  static final Object getInstanceProperty(String propertyName, Class ofClass,\n-                                          Class defaultClass)\n-  {\n-    Class klass = getClassProperty(propertyName, defaultClass);\n-    if (klass == null)\n-      return null;\n-\n-    try\n-      {\n-\tObject obj = klass.newInstance();\n-\tif (ofClass.isInstance(obj))\n-\t  return obj;\n-      }\n-    catch (Exception _)\n-      {\n-      }\n-\n-    if (defaultClass == null)\n-      return null;\n-\n-    try\n-      {\n-\treturn defaultClass.newInstance();\n-      }\n-    catch (java.lang.InstantiationException ex)\n-      {\n-\tthrow new RuntimeException(ex.getMessage());\n-      }\n-    catch (java.lang.IllegalAccessException ex)\n-      {\n-\tthrow new RuntimeException(ex.getMessage());\n-      }\n-  }\n-\n-  /**\n-   * An instance of <code>LoggingPermission(\"control\")</code>\n-   * that is shared between calls to <code>checkAccess()</code>.\n-   */\n-  private static final LoggingPermission controlPermission = new LoggingPermission(\"control\",\n-                                                                                   null);\n-\n-  /**\n-   * Checks whether the current security context allows changing\n-   * the configuration of the logging framework.  For the security\n-   * context to be trusted, it has to be granted\n-   * a LoggingPermission(\"control\").\n-   *\n-   * @throws SecurityException if a security manager exists and\n-   *         the caller is not granted the permission to control\n-   *         the logging infrastructure.\n-   */\n-  public void checkAccess() throws SecurityException\n-  {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkPermission(controlPermission);\n-  }\n-\n-  /**\n-   * Creates a new instance of a class specified by name.\n-   *\n-   * @param className the name of the class of which a new instance\n-   *        should be created.\n-   *\n-   * @param ofClass the class to which the new instance should\n-   *        be either an instance or an instance of a subclass.\n-   *        FIXME: This description is just terrible.\n-   *\n-   * @return the new instance, or <code>null</code> if\n-   *         <code>className</code> is <code>null</code>, if no class\n-   *         with that name could be found, if there was an error\n-   *         loading that class, or if the constructor of the class\n-   *         has thrown an exception.\n-   */\n-  static final Object createInstance(String className, Class ofClass)\n-  {\n-    Class klass;\n-\n-    if ((className == null) || (className.length() == 0))\n-      return null;\n-\n-    try\n-      {\n-\tklass = Class.forName(className);\n-\tif (! ofClass.isAssignableFrom(klass))\n-\t  return null;\n-\n-\treturn klass.newInstance();\n-      }\n-    catch (Exception _)\n-      {\n-\treturn null;\n-      }\n-    catch (java.lang.LinkageError _)\n-      {\n-\treturn null;\n-      }\n-  }\n-}"}, {"sha": "18e0684aa5cd2122bcf73fc10f97df746e2f8707", "filename": "libjava/java/util/logging/Logger.java", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2Fjava%2Futil%2Flogging%2FLogger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2Fjava%2Futil%2Flogging%2FLogger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLogger.java?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -1,5 +1,5 @@\n /* Logger.java -- a class for logging messages\n-   Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -1170,4 +1170,18 @@ public synchronized void setParent(Logger parent)\n    * @return caller of the initial looging method\n    */\n   private native StackTraceElement getCallerStackFrame();\n+\n+  /**\n+   * Reset and close handlers attached to this logger. This function is package\n+   * private because it must only be available to the LogManager.\n+   */\n+  void resetLogger()\n+  {\n+    for (int i = 0; i < handlers.length; i++)\n+      {\n+        handlers[i].close();\n+        handlerList.remove(handlers[i]);\n+      }\n+    handlers = getHandlers();\n+  }\n }"}, {"sha": "fbefe52760dad28321027bec2bd8683de01ea2d7", "filename": "libjava/sources.am", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143145daa42382453636fb24b705c673ee812e37/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143145daa42382453636fb24b705c673ee812e37/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=143145daa42382453636fb24b705c673ee812e37", "patch": "@@ -4114,9 +4114,9 @@ classpath/java/io/Externalizable.java \\\n java/io/File.java \\\n classpath/java/io/FileDescriptor.java \\\n classpath/java/io/FileFilter.java \\\n-java/io/FileInputStream.java \\\n+classpath/java/io/FileInputStream.java \\\n classpath/java/io/FileNotFoundException.java \\\n-java/io/FileOutputStream.java \\\n+classpath/java/io/FileOutputStream.java \\\n classpath/java/io/FilePermission.java \\\n classpath/java/io/FileReader.java \\\n classpath/java/io/FileWriter.java \\\n@@ -4156,7 +4156,7 @@ java/io/PrintStream.java \\\n classpath/java/io/PrintWriter.java \\\n classpath/java/io/PushbackInputStream.java \\\n classpath/java/io/PushbackReader.java \\\n-java/io/RandomAccessFile.java \\\n+classpath/java/io/RandomAccessFile.java \\\n classpath/java/io/Reader.java \\\n classpath/java/io/SequenceInputStream.java \\\n classpath/java/io/Serializable.java \\\n@@ -4221,7 +4221,7 @@ classpath/java/lang/IllegalStateException.java \\\n classpath/java/lang/IllegalThreadStateException.java \\\n classpath/java/lang/IncompatibleClassChangeError.java \\\n classpath/java/lang/IndexOutOfBoundsException.java \\\n-java/lang/InheritableThreadLocal.java \\\n+classpath/java/lang/InheritableThreadLocal.java \\\n classpath/java/lang/InstantiationError.java \\\n classpath/java/lang/InstantiationException.java \\\n classpath/java/lang/Integer.java \\\n@@ -4261,7 +4261,7 @@ java/lang/System.java \\\n java/lang/Thread.java \\\n classpath/java/lang/ThreadDeath.java \\\n classpath/java/lang/ThreadGroup.java \\\n-java/lang/ThreadLocal.java \\\n+classpath/java/lang/ThreadLocal.java \\\n classpath/java/lang/Throwable.java \\\n classpath/java/lang/TypeNotPresentException.java \\\n classpath/java/lang/UnknownError.java \\\n@@ -4741,7 +4741,7 @@ java/rmi/server.list: $(java_rmi_server_source_files)\n \n \n java_security_source_files = \\\n-java/security/AccessControlContext.java \\\n+classpath/java/security/AccessControlContext.java \\\n classpath/java/security/AccessControlException.java \\\n java/security/AccessController.java \\\n classpath/java/security/AlgorithmParameterGenerator.java \\\n@@ -5150,7 +5150,7 @@ classpath/java/util/logging/Filter.java \\\n classpath/java/util/logging/Formatter.java \\\n classpath/java/util/logging/Handler.java \\\n classpath/java/util/logging/Level.java \\\n-java/util/logging/LogManager.java \\\n+classpath/java/util/logging/LogManager.java \\\n classpath/java/util/logging/LogRecord.java \\\n java/util/logging/Logger.java \\\n classpath/java/util/logging/LoggingPermission.java \\"}]}