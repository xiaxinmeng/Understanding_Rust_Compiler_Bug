{"sha": "4b7b277aff44cffe643cff9b84d13968b29fa177", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI3YjI3N2FmZjQ0Y2ZmZTY0M2NmZjliODRkMTM5NjhiMjlmYTE3Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-09-13T06:30:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-09-13T06:30:59Z"}, "message": "re PR rtl-optimization/28982 (Incorrect reloading of automodification expressions)\n\ngcc/\n\tPR rtl-optimization/28982\n\t* reload.c (find_reloads_address_1): Use RELOAD_OTHER for the\n\tindex of a PRE_MODIFY or POST_MODIFY address.\n\t* reload1.c (inc_for_reload): Use find_replacement on the original\n\tbase and index registers.\n\ngcc/testsuite/\n\tPR rtl-optimization/28982\n\t* gcc.c-torture/execute/pr28982a.c: New test.\n\t* gcc.c-torture/execute/pr28982b.c: Likewise.\n\nFrom-SVN: r116919", "tree": {"sha": "2aa34947dc3602c792429dc6db53537ff293ce74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aa34947dc3602c792429dc6db53537ff293ce74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b7b277aff44cffe643cff9b84d13968b29fa177", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7b277aff44cffe643cff9b84d13968b29fa177", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7b277aff44cffe643cff9b84d13968b29fa177", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7b277aff44cffe643cff9b84d13968b29fa177/comments", "author": null, "committer": null, "parents": [{"sha": "04df96dded18551448d76b9a753c83d917a8cebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04df96dded18551448d76b9a753c83d917a8cebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04df96dded18551448d76b9a753c83d917a8cebd"}], "stats": {"total": 155, "additions": 149, "deletions": 6}, "files": [{"sha": "0eab63e51a540ecba40e0e0ae6941c28348be3d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b7b277aff44cffe643cff9b84d13968b29fa177", "patch": "@@ -1,3 +1,11 @@\n+2006-09-13  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR rtl-optimization/28982\n+\t* reload.c (find_reloads_address_1): Use RELOAD_OTHER for the\n+\tindex of a PRE_MODIFY or POST_MODIFY address.\n+\t* reload1.c (inc_for_reload): Use find_replacement on the original\n+\tbase and index registers.\n+\n 2006-09-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* doc/invoke.texi (mpreferred-stack-boundary): Remove exception"}, {"sha": "1f1bc23020b4f7bbf58f3aef96306cd980babbc1", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4b7b277aff44cffe643cff9b84d13968b29fa177", "patch": "@@ -5541,12 +5541,18 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t/* Require index register (or constant).  Let's just handle the\n \t   register case in the meantime... If the target allows\n \t   auto-modify by a constant then we could try replacing a pseudo\n-\t   register with its equivalent constant where applicable.  */\n+\t   register with its equivalent constant where applicable.\n+\n+\t   If we later decide to reload the whole PRE_MODIFY or\n+\t   POST_MODIFY, inc_for_reload might clobber the reload register\n+\t   before reading the index.  The index register might therefore\n+\t   need to live longer than a TYPE reload normally would, so be\n+\t   conservative and class it as RELOAD_OTHER.  */\n \tif (REG_P (XEXP (op1, 1)))\n \t  if (!REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n \t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,\n-\t\t\t\t    &XEXP (op1, 1), opnum, type, ind_levels,\n-\t\t\t\t    insn);\n+\t\t\t\t    &XEXP (op1, 1), opnum, RELOAD_OTHER,\n+\t\t\t\t    ind_levels, insn);\n \n \tgcc_assert (REG_P (XEXP (op1, 0)));\n "}, {"sha": "04f64488566b8891380453789b8116b74619df16", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4b7b277aff44cffe643cff9b84d13968b29fa177", "patch": "@@ -8177,7 +8177,7 @@ static rtx\n inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n {\n   /* REG or MEM to be copied and incremented.  */\n-  rtx incloc = XEXP (value, 0);\n+  rtx incloc = find_replacement (&XEXP (value, 0));\n   /* Nonzero if increment after copying.  */\n   int post = (GET_CODE (value) == POST_DEC || GET_CODE (value) == POST_INC\n \t      || GET_CODE (value) == POST_MODIFY);\n@@ -8186,7 +8186,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n   rtx add_insn;\n   int code;\n   rtx store;\n-  rtx real_in = in == value ? XEXP (in, 0) : in;\n+  rtx real_in = in == value ? incloc : in;\n \n   /* No hard register is equivalent to this register after\n      inc/dec operation.  If REG_LAST_RELOAD_REG were nonzero,\n@@ -8198,7 +8198,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n   if (GET_CODE (value) == PRE_MODIFY || GET_CODE (value) == POST_MODIFY)\n     {\n       gcc_assert (GET_CODE (XEXP (value, 1)) == PLUS);\n-      inc = XEXP (XEXP (value, 1), 1);\n+      inc = find_replacement (&XEXP (XEXP (value, 1), 1));\n     }\n   else\n     {"}, {"sha": "f9de5f24209929e10b6ecd13b2645d4e4c3e38a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b7b277aff44cffe643cff9b84d13968b29fa177", "patch": "@@ -1,3 +1,9 @@\n+2006-09-13  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR rtl-optimization/28982\n+\t* gcc.c-torture/execute/pr28982a.c: New test.\n+\t* gcc.c-torture/execute/pr28982b.c: Likewise.\n+\n 2006-09-12  Eric Christopher  <echristo@apple.com>\n \n \t* gcc.target/x86_64/abi/asm-support-darwin.s: New."}, {"sha": "5660a8d3aff701d98feedf07523a5d476af16a2c", "filename": "gcc/testsuite/gcc.c-torture/execute/pr28982a.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28982a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28982a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28982a.c?ref=4b7b277aff44cffe643cff9b84d13968b29fa177", "patch": "@@ -0,0 +1,65 @@\n+/* PR rtl-optimization/28982.  Function foo() does the equivalent of:\n+\n+     float tmp_results[NVARS];\n+     for (int i = 0; i < NVARS; i++)\n+       {\n+\t int inc = incs[i];\n+\t float *ptr = ptrs[i], result = 0;\n+\t for (int j = 0; j < n; j++)\n+\t   result += *ptr, ptr += inc;\n+\t tmp_results[i] = result;\n+       }\n+     memcpy (results, tmp_results, sizeof (results));\n+\n+   but without the outermost loop.  The idea is to create high register\n+   pressure and ensure that some INC and PTR variables are spilled.\n+\n+   On ARM targets, sequences like \"result += *ptr, ptr += inc\" can\n+   usually be implemented using (mem (post_modify ...)), and we do\n+   indeed create such MEMs before reload for this testcase.  However,\n+   (post_modify ...) is not a valid address for coprocessor loads, so\n+   for -mfloat-abi=softfp, reload reloads the POST_MODIFY into a base\n+   register.  GCC did not deal correctly with cases where the base and\n+   index of the POST_MODIFY are themselves reloaded.  */\n+#define NITER 4\n+#define NVARS 20\n+#define MULTI(X) \\\n+  X( 0), X( 1), X( 2), X( 3), X( 4), X( 5), X( 6), X( 7), X( 8), X( 9), \\\n+  X(10), X(11), X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19)\n+\n+#define DECLAREI(INDEX) inc##INDEX = incs[INDEX]\n+#define DECLAREF(INDEX) *ptr##INDEX = ptrs[INDEX], result##INDEX = 0\n+#define LOOP(INDEX) result##INDEX += *ptr##INDEX, ptr##INDEX += inc##INDEX\n+#define COPYOUT(INDEX) results[INDEX] = result##INDEX\n+\n+float *ptrs[NVARS];\n+float results[NVARS];\n+int incs[NVARS];\n+\n+void __attribute__((noinline))\n+foo (int n)\n+{\n+  int MULTI (DECLAREI);\n+  float MULTI (DECLAREF);\n+  while (n--)\n+    MULTI (LOOP);\n+  MULTI (COPYOUT);\n+}\n+\n+float input[NITER * NVARS];\n+\n+int\n+main (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < NVARS; i++)\n+    ptrs[i] = input + i, incs[i] = i;\n+  for (i = 0; i < NITER * NVARS; i++)\n+    input[i] = i;\n+  foo (NITER);\n+  for (i = 0; i < NVARS; i++)\n+    if (results[i] != i * NITER * (NITER + 1) / 2)\n+      return 1;\n+  return 0;\n+}"}, {"sha": "3f9f5bafce5290eae8fc7f92dd50c3965d7de3d0", "filename": "gcc/testsuite/gcc.c-torture/execute/pr28982b.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28982b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b7b277aff44cffe643cff9b84d13968b29fa177/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28982b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr28982b.c?ref=4b7b277aff44cffe643cff9b84d13968b29fa177", "patch": "@@ -0,0 +1,58 @@\n+/* Like pr28982a.c, but with the spill slots outside the range of\n+   a single sp-based load on ARM.  This test tests for cases where\n+   the addresses in the base and index reloads require further reloads.  */\n+#if defined(STACK_SIZE) && STACK_SIZE <= 0x80100\n+int main (void) { return 0; }\n+#else\n+#define NITER 4\n+#define NVARS 20\n+#define MULTI(X) \\\n+  X( 0), X( 1), X( 2), X( 3), X( 4), X( 5), X( 6), X( 7), X( 8), X( 9), \\\n+  X(10), X(11), X(12), X(13), X(14), X(15), X(16), X(17), X(18), X(19)\n+\n+#define DECLAREI(INDEX) inc##INDEX = incs[INDEX]\n+#define DECLAREF(INDEX) *ptr##INDEX = ptrs[INDEX], result##INDEX = 0\n+#define LOOP(INDEX) result##INDEX += *ptr##INDEX, ptr##INDEX += inc##INDEX\n+#define COPYOUT(INDEX) results[INDEX] = result##INDEX\n+\n+float *ptrs[NVARS];\n+float results[NVARS];\n+int incs[NVARS];\n+\n+struct big { int i[0x10000]; };\n+void __attribute__((noinline))\n+bar (struct big b)\n+{\n+  incs[0] += b.i[0];\n+}\n+\n+void __attribute__((noinline))\n+foo (int n)\n+{\n+  struct big b = {};\n+  int MULTI (DECLAREI);\n+  float MULTI (DECLAREF);\n+  while (n--)\n+    MULTI (LOOP);\n+  MULTI (COPYOUT);\n+  bar (b);\n+}\n+\n+float input[NITER * NVARS];\n+\n+int\n+main (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < NVARS; i++)\n+    ptrs[i] = input + i, incs[i] = i;\n+  for (i = 0; i < NITER * NVARS; i++)\n+    input[i] = i;\n+  foo (NITER);\n+  for (i = 0; i < NVARS; i++)\n+    if (results[i] != i * NITER * (NITER + 1) / 2)\n+      return 1;\n+  return 0;\n+}\n+#endif"}]}