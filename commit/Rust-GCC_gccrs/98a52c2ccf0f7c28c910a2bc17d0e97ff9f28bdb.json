{"sha": "98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhNTJjMmNjZjBmN2MyOGM5MTBhMmJjMTdkMGU5N2ZmOWYyOGJkYg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-07-07T00:49:36Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-07-07T00:49:36Z"}, "message": "Java: fixes for the PRs gcj/{271,272,275}.\n\n2000-07-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (parser_qualified_classname): Removed parameter\n\t`is_static'.\n\t(create_interface): Removed first passed parameter to\n\tparser_qualified_classname.\n\t(create_class): Likewise. Don't install alias on static\n\tinnerclasses. Fixes gcj/275.\n\n2000-07-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (maybe_generate_pre_expand_clinit): Don't build a\n\tdebugable statement with empty_stmt_node. Fixes gcj/272\n\n2000-07-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* expr.c (build_instanceof): Layout type after it's loaded. Fixes\n\tgcj/271.\n\n(Fix to the PR gcj/271, gcj/272 and gcj/275:\n http://sourceware.cygnus.com/ml/java-prs/2000-q3/msg00000.html\n http://sourceware.cygnus.com/ml/java-prs/2000-q3/msg00002.html\n http://sourceware.cygnus.com/ml/java-prs/2000-q3/msg00001.html )\n\nFrom-SVN: r34894", "tree": {"sha": "0d9007d5892ffb0c44e98f6a33be8436e92322e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d9007d5892ffb0c44e98f6a33be8436e92322e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/comments", "author": null, "committer": null, "parents": [{"sha": "24c3c71a8c15e208765dff463ba2b7a3f34fe82a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c3c71a8c15e208765dff463ba2b7a3f34fe82a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c3c71a8c15e208765dff463ba2b7a3f34fe82a"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "e6deecd4c0e3a96c20eca2451d491accf8f1859e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "patch": "@@ -16,6 +16,25 @@\n         argument on the first pass for CNI as well as JNI.\n         (print_method_info): Set up method name on the first pass only.\n \t\n+2000-07-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (parser_qualified_classname): Removed parameter\n+\t`is_static'.\n+\t(create_interface): Removed first passed parameter to\n+\tparser_qualified_classname.\n+\t(create_class): Likewise. Don't install alias on static\n+\tinnerclasses. Fixes gcj/275.\n+\n+2000-07-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (maybe_generate_pre_expand_clinit): Don't build a\n+\tdebugable statement with empty_stmt_node. Fixes gcj/272\n+\n+2000-07-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* expr.c (build_instanceof): Layout type after it's loaded. Fixes\n+\tgcj/271.\n+\n 2000-06-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* jcf-write.c (push_long_const): Appropriately cast short negative"}, {"sha": "f01940f6490992b5398d9db2f98074ceff2b5095", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "patch": "@@ -1073,6 +1073,7 @@ build_instanceof (value, type)\n   if (CLASS_P (type) && ! CLASS_LOADED_P (type))\n     {\n       load_class (type, 1);\n+      safe_layout_class (type);\n       if (! TYPE_SIZE (type) || TREE_CODE (TYPE_SIZE (type)) == ERROR_MARK)\n \treturn error_mark_node;\n     }"}, {"sha": "2910e447d84047f069f36332208e95d0f9fbb54a", "filename": "gcc/java/parse.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "patch": "@@ -156,7 +156,7 @@ static tree  find_field PARAMS ((tree, tree));\n static tree lookup_field_wrapper PARAMS ((tree, tree));\n static int   duplicate_declaration_error_p PARAMS ((tree, tree, tree));\n static void  register_fields PARAMS ((int, tree, tree));\n-static tree parser_qualified_classname PARAMS ((int, tree));\n+static tree parser_qualified_classname PARAMS ((tree));\n static int  parser_check_super PARAMS ((tree, tree, tree));\n static int  parser_check_super_interface PARAMS ((tree, tree, tree));\n static void check_modifiers_consistency PARAMS ((int));\n@@ -6347,7 +6347,7 @@ create_interface (flags, id, super)\n      tree id, super;\n {\n   tree raw_name = EXPR_WFL_NODE (id);\n-  tree q_name = parser_qualified_classname (flags & ACC_STATIC, raw_name);\n+  tree q_name = parser_qualified_classname (raw_name);\n   tree decl = IDENTIFIER_CLASS_VALUE (q_name);\n \n   EXPR_WFL_NODE (id) = q_name;\t/* Keep source location, even if refined. */\n@@ -6482,7 +6482,7 @@ create_class (flags, id, super, interfaces)\n   tree class_id, decl;\n   tree super_decl_type;\n \n-  class_id = parser_qualified_classname (0, raw_name);\n+  class_id = parser_qualified_classname (raw_name);\n   decl = IDENTIFIER_CLASS_VALUE (class_id);\n   EXPR_WFL_NODE (id) = class_id;\n \n@@ -6538,13 +6538,6 @@ create_class (flags, id, super, interfaces)\n   CLASS_COMPLETE_P (decl) = 1;\n   add_superinterfaces (decl, interfaces);\n \n-  /* If the class is a top level inner class, install an alias. */\n-  if (INNER_CLASS_DECL_P (decl) && CLASS_STATIC (decl))\n-    {\n-      tree alias = parser_qualified_classname (1, raw_name);\n-      IDENTIFIER_GLOBAL_VALUE (alias) = decl;\n-    }\n-\n   /* Add the private this$<n> field, Replicate final locals still in\n      scope as private final fields mangled like val$<local_name>.\n      This doesn't not occur for top level (static) inner classes. */\n@@ -7484,14 +7477,12 @@ unresolved_type_p (wfl, returned)\n    qualification from the current package definition. */\n \n static tree\n-parser_qualified_classname (is_static, name)\n-     int is_static;\n+parser_qualified_classname (name)\n      tree name;\n {\n   tree nested_class_name;\n \n-  if (!is_static \n-      && (nested_class_name = maybe_make_nested_class_name (name)))\n+  if ((nested_class_name = maybe_make_nested_class_name (name)))\n     return nested_class_name;\n \n   if (ctxp->package)\n@@ -10159,7 +10150,7 @@ maybe_generate_pre_expand_clinit (class_type)\n       /* We build the assignment expression that will initialize the\n \t field to its value. There are strict rules on static\n \t initializers (8.5). FIXME */\n-      if (TREE_CODE (stmt) != BLOCK)\n+      if (TREE_CODE (stmt) != BLOCK && stmt != empty_stmt_node)\n \tstmt = build_debugable_stmt (EXPR_WFL_LINECOL (stmt), stmt);\n       java_method_add_stmt (mdecl, stmt);\n     }"}, {"sha": "42274e63b62a62391512387fa4a4fb640240618b", "filename": "gcc/java/parse.y", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=98a52c2ccf0f7c28c910a2bc17d0e97ff9f28bdb", "patch": "@@ -81,7 +81,7 @@ static tree  find_field PARAMS ((tree, tree));\n static tree lookup_field_wrapper PARAMS ((tree, tree));\n static int   duplicate_declaration_error_p PARAMS ((tree, tree, tree));\n static void  register_fields PARAMS ((int, tree, tree));\n-static tree parser_qualified_classname PARAMS ((int, tree));\n+static tree parser_qualified_classname PARAMS ((tree));\n static int  parser_check_super PARAMS ((tree, tree, tree));\n static int  parser_check_super_interface PARAMS ((tree, tree, tree));\n static void check_modifiers_consistency PARAMS ((int));\n@@ -3649,7 +3649,7 @@ create_interface (flags, id, super)\n      tree id, super;\n {\n   tree raw_name = EXPR_WFL_NODE (id);\n-  tree q_name = parser_qualified_classname (flags & ACC_STATIC, raw_name);\n+  tree q_name = parser_qualified_classname (raw_name);\n   tree decl = IDENTIFIER_CLASS_VALUE (q_name);\n \n   EXPR_WFL_NODE (id) = q_name;\t/* Keep source location, even if refined. */\n@@ -3784,7 +3784,7 @@ create_class (flags, id, super, interfaces)\n   tree class_id, decl;\n   tree super_decl_type;\n \n-  class_id = parser_qualified_classname (0, raw_name);\n+  class_id = parser_qualified_classname (raw_name);\n   decl = IDENTIFIER_CLASS_VALUE (class_id);\n   EXPR_WFL_NODE (id) = class_id;\n \n@@ -3840,13 +3840,6 @@ create_class (flags, id, super, interfaces)\n   CLASS_COMPLETE_P (decl) = 1;\n   add_superinterfaces (decl, interfaces);\n \n-  /* If the class is a top level inner class, install an alias. */\n-  if (INNER_CLASS_DECL_P (decl) && CLASS_STATIC (decl))\n-    {\n-      tree alias = parser_qualified_classname (1, raw_name);\n-      IDENTIFIER_GLOBAL_VALUE (alias) = decl;\n-    }\n-\n   /* Add the private this$<n> field, Replicate final locals still in\n      scope as private final fields mangled like val$<local_name>.\n      This doesn't not occur for top level (static) inner classes. */\n@@ -4786,14 +4779,12 @@ unresolved_type_p (wfl, returned)\n    qualification from the current package definition. */\n \n static tree\n-parser_qualified_classname (is_static, name)\n-     int is_static;\n+parser_qualified_classname (name)\n      tree name;\n {\n   tree nested_class_name;\n \n-  if (!is_static \n-      && (nested_class_name = maybe_make_nested_class_name (name)))\n+  if ((nested_class_name = maybe_make_nested_class_name (name)))\n     return nested_class_name;\n \n   if (ctxp->package)\n@@ -7461,7 +7452,7 @@ maybe_generate_pre_expand_clinit (class_type)\n       /* We build the assignment expression that will initialize the\n \t field to its value. There are strict rules on static\n \t initializers (8.5). FIXME */\n-      if (TREE_CODE (stmt) != BLOCK)\n+      if (TREE_CODE (stmt) != BLOCK && stmt != empty_stmt_node)\n \tstmt = build_debugable_stmt (EXPR_WFL_LINECOL (stmt), stmt);\n       java_method_add_stmt (mdecl, stmt);\n     }"}]}