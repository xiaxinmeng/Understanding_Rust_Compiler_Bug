{"sha": "9fae925b0054a850342419833ee04af01891fd14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhZTkyNWIwMDU0YTg1MDM0MjQxOTgzM2VlMDRhZjAxODkxZmQxNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-16T19:06:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-16T19:06:12Z"}, "message": "tree-into-ssa.c (block_defs_stack): New toplevel varray.\n\n\n\t* tree-into-ssa.c (block_defs_stack): New toplevel varray.\n\t(rewrite_block_data): Remove, no longer used.\n\t(rewrite_initialize_block_local_data): Remove, no longer used.\n\t(rewrite_initialize_block): Mark parameters as unused as needed.\n\tChange references to the block local block_defs to be block_defs_stack.\n\tPush a marker onto the block_defs_stack.\n\t(ssa_rewrite_initialize_block): Similarly.\n\t(rewrite_stmt, ssa_rewrite_stmt): Similarly.\n\t(ssa_register_new_def): No longer needs varray argument.  Use\n\tblock_defs_stack instead.  No longer handle possibly null block_defs\n\tvarray.  Reverse order of items we push on the stack to make it\n\teasier to identify our marker.\n\t(register_new_def): No longer handle possibly null block_defs\n\tvarray.\n\t(rewrite_finalize_block): Revamp to look for markers in the global\n\tblock_defs_stack varray rather than wiping a block local varray.\n\tMark arguments as unused as needed.\n\t(ssa_rewrite_finalize_block): Similarly.\n\t(rewrite_into_ssa): Update initialization of dom walker structure\n\tto reflect that we don't need block local data anymore.  Initialize\n\tthe block_defs_stack varray.\n\t(rewrite_ssa_into_ssa): Similarly.\n\t* tree-ssa-dom.c (block_defs_stack): New toplevel varray.\n\t(struct dom_walk_data): Kill block_defs field.\n\t(tree_ssa_dominator_optimize): Initialize block_defs_stack.\n\t(thread_across_edge): Use the global block_defs_stack instead of\n\tthe old block_defs varray.\n\t(dom_opt_initialize_block_local_data): Update now that we don't have\n\tblock_defs field to check anymore.\n\t(dom_opt_initialize_block): Push a marker onto block_defs_stack.\n\t(restore_currdefs_to_original_value): Use the new block_defs_stack\n\tinstead of a block local varray.\n\t(dom_opt_finalize_block): Similarly.\n\t(record_equivalencs_from_phis): Similarly.\n\t(optimize_stmt, register_definitions_for_stmt): Similarly.\n\nFrom-SVN: r87611", "tree": {"sha": "c92943ffada719a9ee2bef1e625cf2f1ed9cebc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c92943ffada719a9ee2bef1e625cf2f1ed9cebc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fae925b0054a850342419833ee04af01891fd14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fae925b0054a850342419833ee04af01891fd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fae925b0054a850342419833ee04af01891fd14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fae925b0054a850342419833ee04af01891fd14/comments", "author": null, "committer": null, "parents": [{"sha": "2d0db225d32eecd53d1db78a80dc4ad0945c0833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d0db225d32eecd53d1db78a80dc4ad0945c0833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d0db225d32eecd53d1db78a80dc4ad0945c0833"}], "stats": {"total": 267, "additions": 154, "deletions": 113}, "files": [{"sha": "7e55bb4df77ee74a3b93084a76cee53cf622bf6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fae925b0054a850342419833ee04af01891fd14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fae925b0054a850342419833ee04af01891fd14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fae925b0054a850342419833ee04af01891fd14", "patch": "@@ -1,3 +1,41 @@\n+2004-09-16 Jeff Law  <law@redhat.com>\n+\n+\t* tree-into-ssa.c (block_defs_stack): New toplevel varray.\n+\t(rewrite_block_data): Remove, no longer used.\n+\t(rewrite_initialize_block_local_data): Remove, no longer used.\n+\t(rewrite_initialize_block): Mark parameters as unused as needed.\n+\tChange references to the block local block_defs to be block_defs_stack.\n+\tPush a marker onto the block_defs_stack.\n+\t(ssa_rewrite_initialize_block): Similarly.\n+\t(rewrite_stmt, ssa_rewrite_stmt): Similarly.\n+\t(ssa_register_new_def): No longer needs varray argument.  Use\n+\tblock_defs_stack instead.  No longer handle possibly null block_defs\n+\tvarray.  Reverse order of items we push on the stack to make it\n+\teasier to identify our marker.\n+\t(register_new_def): No longer handle possibly null block_defs\n+\tvarray.\n+\t(rewrite_finalize_block): Revamp to look for markers in the global\n+\tblock_defs_stack varray rather than wiping a block local varray.\n+\tMark arguments as unused as needed.\n+\t(ssa_rewrite_finalize_block): Similarly.\n+\t(rewrite_into_ssa): Update initialization of dom walker structure\n+\tto reflect that we don't need block local data anymore.  Initialize\n+\tthe block_defs_stack varray.\n+\t(rewrite_ssa_into_ssa): Similarly.\n+\t* tree-ssa-dom.c (block_defs_stack): New toplevel varray.\n+\t(struct dom_walk_data): Kill block_defs field.\n+\t(tree_ssa_dominator_optimize): Initialize block_defs_stack.\n+\t(thread_across_edge): Use the global block_defs_stack instead of\n+\tthe old block_defs varray.\n+\t(dom_opt_initialize_block_local_data): Update now that we don't have\n+\tblock_defs field to check anymore.\n+\t(dom_opt_initialize_block): Push a marker onto block_defs_stack.\n+\t(restore_currdefs_to_original_value): Use the new block_defs_stack\n+\tinstead of a block local varray.\n+\t(dom_opt_finalize_block): Similarly.\n+\t(record_equivalencs_from_phis): Similarly.\n+\t(optimize_stmt, register_definitions_for_stmt): Similarly.\n+\n 2004-09-16  Andrew MacLeod  <amacleod@redhat.com>\n \n \tPR tree-optimization/17517"}, {"sha": "5a49d7f7d09a1a50e50ac2972a2f062b7568ba77", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fae925b0054a850342419833ee04af01891fd14/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fae925b0054a850342419833ee04af01891fd14/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=9fae925b0054a850342419833ee04af01891fd14", "patch": "@@ -83,6 +83,34 @@ struct def_blocks_d\n    computing PHI pruning heuristics.  */\n static htab_t def_blocks;\n \n+/* Stack of trees used to restore the global currdefs to its original\n+   state after completing rewriting of a block and its dominator children.\n+\n+   This varray is used in two contexts.  The first is rewriting of _DECL\n+   nodes into SSA_NAMEs.  In that context it's elements have the\n+   following properties:\n+\n+     An SSA_NAME indicates that the current definition of the underlying\n+     variable should be set to the given SSA_NAME.\n+                                                                                \n+     A _DECL node indicates that the underlying variable has no current\n+     definition.\n+                                                                                \n+     A NULL node is used to mark the last node associated with the\n+     current block. \n+\n+\n+   This varray is also used when rewriting an SSA_NAME which has multiple\n+   definition sites into multiple SSA_NAMEs.  In that context entries come\n+   in pairs.\n+\n+     The top entry is an SSA_NAME and the top-1 entry is the\n+     current value for that SSA_NAME. \n+\n+     A NULL node at the top entry is used to mark the last node associated\n+     with the current block.  */\n+static varray_type block_defs_stack;\n+\n /* Global data to attach to the main dominator walk structure.  */\n struct mark_def_sites_global_data\n {\n@@ -96,11 +124,6 @@ struct mark_def_sites_global_data\n   sbitmap names_to_rename;\n };\n \n-struct rewrite_block_data\n-{\n-  varray_type block_defs;\n-};\n-\n /* Information stored for ssa names.  */\n \n struct ssa_name_info\n@@ -116,8 +139,6 @@ struct ssa_name_info\n \n /* Local functions.  */\n static void rewrite_finalize_block (struct dom_walk_data *, basic_block);\n-static void rewrite_initialize_block_local_data (struct dom_walk_data *,\n-\t\t\t\t\t\t basic_block, bool);\n static void rewrite_initialize_block (struct dom_walk_data *, basic_block);\n static void rewrite_add_phi_arguments (struct dom_walk_data *, basic_block);\n static void mark_def_sites (struct dom_walk_data *walk_data,\n@@ -636,52 +657,31 @@ insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n       definitions are restored to the names that were valid in the\n       dominator parent of BB.  */\n \n-/* Initialize the local stacks.\n-     \n-   BLOCK_DEFS is used to save all the existing reaching definitions for\n-   the new SSA names introduced in this block.  Before registering a\n-   new definition for a variable, the existing reaching definition is\n-   pushed into this stack so that we can restore it in Step 5.  */\n-\n-static void\n-rewrite_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t\t     basic_block bb ATTRIBUTE_UNUSED,\n-\t\t\t\t     bool recycled ATTRIBUTE_UNUSED)\n-{\n-  struct rewrite_block_data *bd\n-    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n-                                                                                \n-  /* We get cleared memory from the allocator, so if the memory is\n-     not cleared, then we are re-using a previously allocated entry.  In\n-     that case, we can also re-use the underlying virtual arrays.  Just\n-     make sure we clear them before using them!  */\n-  gcc_assert (!recycled || !bd->block_defs || !(VARRAY_ACTIVE_SIZE (bd->block_defs) > 0));\n-}\n-\n-\n /* SSA Rewriting Step 1.  Initialization, create a block local stack\n    of reaching definitions for new SSA names produced in this block\n    (BLOCK_DEFS).  Register new definitions for every PHI node in the\n    block.  */\n \n static void\n-rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n+rewrite_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t  basic_block bb)\n {\n   tree phi;\n-  struct rewrite_block_data *bd\n-    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n+  /* Mark the unwind point for this block.  */\n+  VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n+\n   /* Step 1.  Register new definitions for every PHI node in the block.\n      Conceptually, all the PHI nodes are executed in parallel and each PHI\n      node introduces a new version for the associated variable.  */\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree result = PHI_RESULT (phi);\n \n-      register_new_def (result, &bd->block_defs);\n+      register_new_def (result, &block_defs_stack);\n     }\n }\n \n@@ -690,7 +690,7 @@ rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n    into the stack pointed by BLOCK_DEFS_P.  */\n \n static void\n-ssa_register_new_def (tree var, tree def, varray_type *block_defs_p)\n+ssa_register_new_def (tree var, tree def)\n {\n   tree currdef;\n    \n@@ -705,15 +705,13 @@ ssa_register_new_def (tree var, tree def, varray_type *block_defs_p)\n     }\n \n   currdef = get_current_def (var);\n-  if (! *block_defs_p)\n-    VARRAY_TREE_INIT (*block_defs_p, 20, \"block_defs\");\n \n   /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n      later used by the dominator tree callbacks to restore the reaching\n      definitions for all the variables defined in the block after a recursive\n      visit to all its immediately dominated blocks.  */\n-  VARRAY_PUSH_TREE (*block_defs_p, var);\n-  VARRAY_PUSH_TREE (*block_defs_p, currdef);\n+  VARRAY_PUSH_TREE (block_defs_stack, currdef);\n+  VARRAY_PUSH_TREE (block_defs_stack, var);\n \n   /* Set the current reaching definition for VAR to be DEF.  */\n   set_current_def (var, def);\n@@ -725,15 +723,16 @@ static void\n ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n {\n   tree phi, new_name;\n-  struct rewrite_block_data *bd\n-    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n   sbitmap names_to_rename = walk_data->global_data;\n   edge e;\n   bool abnormal_phi;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n \n+  /* Mark the unwind point for this block.  */\n+  VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n+\n   for (e = bb->pred; e; e = e->pred_next)\n     if (e->flags & EDGE_ABNORMAL)\n       break;\n@@ -757,7 +756,7 @@ ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n       else\n \tnew_name = result;\n \n-      ssa_register_new_def (result, new_name, &bd->block_defs);\n+      ssa_register_new_def (result, new_name);\n     }\n }\n \n@@ -824,24 +823,28 @@ ssa_rewrite_phi_arguments (struct dom_walk_data *walk_data, basic_block bb)\n     }\n }\n \n-/* SSA Rewriting Step 5.  Restore the current reaching definition for each\n-   variable referenced in the block (in reverse order).  */\n \n+/* Similar to restore_vars_to_original_value, except that it restores \n+   CURRDEFS to its original value.  */\n static void\n-rewrite_finalize_block (struct dom_walk_data *walk_data,\n+rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\tbasic_block bb ATTRIBUTE_UNUSED)\n {\n-  struct rewrite_block_data *bd\n-    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n-\n-  /* Step 5.  Restore the current reaching definition for each variable\n-     referenced in the block (in reverse order).  */\n-  while (bd->block_defs && VARRAY_ACTIVE_SIZE (bd->block_defs) > 0)\n+  /* Restore CURRDEFS to its original state.  */\n+  while (VARRAY_ACTIVE_SIZE (block_defs_stack) > 0)\n     {\n-      tree tmp = VARRAY_TOP_TREE (bd->block_defs);\n+      tree tmp = VARRAY_TOP_TREE (block_defs_stack);\n       tree saved_def, var;\n \n-      VARRAY_POP (bd->block_defs);\n+      VARRAY_POP (block_defs_stack);\n+\n+      if (tmp == NULL_TREE)\n+\tbreak;\n+\n+      /* If we recorded an SSA_NAME, then make the SSA_NAME the current\n+\t definition of its underlying variable.  If we recorded anything\n+\t else, it must have been an _DECL node and its current reaching\n+\t definition must have been NULL.  */\n       if (TREE_CODE (tmp) == SSA_NAME)\n \t{\n \t  saved_def = tmp;\n@@ -852,30 +855,32 @@ rewrite_finalize_block (struct dom_walk_data *walk_data,\n \t  saved_def = NULL;\n \t  var = tmp;\n \t}\n-\n+                                                                                \n       set_current_def (var, saved_def);\n     }\n }\n \n /* Ditto, for rewriting ssa names.  */\n \n static void\n-ssa_rewrite_finalize_block (struct dom_walk_data *walk_data,\n+ssa_rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n {\n-  struct rewrite_block_data *bd\n-    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   /* Step 5.  Restore the current reaching definition for each variable\n      referenced in the block (in reverse order).  */\n-  while (bd->block_defs && VARRAY_ACTIVE_SIZE (bd->block_defs) > 0)\n+  while (VARRAY_ACTIVE_SIZE (block_defs_stack) > 0)\n     {\n-      tree var;\n-      tree saved_def = VARRAY_TOP_TREE (bd->block_defs);\n-      VARRAY_POP (bd->block_defs);\n+      tree var = VARRAY_TOP_TREE (block_defs_stack);\n+      tree saved_def;\n+\n+      VARRAY_POP (block_defs_stack);\n       \n-      var = VARRAY_TOP_TREE (bd->block_defs);\n-      VARRAY_POP (bd->block_defs);\n+      if (var == NULL)\n+\tbreak;\n+\n+      saved_def = VARRAY_TOP_TREE (block_defs_stack);\n+      VARRAY_POP (block_defs_stack);\n \n       set_current_def (var, saved_def);\n     }\n@@ -1037,7 +1042,7 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n    definition of a variable when a new real or virtual definition is found.  */\n \n static void\n-rewrite_stmt (struct dom_walk_data *walk_data,\n+rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t      basic_block bb ATTRIBUTE_UNUSED,\n \t      block_stmt_iterator si)\n {\n@@ -1046,9 +1051,6 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n-  struct rewrite_block_data *bd;\n-\n-  bd = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n \n   stmt = bsi_stmt (si);\n   ann = stmt_ann (stmt);\n@@ -1076,7 +1078,7 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n-      register_new_def (DEF_FROM_PTR (def_p), &bd->block_defs);\n+      register_new_def (DEF_FROM_PTR (def_p), &block_defs_stack);\n     }\n }\n \n@@ -1092,11 +1094,8 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n   ssa_op_iter iter;\n   use_operand_p use_p;\n   def_operand_p def_p;\n-  struct rewrite_block_data *bd;\n   sbitmap names_to_rename = walk_data->global_data;\n \n-  bd = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n-\n   stmt = bsi_stmt (si);\n   ann = stmt_ann (stmt);\n \n@@ -1127,7 +1126,7 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n \tcontinue;\n \n       SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n-      ssa_register_new_def (var, DEF_FROM_PTR (def_p), &bd->block_defs);\n+      ssa_register_new_def (var, DEF_FROM_PTR (def_p));\n     }\n }\n \n@@ -1166,8 +1165,6 @@ register_new_def (tree def, varray_type *block_defs_p)\n     }\n \n   currdef = get_current_def (var);\n-  if (! *block_defs_p)\n-    VARRAY_TREE_INIT (*block_defs_p, 20, \"block_defs\");\n \n   /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n      later used by the dominator tree callbacks to restore the reaching\n@@ -1497,15 +1494,17 @@ rewrite_into_ssa (bool all)\n   /* Setup callbacks for the generic dominator tree walker.  */\n   walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = rewrite_initialize_block_local_data;\n+  walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n   walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n   walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments; \n   walk_data.after_dom_children_before_stmts =  NULL;\n   walk_data.after_dom_children_walk_stmts =  NULL;\n   walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n   walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = sizeof (struct rewrite_block_data);\n+  walk_data.block_local_data_size = 0;\n+\n+  VARRAY_TREE_INIT (block_defs_stack, 10, \"Block DEFS Stack\");\n \n   /* Initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -1606,6 +1605,8 @@ rewrite_ssa_into_ssa (void)\n   mark_def_sites_global_data.names_to_rename = snames_to_rename;\n   walk_data.global_data = &mark_def_sites_global_data;\n \n+  VARRAY_TREE_INIT (block_defs_stack, 10, \"Block DEFS Stack\");\n+\n   /* We do not have any local data.  */\n   walk_data.block_local_data_size = 0;\n \n@@ -1633,16 +1634,15 @@ rewrite_ssa_into_ssa (void)\n   /* Setup callbacks for the generic dominator tree walker.  */\n   walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data\n-\t  = rewrite_initialize_block_local_data;\n+  walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children_before_stmts = ssa_rewrite_initialize_block;\n   walk_data.before_dom_children_walk_stmts = ssa_rewrite_stmt;\n   walk_data.before_dom_children_after_stmts = ssa_rewrite_phi_arguments;\n   walk_data.after_dom_children_before_stmts = NULL;\n   walk_data.after_dom_children_walk_stmts =  NULL;\n   walk_data.after_dom_children_after_stmts =  ssa_rewrite_finalize_block;\n   walk_data.global_data = snames_to_rename;\n-  walk_data.block_local_data_size = sizeof (struct rewrite_block_data);\n+  walk_data.block_local_data_size = 0;\n \n   /* Initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);"}, {"sha": "b99097407f90c7d20d79cec58522e28c932394c5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fae925b0054a850342419833ee04af01891fd14/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fae925b0054a850342419833ee04af01891fd14/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=9fae925b0054a850342419833ee04af01891fd14", "patch": "@@ -61,6 +61,19 @@ static htab_t avail_exprs;\n    marker.  */\n static varray_type avail_exprs_stack;\n \n+/* Stack of trees used to restore the global currdefs to its original\n+   state after completing optimization of a block and its dominator children.\n+\n+   An SSA_NAME indicates that the current definition of the underlying\n+   variable should be set to the given SSA_NAME.\n+\n+   A _DECL node indicates that the underlying variable has no current\n+   definition.\n+\n+   A NULL node is used to mark the last node associated with the\n+   current block.  */\n+varray_type block_defs_stack;\n+\n /* Stack of statements we need to rescan during finalization for newly\n    exposed variables.\n \n@@ -200,11 +213,6 @@ struct dom_walk_block_data\n      in this basic block.  We use this during finalization to know\n      which variables need their VRP data updated.  */\n   varray_type vrp_variables;\n-\n-  /* Array of tree pairs used to restore the global currdefs to its\n-     original state after completing optimization of a block and its\n-     dominator children.  */\n-  varray_type block_defs;\n };\n \n struct eq_expr_value\n@@ -255,9 +263,8 @@ static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (varray_type locals,\n \t\t\t\t\t    unsigned limit, \n \t\t\t\t\t    varray_type table);\n-static void restore_currdefs_to_original_value (varray_type locals,\n-\t\t\t\t\t\tunsigned limit);\n-static void register_definitions_for_stmt (tree, varray_type *);\n+static void restore_currdefs_to_original_value (void);\n+static void register_definitions_for_stmt (tree);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n /* Local version of fold that doesn't introduce cruft.  */\n@@ -314,6 +321,7 @@ tree_ssa_dominator_optimize (void)\n   /* Create our hash tables.  */\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   VARRAY_TREE_INIT (avail_exprs_stack, 20, \"Available expression stack\");\n+  VARRAY_TREE_INIT (block_defs_stack, 20, \"Block DEFS stack\");\n   VARRAY_TREE_INIT (const_and_copies, num_ssa_names, \"const_and_copies\");\n   nonzero_vars = BITMAP_XMALLOC ();\n   VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n@@ -461,7 +469,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       tree dst = PHI_RESULT (phi);\n       record_const_or_copy (dst, src, &bd->const_and_copies);\n-      register_new_def (dst, &bd->block_defs);\n+      register_new_def (dst, &block_defs_stack);\n     }\n \n   for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n@@ -576,7 +584,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t the result of this statement is used later we can copy propagate\n \t suitably.  */\n       record_const_or_copy (lhs, cached_lhs, &bd->const_and_copies);\n-      register_new_def (lhs, &bd->block_defs);\n+      register_new_def (lhs, &block_defs_stack);\n     }\n \n   /* If we stopped at a COND_EXPR or SWITCH_EXPR, then see if we know which\n@@ -735,8 +743,6 @@ dom_opt_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n \t\t  || VARRAY_ACTIVE_SIZE (bd->nonzero_vars) == 0);\n       gcc_assert (!bd->vrp_variables\n \t\t  || VARRAY_ACTIVE_SIZE (bd->vrp_variables) == 0);\n-      gcc_assert (!bd->block_defs\n-\t\t  || VARRAY_ACTIVE_SIZE (bd->block_defs) == 0);\n     }\n }\n \n@@ -750,9 +756,10 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n \n-  /* Push a marker on AVAIL_EXPRS_STACK so that we know how far to unwind\n-     when we finalize this block.  */\n+  /* Push a marker on the stacks of local information so that we know how\n+     far to unwind when we finalize this block.  */\n   VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n+  VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (walk_data, bb);\n \n@@ -869,18 +876,18 @@ restore_vars_to_original_value (varray_type locals,\n /* Similar to restore_vars_to_original_value, except that it restores \n    CURRDEFS to its original value.  */\n static void\n-restore_currdefs_to_original_value (varray_type locals, unsigned limit)\n+restore_currdefs_to_original_value (void)\n {\n-  if (!locals)\n-    return;\n-\n   /* Restore CURRDEFS to its original state.  */\n-  while (VARRAY_ACTIVE_SIZE (locals) > limit)\n+  while (VARRAY_ACTIVE_SIZE (block_defs_stack) > 0)\n     {\n-      tree tmp = VARRAY_TOP_TREE (locals);\n+      tree tmp = VARRAY_TOP_TREE (block_defs_stack);\n       tree saved_def, var;\n \n-      VARRAY_POP (locals);\n+      VARRAY_POP (block_defs_stack);\n+\n+      if (tmp == NULL_TREE)\n+\tbreak;\n \n       /* If we recorded an SSA_NAME, then make the SSA_NAME the current\n \t definition of its underlying variable.  If we recorded anything\n@@ -953,18 +960,15 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  || phi_nodes (true_edge->dest))\n \t{\n \t  unsigned const_and_copies_limit;\n-\t  unsigned currdefs_limit;\n \n \t  const_and_copies_limit\n \t    = bd->const_and_copies ? VARRAY_ACTIVE_SIZE (bd->const_and_copies)\n \t\t\t\t   : 0;\n-\t  currdefs_limit\n-\t    = bd->block_defs ? VARRAY_ACTIVE_SIZE (bd->block_defs) : 0;\n-\n \t  /* Push a marker onto the available expression stack so that we\n \t     unwind any expressions related to the TRUE arm before processing\n \t     the false arm below.  */\n \t  VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n+\t  VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n \n \t  /* Record any equivalences created by following this edge.  */\n \t  if (TREE_CODE_CLASS (cond_code) == '<')\n@@ -986,7 +990,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  restore_vars_to_original_value (bd->const_and_copies,\n \t\t\t\t\t  const_and_copies_limit,\n \t\t\t\t\t  const_and_copies);\n-\t  restore_currdefs_to_original_value (bd->block_defs, currdefs_limit);\n+\t  restore_currdefs_to_original_value ();\n \t}\n \n       /* Similarly for the ELSE arm.  */\n@@ -1015,7 +1019,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n   remove_local_expressions_from_table ();\n   restore_nonzero_vars_to_original_value (bd->nonzero_vars, 0, nonzero_vars);\n   restore_vars_to_original_value (bd->const_and_copies, 0, const_and_copies);\n-  restore_currdefs_to_original_value (bd->block_defs, 0);\n+  restore_currdefs_to_original_value ();\n \n   /* Remove VRP records associated with this basic block.  They are no\n      longer valid.\n@@ -1075,10 +1079,9 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n    even if we do not know its exact value.  */\n \n static void\n-record_equivalences_from_phis (struct dom_walk_data *walk_data, basic_block bb)\n+record_equivalences_from_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t       basic_block bb)\n {\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n   tree phi;\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n@@ -1137,7 +1140,7 @@ record_equivalences_from_phis (struct dom_walk_data *walk_data, basic_block bb)\n       if (i == PHI_NUM_ARGS (phi))\n \tbitmap_set_bit (nonzero_vars, SSA_NAME_VERSION (PHI_RESULT (phi)));\n \n-      register_new_def (lhs, &bd->block_defs);\n+      register_new_def (lhs, &block_defs_stack);\n     }\n }\n \n@@ -2759,7 +2762,7 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n \t\t\t\t   may_optimize_p,\n \t\t\t\t   ann);\n \n-  register_definitions_for_stmt (stmt, &bd->block_defs);\n+  register_definitions_for_stmt (stmt);\n \n   /* If STMT is a COND_EXPR and it was modified, then we may know\n      where it goes.  If that is the case, then mark the CFG as altered.\n@@ -3290,7 +3293,7 @@ avail_expr_eq (const void *p1, const void *p2)\n    and CURRDEFS.  */\n \n static void\n-register_definitions_for_stmt (tree stmt, varray_type *block_defs_p)\n+register_definitions_for_stmt (tree stmt)\n {\n   tree def;\n   ssa_op_iter iter;\n@@ -3300,7 +3303,7 @@ register_definitions_for_stmt (tree stmt, varray_type *block_defs_p)\n \n       /* FIXME: We shouldn't be registering new defs if the variable\n \t doesn't need to be renamed.  */\n-      register_new_def (def, block_defs_p);\n+      register_new_def (def, &block_defs_stack);\n     }\n }\n "}]}