{"sha": "718699e90006763f7a55e5e6449e5b9707c5125f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE4Njk5ZTkwMDA2NzYzZjdhNTVlNWU2NDQ5ZTViOTcwN2M1MTI1Zg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-12-03T01:25:42Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-12-03T01:25:42Z"}, "message": "c-typeck.c (default_function_array_conversion, [...]): Allow for CONVERT_EXPR as well as NOP_EXPR.\n\n\t* c-typeck.c (default_function_array_conversion,\n\tbuild_function_call): Allow for CONVERT_EXPR as well as NOP_EXPR.\n\t(build_conditional_expr): Apply integer_zerop to orig_op1 and\n\torig_op2.  Don't check them for NOP_EXPR.\n\t(build_c_cast, convert_for_assignment): Don't check for NOP_EXPR\n\taround integer zero.\n\ntestsuite:\n\t* gcc.dg/c90-const-expr-4.c, gcc.dg/c99-const-expr-4.c: New tests.\n\nFrom-SVN: r107990", "tree": {"sha": "6c2b69079782b4aa8a161ed35bf198ae14b5ad6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c2b69079782b4aa8a161ed35bf198ae14b5ad6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/718699e90006763f7a55e5e6449e5b9707c5125f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/718699e90006763f7a55e5e6449e5b9707c5125f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/718699e90006763f7a55e5e6449e5b9707c5125f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/718699e90006763f7a55e5e6449e5b9707c5125f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3820178b949baa84b2d55069579a545fba478430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3820178b949baa84b2d55069579a545fba478430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3820178b949baa84b2d55069579a545fba478430"}], "stats": {"total": 65, "additions": 45, "deletions": 20}, "files": [{"sha": "0fa3c22817dff2e2f168c28c7d3c9bf65fffcd06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=718699e90006763f7a55e5e6449e5b9707c5125f", "patch": "@@ -1,3 +1,12 @@\n+2005-12-03  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* c-typeck.c (default_function_array_conversion,\n+\tbuild_function_call): Allow for CONVERT_EXPR as well as NOP_EXPR.\n+\t(build_conditional_expr): Apply integer_zerop to orig_op1 and\n+\torig_op2.  Don't check them for NOP_EXPR.\n+\t(build_c_cast, convert_for_assignment): Don't check for NOP_EXPR\n+\taround integer zero.\n+\n 2005-12-03  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_stack_t): Remove toc_save_p,"}, {"sha": "188e1fe355c706481f29436bf6359e0d344e34e6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=718699e90006763f7a55e5e6449e5b9707c5125f", "patch": "@@ -1467,7 +1467,8 @@ default_function_array_conversion (struct c_expr exp)\n \tbool lvalue_array_p;\n \n \twhile ((TREE_CODE (exp.value) == NON_LVALUE_EXPR\n-\t\t|| TREE_CODE (exp.value) == NOP_EXPR)\n+\t\t|| TREE_CODE (exp.value) == NOP_EXPR\n+\t\t|| TREE_CODE (exp.value) == CONVERT_EXPR)\n \t       && TREE_TYPE (TREE_OPERAND (exp.value, 0)) == type)\n \t  {\n \t    if (TREE_CODE (exp.value) == NON_LVALUE_EXPR)\n@@ -2161,7 +2162,8 @@ build_function_call (tree function, tree params)\n      expression if necessary.  This has the nice side-effect to prevent\n      the tree-inliner from generating invalid assignment trees which may\n      blow up in the RTL expander later.  */\n-  if (TREE_CODE (function) == NOP_EXPR\n+  if ((TREE_CODE (function) == NOP_EXPR\n+       || TREE_CODE (function) == CONVERT_EXPR)\n       && TREE_CODE (tem = TREE_OPERAND (function, 0)) == ADDR_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (tem, 0)) == FUNCTION_DECL\n       && !comptypes (fntype, TREE_TYPE (tem)))\n@@ -3182,11 +3184,9 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     {\n       if (comp_target_types (type1, type2))\n \tresult_type = common_pointer_type (type1, type2);\n-      else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node\n-\t       && TREE_CODE (orig_op1) != NOP_EXPR)\n+      else if (integer_zerop (orig_op1) && TREE_TYPE (type1) == void_type_node)\n \tresult_type = qualify_type (type2, type1);\n-      else if (integer_zerop (op2) && TREE_TYPE (type2) == void_type_node\n-\t       && TREE_CODE (orig_op2) != NOP_EXPR)\n+      else if (integer_zerop (orig_op2) && TREE_TYPE (type2) == void_type_node)\n \tresult_type = qualify_type (type1, type2);\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n@@ -3458,8 +3458,7 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n-\t  && !(integer_zerop (value) && TREE_TYPE (otype) == void_type_node\n-\t       && TREE_CODE (expr) != NOP_EXPR))\n+\t  && !(integer_zerop (value) && TREE_TYPE (otype) == void_type_node))\n \tpedwarn (\"ISO C forbids conversion of object pointer to function pointer type\");\n \n       ovalue = value;\n@@ -3812,9 +3811,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t    }\n \n \t  /* Can convert integer zero to any pointer type.  */\n-\t  if (integer_zerop (rhs)\n-\t      || (TREE_CODE (rhs) == NOP_EXPR\n-\t\t  && integer_zerop (TREE_OPERAND (rhs, 0))))\n+\t  if (integer_zerop (rhs))\n \t    {\n \t      rhs = null_pointer_node;\n \t      break;\n@@ -3952,9 +3949,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)\n \t\t  ||\n \t\t  (VOID_TYPE_P (ttr)\n-\t\t   /* Check TREE_CODE to catch cases like (void *) (char *) 0\n-\t\t      which are not ANSI null ptr constants.  */\n-\t\t   && (!integer_zerop (rhs) || TREE_CODE (rhs) == NOP_EXPR)\n+\t\t   && !integer_zerop (rhs)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n \t    WARN_FOR_ASSIGNMENT (G_(\"ISO C forbids passing argument %d of \"\n \t\t\t\t    \"%qE between function pointer \"\n@@ -4044,12 +4039,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       /* An explicit constant 0 can convert to a pointer,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n-      if (!(TREE_CODE (rhs) == INTEGER_CST && integer_zerop (rhs))\n-\t  &&\n-\t  !(TREE_CODE (rhs) == NOP_EXPR\n-\t    && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE\n-\t    && TREE_CODE (TREE_OPERAND (rhs, 0)) == INTEGER_CST\n-\t    && integer_zerop (TREE_OPERAND (rhs, 0))))\n+      if (!integer_zerop (rhs))\n \tWARN_FOR_ASSIGNMENT (G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\"pointer from integer without a cast\"),\n \t\t\t     G_(\"assignment makes pointer from integer \""}, {"sha": "b6c4a8e1e1f934d2f98428d79457734240f01f4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=718699e90006763f7a55e5e6449e5b9707c5125f", "patch": "@@ -1,3 +1,7 @@\n+2005-12-03  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/c90-const-expr-4.c, gcc.dg/c99-const-expr-4.c: New tests.\n+\n 2005-12-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/24173"}, {"sha": "6a449870ed3f8b430ef85e7f23a87a5272b320e3", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-4.c?ref=718699e90006763f7a55e5e6449e5b9707c5125f", "patch": "@@ -0,0 +1,11 @@\n+/* Test for constant expressions: const variable with value 0 is not a\n+   null pointer constant so the conditional expression should have\n+   type void * and the assignment is OK.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -O2\" } */\n+int *p;\n+long *q;\n+static void *const n = 0;\n+int j;\n+void f(void) { q = j ? p : n; }"}, {"sha": "f6beaf77a04135413b41624882de7c5d9eed96ac", "filename": "gcc/testsuite/gcc.dg/c99-const-expr-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/718699e90006763f7a55e5e6449e5b9707c5125f/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-const-expr-4.c?ref=718699e90006763f7a55e5e6449e5b9707c5125f", "patch": "@@ -0,0 +1,11 @@\n+/* Test for constant expressions: const variable with value 0 is not a\n+   null pointer constant so the conditional expression should have\n+   type void * and the assignment is OK.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -O2\" } */\n+int *p;\n+long *q;\n+static void *const n = 0;\n+int j;\n+void f(void) { q = j ? p : n; }"}]}