{"sha": "a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkYWQ3YjY1ODUwZDdiNGVhODNmN2E4ZTE3ZDc0ZTdhZWVmY2RkNQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mjw@redhat.com", "date": "2014-08-19T10:30:07Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2014-08-19T10:30:07Z"}, "message": "Add guality [p]type test.\n\nAdd a new type:var variant to the guality.exp testsuite to check that\ngdb gets the correct type for a variable or function. To use it in a\nguality test add something like:\n\n/* { dg-final { gdb-test 50 \"type:main\" \"int (int, char **)\" } } */\n\nWhich will put a breakpoint at line 50 and check that the type of \"main\"\nequals \"int (int, char **)\" according to gdb. The test harness will make\nsure to squash all extra whitespace/newlines that gdb might use to make\ncomparisons of large structs easy.\n\ngcc/testsuite/ChangeLog\n\n\t* lib/gcc-gdb-test.exp (gdb-test): Handle type:var for gdb ptype\n\tmatching. Catch '<unknown type in ' to recognize older gdb versions.\n\t* gcc.dg/guality/const-volatile.c: New test.\n\nFrom-SVN: r214139", "tree": {"sha": "3fd8d69776cc4f02da123057b50399697da12933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd8d69776cc4f02da123057b50399697da12933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/comments", "author": null, "committer": null, "parents": [{"sha": "4f9b1c116e1ec9ffaa8f951e54d08621e2fc5d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f9b1c116e1ec9ffaa8f951e54d08621e2fc5d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f9b1c116e1ec9ffaa8f951e54d08621e2fc5d98"}], "stats": {"total": 136, "additions": 132, "deletions": 4}, "files": [{"sha": "cc24bfa93745afe610f2dbde9c3e2d178a281143", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "patch": "@@ -1,3 +1,9 @@\n+2014-07-03  Mark Wielaard  <mjw@redhat.com>\n+\n+\t* lib/gcc-gdb-test.exp (gdb-test): Handle type:var for gdb ptype\n+\tmatching. Catch '<unknown type in ' to recognize older gdb versions.\n+\t* gcc.dg/guality/const-volatile.c: New test.\n+\n 2014-08-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/debug/dwarf2/nested-4.C: XFAIL on *-*-solaris2.1[1-9]* &&"}, {"sha": "6c2b61782b10cdb6a27ac0083a36e8db9a0ec39d", "filename": "gcc/testsuite/gcc.dg/guality/const-volatile.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fconst-volatile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fconst-volatile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fconst-volatile.c?ref=a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "patch": "@@ -0,0 +1,83 @@\n+/* debuginfo tests for combinations of const and volatile type qualifiers. */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+int i;\n+const int ci;\n+volatile int vi;\n+const volatile int cvi;\n+\n+int *pi;\n+const int *pci;\n+volatile int *pvi;\n+const volatile int *pcvi;\n+\n+int * const cip;\n+int * volatile vip;\n+int * const volatile cvip;\n+\n+volatile struct\n+{\n+  const long cli;\n+  const signed char csc;\n+} vs;\n+\n+struct foo\n+{\n+  const long cli;\n+  const signed char csc;\n+};\n+\n+struct foo foo;\n+const struct foo cfoo;\n+volatile struct foo vfoo;\n+const volatile struct foo cvfoo;\n+\n+typedef volatile signed char score;\n+\n+score s;\n+const score cs;\n+\n+static __attribute__((noclone, noinline)) int\n+f (const char *progname, volatile struct foo *dummy, const score s)\n+{\n+  return progname == 0 || dummy == 0 || dummy->csc == s;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  score as = argc;\n+  struct foo dummy = { 1, 1 };\n+  return f (argv[0], &dummy, as) - 1;\n+}\n+\n+/* { dg-final { gdb-test 50 \"type:main\" \"int (int, char **)\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:i\" \"int\" } } */\n+/* { dg-final { gdb-test 50 \"type:ci\" \"const int\" } } */\n+/* { dg-final { gdb-test 50 \"type:vi\" \"volatile int\" } } */\n+/* { dg-final { gdb-test 50 \"type:cvi\" \"const volatile int\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:pi\" \"int *\" } } */\n+/* { dg-final { gdb-test 50 \"type:pci\" \"const int *\" } } */\n+/* { dg-final { gdb-test 50 \"type:pvi\" \"volatile int *\" } } */\n+/* { dg-final { gdb-test 50 \"type:pcvi\" \"const volatile int *\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:cip\" \"int * const\" } } */\n+/* { dg-final { gdb-test 50 \"type:vip\" \"int * volatile\" } } */\n+/* { dg-final { gdb-test 50 \"type:cvip\" \"int * const volatile\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:vs\" \"volatile struct { const long cli; const signed char csc; }\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:cvip\" \"int * const volatile\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:foo\" \"struct foo { const long cli; const signed char csc; }\" } } */\n+/* { dg-final { gdb-test 50 \"type:cfoo\" \"const struct foo { const long cli; const signed char csc; }\" } } */\n+/* { dg-final { gdb-test 50 \"type:vfoo\" \"volatile struct foo { const long cli; const signed char csc; }\" } } */\n+/* { dg-final { gdb-test 50 \"type:cvfoo\" \"const volatile struct foo { const long cli; const signed char csc; }\" } } */\n+\n+/* { dg-final { gdb-test 58 \"type:s\" \"volatile signed char\" } } */\n+/* { dg-final { gdb-test 50 \"type:cs\" \"const volatile signed char\" } } */\n+\n+/* { dg-final { gdb-test 50 \"type:f\" \"int (const char *, volatile struct foo *, const score)\" } } */"}, {"sha": "c7297936c39b7f68e9aeee26aa8df7e63287858a", "filename": "gcc/testsuite/lib/gcc-gdb-test.exp", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/gcc%2Ftestsuite%2Flib%2Fgcc-gdb-test.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5/gcc%2Ftestsuite%2Flib%2Fgcc-gdb-test.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-gdb-test.exp?ref=a6dad7b65850d7b4ea83f7a8e17d74e7aeefcdd5", "patch": "@@ -19,7 +19,12 @@\n #\n # Argument 0 is the line number on which to put a breakpoint\n # Argument 1 is the name of the variable to be checked\n-# Argument 2 is the expected value of the variable\n+#   possibly prefixed with type: to get the type of the variable\n+#   instead of the value of the variable (the default).\n+# Argument 2 is the expected value (or type) of the variable\n+#   When asking for the value, the expected value is produced\n+#   calling print on it in gdb. When asking for the type it is\n+#   the literal string with extra whitespace removed.\n # Argument 3 handles expected failures and the like\n proc gdb-test { args } {\n     if { ![isnative] || [is_remote target] } { return }\n@@ -39,6 +44,16 @@ proc gdb-test { args } {\n     upvar 2 name testcase\n     upvar 2 prog prog\n \n+    # The command to run on the variable\n+    set arg1 [lindex $args 1]\n+    if { [string equal -length 5 \"type:\" $arg1] == 1 } {\n+\tset command \"ptype\"\n+\tset var [string range $arg1 5 end]\n+    } else {\n+\tset command \"print\"\n+\tset var $arg1\n+    }\n+\n     set gdb_name $::env(GUALITY_GDB_NAME)\n     set testname \"$testcase line [lindex $args 0] [lindex $args 1] == [lindex $args 2]\"\n     set output_file \"[file rootname [file tail $prog]].exe\"\n@@ -47,8 +62,14 @@ proc gdb-test { args } {\n     set fd [open $cmd_file \"w\"]\n     puts $fd \"break [lindex $args 0]\"\n     puts $fd \"run\"\n-    puts $fd \"print [lindex $args 1]\"\n-    puts $fd \"print [lindex $args 2]\"\n+    puts $fd \"$command $var\"\n+    if { $command == \"print\" } {\n+\t# For values, let gdb interpret them by printing them.\n+\tputs $fd \"print [lindex $args 2]\"\n+    } else {\n+\t# Since types can span multiple lines, we need an end marker.\n+\tputs $fd \"echo TYPE_END\\\\n\"\n+    }\n     puts $fd \"quit\"\n     close $fd\n \n@@ -62,12 +83,13 @@ proc gdb-test { args } {\n \n     remote_expect target [timeout_value] {\n \t# Too old GDB\n-\t-re \"Unhandled dwarf expression|Error in sourced command file\" {\n+\t-re \"Unhandled dwarf expression|Error in sourced command file|<unknown type in \" {\n \t    unsupported \"$testname\"\n \t    remote_close target\n \t    file delete $cmd_file\n \t    return\n \t}\n+\t# print var; print expected\n \t-re {[\\n\\r]\\$1 = ([^\\n\\r]*)[\\n\\r]+\\$2 = ([^\\n\\r]*)[\\n\\r]} {\n \t    set first $expect_out(1,string)\n \t    set second $expect_out(2,string)\n@@ -83,6 +105,23 @@ proc gdb-test { args } {\n \t    file delete $cmd_file\n \t    return\n \t}\n+\t# ptype var;\n+\t-re {[\\n\\r]type = (.*)[\\n\\r][\\n\\r]TYPE_END[\\n\\r]} {\n+\t    set type $expect_out(1,string)\n+\t    # Squash all extra whitespace/newlines that gdb might use for\n+\t    # \"pretty printing\" into one so result is just one line.\n+\t    regsub -all {[\\n\\r\\t ]+} $type \" \" type\n+\t    set expected [lindex $args 2]\n+\t    if { $type == $expected } {\n+\t\tpass \"$testname\"\n+\t    } else {\n+\t\tsend_log -- \"$type != $expected\\n\"\n+\t\tfail \"$testname\"\n+\t    }\n+\t    remote_close target\n+\t    file delete $cmd_file\n+\t    return\n+\t}\n \ttimeout {\n \t    unsupported \"$testname\"\n \t    remote_close target"}]}