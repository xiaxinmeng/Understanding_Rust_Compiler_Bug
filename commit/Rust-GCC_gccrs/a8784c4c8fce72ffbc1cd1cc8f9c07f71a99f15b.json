{"sha": "a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3ODRjNGM4ZmNlNzJmZmJjMWNkMWNjOGY5YzA3ZjcxYTk5ZjE1Yg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@unitus.it", "date": "2003-07-07T12:15:00Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-07-07T12:15:00Z"}, "message": "std_complex.h: Partially revert last changes: cmath functions must not be qualified.\n\n2003-07-07  Paolo Carlini  <pcarlini@unitus.it>\n\n\t* include/std/std_complex.h: Partially revert last\n\tchanges: cmath functions must not be qualified.\n\nFrom-SVN: r69040", "tree": {"sha": "fab91978f204af80ce0e6e20ac7ff97d6ff8b3e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fab91978f204af80ce0e6e20ac7ff97d6ff8b3e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b/comments", "author": null, "committer": null, "parents": [{"sha": "e61a2eb7764935d0e038ba4bd9d8161a11cf342b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61a2eb7764935d0e038ba4bd9d8161a11cf342b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61a2eb7764935d0e038ba4bd9d8161a11cf342b"}], "stats": {"total": 43, "additions": 24, "deletions": 19}, "files": [{"sha": "0e55603e598056bb9e548086e3a624fa06c55b68", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b", "patch": "@@ -1,3 +1,8 @@\n+2003-07-07  Paolo Carlini  <pcarlini@unitus.it>\n+\n+\t* include/std/std_complex.h: Partially revert last\n+\tchanges: cmath functions must not be qualified.\n+\n 2003-07-06  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* acinclude.m4 (GLIBCXX_ENABLE_SYMVERS):  Do not test for binutils"}, {"sha": "94c30a2cde68d14b82d047c3908e34aacd3593cb", "filename": "libstdc++-v3/include/std/std_complex.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h?ref=a8784c4c8fce72ffbc1cd1cc8f9c07f71a99f15b", "patch": "@@ -411,18 +411,18 @@ namespace std\n     {\n       _Tp __x = __z.real();\n       _Tp __y = __z.imag();\n-      const _Tp __s = std::max(std::abs(__x), std::abs(__y));\n+      const _Tp __s = std::max(abs(__x), abs(__y));\n       if (__s == _Tp())  // well ...\n         return __s;\n       __x /= __s; \n       __y /= __s;\n-      return __s * std::sqrt(__x * __x + __y * __y);\n+      return __s * sqrt(__x * __x + __y * __y);\n     }\n \n   template<typename _Tp>\n     inline _Tp\n     arg(const complex<_Tp>& __z)\n-    { return std::atan2(__z.imag(), __z.real()); }\n+    { return atan2(__z.imag(), __z.real()); }\n \n   // 26.2.7/5: norm(__z) returns the squared magintude of __z.\n   //     As defined, norm() is -not- a norm is the common mathematical\n@@ -462,7 +462,7 @@ namespace std\n   template<typename _Tp>\n     inline complex<_Tp>\n     polar(const _Tp& __rho, const _Tp& __theta)\n-    { return complex<_Tp>(__rho * std::cos(__theta), __rho * std::sin(__theta)); }\n+    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n@@ -476,7 +476,7 @@ namespace std\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n-      return complex<_Tp>(std::cos(__x) * std::cosh(__y), -std::sin(__x) * std::sinh(__y));\n+      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));\n     }\n \n   template<typename _Tp>\n@@ -485,31 +485,31 @@ namespace std\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n-      return complex<_Tp>(std::cosh(__x) * std::cos(__y), std::sinh(__x) * std::sin(__y));\n+      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     exp(const complex<_Tp>& __z)\n-    { return std::polar(std::exp(__z.real()), __z.imag()); }\n+    { return std::polar(exp(__z.real()), __z.imag()); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     log(const complex<_Tp>& __z)\n-    { return complex<_Tp>(std::log(std::abs(__z)), std::arg(__z)); }\n+    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     log10(const complex<_Tp>& __z)\n-    { return std::log(__z) / std::log(_Tp(10.0)); }\n+    { return std::log(__z) / log(_Tp(10.0)); }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     sin(const complex<_Tp>& __z)\n     {\n       const _Tp __x = __z.real();\n       const _Tp __y = __z.imag();\n-      return complex<_Tp>(std::sin(__x) * std::cosh(__y), std::cos(__x) * std::sinh(__y)); \n+      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y)); \n     }\n \n   template<typename _Tp>\n@@ -518,7 +518,7 @@ namespace std\n     {\n       const _Tp __x = __z.real();\n       const _Tp  __y = __z.imag();\n-      return complex<_Tp>(std::sinh(__x) * std::cos(__y), std::cosh(__x) * std::sin(__y));\n+      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));\n     }\n \n   template<typename _Tp>\n@@ -530,16 +530,16 @@ namespace std\n \n       if (__x == _Tp())\n         {\n-          _Tp __t = std::sqrt(std::abs(__y) / 2);\n+          _Tp __t = sqrt(abs(__y) / 2);\n           return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);\n         }\n       else\n         {\n-          _Tp __t = std::sqrt(2 * (std::abs(__z) + std::abs(__x)));\n+          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));\n           _Tp __u = __t / 2;\n           return __x > _Tp()\n             ? complex<_Tp>(__u, __y / __t)\n-            : complex<_Tp>(std::abs(__y) / __t, __y < _Tp() ? -__u : __u);\n+            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);\n         }\n     }\n \n@@ -569,17 +569,17 @@ namespace std\n     pow(const complex<_Tp>& __x, const _Tp& __y)\n     {\n       if (__x.imag() == _Tp())\n-        return std::pow(__x.real(), __y);\n+        return pow(__x.real(), __y);\n \n-      complex<_Tp> __t = std::log(__x);\n-      return std::polar(std::exp(__y * __t.real()), __y * __t.imag());\n+      complex<_Tp> __t = log(__x);\n+      return std::polar(exp(__y * __t.real()), __y * __t.imag());\n     }\n \n   template<typename _Tp>\n     inline complex<_Tp>\n     pow(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     {\n-      return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x));\n+      return __x == _Tp() ? _Tp() : exp(__y * log(__x));\n     }\n \n   template<typename _Tp>\n@@ -588,7 +588,7 @@ namespace std\n     {\n       return __x == _Tp()\n         ? _Tp()\n-        : std::polar(std::pow(__x, __y.real()), __y.imag() * std::log(__x));\n+        : std::polar(pow(__x, __y.real()), __y.imag() * log(__x));\n     }\n \n   // 26.2.3  complex specializations"}]}