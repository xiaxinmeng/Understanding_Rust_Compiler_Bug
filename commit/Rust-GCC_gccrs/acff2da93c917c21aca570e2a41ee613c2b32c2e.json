{"sha": "acff2da93c917c21aca570e2a41ee613c2b32c2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNmZjJkYTkzYzkxN2MyMWFjYTU3MGUyYTQxZWU2MTNjMmIzMmMyZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-09-23T17:16:07Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-09-23T17:16:07Z"}, "message": "re PR fortran/16861 ([4.0 only] segfault with doubly used module)\n\n2005-09-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16861\n\t* module.c (mio_component_ref): Return if the symbol is NULL\n\tand wait for another iteration during module reads.\n\t(mio_symtree_ref): Suppress the writing of contained symbols,\n\twhen a symbol is available in the main namespace.\n\t(read_module): Restrict scope of special treatment of contained\n\tsymbols to variables only and suppress redundant call to\n\tfind_true_name.\n\n2005-09-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16861\n\t* gfortran.dg/nested_modules_3.f90: New.\n\nFrom-SVN: r104574", "tree": {"sha": "d068f8c60390d286e2f452c877da2e48722452f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d068f8c60390d286e2f452c877da2e48722452f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acff2da93c917c21aca570e2a41ee613c2b32c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acff2da93c917c21aca570e2a41ee613c2b32c2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acff2da93c917c21aca570e2a41ee613c2b32c2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acff2da93c917c21aca570e2a41ee613c2b32c2e/comments", "author": null, "committer": null, "parents": [{"sha": "e1e73e8db762a241a34ccf564e9592992535151e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e73e8db762a241a34ccf564e9592992535151e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e73e8db762a241a34ccf564e9592992535151e"}], "stats": {"total": 110, "additions": 98, "deletions": 12}, "files": [{"sha": "76b0344e73c2965e1331d57b7110770dfb90e261", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=acff2da93c917c21aca570e2a41ee613c2b32c2e", "patch": "@@ -1,3 +1,14 @@\n+2005-09-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16861\n+\t* module.c (mio_component_ref): Return if the symbol is NULL\n+\tand wait for another iteration during module reads.\n+\t(mio_symtree_ref): Suppress the writing of contained symbols,\n+\twhen a symbol is available in the main namespace.\n+\t(read_module): Restrict scope of special treatment of contained\n+\tsymbols to variables only and suppress redundant call to\n+\tfind_true_name.\n+\n 2005-09-22  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/24005"}, {"sha": "1066e2ef52f5f1d3cc53c97d7f0d64843d93dd94", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=acff2da93c917c21aca570e2a41ee613c2b32c2e", "patch": "@@ -1873,6 +1873,12 @@ mio_component_ref (gfc_component ** cp, gfc_symbol * sym)\n     {\n       mio_internal_string (name);\n \n+      /* It can happen that a component reference can be read before the\n+\t associated derived type symbol has been loaded. Return now and\n+\t wait for a later iteration of load_needed.  */\n+      if (sym == NULL)\n+\treturn;\n+\n       if (sym->components != NULL && p->u.pointer == NULL)\n \t{\n \t  /* Symbol already loaded, so search by name.  */\n@@ -2085,10 +2091,18 @@ mio_symtree_ref (gfc_symtree ** stp)\n {\n   pointer_info *p;\n   fixup_t *f;\n+  gfc_symtree * ns_st = NULL;\n \n   if (iomode == IO_OUTPUT)\n     {\n-      mio_symbol_ref (&(*stp)->n.sym);\n+      /* If this is a symtree for a symbol that came from a contained module\n+\t namespace, it has a unique name and we should look in the current\n+\t namespace to see if the required, non-contained symbol is available\n+\t yet. If so, the latter should be written.  */\n+      if ((*stp)->n.sym && check_unique_name((*stp)->name))\n+\tns_st = gfc_find_symtree (gfc_current_ns->sym_root, (*stp)->n.sym->name);\n+\n+      mio_symbol_ref (ns_st ? &ns_st->n.sym : &(*stp)->n.sym);\n     }\n   else\n     {\n@@ -3099,7 +3113,7 @@ read_module (void)\n   const char *p;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_intrinsic_op i;\n-  int ambiguous, j, nuse, series, symbol;\n+  int ambiguous, j, nuse, symbol;\n   pointer_info *info;\n   gfc_use_rename *u;\n   gfc_symtree *st;\n@@ -3119,7 +3133,6 @@ read_module (void)\n   mio_lparen ();\n \n   /* Create the fixup nodes for all the symbols.  */\n-  series = 0;\n \n   while (peek_atom () != ATOM_RPAREN)\n     {\n@@ -3144,14 +3157,16 @@ read_module (void)\n \n       sym = find_true_name (info->u.rsym.true_name, info->u.rsym.module);\n \n-      /* If a module contains subroutines with assumed shape dummy\n-       arguments, the symbols for indices need to be different from\n-       from those in the module proper(ns = 1).  */\n-      if (sym !=NULL && info->u.rsym.ns != 1)\n-\tsym = find_true_name (info->u.rsym.true_name,\n-\t\tgfc_get_string (\"%s@%d\",module_name, series++));\n+        /* See if the symbol has already been loaded by a previous module.\n+\t If so, we reference the existing symbol and prevent it from\n+\t being loaded again.  This should not happen if the symbol being\n+\t read is an index for an assumed shape dummy array (ns != 1).  */\n \n-      if (sym == NULL)\n+      sym = find_true_name (info->u.rsym.true_name, info->u.rsym.module);\n+\n+      if (sym == NULL\n+\t   || (sym->attr.flavor == FL_VARIABLE\n+\t       && info->u.rsym.ns !=1))\n \tcontinue;\n \n       info->u.rsym.state = USED;\n@@ -3213,8 +3228,8 @@ read_module (void)\n \t      if (sym == NULL)\n \t\t{\n \t\t  sym = info->u.rsym.sym =\n-\t\t      gfc_new_symbol (info->u.rsym.true_name\n-\t\t\t\t      , gfc_current_ns);\n+\t\t      gfc_new_symbol (info->u.rsym.true_name,\n+\t\t\t\t      gfc_current_ns);\n \n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n \t\t}"}, {"sha": "0c43597323e8c569fbeca749df3a59e9c2064af5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=acff2da93c917c21aca570e2a41ee613c2b32c2e", "patch": "@@ -1,3 +1,8 @@\n+2005-09-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/16861\n+\t* gfortran.dg/nested_modules_3.f90: New.\n+\n 2005-09-22 Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/24005"}, {"sha": "364460c613826604cc76658ec154d8cfaf4796a3", "filename": "gcc/testsuite/gfortran.dg/nested_modules_3.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acff2da93c917c21aca570e2a41ee613c2b32c2e/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_3.f90?ref=acff2da93c917c21aca570e2a41ee613c2b32c2e", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+!\n+! This tests the improved version of the patch for PR16861.  Testing\n+! after committing the first version, revealed that this test did\n+! not work but was not regtested for, either.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org>\n+!\n+MODULE foo\n+  TYPE type1\n+    INTEGER i1\n+  END TYPE type1\n+END MODULE\n+\n+MODULE bar\n+CONTAINS\n+  SUBROUTINE sub1 (x, y)\n+    USE foo\n+    TYPE (type1)  :: x\n+    INTEGER  :: y(x%i1)\n+    y = 1\n+  END SUBROUTINE SUB1\n+  SUBROUTINE sub2 (u, v)\n+    USE foo\n+    TYPE (type1)  :: u\n+    INTEGER  :: v(u%i1)\n+    v = 2\n+  END SUBROUTINE SUB2\n+END MODULE\n+\n+MODULE foobar\n+  USE foo\n+  USE bar\n+CONTAINS\n+  SUBROUTINE sub3 (s, t)\n+    USE foo\n+    TYPE (type1)  :: s\n+    INTEGER  :: t(s%i1)\n+    t = 3\n+  END SUBROUTINE SUB3\n+END MODULE foobar\n+\n+PROGRAM use_foobar\n+  USE foo\n+  USE foobar\n+  INTEGER :: j(3) = 0\n+  TYPE (type1)   :: z\n+  z%i1 = 3\n+  CALL sub1 (z, j)\n+  z%i1 = 2\n+  CALL sub2 (z, j)\n+  z%i1 = 1\n+  CALL sub3 (z, j)\n+  IF (ALL (j.ne.(/3,2,1/))) CALL abort ()\n+END PROGRAM use_foobar"}]}