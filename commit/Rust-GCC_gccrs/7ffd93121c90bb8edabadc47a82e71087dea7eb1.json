{"sha": "7ffd93121c90bb8edabadc47a82e71087dea7eb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmZDkzMTIxYzkwYmI4ZWRhYmFkYzQ3YTgyZTcxMDg3ZGVhN2ViMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:55:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:55:59Z"}, "message": "sem_ch4.adb (Analyze_Selected_Component): Create Actual_Subtype even with expansion disabled.\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Create Actual_Subtype even\n\twith expansion disabled. The actual subtype is needed among other\n\tplaces when the selected component appears in the context of a loop\n\tbound, and denotes a packed array.\n\t(Operator_Check): Always use the first subtype in the\n\terror message, to avoid the appearance of internal base types.\n\t(Transform_Object_Operation): Copy each actual in full\n\tto the parameter associations of the constructed call, rather than\n\tusing the shallow copy mechanism of New_Copy_List. This ensures that\n\tthe chaining of named associations is done properly.\n\t(Complete_Object_Operation): Rewrite node, rather than\n\treplacing it, so that we can trace back to the original selected\n\tcomponent.\n\n\t* sem_elab.adb (Set_Elaboration_Constraint): For initialization calls,\n\tand calls that use object notation, if the called function is not\n\tdeclared  in a withed unit, place the elaboration constraint on the\n\tunit in the context that makes the function accessible.\n\t(Check_Elab_Subtype_Declaration): Check whether a subtype declaration\n\timposes an elaboration constraint between two packages.\n\nFrom-SVN: r94820", "tree": {"sha": "84dd53df6d99da6a0a0aa0fe0a8c759e21953676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84dd53df6d99da6a0a0aa0fe0a8c759e21953676"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ffd93121c90bb8edabadc47a82e71087dea7eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffd93121c90bb8edabadc47a82e71087dea7eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffd93121c90bb8edabadc47a82e71087dea7eb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffd93121c90bb8edabadc47a82e71087dea7eb1/comments", "author": null, "committer": null, "parents": [{"sha": "a3a0db2eb9a89957d478bce7132e19d0492eb96d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a0db2eb9a89957d478bce7132e19d0492eb96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a0db2eb9a89957d478bce7132e19d0492eb96d"}], "stats": {"total": 170, "additions": 149, "deletions": 21}, "files": [{"sha": "17d9993f329a54b961d7dbc370f9309fca554b9f", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffd93121c90bb8edabadc47a82e71087dea7eb1/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffd93121c90bb8edabadc47a82e71087dea7eb1/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7ffd93121c90bb8edabadc47a82e71087dea7eb1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2650,10 +2650,7 @@ package body Sem_Ch4 is\n                --  not make an actual subtype, we end up getting a direct\n                --  reference to a discriminant which will not do.\n \n-               --  Comment needs revision, \"in all other cases\" does not\n-               --  reasonably describe the situation below with an elsif???\n-\n-               elsif Expander_Active then\n+               else\n                   Act_Decl :=\n                     Build_Actual_Subtype_Of_Component (Etype (Comp), N);\n                   Insert_Action (N, Act_Decl);\n@@ -2675,9 +2672,6 @@ package body Sem_Ch4 is\n                         Set_Etype (N, Subt);\n                      end;\n                   end if;\n-\n-               else\n-                  Set_Etype (N, Etype (Comp));\n                end if;\n \n                return;\n@@ -4400,7 +4394,7 @@ package body Sem_Ch4 is\n                     and then not Is_Overloaded (R)\n                     and then Base_Type (Etype (L)) = Base_Type (Etype (R))\n                   then\n-                     Error_Msg_Node_2 := Etype (R);\n+                     Error_Msg_Node_2 := First_Subtype (Etype (R));\n                      Error_Msg_N (\"there is no applicable operator& for}\", N);\n \n                   else\n@@ -4799,7 +4793,7 @@ package body Sem_Ch4 is\n       begin\n          Set_Name (Call_Node, New_Copy_Tree (Subprog));\n          Set_Analyzed (Call_Node, False);\n-         Replace (Node_To_Replace, Call_Node);\n+         Rewrite (Node_To_Replace, Call_Node);\n          Analyze (Node_To_Replace);\n \n       end Complete_Object_Operation;\n@@ -4830,8 +4824,19 @@ package body Sem_Ch4 is\n          then\n             Node_To_Replace := Parent_Node;\n \n-            Append_List_To (Actuals,\n-              New_Copy_List (Parameter_Associations (Parent_Node)));\n+            --  Copy list of actuals in full before attempting to resolve call.\n+            --  This is necessary to ensure that the chaining of named actuals\n+            --  that happens during matching is done on a separate copy.\n+\n+            declare\n+               Actual : Node_Id;\n+            begin\n+               Actual := First (Parameter_Associations (Parent_Node));\n+               while Present (Actual) loop\n+                  Append (New_Copy_Tree (Actual), Actuals);\n+                  Next (Actual);\n+               end loop;\n+            end;\n \n             if Nkind (Parent_Node) = N_Procedure_Call_Statement then\n                Call_Node :="}, {"sha": "f7236abe20e1f6c90dda8397a8c4f0b55bf6ffed", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 132, "deletions": 9, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffd93121c90bb8edabadc47a82e71087dea7eb1/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffd93121c90bb8edabadc47a82e71087dea7eb1/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=7ffd93121c90bb8edabadc47a82e71087dea7eb1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -159,7 +159,7 @@ package body Sem_Elab is\n    -- Local Subprograms --\n    -----------------------\n \n-   --  Note: Outer_Scope in all these calls represents the scope of\n+   --  Note: Outer_Scope in all following specs represents the scope of\n    --  interest of the outer level call. If it is set to Standard_Standard,\n    --  then it means the outer level call was at elaboration level, and that\n    --  thus all calls are of interest. If it was set to some other scope,\n@@ -224,6 +224,29 @@ package body Sem_Elab is\n    --  to Check_Internal_Call. Outer_Scope is the outer level scope for\n    --  the original call.\n \n+   procedure Set_Elaboration_Constraint\n+    (Call : Node_Id;\n+     Subp : Entity_Id;\n+     Scop : Entity_Id);\n+   --  The current unit U may depend semantically on some unit P which is not\n+   --  in the current context. If there is an elaboration call that reaches P,\n+   --  we need to indicate that P requires an Elaborate_All, but this is not\n+   --  effective in U's ali file, if there is no with_clause for P. In this\n+   --  case we add the Elaborate_All on the unit Q that directly or indirectly\n+   --  makes P available. This can happen in two cases:\n+   --\n+   --    a) Q declares a subtype of a type declared in P, and the call is an\n+   --    initialization call for an object of that subtype.\n+   --\n+   --    b) Q declares an object of some tagged type whose root type is\n+   --    declared in P, and the initialization call uses object notation on\n+   --    that object to reach a primitive operation or a classwide operation\n+   --    declared in P.\n+   --\n+   --  If P appears in the context of U, the current processing is correct.\n+   --  Otherwise we must identify these two cases to retrieve Q and place the\n+   --  Elaborate_All_Desirable on it.\n+\n    function Has_Generic_Body (N : Node_Id) return Boolean;\n    --  N is a generic package instantiation node, and this routine determines\n    --  if this package spec does in fact have a generic body. If so, then\n@@ -308,11 +331,16 @@ package body Sem_Elab is\n       --  elaboration check is required.\n \n       W_Scope : Entity_Id;\n-      --  Top level scope of directly called entity for subprogram.\n-      --  This differs from E_Scope in the case where renamings or\n-      --  derivations are involved, since it does not follow these\n-      --  links, thus W_Scope is always in a visible unit. This is\n-      --  the scope for the Elaborate_All if one is needed.\n+      --  Top level scope of directly called entity for subprogram. This\n+      --  differs from E_Scope in the case where renamings or derivations\n+      --  are involved, since it does not follow these links. W_Scope is\n+      --  generally in a visible unit, and it is this scope that may require\n+      --  an Elaborate_All. However, there are some cases (initialization\n+      --  calls and calls involving object notation) where W_Scope might not\n+      --  be in the context of the current unit, and there is an intermediate\n+      --  package that is, in which case the Elaborate_All has to be placed\n+      --  on this intedermediate package. These special cases are handled in\n+      --  Set_Elaboration_Constraint.\n \n       Body_Acts_As_Spec : Boolean;\n       --  Set to true if call is to body acting as spec (no separate spec)\n@@ -751,8 +779,7 @@ package body Sem_Elab is\n \n                --  Set indication for binder to generate Elaborate_All\n \n-               Set_Elaborate_All_Desirable (W_Scope);\n-               Set_Suppress_Elaboration_Warnings (W_Scope, True);\n+               Set_Elaboration_Constraint (N, E, W_Scope);\n             end if;\n          end if;\n \n@@ -1345,6 +1372,12 @@ package body Sem_Elab is\n          return;\n       end if;\n \n+      --  Nothing to do if the instantiation is not in the main unit.\n+\n+      if not In_Extended_Main_Code_Unit (N) then\n+         return;\n+      end if;\n+\n       Ent := Get_Generic_Entity (N);\n       From_Elab_Code := not In_Subprogram_Or_Concurrent_Unit;\n \n@@ -2000,6 +2033,96 @@ package body Sem_Elab is\n       In_Task_Activation := False;\n    end Check_Task_Activation;\n \n+   --------------------------------\n+   -- Set_Elaboration_Constraint --\n+   --------------------------------\n+\n+   procedure Set_Elaboration_Constraint\n+    (Call : Node_Id;\n+     Subp : Entity_Id;\n+     Scop : Entity_Id)\n+   is\n+      Elab_Unit  : Entity_Id;\n+      Init_Call  : constant Boolean :=\n+                     Chars (Subp) = Name_Initialize\n+                       and then Comes_From_Source (Subp)\n+                       and then Present (Parameter_Associations (Call))\n+                       and then Is_Controlled\n+                         (Etype (First (Parameter_Associations (Call))));\n+   begin\n+      --  If the unit is mentioned in a with_clause of the current\n+      --  unit, it is visible, and we can set the elaboration flag.\n+\n+      if Is_Immediately_Visible (Scop)\n+        or else\n+          (Is_Child_Unit (Scop) and then Is_Visible_Child_Unit (Scop))\n+      then\n+         Set_Elaborate_All_Desirable (Scop);\n+         Set_Suppress_Elaboration_Warnings (Scop, True);\n+         return;\n+      end if;\n+\n+      --  If this is not an initialization call or a call using object notation\n+      --  we know that the unit of the called entity is in the context, and\n+      --  we can set the flag as well. The unit need not be visible if the call\n+      --  occurs within an instantiation.\n+\n+      if Is_Init_Proc (Subp)\n+        or else Init_Call\n+        or else Nkind (Original_Node (Call)) = N_Selected_Component\n+      then\n+         null;  --  detailed processing follows.\n+\n+      else\n+         Set_Elaborate_All_Desirable (Scop);\n+         Set_Suppress_Elaboration_Warnings (Scop, True);\n+         return;\n+      end if;\n+\n+      --  If the unit is not in the context, there must be an intermediate\n+      --  unit that is, on which we need to place to elaboration flag.\n+\n+      if Is_Init_Proc (Subp)\n+        or else Init_Call\n+      then\n+         --  The initialization call is on an object whose type is not\n+         --  declared in the same scope as the subprogram. The type of\n+         --  the object must be a subtype of the type of operation. This\n+         --  object is the first actual in the call.\n+\n+         declare\n+            Typ  : constant Entity_Id :=\n+                     Etype (First (Parameter_Associations (Call)));\n+         begin\n+            Elab_Unit := Scope (Typ);\n+\n+            while (Present (Elab_Unit))\n+              and then not Is_Compilation_Unit (Elab_Unit)\n+            loop\n+               Elab_Unit := Scope (Elab_Unit);\n+            end loop;\n+         end;\n+      elsif Nkind (Original_Node (Call)) = N_Selected_Component then\n+\n+         --  If original node uses selected component notation, the\n+         --  prefix is visible and determines the scope that must be\n+         --  elaborated. After rewriting, the prefix is the first actual\n+         --  in the call.\n+\n+         Elab_Unit := Scope (Etype (First (Parameter_Associations (Call))));\n+\n+      else\n+         --  Using previously computed scope. If the elaboration check is\n+         --  done after analysis, the scope is not visible any longer, but\n+         --  must still be in the context.\n+\n+         Elab_Unit := Scop;\n+      end if;\n+\n+      Set_Elaborate_All_Desirable (Elab_Unit);\n+      Set_Suppress_Elaboration_Warnings (Elab_Unit, True);\n+   end Set_Elaboration_Constraint;\n+\n    ----------------------\n    -- Has_Generic_Body --\n    ----------------------"}]}