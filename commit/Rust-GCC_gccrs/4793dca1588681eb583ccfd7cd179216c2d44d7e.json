{"sha": "4793dca1588681eb583ccfd7cd179216c2d44d7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5M2RjYTE1ODg2ODFlYjU4M2NjZmQ3Y2QxNzkyMTZjMmQ0NGQ3ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-16T20:54:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-16T20:54:44Z"}, "message": "basic-block.h (CLEANUP_PRE_SIBCALL): New constant.\n\n\t* basic-block.h (CLEANUP_PRE_SIBCALL): New constant.\n\t* except.c (finish_eh_generation): Update call of cleanup_cfg;\n\tdo rebuild_jump_labels instead of jump_optimize\n\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Likewise.\n\t* toplev.c (rest_of_compulation): Likewise for -Wreturn_type.\n\t* flow.c (try_optimize_cfg): Remove unneeded code_labels.\n\n\t* flow.c: Include timevar.h\n\t(find_basic_block): Push/pop timevar;\n\t(cleanup_cfg): Likewise.\n\t* timevar.def (TV_CFG, TV_CLEANUP_CFG): New.\n\t* Makefile: Add dependencies on timevar.h\n\n\t* integrate.c (save_for_inline): Kill all BASIC_BLOCK notes.\n\t(copy_insn_list): Avoid killing of BASIC_BLOCK notes.\n\n\t* rtl.h (delete_trivially_dead_insns): Add new parameter.\n\t* toplev.c (rest_of_compilation): Update calls.\n\t* cse.c (set_live_p, insn_live_p, dead_libcall_p): Break out from ...\n\t(delete_trivially_dead_insns): ... here; accept new argument\n\tpreserve_basic_blocks; preserve basic blocks if set.\n\n\t* reg-stack.c (stack_regs_mentioned): Return 0 if\n\tstack_regs_mentioned_data is not initialized.\n\t(reg_to_stack): Make stack_regs_mentioned survive after the\n\treg-stack is completted; do not call cleanup_cfg.\n\t* toplev.c (rest_of_compilation): Do cleanup_cfg before bb-reorder;\n\tmake cleanup_cfg after bb-reorder to output to debug file.\n\nFrom-SVN: r44056", "tree": {"sha": "f2d3118471d29556bb961862c3ae6d62df08e484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2d3118471d29556bb961862c3ae6d62df08e484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4793dca1588681eb583ccfd7cd179216c2d44d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4793dca1588681eb583ccfd7cd179216c2d44d7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4793dca1588681eb583ccfd7cd179216c2d44d7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4793dca1588681eb583ccfd7cd179216c2d44d7e/comments", "author": null, "committer": null, "parents": [{"sha": "ccef9ef51073dac630247180cba0591af5382d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccef9ef51073dac630247180cba0591af5382d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccef9ef51073dac630247180cba0591af5382d6b"}], "stats": {"total": 414, "additions": 278, "deletions": 136}, "files": [{"sha": "f012bdae56cb202f319985620a8d360b85cf35e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -1,3 +1,34 @@\n+Mon Jul 16 22:48:00 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (CLEANUP_PRE_SIBCALL): New constant.\n+\t* except.c (finish_eh_generation): Update call of cleanup_cfg;\n+\tdo rebuild_jump_labels instead of jump_optimize\n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Likewise.\n+\t* toplev.c (rest_of_compulation): Likewise for -Wreturn_type.\n+\t* flow.c (try_optimize_cfg): Remove unneeded code_labels.\n+\n+\t* flow.c: Include timevar.h\n+\t(find_basic_block): Push/pop timevar;\n+\t(cleanup_cfg): Likewise.\n+\t* timevar.def (TV_CFG, TV_CLEANUP_CFG): New.\n+\t* Makefile: Add dependencies on timevar.h\n+\n+\t* integrate.c (save_for_inline): Kill all BASIC_BLOCK notes.\n+\t(copy_insn_list): Avoid killing of BASIC_BLOCK notes.\n+\n+\t* rtl.h (delete_trivially_dead_insns): Add new parameter.\n+\t* toplev.c (rest_of_compilation): Update calls.\n+\t* cse.c (set_live_p, insn_live_p, dead_libcall_p): Break out from ...\n+\t(delete_trivially_dead_insns): ... here; accept new argument\n+\tpreserve_basic_blocks; preserve basic blocks if set.\n+\n+\t* reg-stack.c (stack_regs_mentioned): Return 0 if\n+\tstack_regs_mentioned_data is not initialized.\n+\t(reg_to_stack): Make stack_regs_mentioned survive after the\n+\treg-stack is completted; do not call cleanup_cfg.\n+\t* toplev.c (rest_of_compilation): Do cleanup_cfg before bb-reorder;\n+\tmake cleanup_cfg after bb-reorder to output to debug file.\n+\n 2001-07-16  Richard Henderson  <rth@redhat.com>\n \n \t* regclass.c (init_reg_sets): Use only 32 bits per initializer"}, {"sha": "5b210fb981b7bd3f2bd3e3f3c041fb1c84196e5e", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -540,6 +540,8 @@ enum update_life_extent\n #define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n #define CLEANUP_POST_REGSTACK\t4\t/* We run after reg-stack and need\n \t\t\t\t\t   to care REG_DEAD notes.  */\n+#define CLEANUP_PRE_SIBCALL\t8\t/* Do not get confused by code hidden\n+\t\t\t\t\t   inside call_placeholders..  */\n /* Flags for loop discovery.  */\n \n #define LOOP_TREE\t\t1 \t/* Build loop hierarchy tree.  */"}, {"sha": "53995ba2e4bae4980bea4e5ff301c11e65f4a896", "filename": "gcc/config.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -1,4 +1,4 @@\n-/* config.in.  Generated automatically from configure.in by autoheader 2.13.  */\n+/* config.in.  Generated automatically from configure.in by autoheader.  */\n \n /* Define to empty if the keyword does not work.  */\n #undef const"}, {"sha": "70360d8699314ca7294fe3947067d8bfd20a020a", "filename": "gcc/cse.c", "status": "modified", "additions": 166, "deletions": 107, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -689,6 +689,9 @@ static struct cse_reg_info * get_cse_reg_info PARAMS ((unsigned int));\n static int check_dependence\tPARAMS ((rtx *, void *));\n \n static void flush_hash_table\tPARAMS ((void));\n+static bool insn_live_p\t\tPARAMS ((rtx, int *));\n+static bool set_live_p\t\tPARAMS ((rtx, int *));\n+static bool dead_libcall_p\tPARAMS ((rtx, int *));\n \f\n /* Dump the expressions in the equivalence class indicated by CLASSP.\n    This function is used only for debugging.  */\n@@ -7481,6 +7484,98 @@ count_reg_usage (x, counts, dest, incr)\n     }\n }\n \f\n+/* Return true if set is live.  */\n+static bool\n+set_live_p (set, counts)\n+     rtx set;\n+     int *counts;\n+{\n+#ifdef HAVE_cc0\n+  rtx tem;\n+#endif\n+\n+  if (set_noop_p (set))\n+    ;\n+\n+#ifdef HAVE_cc0\n+  else if (GET_CODE (SET_DEST (set)) == CC0\n+\t   && !side_effects_p (SET_SRC (set))\n+\t   && ((tem = next_nonnote_insn (insn)) == 0\n+\t       || !INSN_P (tem)\n+\t       || !reg_referenced_p (cc0_rtx, PATTERN (tem))))\n+    return false;\n+#endif\n+  else if (GET_CODE (SET_DEST (set)) != REG\n+\t   || REGNO (SET_DEST (set)) < FIRST_PSEUDO_REGISTER\n+\t   || counts[REGNO (SET_DEST (set))] != 0\n+\t   || side_effects_p (SET_SRC (set))\n+\t   /* An ADDRESSOF expression can turn into a use of the\n+\t      internal arg pointer, so always consider the\n+\t      internal arg pointer live.  If it is truly dead,\n+\t      flow will delete the initializing insn.  */\n+\t   || (SET_DEST (set) == current_function_internal_arg_pointer))\n+    return true;\n+  return false;\n+}\n+\n+/* Return true if insn is live.  */\n+\n+static bool\n+insn_live_p (insn, counts)\n+     rtx insn;\n+     int *counts;\n+{\n+  int i;\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    return set_live_p (PATTERN (insn), counts);\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+    for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+      {\n+\trtx elt = XVECEXP (PATTERN (insn), 0, i);\n+\n+\tif (GET_CODE (elt) == SET)\n+\t  {\n+\t    if (set_live_p (elt, counts))\n+\t      return true;\n+\t  }\n+\telse if (GET_CODE (elt) != CLOBBER && GET_CODE (elt) != USE)\n+\t  return true;\n+      }\n+  else\n+    return true;\n+}\n+\n+/* Return true if libcall is dead as a whole.  */\n+\n+static bool\n+dead_libcall_p (insn, counts)\n+     rtx insn;\n+     int *counts;\n+{\n+  rtx note;\n+  /* See if there's a REG_EQUAL note on this insn and try to\n+     replace the source with the REG_EQUAL expression.\n+\n+     We assume that insns with REG_RETVALs can only be reg->reg\n+     copies at this point.  */\n+  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+  if (note)\n+    {\n+      rtx set = single_set (insn);\n+      rtx new = simplify_rtx (XEXP (note, 0));\n+\n+      if (!new)\n+\tnew = XEXP (note, 0);\n+\n+      if (set && validate_change (insn, &SET_SRC (set), new, 0))\n+\t{\n+\t  remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Scan all the insns and delete any that are dead; i.e., they store a register\n    that is never used or they copy a register to itself.\n \n@@ -7490,17 +7585,16 @@ count_reg_usage (x, counts, dest, incr)\n    remaining passes of the compilation are also sped up.  */\n \n void\n-delete_trivially_dead_insns (insns, nreg)\n+delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n      rtx insns;\n      int nreg;\n+     int preserve_basic_blocks;\n {\n   int *counts;\n   rtx insn, prev;\n-#ifdef HAVE_cc0\n-  rtx tem;\n-#endif\n   int i;\n   int in_libcall = 0, dead_libcall = 0;\n+  basic_block bb;\n \n   /* First count the number of times each register is used.  */\n   counts = (int *) xcalloc (nreg, sizeof (int));\n@@ -7518,124 +7612,89 @@ delete_trivially_dead_insns (insns, nreg)\n   if (! INSN_P (insn))\n     insn = prev_real_insn (insn);\n \n-  for (; insn; insn = prev)\n-    {\n-      int live_insn = 0;\n-      rtx note;\n-\n-      prev = prev_real_insn (insn);\n+  if (!preserve_basic_blocks)\n+    for (; insn; insn = prev)\n+      {\n+\tint live_insn = 0;\n+\trtx note;\n \n-      /* Don't delete any insns that are part of a libcall block unless\n-\t we can delete the whole libcall block.\n+\tprev = prev_real_insn (insn);\n \n-\t Flow or loop might get confused if we did that.  Remember\n-\t that we are scanning backwards.  */\n-      if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t{\n-\t  in_libcall = 1;\n-\t  live_insn = 1;\n-\t  dead_libcall = 0;\n+\t/* Don't delete any insns that are part of a libcall block unless\n+\t   we can delete the whole libcall block.\n \n-\t  /* See if there's a REG_EQUAL note on this insn and try to\n-\t     replace the source with the REG_EQUAL expression.\n+\t   Flow or loop might get confused if we did that.  Remember\n+\t   that we are scanning backwards.  */\n+\tif (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t  {\n+\t    in_libcall = 1;\n+\t    live_insn = 1;\n+\t    dead_libcall = dead_libcall_p (insn, counts);\n+\t  }\n+\telse if (in_libcall)\n+\t  live_insn = ! dead_libcall;\n+\telse\n+\t  live_insn = insn_live_p (insn, counts);\n \n-\t     We assume that insns with REG_RETVALs can only be reg->reg\n-\t     copies at this point.  */\n-\t  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t  if (note)\n-\t    {\n-\t      rtx set = single_set (insn);\n-\t      rtx new = simplify_rtx (XEXP (note, 0));\n+\t/* If this is a dead insn, delete it and show registers in it aren't\n+\t   being used.  */\n \n-\t      if (!new)\n-\t\tnew = XEXP (note, 0);\n+\tif (! live_insn)\n+\t  {\n+\t    count_reg_usage (insn, counts, NULL_RTX, -1);\n+\t    delete_insn (insn);\n+\t  }\n \n-\t      if (set && validate_change (insn, &SET_SRC (set), new, 0))\n-\t\t{\n-\t\t  remove_note (insn,\n-\t\t\t       find_reg_note (insn, REG_RETVAL, NULL_RTX));\n-\t\t  dead_libcall = 1;\n-\t\t}\n-\t    }\n-\t}\n-      else if (in_libcall)\n-\tlive_insn = ! dead_libcall;\n-      else if (GET_CODE (PATTERN (insn)) == SET)\n+\tif (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n+\t  {\n+\t    in_libcall = 0;\n+\t    dead_libcall = 0;\n+\t  }\n+      }\n+  else\n+    for (i = 0; i < n_basic_blocks; i++)\n+      for (bb = BASIC_BLOCK (i), insn = bb->end; insn != bb->head; insn = prev)\n \t{\n-\t  if (set_noop_p (PATTERN (insn)))\n-\t    ;\n+\t  int live_insn = 0;\n+\t  rtx note;\n \n-#ifdef HAVE_cc0\n-\t  else if (GET_CODE (SET_DEST (PATTERN (insn))) == CC0\n-\t\t   && ! side_effects_p (SET_SRC (PATTERN (insn)))\n-\t\t   && ((tem = next_nonnote_insn (insn)) == 0\n-\t\t       || ! INSN_P (tem)\n-\t\t       || ! reg_referenced_p (cc0_rtx, PATTERN (tem))))\n-\t    ;\n-#endif\n-\t  else if (GET_CODE (SET_DEST (PATTERN (insn))) != REG\n-\t\t   || REGNO (SET_DEST (PATTERN (insn))) < FIRST_PSEUDO_REGISTER\n-\t\t   || counts[REGNO (SET_DEST (PATTERN (insn)))] != 0\n-\t\t   || side_effects_p (SET_SRC (PATTERN (insn)))\n-\t\t   /* An ADDRESSOF expression can turn into a use of the\n-\t\t      internal arg pointer, so always consider the\n-\t\t      internal arg pointer live.  If it is truly dead,\n-\t\t      flow will delete the initializing insn.  */\n-\t\t   || (SET_DEST (PATTERN (insn))\n-\t\t       == current_function_internal_arg_pointer))\n-\t    live_insn = 1;\n-\t}\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\tfor (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t  {\n-\t    rtx elt = XVECEXP (PATTERN (insn), 0, i);\n+\t  prev = PREV_INSN (insn);\n+\t  if (!INSN_P (insn))\n+\t    continue;\n \n-\t    if (GET_CODE (elt) == SET)\n-\t      {\n-\t\tif (set_noop_p (elt))\n-\t\t  ;\n+\t  /* Don't delete any insns that are part of a libcall block unless\n+\t     we can delete the whole libcall block.\n \n-#ifdef HAVE_cc0\n-\t\telse if (GET_CODE (SET_DEST (elt)) == CC0\n-\t\t\t && ! side_effects_p (SET_SRC (elt))\n-\t\t\t && ((tem = next_nonnote_insn (insn)) == 0\n-\t\t\t     || ! INSN_P (tem)\n-\t\t\t     || ! reg_referenced_p (cc0_rtx, PATTERN (tem))))\n-\t\t  ;\n-#endif\n-\t\telse if (GET_CODE (SET_DEST (elt)) != REG\n-\t\t\t || REGNO (SET_DEST (elt)) < FIRST_PSEUDO_REGISTER\n-\t\t\t || counts[REGNO (SET_DEST (elt))] != 0\n-\t\t\t || side_effects_p (SET_SRC (elt))\n-\t\t\t /* An ADDRESSOF expression can turn into a use of the\n-\t\t\t    internal arg pointer, so always consider the\n-\t\t\t    internal arg pointer live.  If it is truly dead,\n-\t\t\t    flow will delete the initializing insn.  */\n-\t\t\t || (SET_DEST (elt)\n-\t\t\t     == current_function_internal_arg_pointer))\n-\t\t  live_insn = 1;\n-\t      }\n-\t    else if (GET_CODE (elt) != CLOBBER && GET_CODE (elt) != USE)\n+\t     Flow or loop might get confused if we did that.  Remember\n+\t     that we are scanning backwards.  */\n+\t  if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\t    {\n+\t      in_libcall = 1;\n \t      live_insn = 1;\n-\t  }\n-      else\n-\tlive_insn = 1;\n+\t      dead_libcall = dead_libcall_p (insn, counts);\n+\t    }\n+\t  else if (in_libcall)\n+\t    live_insn = ! dead_libcall;\n+\t  else\n+\t    live_insn = insn_live_p (insn, counts);\n \n-      /* If this is a dead insn, delete it and show registers in it aren't\n-\t being used.  */\n+\t  /* If this is a dead insn, delete it and show registers in it aren't\n+\t     being used.  */\n \n-      if (! live_insn)\n-\t{\n-\t  count_reg_usage (insn, counts, NULL_RTX, -1);\n-\t  delete_insn (insn);\n-\t}\n+\t  if (! live_insn)\n+\t    {\n+\t      count_reg_usage (insn, counts, NULL_RTX, -1);\n+\t      if (insn == bb->end)\n+\t\tbb->end = PREV_INSN (insn);\n+\t      flow_delete_insn (insn);\n+\t    }\n \n-      if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t{\n-\t  in_libcall = 0;\n-\t  dead_libcall = 0;\n+\t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n+\t    {\n+\t      in_libcall = 0;\n+\t      dead_libcall = 0;\n+\t    }\n \t}\n-    }\n \n   /* Clean up.  */\n   free (counts);"}, {"sha": "da50101264877560297f06b5e5cfcb5802fd8c7e", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -2347,7 +2347,7 @@ finish_eh_generation ()\n      connect many of the handlers, and then type information will not\n      be effective.  Still, this is a win over previous implementations.  */\n \n-  jump_optimize_minimal (get_insns ());\n+  rebuild_jump_labels (get_insns ());\n   find_basic_blocks (get_insns (), max_reg_num (), 0);\n   cleanup_cfg (0);\n \n@@ -2370,7 +2370,7 @@ finish_eh_generation ()\n \n   /* We've totally changed the CFG.  Start over.  */\n   find_exception_handler_labels ();\n-  jump_optimize_minimal (get_insns ());\n+  rebuild_jump_labels (get_insns ());\n   find_basic_blocks (get_insns (), max_reg_num (), 0);\n   cleanup_cfg (0);\n }"}, {"sha": "a771ab4c3d162de318824263b896b44c8fc7e1a4", "filename": "gcc/flow.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -135,6 +135,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"expr.h\"\n #include \"ssa.h\"\n+#include \"timevar.h\"\n \n #include \"obstack.h\"\n #include \"splay-tree.h\"\n@@ -499,6 +500,7 @@ find_basic_blocks (f, nregs, file)\n      FILE *file ATTRIBUTE_UNUSED;\n {\n   int max_uid;\n+  timevar_push (TV_CFG);\n \n   /* Flush out existing data.  */\n   if (basic_block_info != NULL)\n@@ -556,6 +558,7 @@ find_basic_blocks (f, nregs, file)\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n+  timevar_pop (TV_CFG);\n }\n \n void\n@@ -1002,6 +1005,7 @@ void\n cleanup_cfg (mode)\n      int mode;\n {\n+  timevar_push (TV_CLEANUP_CFG);\n   delete_unreachable_blocks ();\n   if (try_optimize_cfg (mode))\n     delete_unreachable_blocks ();\n@@ -1010,6 +1014,7 @@ cleanup_cfg (mode)\n   /* Kill the data we won't maintain.  */\n   free_EXPR_LIST_list (&label_value_list);\n   free_EXPR_LIST_list (&tail_recursion_label_list);\n+  timevar_pop (TV_CLEANUP_CFG);\n }\n \n /* Create a new basic block consisting of the instructions between\n@@ -2960,6 +2965,14 @@ merge_blocks (e, b, c, mode)\n       int c_has_outgoing_fallthru;\n       int b_has_incoming_fallthru;\n \n+      /* Avoid overactive code motion, as the forwarder blocks should eb\n+         eliminated by the edge redirection instead. Only exception is the\n+\t case b is an forwarder block and c has no fallthru edge, but no\n+\t optimizers should be confused by this extra jump and we are about\n+\t to kill the jump in bb_reorder pass instead.  */\n+      if (forwarder_block_p (b) || forwarder_block_p (c))\n+\treturn 0;\n+\n       /* We must make sure to not munge nesting of exception regions,\n \t lexical blocks, and loop notes.\n \n@@ -3688,6 +3701,26 @@ try_optimize_cfg (mode)\n \t      b = c;\n \t    }\n \n+\t  /* Remove code labels no longer used.  \n+\t     Don't do the optimization before sibling calls are discovered,\n+\t     as some branches may be hidden inside CALL_PLACEHOLDERs.  */\n+\t  if (!(mode & CLEANUP_PRE_SIBCALL)\n+\t      && b->pred->pred_next == NULL\n+\t      && (b->pred->flags & EDGE_FALLTHRU)\n+\t      && GET_CODE (b->head) == CODE_LABEL\n+\t      /* If previous block does end with condjump jumping to next BB,\n+\t         we can't delete the label.  */\n+\t      && (b->pred->src == ENTRY_BLOCK_PTR\n+\t\t  || !reg_mentioned_p (b->head, b->pred->src->end)))\n+\t    {\n+\t      rtx label = b->head;\n+\t      b->head = NEXT_INSN (b->head);\n+\t      flow_delete_insn_chain (label, label);\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n+\t\t\t b->index);\n+\t    }\n+\n \t  /* A loop because chains of blocks might be combineable.  */\n \t  while ((s = b->succ) != NULL\n \t\t && s->succ_next == NULL"}, {"sha": "a642dcc1e08c98823ae97e11fe09016595a7f6e6", "filename": "gcc/integrate.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -427,6 +427,13 @@ save_for_inline (fndecl)\n \n   argvec = initialize_for_inline (fndecl);\n \n+  /* Delete basic block notes created by early run of find_basic_block.\n+     The notes would be later used by find_basic_blocks to reuse the memory\n+     for basic_block structures on already freed obstack.  */\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK)\n+      delete_insn (insn);\n+\n   /* If there are insns that copy parms from the stack into pseudo registers,\n      those insns are not copied.  `expand_inline_function' must\n      emit the correct code to handle such things.  */\n@@ -1552,17 +1559,11 @@ copy_insn_list (insns, map, static_chain_value)\n \t     discarded because it is important to have only one of\n \t     each in the current function.\n \n-\t     NOTE_INSN_DELETED notes aren't useful.\n-\n-\t     NOTE_INSN_BASIC_BLOCK is discarded because the saved bb\n-\t     pointer (which will soon be dangling) confuses flow's\n-\t     attempts to preserve bb structures during the compilation\n-\t     of a function.  */\n+\t     NOTE_INSN_DELETED notes aren't useful.  */\n \n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_END\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_FUNCTION_BEG\n-\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n-\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED)\n \t    {\n \t      copy = emit_note (NOTE_SOURCE_FILE (insn),\n \t\t\t\tNOTE_LINE_NUMBER (insn));"}, {"sha": "19f666087bdcf5653db5e7f4ed764dd1ad4c59da", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -303,7 +303,7 @@ stack_regs_mentioned (insn)\n   unsigned int uid, max;\n   int test;\n \n-  if (! INSN_P (insn))\n+  if (! INSN_P (insn) || !stack_regs_mentioned_data)\n     return 0;\n \n   uid = INSN_UID (insn);\n@@ -419,6 +419,13 @@ reg_to_stack (first, file)\n   int max_uid;\n   block_info bi;\n \n+  /* Clean up previous run.  */\n+  if (stack_regs_mentioned_data)\n+    {\n+      VARRAY_FREE (stack_regs_mentioned_data);\n+      stack_regs_mentioned_data = 0;\n+    }\n+\n   if (!optimize)\n     split_all_insns (0);\n \n@@ -479,11 +486,8 @@ reg_to_stack (first, file)\n   VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n \t\t    \"stack_regs_mentioned cache\");\n \n-  if (convert_regs (file) && optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_CROSSJUMP | CLEANUP_POST_REGSTACK);\n+  convert_regs (file);\n \n-  /* Clean up.  */\n-  VARRAY_FREE (stack_regs_mentioned_data);\n   free (bi);\n }\n \f"}, {"sha": "0401f8deea87706e1aa98242a9ffc30657fa8322", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -1689,7 +1689,7 @@ struct cse_basic_block_data;\n \n extern int rtx_cost\t\t\tPARAMS ((rtx, enum rtx_code));\n extern int address_cost\t\t\tPARAMS ((rtx, enum machine_mode));\n-extern void delete_trivially_dead_insns\tPARAMS ((rtx, int));\n+extern void delete_trivially_dead_insns\tPARAMS ((rtx, int, int));\n #ifdef BUFSIZ\n extern int cse_main\t\t\tPARAMS ((rtx, int, int, FILE *));\n #endif"}, {"sha": "1203e68423499a7f60e2eacd58b596a25bbfea62", "filename": "gcc/sibcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -565,11 +565,11 @@ optimize_sibling_and_tail_recursive_calls ()\n      ahead and find all the EH labels.  */\n   find_exception_handler_labels ();\n \n-  jump_optimize_minimal (insns);\n+  rebuild_jump_labels (insns);\n   /* We need cfg information to determine which blocks are succeeded\n      only by the epilogue.  */\n   find_basic_blocks (insns, max_reg_num (), 0);\n-  cleanup_cfg (0);\n+  cleanup_cfg (CLEANUP_PRE_SIBCALL);\n \n   /* If there are no basic blocks, then there is nothing to do.  */\n   if (n_basic_blocks == 0)"}, {"sha": "1ad57a1c504d7aa57069e4deed7c39bf6233be2d", "filename": "gcc/timevar.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -39,6 +39,10 @@ DEFTIMEVAR (TV_GC                    , \"garbage collection\")\n /* Time spent generating dump files.  */\n DEFTIMEVAR (TV_DUMP                  , \"dump files\")\n \n+/* Time spent by constructing CFG.  */\n+DEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n+/* Time spent by cleaning up CFG.  */\n+DEFTIMEVAR (TV_CLEANUP_CFG           , \"cfg cleanup\")\n /* Timing in various stages of the compiler.  */\n DEFTIMEVAR (TV_CPP\t\t     , \"preprocessing\")\n DEFTIMEVAR (TV_LEX\t\t     , \"lexical analysis\")"}, {"sha": "e357d62b6d386be3eaa0301478872cedfcf118f1", "filename": "gcc/toplev.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4793dca1588681eb583ccfd7cd179216c2d44d7e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4793dca1588681eb583ccfd7cd179216c2d44d7e", "patch": "@@ -2827,17 +2827,18 @@ rest_of_compilation (decl)\n       if (DECL_DEFER_OUTPUT (decl))\n \t{\n \t  /* If -Wreturn-type, we have to do a bit of compilation.  We just\n-\t     want to call jump_optimize to figure out whether or not we can\n+\t     want to call cleanup the cfg to figure out whether or not we can\n \t     fall off the end of the function; we do the minimum amount of\n-\t     work necessary to make that safe.  And, we set optimize to zero\n-\t     to keep jump_optimize from working too hard.  */\n+\t     work necessary to make that safe.  */\n \t  if (warn_return_type)\n \t    {\n \t      int saved_optimize = optimize;\n \n \t      optimize = 0;\n+\t      rebuild_jump_labels (insns);\n \t      find_exception_handler_labels ();\n-\t      jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t      cleanup_cfg (CLEANUP_PRE_SIBCALL);\n \t      optimize = saved_optimize;\n \t    }\n \n@@ -3092,7 +3093,7 @@ rest_of_compilation (decl)\n \n       /* Run this after jump optmizations remove all the unreachable code\n \t so that unreachable code will not keep values live.  */\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n+      delete_trivially_dead_insns (insns, max_reg_num (), 0);\n \n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks)\n@@ -3195,7 +3196,7 @@ rest_of_compilation (decl)\n \t     trivially dead.  We delete those instructions now in the\n \t     hope that doing so will make the heuristics in loop work\n \t     better and possibly speed up compilation.  */\n-\t  delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n \n \t  /* The regscan pass is currently necessary as the alias\n \t\t  analysis code depends on this information.  */\n@@ -3228,7 +3229,7 @@ rest_of_compilation (decl)\n \t     trivially dead.  We delete those instructions now in the\n \t     hope that doing so will make the heuristics in jump work\n \t     better and possibly speed up compilation.  */\n-\t  delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n \n \t  reg_scan (insns, max_reg_num (), 0);\n \t  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n@@ -3672,15 +3673,22 @@ rest_of_compilation (decl)\n \n   ggc_collect ();\n #endif\n-  if (optimize > 0 && flag_reorder_blocks)\n+  if (optimize > 0)\n     {\n       timevar_push (TV_REORDER_BLOCKS);\n       open_dump_file (DFI_bbro, decl);\n \n-      reorder_basic_blocks ();\n+      /* Last attempt to optimize CFG, as life analyzis possibly removed\n+\t some instructions.  */\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n+\t\t   | CLEANUP_CROSSJUMP);\n+      if (flag_reorder_blocks)\n+\t{\n+\t  reorder_basic_blocks ();\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n+\t}\n \n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n       timevar_pop (TV_REORDER_BLOCKS);\n     }\n "}]}