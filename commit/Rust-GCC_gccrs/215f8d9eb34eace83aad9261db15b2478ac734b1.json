{"sha": "215f8d9eb34eace83aad9261db15b2478ac734b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE1ZjhkOWViMzRlYWNlODNhYWQ5MjYxZGIxNWIyNDc4YWM3MzRiMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-02-16T20:56:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-02-16T20:56:55Z"}, "message": "re PR tree-optimization/64823 (false \"may be used uninitialized\", missed jump threading)\n\n\tPR tree-optimization/64823\n\t* tree-vrp.c (identify_jump_threads): Handle blocks with no real\n\tstatements.\n\t* tree-ssa-threadedge.c (potentially_threadable_block): Allow\n\tthreading through blocks with PHIs, but no statements.\n\t(thread_through_normal_block): Distinguish between blocks where\n\twe did not process all the statements and blocks with no statements.\n\n\tPR tree-optimization/64823\n\t* gcc.dg/uninit-20.c: New test.\n\nFrom-SVN: r220743", "tree": {"sha": "a6439f13a3fb8cf10f44d005b6dd6a2fd8999477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6439f13a3fb8cf10f44d005b6dd6a2fd8999477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/215f8d9eb34eace83aad9261db15b2478ac734b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/215f8d9eb34eace83aad9261db15b2478ac734b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/215f8d9eb34eace83aad9261db15b2478ac734b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/215f8d9eb34eace83aad9261db15b2478ac734b1/comments", "author": null, "committer": null, "parents": [{"sha": "ed89033d7c15db7bbc3c6c6dfb9495ac263b3a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed89033d7c15db7bbc3c6c6dfb9495ac263b3a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed89033d7c15db7bbc3c6c6dfb9495ac263b3a73"}], "stats": {"total": 85, "additions": 75, "deletions": 10}, "files": [{"sha": "bbeee3fdebcdecaa9b0cd29ff94ab2daf0825068", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=215f8d9eb34eace83aad9261db15b2478ac734b1", "patch": "@@ -1,3 +1,13 @@\n+2015-02-16  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/64823\n+\t* tree-vrp.c (identify_jump_threads): Handle blocks with no real\n+\tstatements.\n+\t* tree-ssa-threadedge.c (potentially_threadable_block): Allow\n+\tthreading through blocks with PHIs, but no statements.\n+\t(thread_through_normal_block): Distinguish between blocks where\n+\twe did not process all the statements and blocks with no statements.\n+\n 2015-02-16  Jakub Jelinek  <jakub@redhat.com>\n \t    James Greenhalgh  <james.greenhalgh@arm.com>\n "}, {"sha": "06ed820e235362448c3b6df2c70d52f338de7caf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=215f8d9eb34eace83aad9261db15b2478ac734b1", "patch": "@@ -1,3 +1,8 @@\n+2015-02-16  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/64823\n+\t* gcc.dg/uninit-20.c: New test.\n+\n 2015-02-16  Jakub Jelinek  <jakub@redhat.com>\n \t    James Greenhalgh  <james.greenhalgh@arm.com>\n "}, {"sha": "12001aee9937e4ac4ebce75425ada030d6241575", "filename": "gcc/testsuite/gcc.dg/uninit-20.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-20.c?ref=215f8d9eb34eace83aad9261db15b2478ac734b1", "patch": "@@ -0,0 +1,18 @@\n+/* Spurious uninitialized variable warnings, from gdb */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wuninitialized\" } */\n+struct os { struct o *o; };\n+struct o { struct o *next; struct os *se; };\n+void f(struct o *o){\n+  struct os *s;\n+  if(o) s = o->se;\n+  while(o && s == o->se){\n+    s++; // here `o' is non-zero and thus s is initialized\n+    s == o->se  // `?' is essential, `if' does not trigger the warning\n+      ? (o = o->next, o ? s = o->se : 0)\n+      : 0;\n+  }\n+}\n+\n+\n+"}, {"sha": "7187d065e91479aef5a1cbf7175ef76a4a4aa73a", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=215f8d9eb34eace83aad9261db15b2478ac734b1", "patch": "@@ -110,6 +110,15 @@ potentially_threadable_block (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n+  /* Special case.  We can get blocks that are forwarders, but are\n+     not optimized away because they forward from outside a loop\n+     to the loop header.   We want to thread through them as we can\n+     sometimes thread to the loop exit, which is obviously profitable. \n+     the interesting case here is when the block has PHIs.  */\n+  if (gsi_end_p (gsi_start_nondebug_bb (bb))\n+      && !gsi_end_p (gsi_start_phis (bb)))\n+    return true;\n+  \n   /* If BB has a single successor or a single predecessor, then\n      there is no threading opportunity.  */\n   if (single_succ_p (bb) || single_pred_p (bb))\n@@ -1281,16 +1290,32 @@ thread_through_normal_block (edge e,\n     = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify,\n \t\t\t\t\t\t\t*backedge_seen_p);\n \n-  /* If we didn't look at all the statements, the most likely reason is\n-     there were too many and thus duplicating this block is not profitable.\n+  /* There's two reasons STMT might be null, and distinguishing\n+     between them is important.\n \n-     Also note if we do not look at all the statements, then we may not\n-     have invalidated equivalences that are no longer valid if we threaded\n-     around a loop.  Thus we must signal to our caller that this block\n-     is not suitable for use as a joiner in a threading path.  */\n+     First the block may not have had any statements.  For example, it\n+     might have some PHIs and unconditionally transfer control elsewhere.\n+     Such blocks are suitable for jump threading, particularly as a\n+     joiner block.\n+\n+     The second reason would be if we did not process all the statements\n+     in the block (because there were too many to make duplicating the\n+     block profitable.   If we did not look at all the statements, then\n+     we may not have invalidated everything needing invalidation.  Thus\n+     we must signal to our caller that this block is not suitable for\n+     use as a joiner in a threading path.  */\n   if (!stmt)\n-    return -1;\n+    {\n+      /* First case.  The statement simply doesn't have any instructions, but\n+\t does have PHIs.  */\n+      if (gsi_end_p (gsi_start_nondebug_bb (e->dest))\n+\t  && !gsi_end_p (gsi_start_phis (e->dest)))\n+\treturn 0;\n \n+      /* Second case.  */\n+      return -1;\n+    }\n+  \n   /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n      will be taken.  */\n   if (gimple_code (stmt) == GIMPLE_COND"}, {"sha": "d996bcccda473103cb8df596df1f021a24afacbc", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/215f8d9eb34eace83aad9261db15b2478ac734b1/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=215f8d9eb34eace83aad9261db15b2478ac734b1", "patch": "@@ -10176,13 +10176,20 @@ identify_jump_threads (void)\n       /* We only care about blocks ending in a COND_EXPR.  While there\n \t may be some value in handling SWITCH_EXPR here, I doubt it's\n \t terribly important.  */\n-      last = gsi_stmt (gsi_last_bb (bb));\n+      last = gsi_stmt (gsi_last_nondebug_bb (bb));\n \n       /* We're basically looking for a switch or any kind of conditional with\n \t integral or pointer type arguments.  Note the type of the second\n \t argument will be the same as the first argument, so no need to\n-\t check it explicitly.  */\n-      if (gimple_code (last) == GIMPLE_SWITCH\n+\t check it explicitly. \n+\n+\t We also handle the case where there are no statements in the\n+\t block.  This come up with forwarder blocks that are not\n+\t optimized away because they lead to a loop header.  But we do\n+\t want to thread through them as we can sometimes thread to the\n+\t loop exit which is obviously profitable.  */\n+      if (!last\n+\t  || gimple_code (last) == GIMPLE_SWITCH\n \t  || (gimple_code (last) == GIMPLE_COND\n       \t      && TREE_CODE (gimple_cond_lhs (last)) == SSA_NAME\n \t      && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (last)))"}]}