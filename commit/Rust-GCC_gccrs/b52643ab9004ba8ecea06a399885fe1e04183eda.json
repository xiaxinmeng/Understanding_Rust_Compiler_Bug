{"sha": "b52643ab9004ba8ecea06a399885fe1e04183eda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyNjQzYWI5MDA0YmE4ZWNlYTA2YTM5OTg4NWZlMWUwNDE4M2VkYQ==", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-07-14T17:31:35Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-07-14T17:31:35Z"}, "message": "libgomp: Fix hang when profiling OpenACC programs with CUDA 9.0 nvprof\n\nThe version of nvprof in CUDA 9.0 causes a hang when used to profile an\nOpenACC program.  This is because it calls acc_get_device_type from\na callback called during device initialization, which then attempts\nto acquire acc_device_lock while it is already taken, resulting in\ndeadlock.  This works around the issue by returning acc_device_none\nfrom acc_get_device_type without attempting to acquire the lock when\ninitialization has not completed yet.\n\n2020-07-14  Tom de Vries  <tom@codesourcery.com>\n\t    Cesar Philippidis  <cesar@codesourcery.com>\n\t    Thomas Schwinge  <thomas@codesourcery.com>\n\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n\n\tlibgomp/\n\t* oacc-init.c (acc_init_state_lock, acc_init_state, acc_init_thread):\n\tNew variable.\n\t(acc_init_1): Set acc_init_thread to pthread_self ().  Set\n\tacc_init_state to initializing at the start, and to initialized at the\n\tend.\n\t(self_initializing_p): New function.\n\t(acc_get_device_type): Return acc_device_none if called by thread that\n\tis currently executing acc_init_1.\n\t* libgomp.texi (acc_get_device_type): Update documentation.\n\t(Implementation Status and Implementation-Defined Behavior): Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-init-2.c: New.", "tree": {"sha": "fe2f328c0be9fc9ee8eba66196c8202f8132102c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe2f328c0be9fc9ee8eba66196c8202f8132102c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52643ab9004ba8ecea06a399885fe1e04183eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52643ab9004ba8ecea06a399885fe1e04183eda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52643ab9004ba8ecea06a399885fe1e04183eda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52643ab9004ba8ecea06a399885fe1e04183eda/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bae45b8be57b2a2c22bf45f3eeb1118c328ad028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae45b8be57b2a2c22bf45f3eeb1118c328ad028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae45b8be57b2a2c22bf45f3eeb1118c328ad028"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "5331230c20740e8a612a6b8c9a6fafdd20a1af2a", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52643ab9004ba8ecea06a399885fe1e04183eda/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52643ab9004ba8ecea06a399885fe1e04183eda/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=b52643ab9004ba8ecea06a399885fe1e04183eda", "patch": "@@ -1967,6 +1967,12 @@ in @var{devicetype}, to use when executing a parallel or kernels region.\n This function returns what device type will be used when executing a\n parallel or kernels region.\n \n+This function returns @code{acc_device_none} if\n+@code{acc_get_device_type} is called from\n+@code{acc_ev_device_init_start}, @code{acc_ev_device_init_end}\n+callbacks of the OpenACC Profiling Interface (@ref{OpenACC Profiling\n+Interface}), that is, if the device is currently being initialized.\n+\n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n @item @emph{Prototype}: @tab @code{acc_device_t acc_get_device_type(void);}\n@@ -3382,6 +3388,11 @@ every event that has been registered.\n \n We're not yet accounting for the fact that @cite{OpenACC events may\n occur during event processing}.\n+We just handle one case specially, as required by CUDA 9.0\n+@command{nvprof}, that @code{acc_get_device_type}\n+(@ref{acc_get_device_type})) may be called from\n+@code{acc_ev_device_init_start}, @code{acc_ev_device_init_end}\n+callbacks.\n \n We're not yet implementing initialization via a\n @code{acc_register_library} function that is either statically linked"}, {"sha": "1e7f9345c682b30f1e342f4435d24f013f417e6e", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52643ab9004ba8ecea06a399885fe1e04183eda/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52643ab9004ba8ecea06a399885fe1e04183eda/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=b52643ab9004ba8ecea06a399885fe1e04183eda", "patch": "@@ -40,6 +40,11 @@\n \n static gomp_mutex_t acc_device_lock;\n \n+static gomp_mutex_t acc_init_state_lock;\n+static enum { uninitialized, initializing, initialized } acc_init_state\n+  = uninitialized;\n+static pthread_t acc_init_thread;\n+\n /* A cached version of the dispatcher for the global \"current\" accelerator type,\n    e.g. used as the default when creating new host threads.  This is the\n    device-type equivalent of goacc_device_num (which specifies which device to\n@@ -228,6 +233,11 @@ acc_dev_num_out_of_range (acc_device_t d, int ord, int ndevs)\n static struct gomp_device_descr *\n acc_init_1 (acc_device_t d, acc_construct_t parent_construct, int implicit)\n {\n+  gomp_mutex_lock (&acc_init_state_lock);\n+  acc_init_state = initializing;\n+  acc_init_thread = pthread_self ();\n+  gomp_mutex_unlock (&acc_init_state_lock);\n+\n   bool check_not_nested_p;\n   if (implicit)\n     {\n@@ -317,6 +327,14 @@ acc_init_1 (acc_device_t d, acc_construct_t parent_construct, int implicit)\n \t\t\t\t&api_info);\n     }\n \n+  /* We're setting 'initialized' *after* 'goacc_profiling_dispatch', so that a\n+     nested 'acc_get_device_type' called from a profiling callback still sees\n+     'initializing', so that we don't deadlock when it then again tries to lock\n+     'goacc_prof_lock'.  See also the discussion in 'acc_get_device_type'.  */\n+  gomp_mutex_lock (&acc_init_state_lock);\n+  acc_init_state = initialized;\n+  gomp_mutex_unlock (&acc_init_state_lock);\n+\n   return base_dev;\n }\n \n@@ -643,6 +661,17 @@ acc_set_device_type (acc_device_t d)\n \n ialias (acc_set_device_type)\n \n+static bool\n+self_initializing_p (void)\n+{\n+  bool res;\n+  gomp_mutex_lock (&acc_init_state_lock);\n+  res = (acc_init_state == initializing\n+\t && pthread_equal (acc_init_thread, pthread_self ()));\n+  gomp_mutex_unlock (&acc_init_state_lock);\n+  return res;\n+}\n+\n acc_device_t\n acc_get_device_type (void)\n {\n@@ -652,6 +681,15 @@ acc_get_device_type (void)\n \n   if (thr && thr->base_dev)\n     res = acc_device_type (thr->base_dev->type);\n+  else if (self_initializing_p ())\n+    /* The Cuda libaccinj64.so version 9.0+ calls acc_get_device_type during the\n+       acc_ev_device_init_start event callback, which is dispatched during\n+       acc_init_1.  Trying to lock acc_device_lock during such a call (as we do\n+       in the else clause below), will result in deadlock, since the lock has\n+       already been taken by the acc_init_1 caller.  We work around this problem\n+       by using the acc_get_device_type property \"If the device type has not yet\n+       been selected, the value acc_device_none may be returned\".  */\n+    ;\n   else\n     {\n       acc_prof_info prof_info;"}, {"sha": "b4e9f188aa6e97beb37508e28d8a45415004ccbe", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-init-2.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52643ab9004ba8ecea06a399885fe1e04183eda/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52643ab9004ba8ecea06a399885fe1e04183eda/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-init-2.c?ref=b52643ab9004ba8ecea06a399885fe1e04183eda", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run } */\n+/* { dg-timeout 10 } */\n+\n+/* Test the calling of 'acc_get_device_type' from within\n+   'cb_device_init_start' and 'cb_device_init_end' callbacks.  This occurs\n+   when the CUDA 9.0 'nvprof' tool is used, and previously deadlocked.  */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <acc_prof.h>\n+\n+static acc_prof_reg reg;\n+static acc_prof_reg unreg;\n+static acc_prof_lookup_func lookup;\n+\n+void acc_register_library (acc_prof_reg reg_, acc_prof_reg unreg_, acc_prof_lookup_func lookup_)\n+{\n+  reg = reg_;\n+  unreg = unreg_;\n+  lookup = lookup_;\n+}\n+\n+static bool expect_cb_device_init_start;\n+static bool expect_cb_device_init_end;\n+\n+static void cb_device_init_start (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (expect_cb_device_init_start);\n+  expect_cb_device_init_start = false;\n+\n+  acc_device_t acc_device_type;\n+  acc_device_type = acc_get_device_type ();\n+  assert (acc_device_type == acc_device_none);\n+\n+  expect_cb_device_init_end = true;\n+}\n+\n+static void cb_device_init_end (acc_prof_info *prof_info, acc_event_info *event_info, acc_api_info *api_info)\n+{\n+  assert (expect_cb_device_init_end);\n+  expect_cb_device_init_end = false;\n+\n+  acc_device_t acc_device_type;\n+  acc_device_type = acc_get_device_type ();\n+  assert (acc_device_type == acc_device_none);\n+}\n+\n+int main(void)\n+{\n+  acc_register_library (acc_prof_register, acc_prof_unregister, acc_prof_lookup);\n+\n+  reg (acc_ev_device_init_start, cb_device_init_start, acc_reg);\n+  reg (acc_ev_device_init_end, cb_device_init_end, acc_reg);\n+\n+  expect_cb_device_init_start = true;\n+  expect_cb_device_init_end = false;\n+  acc_init (acc_device_host);\n+  assert (!expect_cb_device_init_start);\n+  assert (!expect_cb_device_init_end);\n+  {\n+    acc_device_t acc_device_type;\n+    acc_device_type = acc_get_device_type ();\n+    assert (acc_device_type == acc_device_host);\n+  }\n+  acc_shutdown (acc_device_host);\n+\n+  expect_cb_device_init_start = true;\n+  expect_cb_device_init_end = false;\n+  acc_init (acc_device_default);\n+  assert (!expect_cb_device_init_start);\n+  assert (!expect_cb_device_init_end);\n+  {\n+    acc_device_t acc_device_type;\n+    acc_device_type = acc_get_device_type ();\n+    assert (acc_device_type != acc_device_none);\n+  }\n+  acc_shutdown (acc_device_default);\n+\n+  return 0;\n+}"}]}