{"sha": "4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQxNDI5YjJkZDNmYWZkYjI0ZjljZDMyNGNmZDA2M2IxM2IyNzVkOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:45:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:45:27Z"}, "message": "[multiple changes]\n\n2014-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb, gnat1drv.adb, sem_ch13.adb: Minor reformatting and\n\tcode clean up.\n\n2014-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_res.adb (Is_OK_Volatile_Context): Allow\n\ta volatile object reference to appear as the expression of a\n\ttype conversion.\n\nFrom-SVN: r216091", "tree": {"sha": "cec57d4cae91acb9b83d5ed5f8a252fe8a2e4216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cec57d4cae91acb9b83d5ed5f8a252fe8a2e4216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/comments", "author": null, "committer": null, "parents": [{"sha": "c9f95e4c252a3e5528c4da53b183c78b66258566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f95e4c252a3e5528c4da53b183c78b66258566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f95e4c252a3e5528c4da53b183c78b66258566"}], "stats": {"total": 728, "additions": 380, "deletions": 348}, "files": [{"sha": "f43c709672d968045b27ef06cc09546f9b77c022", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "patch": "@@ -1,3 +1,14 @@\n+2014-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb, gnat1drv.adb, sem_ch13.adb: Minor reformatting and\n+\tcode clean up.\n+\n+2014-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_res.adb (Is_OK_Volatile_Context): Allow\n+\ta volatile object reference to appear as the expression of a\n+\ttype conversion.\n+\n 2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Analyze_Aspect_Specifications, Library_Unit_Aspects):"}, {"sha": "3ae0f50516d84380cfcc1381f947167b2b703c86", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 347, "deletions": 345, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "patch": "@@ -1857,6 +1857,13 @@ package body Freeze is\n       --  Create Freeze_Generic_Entity nodes for types declared in a generic\n       --  package. Recurse on inner generic packages.\n \n+      function Freeze_Profile (E : Entity_Id) return Boolean;\n+      --  Freeze formals and return type of subprogram.\n+      --  If some type in the profile is a limited view, freezing of the entity\n+      --  will take place elsewhere, and the function returns False.\n+      --  This routine will be modified if and when we can implement AI05-019\n+      --  efficiently.\n+\n       procedure Freeze_Record_Type (Rec : Entity_Id);\n       --  Freeze record type, including freezing component types, and freezing\n       --  primitive operations if this is a tagged type.\n@@ -2681,6 +2688,341 @@ package body Freeze is\n          return Flist;\n       end Freeze_Generic_Entities;\n \n+      --------------------\n+      -- Freeze_Profile --\n+      --------------------\n+\n+      function Freeze_Profile (E : Entity_Id) return Boolean is\n+         F_Type    : Entity_Id;\n+         R_Type    : Entity_Id;\n+         Warn_Node : Node_Id;\n+\n+      begin\n+         --  Loop through formals\n+\n+         Formal := First_Formal (E);\n+         while Present (Formal) loop\n+            F_Type := Etype (Formal);\n+\n+            --  AI05-0151: incomplete types can appear in a profile.\n+            --  By the time the entity is frozen, the full view must\n+            --  be available, unless it is a limited view.\n+\n+            if Is_Incomplete_Type (F_Type)\n+              and then Present (Full_View (F_Type))\n+              and then not From_Limited_With (F_Type)\n+            then\n+               F_Type := Full_View (F_Type);\n+               Set_Etype (Formal, F_Type);\n+            end if;\n+\n+            Freeze_And_Append (F_Type, N, Result);\n+\n+            if Is_Private_Type (F_Type)\n+              and then Is_Private_Type (Base_Type (F_Type))\n+              and then No (Full_View (Base_Type (F_Type)))\n+              and then not Is_Generic_Type (F_Type)\n+              and then not Is_Derived_Type (F_Type)\n+            then\n+               --  If the type of a formal is incomplete, subprogram\n+               --  is being frozen prematurely. Within an instance\n+               --  (but not within a wrapper package) this is an\n+               --  artifact of our need to regard the end of an\n+               --  instantiation as a freeze point. Otherwise it is\n+               --  a definite error.\n+\n+               if In_Instance then\n+                  Set_Is_Frozen (E, False);\n+                  Result := No_List;\n+                  return False;\n+\n+               elsif not After_Last_Declaration\n+                 and then not Freezing_Library_Level_Tagged_Type\n+               then\n+                  Error_Msg_Node_1 := F_Type;\n+                  Error_Msg\n+                    (\"type& must be fully defined before this point\",\n+                      Loc);\n+               end if;\n+            end if;\n+\n+            --  Check suspicious parameter for C function. These tests\n+            --  apply only to exported/imported subprograms.\n+\n+            if Warn_On_Export_Import\n+              and then Comes_From_Source (E)\n+              and then (Convention (E) = Convention_C\n+                          or else\n+                        Convention (E) = Convention_CPP)\n+              and then (Is_Imported (E) or else Is_Exported (E))\n+              and then Convention (E) /= Convention (Formal)\n+              and then not Has_Warnings_Off (E)\n+              and then not Has_Warnings_Off (F_Type)\n+              and then not Has_Warnings_Off (Formal)\n+            then\n+               --  Qualify mention of formals with subprogram name\n+\n+               Error_Msg_Qual_Level := 1;\n+\n+               --  Check suspicious use of fat C pointer\n+\n+               if Is_Access_Type (F_Type)\n+                 and then Esize (F_Type) > Ttypes.System_Address_Size\n+               then\n+                  Error_Msg_N\n+                    (\"?x?type of & does not correspond to C pointer!\", Formal);\n+\n+               --  Check suspicious return of boolean\n+\n+               elsif Root_Type (F_Type) = Standard_Boolean\n+                 and then Convention (F_Type) = Convention_Ada\n+                 and then not Has_Warnings_Off (F_Type)\n+                 and then not Has_Size_Clause (F_Type)\n+                 and then VM_Target = No_VM\n+               then\n+                  Error_Msg_N (\"& is an 8-bit Ada Boolean?x?\", Formal);\n+                  Error_Msg_N (\"\\use appropriate corresponding type in C \"\n+                     & \"(e.g. char)?x?\", Formal);\n+\n+               --  Check suspicious tagged type\n+\n+               elsif (Is_Tagged_Type (F_Type)\n+                       or else (Is_Access_Type (F_Type)\n+                                  and then\n+                                    Is_Tagged_Type\n+                                      (Designated_Type (F_Type))))\n+                 and then Convention (E) = Convention_C\n+               then\n+                  Error_Msg_N (\"?x?& involves a tagged type which does not \"\n+                     & \"correspond to any C type!\", Formal);\n+\n+               --  Check wrong convention subprogram pointer\n+\n+               elsif Ekind (F_Type) = E_Access_Subprogram_Type\n+                 and then not Has_Foreign_Convention (F_Type)\n+               then\n+                  Error_Msg_N (\"?x?subprogram pointer & should \"\n+                     & \"have foreign convention!\", Formal);\n+                  Error_Msg_Sloc := Sloc (F_Type);\n+                  Error_Msg_NE\n+                    (\"\\?x?add Convention pragma to declaration of &#\",\n+                     Formal, F_Type);\n+               end if;\n+\n+               --  Turn off name qualification after message output\n+\n+               Error_Msg_Qual_Level := 0;\n+            end if;\n+\n+            --  Check for unconstrained array in exported foreign\n+            --  convention case.\n+\n+            if Has_Foreign_Convention (E)\n+              and then not Is_Imported (E)\n+              and then Is_Array_Type (F_Type)\n+              and then not Is_Constrained (F_Type)\n+              and then Warn_On_Export_Import\n+\n+              --  Exclude VM case, since both .NET and JVM can handle\n+              --  unconstrained arrays without a problem.\n+\n+              and then VM_Target = No_VM\n+            then\n+               Error_Msg_Qual_Level := 1;\n+\n+               --  If this is an inherited operation, place the\n+               --  warning on the derived type declaration, rather\n+               --  than on the original subprogram.\n+\n+               if Nkind (Original_Node (Parent (E))) = N_Full_Type_Declaration\n+               then\n+                  Warn_Node := Parent (E);\n+\n+                  if Formal = First_Formal (E) then\n+                     Error_Msg_NE\n+                       (\"??in inherited operation&\", Warn_Node, E);\n+                  end if;\n+               else\n+                  Warn_Node := Formal;\n+               end if;\n+\n+               Error_Msg_NE (\"?x?type of argument& is unconstrained array\",\n+                  Warn_Node, Formal);\n+               Error_Msg_NE (\"?x?foreign caller must pass bounds explicitly\",\n+                  Warn_Node, Formal);\n+               Error_Msg_Qual_Level := 0;\n+            end if;\n+\n+            if not From_Limited_With (F_Type) then\n+               if Is_Access_Type (F_Type) then\n+                  F_Type := Designated_Type (F_Type);\n+               end if;\n+\n+               --  If the formal is an anonymous_access_to_subprogram\n+               --  freeze the  subprogram type as well, to prevent\n+               --  scope anomalies in gigi, because there is no other\n+               --  clear point at which it could be frozen.\n+\n+               if Is_Itype (Etype (Formal))\n+                 and then Ekind (F_Type) = E_Subprogram_Type\n+               then\n+                  Freeze_And_Append (F_Type, N, Result);\n+               end if;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         --  Case of function: similar checks on return type\n+\n+         if Ekind (E) = E_Function then\n+\n+            --  Check whether function is declared elsewhere.\n+\n+            Late_Freezing :=\n+              Get_Source_Unit (E) /= Get_Source_Unit (N)\n+                and then Returns_Limited_View (E)\n+                and then not In_Open_Scopes (Scope (E));\n+\n+            --  Freeze return type\n+\n+            R_Type := Etype (E);\n+\n+            --  AI05-0151: the return type may have been incomplete\n+            --  at the point of declaration. Replace it with the full\n+            --  view, unless the current type is a limited view. In\n+            --  that case the full view is in a different unit, and\n+            --  gigi finds the non-limited view after the other unit\n+            --  is elaborated.\n+\n+            if Ekind (R_Type) = E_Incomplete_Type\n+              and then Present (Full_View (R_Type))\n+              and then not From_Limited_With (R_Type)\n+            then\n+               R_Type := Full_View (R_Type);\n+               Set_Etype (E, R_Type);\n+\n+            --  If the return type is a limited view and the non-\n+            --  limited view is still incomplete, the function has\n+            --  to be frozen at a later time.\n+\n+            elsif Ekind (R_Type) = E_Incomplete_Type\n+              and then From_Limited_With (R_Type)\n+              and then\n+                Ekind (Non_Limited_View (R_Type)) = E_Incomplete_Type\n+            then\n+               Set_Is_Frozen (E, False);\n+               Set_Returns_Limited_View (E);\n+               return False;\n+            end if;\n+\n+            Freeze_And_Append (R_Type, N, Result);\n+\n+            --  Check suspicious return type for C function\n+\n+            if Warn_On_Export_Import\n+              and then (Convention (E) = Convention_C\n+                          or else\n+                        Convention (E) = Convention_CPP)\n+              and then (Is_Imported (E) or else Is_Exported (E))\n+            then\n+               --  Check suspicious return of fat C pointer\n+\n+               if Is_Access_Type (R_Type)\n+                 and then Esize (R_Type) > Ttypes.System_Address_Size\n+                 and then not Has_Warnings_Off (E)\n+                 and then not Has_Warnings_Off (R_Type)\n+               then\n+                  Error_Msg_N (\"?x?return type of& does not \"\n+                     & \"correspond to C pointer!\", E);\n+\n+               --  Check suspicious return of boolean\n+\n+               elsif Root_Type (R_Type) = Standard_Boolean\n+                 and then Convention (R_Type) = Convention_Ada\n+                 and then VM_Target = No_VM\n+                 and then not Has_Warnings_Off (E)\n+                 and then not Has_Warnings_Off (R_Type)\n+                 and then not Has_Size_Clause (R_Type)\n+               then\n+                  declare\n+                     N : constant Node_Id :=\n+                           Result_Definition (Declaration_Node (E));\n+                  begin\n+                     Error_Msg_NE\n+                       (\"return type of & is an 8-bit Ada Boolean?x?\", N, E);\n+                     Error_Msg_NE\n+                       (\"\\use appropriate corresponding type in C \"\n+                        & \"(e.g. char)?x?\", N, E);\n+                  end;\n+\n+               --  Check suspicious return tagged type\n+\n+               elsif (Is_Tagged_Type (R_Type)\n+                       or else (Is_Access_Type (R_Type)\n+                                 and then\n+                                   Is_Tagged_Type\n+                                     (Designated_Type (R_Type))))\n+                 and then Convention (E) = Convention_C\n+                 and then not Has_Warnings_Off (E)\n+                 and then not Has_Warnings_Off (R_Type)\n+               then\n+                  Error_Msg_N (\"?x?return type of & does not \"\n+                     & \"correspond to C type!\", E);\n+\n+               --  Check return of wrong convention subprogram pointer\n+\n+               elsif Ekind (R_Type) = E_Access_Subprogram_Type\n+                 and then not Has_Foreign_Convention (R_Type)\n+                 and then not Has_Warnings_Off (E)\n+                 and then not Has_Warnings_Off (R_Type)\n+               then\n+                  Error_Msg_N (\"?x?& should return a foreign \"\n+                     & \"convention subprogram pointer\", E);\n+                  Error_Msg_Sloc := Sloc (R_Type);\n+                  Error_Msg_NE\n+                    (\"\\?x?add Convention pragma to declaration of& #\",\n+                     E, R_Type);\n+               end if;\n+            end if;\n+\n+            --  Give warning for suspicious return of a result of an\n+            --  unconstrained array type in a foreign convention\n+            --  function.\n+\n+            if Has_Foreign_Convention (E)\n+\n+              --  We are looking for a return of unconstrained array\n+\n+              and then Is_Array_Type (R_Type)\n+              and then not Is_Constrained (R_Type)\n+\n+              --  Exclude imported routines, the warning does not\n+              --  belong on the import, but rather on the routine\n+              --  definition.\n+\n+              and then not Is_Imported (E)\n+\n+              --  Exclude VM case, since both .NET and JVM can handle\n+              --  return of unconstrained arrays without a problem.\n+\n+              and then VM_Target = No_VM\n+\n+              --  Check that general warning is enabled, and that it\n+              --  is not suppressed for this particular case.\n+\n+              and then Warn_On_Export_Import\n+              and then not Has_Warnings_Off (E)\n+              and then not Has_Warnings_Off (R_Type)\n+            then\n+               Error_Msg_N (\"?x?foreign convention function& should not \" &\n+                 \"return unconstrained array!\", E);\n+            end if;\n+         end if;\n+\n+         return True;\n+      end Freeze_Profile;\n+\n       ------------------------\n       -- Freeze_Record_Type --\n       ------------------------\n@@ -4009,352 +4351,12 @@ package body Freeze is\n             --  reference is not a freezing point of the profile.\n             --  Other constructs that should not freeze ???\n \n-            if Ada_Version > Ada_2005\n-              and then Nkind (N) = N_Attribute_Reference\n-            then\n-               null;\n-\n-            elsif not Is_Internal (E) then\n-               declare\n-                  F_Type    : Entity_Id;\n-                  R_Type    : Entity_Id;\n-                  Warn_Node : Node_Id;\n-\n-               begin\n-                  --  Loop through formals\n-\n-                  Formal := First_Formal (E);\n-                  while Present (Formal) loop\n-                     F_Type := Etype (Formal);\n-\n-                     --  AI05-0151: incomplete types can appear in a profile.\n-                     --  By the time the entity is frozen, the full view must\n-                     --  be available, unless it is a limited view.\n-\n-                     if Is_Incomplete_Type (F_Type)\n-                       and then Present (Full_View (F_Type))\n-                       and then not From_Limited_With (F_Type)\n-                     then\n-                        F_Type := Full_View (F_Type);\n-                        Set_Etype (Formal, F_Type);\n-                     end if;\n-\n-                     Freeze_And_Append (F_Type, N, Result);\n-\n-                     if Is_Private_Type (F_Type)\n-                       and then Is_Private_Type (Base_Type (F_Type))\n-                       and then No (Full_View (Base_Type (F_Type)))\n-                       and then not Is_Generic_Type (F_Type)\n-                       and then not Is_Derived_Type (F_Type)\n-                     then\n-                        --  If the type of a formal is incomplete, subprogram\n-                        --  is being frozen prematurely. Within an instance\n-                        --  (but not within a wrapper package) this is an\n-                        --  artifact of our need to regard the end of an\n-                        --  instantiation as a freeze point. Otherwise it is\n-                        --  a definite error.\n-\n-                        if In_Instance then\n-                           Set_Is_Frozen (E, False);\n-                           return No_List;\n-\n-                        elsif not After_Last_Declaration\n-                          and then not Freezing_Library_Level_Tagged_Type\n-                        then\n-                           Error_Msg_Node_1 := F_Type;\n-                           Error_Msg\n-                             (\"type& must be fully defined before this point\",\n-                               Loc);\n-                        end if;\n-                     end if;\n-\n-                     --  Check suspicious parameter for C function. These tests\n-                     --  apply only to exported/imported subprograms.\n-\n-                     if Warn_On_Export_Import\n-                       and then Comes_From_Source (E)\n-                       and then (Convention (E) = Convention_C\n-                                   or else\n-                                 Convention (E) = Convention_CPP)\n-                       and then (Is_Imported (E) or else Is_Exported (E))\n-                       and then Convention (E) /= Convention (Formal)\n-                       and then not Has_Warnings_Off (E)\n-                       and then not Has_Warnings_Off (F_Type)\n-                       and then not Has_Warnings_Off (Formal)\n-                     then\n-                        --  Qualify mention of formals with subprogram name\n-\n-                        Error_Msg_Qual_Level := 1;\n-\n-                        --  Check suspicious use of fat C pointer\n-\n-                        if Is_Access_Type (F_Type)\n-                          and then Esize (F_Type) > Ttypes.System_Address_Size\n-                        then\n-                           Error_Msg_N\n-                             (\"?x?type of & does not correspond to C pointer!\",\n-                              Formal);\n-\n-                        --  Check suspicious return of boolean\n-\n-                        elsif Root_Type (F_Type) = Standard_Boolean\n-                          and then Convention (F_Type) = Convention_Ada\n-                          and then not Has_Warnings_Off (F_Type)\n-                          and then not Has_Size_Clause (F_Type)\n-                          and then VM_Target = No_VM\n-                        then\n-                           Error_Msg_N\n-                             (\"& is an 8-bit Ada Boolean?x?\", Formal);\n-                           Error_Msg_N\n-                             (\"\\use appropriate corresponding type in C \"\n-                              & \"(e.g. char)?x?\", Formal);\n-\n-                        --  Check suspicious tagged type\n-\n-                        elsif (Is_Tagged_Type (F_Type)\n-                                or else (Is_Access_Type (F_Type)\n-                                           and then\n-                                             Is_Tagged_Type\n-                                               (Designated_Type (F_Type))))\n-                          and then Convention (E) = Convention_C\n-                        then\n-                           Error_Msg_N\n-                             (\"?x?& involves a tagged type which does not \"\n-                              & \"correspond to any C type!\", Formal);\n-\n-                        --  Check wrong convention subprogram pointer\n-\n-                        elsif Ekind (F_Type) = E_Access_Subprogram_Type\n-                          and then not Has_Foreign_Convention (F_Type)\n-                        then\n-                           Error_Msg_N\n-                             (\"?x?subprogram pointer & should \"\n-                              & \"have foreign convention!\", Formal);\n-                           Error_Msg_Sloc := Sloc (F_Type);\n-                           Error_Msg_NE\n-                             (\"\\?x?add Convention pragma to declaration of &#\",\n-                              Formal, F_Type);\n-                        end if;\n-\n-                        --  Turn off name qualification after message output\n-\n-                        Error_Msg_Qual_Level := 0;\n-                     end if;\n+            --  This processing doesn't apply to internal entities (see below)\n \n-                     --  Check for unconstrained array in exported foreign\n-                     --  convention case.\n-\n-                     if Has_Foreign_Convention (E)\n-                       and then not Is_Imported (E)\n-                       and then Is_Array_Type (F_Type)\n-                       and then not Is_Constrained (F_Type)\n-                       and then Warn_On_Export_Import\n-\n-                       --  Exclude VM case, since both .NET and JVM can handle\n-                       --  unconstrained arrays without a problem.\n-\n-                       and then VM_Target = No_VM\n-                     then\n-                        Error_Msg_Qual_Level := 1;\n-\n-                        --  If this is an inherited operation, place the\n-                        --  warning on the derived type declaration, rather\n-                        --  than on the original subprogram.\n-\n-                        if Nkind (Original_Node (Parent (E))) =\n-                          N_Full_Type_Declaration\n-                        then\n-                           Warn_Node := Parent (E);\n-\n-                           if Formal = First_Formal (E) then\n-                              Error_Msg_NE\n-                                (\"??in inherited operation&\", Warn_Node, E);\n-                           end if;\n-                        else\n-                           Warn_Node := Formal;\n-                        end if;\n-\n-                        Error_Msg_NE\n-                          (\"?x?type of argument& is unconstrained array\",\n-                           Warn_Node, Formal);\n-                        Error_Msg_NE\n-                          (\"?x?foreign caller must pass bounds explicitly\",\n-                           Warn_Node, Formal);\n-                        Error_Msg_Qual_Level := 0;\n-                     end if;\n-\n-                     if not From_Limited_With (F_Type) then\n-                        if Is_Access_Type (F_Type) then\n-                           F_Type := Designated_Type (F_Type);\n-                        end if;\n-\n-                        --  If the formal is an anonymous_access_to_subprogram\n-                        --  freeze the  subprogram type as well, to prevent\n-                        --  scope anomalies in gigi, because there is no other\n-                        --  clear point at which it could be frozen.\n-\n-                        if Is_Itype (Etype (Formal))\n-                          and then Ekind (F_Type) = E_Subprogram_Type\n-                        then\n-                           Freeze_And_Append (F_Type, N, Result);\n-                        end if;\n-                     end if;\n-\n-                     Next_Formal (Formal);\n-                  end loop;\n-\n-                  --  Case of function: similar checks on return type\n-\n-                  if Ekind (E) = E_Function then\n-\n-                     --  Check whether function is declared elsewhere.\n-\n-                     Late_Freezing :=\n-                       Get_Source_Unit (E) /= Get_Source_Unit (N)\n-                         and then Returns_Limited_View (E)\n-                         and then not In_Open_Scopes (Scope (E));\n-\n-                     --  Freeze return type\n-\n-                     R_Type := Etype (E);\n-\n-                     --  AI05-0151: the return type may have been incomplete\n-                     --  at the point of declaration. Replace it with the full\n-                     --  view, unless the current type is a limited view. In\n-                     --  that case the full view is in a different unit, and\n-                     --  gigi finds the non-limited view after the other unit\n-                     --  is elaborated.\n-\n-                     if Ekind (R_Type) = E_Incomplete_Type\n-                       and then Present (Full_View (R_Type))\n-                       and then not From_Limited_With (R_Type)\n-                     then\n-                        R_Type := Full_View (R_Type);\n-                        Set_Etype (E, R_Type);\n-\n-                     --  If the return type is a limited view and the non-\n-                     --  limited view is still incomplete, the function has\n-                     --  to be frozen at a later time.\n-\n-                     elsif Ekind (R_Type) = E_Incomplete_Type\n-                       and then From_Limited_With (R_Type)\n-                       and then\n-                         Ekind (Non_Limited_View (R_Type)) = E_Incomplete_Type\n-                     then\n-                        Set_Is_Frozen (E, False);\n-                        Set_Returns_Limited_View (E);\n-                        return Result;\n-                     end if;\n-\n-                     Freeze_And_Append (R_Type, N, Result);\n-\n-                     --  Check suspicious return type for C function\n-\n-                     if Warn_On_Export_Import\n-                       and then (Convention (E) = Convention_C\n-                                   or else\n-                                 Convention (E) = Convention_CPP)\n-                       and then (Is_Imported (E) or else Is_Exported (E))\n-                     then\n-                        --  Check suspicious return of fat C pointer\n-\n-                        if Is_Access_Type (R_Type)\n-                          and then Esize (R_Type) > Ttypes.System_Address_Size\n-                          and then not Has_Warnings_Off (E)\n-                          and then not Has_Warnings_Off (R_Type)\n-                        then\n-                           Error_Msg_N\n-                             (\"?x?return type of& does not \"\n-                              & \"correspond to C pointer!\", E);\n-\n-                        --  Check suspicious return of boolean\n-\n-                        elsif Root_Type (R_Type) = Standard_Boolean\n-                          and then Convention (R_Type) = Convention_Ada\n-                          and then VM_Target = No_VM\n-                          and then not Has_Warnings_Off (E)\n-                          and then not Has_Warnings_Off (R_Type)\n-                          and then not Has_Size_Clause (R_Type)\n-                        then\n-                           declare\n-                              N : constant Node_Id :=\n-                                    Result_Definition (Declaration_Node (E));\n-                           begin\n-                              Error_Msg_NE\n-                                (\"return type of & is an 8-bit Ada Boolean?x?\",\n-                                 N, E);\n-                              Error_Msg_NE\n-                                (\"\\use appropriate corresponding type in C \"\n-                                 & \"(e.g. char)?x?\", N, E);\n-                           end;\n-\n-                        --  Check suspicious return tagged type\n-\n-                        elsif (Is_Tagged_Type (R_Type)\n-                                or else (Is_Access_Type (R_Type)\n-                                          and then\n-                                            Is_Tagged_Type\n-                                              (Designated_Type (R_Type))))\n-                          and then Convention (E) = Convention_C\n-                          and then not Has_Warnings_Off (E)\n-                          and then not Has_Warnings_Off (R_Type)\n-                        then\n-                           Error_Msg_N\n-                             (\"?x?return type of & does not \"\n-                              & \"correspond to C type!\", E);\n-\n-                        --  Check return of wrong convention subprogram pointer\n-\n-                        elsif Ekind (R_Type) = E_Access_Subprogram_Type\n-                          and then not Has_Foreign_Convention (R_Type)\n-                          and then not Has_Warnings_Off (E)\n-                          and then not Has_Warnings_Off (R_Type)\n-                        then\n-                           Error_Msg_N\n-                             (\"?x?& should return a foreign \"\n-                              & \"convention subprogram pointer\", E);\n-                           Error_Msg_Sloc := Sloc (R_Type);\n-                           Error_Msg_NE\n-                             (\"\\?x?add Convention pragma to declaration of& #\",\n-                              E, R_Type);\n-                        end if;\n-                     end if;\n-\n-                     --  Give warning for suspicious return of a result of an\n-                     --  unconstrained array type in a foreign convention\n-                     --  function.\n-\n-                     if Has_Foreign_Convention (E)\n-\n-                       --  We are looking for a return of unconstrained array\n-\n-                       and then Is_Array_Type (R_Type)\n-                       and then not Is_Constrained (R_Type)\n-\n-                       --  Exclude imported routines, the warning does not\n-                       --  belong on the import, but rather on the routine\n-                       --  definition.\n-\n-                       and then not Is_Imported (E)\n-\n-                       --  Exclude VM case, since both .NET and JVM can handle\n-                       --  return of unconstrained arrays without a problem.\n-\n-                       and then VM_Target = No_VM\n-\n-                       --  Check that general warning is enabled, and that it\n-                       --  is not suppressed for this particular case.\n-\n-                       and then Warn_On_Export_Import\n-                       and then not Has_Warnings_Off (E)\n-                       and then not Has_Warnings_Off (R_Type)\n-                     then\n-                        Error_Msg_N\n-                          (\"?x?foreign convention function& should not \" &\n-                           \"return unconstrained array!\", E);\n-                     end if;\n-                  end if;\n-               end;\n+            if not Is_Internal (E) then\n+               if not Freeze_Profile (E) then\n+                  return Result;\n+               end if;\n             end if;\n \n             --  Must freeze its parent first if it is a derived subprogram"}, {"sha": "4cbb8cb21ef660d750522059020542b4a8ad5ced", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "patch": "@@ -585,7 +585,12 @@ procedure Gnat1drv is\n \n       --  Treat -gnatn as equivalent to -gnatN for non-GCC targets\n \n-      if Inline_Active and then not Front_End_Inlining then\n+      if Inline_Active and not Front_End_Inlining then\n+\n+         --  We really should have a tag for this, what if we added a new\n+         --  back end some day, it would not be true for this test, but it\n+         --  would be non-GCC, so this is a bit troublesome ???\n+\n          Front_End_Inlining := VM_Target /= No_VM or else AAMP_On_Target;\n       end if;\n "}, {"sha": "2a3dc45405c9060af3f82daadf80c1f15cc67215", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "patch": "@@ -3018,14 +3018,16 @@ package body Sem_Ch13 is\n                   --  of a package declaration, the pragma needs to be inserted\n                   --  in the list of declarations for the associated package.\n                   --  There is no issue of visibility delay for these aspects.\n-                  --  Aspect is legal on a local instantiation of a library-\n-                  --  level generic unit.\n \n                   if A_Id in Library_Unit_Aspects\n                     and then\n                       Nkind_In (N, N_Package_Declaration,\n                                    N_Generic_Package_Declaration)\n                     and then Nkind (Parent (N)) /= N_Compilation_Unit\n+\n+                    --  Aspect is legal on a local instantiation of a library-\n+                    --  level generic unit.\n+\n                     and then not Is_Generic_Instance (Defining_Entity (N))\n                   then\n                      Error_Msg_N"}, {"sha": "f300e7099b39e76b2c38ba079a90592f40e2ac50", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "patch": "@@ -6696,6 +6696,18 @@ package body Sem_Res is\n          then\n             return True;\n \n+         --  The volatile object appears as the expression of a type conversion\n+         --  occurring in a non-interfering context.\n+\n+         elsif Nkind_In (Context, N_Type_Conversion,\n+                                  N_Unchecked_Type_Conversion)\n+           and then Expression (Context) = Obj_Ref\n+           and then Is_OK_Volatile_Context\n+                      (Context => Parent (Context),\n+                       Obj_Ref => Context)\n+         then\n+            return True;\n+\n          --  Allow references to volatile objects in various checks. This is\n          --  not a direct SPARK 2014 requirement.\n "}]}