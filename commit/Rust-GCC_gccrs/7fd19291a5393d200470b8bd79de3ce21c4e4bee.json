{"sha": "7fd19291a5393d200470b8bd79de3ce21c4e4bee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZkMTkyOTFhNTM5M2QyMDA0NzBiOGJkNzlkZTNjZTIxYzRlNGJlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-27T22:36:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-27T22:36:48Z"}, "message": "runtime: adapt memory management to AIX mmap\n    \n    On AIX:\n    * mmap does not allow to map an already mapped range,\n    * mmap range start at 0x30000000 for 32 bits processes,\n    * mmap range start at 0x70000000_00000000 for 64 bits processes\n    \n    This is adapted from change 37845.\n    \n    Issue golang/go#19200\n    \n    Reviewed-on: https://go-review.googlesource.com/46772\n\nFrom-SVN: r249713", "tree": {"sha": "c105247981108997e8faf34d6055638c1d52e2a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c105247981108997e8faf34d6055638c1d52e2a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fd19291a5393d200470b8bd79de3ce21c4e4bee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd19291a5393d200470b8bd79de3ce21c4e4bee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd19291a5393d200470b8bd79de3ce21c4e4bee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd19291a5393d200470b8bd79de3ce21c4e4bee/comments", "author": null, "committer": null, "parents": [{"sha": "f9dedc3f21020bcc704fcfb7caa1b04b5dc874e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9dedc3f21020bcc704fcfb7caa1b04b5dc874e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9dedc3f21020bcc704fcfb7caa1b04b5dc874e7"}], "stats": {"total": 20, "additions": 18, "deletions": 2}, "files": [{"sha": "b52320bc4b072023f5a815900cbe16b78db72669", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd19291a5393d200470b8bd79de3ce21c4e4bee/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd19291a5393d200470b8bd79de3ce21c4e4bee/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7fd19291a5393d200470b8bd79de3ce21c4e4bee", "patch": "@@ -1,4 +1,4 @@\n-63b766d67098877496a4b79d7f41e731fbe8abc8\n+66d14d95a5a453682fe387319c80bc4fc40d96ad\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3912fc2da58a4c006aa8a4e400398fb36dba07d3", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd19291a5393d200470b8bd79de3ce21c4e4bee/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd19291a5393d200470b8bd79de3ce21c4e4bee/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=7fd19291a5393d200470b8bd79de3ce21c4e4bee", "patch": "@@ -291,6 +291,8 @@ func mallocinit() {\n \t\t// allocation at 0x40 << 32 because when using 4k pages with 3-level\n \t\t// translation buffers, the user address space is limited to 39 bits\n \t\t// On darwin/arm64, the address space is even smaller.\n+\t\t// On AIX, mmap adresses range start at 0x07000000_00000000 for 64 bits\n+\t\t// processes.\n \t\tarenaSize := round(_MaxMem, _PageSize)\n \t\tbitmapSize = arenaSize / (sys.PtrSize * 8 / 2)\n \t\tspansSize = arenaSize / _PageSize * sys.PtrSize\n@@ -301,12 +303,15 @@ func mallocinit() {\n \t\t\t\tp = uintptr(i)<<40 | uintptrMask&(0x0013<<28)\n \t\t\tcase GOARCH == \"arm64\":\n \t\t\t\tp = uintptr(i)<<40 | uintptrMask&(0x0040<<32)\n+\t\t\tcase GOOS == \"aix\":\n+\t\t\t\ti = 1\n+\t\t\t\tp = uintptr(i)<<32 | uintptrMask&(0x70<<52)\n \t\t\tdefault:\n \t\t\t\tp = uintptr(i)<<40 | uintptrMask&(0x00c0<<32)\n \t\t\t}\n \t\t\tpSize = bitmapSize + spansSize + arenaSize + _PageSize\n \t\t\tp = uintptr(sysReserve(unsafe.Pointer(p), pSize, &reserved))\n-\t\t\tif p != 0 {\n+\t\t\tif p != 0 || GOOS == \"aix\" { // Useless to loop on AIX, as i is forced to 1\n \t\t\t\tbreak\n \t\t\t}\n \t\t}"}, {"sha": "ea3e5ebab4eac3effee5cc85478208f9f680f684", "filename": "libgo/go/runtime/mem_gccgo.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd19291a5393d200470b8bd79de3ce21c4e4bee/libgo%2Fgo%2Fruntime%2Fmem_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd19291a5393d200470b8bd79de3ce21c4e4bee/libgo%2Fgo%2Fruntime%2Fmem_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmem_gccgo.go?ref=7fd19291a5393d200470b8bd79de3ce21c4e4bee", "patch": "@@ -270,6 +270,11 @@ func sysMap(v unsafe.Pointer, n uintptr, reserved bool, sysStat *uint64) {\n \t\treturn\n \t}\n \n+\tif GOOS == \"aix\" {\n+\t\t// AIX does not allow mapping a range that is already mapped.\n+\t\t// So always unmap first even if it is already unmapped.\n+\t\tmunmap(v, n)\n+\t}\n \tp := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, mmapFD, 0)\n \tif uintptr(p) == _MAP_FAILED && errno() == _ENOMEM {\n \t\tthrow(\"runtime: out of memory\")"}, {"sha": "6da35210440501849265ac74b92cc9dd9564a3f8", "filename": "libgo/runtime/runtime_c.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd19291a5393d200470b8bd79de3ce21c4e4bee/libgo%2Fruntime%2Fruntime_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd19291a5393d200470b8bd79de3ce21c4e4bee/libgo%2Fruntime%2Fruntime_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime_c.c?ref=7fd19291a5393d200470b8bd79de3ce21c4e4bee", "patch": "@@ -139,13 +139,19 @@ uintptr getEnd(void)\n uintptr\n getEnd()\n {\n+#ifdef _AIX\n+  // mmap adresses range start at 0x30000000 on AIX for 32 bits processes\n+  uintptr end = 0x30000000U;\n+#else\n   uintptr end = 0;\n   uintptr *pend;\n \n   pend = &__go_end;\n   if (pend != nil) {\n     end = *pend;\n   }\n+#endif\n+\n   return end;\n }\n "}]}