{"sha": "524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI0ZDliNGI5MDM1ZmY2OWYxMDI0Y2EyYzMyYzcyMTcxMjhmM2NmOQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-10-19T23:47:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2015-10-19T23:47:35Z"}, "message": "REE: fix uninitialized registers handling\n\ngcc/ChangeLog:\n\n\tPR rtl-optimization/66790\n\t* df.h (DF_MIR): New macro.\n\t(DF_LAST_PROBLEM_PLUS1): Update to be past DF_MIR\n\t(DF_MIR_INFO_BB): New macro.\n\t(DF_MIR_IN, DF_MIR_OUT): New macros.\n\t(struct df_mir_bb_info): New.\n\t(df_mir): New macro.\n\t(df_mir_add_problem, df_mir_simulate_one_insn): New forward\n\tdeclarations.\n\t(df_mir_get_bb_info): New.\n\t* df-problems.c (struct df_mir_problem_data): New.\n\t(df_mir_free_bb_info, df_mir_alloc, df_mir_reset,\n\tdf_mir_bb_local_compute, df_mir_local_compute, df_mir_init,\n\tdf_mir_confluence_0, df_mir_confluence_n,\n\tdf_mir_transfer_function, df_mir_free, df_mir_top_dump,\n\tdf_mir_bottom_dump, df_mir_verify_solution_start,\n\tdf_mir_verify_solution_end): New.\n\t(problem_MIR): New.\n\t(df_mir_add_problem, df_mir_simulate_one_insn): New.\n\t* timevar.def (TV_DF_MIR): New.\n\t* ree.c: Include bitmap.h\n\t(add_removable_extension): Add an INIT_REGS parameter.  Use it\n\tto skip zero-extensions that may get an uninitialized register.\n\t(find_removable_extensions): Compute must-initialized registers\n\tusing the MIR dataflow problem. Update the call to\n\tadd_removable_extension.\n\t(find_and_remove_re): Call df_mir_add_problem.\n\ngcc/testsuite/ChangeLog:\n\n\t* gnat.dg/opt50.adb: New test.\n\t* gnat.dg/opt50_pkg.adb: New helper.\n\t* gnat.dg/opt50_pkg.ads: New helper.\n\nFrom-SVN: r229008", "tree": {"sha": "d4b672674b050b5804bf9a28e4d83b5c24ea0d85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4b672674b050b5804bf9a28e4d83b5c24ea0d85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32308c8db4af9260cafcb517fe020dff5280f993", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32308c8db4af9260cafcb517fe020dff5280f993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32308c8db4af9260cafcb517fe020dff5280f993"}], "stats": {"total": 619, "additions": 605, "deletions": 14}, "files": [{"sha": "4279557480d774d2032a8b974ea75f643949822f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -1,3 +1,33 @@\n+2015-10-19  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\tPR rtl-optimization/66790\n+\t* df.h (DF_MIR): New macro.\n+\t(DF_LAST_PROBLEM_PLUS1): Update to be past DF_MIR\n+\t(DF_MIR_INFO_BB): New macro.\n+\t(DF_MIR_IN, DF_MIR_OUT): New macros.\n+\t(struct df_mir_bb_info): New.\n+\t(df_mir): New macro.\n+\t(df_mir_add_problem, df_mir_simulate_one_insn): New forward\n+\tdeclarations.\n+\t(df_mir_get_bb_info): New.\n+\t* df-problems.c (struct df_mir_problem_data): New.\n+\t(df_mir_free_bb_info, df_mir_alloc, df_mir_reset,\n+\tdf_mir_bb_local_compute, df_mir_local_compute, df_mir_init,\n+\tdf_mir_confluence_0, df_mir_confluence_n,\n+\tdf_mir_transfer_function, df_mir_free, df_mir_top_dump,\n+\tdf_mir_bottom_dump, df_mir_verify_solution_start,\n+\tdf_mir_verify_solution_end): New.\n+\t(problem_MIR): New.\n+\t(df_mir_add_problem, df_mir_simulate_one_insn): New.\n+\t* timevar.def (TV_DF_MIR): New.\n+\t* ree.c: Include bitmap.h\n+\t(add_removable_extension): Add an INIT_REGS parameter.  Use it\n+\tto skip zero-extensions that may get an uninitialized register.\n+\t(find_removable_extensions): Compute must-initialized registers\n+\tusing the MIR dataflow problem. Update the call to\n+\tadd_removable_extension.\n+\t(find_and_remove_re): Call df_mir_add_problem.\n+\n 2015-10-19  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* common/config/mn10300/mn10300-common.c"}, {"sha": "331fd87f2b5548c62f5adf1f416c86975cb6fc45", "filename": "gcc/df-problems.c", "status": "modified", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -1848,6 +1848,409 @@ df_live_verify_transfer_functions (void)\n   bitmap_clear (&all_blocks);\n }\n \f\n+/*----------------------------------------------------------------------------\n+   MUST-INITIALIZED REGISTERS.\n+----------------------------------------------------------------------------*/\n+\n+/* Private data used to verify the solution for this problem.  */\n+struct df_mir_problem_data\n+{\n+  bitmap_head *in;\n+  bitmap_head *out;\n+  /* An obstack for the bitmaps we need for this problem.  */\n+  bitmap_obstack mir_bitmaps;\n+};\n+\n+\n+/* Free basic block info.  */\n+\n+static void\n+df_mir_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n+\t\t     void *vbb_info)\n+{\n+  struct df_mir_bb_info *bb_info = (struct df_mir_bb_info *) vbb_info;\n+  if (bb_info)\n+    {\n+      bitmap_clear (&bb_info->gen);\n+      bitmap_clear (&bb_info->kill);\n+      bitmap_clear (&bb_info->in);\n+      bitmap_clear (&bb_info->out);\n+    }\n+}\n+\n+\n+/* Allocate or reset bitmaps for DF_MIR blocks. The solution bits are\n+   not touched unless the block is new.  */\n+\n+static void\n+df_mir_alloc (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+  struct df_mir_problem_data *problem_data;\n+\n+  if (df_mir->problem_data)\n+    problem_data = (struct df_mir_problem_data *) df_mir->problem_data;\n+  else\n+    {\n+      problem_data = XNEW (struct df_mir_problem_data);\n+      df_mir->problem_data = problem_data;\n+\n+      problem_data->out = NULL;\n+      problem_data->in = NULL;\n+      bitmap_obstack_initialize (&problem_data->mir_bitmaps);\n+    }\n+\n+  df_grow_bb_info (df_mir);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+\n+      /* When bitmaps are already initialized, just clear them.  */\n+      if (bb_info->kill.obstack)\n+\t{\n+\t  bitmap_clear (&bb_info->kill);\n+\t  bitmap_clear (&bb_info->gen);\n+\t}\n+      else\n+\t{\n+\t  bitmap_initialize (&bb_info->kill, &problem_data->mir_bitmaps);\n+\t  bitmap_initialize (&bb_info->gen, &problem_data->mir_bitmaps);\n+\t  bitmap_initialize (&bb_info->in, &problem_data->mir_bitmaps);\n+\t  bitmap_initialize (&bb_info->out, &problem_data->mir_bitmaps);\n+\t  bitmap_set_range (&bb_info->in, 0, DF_REG_SIZE (df));\n+\t  bitmap_set_range (&bb_info->out, 0, DF_REG_SIZE (df));\n+\t}\n+    }\n+\n+  df_mir->optional_p = 1;\n+}\n+\n+\n+/* Reset the global solution for recalculation.  */\n+\n+static void\n+df_mir_reset (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+\n+      gcc_assert (bb_info);\n+\n+      bitmap_clear (&bb_info->in);\n+      bitmap_set_range (&bb_info->in, 0, DF_REG_SIZE (df));\n+      bitmap_clear (&bb_info->out);\n+      bitmap_set_range (&bb_info->out, 0, DF_REG_SIZE (df));\n+    }\n+}\n+\n+\n+/* Compute local uninitialized register info for basic block BB.  */\n+\n+static void\n+df_mir_bb_local_compute (unsigned int bb_index)\n+{\n+  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n+  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+  rtx_insn *insn;\n+  int luid = 0;\n+\n+  /* Ignoring artificial defs is intentional: these often pretend that some\n+     registers carry incoming arguments (when they are FUNCTION_ARG_REGNO) even\n+     though they are not used for that.  As a result, conservatively assume\n+     they may be uninitialized.  */\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      struct df_insn_info *insn_info = DF_INSN_UID_GET (uid);\n+\n+      /* Inserting labels does not always trigger the incremental\n+\t rescanning.  */\n+      if (!insn_info)\n+\t{\n+\t  gcc_assert (!INSN_P (insn));\n+\t  insn_info = df_insn_create_insn_record (insn);\n+\t}\n+\n+      DF_INSN_INFO_LUID (insn_info) = luid;\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      luid++;\n+      df_mir_simulate_one_insn (bb, insn, &bb_info->kill, &bb_info->gen);\n+    }\n+}\n+\n+\n+/* Compute local uninitialized register info.  */\n+\n+static void\n+df_mir_local_compute (bitmap all_blocks)\n+{\n+  unsigned int bb_index;\n+  bitmap_iterator bi;\n+\n+  df_grow_insn_info ();\n+\n+  EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n+    {\n+      df_mir_bb_local_compute (bb_index);\n+    }\n+}\n+\n+\n+/* Initialize the solution vectors.  */\n+\n+static void\n+df_mir_init (bitmap all_blocks)\n+{\n+  df_mir_reset (all_blocks);\n+}\n+\n+\n+/* Initialize IN sets for blocks with no predecessors: when landing on such\n+   blocks, assume all registers are uninitialized.  */\n+\n+static void\n+df_mir_confluence_0 (basic_block bb)\n+{\n+  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n+\n+  bitmap_clear (&bb_info->in);\n+}\n+\n+\n+/* Forward confluence function that ignores fake edges.  */\n+\n+static bool\n+df_mir_confluence_n (edge e)\n+{\n+  bitmap op1 = &df_mir_get_bb_info (e->dest->index)->in;\n+  bitmap op2 = &df_mir_get_bb_info (e->src->index)->out;\n+\n+  if (e->flags & EDGE_FAKE)\n+    return false;\n+\n+  /* A register is must-initialized at the entry of a basic block iff it is\n+     must-initialized at the exit of all the predecessors.  */\n+  return bitmap_and_into (op1, op2);\n+}\n+\n+\n+/* Transfer function for the forwards must-initialized problem.  */\n+\n+static bool\n+df_mir_transfer_function (int bb_index)\n+{\n+  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+  bitmap in = &bb_info->in;\n+  bitmap out = &bb_info->out;\n+  bitmap gen = &bb_info->gen;\n+  bitmap kill = &bb_info->kill;\n+\n+  return bitmap_ior_and_compl (out, gen, in, kill);\n+}\n+\n+\n+/* Free all storage associated with the problem.  */\n+\n+static void\n+df_mir_free (void)\n+{\n+  struct df_mir_problem_data *problem_data\n+    = (struct df_mir_problem_data *) df_mir->problem_data;\n+  if (df_mir->block_info)\n+    {\n+      df_mir->block_info_size = 0;\n+      free (df_mir->block_info);\n+      df_mir->block_info = NULL;\n+      bitmap_obstack_release (&problem_data->mir_bitmaps);\n+      free (problem_data);\n+      df_mir->problem_data = NULL;\n+    }\n+  free (df_mir);\n+}\n+\n+\n+/* Debugging info at top of bb.  */\n+\n+static void\n+df_mir_top_dump (basic_block bb, FILE *file)\n+{\n+  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n+\n+  if (!bb_info)\n+    return;\n+\n+  fprintf (file, \";; mir   in  \\t\");\n+  df_print_regset (file, &bb_info->in);\n+  fprintf (file, \";; mir   kill\\t\");\n+  df_print_regset (file, &bb_info->kill);\n+  fprintf (file, \";; mir   gen \\t\");\n+  df_print_regset (file, &bb_info->gen);\n+}\n+\n+/* Debugging info at bottom of bb.  */\n+\n+static void\n+df_mir_bottom_dump (basic_block bb, FILE *file)\n+{\n+  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n+\n+  if (!bb_info)\n+    return;\n+\n+  fprintf (file, \";; mir   out \\t\");\n+  df_print_regset (file, &bb_info->out);\n+}\n+\n+\n+/* Build the datastructure to verify that the solution to the dataflow\n+   equations is not dirty.  */\n+\n+static void\n+df_mir_verify_solution_start (void)\n+{\n+  basic_block bb;\n+  struct df_mir_problem_data *problem_data;\n+  if (df_mir->solutions_dirty)\n+    return;\n+\n+  /* Set it true so that the solution is recomputed.  */\n+  df_mir->solutions_dirty = true;\n+\n+  problem_data = (struct df_mir_problem_data *) df_mir->problem_data;\n+  problem_data->in = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n+  problem_data->out = XNEWVEC (bitmap_head, last_basic_block_for_fn (cfun));\n+  bitmap_obstack_initialize (&problem_data->mir_bitmaps);\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      bitmap_initialize (&problem_data->in[bb->index], &problem_data->mir_bitmaps);\n+      bitmap_initialize (&problem_data->out[bb->index], &problem_data->mir_bitmaps);\n+      bitmap_copy (&problem_data->in[bb->index], DF_MIR_IN (bb));\n+      bitmap_copy (&problem_data->out[bb->index], DF_MIR_OUT (bb));\n+    }\n+}\n+\n+\n+/* Compare the saved datastructure and the new solution to the dataflow\n+   equations.  */\n+\n+static void\n+df_mir_verify_solution_end (void)\n+{\n+  struct df_mir_problem_data *problem_data;\n+  basic_block bb;\n+\n+  problem_data = (struct df_mir_problem_data *) df_mir->problem_data;\n+  if (!problem_data->out)\n+    return;\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      if ((!bitmap_equal_p (&problem_data->in[bb->index], DF_MIR_IN (bb)))\n+\t  || (!bitmap_equal_p (&problem_data->out[bb->index], DF_MIR_OUT (bb))))\n+\tgcc_unreachable ();\n+    }\n+\n+  /* Cannot delete them immediately because you may want to dump them\n+     if the comparison fails.  */\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      bitmap_clear (&problem_data->in[bb->index]);\n+      bitmap_clear (&problem_data->out[bb->index]);\n+    }\n+\n+  free (problem_data->in);\n+  free (problem_data->out);\n+  bitmap_obstack_release (&problem_data->mir_bitmaps);\n+  free (problem_data);\n+  df_mir->problem_data = NULL;\n+}\n+\n+\n+/* All of the information associated with every instance of the problem.  */\n+\n+static struct df_problem problem_MIR =\n+{\n+  DF_MIR,                       /* Problem id.  */\n+  DF_FORWARD,                   /* Direction.  */\n+  df_mir_alloc,                 /* Allocate the problem specific data.  */\n+  df_mir_reset,                 /* Reset global information.  */\n+  df_mir_free_bb_info,          /* Free basic block info.  */\n+  df_mir_local_compute,         /* Local compute function.  */\n+  df_mir_init,                  /* Init the solution specific data.  */\n+  df_worklist_dataflow,         /* Worklist solver.  */\n+  df_mir_confluence_0,          /* Confluence operator 0.  */\n+  df_mir_confluence_n,          /* Confluence operator n.  */\n+  df_mir_transfer_function,     /* Transfer function.  */\n+  NULL,                         /* Finalize function.  */\n+  df_mir_free,                  /* Free all of the problem information.  */\n+  df_mir_free,                  /* Remove this problem from the stack of dataflow problems.  */\n+  NULL,                         /* Debugging.  */\n+  df_mir_top_dump,              /* Debugging start block.  */\n+  df_mir_bottom_dump,           /* Debugging end block.  */\n+  NULL,                         /* Debugging start insn.  */\n+  NULL,                         /* Debugging end insn.  */\n+  df_mir_verify_solution_start, /* Incremental solution verify start.  */\n+  df_mir_verify_solution_end,   /* Incremental solution verify end.  */\n+  NULL,                         /* Dependent problem.  */\n+  sizeof (struct df_mir_bb_info),/* Size of entry of block_info array.  */\n+  TV_DF_MIR,                    /* Timing variable.  */\n+  false                         /* Reset blocks on dropping out of blocks_to_analyze.  */\n+};\n+\n+\n+/* Create a new DATAFLOW instance and add it to an existing instance\n+   of DF.  */\n+\n+void\n+df_mir_add_problem (void)\n+{\n+  df_add_problem (&problem_MIR);\n+  /* These will be initialized when df_scan_blocks processes each\n+     block.  */\n+  df_mir->out_of_date_transfer_functions = BITMAP_ALLOC (&df_bitmap_obstack);\n+}\n+\n+\n+/* Apply the effects of the gen/kills in INSN to the corresponding bitmaps.  */\n+\n+void\n+df_mir_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx_insn *insn,\n+\t\t\t  bitmap kill, bitmap gen)\n+{\n+  df_ref def;\n+\n+  FOR_EACH_INSN_DEF (def, insn)\n+    {\n+      unsigned int regno = DF_REF_REGNO (def);\n+\n+      /* The order of GENs/KILLs matters, so if this def clobbers a reg, any\n+\t previous gen is irrelevant (and reciprocally).  Also, claim that a\n+\t register is GEN only if it is in all cases.  */\n+      if (DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))\n+\t{\n+\t  bitmap_set_bit (kill, regno);\n+\t  bitmap_clear_bit (gen, regno);\n+\t}\n+      /* In the worst case, partial and conditional defs can leave bits\n+\t uninitialized, so assume they do not change anything.  */\n+      else if (!DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL | DF_REF_CONDITIONAL))\n+\t{\n+\t  bitmap_set_bit (gen, regno);\n+\t  bitmap_clear_bit (kill, regno);\n+\t}\n+    }\n+}\n+\f\n /*----------------------------------------------------------------------------\n    CREATE DEF_USE (DU) and / or USE_DEF (UD) CHAINS\n "}, {"sha": "54b9abbed56a45c4e7f9da726d6f941d54ea5f9c", "filename": "gcc/df.h", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -51,8 +51,9 @@ union df_ref_d;\n #define DF_WORD_LR 5      /* Subreg tracking lr.  */\n #define DF_NOTE    6      /* REG_DEAD and REG_UNUSED notes.  */\n #define DF_MD      7      /* Multiple Definitions. */\n+#define DF_MIR     8      /* Must-initialized Registers.  */\n \n-#define DF_LAST_PROBLEM_PLUS1 (DF_MD + 1)\n+#define DF_LAST_PROBLEM_PLUS1 (DF_MIR + 1)\n \n /* Dataflow direction.  */\n enum df_flow_dir\n@@ -612,12 +613,16 @@ struct df_d\n #define DF_LIVE_BB_INFO(BB) (df_live_get_bb_info ((BB)->index))\n #define DF_WORD_LR_BB_INFO(BB) (df_word_lr_get_bb_info ((BB)->index))\n #define DF_MD_BB_INFO(BB) (df_md_get_bb_info ((BB)->index))\n+#define DF_MIR_BB_INFO(BB) (df_mir_get_bb_info ((BB)->index))\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n #define DF_LIVE_IN(BB) (&DF_LIVE_BB_INFO (BB)->in)\n #define DF_LIVE_OUT(BB) (&DF_LIVE_BB_INFO (BB)->out)\n \n+#define DF_MIR_IN(BB) (&DF_MIR_BB_INFO (BB)->in)\n+#define DF_MIR_OUT(BB) (&DF_MIR_BB_INFO (BB)->out)\n+\n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n@@ -896,6 +901,21 @@ struct df_word_lr_bb_info\n   bitmap_head out;   /* At the bottom of the block.  */\n };\n \n+/* Must-initialized registers.  All bitmaps are referenced by the\n+   register number.  */\n+struct df_mir_bb_info\n+{\n+  /* Local sets to describe the basic blocks.  */\n+  bitmap_head kill;  /* The set of registers unset in this block.  Calls,\n+\t\t        for instance, unset registers.  */\n+  bitmap_head gen;   /* The set of registers set in this block, excluding the\n+\t\t\tones killed later on in this block.  */\n+\n+  /* The results of the dataflow problem.  */\n+  bitmap_head in;    /* At the top of the block.  */\n+  bitmap_head out;   /* At the bottom of the block.  */\n+};\n+\n \n /* This is used for debugging and for the dumpers to find the latest\n    instance so that the df info can be added to the dumps.  This\n@@ -909,6 +929,7 @@ extern struct df_d *df;\n #define df_word_lr (df->problems_by_index[DF_WORD_LR])\n #define df_note    (df->problems_by_index[DF_NOTE])\n #define df_md      (df->problems_by_index[DF_MD])\n+#define df_mir     (df->problems_by_index[DF_MIR])\n \n /* This symbol turns on checking that each modification of the cfg has\n   been identified to the appropriate df routines.  It is not part of\n@@ -1005,6 +1026,8 @@ extern void df_note_add_problem (void);\n extern void df_md_add_problem (void);\n extern void df_md_simulate_artificial_defs_at_top (basic_block, bitmap);\n extern void df_md_simulate_one_insn (basic_block, rtx_insn *, bitmap);\n+extern void df_mir_add_problem (void);\n+extern void df_mir_simulate_one_insn (basic_block, rtx_insn *, bitmap, bitmap);\n extern void df_simulate_find_noclobber_defs (rtx_insn *, bitmap);\n extern void df_simulate_find_defs (rtx_insn *, bitmap);\n extern void df_simulate_defs (rtx_insn *, bitmap);\n@@ -1111,6 +1134,15 @@ df_word_lr_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n+static inline struct df_mir_bb_info *\n+df_mir_get_bb_info (unsigned int index)\n+{\n+  if (index < df_mir->block_info_size)\n+    return &((struct df_mir_bb_info *) df_mir->block_info)[index];\n+  else\n+    return NULL;\n+}\n+\n /* Get the live at out set for BB no matter what problem happens to be\n    defined.  This function is used by the register allocators who\n    choose different dataflow problems depending on the optimization"}, {"sha": "a75c73266131bdfa866295edf1bbf93d4560472a", "filename": "gcc/ree.c", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -246,6 +246,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"cgraph.h\"\n+#include \"bitmap.h\"\n \n /* This structure represents a candidate for elimination.  */\n \n@@ -973,7 +974,8 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n static void\n add_removable_extension (const_rtx expr, rtx_insn *insn,\n \t\t\t vec<ext_cand> *insn_list,\n-\t\t\t unsigned *def_map)\n+\t\t\t unsigned *def_map,\n+\t\t\t bitmap init_regs)\n {\n   enum rtx_code code;\n   machine_mode mode;\n@@ -993,11 +995,29 @@ add_removable_extension (const_rtx expr, rtx_insn *insn,\n       && (code == SIGN_EXTEND || code == ZERO_EXTEND)\n       && REG_P (XEXP (src, 0)))\n     {\n+      rtx reg = XEXP (src, 0);\n       struct df_link *defs, *def;\n       ext_cand *cand;\n \n-      /* First, make sure we can get all the reaching definitions.  */\n-      defs = get_defs (insn, XEXP (src, 0), NULL);\n+      /* Zero-extension of an undefined value is partly defined (it's\n+\t completely undefined for sign-extension, though).  So if there exists\n+\t a path from the entry to this zero-extension that leaves this register\n+\t uninitialized, removing the extension could change the behavior of\n+\t correct programs.  So first, check it is not the case.  */\n+      if (code == ZERO_EXTEND && !bitmap_bit_p (init_regs, REGNO (reg)))\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Cannot eliminate extension:\\n\");\n+\t      print_rtl_single (dump_file, insn);\n+\t      fprintf (dump_file, \" because it can operate on uninitialized\"\n+\t\t\t          \" data\\n\");\n+\t    }\n+\t  return;\n+\t}\n+\n+      /* Second, make sure we can get all the reaching definitions.  */\n+      defs = get_defs (insn, reg, NULL);\n       if (!defs)\n \t{\n \t  if (dump_file)\n@@ -1009,7 +1029,7 @@ add_removable_extension (const_rtx expr, rtx_insn *insn,\n \t  return;\n \t}\n \n-      /* Second, make sure the reaching definitions don't feed another and\n+      /* Third, make sure the reaching definitions don't feed another and\n \t different extension.  FIXME: this obviously can be improved.  */\n       for (def = defs; def; def = def->next)\n \tif ((idx = def_map[INSN_UID (DF_REF_INSN (def->ref))])\n@@ -1099,18 +1119,33 @@ find_removable_extensions (void)\n   rtx_insn *insn;\n   rtx set;\n   unsigned *def_map = XCNEWVEC (unsigned, max_insn_uid);\n+  bitmap_head init, kill, gen, tmp;\n+\n+  bitmap_initialize (&init, NULL);\n+  bitmap_initialize (&kill, NULL);\n+  bitmap_initialize (&gen, NULL);\n+  bitmap_initialize (&tmp, NULL);\n \n   FOR_EACH_BB_FN (bb, cfun)\n-    FOR_BB_INSNS (bb, insn)\n-      {\n-\tif (!NONDEBUG_INSN_P (insn))\n-\t  continue;\n+    {\n+      bitmap_copy (&init, DF_MIR_IN (bb));\n+      bitmap_clear (&kill);\n+      bitmap_clear (&gen);\n \n-\tset = single_set (insn);\n-\tif (set == NULL_RTX)\n-\t  continue;\n-\tadd_removable_extension (set, insn, &insn_list, def_map);\n-      }\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (NONDEBUG_INSN_P (insn))\n+\t    {\n+\t      set = single_set (insn);\n+\t      if (set != NULL_RTX)\n+\t\tadd_removable_extension (set, insn, &insn_list, def_map,\n+\t\t\t\t\t &init);\n+\t      df_mir_simulate_one_insn (bb, insn, &kill, &gen);\n+\t      bitmap_ior_and_compl (&tmp, &gen, &init, &kill);\n+\t      bitmap_copy (&init, &tmp);\n+\t    }\n+\t}\n+    }\n \n   XDELETEVEC (def_map);\n \n@@ -1135,6 +1170,7 @@ find_and_remove_re (void)\n      extension instruction.  */\n   df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n   df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n+  df_mir_add_problem ();\n   df_analyze ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n "}, {"sha": "5a32885249a335b37ea86b41e4c621a9fd032ea8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -1,3 +1,9 @@\n+2015-10-19  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gnat.dg/opt50.adb: New test.\n+\t* gnat.dg/opt50_pkg.adb: New helper.\n+\t* gnat.dg/opt50_pkg.ads: New helper.\n+\n 2015-10-19  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68019"}, {"sha": "f930d0980afb38a1c73733a84022ad31ab4082f7", "filename": "gcc/testsuite/gnat.dg/opt50.adb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50.adb?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -0,0 +1,23 @@\n+-- { dg-do run }\n+-- { dg-options \"-O3 -gnatn\" }\n+\n+with Opt50_Pkg; use Opt50_Pkg;\n+\n+procedure Opt50 is\n+  B : Boolean;\n+  E : Enum;\n+begin\n+  Get (\"four\", E, B);\n+  if B = True then\n+    raise Program_Error;\n+  end if;\n+  Get (\"three\", E, B);\n+  if B = False then\n+    raise Program_Error;\n+  end if;\n+  declare\n+    A : Enum_Boolean_Array (One .. E) := (others => True);\n+  begin\n+    Set (A);\n+  end;\n+end Opt50;"}, {"sha": "0f92f7dcf532afa3e98fa8e49a20f4e24ca2cfd4", "filename": "gcc/testsuite/gnat.dg/opt50_pkg.adb", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50_pkg.adb?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -0,0 +1,48 @@\n+with Ada.Characters.Handling;\n+with Ada.Containers;\n+with Ada.Containers.Indefinite_Hashed_Maps;\n+with Ada.Strings.Hash;\n+\n+package body Opt50_Pkg is\n+\n+   type Enum_Name is array (Enum) of access constant String;\n+\n+   Enum_Name_Table : constant Enum_Name := (\n+      One   => new String'(\"one\"),\n+      Two   => new String'(\"two\"),\n+      Three => new String'(\"three\"));\n+\n+   package String_To_Enum_Map is new Ada.Containers.Indefinite_Hashed_Maps\n+      (Key_Type => String, Element_Type => Enum,\n+       Hash => Ada.Strings.Hash, Equivalent_Keys => \"=\");\n+\n+   function Fill_Hashed_Map return String_To_Enum_Map.Map is\n+      Res : String_To_Enum_Map.Map;\n+      use String_To_Enum_Map;\n+   begin\n+      for I in Enum_Name_Table'Range loop\n+         declare\n+            Kind : constant String := Enum_Name_Table (I).all;\n+         begin\n+            Res.Insert(Key => Kind, New_Item => I);\n+         end;\n+      end loop;\n+      return Res;\n+   end;\n+\n+   String_To_Enum : constant String_To_Enum_Map.Map := Fill_Hashed_Map;\n+\n+   procedure Get (Kind : String; Result : out Enum; Success : out Boolean) is\n+      X : constant String := Ada.Characters.Handling.To_Lower (Kind);\n+      use String_To_Enum_Map;\n+      Curs : constant Cursor := String_To_Enum.Find (X);\n+   begin\n+      Success := Curs /= No_Element;\n+      if Success then\n+         Result := Element(Curs);\n+      end if;\n+   end;\n+\n+   procedure Set (A : Enum_Boolean_Array) is null;\n+\n+end Opt50_Pkg;"}, {"sha": "9faea546b3cf8a8036f87b24c8af8b0ab8266c4b", "filename": "gcc/testsuite/gnat.dg/opt50_pkg.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt50_pkg.ads?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -0,0 +1,12 @@\n+package Opt50_Pkg is\n+\n+   type Enum is (One, Two, Three);\n+   for Enum'Size use 16;\n+\n+   type Enum_Boolean_Array is array (Enum range <>) of Boolean;\n+\n+   procedure Get (Kind : String; Result : out Enum; Success : out Boolean);\n+\n+   procedure Set (A : Enum_Boolean_Array);\n+\n+end Opt50_Pkg;"}, {"sha": "2fbfb174e94ea135979e1b3521aa805b076ef294", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/524d9b4b9035ff69f1024ca2c32c7217128f3cf9/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=524d9b4b9035ff69f1024ca2c32c7217128f3cf9", "patch": "@@ -115,6 +115,7 @@ DEFTIMEVAR (TV_DF_MD\t\t     , \"df multiple defs\")\n DEFTIMEVAR (TV_DF_RD\t\t     , \"df reaching defs\")\n DEFTIMEVAR (TV_DF_LR\t\t     , \"df live regs\")\n DEFTIMEVAR (TV_DF_LIVE\t\t     , \"df live&initialized regs\")\n+DEFTIMEVAR (TV_DF_MIR\t\t     , \"df must-initialized regs\")\n DEFTIMEVAR (TV_DF_CHAIN\t\t     , \"df use-def / def-use chains\")\n DEFTIMEVAR (TV_DF_WORD_LR\t     , \"df live reg subwords\")\n DEFTIMEVAR (TV_DF_NOTE\t\t     , \"df reg dead/unused notes\")"}]}