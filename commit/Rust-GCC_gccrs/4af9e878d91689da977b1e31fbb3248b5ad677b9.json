{"sha": "4af9e878d91689da977b1e31fbb3248b5ad677b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmOWU4NzhkOTE2ODlkYTk3N2IxZTMxZmJiMzI0OGI1YWQ2NzdiOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-01-15T18:14:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-01-15T18:14:32Z"}, "message": "re PR c++/36334 (typedef to function type leads to problems)\n\n        PR c++/36334\n        PR c++/37646\n        * tree.c (lvalue_p_1): Handle BASELINK.  A COMPONENT_REF to\n        a function isn't necessarily an lvalue. Take tree, not const_tree.\n        (lvalue_p, real_lvalue_p): Take tree, not const_tree.\n        * typeck.c (lvalue_or_else): Likewise.\n        * cp-tree.h: Adjust prototypes.\n\nFrom-SVN: r143404", "tree": {"sha": "813a681559b4e930c5f836452d80f24baae41519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/813a681559b4e930c5f836452d80f24baae41519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af9e878d91689da977b1e31fbb3248b5ad677b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af9e878d91689da977b1e31fbb3248b5ad677b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af9e878d91689da977b1e31fbb3248b5ad677b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af9e878d91689da977b1e31fbb3248b5ad677b9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1253e7e69d20a489bb734ea66d0702e9eaa4b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1253e7e69d20a489bb734ea66d0702e9eaa4b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1253e7e69d20a489bb734ea66d0702e9eaa4b76"}], "stats": {"total": 87, "additions": 75, "deletions": 12}, "files": [{"sha": "4b23d3193635c656c75954e89a5aa15b21c7dd38", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -1,3 +1,13 @@\n+2009-01-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/36334\n+\tPR c++/37646\n+\t* tree.c (lvalue_p_1): Handle BASELINK.  A COMPONENT_REF to\n+\ta function isn't necessarily an lvalue. Take tree, not const_tree.\n+\t(lvalue_p, real_lvalue_p): Take tree, not const_tree.\n+\t* typeck.c (lvalue_or_else): Likewise.\n+\t* cp-tree.h: Adjust prototypes.\n+\n 2009-01-15  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR c++/38357"}, {"sha": "186ec9ab6adffef6a615d8ba42cd3bc9b79e28c5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -4836,7 +4836,7 @@ extern tree canonical_type_variant\t\t(tree);\n extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(const_tree);\n-extern cp_lvalue_kind real_lvalue_p\t\t(const_tree);\n+extern cp_lvalue_kind real_lvalue_p\t\t(tree);\n extern bool builtin_valid_in_constant_expr_p    (const_tree);\n extern tree build_min\t\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_nt\t\t\t(enum tree_code, ...);\n@@ -4984,9 +4984,9 @@ extern tree lookup_anon_field\t\t\t(tree, tree);\n extern bool invalid_nonstatic_memfn_p\t\t(const_tree, tsubst_flags_t);\n extern tree convert_member_func_to_ptr\t\t(tree, tree);\n extern tree convert_ptrmem\t\t\t(tree, tree, bool, bool);\n-extern int lvalue_or_else\t\t\t(const_tree, enum lvalue_use,\n+extern int lvalue_or_else\t\t\t(tree, enum lvalue_use,\n                                                  tsubst_flags_t);\n-extern int lvalue_p\t\t\t\t(const_tree);\n+extern int lvalue_p\t\t\t\t(tree);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "3347bfb9f0bd5861b5dff482e730430231fd1412", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -44,7 +44,7 @@ static tree build_cplus_array_type_1 (tree, tree);\n static int list_hash_eq (const void *, const void *);\n static hashval_t list_hash_pieces (tree, tree, tree);\n static hashval_t list_hash (const void *);\n-static cp_lvalue_kind lvalue_p_1 (const_tree, int);\n+static cp_lvalue_kind lvalue_p_1 (tree, int);\n static tree build_target_expr (tree, tree);\n static tree count_trees_r (tree *, int *, void *);\n static tree verify_stmt_tree_r (tree *, int *, void *);\n@@ -59,7 +59,7 @@ static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n    nonzero, rvalues of class type are considered lvalues.  */\n \n static cp_lvalue_kind\n-lvalue_p_1 (const_tree ref,\n+lvalue_p_1 (tree ref,\n \t    int treat_class_rvalues_as_lvalues)\n {\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n@@ -110,11 +110,13 @@ lvalue_p_1 (const_tree ref,\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n \t\t\t\t    treat_class_rvalues_as_lvalues);\n       /* Look at the member designator.  */\n-      if (!op1_lvalue_kind\n-\t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n-\t     situations.  */\n-\t  || TREE_CODE (TREE_OPERAND (ref, 1)) != FIELD_DECL)\n+      if (!op1_lvalue_kind)\n \t;\n+      else if (is_overloaded_fn (TREE_OPERAND (ref, 1)))\n+\t/* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n+\t   situations.  */\n+\top1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t      treat_class_rvalues_as_lvalues);\n       else if (DECL_C_BIT_FIELD (TREE_OPERAND (ref, 1)))\n \t{\n \t  /* Clear the ordinary bit.  If this object was a class\n@@ -195,6 +197,12 @@ lvalue_p_1 (const_tree ref,\n       return (DECL_NONSTATIC_MEMBER_FUNCTION_P (ref)\n \t      ? clk_none : clk_ordinary);\n \n+    case BASELINK:\n+      /* We now represent a reference to a single static member function\n+\t with a BASELINK.  */\n+      return lvalue_p_1 (BASELINK_FUNCTIONS (ref),\n+\t\t\t treat_class_rvalues_as_lvalues);\n+\n     case NON_DEPENDENT_EXPR:\n       /* We must consider NON_DEPENDENT_EXPRs to be lvalues so that\n \t things like \"&E\" where \"E\" is an expression with a\n@@ -227,7 +235,7 @@ lvalue_p_1 (const_tree ref,\n    computes the C++ definition of lvalue.  */\n \n cp_lvalue_kind\n-real_lvalue_p (const_tree ref)\n+real_lvalue_p (tree ref)\n {\n   return lvalue_p_1 (ref,\n \t\t     /*treat_class_rvalues_as_lvalues=*/0);\n@@ -237,7 +245,7 @@ real_lvalue_p (const_tree ref)\n    considered lvalues.  */\n \n int\n-lvalue_p (const_tree ref)\n+lvalue_p (tree ref)\n {\n   return\n     (lvalue_p_1 (ref, /*class rvalue ok*/ 1) != clk_none);"}, {"sha": "415b8a26291f3e862a435ef69a0d4d0724fd1cfb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -7339,7 +7339,7 @@ non_reference (tree t)\n    how the lvalue is being used and so selects the error message.  */\n \n int\n-lvalue_or_else (const_tree ref, enum lvalue_use use, tsubst_flags_t complain)\n+lvalue_or_else (tree ref, enum lvalue_use use, tsubst_flags_t complain)\n {\n   int win = lvalue_p (ref);\n "}, {"sha": "198ba977e5b045f85a1113af87d0281f7ddef49c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -1,3 +1,11 @@\n+2009-01-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/36334\n+\t* g++.dg/conversion/memfn1.C: New test.\n+\n+\tPR c++/37646\n+\t* g++.dg/conversion/memfn2.C: New test.\n+\n 2008-01-15  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR c++/38357"}, {"sha": "da2fb0fadee56cf237c9cb77b8ec28b4c707f5f7", "filename": "gcc/testsuite/g++.dg/conversion/memfn1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fmemfn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fmemfn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fmemfn1.C?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/36334\n+\n+struct X\n+{\n+  typedef int* foobar();\n+  static void foo(foobar&);\n+};\n+\n+void X::foo(foobar&)\n+{\n+}\n+\n+struct Y : public X\n+{\n+  static foobar bar;\n+  static void foo();\n+};\n+\n+void Y::foo()\n+{\n+  X::foo(bar);\n+}\n+int* Y::bar()\n+{\n+  return 0;\n+}"}, {"sha": "c3d76133dbd46613e246ad67636db81d5d9cc103", "filename": "gcc/testsuite/g++.dg/conversion/memfn2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fmemfn2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af9e878d91689da977b1e31fbb3248b5ad677b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fmemfn2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fmemfn2.C?ref=4af9e878d91689da977b1e31fbb3248b5ad677b9", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/37646\n+\n+struct A\n+{\n+  void foo();\n+\n+  void bar(int i)\n+  {\n+    void (*p)() = i ? foo : foo; // { dg-error \"invalid use of member\" }\n+  }\n+};"}]}