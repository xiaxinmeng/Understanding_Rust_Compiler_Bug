{"sha": "5f3682ffcef162363b783eb9ee702debff489fa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYzNjgyZmZjZWYxNjIzNjNiNzgzZWI5ZWU3MDJkZWJmZjQ4OWZhOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-11-16T14:54:54Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-11-16T14:54:54Z"}, "message": "[PATCH] New lang hook\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-11/msg01340.html\n\tPR c++/82836\n\tPR c++/82737\n\t* tree.h (COPY_DECL_RTL): Rename parms for clarity.\n\t(SET_DECL_ASSEMBLER_NAME): Forward to\n\toverwrite_decl_assembler_name.\n\t(COPY_DECL_ASSEMBLER_NAME): Rename parms for clarity.\n\t(overwrite_decl_assembler_name): Declare.\n\t* tree.c (overwrite_decl_assembler_name): New.\n\t* langhooks-def.h (lhd_overwrite_decl_assembler_name): Declare.\n\t(LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME): Provide default.\n\t(LANG_HOOKS_INITIALIZER): Add it.\n\t* langhooks.h (struct lang_hooks): Add overwrite_decl_assembler_name.\n\t* langhooks.c (lhd_set_decl_assembler_name): Use\n\tSET_DECL_ASSEMBLER_NAME.\n\t(lhd_overwrite_decl_assembler_name): Default implementation.\n\n\tPR c++/82836\n\tPR c++/82737\n\t* cp-objcp-common.h (LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME):\n\tOverride.\n\t* cp-tree.h (overwrite_mangling): Declare.\n\t* decl2.c (struct mangled_decl_hash): Entries are deletable.\n\t(overwrite_mangling): New.\n\n\tPR c++/82836\n\tPR c++/82737\n\t* g++.dg/pr82836.C: New.\n\nFrom-SVN: r254823", "tree": {"sha": "b9e4f1042a3c4558c07ba463d34ee29d68c28a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9e4f1042a3c4558c07ba463d34ee29d68c28a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f3682ffcef162363b783eb9ee702debff489fa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3682ffcef162363b783eb9ee702debff489fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f3682ffcef162363b783eb9ee702debff489fa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3682ffcef162363b783eb9ee702debff489fa8/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a930324dabd41a76ef141a85a7d0cc7fc9c9c0b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a930324dabd41a76ef141a85a7d0cc7fc9c9c0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a930324dabd41a76ef141a85a7d0cc7fc9c9c0b3"}], "stats": {"total": 757, "additions": 739, "deletions": 18}, "files": [{"sha": "de9c6df23ed49ba08ddcb58381a427a5c731d825", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -1,3 +1,21 @@\n+2017-11-16  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/82836\n+\tPR c++/82737\n+\t* tree.h (COPY_DECL_RTL): Rename parms for clarity.\n+\t(SET_DECL_ASSEMBLER_NAME): Forward to\n+\toverwrite_decl_assembler_name.\n+\t(COPY_DECL_ASSEMBLER_NAME): Rename parms for clarity.\n+\t(overwrite_decl_assembler_name): Declare.\n+\t* tree.c (overwrite_decl_assembler_name): New.\n+\t* langhooks-def.h (lhd_overwrite_decl_assembler_name): Declare.\n+\t(LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME): Provide default.\n+\t(LANG_HOOKS_INITIALIZER): Add it.\n+\t* langhooks.h (struct lang_hooks): Add overwrite_decl_assembler_name.\n+\t* langhooks.c (lhd_set_decl_assembler_name): Use\n+\tSET_DECL_ASSEMBLER_NAME.\n+\t(lhd_overwrite_decl_assembler_name): Default implementation.\n+\n 2017-11-16  Wilco Dijkstra  <wdijkstr@arm.com>\n \t    Jackson Woodruff  <jackson.woodruff@arm.com>\n "}, {"sha": "9ceff2f397e759b735b4da18fd32b0163b1f336b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -1,5 +1,13 @@\n 2017-11-16  Nathan Sidwell  <nathan@acm.org>\n \n+\tPR c++/82836\n+\tPR c++/82737\n+\t* cp-objcp-common.h (LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME):\n+\tOverride.\n+\t* cp-tree.h (overwrite_mangling): Declare.\n+\t* decl2.c (struct mangled_decl_hash): Entries are deletable.\n+\t(overwrite_mangling): New.\n+\n \tPR c++/81060\n \t* decl.c (xref_tag_1): Push lambda into current scope.\n \t* name-lookup.c (do_pushtag): Don't deal with ts_lambda here."}, {"sha": "a1b1fcdea63e86efa14811e0ef0ffbe30343b4ec", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -73,6 +73,8 @@ extern void cp_register_dumps (gcc::dump_manager *);\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL cxx_dup_lang_specific_decl\n #undef LANG_HOOKS_SET_DECL_ASSEMBLER_NAME\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME mangle_decl\n+#undef LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME\n+#define LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME overwrite_mangling\n #undef LANG_HOOKS_PRINT_STATISTICS\n #define LANG_HOOKS_PRINT_STATISTICS cxx_print_statistics\n #undef LANG_HOOKS_PRINT_XNODE"}, {"sha": "c6554162078d514ba4241ebab747d63ad749e3db", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -6187,6 +6187,7 @@ extern tree cxx_maybe_build_cleanup\t\t(tree, tsubst_flags_t);\n \n /* in decl2.c */\n extern void record_mangling\t\t\t(tree, bool);\n+extern void overwrite_mangling\t\t\t(tree, tree);\n extern void note_mangling_alias\t\t\t(tree, tree);\n extern void generate_mangling_aliases\t\t(void);\n extern tree build_memfn_type\t\t\t(tree, tree, cp_cv_quals, cp_ref_qualifier);"}, {"sha": "bc0db0000deb049186441aaa0d73d26a52f1849f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -123,9 +123,14 @@ struct mangled_decl_hash : ggc_remove <tree>\n   static inline void mark_empty (value_type &p) {p = NULL_TREE;}\n   static inline bool is_empty (value_type p) {return !p;}\n \n-  /* Nothing is deletable.  Everything is insertable.  */\n-  static bool is_deleted (value_type) { return false; }\n-  static void mark_deleted (value_type) { gcc_unreachable (); }\n+  static bool is_deleted (value_type e)\n+  {\n+    return e == reinterpret_cast <value_type> (1);\n+  }\n+  static void mark_deleted (value_type &e)\n+  {\n+    e = reinterpret_cast <value_type> (1);\n+  }\n };\n \n /* A hash table of decls keyed by mangled name.  Used to figure out if\n@@ -4439,6 +4444,33 @@ record_mangling (tree decl, bool need_warning)\n     }\n }\n \n+/* The mangled name of DECL is being forcibly changed to NAME.  Remove\n+   any existing knowledge of DECL's mangled name meaning DECL.  */\n+\n+void\n+overwrite_mangling (tree decl, tree name)\n+{\n+  if (tree id = DECL_ASSEMBLER_NAME_RAW (decl))\n+    if ((TREE_CODE (decl) == VAR_DECL\n+\t || TREE_CODE (decl) == FUNCTION_DECL)\n+\t&& mangled_decls)\n+      if (tree *slot\n+\t  = mangled_decls->find_slot_with_hash (id, IDENTIFIER_HASH_VALUE (id),\n+\t\t\t\t\t\tNO_INSERT))\n+\tif (*slot == decl)\n+\t  {\n+\t    mangled_decls->clear_slot (slot);\n+\n+\t    /* If this is an alias, remove it from the symbol table.  */\n+\t    if (DECL_ARTIFICIAL (decl) && DECL_IGNORED_P (decl))\n+\t      if (symtab_node *n = symtab_node::get (decl))\n+\t\tif (n->cpp_implicit_alias)\n+\t\t  n->remove ();\n+\t  }\n+\n+  DECL_ASSEMBLER_NAME_RAW (decl) = name;\n+}\n+\n /* The entire file is now complete.  If requested, dump everything\n    to a file.  */\n "}, {"sha": "44e7edf04ba5e62c897cfddc4cc0e1b08f3da888", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -51,7 +51,8 @@ extern const char *lhd_dwarf_name (tree, int);\n extern int lhd_types_compatible_p (tree, tree);\n extern void lhd_print_error_function (diagnostic_context *,\n \t\t\t\t      const char *, struct diagnostic_info *);\n-extern void lhd_set_decl_assembler_name (tree);\n+extern void lhd_set_decl_assembler_name (tree decl);\n+extern void lhd_overwrite_decl_assembler_name (tree decl, tree name);\n extern bool lhd_warn_unused_global_decl (const_tree);\n extern tree lhd_type_for_size (unsigned precision, int unsignedp);\n extern void lhd_incomplete_type_error (location_t, const_tree, const_tree);\n@@ -107,6 +108,7 @@ extern int lhd_type_dwarf_attribute (const_tree, int);\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL lhd_do_nothing_t\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n+#define LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME lhd_overwrite_decl_assembler_name\n #define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n #define LANG_HOOKS_PRINT_XNODE\t\tlhd_print_tree_nothing\n #define LANG_HOOKS_PRINT_DECL\t\tlhd_print_tree_nothing\n@@ -310,6 +312,7 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_FINISH_INCOMPLETE_DECL, \\\n   LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\\n   LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n+  LANG_HOOKS_OVERWRITE_DECL_ASSEMBLER_NAME, \\\n   LANG_HOOKS_PRINT_STATISTICS, \\\n   LANG_HOOKS_PRINT_XNODE, \\\n   LANG_HOOKS_PRINT_DECL, \\"}, {"sha": "0fab9d5c06876a3ddd9776e9301b4dd824e1e6f7", "filename": "gcc/langhooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -171,8 +171,15 @@ lhd_set_decl_assembler_name (tree decl)\n       ASM_FORMAT_PRIVATE_NAME (label, name, DECL_UID (decl));\n       id = get_identifier (label);\n     }\n+\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n+}\n \n+/* Forcibly overwrite the DECL_ASSEMBLER_NAME for DECL to NAME.  */\n+void\n+lhd_overwrite_decl_assembler_name (tree decl, tree name)\n+{\n+  DECL_ASSEMBLER_NAME_RAW (decl) = name;\n }\n \n /* Type promotion for variable arguments.  */"}, {"sha": "afc879ff9c2fe9cf904792c16145f4c7c5483592", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -395,6 +395,10 @@ struct lang_hooks\n      assembler does not talk about it.  */\n   void (*set_decl_assembler_name) (tree);\n \n+  /* Overwrite the DECL_ASSEMBLER_NAME for a node.  The name is being\n+     changed (including to or from NULL_TREE).  */\n+  void (*overwrite_decl_assembler_name) (tree, tree);\n+\n   /* The front end can add its own statistics to -fmem-report with\n      this hook.  It should output to stderr.  */\n   void (*print_statistics) (void);"}, {"sha": "158605a76f7c5e3a57467632de733ad12504cf53", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -1,5 +1,9 @@\n 2017-11-16  Nathan Sidwell  <nathan@acm.org>\n \n+\tPR c++/82836\n+\tPR c++/82737\n+\t* g++.dg/pr82836.C: New.\n+\n \tPR c++81060\n \t* g++.dg/cpp0x/lambda/lambda-template13.C: Avoid undefined\n \ttemplate using local type error."}, {"sha": "80876644b9844224f438206d6114c3984cd051be", "filename": "gcc/testsuite/g++.dg/pr82836.C", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr82836.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr82836.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr82836.C?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -0,0 +1,628 @@\n+// PR c++/82836\n+// { dg-do compile { target c++17 } }\n+// { dg-additional-options \"-Wno-pedantic\" }\n+// We were resetting DECL_ASSEMBLER_NAME when processing pragma weak,\n+// breaking C++'s mangling alias hash table.  That hash table needs to\n+// be tickled in just the right way to hit the problem.\n+\n+namespace std {\n+typedef long unsigned size_t;\n+inline namespace __cxx11 {}\n+double abs() {}\n+__int128 abs(__int128 ) {}\n+__float128 abs(__float128 ) {}\n+\n+  \n+#pragma weak pthread_create\n+typedef int luaL_Reg;\n+typedef int swig_lua_const_info;\n+typedef int swig_lua_attribute;\n+typedef int swig_lua_class;\n+}\n+static int swig_types;\n+static int swig_module;\n+namespace std {\n+  template < typename > class allocator;\n+  template < class > struct char_traits;\n+  namespace __cxx11 {\n+  template < typename _CharT, typename =  _CharT ,\n+             typename =  _CharT  >\n+  class basic_string;\n+  typedef basic_string< char > string;\n+  }\n+}\n+namespace __gnu_cxx {\n+  template < typename > struct __numeric_traits_integer;\n+  struct __conditional_type {\n+    typedef __numeric_traits_integer< int > __type;\n+  }__is_null_pointer0;\n+  template < typename _Value > struct __numeric_traits_integer {\n+    static const _Value __min = 0;\n+    static const _Value __max = 0;\n+  };\n+  template < typename _Value >\n+  const _Value __numeric_traits_integer< _Value >::__min;\n+  template < typename _Value >\n+  const _Value __numeric_traits_integer< _Value >::__max;\n+  template < typename >\n+  struct __numeric_traits : __conditional_type::__type {};\n+}\n+namespace std {\n+  template < typename _Tp, _Tp __v > struct integral_constant {\n+    static constexpr _Tp value = __v;\n+  };\n+  template < typename _Tp, _Tp __v >\n+  constexpr _Tp integral_constant< _Tp, __v >::value;\n+  typedef integral_constant< bool, false > false_type;\n+  struct __is_void_helper : false_type {};\n+  struct is_void : __is_void_helper{};\n+  template < int > struct conditional  ;\n+  template < typename , typename ,\n+             template < typename... > class >\n+  struct __detector {\n+       ;\n+  };\n+  template < typename _Default, template < typename > class _Op>\n+  using __detected_or = __detector< _Default, void, _Op>;\n+  template < typename _Default, template < typename> class _Op\n+               >\n+  using __detected_or_t =\n+      typename __detected_or< _Default, _Op>::type;\n+  struct  {}piecewise_construct ;\n+  struct random_access_iterator_tag ;\n+  template < typename , typename > struct iterator {\n+    typedef int difference_type;\n+    typedef int reference;\n+  };\n+  using __make_not_void = conditional< is_void::value >;\n+      struct pointer_traits \n+    ;\n+  \n+  template <> struct char_traits< char > {\n+    typedef char char_type;\n+    typedef int int_type;\n+    void assign() {}\n+    bool eq() {}\n+    bool lt() {}\n+    int compare() {}\n+    size_t length() {}\n+    char_type find() {}\n+    char_type move() {}\n+    char_type copy() {}\n+    char_type assign(char_type ) {}\n+    char_type to_char_type() {}\n+    int_type to_int_type() {}\n+    bool eq_int_type() {}\n+    int_type eof() {}\n+    int_type not_eof() {}\n+  };\n+  template <> struct char_traits< wchar_t > {\n+    typedef wchar_t char_type;\n+    typedef int int_type;\n+    void assign() {}\n+    bool eq() {}\n+    bool lt() {}\n+    int compare() {}\n+    size_t length() {}\n+    char_type find() {}\n+    char_type move() {}\n+    char_type copy() {}\n+    char_type assign(char_type ) {}\n+    char_type to_char_type() {}\n+    int_type to_int_type() {}\n+    bool eq_int_type() {}\n+    int_type eof() {}\n+    int_type not_eof() {}\n+  };\n+}\n+typedef int uint_least16_t;\n+typedef int uint_least32_t;\n+namespace std {\n+template <> struct char_traits< char16_t > {\n+  typedef char16_t char_type;\n+  typedef uint_least16_t int_type;\n+  void assign() {}\n+  bool eq() {}\n+  bool lt() {}\n+  int compare() {}\n+  size_t length() {}\n+  char_type find() {}\n+  char_type move() {}\n+  char_type copy() {}\n+  char_type assign(char_type ) {}\n+  char_type to_char_type() {}\n+  int_type to_int_type() {}\n+  bool eq_int_type() {}\n+  int_type eof() {}\n+  int_type not_eof() {}\n+};\n+template <> struct char_traits< char32_t > {\n+  typedef char32_t char_type;\n+  typedef uint_least32_t int_type;\n+  void assign() {}\n+  bool eq() {}\n+  bool lt() {}\n+  int compare() {}\n+  size_t length() {}\n+  char_type find() {}\n+  char_type move() {}\n+  char_type copy() {}\n+  char_type assign(char_type ) {}\n+  char_type to_char_type() {}\n+  int_type to_int_type() {}\n+  bool eq_int_type() {}\n+  int_type eof() {}\n+  int_type not_eof() {}\n+};\n+}\n+void *operator new(std::size_t) {}\n+void *operator new[](std::size_t) {}\n+void operator delete(void *){}\n+void operator delete[](void *) {}\n+namespace  {\n+        ;\n+}\n+namespace std {\n+\n+template < typename  > class allocator {\n+public:\n+  \n+  \n+  ~allocator();\n+}\n+;\n+template < typename _Tp >\n+struct less {\n+  bool operator()( _Tp ,  _Tp ) {}\n+};\n+}\n+typedef int _Atomic_word;\n+namespace {\n+  _Atomic_word __exchange_and_add_single0;\n+  static void __atomic_add_single();\n+  _Atomic_word __attribute____exchange_and_add_dispatch0;\n+  static void __attribute____atomic_add_dispatch();\n+}\n+namespace std {\n+  struct __allocator_traits_base {\n+    template < typename = void > struct __rebind {\n+      using type =\n+          allocator< char >;\n+    }\n+\n+  ;\n+  };\n+  template < typename , typename >\n+  using __alloc_rebind =\n+      __allocator_traits_base::__rebind<>::type;\n+  template < typename >\n+  struct allocator_traits   {\n+       \n+    template < typename _Tp >\n+    using rebind_alloc = __alloc_rebind<  char , _Tp >;\n+  };\n+}\n+namespace __gnu_cxx {\n+  template < typename >\n+  struct __alloc_traits : std::allocator_traits< std::allocator< char > > {\n+    template < typename > struct rebind {\n+      typedef rebind_alloc< int >\n+          other;\n+    };\n+  };\n+}\n+namespace std {\n+  namespace __cxx11 {\n+  template < typename , typename , typename >\n+  class basic_string {\n+    typedef __gnu_cxx::__alloc_traits<  char  >::\n+        rebind< int >::other _Char_alloc_type\n+    ;\n+    struct  : _Char_alloc_type {}_M_dataplus;\n+    int _S_compare() {\n+      \n+      if (__gnu_cxx::__numeric_traits< int >::__max)\n+        \n+       (__gnu_cxx::__numeric_traits< int >::__min)\n+        ;\n+    }\n+  };\n+  }\n+  template < typename _CharT, typename _Traits, typename _Alloc >\n+  basic_string<  _Traits> operator+(\n+       basic_string<   _Alloc > );\n+  template < typename _CharT, typename _Traits, typename _Alloc >\n+  basic_string<  _Traits> operator+(\n+        _Alloc  );\n+  template < typename _CharT, typename _Traits, typename _Alloc >\n+  basic_string<  _Traits> operator+(\n+        _Alloc  );\n+  template < typename , typename > struct __hash_base ;\n+  template < typename > struct hash;\n+  template <> struct hash< char > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< signed char > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< unsigned char > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< wchar_t > {\n+    void operator0() {}\n+  };\n+  template <> struct __hash_base< size_t, char16_t > {\n+    size_t operator0() {}\n+  };\n+  template <> struct __hash_base< size_t, char32_t > {\n+    size_t operator0() {}\n+  };\n+  template <> struct hash< short > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< int > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< long > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< long long > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< unsigned short > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< unsigned > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< unsigned long > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< unsigned long long > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< __int128 > {\n+    void operator0() {}\n+  };\n+  template <> struct hash< __int128 unsigned > {\n+    void operator0() {}\n+  };\n+  typedef long _Bit_type;\n+  struct _Bit_reference {\n+     ;\n+    _Bit_type _M_mask;\n+    _Bit_reference  () {}\n+    operator bool() {}\n+    _Bit_reference (bool ) {}\n+    _Bit_reference operator=(_Bit_reference ) {}\n+    bool operator==(_Bit_reference ) {}\n+    bool operator<(_Bit_reference ) {}\n+    void flip() {}\n+  };\n+  void swap() {}\n+  void swap(bool ) {}\n+  void swap(_Bit_reference ) {}\n+  struct _Bit_iterator_base\n+      :iterator< random_access_iterator_tag, bool > {\n+    _Bit_type *_M_p;\n+    int _M_offset;\n+    _Bit_iterator_base(_Bit_type *, int \n+         _M_offset) {}\n+    void _M_bump_up() {}\n+    void _M_bump_down() {}\n+    void _M_incr() {}\n+    bool operator==(_Bit_iterator_base ) {}\n+    bool operator<(_Bit_iterator_base ) {}\n+    bool operator!=(_Bit_iterator_base ) {}\n+    bool operator>(_Bit_iterator_base ) {}\n+    bool operator<=(_Bit_iterator_base ) {}\n+    bool operator>=(_Bit_iterator_base ) {}\n+  };\n+  struct _Bit_iterator : _Bit_iterator_base {\n+    _Bit_iterator() : _Bit_iterator_base(0, 0) {}\n+    _Bit_iterator(_Bit_type *__x, int __y)\n+        : _Bit_iterator_base(__x, __y) {}\n+    iterator _M_const_cast() {}\n+    iterator operator+() {}\n+    iterator operator-() {}\n+    reference operator[](difference_type ) {}\n+  };\n+  void operator+(_Bit_iterator ) {}\n+  struct _Bit_const_iterator : _Bit_iterator_base {\n+    _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}\n+    _Bit_type _Bit_const_iterator___x;\n+    _Bit_const_iterator(int __y)\n+        : _Bit_iterator_base(&_Bit_const_iterator___x, __y) {}\n+    _Bit_const_iterator(_Bit_iterator __x)\n+        : _Bit_iterator_base(_M_p, _M_offset) {}\n+    void _M_const_cast() {}\n+    void operator*() {}\n+    void operator++() {}\n+    void operator++(int) {}\n+    void operator--() {}\n+  };\n+  class runtime_error {\n+  public:\n+    runtime_error(const string );\n+  };\n+  inline namespace _V2 {\n+  class error_category {\n+    bool operator<(error_category __other) {\n+      less< error_category * >()(this, &__other);\n+    }\n+    bool operator==(error_category ) {}\n+    bool operator!=(error_category ) {}\n+  };\n+  }\n+  struct error_code {\n+    error_code() : _M_cat() {}\n+    error_code(error_category ) : _M_cat() {}\n+    void assign() {}\n+    void clear() {}\n+    int value() {}\n+    error_category category() {}\n+    string message() {}\n+    error_category _M_cat;\n+  };\n+  inline error_code make_error_code() noexcept {}\n+  inline bool operator<(const error_code ,\n+                        const error_code ) noexcept {}\n+  struct error_condition {\n+    error_condition() {}\n+    error_condition(const error_category ) {}\n+    void assign() noexcept {}\n+    void clear() noexcept {}\n+    int value() {}\n+    const error_category &category() {}\n+    string message_M_cat;\n+  };\n+  inline error_condition make_error_condition() noexcept {}\n+  inline bool operator<(const error_condition ,\n+                        const error_condition ) noexcept {}\n+  inline bool operator==(const error_code ,\n+                         const error_code ) noexcept {}\n+  inline bool operator==(const error_code ,\n+                         const error_condition ) noexcept {}\n+  inline bool operator==(const error_condition ,\n+                         const error_code ) noexcept {}\n+  inline bool operator==(const error_condition ,\n+                         const error_condition ) noexcept {}\n+  inline bool operator!=(const error_code ,\n+                         const error_code ) noexcept {}\n+  inline bool operator!=(const error_code ,\n+                         const error_condition ) noexcept {}\n+  inline bool operator!=(const error_condition ,\n+                         const error_code ) noexcept {}\n+  inline bool operator!=(const error_condition ,\n+                         const error_condition ) noexcept {}\n+  class system_error : public runtime_error {\n+  error_code _M_code;\n+\n+  system_error(error_code __ec = error_code())\n+        : runtime_error(__ec.message()) {}\n+    system_error(error_code __ec, const string &__what)\n+        : runtime_error(__ec.message()) {}\n+    system_error(error_code __ec, const char *__what)\n+        : runtime_error((__ec.message())) {}\n+    system_error(const char )\n+        : system_error() {}\n+    system_error(const error_category )\n+        : runtime_error(error_code().message()) {}\n+    system_error(const string &__what)\n+        : runtime_error(error_code().message()) {}\n+    const error_code &code() {}\n+    void operator0() {}\n+  };\n+  enum _Ios_Fmtflags {};\n+  _Ios_Fmtflags operator&(_Ios_Fmtflags __a__b) {}\n+  _Ios_Fmtflags operator|(_Ios_Fmtflags __a,\n+                                           _Ios_Fmtflags __b) {}\n+  _Ios_Fmtflags operator^(_Ios_Fmtflags __a,\n+                                           _Ios_Fmtflags __b) {}\n+  _Ios_Fmtflags operator~(_Ios_Fmtflags __a) {}\n+  _Ios_Fmtflags &operator|=(_Ios_Fmtflags ,\n+                                         _Ios_Fmtflags __b) {}\n+  _Ios_Fmtflags &operator&=(_Ios_Fmtflags ,\n+                                         _Ios_Fmtflags __b) {}\n+  _Ios_Fmtflags &operator^=(_Ios_Fmtflags ,\n+                                         _Ios_Fmtflags __b) {}\n+  enum _Ios_Openmode {\n+    _S_ios_openmode_max };\n+  _Ios_Openmode operator&(_Ios_Openmode __a__b) {}\n+  _Ios_Openmode operator|(_Ios_Openmode __a,\n+                                           _Ios_Openmode __b) {}\n+  _Ios_Openmode operator^(_Ios_Openmode __a,\n+                                           _Ios_Openmode __b) {}\n+  _Ios_Openmode operator~(_Ios_Openmode __a) {}\n+  _Ios_Openmode &operator|=(_Ios_Openmode ,\n+                                         _Ios_Openmode __b) {}\n+  _Ios_Openmode &operator&=(_Ios_Openmode ,\n+                                         _Ios_Openmode __b) {}\n+  _Ios_Openmode &operator^=(_Ios_Openmode ,\n+                                         _Ios_Openmode __b) {}\n+  enum _Ios_Iostate {\n+    _S_ios_iostate_max };\n+  _Ios_Iostate operator&(_Ios_Iostate __a__b) {}\n+  _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) {}\n+  _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) {}\n+  _Ios_Iostate operator~(_Ios_Iostate __a) {}\n+  _Ios_Iostate &operator|=(_Ios_Iostate , _Ios_Iostate __b) {}\n+  _Ios_Iostate &operator&=(_Ios_Iostate , _Ios_Iostate __b) {}\n+  _Ios_Iostate &operator^=(_Ios_Iostate , _Ios_Iostate __b) {}\n+  enum class io_errc;\n+  inline error_code make_error_code(io_errc __e) noexcept {}\n+  inline error_condition make_error_condition_wrap_class_string;\n+static luaL_Reg swig_ClientProfile_methods;\n+static luaL_Reg swig_ClientProfile_meta;\n+static swig_lua_attribute swig_ClientProfile_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_ClientProfile_Sf_SwigStatic_constants;\n+static luaL_Reg swig_ClientProfile_Sf_SwigStatic_methods;\n+static swig_lua_class swig_ClientProfile_Sf_SwigStatic_classes;\n+static int swig_ClientProfile_Sf_SwigStatic;\n+static swig_lua_class swig_ClientProfile_bases;\n+static const char *swig_ClientProfile_base_names;\n+static swig_lua_class _wrap_class_ClientProfile;\n+static int _proxy__wrap_new_Connection0;\n+static swig_lua_attribute swig_Connection_attributes;\n+static luaL_Reg swig_Connection_methods;\n+static luaL_Reg swig_Connection_meta;\n+static swig_lua_attribute swig_Connection_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_Connection_Sf_SwigStatic_constants;\n+static luaL_Reg swig_Connection_Sf_SwigStatic_methods;\n+static swig_lua_class swig_Connection_Sf_SwigStatic_classes;\n+static int swig_Connection_Sf_SwigStatic;\n+static swig_lua_class swig_Connection_bases;\n+static const char swig_Connection_base_names = 0;\n+static swig_lua_class _wrap_class_Connection;\n+static int _proxy__wrap_new_ConnectionPool0;\n+static swig_lua_attribute swig_ConnectionPool_attributes;\n+static luaL_Reg swig_ConnectionPool_methods;\n+static luaL_Reg swig_ConnectionPool_meta;\n+static swig_lua_attribute swig_ConnectionPool_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_ConnectionPool_Sf_SwigStatic_constants;\n+static luaL_Reg swig_ConnectionPool_Sf_SwigStatic_methods;\n+static swig_lua_class swig_ConnectionPool_Sf_SwigStatic_classes;\n+static int swig_ConnectionPool_Sf_SwigStatic;\n+static swig_lua_class *swig_ConnectionPool_bases ;\n+static const char *swig_ConnectionPool_base_names ;\n+static swig_lua_class _wrap_class_ConnectionPool;\n+static int _proxy__wrap_new_Client0;\n+static swig_lua_attribute swig_Client_attributes;\n+static luaL_Reg swig_Client_methods;\n+static luaL_Reg swig_Client_meta;\n+static swig_lua_attribute swig_Client_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_Client_Sf_SwigStatic_constants;\n+static luaL_Reg swig_Client_Sf_SwigStatic_methods;\n+static swig_lua_class swig_Client_Sf_SwigStatic_classes;\n+static int swig_Client_Sf_SwigStatic;\n+static swig_lua_class *swig_Client_bases;\n+static const char *swig_Client_base_names;\n+static swig_lua_class _wrap_class_Client;\n+static int _proxy__wrap_new_PreludeLog0;\n+static swig_lua_attribute swig_PreludeLog_attributes;\n+static luaL_Reg swig_PreludeLog_methods;\n+static luaL_Reg swig_PreludeLog_meta;\n+static swig_lua_attribute swig_PreludeLog_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_PreludeLog_Sf_SwigStatic_constants;\n+static luaL_Reg swig_PreludeLog_Sf_SwigStatic_methods;\n+static swig_lua_class swig_PreludeLog_Sf_SwigStatic_classes;\n+static int swig_PreludeLog_Sf_SwigStatic;\n+static swig_lua_class swig_PreludeLog_bases;\n+static const char *swig_PreludeLog_base_names;\n+static swig_lua_class _wrap_class_PreludeLog;\n+static int _proxy__wrap_new_PreludeError0;\n+static swig_lua_attribute swig_PreludeError_attributes;\n+static luaL_Reg swig_PreludeError_methods;\n+static luaL_Reg swig_PreludeError_meta;\n+static swig_lua_attribute swig_PreludeError_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_PreludeError_Sf_SwigStatic_constants;\n+static luaL_Reg swig_PreludeError_Sf_SwigStatic_methods;\n+static swig_lua_class swig_PreludeError_Sf_SwigStatic_classes;\n+static int swig_PreludeError_Sf_SwigStatic;\n+static swig_lua_class swig_PreludeError_bases;\n+static const char *swig_PreludeError_base_names;\n+static swig_lua_class _wrap_class_PreludeError;\n+static int _proxy__wrap_new_ClientEasy0;\n+static swig_lua_attribute swig_ClientEasy_attributes;\n+static luaL_Reg swig_ClientEasy_methods;\n+static luaL_Reg swig_ClientEasy_meta;\n+static swig_lua_attribute swig_ClientEasy_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_ClientEasy_Sf_SwigStatic_constants;\n+static luaL_Reg swig_ClientEasy_Sf_SwigStatic_methods;\n+static swig_lua_class swig_ClientEasy_Sf_SwigStatic_classes;\n+static int swig_ClientEasy_Sf_SwigStatic;\n+static swig_lua_class *swig_ClientEasy_bases;\n+static const char *swig_ClientEasy_base_names;\n+static swig_lua_class _wrap_class_ClientEasy;\n+static int _proxy__wrap_new_IDMEFCriterion0;\n+static swig_lua_attribute swig_IDMEFCriterion_attributes;\n+static luaL_Reg swig_IDMEFCriterion_methods;\n+static luaL_Reg swig_IDMEFCriterion_meta;\n+static swig_lua_attribute swig_IDMEFCriterion_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEFCriterion_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEFCriterion_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEFCriterion_Sf_SwigStatic_classes;\n+static int swig_IDMEFCriterion_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEFCriterion_bases;\n+static const char *swig_IDMEFCriterion_base_names;\n+static swig_lua_class _wrap_class_IDMEFCriterion;\n+static int _proxy__wrap_new_IDMEFCriteria0;\n+static swig_lua_attribute swig_IDMEFCriteria_attributes;\n+static luaL_Reg swig_IDMEFCriteria_methods;\n+static luaL_Reg swig_IDMEFCriteria_meta;\n+static swig_lua_attribute swig_IDMEFCriteria_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEFCriteria_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEFCriteria_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEFCriteria_Sf_SwigStatic_classes;\n+static int swig_IDMEFCriteria_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEFCriteria_bases;\n+static const char *swig_IDMEFCriteria_base_names;\n+static swig_lua_class _wrap_class_IDMEFCriteria;\n+static int _proxy__wrap_new_IDMEFValue0;\n+static swig_lua_attribute swig_IDMEFValue_attributes;\n+static luaL_Reg swig_IDMEFValue_methods;\n+static luaL_Reg swig_IDMEFValue_meta;\n+static swig_lua_attribute swig_IDMEFValue_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEFValue_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEFValue_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEFValue_Sf_SwigStatic_classes;\n+static int swig_IDMEFValue_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEFValue_bases;\n+static const char *swig_IDMEFValue_base_names;\n+static swig_lua_class _wrap_class_IDMEFValue;\n+static int _proxy__wrap_new_IDMEFPath0;\n+static swig_lua_attribute swig_IDMEFPath_attributes;\n+static luaL_Reg swig_IDMEFPath_methods;\n+static luaL_Reg swig_IDMEFPath_meta;\n+static swig_lua_attribute swig_IDMEFPath_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEFPath_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEFPath_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEFPath_Sf_SwigStatic_classes;\n+static int swig_IDMEFPath_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEFPath_bases;\n+static const char *swig_IDMEFPath_base_names;\n+static swig_lua_class _wrap_class_IDMEFPath;\n+static int _proxy__wrap_new_IDMEFTime0;\n+static swig_lua_attribute swig_IDMEFTime_attributes;\n+static luaL_Reg swig_IDMEFTime_methods;\n+static luaL_Reg swig_IDMEFTime_meta;\n+static swig_lua_attribute swig_IDMEFTime_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEFTime_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEFTime_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEFTime_Sf_SwigStatic_classes;\n+static int swig_IDMEFTime_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEFTime_bases;\n+static const char *swig_IDMEFTime_base_names;\n+static swig_lua_class _wrap_class_IDMEFTime;\n+static int _proxy__wrap_new_IDMEFClass0;\n+static swig_lua_attribute swig_IDMEFClass_attributes;\n+static luaL_Reg swig_IDMEFClass_methods;\n+static luaL_Reg swig_IDMEFClass_meta;\n+static swig_lua_attribute swig_IDMEFClass_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEFClass_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEFClass_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEFClass_Sf_SwigStatic_classes;\n+static int swig_IDMEFClass_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEFClass_bases;\n+static const char *swig_IDMEFClass_base_names;\n+static swig_lua_class _wrap_class_IDMEFClass;\n+static int _proxy__wrap_new_IDMEF0;\n+static swig_lua_attribute swig_IDMEF_attributes;\n+static luaL_Reg swig_IDMEF_methods;\n+static luaL_Reg swig_IDMEF_meta;\n+static swig_lua_attribute swig_IDMEF_Sf_SwigStatic_attributes;\n+static swig_lua_const_info swig_IDMEF_Sf_SwigStatic_constants;\n+static luaL_Reg swig_IDMEF_Sf_SwigStatic_methods;\n+static swig_lua_class swig_IDMEF_Sf_SwigStatic_classes;\n+static int swig_IDMEF_Sf_SwigStatic;\n+static swig_lua_class swig_IDMEF_bases;\n+static const char *swig_IDMEF_base_names;\n+static swig_lua_class _wrap_class_IDMEF;\n+static swig_lua_attribute swig_SwigModule_attributes;\n+static swig_lua_const_info swig_SwigModule_constants;\n+static luaL_Reg swig_SwigModule_methods;\n+static swig_lua_class *swig_SwigModule_classes;\n+static int swig_SwigModule_namespaces;\n+static int swig_SwigModule;\n+}\n+static void *_p_Prelude__ClientTo_p_Prelude__ClientProfile0;"}, {"sha": "72da68322cce27536bf2059799ba979c5457b0e2", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -674,6 +674,17 @@ decl_assembler_name (tree decl)\n   return DECL_ASSEMBLER_NAME_RAW (decl);\n }\n \n+/* The DECL_ASSEMBLER_NAME_RAW of DECL is being explicitly set to NAME\n+   (either of which may be NULL).  Inform the FE, if this changes the\n+   name.  */\n+\n+void\n+overwrite_decl_assembler_name (tree decl, tree name)\n+{\n+  if (DECL_ASSEMBLER_NAME_RAW (decl) != name)\n+    lang_hooks.overwrite_decl_assembler_name (decl, name);\n+}\n+\n /* When the target supports COMDAT groups, this indicates which group the\n    DECL is associated with.  This can be either an IDENTIFIER_NODE or a\n    decl, in which case its DECL_ASSEMBLER_NAME identifies the group.  */"}, {"sha": "0ec092aa8128fa31a52d197284d0e81cfe2c72e9", "filename": "gcc/tree.h", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3682ffcef162363b783eb9ee702debff489fa8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5f3682ffcef162363b783eb9ee702debff489fa8", "patch": "@@ -2528,11 +2528,11 @@ extern void decl_value_expr_insert (tree, tree);\n #define DECL_RTL_SET_P(NODE) \\\n   (HAS_RTL_P (NODE) && DECL_WRTL_CHECK (NODE)->decl_with_rtl.rtl != NULL)\n \n-/* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n-   NODE1, it will not be set for NODE2; this is a lazy copy.  */\n-#define COPY_DECL_RTL(NODE1, NODE2) \\\n-  (DECL_WRTL_CHECK (NODE2)->decl_with_rtl.rtl \\\n-   = DECL_WRTL_CHECK (NODE1)->decl_with_rtl.rtl)\n+/* Copy the RTL from SRC_DECL to DST_DECL.  If the RTL was not set for\n+   SRC_DECL, it will not be set for DST_DECL; this is a lazy copy.  */\n+#define COPY_DECL_RTL(SRC_DECL, DST_DECL) \\\n+  (DECL_WRTL_CHECK (DST_DECL)->decl_with_rtl.rtl \\\n+   = DECL_WRTL_CHECK (SRC_DECL)->decl_with_rtl.rtl)\n \n /* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */\n #define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n@@ -2723,19 +2723,21 @@ extern void decl_value_expr_insert (tree, tree);\n \n /* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n #define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n-  (DECL_ASSEMBLER_NAME_RAW (NODE) = (NAME))\n+  overwrite_decl_assembler_name (NODE, NAME)\n \n-/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if DECL1's\n-   DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n-   the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n-   semantics of using this macro, are different than saying:\n+/* Copy the DECL_ASSEMBLER_NAME from SRC_DECL to DST_DECL.  Note that\n+   if SRC_DECL's DECL_ASSEMBLER_NAME has not yet been set, using this\n+   macro will not cause the DECL_ASSEMBLER_NAME to be set, but will\n+   clear DECL_ASSEMBLER_NAME of DST_DECL, if it was already set.  In\n+   other words, the semantics of using this macro, are different than\n+   saying:\n \n-     SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n+     SET_DECL_ASSEMBLER_NAME(DST_DECL, DECL_ASSEMBLER_NAME (SRC_DECL))\n \n-   which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n+   which will try to set the DECL_ASSEMBLER_NAME for SRC_DECL.  */\n \n-#define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n-  SET_DECL_ASSEMBLER_NAME (DECL2, DECL_ASSEMBLER_NAME_RAW (DECL1))\n+#define COPY_DECL_ASSEMBLER_NAME(SRC_DECL, DST_DECL)\t\t\t\\\n+  SET_DECL_ASSEMBLER_NAME (DST_DECL, DECL_ASSEMBLER_NAME_RAW (SRC_DECL))\n \n /* Records the section name in a section attribute.  Used to pass\n    the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n@@ -3872,6 +3874,7 @@ id_equal (const char *str, const_tree id)\n    || ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))\n \n extern tree decl_assembler_name (tree);\n+extern void overwrite_decl_assembler_name (tree decl, tree name);\n extern tree decl_comdat_group (const_tree);\n extern tree decl_comdat_group_id (const_tree);\n extern const char *decl_section_name (const_tree);"}]}