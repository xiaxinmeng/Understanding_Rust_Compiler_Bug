{"sha": "95935e2db5c45bef5631f51538d1e10d8b5b7524", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU5MzVlMmRiNWM0NWJlZjU2MzFmNTE1MzhkMWUxMGQ4YjViNzUyNA==", "commit": {"author": {"name": "Denis Vlasenko", "email": "vda@port.imtp.ilyichevsk.odessa.ua", "date": "2005-05-06T19:31:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-05-06T19:31:13Z"}, "message": "re PR target/21329 (optimize i386 block copy)\n\n2005-05-06  Denis Vlasenko  <vda@port.imtp.ilyichevsk.odessa.ua>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/21329\n\t* config/i386/i386.c (ix86_expand_movmem): Don't use rep; movsb\n\tfor -Os if (movsl;)*(movsw;)?(movsb;)? sequence is shorter.\n\tDon't use rep; movs{l,q} if the repetition count is really small,\n\tinstead use a sequence of movs{l,q} instructions.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r99330", "tree": {"sha": "a8c4fe03058504b928f111c7c07e133341661d9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c4fe03058504b928f111c7c07e133341661d9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95935e2db5c45bef5631f51538d1e10d8b5b7524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95935e2db5c45bef5631f51538d1e10d8b5b7524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95935e2db5c45bef5631f51538d1e10d8b5b7524", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95935e2db5c45bef5631f51538d1e10d8b5b7524/comments", "author": null, "committer": null, "parents": [{"sha": "2b41c040165ff3e5fe42a491f17b9e8a5475afff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b41c040165ff3e5fe42a491f17b9e8a5475afff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b41c040165ff3e5fe42a491f17b9e8a5475afff"}], "stats": {"total": 63, "additions": 50, "deletions": 13}, "files": [{"sha": "1db6106681a78f0fe7a24a41bddb2517154fc91a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95935e2db5c45bef5631f51538d1e10d8b5b7524/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95935e2db5c45bef5631f51538d1e10d8b5b7524/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95935e2db5c45bef5631f51538d1e10d8b5b7524", "patch": "@@ -1,3 +1,12 @@\n+2005-05-06  Denis Vlasenko  <vda@port.imtp.ilyichevsk.odessa.ua>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/21329\n+\t* config/i386/i386.c (ix86_expand_movmem): Don't use rep; movsb\n+\tfor -Os if (movsl;)*(movsw;)?(movsb;)? sequence is shorter.\n+\tDon't use rep; movs{l,q} if the repetition count is really small,\n+\tinstead use a sequence of movs{l,q} instructions.\n+\n 2005-05-06  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/21380"}, {"sha": "1e8326d970cee080f9a38d41f3786c5db2286ff0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95935e2db5c45bef5631f51538d1e10d8b5b7524/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95935e2db5c45bef5631f51538d1e10d8b5b7524/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=95935e2db5c45bef5631f51538d1e10d8b5b7524", "patch": "@@ -11285,9 +11285,20 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n     src = replace_equiv_address_nv (src, srcreg);\n \n   /* When optimizing for size emit simple rep ; movsb instruction for\n-     counts not divisible by 4.  */\n+     counts not divisible by 4, except when (movsl;)*(movsw;)?(movsb;)?\n+     sequence is shorter than mov{b,l} $count, %{ecx,cl}; rep; movsb.\n+     Sice of (movsl;)*(movsw;)?(movsb;)? sequence is\n+     count / 4 + (count & 3), the other sequence is either 4 or 7 bytes,\n+     but we don't know whether upper 24 (resp. 56) bits of %ecx will be\n+     known to be zero or not.  The rep; movsb sequence causes higher\n+     register preasure though, so take that into account.  */\n \n-  if ((!optimize || optimize_size) && (count == 0 || (count & 0x03)))\n+  if ((!optimize || optimize_size)\n+      && (count == 0\n+\t  || ((count & 0x03)\n+\t      && (!optimize_size\n+\t\t  || count > 5 * 4\n+\t\t  || (count & 3) + count / 4 > 6))))\n     {\n       emit_insn (gen_cld ());\n       countreg = ix86_zero_extend_to_Pmode (count_exp);\n@@ -11313,19 +11324,36 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n       emit_insn (gen_cld ());\n       if (count & ~(size - 1))\n \t{\n-\t  countreg = copy_to_mode_reg (counter_mode,\n-\t\t\t\t       GEN_INT ((count >> (size == 4 ? 2 : 3))\n-\t\t\t\t\t\t& (TARGET_64BIT ? -1 : 0x3fffffff)));\n-\t  countreg = ix86_zero_extend_to_Pmode (countreg);\n+\t  if ((TARGET_SINGLE_STRINGOP || optimize_size) && count < 5 * 4)\n+\t    {\n+\t      enum machine_mode movs_mode = size == 4 ? SImode : DImode;\n+\n+\t      while (offset < (count & ~(size - 1)))\n+\t\t{\n+\t\t  srcmem = adjust_automodify_address_nv (src, movs_mode,\n+\t\t\t\t\t\t\t srcreg, offset);\n+\t\t  dstmem = adjust_automodify_address_nv (dst, movs_mode,\n+\t\t\t\t\t\t\t destreg, offset);\n+\t\t  emit_insn (gen_strmov (destreg, dstmem, srcreg, srcmem));\n+\t\t  offset += size;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      countreg = GEN_INT ((count >> (size == 4 ? 2 : 3))\n+\t\t\t\t  & (TARGET_64BIT ? -1 : 0x3fffffff));\n+\t      countreg = copy_to_mode_reg (counter_mode, countreg);\n+\t      countreg = ix86_zero_extend_to_Pmode (countreg);\n \n-\t  destexp = gen_rtx_ASHIFT (Pmode, countreg,\n-\t\t\t\t    GEN_INT (size == 4 ? 2 : 3));\n-\t  srcexp = gen_rtx_PLUS (Pmode, destexp, srcreg);\n-\t  destexp = gen_rtx_PLUS (Pmode, destexp, destreg);\n+\t      destexp = gen_rtx_ASHIFT (Pmode, countreg,\n+\t\t\t\t\tGEN_INT (size == 4 ? 2 : 3));\n+\t      srcexp = gen_rtx_PLUS (Pmode, destexp, srcreg);\n+\t      destexp = gen_rtx_PLUS (Pmode, destexp, destreg);\n \n-\t  emit_insn (gen_rep_mov (destreg, dst, srcreg, src,\n-\t\t\t\t  countreg, destexp, srcexp));\n-\t  offset = count & ~(size - 1);\n+\t      emit_insn (gen_rep_mov (destreg, dst, srcreg, src,\n+\t\t\t\t      countreg, destexp, srcexp));\n+\t      offset = count & ~(size - 1);\n+\t    }\n \t}\n       if (size == 8 && (count & 0x04))\n \t{"}]}