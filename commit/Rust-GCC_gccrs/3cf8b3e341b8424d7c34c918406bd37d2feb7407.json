{"sha": "3cf8b3e341b8424d7c34c918406bd37d2feb7407", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmOGIzZTM0MWI4NDI0ZDdjMzRjOTE4NDA2YmQzN2QyZmViNzQwNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-05-07T11:17:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-05-07T11:17:00Z"}, "message": "re PR tree-optimization/90316 (large compile time increase in opt / alias stmt walking for Go example)\n\n2019-05-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/90316\n\t* tree-ssa-alias.h (get_continuation_for_phi): Take walking\n\tlimit by reference.\n\t(walk_non_aliased_vuses): Take walking limit argument.\n\t* tree-ssa-alias.c (maybe_skip_until): Take limit and abort\n\twalking if it is reached instead of just counting.\n\t(get_continuation_for_phi): Likewise.\n\t(walk_non_aliased_vuses): Likewise, instead of leaving counter\n\tlimiting to the callback.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_2): Adjust.\n\t(vn_reference_lookup_3): Likewise.\n\t(vn_reference_lookup_pieces): Likewise.\n\t(vn_reference_lookup): Likewise.\n\t* tree-ssa-pre.c (translate_vuse_through_block): Limit walking.\n\t* tree-ssa-scopedtables.c (vuse_eq): Adjust.\n\t(avail_exprs_stack::lookup_avail_expr): Likewise.\n\nFrom-SVN: r270940", "tree": {"sha": "c3079ed3fb4d622158479ef6cb1ccfc0355988ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3079ed3fb4d622158479ef6cb1ccfc0355988ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf8b3e341b8424d7c34c918406bd37d2feb7407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf8b3e341b8424d7c34c918406bd37d2feb7407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf8b3e341b8424d7c34c918406bd37d2feb7407", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf8b3e341b8424d7c34c918406bd37d2feb7407/comments", "author": null, "committer": null, "parents": [{"sha": "bca0a3216deff39ec9e4dcf979fff7f313ca6486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bca0a3216deff39ec9e4dcf979fff7f313ca6486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bca0a3216deff39ec9e4dcf979fff7f313ca6486"}], "stats": {"total": 104, "additions": 61, "deletions": 43}, "files": [{"sha": "20586bfa8494bdc7c0a599ff25cdf1b3809b21c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cf8b3e341b8424d7c34c918406bd37d2feb7407", "patch": "@@ -1,4 +1,23 @@\n-2019-05-03  Jan Hubicka  <hubicka@ucw.cz>\n+2019-05-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/90316\n+\t* tree-ssa-alias.h (get_continuation_for_phi): Take walking\n+\tlimit by reference.\n+\t(walk_non_aliased_vuses): Take walking limit argument.\n+\t* tree-ssa-alias.c (maybe_skip_until): Take limit and abort\n+\twalking if it is reached instead of just counting.\n+\t(get_continuation_for_phi): Likewise.\n+\t(walk_non_aliased_vuses): Likewise, instead of leaving counter\n+\tlimiting to the callback.\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_2): Adjust.\n+\t(vn_reference_lookup_3): Likewise.\n+\t(vn_reference_lookup_pieces): Likewise.\n+\t(vn_reference_lookup): Likewise.\n+\t* tree-ssa-pre.c (translate_vuse_through_block): Limit walking.\n+\t* tree-ssa-scopedtables.c (vuse_eq): Adjust.\n+\t(avail_exprs_stack::lookup_avail_expr): Likewise.\n+\n+2019-05-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa-alias.c (aliasing_component_refs_p): Continue looking\n \tfor comparaible types in the second direction even if first one"}, {"sha": "619cc8991b9a0851072314d806f4583443b0a435", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3cf8b3e341b8424d7c34c918406bd37d2feb7407", "patch": "@@ -2601,7 +2601,7 @@ stmt_kills_ref_p (gimple *stmt, tree ref)\n \n static bool\n maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n-\t\t  ao_ref *ref, tree vuse, unsigned int *cnt, bitmap *visited,\n+\t\t  ao_ref *ref, tree vuse, unsigned int &limit, bitmap *visited,\n \t\t  bool abort_on_visited,\n \t\t  void *(*translate)(ao_ref *, tree, void *, bool *),\n \t\t  void *data)\n@@ -2636,7 +2636,7 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n \t  /* An already visited PHI node ends the walk successfully.  */\n \t  if (bitmap_bit_p (*visited, SSA_NAME_VERSION (PHI_RESULT (def_stmt))))\n \t    return !abort_on_visited;\n-\t  vuse = get_continuation_for_phi (def_stmt, ref, cnt,\n+\t  vuse = get_continuation_for_phi (def_stmt, ref, limit,\n \t\t\t\t\t   visited, abort_on_visited,\n \t\t\t\t\t   translate, data);\n \t  if (!vuse)\n@@ -2648,7 +2648,9 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n       else\n \t{\n \t  /* A clobbering statement or the end of the IL ends it failing.  */\n-\t  ++*cnt;\n+\t  if ((int)limit <= 0)\n+\t    return false;\n+\t  --limit;\n \t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))\n \t    {\n \t      bool disambiguate_only = true;\n@@ -2676,12 +2678,13 @@ maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,\n /* Starting from a PHI node for the virtual operand of the memory reference\n    REF find a continuation virtual operand that allows to continue walking\n    statements dominating PHI skipping only statements that cannot possibly\n-   clobber REF.  Increments *CNT for each alias disambiguation done.\n+   clobber REF.  Decrements LIMIT for each alias disambiguation done\n+   and aborts the walk, returning NULL_TREE if it reaches zero.\n    Returns NULL_TREE if no suitable virtual operand can be found.  */\n \n tree\n get_continuation_for_phi (gimple *phi, ao_ref *ref,\n-\t\t\t  unsigned int *cnt, bitmap *visited,\n+\t\t\t  unsigned int &limit, bitmap *visited,\n \t\t\t  bool abort_on_visited,\n \t\t\t  void *(*translate)(ao_ref *, tree, void *, bool *),\n \t\t\t  void *data)\n@@ -2723,7 +2726,7 @@ get_continuation_for_phi (gimple *phi, ao_ref *ref,\n       arg1 = PHI_ARG_DEF (phi, i);\n       if (arg1 == arg0)\n \t;\n-      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, cnt, visited,\n+      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, limit, visited,\n \t\t\t\t   abort_on_visited,\n \t\t\t\t   /* Do not translate when walking over\n \t\t\t\t      backedges.  */\n@@ -2759,18 +2762,22 @@ get_continuation_for_phi (gimple *phi, ao_ref *ref,\n    implement optimistic value-numbering for example.  Note that the\n    VUSE argument is assumed to be valueized already.\n \n+   LIMIT specifies the number of alias queries we are allowed to do,\n+   the walk stops when it reaches zero and NULL is returned.  LIMIT\n+   is decremented by the number of alias queries (plus adjustments\n+   done by the callbacks) upon return.\n+\n    TODO: Cache the vector of equivalent vuses per ref, vuse pair.  */\n \n void *\n walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n-\t\t\tvoid *(*walker)(ao_ref *, tree, unsigned int, void *),\n+\t\t\tvoid *(*walker)(ao_ref *, tree, void *),\n \t\t\tvoid *(*translate)(ao_ref *, tree, void *, bool *),\n \t\t\ttree (*valueize)(tree),\n-\t\t\tvoid *data)\n+\t\t\tunsigned &limit, void *data)\n {\n   bitmap visited = NULL;\n   void *res;\n-  unsigned int cnt = 0;\n   bool translated = false;\n \n   timevar_push (TV_ALIAS_STMT_WALK);\n@@ -2780,7 +2787,7 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n       gimple *def_stmt;\n \n       /* ???  Do we want to account this to TV_ALIAS_STMT_WALK?  */\n-      res = (*walker) (ref, vuse, cnt, data);\n+      res = (*walker) (ref, vuse, data);\n       /* Abort walk.  */\n       if (res == (void *)-1)\n \t{\n@@ -2804,11 +2811,15 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n       if (gimple_nop_p (def_stmt))\n \tbreak;\n       else if (gimple_code (def_stmt) == GIMPLE_PHI)\n-\tvuse = get_continuation_for_phi (def_stmt, ref, &cnt,\n+\tvuse = get_continuation_for_phi (def_stmt, ref, limit,\n \t\t\t\t\t &visited, translated, translate, data);\n       else\n \t{\n-\t  cnt++;\n+\t  if ((int)limit <= 0)\n+\t    {\n+\t      res = NULL;\n+\t      break;\n+\t    }\n \t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))\n \t    {\n \t      if (!translate)"}, {"sha": "cee844973d9c960733b8093b6e7fa25c2545d333", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=3cf8b3e341b8424d7c34c918406bd37d2feb7407", "patch": "@@ -132,15 +132,13 @@ extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);\n extern bool stmt_kills_ref_p (gimple *, tree);\n extern bool stmt_kills_ref_p (gimple *, ao_ref *);\n extern tree get_continuation_for_phi (gimple *, ao_ref *,\n-\t\t\t\t      unsigned int *, bitmap *, bool,\n+\t\t\t\t      unsigned int &, bitmap *, bool,\n \t\t\t\t      void *(*)(ao_ref *, tree, void *, bool *),\n \t\t\t\t      void *);\n extern void *walk_non_aliased_vuses (ao_ref *, tree,\n-\t\t\t\t     void *(*)(ao_ref *, tree,\n-\t\t\t\t\t       unsigned int, void *),\n+\t\t\t\t     void *(*)(ao_ref *, tree, void *),\n \t\t\t\t     void *(*)(ao_ref *, tree, void *, bool *),\n-\t\t\t\t     tree (*)(tree),\n-\t\t\t\t     void *);\n+\t\t\t\t     tree (*)(tree), unsigned &, void *);\n extern int walk_aliased_vdefs (ao_ref *, tree,\n \t\t\t       bool (*)(ao_ref *, tree, void *),\n \t\t\t       void *, bitmap *,"}, {"sha": "646feb6085f0b07949a9a150039ba06b117a2ff4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=3cf8b3e341b8424d7c34c918406bd37d2feb7407", "patch": "@@ -1151,6 +1151,7 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n   if (gimple_bb (phi) != phiblock)\n     return vuse;\n \n+  unsigned int cnt = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n   use_oracle = ao_ref_init_from_vn_reference (&ref, set, type, operands);\n \n   /* Use the alias-oracle to find either the PHI node in this block,\n@@ -1159,8 +1160,10 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n   if (gimple_code (phi) == GIMPLE_PHI)\n     e = find_edge (block, phiblock);\n   else if (use_oracle)\n-    while (!stmt_may_clobber_ref_p_1 (phi, &ref))\n+    while (cnt > 0\n+\t   && !stmt_may_clobber_ref_p_1 (phi, &ref))\n       {\n+\t--cnt;\n \tvuse = gimple_vuse (phi);\n \tphi = SSA_NAME_DEF_STMT (vuse);\n \tif (gimple_bb (phi) != phiblock)\n@@ -1179,10 +1182,9 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n       if (use_oracle)\n \t{\n \t  bitmap visited = NULL;\n-\t  unsigned int cnt;\n \t  /* Try to find a vuse that dominates this phi node by skipping\n \t     non-clobbering statements.  */\n-\t  vuse = get_continuation_for_phi (phi, &ref, &cnt, &visited, false,\n+\t  vuse = get_continuation_for_phi (phi, &ref, cnt, &visited, false,\n \t\t\t\t\t   NULL, NULL);\n \t  if (visited)\n \t    BITMAP_FREE (visited);"}, {"sha": "219fb9ea175a55302fda3f02bf4783355555ab8d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=3cf8b3e341b8424d7c34c918406bd37d2feb7407", "patch": "@@ -1671,19 +1671,12 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n    with the current VUSE and performs the expression lookup.  */\n \n static void *\n-vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse,\n-\t\t       unsigned int cnt, void *vr_)\n+vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *vr_)\n {\n   vn_reference_t vr = (vn_reference_t)vr_;\n   vn_reference_s **slot;\n   hashval_t hash;\n \n-  /* This bounds the stmt walks we perform on reference lookups\n-     to O(1) instead of O(N) where N is the number of dominating\n-     stores.  */\n-  if (cnt > (unsigned) PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS))\n-    return (void *)-1;\n-\n   if (last_vuse_ptr)\n     *last_vuse_ptr = vuse;\n \n@@ -2023,8 +2016,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t  last_vuse_ptr = NULL;\n \t  tree saved_vuse = vr->vuse;\n \t  hashval_t saved_hashcode = vr->hashcode;\n-\t  void *res = vn_reference_lookup_2 (ref,\n-\t\t\t\t\t     gimple_vuse (def_stmt), 0, vr);\n+\t  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), vr);\n \t  /* Need to restore vr->vuse and vr->hashcode.  */\n \t  vr->vuse = saved_vuse;\n \t  vr->hashcode = saved_hashcode;\n@@ -2671,13 +2663,14 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n       && vr1.vuse)\n     {\n       ao_ref r;\n+      unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n       vn_walk_kind = kind;\n       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))\n \t*vnresult =\n \t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n \t\t\t\t\t\t  vn_reference_lookup_2,\n \t\t\t\t\t\t  vn_reference_lookup_3,\n-\t\t\t\t\t\t  vuse_valueize, &vr1);\n+\t\t\t\t\t\t  vuse_valueize, limit, &vr1);\n       gcc_checking_assert (vr1.operands == shared_lookup_references);\n     }\n \n@@ -2720,6 +2713,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n     {\n       vn_reference_t wvnresult;\n       ao_ref r;\n+      unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n       /* Make sure to use a valueized reference if we valueized anything.\n          Otherwise preserve the full reference for advanced TBAA.  */\n       if (!valuezied_anything\n@@ -2733,7 +2727,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n \t(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n \t\t\t\t\t\tvn_reference_lookup_2,\n \t\t\t\t\t\tvn_reference_lookup_3,\n-\t\t\t\t\t\tvuse_valueize, &vr1);\n+\t\t\t\t\t\tvuse_valueize, limit, &vr1);\n       gcc_checking_assert (vr1.operands == shared_lookup_references);\n       if (wvnresult)\n \t{"}, {"sha": "0614afc3be8dbc520d76014b8fbed79542f11d20", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf8b3e341b8424d7c34c918406bd37d2feb7407/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=3cf8b3e341b8424d7c34c918406bd37d2feb7407", "patch": "@@ -100,19 +100,12 @@ avail_exprs_stack::record_expr (class expr_hash_elt *elt1,\n    the desired memory state.  */\n \n static void *\n-vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n+vuse_eq (ao_ref *, tree vuse1, void *data)\n {\n   tree vuse2 = (tree) data;\n   if (vuse1 == vuse2)\n     return data;\n \n-  /* This bounds the stmt walks we perform on reference lookups\n-     to O(1) instead of O(N) where N is the number of dominating\n-     stores leading to a candidate.  We re-use the SCCVN param\n-     for this as it is basically the same complexity.  */\n-  if (cnt > (unsigned) PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS))\n-    return (void *)-1;\n-\n   return NULL;\n }\n \n@@ -299,13 +292,14 @@ avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n \t up the virtual use-def chain using walk_non_aliased_vuses.\n \t But don't do this when removing expressions from the hash.  */\n       ao_ref ref;\n+      unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n       if (!(vuse1 && vuse2\n \t    && gimple_assign_single_p (stmt)\n \t    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n \t    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),\n \t\tref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)\n-\t    && walk_non_aliased_vuses (&ref, vuse2,\n-\t\t\t\t       vuse_eq, NULL, NULL, vuse1) != NULL))\n+\t    && walk_non_aliased_vuses (&ref, vuse2, vuse_eq, NULL, NULL,\n+\t\t\t\t       limit, vuse1) != NULL))\n \t{\n \t  if (insert)\n \t    {"}]}