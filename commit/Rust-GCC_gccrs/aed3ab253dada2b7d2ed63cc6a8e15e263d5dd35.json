{"sha": "aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVkM2FiMjUzZGFkYTJiN2QyZWQ2M2NjNmE4ZTE1ZTI2M2Q1ZGQzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-27T10:43:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-27T10:43:36Z"}, "message": "openmp: Non-rectangular loop support for non-composite worksharing loops and distribute\n\nThis implements the fallback mentioned in\nhttps://gcc.gnu.org/pipermail/gcc/2020-June/232874.html\nSpecial cases for triangular loops etc. to follow later, also composite\nconstructs not supported yet (need to check the passing of temporaries around)\nand lastprivate might not give the same answers as serial loop if the last\ninnermost body iteration isn't the last one for some of the outer loops\n(that will need to be solved separately together with rectangular loops that have no\ninnermost body iterations, but some of the outer loops actually iterate).\nAlso, simd needs work.\n\n2020-06-27  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-general.h (struct omp_for_data_loop): Add non_rect_referenced\n\tmember, move outer member.\n\t(struct omp_for_data): Add first_nonrect and last_nonrect members.\n\t* omp-general.c (omp_extract_for_data): Initialize first_nonrect,\n\tlast_nonrect and non_rect_referenced members.\n\t* omp-expand.c (expand_omp_for_init_counts): Handle non-rectangular\n\tloops.\n\t(expand_omp_for_init_vars): Add nonrect_bounds parameter.  Handle\n\tnon-rectangular loops.\n\t(extract_omp_for_update_vars): Likewise.\n\t(expand_omp_for_generic, expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk, expand_omp_simd,\n\texpand_omp_taskloop_for_outer, expand_omp_taskloop_for_inner): Adjust\n\texpand_omp_for_init_vars and extract_omp_for_update_vars callers.\n\t(expand_omp_for): Don't sorry on non-composite worksharing-loop or\n\tdistribute.\n\n\t* testsuite/libgomp.c/loop-17.c: New test.\n\t* testsuite/libgomp.c/loop-18.c: New test.", "tree": {"sha": "3fd34073f92ce78c1c3031fee739b8b0d0aa7f75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd34073f92ce78c1c3031fee739b8b0d0aa7f75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37995960984ea2222346dd9d168d332cd6f7adf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37995960984ea2222346dd9d168d332cd6f7adf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37995960984ea2222346dd9d168d332cd6f7adf0"}], "stats": {"total": 1163, "additions": 1116, "deletions": 47}, "files": [{"sha": "0f07e51f7e8141ea6944ad1bc609cfd940fed5df", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 663, "deletions": 45, "changes": 708, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "patch": "@@ -1734,7 +1734,39 @@ expand_oacc_collapse_vars (const struct omp_for_data *fd, bool inner,\n \tcount = 0;\n    and set ZERO_ITER_BB to that bb.  If this isn't the outermost\n    of the combined loop constructs, just initialize COUNTS array\n-   from the _looptemp_ clauses.  */\n+   from the _looptemp_ clauses.  For loop nests with non-rectangular\n+   loops, do this only for the rectangular loops.  Then pick\n+   the loops which reference outer vars in their bound expressions\n+   and the loops which they refer to and for this sub-nest compute\n+   number of iterations.  For triangular loops use Faulhaber's formula\n+   (TBD.), otherwise as a fallback, compute by iterating the loops.\n+   If e.g. the sub-nest is\n+\tfor (I = N11; I COND1 N12; I += STEP1)\n+\tfor (J = M21 * I + N21; J COND2 M22 * I + N22; J += STEP2)\n+\tfor (K = M31 * J + N31; K COND3 M32 * J + N32; K += STEP3)\n+   do:\n+\tCOUNT = 0;\n+\tfor (tmpi = N11; tmpi COND1 N12; tmpi += STEP1)\n+\tfor (tmpj = M21 * tmpi + N21;\n+\t     tmpj COND2 M22 * tmpi + N22; tmpj += STEP2)\n+\t  {\n+\t    int tmpk1 = M31 * tmpj + N31;\n+\t    int tmpk2 = M32 * tmpj + N32;\n+\t    if (tmpk1 COND3 tmpk2)\n+\t      {\n+\t\tif (COND3 is <)\n+\t\t  adj = STEP3 - 1;\n+\t\telse\n+\t\t  adj = STEP3 + 1;\n+\t\tCOUNT += (adj + tmpk2 - tmpk1) / STEP3;\n+\t      }\n+\t  }\n+   and finally multiply the counts of the rectangular loops not\n+   in the sub-nest with COUNT.  Also, as counts[fd->last_nonrect]\n+   store number of iterations of the loops from fd->first_nonrect\n+   to fd->last_nonrect inclusive, i.e. the above COUNT multiplied\n+   by the counts of rectangular loops not referenced in any non-rectangular\n+   loops sandwitched in between those.  */\n \n /* NOTE: It *could* be better to moosh all of the BBs together,\n    creating one larger BB with all the computation and the unexpected\n@@ -1813,12 +1845,23 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t  break;\n \t}\n     }\n+  bool rect_count_seen = false;\n   for (i = 0; i < (fd->ordered ? fd->ordered : fd->collapse); i++)\n     {\n       tree itype = TREE_TYPE (fd->loops[i].v);\n \n       if (i >= fd->collapse && counts[i])\n \tcontinue;\n+      if (fd->non_rect)\n+\t{\n+\t  /* Skip loops that use outer iterators in their expressions\n+\t     during this phase.  */\n+\t  if (fd->loops[i].m1 || fd->loops[i].m2)\n+\t    {\n+\t      counts[i] = build_zero_cst (type);\n+\t      continue;\n+\t    }\n+\t}\n       if ((SSA_VAR_P (fd->loop.n2) || i >= fd->collapse)\n \t  && ((t = fold_binary (fd->loops[i].cond_code, boolean_type_node,\n \t\t\t\tfold_convert (itype, fd->loops[i].n1),\n@@ -1914,13 +1957,197 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t}\n       if (SSA_VAR_P (fd->loop.n2) && i < fd->collapse)\n \t{\n-\t  if (i == 0)\n-\t    t = counts[0];\n+\t  if (fd->non_rect && i >= fd->first_nonrect && i <= fd->last_nonrect)\n+\t    continue;\n+\t  if (!rect_count_seen)\n+\t    {\n+\t      t = counts[i];\n+\t      rect_count_seen = true;\n+\t    }\n \t  else\n \t    t = fold_build2 (MULT_EXPR, type, fd->loop.n2, counts[i]);\n \t  expand_omp_build_assign (gsi, fd->loop.n2, t);\n \t}\n     }\n+  if (fd->non_rect && SSA_VAR_P (fd->loop.n2))\n+    {\n+      gcc_assert (fd->last_nonrect != -1);\n+\n+      /* Fallback implementation.  Evaluate the loops with m1/m2\n+\t non-NULL as well as their outer loops at runtime using temporaries\n+\t instead of the original iteration variables, and in the\n+\t body just bump the counter.  */\n+      counts[fd->last_nonrect] = create_tmp_reg (type, \".count\");\n+      expand_omp_build_assign (gsi, counts[fd->last_nonrect],\n+\t\t\t       build_zero_cst (type));\n+      gimple_stmt_iterator gsi2 = *gsi;\n+      gsi_prev (&gsi2);\n+      e = split_block (entry_bb, gsi_stmt (gsi2));\n+      e = split_block (e->dest, (gimple *) NULL);\n+      basic_block cur_bb = e->src;\n+      basic_block next_bb = e->dest;\n+      entry_bb = e->dest;\n+      *gsi = gsi_after_labels (entry_bb);\n+\n+      tree *vs = XALLOCAVEC (tree, fd->last_nonrect);\n+      memset (vs, 0, fd->last_nonrect * sizeof (tree));\n+\n+      for (i = 0; i <= fd->last_nonrect; i++)\n+\t{\n+\t  if (fd->loops[i].m1 == NULL_TREE\n+\t      && fd->loops[i].m2 == NULL_TREE\n+\t      && !fd->loops[i].non_rect_referenced)\n+\t    continue;\n+\n+\t  tree itype = TREE_TYPE (fd->loops[i].v);\n+\n+\t  gsi2 = gsi_after_labels (cur_bb);\n+\t  tree n1, n2;\n+\t  t = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n+\t  if (fd->loops[i].m1)\n+\t    {\n+\t      n1 = fold_convert (itype, unshare_expr (fd->loops[i].m1));\n+\t      n1 = fold_build2 (MULT_EXPR, itype, vs[i - fd->loops[i].outer],\n+\t\t\t\tn1);\n+\t      n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n+\t    }\n+\t  else\n+\t    n1 = t;\n+\t  n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n+\t\t\t\t\t true, GSI_SAME_STMT);\n+\t  if (i < fd->last_nonrect)\n+\t    {\n+\t      vs[i] = create_tmp_reg (itype, \".it\");\n+\t      expand_omp_build_assign (&gsi2, vs[i], n1);\n+\t    }\n+\t  t = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n+\t  if (fd->loops[i].m2)\n+\t    {\n+\t      n2 = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n+\t      n2 = fold_build2 (MULT_EXPR, itype, vs[i - fd->loops[i].outer],\n+\t\t\t\tn2);\n+\t      n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n+\t    }\n+\t  else\n+\t    n2 = t;\n+\t  n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n+\t\t\t\t\t true, GSI_SAME_STMT);\n+\t  if (i == fd->last_nonrect)\n+\t    {\n+\t      gcond *cond_stmt\n+\t\t= gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t     NULL_TREE, NULL_TREE);\n+\t      gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t      e = split_block (cur_bb, cond_stmt);\n+\t      e->flags = EDGE_TRUE_VALUE;\n+\t      ne = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n+\t      e->probability = profile_probability::likely ().guessed ();\n+\t      ne->probability = e->probability.invert ();\n+\t      gsi2 = gsi_after_labels (e->dest);\n+\n+\t      t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n+\t\t\t\t\t ? -1 : 1));\n+\t      t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t       fold_convert (itype, fd->loops[i].step), t);\n+\t      t = fold_build2 (PLUS_EXPR, itype, t, n2);\n+\t      t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+\t      tree step = fold_convert (itype, fd->loops[i].step);\n+\t      if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n+\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t\t fold_build1 (NEGATE_EXPR, itype, step));\n+\t      else\n+\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t      t = fold_convert (type, t);\n+\t      t = fold_build2 (PLUS_EXPR, type, counts[fd->last_nonrect], t);\n+\t      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t      expand_omp_build_assign (&gsi2, counts[fd->last_nonrect], t);\n+\t      e = make_edge (e->dest, next_bb, EDGE_FALLTHRU);\n+\t      set_immediate_dominator (CDI_DOMINATORS, next_bb, cur_bb);\n+\t      break;\n+\t    }\n+\t  e = split_block (cur_bb, last_stmt (cur_bb));\n+\n+\t  basic_block new_cur_bb = create_empty_bb (cur_bb);\n+\t  add_bb_to_loop (new_cur_bb, cur_bb->loop_father);\n+\n+\t  gsi2 = gsi_after_labels (e->dest);\n+\t  tree step = fold_convert (itype, unshare_expr (fd->loops[i].step));\n+\t  t = fold_build2 (PLUS_EXPR, itype, vs[i], step);\n+\t  t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t  expand_omp_build_assign (&gsi2, vs[i], t);\n+\n+\t  ne = split_block (e->dest, last_stmt (e->dest));\n+\t  gsi2 = gsi_after_labels (ne->dest);\n+\n+\t  gcond *cond_stmt\n+\t    = gimple_build_cond (fd->loops[i].cond_code, vs[i], n2,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t  edge e3, e4;\n+\t  if (next_bb == entry_bb)\n+\t    {\n+\t      e3 = find_edge (ne->dest, next_bb);\n+\t      e3->flags = EDGE_FALSE_VALUE;\n+\t    }\n+\t  else\n+\t    e3 = make_edge (ne->dest, next_bb, EDGE_FALSE_VALUE);\n+\t  e4 = make_edge (ne->dest, new_cur_bb, EDGE_TRUE_VALUE);\n+\t  e4->probability = profile_probability::likely ().guessed ();\n+\t  e3->probability = e4->probability.invert ();\n+\t  basic_block esrc = e->src;\n+\t  make_edge (e->src, ne->dest, EDGE_FALLTHRU);\n+\t  cur_bb = new_cur_bb;\n+\t  basic_block latch_bb = next_bb;\n+\t  next_bb = e->dest;\n+\t  remove_edge (e);\n+\t  set_immediate_dominator (CDI_DOMINATORS, ne->dest, esrc);\n+\t  set_immediate_dominator (CDI_DOMINATORS, latch_bb, ne->dest);\n+\t  set_immediate_dominator (CDI_DOMINATORS, cur_bb, ne->dest);\n+\t}\n+      t = NULL_TREE;\n+      for (i = fd->first_nonrect; i < fd->last_nonrect; i++)\n+\tif (!fd->loops[i].non_rect_referenced\n+\t    && fd->loops[i].m1 == NULL_TREE\n+\t    && fd->loops[i].m2 == NULL_TREE)\n+\t  {\n+\t    if (t == NULL_TREE)\n+\t      t = counts[i];\n+\t    else\n+\t      t = fold_build2 (MULT_EXPR, type, t, counts[i]);\n+\t  }\n+      if (t)\n+\t{\n+\t  t = fold_build2 (MULT_EXPR, type, counts[fd->last_nonrect], t);\n+\t  expand_omp_build_assign (gsi, counts[fd->last_nonrect], t);\n+\t}\n+      if (!rect_count_seen)\n+\tt = counts[fd->last_nonrect];\n+      else\n+\tt = fold_build2 (MULT_EXPR, type, fd->loop.n2,\n+\t\t\t counts[fd->last_nonrect]);\n+      expand_omp_build_assign (gsi, fd->loop.n2, t);\n+    }\n+  else if (fd->non_rect)\n+    {\n+      tree t = fd->loop.n2;\n+      gcc_assert (TREE_CODE (t) == INTEGER_CST);\n+      int non_rect_referenced = 0, non_rect = 0;\n+      for (i = 0; i < fd->collapse; i++)\n+\t{\n+\t  if ((i < fd->first_nonrect || fd->last_nonrect)\n+\t      && !integer_zerop (counts[i]))\n+\t    t = fold_build2 (TRUNC_DIV_EXPR, type, t, counts[i]);\n+\t  if (fd->loops[i].non_rect_referenced)\n+\t    non_rect_referenced++;\n+\t  if (fd->loops[i].m1 || fd->loops[i].m2)\n+\t    non_rect++;\n+\t}\n+      gcc_assert (non_rect == 1 && non_rect_referenced == 1);\n+      counts[fd->last_nonrect] = t;\n+    }\n }\n \n /* Helper function for expand_omp_{for_*,simd}.  Generate code like:\n@@ -1933,11 +2160,43 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n    if this loop doesn't have an inner loop construct combined with it.\n    If it does have an inner loop construct combined with it and the\n    iteration count isn't known constant, store values from counts array\n-   into its _looptemp_ temporaries instead.  */\n+   into its _looptemp_ temporaries instead.\n+   For non-rectangular loops (between fd->first_nonrect and fd->last_nonrect\n+   inclusive), use the count of all those loops together, and either\n+   find quadratic etc. equation roots (TBD), or as a fallback, do:\n+\tCOUNT = 0;\n+\tfor (tmpi = N11; tmpi COND1 N12; tmpi += STEP1)\n+\tfor (tmpj = M21 * tmpi + N21;\n+\t     tmpj COND2 M22 * tmpi + N22; tmpj += STEP2)\n+\t  {\n+\t    int tmpk1 = M31 * tmpj + N31;\n+\t    int tmpk2 = M32 * tmpj + N32;\n+\t    if (tmpk1 COND3 tmpk2)\n+\t      {\n+\t\tif (COND3 is <)\n+\t\t  adj = STEP3 - 1;\n+\t\telse\n+\t\t  adj = STEP3 + 1;\n+\t\tint temp = (adj + tmpk2 - tmpk1) / STEP3;\n+\t\tif (COUNT + temp > T)\n+\t\t  {\n+\t\t    V1 = tmpi;\n+\t\t    V2 = tmpj;\n+\t\t    V3 = tmpk1 + (T - COUNT) * STEP3;\n+\t\t    goto done;\n+\t\t  }\n+\t\telse\n+\t\t  COUNT += temp;\n+\t      }\n+\t  }\n+\tdone:;\n+   but for optional innermost or outermost rectangular loops that aren't\n+   referenced by other loop expressions keep doing the division/modulo.  */\n \n static void\n expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n-\t\t\t  tree *counts, gimple *inner_stmt, tree startvar)\n+\t\t\t  tree *counts, tree *nonrect_bounds,\n+\t\t\t  gimple *inner_stmt, tree startvar)\n {\n   int i;\n   if (gimple_omp_for_combined_p (fd->for_stmt))\n@@ -1984,33 +2243,266 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n       itype = vtype;\n       if (POINTER_TYPE_P (vtype))\n \titype = signed_type_for (vtype);\n-      if (i != 0)\n+      if (i != 0 && (i != fd->last_nonrect || fd->first_nonrect))\n \tt = fold_build2 (TRUNC_MOD_EXPR, type, tem, counts[i]);\n       else\n \tt = tem;\n-      t = fold_convert (itype, t);\n-      t = fold_build2 (MULT_EXPR, itype, t,\n-\t\t       fold_convert (itype, fd->loops[i].step));\n-      if (POINTER_TYPE_P (vtype))\n-\tt = fold_build_pointer_plus (fd->loops[i].n1, t);\n+      if (i == fd->last_nonrect)\n+\t{\n+\t  /* Fallback implementation.  Evaluate the loops in between\n+\t     (inclusive) fd->first_nonrect and fd->last_nonrect at\n+\t     runtime unsing temporaries instead of the original iteration\n+\t     variables, in the body just bump the counter and compare\n+\t     with the desired value.  */\n+\t  t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE,\n+\t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n+\t  tree stopval = t;\n+\t  tree idx = create_tmp_reg (type, \".count\");\n+\t  expand_omp_build_assign (gsi, idx,\n+\t\t\t\t   build_zero_cst (type), true);\n+\t  gimple_stmt_iterator gsi2 = *gsi;\n+\t  basic_block entry_bb = gsi_bb (gsi2);\n+\t  edge e = split_block (entry_bb, gsi_stmt (gsi2));\n+\t  e = split_block (e->dest, (gimple *) NULL);\n+\t  basic_block dom_bb = NULL;\n+\t  basic_block cur_bb = e->src;\n+\t  basic_block next_bb = e->dest;\n+\t  entry_bb = e->dest;\n+\t  *gsi = gsi_after_labels (entry_bb);\n+\n+\t  tree *vs = XALLOCAVEC (tree, fd->last_nonrect);\n+\t  tree n1 = NULL_TREE, n2 = NULL_TREE;\n+\t  memset (vs, 0, fd->last_nonrect * sizeof (tree));\n+\n+\t  for (int j = fd->first_nonrect; j <= fd->last_nonrect; j++)\n+\t    {\n+\t      tree itype = TREE_TYPE (fd->loops[j].v);\n+\t      bool rect_p = (fd->loops[j].m1 == NULL_TREE\n+\t\t\t     && fd->loops[j].m2 == NULL_TREE\n+\t\t\t     && !fd->loops[j].non_rect_referenced);\n+\t      gsi2 = gsi_after_labels (cur_bb);\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[j].n1));\n+\t      if (fd->loops[j].m1)\n+\t\t{\n+\t\t  n1 = fold_convert (itype, unshare_expr (fd->loops[j].m1));\n+\t\t  n1 = fold_build2 (MULT_EXPR, itype,\n+\t\t\t\t    vs[j - fd->loops[j].outer], n1);\n+\t\t  n1 = fold_build2 (PLUS_EXPR, itype, n1, t);\n+\t\t}\n+\t      else if (rect_p)\n+\t\tn1 = build_zero_cst (type);\n+\t      else\n+\t\tn1 = t;\n+\t      n1 = force_gimple_operand_gsi (&gsi2, n1, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      if (j < fd->last_nonrect)\n+\t\t{\n+\t\t  vs[j] = create_tmp_reg (rect_p ? type : itype, \".it\");\n+\t\t  expand_omp_build_assign (&gsi2, vs[j], n1);\n+\t\t}\n+\t      t = fold_convert (itype, unshare_expr (fd->loops[j].n2));\n+\t      if (fd->loops[j].m2)\n+\t\t{\n+\t\t  n2 = fold_convert (itype, unshare_expr (fd->loops[j].m2));\n+\t\t  n2 = fold_build2 (MULT_EXPR, itype,\n+\t\t\t\t    vs[j - fd->loops[j].outer], n2);\n+\t\t  n2 = fold_build2 (PLUS_EXPR, itype, n2, t);\n+\t\t}\n+\t      else if (rect_p)\n+\t\tn2 = counts[j];\n+\t      else\n+\t\tn2 = t;\n+\t      n2 = force_gimple_operand_gsi (&gsi2, n2, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      if (j == fd->last_nonrect)\n+\t\t{\n+\t\t  gcond *cond_stmt\n+\t\t    = gimple_build_cond (fd->loops[j].cond_code, n1, n2,\n+\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t\t  e = split_block (cur_bb, cond_stmt);\n+\t\t  e->flags = EDGE_TRUE_VALUE;\n+\t\t  edge ne = make_edge (cur_bb, next_bb, EDGE_FALSE_VALUE);\n+\t\t  e->probability = profile_probability::likely ().guessed ();\n+\t\t  ne->probability = e->probability.invert ();\n+\t\t  gsi2 = gsi_after_labels (e->dest);\n+\n+\t\t  t = build_int_cst (itype, (fd->loops[j].cond_code == LT_EXPR\n+\t\t\t\t\t     ? -1 : 1));\n+\t\t  t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t\t   fold_convert (itype, fd->loops[j].step), t);\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, t, n2);\n+\t\t  t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+\t\t  tree step = fold_convert (itype, fd->loops[j].step);\n+\t\t  if (TYPE_UNSIGNED (itype)\n+\t\t      && fd->loops[j].cond_code == GT_EXPR)\n+\t\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t\t     fold_build1 (NEGATE_EXPR, itype, step));\n+\t\t  else\n+\t\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t\t  t = fold_convert (type, t);\n+\t\t  t = fold_build2 (PLUS_EXPR, type, idx, t);\n+\t\t  t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t\t  e = make_edge (e->dest, next_bb, EDGE_FALLTHRU);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, next_bb, cur_bb);\n+\t\t  cond_stmt\n+\t\t    = gimple_build_cond (LE_EXPR, t, stopval, NULL_TREE,\n+\t\t\t\t\t NULL_TREE);\n+\t\t  gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t\t  e = split_block (gsi_bb (gsi2), cond_stmt);\n+\t\t  e->flags = EDGE_TRUE_VALUE;\n+\t\t  e->probability = profile_probability::likely ().guessed ();\n+\t\t  ne = make_edge (e->src, entry_bb, EDGE_FALSE_VALUE);\n+\t\t  ne->probability = e->probability.invert ();\n+\t\t  gsi2 = gsi_after_labels (e->dest);\n+\t\t  expand_omp_build_assign (&gsi2, idx, t);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, entry_bb, dom_bb);\n+\t\t  break;\n+\t\t}\n+\t      e = split_block (cur_bb, last_stmt (cur_bb));\n+\n+\t      basic_block new_cur_bb = create_empty_bb (cur_bb);\n+\t      add_bb_to_loop (new_cur_bb, cur_bb->loop_father);\n+\n+\t      gsi2 = gsi_after_labels (e->dest);\n+\t      if (rect_p)\n+\t\tt = fold_build2 (PLUS_EXPR, type, vs[j],\n+\t\t\t\t build_one_cst (type));\n+\t      else\n+\t\t{\n+\t\t  tree step\n+\t\t    = fold_convert (itype, unshare_expr (fd->loops[j].step));\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, vs[j], step);\n+\t\t}\n+\t      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t      expand_omp_build_assign (&gsi2, vs[j], t);\n+\n+\t      edge ne = split_block (e->dest, last_stmt (e->dest));\n+\t      gsi2 = gsi_after_labels (ne->dest);\n+\n+\t      gcond *cond_stmt;\n+\t      if (next_bb == entry_bb)\n+\t\t/* No need to actually check the outermost condition.  */\n+\t\tcond_stmt\n+\t\t  = gimple_build_cond (EQ_EXPR, boolean_true_node,\n+\t\t\t\t       boolean_true_node,\n+\t\t\t\t       NULL_TREE, NULL_TREE);\n+\t      else\n+\t\tcond_stmt\n+\t\t  = gimple_build_cond (rect_p ? LT_EXPR\n+\t\t\t\t\t      : fd->loops[j].cond_code,\n+\t\t\t\t       vs[j], n2, NULL_TREE, NULL_TREE);\n+\t      gsi_insert_before (&gsi2, cond_stmt, GSI_SAME_STMT);\n+\t      edge e3, e4;\n+\t      if (next_bb == entry_bb)\n+\t\t{\n+\t\t  e3 = find_edge (ne->dest, next_bb);\n+\t\t  e3->flags = EDGE_FALSE_VALUE;\n+\t\t  dom_bb = ne->dest;\n+\t\t}\n+\t      else\n+\t\te3 = make_edge (ne->dest, next_bb, EDGE_FALSE_VALUE);\n+\t      e4 = make_edge (ne->dest, new_cur_bb, EDGE_TRUE_VALUE);\n+\t      e4->probability = profile_probability::likely ().guessed ();\n+\t      e3->probability = e4->probability.invert ();\n+\t      basic_block esrc = e->src;\n+\t      make_edge (e->src, ne->dest, EDGE_FALLTHRU);\n+\t      cur_bb = new_cur_bb;\n+\t      basic_block latch_bb = next_bb;\n+\t      next_bb = e->dest;\n+\t      remove_edge (e);\n+\t      set_immediate_dominator (CDI_DOMINATORS, ne->dest, esrc);\n+\t      set_immediate_dominator (CDI_DOMINATORS, latch_bb, ne->dest);\n+\t      set_immediate_dominator (CDI_DOMINATORS, cur_bb, ne->dest);\n+\t    }\n+\t  for (int j = fd->last_nonrect; j >= fd->first_nonrect; j--)\n+\t    {\n+\t      tree itype = TREE_TYPE (fd->loops[j].v);\n+\t      bool rect_p = (fd->loops[j].m1 == NULL_TREE\n+\t\t\t     && fd->loops[j].m2 == NULL_TREE\n+\t\t\t     && !fd->loops[j].non_rect_referenced);\n+\t      if (j == fd->last_nonrect)\n+\t\t{\n+\t\t  t = fold_build2 (MINUS_EXPR, type, stopval, idx);\n+\t\t  t = fold_convert (itype, t);\n+\t\t  tree t2\n+\t\t    = fold_convert (itype, unshare_expr (fd->loops[j].step));\n+\t\t  t = fold_build2 (MULT_EXPR, itype, t, t2);\n+\t\t  t = fold_build2 (PLUS_EXPR, itype, n1, t);\n+\t\t}\n+\t      else if (rect_p)\n+\t\t{\n+\t\t  t = fold_convert (itype, vs[j]);\n+\t\t  t = fold_build2 (MULT_EXPR, itype, t,\n+\t\t\t\t   fold_convert (itype, fd->loops[j].step));\n+\t\t  if (POINTER_TYPE_P (vtype))\n+\t\t    t = fold_build_pointer_plus (fd->loops[j].n1, t);\n+\t\t  else\n+\t\t    t = fold_build2 (PLUS_EXPR, itype, fd->loops[j].n1, t);\n+\t\t}\n+\t      else\n+\t\tt = vs[j];\n+\t      t = force_gimple_operand_gsi (gsi, t, false,\n+\t\t\t\t\t    NULL_TREE, true,\n+\t\t\t\t\t    GSI_SAME_STMT);\n+\t      stmt = gimple_build_assign (fd->loops[j].v, t);\n+\t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\t    }\n+\t  if (gsi_end_p (*gsi))\n+\t    *gsi = gsi_last_bb (gsi_bb (*gsi));\n+\t  else\n+\t    gsi_prev (gsi);\n+\t}\n       else\n-\tt = fold_build2 (PLUS_EXPR, itype, fd->loops[i].n1, t);\n-      t = force_gimple_operand_gsi (gsi, t,\n-\t\t\t\t    DECL_P (fd->loops[i].v)\n-\t\t\t\t    && TREE_ADDRESSABLE (fd->loops[i].v),\n-\t\t\t\t    NULL_TREE, false,\n-\t\t\t\t    GSI_CONTINUE_LINKING);\n-      stmt = gimple_build_assign (fd->loops[i].v, t);\n-      gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n-      if (i != 0)\n+\t{\n+\t  t = fold_convert (itype, t);\n+\t  t = fold_build2 (MULT_EXPR, itype, t,\n+\t\t\t   fold_convert (itype, fd->loops[i].step));\n+\t  if (POINTER_TYPE_P (vtype))\n+\t    t = fold_build_pointer_plus (fd->loops[i].n1, t);\n+\t  else\n+\t    t = fold_build2 (PLUS_EXPR, itype, fd->loops[i].n1, t);\n+\t  t = force_gimple_operand_gsi (gsi, t,\n+\t\t\t\t\tDECL_P (fd->loops[i].v)\n+\t\t\t\t\t&& TREE_ADDRESSABLE (fd->loops[i].v),\n+\t\t\t\t\tNULL_TREE, false,\n+\t\t\t\t\tGSI_CONTINUE_LINKING);\n+\t  stmt = gimple_build_assign (fd->loops[i].v, t);\n+\t  gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n+\t}\n+      if (i != 0 && (i != fd->last_nonrect || fd->first_nonrect))\n \t{\n \t  t = fold_build2 (TRUNC_DIV_EXPR, type, tem, counts[i]);\n \t  t = force_gimple_operand_gsi (gsi, t, false, NULL_TREE,\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n \t  stmt = gimple_build_assign (tem, t);\n \t  gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n \t}\n+      if (i == fd->last_nonrect)\n+\ti = fd->first_nonrect;\n     }\n+  if (fd->non_rect)\n+    for (i = 0; i <= fd->last_nonrect; i++)\n+      if (fd->loops[i].m2)\n+\t{\n+\t  tree itype = TREE_TYPE (fd->loops[i].v);\n+\n+\t  tree t = fold_convert (itype, unshare_expr (fd->loops[i].m2));\n+\t  t = fold_build2 (MULT_EXPR, itype,\n+\t\t\t   fd->loops[i - fd->loops[i].outer].v, t);\n+\t  t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t   fold_convert (itype,\n+\t\t\t\t\t unshare_expr (fd->loops[i].n2)));\n+\t  nonrect_bounds[i] = create_tmp_reg (itype, \".bound\");\n+\t  t = force_gimple_operand_gsi (gsi, t, false,\n+\t\t\t\t\tNULL_TREE, false,\n+\t\t\t\t\tGSI_CONTINUE_LINKING);\n+\t  stmt = gimple_build_assign (nonrect_bounds[i], t);\n+\t  gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n+\t}\n }\n \n /* Helper function for expand_omp_for_*.  Generate code like:\n@@ -2024,11 +2516,38 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n     L12:\n \tV2 = N21;\n \tV1 += STEP1;\n-\tgoto BODY_BB;  */\n+\tgoto BODY_BB;\n+   For non-rectangular loops, use temporaries stored in nonrect_bounds\n+   for the upper bounds if M?2 multiplier is present.  Given e.g.\n+   for (V1 = N11; V1 cond1 N12; V1 += STEP1)\n+   for (V2 = N21; V2 cond2 N22; V2 += STEP2)\n+   for (V3 = N31; V3 cond3 N32; V3 += STEP3)\n+   for (V4 = N41 + M41 * V2; V4 cond4 N42 + M42 * V2; V4 += STEP4)\n+   do:\n+    L10:\n+\tV4 += STEP4;\n+\tif (V4 cond4 NONRECT_BOUND4) goto BODY_BB; else goto L11;\n+    L11:\n+\tV4 = N41 + M41 * V2; // This can be left out if the loop\n+\t\t\t     // refers to the immediate parent loop\n+\tV3 += STEP3;\n+\tif (V3 cond3 N32) goto BODY_BB; else goto L12;\n+    L12:\n+\tV3 = N31;\n+\tV2 += STEP2;\n+\tif (V2 cond2 N22) goto L120; else goto L13;\n+    L120:\n+\tV4 = N41 + M41 * V2;\n+\tNONRECT_BOUND4 = N42 + M42 * V2;\n+\tif (V4 cond4 NONRECT_BOUND4) goto BODY_BB; else goto L12;\n+    L13:\n+\tV2 = N21;\n+\tV1 += STEP1;\n+\tgoto L120;  */\n \n static basic_block\n-extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n-\t\t\t     basic_block body_bb)\n+extract_omp_for_update_vars (struct omp_for_data *fd, tree *nonrect_bounds,\n+\t\t\t     basic_block cont_bb, basic_block body_bb)\n {\n   basic_block last_bb, bb, collapse_bb = NULL;\n   int i;\n@@ -2049,17 +2568,28 @@ extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n       if (i < fd->collapse - 1)\n \t{\n \t  e = make_edge (last_bb, bb, EDGE_FALSE_VALUE);\n-\t  e->probability = profile_probability::guessed_always ().apply_scale (1, 8);\n+\t  e->probability\n+\t    = profile_probability::guessed_always ().apply_scale (1, 8);\n \n-\t  t = fd->loops[i + 1].n1;\n-\t  t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\t\tDECL_P (fd->loops[i + 1].v)\n-\t\t\t\t\t&& TREE_ADDRESSABLE (fd->loops[i\n-\t\t\t\t\t\t\t\t       + 1].v),\n-\t\t\t\t\tNULL_TREE, false,\n-\t\t\t\t\tGSI_CONTINUE_LINKING);\n-\t  stmt = gimple_build_assign (fd->loops[i + 1].v, t);\n-\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\t  struct omp_for_data_loop *l = &fd->loops[i + 1];\n+\t  if (l->m1 == NULL_TREE || l->outer != 1)\n+\t    {\n+\t      t = l->n1;\n+\t      if (l->m1)\n+\t\t{\n+\t\t  tree t2\n+\t\t    = fold_build2 (MULT_EXPR, TREE_TYPE (t),\n+\t\t\t\t   fd->loops[i + 1 - l->outer].v, l->m1);\n+\t\t  t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t2, t);\n+\t\t}\n+\t      t = force_gimple_operand_gsi (&gsi, t,\n+\t\t\t\t\t    DECL_P (l->v)\n+\t\t\t\t\t    && TREE_ADDRESSABLE (l->v),\n+\t\t\t\t\t    NULL_TREE, false,\n+\t\t\t\t\t    GSI_CONTINUE_LINKING);\n+\t      stmt = gimple_build_assign (l->v, t);\n+\t      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\t    }\n \t}\n       else\n \tcollapse_bb = bb;\n@@ -2077,9 +2607,84 @@ extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n       stmt = gimple_build_assign (fd->loops[i].v, t);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n+      if (fd->loops[i].non_rect_referenced)\n+\t{\n+\t  basic_block update_bb = NULL, prev_bb = NULL;\n+\t  for (int j = i + 1; j <= fd->last_nonrect; j++)\n+\t    if (j - fd->loops[j].outer == i)\n+\t      {\n+\t\ttree n1, n2;\n+\t\tstruct omp_for_data_loop *l = &fd->loops[j];\n+\t\tbasic_block this_bb = create_empty_bb (last_bb);\n+\t\tadd_bb_to_loop (this_bb, last_bb->loop_father);\n+\t\tgimple_stmt_iterator gsi2 = gsi_start_bb (this_bb);\n+\t\tif (prev_bb)\n+\t\t  {\n+\t\t    e = make_edge (prev_bb, this_bb, EDGE_TRUE_VALUE);\n+\t\t    e->probability\n+\t\t      = profile_probability::guessed_always ().apply_scale (7,\n+\t\t\t\t\t\t\t\t\t    8);\n+\t\t    set_immediate_dominator (CDI_DOMINATORS, this_bb, prev_bb);\n+\n+\t\t  }\n+\t\tif (l->m1)\n+\t\t  {\n+\t\t    t = fold_build2 (MULT_EXPR, TREE_TYPE (l->m1), l->m1,\n+\t\t\t\t     fd->loops[i].v);\n+\t\t    t = fold_build2 (PLUS_EXPR, TREE_TYPE (l->v), t, l->n1);\n+\t\t    n1 = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t   GSI_CONTINUE_LINKING);\n+\t\t    stmt = gimple_build_assign (l->v, n1);\n+\t\t    gsi_insert_after (&gsi2, stmt, GSI_CONTINUE_LINKING);\n+\t\t    n1 = l->v;\n+\t\t  }\n+\t\telse\n+\t\t  n1 = force_gimple_operand_gsi (&gsi2, l->n1, true,\n+\t\t\t\t\t\t NULL_TREE, false,\n+\t\t\t\t\t\t GSI_CONTINUE_LINKING);\n+\t\tif (l->m2)\n+\t\t  {\n+\t\t    t = fold_build2 (MULT_EXPR, TREE_TYPE (l->m2), l->m2,\n+\t\t\t\t     fd->loops[i].v);\n+\t\t    t = fold_build2 (PLUS_EXPR, TREE_TYPE (nonrect_bounds[j]),\n+\t\t\t\t     t, unshare_expr (l->n2));\n+\t\t    n2 = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t   GSI_CONTINUE_LINKING);\n+\t\t    stmt = gimple_build_assign (nonrect_bounds[j], n2);\n+\t\t    gsi_insert_after (&gsi2, stmt, GSI_CONTINUE_LINKING);\n+\t\t    n2 = nonrect_bounds[j];\n+\t\t  }\n+\t\telse\n+\t\t  n2 = force_gimple_operand_gsi (&gsi2, unshare_expr (l->n2),\n+\t\t\t\t\t\t true, NULL_TREE, false,\n+\t\t\t\t\t\t GSI_CONTINUE_LINKING);\n+\t\tgcond *cond_stmt\n+\t\t  = gimple_build_cond (l->cond_code, n1, n2,\n+\t\t\t\t       NULL_TREE, NULL_TREE);\n+\t\tgsi_insert_after (&gsi2, cond_stmt, GSI_CONTINUE_LINKING);\n+\t\tif (update_bb == NULL)\n+\t\t  update_bb = this_bb;\n+\t\te = make_edge (this_bb, bb, EDGE_FALSE_VALUE);\n+\t\te->probability\n+\t\t  = profile_probability::guessed_always ().apply_scale (1, 8);\n+\t\tif (prev_bb == NULL)\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, this_bb, last_bb);\n+\t\tprev_bb = this_bb;\n+\t      }\n+\t  e = make_edge (prev_bb, body_bb, EDGE_TRUE_VALUE);\n+\t  e->probability\n+\t    = profile_probability::guessed_always ().apply_scale (7, 8);\n+\t  body_bb = update_bb;\n+\t}\n+\n       if (i > 0)\n \t{\n-\t  t = fd->loops[i].n2;\n+\t  if (fd->loops[i].m2)\n+\t    t = nonrect_bounds[i];\n+\t  else\n+\t    t = unshare_expr (fd->loops[i].n2);\n \t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n \t  tree v = fd->loops[i].v;\n@@ -2099,6 +2704,7 @@ extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n \t}\n       else\n \tmake_edge (bb, body_bb, EDGE_FALLTHRU);\n+      set_immediate_dominator (CDI_DOMINATORS, bb, last_bb);\n       last_bb = bb;\n     }\n \n@@ -3180,7 +3786,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \t}\n   if (fd->collapse > 1)\n-    expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n+    expand_omp_for_init_vars (fd, &gsi, counts, NULL, inner_stmt, startvar);\n \n   if (fd->ordered)\n     {\n@@ -3327,7 +3933,7 @@ expand_omp_for_generic (struct omp_region *region,\n       gsi_remove (&gsi, true);\n \n       if (fd->collapse > 1 && !gimple_omp_for_combined_p (fd->for_stmt))\n-\tcollapse_bb = extract_omp_for_update_vars (fd, cont_bb, l1_bb);\n+\tcollapse_bb = extract_omp_for_update_vars (fd, NULL, cont_bb, l1_bb);\n \n       /* Emit code to get the next parallel iteration in L2_BB.  */\n       gsi = gsi_start_bb (l2_bb);\n@@ -4111,6 +4717,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n     }\n   /* Handle linear clause adjustments.  */\n   tree itercnt = NULL_TREE;\n+  tree *nonrect_bounds = NULL;\n   if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_FOR)\n     for (tree c = gimple_omp_for_clauses (fd->for_stmt);\n \t c; c = OMP_CLAUSE_CHAIN (c))\n@@ -4153,7 +4760,15 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \t}\n   if (fd->collapse > 1)\n-    expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n+    {\n+      if (fd->non_rect)\n+\t{\n+\t  nonrect_bounds = XALLOCAVEC (tree, fd->last_nonrect + 1);\n+\t  memset (nonrect_bounds, 0, sizeof (tree) * (fd->last_nonrect + 1));\n+\t}\n+      expand_omp_for_init_vars (fd, &gsi, counts, nonrect_bounds, inner_stmt,\n+\t\t\t\tstartvar);\n+    }\n \n   if (!broken_loop)\n     {\n@@ -4205,7 +4820,8 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       gsi_remove (&gsi, true);\n \n       if (fd->collapse > 1 && !gimple_omp_for_combined_p (fd->for_stmt))\n-\tcollapse_bb = extract_omp_for_update_vars (fd, cont_bb, body_bb);\n+\tcollapse_bb = extract_omp_for_update_vars (fd, nonrect_bounds,\n+\t\t\t\t\t\t   cont_bb, body_bb);\n     }\n \n   /* Replace the GIMPLE_OMP_RETURN with a barrier, or nothing.  */\n@@ -4876,7 +5492,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t  gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n \t}\n   if (fd->collapse > 1)\n-    expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n+    expand_omp_for_init_vars (fd, &gsi, counts, NULL, inner_stmt, startvar);\n \n   if (!broken_loop)\n     {\n@@ -4931,7 +5547,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       gsi_remove (&gsi, true);\n \n       if (fd->collapse > 1 && !gimple_omp_for_combined_p (fd->for_stmt))\n-\tcollapse_bb = extract_omp_for_update_vars (fd, cont_bb, body_bb);\n+\tcollapse_bb = extract_omp_for_update_vars (fd, NULL, cont_bb, body_bb);\n \n       /* Trip update code goes into TRIP_UPDATE_BB.  */\n       gsi = gsi_start_bb (trip_update_bb);\n@@ -5331,7 +5947,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n       if (gimple_omp_for_combined_into_p (fd->for_stmt))\n \t{\n \t  gsi_prev (&gsi);\n-\t  expand_omp_for_init_vars (fd, &gsi, counts, NULL, n1);\n+\t  expand_omp_for_init_vars (fd, &gsi, counts, NULL, NULL, n1);\n \t  gsi_next (&gsi);\n \t}\n       else\n@@ -5704,7 +6320,7 @@ expand_omp_taskloop_for_outer (struct omp_region *region,\n   assign_stmt = gimple_build_assign (endvar, t1);\n   gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n   if (fd->collapse > 1)\n-    expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n+    expand_omp_for_init_vars (fd, &gsi, counts, NULL, inner_stmt, startvar);\n \n   /* Remove the GIMPLE_OMP_FOR statement.  */\n   gsi = gsi_for_stmt (for_stmt);\n@@ -5860,7 +6476,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n       gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n     }\n   if (fd->collapse > 1)\n-    expand_omp_for_init_vars (fd, &gsi, counts, inner_stmt, startvar);\n+    expand_omp_for_init_vars (fd, &gsi, counts, NULL, inner_stmt, startvar);\n \n   if (!broken_loop)\n     {\n@@ -5895,7 +6511,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n       gsi_remove (&gsi, true);\n \n       if (fd->collapse > 1 && !gimple_omp_for_combined_p (fd->for_stmt))\n-\tcollapse_bb = extract_omp_for_update_vars (fd, cont_bb, body_bb);\n+\tcollapse_bb = extract_omp_for_update_vars (fd, NULL, cont_bb, body_bb);\n     }\n \n   /* Remove the GIMPLE_OMP_FOR statement.  */\n@@ -6556,7 +7172,9 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n   else if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n \t   && !fd.have_ordered)\n     {\n-      if (fd.non_rect)\n+      if (fd.non_rect\n+\t  && (gimple_omp_for_combined_into_p (fd.for_stmt)\n+\t      || gimple_omp_for_combined_p (fd.for_stmt)))\n \tsorry_at (gimple_location (fd.for_stmt),\n \t\t  \"non-rectangular OpenMP loops not supported yet\");\n       if (fd.chunk_size == NULL)"}, {"sha": "2a47466f89710d4255dc113db2e825f33731613a", "filename": "gcc/omp-general.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "patch": "@@ -206,6 +206,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->tiling = NULL_TREE;\n   fd->collapse = 1;\n   fd->ordered = 0;\n+  fd->first_nonrect = -1;\n+  fd->last_nonrect = -1;\n   fd->sched_kind = OMP_CLAUSE_SCHEDULE_STATIC;\n   fd->sched_modifiers = 0;\n   fd->chunk_size = NULL_TREE;\n@@ -372,18 +374,24 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n       loop->m1 = NULL_TREE;\n       loop->m2 = NULL_TREE;\n       loop->outer = 0;\n+      loop->non_rect_referenced = false;\n       if (TREE_CODE (loop->n1) == TREE_VEC)\n \t{\n \t  for (int j = i - 1; j >= 0; j--)\n \t    if (TREE_VEC_ELT (loop->n1, 0) == gimple_omp_for_index (for_stmt, j))\n \t      {\n \t\tloop->outer = i - j;\n+\t\tif (loops != NULL)\n+\t\t  loops[j].non_rect_referenced = true;\n+\t\tif (fd->first_nonrect == -1 || fd->first_nonrect > j)\n+\t\t  fd->first_nonrect = j;\n \t\tbreak;\n \t      }\n \t  gcc_assert (loop->outer);\n \t  loop->m1 = TREE_VEC_ELT (loop->n1, 1);\n \t  loop->n1 = TREE_VEC_ELT (loop->n1, 2);\n \t  fd->non_rect = true;\n+\t  fd->last_nonrect = i;\n \t}\n \n       loop->cond_code = gimple_omp_for_cond (for_stmt, i);\n@@ -401,12 +409,17 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      if (TREE_VEC_ELT (loop->n2, 0) == gimple_omp_for_index (for_stmt, j))\n \t\t{\n \t\t  loop->outer = i - j;\n+\t\t  if (loops != NULL)\n+\t\t    loops[j].non_rect_referenced = true;\n+\t\t  if (fd->first_nonrect == -1 || fd->first_nonrect > j)\n+\t\t    fd->first_nonrect = j;\n \t\t  break;\n \t\t}\n \t  gcc_assert (loop->outer);\n \t  loop->m2 = TREE_VEC_ELT (loop->n2, 1);\n \t  loop->n2 = TREE_VEC_ELT (loop->n2, 2);\n \t  fd->non_rect = true;\n+\t  fd->last_nonrect = i;\n \t}\n \n       t = gimple_omp_for_incr (for_stmt, i);"}, {"sha": "a76396577b9db6774f4bd458188a34b6cb722f33", "filename": "gcc/omp-general.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "patch": "@@ -47,13 +47,16 @@ enum oacc_loop_flags {\n    or for non-rectangular loops:\n    for (V = M1 * W + N1; V cond M2 * W + N2; V += STEP;\n    where W is V of the OUTER-th loop (e.g. for OUTER 1 it is the\n-   the index of the immediately surrounding loop).  */\n+   the index of the immediately surrounding loop).\n+   NON_RECT_REFERENCED is true for loops referenced by loops\n+   with non-NULL M1 or M2.  */\n \n struct omp_for_data_loop\n {\n   tree v, n1, n2, step, m1, m2;\n-  int outer;\n   enum tree_code cond_code;\n+  int outer;\n+  bool non_rect_referenced;\n };\n \n /* A structure describing the main elements of a parallel loop.  */\n@@ -67,6 +70,7 @@ struct omp_for_data\n   tree tiling;  /* Tiling values (if non null).  */\n   int collapse;  /* Collapsed loops, 1 for a non-collapsed loop.  */\n   int ordered;\n+  int first_nonrect, last_nonrect;\n   bool have_nowait, have_ordered, simd_schedule, have_reductemp;\n   bool have_pointer_condtemp, have_scantemp, have_nonctrl_scantemp;\n   bool non_rect;"}, {"sha": "a8a595a42f5236f00ee861ef08d512800a103e0a", "filename": "libgomp/testsuite/libgomp.c/loop-17.c", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-17.c?ref=aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "patch": "@@ -0,0 +1,189 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+signed char v[5][7][9][21][4][42][3];\n+volatile int zero = 0, one = 1, two = 2, three = 3;\n+volatile int five = 5, seven = 7, nine = 9, eleven = 11;\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int k = 0; k < 9; k++)\n+  for (int l = 2 * j; l < 3 * j; l++)\n+  for (int m = 7; m < 11; m++)\n+  for (int n = l; n < 2 * l; n++)\n+  for (int o = 0; o < 3; o++)\n+    v[i][j][k][l][m - 7][n][o] = 1;\n+\n+  int niters = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(7) reduction(+:niters)\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int k = 0; k < 9; k++)\n+  for (int l = 2 * j; l < 3 * j; l++)\n+  for (int m = 7; m < 11; m++)\n+  for (int n = l; n < 2 * l; n++)\n+  for (int o = 0; o < 3; o++)\n+    {\n+      niters++;\n+      if (i < 0 || i >= 5\n+\t  || j < 0 || j >= 7\n+\t  || k < 0 || k >= 9\n+\t  || l < 2 * j || l >= 3 * j\n+\t  || m < 7 || m >= 11\n+\t  || n < l || n >= 2 * l\n+\t  || o < 0 || o >= 3)\n+\tabort ();\n+      if (v[i][j][k][l][m - 7][n][o] != 1)\n+\tabort ();\n+      v[i][j][k][l][m - 7][n][o]++;\n+    }\n+\n+  if (niters != 117180)\n+    abort ();\n+\n+  int niters2 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(7) reduction(+:niters2)\n+  for (int i = zero; i < five; i += one)\n+  for (int j = seven - one; j >= zero; j -= one)\n+  for (int k = nine - one; k >= zero; k += -one)\n+  for (int l = two * j + zero; l < three * j; l += one)\n+  for (int m = eleven - one; m >= seven; m -= one)\n+  for (int n = two * l - one; n > one * l - one; n -= one)\n+  for (int o = zero; o < three; o += one)\n+    {\n+      niters2++;\n+      if (i < 0 || i >= 5\n+\t  || j < 0 || j >= 7\n+\t  || k < 0 || k >= 9\n+\t  || l < 2 * j || l >= 3 * j\n+\t  || m < 7 || m >= 11\n+\t  || n < l || n >= 2 * l\n+\t  || o < 0 || o >= 3)\n+\tabort ();\n+      if (v[i][j][k][l][m - 7][n][o] != 2)\n+\tabort ();\n+      v[i][j][k][l][m - 7][n][o]++;\n+    }\n+\n+  if (niters2 != 117180)\n+    abort ();\n+\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int k = 0; k < 9; k++)\n+  for (int l = 2 * j; l < 3 * j; l++)\n+  for (int m = 7; m < 11; m++)\n+  for (int n = l; n < 2 * l; n++)\n+  for (int o = 0; o < 3; o++)\n+    if (v[i][j][k][l][m - 7][n][o] != 3)\n+      abort ();\n+\n+  int niters3 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(5) reduction(+:niters3)\n+  for (int i = 4; i >= 0; i--)\n+  for (int j = 6; j >= 0; --j)\n+  for (int l = 3 * j - 1; l >= 2 * j; l--)\n+  for (int n = 2 * l + -1; n > l - 1; --n)\n+  for (int o = 2; o >= 0; o--)\n+    {\n+      niters3++;\n+      if (i < 0 || i >= 5\n+\t  || j < 0 || j >= 7\n+\t  || l < 2 * j || l >= 3 * j\n+\t  || n < l || n >= 2 * l\n+\t  || o < 0 || o >= 3)\n+\tabort ();\n+      if (v[i][j][0][l][0][n][o] != 3)\n+\tabort ();\n+      v[i][j][0][l][0][n][o]++;\n+    }\n+\n+  if (niters3 != 3255)\n+    abort ();\n+\n+  int niters4 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(5) reduction(+:niters4)\n+  for (int i = zero; i < five; i += one)\n+  for (int j = zero; j <= seven - one; j += one)\n+  for (int l = j * two; l < three * j + zero; l += one)\n+  for (int n = one * l; n <= l * two - one; n += one)\n+  for (int o = zero; o < three; o += one)\n+    {\n+      niters4++;\n+      if (i < 0 || i >= 5\n+\t  || j < 0 || j >= 7\n+\t  || l < 2 * j || l >= 3 * j\n+\t  || n < l || n >= 2 * l\n+\t  || o < 0 || o >= 3)\n+\tabort ();\n+      if (v[i][j][0][l][0][n][o] != 4)\n+\tabort ();\n+      v[i][j][0][l][0][n][o]++;\n+    }\n+\n+  if (niters4 != 3255)\n+    abort ();\n+\n+  for (int i = 0; i < 5; i++)\n+  for (int j = 0; j < 7; j++)\n+  for (int l = 2 * j; l < 3 * j; l++)\n+  for (int n = l; n < 2 * l; n++)\n+  for (int o = 0; o < 3; o++)\n+    if (v[i][j][0][l][0][n][o] != 5)\n+      abort ();\n+\n+  int niters5 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(3) reduction(+:niters5)\n+  for (int j = 6; j >= 0; --j)\n+  for (int l = 2 * j; l <= 3 * j - 1; l++)\n+  for (int n = 2 * l + -1; n > l - 1; --n)\n+    {\n+      niters5++;\n+      if (j < 0 || j >= 7\n+\t  || l < 2 * j || l >= 3 * j\n+\t  || n < l || n >= 2 * l)\n+\tabort ();\n+      if (v[0][j][0][l][0][n][0] != 5)\n+\tabort ();\n+      v[0][j][0][l][0][n][0]++;\n+    }\n+\n+  if (niters5 != 217)\n+    abort ();\n+\n+  int niters6 = 0;\n+  #pragma omp parallel\n+  #pragma omp for collapse(3) reduction(+:niters6)\n+  for (int j = seven - one; j > - one; j -= one)\n+  for (int l = j * three - one; l >= j * two + zero; l += -one)\n+  for (int n = two * l - one; n > l - one; n -= one)\n+    {\n+      niters6++;\n+      if (j < 0 || j >= 7\n+\t  || l < 2 * j || l >= 3 * j\n+\t  || n < l || n >= 2 * l)\n+\tabort ();\n+      if (v[0][j][0][l][0][n][0] != 6)\n+\tabort ();\n+      v[0][j][0][l][0][n][0]++;\n+    }\n+\n+  if (niters6 != 217)\n+    abort ();\n+\n+  for (int j = 0; j < 7; j++)\n+  for (int l = 2 * j; l < 3 * j; l++)\n+  for (int n = l; n < 2 * l; n++)\n+    if (v[0][j][0][l][0][n][0] != 7)\n+      abort ();\n+  return 0;\n+}"}, {"sha": "5963a4a493141e9f99c2638fccaa0368e3b1fe5f", "filename": "libgomp/testsuite/libgomp.c/loop-18.c", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-18.c?ref=aed3ab253dada2b7d2ed63cc6a8e15e263d5dd35", "patch": "@@ -0,0 +1,245 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int x, i, j;\n+volatile int a, b, c, d, e, f, g, h;\n+int k[11][101];\n+\n+int\n+main ()\n+{\n+  int niters;\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      k[i][j] = 1;\n+  a = 1; b = 11; c = 1; d = 0; e = 1; f = 10; g = 1; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      {\n+\tif (i < 1 || i > 10 || j < 1 || j > 10 * i || k[i][j] != 1)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 101 || x != 10340 || niters != 550)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 1 || i > 10 || j < 1 || j > 10 * i || k[i][j] != 2)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 101 || x != 10340 || niters != 550)\n+    abort ();\n+  for (i = 1; i <= 10; i++)\n+    for (j = 1; j <= 10 * i; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      k[i][j] = 1;\n+  a = 0; b = 10; c = 1; d = 0; e = 0; f = 10; g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      {\n+\tif (i < 0 || i >= 10 || j < 0 || j >= 10 * i || k[i][j] != 1)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 10 || j != 90 || x != 9305 || niters != 450)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 0 || i >= 10 || j < 0 || j >= 10 * i || k[i][j] != 2)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 10 || j != 90 || x != 9305 || niters != 450)\n+    abort ();\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 10 * i; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      k[i][j + 1] = 1;\n+  a = 4; b = 10; c = 1; d = 2; e = -9; f = 1; g = 0; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      {\n+\tif (i < 4 || i >= 10 || j < -9 + 2 * i || j >= i || k[i][j + 1] != 1)\n+\t  abort ();\n+\tk[i][j + 1]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 10 || j != 9 || */x != 8199 || niters != 15)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 4 || i >= 10 || j < -9 + 2 * i || j >= i || k[i][j + 1] != 2)\n+\t  abort ();\n+\tk[i][j + 1]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 10 || j != 9 || */x != 8199 || niters != 15)\n+    abort ();\n+  for (i = 4; i < 10; i++)\n+    for (j = -9 + 2 * i; j < i; j++)\n+      if (k[i][j + 1] == 3)\n+\tk[i][j + 1] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      k[i][j] = 1;\n+  a = 1; b = 10; c = 2; d = 0; e = 1; f = 1; g = 1; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      {\n+\tif (i < 1 || i >= 10 || j < 1 || j >= i + 1 || k[i][j] != 1)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 10 || x != 9225 || niters != 25)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i < 1 || i >= 10 || j < 1 || j >= i + 1 || k[i][j] != 2)\n+\t  abort ();\n+\tk[i][j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 11 || j != 10 || x != 9225 || niters != 25)\n+    abort ();\n+  for (i = 1; i < 10; i += 2)\n+    for (j = 1; j < i + 1; j++)\n+      if (k[i][j] == 3)\n+\tk[i][j] = 0;\n+      else\n+\tabort ();\n+  for (i = 0; i < 11; i++)\n+    for (j = 0; j < 101; j++)\n+      if (k[i][j] != 0)\n+\tabort ();\n+  for (j = -11; j >= -41; j -= 15)\n+    k[0][-j] = 1;\n+  a = 4; b = 8; c = 12; d = -8; e = -9; f = -3; g = 6; h = 15;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 4; i < 8; i += 12)\n+    for (j = -8 * i - 9; j < i * -3 + 6; j += 15)\n+      {\n+\tif (i != 4 || j < -41 || j > -11 || k[0][-j] != 1)\n+\t  abort ();\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 4 || x != 5109 || niters != 3)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i != 4 || j < -41 || j > -11 || k[0][-j] != 2)\n+\t  abort ();\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 16 || j != 4 || x != 5109 || niters != 3)\n+    abort ();\n+  for (j = -11; j >= -41; j -= 15)\n+    if (k[0][-j] == 3)\n+      k[0][-j] = 0;\n+    else\n+      abort ();\n+  for (j = -11; j >= -41; j--)\n+    if (k[0][-j] != 0)\n+      abort ();\n+  for (j = -34; j <= -7; j++)\n+    k[0][-j] = 1;\n+  a = -13; b = 7; c = 12; d = 3; e = 5; f = 0; g = -6; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = -13; i < 7; i += 12)\n+    for (j = 3 * i + 5; j < -6; j++)\n+      {\n+\tif (i != -13 || j < -34 || j > -7 || k[0][-j] != 1)\n+\t  abort ();\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 11 || j != 2 || */x != -12295 || niters != 28)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i != -13 || j < -34 || j > -7 || k[0][-j] != 2)\n+\t  abort ();\n+\tk[0][-j]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 11 || j != 2 || */x != -12295 || niters != 28)\n+    abort ();\n+  for (j = -34; j <= -7; j++)\n+    if (k[0][-j] == 3)\n+      k[0][-j] = 0;\n+    else\n+      abort ();\n+  return 0;\n+}"}]}