{"sha": "21b11495d75df8fd0e5b23f0176f6aa676875055", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFiMTE0OTVkNzVkZjhmZDBlNWIyM2YwMTc2ZjZhYTY3Njg3NTA1NQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-09-09T19:16:56Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-09-09T19:16:56Z"}, "message": "cpplib.h (TTYPE_TABLE): Remove CPP_ and SPELL_ prefixes throughout.\n\n2004-09-09  Matt Austern  <austern@apple.com>\n\t    Zack Weinberg  <zack@codesourcery.com>\n\n\t* include/cpplib.h (TTYPE_TABLE): Remove CPP_ and SPELL_\n\tprefixes throughout.  Add entry for PRAGMA.  Remove\n\tunnecessary \"= 0\" from EQ.\n\t(enum cpp_ttype): Adjust OP and TK definitions to restore\n\tprefixes, via token-paste.\n\t(CPP_LAST_EQ, CPP_FIRST_DIGRAPH, CPP_LAST_PUNCTUATOR, CPP_LAST_CPP_OP):\n\tChange from #defines to additional cpp_ttype enumerators.\n\t(struct cpp_options): Add defer_pragmas.\n\t(cpp_handle_deferred_pragma): Prototype new interface.\n\n\t* internal.h (struct cpp_reader): Add directive_result.\n\t* directives.c (struct pragma_entry): Add is_internal field;\n\tgive boolean fields type bool.\n\t(start_directive): Initialize pfile->directive_result.type.\n\t(_cpp_do__Pragma): Likewise.\n\t(run_directive): Do not crash if pfile->buffer->prev is NULL.\n\t(insert_pragma_entry): Add 'internal' argument; set new->is_internal\n\tfrom it.\n\t(register_pragma): New static function, bulk of former\n\tcpp_register_pragma here; add 'internal' argument, pass along\n\tto insert_pragma_entry.\n\t(cpp_register_pragma): Now a wrapper around register_pragma which\n\talways passes false for 'internal' argument.\n\t(_cpp_init_internal_pragmas): Call register_pragma directly, passing\n\ttrue for 'internal'.\n\t(do_pragma): If CPP_OPTION (pfile, defer_pragmas) and this isn't\n\tan internal pragma, save text till the end of the line as a CPP_PRAGMA\n\ttoken instead of executing the pragma.\n\t(cpp_handle_deferred_pragma): New interface.\n\t* lex.c (token_spellings): Adjust OP and TK definitions to\n\tmatch changes to cpplib.h.\n\t(_cpp_lex_token): Check for a directive-result token and\n\treturn it if present.\n\t(cpp_token_val_index): Handle CPP_PRAGMA.\n\t* macro.c (cpp_builtin_macro_text): Correct comment.\n\t(builtin_macro): Handle directive-result tokens from _cpp_do__Pragma.\n\nFrom-SVN: r87247", "tree": {"sha": "e54413e76af5e0dcfeb68d4c3f3c4ea1d44ceec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54413e76af5e0dcfeb68d4c3f3c4ea1d44ceec0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21b11495d75df8fd0e5b23f0176f6aa676875055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b11495d75df8fd0e5b23f0176f6aa676875055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b11495d75df8fd0e5b23f0176f6aa676875055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b11495d75df8fd0e5b23f0176f6aa676875055/comments", "author": null, "committer": null, "parents": [{"sha": "b49ce401c20c43ae693407fdd9218fdb2e576d4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b49ce401c20c43ae693407fdd9218fdb2e576d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b49ce401c20c43ae693407fdd9218fdb2e576d4f"}], "stats": {"total": 378, "additions": 258, "deletions": 120}, "files": [{"sha": "7090249bd8a4ce1c28fa20b1073a91240b3227d8", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=21b11495d75df8fd0e5b23f0176f6aa676875055", "patch": "@@ -1,3 +1,43 @@\n+2004-09-09  Matt Austern  <austern@apple.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* include/cpplib.h (TTYPE_TABLE): Remove CPP_ and SPELL_\n+\tprefixes throughout.  Add entry for PRAGMA.  Remove\n+\tunnecessary \"= 0\" from EQ.\n+\t(enum cpp_ttype): Adjust OP and TK definitions to restore\n+\tprefixes, via token-paste.\n+\t(CPP_LAST_EQ, CPP_FIRST_DIGRAPH, CPP_LAST_PUNCTUATOR, CPP_LAST_CPP_OP):\n+\tChange from #defines to additional cpp_ttype enumerators.\n+\t(struct cpp_options): Add defer_pragmas.\n+\t(cpp_handle_deferred_pragma): Prototype new interface.\n+\n+\t* internal.h (struct cpp_reader): Add directive_result.\n+\t* directives.c (struct pragma_entry): Add is_internal field;\n+\tgive boolean fields type bool.\n+\t(start_directive): Initialize pfile->directive_result.type.\n+\t(_cpp_do__Pragma): Likewise.\n+\t(run_directive): Do not crash if pfile->buffer->prev is NULL.\n+\t(insert_pragma_entry): Add 'internal' argument; set new->is_internal\n+\tfrom it.\n+\t(register_pragma): New static function, bulk of former\n+\tcpp_register_pragma here; add 'internal' argument, pass along\n+\tto insert_pragma_entry.\n+\t(cpp_register_pragma): Now a wrapper around register_pragma which\n+\talways passes false for 'internal' argument.\n+\t(_cpp_init_internal_pragmas): Call register_pragma directly, passing\n+\ttrue for 'internal'.\n+\t(do_pragma): If CPP_OPTION (pfile, defer_pragmas) and this isn't\n+\tan internal pragma, save text till the end of the line as a CPP_PRAGMA\n+\ttoken instead of executing the pragma.\n+\t(cpp_handle_deferred_pragma): New interface.\n+\t* lex.c (token_spellings): Adjust OP and TK definitions to\n+\tmatch changes to cpplib.h.\n+\t(_cpp_lex_token): Check for a directive-result token and\n+\treturn it if present.\n+\t(cpp_token_val_index): Handle CPP_PRAGMA.\n+\t* macro.c (cpp_builtin_macro_text): Correct comment.\n+\t(builtin_macro): Handle directive-result tokens from _cpp_do__Pragma.\n+\n 2004-09-06  Serge Belyshev  <belyshev@lubercy.com>\n \n \tPR preprocessor/14699\n@@ -38,9 +78,9 @@\n \t* macro.c: Likewise.\n \t* cpplib.h (cpp_deps_style): Export enum with name.\n \n-2004-07-23  Matthias Klose  <doko@debian.org> \n+2004-07-23  Matthias Klose  <doko@debian.org>\n \n-\t* init.c (init_library): Use PACKAGE for the text domain. \n+\t* init.c (init_library): Use PACKAGE for the text domain.\n \n 2004-07-16  Andris Pavenis  <pavenis@latnet.lv>\n "}, {"sha": "b2b6b32e6c1599549dbed13654ef3c72e188572a", "filename": "libcpp/directives.c", "status": "modified", "additions": 90, "deletions": 17, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=21b11495d75df8fd0e5b23f0176f6aa676875055", "patch": "@@ -44,7 +44,8 @@ struct pragma_entry\n {\n   struct pragma_entry *next;\n   const cpp_hashnode *pragma;\t/* Name and length.  */\n-  int is_nspace;\n+  bool is_nspace;\n+  bool is_internal;\n   union {\n     pragma_cb handler;\n     struct pragma_entry *space;\n@@ -106,7 +107,10 @@ static struct pragma_entry *lookup_pragma_entry (struct pragma_entry *,\n static struct pragma_entry *insert_pragma_entry (cpp_reader *,\n                                                  struct pragma_entry **,\n                                                  const cpp_hashnode *,\n-                                                 pragma_cb);\n+                                                 pragma_cb,\n+\t\t\t\t\t\t bool);\n+static void register_pragma (cpp_reader *, const char *, const char *,\n+\t\t\t     pragma_cb, bool);\n static int count_registered_pragmas (struct pragma_entry *);\n static char ** save_registered_pragmas (struct pragma_entry *, char **);\n static char ** restore_registered_pragmas (cpp_reader *, struct pragma_entry *,\n@@ -219,6 +223,7 @@ start_directive (cpp_reader *pfile)\n   /* Setup in-directive state.  */\n   pfile->state.in_directive = 1;\n   pfile->state.save_comments = 0;\n+  pfile->directive_result.type = CPP_PADDING;\n \n   /* Some handlers need the position of the # for diagnostics.  */\n   pfile->directive_line = pfile->line_table->highest_line;\n@@ -442,7 +447,7 @@ run_directive (cpp_reader *pfile, int dir_no, const char *buf, size_t count)\n   cpp_push_buffer (pfile, (const uchar *) buf, count,\n \t\t   /* from_stage3 */ true);\n   /* Disgusting hack.  */\n-  if (dir_no == T_PRAGMA)\n+  if (dir_no == T_PRAGMA && pfile->buffer->prev)\n     pfile->buffer->file = pfile->buffer->prev->file;\n   start_directive (pfile);\n \n@@ -954,10 +959,12 @@ lookup_pragma_entry (struct pragma_entry *chain, const cpp_hashnode *pragma)\n \n /* Create and insert a pragma entry for NAME at the beginning of a\n    singly-linked CHAIN.  If handler is NULL, it is a namespace,\n-   otherwise it is a pragma and its handler.  */\n+   otherwise it is a pragma and its handler.  If INTERNAL is true\n+   this pragma is being inserted by libcpp itself. */\n static struct pragma_entry *\n insert_pragma_entry (cpp_reader *pfile, struct pragma_entry **chain,\n-\t\t     const cpp_hashnode *pragma, pragma_cb handler)\n+\t\t     const cpp_hashnode *pragma, pragma_cb handler,\n+\t\t     bool internal)\n {\n   struct pragma_entry *new;\n \n@@ -975,17 +982,20 @@ insert_pragma_entry (cpp_reader *pfile, struct pragma_entry **chain,\n       new->u.space = NULL;\n     }\n \n+  new->is_internal = internal;\n   new->next = *chain;\n   *chain = new;\n   return new;\n }\n \n /* Register a pragma NAME in namespace SPACE.  If SPACE is null, it\n    goes in the global namespace.  HANDLER is the handler it will call,\n-   which must be non-NULL.  */\n-void\n-cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n-\t\t     pragma_cb handler)\n+   which must be non-NULL.  INTERNAL is true if this is a pragma\n+   registered by cpplib itself, false if it is registered via\n+   cpp_register_pragma */\n+static void\n+register_pragma (cpp_reader *pfile, const char *space, const char *name,\n+\t\t pragma_cb handler, bool internal)\n {\n   struct pragma_entry **chain = &pfile->pragmas;\n   struct pragma_entry *entry;\n@@ -999,7 +1009,7 @@ cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n       node = cpp_lookup (pfile, U space, strlen (space));\n       entry = lookup_pragma_entry (*chain, node);\n       if (!entry)\n-\tentry = insert_pragma_entry (pfile, chain, node, NULL);\n+\tentry = insert_pragma_entry (pfile, chain, node, NULL, internal);\n       else if (!entry->is_nspace)\n \tgoto clash;\n       chain = &entry->u.space;\n@@ -1022,20 +1032,30 @@ cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n \tcpp_error (pfile, CPP_DL_ICE, \"#pragma %s is already registered\", name);\n     }\n   else\n-    insert_pragma_entry (pfile, chain, node, handler);\n+    insert_pragma_entry (pfile, chain, node, handler, internal);\n+}\n+\n+/* Register a pragma NAME in namespace SPACE.  If SPACE is null, it\n+   goes in the global namespace.  HANDLER is the handler it will call,\n+   which must be non-NULL.  This function is exported from libcpp. */\n+void\n+cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n+\t\t     pragma_cb handler)\n+{\n+  register_pragma (pfile, space, name, handler, false);\n }\n \n /* Register the pragmas the preprocessor itself handles.  */\n void\n _cpp_init_internal_pragmas (cpp_reader *pfile)\n {\n   /* Pragmas in the global namespace.  */\n-  cpp_register_pragma (pfile, 0, \"once\", do_pragma_once);\n+  register_pragma (pfile, 0, \"once\", do_pragma_once, true);\n \n   /* New GCC-specific pragmas should be put in the GCC namespace.  */\n-  cpp_register_pragma (pfile, \"GCC\", \"poison\", do_pragma_poison);\n-  cpp_register_pragma (pfile, \"GCC\", \"system_header\", do_pragma_system_header);\n-  cpp_register_pragma (pfile, \"GCC\", \"dependency\", do_pragma_dependency);\n+  register_pragma (pfile, \"GCC\", \"poison\", do_pragma_poison, true);\n+  register_pragma (pfile, \"GCC\", \"system_header\", do_pragma_system_header, true);\n+  register_pragma (pfile, \"GCC\", \"dependency\", do_pragma_dependency, true);\n }\n \n /* Return the number of registered pragmas in PE.  */\n@@ -1113,7 +1133,11 @@ _cpp_restore_pragma_names (cpp_reader *pfile, char **saved)\n    front end.  C99 defines three pragmas and says that no macro\n    expansion is to be performed on them; whether or not macro\n    expansion happens for other pragmas is implementation defined.\n-   This implementation never macro-expands the text after #pragma.  */\n+   This implementation never macro-expands the text after #pragma.\n+\n+   The library user has the option of deferring execution of\n+   #pragmas not handled by cpplib, in which case they are converted\n+   to CPP_PRAGMA tokens and inserted into the output stream.  */\n static void\n do_pragma (cpp_reader *pfile)\n {\n@@ -1138,7 +1162,7 @@ do_pragma (cpp_reader *pfile)\n \t}\n     }\n \n-  if (p)\n+  if (p && (p->is_internal || !CPP_OPTION (pfile, defer_pragmas)))\n     {\n       /* Since the handler below doesn't get the line number, that it\n \t might need for diagnostics, make sure it has the right\n@@ -1147,6 +1171,31 @@ do_pragma (cpp_reader *pfile)\n \t(*pfile->cb.line_change) (pfile, pragma_token, false);\n       (*p->u.handler) (pfile);\n     }\n+  else if (CPP_OPTION (pfile, defer_pragmas))\n+    {\n+      /* Squirrel away the pragma text.  Pragmas are newline-terminated. */\n+      const uchar *line_start, *line_end;\n+      uchar *s;\n+      cpp_string body;\n+      cpp_token *ptok;\n+\n+      _cpp_backup_tokens (pfile, count);\n+      line_start = CPP_BUFFER (pfile)->cur;\n+      line_end = ustrchr (line_start, '\\n');\n+\n+      body.len = (line_end - line_start) + 1;\n+      s = _cpp_unaligned_alloc (pfile, body.len + 1);\n+      memcpy (s, line_start, body.len);\n+      s[body.len] = '\\0';\n+      body.text = s;\n+\n+      /* Create a CPP_PRAGMA token.  */\n+      ptok = &pfile->directive_result;\n+      ptok->src_loc = pragma_token->src_loc;\n+      ptok->type = CPP_PRAGMA;\n+      ptok->flags = pragma_token->flags | NO_EXPAND;\n+      ptok->val.str = body;\n+    }\n   else if (pfile->cb.def_pragma)\n     {\n       _cpp_backup_tokens (pfile, count);\n@@ -1350,6 +1399,7 @@ void\n _cpp_do__Pragma (cpp_reader *pfile)\n {\n   const cpp_token *string = get__Pragma_string (pfile);\n+  pfile->directive_result.type = CPP_PADDING;\n \n   if (string)\n     destringize_and_run (pfile, &string->val.str);\n@@ -1358,6 +1408,29 @@ _cpp_do__Pragma (cpp_reader *pfile)\n \t       \"_Pragma takes a parenthesized string literal\");\n }\n \n+/* Handle a pragma that the front end deferred until now. */\n+void\n+cpp_handle_deferred_pragma (cpp_reader *pfile, const cpp_string *s)\n+{\n+  cpp_context *saved_context = pfile->context;\n+  cpp_token *saved_cur_token = pfile->cur_token;\n+  tokenrun *saved_cur_run = pfile->cur_run;\n+  bool saved_defer_pragmas = CPP_OPTION (pfile, defer_pragmas);\n+\n+  pfile->context = XNEW (cpp_context);\n+  pfile->context->macro = 0;\n+  pfile->context->prev = 0;\n+  CPP_OPTION (pfile, defer_pragmas) = false;\n+\n+  run_directive (pfile, T_PRAGMA, s->text, s->len);\n+\n+  XDELETE (pfile->context);\n+  pfile->context = saved_context;\n+  pfile->cur_token = saved_cur_token;\n+  pfile->cur_run = saved_cur_run;\n+  CPP_OPTION (pfile, defer_pragmas) = saved_defer_pragmas;\n+}\n+\n /* Ignore #sccs on all systems.  */\n static void\n do_sccs (cpp_reader *pfile ATTRIBUTE_UNUSED)"}, {"sha": "4ee626ecd1c1138f44e8fd141dca3652cc798633", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 98, "deletions": 92, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=21b11495d75df8fd0e5b23f0176f6aa676875055", "patch": "@@ -52,101 +52,102 @@ struct _cpp_file;\n    '='.  The lexer needs operators ending in '=', like \">>=\", to be in\n    the same order as their counterparts without the '=', like \">>\".  */\n \n-/* Positions in the table.  */\n-#define CPP_LAST_EQ CPP_MAX\n-#define CPP_FIRST_DIGRAPH CPP_HASH\n-#define CPP_LAST_PUNCTUATOR CPP_DOT_STAR\n-#define CPP_LAST_CPP_OP CPP_LESS_EQ\n-\n-#define TTYPE_TABLE\t\t\t\t\\\n-  OP(CPP_EQ = 0,\t\"=\")\t\t\t\\\n-  OP(CPP_NOT,\t\t\"!\")\t\t\t\\\n-  OP(CPP_GREATER,\t\">\")\t/* compare */\t\\\n-  OP(CPP_LESS,\t\t\"<\")\t\t\t\\\n-  OP(CPP_PLUS,\t\t\"+\")\t/* math */\t\\\n-  OP(CPP_MINUS,\t\t\"-\")\t\t\t\\\n-  OP(CPP_MULT,\t\t\"*\")\t\t\t\\\n-  OP(CPP_DIV,\t\t\"/\")\t\t\t\\\n-  OP(CPP_MOD,\t\t\"%\")\t\t\t\\\n-  OP(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n-  OP(CPP_OR,\t\t\"|\")\t\t\t\\\n-  OP(CPP_XOR,\t\t\"^\")\t\t\t\\\n-  OP(CPP_RSHIFT,\t\">>\")\t\t\t\\\n-  OP(CPP_LSHIFT,\t\"<<\")\t\t\t\\\n-  OP(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n-  OP(CPP_MAX,\t\t\">?\")\t\t\t\\\n-\\\n-  OP(CPP_COMPL,\t\t\"~\")\t\t\t\\\n-  OP(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n-  OP(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n-  OP(CPP_QUERY,\t\t\"?\")\t\t\t\\\n-  OP(CPP_COLON,\t\t\":\")\t\t\t\\\n-  OP(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n-  OP(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n-  OP(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n-  TK(CPP_EOF,\t\tSPELL_NONE)\t\t\\\n-  OP(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n-  OP(CPP_NOT_EQ,\t\"!=\")\t\t\t\\\n-  OP(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n-  OP(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n-\\\n-  /* These two are unary + / - in preprocessor expressions.  */ \\\n-  OP(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n-  OP(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n-\\\n-  OP(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n-  OP(CPP_DIV_EQ,\t\"/=\")\t\t\t\\\n-  OP(CPP_MOD_EQ,\t\"%=\")\t\t\t\\\n-  OP(CPP_AND_EQ,\t\"&=\")\t/* bit ops */\t\\\n-  OP(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n-  OP(CPP_XOR_EQ,\t\"^=\")\t\t\t\\\n-  OP(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n-  OP(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n-  OP(CPP_MIN_EQ,\t\"<?=\")\t/* extension */\t\\\n-  OP(CPP_MAX_EQ,\t\">?=\")\t\t\t\\\n-  /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\\\n-  OP(CPP_HASH,\t\t\"#\")\t/* digraphs */\t\\\n-  OP(CPP_PASTE,\t\t\"##\")\t\t\t\\\n-  OP(CPP_OPEN_SQUARE,\t\"[\")\t\t\t\\\n-  OP(CPP_CLOSE_SQUARE,\t\"]\")\t\t\t\\\n-  OP(CPP_OPEN_BRACE,\t\"{\")\t\t\t\\\n-  OP(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n-  /* The remainder of the punctuation.  Order is not significant.  */\t\\\n-  OP(CPP_SEMICOLON,\t\";\")\t/* structure */\t\\\n-  OP(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n-  OP(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n-  OP(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n-  OP(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n-  OP(CPP_DOT,\t\t\".\")\t\t\t\\\n-  OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n-  OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n-  OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n-  OP(CPP_ATSIGN,\t\"@\")  /* used in Objective-C */ \\\n-\\\n-  TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n-  TK(CPP_AT_NAME,       SPELL_IDENT)    /* @word - Objective-C */       \\\n-  TK(CPP_NUMBER,\tSPELL_LITERAL)\t/* 34_be+ta  */\t\t\t\\\n-\\\n-  TK(CPP_CHAR,\t\tSPELL_LITERAL)\t/* 'char' */\t\t\t\\\n-  TK(CPP_WCHAR,\t\tSPELL_LITERAL)\t/* L'char' */\t\t\t\\\n-  TK(CPP_OTHER,\t\tSPELL_LITERAL)\t/* stray punctuation */\t\t\\\n-\\\n-  TK(CPP_STRING,\tSPELL_LITERAL)\t/* \"string\" */\t\t\t\\\n-  TK(CPP_WSTRING,\tSPELL_LITERAL)\t/* L\"string\" */\t\t\t\\\n-  TK(CPP_OBJC_STRING,   SPELL_LITERAL)  /* @\"string\" - Objective-C */\t\\\n-  TK(CPP_HEADER_NAME,\tSPELL_LITERAL)\t/* <stdio.h> in #include */\t\\\n-\\\n-  TK(CPP_COMMENT,\tSPELL_LITERAL)\t/* Only if output comments.  */ \\\n-                                        /* SPELL_LITERAL happens to DTRT.  */ \\\n-  TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n-  TK(CPP_PADDING,\tSPELL_NONE)\t/* Whitespace for cpp0.  */\n-\n-#define OP(e, s) e,\n-#define TK(e, s) e,\n+#define TTYPE_TABLE\t\t\t\t\t\t\t\\\n+  OP(EQ,\t\t\"=\")\t\t\t\t\t\t\\\n+  OP(NOT,\t\t\"!\")\t\t\t\t\t\t\\\n+  OP(GREATER,\t\t\">\")\t/* compare */\t\t\t\t\\\n+  OP(LESS,\t\t\"<\")\t\t\t\t\t\t\\\n+  OP(PLUS,\t\t\"+\")\t/* math */\t\t\t\t\\\n+  OP(MINUS,\t\t\"-\")\t\t\t\t\t\t\\\n+  OP(MULT,\t\t\"*\")\t\t\t\t\t\t\\\n+  OP(DIV,\t\t\"/\")\t\t\t\t\t\t\\\n+  OP(MOD,\t\t\"%\")\t\t\t\t\t\t\\\n+  OP(AND,\t\t\"&\")\t/* bit ops */\t\t\t\t\\\n+  OP(OR,\t\t\"|\")\t\t\t\t\t\t\\\n+  OP(XOR,\t\t\"^\")\t\t\t\t\t\t\\\n+  OP(RSHIFT,\t\t\">>\")\t\t\t\t\t\t\\\n+  OP(LSHIFT,\t\t\"<<\")\t\t\t\t\t\t\\\n+  OP(MIN,\t\t\"<?\")\t/* extension */\t\t\t\t\\\n+  OP(MAX,\t\t\">?\")\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  OP(COMPL,\t\t\"~\")\t\t\t\t\t\t\\\n+  OP(AND_AND,\t\t\"&&\")\t/* logical */\t\t\t\t\\\n+  OP(OR_OR,\t\t\"||\")\t\t\t\t\t\t\\\n+  OP(QUERY,\t\t\"?\")\t\t\t\t\t\t\\\n+  OP(COLON,\t\t\":\")\t\t\t\t\t\t\\\n+  OP(COMMA,\t\t\",\")\t/* grouping */\t\t\t\t\\\n+  OP(OPEN_PAREN,\t\"(\")\t\t\t\t\t\t\\\n+  OP(CLOSE_PAREN,\t\")\")\t\t\t\t\t\t\\\n+  TK(EOF,\t\tNONE)\t\t\t\t\t\t\\\n+  OP(EQ_EQ,\t\t\"==\")\t/* compare */\t\t\t\t\\\n+  OP(NOT_EQ,\t\t\"!=\")\t\t\t\t\t\t\\\n+  OP(GREATER_EQ,\t\">=\")\t\t\t\t\t\t\\\n+  OP(LESS_EQ,\t\t\"<=\")\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* These two are unary + / - in preprocessor expressions.  */\t\t\\\n+  OP(PLUS_EQ,\t\t\"+=\")\t/* math */\t\t\t\t\\\n+  OP(MINUS_EQ,\t\t\"-=\")\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  OP(MULT_EQ,\t\t\"*=\")\t\t\t\t\t\t\\\n+  OP(DIV_EQ,\t\t\"/=\")\t\t\t\t\t\t\\\n+  OP(MOD_EQ,\t\t\"%=\")\t\t\t\t\t\t\\\n+  OP(AND_EQ,\t\t\"&=\")\t/* bit ops */\t\t\t\t\\\n+  OP(OR_EQ,\t\t\"|=\")\t\t\t\t\t\t\\\n+  OP(XOR_EQ,\t\t\"^=\")\t\t\t\t\t\t\\\n+  OP(RSHIFT_EQ,\t\t\">>=\")\t\t\t\t\t\t\\\n+  OP(LSHIFT_EQ,\t\t\"<<=\")\t\t\t\t\t\t\\\n+  OP(MIN_EQ,\t\t\"<?=\")\t/* extension */\t\t\t\t\\\n+  OP(MAX_EQ,\t\t\">?=\")\t\t\t\t\t\t\\\n+  /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\t\\\n+  OP(HASH,\t\t\"#\")\t/* digraphs */\t\t\t\t\\\n+  OP(PASTE,\t\t\"##\")\t\t\t\t\t\t\\\n+  OP(OPEN_SQUARE,\t\"[\")\t\t\t\t\t\t\\\n+  OP(CLOSE_SQUARE,\t\"]\")\t\t\t\t\t\t\\\n+  OP(OPEN_BRACE,\t\"{\")\t\t\t\t\t\t\\\n+  OP(CLOSE_BRACE,\t\"}\")\t\t\t\t\t\t\\\n+  /* The remainder of the punctuation.\tOrder is not significant.  */\t\\\n+  OP(SEMICOLON,\t\t\";\")\t/* structure */\t\t\t\t\\\n+  OP(ELLIPSIS,\t\t\"...\")\t\t\t\t\t\t\\\n+  OP(PLUS_PLUS,\t\t\"++\")\t/* increment */\t\t\t\t\\\n+  OP(MINUS_MINUS,\t\"--\")\t\t\t\t\t\t\\\n+  OP(DEREF,\t\t\"->\")\t/* accessors */\t\t\t\t\\\n+  OP(DOT,\t\t\".\")\t\t\t\t\t\t\\\n+  OP(SCOPE,\t\t\"::\")\t\t\t\t\t\t\\\n+  OP(DEREF_STAR,\t\"->*\")\t\t\t\t\t\t\\\n+  OP(DOT_STAR,\t\t\".*\")\t\t\t\t\t\t\\\n+  OP(ATSIGN,\t\t\"@\")  /* used in Objective-C */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TK(NAME,\t\tIDENT)\t /* word */\t\t\t\t\\\n+  TK(AT_NAME,\t\tIDENT)\t /* @word - Objective-C */\t\t\\\n+  TK(NUMBER,\t\tLITERAL) /* 34_be+ta  */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TK(CHAR,\t\tLITERAL) /* 'char' */\t\t\t\t\\\n+  TK(WCHAR,\t\tLITERAL) /* L'char' */\t\t\t\t\\\n+  TK(OTHER,\t\tLITERAL) /* stray punctuation */\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TK(STRING,\t\tLITERAL) /* \"string\" */\t\t\t\t\\\n+  TK(WSTRING,\t\tLITERAL) /* L\"string\" */\t\t\t\\\n+  TK(OBJC_STRING,\tLITERAL) /* @\"string\" - Objective-C */\t\t\\\n+  TK(HEADER_NAME,\tLITERAL) /* <stdio.h> in #include */\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TK(COMMENT,\t\tLITERAL) /* Only if output comments.  */\t\\\n+\t\t\t\t /* SPELL_LITERAL happens to DTRT.  */\t\\\n+  TK(MACRO_ARG,\t\tNONE)\t /* Macro argument.  */\t\t\t\\\n+  TK(PRAGMA,\t\tNONE)\t /* Only if deferring pragmas */\t\\\n+  TK(PADDING,\t\tNONE)\t /* Whitespace for -E.\t*/\n+\n+#define OP(e, s) CPP_ ## e,\n+#define TK(e, s) CPP_ ## e,\n enum cpp_ttype\n {\n   TTYPE_TABLE\n-  N_TTYPES\n+  N_TTYPES,\n+\n+  /* Positions in the table.  */\n+  CPP_LAST_EQ        = CPP_MAX,\n+  CPP_FIRST_DIGRAPH  = CPP_HASH,\n+  CPP_LAST_PUNCTUATOR= CPP_DOT_STAR,\n+  CPP_LAST_CPP_OP    = CPP_LESS_EQ\n };\n #undef OP\n #undef TK\n@@ -409,6 +410,10 @@ struct cpp_options\n \n   /* Nonzero means __STDC__ should have the value 0 in system headers.  */\n   unsigned char stdc_0_in_system_headers;\n+\n+  /* True means return pragmas as tokens rather than processing\n+     them directly. */\n+  bool defer_pragmas;\n };\n \n /* Callback for header lookup for HEADER, which is the name of a\n@@ -634,6 +639,7 @@ extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,\n \t\t\t\t       unsigned char *);\n extern void cpp_register_pragma (cpp_reader *, const char *, const char *,\n \t\t\t\t void (*) (cpp_reader *));\n+extern void cpp_handle_deferred_pragma (cpp_reader *, const cpp_string *);\n extern int cpp_avoid_paste (cpp_reader *, const cpp_token *,\n \t\t\t    const cpp_token *);\n extern const cpp_token *cpp_get_token (cpp_reader *);"}, {"sha": "dc1e8fb3d65516523d3ca4ed2032714036eb0ec0", "filename": "libcpp/internal.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=21b11495d75df8fd0e5b23f0176f6aa676875055", "patch": "@@ -322,6 +322,9 @@ struct cpp_reader\n   /* If in_directive, the directive if known.  */\n   const struct directive *directive;\n \n+  /* Token generated while handling a directive, if any. */\n+  cpp_token directive_result;\n+\n   /* Search paths for include files.  */\n   struct cpp_dir *quote_include;\t/* \"\" */\n   struct cpp_dir *bracket_include;\t/* <> */"}, {"sha": "62a28f81b8781379ea929c30866cdd6f9b039a08", "filename": "libcpp/lex.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=21b11495d75df8fd0e5b23f0176f6aa676875055", "patch": "@@ -41,8 +41,8 @@ struct token_spelling\n static const unsigned char *const digraph_spellings[] =\n { U\"%:\", U\"%:%:\", U\"<:\", U\":>\", U\"<%\", U\"%>\" };\n \n-#define OP(e, s) { SPELL_OPERATOR, U s           },\n-#define TK(e, s) { s,              U #e },\n+#define OP(e, s) { SPELL_OPERATOR, U s  },\n+#define TK(e, s) { SPELL_ ## s,    U #e },\n static const struct token_spelling token_spellings[N_TTYPES] = { TTYPE_TABLE };\n #undef OP\n #undef TK\n@@ -736,7 +736,16 @@ _cpp_lex_token (cpp_reader *pfile)\n \t\t handles the directive as normal.  */\n \t      && pfile->state.parsing_args != 1\n \t      && _cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n-\t    continue;\n+\t    {\n+\t      if (pfile->directive_result.type == CPP_PADDING)\n+\t\tcontinue;\n+\t      else\n+\t\t{\n+\t\t  result = &pfile->directive_result;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n \t  if (pfile->cb.line_change && !pfile->state.skipping)\n \t    pfile->cb.line_change (pfile, result, pfile->state.parsing_args);\n \t}\n@@ -1573,6 +1582,8 @@ cpp_token_val_index (cpp_token *tok)\n \treturn CPP_TOKEN_FLD_ARG_NO;\n       else if (tok->type == CPP_PADDING)\n \treturn CPP_TOKEN_FLD_SOURCE;\n+      else if (tok->type == CPP_PRAGMA)\n+\treturn CPP_TOKEN_FLD_STR;\n       /* else fall through */\n     default:\n       return CPP_TOKEN_FLD_NONE;"}, {"sha": "77183343d9e15576c614d706dd4e6c89f7421735", "filename": "libcpp/macro.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b11495d75df8fd0e5b23f0176f6aa676875055/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=21b11495d75df8fd0e5b23f0176f6aa676875055", "patch": "@@ -109,10 +109,8 @@ static const char * const monthnames[] =\n   \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n };\n \n-/* Handle builtin macros like __FILE__, and push the resulting token\n-   on the context stack.  Also handles _Pragma, for which no new token\n-   is created.  Returns 1 if it generates a new token context, 0 to\n-   return the token to the caller.  */\n+/* Helper function for builtin_macro.  Returns the text generated by\n+   a builtin macro. */\n const uchar *\n _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n {\n@@ -245,8 +243,8 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n }\n \n /* Convert builtin macros like __FILE__ to a token and push it on the\n-   context stack.  Also handles _Pragma, for which no new token is\n-   created.  Returns 1 if it generates a new token context, 0 to\n+   context stack.  Also handles _Pragma, for which a new token may not\n+   be created.  Returns 1 if it generates a new token context, 0 to\n    return the token to the caller.  */\n static int\n builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n@@ -263,6 +261,13 @@ builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n \treturn 0;\n \n       _cpp_do__Pragma (pfile);\n+      if (pfile->directive_result.type == CPP_PRAGMA) \n+\t{\n+\t  cpp_token *tok = _cpp_temp_token (pfile);\n+\t  *tok = pfile->directive_result;\n+\t  push_token_context (pfile, NULL, tok, 1);\n+\t}\n+\n       return 1;\n     }\n "}]}