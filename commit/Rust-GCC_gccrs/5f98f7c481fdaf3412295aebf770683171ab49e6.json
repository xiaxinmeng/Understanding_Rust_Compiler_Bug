{"sha": "5f98f7c481fdaf3412295aebf770683171ab49e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY5OGY3YzQ4MWZkYWYzNDEyMjk1YWViZjc3MDY4MzE3MWFiNDllNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-03-17T12:17:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-03-17T12:17:02Z"}, "message": "function.c (fixup_var_refs_1): First try moving the expression directly into a register.\n\n        * function.c (fixup_var_refs_1): First try moving the expression\n        directly into a register.  Don't separate cc0 setter and user.\n\nFrom-SVN: r25821", "tree": {"sha": "3d75f1344d552a6d5963759dfe55d1037dea2a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d75f1344d552a6d5963759dfe55d1037dea2a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f98f7c481fdaf3412295aebf770683171ab49e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f98f7c481fdaf3412295aebf770683171ab49e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f98f7c481fdaf3412295aebf770683171ab49e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f98f7c481fdaf3412295aebf770683171ab49e6/comments", "author": null, "committer": null, "parents": [{"sha": "e75f4f152f98f31606a8211b21f63083778c28da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75f4f152f98f31606a8211b21f63083778c28da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e75f4f152f98f31606a8211b21f63083778c28da"}], "stats": {"total": 48, "additions": 40, "deletions": 8}, "files": [{"sha": "831320fa040c5e6e24ed56ff5ad7f729312ef201", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98f7c481fdaf3412295aebf770683171ab49e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98f7c481fdaf3412295aebf770683171ab49e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f98f7c481fdaf3412295aebf770683171ab49e6", "patch": "@@ -1,3 +1,8 @@\n+Wed Mar 17 12:16:26 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (fixup_var_refs_1): First try moving the expression\n+\tdirectly into a register.  Don't separate cc0 setter and user.\n+\n Wed Mar 17 11:20:29 1999  Dave Brolley  <brolley@cygnus.com>\n \n \t* cppfiles.c (PIPE_BUF): #define PIPE_BUF if not defined already."}, {"sha": "82ad012e9f3337531d78a84834b7e978754c3902", "filename": "gcc/function.c", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98f7c481fdaf3412295aebf770683171ab49e6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98f7c481fdaf3412295aebf770683171ab49e6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5f98f7c481fdaf3412295aebf770683171ab49e6", "patch": "@@ -1995,18 +1995,45 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t  /* Prevent sharing of rtl that might lose.  */\n \t  rtx sub = copy_rtx (XEXP (var, 0));\n \n-\t  start_sequence ();\n-\n \t  if (! validate_change (insn, loc, sub, 0))\n \t    {\n-\t      rtx y = force_operand (sub, NULL_RTX);\n+\t      rtx y = gen_reg_rtx (GET_MODE (sub));\n+\t      rtx seq, new_insn;\n \n-\t      if (! validate_change (insn, loc, y, 0))\n-\t\t*loc = copy_to_reg (y);\n-\t    }\n+\t      /* We should be able to replace with a register or all is lost.\n+\t\t Note that we can't use validate_change to verify this, since\n+\t\t we're not caring for replacing all dups simultaneously.  */\n+\t      if (! validate_replace_rtx (*loc, y, insn))\n+\t\tabort ();\n \n-\t  emit_insn_before (gen_sequence (), insn);\n-\t  end_sequence ();\n+\t      /* Careful!  First try to recognize a direct move of the\n+\t\t value, mimicking how things are done in gen_reload wrt\n+\t\t PLUS.  Consider what happens when insn is a conditional\n+\t\t move instruction and addsi3 clobbers flags.  */\n+\n+\t      start_sequence ();\n+\t      new_insn = emit_insn (gen_rtx_SET (VOIDmode, y, sub));\n+\t      seq = gen_sequence ();\n+\t      end_sequence ();\n+\n+\t      if (recog_memoized (new_insn) < 0)\n+\t\t{\n+\t\t  /* That failed.  Fall back on force_operand and hope.  */\n+\n+\t\t  start_sequence ();\n+\t\t  force_operand (sub, y);\n+\t\t  seq = gen_sequence ();\n+\t\t  end_sequence ();\n+\t\t}\n+\n+#ifdef HAVE_cc0\n+\t      /* Don't separate setter from user.  */\n+\t      if (PREV_INSN (insn) && sets_cc0_p (PREV_INSN (insn)))\n+\t\tinsn = PREV_INSN (insn);\n+#endif\n+\n+\t      emit_insn_before (seq, insn);\n+\t    }\n \t}\n       return;\n "}]}