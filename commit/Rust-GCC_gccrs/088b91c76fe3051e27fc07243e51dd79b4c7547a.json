{"sha": "088b91c76fe3051e27fc07243e51dd79b4c7547a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg4YjkxYzc2ZmUzMDUxZTI3ZmMwNzI0M2U1MWRkNzliNGM3NTQ3YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-11-20T10:29:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-20T10:29:22Z"}, "message": "trans.c (struct language_function): Add GNAT_RET.\n\n\t* gcc-interface/trans.c (struct language_function): Add GNAT_RET.\n\t(f_gnat_ret): New macro.\n\t(struct nrv_data): Add GNAT_RET.\n\t(finalize_nrv_unc_r): New helper function.\n\t(finalize_nrv): Add GNAT_RET parameter.  Copy it into DATA.  If the\n\tfunction returns unconstrained, use finalize_nrv_unc_r as callback.\n\t(return_value_ok_for_nrv_p): Test the alignment of RET_OBJ only if\n\tRET_OBJ is non-null.\n\t(Subprogram_Body_to_gnu): Pass GNAT_RET to finalize_nrv.\n\t(gnat_to_gnu) <N_Return_Statement>: In the return-unconstrained case,\n\tif optimization is enabled, record candidates for the Named Return\n\tValue optimization.\n\nFrom-SVN: r181528", "tree": {"sha": "9c844bb48a22047801d660226093b217eb80a6b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c844bb48a22047801d660226093b217eb80a6b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/088b91c76fe3051e27fc07243e51dd79b4c7547a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088b91c76fe3051e27fc07243e51dd79b4c7547a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/088b91c76fe3051e27fc07243e51dd79b4c7547a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/088b91c76fe3051e27fc07243e51dd79b4c7547a/comments", "author": null, "committer": null, "parents": [{"sha": "0d24bf7601974f373cce377a50132c485d488e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d24bf7601974f373cce377a50132c485d488e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d24bf7601974f373cce377a50132c485d488e18"}], "stats": {"total": 228, "additions": 218, "deletions": 10}, "files": [{"sha": "e6bc5c7b835e1438825bca9540faa2b13f879371", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088b91c76fe3051e27fc07243e51dd79b4c7547a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088b91c76fe3051e27fc07243e51dd79b4c7547a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=088b91c76fe3051e27fc07243e51dd79b4c7547a", "patch": "@@ -1,4 +1,19 @@\n-2011-10-20  Eric Botcazou  <ebotcazou@adacore.com>\n+2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (struct language_function): Add GNAT_RET.\n+\t(f_gnat_ret): New macro.\n+\t(struct nrv_data): Add GNAT_RET.\n+\t(finalize_nrv_unc_r): New helper function.\n+\t(finalize_nrv): Add GNAT_RET parameter.  Copy it into DATA.  If the\n+\tfunction returns unconstrained, use finalize_nrv_unc_r as callback.\n+\t(return_value_ok_for_nrv_p): Test the alignment of RET_OBJ only if\n+\tRET_OBJ is non-null.\n+\t(Subprogram_Body_to_gnu): Pass GNAT_RET to finalize_nrv.\n+\t(gnat_to_gnu) <N_Return_Statement>: In the return-unconstrained case,\n+\tif optimization is enabled, record candidates for the Named Return\n+\tValue optimization.\n+\n+2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Add comment.\n \t(gnat_to_gnu) <N_Return_Statement>: Add 'else' to avoid doing a useless"}, {"sha": "42b4e9154c3386402dff230b5e49af8fcb4353f7", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 202, "deletions": 9, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/088b91c76fe3051e27fc07243e51dd79b4c7547a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/088b91c76fe3051e27fc07243e51dd79b4c7547a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=088b91c76fe3051e27fc07243e51dd79b4c7547a", "patch": "@@ -129,6 +129,7 @@ struct GTY(()) language_function {\n   VEC(parm_attr,gc) *parm_attr_cache;\n   bitmap named_ret_val;\n   VEC(tree,gc) *other_ret_val;\n+  int gnat_ret;\n };\n \n #define f_parm_attr_cache \\\n@@ -140,6 +141,9 @@ struct GTY(()) language_function {\n #define f_other_ret_val \\\n   DECL_STRUCT_FUNCTION (current_function_decl)->language->other_ret_val\n \n+#define f_gnat_ret \\\n+  DECL_STRUCT_FUNCTION (current_function_decl)->language->gnat_ret\n+\n /* A structure used to gather together information about a statement group.\n    We use this to gather related statements, for example the \"then\" part\n    of a IF.  In the case where it represents a lexical scope, we may also\n@@ -2674,12 +2678,20 @@ establish_gnat_vms_condition_handler (void)\n \tfirst list.  These are the Named Return Values.\n \n      4. Adjust the relevant RETURN_EXPRs and replace the occurrences of the\n-\tNamed Return Values in the function with the RESULT_DECL.  */\n+\tNamed Return Values in the function with the RESULT_DECL.\n+\n+   If the function returns an unconstrained type, things are a bit different\n+   because the anonymous return object is allocated on the secondary stack\n+   and RESULT_DECL is only a pointer to it.  Each return object can be of a\n+   different size and is allocated separately so we need not care about the\n+   aforementioned overlapping issues.  Therefore, we don't collect the other\n+   expressions and skip step #2 in the algorithm.  */\n \n struct nrv_data\n {\n   bitmap nrv;\n   tree result;\n+  Node_Id gnat_ret;\n   struct pointer_set_t *visited;\n };\n \n@@ -2812,8 +2824,153 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n     *tp = convert (TREE_TYPE (t), dp->result);\n \n   /* Avoid walking into the same tree more than once.  Unfortunately, we\n-     can't just use walk_tree_without_duplicates because it would only call\n-     us for the first occurrence of NRVs in the function body.  */\n+     can't just use walk_tree_without_duplicates because it would only\n+     call us for the first occurrence of NRVs in the function body.  */\n+  if (pointer_set_insert (dp->visited, *tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Likewise, but used when the function returns an unconstrained type.  */\n+\n+static tree\n+finalize_nrv_unc_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct nrv_data *dp = (struct nrv_data *)data;\n+  tree t = *tp;\n+\n+  /* No need to walk into types.  */\n+  if (TYPE_P (t))\n+    *walk_subtrees = 0;\n+\n+  /* We need to see the DECL_EXPR of NRVs before any other references so we\n+     walk the body of BIND_EXPR before walking its variables.  */\n+  else if (TREE_CODE (t) == BIND_EXPR)\n+    walk_tree (&BIND_EXPR_BODY (t), finalize_nrv_unc_r, data, NULL);\n+\n+  /* Change RETURN_EXPRs of NRVs to assign to the RESULT_DECL only the final\n+     return value built by the allocator instead of the whole construct.  */\n+  else if (TREE_CODE (t) == RETURN_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR)\n+    {\n+      tree ret_val = TREE_OPERAND (TREE_OPERAND (t, 0), 1);\n+\n+      /* This is the construct returned by the allocator.  */\n+      if (TREE_CODE (ret_val) == COMPOUND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (ret_val, 0)) == INIT_EXPR)\n+\t{\n+\t  if (TYPE_IS_FAT_POINTER_P (TREE_TYPE (ret_val)))\n+\t    ret_val\n+\t      = VEC_index (constructor_elt,\n+\t\t\t   CONSTRUCTOR_ELTS\n+\t\t\t   (TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1)),\n+\t\t\t    1)->value;\n+\t  else\n+\t    ret_val = TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1);\n+\t}\n+\n+      /* Strip useless conversions around the return value.  */\n+      if (gnat_useless_type_conversion (ret_val)\n+\t  || TREE_CODE (ret_val) == VIEW_CONVERT_EXPR)\n+\tret_val = TREE_OPERAND (ret_val, 0);\n+\n+      /* Strip unpadding around the return value.  */\n+      if (TREE_CODE (ret_val) == COMPONENT_REF\n+\t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (ret_val, 0))))\n+\tret_val = TREE_OPERAND (ret_val, 0);\n+\n+      /* Assign the new return value to the RESULT_DECL.  */\n+      if (is_nrv_p (dp->nrv, ret_val))\n+\tTREE_OPERAND (TREE_OPERAND (t, 0), 1)\n+\t  = TREE_OPERAND (DECL_INITIAL (ret_val), 0);\n+    }\n+\n+  /* Adjust the DECL_EXPR of NRVs to call the allocator and save the result\n+     into a new variable.  */\n+  else if (TREE_CODE (t) == DECL_EXPR\n+\t   && is_nrv_p (dp->nrv, DECL_EXPR_DECL (t)))\n+    {\n+      tree saved_current_function_decl = current_function_decl;\n+      tree var = DECL_EXPR_DECL (t);\n+      tree alloc, p_array, new_var, new_ret;\n+      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 2);\n+\n+      /* Create an artificial context to build the allocation.  */\n+      current_function_decl = decl_function_context (var);\n+      start_stmt_group ();\n+      gnat_pushlevel ();\n+\n+      /* This will return a COMPOUND_EXPR with the allocation in the first\n+\t arm and the final return value in the second arm.  */\n+      alloc = build_allocator (TREE_TYPE (var), DECL_INITIAL (var),\n+\t\t\t       TREE_TYPE (dp->result),\n+\t\t\t       Procedure_To_Call (dp->gnat_ret),\n+\t\t\t       Storage_Pool (dp->gnat_ret),\n+\t\t\t       Empty, false);\n+\n+      /* The new variable is built as a reference to the allocated space.  */\n+      new_var\n+\t= build_decl (DECL_SOURCE_LOCATION (var), VAR_DECL, DECL_NAME (var),\n+\t\t      build_reference_type (TREE_TYPE (var)));\n+      DECL_BY_REFERENCE (new_var) = 1;\n+\n+      if (TYPE_IS_FAT_POINTER_P (TREE_TYPE (alloc)))\n+\t{\n+\t  /* The new initial value is a COMPOUND_EXPR with the allocation in\n+\t     the first arm and the value of P_ARRAY in the second arm.  */\n+\t  DECL_INITIAL (new_var)\n+\t    = build2 (COMPOUND_EXPR, TREE_TYPE (new_var),\n+\t\t      TREE_OPERAND (alloc, 0),\n+\t\t      VEC_index (constructor_elt,\n+\t\t\t\t CONSTRUCTOR_ELTS (TREE_OPERAND (alloc, 1)),\n+\t\t\t\t\t\t   0)->value);\n+\n+\t  /* Build a modified CONSTRUCTOR that references NEW_VAR.  */\n+\t  p_array = TYPE_FIELDS (TREE_TYPE (alloc));\n+\t  CONSTRUCTOR_APPEND_ELT (v, p_array,\n+\t\t\t\t  fold_convert (TREE_TYPE (p_array), new_var));\n+\t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (p_array),\n+\t\t\t\t  VEC_index (constructor_elt,\n+\t\t\t\t\t     CONSTRUCTOR_ELTS\n+\t\t\t\t\t     (TREE_OPERAND (alloc, 1)),\n+\t\t\t\t\t      1)->value);\n+\t  new_ret = build_constructor (TREE_TYPE (alloc), v);\n+\t}\n+      else\n+\t{\n+\t  /* The new initial value is just the allocation.  */\n+\t  DECL_INITIAL (new_var) = alloc;\n+\t  new_ret = fold_convert (TREE_TYPE (alloc), new_var);\n+\t}\n+\n+      gnat_pushdecl (new_var, Empty);\n+\n+      /* Destroy the artificial context and insert the new statements.  */\n+      gnat_zaplevel ();\n+      *tp = end_stmt_group ();\n+      current_function_decl = saved_current_function_decl;\n+\n+      /* Chain NEW_VAR immediately after VAR and ignore the latter.  */\n+      DECL_CHAIN (new_var) = DECL_CHAIN (var);\n+      DECL_CHAIN (var) = new_var;\n+      DECL_IGNORED_P (var) = 1;\n+\n+      /* Save the new return value and the dereference of NEW_VAR.  */\n+      DECL_INITIAL (var)\n+\t= build2 (COMPOUND_EXPR, TREE_TYPE (var), new_ret,\n+\t\t  build1 (INDIRECT_REF, TREE_TYPE (var), new_var));\n+      /* ??? Kludge to avoid messing up during inlining.  */\n+      DECL_CONTEXT (var) = NULL_TREE;\n+    }\n+\n+  /* And replace all uses of NRVs with the dereference of NEW_VAR.  */\n+  else if (is_nrv_p (dp->nrv, t))\n+    *tp = TREE_OPERAND (DECL_INITIAL (t), 1);\n+\n+  /* Avoid walking into the same tree more than once.  Unfortunately, we\n+     can't just use walk_tree_without_duplicates because it would only\n+     call us for the first occurrence of NRVs in the function body.  */\n   if (pointer_set_insert (dp->visited, *tp))\n     *walk_subtrees = 0;\n \n@@ -2822,13 +2979,14 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n \n /* Finalize the Named Return Value optimization for FNDECL.  The NRV bitmap\n    contains the candidates for Named Return Value and OTHER is a list of\n-   the other return values.  */\n+   the other return values.  GNAT_RET is a representative return node.  */\n \n static void\n-finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other)\n+finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other, Node_Id gnat_ret)\n {\n   struct cgraph_node *node;\n   struct nrv_data data;\n+  walk_tree_fn func;\n   unsigned int i;\n   tree iter;\n \n@@ -2860,8 +3018,13 @@ finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other)\n   /* Adjust the relevant RETURN_EXPRs and replace the occurrences of NRVs.  */\n   data.nrv = nrv;\n   data.result = DECL_RESULT (fndecl);\n+  data.gnat_ret = gnat_ret;\n   data.visited = pointer_set_create ();\n-  walk_tree (&DECL_SAVED_TREE (fndecl), finalize_nrv_r, &data, NULL);\n+  if (TYPE_RETURN_UNCONSTRAINED_P (TREE_TYPE (fndecl)))\n+    func = finalize_nrv_unc_r;\n+  else\n+    func = finalize_nrv_r;\n+  walk_tree (&DECL_SAVED_TREE (fndecl), func, &data, NULL);\n   pointer_set_destroy (data.visited);\n }\n \n@@ -2886,7 +3049,7 @@ return_value_ok_for_nrv_p (tree ret_obj, tree ret_val)\n   if (TREE_ADDRESSABLE (ret_val))\n     return false;\n \n-  if (DECL_ALIGN (ret_val) > DECL_ALIGN (ret_obj))\n+  if (ret_obj && DECL_ALIGN (ret_val) > DECL_ALIGN (ret_obj))\n     return false;\n \n   return true;\n@@ -3286,8 +3449,10 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      a Named Return Value, finalize the optimization.  */\n   if (optimize && gnu_subprog_language->named_ret_val)\n     {\n-      finalize_nrv (gnu_subprog_decl, gnu_subprog_language->named_ret_val,\n-\t\t    gnu_subprog_language->other_ret_val);\n+      finalize_nrv (gnu_subprog_decl,\n+\t\t    gnu_subprog_language->named_ret_val,\n+\t\t    gnu_subprog_language->other_ret_val,\n+\t\t    gnu_subprog_language->gnat_ret);\n       gnu_subprog_language->named_ret_val = NULL;\n       gnu_subprog_language->other_ret_val = NULL;\n     }\n@@ -5882,6 +6047,34 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    else if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type))\n \t      {\n \t\tgnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n+\n+\t\t/* And find out whether this is a candidate for Named Return\n+\t\t   Value.  If so, record it.  */\n+\t\tif (!TYPE_CI_CO_LIST (gnu_subprog_type) && optimize)\n+\t\t  {\n+\t\t    tree ret_val = gnu_ret_val;\n+\n+\t\t    /* Strip useless conversions around the return value.  */\n+\t\t    if (gnat_useless_type_conversion (ret_val))\n+\t\t      ret_val = TREE_OPERAND (ret_val, 0);\n+\n+\t\t    /* Strip unpadding around the return value.  */\n+\t\t    if (TREE_CODE (ret_val) == COMPONENT_REF\n+\t\t\t&& TYPE_IS_PADDING_P\n+\t\t\t   (TREE_TYPE (TREE_OPERAND (ret_val, 0))))\n+\t\t      ret_val = TREE_OPERAND (ret_val, 0);\n+\n+\t\t    /* Now apply the test to the return value.  */\n+\t\t    if (return_value_ok_for_nrv_p (NULL_TREE, ret_val))\n+\t\t      {\n+\t\t\tif (!f_named_ret_val)\n+\t\t\t  f_named_ret_val = BITMAP_GGC_ALLOC ();\n+\t\t\tbitmap_set_bit (f_named_ret_val, DECL_UID (ret_val));\n+\t\t\tif (!f_gnat_ret)\n+\t\t\t  f_gnat_ret = gnat_node;\n+\t\t      }\n+\t\t  }\n+\n \t\tgnu_ret_val = build_allocator (TREE_TYPE (gnu_ret_val),\n \t\t\t\t\t       gnu_ret_val,\n \t\t\t\t\t       TREE_TYPE (gnu_ret_obj),"}]}