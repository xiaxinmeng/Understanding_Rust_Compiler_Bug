{"sha": "f3fc6b6c4577585d5ece8ba7f56f217020489b99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNmYzZiNmM0NTc3NTg1ZDVlY2U4YmE3ZjU2ZjIxNzAyMDQ4OWI5OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-25T21:25:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-25T21:25:27Z"}, "message": "* gcc.texi (Temporaries): Update.\n\nFrom-SVN: r25987", "tree": {"sha": "bade2ef26255f737cac80a06f02b208c54c2328a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bade2ef26255f737cac80a06f02b208c54c2328a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3fc6b6c4577585d5ece8ba7f56f217020489b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3fc6b6c4577585d5ece8ba7f56f217020489b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3fc6b6c4577585d5ece8ba7f56f217020489b99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3fc6b6c4577585d5ece8ba7f56f217020489b99/comments", "author": null, "committer": null, "parents": [{"sha": "e2064f2a456bfeee512f116db1128c0ff1b41336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2064f2a456bfeee512f116db1128c0ff1b41336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2064f2a456bfeee512f116db1128c0ff1b41336"}], "stats": {"total": 66, "additions": 36, "deletions": 30}, "files": [{"sha": "7753d2fa5bd7d45d3689f4eccde6b8c6d32cbae5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3fc6b6c4577585d5ece8ba7f56f217020489b99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3fc6b6c4577585d5ece8ba7f56f217020489b99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3fc6b6c4577585d5ece8ba7f56f217020489b99", "patch": "@@ -1,3 +1,7 @@\n+Thu Mar 25 21:08:02 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* gcc.texi (Temporaries): Update.\n+\n Thu Mar 25 16:53:53 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* combine.c (distribute_notes): Place REG_LABEL also where"}, {"sha": "da8431f27f83fecf78e6cc9ae592aca588d30325", "filename": "gcc/gcc.texi", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3fc6b6c4577585d5ece8ba7f56f217020489b99/gcc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3fc6b6c4577585d5ece8ba7f56f217020489b99/gcc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.texi?ref=f3fc6b6c4577585d5ece8ba7f56f217020489b99", "patch": "@@ -1698,50 +1698,52 @@ symbols any static data members that lack definitions.\n It is dangerous to use pointers or references to @emph{portions} of a\n temporary object.  The compiler may very well delete the object before\n you expect it to, leaving a pointer to garbage.  The most common place\n-where this problem crops up is in classes like the libg++\n-@code{String} class, that define a conversion function to type\n-@code{char *} or @code{const char *}.  However, any class that returns\n-a pointer to some internal structure is potentially subject to this\n-problem.\n+where this problem crops up is in classes like string classes,\n+especially ones that define a conversion function to type @code{char *}\n+or @code{const char *} -- which is one reason why the standard\n+@code{string} class requires you to call the @code{c_str} member\n+function.  However, any class that returns a pointer to some internal\n+structure is potentially subject to this problem.\n \n For example, a program may use a function @code{strfunc} that returns\n-@code{String} objects, and another function @code{charfunc} that\n+@code{string} objects, and another function @code{charfunc} that\n operates on pointers to @code{char}:\n \n @example\n-String strfunc ();\n+string strfunc ();\n void charfunc (const char *);\n+\n+void \n+f ()\n+@{\n+  const char *p = strfunc().c_str();\n+  ...\n+  charfunc (p);\n+  ...\n+  charfunc (p);\n+@}\n @end example\n \n @noindent\n-In this situation, it may seem natural to write @w{@samp{charfunc\n-(strfunc ());}} based on the knowledge that class @code{String} has an\n-explicit conversion to @code{char} pointers.  However, what really\n-happens is akin to @samp{charfunc (@w{strfunc ()}.@w{convert ()});},\n-where the @code{convert} method is a function to do the same data\n-conversion normally performed by a cast.  Since the last use of the\n-temporary @code{String} object is the call to the conversion function,\n-the compiler may delete that object before actually calling\n-@code{charfunc}.  The compiler has no way of knowing that deleting the\n-@code{String} object will invalidate the pointer.  The pointer then\n-points to garbage, so that by the time @code{charfunc} is called, it\n-gets an invalid argument.\n+In this situation, it may seem reasonable to save a pointer to the C\n+string returned by the @code{c_str} member function and use that rather\n+than call @code{c_str} repeatedly.  However, the temporary string\n+created by the call to @code{strfunc} is destroyed after @code{p} is\n+initialized, at which point @code{p} is left pointing to freed memory.\n \n Code like this may run successfully under some other compilers,\n-especially those that delete temporaries relatively late.  However, the\n-GNU C++ behavior is also standard-conforming, so if your program depends\n-on late destruction of temporaries it is not portable.\n-\n-If you think this is surprising, you should be aware that the ANSI C++\n-committee continues to debate the lifetime-of-temporaries problem.\n+particularly obsolete cfront-based compilers that delete temporaries\n+along with normal local variables.  However, the GNU C++ behavior is\n+standard-conforming, so if your program depends on late destruction of\n+temporaries it is not portable.\n \n-For now, at least, the safe way to write such code is to give the\n-temporary a name, which forces it to remain until the end of the scope of\n-the name.  For example:\n+The safe way to write such code is to give the temporary a name, which\n+forces it to remain until the end of the scope of the name.  For\n+example:\n \n @example\n-String& tmp = strfunc ();\n-charfunc (tmp);\n+string& tmp = strfunc ();\n+charfunc (tmp.c_str ());\n @end example\n \n @node Protoize Caveats"}]}