{"sha": "0af5da7fb02b22c775094c868ea907b69ec7a3c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFmNWRhN2ZiMDJiMjJjNzc1MDk0Yzg2OGVhOTA3YjY5ZWM3YTNjMQ==", "commit": {"author": {"name": "Fariborz Jahanian", "email": "fjahanian@apple.com", "date": "2004-03-30T20:00:23Z"}, "committer": {"name": "Fariborz Jahanian", "email": "fjahanian@gcc.gnu.org", "date": "2004-03-30T20:00:23Z"}, "message": "Reassociate multiply expression with an adjacent non-multiply expression.\n\nReviewed by Roger Sayle.\n\nFrom-SVN: r80093", "tree": {"sha": "ec2e191c5a9154e212b3e213108a31cd8ca98477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec2e191c5a9154e212b3e213108a31cd8ca98477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0af5da7fb02b22c775094c868ea907b69ec7a3c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af5da7fb02b22c775094c868ea907b69ec7a3c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0af5da7fb02b22c775094c868ea907b69ec7a3c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af5da7fb02b22c775094c868ea907b69ec7a3c1/comments", "author": null, "committer": null, "parents": [{"sha": "cfdfa11075770af7e2c8b0d3fd7e17d066c7385d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfdfa11075770af7e2c8b0d3fd7e17d066c7385d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfdfa11075770af7e2c8b0d3fd7e17d066c7385d"}], "stats": {"total": 36, "additions": 36, "deletions": 0}, "files": [{"sha": "61813c4529e09c2b8852b4a879bdc684a5ac2ac3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af5da7fb02b22c775094c868ea907b69ec7a3c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af5da7fb02b22c775094c868ea907b69ec7a3c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0af5da7fb02b22c775094c868ea907b69ec7a3c1", "patch": "@@ -1,3 +1,9 @@\n+2004-03-29  Fariborz Jahanian <fjahanian@apple.com>\n+\n+        * fold-const.c (fold): Reassociate multiply expression\n+        with an adjacent non-multiply expression to use\n+        architecture's multiply-add instruction.\n+\n 2004-03-30  Zack Weinberg  <zack@codesourcery.com>\n \n \t* gengtype.c (create_option): New function."}, {"sha": "9be1ceae02373c35e35885cbec2f2e6dcd396df6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af5da7fb02b22c775094c868ea907b69ec7a3c1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af5da7fb02b22c775094c868ea907b69ec7a3c1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0af5da7fb02b22c775094c868ea907b69ec7a3c1", "patch": "@@ -6042,6 +6042,36 @@ fold (tree expr)\n \t\t\t\t  TREE_OPERAND (arg0, 0),\n \t\t\t\t  build_real (type, c1)));\n \t    }\n+          /* Convert a + (b*c + d*e) into (a + b*c) + d*e */\n+          if (flag_unsafe_math_optimizations\n+              && TREE_CODE (arg1) == PLUS_EXPR\n+              && TREE_CODE (arg0) != MULT_EXPR)\n+            {\n+              tree tree10 = TREE_OPERAND (arg1, 0);\n+              tree tree11 = TREE_OPERAND (arg1, 1);\n+              if (TREE_CODE (tree11) == MULT_EXPR\n+\t\t  && TREE_CODE (tree10) == MULT_EXPR)\n+                {\n+                  tree tree0;\n+                  tree0 = fold (build (PLUS_EXPR, type, arg0, tree10));\n+                  return fold (build (PLUS_EXPR, type, tree0, tree11));\n+                }\n+            }\n+          /* Convert (b*c + d*e) + a into b*c + (d*e +a) */\n+          if (flag_unsafe_math_optimizations\n+              && TREE_CODE (arg0) == PLUS_EXPR\n+              && TREE_CODE (arg1) != MULT_EXPR)\n+            {\n+              tree tree00 = TREE_OPERAND (arg0, 0);\n+              tree tree01 = TREE_OPERAND (arg0, 1);\n+              if (TREE_CODE (tree01) == MULT_EXPR\n+\t\t  && TREE_CODE (tree00) == MULT_EXPR)\n+                {\n+                  tree tree0;\n+                  tree0 = fold (build (PLUS_EXPR, type, tree01, arg1));\n+                  return fold (build (PLUS_EXPR, type, tree00, tree0));\n+                }\n+            }\n \t}\n \n      bit_rotate:"}]}