{"sha": "cffd725c0eb44daa0234f3af39cd94ad97f2833d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmZDcyNWMwZWI0NGRhYTAyMzRmM2FmMzljZDk0YWQ5N2YyODMzZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-11-30T14:00:28Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-12-01T10:25:58Z"}, "message": "testsuite: remove LIT annotation and reduce\n\nI noticed the test-case contains LIT annotation and\nit is possible to reduce. I did that with compiler that\nwas affected by the PR.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/torture/pr93347.C: Reduce and remove LIT keywords.", "tree": {"sha": "0c228b4dce4ea2879f04906dd6ef0c1893c3125b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c228b4dce4ea2879f04906dd6ef0c1893c3125b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cffd725c0eb44daa0234f3af39cd94ad97f2833d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffd725c0eb44daa0234f3af39cd94ad97f2833d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cffd725c0eb44daa0234f3af39cd94ad97f2833d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffd725c0eb44daa0234f3af39cd94ad97f2833d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc4ae2b263bced781a2d2d0cf0085d262040db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc4ae2b263bced781a2d2d0cf0085d262040db6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbc4ae2b263bced781a2d2d0cf0085d262040db6"}], "stats": {"total": 320, "additions": 17, "deletions": 303}, "files": [{"sha": "6e3b1af25f155a86c67025dd78a8b2dd16fd43c3", "filename": "gcc/testsuite/g++.dg/torture/pr93347.C", "status": "modified", "additions": 17, "deletions": 303, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cffd725c0eb44daa0234f3af39cd94ad97f2833d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93347.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cffd725c0eb44daa0234f3af39cd94ad97f2833d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93347.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93347.C?ref=cffd725c0eb44daa0234f3af39cd94ad97f2833d", "patch": "@@ -1,306 +1,20 @@\n // { dg-additional-options \"--param early-inlining-insns=3 --param ipa-cp-eval-threshold=100\" }\n \n-namespace Test1 {\n-  struct A {\n-    virtual int f() final;\n-  };\n \n-  // CHECK-LABEL: define i32 @_ZN5Test11fEPNS_1AE\n-  int f(A *a) {\n-    // CHECK: call i32 @_ZN5Test11A1fEv\n-    return a->f();\n-  }\n-}\n-\n-namespace Test2 {\n-  struct A final {\n-    virtual int f();\n-  };\n-\n-  // CHECK-LABEL: define i32 @_ZN5Test21fEPNS_1AE\n-  int f(A *a) {\n-    // CHECK: call i32 @_ZN5Test21A1fEv\n-    return a->f();\n-  }\n-}\n-\n-namespace Test2a {\n-  struct A {\n-    virtual ~A() final {}\n-    virtual int f();\n-  };\n-\n-  // CHECK-LABEL: define i32 @_ZN6Test2a1fEPNS_1AE\n-  int f(A *a) {\n-    // CHECK: call i32 @_ZN6Test2a1A1fEv\n-    return a->f();\n-  }\n-}\n-\n-\n-namespace Test3 {\n-  struct A {\n-    virtual int f();  };\n-\n-  struct B final : A { };\n-\n-  // CHECK-LABEL: define i32 @_ZN5Test31fEPNS_1BE\n-  int f(B *b) {\n-    // CHECK: call i32 @_ZN5Test31A1fEv\n-    return b->f();\n-  }\n-\n-  // CHECK-LABEL: define i32 @_ZN5Test31fERNS_1BE\n-  int f(B &b) {\n-    // CHECK: call i32 @_ZN5Test31A1fEv\n-    return b.f();\n-  }\n-\n-  // CHECK-LABEL: define i32 @_ZN5Test31fEPv\n-  int f(void *v) {\n-    // CHECK: call i32 @_ZN5Test31A1fEv\n-    return static_cast<B*>(v)->f();\n-  }\n-}\n-\n-namespace Test4 {\n-  struct A {\n-    virtual void f();\n-    virtual int operator-();\n-  };\n-\n-  struct B final : A {\n-    virtual void f();\n-    virtual int operator-();\n-  };\n-\n-  // CHECK-LABEL: define void @_ZN5Test41fEPNS_1BE\n-  void f(B* d) {\n-    // CHECK: call void @_ZN5Test41B1fEv\n-    static_cast<A*>(d)->f();\n-    // CHECK: call i32 @_ZN5Test41BngEv\n-    -static_cast<A&>(*d);\n-  }\n-}\n-\n-namespace Test5 {\n-  struct A {\n-    virtual void f();\n-    virtual int operator-();\n-  };\n-\n-  struct B : A {\n-    virtual void f();\n-    virtual int operator-();\n-  };\n-\n-  struct C final : B {\n-  };\n-\n-  // CHECK-LABEL: define void @_ZN5Test51fEPNS_1CE\n-  void f(C* d) {\n-    // FIXME: It should be possible to devirtualize this case, but that is\n-    // not implemented yet.\n-    // CHECK: getelementptr\n-    // CHECK-NEXT: %[[FUNC:.*]] = load\n-    // CHECK-NEXT: call void %[[FUNC]]\n-    static_cast<A*>(d)->f();\n-  }\n-  // CHECK-LABEL: define void @_ZN5Test53fopEPNS_1CE\n-  void fop(C* d) {\n-    // FIXME: It should be possible to devirtualize this case, but that is\n-    // not implemented yet.\n-    // CHECK: getelementptr\n-    // CHECK-NEXT: %[[FUNC:.*]] = load\n-    // CHECK-NEXT: call i32 %[[FUNC]]\n-    -static_cast<A&>(*d);\n-  }\n-}\n-\n-namespace Test6 {\n-  struct A {\n-    virtual ~A();\n-  };\n-\n-  struct B : public A {\n-    virtual ~B();\n-  };\n-\n-  struct C {\n-    virtual ~C();\n-  };\n-\n-  struct D final : public C, public B {\n-  };\n-\n-  // CHECK-LABEL: define void @_ZN5Test61fEPNS_1DE\n-  void f(D* d) {\n-    // CHECK: call void @_ZN5Test61DD1Ev\n-    static_cast<A*>(d)->~A();\n-  }\n-}\n-\n-namespace Test7 {\n-  struct foo {\n-    virtual void g() {}\n-  };\n-\n-  struct bar {\n-    virtual int f() { return 0; }\n-  };\n-\n-  struct zed final : public foo, public bar {\n-    int z;\n-    virtual int f() {return z;}\n-  };\n-\n-  // CHECK-LABEL: define i32 @_ZN5Test71fEPNS_3zedE\n-  int f(zed *z) {\n-    // CHECK: alloca\n-    // CHECK-NEXT: store\n-    // CHECK-NEXT: load\n-    // CHECK-NEXT: call i32 @_ZN5Test73zed1fEv\n-    // CHECK-NEXT: ret\n-    return static_cast<bar*>(z)->f();\n-  }\n-}\n-\n-namespace Test8 {\n-  struct A { virtual ~A() {} };\n-  struct B {\n-    int b;\n-    virtual int foo() { return b; }\n-  };\n-  struct C final : A, B {  };\n-  // CHECK-LABEL: define i32 @_ZN5Test84testEPNS_1CE\n-  int test(C *c) {\n-    // CHECK: %[[THIS:.*]] = phi\n-    // CHECK-NEXT: call i32 @_ZN5Test81B3fooEv(%\"struct.Test8::B\"* %[[THIS]])\n-    return static_cast<B*>(c)->foo();\n-  }\n-}\n-\n-namespace Test9 {\n-  struct A {\n-    int a;\n-  };\n-  struct B {\n-    int b;\n-  };\n-  struct C : public B, public A {\n-  };\n-  struct RA {\n-    virtual A *f() {\n-      return 0;\n-    }\n-    virtual A *operator-() {\n-      return 0;\n-    }\n-  };\n-  struct RC final : public RA {\n-    virtual C *f() {\n-      C *x = new C();\n-      x->a = 1;\n-      x->b = 2;\n-      return x;\n-    }\n-    virtual C *operator-() {\n-      C *x = new C();\n-      x->a = 1;\n-      x->b = 2;\n-      return x;\n-    }\n-  };\n-  // CHECK: define {{.*}} @_ZN5Test91fEPNS_2RCE\n-  A *f(RC *x) {\n-    // FIXME: It should be possible to devirtualize this case, but that is\n-    // not implemented yet.\n-    // CHECK: load\n-    // CHECK: bitcast\n-    // CHECK: [[F_PTR_RA:%.+]] = bitcast\n-    // CHECK: [[VTABLE:%.+]] = load {{.+}} [[F_PTR_RA]]\n-    // CHECK: [[VFN:%.+]] = getelementptr inbounds {{.+}} [[VTABLE]], i{{[0-9]+}} 0\n-    // CHECK-NEXT: %[[FUNC:.*]] = load {{.+}} [[VFN]]\n-    // CHECK-NEXT: = call {{.*}} %[[FUNC]]\n-    return static_cast<RA*>(x)->f();\n-  }\n-  // CHECK: define {{.*}} @_ZN5Test93fopEPNS_2RCE\n-  A *fop(RC *x) {\n-    // FIXME: It should be possible to devirtualize this case, but that is\n-    // not implemented yet.\n-    // CHECK: load\n-    // CHECK: bitcast\n-    // CHECK: [[F_PTR_RA:%.+]] = bitcast\n-    // CHECK: [[VTABLE:%.+]] = load {{.+}} [[F_PTR_RA]]\n-    // CHECK: [[VFN:%.+]] = getelementptr inbounds {{.+}} [[VTABLE]], i{{[0-9]+}} 1\n-    // CHECK-NEXT: %[[FUNC:.*]] = load {{.+}} [[VFN]]\n-    // CHECK-NEXT: = call {{.*}} %[[FUNC]]\n-    return -static_cast<RA&>(*x);\n-  }\n-}\n-\n-namespace Test10 {\n-  struct A {\n-    virtual int f();\n-  };\n-\n-  struct B : A {\n-    int f() final;\n-  };\n-\n-  // CHECK-LABEL: define i32 @_ZN6Test101fEPNS_1BE\n-  int f(B *b) {\n-    // CHECK: call i32 @_ZN6Test101B1fEv\n-    return static_cast<A *>(b)->f();\n-  }\n-}\n-\n-namespace Test11 {\n-  // Check that the definitions of Derived's operators are emitted.\n-\n-  // CHECK-LABEL: define linkonce_odr void @_ZN6Test111SIiE4foo1Ev(\n-  // CHECK: call void @_ZN6Test111SIiE7DerivedclEv(\n-  // CHECK: call zeroext i1 @_ZN6Test111SIiE7DerivedeqERKNS_4BaseE(\n-  // CHECK: call zeroext i1 @_ZN6Test111SIiE7DerivedntEv(\n-  // CHECK: call dereferenceable(4) %\"class.Test11::Base\"* @_ZN6Test111SIiE7DerivedixEi(\n-  // CHECK: define linkonce_odr void @_ZN6Test111SIiE7DerivedclEv(\n-  // CHECK: define linkonce_odr zeroext i1 @_ZN6Test111SIiE7DerivedeqERKNS_4BaseE(\n-  // CHECK: define linkonce_odr zeroext i1 @_ZN6Test111SIiE7DerivedntEv(\n-  // CHECK: define linkonce_odr dereferenceable(4) %\"class.Test11::Base\"* @_ZN6Test111SIiE7DerivedixEi(\n-  class Base {\n-  public:\n-    virtual void operator()() {}\n-    virtual bool operator==(const Base &other) { return false; }\n-    virtual bool operator!() { return false; }\n-    virtual Base &operator[](int i) { return *this; }\n-  };\n-\n-  template<class T>\n-  struct S {\n-    class Derived final : public Base {\n-    public:\n-      void operator()() override {}\n-      bool operator==(const Base &other) override { return true; }\n-      bool operator!() override { return true; }\n-      Base &operator[](int i) override { return *this; }\n-    };\n-\n-    Derived *ptr = nullptr, *ptr2 = nullptr;\n-\n-    void foo1() {\n-      if (ptr && ptr2) {\n-        // These calls get devirtualized. Linkage fails if the definitions of\n-        // the called functions are not emitted.\n-        (*ptr)();\n-        (void)(*ptr == *ptr2);\n-        (void)(!(*ptr));\n-        (void)((*ptr)[1]);\n-      }\n-    }\n-  };\n-\n-  void foo2() {\n-    S<int> *s = new S<int>;\n-    s->foo1();\n-  }\n-}\n+struct A {\n+  int a;\n+};\n+struct B {\n+  int b;\n+};\n+struct C : B, A {};\n+struct RA {\n+  virtual A *operator-();\n+};\n+struct RC : RA {\n+  C *operator-() {\n+    C *x = new C();\n+    return x;\n+  }\n+};\n+void fop(RC *x) { -static_cast<RA &>(*x); }"}]}