{"sha": "0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ4Zjc0YjRjZjA2ODM1YTMyN2FhZWY2OTc4N2E0YjdkOWRjOGU2Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-11-08T15:19:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-11-08T15:19:20Z"}, "message": "decl.c (components_to_record): Remove obsolete kludge.\n\n\t* gcc-interface/decl.c (components_to_record): Remove obsolete kludge.\n\t* gcc-interface/utils.c (make_packable_type): Set TYPE_PACKED on the\n\tnew type but do not take into account the setting on the old type for\n\tthe new fields.  Rename a local variable.\n\t(finish_record_type): Clear DECL_BIT_FIELD_TYPE on a variant part at\n\toffset 0, if any.\n\t(create_field_decl): Tweak comment.\n\nFrom-SVN: r265917", "tree": {"sha": "482495e0d36bb75f4d01e476d891266a00a62810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/482495e0d36bb75f4d01e476d891266a00a62810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/comments", "author": null, "committer": null, "parents": [{"sha": "67124cb62dd566664aa53183821957fa97b27e54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67124cb62dd566664aa53183821957fa97b27e54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67124cb62dd566664aa53183821957fa97b27e54"}], "stats": {"total": 54, "additions": 29, "deletions": 25}, "files": [{"sha": "a1b3c666e3a1e606e47be1e76574d28610b50ef1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "patch": "@@ -1,3 +1,13 @@\n+2018-11-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (components_to_record): Remove obsolete kludge.\n+\t* gcc-interface/utils.c (make_packable_type): Set TYPE_PACKED on the\n+\tnew type but do not take into account the setting on the old type for\n+\tthe new fields.  Rename a local variable.\n+\t(finish_record_type): Clear DECL_BIT_FIELD_TYPE on a variant part at\n+\toffset 0, if any.\n+\t(create_field_decl): Tweak comment.\n+\n 2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (unchecked_convert): Use local variables for"}, {"sha": "d8fb8ee74b984cf4f438fa6e0aab11a218f1d3c0", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "patch": "@@ -8146,23 +8146,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \n   /* Chain the variant part at the end of the field list.  */\n   if (gnu_variant_part)\n-    {\n-      /* We make an exception if the variant part is at offset 0, has a fixed\n-\t size, and there is a single rep'ed field placed after it because, in\n-\t this case, there is an obvious order of increasing position.  */\n-      if (variants_have_rep\n-\t  && TREE_CODE (DECL_SIZE_UNIT (gnu_variant_part)) == INTEGER_CST\n-\t  && gnu_rep_list\n-\t  && gnu_field_list == gnu_rep_list\n-\t  && !tree_int_cst_lt (DECL_FIELD_OFFSET (gnu_rep_list),\n-\t\t\t       DECL_SIZE_UNIT (gnu_variant_part)))\n-\t{\n-\t  DECL_CHAIN (gnu_variant_part) = gnu_field_list;\n-\t  gnu_field_list = gnu_variant_part;\n-\t}\n-      else\n-\tgnu_field_list = chainon (gnu_field_list, gnu_variant_part);\n-    }\n+    gnu_field_list = chainon (gnu_field_list, gnu_variant_part);\n \n   if (cancel_alignment)\n     SET_TYPE_ALIGN (gnu_record_type, 0);"}, {"sha": "05959d6427bd4f90eeb78e0c2a80094e6fa37973", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8f74b4cf06835a327aaef69787a4b7d9dc8e66/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0d8f74b4cf06835a327aaef69787a4b7d9dc8e66", "patch": "@@ -973,6 +973,7 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n      Note that we rely on the pointer equality created here for\n      TYPE_NAME to look through conversions in various places.  */\n   TYPE_NAME (new_type) = TYPE_NAME (type);\n+  TYPE_PACKED (new_type) = 1;\n   TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n   TYPE_REVERSE_STORAGE_ORDER (new_type) = TYPE_REVERSE_STORAGE_ORDER (type);\n@@ -1018,7 +1019,7 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       tree new_field_type = TREE_TYPE (field);\n-      tree new_field, new_size;\n+      tree new_field, new_field_size;\n \n       if (RECORD_OR_UNION_TYPE_P (new_field_type)\n \t  && !TYPE_FAT_POINTER_P (new_field_type)\n@@ -1034,14 +1035,15 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n \t  && !TYPE_FAT_POINTER_P (new_field_type)\n \t  && !TYPE_CONTAINS_TEMPLATE_P (new_field_type)\n \t  && TYPE_ADA_SIZE (new_field_type))\n-\tnew_size = TYPE_ADA_SIZE (new_field_type);\n+\tnew_field_size = TYPE_ADA_SIZE (new_field_type);\n       else\n-\tnew_size = DECL_SIZE (field);\n+\tnew_field_size = DECL_SIZE (field);\n \n+      /* This is a layout with full representation, alignment and size clauses\n+\t so we simply pass 0 as PACKED like gnat_to_gnu_field in this case.  */\n       new_field\n \t= create_field_decl (DECL_NAME (field), new_field_type, new_type,\n-\t\t\t     new_size, bit_position (field),\n-\t\t\t     TYPE_PACKED (type),\n+\t\t\t     new_field_size, bit_position (field), 0,\n \t\t\t     !DECL_NONADDRESSABLE_P (field));\n \n       DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (field);\n@@ -1896,6 +1898,14 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n \t    DECL_BIT_FIELD (field) = 0;\n \t}\n \n+      /* Clear DECL_BIT_FIELD_TYPE for a variant part at offset 0, it's simply\n+\t not supported by the DECL_BIT_FIELD_REPRESENTATIVE machinery because\n+\t the variant part is always the last field in the list.  */\n+      if (DECL_INTERNAL_P (field)\n+\t  && TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n+\t  && integer_zerop (pos))\n+\tDECL_BIT_FIELD_TYPE (field) = NULL_TREE;\n+\n       /* If we still have DECL_BIT_FIELD set at this point, we know that the\n \t field is technically not addressable.  Except that it can actually\n \t be addressed if it is BLKmode and happens to be properly aligned.  */\n@@ -2725,17 +2735,17 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n \tsize = round_up (size, BITS_PER_UNIT);\n     }\n \n-  /* If we may, according to ADDRESSABLE, make a bitfield if a size is\n+  /* If we may, according to ADDRESSABLE, make a bitfield when the size is\n      specified for two reasons: first if the size differs from the natural\n-     size.  Second, if the alignment is insufficient.  There are a number of\n+     size; second, if the alignment is insufficient.  There are a number of\n      ways the latter can be true.\n \n      We never make a bitfield if the type of the field has a nonconstant size,\n      because no such entity requiring bitfield operations should reach here.\n \n      We do *preventively* make a bitfield when there might be the need for it\n      but we don't have all the necessary information to decide, as is the case\n-     of a field with no specified position in a packed record.\n+     of a field in a packed record.\n \n      We also don't look at STRICT_ALIGNMENT here, and rely on later processing\n      in layout_decl or finish_record_type to clear the bit_field indication if"}]}