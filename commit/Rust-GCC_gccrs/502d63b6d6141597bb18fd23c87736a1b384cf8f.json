{"sha": "502d63b6d6141597bb18fd23c87736a1b384cf8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyZDYzYjZkNjE0MTU5N2JiMThmZDIzYzg3NzM2YTFiMzg0Y2Y4Zg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-03-09T12:23:03Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-17T10:04:22Z"}, "message": "Lower VEC_COND_EXPR into internal functions.\n\ngcc/ChangeLog:\n\n\t* Makefile.in: Add new file.\n\t* expr.c (expand_expr_real_2): Add gcc_unreachable as we should\n\tnot meet this condition.\n\t(do_store_flag): Likewise.\n\t* gimplify.c (gimplify_expr): Gimplify first argument of\n\tVEC_COND_EXPR to be a SSA name.\n\t* internal-fn.c (vec_cond_mask_direct): New.\n\t(vec_cond_direct): Likewise.\n\t(vec_condu_direct): Likewise.\n\t(vec_condeq_direct): Likewise.\n\t(expand_vect_cond_optab_fn):  New.\n\t(expand_vec_cond_optab_fn): Likewise.\n\t(expand_vec_condu_optab_fn): Likewise.\n\t(expand_vec_condeq_optab_fn): Likewise.\n\t(expand_vect_cond_mask_optab_fn): Likewise.\n\t(expand_vec_cond_mask_optab_fn): Likewise.\n\t(direct_vec_cond_mask_optab_supported_p): Likewise.\n\t(direct_vec_cond_optab_supported_p): Likewise.\n\t(direct_vec_condu_optab_supported_p): Likewise.\n\t(direct_vec_condeq_optab_supported_p): Likewise.\n\t* internal-fn.def (VCOND): New OPTAB.\n\t(VCONDU): Likewise.\n\t(VCONDEQ): Likewise.\n\t(VCOND_MASK): Likewise.\n\t* optabs.c (get_rtx_code): Make it global.\n\t(expand_vec_cond_mask_expr): Removed.\n\t(expand_vec_cond_expr): Removed.\n\t* optabs.h (expand_vec_cond_expr): Likewise.\n\t(vector_compare_rtx): Make it global.\n\t* passes.def: Add new pass_gimple_isel pass.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Add check\n\tfor VEC_COND_EXPR about first argument.\n\t* tree-pass.h (make_pass_gimple_isel): New.\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Prevent\n\tpropagation of the first argument of a VEC_COND_EXPR.\n\t* tree-ssa-reassoc.c (ovce_extract_ops): Support SSA_NAME as\n\tfirst argument of a VEC_COND_EXPR.\n\t(optimize_vec_cond_expr): Likewise.\n\t* tree-vect-generic.c (expand_vector_divmod): Make SSA_NAME\n\tfor a first argument of created VEC_COND_EXPR.\n\t(expand_vector_condition): Fix coding style.\n\t* tree-vect-stmts.c (vectorizable_condition): Gimplify\n\tfirst argument.\n\t* gimple-isel.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/vect/vec-cond-expr-eh.C: New test.", "tree": {"sha": "eba6680f649788bfbb44d1ec63183781460c997f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eba6680f649788bfbb44d1ec63183781460c997f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/502d63b6d6141597bb18fd23c87736a1b384cf8f", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl7p6qYACgkQTcGC3A+n\nN4U4Owf/fznYGda9/xHE29dOc2p9gfTlP+k9WNECYPYFSLByZ2rEEb2/qRs7mF5I\n58fskkETB93wJCqhulfqn9C6/7KIb4tv8ilG5Q5O23mGPiRR4Og5NN7NjCwQxM5D\nxuVK16W3zxW1toNm9pDUyTNDPva/y5XxJ7B4dtxrr2wCsk6NJ2HbMDWGX31e+0ER\nv8SgM7S2hUkUrNOI55/8/iV3z3eiocltQAkRND1fJf6vuxpUSQ8YKZl2ZcsZkdd/\nwsRIxTKe7tewHnkU1r0PL50SSwm2INLqPbJ90OTg2woZGFXvcU61ugWjXLIhApCT\nAT0NDd6bm1nSnSFgY7gbemRx0L+zbg==\n=JZ1X\n-----END PGP SIGNATURE-----", "payload": "tree eba6680f649788bfbb44d1ec63183781460c997f\nparent 2021af0c23acaa827b5a8c5c5ba82b713f9cff1e\nauthor Martin Liska <mliska@suse.cz> 1583756583 +0100\ncommitter Martin Liska <mliska@suse.cz> 1592388262 +0200\n\nLower VEC_COND_EXPR into internal functions.\n\ngcc/ChangeLog:\n\n\t* Makefile.in: Add new file.\n\t* expr.c (expand_expr_real_2): Add gcc_unreachable as we should\n\tnot meet this condition.\n\t(do_store_flag): Likewise.\n\t* gimplify.c (gimplify_expr): Gimplify first argument of\n\tVEC_COND_EXPR to be a SSA name.\n\t* internal-fn.c (vec_cond_mask_direct): New.\n\t(vec_cond_direct): Likewise.\n\t(vec_condu_direct): Likewise.\n\t(vec_condeq_direct): Likewise.\n\t(expand_vect_cond_optab_fn):  New.\n\t(expand_vec_cond_optab_fn): Likewise.\n\t(expand_vec_condu_optab_fn): Likewise.\n\t(expand_vec_condeq_optab_fn): Likewise.\n\t(expand_vect_cond_mask_optab_fn): Likewise.\n\t(expand_vec_cond_mask_optab_fn): Likewise.\n\t(direct_vec_cond_mask_optab_supported_p): Likewise.\n\t(direct_vec_cond_optab_supported_p): Likewise.\n\t(direct_vec_condu_optab_supported_p): Likewise.\n\t(direct_vec_condeq_optab_supported_p): Likewise.\n\t* internal-fn.def (VCOND): New OPTAB.\n\t(VCONDU): Likewise.\n\t(VCONDEQ): Likewise.\n\t(VCOND_MASK): Likewise.\n\t* optabs.c (get_rtx_code): Make it global.\n\t(expand_vec_cond_mask_expr): Removed.\n\t(expand_vec_cond_expr): Removed.\n\t* optabs.h (expand_vec_cond_expr): Likewise.\n\t(vector_compare_rtx): Make it global.\n\t* passes.def: Add new pass_gimple_isel pass.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Add check\n\tfor VEC_COND_EXPR about first argument.\n\t* tree-pass.h (make_pass_gimple_isel): New.\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Prevent\n\tpropagation of the first argument of a VEC_COND_EXPR.\n\t* tree-ssa-reassoc.c (ovce_extract_ops): Support SSA_NAME as\n\tfirst argument of a VEC_COND_EXPR.\n\t(optimize_vec_cond_expr): Likewise.\n\t* tree-vect-generic.c (expand_vector_divmod): Make SSA_NAME\n\tfor a first argument of created VEC_COND_EXPR.\n\t(expand_vector_condition): Fix coding style.\n\t* tree-vect-stmts.c (vectorizable_condition): Gimplify\n\tfirst argument.\n\t* gimple-isel.cc: New file.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/vect/vec-cond-expr-eh.C: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502d63b6d6141597bb18fd23c87736a1b384cf8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502d63b6d6141597bb18fd23c87736a1b384cf8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502d63b6d6141597bb18fd23c87736a1b384cf8f/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2021af0c23acaa827b5a8c5c5ba82b713f9cff1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2021af0c23acaa827b5a8c5c5ba82b713f9cff1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2021af0c23acaa827b5a8c5c5ba82b713f9cff1e"}], "stats": {"total": 652, "additions": 441, "deletions": 211}, "files": [{"sha": "238b529f373d7a33d8a8ecc6c4d7f2d0659c4f2a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -1631,6 +1631,7 @@ OBJS = \\\n \ttree-streamer-out.o \\\n \ttree-tailcall.o \\\n \ttree-vect-generic.o \\\n+\tgimple-isel.o \\\n \ttree-vect-patterns.o \\\n \ttree-vect-data-refs.o \\\n \ttree-vect-stmts.o \\\n@@ -2600,6 +2601,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/dwarf2cfi.c \\\n   $(srcdir)/dwarf2out.c \\\n   $(srcdir)/tree-vect-generic.c \\\n+  $(srcdir)/gimple-isel.cc \\\n   $(srcdir)/dojump.c $(srcdir)/emit-rtl.h \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \\\n   $(srcdir)/expr.h \\"}, {"sha": "3c68b0d754cae1f71acd7020fd6f6ef4ff2cb9dc", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -9316,17 +9316,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       if (temp != 0)\n \treturn temp;\n \n-      /* For vector MIN <x, y>, expand it a VEC_COND_EXPR <x <= y, x, y>\n-\t and similarly for MAX <x, y>.  */\n       if (VECTOR_TYPE_P (type))\n-\t{\n-\t  tree t0 = make_tree (type, op0);\n-\t  tree t1 = make_tree (type, op1);\n-\t  tree comparison = build2 (code == MIN_EXPR ? LE_EXPR : GE_EXPR,\n-\t\t\t\t    type, t0, t1);\n-\t  return expand_vec_cond_expr (type, comparison, t0, t1,\n-\t\t\t\t       original_target);\n-\t}\n+\tgcc_unreachable ();\n \n       /* At this point, a MEM target is no longer useful; we will get better\n \t code without it.  */\n@@ -9915,10 +9906,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \treturn temp;\n       }\n \n-    case VEC_COND_EXPR:\n-      target = expand_vec_cond_expr (type, treeop0, treeop1, treeop2, target);\n-      return target;\n-\n     case VEC_DUPLICATE_EXPR:\n       op0 = expand_expr (treeop0, NULL_RTX, VOIDmode, modifier);\n       target = expand_vector_broadcast (mode, op0);\n@@ -12249,21 +12236,15 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n   STRIP_NOPS (arg1);\n \n   /* For vector typed comparisons emit code to generate the desired\n-     all-ones or all-zeros mask.  Conveniently use the VEC_COND_EXPR\n-     expander for this.  */\n+     all-ones or all-zeros mask.  */\n   if (TREE_CODE (ops->type) == VECTOR_TYPE)\n     {\n       tree ifexp = build2 (ops->code, ops->type, arg0, arg1);\n       if (VECTOR_BOOLEAN_TYPE_P (ops->type)\n \t  && expand_vec_cmp_expr_p (TREE_TYPE (arg0), ops->type, ops->code))\n \treturn expand_vec_cmp_expr (ops->type, ifexp, target);\n       else\n-\t{\n-\t  tree if_true = constant_boolean_node (true, ops->type);\n-\t  tree if_false = constant_boolean_node (false, ops->type);\n-\t  return expand_vec_cond_expr (ops->type, ifexp, if_true,\n-\t\t\t\t       if_false, target);\n-\t}\n+\tgcc_unreachable ();\n     }\n \n   /* Optimize (x % C1) == C2 or (x % C1) != C2 if it is beneficial"}, {"sha": "97f9208050322a3bd874c7938e9226ac92991699", "filename": "gcc/gimple-isel.cc", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fgimple-isel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fgimple-isel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-isel.cc?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -0,0 +1,244 @@\n+/* Schedule GIMPLE vector statements.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"expmed.h\"\n+#include \"optabs-tree.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify-me.h\"\n+#include \"gimplify.h\"\n+#include \"tree-cfg.h\"\n+\n+/* Expand all VEC_COND_EXPR gimple assignments into calls to internal\n+   function based on type of selected expansion.  */\n+\n+static gimple *\n+gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,\n+\t\t\t     hash_map<tree, unsigned int> *vec_cond_ssa_name_uses)\n+{\n+  tree lhs, op0a = NULL_TREE, op0b = NULL_TREE;\n+  enum tree_code code;\n+  enum tree_code tcode;\n+  machine_mode cmp_op_mode;\n+  bool unsignedp;\n+  enum insn_code icode;\n+  imm_use_iterator imm_iter;\n+\n+  /* Only consider code == GIMPLE_ASSIGN.  */\n+  gassign *stmt = dyn_cast<gassign *> (gsi_stmt (*gsi));\n+  if (!stmt)\n+    return NULL;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+  if (code != VEC_COND_EXPR)\n+    return NULL;\n+\n+  tree op0 = gimple_assign_rhs1 (stmt);\n+  tree op1 = gimple_assign_rhs2 (stmt);\n+  tree op2 = gimple_assign_rhs3 (stmt);\n+  lhs = gimple_assign_lhs (stmt);\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+\n+  gcc_assert (!COMPARISON_CLASS_P (op0));\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    {\n+      unsigned int used_vec_cond_exprs = 0;\n+      unsigned int *slot = vec_cond_ssa_name_uses->get (op0);\n+      if (slot)\n+\tused_vec_cond_exprs = *slot;\n+      else\n+\t{\n+\t  gimple *use_stmt;\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, op0)\n+\t    {\n+\t      gassign *assign = dyn_cast<gassign *> (use_stmt);\n+\t      if (assign != NULL\n+\t\t  && gimple_assign_rhs_code (assign) == VEC_COND_EXPR\n+\t\t  && gimple_assign_rhs1 (assign) == op0)\n+\t\tused_vec_cond_exprs++;\n+\t    }\n+\t  vec_cond_ssa_name_uses->put (op0, used_vec_cond_exprs);\n+\t}\n+\n+      gassign *def_stmt = dyn_cast<gassign *> (SSA_NAME_DEF_STMT (op0));\n+      if (def_stmt)\n+\t{\n+\t  tcode = gimple_assign_rhs_code (def_stmt);\n+\t  op0a = gimple_assign_rhs1 (def_stmt);\n+\t  op0b = gimple_assign_rhs2 (def_stmt);\n+\n+\t  tree op0a_type = TREE_TYPE (op0a);\n+\t  if (used_vec_cond_exprs >= 2\n+\t      && (get_vcond_mask_icode (mode, TYPE_MODE (op0a_type))\n+\t\t  != CODE_FOR_nothing)\n+\t      && expand_vec_cmp_expr_p (op0a_type, TREE_TYPE (lhs), tcode))\n+\t    {\n+\t      /* Keep the SSA name and use vcond_mask.  */\n+\t      tcode = TREE_CODE (op0);\n+\t    }\n+\t}\n+      else\n+\ttcode = TREE_CODE (op0);\n+    }\n+  else\n+    tcode = TREE_CODE (op0);\n+\n+  if (TREE_CODE_CLASS (tcode) != tcc_comparison)\n+    {\n+      gcc_assert (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (op0)));\n+      if (get_vcond_mask_icode (mode, TYPE_MODE (TREE_TYPE (op0)))\n+\t  != CODE_FOR_nothing)\n+\treturn gimple_build_call_internal (IFN_VCOND_MASK, 3, op0, op1, op2);\n+      /* Fake op0 < 0.  */\n+      else\n+\t{\n+\t  gcc_assert (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (op0)))\n+\t\t      == MODE_VECTOR_INT);\n+\t  op0a = op0;\n+\t  op0b = build_zero_cst (TREE_TYPE (op0));\n+\t  tcode = LT_EXPR;\n+\t}\n+    }\n+  cmp_op_mode = TYPE_MODE (TREE_TYPE (op0a));\n+  unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));\n+\n+\n+  gcc_assert (known_eq (GET_MODE_SIZE (mode), GET_MODE_SIZE (cmp_op_mode))\n+\t      && known_eq (GET_MODE_NUNITS (mode),\n+\t\t\t   GET_MODE_NUNITS (cmp_op_mode)));\n+\n+  icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      if (tcode == LT_EXPR\n+\t  && op0a == op0\n+\t  && TREE_CODE (op0) == VECTOR_CST)\n+\t{\n+\t  /* A VEC_COND_EXPR condition could be folded from EQ_EXPR/NE_EXPR\n+\t     into a constant when only get_vcond_eq_icode is supported.\n+\t     Verify < 0 and != 0 behave the same and change it to NE_EXPR.  */\n+\t  unsigned HOST_WIDE_INT nelts;\n+\t  if (!VECTOR_CST_NELTS (op0).is_constant (&nelts))\n+\t    {\n+\t      if (VECTOR_CST_STEPPED_P (op0))\n+\t\tgcc_unreachable ();\n+\t      nelts = vector_cst_encoded_nelts (op0);\n+\t    }\n+\t  for (unsigned int i = 0; i < nelts; ++i)\n+\t    if (tree_int_cst_sgn (vector_cst_elt (op0, i)) == 1)\n+\t      gcc_unreachable ();\n+\t  tcode = NE_EXPR;\n+\t}\n+      if (tcode == EQ_EXPR || tcode == NE_EXPR)\n+\t{\n+\t  tree tcode_tree = build_int_cst (integer_type_node, tcode);\n+\t  return gimple_build_call_internal (IFN_VCONDEQ, 5, op0a, op0b, op1,\n+\t\t\t\t\t     op2, tcode_tree);\n+\t}\n+    }\n+\n+  gcc_assert (icode != CODE_FOR_nothing);\n+  tree tcode_tree = build_int_cst (integer_type_node, tcode);\n+  return gimple_build_call_internal (unsignedp ? IFN_VCONDU : IFN_VCOND,\n+\t\t\t\t     5, op0a, op0b, op1, op2, tcode_tree);\n+}\n+\n+\n+\n+/* Iterate all gimple statements and try to expand\n+   VEC_COND_EXPR assignments.  */\n+\n+static unsigned int\n+gimple_expand_vec_cond_exprs (void)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+  bool cfg_changed = false;\n+  hash_map<tree, unsigned int> vec_cond_ssa_name_uses;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple *g = gimple_expand_vec_cond_expr (&gsi,\n+\t\t\t\t\t\t   &vec_cond_ssa_name_uses);\n+\t  if (g != NULL)\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (gsi_stmt (gsi));\n+\t      gimple_set_lhs (g, lhs);\n+\t      gsi_replace (&gsi, g, false);\n+\t    }\n+\t}\n+    }\n+\n+  return cfg_changed ? TODO_cleanup_cfg : 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_gimple_isel =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"isel\", /* name */\n+  OPTGROUP_VEC, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_gimple_isel : public gimple_opt_pass\n+{\n+public:\n+  pass_gimple_isel (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_gimple_isel, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return true;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return gimple_expand_vec_cond_exprs ();\n+    }\n+\n+}; // class pass_gimple_isel\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_gimple_isel (gcc::context *ctxt)\n+{\n+  return new pass_gimple_isel (ctxt);\n+}\n+"}, {"sha": "ab3408f480e623260b46eb1a2614b8cab95d14f9", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -14312,20 +14312,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  }\n \n \tcase VEC_COND_EXPR:\n-\t  {\n-\t    enum gimplify_status r0, r1, r2;\n-\n-\t    r0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n-\t\t\t\tpost_p, is_gimple_condexpr, fb_rvalue);\n-\t    r1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p,\n-\t\t\t\tpost_p, is_gimple_val, fb_rvalue);\n-\t    r2 = gimplify_expr (&TREE_OPERAND (*expr_p, 2), pre_p,\n-\t\t\t\tpost_p, is_gimple_val, fb_rvalue);\n-\n-\t    ret = MIN (MIN (r0, r1), r2);\n-\t    recalculate_side_effects (*expr_p);\n-\t  }\n-\t  break;\n+\t  goto expr_3;\n \n \tcase VEC_PERM_EXPR:\n \t  /* Classified as tcc_expression.  */"}, {"sha": "644f234e087f74288573f90634ee8b6c70c6b202", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa.h\"\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n+#include \"explow.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -107,6 +108,10 @@ init_internal_fns ()\n #define mask_store_direct { 3, 2, false }\n #define store_lanes_direct { 0, 0, false }\n #define mask_store_lanes_direct { 0, 0, false }\n+#define vec_cond_mask_direct { 0, 0, false }\n+#define vec_cond_direct { 0, 0, false }\n+#define vec_condu_direct { 0, 0, false }\n+#define vec_condeq_direct { 0, 0, false }\n #define scatter_store_direct { 3, 1, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n@@ -2548,6 +2553,86 @@ expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n \n #define expand_mask_store_lanes_optab_fn expand_mask_store_optab_fn\n \n+/* Expand VCOND, VCONDU and VCONDEQ optab internal functions.\n+   The expansion of STMT happens based on OPTAB table associated.  */\n+\n+static void\n+expand_vect_cond_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n+{\n+  class expand_operand ops[6];\n+  insn_code icode;\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree op0a = gimple_call_arg (stmt, 0);\n+  tree op0b = gimple_call_arg (stmt, 1);\n+  tree op1 = gimple_call_arg (stmt, 2);\n+  tree op2 = gimple_call_arg (stmt, 3);\n+  enum tree_code tcode = (tree_code) int_cst_value (gimple_call_arg (stmt, 4));\n+\n+  tree vec_cond_type = TREE_TYPE (lhs);\n+  tree op_mode = TREE_TYPE (op0a);\n+  bool unsignedp = TYPE_UNSIGNED (op_mode);\n+\n+  machine_mode mode = TYPE_MODE (vec_cond_type);\n+  machine_mode cmp_op_mode = TYPE_MODE (op_mode);\n+\n+  icode = convert_optab_handler (optab, mode, cmp_op_mode);\n+  rtx comparison\n+    = vector_compare_rtx (VOIDmode, tcode, op0a, op0b, unsignedp, icode, 4);\n+  rtx rtx_op1 = expand_normal (op1);\n+  rtx rtx_op2 = expand_normal (op2);\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], rtx_op1, mode);\n+  create_input_operand (&ops[2], rtx_op2, mode);\n+  create_fixed_operand (&ops[3], comparison);\n+  create_fixed_operand (&ops[4], XEXP (comparison, 0));\n+  create_fixed_operand (&ops[5], XEXP (comparison, 1));\n+  expand_insn (icode, 6, ops);\n+}\n+\n+#define expand_vec_cond_optab_fn expand_vect_cond_optab_fn\n+#define expand_vec_condu_optab_fn expand_vect_cond_optab_fn\n+#define expand_vec_condeq_optab_fn expand_vect_cond_optab_fn\n+\n+/* Expand VCOND_MASK optab internal function.\n+   The expansion of STMT happens based on OPTAB table associated.  */\n+\n+static void\n+expand_vect_cond_mask_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n+{\n+  class expand_operand ops[4];\n+\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree op0 = gimple_call_arg (stmt, 0);\n+  tree op1 = gimple_call_arg (stmt, 1);\n+  tree op2 = gimple_call_arg (stmt, 2);\n+  tree vec_cond_type = TREE_TYPE (lhs);\n+\n+  machine_mode mode = TYPE_MODE (vec_cond_type);\n+  machine_mode mask_mode = TYPE_MODE (TREE_TYPE (op0));\n+  enum insn_code icode = convert_optab_handler (optab, mode, mask_mode);\n+  rtx mask, rtx_op1, rtx_op2;\n+\n+  gcc_assert (icode != CODE_FOR_nothing);\n+\n+  mask = expand_normal (op0);\n+  rtx_op1 = expand_normal (op1);\n+  rtx_op2 = expand_normal (op2);\n+\n+  mask = force_reg (mask_mode, mask);\n+  rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], rtx_op1, mode);\n+  create_input_operand (&ops[2], rtx_op2, mode);\n+  create_input_operand (&ops[3], mask, mask_mode);\n+  expand_insn (icode, 4, ops);\n+}\n+\n+#define expand_vec_cond_mask_optab_fn expand_vect_cond_mask_optab_fn\n+\n static void\n expand_ABNORMAL_DISPATCHER (internal_fn, gcall *)\n {\n@@ -3131,6 +3216,10 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_vec_cond_mask_optab_supported_p multi_vector_optab_supported_p\n+#define direct_vec_cond_optab_supported_p multi_vector_optab_supported_p\n+#define direct_vec_condu_optab_supported_p multi_vector_optab_supported_p\n+#define direct_vec_condeq_optab_supported_p multi_vector_optab_supported_p\n #define direct_scatter_store_optab_supported_p convert_optab_supported_p\n #define direct_while_optab_supported_p convert_optab_supported_p\n #define direct_fold_extract_optab_supported_p direct_optab_supported_p"}, {"sha": "0c6fc3711904c859a36e9efce16bdf6179a2cf53", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -136,6 +136,11 @@ DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,\n \t\t       vec_mask_store_lanes, mask_store_lanes)\n \n+DEF_INTERNAL_OPTAB_FN (VCOND, 0, vcond, vec_cond)\n+DEF_INTERNAL_OPTAB_FN (VCONDU, 0, vcondu, vec_condu)\n+DEF_INTERNAL_OPTAB_FN (VCONDEQ, 0, vcondeq, vec_condeq)\n+DEF_INTERNAL_OPTAB_FN (VCOND_MASK, 0, vcond_mask, vec_cond_mask)\n+\n DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)\n DEF_INTERNAL_OPTAB_FN (CHECK_RAW_PTRS, ECF_CONST | ECF_NOTHROW,\n \t\t       check_raw_ptrs, check_ptrs)"}, {"sha": "184827fdf4e0269477e4773acee0bfa7c58008db", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 123, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -5442,7 +5442,7 @@ get_rtx_code (enum tree_code tcode, bool unsignedp)\n    first comparison operand for insn ICODE.  Do not generate the\n    compare instruction itself.  */\n \n-static rtx\n+rtx\n vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n \t\t    tree t_op0, tree t_op1, bool unsignedp,\n \t\t    enum insn_code icode, unsigned int opno)\n@@ -5809,128 +5809,6 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   return tmp;\n }\n \n-/* Generate insns for a VEC_COND_EXPR with mask, given its TYPE and its\n-   three operands.  */\n-\n-rtx\n-expand_vec_cond_mask_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n-\t\t\t   rtx target)\n-{\n-  class expand_operand ops[4];\n-  machine_mode mode = TYPE_MODE (vec_cond_type);\n-  machine_mode mask_mode = TYPE_MODE (TREE_TYPE (op0));\n-  enum insn_code icode = get_vcond_mask_icode (mode, mask_mode);\n-  rtx mask, rtx_op1, rtx_op2;\n-\n-  if (icode == CODE_FOR_nothing)\n-    return 0;\n-\n-  mask = expand_normal (op0);\n-  rtx_op1 = expand_normal (op1);\n-  rtx_op2 = expand_normal (op2);\n-\n-  mask = force_reg (mask_mode, mask);\n-  rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n-\n-  create_output_operand (&ops[0], target, mode);\n-  create_input_operand (&ops[1], rtx_op1, mode);\n-  create_input_operand (&ops[2], rtx_op2, mode);\n-  create_input_operand (&ops[3], mask, mask_mode);\n-  expand_insn (icode, 4, ops);\n-\n-  return ops[0].value;\n-}\n-\n-/* Generate insns for a VEC_COND_EXPR, given its TYPE and its\n-   three operands.  */\n-\n-rtx\n-expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n-\t\t      rtx target)\n-{\n-  class expand_operand ops[6];\n-  enum insn_code icode;\n-  rtx comparison, rtx_op1, rtx_op2;\n-  machine_mode mode = TYPE_MODE (vec_cond_type);\n-  machine_mode cmp_op_mode;\n-  bool unsignedp;\n-  tree op0a, op0b;\n-  enum tree_code tcode;\n-\n-  if (COMPARISON_CLASS_P (op0))\n-    {\n-      op0a = TREE_OPERAND (op0, 0);\n-      op0b = TREE_OPERAND (op0, 1);\n-      tcode = TREE_CODE (op0);\n-    }\n-  else\n-    {\n-      gcc_assert (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (op0)));\n-      if (get_vcond_mask_icode (mode, TYPE_MODE (TREE_TYPE (op0)))\n-\t  != CODE_FOR_nothing)\n-\treturn expand_vec_cond_mask_expr (vec_cond_type, op0, op1,\n-\t\t\t\t\t  op2, target);\n-      /* Fake op0 < 0.  */\n-      else\n-\t{\n-\t  gcc_assert (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (op0)))\n-\t\t      == MODE_VECTOR_INT);\n-\t  op0a = op0;\n-\t  op0b = build_zero_cst (TREE_TYPE (op0));\n-\t  tcode = LT_EXPR;\n-\t}\n-    }\n-  cmp_op_mode = TYPE_MODE (TREE_TYPE (op0a));\n-  unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));\n-\n-\n-  gcc_assert (known_eq (GET_MODE_SIZE (mode), GET_MODE_SIZE (cmp_op_mode))\n-\t      && known_eq (GET_MODE_NUNITS (mode),\n-\t\t\t   GET_MODE_NUNITS (cmp_op_mode)));\n-\n-  icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);\n-  if (icode == CODE_FOR_nothing)\n-    {\n-      if (tcode == LT_EXPR\n-\t  && op0a == op0\n-\t  && TREE_CODE (op0) == VECTOR_CST)\n-\t{\n-\t  /* A VEC_COND_EXPR condition could be folded from EQ_EXPR/NE_EXPR\n-\t     into a constant when only get_vcond_eq_icode is supported.\n-\t     Verify < 0 and != 0 behave the same and change it to NE_EXPR.  */\n-\t  unsigned HOST_WIDE_INT nelts;\n-\t  if (!VECTOR_CST_NELTS (op0).is_constant (&nelts))\n-\t    {\n-\t      if (VECTOR_CST_STEPPED_P (op0))\n-\t\treturn 0;\n-\t      nelts = vector_cst_encoded_nelts (op0);\n-\t    }\n-\t  for (unsigned int i = 0; i < nelts; ++i)\n-\t    if (tree_int_cst_sgn (vector_cst_elt (op0, i)) == 1)\n-\t      return 0;\n-\t  tcode = NE_EXPR;\n-\t}\n-      if (tcode == EQ_EXPR || tcode == NE_EXPR)\n-\ticode = get_vcond_eq_icode (mode, cmp_op_mode);\n-      if (icode == CODE_FOR_nothing)\n-\treturn 0;\n-    }\n-\n-  comparison = vector_compare_rtx (VOIDmode, tcode, op0a, op0b, unsignedp,\n-\t\t\t\t   icode, 4);\n-  rtx_op1 = expand_normal (op1);\n-  rtx_op2 = expand_normal (op2);\n-\n-  create_output_operand (&ops[0], target, mode);\n-  create_input_operand (&ops[1], rtx_op1, mode);\n-  create_input_operand (&ops[2], rtx_op2, mode);\n-  create_fixed_operand (&ops[3], comparison);\n-  create_fixed_operand (&ops[4], XEXP (comparison, 0));\n-  create_fixed_operand (&ops[5], XEXP (comparison, 1));\n-  expand_insn (icode, 6, ops);\n-  return ops[0].value;\n-}\n-\n /* Generate VEC_SERIES_EXPR <OP0, OP1>, returning a value of mode VMODE.\n    Use TARGET for the result if nonnull and convenient.  */\n "}, {"sha": "7c2ec257cb0d8c2433897b39bea2696f23a5c5ea", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -321,9 +321,6 @@ extern rtx expand_vec_perm_const (machine_mode, rtx, rtx,\n /* Generate code for vector comparison.  */\n extern rtx expand_vec_cmp_expr (tree, tree, rtx);\n \n-/* Generate code for VEC_COND_EXPR.  */\n-extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n-\n /* Generate code for VEC_SERIES_EXPR.  */\n extern rtx expand_vec_series_expr (machine_mode, rtx, rtx, rtx);\n \n@@ -364,5 +361,9 @@ extern void expand_jump_insn (enum insn_code icode, unsigned int nops,\n \t\t\t      class expand_operand *ops);\n \n extern enum rtx_code get_rtx_code (enum tree_code tcode, bool unsignedp);\n+extern rtx vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n+\t\t\t       tree t_op0, tree t_op1, bool unsignedp,\n+\t\t\t       enum insn_code icode, unsigned int opno);\n+\n \n #endif /* GCC_OPTABS_H */"}, {"sha": "2b1e09fdda3681258d6e6d59f1f9997c07fc00ff", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -399,6 +399,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_cleanup_eh);\n   NEXT_PASS (pass_lower_resx);\n   NEXT_PASS (pass_nrv);\n+  NEXT_PASS (pass_gimple_isel);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n   NEXT_PASS (pass_warn_function_noreturn);\n   NEXT_PASS (pass_gen_hsail);"}, {"sha": "00fe2422444b821f2c1970ff5534fc622a63edfe", "filename": "gcc/testsuite/g++.dg/vect/vec-cond-expr-eh.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvec-cond-expr-eh.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvec-cond-expr-eh.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvec-cond-expr-eh.C?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fnon-call-exceptions\" } */\n+\n+typedef double v2df __attribute__((vector_size(16)));\n+\n+v2df foo (v2df a, v2df b, v2df c, v2df d)\n+{\n+  try\n+  {\n+    v2df res = a < b ? c : d;\n+    return res;\n+    }\n+    catch (...)\n+    {\n+    return (v2df){};\n+    }\n+}"}, {"sha": "7a1ac80c2ac5159f543e564927e959200c8be729", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -4155,7 +4155,7 @@ verify_gimple_assign_ternary (gassign *stmt)\n       return true;\n     }\n \n-  if (((rhs_code == VEC_COND_EXPR || rhs_code == COND_EXPR)\n+  if ((rhs_code == COND_EXPR\n        ? !is_gimple_condexpr (rhs1) : !is_gimple_val (rhs1))\n       || !is_gimple_val (rhs2)\n       || !is_gimple_val (rhs3))"}, {"sha": "215c8f2a337a9d5d1044b8a9d264ec86b1b03364", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -627,6 +627,7 @@ extern gimple_opt_pass *make_pass_local_fn_summary (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_update_address_taken (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_convert_switch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vaarg (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_gimple_isel (gcc::context *ctxt);\n \n /* Current optimization pass.  */\n extern opt_pass *current_pass;"}, {"sha": "0ab8267fdf9c8af2cd8c4a828f46bebb2ee61a15", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -3133,8 +3133,7 @@ pass_forwprop::execute (function *fun)\n \t\t    tree rhs1 = gimple_assign_rhs1 (stmt);\n \t\t    enum tree_code code = gimple_assign_rhs_code (stmt);\n \n-\t\t    if (code == COND_EXPR\n-\t\t\t|| code == VEC_COND_EXPR)\n+\t\t    if (code == COND_EXPR)\n \t\t      {\n \t\t\t/* In this case the entire COND_EXPR is in rhs1. */\n \t\t\tif (forward_propagate_into_cond (&gsi))"}, {"sha": "2cc50f41cdd1ba56d716b83e55d89608320a8634", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -3831,14 +3831,17 @@ optimize_range_tests (enum tree_code opcode,\n    to type of comparison.  */\n \n static tree_code\n-ovce_extract_ops (tree var, gassign **rets, bool *reti, tree *type)\n+ovce_extract_ops (tree var, gassign **rets, bool *reti, tree *type,\n+\t\t  tree *lhs, tree *rhs, gassign **vcond)\n {\n   if (TREE_CODE (var) != SSA_NAME)\n     return ERROR_MARK;\n \n   gassign *stmt = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (var));\n   if (stmt == NULL)\n     return ERROR_MARK;\n+  if (*vcond)\n+    *vcond = stmt;\n \n   /* ??? If we start creating more COND_EXPR, we could perform\n      this same optimization with them.\tFor now, simplify.  */\n@@ -3847,9 +3850,20 @@ ovce_extract_ops (tree var, gassign **rets, bool *reti, tree *type)\n \n   tree cond = gimple_assign_rhs1 (stmt);\n   tree_code cmp = TREE_CODE (cond);\n-  if (TREE_CODE_CLASS (cmp) != tcc_comparison)\n+  if (cmp != SSA_NAME)\n     return ERROR_MARK;\n \n+  gassign *assign = dyn_cast<gassign *> (SSA_NAME_DEF_STMT (cond));\n+  if (stmt == NULL\n+      || TREE_CODE_CLASS (gimple_assign_rhs_code (assign)) != tcc_comparison)\n+    return ERROR_MARK;\n+\n+  cmp = gimple_assign_rhs_code (assign);\n+  if (lhs)\n+    *lhs = gimple_assign_rhs1 (assign);\n+  if (rhs)\n+    *rhs = gimple_assign_rhs2 (assign);\n+\n   /* ??? For now, allow only canonical true and false result vectors.\n      We could expand this to other constants should the need arise,\n      but at the moment we don't create them.  */\n@@ -3870,7 +3884,7 @@ ovce_extract_ops (tree var, gassign **rets, bool *reti, tree *type)\n \n   /* Success!  */\n   if (rets)\n-    *rets = stmt;\n+    *rets = assign;\n   if (reti)\n     *reti = inv;\n   if (type)\n@@ -3894,37 +3908,32 @@ optimize_vec_cond_expr (tree_code opcode, vec<operand_entry *> *ops)\n     {\n       tree elt0 = (*ops)[i]->op;\n \n-      gassign *stmt0;\n+      gassign *stmt0, *vcond0;\n       bool invert;\n-      tree type;\n-      tree_code cmp0 = ovce_extract_ops (elt0, &stmt0, &invert, &type);\n+      tree type, lhs0, rhs0;\n+      tree_code cmp0 = ovce_extract_ops (elt0, &stmt0, &invert, &type, &lhs0,\n+\t\t\t\t\t &rhs0, &vcond0);\n       if (cmp0 == ERROR_MARK)\n \tcontinue;\n \n       for (j = i + 1; j < length; ++j)\n \t{\n \t  tree &elt1 = (*ops)[j]->op;\n \n-\t  gassign *stmt1;\n-\t  tree_code cmp1 = ovce_extract_ops (elt1, &stmt1, NULL, NULL);\n+\t  gassign *stmt1, *vcond1;\n+\t  tree lhs1, rhs1;\n+\t  tree_code cmp1 = ovce_extract_ops (elt1, &stmt1, NULL, NULL, &lhs1,\n+\t\t\t\t\t     &rhs1, &vcond1);\n \t  if (cmp1 == ERROR_MARK)\n \t    continue;\n \n-\t  tree cond0 = gimple_assign_rhs1 (stmt0);\n-\t  tree x0 = TREE_OPERAND (cond0, 0);\n-\t  tree y0 = TREE_OPERAND (cond0, 1);\n-\n-\t  tree cond1 = gimple_assign_rhs1 (stmt1);\n-\t  tree x1 = TREE_OPERAND (cond1, 0);\n-\t  tree y1 = TREE_OPERAND (cond1, 1);\n-\n \t  tree comb;\n \t  if (opcode == BIT_AND_EXPR)\n-\t    comb = maybe_fold_and_comparisons (type, cmp0, x0, y0, cmp1, x1,\n-\t\t\t\t\t       y1);\n+\t    comb = maybe_fold_and_comparisons (type, cmp0, lhs0, rhs0,\n+\t\t\t\t\t       cmp1, lhs1, rhs1);\n \t  else if (opcode == BIT_IOR_EXPR)\n-\t    comb = maybe_fold_or_comparisons (type, cmp0, x0, y0, cmp1, x1,\n-\t\t\t\t\t      y1);\n+\t    comb = maybe_fold_or_comparisons (type, cmp0, lhs0, rhs0,\n+\t\t\t\t\t      cmp1, lhs1, rhs1);\n \t  else\n \t    gcc_unreachable ();\n \t  if (comb == NULL)\n@@ -3934,19 +3943,22 @@ optimize_vec_cond_expr (tree_code opcode, vec<operand_entry *> *ops)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"Transforming \");\n-\t      print_generic_expr (dump_file, cond0);\n+\t      print_generic_expr (dump_file, gimple_assign_lhs (stmt0));\n \t      fprintf (dump_file, \" %c \", opcode == BIT_AND_EXPR ? '&' : '|');\n-\t      print_generic_expr (dump_file, cond1);\n+\t      print_generic_expr (dump_file, gimple_assign_lhs (stmt1));\n \t      fprintf (dump_file, \" into \");\n \t      print_generic_expr (dump_file, comb);\n \t      fputc ('\\n', dump_file);\n \t    }\n \n-\t  gimple_assign_set_rhs1 (stmt0, comb);\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (vcond0);\n+\t  tree exp = force_gimple_operand_gsi (&gsi, comb, true, NULL_TREE,\n+\t\t\t\t\t       true, GSI_SAME_STMT);\n \t  if (invert)\n-\t    std::swap (*gimple_assign_rhs2_ptr (stmt0),\n-\t\t       *gimple_assign_rhs3_ptr (stmt0));\n-\t  update_stmt (stmt0);\n+\t    swap_ssa_operands (vcond0, gimple_assign_rhs2_ptr (vcond0),\n+\t\t\t       gimple_assign_rhs3_ptr (vcond0));\n+\t  gimple_assign_set_rhs1 (vcond0, exp);\n+\t  update_stmt (vcond0);\n \n \t  elt1 = error_mark_node;\n \t  any_changes = true;"}, {"sha": "fb955bbf3d2187f8df72660bfe65e05557b6d6b3", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -694,21 +694,23 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t  if (addend == NULL_TREE\n \t      && expand_vec_cond_expr_p (type, type, LT_EXPR))\n \t    {\n-\t      tree zero, cst, cond, mask_type;\n-\t      gimple *stmt;\n+\t      tree zero, cst, mask_type, mask;\n+\t      gimple *stmt, *cond;\n \n \t      mask_type = truth_type_for (type);\n \t      zero = build_zero_cst (type);\n-\t      cond = build2 (LT_EXPR, mask_type, op0, zero);\n+\t      mask = make_ssa_name (mask_type);\n+\t      cond = gimple_build_assign (mask, LT_EXPR, op0, zero);\n+\t      gsi_insert_before (gsi, cond, GSI_SAME_STMT);\n \t      tree_vector_builder vec (type, nunits, 1);\n \t      for (i = 0; i < nunits; i++)\n \t\tvec.quick_push (build_int_cst (TREE_TYPE (type),\n \t\t\t\t\t       (HOST_WIDE_INT_1U\n \t\t\t\t\t\t<< shifts[i]) - 1));\n \t      cst = vec.build ();\n \t      addend = make_ssa_name (type);\n-\t      stmt = gimple_build_assign (addend, VEC_COND_EXPR, cond,\n-\t\t\t\t\t  cst, zero);\n+\t      stmt\n+\t\t= gimple_build_assign (addend, VEC_COND_EXPR, mask, cst, zero);\n \t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n \t    }\n \t}\n@@ -950,21 +952,28 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n   tree index = bitsize_int (0);\n   tree comp_width = width;\n   tree comp_index = index;\n-  int i;\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n+  tree_code code = TREE_CODE (a);\n \n-  if (!is_gimple_val (a))\n+  if (code == SSA_NAME)\n     {\n-      gcc_assert (COMPARISON_CLASS_P (a));\n-      a_is_comparison = true;\n-      a1 = TREE_OPERAND (a, 0);\n-      a2 = TREE_OPERAND (a, 1);\n-      comp_inner_type = TREE_TYPE (TREE_TYPE (a1));\n-      comp_width = vector_element_bits_tree (TREE_TYPE (a1));\n+      gimple *assign = SSA_NAME_DEF_STMT (a);\n+      if (TREE_CODE_CLASS (gimple_assign_rhs_code (assign)) == tcc_comparison)\n+\t{\n+\t  a_is_comparison = true;\n+\t  a1 = gimple_assign_rhs1 (assign);\n+\t  a2 = gimple_assign_rhs2 (assign);\n+\t  code = gimple_assign_rhs_code (assign);\n+\t  comp_inner_type = TREE_TYPE (TREE_TYPE (a1));\n+\t  comp_width = vector_element_bits_tree (TREE_TYPE (a1));\n+\t}\n     }\n \n-  if (expand_vec_cond_expr_p (type, TREE_TYPE (a1), TREE_CODE (a)))\n-    return;\n+  if (expand_vec_cond_expr_p (type, TREE_TYPE (a1), code))\n+    {\n+      gcc_assert (TREE_CODE (a) == SSA_NAME || TREE_CODE (a) == VECTOR_CST);\n+      return;\n+    }\n \n   /* Handle vector boolean types with bitmasks.  If there is a comparison\n      and we can expand the comparison into the vector boolean bitmask,\n@@ -987,7 +996,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n \t  : expand_vec_cmp_expr_p (TREE_TYPE (a1), type, TREE_CODE (a))))\n     {\n       if (a_is_comparison)\n-\ta = gimplify_build2 (gsi, TREE_CODE (a), type, a1, a2);\n+\ta = gimplify_build2 (gsi, code, type, a1, a2);\n       a1 = gimplify_build2 (gsi, BIT_AND_EXPR, type, a, b);\n       a2 = gimplify_build1 (gsi, BIT_NOT_EXPR, type, a);\n       a2 = gimplify_build2 (gsi, BIT_AND_EXPR, type, a2, c);\n@@ -1018,7 +1027,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n \n   int nunits = nunits_for_known_piecewise_op (type);\n   vec_alloc (v, nunits);\n-  for (i = 0; i < nunits; i++)\n+  for (int i = 0; i < nunits; i++)\n     {\n       tree aa, result;\n       tree bb = tree_vec_extract (gsi, inner_type, b, width, index);\n@@ -1029,7 +1038,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n \t\t\t\t       comp_width, comp_index);\n \t  tree aa2 = tree_vec_extract (gsi, comp_inner_type, a2,\n \t\t\t\t       comp_width, comp_index);\n-\t  aa = fold_build2 (TREE_CODE (a), cond_type, aa1, aa2);\n+\t  aa = fold_build2 (code, cond_type, aa1, aa2);\n \t}\n       else if (a_is_scalar_bitmask)\n \t{"}, {"sha": "a3d070bc28cbc3cee8138de4e1c8e4aa9f9f613f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502d63b6d6141597bb18fd23c87736a1b384cf8f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=502d63b6d6141597bb18fd23c87736a1b384cf8f", "patch": "@@ -9937,8 +9937,12 @@ vectorizable_condition (vec_info *vinfo,\n \t{\n \t  vec_cond_rhs = vec_oprnds1[i];\n \t  if (bitop1 == NOP_EXPR)\n-\t    vec_compare = build2 (cond_code, vec_cmp_type,\n-\t\t\t\t  vec_cond_lhs, vec_cond_rhs);\n+\t    {\n+\t      gimple_seq stmts = NULL;\n+\t      vec_compare = gimple_build (&stmts, cond_code, vec_cmp_type,\n+\t\t\t\t\t   vec_cond_lhs, vec_cond_rhs);\n+\t      gsi_insert_before (gsi, stmts, GSI_SAME_STMT);\n+\t    }\n \t  else\n \t    {\n \t      new_temp = make_ssa_name (vec_cmp_type);"}]}