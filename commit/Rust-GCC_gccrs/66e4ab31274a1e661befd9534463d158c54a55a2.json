{"sha": "66e4ab31274a1e661befd9534463d158c54a55a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlNGFiMzEyNzRhMWU2NjFiZWZkOTUzNDQ2M2QxNThjNTRhNTVhMg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-06-07T18:10:31Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-06-07T18:10:31Z"}, "message": "decl.c: Miscellaneous whitespace fixes.\n\n* decl.c: Miscellaneous whitespace fixes.\n* expr.c: Likewise.\n* gfortran.h: Likewise.\n* interface.c : Likewise.\n* io.c: Likewise.\n* match.c: Likewise.\n* match.h: Likewise.\n* module.c: Likewise.\n* parse.c: Likewise.\n* resolve.c: Likewise.\n* symbol.c: Likewise.\n* trans-array.c: Likewise.\n* trans-common.c: Likewise.\n* trans-decl.c: Likewise.\n* trans-intrinsic.c: Likewise.\n* trans-io.c: Likewise.\n* trans-stmt.c: Likewise.\n* trans-types.c: Likewise.\n\nFrom-SVN: r125533", "tree": {"sha": "a5d4d0d32adbc5ce952e0f81a156f8590ce3ee2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5d4d0d32adbc5ce952e0f81a156f8590ce3ee2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66e4ab31274a1e661befd9534463d158c54a55a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e4ab31274a1e661befd9534463d158c54a55a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e4ab31274a1e661befd9534463d158c54a55a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e4ab31274a1e661befd9534463d158c54a55a2/comments", "author": null, "committer": null, "parents": [{"sha": "bb27eeda7dc859c9d1c9a69baea30f9cf273ec4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb27eeda7dc859c9d1c9a69baea30f9cf273ec4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb27eeda7dc859c9d1c9a69baea30f9cf273ec4a"}], "stats": {"total": 649, "additions": 339, "deletions": 310}, "files": [{"sha": "4a7edfdacabbcbafa28602680148388f804e17b7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -1,3 +1,24 @@\n+2007-06-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* decl.c: Miscellaneous whitespace fixes.\n+\t* expr.c: Likewise.\n+\t* gfortran.h: Likewise.\n+\t* interface.c : Likewise.\n+\t* io.c: Likewise.\n+\t* match.c: Likewise.\n+\t* match.h: Likewise.\n+\t* module.c: Likewise.\n+\t* parse.c: Likewise.\n+\t* resolve.c: Likewise.\n+\t* symbol.c: Likewise.\n+\t* trans-array.c: Likewise.\n+\t* trans-common.c: Likewise.\n+\t* trans-decl.c: Likewise.\n+\t* trans-intrinsic.c: Likewise.\n+\t* trans-io.c: Likewise.\n+\t* trans-stmt.c: Likewise.\n+\t* trans-types.c: Likewise.\n+\n 2007-06-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/18923"}, {"sha": "82d3e6686ca96ee32ea9381bd6e0b245f307a471", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -141,7 +141,7 @@ gfc_free_data (gfc_data *p)\n /* Free all data in a namespace.  */\n \n static void\n-gfc_free_data_all (gfc_namespace * ns)\n+gfc_free_data_all (gfc_namespace *ns)\n {\n   gfc_data *d;\n \n@@ -444,8 +444,7 @@ match_old_style_init (const char *name)\n   newdata->var->expr = gfc_get_variable_expr (st);\n   newdata->where = gfc_current_locus;\n \n-  /* Match initial value list. This also eats the terminal\n-     '/'.  */\n+  /* Match initial value list. This also eats the terminal '/'.  */\n   m = top_val_list (newdata);\n   if (m != MATCH_YES)\n     {\n@@ -638,7 +637,7 @@ find_special (const char *name, gfc_symbol **result)\n   if (s->state != COMP_INTERFACE)\n     goto end;\n   if (s->sym == NULL)\n-    goto end;\t\t  /* Nameless interface */\n+    goto end;\t\t  /* Nameless interface.  */\n \n   if (strcmp (name, s->sym->name) == 0)\n     {\n@@ -729,7 +728,7 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n   st->n.sym = sym;\n   sym->refs++;\n \n-  /* See if the procedure should be a module procedure */\n+  /* See if the procedure should be a module procedure.  */\n \n   if (((sym->ns->proc_name != NULL\n \t\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n@@ -756,8 +755,7 @@ build_sym (const char *name, gfc_charlen *cl,\n   if (gfc_get_symbol (name, NULL, &sym))\n     return FAILURE;\n \n-  /* Start updating the symbol table.  Add basic type attribute\n-     if present.  */\n+  /* Start updating the symbol table.  Add basic type attribute if present.  */\n   if (current_ts.type != BT_UNKNOWN\n       && (sym->attr.implicit_type == 0\n \t  || !gfc_compare_types (&sym->ts, &current_ts))\n@@ -831,7 +829,7 @@ gfc_set_constant_character_len (int len, gfc_expr *expr, bool array)\n    enum history node containing largest initializer.\n \n    SYM points to the symbol node of enumerator.\n-   INIT points to its enumerator value.   */\n+   INIT points to its enumerator value.  */\n \n static void\n create_enum_history (gfc_symbol *sym, gfc_expr *init)\n@@ -885,8 +883,7 @@ gfc_free_enum_history (void)\n    expression to a symbol.  */\n \n static try\n-add_init_expr_to_sym (const char *name, gfc_expr **initp,\n-\t\t      locus *var_locus)\n+add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n {\n   symbol_attribute attr;\n   gfc_symbol *sym;\n@@ -949,9 +946,8 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp,\n \t  /* Update symbol character length according initializer.  */\n \t  if (sym->ts.cl->length == NULL)\n \t    {\n-\t      /* If there are multiple CHARACTER variables declared on\n-\t\t the same line, we don't want them to share the same\n-\t\tlength.  */\n+\t      /* If there are multiple CHARACTER variables declared on the\n+\t\t same line, we don't want them to share the same length.  */\n \t      sym->ts.cl = gfc_get_charlen ();\n \t      sym->ts.cl->next = gfc_current_ns->cl_list;\n \t      gfc_current_ns->cl_list = sym->ts.cl;\n@@ -1239,7 +1235,7 @@ variable_decl (int elem)\n     }\n \n   /*  If this symbol has already shown up in a Cray Pointer declaration,\n-      then we want to set the type & bail out. */\n+      then we want to set the type & bail out.  */\n   if (gfc_option.flag_cray_pointer)\n     {\n       gfc_find_symbol (name, gfc_current_ns, 1, &sym);\n@@ -1615,7 +1611,7 @@ match_char_spec (gfc_typespec *ts)\n       goto rparen;\n     }\n \n-  /* Try to match \"LEN = <len-param>\" or \"LEN = <len-param>, KIND = <int>\"  */\n+  /* Try to match \"LEN = <len-param>\" or \"LEN = <len-param>, KIND = <int>\".  */\n   if (gfc_match (\" len =\") == MATCH_YES)\n     {\n       m = char_len_param_value (&len);\n@@ -1642,7 +1638,7 @@ match_char_spec (gfc_typespec *ts)\n       goto rparen;\n     }\n \n-  /* Try to match   ( <len-param> ) or ( <len-param> , [ KIND = ] <int> )  */\n+  /* Try to match ( <len-param> ) or ( <len-param> , [ KIND = ] <int> ).  */\n   m = char_len_param_value (&len);\n   if (m == MATCH_NO)\n     goto syntax;\n@@ -1895,7 +1891,7 @@ match_implicit_range (void)\n       switch (c)\n \t{\n \tcase ')':\n-\t  inner = 0;\t\t/* Fall through */\n+\t  inner = 0;\t\t/* Fall through.  */\n \n \tcase ',':\n \t  c2 = c1;\n@@ -2068,6 +2064,7 @@ gfc_match_implicit (void)\n   return MATCH_ERROR;\n }\n \n+\n match\n gfc_match_import (void)\n {\n@@ -2076,8 +2073,8 @@ gfc_match_import (void)\n   gfc_symbol *sym;\n   gfc_symtree *st;\n \n-  if (gfc_current_ns->proc_name == NULL ||\n-      gfc_current_ns->proc_name->attr.if_source != IFSRC_IFBODY)\n+  if (gfc_current_ns->proc_name == NULL\n+      || gfc_current_ns->proc_name->attr.if_source != IFSRC_IFBODY)\n     {\n       gfc_error (\"IMPORT statement at %C only permitted in \"\n \t\t \"an INTERFACE body\");\n@@ -2111,16 +2108,15 @@ gfc_match_import (void)\n \t{\n \tcase MATCH_YES:\n \t  if (gfc_current_ns->parent !=  NULL\n-\t\t  && gfc_find_symbol (name, gfc_current_ns->parent,\n-\t\t\t\t      1, &sym))\n+\t      && gfc_find_symbol (name, gfc_current_ns->parent, 1, &sym))\n \t    {\n \t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n \t       return MATCH_ERROR;\n \t    }\n \t  else if (gfc_current_ns->proc_name->ns->parent !=  NULL\n-\t\t  && gfc_find_symbol (name,\n-\t\t\tgfc_current_ns->proc_name->ns->parent,\n-\t\t\t1, &sym))\n+\t\t   && gfc_find_symbol (name,\n+\t\t\t\t       gfc_current_ns->proc_name->ns->parent,\n+\t\t\t\t       1, &sym))\n \t    {\n \t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n \t       return MATCH_ERROR;\n@@ -2168,6 +2164,7 @@ gfc_match_import (void)\n   return MATCH_ERROR;\n }\n \n+\n /* Matches an attribute specification including array specs.  If\n    successful, leaves the variables current_attr and current_as\n    holding the specification.  Also sets the colon_seen variable for\n@@ -2326,7 +2323,7 @@ match_attr_spec (void)\n \t    attr = \"VOLATILE\";\n \t    break;\n \t  default:\n-\t    attr = NULL;\t/* This shouldn't happen */\n+\t    attr = NULL;\t/* This shouldn't happen.  */\n \t  }\n \n \tgfc_error (\"Duplicate %s attribute at %L\", attr, &seen_at[d]);\n@@ -2777,8 +2774,8 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n \t}\n     }\n \n-  if (gfc_add_explicit_interface (progname, IFSRC_DECL, head, NULL) ==\n-      FAILURE)\n+  if (gfc_add_explicit_interface (progname, IFSRC_DECL, head, NULL)\n+      == FAILURE)\n     {\n       m = MATCH_ERROR;\n       goto cleanup;\n@@ -2796,7 +2793,7 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n    ENTRY statement.  Also matches the end-of-statement.  */\n \n static match\n-match_result (gfc_symbol * function, gfc_symbol **result)\n+match_result (gfc_symbol *function, gfc_symbol **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *r;\n@@ -2865,7 +2862,6 @@ gfc_match_function_decl (void)\n       gfc_current_locus = old_loc;\n       return MATCH_NO;\n     }\n-\n   if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n   gfc_new_block = sym;\n@@ -3371,7 +3367,7 @@ gfc_match_end (gfc_statement *st)\n     {\n       if (!eos_ok)\n \t{\n-\t  /* We would have required END [something]  */\n+\t  /* We would have required END [something].  */\n \t  gfc_error (\"%s statement expected at %L\",\n \t\t     gfc_ascii_statement (*st), &old_loc);\n \t  goto cleanup;\n@@ -3408,7 +3404,8 @@ gfc_match_end (gfc_statement *st)\n   if (*st == ST_END_INTERFACE)\n     return gfc_match_end_interface ();\n \n-  /* We haven't hit the end of statement, so what is left must be an end-name.  */\n+  /* We haven't hit the end of statement, so what is left must be an\n+     end-name.  */\n   m = gfc_match_space ();\n   if (m == MATCH_YES)\n     m = gfc_match_name (name);\n@@ -4262,6 +4259,7 @@ gfc_match_value (void)\n   return MATCH_ERROR;\n }\n \n+\n match\n gfc_match_volatile (void)\n {\n@@ -4315,7 +4313,6 @@ gfc_match_volatile (void)\n }\n \n \n-\n /* Match a module procedure statement.  Note that we have to modify\n    symbols in the parent's namespace because the current one was there\n    to receive symbols that are in an interface's formal argument list.  */\n@@ -4627,7 +4624,7 @@ enumerator_decl (void)\n }\n \n \n-/* Match the enumerator definition statement. */\n+/* Match the enumerator definition statement.  */\n \n match\n gfc_match_enumerator_def (void)"}, {"sha": "00ed9a04d77a89a9e7f5592b0d9b58d11032342a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -352,8 +352,7 @@ gfc_copy_shape (mpz_t *shape, int rank)\n       { s1 ... sN-1  sN+1    ...  sR-1}\n \n    If anything goes wrong -- N is not a constant, its value is out\n-   of range -- or anything else, just returns NULL.\n-*/\n+   of range -- or anything else, just returns NULL.  */\n \n mpz_t *\n gfc_copy_shape_excluding (mpz_t *shape, int rank, gfc_expr *dim)\n@@ -369,7 +368,7 @@ gfc_copy_shape_excluding (mpz_t *shape, int rank, gfc_expr *dim)\n     return NULL;\n \n   n = mpz_get_si (dim->value.integer);\n-  n--; /* Convert to zero based index */\n+  n--; /* Convert to zero based index.  */\n   if (n < 0 || n >= rank)\n     return NULL;\n \n@@ -477,7 +476,7 @@ gfc_copy_expr (gfc_expr *p)\n \t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n \t  break;\n \n-\tdefault:\t\t/* Binary operators */\n+\tdefault:\t\t/* Binary operators.  */\n \t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n \t  q->value.op.op2 = gfc_copy_expr (p->value.op.op2);\n \t  break;\n@@ -696,7 +695,6 @@ gfc_is_constant_expr (gfc_expr *e)\n       rv = (gfc_is_constant_expr (e->value.op.op1)\n \t    && (e->value.op.op2 == NULL\n \t\t|| gfc_is_constant_expr (e->value.op.op2)));\n-\n       break;\n \n     case EXPR_VARIABLE:\n@@ -772,7 +770,7 @@ simplify_intrinsic_op (gfc_expr *p, int type)\n       || (op2 != NULL && !gfc_is_constant_expr (op2)))\n     return SUCCESS;\n \n-  /* Rip p apart */\n+  /* Rip p apart.  */\n   p->value.op.op1 = NULL;\n   p->value.op.op2 = NULL;\n \n@@ -1330,7 +1328,7 @@ simplify_const_ref (gfc_expr *p)\n \t\treturn FAILURE;\n \t      p->ref->u.ar.type = AR_FULL;\n \n-\t    /* FALLTHROUGH  */\n+\t    /* Fall through.  */\n \n \t    case AR_FULL:\n \t      if (p->ref->next != NULL\n@@ -1412,6 +1410,7 @@ simplify_ref_chain (gfc_ref *ref, int type)\n \n \n /* Try to substitute the value of a parameter variable.  */\n+\n static try\n simplify_parameter_variable (gfc_expr *p, int type)\n {\n@@ -1429,8 +1428,7 @@ simplify_parameter_variable (gfc_expr *p, int type)\n     e->ref = copy_ref (p->ref);\n   t = gfc_simplify_expr (e, type);\n \n-  /* Only use the simplification if it eliminated all subobject\n-     references.  */\n+  /* Only use the simplification if it eliminated all subobject references.  */\n   if (t == SUCCESS && !e->ref)\n     gfc_replace_expr (p, e);\n   else\n@@ -2168,7 +2166,6 @@ check_restricted (gfc_expr *e)\n     case EXPR_FUNCTION:\n       t = e->value.function.esym ? external_spec_function (e)\n \t\t\t\t : restricted_intrinsic (e);\n-\n       break;\n \n     case EXPR_VARIABLE:\n@@ -2249,6 +2246,7 @@ check_restricted (gfc_expr *e)\n try\n gfc_specification_expr (gfc_expr *e)\n {\n+\n   if (e == NULL)\n     return SUCCESS;\n \n@@ -2352,38 +2350,38 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n       return FAILURE;\n     }\n \n-/* 12.5.2.2, Note 12.26: The result variable is very similar to any other\n-   variable local to a function subprogram.  Its existence begins when\n-   execution of the function is initiated and ends when execution of the\n-   function is terminated.....\n-   Therefore, the left hand side is no longer a varaiable, when it is:  */\n+  /* 12.5.2.2, Note 12.26: The result variable is very similar to any other\n+     variable local to a function subprogram.  Its existence begins when\n+     execution of the function is initiated and ends when execution of the\n+     function is terminated...\n+     Therefore, the left hand side is no longer a variable, when it is:  */\n   if (sym->attr.flavor == FL_PROCEDURE && sym->attr.proc != PROC_ST_FUNCTION\n       && !sym->attr.external)\n     {\n       bool bad_proc;\n       bad_proc = false;\n \n-      /* (i) Use associated; */\n+      /* (i) Use associated;  */\n       if (sym->attr.use_assoc)\n \tbad_proc = true;\n \n       /* (ii) The assignment is in the main program; or  */\n       if (gfc_current_ns->proc_name->attr.is_main_program)\n \tbad_proc = true;\n \n-      /* (iii) A module or internal procedure....  */\n+      /* (iii) A module or internal procedure...  */\n       if ((gfc_current_ns->proc_name->attr.proc == PROC_INTERNAL\n \t   || gfc_current_ns->proc_name->attr.proc == PROC_MODULE)\n \t  && gfc_current_ns->parent\n \t  && (!(gfc_current_ns->parent->proc_name->attr.function\n \t\t|| gfc_current_ns->parent->proc_name->attr.subroutine)\n \t      || gfc_current_ns->parent->proc_name->attr.is_main_program))\n \t{\n-\t  /* .... that is not a function.... */ \n+\t  /* ... that is not a function...  */ \n \t  if (!gfc_current_ns->proc_name->attr.function)\n \t    bad_proc = true;\n \n-\t  /* .... or is not an entry and has a different name.  */\n+\t  /* ... or is not an entry and has a different name.  */\n \t  if (!sym->attr.entry && sym->name != gfc_current_ns->proc_name->name)\n \t    bad_proc = true;\n \t}\n@@ -2426,7 +2424,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n        return FAILURE;\n      }\n \n-  /* This is possibly a typo: x = f() instead of x => f()  */\n+  /* This is possibly a typo: x = f() instead of x => f().  */\n   if (gfc_option.warn_surprising \n       && rvalue->expr_type == EXPR_FUNCTION\n       && rvalue->symtree->n.sym->attr.pointer)"}, {"sha": "aa4c03508d4c7ea4c90aca4b447e4253bb4da5c6", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -619,8 +619,8 @@ typedef struct\n   /* Special attributes for Cray pointers, pointees.  */\n   unsigned cray_pointer:1, cray_pointee:1;\n \n-  /* The symbol is a derived type with allocatable components, possibly nested.\n-   */\n+  /* The symbol is a derived type with allocatable components, possibly\n+     nested.  */\n   unsigned alloc_comp:1;\n \n   /* The namespace where the VOLATILE attribute has been set.  */\n@@ -1263,8 +1263,7 @@ gfc_simplify_f;\n \n /* Again like gfc_check_f, these specify the type of the resolution\n    function associated with an intrinsic. The fX are just like in\n-   gfc_check_f. f1m is used for MIN and MAX, s1 is used for abort().\n-   */\n+   gfc_check_f. f1m is used for MIN and MAX, s1 is used for abort().  */\n \n typedef union\n {\n@@ -1847,7 +1846,7 @@ extern locus gfc_current_locus;\n /* misc.c */\n void *gfc_getmem (size_t) ATTRIBUTE_MALLOC;\n void gfc_free (void *);\n-int gfc_terminal_width(void);\n+int gfc_terminal_width (void);\n void gfc_clear_ts (gfc_typespec *);\n FILE *gfc_open_file (const char *);\n const char *gfc_basic_typename (bt);\n@@ -1949,7 +1948,7 @@ try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n void gfc_set_component_attr (gfc_component *, symbol_attribute *);\n void gfc_get_component_attr (symbol_attribute *, gfc_component *);\n \n-void gfc_set_sym_referenced (gfc_symbol * sym);\n+void gfc_set_sym_referenced (gfc_symbol *);\n \n try gfc_add_attribute (symbol_attribute *, locus *);\n try gfc_add_allocatable (symbol_attribute *, locus *);\n@@ -1960,7 +1959,7 @@ try gfc_add_optional (symbol_attribute *, locus *);\n try gfc_add_pointer (symbol_attribute *, locus *);\n try gfc_add_cray_pointer (symbol_attribute *, locus *);\n try gfc_add_cray_pointee (symbol_attribute *, locus *);\n-try gfc_mod_pointee_as (gfc_array_spec *as);\n+try gfc_mod_pointee_as (gfc_array_spec *);\n try gfc_add_protected (symbol_attribute *, const char *, locus *);\n try gfc_add_result (symbol_attribute *, const char *, locus *);\n try gfc_add_save (symbol_attribute *, const char *, locus *);\n@@ -2025,7 +2024,7 @@ int gfc_symbols_could_alias (gfc_symbol *, gfc_symbol *);\n \n void gfc_undo_symbols (void);\n void gfc_commit_symbols (void);\n-void gfc_commit_symbol (gfc_symbol * sym);\n+void gfc_commit_symbol (gfc_symbol *);\n void gfc_free_namespace (gfc_namespace *);\n \n void gfc_symbol_init_2 (void);\n@@ -2121,7 +2120,7 @@ try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n gfc_expr *gfc_default_initializer (gfc_typespec *);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n \n-void gfc_expr_set_symbols_referenced (gfc_expr * expr);\n+void gfc_expr_set_symbols_referenced (gfc_expr *);\n \n /* st.c */\n extern gfc_code new_st;\n@@ -2166,15 +2165,15 @@ try gfc_resolve_array_constructor (gfc_expr *);\n try gfc_check_constructor_type (gfc_expr *);\n try gfc_check_iter_variable (gfc_expr *);\n try gfc_check_constructor (gfc_expr *, try (*)(gfc_expr *));\n-gfc_constructor *gfc_copy_constructor (gfc_constructor * src);\n+gfc_constructor *gfc_copy_constructor (gfc_constructor *);\n gfc_expr *gfc_get_array_element (gfc_expr *, int);\n try gfc_array_size (gfc_expr *, mpz_t *);\n try gfc_array_dimen_size (gfc_expr *, int, mpz_t *);\n try gfc_array_ref_shape (gfc_array_ref *, mpz_t *);\n gfc_array_ref *gfc_find_array_ref (gfc_expr *);\n void gfc_insert_constructor (gfc_expr *, gfc_constructor *);\n gfc_constructor *gfc_get_constructor (void);\n-tree gfc_conv_array_initializer (tree type, gfc_expr * expr);\n+tree gfc_conv_array_initializer (tree type, gfc_expr *);\n try spec_size (gfc_array_spec *, mpz_t *);\n try spec_dimen_size (gfc_array_spec *, int, mpz_t *);\n int gfc_is_compile_time_shape (gfc_array_spec *);\n@@ -2190,7 +2189,7 @@ gfc_symbol *gfc_search_interface (gfc_interface *, int,\n try gfc_extend_expr (gfc_expr *);\n void gfc_free_formal_arglist (gfc_formal_arglist *);\n try gfc_extend_assign (gfc_code *, gfc_namespace *);\n-try gfc_add_interface (gfc_symbol * sym);\n+try gfc_add_interface (gfc_symbol *);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "c30b4d68b2defe02095e5b80abb46a309824e663", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -423,7 +423,7 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n   r2 = (s2->as != NULL) ? s2->as->rank : 0;\n \n   if (r1 != r2)\n-    return 0;\t\t\t/* Ranks differ */\n+    return 0;\t\t\t/* Ranks differ.  */\n \n   return gfc_compare_types (&s1->ts, &s2->ts);\n }\n@@ -750,7 +750,7 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n \tcontinue;\n \n       if (arg[i].sym && arg[i].sym->attr.optional)\n-\tcontinue;\t\t/* Skip optional arguments */\n+\tcontinue;\t\t/* Skip optional arguments.  */\n \n       arg[i].flag = k;\n \n@@ -899,13 +899,13 @@ compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n \n   if (s1->attr.function != s2->attr.function\n       && s1->attr.subroutine != s2->attr.subroutine)\n-    return 0;\t\t\t/* disagreement between function/subroutine */\n+    return 0;\t\t/* Disagreement between function/subroutine.  */\n \n   f1 = s1->formal;\n   f2 = s2->formal;\n \n   if (f1 == NULL && f2 == NULL)\n-    return 1;\t\t\t/* Special case */\n+    return 1;\t\t\t/* Special case.  */\n \n   if (count_types_test (f1, f2))\n     return 0;\n@@ -965,7 +965,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t    }\n \t  else\n \t    {\n-\t      /* Duplicate interface */\n+\t      /* Duplicate interface.  */\n \t      qlast->next = q->next;\n \t      gfc_free (q);\n \t      q = qlast->next;\n@@ -978,8 +978,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \n \n /* Check lists of interfaces to make sure that no two interfaces are\n-   ambiguous.  Duplicate interfaces (from the same symbol) are OK\n-   here.  */\n+   ambiguous.  Duplicate interfaces (from the same symbol) are OK here.  */\n \n static int\n check_interface1 (gfc_interface *p, gfc_interface *q0,\n@@ -991,7 +990,7 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n     for (q = q0; q; q = q->next)\n       {\n \tif (p->sym == q->sym)\n-\t  continue;\t\t/* Duplicates OK here */\n+\t  continue;\t\t/* Duplicates OK here.  */\n \n \tif (p->sym->name == q->sym->name && p->sym->module == q->sym->module)\n \t  continue;\n@@ -1193,7 +1192,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n       if (formal->attr.if_source == IFSRC_UNKNOWN\n \t  || actual->symtree->n.sym->attr.external)\n-\treturn 1;\t\t/* Assume match */\n+\treturn 1;\t\t/* Assume match.  */\n \n       return compare_interfaces (formal, actual->symtree->n.sym, 0);\n     }\n@@ -1226,7 +1225,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       break;\n \n   if (ref == NULL)\n-    return 0;\t\t\t/* Not an array element */\n+    return 0;\t\t\t/* Not an array element.  */\n \n   return 1;\n }\n@@ -1905,7 +1904,7 @@ find_sym_in_symtree (gfc_symbol *sym)\n   if (st && st->n.sym == sym)\n     return st;\n \n-  /* if it's been renamed, resort to a brute-force search.  */\n+  /* If it's been renamed, resort to a brute-force search.  */\n   /* TODO: avoid having to do this search.  If the symbol doesn't exist\n      in the symtree for the current namespace, it should probably be added.  */\n   for (ns = gfc_current_ns; ns; ns = ns->parent)\n@@ -1915,7 +1914,7 @@ find_sym_in_symtree (gfc_symbol *sym)\n \treturn st;\n     }\n   gfc_internal_error (\"Unable to find symbol %s\", sym->name);\n-  /* Not reached */\n+  /* Not reached.  */\n }\n \n \n@@ -1974,7 +1973,7 @@ gfc_extend_expr (gfc_expr *e)\n \n   if (sym == NULL)\n     {\n-      /* Don't use gfc_free_actual_arglist() */\n+      /* Don't use gfc_free_actual_arglist().  */\n       if (actual->next != NULL)\n \tgfc_free (actual->next);\n       gfc_free (actual);\n@@ -2063,7 +2062,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n    procedures can be present without interfaces.  */\n \n static try\n-check_new_interface (gfc_interface * base, gfc_symbol * new)\n+check_new_interface (gfc_interface *base, gfc_symbol *new)\n {\n   gfc_interface *ip;\n "}, {"sha": "8e81d6a19fea3de5786d04b30b6b92cd277a7261", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -196,7 +196,7 @@ unget_char (void)\n   use_last_char = 1;\n }\n \n-/* Eat up the spaces and return a character. */\n+/* Eat up the spaces and return a character.  */\n \n static char\n next_char_not_space (void)"}, {"sha": "0f99a521189ab78e1b82877a335ead9d38553fd6", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -118,7 +118,7 @@ gfc_match_eos (void)\n \t    }\n \t  while (c != '\\n');\n \n-\t  /* Fall through */\n+\t  /* Fall through.  */\n \n \tcase '\\n':\n \t  return MATCH_YES;\n@@ -441,7 +441,7 @@ gfc_match_sym_tree (gfc_symtree **matched_symbol, int host_assoc)\n \n   if (host_assoc)\n     return (gfc_get_ha_sym_tree (buffer, matched_symbol))\n-\t   ? MATCH_ERROR : MATCH_YES;\n+\t    ? MATCH_ERROR : MATCH_YES;\n \n   if (gfc_get_sym_tree (buffer, NULL, matched_symbol))\n     return MATCH_ERROR;\n@@ -741,7 +741,7 @@ gfc_match (const char *target, ...)\n \t  goto not_yes;\n \n \tcase '%':\n-\t  break;\t/* Fall through to character matcher */\n+\t  break;\t/* Fall through to character matcher.  */\n \n \tdefault:\n \t  gfc_internal_error (\"gfc_match(): Bad match code %c\", c);\n@@ -771,7 +771,7 @@ gfc_match (const char *target, ...)\n \t    {\n \t    case '%':\n \t      matches++;\n-\t      break;\t\t/* Skip */\n+\t      break;\t\t/* Skip.  */\n \n \t    /* Matches that don't have to be undone */\n \t    case 'o':\n@@ -911,7 +911,6 @@ gfc_match_pointer_assignment (void)\n       goto cleanup;\n     }\n \n-\n   new_st.op = EXEC_POINTER_ASSIGN;\n   new_st.expr = lvalue;\n   new_st.expr2 = rvalue;\n@@ -1073,7 +1072,7 @@ gfc_match_if (gfc_statement *if_type)\n   if (m == MATCH_ERROR)\n     return MATCH_ERROR;\n \n-  gfc_match (\" if ( %e ) \", &expr);\t/* Guaranteed to match */\n+  gfc_match (\" if ( %e ) \", &expr);\t/* Guaranteed to match.  */\n \n   m = gfc_match_pointer_assignment ();\n   if (m == MATCH_YES)\n@@ -1083,7 +1082,7 @@ gfc_match_if (gfc_statement *if_type)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_loc;\n \n-  gfc_match (\" if ( %e ) \", &expr);\t/* Guaranteed to match */\n+  gfc_match (\" if ( %e ) \", &expr);\t/* Guaranteed to match.  */\n \n   /* Look at the next keyword to see which matcher to call.  Matching\n      the keyword doesn't affect the symbol table, so we don't have to\n@@ -1249,6 +1248,7 @@ gfc_match_elseif (void)\n void\n gfc_free_iterator (gfc_iterator *iter, int flag)\n {\n+\n   if (iter == NULL)\n     return;\n \n@@ -1288,7 +1288,7 @@ gfc_match_do (void)\n   if (m == MATCH_ERROR)\n     goto cleanup;\n \n-/* Match an infinite DO, make it like a DO WHILE(.TRUE.) */\n+  /* Match an infinite DO, make it like a DO WHILE(.TRUE.).  */\n \n   if (gfc_match_eos () == MATCH_YES)\n     {\n@@ -1297,8 +1297,8 @@ gfc_match_do (void)\n       goto done;\n     }\n \n-  /* match an optional comma, if no comma is found a space is obligatory.  */\n-  if (gfc_match_char(',') != MATCH_YES && gfc_match (\"% \") != MATCH_YES)\n+  /* Match an optional comma, if no comma is found, a space is obligatory.  */\n+  if (gfc_match_char (',') != MATCH_YES && gfc_match (\"% \") != MATCH_YES)\n     return MATCH_NO;\n \n   /* See if we have a DO WHILE.  */\n@@ -1309,15 +1309,15 @@ gfc_match_do (void)\n     }\n \n   /* The abortive DO WHILE may have done something to the symbol\n-     table, so we start over: */\n+     table, so we start over.  */\n   gfc_undo_symbols ();\n   gfc_current_locus = old_loc;\n \n-  gfc_match_label ();\t\t/* This won't error */\n-  gfc_match (\" do \");\t\t/* This will work */\n+  gfc_match_label ();\t\t/* This won't error.  */\n+  gfc_match (\" do \");\t\t/* This will work.  */\n \n-  gfc_match_st_label (&label);\t/* Can't error out */\n-  gfc_match_char (',');\t\t/* Optional comma */\n+  gfc_match_st_label (&label);\t/* Can't error out.  */\n+  gfc_match_char (',');\t\t/* Optional comma.  */\n \n   m = gfc_match_iterator (&iter, 0);\n   if (m == MATCH_NO)\n@@ -1389,8 +1389,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t}\n     }\n \n-  /* Find the loop mentioned specified by the label (or lack of a\n-     label).  */\n+  /* Find the loop mentioned specified by the label (or lack of a label).  */\n   for (o = NULL, p = gfc_state_stack; p; p = p->previous)\n     if (p->state == COMP_DO && (sym == NULL || sym == p->sym))\n       break;\n@@ -1432,7 +1431,6 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n   new_st.ext.whichloop = p->head;\n \n   new_st.op = op;\n-/*  new_st.sym = sym;*/\n \n   return MATCH_YES;\n }\n@@ -1519,6 +1517,7 @@ gfc_match_stopcode (gfc_statement st)\n   return MATCH_ERROR;\n }\n \n+\n /* Match the (deprecated) PAUSE statement.  */\n \n match\n@@ -1890,7 +1889,7 @@ gfc_match_nullify (void)\n       if (m == MATCH_NO)\n \tgoto syntax;\n \n-      if (gfc_check_do_variable(p->symtree))\n+      if (gfc_check_do_variable (p->symtree))\n \tgoto cleanup;\n \n       if (gfc_pure (NULL) && gfc_impure_variable (p->symtree->n.sym))\n@@ -1899,13 +1898,13 @@ gfc_match_nullify (void)\n \t  goto cleanup;\n \t}\n \n-      /* build ' => NULL() ' */\n+      /* build ' => NULL() '.  */\n       e = gfc_get_expr ();\n       e->where = gfc_current_locus;\n       e->expr_type = EXPR_NULL;\n       e->ts.type = BT_UNKNOWN;\n \n-      /* Chain to list */\n+      /* Chain to list.  */\n       if (tail == NULL)\n \ttail = &new_st;\n       else\n@@ -2145,7 +2144,7 @@ gfc_match_call (void)\n   i = 0;\n   for (a = arglist; a; a = a->next)\n     if (a->expr == NULL)\n-\ti = 1;\n+      i = 1;\n \n   if (i)\n     {\n@@ -2156,7 +2155,7 @@ gfc_match_call (void)\n       new_st.next = c = gfc_get_code ();\n       c->op = EXEC_SELECT;\n       sprintf (name, \"_result_%s\", sym->name);\n-      gfc_get_ha_sym_tree (name, &select_st);  /* Can't fail */\n+      gfc_get_ha_sym_tree (name, &select_st);   /* Can't fail.  */\n \n       select_sym = select_st->n.sym;\n       select_sym->ts.type = BT_INTEGER;\n@@ -2565,11 +2564,11 @@ gfc_match_namelist (void)\n \t}\n \n       if (group_name->attr.flavor == FL_NAMELIST\n-\t    && group_name->attr.use_assoc\n-\t    && gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n-\t\t\t       \"at %C already is USE associated and can\"\n-\t\t\t       \"not be respecified.\", group_name->name)\n-\t       == FAILURE)\n+\t  && group_name->attr.use_assoc\n+\t  && gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n+\t\t\t     \"at %C already is USE associated and can\"\n+\t\t\t     \"not be respecified.\", group_name->name)\n+\t     == FAILURE)\n \treturn MATCH_ERROR;\n \n       if (group_name->attr.flavor != FL_NAMELIST\n@@ -2776,7 +2775,7 @@ gfc_match_equivalence (void)\n       /* If one of the members of an equivalence is in common, then\n \t mark them all as being in common.  Before doing this, check\n \t that members of the equivalence group are not in different\n-\t common blocks. */\n+\t common blocks.  */\n       if (common_flag)\n \tfor (set = eq; set; set = set->eq)\n \t  {\n@@ -3217,6 +3216,7 @@ match_simple_where (void)\n   return MATCH_ERROR;\n }\n \n+\n /* Match a WHERE statement.  */\n \n match\n@@ -3308,7 +3308,7 @@ gfc_match_elsewhere (void)\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n \t}\n-      /* Better be a name at this point */\n+      /* Better be a name at this point.  */\n       m = gfc_match_name (name);\n       if (m == MATCH_NO)\n \tgoto syntax;\n@@ -3383,7 +3383,7 @@ match_forall_iterator (gfc_forall_iterator **result)\n     goto cleanup;\n \n   if (gfc_match_char ('=') != MATCH_YES\n-\t|| iter->var->expr_type != EXPR_VARIABLE)\n+      || iter->var->expr_type != EXPR_VARIABLE)\n     {\n       m = MATCH_NO;\n       goto cleanup;\n@@ -3472,7 +3472,7 @@ match_forall_header (gfc_forall_iterator **phead, gfc_expr **mask)\n \t  continue;\n \t}\n \n-      /* Have to have a mask expression */\n+      /* Have to have a mask expression.  */\n \n       m = gfc_match_expr (&msk);\n       if (m == MATCH_NO)"}, {"sha": "ffba10251a4b3b3ac5ef67e1dee1b15d57514050", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -1,5 +1,6 @@\n /* All matcher functions.\n-   Copyright (C) 2003, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2005, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n This file is part of GCC.\n@@ -35,9 +36,9 @@ extern gfc_st_label *gfc_statement_label;\n \n /****************** All gfc_match* routines *****************/\n \n-/* match.c */\n+/* match.c.  */\n \n-/* Generic match subroutines */\n+/* Generic match subroutines.  */\n match gfc_match_space (void);\n match gfc_match_eos (void);\n match gfc_match_small_literal_int (int *, int *);\n@@ -53,7 +54,7 @@ match gfc_match_char (char);\n match gfc_match (const char *, ...);\n match gfc_match_iterator (gfc_iterator *, int);\n \n-/* Statement matchers */\n+/* Statement matchers.  */\n match gfc_match_program (void);\n match gfc_match_pointer_assignment (void);\n match gfc_match_assignment (void);\n@@ -90,9 +91,9 @@ match gfc_match_forall (gfc_statement *);\n \n gfc_common_head *gfc_get_common (const char *, int);\n \n-/* openmp.c */\n+/* openmp.c.  */\n \n-/* OpenMP directive matchers */\n+/* OpenMP directive matchers.  */\n match gfc_match_omp_eos (void);\n match gfc_match_omp_atomic (void);\n match gfc_match_omp_barrier (void);\n@@ -112,7 +113,7 @@ match gfc_match_omp_workshare (void);\n match gfc_match_omp_end_nowait (void);\n match gfc_match_omp_end_single (void);\n \n-/* decl.c */\n+/* decl.c.  */\n \n match gfc_match_data (void);\n match gfc_match_null (gfc_expr **);\n@@ -132,7 +133,7 @@ match gfc_match_implicit (void);\n \n void gfc_set_constant_character_len (int, gfc_expr *, bool);\n \n-/* Matchers for attribute declarations */\n+/* Matchers for attribute declarations.  */\n match gfc_match_allocatable (void);\n match gfc_match_dimension (void);\n match gfc_match_external (void);\n@@ -163,17 +164,17 @@ match gfc_match_literal_constant (gfc_expr **, int);\n    only makes sure the init expr. is valid.  */\n match gfc_match_init_expr (gfc_expr **);\n \n-/* array.c */\n+/* array.c.  */\n match gfc_match_array_spec (gfc_array_spec **);\n match gfc_match_array_ref (gfc_array_ref *, gfc_array_spec *, int);\n match gfc_match_array_constructor (gfc_expr **);\n \n-/* interface.c */\n+/* interface.c.  */\n match gfc_match_generic_spec (interface_type *, char *, gfc_intrinsic_op *);\n match gfc_match_interface (void);\n match gfc_match_end_interface (void);\n \n-/* io.c  */\n+/* io.c.  */\n match gfc_match_format (void);\n match gfc_match_open (void);\n match gfc_match_close (void);\n@@ -186,11 +187,11 @@ match gfc_match_read (void);\n match gfc_match_write (void);\n match gfc_match_print (void);\n \n-/* matchexp.c */\n+/* matchexp.c.  */\n match gfc_match_defined_op_name (char *, int);\n match gfc_match_expr (gfc_expr **);\n \n-/* module.c */\n+/* module.c.  */\n match gfc_match_use (void);\n void gfc_use_module (void);\n "}, {"sha": "876255f5849b63c4e655938dd19656e9773e59a4", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -399,6 +399,7 @@ find_pointer2 (void *p)\n \n \n /* Resolve any fixups using a known pointer.  */\n+\n static void\n resolve_fixups (fixup_t *f, void *gp)\n {\n@@ -599,7 +600,7 @@ gfc_match_use (void)\n \t  if (type == INTERFACE_USER_OP && m == MATCH_YES\n \t      && (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Renaming \"\n \t\t\t\t  \"operators in USE statements at %C\")\n-\t         == FAILURE))\n+\t\t == FAILURE))\n \t    goto cleanup;\n \n \t  if (only_flag)\n@@ -986,7 +987,7 @@ parse_string (void)\n \n   len = 0;\n \n-  /* See how long the string is */\n+  /* See how long the string is.  */\n   for ( ; ; )\n     {\n       c = module_char ();\n@@ -1017,11 +1018,11 @@ parse_string (void)\n     {\n       c = module_char ();\n       if (c == '\\'')\n-\tmodule_char ();\t\t/* Guaranteed to be another \\'  */\n+\tmodule_char ();\t\t/* Guaranteed to be another \\'.  */\n       *p++ = c;\n     }\n \n-  module_char ();\t\t/* Terminating \\'  */\n+  module_char ();\t\t/* Terminating \\'.  */\n   *p = '\\0';\t\t\t/* C-style string for debug purposes.  */\n }\n \n@@ -1186,7 +1187,7 @@ parse_atom (void)\n       bad_module (\"Bad name\");\n     }\n \n-  /* Not reached */\n+  /* Not reached.  */\n }\n \n \n@@ -1265,7 +1266,7 @@ find_enum (const mstring *m)\n \n   bad_module (\"find_enum(): Enum not found\");\n \n-  /* Not reached */\n+  /* Not reached.  */\n }\n \n \n@@ -1436,8 +1437,7 @@ mio_integer (int *ip)\n }\n \n \n-/* Read or write a character pointer that points to a string on the\n-   heap.  */\n+/* Read or write a character pointer that points to a string on the heap.  */\n \n static const char *\n mio_allocated_string (const char *s)\n@@ -1497,7 +1497,6 @@ mio_internal_string (char *string)\n }\n \n \n-\n typedef enum\n { AB_ALLOCATABLE, AB_DIMENSION, AB_EXTERNAL, AB_INTRINSIC, AB_OPTIONAL,\n   AB_POINTER, AB_SAVE, AB_TARGET, AB_DUMMY, AB_RESULT, AB_DATA,\n@@ -2171,7 +2170,6 @@ mio_formal_arglist (gfc_symbol *sym)\n     {\n       for (f = sym->formal; f; f = f->next)\n \tmio_symbol_ref (&f->sym);\n-\n     }\n   else\n     {\n@@ -2271,7 +2269,7 @@ mio_symtree_ref (gfc_symtree **stp)\n \t  f->next = p->u.rsym.stfixup;\n \t  p->u.rsym.stfixup = f;\n \n-\t  f->pointer = (void **)stp;\n+\t  f->pointer = (void **) stp;\n \t}\n     }\n }\n@@ -2598,7 +2596,7 @@ fix_mio_expr (gfc_expr *e)\n \t namespace, it has a unique name and we should look in the current\n \t namespace to see if the required, non-contained symbol is available\n \t yet. If so, the latter should be written.  */\n-      if (e->symtree->n.sym && check_unique_name(e->symtree->name))\n+      if (e->symtree->n.sym && check_unique_name (e->symtree->name))\n \tns_st = gfc_find_symtree (gfc_current_ns->sym_root,\n \t\t\t\t  e->symtree->n.sym->name);\n \n@@ -2801,7 +2799,7 @@ mio_expr (gfc_expr **ep)\n }\n \n \n-/* Read and write namelists */\n+/* Read and write namelists.  */\n \n static void\n mio_namelist (gfc_symbol *sym)\n@@ -2982,7 +2980,7 @@ mio_symbol (gfc_symbol *sym)\n \t}\n     }\n \n-  /* Save/restore common block links */\n+  /* Save/restore common block links.  */\n   mio_symbol_ref (&sym->common_next);\n \n   mio_formal_arglist (sym);\n@@ -3133,8 +3131,8 @@ load_generic_interfaces (void)\n \t      p = p ? p : name;\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n \t      if (!sym->attr.generic\n-\t\t    && sym->module != NULL\n-\t\t    && strcmp(module, sym->module) != 0)\n+\t\t  && sym->module != NULL\n+\t\t  && strcmp(module, sym->module) != 0)\n \t\tst->ambiguous = 1;\n \t    }\n \t  if (i == 1)\n@@ -3187,9 +3185,9 @@ load_commons (void)\n }\n \n \n-/* load_equiv()-- Load equivalences. The flag in_load_equiv informs\n-   mio_expr_ref of this so that unused variables are not loaded and\n-   so that the expression can be safely freed.*/\n+/* Load equivalences.  The flag in_load_equiv informs mio_expr_ref of this\n+   so that unused variables are not loaded and so that the expression can\n+   be safely freed.  */\n \n static void\n load_equiv (void)\n@@ -3204,7 +3202,7 @@ load_equiv (void)\n   while (end != NULL && end->next != NULL)\n     end = end->next;\n \n-  while (peek_atom() != ATOM_RPAREN) {\n+  while (peek_atom () != ATOM_RPAREN) {\n     mio_lparen ();\n     head = tail = NULL;\n \n@@ -3258,6 +3256,7 @@ load_equiv (void)\n   in_load_equiv = false;\n }\n \n+\n /* Recursive function to traverse the pointer_info tree and load a\n    needed symbol.  We return nonzero if we load a symbol and stop the\n    traversal, because the act of loading can alter the tree.  */\n@@ -3315,8 +3314,7 @@ load_needed (pointer_info *p)\n }\n \n \n-/* Recursive function for cleaning up things after a module has been\n-   read.  */\n+/* Recursive function for cleaning up things after a module has been read.  */\n \n static void\n read_cleanup (pointer_info *p)\n@@ -3391,7 +3389,7 @@ read_module (void)\n   gfc_symtree *st;\n   gfc_symbol *sym;\n \n-  get_module_locus (&operator_interfaces);\t/* Skip these for now */\n+  get_module_locus (&operator_interfaces);\t/* Skip these for now.  */\n   skip_list ();\n \n   get_module_locus (&user_operators);\n@@ -3489,8 +3487,7 @@ read_module (void)\n \t    p = name;\n \n \t  /* Skip symtree nodes not in an ONLY clause, unless there\n-\t     is an existing symtree loaded from another USE\n-\t     statement.  */\n+\t     is an existing symtree loaded from another USE statement.  */\n \t  if (p == NULL)\n \t    {\n \t      st = gfc_find_symtree (gfc_current_ns->sym_root, name);\n@@ -3642,7 +3639,7 @@ gfc_check_access (gfc_access specific_access, gfc_access default_access)\n }\n \n \n-/* Write a common block to the module */\n+/* Write a common block to the module.  */\n \n static void\n write_common (gfc_symtree *st)\n@@ -3794,6 +3791,7 @@ write_symbol0 (gfc_symtree *st)\n static int\n write_symbol1 (pointer_info *p)\n {\n+\n   if (p == NULL)\n     return 0;\n \n@@ -3982,6 +3980,7 @@ read_md5_from_module_file (const char * filename, unsigned char md5[16])\n   return 0;\n }\n \n+\n /* Given module, dump it to disk.  If there was an error while\n    processing the module, dump_flag will be set to zero and we delete\n    the module file, even if it was already there.  */\n@@ -4039,7 +4038,7 @@ gfc_dump_module (const char *name, int dump_flag)\n \t   gfc_source_file, p);\n   fgetpos (module_fp, &md5_pos);\n   fputs (\"00000000000000000000000000000000 -- \"\n-        \"If you edit this, you'll get what you deserve.\\n\\n\", module_fp);\n+\t\"If you edit this, you'll get what you deserve.\\n\\n\", module_fp);\n \n   /* Initialize the MD5 context that will be used for output.  */\n   md5_init_ctx (&ctx);"}, {"sha": "0daac0c1b8917c5e0cee716e687a0b9e9f119e5b", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -42,6 +42,7 @@ static void check_statement_label (gfc_statement);\n static void undo_new_statement (void);\n static void reject_statement (void);\n \n+\n /* A sort of half-matching function.  We try to match the word on the\n    input with the passed string.  If this succeeds, we call the\n    keyword-dependent matching function that will match the rest of the\n@@ -740,7 +741,6 @@ push_state (gfc_state_data *p, gfc_compile_state new_state, gfc_symbol *sym)\n \n \n /* Pop the current state.  */\n-\n static void\n pop_state (void)\n {"}, {"sha": "74aa9152540ee930c0c11e4315328571a5d43b07", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -2027,7 +2027,7 @@ resolve_call (gfc_code *c)\n   if (resolve_actual_arglist (c->ext.actual, ptype) == FAILURE)\n     return FAILURE;\n \n-  /* Resume assumed_size checking. */\n+  /* Resume assumed_size checking.  */\n   need_full_assumed_size--;\n \n   t = SUCCESS;\n@@ -5532,7 +5532,7 @@ resolve_charlen (gfc_charlen *cl)\n }\n \n \n-/* Test for non-constant shape arrays. */\n+/* Test for non-constant shape arrays.  */\n \n static bool\n is_non_constant_shape_array (gfc_symbol *sym)\n@@ -5632,7 +5632,7 @@ apply_default_init (gfc_symbol *sym)\n }\n \n \n-/* Resolution of common features of flavors variable and procedure. */\n+/* Resolution of common features of flavors variable and procedure.  */\n \n static try\n resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n@@ -5915,7 +5915,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n   /* Ensure that derived type for are not of a private type.  Internal\n      module procedures are excluded by 2.2.3.3 - ie. they are not\n      externally accessible and can access all the objects accessible in\n-     the host. */\n+     the host.  */\n   if (!(sym->ns->parent\n \t&& sym->ns->parent->proc_name->attr.flavor == FL_MODULE)\n       && gfc_check_access(sym->attr.access, sym->ns->default_access))\n@@ -6967,7 +6967,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n       return FAILURE;\n     }\n \n-  /* Shall not have allocatable components. */\n+  /* Shall not have allocatable components.  */\n   if (derived->attr.alloc_comp)\n     {\n       gfc_error (\"Derived type variable '%s' at %L cannot have ALLOCATABLE \"\n@@ -7263,7 +7263,7 @@ resolve_equivalence (gfc_equiv *eq)\n }\n \n \n-/* Resolve function and ENTRY types, issue diagnostics if needed. */\n+/* Resolve function and ENTRY types, issue diagnostics if needed.  */\n \n static void\n resolve_fntype (gfc_namespace *ns)"}, {"sha": "5215c3ec2a7010a8ee47de7b4fcb6fcf17adcf99", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 138, "deletions": 128, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -167,7 +167,7 @@ gfc_add_new_implicit_range (int c1, int c2)\n    the new implicit types back into the existing types will work.  */\n \n try\n-gfc_merge_new_implicit (gfc_typespec * ts)\n+gfc_merge_new_implicit (gfc_typespec *ts)\n {\n   int i;\n \n@@ -199,7 +199,7 @@ gfc_merge_new_implicit (gfc_typespec * ts)\n /* Given a symbol, return a pointer to the typespec for its default type.  */\n \n gfc_typespec *\n-gfc_get_default_type (gfc_symbol * sym, gfc_namespace * ns)\n+gfc_get_default_type (gfc_symbol *sym, gfc_namespace *ns)\n {\n   char letter;\n \n@@ -225,7 +225,7 @@ gfc_get_default_type (gfc_symbol * sym, gfc_namespace * ns)\n    type.  */\n \n try\n-gfc_set_default_type (gfc_symbol * sym, int error_flag, gfc_namespace * ns)\n+gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n {\n   gfc_typespec *ts;\n \n@@ -305,7 +305,7 @@ gfc_check_function_type (gfc_namespace *ns)\n                               }\n \n static try\n-check_conflict (symbol_attribute * attr, const char * name, locus * where)\n+check_conflict (symbol_attribute *attr, const char *name, locus *where)\n {\n   static const char *dummy = \"DUMMY\", *save = \"SAVE\", *pointer = \"POINTER\",\n     *target = \"TARGET\", *external = \"EXTERNAL\", *intent = \"INTENT\",\n@@ -359,8 +359,8 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       if (a1 != NULL)\n \t{\n \t  gfc_error\n-\t    (\"%s attribute not allowed in BLOCK DATA program unit at %L\", a1,\n-\t     where);\n+\t    (\"%s attribute not allowed in BLOCK DATA program unit at %L\",\n+\t     a1, where);\n \t  return FAILURE;\n \t}\n     }\n@@ -461,7 +461,8 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (value, dimension)\n   conf (value, external)\n \n-  if (attr->value && (attr->intent == INTENT_OUT || attr->intent == INTENT_INOUT))\n+  if (attr->value\n+      && (attr->intent == INTENT_OUT || attr->intent == INTENT_INOUT))\n     {\n       a1 = value;\n       a2 = attr->intent == INTENT_OUT ? intent_out : intent_inout;\n@@ -485,7 +486,6 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       && attr->flavor != FL_PROCEDURE\n       && attr->flavor != FL_UNKNOWN)\n     {\n-\n       a2 = in_namelist;\n       goto conflict;\n     }\n@@ -520,18 +520,18 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n \n     case FL_PROCEDURE:\n       conf2 (intent);\n-      conf2(save);\n+      conf2 (save);\n \n       if (attr->subroutine)\n \t{\n-\t  conf2(pointer);\n-\t  conf2(target);\n-\t  conf2(allocatable);\n-\t  conf2(result);\n-\t  conf2(in_namelist);\n-\t  conf2(dimension);\n-\t  conf2(function);\n-\t  conf2(threadprivate);\n+\t  conf2 (pointer);\n+\t  conf2 (target);\n+\t  conf2 (allocatable);\n+\t  conf2 (result);\n+\t  conf2 (in_namelist);\n+\t  conf2 (dimension);\n+\t  conf2 (function);\n+\t  conf2 (threadprivate);\n \t}\n \n       switch (attr->proc)\n@@ -637,8 +637,9 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n /* Mark a symbol as referenced.  */\n \n void\n-gfc_set_sym_referenced (gfc_symbol * sym)\n+gfc_set_sym_referenced (gfc_symbol *sym)\n {\n+\n   if (sym->attr.referenced)\n     return;\n \n@@ -656,7 +657,7 @@ gfc_set_sym_referenced (gfc_symbol * sym)\n    nonzero if not.  */\n \n static int\n-check_used (symbol_attribute * attr, const char * name, locus * where)\n+check_used (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->use_assoc == 0)\n@@ -679,7 +680,7 @@ check_used (symbol_attribute * attr, const char * name, locus * where)\n /* Generate an error because of a duplicate attribute.  */\n \n static void\n-duplicate_attr (const char *attr, locus * where)\n+duplicate_attr (const char *attr, locus *where)\n {\n \n   if (where == NULL)\n@@ -688,19 +689,22 @@ duplicate_attr (const char *attr, locus * where)\n   gfc_error (\"Duplicate %s attribute specified at %L\", attr, where);\n }\n \n-/* Called from decl.c (attr_decl1) to check attributes, when declared separately.  */\n+\n+/* Called from decl.c (attr_decl1) to check attributes, when declared\n+   separately.  */\n \n try\n-gfc_add_attribute (symbol_attribute * attr, locus * where)\n+gfc_add_attribute (symbol_attribute *attr, locus *where)\n {\n+\n   if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   return check_conflict (attr, NULL, where);\n }\n \n try\n-gfc_add_allocatable (symbol_attribute * attr, locus * where)\n+gfc_add_allocatable (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -718,7 +722,7 @@ gfc_add_allocatable (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_dimension (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -736,7 +740,7 @@ gfc_add_dimension (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_external (symbol_attribute * attr, locus * where)\n+gfc_add_external (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -755,7 +759,7 @@ gfc_add_external (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_intrinsic (symbol_attribute * attr, locus * where)\n+gfc_add_intrinsic (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -774,7 +778,7 @@ gfc_add_intrinsic (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_optional (symbol_attribute * attr, locus * where)\n+gfc_add_optional (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -792,7 +796,7 @@ gfc_add_optional (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_pointer (symbol_attribute * attr, locus * where)\n+gfc_add_pointer (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -804,7 +808,7 @@ gfc_add_pointer (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_cray_pointer (symbol_attribute * attr, locus * where)\n+gfc_add_cray_pointer (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -816,7 +820,7 @@ gfc_add_cray_pointer (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_cray_pointee (symbol_attribute * attr, locus * where)\n+gfc_add_cray_pointee (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -833,8 +837,9 @@ gfc_add_cray_pointee (symbol_attribute * attr, locus * where)\n   return check_conflict (attr, NULL, where);\n }\n \n+\n try\n-gfc_add_protected (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_protected (symbol_attribute *attr, const char *name, locus *where)\n {\n   if (check_used (attr, name, where))\n     return FAILURE;\n@@ -852,8 +857,9 @@ gfc_add_protected (symbol_attribute * attr, const char *name, locus * where)\n   return check_conflict (attr, name, where);\n }\n \n+\n try\n-gfc_add_result (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_result (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -865,7 +871,7 @@ gfc_add_result (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_save (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_save (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -892,8 +898,9 @@ gfc_add_save (symbol_attribute * attr, const char *name, locus * where)\n   return check_conflict (attr, name, where);\n }\n \n+\n try\n-gfc_add_value (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_value (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -912,8 +919,9 @@ gfc_add_value (symbol_attribute * attr, const char *name, locus * where)\n   return check_conflict (attr, name, where);\n }\n \n+\n try\n-gfc_add_volatile (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n {\n   /* No check_used needed as 11.2.1 of the F2003 standard allows\n      that the local identifier made accessible by a use statement can be\n@@ -932,8 +940,9 @@ gfc_add_volatile (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_threadprivate (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n {\n+\n   if (check_used (attr, name, where))\n     return FAILURE;\n \n@@ -949,7 +958,7 @@ gfc_add_threadprivate (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_target (symbol_attribute * attr, locus * where)\n+gfc_add_target (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -967,7 +976,7 @@ gfc_add_target (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_dummy (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_dummy (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -980,7 +989,7 @@ gfc_add_dummy (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_in_common (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_in_common (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -997,8 +1006,9 @@ gfc_add_in_common (symbol_attribute * attr, const char *name, locus * where)\n   return gfc_add_flavor (attr, FL_VARIABLE, name, where);\n }\n \n+\n try\n-gfc_add_in_equivalence (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_in_equivalence (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   /* Duplicate attribute already checked for.  */\n@@ -1026,8 +1036,7 @@ gfc_add_data (symbol_attribute *attr, const char *name, locus *where)\n \n \n try\n-gfc_add_in_namelist (symbol_attribute * attr, const char *name,\n-\t\t     locus * where)\n+gfc_add_in_namelist (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   attr->in_namelist = 1;\n@@ -1036,7 +1045,7 @@ gfc_add_in_namelist (symbol_attribute * attr, const char *name,\n \n \n try\n-gfc_add_sequence (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_sequence (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -1048,7 +1057,7 @@ gfc_add_sequence (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_elemental (symbol_attribute * attr, locus * where)\n+gfc_add_elemental (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -1060,7 +1069,7 @@ gfc_add_elemental (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_pure (symbol_attribute * attr, locus * where)\n+gfc_add_pure (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -1072,7 +1081,7 @@ gfc_add_pure (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_recursive (symbol_attribute * attr, locus * where)\n+gfc_add_recursive (symbol_attribute *attr, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -1084,7 +1093,7 @@ gfc_add_recursive (symbol_attribute * attr, locus * where)\n \n \n try\n-gfc_add_entry (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_entry (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -1102,7 +1111,7 @@ gfc_add_entry (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_function (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_function (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->flavor != FL_PROCEDURE\n@@ -1115,7 +1124,7 @@ gfc_add_function (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_subroutine (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_subroutine (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->flavor != FL_PROCEDURE\n@@ -1128,7 +1137,7 @@ gfc_add_subroutine (symbol_attribute * attr, const char *name, locus * where)\n \n \n try\n-gfc_add_generic (symbol_attribute * attr, const char *name, locus * where)\n+gfc_add_generic (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   if (attr->flavor != FL_PROCEDURE\n@@ -1144,8 +1153,8 @@ gfc_add_generic (symbol_attribute * attr, const char *name, locus * where)\n    considers attributes and can be reaffirmed multiple times.  */\n \n try\n-gfc_add_flavor (symbol_attribute * attr, sym_flavor f, const char *name,\n-\t\tlocus * where)\n+gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n+\t\tlocus *where)\n {\n \n   if ((f == FL_PROGRAM || f == FL_BLOCK_DATA || f == FL_MODULE\n@@ -1180,8 +1189,8 @@ gfc_add_flavor (symbol_attribute * attr, sym_flavor f, const char *name,\n \n \n try\n-gfc_add_procedure (symbol_attribute * attr, procedure_type t,\n-\t\t   const char *name, locus * where)\n+gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n+\t\t   const char *name, locus *where)\n {\n \n   if (check_used (attr, name, where))\n@@ -1216,7 +1225,7 @@ gfc_add_procedure (symbol_attribute * attr, procedure_type t,\n \n \n try\n-gfc_add_intent (symbol_attribute * attr, sym_intent intent, locus * where)\n+gfc_add_intent (symbol_attribute *attr, sym_intent intent, locus *where)\n {\n \n   if (check_used (attr, NULL, where))\n@@ -1242,8 +1251,8 @@ gfc_add_intent (symbol_attribute * attr, sym_intent intent, locus * where)\n /* No checks for use-association in public and private statements.  */\n \n try\n-gfc_add_access (symbol_attribute * attr, gfc_access access,\n-\t\tconst char *name, locus * where)\n+gfc_add_access (symbol_attribute *attr, gfc_access access,\n+\t\tconst char *name, locus *where)\n {\n \n   if (attr->access == ACCESS_UNKNOWN)\n@@ -1289,7 +1298,7 @@ gfc_add_explicit_interface (gfc_symbol * sym, ifsrc source,\n /* Add a type to a symbol.  */\n \n try\n-gfc_add_type (gfc_symbol * sym, gfc_typespec * ts, locus * where)\n+gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n {\n   sym_flavor flavor;\n \n@@ -1300,23 +1309,23 @@ gfc_add_type (gfc_symbol * sym, gfc_typespec * ts, locus * where)\n     {\n       const char *msg = \"Symbol '%s' at %L already has basic type of %s\";\n       if (!(sym->ts.type == ts->type\n-\t     && (sym->attr.flavor == FL_PROCEDURE || sym->attr.result))\n-\t   || gfc_notification_std (GFC_STD_GNU) == ERROR\n-\t   || pedantic)\n+\t    && (sym->attr.flavor == FL_PROCEDURE || sym->attr.result))\n+\t  || gfc_notification_std (GFC_STD_GNU) == ERROR\n+\t  || pedantic)\n \t{\n \t  gfc_error (msg, sym->name, where, gfc_basic_typename (sym->ts.type));\n \t  return FAILURE;\n \t}\n       else if (gfc_notify_std (GFC_STD_GNU, msg, sym->name, where,\n \t\t\t       gfc_basic_typename (sym->ts.type)) == FAILURE)\n-\t  return FAILURE;\n+\treturn FAILURE;\n     }\n \n   flavor = sym->attr.flavor;\n \n   if (flavor == FL_PROGRAM || flavor == FL_BLOCK_DATA || flavor == FL_MODULE\n-      || flavor == FL_LABEL || (flavor == FL_PROCEDURE\n-\t\t\t\t&& sym->attr.subroutine)\n+      || flavor == FL_LABEL\n+      || (flavor == FL_PROCEDURE && sym->attr.subroutine)\n       || flavor == FL_DERIVED || flavor == FL_NAMELIST)\n     {\n       gfc_error (\"Symbol '%s' at %L cannot have a type\", sym->name, where);\n@@ -1331,18 +1340,18 @@ gfc_add_type (gfc_symbol * sym, gfc_typespec * ts, locus * where)\n /* Clears all attributes.  */\n \n void\n-gfc_clear_attr (symbol_attribute * attr)\n+gfc_clear_attr (symbol_attribute *attr)\n {\n-  memset (attr, 0, sizeof(symbol_attribute));\n+  memset (attr, 0, sizeof (symbol_attribute));\n }\n \n \n /* Check for missing attributes in the new symbol.  Currently does\n    nothing, but it's not clear that it is unnecessary yet.  */\n \n try\n-gfc_missing_attr (symbol_attribute * attr ATTRIBUTE_UNUSED,\n-\t\t  locus * where ATTRIBUTE_UNUSED)\n+gfc_missing_attr (symbol_attribute *attr ATTRIBUTE_UNUSED,\n+\t\t  locus *where ATTRIBUTE_UNUSED)\n {\n \n   return SUCCESS;\n@@ -1374,7 +1383,8 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n     goto fail;\n   if (src->volatile_ && gfc_add_volatile (dest, NULL, where) == FAILURE)\n     goto fail;\n-  if (src->threadprivate && gfc_add_threadprivate (dest, NULL, where) == FAILURE)\n+  if (src->threadprivate\n+      && gfc_add_threadprivate (dest, NULL, where) == FAILURE)\n     goto fail;\n   if (src->target && gfc_add_target (dest, where) == FAILURE)\n     goto fail;\n@@ -1455,7 +1465,8 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n    point to the additional component structure.  */\n \n try\n-gfc_add_component (gfc_symbol * sym, const char *name, gfc_component ** component)\n+gfc_add_component (gfc_symbol *sym, const char *name,\n+\t\t   gfc_component **component)\n {\n   gfc_component *p, *tail;\n \n@@ -1493,7 +1504,7 @@ gfc_add_component (gfc_symbol * sym, const char *name, gfc_component ** componen\n    namespace.  */\n \n static void\n-switch_types (gfc_symtree * st, gfc_symbol * from, gfc_symbol * to)\n+switch_types (gfc_symtree *st, gfc_symbol *from, gfc_symbol *to)\n {\n   gfc_symbol *sym;\n \n@@ -1528,7 +1539,7 @@ switch_types (gfc_symtree * st, gfc_symbol * from, gfc_symbol * to)\n    is no translation and we return the node we were passed.  */\n \n gfc_symbol *\n-gfc_use_derived (gfc_symbol * sym)\n+gfc_use_derived (gfc_symbol *sym)\n {\n   gfc_symbol *s;\n   gfc_typespec *t;\n@@ -1586,7 +1597,7 @@ gfc_use_derived (gfc_symbol * sym)\n    not found or the components are private.  */\n \n gfc_component *\n-gfc_find_component (gfc_symbol * sym, const char *name)\n+gfc_find_component (gfc_symbol *sym, const char *name)\n {\n   gfc_component *p;\n \n@@ -1623,7 +1634,7 @@ gfc_find_component (gfc_symbol * sym, const char *name)\n    they point to.  */\n \n static void\n-free_components (gfc_component * p)\n+free_components (gfc_component *p)\n {\n   gfc_component *q;\n \n@@ -1639,11 +1650,10 @@ free_components (gfc_component * p)\n }\n \n \n-/* Set component attributes from a standard symbol attribute\n-   structure.  */\n+/* Set component attributes from a standard symbol attribute structure.  */\n \n void\n-gfc_set_component_attr (gfc_component * c, symbol_attribute * attr)\n+gfc_set_component_attr (gfc_component *c, symbol_attribute *attr)\n {\n \n   c->dimension = attr->dimension;\n@@ -1656,7 +1666,7 @@ gfc_set_component_attr (gfc_component * c, symbol_attribute * attr)\n    structure.  */\n \n void\n-gfc_get_component_attr (symbol_attribute * attr, gfc_component * c)\n+gfc_get_component_attr (symbol_attribute *attr, gfc_component *c)\n {\n \n   gfc_clear_attr (attr);\n@@ -1672,10 +1682,10 @@ gfc_get_component_attr (symbol_attribute * attr, gfc_component * c)\n    binary tree.  */\n \n static int\n-compare_st_labels (void * a1, void * b1)\n+compare_st_labels (void *a1, void *b1)\n {\n-  int a = ((gfc_st_label *)a1)->value;\n-  int b = ((gfc_st_label *)b1)->value;\n+  int a = ((gfc_st_label *) a1)->value;\n+  int b = ((gfc_st_label *) b1)->value;\n \n   return (b - a);\n }\n@@ -1686,8 +1696,9 @@ compare_st_labels (void * a1, void * b1)\n    occurs.  */\n \n void\n-gfc_free_st_label (gfc_st_label * label)\n+gfc_free_st_label (gfc_st_label *label)\n {\n+\n   if (label == NULL)\n     return;\n \n@@ -1699,11 +1710,13 @@ gfc_free_st_label (gfc_st_label * label)\n   gfc_free (label);\n }\n \n+\n /* Free a whole tree of gfc_st_label structures.  */\n \n static void\n-free_st_labels (gfc_st_label * label)\n+free_st_labels (gfc_st_label *label)\n {\n+\n   if (label == NULL)\n     return;\n \n@@ -1755,7 +1768,7 @@ gfc_get_st_label (int labelno)\n    correctly.  */\n \n void\n-gfc_define_st_label (gfc_st_label * lp, gfc_sl_type type, locus * label_locus)\n+gfc_define_st_label (gfc_st_label *lp, gfc_sl_type type, locus *label_locus)\n {\n   int labelno;\n \n@@ -1802,7 +1815,7 @@ gfc_define_st_label (gfc_st_label * lp, gfc_sl_type type, locus * label_locus)\n    wrong.  */\n \n try\n-gfc_reference_st_label (gfc_st_label * lp, gfc_sl_type type)\n+gfc_reference_st_label (gfc_st_label *lp, gfc_sl_type type)\n {\n   gfc_sl_type label_type;\n   int labelno;\n@@ -1867,7 +1880,7 @@ gfc_reference_st_label (gfc_st_label * lp, gfc_sl_type type)\n    PARENT if PARENT_TYPES is set.  */\n \n gfc_namespace *\n-gfc_get_namespace (gfc_namespace * parent, int parent_types)\n+gfc_get_namespace (gfc_namespace *parent, int parent_types)\n {\n   gfc_namespace *ns;\n   gfc_typespec *ts;\n@@ -1891,7 +1904,7 @@ gfc_get_namespace (gfc_namespace * parent, int parent_types)\n \n       if (parent_types && ns->parent != NULL)\n \t{\n-\t  /* Copy parent settings */\n+\t  /* Copy parent settings.  */\n \t  *ts = ns->parent->default_type[i - 'a'];\n \t  continue;\n \t}\n@@ -1923,7 +1936,7 @@ gfc_get_namespace (gfc_namespace * parent, int parent_types)\n /* Comparison function for symtree nodes.  */\n \n static int\n-compare_symtree (void * _st1, void * _st2)\n+compare_symtree (void *_st1, void *_st2)\n {\n   gfc_symtree *st1, *st2;\n \n@@ -1937,7 +1950,7 @@ compare_symtree (void * _st1, void * _st2)\n /* Allocate a new symtree node and associate it with the new symbol.  */\n \n gfc_symtree *\n-gfc_new_symtree (gfc_symtree ** root, const char *name)\n+gfc_new_symtree (gfc_symtree **root, const char *name)\n {\n   gfc_symtree *st;\n \n@@ -1952,7 +1965,7 @@ gfc_new_symtree (gfc_symtree ** root, const char *name)\n /* Delete a symbol from the tree.  Does not free the symbol itself!  */\n \n static void\n-delete_symtree (gfc_symtree ** root, const char *name)\n+delete_symtree (gfc_symtree **root, const char *name)\n {\n   gfc_symtree st, *st0;\n \n@@ -1969,7 +1982,7 @@ delete_symtree (gfc_symtree ** root, const char *name)\n    the namespace.  Returns NULL if the symbol is not found.  */\n \n gfc_symtree *\n-gfc_find_symtree (gfc_symtree * st, const char *name)\n+gfc_find_symtree (gfc_symtree *st, const char *name)\n {\n   int c;\n \n@@ -2015,7 +2028,7 @@ gfc_get_uop (const char *name)\n    not exist.  */\n \n gfc_user_op *\n-gfc_find_uop (const char *name, gfc_namespace * ns)\n+gfc_find_uop (const char *name, gfc_namespace *ns)\n {\n   gfc_symtree *st;\n \n@@ -2030,7 +2043,7 @@ gfc_find_uop (const char *name, gfc_namespace * ns)\n /* Remove a gfc_symbol structure and everything it points to.  */\n \n void\n-gfc_free_symbol (gfc_symbol * sym)\n+gfc_free_symbol (gfc_symbol *sym)\n {\n \n   if (sym == NULL)\n@@ -2058,7 +2071,7 @@ gfc_free_symbol (gfc_symbol * sym)\n /* Allocate and initialize a new symbol node.  */\n \n gfc_symbol *\n-gfc_new_symbol (const char *name, gfc_namespace * ns)\n+gfc_new_symbol (const char *name, gfc_namespace *ns)\n {\n   gfc_symbol *p;\n \n@@ -2081,7 +2094,7 @@ gfc_new_symbol (const char *name, gfc_namespace * ns)\n /* Generate an error if a symbol is ambiguous.  */\n \n static void\n-ambiguous_symbol (const char *name, gfc_symtree * st)\n+ambiguous_symbol (const char *name, gfc_symtree *st)\n {\n \n   if (st->n.sym->module)\n@@ -2098,8 +2111,8 @@ ambiguous_symbol (const char *name, gfc_symtree * st)\n    Returns nonzero if the name is ambiguous.  */\n \n int\n-gfc_find_sym_tree (const char *name, gfc_namespace * ns, int parent_flag,\n-\t\t   gfc_symtree ** result)\n+gfc_find_sym_tree (const char *name, gfc_namespace *ns, int parent_flag,\n+\t\t   gfc_symtree **result)\n {\n   gfc_symtree *st;\n \n@@ -2138,8 +2151,8 @@ gfc_find_sym_tree (const char *name, gfc_namespace * ns, int parent_flag,\n /* Same, but returns the symbol instead.  */\n \n int\n-gfc_find_symbol (const char *name, gfc_namespace * ns, int parent_flag,\n-\t\t gfc_symbol ** result)\n+gfc_find_symbol (const char *name, gfc_namespace *ns, int parent_flag,\n+\t\t gfc_symbol **result)\n {\n   gfc_symtree *st;\n   int i;\n@@ -2158,7 +2171,7 @@ gfc_find_symbol (const char *name, gfc_namespace * ns, int parent_flag,\n /* Save symbol with the information necessary to back it out.  */\n \n static void\n-save_symbol_data (gfc_symbol * sym)\n+save_symbol_data (gfc_symbol *sym)\n {\n \n   if (sym->new || sym->old_symbol != NULL)\n@@ -2184,7 +2197,7 @@ save_symbol_data (gfc_symbol * sym)\n    So if the return value is nonzero, then an error was issued.  */\n \n int\n-gfc_get_sym_tree (const char *name, gfc_namespace * ns, gfc_symtree ** result)\n+gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result)\n {\n   gfc_symtree *st;\n   gfc_symbol *p;\n@@ -2246,12 +2259,11 @@ gfc_get_sym_tree (const char *name, gfc_namespace * ns, gfc_symtree ** result)\n \n \n int\n-gfc_get_symbol (const char *name, gfc_namespace * ns, gfc_symbol ** result)\n+gfc_get_symbol (const char *name, gfc_namespace *ns, gfc_symbol **result)\n {\n   gfc_symtree *st;\n   int i;\n \n-\n   i = gfc_get_sym_tree (name, ns, &st);\n   if (i != 0)\n     return i;\n@@ -2268,7 +2280,7 @@ gfc_get_symbol (const char *name, gfc_namespace * ns, gfc_symbol ** result)\n    exist, but tries to host-associate the symbol if possible.  */\n \n int\n-gfc_get_ha_sym_tree (const char *name, gfc_symtree ** result)\n+gfc_get_ha_sym_tree (const char *name, gfc_symtree **result)\n {\n   gfc_symtree *st;\n   int i;\n@@ -2277,7 +2289,6 @@ gfc_get_ha_sym_tree (const char *name, gfc_symtree ** result)\n   if (st != NULL)\n     {\n       save_symbol_data (st->n.sym);\n-\n       *result = st;\n       return i;\n     }\n@@ -2300,7 +2311,7 @@ gfc_get_ha_sym_tree (const char *name, gfc_symtree ** result)\n \n \n int\n-gfc_get_ha_symbol (const char *name, gfc_symbol ** result)\n+gfc_get_ha_symbol (const char *name, gfc_symbol **result)\n {\n   int i;\n   gfc_symtree *st;\n@@ -2319,7 +2330,7 @@ gfc_get_ha_symbol (const char *name, gfc_symbol ** result)\n    not take account of aliasing due to equivalence statements.  */\n \n int\n-gfc_symbols_could_alias (gfc_symbol * lsym, gfc_symbol * rsym)\n+gfc_symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym)\n {\n   /* Aliasing isn't possible if the symbols have different base types.  */\n   if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)\n@@ -2397,7 +2408,6 @@ gfc_undo_symbols (void)\n \t}\n       else\n \t{\n-\n \t  if (p->namelist_tail != old->namelist_tail)\n \t    {\n \t      gfc_free_namelist (old->namelist_tail);\n@@ -2429,8 +2439,9 @@ gfc_undo_symbols (void)\n    because sym->namelist has gotten a few more items.  */\n \n static void\n-free_old_symbol (gfc_symbol * sym)\n+free_old_symbol (gfc_symbol *sym)\n {\n+\n   if (sym->old_symbol == NULL)\n     return;\n \n@@ -2462,7 +2473,6 @@ gfc_commit_symbols (void)\n       p->tlink = NULL;\n       p->mark = 0;\n       p->new = 0;\n-\n       free_old_symbol (p);\n     }\n   changed_syms = NULL;\n@@ -2473,7 +2483,7 @@ gfc_commit_symbols (void)\n    information.  */\n \n void\n-gfc_commit_symbol (gfc_symbol * sym)\n+gfc_commit_symbol (gfc_symbol *sym)\n {\n   gfc_symbol *p;\n \n@@ -2517,7 +2527,7 @@ free_common_tree (gfc_symtree * common_tree)\n    operator nodes that it contains.  */\n \n static void\n-free_uop_tree (gfc_symtree * uop_tree)\n+free_uop_tree (gfc_symtree *uop_tree)\n {\n \n   if (uop_tree == NULL)\n@@ -2537,7 +2547,7 @@ free_uop_tree (gfc_symtree * uop_tree)\n    that it contains.  */\n \n static void\n-free_sym_tree (gfc_symtree * sym_tree)\n+free_sym_tree (gfc_symtree *sym_tree)\n {\n   gfc_namespace *ns;\n   gfc_symbol *sym;\n@@ -2592,7 +2602,7 @@ gfc_free_dt_list (void)\n /* Free the gfc_equiv_info's.  */\n \n static void\n-gfc_free_equiv_infos (gfc_equiv_info * s)\n+gfc_free_equiv_infos (gfc_equiv_info *s)\n {\n   if (s == NULL)\n     return;\n@@ -2604,7 +2614,7 @@ gfc_free_equiv_infos (gfc_equiv_info * s)\n /* Free the gfc_equiv_lists.  */\n \n static void\n-gfc_free_equiv_lists (gfc_equiv_list * l)\n+gfc_free_equiv_lists (gfc_equiv_list *l)\n {\n   if (l == NULL)\n     return;\n@@ -2619,7 +2629,7 @@ gfc_free_equiv_lists (gfc_equiv_list * l)\n    taken care of when a specific name is freed.  */\n \n void\n-gfc_free_namespace (gfc_namespace * ns)\n+gfc_free_namespace (gfc_namespace *ns)\n {\n   gfc_charlen *cl, *cl2;\n   gfc_namespace *p, *q;\n@@ -2663,7 +2673,6 @@ gfc_free_namespace (gfc_namespace * ns)\n     {\n       q = p;\n       p = p->sibling;\n-\n       gfc_free_namespace (q);\n     }\n }\n@@ -2690,7 +2699,7 @@ gfc_symbol_done_2 (void)\n /* Clear mark bits from symbol nodes associated with a symtree node.  */\n \n static void\n-clear_sym_mark (gfc_symtree * st)\n+clear_sym_mark (gfc_symtree *st)\n {\n \n   st->n.sym->mark = 0;\n@@ -2700,7 +2709,7 @@ clear_sym_mark (gfc_symtree * st)\n /* Recursively traverse the symtree nodes.  */\n \n void\n-gfc_traverse_symtree (gfc_symtree * st, void (*func) (gfc_symtree *))\n+gfc_traverse_symtree (gfc_symtree *st, void (*func) (gfc_symtree *))\n {\n   if (st != NULL)\n     {\n@@ -2715,7 +2724,7 @@ gfc_traverse_symtree (gfc_symtree * st, void (*func) (gfc_symtree *))\n /* Recursive namespace traversal function.  */\n \n static void\n-traverse_ns (gfc_symtree * st, void (*func) (gfc_symbol *))\n+traverse_ns (gfc_symtree *st, void (*func) (gfc_symbol *))\n {\n \n   if (st == NULL)\n@@ -2734,7 +2743,7 @@ traverse_ns (gfc_symtree * st, void (*func) (gfc_symbol *))\n    care that each gfc_symbol node is called exactly once.  */\n \n void\n-gfc_traverse_ns (gfc_namespace * ns, void (*func) (gfc_symbol *))\n+gfc_traverse_ns (gfc_namespace *ns, void (*func) (gfc_symbol *))\n {\n \n   gfc_traverse_symtree (ns->sym_root, clear_sym_mark);\n@@ -2744,8 +2753,9 @@ gfc_traverse_ns (gfc_namespace * ns, void (*func) (gfc_symbol *))\n \n \n /* Return TRUE if the symbol is an automatic variable.  */\n+\n static bool\n-gfc_is_var_automatic (gfc_symbol * sym)\n+gfc_is_var_automatic (gfc_symbol *sym)\n {\n   /* Pointer and allocatable variables are never automatic.  */\n   if (sym->attr.pointer || sym->attr.allocatable)\n@@ -2765,7 +2775,7 @@ gfc_is_var_automatic (gfc_symbol * sym)\n /* Given a symbol, mark it as SAVEd if it is allowed.  */\n \n static void\n-save_symbol (gfc_symbol * sym)\n+save_symbol (gfc_symbol *sym)\n {\n \n   if (sym->attr.use_assoc)\n@@ -2785,7 +2795,7 @@ save_symbol (gfc_symbol * sym)\n /* Mark those symbols which can be SAVEd as such.  */\n \n void\n-gfc_save_all (gfc_namespace * ns)\n+gfc_save_all (gfc_namespace *ns)\n {\n \n   gfc_traverse_ns (ns, save_symbol);\n@@ -2833,13 +2843,13 @@ gfc_find_gsymbol (gfc_gsymbol *symbol, const char *name)\n /* Compare two global symbols. Used for managing the BB tree.  */\n \n static int\n-gsym_compare (void * _s1, void * _s2)\n+gsym_compare (void *_s1, void *_s2)\n {\n   gfc_gsymbol *s1, *s2;\n \n-  s1 = (gfc_gsymbol *)_s1;\n-  s2 = (gfc_gsymbol *)_s2;\n-  return strcmp(s1->name, s2->name);\n+  s1 = (gfc_gsymbol *) _s1;\n+  s2 = (gfc_gsymbol *) _s2;\n+  return strcmp (s1->name, s2->name);\n }\n \n "}, {"sha": "8b13e670a71e6f2775a7b8995625149c933cadf3", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -5009,7 +5009,7 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n   tree null_data;\n   stmtblock_t block;\n \n-  /* If the source is null, set the destination to null. */\n+  /* If the source is null, set the destination to null.  */\n   gfc_init_block (&block);\n   gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n   null_data = gfc_finish_block (&block);\n@@ -5126,7 +5126,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n       gfc_add_expr_to_block (&loopbody, tmp);\n \n-      /* Build the loop and return. */\n+      /* Build the loop and return.  */\n       gfc_init_loopinfo (&loop);\n       loop.dimen = 1;\n       loop.from[0] = gfc_index_zero_node;\n@@ -5143,7 +5143,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n     }\n \n   /* Otherwise, act on the components or recursively call self to\n-     act on a chain of components. */\n+     act on a chain of components.  */\n   for (c = der_type->components; c; c = c->next)\n     {\n       bool cmp_has_alloc_comps = (c->ts.type == BT_DERIVED)"}, {"sha": "bde7ea577cd83a7175031d3a9fc724689bf42edc", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -417,7 +417,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n    backend declarations for all of the elements.  */\n \n static void\n-create_common (gfc_common_head *com, segment_info * head, bool saw_equiv)\n+create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n {\n   segment_info *s, *next_s;\n   tree union_type;\n@@ -483,8 +483,10 @@ create_common (gfc_common_head *com, segment_info * head, bool saw_equiv)\n                 }\n \t      /* Add the initializer for this field.  */\n \t      tmp = gfc_conv_initializer (s->sym->value, &s->sym->ts,\n-\t\t  TREE_TYPE (s->field), s->sym->attr.dimension,\n-\t\t  s->sym->attr.pointer || s->sym->attr.allocatable);\n+\t\t\t\t\t  TREE_TYPE (s->field),\n+\t\t\t\t\t  s->sym->attr.dimension,\n+\t\t\t\t\t  s->sym->attr.pointer\n+\t\t\t\t\t  || s->sym->attr.allocatable);\n \n \t      CONSTRUCTOR_APPEND_ELT (v, s->field, tmp);\n               offset = s->offset + s->length;\n@@ -785,7 +787,7 @@ find_equivalence (segment_info *n)\n }\n \n \n-  /* Add all symbols equivalenced within a segment.  We need to scan the\n+/* Add all symbols equivalenced within a segment.  We need to scan the\n    segment list multiple times to include indirect equivalences.  Since\n    a new segment_info can inserted at the beginning of the segment list,\n    depending on its offset, we have to force a final pass through the\n@@ -827,7 +829,7 @@ add_equivalences (bool *saw_equiv)\n    Sets *palign to the required alignment.  */\n \n static HOST_WIDE_INT\n-align_segment (unsigned HOST_WIDE_INT * palign)\n+align_segment (unsigned HOST_WIDE_INT *palign)\n {\n   segment_info *s;\n   unsigned HOST_WIDE_INT offset;\n@@ -864,7 +866,7 @@ align_segment (unsigned HOST_WIDE_INT * palign)\n /* Adjust segment offsets by the given amount.  */\n \n static void\n-apply_segment_offset (segment_info * s, HOST_WIDE_INT offset)\n+apply_segment_offset (segment_info *s, HOST_WIDE_INT offset)\n {\n   for (; s; s = s->next)\n     s->offset += offset;\n@@ -999,7 +1001,8 @@ finish_equivalences (gfc_namespace *ns)\n         sym = z->expr->symtree->n.sym;\n         current_segment = get_segment_info (sym, 0);\n \n-        /* All objects directly or indirectly equivalenced with this symbol.  */\n+        /* All objects directly or indirectly equivalenced with this\n+\t   symbol.  */\n         add_equivalences (&dummy);\n \n \t/* Align the block.  */\n@@ -1010,16 +1013,17 @@ finish_equivalences (gfc_namespace *ns)\n \n \tapply_segment_offset (current_segment, offset);\n \n-\t/* Create the decl. If this is a module equivalence, it has a unique\n-\t   name, pointed to by z->module. This is written to a gfc_common_header\n-\t   to push create_common into using build_common_decl, so that the\n-\t   equivalence appears as an external symbol. Otherwise, a local\n-\t   declaration is built using build_equiv_decl.*/\n+\t/* Create the decl.  If this is a module equivalence, it has a\n+\t   unique name, pointed to by z->module.  This is written to a\n+\t   gfc_common_header to push create_common into using\n+\t   build_common_decl, so that the equivalence appears as an\n+\t   external symbol.  Otherwise, a local declaration is built using\n+\t   build_equiv_decl.  */\n \tif (z->module)\n \t  {\n \t    c = gfc_get_common_head ();\n \t    /* We've lost the real location, so use the location of the\n-\t     enclosing procedure.  */\n+\t       enclosing procedure.  */\n \t    c->where = ns->proc_name->declared_at;\n \t    strcpy (c->name, z->module);\n \t  }"}, {"sha": "0ab2d746c527ea048a4b9196507c9872d2f6e27a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -2909,7 +2909,7 @@ generate_expr_decls (gfc_symbol *sym, gfc_expr *e)\n }\n \n \n-/* Check for dependencies in the character length and array spec. */\n+/* Check for dependencies in the character length and array spec.  */\n \n static void\n generate_dependency_declarations (gfc_symbol *sym)"}, {"sha": "6bd867b221ac080383d5c309f8a31aa79a4c634a", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -2025,7 +2025,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   /* We start with the most negative possible value for MAXLOC, and the most\n      positive possible value for MINLOC. The most negative possible value is\n      -HUGE for BT_REAL and (-HUGE - 1) for BT_INTEGER; the most positive\n-     possible value is HUGE in both cases. */\n+     possible value is HUGE in both cases.  */\n   if (op == GT_EXPR)\n     tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n   gfc_add_modify_expr (&se->pre, limit, tmp);\n@@ -2191,7 +2191,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n   /* We start with the most negative possible value for MAXVAL, and the most\n      positive possible value for MINVAL. The most negative possible value is\n      -HUGE for BT_REAL and (-HUGE - 1) for BT_INTEGER; the most positive\n-     possible value is HUGE in both cases. */\n+     possible value is HUGE in both cases.  */\n   if (op == GT_EXPR)\n     tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n "}, {"sha": "a1a057042d847dfbf35d8d7e866b7a6223cca96d", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -1261,7 +1261,7 @@ gfc_new_nml_name_expr (const char * name)\n }\n \n /* nml_full_name builds up the fully qualified name of a\n-   derived type component. */\n+   derived type component.  */\n \n static char*\n nml_full_name (const char* var_name, const char* cmp_name)\n@@ -1281,7 +1281,7 @@ nml_full_name (const char* var_name, const char* cmp_name)\n    gfc_symbol or gfc_component backend_decl's. An offset is\n    provided so that the address of an element of an array of\n    derived types is returned. This is used in the runtime to\n-   determine that span of the derived type. */\n+   determine that span of the derived type.  */\n \n static tree\n nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,"}, {"sha": "51586c8c895ce3fa98e5082df177388d12d2813b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -243,7 +243,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t}\n \n       /* If there is a dependency, create a temporary and use it\n-\t instead of the variable. */\n+\t instead of the variable.  */\n       fsym = formal ? formal->sym : NULL;\n       if (e->expr_type == EXPR_VARIABLE\n \t    && e->rank && fsym"}, {"sha": "20d1718b818bb1c74f8522853f8ead22f62f42b4", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e4ab31274a1e661befd9534463d158c54a55a2/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=66e4ab31274a1e661befd9534463d158c54a55a2", "patch": "@@ -77,6 +77,7 @@ gfc_real_info gfc_real_kinds[MAX_REAL_KINDS + 1];\n static GTY(()) tree gfc_real_types[MAX_REAL_KINDS + 1];\n static GTY(()) tree gfc_complex_types[MAX_REAL_KINDS + 1];\n \n+\n /* The integer kind to use for array indices.  This will be set to the\n    proper value based on target information from the backend.  */\n \n@@ -1594,7 +1595,7 @@ gfc_return_by_reference (gfc_symbol * sym)\n       && sym->ts.type == BT_COMPLEX\n       && !sym->attr.intrinsic && !sym->attr.always_explicit)\n     return 1;\n-  \n+\n   return 0;\n }\n \f"}]}