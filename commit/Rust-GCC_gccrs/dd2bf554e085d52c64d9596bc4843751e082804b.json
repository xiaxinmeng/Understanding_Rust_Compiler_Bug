{"sha": "dd2bf554e085d52c64d9596bc4843751e082804b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQyYmY1NTRlMDg1ZDUyYzY0ZDk1OTZiYzQ4NDM3NTFlMDgyODA0Yg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2014-02-19T10:30:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T10:30:33Z"}, "message": "style.adb (Missing_Overriding): Warning does not apply in language versions prior to Ada 2005.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* style.adb (Missing_Overriding): Warning does not apply in\n\tlanguage versions prior to Ada 2005.\n\t* snames.ads-tmpl: Add Name_Iterable and Attribute_Iterable.\n\t* sem_attr.adb: Add Attribute_Iterable where needed.\n\t* exp_attr.adb: ditto.\n\t* exp_ch5.adb (Expand_Formal_Container_Loop): New procedure to\n\thandle loops and quantified expressions over types that have an\n\titerable aspect.  Called from Expand_Iterator_Loop.\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Recognize types\n\twith Iterable aspect.\n\t* sem_ch13.adb (Validate_Iterable_Aspect): Verify that the\n\tsubprograms specified in the Iterable aspect have the proper\n\tsignature involving container and cursor.\n\t(Check_Aspect_At_Freeze_Point): Analyze value of iterable aspect.\n\t* sem_ch13.ads (Validate_Iterable_Aspect): New subprogram.\n\t* sem_util.ads, sem_util.adb (Get_Iterable_Type_Primitive):\n\tNew procedure to retrieve one of the primitives First, Last,\n\tor Has_Element, from the value of the iterable aspect of a\n\tformal container.\n\t(Is_Container_Element): Predicate to recognize expressions\n\tthat denote an element of one of the predefined containers,\n\tfor possible optimization.  This subprogram is not currently\n\tused, pending ARG discussions on the legality of the proposed\n\toptimization. Worth preserving for eventual use.\n\t(Is_Iterator): Recognize formal container types.\n\t* aspects.ads, aspects.adb: Add Aspect_Iterable where needed.\n\nFrom-SVN: r207881", "tree": {"sha": "a47b8f73a25d9edbde9b11b8b6ba4b1774d438f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a47b8f73a25d9edbde9b11b8b6ba4b1774d438f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd2bf554e085d52c64d9596bc4843751e082804b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2bf554e085d52c64d9596bc4843751e082804b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd2bf554e085d52c64d9596bc4843751e082804b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2bf554e085d52c64d9596bc4843751e082804b/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f63680d9a8239e801b7f9a0c6f7ddabf433c06"}], "stats": {"total": 566, "additions": 561, "deletions": 5}, "files": [{"sha": "a069df867ed90cedf977c25f46acd7f7b9638c51", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -1,3 +1,32 @@\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* style.adb (Missing_Overriding): Warning does not apply in\n+\tlanguage versions prior to Ada 2005.\n+\t* snames.ads-tmpl: Add Name_Iterable and Attribute_Iterable.\n+\t* sem_attr.adb: Add Attribute_Iterable where needed.\n+\t* exp_attr.adb: ditto.\n+\t* exp_ch5.adb (Expand_Formal_Container_Loop): New procedure to\n+\thandle loops and quantified expressions over types that have an\n+\titerable aspect.  Called from Expand_Iterator_Loop.\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Recognize types\n+\twith Iterable aspect.\n+\t* sem_ch13.adb (Validate_Iterable_Aspect): Verify that the\n+\tsubprograms specified in the Iterable aspect have the proper\n+\tsignature involving container and cursor.\n+\t(Check_Aspect_At_Freeze_Point): Analyze value of iterable aspect.\n+\t* sem_ch13.ads (Validate_Iterable_Aspect): New subprogram.\n+\t* sem_util.ads, sem_util.adb (Get_Iterable_Type_Primitive):\n+\tNew procedure to retrieve one of the primitives First, Last,\n+\tor Has_Element, from the value of the iterable aspect of a\n+\tformal container.\n+\t(Is_Container_Element): Predicate to recognize expressions\n+\tthat denote an element of one of the predefined containers,\n+\tfor possible optimization.  This subprogram is not currently\n+\tused, pending ARG discussions on the legality of the proposed\n+\toptimization. Worth preserving for eventual use.\n+\t(Is_Iterator): Recognize formal container types.\n+\t* aspects.ads, aspects.adb: Add Aspect_Iterable where needed.\n+\n 2014-02-19  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_attr.adb (Expand_Min_Max_Attribute): New procedure"}, {"sha": "e34c9faad0141c9b3ace6a8e5d9288cb0c722011", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -514,6 +514,7 @@ package body Aspects is\n     Aspect_Interrupt_Handler            => Aspect_Interrupt_Handler,\n     Aspect_Interrupt_Priority           => Aspect_Priority,\n     Aspect_Invariant                    => Aspect_Invariant,\n+    Aspect_Iterable                     => Aspect_Iterable,\n     Aspect_Iterator_Element             => Aspect_Iterator_Element,\n     Aspect_Link_Name                    => Aspect_Link_Name,\n     Aspect_Linker_Section               => Aspect_Linker_Section,"}, {"sha": "be39625fb93898ab424eaeb078aa18fbc39f35ba", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -102,6 +102,7 @@ package Aspects is\n       Aspect_Interrupt_Priority,\n       Aspect_Invariant,                     -- GNAT\n       Aspect_Iterator_Element,\n+      Aspect_Iterable,                      -- GNAT\n       Aspect_Link_Name,\n       Aspect_Linker_Section,                -- GNAT\n       Aspect_Machine_Radix,\n@@ -325,6 +326,7 @@ package Aspects is\n       Aspect_Input                   => Name,\n       Aspect_Interrupt_Priority      => Expression,\n       Aspect_Invariant               => Expression,\n+      Aspect_Iterable                => Expression,\n       Aspect_Iterator_Element        => Name,\n       Aspect_Link_Name               => Expression,\n       Aspect_Linker_Section          => Expression,\n@@ -423,6 +425,7 @@ package Aspects is\n       Aspect_Interrupt_Priority           => Name_Interrupt_Priority,\n       Aspect_Invariant                    => Name_Invariant,\n       Aspect_Iterator_Element             => Name_Iterator_Element,\n+      Aspect_Iterable                     => Name_Iterable,\n       Aspect_Link_Name                    => Name_Link_Name,\n       Aspect_Linker_Section               => Name_Linker_Section,\n       Aspect_Lock_Free                    => Name_Lock_Free,\n@@ -628,6 +631,7 @@ package Aspects is\n       Aspect_Interrupt_Handler            => Always_Delay,\n       Aspect_Interrupt_Priority           => Always_Delay,\n       Aspect_Invariant                    => Always_Delay,\n+      Aspect_Iterable                     => Always_Delay,\n       Aspect_Iterator_Element             => Always_Delay,\n       Aspect_Link_Name                    => Always_Delay,\n       Aspect_Linker_Section               => Always_Delay,"}, {"sha": "683233c257acbc02ea96b2225096444c8bbde1c9", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -1351,6 +1351,7 @@ package body Exp_Attr is\n       when Attribute_Constant_Indexing    |\n            Attribute_Default_Iterator     |\n            Attribute_Implicit_Dereference |\n+           Attribute_Iterable             |\n            Attribute_Iterator_Element     |\n            Attribute_Variable_Indexing    =>\n          null;"}, {"sha": "37ce6f4efebab4fe5047de7717b7e3e5b509681d", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -103,6 +103,8 @@ package body Exp_Ch5 is\n    --  clause (this last case is required because holes in the tagged type\n    --  might be filled with components from child types).\n \n+   procedure Expand_Formal_Container_Loop (Typ : Entity_Id; N : Node_Id);\n+\n    procedure Expand_Iterator_Loop (N : Node_Id);\n    --  Expand loop over arrays and containers that uses the form \"for X of C\"\n    --  with an optional subtype mark, or \"for Y in C\".\n@@ -2651,6 +2653,85 @@ package body Exp_Ch5 is\n       Adjust_Condition (Condition (N));\n    end Expand_N_Exit_Statement;\n \n+   ----------------------------------\n+   -- Expand_Formal_Container_Loop --\n+   ----------------------------------\n+\n+   procedure Expand_Formal_Container_Loop (Typ : Entity_Id; N : Node_Id) is\n+      Isc       : constant Node_Id    := Iteration_Scheme (N);\n+      I_Spec    : constant Node_Id    := Iterator_Specification (Isc);\n+      Cursor    : constant Entity_Id  := Defining_Identifier (I_Spec);\n+      Container : constant Node_Id    := Entity (Name (I_Spec));\n+      Stats     : constant List_Id    := Statements (N);\n+      Loc       : constant Source_Ptr := Sloc (N);\n+\n+      First_Op : constant Entity_Id :=\n+                   Get_Iterable_Type_Primitive (Typ, Name_First);\n+      Next_Op  : constant Entity_Id :=\n+                   Get_Iterable_Type_Primitive (Typ, Name_Next);\n+      Has_Element_Op : constant Entity_Id :=\n+                   Get_Iterable_Type_Primitive (Typ, Name_Has_Element);\n+\n+      Advance  : Node_Id;\n+      Init     : Node_Id;\n+      New_Loop : Node_Id;\n+\n+   begin\n+      --  The expansion resembles the one for Ada containers, but the\n+      --  primitives mention the the domain of iteration explicitly, and\n+      --  First applied to the container yields a cursor directly.\n+\n+      --    Cursor : Cursor_type := First (Container);\n+      --    while Has_Element (Cursor, Container) loop\n+      --          <original loop statements>\n+      --       Cursor := Next (Container, Cursor);\n+      --    end loop;\n+\n+      Init :=\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => Cursor,\n+           Object_Definition => New_Occurrence_Of (Etype (First_Op),  Loc),\n+             Expression =>\n+               Make_Function_Call (Loc,\n+                 Name => New_Occurrence_Of (First_Op, Loc),\n+                   Parameter_Associations =>\n+                     New_List (New_Occurrence_Of (Container, Loc))));\n+\n+      Set_Ekind (Cursor, E_Variable);\n+\n+      Insert_Action (N, Init);\n+\n+      Advance :=\n+        Make_Assignment_Statement (Loc,\n+          Name => New_Occurrence_Of (Cursor, Loc),\n+          Expression =>\n+            Make_Function_Call (Loc,\n+              Name => New_Occurrence_Of (Next_Op, Loc),\n+                Parameter_Associations =>\n+                  New_List\n+                    (New_Occurrence_Of (Container, Loc),\n+                     New_Occurrence_Of (Cursor, Loc))));\n+\n+      Append_To (Stats, Advance);\n+\n+      New_Loop :=\n+        Make_Loop_Statement (Loc,\n+          Iteration_Scheme =>\n+            Make_Iteration_Scheme (Loc,\n+              Condition =>\n+                Make_Function_Call (Loc,\n+                  Name                   =>\n+                    New_Occurrence_Of (Has_Element_Op, Loc),\n+                  Parameter_Associations =>\n+                    New_List\n+                     (New_Reference_To (Container, Loc),\n+                      New_Reference_To (Cursor, Loc)))),\n+          Statements => Stats,\n+          End_Label  => Empty);\n+      Rewrite (N, New_Loop);\n+      Analyze (New_Loop);\n+   end Expand_Formal_Container_Loop;\n+\n    -----------------------------\n    -- Expand_N_Goto_Statement --\n    -----------------------------\n@@ -2966,6 +3047,10 @@ package body Exp_Ch5 is\n       if Is_Array_Type (Container_Typ) then\n          Expand_Iterator_Loop_Over_Array (N);\n          return;\n+\n+      elsif Has_Aspect (Container_Typ, Aspect_Iterable) then\n+         Expand_Formal_Container_Loop (Container_Typ, N);\n+         return;\n       end if;\n \n       --  Processing for containers"}, {"sha": "b25bf1726db840d014e5392ddf47ba49fb998456", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -2491,6 +2491,7 @@ package body Sem_Attr is\n            Attribute_Default_Iterator     |\n            Attribute_Implicit_Dereference |\n            Attribute_Iterator_Element     |\n+           Attribute_Iterable             |\n            Attribute_Variable_Indexing    =>\n          Error_Msg_N (\"illegal attribute\", N);\n \n@@ -7472,6 +7473,7 @@ package body Sem_Attr is\n               Attribute_Default_Iterator     |\n               Attribute_Implicit_Dereference |\n               Attribute_Iterator_Element     |\n+              Attribute_Iterable             |\n               Attribute_Variable_Indexing    => null;\n \n          --  Internal attributes used to deal with Ada 2012 delayed aspects."}, {"sha": "97715ca5d38f6a01a260508976030f4d1129880e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -1110,6 +1110,9 @@ package body Sem_Ch13 is\n                     Aspect_Iterator_Element  =>\n                   Analyze (Expression (ASN));\n \n+               when Aspect_Iterable =>\n+                  Validate_Iterable_Aspect (E, ASN);\n+\n                when others =>\n                   null;\n                end case;\n@@ -1571,6 +1574,7 @@ package body Sem_Ch13 is\n                     Aspect_Dispatching_Domain   |\n                     Aspect_External_Tag         |\n                     Aspect_Input                |\n+                    Aspect_Iterable             |\n                     Aspect_Iterator_Element     |\n                     Aspect_Machine_Radix        |\n                     Aspect_Object_Size          |\n@@ -4281,6 +4285,29 @@ package body Sem_Ch13 is\n             end if;\n          end Interrupt_Priority;\n \n+         --------------\n+         -- Iterable --\n+         --------------\n+\n+         when Attribute_Iterable =>\n+            Analyze (Expr);\n+            if Nkind (Expr) /= N_Aggregate then\n+               Error_Msg_N (\"aspect Iterable must be an aggregate\", Expr);\n+            end if;\n+\n+            declare\n+               Assoc : Node_Id;\n+\n+            begin\n+               Assoc := First (Component_Associations (Expr));\n+               while Present (Assoc) loop\n+                  if not Is_Entity_Name (Expression (Assoc)) then\n+                     Error_Msg_N (\"value must be a function\", Assoc);\n+                  end if;\n+                  Next (Assoc);\n+               end loop;\n+            end;\n+\n          ----------------------\n          -- Iterator_Element --\n          ----------------------\n@@ -8012,6 +8039,20 @@ package body Sem_Ch13 is\n             Analyze (Expression (ASN));\n             return;\n \n+         --  Ditto for Iterable, legality checks in Validate_Iterable_Aspect.\n+\n+         when Aspect_Iterable =>\n+            declare\n+               Assoc : Node_Id;\n+            begin\n+               Assoc := First (Component_Associations (Expression (ASN)));\n+               while Present (Assoc) loop\n+                  Analyze (Expression (Assoc));\n+                  Next (Assoc);\n+               end loop;\n+            end;\n+            return;\n+\n          --  Invariant/Predicate take boolean expressions\n \n          when Aspect_Dynamic_Predicate |\n@@ -11223,6 +11264,153 @@ package body Sem_Ch13 is\n       end loop;\n    end Validate_Independence;\n \n+   ------------------------------\n+   -- Validate_Iterable_Aspect --\n+   ------------------------------\n+\n+   procedure Validate_Iterable_Aspect (Typ : Entity_Id; ASN : Node_Id) is\n+      Scop           : constant Entity_Id := Scope (Typ);\n+      Assoc          : Node_Id;\n+      Expr           : Node_Id;\n+\n+      Prim           : Node_Id;\n+      Cursor         : Entity_Id;\n+\n+      First_Id       : Entity_Id;\n+      Next_Id        : Entity_Id;\n+      Has_Element_Id : Entity_Id;\n+      Element_Id     : Entity_Id;\n+\n+      procedure Check_Signature (Op : Entity_Id; Num_Formals : Positive);\n+      --  Verify that primitive has two parameters of the proper types.\n+\n+      procedure Check_Signature (Op : Entity_Id; Num_Formals : Positive) is\n+         F1, F2 : Entity_Id;\n+\n+      begin\n+         if Scope (Op) /= Current_Scope then\n+            Error_Msg_N (\"iterable primitive must be declared in scope\", Prim);\n+         end if;\n+\n+         F1 := First_Formal (Op);\n+         if No (F1)\n+           or else Etype (F1) /= Typ\n+         then\n+            Error_Msg_N (\"first parameter must be container type\", Op);\n+         end if;\n+\n+         if Num_Formals = 1 then\n+            if Present (Next_Formal (F1)) then\n+               Error_Msg_N (\"First must have a single parameter\", Op);\n+            end if;\n+\n+         else\n+            F2 := Next_Formal (F1);\n+            if No (F2)\n+              or else Etype (F2) /= Cursor\n+            then\n+               Error_Msg_N (\"second parameter must be cursor\", Op);\n+            end if;\n+\n+            if Present (Next_Formal (F2)) then\n+               Error_Msg_N (\"too many parameters in iterable primitive\", Op);\n+            end if;\n+         end if;\n+      end Check_Signature;\n+\n+   begin\n+      --  There must be a cursor type declared in the same package.\n+\n+      declare\n+         E : Entity_Id;\n+\n+      begin\n+         Cursor := Empty;\n+         E := First_Entity (Scop);\n+         while Present (E) loop\n+            if Chars (E) = Name_Cursor\n+               and then Is_Type (E)\n+            then\n+               Cursor := E;\n+               exit;\n+            end if;\n+\n+            Next_Entity (E);\n+         end loop;\n+\n+         if No (Cursor) then\n+            Error_Msg_N (\"Iterable aspect requires a cursor type\", ASN);\n+            return;\n+         end if;\n+      end;\n+\n+      First_Id       := Empty;\n+      Next_Id        := Empty;\n+      Has_Element_Id := Empty;\n+\n+      --  Each expression must resolve to a function with the proper signature\n+\n+      Assoc := First (Component_Associations (Expression (ASN)));\n+      while Present (Assoc) loop\n+         Expr := Expression (Assoc);\n+         Analyze (Expr);\n+\n+         if not Is_Entity_Name (Expr)\n+           or else Ekind (Entity (Expr)) /= E_Function\n+         then\n+            Error_Msg_N (\"this should be a function name\", Expr);\n+         end if;\n+\n+         Prim := First (Choices (Assoc));\n+         if Nkind (Prim) /= N_Identifier\n+           or else Present (Next (Prim))\n+         then\n+            Error_Msg_N (\"illegal name in association\", Prim);\n+\n+         elsif Chars (Prim) = Name_First then\n+            First_Id := Entity (Expr);\n+            Check_Signature (First_Id, 1);\n+            if Etype (First_Id) /= Cursor then\n+               Error_Msg_NE (\"First must return Cursor\", Expr, First_Id);\n+            end if;\n+\n+         elsif Chars (Prim) = Name_Next then\n+            Next_Id := Entity (Expr);\n+            Check_Signature (Next_Id, 2);\n+            if Etype (Next_Id) /= Cursor then\n+               Error_Msg_NE (\"Next must return Cursor\", Expr, First_Id);\n+            end if;\n+\n+         elsif Chars (Prim) = Name_Has_Element then\n+            Has_Element_Id := Entity (Expr);\n+            if Etype (Has_Element_Id) /= Standard_Boolean then\n+               Error_Msg_NE\n+                (\"Has_Element must return Boolean\", Expr, First_Id);\n+            end if;\n+\n+         elsif Chars (Prim) = Name_Element then\n+            Element_Id := Entity (Expr);\n+            Check_Signature (Element_Id, 2);\n+\n+         else\n+            Error_Msg_N (\"invalid name for iterable function\", Prim);\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+\n+      if No (First_Id) then\n+         Error_Msg_N (\"Iterable aspect must have a First primitive\", ASN);\n+\n+      elsif No (Next_Id) then\n+         Error_Msg_N (\"Iterable aspect must have a Next primitive\", ASN);\n+\n+      elsif No (Has_Element_Id) then\n+         Error_Msg_N\n+           (\"Iterable aspect must have a Has_Element  primitive\", ASN);\n+      end if;\n+   end Validate_Iterable_Aspect;\n+\n    -----------------------------------\n    -- Validate_Unchecked_Conversion --\n    -----------------------------------"}, {"sha": "d99d57947c1991b3fc2a319e213dfcb70490f3ee", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -325,4 +325,10 @@ package Sem_Ch13 is\n    procedure Inherit_Aspects_At_Freeze_Point (Typ : Entity_Id);\n    --  Given an entity Typ that denotes a derived type or a subtype, this\n    --  routine performs the inheritance of aspects at the freeze point.\n+\n+   procedure Validate_Iterable_Aspect (Typ : Entity_Id; ASN : Node_Id);\n+   --  For SPARK 2014 formal containers. The expression has the form of an\n+   --  aggregate, and each entry must denote a function with the proper\n+   --  syntax for First, Next, and Has_Element. Optionally an Element primitive\n+   --  may also be defined.\n end Sem_Ch13;"}, {"sha": "6155939b4732a5bcc615494b8a9d66533e43aab3", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -1890,20 +1890,30 @@ package body Sem_Ch5 is\n             --  iterator, typically the result of a call to Iterate. Give a\n             --  useful error message when the name is a container by itself.\n \n+            --  The type may be a formal container type, which has to have\n+            --  an Iterable aspect detailing the required primitives.\n+\n             if Is_Entity_Name (Original_Node (Name (N)))\n               and then not Is_Iterator (Typ)\n             then\n-               if not Has_Aspect (Typ, Aspect_Iterator_Element) then\n+               if Has_Aspect (Typ, Aspect_Iterable) then\n+                  null;\n+\n+               elsif not Has_Aspect (Typ, Aspect_Iterator_Element) then\n                   Error_Msg_NE\n                     (\"cannot iterate over&\", Name (N), Typ);\n                else\n                   Error_Msg_N\n                     (\"name must be an iterator, not a container\", Name (N));\n                end if;\n \n-               Error_Msg_NE\n-                 (\"\\to iterate directly over the elements of a container, \" &\n-                   \"write `of &`\", Name (N), Original_Node (Name (N)));\n+               if Has_Aspect (Typ, Aspect_Iterable) then\n+                  null;\n+               else\n+                  Error_Msg_NE\n+                    (\"\\to iterate directly over the elements of a container, \"\n+                      & \"write `of &`\", Name (N), Original_Node (Name (N)));\n+               end if;\n             end if;\n \n             --  The result type of Iterate function is the classwide type of"}, {"sha": "b8700189631853331eefd577f560b3002bfa2102", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -6619,6 +6619,34 @@ package body Sem_Util is\n       end if;\n    end Get_Index_Bounds;\n \n+   ---------------------------------\n+   -- Get_Iterable_Type_Primitive --\n+   ---------------------------------\n+\n+   function Get_Iterable_Type_Primitive\n+     (Typ : Entity_Id;\n+      Nam : Name_Id) return Entity_Id\n+   is\n+      Funcs : constant Node_Id := Find_Value_Of_Aspect (Typ, Aspect_Iterable);\n+      Assoc : Node_Id;\n+   begin\n+      if No (Funcs) then\n+         return Empty;\n+\n+      else\n+         Assoc := First (Component_Associations (Funcs));\n+         while Present (Assoc) loop\n+            if Chars (First (Choices (Assoc))) = Nam then\n+               return Entity (Expression (Assoc));\n+            end if;\n+\n+            Assoc := Next (Assoc);\n+         end loop;\n+\n+         return Empty;\n+      end if;\n+   end Get_Iterable_Type_Primitive;\n+\n    ----------------------------------\n    -- Get_Library_Unit_Name_string --\n    ----------------------------------\n@@ -9301,6 +9329,183 @@ package body Sem_Util is\n                or else Is_Task_Interface (T));\n    end Is_Concurrent_Interface;\n \n+   ---------------------------\n+   --  Is_Container_Element --\n+   ---------------------------\n+\n+   function Is_Container_Element (Exp : Node_Id) return Boolean is\n+      Loc      : constant Source_Ptr := Sloc (Exp);\n+      Pref     : constant Node_Id   := Prefix (Exp);\n+      Call     : Node_Id;\n+      --  Call to an indexing aspect\n+\n+      Cont_Typ : Entity_Id;\n+      --  The type of the container being accessed\n+\n+      Elem_Typ : Entity_Id;\n+      --  Its element type\n+\n+      Indexing : Entity_Id;\n+      Is_Const : Boolean;\n+      --  Indicates that constant indexing is used, and the element is thus\n+      --  a constant\n+\n+      Ref_Typ  : Entity_Id;\n+      --  The reference type returned by the indexing operation.\n+\n+   begin\n+      --  If C is a container, in a context that imposes the element type of\n+      --  that container, the indexing notation C (X) is rewritten as:\n+      --               Indexing (C, X).Discr.all\n+      --  where Indexing is one of the indexing aspects of the container.\n+      --  If the context does not require a reference, the construct can be\n+      --  rewritten as Element (C, X).\n+      --  First, verify that the construct has the proper form.\n+\n+      if not Expander_Active then\n+         return False;\n+\n+      elsif Nkind (Pref) /= N_Selected_Component then\n+         return False;\n+\n+      elsif Nkind (Prefix (Pref)) /= N_Function_Call then\n+         return False;\n+\n+      else\n+         Call     := Prefix (Pref);\n+         Ref_Typ  := Etype (Call);\n+      end if;\n+\n+      if not Has_Implicit_Dereference (Ref_Typ)\n+        or else No (First (Parameter_Associations (Call)))\n+        or else not Is_Entity_Name (Name (Call))\n+      then\n+         return False;\n+      end if;\n+\n+      --  Retrieve type of container object, and its iterator aspects.\n+\n+      Cont_Typ := Etype (First (Parameter_Associations (Call)));\n+      Indexing :=\n+         Find_Value_Of_Aspect (Cont_Typ, Aspect_Constant_Indexing);\n+      Is_Const := False;\n+      if No (Indexing) then\n+\n+         --  Container should have at least one indexing operation.\n+\n+         return False;\n+\n+      elsif Entity (Name (Call)) /= Entity (Indexing) then\n+\n+         --  This may be a variable indexing operation\n+\n+         Indexing :=\n+           Find_Value_Of_Aspect (Cont_Typ, Aspect_Variable_Indexing);\n+         if No (Indexing)\n+           or else Entity (Name (Call)) /= Entity (Indexing)\n+         then\n+            return False;\n+         end if;\n+\n+      else\n+         Is_Const := True;\n+      end if;\n+\n+      Elem_Typ := Find_Value_Of_Aspect (Cont_Typ, Aspect_Iterator_Element);\n+      if No (Elem_Typ)\n+        or else Entity (Elem_Typ) /= Etype (Exp)\n+      then\n+         return False;\n+      end if;\n+\n+      --  Check that the expression is not the target of an assignment, in\n+      --  which case the rewriting is not possible.\n+\n+      if not Is_Const then\n+         declare\n+            Par : Node_Id;\n+\n+         begin\n+            Par := Exp;\n+            while Present (Par)\n+            loop\n+               if Nkind (Parent (Par)) = N_Assignment_Statement\n+                 and then Par = Name (Parent (Par))\n+               then\n+                  return False;\n+\n+               --  A renaming produces a reference, and the transformation\n+               --  does not apply.\n+\n+               elsif Nkind (Parent (Par)) = N_Object_Renaming_Declaration then\n+                  return False;\n+\n+               elsif Nkind_In\n+                 (Nkind (Parent (Par)),\n+                     N_Function_Call,\n+                     N_Procedure_Call_Statement,\n+                     N_Entry_Call_Statement)\n+               then\n+                  --  Check that the element is not part of an actual for an\n+                  --  in-out parameter.\n+\n+                  declare\n+                     F : Entity_Id;\n+                     A : Node_Id;\n+\n+                  begin\n+                     F := First_Formal (Entity (Name (Parent (Par))));\n+                     A := First (Parameter_Associations (Parent (Par)));\n+                     while Present (F) loop\n+                        if A = Par\n+                          and then Ekind (F) /= E_In_Parameter\n+                        then\n+                           return False;\n+                        end if;\n+\n+                        Next_Formal (F);\n+                        Next (A);\n+                     end loop;\n+                  end;\n+\n+                  --  in_parameter in a call:  element is not modified.\n+\n+                  exit;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  The expression has the proper form and the context requires the\n+      --  element type. Retrieve the Element function of the container, and\n+      --  rewrite the construct as a call to it.\n+\n+      declare\n+         Op : Elmt_Id;\n+\n+      begin\n+         Op := First_Elmt (Primitive_Operations (Cont_Typ));\n+         while Present (Op) loop\n+            exit when Chars (Node (Op)) = Name_Element;\n+            Next_Elmt (Op);\n+         end loop;\n+\n+         if No (Op) then\n+            return False;\n+\n+         else\n+            Rewrite (Exp,\n+              Make_Function_Call (Loc,\n+                Name => New_Occurrence_Of (Node (Op), Loc),\n+                Parameter_Associations => Parameter_Associations (Call)));\n+            Analyze_And_Resolve (Exp, Entity (Elem_Typ));\n+            return True;\n+         end if;\n+      end;\n+   end Is_Container_Element;\n+\n    -----------------------\n    -- Is_Constant_Bound --\n    -----------------------\n@@ -10039,6 +10244,9 @@ package body Sem_Util is\n       elsif not Is_Tagged_Type (Typ) or else not Is_Derived_Type (Typ) then\n          return False;\n \n+      elsif Present (Find_Value_Of_Aspect (Typ, Aspect_Iterable)) then\n+         return True;\n+\n       else\n          Collect_Interfaces (Typ, Ifaces_List);\n "}, {"sha": "e06c1572c48ad32fb136ffb3212e951ed1242163", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -818,6 +818,12 @@ package Sem_Util is\n    --  The third argument supplies a source location for constructed nodes\n    --  returned by this function.\n \n+   function Get_Iterable_Type_Primitive\n+     (Typ : Entity_Id;\n+      Nam : Name_Id) return Entity_Id;\n+   --  Retrieve one of the primitives First, Next, Has_Element, Element from\n+   --  the value of the Iterable aspect of a formal type.\n+\n    procedure Get_Library_Unit_Name_String (Decl_Node : Node_Id);\n    --  Retrieve the fully expanded name of the library unit declared by\n    --  Decl_Node into the name buffer.\n@@ -1102,6 +1108,17 @@ package Sem_Util is\n    --  enumeration literal, or an expression composed of constant-bound\n    --  subexpressions which are evaluated by means of standard operators.\n \n+   function Is_Container_Element (Exp : Node_Id) return Boolean;\n+   --  This routine recognizes expressions that denote an element of one of\n+   --  the predefined containers, when the source only contains an indexing\n+   --  operation and an implicit dereference is inserted by the compiler. In\n+   --  the absence of this optimization, the indexing creates a temporary\n+   --  controlled cursor that sets the tampering bit of the container, and\n+   --  restricts the use of the convenient notation C (X) to contexts that\n+   --  do not check the tampering bit (e.g.  C.Include (X,  C (Y)).\n+   --  Exp is an explicit dereference. The transformation applies when it\n+   --  has the form  F (X).Discr.all.\n+\n    function Is_Controlling_Limited_Procedure\n      (Proc_Nam : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-345): Determine whether Proc_Nam is a primitive procedure"}, {"sha": "7a86c97b1ce03e6197640610f1828ceb7e38f445", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -872,6 +872,7 @@ package Snames is\n    Name_Integer_Value                  : constant Name_Id := N + $; -- GNAT\n    Name_Invalid_Value                  : constant Name_Id := N + $; -- GNAT\n    Name_Iterator_Element               : constant Name_Id := N + $; -- GNAT\n+   Name_Iterable                       : constant Name_Id := N + $; -- GNAT\n    Name_Large                          : constant Name_Id := N + $; -- Ada 83\n    Name_Last                           : constant Name_Id := N + $;\n    Name_Last_Bit                       : constant Name_Id := N + $;\n@@ -1496,6 +1497,7 @@ package Snames is\n       Attribute_Integer_Value,\n       Attribute_Invalid_Value,\n       Attribute_Iterator_Element,\n+      Attribute_Iterable,\n       Attribute_Large,\n       Attribute_Last,\n       Attribute_Last_Bit,"}, {"sha": "33e0077e0d21bbb30a20c5e66a3f6ac0f73d6ae3", "filename": "gcc/ada/style.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fstyle.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2bf554e085d52c64d9596bc4843751e082804b/gcc%2Fada%2Fstyle.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.adb?ref=dd2bf554e085d52c64d9596bc4843751e082804b", "patch": "@@ -29,6 +29,7 @@ with Csets;    use Csets;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Namet;    use Namet;\n+with Opt;      use Opt;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n@@ -260,10 +261,12 @@ package body Style is\n    begin\n \n       --  Perform the check on source subprograms and on subprogram instances,\n-      --  because these can be primitives of untagged types.\n+      --  because these can be primitives of untagged types. Note that such\n+      --  indicators were introduced in Ada 2005.\n \n       if Style_Check_Missing_Overriding\n         and then (Comes_From_Source (N) or else Is_Generic_Instance (E))\n+        and then Ada_Version >= Ada_2005\n       then\n          if Nkind (N) = N_Subprogram_Body then\n             Error_Msg_NE -- CODEFIX"}]}