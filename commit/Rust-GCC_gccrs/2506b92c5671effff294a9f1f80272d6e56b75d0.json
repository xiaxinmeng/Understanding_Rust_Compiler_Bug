{"sha": "2506b92c5671effff294a9f1f80272d6e56b75d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUwNmI5MmM1NjcxZWZmZmYyOTRhOWYxZjgwMjcyZDZlNTZiNzVkMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-11T08:51:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-11T08:51:34Z"}, "message": "tree-vrp.h (class value_range_base): New base class for value_range containing all but the m_equiv member.\n\n2018-11-11  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.h (class value_range_base): New base class for\n\tvalue_range containing all but the m_equiv member.\n\t(dump_value_range_base): Add.\n\t(range_includes_zero_p): Work on value_range_base.\n\t* tree-vrp.c (value_range_base::set): Split out base handling\n\tfrom...\n\t(value_range::set): this.\n\t(value_range::set_equiv): New.\n\t(value_range_base::value_range_base): New constructors.\n\t(value_range_base::check): Split out base handling from...\n\t(value_range::check): this.\n\t(value_range::equal_p): Refactor in terms of\n\tignore_equivs_equal_p which is now member of the base.\n\t(value_range_base::set_undefined): New.\n\t(value_range_base::set_varying): Likewise.\n\t(value_range_base::dump):Split out base handling from...\n\t(value_range::dump): this.\n\t(value_range_base::set_and_canonicalize): Split out base handling\n\tfrom...\n\t(value_range::set_and_canonicalize): this.\n\t(value_range_base::union_): New.\n\t* ipa-prop.h (struct ipa_jump_func): Use value_range_base *\n\tfor m_vr.\n\t* ipa-cp.c (class ipcp_vr_lattice): Use value_range_base\n\tinstead of value_range everywhere.\n\t(ipcp_vr_lattice::print): Use dump_value_range_base.\n\t(ipcp_vr_lattice::meet_with): Adjust.\n\t(ipcp_vr_lattice::meet_with_1): Likewise.\n\t(ipa_vr_operation_and_type_effects): Likewise.\n\t(propagate_vr_across_jump_function): Likewise.\n\t* ipa-prop.c (struct ipa_vr_ggc_hash_traits): Likewise.\n\t(ipa_get_value_range): Likewise.\n\t(ipa_set_jfunc_vr): Likewise.\n\t(ipa_compute_jump_functions_for_edge): Likewise.\n\nFrom-SVN: r266011", "tree": {"sha": "732562c6401b328f3dea5c5aab7282991ba039d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/732562c6401b328f3dea5c5aab7282991ba039d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2506b92c5671effff294a9f1f80272d6e56b75d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2506b92c5671effff294a9f1f80272d6e56b75d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2506b92c5671effff294a9f1f80272d6e56b75d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2506b92c5671effff294a9f1f80272d6e56b75d0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d18dc9db0513eae3dba69fb143e35cbe8c34f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d18dc9db0513eae3dba69fb143e35cbe8c34f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d18dc9db0513eae3dba69fb143e35cbe8c34f20"}], "stats": {"total": 401, "additions": 310, "deletions": 91}, "files": [{"sha": "2997cf7b486e4c2464a67c9ac6c76761eea8b682", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2506b92c5671effff294a9f1f80272d6e56b75d0", "patch": "@@ -1,3 +1,40 @@\n+2018-11-11  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.h (class value_range_base): New base class for\n+\tvalue_range containing all but the m_equiv member.\n+\t(dump_value_range_base): Add.\n+\t(range_includes_zero_p): Work on value_range_base.\n+\t* tree-vrp.c (value_range_base::set): Split out base handling\n+\tfrom...\n+\t(value_range::set): this.\n+\t(value_range::set_equiv): New.\n+\t(value_range_base::value_range_base): New constructors.\n+\t(value_range_base::check): Split out base handling from...\n+\t(value_range::check): this.\n+\t(value_range::equal_p): Refactor in terms of\n+\tignore_equivs_equal_p which is now member of the base.\n+\t(value_range_base::set_undefined): New.\n+\t(value_range_base::set_varying): Likewise.\n+\t(value_range_base::dump):Split out base handling from...\n+\t(value_range::dump): this.\n+\t(value_range_base::set_and_canonicalize): Split out base handling\n+\tfrom...\n+\t(value_range::set_and_canonicalize): this.\n+\t(value_range_base::union_): New.\n+\t* ipa-prop.h (struct ipa_jump_func): Use value_range_base *\n+\tfor m_vr.\n+\t* ipa-cp.c (class ipcp_vr_lattice): Use value_range_base\n+\tinstead of value_range everywhere.\n+\t(ipcp_vr_lattice::print): Use dump_value_range_base.\n+\t(ipcp_vr_lattice::meet_with): Adjust.\n+\t(ipcp_vr_lattice::meet_with_1): Likewise.\n+\t(ipa_vr_operation_and_type_effects): Likewise.\n+\t(propagate_vr_across_jump_function): Likewise.\n+\t* ipa-prop.c (struct ipa_vr_ggc_hash_traits): Likewise.\n+\t(ipa_get_value_range): Likewise.\n+\t(ipa_set_jfunc_vr): Likewise.\n+\t(ipa_compute_jump_functions_for_edge): Likewise.\n+\n 2018-11-10  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR middle-end/65703"}, {"sha": "4f147eb37cc3fa1bada42be63c648147ef99292c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=2506b92c5671effff294a9f1f80272d6e56b75d0", "patch": "@@ -307,18 +307,18 @@ class ipcp_bits_lattice\n class ipcp_vr_lattice\n {\n public:\n-  value_range m_vr;\n+  value_range_base m_vr;\n \n   inline bool bottom_p () const;\n   inline bool top_p () const;\n   inline bool set_to_bottom ();\n-  bool meet_with (const value_range *p_vr);\n+  bool meet_with (const value_range_base *p_vr);\n   bool meet_with (const ipcp_vr_lattice &other);\n   void init () { gcc_assert (m_vr.undefined_p ()); }\n   void print (FILE * f);\n \n private:\n-  bool meet_with_1 (const value_range *other_vr);\n+  bool meet_with_1 (const value_range_base *other_vr);\n };\n \n /* Structure containing lattices for a parameter itself and for pieces of\n@@ -522,7 +522,7 @@ ipcp_bits_lattice::print (FILE *f)\n void\n ipcp_vr_lattice::print (FILE * f)\n {\n-  dump_value_range (f, &m_vr);\n+  dump_value_range_base (f, &m_vr);\n }\n \n /* Print all ipcp_lattices of all functions to F.  */\n@@ -909,7 +909,7 @@ ipcp_vr_lattice::meet_with (const ipcp_vr_lattice &other)\n    lattice.  */\n \n bool\n-ipcp_vr_lattice::meet_with (const value_range *p_vr)\n+ipcp_vr_lattice::meet_with (const value_range_base *p_vr)\n {\n   return meet_with_1 (p_vr);\n }\n@@ -918,15 +918,15 @@ ipcp_vr_lattice::meet_with (const value_range *p_vr)\n    OTHER_VR lattice.  Return TRUE if anything changed.  */\n \n bool\n-ipcp_vr_lattice::meet_with_1 (const value_range *other_vr)\n+ipcp_vr_lattice::meet_with_1 (const value_range_base *other_vr)\n {\n   if (bottom_p ())\n     return false;\n \n   if (other_vr->varying_p ())\n     return set_to_bottom ();\n \n-  value_range save (m_vr);\n+  value_range_base save (m_vr);\n   m_vr.union_ (other_vr);\n   return !m_vr.ignore_equivs_equal_p (save);\n }\n@@ -1871,12 +1871,17 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n    the result is a range or an anti-range.  */\n \n static bool\n-ipa_vr_operation_and_type_effects (value_range *dst_vr, value_range *src_vr,\n+ipa_vr_operation_and_type_effects (value_range_base *dst_vr,\n+\t\t\t\t   value_range_base *src_vr,\n \t\t\t\t   enum tree_code operation,\n \t\t\t\t   tree dst_type, tree src_type)\n {\n-  *dst_vr = value_range ();\n-  extract_range_from_unary_expr (dst_vr, operation, dst_type, src_vr, src_type);\n+  /* ???  We'd want to use value_range_base on the VRP workers.  */\n+  value_range dst_tem;\n+  value_range src_tem (*src_vr);\n+  extract_range_from_unary_expr (&dst_tem, operation, dst_type,\n+\t\t\t\t &src_tem, src_type);\n+  *dst_vr = value_range_base (dst_tem.kind (), dst_tem.min (), dst_tem.max ());\n   if (dst_vr->varying_p () || dst_vr->undefined_p ())\n     return false;\n   return true;\n@@ -1915,7 +1920,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \n \t  if (src_lats->m_value_range.bottom_p ())\n \t    return dest_lat->set_to_bottom ();\n-\t  value_range vr;\n+\t  value_range_base vr;\n \t  if (ipa_vr_operation_and_type_effects (&vr,\n \t\t\t\t\t\t &src_lats->m_value_range.m_vr,\n \t\t\t\t\t\t operation, param_type,\n@@ -1932,12 +1937,12 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t  if (TREE_OVERFLOW_P (val))\n \t    val = drop_tree_overflow (val);\n \n-\t  value_range tmpvr (VR_RANGE, val, val);\n+\t  value_range_base tmpvr (VR_RANGE, val, val);\n \t  return dest_lat->meet_with (&tmpvr);\n \t}\n     }\n \n-  value_range vr;\n+  value_range_base vr;\n   if (jfunc->m_vr\n       && ipa_vr_operation_and_type_effects (&vr, jfunc->m_vr, NOP_EXPR,\n \t\t\t\t\t    param_type,"}, {"sha": "5d9d8cff52e6bb60febe85b1c6acb9f65067f2ce", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=2506b92c5671effff294a9f1f80272d6e56b75d0", "patch": "@@ -106,43 +106,42 @@ static GTY ((cache)) hash_table<ipa_bit_ggc_hash_traits> *ipa_bits_hash_table;\n /* Traits for a hash table for reusing value_ranges used for IPA.  Note that\n    the equiv bitmap is not hashed and is expected to be NULL.  */\n \n-struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range *>\n+struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range_base *>\n {\n-  typedef value_range *value_type;\n-  typedef value_range *compare_type;\n+  typedef value_range_base *value_type;\n+  typedef value_range_base *compare_type;\n   static hashval_t\n-  hash (const value_range *p)\n+  hash (const value_range_base *p)\n     {\n-      gcc_checking_assert (!p->equiv ());\n       inchash::hash hstate (p->kind ());\n       inchash::add_expr (p->min (), hstate);\n       inchash::add_expr (p->max (), hstate);\n       return hstate.end ();\n     }\n   static bool\n-  equal (const value_range *a, const value_range *b)\n+  equal (const value_range_base *a, const value_range_base *b)\n     {\n       return a->ignore_equivs_equal_p (*b);\n     }\n   static void\n-  mark_empty (value_range *&p)\n+  mark_empty (value_range_base *&p)\n     {\n       p = NULL;\n     }\n   static bool\n-  is_empty (const value_range *p)\n+  is_empty (const value_range_base *p)\n     {\n       return p == NULL;\n     }\n   static bool\n-  is_deleted (const value_range *p)\n+  is_deleted (const value_range_base *p)\n     {\n-      return p == reinterpret_cast<const value_range *> (1);\n+      return p == reinterpret_cast<const value_range_base *> (1);\n     }\n   static void\n-  mark_deleted (value_range *&p)\n+  mark_deleted (value_range_base *&p)\n     {\n-      p = reinterpret_cast<value_range *> (1);\n+      p = reinterpret_cast<value_range_base *> (1);\n     }\n };\n \n@@ -1770,14 +1769,14 @@ ipa_set_jfunc_bits (ipa_jump_func *jf, const widest_int &value,\n /* Return a pointer to a value_range just like *TMP, but either find it in\n    ipa_vr_hash_table or allocate it in GC memory.  TMP->equiv must be NULL.  */\n \n-static value_range *\n-ipa_get_value_range (value_range *tmp)\n+static value_range_base *\n+ipa_get_value_range (value_range_base *tmp)\n {\n-  value_range **slot = ipa_vr_hash_table->find_slot (tmp, INSERT);\n+  value_range_base **slot = ipa_vr_hash_table->find_slot (tmp, INSERT);\n   if (*slot)\n     return *slot;\n \n-  value_range *vr = ggc_alloc<value_range> ();\n+  value_range_base *vr = ggc_alloc<value_range_base> ();\n   *vr = *tmp;\n   *slot = vr;\n \n@@ -1788,10 +1787,10 @@ ipa_get_value_range (value_range *tmp)\n    equiv set. Use hash table in order to avoid creating multiple same copies of\n    value_ranges.  */\n \n-static value_range *\n+static value_range_base *\n ipa_get_value_range (enum value_range_kind type, tree min, tree max)\n {\n-  value_range tmp (type, min, max);\n+  value_range_base tmp (type, min, max);\n   return ipa_get_value_range (&tmp);\n }\n \n@@ -1810,7 +1809,7 @@ ipa_set_jfunc_vr (ipa_jump_func *jf, enum value_range_kind type,\n    copy from ipa_vr_hash_table or allocate a new on in GC memory.  */\n \n static void\n-ipa_set_jfunc_vr (ipa_jump_func *jf, value_range *tmp)\n+ipa_set_jfunc_vr (ipa_jump_func *jf, value_range_base *tmp)\n {\n   jf->m_vr = ipa_get_value_range (tmp);\n }\n@@ -1886,6 +1885,8 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      && (type = get_range_info (arg, &min, &max))\n \t      && (type == VR_RANGE || type == VR_ANTI_RANGE))\n \t    {\n+\t      /* ???  We'd want to use value_range_base here but the\n+\t         VRP workers need to be adjusted first.  */\n \t      value_range resvr;\n \t      value_range tmpvr (type,\n \t\t\t\t wide_int_to_tree (TREE_TYPE (arg), min),"}, {"sha": "5e826c5d3bab6d78f9b1956a5b9bda767ee45f49", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=2506b92c5671effff294a9f1f80272d6e56b75d0", "patch": "@@ -182,7 +182,7 @@ struct GTY (()) ipa_jump_func\n   /* Information about value range, containing valid data only when vr_known is\n      true.  The pointed to structure is shared betweed different jump\n      functions.  Use ipa_set_jfunc_vr to set this field.  */\n-  struct value_range *m_vr;\n+  struct value_range_base *m_vr;\n \n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump"}, {"sha": "3ef676bb71b0066d0533e17f00b6912709ac90a4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 167, "deletions": 36, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2506b92c5671effff294a9f1f80272d6e56b75d0", "patch": "@@ -73,16 +73,19 @@ along with GCC; see the file COPYING3.  If not see\n    for still active basic-blocks.  */\n static sbitmap *live;\n \n-/* Initialize value_range.  */\n-\n void\n-value_range::set (enum value_range_kind kind, tree min, tree max,\n-\t\t  bitmap equiv)\n+value_range_base::set (enum value_range_kind kind, tree min, tree max)\n {\n   m_kind = kind;\n   m_min = min;\n   m_max = max;\n+  if (flag_checking)\n+    check ();\n+}\n \n+void\n+value_range::set_equiv (bitmap equiv)\n+{\n   /* Since updating the equivalence set involves deep copying the\n      bitmaps, only do it if absolutely necessary.\n \n@@ -99,17 +102,38 @@ value_range::set (enum value_range_kind kind, tree min, tree max,\n       else\n \tbitmap_clear (m_equiv);\n     }\n+}\n+\n+/* Initialize value_range.  */\n+\n+void\n+value_range::set (enum value_range_kind kind, tree min, tree max,\n+\t\t  bitmap equiv)\n+{\n+  value_range_base::set (kind, min, max);\n+  set_equiv (equiv);\n   if (flag_checking)\n     check ();\n }\n \n+value_range_base::value_range_base (value_range_kind kind, tree min, tree max)\n+{\n+  set (kind, min, max);\n+}\n+\n value_range::value_range (value_range_kind kind, tree min, tree max,\n \t\t\t  bitmap equiv)\n {\n   m_equiv = NULL;\n   set (kind, min, max, equiv);\n }\n \n+value_range::value_range (const value_range_base &other)\n+{\n+  m_equiv = NULL;\n+  set (other.kind (), other.min(), other.max (), NULL);\n+}\n+\n /* Like above, but keep the equivalences intact.  */\n \n void\n@@ -133,7 +157,7 @@ value_range::deep_copy (const value_range *from)\n /* Check the validity of the range.  */\n \n void\n-value_range::check ()\n+value_range_base::check ()\n {\n   switch (m_kind)\n     {\n@@ -158,32 +182,44 @@ value_range::check ()\n     case VR_UNDEFINED:\n     case VR_VARYING:\n       gcc_assert (!min () && !max ());\n-      gcc_assert (!m_equiv || bitmap_empty_p (m_equiv));\n       break;\n     default:\n       gcc_unreachable ();\n     }\n }\n \n+void\n+value_range::check ()\n+{\n+  value_range_base::check ();\n+  switch (m_kind)\n+    {\n+    case VR_UNDEFINED:\n+    case VR_VARYING:\n+      gcc_assert (!m_equiv || bitmap_empty_p (m_equiv));\n+    default:;\n+    }\n+}\n+\n /* Returns TRUE if THIS == OTHER.  Ignores the equivalence bitmap if\n    IGNORE_EQUIVS is TRUE.  */\n \n bool\n value_range::equal_p (const value_range &other, bool ignore_equivs) const\n {\n-  return (m_kind == other.m_kind\n-\t  && vrp_operand_equal_p (m_min, other.m_min)\n-\t  && vrp_operand_equal_p (m_max, other.m_max)\n+  return (ignore_equivs_equal_p (other)\n \t  && (ignore_equivs\n \t      || vrp_bitmap_equal_p (m_equiv, other.m_equiv)));\n }\n \n /* Return equality while ignoring equivalence bitmap.  */\n \n bool\n-value_range::ignore_equivs_equal_p (const value_range &other) const\n+value_range_base::ignore_equivs_equal_p (const value_range_base &other) const\n {\n-  return equal_p (other, /*ignore_equivs=*/true);\n+  return (m_kind == other.m_kind\n+\t  && vrp_operand_equal_p (m_min, other.m_min)\n+\t  && vrp_operand_equal_p (m_max, other.m_max));\n }\n \n bool\n@@ -223,13 +259,25 @@ value_range::constant_p () const\n \t  && TREE_CODE (m_max) == INTEGER_CST);\n }\n \n+void\n+value_range_base::set_undefined ()\n+{\n+  *this = value_range_base (VR_UNDEFINED, NULL, NULL);\n+}\n+\n void\n value_range::set_undefined ()\n {\n   equiv_clear ();\n   *this = value_range (VR_UNDEFINED, NULL, NULL, NULL);\n }\n \n+void\n+value_range_base::set_varying ()\n+{\n+  *this = value_range_base (VR_VARYING, NULL, NULL);\n+}\n+\n void\n value_range::set_varying ()\n {\n@@ -240,7 +288,7 @@ value_range::set_varying ()\n /* Return TRUE if it is possible that range contains VAL.  */\n \n bool\n-value_range::may_contain_p (tree val) const\n+value_range_base::may_contain_p (tree val) const\n {\n   if (varying_p ())\n     return true;\n@@ -302,7 +350,7 @@ value_range::singleton_p (tree *result) const\n }\n \n tree\n-value_range::type () const\n+value_range_base::type () const\n {\n   /* Types are only valid for VR_RANGE and VR_ANTI_RANGE, which are\n      known to have non-zero min/max.  */\n@@ -313,7 +361,7 @@ value_range::type () const\n /* Dump value range to FILE.  */\n \n void\n-value_range::dump (FILE *file) const\n+value_range_base::dump (FILE *file) const\n {\n   if (undefined_p ())\n     fprintf (file, \"UNDEFINED\");\n@@ -339,30 +387,36 @@ value_range::dump (FILE *file) const\n \tprint_generic_expr (file, max ());\n \n       fprintf (file, \"]\");\n-\n-      if (m_equiv)\n-\t{\n-\t  bitmap_iterator bi;\n-\t  unsigned i, c = 0;\n-\n-\t  fprintf (file, \"  EQUIVALENCES: { \");\n-\n-\t  EXECUTE_IF_SET_IN_BITMAP (m_equiv, 0, i, bi)\n-\t    {\n-\t      print_generic_expr (file, ssa_name (i));\n-\t      fprintf (file, \" \");\n-\t      c++;\n-\t    }\n-\n-\t  fprintf (file, \"} (%u elements)\", c);\n-\t}\n     }\n   else if (varying_p ())\n     fprintf (file, \"VARYING\");\n   else\n     fprintf (file, \"INVALID RANGE\");\n }\n \n+void\n+value_range::dump (FILE *file) const\n+{\n+  value_range_base::dump (file);\n+  if ((m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n+      && m_equiv)\n+    {\n+      bitmap_iterator bi;\n+      unsigned i, c = 0;\n+\n+      fprintf (file, \"  EQUIVALENCES: { \");\n+\n+      EXECUTE_IF_SET_IN_BITMAP (m_equiv, 0, i, bi)\n+\t{\n+\t  print_generic_expr (file, ssa_name (i));\n+\t  fprintf (file, \" \");\n+\t  c++;\n+\t}\n+\n+      fprintf (file, \"} (%u elements)\", c);\n+    }\n+}\n+\n void\n value_range::dump () const\n {\n@@ -573,8 +627,8 @@ set_value_range (value_range *vr, enum value_range_kind kind,\n    extract ranges from var + CST op limit.  */\n \n void\n-value_range::set_and_canonicalize (enum value_range_kind kind,\n-\t\t\t\t   tree min, tree max, bitmap equiv)\n+value_range_base::set_and_canonicalize (enum value_range_kind kind,\n+\t\t\t\t\ttree min, tree max)\n {\n   /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n   if (kind == VR_UNDEFINED)\n@@ -592,7 +646,7 @@ value_range::set_and_canonicalize (enum value_range_kind kind,\n   if (TREE_CODE (min) != INTEGER_CST\n       || TREE_CODE (max) != INTEGER_CST)\n     {\n-      set_value_range (this, kind, min, max, equiv);\n+      set (kind, min, max);\n       return;\n     }\n \n@@ -680,7 +734,18 @@ value_range::set_and_canonicalize (enum value_range_kind kind,\n      to make sure VRP iteration terminates, otherwise we can get into\n      oscillations.  */\n \n-  set_value_range (this, kind, min, max, equiv);\n+  set (kind, min, max);\n+}\n+\n+void\n+value_range::set_and_canonicalize (enum value_range_kind kind,\n+\t\t\t\t   tree min, tree max, bitmap equiv)\n+{\n+  value_range_base::set_and_canonicalize (kind, min, max);\n+  if (this->kind () == VR_RANGE || this->kind () == VR_ANTI_RANGE)\n+    set_equiv (equiv);\n+  else\n+    equiv_clear ();\n }\n \n /* Set value range VR to a single value.  This function is only called\n@@ -1084,7 +1149,7 @@ value_inside_range (tree val, tree min, tree max)\n /* Return TRUE if *VR includes the value zero.  */\n \n bool\n-range_includes_zero_p (const value_range *vr)\n+range_includes_zero_p (const value_range_base *vr)\n {\n   if (vr->varying_p () || vr->undefined_p ())\n     return true;\n@@ -2119,6 +2184,15 @@ dump_value_range (FILE *file, const value_range *vr)\n     vr->dump (file);\n }\n \n+void\n+dump_value_range_base (FILE *file, const value_range_base *vr)\n+{\n+  if (!vr)\n+    fprintf (file, \"[]\");\n+  else\n+    vr->dump (file);\n+}\n+\n /* Dump value range VR to stderr.  */\n \n DEBUG_FUNCTION void\n@@ -6013,6 +6087,63 @@ value_range::intersect (const value_range *other)\n     }\n }\n \n+/* Meet operation for value ranges.  Given two value ranges VR0 and\n+   VR1, store in VR0 a range that contains both VR0 and VR1.  This\n+   may not be the smallest possible such range.  */\n+\n+void\n+value_range_base::union_ (const value_range_base *other)\n+{\n+  if (other->undefined_p ())\n+    {\n+      /* this already has the resulting range.  */\n+      return;\n+    }\n+\n+  if (this->undefined_p ())\n+    {\n+      *this = *other;\n+      return;\n+    }\n+\n+  if (this->varying_p ())\n+    {\n+      /* Nothing to do.  VR0 already has the resulting range.  */\n+      return;\n+    }\n+\n+  if (other->varying_p ())\n+    {\n+      this->set_varying ();\n+      return;\n+    }\n+\n+  value_range saved (*this);\n+  value_range_kind vr0type = this->kind ();\n+  tree vr0min = this->min ();\n+  tree vr0max = this->max ();\n+  union_ranges (&vr0type, &vr0min, &vr0max,\n+\t\tother->kind (), other->min (), other->max ());\n+  *this = value_range_base (vr0type, vr0min, vr0max);\n+  if (this->varying_p ())\n+    {\n+      /* Failed to find an efficient meet.  Before giving up and setting\n+\t the result to VARYING, see if we can at least derive a useful\n+\t anti-range.  */\n+      if (range_includes_zero_p (&saved) == 0\n+\t  && range_includes_zero_p (other) == 0)\n+\t{\n+\t  tree zero = build_int_cst (saved.type (), 0);\n+\t  *this = value_range_base (VR_ANTI_RANGE, zero, zero);\n+\t  return;\n+\t}\n+\n+      this->set_varying ();\n+      return;\n+    }\n+  this->set_and_canonicalize (this->kind (), this->min (), this->max ());\n+}\n+\n /* Meet operation for value ranges.  Given two value ranges VR0 and\n    VR1, store in VR0 a range that contains both VR0 and VR1.  This\n    may not be the smallest possible such range.  */"}, {"sha": "1e141c017e8cb662bcf65f539942088354da5387", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 67, "deletions": 22, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2506b92c5671effff294a9f1f80272d6e56b75d0/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=2506b92c5671effff294a9f1f80272d6e56b75d0", "patch": "@@ -35,12 +35,63 @@ enum value_range_kind\n   VR_LAST\n };\n \n+\n /* Range of values that can be associated with an SSA_NAME after VRP\n    has executed.  */\n-class GTY((for_user)) value_range\n+class GTY((for_user)) value_range_base\n+{\n+public:\n+  value_range_base ();\n+  value_range_base (value_range_kind, tree, tree);\n+\n+  enum value_range_kind kind () const;\n+  tree min () const;\n+  tree max () const;\n+\n+  /* Types of value ranges.  */\n+  bool undefined_p () const;\n+  bool varying_p () const;\n+\n+  void union_ (const value_range_base *);\n+\n+  bool ignore_equivs_equal_p (const value_range_base &) const;\n+\n+  void set_varying ();\n+  void set_undefined ();\n+\n+  /* Misc methods.  */\n+  tree type () const;\n+  bool may_contain_p (tree) const;\n+  void set_and_canonicalize (enum value_range_kind, tree, tree);\n+\n+  void dump (FILE *) const;\n+\n+protected:\n+  void set (value_range_kind, tree, tree);\n+  void check ();\n+\n+  enum value_range_kind m_kind;\n+\n+  tree m_min;\n+  tree m_max;\n+\n+  friend void gt_ggc_mx_value_range_base (void *);\n+  friend void gt_pch_p_16value_range_base (void *, void *,\n+\t\t\t\t\t   gt_pointer_operator, void *);\n+  friend void gt_pch_nx_value_range_base (void *);\n+  friend void gt_ggc_mx (value_range_base &);\n+  friend void gt_ggc_mx (value_range_base *&);\n+  friend void gt_pch_nx (value_range_base &);\n+  friend void gt_pch_nx (value_range_base *, gt_pointer_operator, void *);\n+};\n+\n+/* Note value_range cannot currently be used with GC memory, only\n+   value_range_base is fully set up for this.  */\n+class GTY((user)) value_range : public value_range_base\n {\n  public:\n   value_range ();\n+  value_range (const value_range_base &);\n   value_range (value_range_kind, tree, tree, bitmap = NULL);\n   void update (value_range_kind, tree, tree);\n   bool operator== (const value_range &) const;\n@@ -49,8 +100,6 @@ class GTY((for_user)) value_range\n   void union_ (const value_range *);\n \n   /* Types of value ranges.  */\n-  bool undefined_p () const;\n-  bool varying_p () const;\n   bool symbolic_p () const;\n   bool constant_p () const;\n   void set_undefined ();\n@@ -62,49 +111,44 @@ class GTY((for_user)) value_range\n   void equiv_add (const_tree, const value_range *, bitmap_obstack * = NULL);\n \n   /* Misc methods.  */\n-  tree type () const;\n   bool zero_p () const;\n-  bool may_contain_p (tree) const;\n   bool singleton_p (tree *result = NULL) const;\n   void deep_copy (const value_range *);\n-  bool ignore_equivs_equal_p (const value_range &) const;\n   void set_and_canonicalize (enum value_range_kind, tree, tree, bitmap);\n   void dump (FILE *) const;\n   void dump () const;\n \n-  enum value_range_kind kind () const;\n-  tree min () const;\n-  tree max () const;\n-\n  private:\n   void set (value_range_kind, tree, tree, bitmap);\n+  void set_equiv (bitmap);\n   void check ();\n   bool equal_p (const value_range &, bool ignore_equivs) const;\n   void intersect_helper (value_range *, const value_range *);\n   void union_helper (value_range *, const value_range *);\n \n-  enum value_range_kind m_kind;\n- public:\n-  /* These should be private, but GTY is a piece of crap.  */\n-  tree m_min;\n-  tree m_max;\n   /* Set of SSA names whose value ranges are equivalent to this one.\n      This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n   bitmap m_equiv;\n };\n \n inline\n-value_range::value_range ()\n+value_range_base::value_range_base ()\n {\n   m_kind = VR_UNDEFINED;\n   m_min = m_max = NULL;\n+}\n+\n+inline\n+value_range::value_range ()\n+  : value_range_base ()\n+{\n   m_equiv = NULL;\n }\n \n /* Return the kind of this range.  */\n \n inline value_range_kind\n-value_range::kind () const\n+value_range_base::kind () const\n {\n   return m_kind;\n }\n@@ -118,31 +162,31 @@ value_range::equiv () const\n /* Return the lower bound.  */\n \n inline tree\n-value_range::min () const\n+value_range_base::min () const\n {\n   return m_min;\n }\n \n /* Return the upper bound.  */\n \n inline tree\n-value_range::max () const\n+value_range_base::max () const\n {\n   return m_max;\n }\n \n /* Return TRUE if range spans the entire possible domain.  */\n \n inline bool\n-value_range::varying_p () const\n+value_range_base::varying_p () const\n {\n   return m_kind == VR_VARYING;\n }\n \n /* Return TRUE if range is undefined (essentially the empty set).  */\n \n inline bool\n-value_range::undefined_p () const\n+value_range_base::undefined_p () const\n {\n   return m_kind == VR_UNDEFINED;\n }\n@@ -158,6 +202,7 @@ value_range::zero_p () const\n }\n \n extern void dump_value_range (FILE *, const value_range *);\n+extern void dump_value_range_base (FILE *, const value_range_base *);\n extern void extract_range_from_unary_expr (value_range *vr,\n \t\t\t\t\t   enum tree_code code,\n \t\t\t\t\t   tree type,\n@@ -187,7 +232,7 @@ extern void register_edge_assert_for (tree, edge, enum tree_code,\n \t\t\t\t      tree, tree, vec<assert_info> &);\n extern bool stmt_interesting_for_vrp (gimple *);\n extern void set_value_range_to_varying (value_range *);\n-extern bool range_includes_zero_p (const value_range *);\n+extern bool range_includes_zero_p (const value_range_base *);\n extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n \n extern void set_value_range_to_nonnull (value_range *, tree);"}]}