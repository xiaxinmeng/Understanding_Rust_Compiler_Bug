{"sha": "a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhMGZjN2Y4OTRiZDliODJjMjNjNzhmNWExZmJkYWU4YmMzYzA0Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-28T08:50:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-28T08:50:56Z"}, "message": "class.c (VTT_TOP_LEVEL_P, [...]): Remove.\n\n\t* class.c (VTT_TOP_LEVEL_P, VTT_MARKED_BINFO_P): Remove.\n\t(struct secondary_vptr_vtt_init_data_s): New.\n\t(build_vtt_inits): Adjust dfs_walkers.\n\t(dfs_build_secondary_vptr_vtt_inits): Caller data is a\n\tsecondary_vptr_vtt_init_data_s structure. Adjust.\n\t(dfs_ctor_vtable_bases_queue_p): Remove.\n\t(dfs_fixup_binfo_vtbls): No need to clear BINFO_MARKED. Simplify.\n\n\t* pt.c (struct get_template_base_data_s): Remove.\n\t(get_template_base_r): Fold into get_template_base.\n\t(get_template_base): Walk base binfos directly in inheritance\n\tgraph order.\nRemove duplicated changelog entries\n\nFrom-SVN: r88224", "tree": {"sha": "91b25be80d108aa01487236145f04a9b3f39168a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91b25be80d108aa01487236145f04a9b3f39168a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/comments", "author": null, "committer": null, "parents": [{"sha": "628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628f6a4e7c8e168256fe257a0dfc5f4fddda900a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628f6a4e7c8e168256fe257a0dfc5f4fddda900a"}], "stats": {"total": 298, "additions": 107, "deletions": 191}, "files": [{"sha": "05e6fc2e0f6edacaa61ce17eea672572171756bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "patch": "@@ -1,3 +1,18 @@\n+2004-09-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (VTT_TOP_LEVEL_P, VTT_MARKED_BINFO_P): Remove.\n+\t(struct secondary_vptr_vtt_init_data_s): New.\n+\t(build_vtt_inits): Adjust dfs_walkers.\n+\t(dfs_build_secondary_vptr_vtt_inits): Caller data is a\n+\tsecondary_vptr_vtt_init_data_s structure. Adjust.\n+\t(dfs_ctor_vtable_bases_queue_p): Remove.\n+\t(dfs_fixup_binfo_vtbls): No need to clear BINFO_MARKED. Simplify.\n+\n+\t* pt.c (struct get_template_base_data_s): Remove.\n+\t(get_template_base_r): Fold into get_template_base.\n+\t(get_template_base): Walk base binfos directly in inheritance\n+\tgraph order.\n+\n 2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/17642\n@@ -29,7 +44,7 @@\n \n 2004-09-27  Matt Austern  <austern@apple.com>\n \n-\t* cp/parser.c (struct cp_token): new one-bit field , implicit_extern_c\n+\t* cp/parser.c (struct cp_token): New one-bit field , implicit_extern_c\n \t(cp_lexer_get_preprocessor_token): Set implicit_extern_c for\n \ttokens that come from headers that are implicitly extern \"C\".\n \t(struct cp_parser): new one-bit field, implicit_extern_c.\n@@ -73,40 +88,6 @@\n \treturn NULL on failure.\n \t(unify): Remove error_mark_node check from get_template_base result.\n \n-2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n-\n-\tPR c++/17585\n-\t* cp-tree.h (shared_member_p): Declare.\n-\t* search.c (shared_member_p): Give it external linkage.\n-\t* semantics.c (finish_qualified_id_expr): Use it.\n-\t(finish_id_expression): Likewise.\n-\n-\tPR c++/17585\n-\t* semantics.c (finish_id_expression): Do not add \"this->\" to\n-\tstatic member functions.\n-\n-2004-09-27  Nathan Sidwell  <nathan@codesourcery.com>\n-\n-\tPR c++/17681\n-\t* error.c (dump_type): Change TREE_VEC case into TREE_BINFO.\n-\n-\t* class.c (struct count_depth_data): Remove.\n-\t(dfs_depth_post, dfs_depth_q): Remove.\n-\t(find_final_overrider): Use number of vbase classes as depth\n-\tbound.\n-\t\n-\t* cp-tree.h (types_overlap_p): Remove.\n-\t* search.c (struct overlap_info): Remove.\n-\t(dfs_check_overlap, dfs_no_overlap_yet, types_overlap_p): Remove.\n-\t\n-\t* pt.c (GTB_VIA_VIRTUAL, GTB_IGNORE_TYPE): Remove.\n-\t(get_template_base_recursive): Remove. Replace with ...\n-\t(get_template_base_r): ... this.\n-\t(struct get_template_base_data_s): New.\n-\t(get_template_base): Use get_template_base_r via dfs_walk.  Always\n-\treturn NULL on failure.\n-\t(unify): Remove error_mark_node check from get_template_base result.\n-\n 2004-09-24  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* parser.c (cp_parser_expression_stack): Clarify why it is"}, {"sha": "deff57311674fc5076927c2277b56ba45b11a3da", "filename": "gcc/cp/class.c", "status": "modified", "additions": 67, "deletions": 98, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "patch": "@@ -188,7 +188,6 @@ static void build_vtt (tree);\n static tree binfo_ctor_vtable (tree);\n static tree *build_vtt_inits (tree, tree, tree *, tree *);\n static tree dfs_build_secondary_vptr_vtt_inits (tree, void *);\n-static tree dfs_ctor_vtable_bases_queue_p (tree, int, void *data);\n static tree dfs_fixup_binfo_vtbls (tree, void *);\n static int record_subobject_offset (tree, tree, splay_tree);\n static int check_subobject_offset (tree, tree, splay_tree);\n@@ -206,12 +205,6 @@ static int empty_base_at_nonzero_offset_p (tree, tree, splay_tree);\n static tree end_of_base (tree);\n static tree get_vcall_index (tree, tree);\n \n-/* Macros for dfs walking during vtt construction. See\n-   dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n-   and dfs_fixup_binfo_vtbls.  */\n-#define VTT_TOP_LEVEL_P(NODE) (TREE_LIST_CHECK (NODE)->common.unsigned_flag)\n-#define VTT_MARKED_BINFO_P(NODE) TREE_USED (NODE)\n-\n /* Variables shared between class.c and call.c.  */\n \n #ifdef GATHER_STATISTICS\n@@ -6716,6 +6709,22 @@ binfo_ctor_vtable (tree binfo)\n   return vt;\n }\n \n+/* Data for secondary VTT initialization.  */\n+typedef struct secondary_vptr_vtt_init_data_s\n+{\n+  /* Is this the primary VTT? */\n+  bool top_level_p;\n+\n+  /* Current index into the VTT.  */\n+  tree index;\n+\n+  /* TREE_LIST of initializers built up.  */\n+  tree inits;\n+\n+  /* The type being constructed by this secondary VTT.  */\n+  tree type_being_constructed;\n+} secondary_vptr_vtt_init_data;\n+\n /* Recursively build the VTT-initializer for BINFO (which is in the\n    hierarchy dominated by T).  INITS points to the end of the initializer\n    list to date.  INDEX is the VTT index where the next element will be\n@@ -6725,12 +6734,13 @@ binfo_ctor_vtable (tree binfo)\n    vtables for the BINFO-in-T variant.  */\n \n static tree *\n-build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n+build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n {\n   int i;\n   tree b;\n   tree init;\n   tree secondary_vptrs;\n+  secondary_vptr_vtt_init_data data;\n   int top_level_p = same_type_p (TREE_TYPE (binfo), t);\n \n   /* We only need VTTs for subobjects with virtual bases.  */\n@@ -6766,157 +6776,116 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or reachable along a virtual path, except\n      subobjects that are non-virtual primary bases.  */\n-  secondary_vptrs = tree_cons (t, NULL_TREE, BINFO_TYPE (binfo));\n-  TREE_TYPE (secondary_vptrs) = *index;\n-  VTT_TOP_LEVEL_P (secondary_vptrs) = top_level_p;\n-  VTT_MARKED_BINFO_P (secondary_vptrs) = 0;\n+  data.top_level_p = top_level_p;\n+  data.index = *index;\n+  data.inits = NULL;\n+  data.type_being_constructed = BINFO_TYPE (binfo);\n   \n-  dfs_walk_real (binfo,\n-\t\t dfs_build_secondary_vptr_vtt_inits,\n-\t\t NULL,\n-\t         dfs_ctor_vtable_bases_queue_p,\n-\t\t secondary_vptrs);\n-  VTT_MARKED_BINFO_P (secondary_vptrs) = 1;\n-  dfs_walk (binfo, dfs_unmark, dfs_ctor_vtable_bases_queue_p,\n-            secondary_vptrs);\n+  dfs_walk_real (binfo, dfs_build_secondary_vptr_vtt_inits,\n+\t\t NULL, unmarkedp, &data);\n+  dfs_walk (binfo, dfs_unmark, markedp, 0);\n \n-  *index = TREE_TYPE (secondary_vptrs);\n+  *index = data.index;\n \n   /* The secondary vptrs come back in reverse order.  After we reverse\n      them, and add the INITS, the last init will be the first element\n      of the chain.  */\n-  secondary_vptrs = TREE_VALUE (secondary_vptrs);\n+  secondary_vptrs = data.inits;\n   if (secondary_vptrs)\n     {\n       *inits = nreverse (secondary_vptrs);\n       inits = &TREE_CHAIN (secondary_vptrs);\n       gcc_assert (*inits == NULL_TREE);\n     }\n \n-  /* Add the secondary VTTs for virtual bases.  */\n   if (top_level_p)\n+    /* Add the secondary VTTs for virtual bases in inheritance graph\n+       order.  */\n     for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n       {\n \tif (!BINFO_VIRTUAL_P (b))\n \t  continue;\n \t\n \tinits = build_vtt_inits (b, t, inits, index);\n       }\n-\n-  if (!top_level_p)\n-    {\n-      tree data = tree_cons (t, binfo, NULL_TREE);\n-      VTT_TOP_LEVEL_P (data) = 0;\n-      VTT_MARKED_BINFO_P (data) = 0;\n-      \n-      dfs_walk (binfo, dfs_fixup_binfo_vtbls,\n-\t        dfs_ctor_vtable_bases_queue_p,\n-\t        data);\n-    }\n+  else\n+    /* Remove the ctor vtables we created.  */\n+    dfs_walk (binfo, dfs_fixup_binfo_vtbls, 0, binfo);\n \n   return inits;\n }\n \n /* Called from build_vtt_inits via dfs_walk.  BINFO is the binfo for the base\n-   in most derived. DATA is a TREE_LIST who's TREE_CHAIN is the type of the\n-   base being constructed whilst this secondary vptr is live.  The\n-   TREE_TOP_LEVEL flag indicates that this is the primary VTT.  */\n+   in most derived. DATA is a SECONDARY_VPTR_VTT_INIT_DATA structure.  */\n \n static tree\n-dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data)\n+dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n {\n-  tree l; \n-  tree t;\n-  tree init;\n-  tree index;\n-  int top_level_p;\n+  secondary_vptr_vtt_init_data *data = (secondary_vptr_vtt_init_data *)data_;\n \n-  l = (tree) data;\n-  t = TREE_CHAIN (l);\n-  top_level_p = VTT_TOP_LEVEL_P (l);\n-  \n   BINFO_MARKED (binfo) = 1;\n \n   /* We don't care about bases that don't have vtables.  */\n   if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n     return NULL_TREE;\n \n-  /* We're only interested in proper subobjects of T.  */\n-  if (same_type_p (BINFO_TYPE (binfo), t))\n+  /* We're only interested in proper subobjects of the type being\n+     constructed.  */\n+  if (same_type_p (BINFO_TYPE (binfo), data->type_being_constructed))\n     return NULL_TREE;\n \n   /* We're not interested in non-virtual primary bases.  */\n   if (!BINFO_VIRTUAL_P (binfo) && BINFO_PRIMARY_P (binfo))\n     return NULL_TREE;\n \n-  /* If BINFO has virtual bases or is reachable via a virtual path\n-     from T, it'll have a secondary vptr.  */\n+  /* We're only interested in bases with virtual bases or reachable\n+     via a virtual path from the type being constructed.  */\n   if (!CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo))\n-      && !binfo_via_virtual (binfo, t))\n+      && !binfo_via_virtual (binfo, data->type_being_constructed))\n     return NULL_TREE;\n \n   /* Record the index where this secondary vptr can be found.  */\n-  index = TREE_TYPE (l);\n-  if (top_level_p)\n+  if (data->top_level_p)\n     {\n       gcc_assert (!BINFO_VPTR_INDEX (binfo));\n-      BINFO_VPTR_INDEX (binfo) = index;\n-    }\n-  TREE_TYPE (l) = size_binop (PLUS_EXPR, index, \n-\t\t\t      TYPE_SIZE_UNIT (ptr_type_node));\n+      BINFO_VPTR_INDEX (binfo) = data->index;\n \n-  /* Add the initializer for the secondary vptr itself.  */\n-  if (top_level_p && BINFO_VIRTUAL_P (binfo))\n-    {\n-      /* It's a primary virtual base, and this is not the construction\n-         vtable. Find the base this is primary of in the inheritance graph,\n-         and use that base's vtable now.  */\n-      while (BINFO_PRIMARY_P (binfo))\n-        binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+      if (BINFO_VIRTUAL_P (binfo))\n+\t{\n+          /* It's a primary virtual base, and this is not a\n+             construction vtable.  Find the base this is primary of in\n+             the inheritance graph, and use that base's vtable\n+             now.  */\n+\t  while (BINFO_PRIMARY_P (binfo))\n+\t    binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+\t}\n     }\n-  init = binfo_ctor_vtable (binfo);\n-  TREE_VALUE (l) = tree_cons (NULL_TREE, init, TREE_VALUE (l));\n-\n-  return NULL_TREE;\n-}\n+  \n+  /* Add the initializer for the secondary vptr itself.  */\n+  data->inits = tree_cons (NULL_TREE, binfo_ctor_vtable (binfo), data->inits);\n \n-/* dfs_walk_real predicate for building vtables. DATA is a TREE_LIST,\n-   VTT_MARKED_BINFO_P indicates whether marked or unmarked bases\n-   should be walked.  TREE_PURPOSE is the TREE_TYPE that dominates the\n-   hierarchy.  */\n+  /* Advance the vtt index.  */\n+  data->index = size_binop (PLUS_EXPR, data->index,\n+\t\t\t    TYPE_SIZE_UNIT (ptr_type_node));\n \n-static tree\n-dfs_ctor_vtable_bases_queue_p (tree derived, int ix,\n-\t\t\t       void* data)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  if (!BINFO_MARKED (binfo) == VTT_MARKED_BINFO_P ((tree) data))\n-    return NULL_TREE;\n-  return binfo;\n+  return NULL_TREE;\n }\n \n-/* Called from build_vtt_inits via dfs_walk. After building constructor\n-   vtables and generating the sub-vtt from them, we need to restore the\n-   BINFO_VTABLES that were scribbled on.  DATA is a TREE_LIST whose\n-   TREE_VALUE is the TREE_TYPE of the base whose sub vtt was generated.  */\n+/* Called from build_vtt_inits via dfs_walk. After building\n+   constructor vtables and generating the sub-vtt from them, we need\n+   to restore the BINFO_VTABLES that were scribbled on.  DATA is the\n+   binfo of the base whose sub vtt was generated.  */\n \n static tree\n dfs_fixup_binfo_vtbls (tree binfo, void* data)\n {\n-  BINFO_MARKED (binfo) = 0;\n-\n-  /* We don't care about bases that don't have vtables.  */\n-  if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n-    return NULL_TREE;\n+  tree vtable = BINFO_VTABLE (binfo);\n \n   /* If we scribbled the construction vtable vptr into BINFO, clear it\n      out now.  */\n-  if (BINFO_VTABLE (binfo)\n-      && TREE_CODE (BINFO_VTABLE (binfo)) == TREE_LIST\n-      && (TREE_PURPOSE (BINFO_VTABLE (binfo)) \n-\t  == TREE_VALUE ((tree) data)))\n-    BINFO_VTABLE (binfo) = TREE_CHAIN (BINFO_VTABLE (binfo));\n+  if (vtable && TREE_CODE (vtable) == TREE_LIST\n+      && (TREE_PURPOSE (vtable) == (tree) data))\n+    BINFO_VTABLE (binfo) = TREE_CHAIN (vtable);\n \n   return NULL_TREE;\n }"}, {"sha": "ebf98cb360c2de4246b8bcac3c02a88d7c9ed296", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 24, "deletions": 58, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a3a0fc7f894bd9b82c23c78f5a1fbdae8bc3c04f", "patch": "@@ -148,7 +148,6 @@ static tree process_partial_specialization (tree);\n static void set_current_access_from_decl (tree);\n static void check_default_tmpl_args (tree, tree, int, int);\n static tree tsubst_call_declarator_parms (tree, tree, tsubst_flags_t, tree);\n-static tree get_template_base_r (tree, void *);\n static tree get_template_base (tree, tree, tree, tree);\n static int verify_class_unification (tree, tree, tree);\n static tree try_class_unification (tree, tree, tree, tree);\n@@ -9475,30 +9474,31 @@ try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n   return arg;\n }\n \n-typedef struct get_template_base_data_s \n-{\n-  /* Parameters for unification.  */\n-  tree tparms;\n-  tree targs;\n-  tree parm;\n-  /* Base we've found to be satisfactory.  */\n-  tree rval;\n-} get_template_base_data;\n-\n-/* Called from get_template_base via dfs_walk.  */\n+/* Given a template type PARM and a class type ARG, find the unique\n+   base type in ARG that is an instance of PARM.  We do not examine\n+   ARG itself; only its base-classes.  If there is not exactly one\n+   appropriate base class, return NULL_TREE.  PARM may be the type of\n+   a partial specialization, as well as a plain template type.  Used\n+   by unify.  */\n \n static tree\n-get_template_base_r (tree arg_binfo,\n-\t\t     void *data_)\n+get_template_base (tree tparms, tree targs, tree parm, tree arg)\n {\n-  get_template_base_data *data = data_;\n+  tree rval = NULL_TREE;\n+  tree binfo;\n \n-  /* Do not look at the most derived binfo -- that's not a proper\n-     base.  */\n-  if (BINFO_INHERITANCE_CHAIN (arg_binfo))\n+  gcc_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)));\n+  \n+  binfo = TYPE_BINFO (complete_type (arg));\n+  if (!binfo)\n+    /* The type could not be completed.  */\n+    return NULL_TREE;\n+\n+  /* Walk in inheritance graph order.  The search order is not\n+     important, and this avoids multiple walks of virtual bases.  */\n+  for (binfo = TREE_CHAIN (binfo); binfo; binfo = TREE_CHAIN (binfo))\n     {\n-      tree r = try_class_unification (data->tparms, data->targs,\n-\t\t\t\t      data->parm, BINFO_TYPE (arg_binfo));\n+      tree r = try_class_unification (tparms, targs, parm, BINFO_TYPE (binfo));\n \n       if (r)\n \t{\n@@ -9510,48 +9510,14 @@ get_template_base_r (tree arg_binfo,\n \t      deduction fails.\n \n \t     applies.  */\n-\t  if (data->rval && !same_type_p (r, data->rval))\n-\t    {\n-\t      data->rval = NULL_TREE;\n-\t      /* Terminate the walk with any non-NULL value.  */\n-\t      return r;\n-\t    }\n+\t  if (rval && !same_type_p (r, rval))\n+\t    return NULL_TREE;\n \t  \n-\t  data->rval = r;\n+\t  rval = r;\n \t}\n     }\n \n-  return NULL_TREE;\n-}\n-\n-/* Given a template type PARM and a class type ARG, find the unique\n-   base type in ARG that is an instance of PARM.  We do not examine\n-   ARG itself; only its base-classes.  If there is no appropriate base\n-   class, return NULL_TREE.  If there is more than one, return\n-   error_mark_node.  PARM may be the type of a partial specialization,\n-   as well as a plain template type.  Used by unify.  */\n-\n-static tree\n-get_template_base (tree tparms, tree targs, tree parm, tree arg)\n-{\n-  get_template_base_data data;\n-  tree arg_binfo;\n-\n-  gcc_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)));\n-  \n-  arg_binfo = TYPE_BINFO (complete_type (arg));\n-  if (!arg_binfo)\n-    /* The type could not be completed.  */\n-    return NULL_TREE;\n-\n-  data.tparms = tparms;\n-  data.targs = targs;\n-  data.parm = parm;\n-  data.rval = NULL_TREE;\n-\n-  dfs_walk_real (arg_binfo, get_template_base_r, 0, 0, &data);\n-\n-  return data.rval;\n+  return rval;\n }\n \n /* Returns the level of DECL, which declares a template parameter.  */"}]}