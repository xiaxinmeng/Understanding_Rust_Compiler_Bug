{"sha": "b99353a2aadd2de47694db415005ab137dd33959", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk5MzUzYTJhYWRkMmRlNDc2OTRkYjQxNTAwNWFiMTM3ZGQzMzk1OQ==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-04-08T08:12:19Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-04-08T08:12:19Z"}, "message": "[NDS32] Implment n9 pipeline.\n\ngcc/\n\t* config.gcc (nds32*): Add nds32-utils.o into extra_objs.\n\t* config/nds32/nds32-n9-2r1w.md: New file.\n\t* config/nds32/nds32-n9-3r2w.md: New file.\n\t* config/nds32/nds32-opts.h (nds32_cpu_type, nds32_mul_type,\n\tnds32_register_ports): New or modify for cpu n9.\n\t* config/nds32/nds32-pipelines-auxiliary.c: Implementation for n9\n\tpipeline.\n\t* config/nds32/nds32-protos.h: More declarations for n9 pipeline.\n\t* config/nds32/nds32-utils.c: New file.\n\t* config/nds32/nds32.h (TARGET_PIPELINE_N9, TARGET_PIPELINE_SIMPLE,\n\tTARGET_MUL_SLOW): Define.\n\t* config/nds32/nds32.md (pipeline_model): New attribute.\n\t* config/nds32/nds32.opt (mcpu, mconfig-mul, mconfig-register-ports):\n\tNew options that support cpu n9.\n\t* config/nds32/pipelines.md: Include n9 settings.\n\t* config/nds32/t-nds32 (nds32-utils.o): Add dependency.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r259218", "tree": {"sha": "a96fdbd7a974618c0e813cce02dde0a15eb07760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a96fdbd7a974618c0e813cce02dde0a15eb07760"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b99353a2aadd2de47694db415005ab137dd33959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99353a2aadd2de47694db415005ab137dd33959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99353a2aadd2de47694db415005ab137dd33959", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99353a2aadd2de47694db415005ab137dd33959/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43fa41c1aaa57d59cbb00ed5c8cfa185d075b105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43fa41c1aaa57d59cbb00ed5c8cfa185d075b105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43fa41c1aaa57d59cbb00ed5c8cfa185d075b105"}], "stats": {"total": 1881, "additions": 1871, "deletions": 10}, "files": [{"sha": "96a858483ee693fe648e598a388db1cef0eaa4bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -1,3 +1,23 @@\n+2018-04-08  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config.gcc (nds32*): Add nds32-utils.o into extra_objs.\n+\t* config/nds32/nds32-n9-2r1w.md: New file.\n+\t* config/nds32/nds32-n9-3r2w.md: New file.\n+\t* config/nds32/nds32-opts.h (nds32_cpu_type, nds32_mul_type,\n+\tnds32_register_ports): New or modify for cpu n9.\n+\t* config/nds32/nds32-pipelines-auxiliary.c: Implementation for n9\n+\tpipeline.\n+\t* config/nds32/nds32-protos.h: More declarations for n9 pipeline.\n+\t* config/nds32/nds32-utils.c: New file.\n+\t* config/nds32/nds32.h (TARGET_PIPELINE_N9, TARGET_PIPELINE_SIMPLE,\n+\tTARGET_MUL_SLOW): Define.\n+\t* config/nds32/nds32.md (pipeline_model): New attribute.\n+\t* config/nds32/nds32.opt (mcpu, mconfig-mul, mconfig-register-ports):\n+\tNew options that support cpu n9.\n+\t* config/nds32/pipelines.md: Include n9 settings.\n+\t* config/nds32/t-nds32 (nds32-utils.o): Add dependency.\n+\n 2018-04-08  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32-md-auxiliary.c (output_cond_branch): Output align"}, {"sha": "fa15a8c6590220191addbecb6db13d202385757d", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -445,7 +445,7 @@ mips*-*-*)\n nds32*)\n \tcpu_type=nds32\n \textra_headers=\"nds32_intrinsic.h\"\n-\textra_objs=\"nds32-cost.o nds32-intrinsic.o nds32-isr.o nds32-md-auxiliary.o nds32-pipelines-auxiliary.o nds32-predicates.o nds32-memory-manipulation.o nds32-fp-as-gp.o nds32-relax-opt.o\"\n+\textra_objs=\"nds32-cost.o nds32-intrinsic.o nds32-isr.o nds32-md-auxiliary.o nds32-pipelines-auxiliary.o nds32-predicates.o nds32-memory-manipulation.o nds32-fp-as-gp.o nds32-relax-opt.o nds32-utils.o\"\n \t;;\n nios2-*-*)\n \tcpu_type=nios2"}, {"sha": "b742e5545e40af7468cfc6e0eb9a68e8b31450d6", "filename": "gcc/config/nds32/nds32-n9-2r1w.md", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-n9-2r1w.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-n9-2r1w.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-n9-2r1w.md?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -0,0 +1,362 @@\n+;; Pipeline descriptions of Andes NDS32 cpu for GNU compiler\n+;; Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+;; Contributed by Andes Technology Corporation.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+;; ------------------------------------------------------------------------\n+;; Define N9 2R1W pipeline settings.\n+;; ------------------------------------------------------------------------\n+\n+(define_automaton \"nds32_n9_2r1w_machine\")\n+\n+;; ------------------------------------------------------------------------\n+;; Pipeline Stages\n+;; ------------------------------------------------------------------------\n+;; IF - Instruction Fetch\n+;; II - Instruction Issue / Instruction Decode\n+;; EX - Instruction Execution\n+;; MM - Memory Execution\n+;; WB - Instruction Retire / Result Write-Back\n+\n+(define_cpu_unit \"n9_2r1w_ii\" \"nds32_n9_2r1w_machine\")\n+(define_cpu_unit \"n9_2r1w_ex\" \"nds32_n9_2r1w_machine\")\n+(define_cpu_unit \"n9_2r1w_mm\" \"nds32_n9_2r1w_machine\")\n+(define_cpu_unit \"n9_2r1w_wb\" \"nds32_n9_2r1w_machine\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_unknown\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"unknown\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_misc\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"misc\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_mmu\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"mmu\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_alu\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"alu\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_alu_shift\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"alu_shift\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_pbsad\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"pbsad\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex*3, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_pbsada\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"pbsada\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex*3, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (match_test \"nds32::load_single_p (insn)\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (match_test \"nds32::store_single_p (insn)\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_1\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"1\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_2\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (ior (and (eq_attr \"type\" \"load_multiple\")\n+\t\t      (eq_attr \"combo\" \"2\"))\n+\t\t (match_test \"nds32::load_double_p (insn)\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_3\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"3\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_4\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"4\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_5\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"5\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*2, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_6\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"6\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*3, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_7\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"7\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*4, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_8\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"8\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*5, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_load_multiple_12\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"12\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*9, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_1\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"1\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_2\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (ior (and (eq_attr \"type\" \"store_multiple\")\n+\t\t      (eq_attr \"combo\" \"2\"))\n+\t\t (match_test \"nds32::store_double_p (insn)\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_3\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"3\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_4\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"4\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_5\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"5\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*2, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_6\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"6\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*3, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_7\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"7\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*4, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_8\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"8\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*5, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_store_multiple_12\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"12\"))))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm, (n9_2r1w_ii+n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb)*9, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_mul_fast\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W && nds32_mul_config != MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_mul_slow\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W && nds32_mul_config == MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex*17, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_mac_fast\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W && nds32_mul_config != MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ii+n9_2r1w_ex, n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_mac_slow\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W && nds32_mul_config == MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, (n9_2r1w_ii+n9_2r1w_ex)*17, n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_ex+n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_div\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"div\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, (n9_2r1w_ii+n9_2r1w_ex)*34, n9_2r1w_ex+n9_2r1w_mm, n9_2r1w_mm+n9_2r1w_wb, n9_2r1w_wb\")\n+\n+(define_insn_reservation \"nds_n9_2r1w_branch\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_2R1W\")\n+       (and (eq_attr \"type\" \"branch\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_2r1w_ii, n9_2r1w_ex, n9_2r1w_mm, n9_2r1w_wb\")\n+\n+;; ------------------------------------------------------------------------\n+;; Comment Notations and Bypass Rules\n+;; ------------------------------------------------------------------------\n+;; Producers (LHS)\n+;;   LD_!bi\n+;;     Load data from the memory (without updating the base register) and\n+;;     produce the loaded data. The result is ready at MM. Because the register\n+;;     port is 2R1W, two micro-operations are required if the base register\n+;;     should be updated. In this case, the base register is updated by the\n+;;     second micro-operation, and the updated result is ready at EX.\n+;;   LMW(N, M)\n+;;     There are N micro-operations within an instruction that loads multiple\n+;;     words. The result produced by the M-th micro-operation is sent to\n+;;     consumers. The result is ready at MM.  If the base register should be\n+;;     updated, an extra micro-operation is apppended to the end of the\n+;;     sequence, and the result is ready at EX.\n+;;   MUL, MAC\n+;;     Compute data in the multiply-adder and produce the data. The result\n+;;     is ready at MM.\n+;;   DIV\n+;;     Compute data in the divider and produce the data. The result is ready\n+;;     at MM.\n+;;\n+;; Consumers (RHS)\n+;;   ALU, PBSAD, PBSADA_RaRb, MUL, MAC, DIV, MMU\n+;;     Require operands at EX.\n+;;   ALU_SHIFT_Rb\n+;;     An ALU-SHIFT instruction consists of a shift micro-operation followed\n+;;     by an arithmetic micro-operation. The operand Rb is used by the first\n+;;     micro-operation, and there are some latencies if data dependency occurs.\n+;;   MOVD44_E\n+;;     A double-word move instruction needs two micro-operations because the\n+;;     reigster ports is 2R1W. The first micro-operation writes an even number\n+;;     register, and the second micro-operation writes an odd number register.\n+;;     Each input operand is required at EX for each micro-operation. MOVD44_E\n+;;     stands for the first micro-operation.\n+;;   MAC_RaRb, M2R\n+;;     MAC instructions do multiplication at EX and do accumulation at MM, but\n+;;     MAC instructions which operate on general purpose registers always\n+;;     require operands at EX because MM stage cannot be forwarded in 2R1W mode.\n+;;   ADDR_IN\n+;;     If an instruction requires an address as its input operand, the address\n+;;     is required at EX.\n+;;   ST_bi\n+;;     A post-increment store instruction requires its data at EX because MM\n+;;     cannot be forwarded in 2R1W mode.\n+;;   ST_!bi_RI\n+;;     A store instruction with an immediate offset requires its data at EX\n+;;     because MM cannot be forwarded in 2R1W mode. If the offset field is a\n+;;     register (ST_!bi_RR), the instruction will be separated into two micro-\n+;;     operations, and the second one requires the input operand at EX in order\n+;;     to store it to the memory.\n+;;   SMW(N, M)\n+;;     There are N micro-operations within an instruction that stores multiple\n+;;     words. Each M-th micro-operation requires its data at MM.\n+;;   BR\n+;;     If a branch instruction is conditional, its input data is required at EX.\n+\n+;; LD_!bi, MUL, MAC\n+;;   -> ALU, ALU_SHIFT_Rb, PBSAD, PBSADA_RaRb, MOVD44_E, MUL, MAC_RaRb, M2R, DIV, ADDR_IN_!bi, ADDR_IN_bi_Ra, ST_bi, ST_!bi_RI, BR, MMU\n+(define_bypass 2\n+  \"nds_n9_2r1w_load,\\\n+   nds_n9_2r1w_mul_fast, nds_n9_2r1w_mul_slow,\\\n+   nds_n9_2r1w_mac_fast, nds_n9_2r1w_mac_slow\"\n+  \"nds_n9_2r1w_alu, nds_n9_2r1w_alu_shift,\\\n+   nds_n9_2r1w_pbsad, nds_n9_2r1w_pbsada,\\\n+   nds_n9_2r1w_mul_fast, nds_n9_2r1w_mul_slow,\\\n+   nds_n9_2r1w_mac_fast, nds_n9_2r1w_mac_slow,\\\n+   nds_n9_2r1w_branch,\\\n+   nds_n9_2r1w_div,\\\n+   nds_n9_2r1w_load,nds_n9_2r1w_store,\\\n+   nds_n9_2r1w_load_multiple_1,nds_n9_2r1w_load_multiple_2, nds_n9_2r1w_load_multiple_3,\\\n+   nds_n9_2r1w_load_multiple_4,nds_n9_2r1w_load_multiple_5, nds_n9_2r1w_load_multiple_6,\\\n+   nds_n9_2r1w_load_multiple_7,nds_n9_2r1w_load_multiple_8, nds_n9_2r1w_load_multiple_12,\\\n+   nds_n9_2r1w_store_multiple_1,nds_n9_2r1w_store_multiple_2, nds_n9_2r1w_store_multiple_3,\\\n+   nds_n9_2r1w_store_multiple_4,nds_n9_2r1w_store_multiple_5, nds_n9_2r1w_store_multiple_6,\\\n+   nds_n9_2r1w_store_multiple_7,nds_n9_2r1w_store_multiple_8, nds_n9_2r1w_store_multiple_12,\\\n+   nds_n9_2r1w_mmu\"\n+  \"nds32_n9_2r1w_mm_to_ex_p\"\n+)\n+\n+;; LMW(N, N)\n+;;   -> ALU, ALU_SHIFT_Rb, PBSAD, PBSADA_RaRb, MOVD44_E, MUL, MAC_RaRb, M2R, DIV, ADDR_IN_!bi, ADDR_IN_bi_Ra, ST_bi, ST_!bi_RI, BR, MMU\n+(define_bypass 2\n+  \"nds_n9_2r1w_load_multiple_1,nds_n9_2r1w_load_multiple_2, nds_n9_2r1w_load_multiple_3,\\\n+   nds_n9_2r1w_load_multiple_4,nds_n9_2r1w_load_multiple_5, nds_n9_2r1w_load_multiple_6,\\\n+   nds_n9_2r1w_load_multiple_7,nds_n9_2r1w_load_multiple_8, nds_n9_2r1w_load_multiple_12\"\n+  \"nds_n9_2r1w_alu, nds_n9_2r1w_alu_shift,\\\n+   nds_n9_2r1w_pbsad, nds_n9_2r1w_pbsada,\\\n+   nds_n9_2r1w_mul_fast, nds_n9_2r1w_mul_slow,\\\n+   nds_n9_2r1w_mac_fast, nds_n9_2r1w_mac_slow,\\\n+   nds_n9_2r1w_branch,\\\n+   nds_n9_2r1w_div,\\\n+   nds_n9_2r1w_load,nds_n9_2r1w_store,\\\n+   nds_n9_2r1w_load_multiple_1,nds_n9_2r1w_load_multiple_2, nds_n9_2r1w_load_multiple_3,\\\n+   nds_n9_2r1w_load_multiple_4,nds_n9_2r1w_load_multiple_5, nds_n9_2r1w_load_multiple_6,\\\n+   nds_n9_2r1w_load_multiple_7,nds_n9_2r1w_load_multiple_8, nds_n9_2r1w_load_multiple_12,\\\n+   nds_n9_2r1w_store_multiple_1,nds_n9_2r1w_store_multiple_2, nds_n9_2r1w_store_multiple_3,\\\n+   nds_n9_2r1w_store_multiple_4,nds_n9_2r1w_store_multiple_5, nds_n9_2r1w_store_multiple_6,\\\n+   nds_n9_2r1w_store_multiple_7,nds_n9_2r1w_store_multiple_8, nds_n9_2r1w_store_multiple_12,\\\n+   nds_n9_2r1w_mmu\"\n+  \"nds32_n9_last_load_to_ex_p\"\n+)"}, {"sha": "8439cc6e36c5328eff6874adef9cb8c7cbb415ea", "filename": "gcc/config/nds32/nds32-n9-3r2w.md", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-n9-3r2w.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-n9-3r2w.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-n9-3r2w.md?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -0,0 +1,357 @@\n+;; Pipeline descriptions of Andes NDS32 cpu for GNU compiler\n+;; Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+;; Contributed by Andes Technology Corporation.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+;; ------------------------------------------------------------------------\n+;; Define N9 3R2W pipeline settings.\n+;; ------------------------------------------------------------------------\n+\n+(define_automaton \"nds32_n9_3r2w_machine\")\n+\n+;; ------------------------------------------------------------------------\n+;; Pipeline Stages\n+;; ------------------------------------------------------------------------\n+;; IF - Instruction Fetch\n+;; II - Instruction Issue / Instruction Decode\n+;; EX - Instruction Execution\n+;; MM - Memory Execution\n+;; WB - Instruction Retire / Result Write-Back\n+\n+(define_cpu_unit \"n9_3r2w_ii\" \"nds32_n9_3r2w_machine\")\n+(define_cpu_unit \"n9_3r2w_ex\" \"nds32_n9_3r2w_machine\")\n+(define_cpu_unit \"n9_3r2w_mm\" \"nds32_n9_3r2w_machine\")\n+(define_cpu_unit \"n9_3r2w_wb\" \"nds32_n9_3r2w_machine\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_unknown\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"unknown\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_misc\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"misc\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mmu\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"mmu\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_alu\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"alu\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_alu_shift\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"alu_shift\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_pbsad\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"pbsad\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*3, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_pbsada\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"pbsada\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*3, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (match_test \"nds32::load_single_p (insn)\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (match_test \"nds32::store_single_p (insn)\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_1\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"1\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_2\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (ior (and (eq_attr \"type\" \"load_multiple\")\n+\t\t      (eq_attr \"combo\" \"2\"))\n+\t\t (match_test \"nds32::load_double_p (insn)\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_3\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"3\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_4\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"4\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_5\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"5\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*2, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_6\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"6\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*3, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_7\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"7\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*4, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_8\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"8\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*5, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_load_multiple_12\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"12\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*9, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_1\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"1\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_2\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (ior (and (eq_attr \"type\" \"store_multiple\")\n+\t\t      (eq_attr \"combo\" \"2\"))\n+\t\t (match_test \"nds32::store_double_p (insn)\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_3\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"3\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_4\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"4\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_5\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"5\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*2, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_6\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"6\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*3, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_7\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"7\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*4, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_8\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"8\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*5, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_store_multiple_12\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"pipeline_model\" \"n9\")\n+\t    (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"12\"))))\n+  \"n9_3r2w_ii, n9_3r2w_ii+n9_3r2w_ex, n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm, (n9_3r2w_ii+n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb)*9, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_mm+n9_3r2w_wb, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mul_fast1\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W && nds32_mul_config == MUL_TYPE_FAST_1\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mul_fast2\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W && nds32_mul_config == MUL_TYPE_FAST_2\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*2, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mul_slow\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W && nds32_mul_config == MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*17, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mac_fast1\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W && nds32_mul_config == MUL_TYPE_FAST_1\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mac_fast2\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W && nds32_mul_config == MUL_TYPE_FAST_2\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*2, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_mac_slow\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W && nds32_mul_config == MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*17, n9_3r2w_ex+n9_3r2w_mm, n9_3r2w_ex+n9_3r2w_mm+n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_div\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"div\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex*34, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+(define_insn_reservation \"nds_n9_3r2w_branch\" 1\n+  (and (match_test \"nds32_register_ports_config == REG_PORT_3R2W\")\n+       (and (eq_attr \"type\" \"branch\")\n+\t    (eq_attr \"pipeline_model\" \"n9\")))\n+  \"n9_3r2w_ii, n9_3r2w_ex, n9_3r2w_mm, n9_3r2w_wb\")\n+\n+;; ------------------------------------------------------------------------\n+;; Comment Notations and Bypass Rules\n+;; ------------------------------------------------------------------------\n+;; Producers (LHS)\n+;;   LD\n+;;     Load data from the memory and produce the loaded data. The result is\n+;;     ready at MM.\n+;;   LMW(N, M)\n+;;     There are N micro-operations within an instruction that loads multiple\n+;;     words. The result produced by the M-th micro-operation is sent to\n+;;     consumers. The result is ready at MM.\n+;;   MUL, MAC\n+;;     Compute data in the multiply-adder and produce the data. The result\n+;;     is ready at MM.\n+;;   DIV\n+;;     Compute data in the divider and produce the data. The result is ready\n+;;     at MM.\n+;;\n+;; Consumers (RHS)\n+;;   ALU, MOVD44, PBSAD, PBSADA_RaRb, MUL, MAC, DIV, MMU\n+;;     Require operands at EX.\n+;;   ALU_SHIFT_Rb\n+;;     An ALU-SHIFT instruction consists of a shift micro-operation followed\n+;;     by an arithmetic micro-operation. The operand Rb is used by the first\n+;;     micro-operation, and there are some latencies if data dependency occurs.\n+;;   MAC_RaRb\n+;;     A MAC instruction does multiplication at EX and does accumulation at MM,\n+;;     so the operand Rt is required at MM, and operands Ra and Rb are required\n+;;     at EX.\n+;;   ADDR_IN\n+;;     If an instruction requires an address as its input operand, the address\n+;;     is required at EX.\n+;;   ST\n+;;     A store instruction requires its data at MM.\n+;;   SMW(N, M)\n+;;     There are N micro-operations within an instruction that stores multiple\n+;;     words. Each M-th micro-operation requires its data at MM.\n+;;   BR\n+;;     If a branch instruction is conditional, its input data is required at EX.\n+\n+;; LD, MUL, MAC, DIV\n+;;   -> ALU, ALU_SHIFT_Rb, PBSAD, PBSADA_RaRb, MOVD44, MUL, MAC_RaRb, DIV, ADDR_IN, BR, MMU\n+(define_bypass 2\n+  \"nds_n9_3r2w_load,\\\n+   nds_n9_3r2w_mul_fast1, nds_n9_3r2w_mul_fast2, nds_n9_3r2w_mul_slow,\\\n+   nds_n9_3r2w_mac_fast1, nds_n9_3r2w_mac_fast2, nds_n9_3r2w_mac_slow,\\\n+   nds_n9_3r2w_div\"\n+  \"nds_n9_3r2w_alu, nds_n9_3r2w_alu_shift,\\\n+   nds_n9_3r2w_pbsad, nds_n9_3r2w_pbsada,\\\n+   nds_n9_3r2w_mul_fast1, nds_n9_3r2w_mul_fast2, nds_n9_3r2w_mul_slow,\\\n+   nds_n9_3r2w_mac_fast1, nds_n9_3r2w_mac_fast2, nds_n9_3r2w_mac_slow,\\\n+   nds_n9_3r2w_branch,\\\n+   nds_n9_3r2w_div,\\\n+   nds_n9_3r2w_load,nds_n9_3r2w_store,\\\n+   nds_n9_3r2w_load_multiple_1,nds_n9_3r2w_load_multiple_2, nds_n9_3r2w_load_multiple_3,\\\n+   nds_n9_3r2w_load_multiple_4,nds_n9_3r2w_load_multiple_5, nds_n9_3r2w_load_multiple_6,\\\n+   nds_n9_3r2w_load_multiple_7,nds_n9_3r2w_load_multiple_8, nds_n9_3r2w_load_multiple_12,\\\n+   nds_n9_3r2w_store_multiple_1,nds_n9_3r2w_store_multiple_2, nds_n9_3r2w_store_multiple_3,\\\n+   nds_n9_3r2w_store_multiple_4,nds_n9_3r2w_store_multiple_5, nds_n9_3r2w_store_multiple_6,\\\n+   nds_n9_3r2w_store_multiple_7,nds_n9_3r2w_store_multiple_8, nds_n9_3r2w_store_multiple_12,\\\n+   nds_n9_3r2w_mmu\"\n+  \"nds32_n9_3r2w_mm_to_ex_p\"\n+)\n+\n+;; LMW(N, N)\n+;;   -> ALU, ALU_SHIFT_Rb, PBSAD, PBSADA_RaRb, MOVD44, MUL, MAC_RaRb, DIV, ADDR_IN, BR, MMU\n+(define_bypass 2\n+  \"nds_n9_3r2w_load_multiple_1,nds_n9_3r2w_load_multiple_2, nds_n9_3r2w_load_multiple_3,\\\n+   nds_n9_3r2w_load_multiple_4,nds_n9_3r2w_load_multiple_5, nds_n9_3r2w_load_multiple_6,\\\n+   nds_n9_3r2w_load_multiple_7,nds_n9_3r2w_load_multiple_8, nds_n9_3r2w_load_multiple_12\"\n+  \"nds_n9_3r2w_alu, nds_n9_3r2w_alu_shift,\\\n+   nds_n9_3r2w_pbsad, nds_n9_3r2w_pbsada,\\\n+   nds_n9_3r2w_mul_fast1, nds_n9_3r2w_mul_fast2, nds_n9_3r2w_mul_slow,\\\n+   nds_n9_3r2w_mac_fast1, nds_n9_3r2w_mac_fast2, nds_n9_3r2w_mac_slow,\\\n+   nds_n9_3r2w_branch,\\\n+   nds_n9_3r2w_div,\\\n+   nds_n9_3r2w_load,nds_n9_3r2w_store,\\\n+   nds_n9_3r2w_load_multiple_1,nds_n9_3r2w_load_multiple_2, nds_n9_3r2w_load_multiple_3,\\\n+   nds_n9_3r2w_load_multiple_4,nds_n9_3r2w_load_multiple_5, nds_n9_3r2w_load_multiple_6,\\\n+   nds_n9_3r2w_load_multiple_7,nds_n9_3r2w_load_multiple_8, nds_n9_3r2w_load_multiple_12,\\\n+   nds_n9_3r2w_store_multiple_1,nds_n9_3r2w_store_multiple_2, nds_n9_3r2w_store_multiple_3,\\\n+   nds_n9_3r2w_store_multiple_4,nds_n9_3r2w_store_multiple_5, nds_n9_3r2w_store_multiple_6,\\\n+   nds_n9_3r2w_store_multiple_7,nds_n9_3r2w_store_multiple_8, nds_n9_3r2w_store_multiple_12,\\\n+   nds_n9_3r2w_mmu\"\n+  \"nds32_n9_last_load_to_ex_p\"\n+)"}, {"sha": "fc8032338dbb552c7472c78aeae623ee11290b98", "filename": "gcc/config/nds32/nds32-opts.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -34,6 +34,13 @@ enum nds32_arch_type\n   ARCH_V3S\n };\n \n+/* The various ANDES CPU.  */\n+enum nds32_cpu_type\n+{\n+  CPU_N9,\n+  CPU_SIMPLE\n+};\n+\n /* The code model defines the address generation strategy.  */\n enum nds32_cmodel_type\n {\n@@ -42,10 +49,19 @@ enum nds32_cmodel_type\n   CMODEL_LARGE\n };\n \n-/* The various ANDES CPU.  */\n-enum nds32_cpu_type\n+/* Multiply instruction configuration.  */\n+enum nds32_mul_type\n+{\n+  MUL_TYPE_FAST_1,\n+  MUL_TYPE_FAST_2,\n+  MUL_TYPE_SLOW\n+};\n+\n+/* Register ports configuration.  */\n+enum nds32_register_ports\n {\n-  CPU_N9\n+  REG_PORT_3R2W,\n+  REG_PORT_2R1W\n };\n \n /* Which ABI to use.  */"}, {"sha": "c34b16855927b1a53f27a01412ce236f20739dc5", "filename": "gcc/config/nds32/nds32-pipelines-auxiliary.c", "status": "modified", "additions": 590, "deletions": 2, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-pipelines-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-pipelines-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-pipelines-auxiliary.c?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -27,10 +27,598 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"target.h\"\n+\n+#include \"nds32-protos.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+namespace nds32 {\n+namespace scheduling {\n+\n+/* Classify the memory access direction.  It's unknown if the offset register\n+   is not a constant value.  */\n+enum memory_access_direction\n+{\n+  MEM_ACCESS_DIR_POS,\n+  MEM_ACCESS_DIR_NEG,\n+  MEM_ACCESS_DIR_UNKNOWN\n+};\n+\n+/* A safe wrapper to the function reg_overlap_mentioned_p ().  */\n+bool\n+reg_overlap_p (rtx x, rtx in)\n+{\n+  if (x == NULL_RTX || in == NULL_RTX)\n+    return false;\n+\n+  return static_cast <bool> (reg_overlap_mentioned_p (x, in));\n+}\n+\n+\n+/* Determine the memory access direction of a load/store insn.  */\n+memory_access_direction\n+determine_access_direction (rtx_insn *insn)\n+{\n+  int post_update_rtx_index;\n+  rtx plus_rtx;\n+  rtx mem_rtx;\n+  rtx offset_rtx;\n+\n+  switch (get_attr_type (insn))\n+  {\n+  case TYPE_LOAD_MULTIPLE:\n+    gcc_assert (parallel_elements (insn) >= 2);\n+\n+    post_update_rtx_index = find_post_update_rtx (insn);\n+    if (post_update_rtx_index != -1)\n+      plus_rtx = SET_SRC (parallel_element (insn, post_update_rtx_index));\n+    else\n+      {\n+\t/* (parallel\n+\t     [(set (reg) (mem (reg)))              : index 0\n+\t      (set (reg) (mem (plus (reg) (...)))) : index 1\n+\t      ...])  */\n+\tmem_rtx = SET_SRC (parallel_element (insn, 1));\n+\tif (GET_CODE (mem_rtx) == UNSPEC)\n+\t  mem_rtx = XVECEXP (mem_rtx, 0, 0);\n+\tgcc_assert (MEM_P (mem_rtx));\n+\tplus_rtx = XEXP (mem_rtx, 0);\n+      }\n+    break;\n+\n+  case TYPE_STORE_MULTIPLE:\n+    gcc_assert (parallel_elements (insn) >= 2);\n+\n+    post_update_rtx_index = find_post_update_rtx (insn);\n+    if (post_update_rtx_index != -1)\n+      plus_rtx = SET_SRC (parallel_element (insn, post_update_rtx_index));\n+    else\n+      {\n+\t/* (parallel\n+\t     [(set (mem (reg))              (reg)) : index 0\n+\t      (set (mem (plus (reg) (...))) (reg)) : index 1\n+\t      ...])  */\n+\tmem_rtx = SET_DEST (parallel_element (insn, 1));\n+\tif (GET_CODE (mem_rtx) == UNSPEC)\n+\t  mem_rtx = XVECEXP (mem_rtx, 0, 0);\n+\tgcc_assert (MEM_P (mem_rtx));\n+\tplus_rtx = XEXP (mem_rtx, 0);\n+      }\n+    break;\n+\n+  case TYPE_LOAD:\n+  case TYPE_STORE:\n+    mem_rtx = extract_mem_rtx (insn);\n+\n+    switch (GET_CODE (XEXP (mem_rtx, 0)))\n+      {\n+      case POST_INC:\n+\t/* (mem (post_inc (...)))  */\n+\treturn MEM_ACCESS_DIR_POS;\n+\n+      case POST_DEC:\n+\t/* (mem (post_dec (...)))  */\n+\treturn MEM_ACCESS_DIR_NEG;\n+\n+      case PLUS:\n+\t/* (mem (plus (reg) (...)))  */\n+\tplus_rtx = XEXP (mem_rtx, 0);\n+\tbreak;\n+\n+      case POST_MODIFY:\n+\t/* (mem (post_modify (reg) (plus (reg) (...))))  */\n+\tplus_rtx = XEXP (XEXP (mem_rtx, 0), 1);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+    break;\n+\n+  default:\n+    gcc_unreachable ();\n+  }\n+\n+  gcc_assert (GET_CODE (plus_rtx) == PLUS);\n+\n+  offset_rtx = XEXP (plus_rtx, 1);\n+  if (GET_CODE (offset_rtx) == CONST_INT)\n+    {\n+      if (INTVAL (offset_rtx) < 0)\n+\treturn MEM_ACCESS_DIR_NEG;\n+      else\n+\treturn MEM_ACCESS_DIR_POS;\n+    }\n+\n+  return MEM_ACCESS_DIR_UNKNOWN;\n+}\n+\n+/* Return the nth load/store operation in the real micro-operation\n+   accessing order.  */\n+rtx\n+extract_nth_access_rtx (rtx_insn *insn, int n)\n+{\n+  int n_elems = parallel_elements (insn);\n+  int post_update_rtx_index = find_post_update_rtx (insn);\n+  memory_access_direction direction = determine_access_direction (insn);\n+\n+  gcc_assert (direction != MEM_ACCESS_DIR_UNKNOWN);\n+\n+  /* Reverse the order if the direction negative.  */\n+  if (direction == MEM_ACCESS_DIR_NEG)\n+    n = -1 * n - 1;\n+\n+  if (post_update_rtx_index != -1)\n+    {\n+      if (n >= 0 && post_update_rtx_index <= n)\n+\t++n;\n+      else if (n < 0 && post_update_rtx_index >= n + n_elems)\n+\t--n;\n+    }\n+\n+  return parallel_element (insn, n);\n+}\n+\n+/* Returns the register operated by the nth load/store operation in the real\n+   micro-operation accessing order.  This function assumes INSN must be a\n+   multiple-word load/store insn.  */\n+rtx\n+extract_nth_lmsw_access_reg (rtx_insn *insn, int n)\n+{\n+  rtx nth_rtx = extract_nth_access_rtx (insn, n);\n+\n+  if (nth_rtx == NULL_RTX)\n+    return NULL_RTX;\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LOAD_MULTIPLE:\n+      return SET_DEST (nth_rtx);\n+\n+    case TYPE_STORE_MULTIPLE:\n+      return SET_SRC (nth_rtx);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Returns the register operated by the nth load/store operation in the real\n+   micro-operation accessing order.  This function assumes INSN must be a\n+   double-word load/store insn.  */\n+rtx\n+extract_nth_ls2_access_reg (rtx_insn *insn, int n)\n+{\n+  rtx reg;\n+  machine_mode mode;\n+\n+  if (post_update_insn_p (insn))\n+    {\n+      memory_access_direction direction = determine_access_direction (insn);\n+      gcc_assert (direction != MEM_ACCESS_DIR_UNKNOWN);\n+\n+      /* Reverse the order if the direction negative.  */\n+      if (direction == MEM_ACCESS_DIR_NEG)\n+\tn = -1 * n - 1;\n+    }\n+\n+  /* Handle the out-of-range case.  */\n+  if (n < -2 || n > 1)\n+    return NULL_RTX;\n+\n+  /* Convert the index to a positive one.  */\n+  if (n < 0)\n+    n = 2 + n;\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LOAD:\n+      reg = SET_DEST (PATTERN (insn));\n+      break;\n+\n+    case TYPE_STORE:\n+      reg = SET_SRC (PATTERN (insn));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcc_assert (REG_P (reg) || GET_CODE (reg) == SUBREG);\n+\n+  switch (GET_MODE (reg))\n+    {\n+    case E_DImode:\n+      mode = SImode;\n+      break;\n+\n+    case E_DFmode:\n+      mode = SFmode;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (n == 0)\n+    return gen_lowpart (mode, reg);\n+  else\n+    return gen_highpart (mode, reg);\n+}\n+\n+/* Returns the register operated by the nth load/store operation in the real\n+   micro-operation accessing order.  */\n+rtx\n+extract_nth_access_reg (rtx_insn *insn, int index)\n+{\n+  switch (GET_CODE (PATTERN (insn)))\n+    {\n+    case PARALLEL:\n+      return extract_nth_lmsw_access_reg (insn, index);\n+\n+    case SET:\n+      return extract_nth_ls2_access_reg (insn, index);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Determine if the latency is occured when the consumer PBSADA_INSN uses the\n+   value of DEF_REG in its Ra or Rb fields.  */\n+bool\n+pbsada_insn_ra_rb_dep_reg_p (rtx pbsada_insn, rtx def_reg)\n+{\n+  rtx unspec_rtx = SET_SRC (PATTERN (pbsada_insn));\n+  gcc_assert (GET_CODE (unspec_rtx) == UNSPEC);\n+\n+  rtx pbsada_ra = XVECEXP (unspec_rtx, 0, 0);\n+  rtx pbsada_rb = XVECEXP (unspec_rtx, 0, 1);\n+\n+  if (rtx_equal_p (def_reg, pbsada_ra)\n+      || rtx_equal_p (def_reg, pbsada_rb))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Check if INSN is a movd44 insn consuming DEF_REG.  */\n+bool\n+movd44_even_dep_p (rtx_insn *insn, rtx def_reg)\n+{\n+  if (!movd44_insn_p (insn))\n+    return false;\n+\n+  rtx use_rtx = SET_SRC (PATTERN (insn));\n+\n+  if (REG_P (def_reg))\n+    {\n+      return rtx_equal_p (def_reg, use_rtx);\n+    }\n+  else if (GET_CODE (def_reg) == SUBREG\n+\t   && GET_MODE (def_reg) == SImode\n+\t   && rtx_equal_p (SUBREG_REG (def_reg), use_rtx))\n+    {\n+      if (TARGET_BIG_ENDIAN && SUBREG_BYTE (def_reg) == 4)\n+\treturn true;\n+\n+      if (!TARGET_BIG_ENDIAN && SUBREG_BYTE (def_reg) == 0)\n+\treturn true;\n+\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+} // namespace scheduling\n+} // namespace nds32\n \n /* ------------------------------------------------------------------------ */\n \n-/* This file is prepared for future implementation of precise\n-   pipeline description for nds32 target.  */\n+using namespace nds32;\n+using namespace nds32::scheduling;\n+\n+/* Check the dependency between the producer defining DEF_REG and CONSUMER\n+   requiring input operand at EX.  */\n+bool\n+n9_2r1w_consumed_by_ex_dep_p (rtx_insn *consumer, rtx def_reg)\n+{\n+  rtx use_rtx;\n+\n+  switch (get_attr_type (consumer))\n+    {\n+    case TYPE_ALU:\n+      if (movd44_even_dep_p (consumer, def_reg))\n+\treturn true;\n+\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_PBSAD:\n+    case TYPE_MUL:\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_ALU_SHIFT:\n+      use_rtx = extract_shift_reg (consumer);\n+      break;\n+\n+    case TYPE_PBSADA:\n+      return pbsada_insn_ra_rb_dep_reg_p (consumer, def_reg);\n+\n+    case TYPE_MAC:\n+      use_rtx = PATTERN (consumer);\n+      break;\n+\n+    case TYPE_DIV:\n+      if (INSN_CODE (consumer) == CODE_FOR_divmodsi4\n+\t  || INSN_CODE (consumer) == CODE_FOR_udivmodsi4)\n+\tuse_rtx = SET_SRC (parallel_element (consumer, 0));\n+      else\n+\tuse_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_MMU:\n+      if (GET_CODE (PATTERN (consumer)) == SET)\n+\tuse_rtx = SET_SRC (PATTERN (consumer));\n+      else\n+\treturn true;\n+      break;\n+\n+    case TYPE_LOAD:\n+      /* ADDR_IN_bi_Ra, ADDR_IN_!bi */\n+      if (post_update_insn_p (consumer))\n+\tuse_rtx = extract_base_reg (consumer);\n+      else\n+\tuse_rtx = extract_mem_rtx (consumer);\n+      break;\n+\n+    case TYPE_STORE:\n+      /* ADDR_IN_bi_Ra, ADDR_IN_!bi */\n+      if (post_update_insn_p (consumer))\n+\tuse_rtx = extract_base_reg (consumer);\n+      else\n+\tuse_rtx = extract_mem_rtx (consumer);\n+\n+      if (reg_overlap_p (def_reg, use_rtx))\n+\treturn true;\n+\n+      /* exclude ST_!bi_RR */\n+      if (!post_update_insn_p (consumer)\n+\t  && !immed_offset_p (extract_mem_rtx (consumer)))\n+\treturn false;\n+\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_LOAD_MULTIPLE:\n+      use_rtx = extract_base_reg (consumer);\n+      break;\n+\n+    case TYPE_STORE_MULTIPLE:\n+      /* ADDR_IN */\n+      use_rtx = extract_base_reg (consumer);\n+      if (reg_overlap_p (def_reg, use_rtx))\n+\treturn true;\n+\n+      /* SMW (N, 1) */\n+      use_rtx = extract_nth_access_rtx (consumer, 0);\n+      break;\n+\n+    case TYPE_BRANCH:\n+      use_rtx = PATTERN (consumer);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (reg_overlap_p (def_reg, use_rtx))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Check the dependency between the producer defining DEF_REG and CONSUMER\n+   requiring input operand at EX.  */\n+bool\n+n9_3r2w_consumed_by_ex_dep_p (rtx_insn *consumer, rtx def_reg)\n+{\n+  rtx use_rtx;\n+\n+  switch (get_attr_type (consumer))\n+    {\n+    case TYPE_ALU:\n+    case TYPE_PBSAD:\n+    case TYPE_MUL:\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_ALU_SHIFT:\n+      use_rtx = extract_shift_reg (consumer);\n+      break;\n+\n+    case TYPE_PBSADA:\n+      return pbsada_insn_ra_rb_dep_reg_p (consumer, def_reg);\n+\n+    case TYPE_MAC:\n+      use_rtx = extract_mac_non_acc_rtx (consumer);\n+      break;\n+\n+   /* Some special instructions, divmodsi4 and udivmodsi4, produce two\n+      results, the quotient and the remainder.  In 2R1W configuration,\n+      it requires two micro-operations in order to write two registers.\n+      We have to check the dependency from the producer to the first\n+      micro-operation.  */\n+    case TYPE_DIV:\n+      if (INSN_CODE (consumer) == CODE_FOR_divmodsi4\n+\t  || INSN_CODE (consumer) == CODE_FOR_udivmodsi4)\n+\tuse_rtx = SET_SRC (parallel_element (consumer, 0));\n+      else\n+\tuse_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_MMU:\n+      if (GET_CODE (PATTERN (consumer)) == SET)\n+\tuse_rtx = SET_SRC (PATTERN (consumer));\n+      else\n+\treturn true;\n+      break;\n+\n+    case TYPE_LOAD:\n+    case TYPE_STORE:\n+      use_rtx = extract_mem_rtx (consumer);\n+      break;\n+\n+    case TYPE_LOAD_MULTIPLE:\n+    case TYPE_STORE_MULTIPLE:\n+      use_rtx = extract_base_reg (consumer);\n+      break;\n+\n+    case TYPE_BRANCH:\n+      use_rtx = PATTERN (consumer);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (reg_overlap_p (def_reg, use_rtx))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Guard functions for N9 cores.  */\n+\n+/* Check dependencies from MM to EX.  */\n+bool\n+nds32_n9_2r1w_mm_to_ex_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  rtx def_reg;\n+\n+  switch (get_attr_type (producer))\n+    {\n+    /* LD_!bi */\n+    case TYPE_LOAD:\n+      if (post_update_insn_p (producer))\n+\treturn false;\n+\n+      def_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+    case TYPE_MUL:\n+    case TYPE_MAC:\n+      def_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+    return n9_2r1w_consumed_by_ex_dep_p (consumer, def_reg);\n+}\n+\n+/* Check dependencies from MM to EX.  */\n+bool\n+nds32_n9_3r2w_mm_to_ex_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  rtx def_reg;\n+\n+  switch (get_attr_type (producer))\n+    {\n+    case TYPE_LOAD:\n+    case TYPE_MUL:\n+    case TYPE_MAC:\n+      def_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+   /* Some special instructions, divmodsi4 and udivmodsi4, produce two\n+      results, the quotient and the remainder.  We have to handle them\n+      individually.  */\n+    case TYPE_DIV:\n+      if (INSN_CODE (producer) == CODE_FOR_divmodsi4\n+\t  || INSN_CODE (producer) == CODE_FOR_udivmodsi4)\n+\t{\n+\t  rtx def_reg1 = SET_DEST (parallel_element (producer, 0));\n+\t  rtx def_reg2 = SET_DEST (parallel_element (producer, 1));\n+\n+\t  return (n9_3r2w_consumed_by_ex_dep_p (consumer, def_reg1)\n+\t\t  || n9_3r2w_consumed_by_ex_dep_p (consumer, def_reg2));\n+\t}\n+\n+      def_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+    return n9_3r2w_consumed_by_ex_dep_p (consumer, def_reg);\n+}\n+\n+/* Check dependencies from LMW(N, N) to EX.  */\n+bool\n+nds32_n9_last_load_to_ex_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  rtx last_def_reg = extract_nth_access_reg (producer, -1);\n+\n+  if (nds32_register_ports_config == REG_PORT_2R1W)\n+    {\n+      /* The base-update micro operation occupies the last cycle.  */\n+      if (post_update_insn_p (producer))\n+\treturn false;\n+\n+      /* When the base register is in the list of a load multiple insn and the\n+\t access order of the base register is not the last one, we need an\n+\t additional micro operation to commit the load result to the base\n+\t register -- we can treat the base register as the last defined\n+\t register.  */\n+      size_t i;\n+      size_t n_elems = parallel_elements (producer);\n+      rtx base_reg = extract_base_reg (producer);\n+\n+      for (i = 0; i < n_elems; ++i)\n+\t{\n+\t  rtx load_rtx = extract_nth_access_rtx (producer, i);\n+\t  rtx list_element = SET_DEST (load_rtx);\n+\n+\t  if (rtx_equal_p (base_reg, list_element) && i != n_elems - 1)\n+\t    {\n+\t      last_def_reg = base_reg;\n+\t      break;\n+\t    }\n+\t}\n+\n+      return n9_2r1w_consumed_by_ex_dep_p (consumer, last_def_reg);\n+    }\n+  else\n+    return n9_3r2w_consumed_by_ex_dep_p (consumer, last_def_reg);\n+}\n \n /* ------------------------------------------------------------------------ */"}, {"sha": "8debf4bd69b909c2c6d12aa5667b020238cbb4c5", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -97,6 +97,13 @@ extern void nds32_expand_unaligned_store (rtx *, enum machine_mode);\n \n extern bool nds32_valid_multiple_load_store_p (rtx, bool, bool);\n \n+/* Auxiliary functions for guard function checking in pipelines.md.  */\n+\n+extern bool nds32_n9_2r1w_mm_to_ex_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n9_3r2w_mm_to_ex_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n9_last_load_to_ex_p (rtx_insn *, rtx_insn *);\n+\n+\n /* Auxiliary functions for stack operation predicate checking.  */\n \n extern bool nds32_valid_stack_push_pop_p (rtx, bool);\n@@ -225,6 +232,29 @@ extern void nds32_cpu_cpp_builtins(struct cpp_reader *);\n \n extern bool nds32_split_double_word_load_store_p (rtx *,bool);\n \n+namespace nds32 {\n+\n+extern rtx extract_pattern_from_insn (rtx);\n+\n+size_t parallel_elements (rtx);\n+rtx parallel_element (rtx, int);\n+bool load_single_p (rtx_insn *);\n+bool store_single_p (rtx_insn *);\n+bool load_double_p (rtx_insn *);\n+bool store_double_p (rtx_insn *);\n+bool post_update_insn_p (rtx_insn *);\n+bool immed_offset_p (rtx);\n+int find_post_update_rtx (rtx_insn *);\n+rtx extract_mem_rtx (rtx_insn *);\n+rtx extract_base_reg (rtx_insn *);\n+\n+rtx extract_shift_reg (rtx);\n+\n+bool movd44_insn_p (rtx_insn *);\n+\n+rtx extract_mac_non_acc_rtx (rtx_insn *);\n+} // namespace nds32\n+\n /* Functions for create nds32 specific optimization pass.  */\n extern rtl_opt_pass *make_pass_nds32_relax_opt (gcc::context *);\n "}, {"sha": "55d4a9193c2d06fb20c386e5ffab32a1b5f98de7", "filename": "gcc/config/nds32/nds32-utils.c", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-utils.c?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -0,0 +1,399 @@\n+/* Auxiliary functions for pipeline descriptions pattern of Andes\n+   NDS32 cpu for GNU compiler\n+   Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+   Contributed by Andes Technology Corporation.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"tm_p.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"recog.h\"\n+#include \"tm-constrs.h\"\n+#include \"insn-attr.h\"\n+\n+\n+namespace nds32 {\n+\n+/* Get the rtx in the PATTERN field of an insn.  If INSN is not an insn,\n+   the funciton doesn't change anything and returns it directly.  */\n+rtx\n+extract_pattern_from_insn (rtx insn)\n+{\n+  if (INSN_P (insn))\n+    return PATTERN (insn);\n+\n+  return insn;\n+}\n+\n+/* Get the number of elements in a parallel rtx.  */\n+size_t\n+parallel_elements (rtx parallel_rtx)\n+{\n+  parallel_rtx = extract_pattern_from_insn (parallel_rtx);\n+  gcc_assert (GET_CODE (parallel_rtx) == PARALLEL);\n+\n+  return XVECLEN (parallel_rtx, 0);\n+}\n+\n+/* Extract an rtx from a parallel rtx with index NTH.  If NTH is a negative\n+   value, the function returns the last NTH rtx.  */\n+rtx\n+parallel_element (rtx parallel_rtx, int nth)\n+{\n+  parallel_rtx = extract_pattern_from_insn (parallel_rtx);\n+  gcc_assert (GET_CODE (parallel_rtx) == PARALLEL);\n+\n+  int len = parallel_elements (parallel_rtx);\n+\n+  if (nth >= 0)\n+    {\n+      if (nth >= len)\n+\treturn NULL_RTX;\n+\n+      return XVECEXP (parallel_rtx, 0, nth);\n+    }\n+  else\n+    {\n+      if (len + nth < 0)\n+\treturn NULL_RTX;\n+\n+      return XVECEXP (parallel_rtx, 0, len + nth);\n+    }\n+}\n+\n+/* Functions to determine whether INSN is single-word, double-word\n+   or partial-word load/store insn.  */\n+\n+bool\n+load_single_p (rtx_insn *insn)\n+{\n+  if (get_attr_type (insn) != TYPE_LOAD)\n+    return false;\n+\n+  if (INSN_CODE (insn) == CODE_FOR_move_di ||\n+      INSN_CODE (insn) == CODE_FOR_move_df)\n+    return false;\n+\n+  return true;\n+}\n+\n+bool\n+store_single_p (rtx_insn *insn)\n+{\n+  if (get_attr_type (insn) != TYPE_STORE)\n+    return false;\n+\n+  if (INSN_CODE (insn) == CODE_FOR_move_di ||\n+      INSN_CODE (insn) == CODE_FOR_move_df)\n+    return false;\n+\n+  return true;\n+}\n+\n+bool\n+load_double_p (rtx_insn *insn)\n+{\n+  if (get_attr_type (insn) != TYPE_LOAD)\n+    return false;\n+\n+  if (INSN_CODE (insn) != CODE_FOR_move_di &&\n+      INSN_CODE (insn) != CODE_FOR_move_df)\n+    return false;\n+\n+  return true;\n+}\n+\n+bool\n+store_double_p (rtx_insn *insn)\n+{\n+  if (get_attr_type (insn) != TYPE_STORE)\n+    return false;\n+\n+  if (INSN_CODE (insn) != CODE_FOR_move_di &&\n+      INSN_CODE (insn) != CODE_FOR_move_df)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Determine if INSN is a post update insn.  */\n+bool\n+post_update_insn_p (rtx_insn *insn)\n+{\n+  if (find_post_update_rtx (insn) == -1)\n+    return false;\n+  else\n+    return true;\n+}\n+\n+/* Check if the address of MEM_RTX consists of a base register and an\n+   immediate offset.  */\n+bool\n+immed_offset_p (rtx mem_rtx)\n+{\n+  gcc_assert (MEM_P (mem_rtx));\n+\n+  rtx addr_rtx = XEXP (mem_rtx, 0);\n+\n+  /* (mem (reg)) is equivalent to (mem (plus (reg) (const_int 0))) */\n+  if (REG_P (addr_rtx))\n+    return true;\n+\n+  /* (mem (plus (reg) (const_int))) */\n+  if (GET_CODE (addr_rtx) == PLUS\n+      && GET_CODE (XEXP (addr_rtx, 1)) == CONST_INT)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Find the post update rtx in INSN.  If INSN is a load/store multiple insn,\n+   the function returns the vector index of its parallel part.  If INSN is a\n+   single load/store insn, the function returns 0.  If INSN is not a post-\n+   update insn, the function returns -1.  */\n+int\n+find_post_update_rtx (rtx_insn *insn)\n+{\n+  rtx mem_rtx;\n+  int i, len;\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LOAD_MULTIPLE:\n+    case TYPE_STORE_MULTIPLE:\n+      /* Find a pattern in a parallel rtx:\n+\t (set (reg) (plus (reg) (const_int)))  */\n+      len = parallel_elements (insn);\n+      for (i = 0; i < len; ++i)\n+\t{\n+\t  rtx curr_insn = parallel_element (insn, i);\n+\n+\t  if (GET_CODE (curr_insn) == SET\n+\t      && REG_P (SET_DEST (curr_insn))\n+\t      && GET_CODE (SET_SRC (curr_insn)) == PLUS)\n+\t\treturn i;\n+\t}\n+      return -1;\n+\n+    case TYPE_LOAD:\n+    case TYPE_FLOAD:\n+    case TYPE_STORE:\n+    case TYPE_FSTORE:\n+      mem_rtx = extract_mem_rtx (insn);\n+      /* (mem (post_inc (reg)))  */\n+      switch (GET_CODE (XEXP (mem_rtx, 0)))\n+\t{\n+\tcase POST_INC:\n+\tcase POST_DEC:\n+\tcase POST_MODIFY:\n+\t  return 0;\n+\n+\tdefault:\n+\t  return -1;\n+\t}\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Extract the MEM rtx from a load/store insn.  */\n+rtx\n+extract_mem_rtx (rtx_insn *insn)\n+{\n+  rtx body = PATTERN (insn);\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LOAD:\n+    case TYPE_FLOAD:\n+      if (MEM_P (SET_SRC (body)))\n+\treturn SET_SRC (body);\n+\n+      /* unaligned address: (unspec [(mem)])  */\n+      if (GET_CODE (SET_SRC (body)) == UNSPEC)\n+\t{\n+\t  gcc_assert (MEM_P (XVECEXP (SET_SRC (body), 0, 0)));\n+\t  return XVECEXP (SET_SRC (body), 0, 0);\n+\t}\n+\n+      /* (sign_extend (mem)) */\n+      gcc_assert (MEM_P (XEXP (SET_SRC (body), 0)));\n+      return XEXP (SET_SRC (body), 0);\n+\n+    case TYPE_STORE:\n+    case TYPE_FSTORE:\n+      if (MEM_P (SET_DEST (body)))\n+\treturn SET_DEST (body);\n+\n+      /* unaligned address: (unspec [(mem)])  */\n+      if (GET_CODE (SET_DEST (body)) == UNSPEC)\n+\t{\n+\t  gcc_assert (MEM_P (XVECEXP (SET_DEST (body), 0, 0)));\n+\t  return XVECEXP (SET_DEST (body), 0, 0);\n+\t}\n+\n+      /* (sign_extend (mem)) */\n+      gcc_assert (MEM_P (XEXP (SET_DEST (body), 0)));\n+      return XEXP (SET_DEST (body), 0);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Extract the base register from load/store insns.  The function returns\n+   NULL_RTX if the address is not consist of any registers.  */\n+rtx\n+extract_base_reg (rtx_insn *insn)\n+{\n+  int post_update_rtx_index;\n+  rtx mem_rtx;\n+  rtx plus_rtx;\n+\n+  /* Find the MEM rtx.  If we can find an insn updating the base register,\n+     the base register will be returned directly.  */\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LOAD_MULTIPLE:\n+      post_update_rtx_index = find_post_update_rtx (insn);\n+\n+      if (post_update_rtx_index != -1)\n+        return SET_DEST (parallel_element (insn, post_update_rtx_index));\n+\n+      mem_rtx = SET_SRC (parallel_element (insn, 0));\n+      break;\n+\n+    case TYPE_STORE_MULTIPLE:\n+      post_update_rtx_index = find_post_update_rtx (insn);\n+\n+      if (post_update_rtx_index != -1)\n+        return SET_DEST (parallel_element (insn, post_update_rtx_index));\n+\n+      mem_rtx = SET_DEST (parallel_element (insn, 0));\n+      break;\n+\n+    case TYPE_LOAD:\n+    case TYPE_FLOAD:\n+    case TYPE_STORE:\n+    case TYPE_FSTORE:\n+      mem_rtx = extract_mem_rtx (insn);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcc_assert (MEM_P (mem_rtx));\n+\n+  /* (mem (reg))  */\n+  if (REG_P (XEXP (mem_rtx, 0)))\n+    return XEXP (mem_rtx, 0);\n+\n+  plus_rtx = XEXP (mem_rtx, 0);\n+\n+  if (GET_CODE (plus_rtx) == SYMBOL_REF\n+      || GET_CODE (plus_rtx) == CONST)\n+    return NULL_RTX;\n+\n+  gcc_assert (GET_CODE (plus_rtx) == PLUS\n+\t      || GET_CODE (plus_rtx) == POST_INC\n+\t      || GET_CODE (plus_rtx) == POST_DEC\n+\t      || GET_CODE (plus_rtx) == POST_MODIFY);\n+  gcc_assert (REG_P (XEXP (plus_rtx, 0)));\n+  /* (mem (plus (reg) (const_int))) or\n+     (mem (post_inc (reg))) or\n+     (mem (post_dec (reg))) or\n+     (mem (post_modify (reg) (plus (reg) (reg))))  */\n+  return XEXP (plus_rtx, 0);\n+}\n+\n+/* Extract the register of the shift operand from an ALU_SHIFT rtx.  */\n+rtx\n+extract_shift_reg (rtx alu_shift_rtx)\n+{\n+  alu_shift_rtx = extract_pattern_from_insn (alu_shift_rtx);\n+\n+  rtx alu_rtx = SET_SRC (alu_shift_rtx);\n+  rtx shift_rtx;\n+\n+  /* Various forms of ALU_SHIFT can be made by the combiner.\n+     See the difference between add_slli and sub_slli in nds32.md.  */\n+  if (REG_P (XEXP (alu_rtx, 0)))\n+    shift_rtx = XEXP (alu_rtx, 1);\n+  else\n+    shift_rtx = XEXP (alu_rtx, 0);\n+\n+  return XEXP (shift_rtx, 0);\n+}\n+\n+/* Check if INSN is a movd44 insn.  */\n+bool\n+movd44_insn_p (rtx_insn *insn)\n+{\n+  if (get_attr_type (insn) == TYPE_ALU\n+      && (INSN_CODE (insn) == CODE_FOR_move_di\n+\t  || INSN_CODE (insn) == CODE_FOR_move_df))\n+    {\n+      rtx body = PATTERN (insn);\n+      gcc_assert (GET_CODE (body) == SET);\n+\n+      rtx src = SET_SRC (body);\n+      rtx dest = SET_DEST (body);\n+\n+      if ((REG_P (src) || GET_CODE (src) == SUBREG)\n+\t  && (REG_P (dest) || GET_CODE (dest) == SUBREG))\n+\treturn true;\n+\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Extract the rtx representing non-accumulation operands of a MAC insn.  */\n+rtx\n+extract_mac_non_acc_rtx (rtx_insn *insn)\n+{\n+  rtx exp = SET_SRC (PATTERN (insn));\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_MAC:\n+      if (REG_P (XEXP (exp, 0)))\n+\treturn XEXP (exp, 1);\n+      else\n+\treturn XEXP (exp, 0);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+} // namespace nds32"}, {"sha": "03deda962b17c56c37ef78c6e4d2c3f3287d5fb4", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -502,6 +502,11 @@ enum nds32_builtins\n    || nds32_arch_option == ARCH_V3S)\n #define TARGET_ISA_V3M  (nds32_arch_option == ARCH_V3M)\n \n+#define TARGET_PIPELINE_N9 \\\n+  (nds32_cpu_option == CPU_N9)\n+#define TARGET_PIPELINE_SIMPLE \\\n+  (nds32_cpu_option == CPU_SIMPLE)\n+\n #define TARGET_CMODEL_SMALL \\\n    (nds32_cmodel_option == CMODEL_SMALL)\n #define TARGET_CMODEL_MEDIUM \\\n@@ -515,6 +520,8 @@ enum nds32_builtins\n    (nds32_cmodel_option == CMODEL_SMALL\\\n     || nds32_cmodel_option == CMODEL_MEDIUM)\n \n+#define TARGET_MUL_SLOW \\\n+  (nds32_mul_config == MUL_TYPE_SLOW)\n \n /* Run-time Target Specification.  */\n #define TARGET_SOFT_FLOAT (nds32_abi == NDS32_ABI_V2)\n@@ -553,6 +560,7 @@ enum nds32_builtins\n \t   \" %{!mno-ext-fpu-dp:%{!mext-fpu-dp:-mext-fpu-dp}}}\" \\\n \t   \" %{march=v3s:%{!mfloat-abi=*:-mfloat-abi=hard}\" \\\n \t   \" %{!mno-ext-fpu-sp:%{!mext-fpu-sp:-mext-fpu-sp}}}\" }, \\\n+  {\"cpu\",  \"%{!mcpu=*:-mcpu=%(VALUE)}\" },   \\\n   {\"float\", \"%{!mfloat-abi=*:-mfloat-abi=%(VALUE)}\" }\n \n #define CC1_SPEC \\"}, {"sha": "dabb97f93fc2d8424fec3c352687816828343a38", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -53,6 +53,15 @@\n (include \"nds32-peephole2.md\")\n \n \n+;; ------------------------------------------------------------------------\n+\n+;; CPU pipeline model.\n+(define_attr \"pipeline_model\" \"n9,simple\"\n+  (const\n+    (cond [(match_test \"nds32_cpu_option == CPU_N9\")  (const_string \"n9\")\n+\t   (match_test \"nds32_cpu_option == CPU_SIMPLE\") (const_string \"simple\")]\n+\t  (const_string \"n9\"))))\n+\n ;; Insn type, it is used to default other attribute values.\n (define_attr \"type\"\n   \"unknown,load,store,load_multiple,store_multiple,alu,alu_shift,pbsad,pbsada,mul,mac,div,branch,mmu,misc,\\"}, {"sha": "304100f6bd105a8a78a146a24ff30668ce5e87aa", "filename": "gcc/config/nds32/nds32.opt", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.opt?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -177,6 +177,21 @@ Known cpu types (for use with the -mcpu= option):\n EnumValue\n Enum(nds32_cpu_type) String(n9) Value(CPU_N9)\n \n+EnumValue\n+Enum(nds32_cpu_type) String(n903) Value(CPU_N9)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(n903a) Value(CPU_N9)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(n968) Value(CPU_N9)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(n968a) Value(CPU_N9)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(simple) Value(CPU_SIMPLE)\n+\n mconfig-fpu=\n Target RejectNegative Joined Enum(float_reg_number) Var(nds32_fp_regnum) Init(TARGET_CONFIG_FPU_DEFAULT)\n Specify a fpu configuration value from 0 to 7; 0-3 is as FPU spec says, and 4-7 is corresponding to 0-3.\n@@ -209,6 +224,38 @@ Enum(float_reg_number) String(6) Value(NDS32_CONFIG_FPU_6)\n EnumValue\n Enum(float_reg_number) String(7) Value(NDS32_CONFIG_FPU_7)\n \n+mconfig-mul=\n+Target RejectNegative Joined Enum(nds32_mul_type) Var(nds32_mul_config) Init(MUL_TYPE_FAST_1)\n+Specify configuration of instruction mul: fast1, fast2 or slow. The default is fast1.\n+\n+Enum\n+Name(nds32_mul_type) Type(enum nds32_mul_type)\n+\n+EnumValue\n+Enum(nds32_mul_type) String(fast) Value(MUL_TYPE_FAST_1)\n+\n+EnumValue\n+Enum(nds32_mul_type) String(fast1) Value(MUL_TYPE_FAST_1)\n+\n+EnumValue\n+Enum(nds32_mul_type) String(fast2) Value(MUL_TYPE_FAST_2)\n+\n+EnumValue\n+Enum(nds32_mul_type) String(slow) Value(MUL_TYPE_SLOW)\n+\n+mconfig-register-ports=\n+Target RejectNegative Joined Enum(nds32_register_ports) Var(nds32_register_ports_config) Init(REG_PORT_3R2W)\n+Specify how many read/write ports for n9/n10 cores.  The value should be 3r2w or 2r1w.\n+\n+Enum\n+Name(nds32_register_ports) Type(enum nds32_register_ports)\n+\n+EnumValue\n+Enum(nds32_register_ports) String(3r2w) Value(REG_PORT_3R2W)\n+\n+EnumValue\n+Enum(nds32_register_ports) String(2r1w) Value(REG_PORT_2R1W)\n+\n mctor-dtor\n Target Report\n Enable constructor/destructor feature."}, {"sha": "433391e47110a9e29c402b57dd935be9de4ce489", "filename": "gcc/config/nds32/pipelines.md", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fpipelines.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Fpipelines.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpipelines.md?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -18,12 +18,24 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_automaton \"nds32_machine\")\n \n-(define_cpu_unit \"general_unit\" \"nds32_machine\")\n+;; ------------------------------------------------------------------------\n+;; Include N9/N10 pipeline settings.\n+;; ------------------------------------------------------------------------\n+(include \"nds32-n9-3r2w.md\")\n+(include \"nds32-n9-2r1w.md\")\n+\n+\n+;; ------------------------------------------------------------------------\n+;; Define simple pipeline settings.\n+;; ------------------------------------------------------------------------\n+\n+(define_automaton \"nds32_simple_machine\")\n+\n+(define_cpu_unit \"simple_unit\" \"nds32_simple_machine\")\n \n (define_insn_reservation \"simple_insn\" 1\n-\t\t\t (eq_attr \"type\" \"unknown,load,store,load_multiple,store_multiple,alu,alu_shift,mul,mac,div,branch,mmu,misc\")\n-\t\t\t \"general_unit\")\n+  (eq_attr \"pipeline_model\" \"simple\")\n+  \"simple_unit\")\n \n ;; ------------------------------------------------------------------------"}, {"sha": "89092a5a1a972a59db1c06cb19322b8f4a26a47c", "filename": "gcc/config/nds32/t-nds32", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Ft-nds32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b99353a2aadd2de47694db415005ab137dd33959/gcc%2Fconfig%2Fnds32%2Ft-nds32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Ft-nds32?ref=b99353a2aadd2de47694db415005ab137dd33959", "patch": "@@ -131,3 +131,16 @@ nds32-relax-opt.o: \\\n   intl.h libfuncs.h $(PARAMS_H) $(OPTS_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/nds32/nds32-relax-opt.c\n+\n+nds32-utils.o: \\\n+  $(srcdir)/config/nds32/nds32-utils.c \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+  $(RTL_H) $(TREE_H) $(HASH_TABLE_H) $(OBSTACK_H) $(REGS_H) hard-reg-set.h \\\n+  insn-config.h conditions.h output.h dumpfile.h \\\n+  $(INSN_ATTR_H) $(FLAGS_H) reload.h $(FUNCTION_H) \\\n+  $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(CGRAPH_H) \\\n+  $(GGC_H) except.h $(C_PRAGMA_H) $(TM_P_H) \\\n+  $(TARGET_H) $(TARGET_DEF_H) debug.h langhooks.h $(DF_H) \\\n+  intl.h libfuncs.h $(PARAMS_H) $(OPTS_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/nds32/nds32-utils.c"}]}