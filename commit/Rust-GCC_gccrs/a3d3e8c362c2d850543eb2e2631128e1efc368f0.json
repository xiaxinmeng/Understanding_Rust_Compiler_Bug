{"sha": "a3d3e8c362c2d850543eb2e2631128e1efc368f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNkM2U4YzM2MmMyZDg1MDU0M2ViMmUyNjMxMTI4ZTFlZmMzNjhmMA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-06T01:50:35Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-06T02:03:38Z"}, "message": "Adjust by-value function vec arguments to by-reference.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_declaration_or_fndef): Adjust by-value function\n\tvec arguments to by-reference.\n\t(c_finish_omp_declare_simd): Same.\n\t(c_parser_compound_statement_nostart): Same.\n\t(c_parser_for_statement): Same.\n\t(c_parser_objc_methodprotolist): Same.\n\t(c_parser_oacc_routine): Same.\n\t(c_parser_omp_for_loop): Same.\n\t(c_parser_omp_declare_simd): Same.\n\ngcc/ChangeLog:\n\n\t* dominance.c (prune_bbs_to_update_dominators): Adjust by-value vec\n\targuments to by-reference.\n\t(iterate_fix_dominators): Same.\n\t* dominance.h (iterate_fix_dominators): Same.\n\t* ipa-prop.h: Call auto_vec::to_vec_legacy.\n\t* tree-data-ref.c (dump_data_dependence_relation): Adjust by-value vec\n\targuments to by-reference.\n\t(debug_data_dependence_relation): Same.\n\t(dump_data_dependence_relations): Same.\n\t* tree-data-ref.h (debug_data_dependence_relation): Same.\n\t(dump_data_dependence_relations): Same.\n\t* tree-predcom.c (dump_chains): Same.\n\t(initialize_root_vars_lm): Same.\n\t(determine_unroll_factor): Same.\n\t(replace_phis_by_defined_names): Same.\n\t(insert_init_seqs): Same.\n\t(pcom_worker::tree_predictive_commoning_loop): Call\n\t auto_vec::to_vec_legacy.\n\t* tree-ssa-pre.c (insert_into_preds_of_block): Adjust by-value vec\n\targuments to by-reference.\n\t* tree-ssa-threadbackward.c (populate_worklist): Same.\n\t(back_threader::resolve_def): Same.\n\t* tree-vect-data-refs.c (vect_check_nonzero_value): Same.\n\t(vect_enhance_data_refs_alignment): Same.\n\t(vect_check_lower_bound): Same.\n\t(vect_prune_runtime_alias_test_list): Same.\n\t(vect_permute_store_chain): Same.\n\t* tree-vect-slp-patterns.c (vect_normalize_conj_loc): Same.\n\t* tree-vect-stmts.c (vect_create_vectorized_demotion_stmts): Same.\n\t* tree-vectorizer.h (vect_permute_store_chain): Same.\n\t* vec.c (test_init): New function.\n\t(vec_c_tests): Call new function.\n\t* vec.h (vec): Declare ctors, dtor, and assignment.\n\t(auto_vec::vec_to_legacy): New function.\n\t(vec::copy): Adjust initialization.", "tree": {"sha": "fd9f723b32b7902c44fe1b0ce02f05356db12cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd9f723b32b7902c44fe1b0ce02f05356db12cae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3d3e8c362c2d850543eb2e2631128e1efc368f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d3e8c362c2d850543eb2e2631128e1efc368f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d3e8c362c2d850543eb2e2631128e1efc368f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d3e8c362c2d850543eb2e2631128e1efc368f0/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ebf4fb54ace6532b53f66405cd44fbbf8572508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ebf4fb54ace6532b53f66405cd44fbbf8572508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ebf4fb54ace6532b53f66405cd44fbbf8572508"}], "stats": {"total": 248, "additions": 158, "deletions": 90}, "files": [{"sha": "d24bfdb67195c7aac0081e968f4705a29e31d622", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -1489,7 +1489,8 @@ static tree c_parser_std_attribute_specifier_sequence (c_parser *);\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n-\t\t\t\t\t   bool, bool, tree *, vec<c_token>,\n+\t\t\t\t\t   bool, bool, tree * = NULL,\n+\t\t\t\t\t   vec<c_token> * = NULL,\n \t\t\t\t\t   bool have_attrs = false,\n \t\t\t\t\t   tree attrs = NULL,\n \t\t\t\t\t   struct oacc_routine_data * = NULL,\n@@ -1774,13 +1775,12 @@ c_parser_external_declaration (c_parser *parser)\n \t an @interface or @protocol with prefix attributes).  We can\n \t only tell which after parsing the declaration specifiers, if\n \t any, and the first declarator.  */\n-      c_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t     NULL, vNULL);\n+      c_parser_declaration_or_fndef (parser, true, true, true, false, true);\n       break;\n     }\n }\n \n-static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec<c_token>);\n+static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec<c_token> *);\n static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);\n \n /* Build and add a DEBUG_BEGIN_STMT statement with location LOC.  */\n@@ -1890,11 +1890,15 @@ static void\n c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t       bool static_assert_ok, bool empty_ok,\n \t\t\t       bool nested, bool start_attr_ok,\n-\t\t\t       tree *objc_foreach_object_declaration,\n-\t\t\t       vec<c_token> omp_declare_simd_clauses,\n-\t\t\t       bool have_attrs, tree attrs,\n-\t\t\t       struct oacc_routine_data *oacc_routine_data,\n-\t\t\t       bool *fallthru_attr_p)\n+\t\t\t       tree *objc_foreach_object_declaration\n+\t\t\t       /* = NULL */,\n+\t\t\t       vec<c_token> *omp_declare_simd_clauses\n+\t\t\t       /* = NULL */,\n+\t\t\t       bool have_attrs /* = false */,\n+\t\t\t       tree attrs /* = NULL_TREE */,\n+\t\t\t       struct oacc_routine_data *oacc_routine_data\n+\t\t\t       /* = NULL */,\n+\t\t\t       bool *fallthru_attr_p /* = NULL */)\n {\n   struct c_declspecs *specs;\n   tree prefix_attrs;\n@@ -2150,7 +2154,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t\tC_DTR_NORMAL, &dummy);\n       if (declarator == NULL)\n \t{\n-\t  if (omp_declare_simd_clauses.exists ())\n+\t  if (omp_declare_simd_clauses)\n \t    c_finish_omp_declare_simd (parser, NULL_TREE, NULL_TREE,\n \t\t\t\t       omp_declare_simd_clauses);\n \t  if (oacc_routine_data)\n@@ -2250,7 +2254,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n \t\t  if (!d)\n \t\t    d = error_mark_node;\n-\t\t  if (omp_declare_simd_clauses.exists ())\n+\t\t  if (omp_declare_simd_clauses)\n \t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n \t\t\t\t\t       omp_declare_simd_clauses);\n \t\t}\n@@ -2262,7 +2266,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n \t\t  if (!d)\n \t\t    d = error_mark_node;\n-\t\t  if (omp_declare_simd_clauses.exists ())\n+\t\t  if (omp_declare_simd_clauses)\n \t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n \t\t\t\t\t       omp_declare_simd_clauses);\n \t\t  init_loc = c_parser_peek_token (parser)->location;\n@@ -2342,7 +2346,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t      warn_parm_array_mismatch (lastloc, d, parms);\n \t\t    }\n \t\t}\n-\t      if (omp_declare_simd_clauses.exists ())\n+\t      if (omp_declare_simd_clauses)\n \t\t{\n \t\t  tree parms = NULL_TREE;\n \t\t  if (d && TREE_CODE (d) == FUNCTION_DECL)\n@@ -2496,9 +2500,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       while (c_parser_next_token_is_not (parser, CPP_EOF)\n \t     && c_parser_next_token_is_not (parser, CPP_OPEN_BRACE))\n \tc_parser_declaration_or_fndef (parser, false, false, false,\n-\t\t\t\t       true, false, NULL, vNULL);\n+\t\t\t\t       true, false);\n       store_parm_decls ();\n-      if (omp_declare_simd_clauses.exists ())\n+      if (omp_declare_simd_clauses)\n \tc_finish_omp_declare_simd (parser, current_function_decl, NULL_TREE,\n \t\t\t\t   omp_declare_simd_clauses);\n       if (oacc_routine_data)\n@@ -5699,7 +5703,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  bool fallthru_attr_p = false;\n \t  c_parser_declaration_or_fndef (parser, true, !have_std_attrs,\n \t\t\t\t\t true, true, true, NULL,\n-\t\t\t\t\t vNULL, have_std_attrs, std_attrs,\n+\t\t\t\t\t NULL, have_std_attrs, std_attrs,\n \t\t\t\t\t NULL, &fallthru_attr_p);\n \n \t  if (last_stmt && !fallthru_attr_p)\n@@ -5731,7 +5735,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t      last_label = false;\n \t      mark_valid_location_for_stdc_pragma (false);\n \t      c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t     true, NULL, vNULL);\n+\t\t\t\t\t     true);\n \t      /* Following the old parser, __extension__ does not\n \t\t disable this diagnostic.  */\n \t      restore_extension_diagnostics (ext);\n@@ -6782,7 +6786,7 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t       || c_parser_nth_token_starts_std_attributes (parser, 1))\n \t{\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true, true, \n-\t\t\t\t\t &object_expression, vNULL);\n+\t\t\t\t\t &object_expression);\n \t  parser->objc_could_be_foreach_context = false;\n \t  \n \t  if (c_parser_next_token_is_keyword (parser, RID_IN))\n@@ -6813,7 +6817,7 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t      ext = disable_extension_diagnostics ();\n \t      c_parser_consume_token (parser);\n \t      c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t     true, &object_expression, vNULL);\n+\t\t\t\t\t     true, &object_expression);\n \t      parser->objc_could_be_foreach_context = false;\n \t      \n \t      restore_extension_diagnostics (ext);\n@@ -11277,7 +11281,7 @@ c_parser_objc_methodprotolist (c_parser *parser)\n \t    }\n \t  else\n \t    c_parser_declaration_or_fndef (parser, false, false, true,\n-\t\t\t\t\t   false, true, NULL, vNULL);\n+\t\t\t\t\t   false, true);\n \t  break;\n \t}\n     }\n@@ -17281,12 +17285,12 @@ c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n \t  while (c_parser_next_token_is (parser, CPP_KEYWORD)\n \t\t && c_parser_peek_token (parser)->keyword == RID_EXTENSION);\n \t  c_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t\t NULL, vNULL, false, NULL, &data);\n+\t\t\t\t\t NULL, NULL, false, NULL, &data);\n \t  restore_extension_diagnostics (ext);\n \t}\n       else\n \tc_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t       NULL, vNULL, false, NULL, &data);\n+\t\t\t\t       NULL, NULL, false, NULL, &data);\n     }\n }\n \n@@ -18393,8 +18397,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t    vec_safe_push (for_block, c_begin_compound_stmt (true));\n \t  this_pre_body = push_stmt_list ();\n \t  c_in_omp_for = true;\n-\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true,\n-\t\t\t\t\t NULL, vNULL);\n+\t  c_parser_declaration_or_fndef (parser, true, true, true, true, true);\n \t  c_in_omp_for = false;\n \t  if (this_pre_body)\n \t    {\n@@ -20335,12 +20338,12 @@ c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n \t  while (c_parser_next_token_is (parser, CPP_KEYWORD)\n \t\t && c_parser_peek_token (parser)->keyword == RID_EXTENSION);\n \t  c_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t\t NULL, clauses);\n+\t\t\t\t\t NULL, &clauses);\n \t  restore_extension_diagnostics (ext);\n \t}\n       else\n \tc_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t       NULL, clauses);\n+\t\t\t\t       NULL, &clauses);\n       break;\n     case pragma_struct:\n     case pragma_param:\n@@ -20361,7 +20364,7 @@ c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n \t  if (c_parser_next_tokens_start_declaration (parser))\n \t    {\n \t      c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t     true, NULL, clauses);\n+\t\t\t\t\t     true, NULL, &clauses);\n \t      restore_extension_diagnostics (ext);\n \t      break;\n \t    }\n@@ -20370,7 +20373,7 @@ c_parser_omp_declare_simd (c_parser *parser, enum pragma_context context)\n       else if (c_parser_next_tokens_start_declaration (parser))\n \t{\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true, true,\n-\t\t\t\t\t NULL, clauses);\n+\t\t\t\t\t NULL, &clauses);\n \t  break;\n \t}\n       error (\"%<#pragma omp declare %s%> must be followed by \"\n@@ -20851,8 +20854,10 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \n static void\n c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n-\t\t\t   vec<c_token> clauses)\n+\t\t\t   vec<c_token> *pclauses)\n {\n+  vec<c_token> &clauses = *pclauses;\n+\n   /* Normally first token is CPP_NAME \"simd\" or \"variant\".  CPP_EOF there\n      indicates error has been reported and CPP_PRAGMA that\n      c_finish_omp_declare_simd has already processed the tokens.  */"}, {"sha": "cc63391a39a5e4913f39e453dcb50391a4b8747d", "filename": "gcc/dominance.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -1227,7 +1227,7 @@ recompute_dominator (enum cdi_direction dir, basic_block bb)\n    from BBS.  */\n \n static void\n-prune_bbs_to_update_dominators (vec<basic_block> bbs,\n+prune_bbs_to_update_dominators (vec<basic_block> &bbs,\n \t\t\t\tbool conservative)\n {\n   unsigned i;\n@@ -1379,7 +1379,7 @@ determine_dominators_for_sons (struct graph *g, vec<basic_block> bbs,\n    a block of BBS in the current dominance tree dominate it.  */\n \n void\n-iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n+iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> &bbs,\n \t\t\tbool conservative)\n {\n   unsigned i;"}, {"sha": "970da02c594d6020a89e5331ac29476d5610f758", "filename": "gcc/dominance.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -78,7 +78,7 @@ checking_verify_dominators (cdi_direction dir)\n \n basic_block recompute_dominator (enum cdi_direction, basic_block);\n extern void iterate_fix_dominators (enum cdi_direction,\n-\t\t\t\t    vec<basic_block> , bool);\n+\t\t\t\t    vec<basic_block> &, bool);\n extern void add_to_dominance_info (enum cdi_direction, basic_block);\n extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n extern basic_block first_dom_son (enum cdi_direction, basic_block);"}, {"sha": "42842d9466a3c26dff80d1fd00d910601c2cea6e", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -499,10 +499,10 @@ class ipa_call_arg_values\n      get reallocated, the member vectors and the underlying auto_vecs would get\n      out of sync.  */\n   ipa_call_arg_values (ipa_auto_call_arg_values *aavals)\n-    : m_known_vals (aavals->m_known_vals),\n-      m_known_contexts (aavals->m_known_contexts),\n-      m_known_aggs (aavals->m_known_aggs),\n-      m_known_value_ranges (aavals->m_known_value_ranges)\n+    : m_known_vals (aavals->m_known_vals.to_vec_legacy ()),\n+      m_known_contexts (aavals->m_known_contexts.to_vec_legacy ()),\n+      m_known_aggs (aavals->m_known_aggs.to_vec_legacy ()),\n+      m_known_value_ranges (aavals->m_known_value_ranges.to_vec_legacy ())\n   {}\n \n   /* If m_known_vals (vector of known \"scalar\" values) is sufficiantly long,"}, {"sha": "e061baa7c20e7b5000f816f850838f5c816c4392", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -404,8 +404,7 @@ print_dist_vectors (FILE *outf, vec<lambda_vector> dist_vects,\n /* Dump function for a DATA_DEPENDENCE_RELATION structure.  */\n \n DEBUG_FUNCTION void\n-dump_data_dependence_relation (FILE *outf,\n-\t\t\t       struct data_dependence_relation *ddr)\n+dump_data_dependence_relation (FILE *outf, const data_dependence_relation *ddr)\n {\n   struct data_reference *dra, *drb;\n \n@@ -479,18 +478,17 @@ dump_data_dependence_relation (FILE *outf,\n /* Debug version.  */\n \n DEBUG_FUNCTION void\n-debug_data_dependence_relation (struct data_dependence_relation *ddr)\n+debug_data_dependence_relation (const struct data_dependence_relation *ddr)\n {\n   dump_data_dependence_relation (stderr, ddr);\n }\n \n /* Dump into FILE all the dependence relations from DDRS.  */\n \n DEBUG_FUNCTION void\n-dump_data_dependence_relations (FILE *file,\n-\t\t\t\tvec<ddr_p> ddrs)\n+dump_data_dependence_relations (FILE *file, const vec<ddr_p> &ddrs)\n {\n-  for (data_dependence_relation *ddr : ddrs)\n+  for (auto ddr : ddrs)\n     dump_data_dependence_relation (file, ddr);\n }\n "}, {"sha": "685f33d85ae77279002d5fe9d6082e80a1ce6bcc", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -528,8 +528,8 @@ extern void debug_data_reference (struct data_reference *);\n extern void debug_data_references (vec<data_reference_p> );\n extern void debug (vec<data_reference_p> &ref);\n extern void debug (vec<data_reference_p> *ptr);\n-extern void debug_data_dependence_relation (struct data_dependence_relation *);\n-extern void dump_data_dependence_relations (FILE *, vec<ddr_p> );\n+extern void debug_data_dependence_relation (const data_dependence_relation *);\n+extern void dump_data_dependence_relations (FILE *, const vec<ddr_p> &);\n extern void debug (vec<ddr_p> &ref);\n extern void debug (vec<ddr_p> *ptr);\n extern void debug_data_dependence_relations (vec<ddr_p> );"}, {"sha": "6b195d1914f53d79594d3eb79c55f8ec63f5ddce", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -639,9 +639,8 @@ dump_chain (FILE *file, chain_p chain)\n \n /* Dumps CHAINS to FILE.  */\n \n-extern void dump_chains (FILE *, vec<chain_p> );\n void\n-dump_chains (FILE *file, vec<chain_p> chains)\n+dump_chains (FILE *file, const vec<chain_p> &chains)\n {\n   chain_p chain;\n   unsigned i;\n@@ -2049,7 +2048,7 @@ finalize_eliminated_stores (class loop *loop, chain_p chain)\n \n static void\n initialize_root_vars_lm (class loop *loop, dref root, bool written,\n-\t\t\t vec<tree> *vars, vec<tree> inits,\n+\t\t\t vec<tree> *vars, const vec<tree> &inits,\n \t\t\t bitmap tmp_vars)\n {\n   unsigned i;\n@@ -2324,7 +2323,7 @@ pcom_worker::execute_pred_commoning_chain (chain_p chain,\n    optimized.  */\n \n static unsigned\n-determine_unroll_factor (vec<chain_p> chains)\n+determine_unroll_factor (const vec<chain_p> &chains)\n {\n   chain_p chain;\n   unsigned factor = 1, af, nfactor, i;\n@@ -2401,7 +2400,7 @@ pcom_worker::execute_pred_commoning (bitmap tmp_vars)\n    phi node, record the ssa name that is defined by it.  */\n \n static void\n-replace_phis_by_defined_names (vec<chain_p> chains)\n+replace_phis_by_defined_names (vec<chain_p> &chains)\n {\n   chain_p chain;\n   dref a;\n@@ -3276,7 +3275,7 @@ pcom_worker::prepare_finalizers ()\n /* Insert all initializing gimple stmts into LOOP's entry edge.  */\n \n static void\n-insert_init_seqs (class loop *loop, vec<chain_p> chains)\n+insert_init_seqs (class loop *loop, vec<chain_p> &chains)\n {\n   unsigned i;\n   edge entry = loop_preheader_edge (loop);\n@@ -3387,7 +3386,7 @@ pcom_worker::tree_predictive_commoning_loop (bool allow_unroll_p)\n \tfprintf (dump_file, \"Unrolling %u times.\\n\", unroll_factor);\n \n       dta.tmp_vars = tmp_vars;\n-      dta.chains = m_chains;\n+      dta.chains = m_chains.to_vec_legacy ();\n       dta.worker = this;\n \n       /* Cfg manipulations performed in tree_transform_and_unroll_loop before"}, {"sha": "ebe95cc6c73f0540db5986869f8d89816df470a4", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -3107,7 +3107,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \n static bool\n insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n-\t\t\t    vec<pre_expr> avail)\n+\t\t\t    vec<pre_expr> &avail)\n {\n   pre_expr expr = expression_for_id (exprnum);\n   pre_expr newphi;"}, {"sha": "e237eb4ca90496ffcd320e9b0863d805983907b5", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -92,7 +92,7 @@ class back_threader\n private:\n   void maybe_register_path (edge taken_edge);\n   bool find_paths_to_names (basic_block bb, bitmap imports);\n-  bool resolve_def (tree name, bitmap interesting, vec<tree> worklist);\n+  bool resolve_def (tree name, bitmap interesting, vec<tree> &worklist);\n   bool resolve_phi (gphi *phi, bitmap imports);\n   edge find_taken_edge (const vec<basic_block> &path);\n   edge find_taken_edge_cond (const vec<basic_block> &path, gcond *);\n@@ -240,7 +240,7 @@ back_threader::find_taken_edge_cond (const vec<basic_block> &path,\n // Populate a vector of trees from a bitmap.\n \n static inline void\n-populate_worklist (vec<tree> worklist, bitmap bits)\n+populate_worklist (vec<tree> &worklist, bitmap bits)\n {\n   bitmap_iterator bi;\n   unsigned i;\n@@ -317,7 +317,7 @@ back_threader::resolve_phi (gphi *phi, bitmap interesting)\n // current path to be constant, register the path, and return TRUE.\n \n bool\n-back_threader::resolve_def (tree name, bitmap interesting, vec<tree> worklist)\n+back_threader::resolve_def (tree name, bitmap interesting, vec<tree> &worklist)\n {\n   gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n "}, {"sha": "d594c0a1b1e5870ecc6c96896a260571ac4efed8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -212,7 +212,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n static void\n vect_check_nonzero_value (loop_vec_info loop_vinfo, tree value)\n {\n-  vec<tree> checks = LOOP_VINFO_CHECK_NONZERO (loop_vinfo);\n+  const vec<tree> &checks = LOOP_VINFO_CHECK_NONZERO (loop_vinfo);\n   for (unsigned int i = 0; i < checks.length(); ++i)\n     if (checks[i] == value)\n       return;\n@@ -2349,8 +2349,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (do_versioning)\n     {\n-      vec<stmt_vec_info> may_misalign_stmts\n-        = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n+      const vec<stmt_vec_info> &may_misalign_stmts\n+\t= LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n       stmt_vec_info stmt_info;\n \n       /* It can now be assumed that the data references in the statements\n@@ -3364,7 +3364,8 @@ static void\n vect_check_lower_bound (loop_vec_info loop_vinfo, tree expr, bool unsigned_p,\n \t\t\tpoly_uint64 min_value)\n {\n-  vec<vec_lower_bound> lower_bounds = LOOP_VINFO_LOWER_BOUNDS (loop_vinfo);\n+  vec<vec_lower_bound> &lower_bounds\n+    = LOOP_VINFO_LOWER_BOUNDS (loop_vinfo);\n   for (unsigned int i = 0; i < lower_bounds.length (); ++i)\n     if (operand_equal_p (lower_bounds[i].expr, expr, 0))\n       {\n@@ -3466,10 +3467,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   typedef pair_hash <tree_operand_hash, tree_operand_hash> tree_pair_hash;\n   hash_set <tree_pair_hash> compared_objects;\n \n-  vec<ddr_p> may_alias_ddrs = LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n+  const vec<ddr_p> &may_alias_ddrs = LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n   vec<dr_with_seg_len_pair_t> &comp_alias_ddrs\n     = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n-  vec<vec_object_pair> &check_unequal_addrs\n+  const vec<vec_object_pair> &check_unequal_addrs\n     = LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo);\n   poly_uint64 vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n@@ -5350,7 +5351,7 @@ vect_store_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count,\n    I4:  6 14 22 30  7 15 23 31.  */\n \n void\n-vect_permute_store_chain (vec_info *vinfo, vec<tree> dr_chain,\n+vect_permute_store_chain (vec_info *vinfo, vec<tree> &dr_chain,\n \t\t\t  unsigned int length,\n \t\t\t  stmt_vec_info stmt_info,\n \t\t\t  gimple_stmt_iterator *gsi,"}, {"sha": "b8d09b7832e29689ede832d555e1b6af2c24ce1e", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -746,7 +746,7 @@ vect_match_call_complex_mla (slp_tree node, unsigned child,\n    of the negate node.  */\n \n static inline bool\n-vect_normalize_conj_loc (vec<slp_tree> args, bool *neg_first_p = NULL)\n+vect_normalize_conj_loc (vec<slp_tree> &args, bool *neg_first_p = NULL)\n {\n   gcc_assert (args.length () == 2);\n   bool neg_found = false;"}, {"sha": "94bdb74ea8db803e419c429da1e3c63b2e3bc793", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -4499,7 +4499,7 @@ static void\n vect_create_vectorized_demotion_stmts (vec_info *vinfo, vec<tree> *vec_oprnds,\n \t\t\t\t       int multi_step_cvt,\n \t\t\t\t       stmt_vec_info stmt_info,\n-\t\t\t\t       vec<tree> vec_dsts,\n+\t\t\t\t       vec<tree> &vec_dsts,\n \t\t\t\t       gimple_stmt_iterator *gsi,\n \t\t\t\t       slp_tree slp_node, enum tree_code code)\n {"}, {"sha": "5571b3cce3b203c4771d9070927a1e33dacce89e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -1990,8 +1990,8 @@ extern bool vect_grouped_store_supported (tree, unsigned HOST_WIDE_INT);\n extern bool vect_store_lanes_supported (tree, unsigned HOST_WIDE_INT, bool);\n extern bool vect_grouped_load_supported (tree, bool, unsigned HOST_WIDE_INT);\n extern bool vect_load_lanes_supported (tree, unsigned HOST_WIDE_INT, bool);\n-extern void vect_permute_store_chain (vec_info *,\n-\t\t\t\t      vec<tree> ,unsigned int, stmt_vec_info,\n+extern void vect_permute_store_chain (vec_info *, vec<tree> &,\n+\t\t\t\t      unsigned int, stmt_vec_info,\n \t\t\t\t      gimple_stmt_iterator *, vec<tree> *);\n extern tree vect_setup_realignment (vec_info *,\n \t\t\t\t    stmt_vec_info, gimple_stmt_iterator *,"}, {"sha": "6d767cc12c14d12682193a20eac262853cdf2430", "filename": "gcc/vec.c", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -38,16 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #endif\n \n-/* vNULL is an empty type with a template cast operation that returns\n-   a zero-initialized vec<T, A, L> instance.  Use this when you want\n-   to assign nil values to new vec instances or pass a nil vector as\n-   a function call argument.\n-\n-   We use this technique because vec<T, A, L> must be PODs (they are\n-   stored in unions and passed in vararg functions), this means that\n-   they cannot have ctors/dtors.  */\n-vnull vNULL;\n-\n /* Vector memory usage.  */\n class vec_usage: public mem_usage\n {\n@@ -282,6 +272,42 @@ safe_push_range (vec <int>&v, int start, int limit)\n     v.safe_push (i);\n }\n \n+/* Verify forms of initialization.  */\n+\n+static void\n+test_init ()\n+{\n+  {\n+    vec<int> v1{ };\n+    ASSERT_EQ (0, v1.length ());\n+\n+    vec<int> v2 (v1);\n+    ASSERT_EQ (0, v2.length ());\n+  }\n+\n+  {\n+    vec<int> v1 = vec<int>();\n+    ASSERT_EQ (0, v1.length ());\n+\n+    vec<int> v2 = v1;\n+    ASSERT_EQ (0, v2.length ());\n+  }\n+\n+  {\n+    vec<int> v1 (vNULL);\n+    ASSERT_EQ (0, v1.length ());\n+    v1.safe_push (1);\n+\n+    vec<int> v2 (v1);\n+    ASSERT_EQ (1, v1.length ());\n+    v2.safe_push (1);\n+\n+    ASSERT_EQ (2, v1.length ());\n+    ASSERT_EQ (2, v2.length ());\n+    v1.release ();\n+  }\n+}\n+\n /* Verify that vec::quick_push works correctly.  */\n \n static void\n@@ -547,6 +573,7 @@ test_auto_delete_vec ()\n void\n vec_c_tests ()\n {\n+  test_init ();\n   test_quick_push ();\n   test_safe_push ();\n   test_truncate ();"}, {"sha": "b3f47b1f65b1a7ed74c6d5c1b58e948fbf22a1e2", "filename": "gcc/vec.h", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3d3e8c362c2d850543eb2e2631128e1efc368f0/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=a3d3e8c362c2d850543eb2e2631128e1efc368f0", "patch": "@@ -541,18 +541,16 @@ vec_copy_construct (T *dst, const T *src, unsigned n)\n     ::new (static_cast<void*>(dst)) T (*src);\n }\n \n-/* Type to provide NULL values for vec<T, A, L>.  This is used to\n-   provide nil initializers for vec instances.  Since vec must be\n-   a POD, we cannot have proper ctor/dtor for it.  To initialize\n-   a vec instance, you can assign it the value vNULL.  This isn't\n-   needed for file-scope and function-local static vectors, which\n-   are zero-initialized by default.  */\n-struct vnull\n-{\n-  template <typename T, typename A, typename L>\n-  CONSTEXPR operator vec<T, A, L> () const { return vec<T, A, L>(); }\n-};\n-extern vnull vNULL;\n+/* Type to provide zero-initialized values for vec<T, A, L>.  This is\n+   used to  provide nil initializers for vec instances.  Since vec must\n+   be a trivially copyable type that can be copied by memcpy and zeroed\n+   out by memset, it must have defaulted default and copy ctor and copy\n+   assignment.  To initialize a vec either use value initialization\n+   (e.g., vec() or vec v{ };) or assign it the value vNULL.  This isn't\n+   needed for file-scope and function-local static vectors, which are\n+   zero-initialized by default.  */\n+struct vnull { };\n+constexpr vnull vNULL{ };\n \n \n /* Embeddable vector.  These vectors are suitable to be embedded\n@@ -1431,10 +1429,34 @@ gt_pch_nx (vec<T, A, vl_embed> *v, gt_pointer_operator op, void *cookie)\n    As long as we use C++03, we cannot have constructors nor\n    destructors in classes that are stored in unions.  */\n \n+template<typename T, size_t N = 0>\n+class auto_vec;\n+\n template<typename T>\n struct vec<T, va_heap, vl_ptr>\n {\n public:\n+  /* Default ctors to ensure triviality.  Use value-initialization\n+     (e.g., vec() or vec v{ };) or vNULL to create a zero-initialized\n+     instance.  */\n+  vec () = default;\n+  vec (const vec &) = default;\n+  /* Initialization from the generic vNULL.  */\n+  vec (vnull): m_vec () { }\n+  /* Same as default ctor: vec storage must be released manually.  */\n+  ~vec () = default;\n+\n+  /* Defaulted same as copy ctor.  */\n+  vec& operator= (const vec &) = default;\n+\n+  /* Prevent implicit conversion from auto_vec.  Use auto_vec::to_vec()\n+     instead.  */\n+  template <size_t N>\n+  vec (auto_vec<T, N> &) = delete;\n+\n+  template <size_t N>\n+  void operator= (auto_vec<T, N> &) = delete;\n+\n   /* Memory allocation and deallocation for the embedded vector.\n      Needed because we cannot have proper ctors/dtors defined.  */\n   void create (unsigned nelems CXX_MEM_STAT_INFO);\n@@ -1522,7 +1544,7 @@ struct vec<T, va_heap, vl_ptr>\n    want to ask for internal storage for vectors on the stack because if the\n    size of the vector is larger than the internal storage that space is wasted.\n    */\n-template<typename T, size_t N = 0>\n+template<typename T, size_t N /* = 0 */>\n class auto_vec : public vec<T, va_heap>\n {\n public:\n@@ -1549,6 +1571,14 @@ class auto_vec : public vec<T, va_heap>\n     this->release ();\n   }\n \n+  /* Explicitly convert to the base class.  There is no conversion\n+     from a const auto_vec because a copy of the returned vec can\n+     be used to modify *THIS.\n+     This is a legacy function not to be used in new code.  */\n+  vec<T, va_heap> to_vec_legacy () {\n+    return *static_cast<vec<T, va_heap> *>(this);\n+  }\n+\n private:\n   vec<T, va_heap, vl_embed> m_auto;\n   T m_data[MAX (N - 1, 1)];\n@@ -1602,6 +1632,14 @@ class auto_vec<T, 0> : public vec<T, va_heap>\n       return *this;\n     }\n \n+  /* Explicitly convert to the base class.  There is no conversion\n+     from a const auto_vec because a copy of the returned vec can\n+     be used to modify *THIS.\n+     This is a legacy function not to be used in new code.  */\n+  vec<T, va_heap> to_vec_legacy () {\n+    return *static_cast<vec<T, va_heap> *>(this);\n+  }\n+\n   // You probably don't want to copy a vector, so these are deleted to prevent\n   // unintentional use.  If you really need a copy of the vectors contents you\n   // can use copy ().\n@@ -1781,7 +1819,7 @@ template<typename T>\n inline vec<T, va_heap, vl_ptr>\n vec<T, va_heap, vl_ptr>::copy (ALONE_MEM_STAT_DECL) const\n {\n-  vec<T, va_heap, vl_ptr> new_vec = vNULL;\n+  vec<T, va_heap, vl_ptr> new_vec{ };\n   if (length ())\n     new_vec.m_vec = m_vec->copy (ALONE_PASS_MEM_STAT);\n   return new_vec;"}]}