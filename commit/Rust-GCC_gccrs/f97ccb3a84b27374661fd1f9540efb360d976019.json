{"sha": "f97ccb3a84b27374661fd1f9540efb360d976019", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk3Y2NiM2E4NGIyNzM3NDY2MWZkMWY5NTQwZWZiMzYwZDk3NjAxOQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2007-08-14T08:45:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:45:48Z"}, "message": "a-cihama.ads, [...] (Next): Applied pragma Inline.\n\n2007-08-14  Bob Duff  <duff@adacore.com>\n\n\t* a-cihama.ads, a-cidlli.ads, a-chtgop.ads, a-chtgop.adb, a-cdlili.ads, \n\ta-cihase.adb, a-cihase.ads, a-cohase.adb, a-cohase.ads, a-ciorma.ads, \n\ta-coorma.ads, a-ciormu.ads, a-coormu.ads, a-ciorse.ads, a-cohama.ads, \n\ta-cohata.ads, a-convec.adb, a-coinve.ads, a-coinve.adb, a-convec.ads,\n\ta-coorse.ads (Next): Applied pragma Inline.\n\tMake all Containers packages Remote_Types (unless they are already\n\tPure).\n\t(Previous): applied pragma Inline\n\t(Elements_Type): is now a record instead of an array\n\nFrom-SVN: r127441", "tree": {"sha": "0e788af9e046a8d5e85a5e51d6780340ded575ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e788af9e046a8d5e85a5e51d6780340ded575ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f97ccb3a84b27374661fd1f9540efb360d976019", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f97ccb3a84b27374661fd1f9540efb360d976019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f97ccb3a84b27374661fd1f9540efb360d976019", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f97ccb3a84b27374661fd1f9540efb360d976019/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b11e8d6fc0722f739630bfabff7d778faae9f1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11e8d6fc0722f739630bfabff7d778faae9f1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11e8d6fc0722f739630bfabff7d778faae9f1d3"}], "stats": {"total": 968, "additions": 561, "deletions": 407}, "files": [{"sha": "e8a0488b2b4e01a0ccc1ce5378d6d2cc48c4b7c7", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -44,6 +44,7 @@ generic\n \n package Ada.Containers.Doubly_Linked_Lists is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    type List is tagged private;\n    pragma Preelaborable_Initialization (List);\n@@ -204,6 +205,10 @@ package Ada.Containers.Doubly_Linked_Lists is\n    end Generic_Sorting;\n \n private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "94a646e3250f1394bb65a50dee40300a7acb9d58", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,8 +37,10 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Hash_Tables.Generic_Operations is\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Buckets_Type, Buckets_Access);\n+   type Buckets_Allocation is access all Buckets_Type;\n+   --  Used for allocation and deallocation (see New_Buckets and\n+   --  Free_Buckets). This is necessary because Buckets_Access has an empty\n+   --  storage pool.\n \n    ------------\n    -- Adjust --\n@@ -66,7 +68,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       --  source table. This has the benefit that when iterating, elements of\n       --  the target are delivered in the exact same order as for the source.\n \n-      HT.Buckets := new Buckets_Type (Src_Buckets'Range);\n+      HT.Buckets := New_Buckets (Length => Src_Buckets'Length);\n \n       for Src_Index in Src_Buckets'Range loop\n          Src_Node := Src_Buckets (Src_Index);\n@@ -220,7 +222,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    procedure Finalize (HT : in out Hash_Table_Type) is\n    begin\n       Clear (HT);\n-      Free (HT.Buckets);\n+      Free_Buckets (HT.Buckets);\n    end Finalize;\n \n    -----------\n@@ -245,6 +247,21 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       end loop;\n    end First;\n \n+   ------------------\n+   -- Free_Buckets --\n+   ------------------\n+\n+   procedure Free_Buckets (Buckets : in out Buckets_Access) is\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation (Buckets_Type, Buckets_Allocation);\n+\n+   begin\n+      --  Buckets must have been created by New_Buckets. Here, we convert back\n+      --  to the Buckets_Allocation type, and do the free on that.\n+\n+      Free (Buckets_Allocation (Buckets));\n+   end Free_Buckets;\n+\n    ---------------------\n    -- Free_Hash_Table --\n    ---------------------\n@@ -265,16 +282,16 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          end loop;\n       end loop;\n \n-      Free (Buckets);\n+      Free_Buckets (Buckets);\n    end Free_Hash_Table;\n \n    -------------------\n    -- Generic_Equal --\n    -------------------\n \n    function Generic_Equal\n-     (L, R : Hash_Table_Type) return Boolean is\n-\n+     (L, R : Hash_Table_Type) return Boolean\n+   is\n       L_Index : Hash_Type;\n       L_Node  : Node_Access;\n \n@@ -386,9 +403,9 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       if HT.Buckets = null\n         or else HT.Buckets'Length < N\n       then\n-         Free (HT.Buckets);\n+         Free_Buckets (HT.Buckets);\n          NN := Prime_Numbers.To_Prime (N);\n-         HT.Buckets := new Buckets_Type (0 .. NN - 1);\n+         HT.Buckets := New_Buckets (Length => NN);\n       end if;\n \n       for J in 1 .. N loop\n@@ -481,6 +498,20 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       Source.Length := 0;\n    end Move;\n \n+   -----------------\n+   -- New_Buckets --\n+   -----------------\n+\n+   function New_Buckets (Length : Hash_Type) return Buckets_Access is\n+      subtype Rng is Hash_Type range 0 .. Length - 1;\n+\n+   begin\n+      --  Allocate in Buckets_Allocation'Storage_Pool, then convert to\n+      --  Buckets_Access.\n+\n+      return Buckets_Access (Buckets_Allocation'(new Buckets_Type (Rng)));\n+   end New_Buckets;\n+\n    ----------\n    -- Next --\n    ----------\n@@ -521,7 +552,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       if HT.Buckets = null then\n          if N > 0 then\n             NN := Prime_Numbers.To_Prime (N);\n-            HT.Buckets := new Buckets_Type (0 .. NN - 1);\n+            HT.Buckets := New_Buckets (Length => NN);\n          end if;\n \n          return;\n@@ -536,7 +567,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          --  length that corresponds to a prime number.)\n \n          if N = 0 then\n-            Free (HT.Buckets);\n+            Free_Buckets (HT.Buckets);\n             return;\n          end if;\n \n@@ -553,8 +584,8 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          declare\n             X : Buckets_Access := HT.Buckets;\n          begin\n-            HT.Buckets := new Buckets_Type (0 .. NN - 1);\n-            Free (X);\n+            HT.Buckets := New_Buckets (Length => NN);\n+            Free_Buckets (X);\n          end;\n \n          return;\n@@ -595,7 +626,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       end if;\n \n       Rehash : declare\n-         Dst_Buckets : Buckets_Access := new Buckets_Type (0 .. NN - 1);\n+         Dst_Buckets : Buckets_Access := New_Buckets (Length => NN);\n          Src_Buckets : Buckets_Access := HT.Buckets;\n \n          L : Count_Type renames HT.Length;\n@@ -656,7 +687,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n                      end;\n                   end loop;\n \n-                  Free (Dst_Buckets);\n+                  Free_Buckets (Dst_Buckets);\n                   raise Program_Error with\n                     \"hash function raised exception during rehash\";\n             end;\n@@ -667,7 +698,7 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          HT.Buckets := Dst_Buckets;\n          HT.Length := LL;\n \n-         Free (Src_Buckets);\n+         Free_Buckets (Src_Buckets);\n       end Rehash;\n    end Reserve_Capacity;\n "}, {"sha": "9e0581093ed81a71fe0c60d340c09308d164622a", "filename": "gcc/ada/a-chtgop.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-chtgop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-chtgop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -163,4 +163,15 @@ package Ada.Containers.Hash_Tables.Generic_Operations is\n    --  first clears hash table HT, then populates the hash table by calling\n    --  New_Node for each item in Stream.\n \n+   function New_Buckets (Length : Hash_Type) return Buckets_Access;\n+   pragma Inline (New_Buckets);\n+   --  Allocate a new Buckets_Type array with bounds 0..Length-1.\n+\n+   procedure Free_Buckets (Buckets : in out Buckets_Access);\n+   pragma Inline (Free_Buckets);\n+   --  Unchecked_Deallocate Buckets.\n+\n+   --  Note: New_Buckets and Free_Buckets are needed because Buckets_Access has\n+   --  an empty pool.\n+\n end Ada.Containers.Hash_Tables.Generic_Operations;"}, {"sha": "4cde43dd860a0b4b05d2098ac340e27c8934aa87", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,6 +45,7 @@ generic\n \n package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    type List is tagged private;\n    pragma Preelaborable_Initialization (List);\n@@ -195,6 +196,10 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    end Generic_Sorting;\n \n private\n+\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "45d307b3e56f67904b47f48b8b3b0f7a44d12319", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -48,6 +48,7 @@ generic\n \n package Ada.Containers.Indefinite_Hashed_Maps is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    type Map is tagged private;\n    pragma Preelaborable_Initialization (Map);\n@@ -159,6 +160,7 @@ private\n    pragma Inline (Reserve_Capacity);\n    pragma Inline (Has_Element);\n    pragma Inline (Equivalent_Keys);\n+   pragma Inline (Next);\n \n    type Node_Type;\n    type Node_Access is access Node_Type;"}, {"sha": "8de25a84efc6366344b0d599c42fbd06dcf0a691", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -340,7 +340,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       declare\n          Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Length := 0;\n@@ -817,7 +817,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       declare\n          Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Length := 0;\n@@ -1372,7 +1372,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Size : constant Hash_Type :=\n                   Prime_Numbers.To_Prime (Left.Length + Right.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Length := 0;\n@@ -1574,7 +1574,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Size : constant Hash_Type :=\n                   Prime_Numbers.To_Prime (Left.Length + Right.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Iterate_Left : declare"}, {"sha": "52d0441ec2a5f96602aa199b4365363e7472ac4f", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -50,6 +50,7 @@ generic\n \n package Ada.Containers.Indefinite_Hashed_Sets is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    type Set is tagged private;\n    pragma Preelaborable_Initialization (Set);\n@@ -204,6 +205,9 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n    end Generic_Keys;\n \n private\n+\n+   pragma Inline (Next);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "25033a9356d5aafece3219fa6d4370350e0044f0", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -47,6 +47,7 @@ generic\n \n package Ada.Containers.Indefinite_Ordered_Maps is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n@@ -176,6 +177,9 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n \n private\n \n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "fec119b28508227579805e73e1dfb5686d91dee2", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,6 +46,7 @@ generic\n \n package Ada.Containers.Indefinite_Ordered_Multisets is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n@@ -238,6 +239,9 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n private\n \n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "67e383fb9d2b648697e9944e7b748227f3baa769", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,6 +46,7 @@ generic\n \n package Ada.Containers.Indefinite_Ordered_Sets is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n@@ -242,6 +243,9 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n private\n \n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "487944c27990258dfac583fad6eb18f507cfaea6", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -47,6 +47,7 @@ generic\n \n package Ada.Containers.Hashed_Maps is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    type Map is tagged private;\n    pragma Preelaborable_Initialization (Map);\n@@ -164,6 +165,7 @@ private\n    pragma Inline (Reserve_Capacity);\n    pragma Inline (Has_Element);\n    pragma Inline (Equivalent_Keys);\n+   pragma Inline (Next);\n \n    type Node_Type;\n    type Node_Access is access Node_Type;"}, {"sha": "e0db89d5b0c4294e56a1b00f9663d8b2904070a3", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -327,7 +327,7 @@ package body Ada.Containers.Hashed_Sets is\n       declare\n          Size : constant Hash_Type := Prime_Numbers.To_Prime (Left.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Length := 0;\n@@ -753,7 +753,7 @@ package body Ada.Containers.Hashed_Sets is\n       declare\n          Size : constant Hash_Type := Prime_Numbers.To_Prime (Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Length := 0;\n@@ -1248,7 +1248,7 @@ package body Ada.Containers.Hashed_Sets is\n          Size : constant Hash_Type :=\n                   Prime_Numbers.To_Prime (Left.Length + Right.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Length := 0;\n@@ -1426,7 +1426,7 @@ package body Ada.Containers.Hashed_Sets is\n          Size : constant Hash_Type :=\n                   Prime_Numbers.To_Prime (Left.Length + Right.Length);\n       begin\n-         Buckets := new Buckets_Type (0 .. Size - 1);\n+         Buckets := HT_Ops.New_Buckets (Length => Size);\n       end;\n \n       Iterate_Left : declare"}, {"sha": "20e29183aa759a4839cbed8cdc9011580272251d", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -49,6 +49,7 @@ generic\n \n package Ada.Containers.Hashed_Sets is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    type Set is tagged private;\n    pragma Preelaborable_Initialization (Set);\n@@ -203,6 +204,9 @@ package Ada.Containers.Hashed_Sets is\n    end Generic_Keys;\n \n private\n+\n+   pragma Inline (Next);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "983e8c39c26fe1d35adaf14310cb24d31f2692e8", "filename": "gcc/ada/a-cohata.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohata.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,7 @@\n --  containers.\n \n package Ada.Containers.Hash_Tables is\n-   pragma Preelaborate;\n+   pragma Pure;  --  so this can be imported by Remote_Types packages\n \n    generic\n       type Node_Type (<>) is limited private;\n@@ -43,7 +43,8 @@ package Ada.Containers.Hash_Tables is\n    package Generic_Hash_Table_Types is\n       type Buckets_Type is array (Hash_Type range <>) of Node_Access;\n \n-      type Buckets_Access is access Buckets_Type;\n+      type Buckets_Access is access all Buckets_Type;\n+      for Buckets_Access'Storage_Size use 0;  --  so this package can be Pure\n \n       type Hash_Table_Type is tagged record\n          Buckets : Buckets_Access;"}, {"sha": "8233a4e9b907303663387f7320621137abeb319d", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 226, "deletions": 182, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,22 +59,23 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n          declare\n-            RE : Elements_Type renames\n-                   Right.Elements (Index_Type'First .. Right.Last);\n+            RE : Elements_Array renames\n+                   Right.Elements.EA (Index_Type'First .. Right.Last);\n \n             Elements : Elements_Access :=\n-                         new Elements_Type (RE'Range);\n+                         new Elements_Type (Right.Last);\n \n          begin\n-            for I in Elements'Range loop\n+            for I in Elements.EA'Range loop\n                begin\n                   if RE (I) /= null then\n-                     Elements (I) := new Element_Type'(RE (I).all);\n+                     Elements.EA (I) := new Element_Type'(RE (I).all);\n                   end if;\n+\n                exception\n                   when others =>\n                      for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements (J));\n+                        Free (Elements.EA (J));\n                      end loop;\n \n                      Free (Elements);\n@@ -89,22 +90,23 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       if RN = 0 then\n          declare\n-            LE : Elements_Type renames\n-                   Left.Elements (Index_Type'First .. Left.Last);\n+            LE : Elements_Array renames\n+                   Left.Elements.EA (Index_Type'First .. Left.Last);\n \n             Elements : Elements_Access :=\n-                         new Elements_Type (LE'Range);\n+                         new Elements_Type (Left.Last);\n \n          begin\n-            for I in Elements'Range loop\n+            for I in Elements.EA'Range loop\n                begin\n                   if LE (I) /= null then\n-                     Elements (I) := new Element_Type'(LE (I).all);\n+                     Elements.EA (I) := new Element_Type'(LE (I).all);\n                   end if;\n+\n                exception\n                   when others =>\n                      for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements (J));\n+                        Free (Elements.EA (J));\n                      end loop;\n \n                      Free (Elements);\n@@ -134,14 +136,13 @@ package body Ada.Containers.Indefinite_Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            LE : Elements_Type renames\n-                   Left.Elements (Index_Type'First .. Left.Last);\n+            LE : Elements_Array renames\n+                   Left.Elements.EA (Index_Type'First .. Left.Last);\n \n-            RE : Elements_Type renames\n-                   Right.Elements (Index_Type'First .. Right.Last);\n+            RE : Elements_Array renames\n+                   Right.Elements.EA (Index_Type'First .. Right.Last);\n \n-            Elements : Elements_Access :=\n-                         new Elements_Type (Index_Type'First .. Last);\n+            Elements : Elements_Access := new Elements_Type (Last);\n \n             I : Index_Type'Base := No_Index;\n \n@@ -151,12 +152,13 @@ package body Ada.Containers.Indefinite_Vectors is\n \n                begin\n                   if LE (LI) /= null then\n-                     Elements (I) := new Element_Type'(LE (LI).all);\n+                     Elements.EA (I) := new Element_Type'(LE (LI).all);\n                   end if;\n+\n                exception\n                   when others =>\n                      for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements (J));\n+                        Free (Elements.EA (J));\n                      end loop;\n \n                      Free (Elements);\n@@ -169,12 +171,13 @@ package body Ada.Containers.Indefinite_Vectors is\n \n                begin\n                   if RE (RI) /= null then\n-                     Elements (I) := new Element_Type'(RE (RI).all);\n+                     Elements.EA (I) := new Element_Type'(RE (RI).all);\n                   end if;\n+\n                exception\n                   when others =>\n                      for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements (J));\n+                        Free (Elements.EA (J));\n                      end loop;\n \n                      Free (Elements);\n@@ -193,14 +196,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if LN = 0 then\n          declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. Index_Type'First);\n-\n-            Elements : Elements_Access := new Elements_Subtype;\n+            Elements : Elements_Access := new Elements_Type (Index_Type'First);\n \n          begin\n             begin\n-               Elements (Elements'First) := new Element_Type'(Right);\n+               Elements.EA (Index_Type'First) := new Element_Type'(Right);\n             exception\n                when others =>\n                   Free (Elements);\n@@ -228,22 +228,23 @@ package body Ada.Containers.Indefinite_Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            LE : Elements_Type renames\n-                   Left.Elements (Index_Type'First .. Left.Last);\n+            LE : Elements_Array renames\n+                   Left.Elements.EA (Index_Type'First .. Left.Last);\n \n             Elements : Elements_Access :=\n-                        new Elements_Type (Index_Type'First .. Last);\n+                        new Elements_Type (Last);\n \n          begin\n             for I in LE'Range loop\n                begin\n                   if LE (I) /= null then\n-                     Elements (I) := new Element_Type'(LE (I).all);\n+                     Elements.EA (I) := new Element_Type'(LE (I).all);\n                   end if;\n+\n                exception\n                   when others =>\n                      for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements (J));\n+                        Free (Elements.EA (J));\n                      end loop;\n \n                      Free (Elements);\n@@ -252,11 +253,12 @@ package body Ada.Containers.Indefinite_Vectors is\n             end loop;\n \n             begin\n-               Elements (Elements'Last) := new Element_Type'(Right);\n+               Elements.EA (Last) := new Element_Type'(Right);\n+\n             exception\n                when others =>\n-                  for J in Index_Type'First .. Elements'Last - 1 loop\n-                     Free (Elements (J));\n+                  for J in Index_Type'First .. Last - 1 loop\n+                     Free (Elements.EA (J));\n                   end loop;\n \n                   Free (Elements);\n@@ -274,14 +276,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    begin\n       if RN = 0 then\n          declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. Index_Type'First);\n-\n-            Elements : Elements_Access := new Elements_Subtype;\n+            Elements : Elements_Access := new Elements_Type (Index_Type'First);\n \n          begin\n             begin\n-               Elements (Elements'First) := new Element_Type'(Left);\n+               Elements.EA (Index_Type'First) := new Element_Type'(Left);\n             exception\n                when others =>\n                   Free (Elements);\n@@ -309,17 +308,17 @@ package body Ada.Containers.Indefinite_Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            RE : Elements_Type renames\n-                   Right.Elements (Index_Type'First .. Right.Last);\n+            RE : Elements_Array renames\n+                   Right.Elements.EA (Index_Type'First .. Right.Last);\n \n             Elements : Elements_Access :=\n-                         new Elements_Type (Index_Type'First .. Last);\n+                         new Elements_Type (Last);\n \n             I : Index_Type'Base := Index_Type'First;\n \n          begin\n             begin\n-               Elements (I) := new Element_Type'(Left);\n+               Elements.EA (I) := new Element_Type'(Left);\n             exception\n                when others =>\n                   Free (Elements);\n@@ -331,12 +330,13 @@ package body Ada.Containers.Indefinite_Vectors is\n \n                begin\n                   if RE (RI) /= null then\n-                     Elements (I) := new Element_Type'(RE (RI).all);\n+                     Elements.EA (I) := new Element_Type'(RE (RI).all);\n                   end if;\n+\n                exception\n                   when others =>\n                      for J in Index_Type'First .. I - 1 loop\n-                        Free (Elements (J));\n+                        Free (Elements.EA (J));\n                      end loop;\n \n                      Free (Elements);\n@@ -356,31 +356,28 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         Last : constant Index_Type := Index_Type'First + 1;\n-\n-         subtype ET is Elements_Type (Index_Type'First .. Last);\n-\n-         Elements : Elements_Access := new ET;\n+         Last     : constant Index_Type := Index_Type'First + 1;\n+         Elements : Elements_Access := new Elements_Type (Last);\n \n       begin\n          begin\n-            Elements (Elements'First) := new Element_Type'(Left);\n+            Elements.EA (Index_Type'First) := new Element_Type'(Left);\n          exception\n             when others =>\n                Free (Elements);\n                raise;\n          end;\n \n          begin\n-            Elements (Elements'Last) := new Element_Type'(Right);\n+            Elements.EA (Last) := new Element_Type'(Right);\n          exception\n             when others =>\n-               Free (Elements (Elements'First));\n+               Free (Elements.EA (Index_Type'First));\n                Free (Elements);\n                raise;\n          end;\n \n-         return (Controlled with Elements, Elements'Last, 0, 0);\n+         return (Controlled with Elements, Last, 0, 0);\n       end;\n    end \"&\";\n \n@@ -399,15 +396,15 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       for J in Index_Type'First .. Left.Last loop\n-         if Left.Elements (J) = null then\n-            if Right.Elements (J) /= null then\n+         if Left.Elements.EA (J) = null then\n+            if Right.Elements.EA (J) /= null then\n                return False;\n             end if;\n \n-         elsif Right.Elements (J) = null then\n+         elsif Right.Elements.EA (J) = null then\n             return False;\n \n-         elsif Left.Elements (J).all /= Right.Elements (J).all then\n+         elsif Left.Elements.EA (J).all /= Right.Elements.EA (J).all then\n             return False;\n          end if;\n       end loop;\n@@ -427,20 +424,21 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         E : Elements_Type renames Container.Elements.all;\n          L : constant Index_Type := Container.Last;\n+         E : Elements_Array renames\n+               Container.Elements.EA (Index_Type'First .. L);\n \n       begin\n          Container.Elements := null;\n          Container.Last := No_Index;\n          Container.Busy := 0;\n          Container.Lock := 0;\n \n-         Container.Elements := new Elements_Type (Index_Type'First .. L);\n+         Container.Elements := new Elements_Type (L);\n \n-         for I in Container.Elements'Range loop\n+         for I in E'Range loop\n             if E (I) /= null then\n-               Container.Elements (I) := new Element_Type'(E (I).all);\n+               Container.Elements.EA (I) := new Element_Type'(E (I).all);\n             end if;\n \n             Container.Last := I;\n@@ -499,7 +497,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          return 0;\n       end if;\n \n-      return Container.Elements'Length;\n+      return Container.Elements.EA'Length;\n    end Capacity;\n \n    -----------\n@@ -515,9 +513,9 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       while Container.Last >= Index_Type'First loop\n          declare\n-            X : Element_Access := Container.Elements (Container.Last);\n+            X : Element_Access := Container.Elements.EA (Container.Last);\n          begin\n-            Container.Elements (Container.Last) := null;\n+            Container.Elements.EA (Container.Last) := null;\n             Container.Last := Container.Last - 1;\n             Free (X);\n          end;\n@@ -576,7 +574,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          N      : constant Int'Base := Int'Min (Count1, Count2);\n \n          J_As_Int : constant Int'Base := Index_As_Int + N;\n-         E        : Elements_Type renames Container.Elements.all;\n+         E        : Elements_Array renames Container.Elements.EA;\n \n       begin\n          if J_As_Int > Old_Last_As_Int then\n@@ -637,7 +635,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       Delete (Container, Position.Index, Count);\n \n-      Position := No_Element;  -- See comment in a-convec.adb\n+      Position := No_Element;\n    end Delete;\n \n    ------------------\n@@ -684,7 +682,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         E : Elements_Type renames Container.Elements.all;\n+         E : Elements_Array renames Container.Elements.EA;\n \n       begin\n          for Indx in 1 .. Count_Type'Min (Count, N) loop\n@@ -715,7 +713,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         EA : constant Element_Access := Container.Elements (Index);\n+         EA : constant Element_Access := Container.Elements.EA (Index);\n \n       begin\n          if EA = null then\n@@ -732,7 +730,21 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      return Element (Position.Container.all, Position.Index);\n+      if Position.Index > Position.Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      declare\n+         EA : constant Element_Access :=\n+                Position.Container.Elements.EA (Position.Index);\n+\n+      begin\n+         if EA = null then\n+            raise Constraint_Error with \"element is empty\";\n+         end if;\n+\n+         return EA.all;\n+      end;\n    end Element;\n \n    --------------\n@@ -772,8 +784,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       for J in Position.Index .. Container.Last loop\n-         if Container.Elements (J) /= null\n-           and then Container.Elements (J).all = Item\n+         if Container.Elements.EA (J) /= null\n+           and then Container.Elements.EA (J).all = Item\n          then\n             return (Container'Unchecked_Access, J);\n          end if;\n@@ -793,8 +805,8 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       for Indx in Index .. Container.Last loop\n-         if Container.Elements (Indx) /= null\n-           and then Container.Elements (Indx).all = Item\n+         if Container.Elements.EA (Indx) /= null\n+           and then Container.Elements.EA (Indx).all = Item\n          then\n             return Indx;\n          end if;\n@@ -822,7 +834,21 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function First_Element (Container : Vector) return Element_Type is\n    begin\n-      return Element (Container, Index_Type'First);\n+      if Container.Last = No_Index then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      declare\n+         EA : constant Element_Access :=\n+                Container.Elements.EA (Index_Type'First);\n+\n+      begin\n+         if EA = null then\n+            raise Constraint_Error with \"first element is empty\";\n+         end if;\n+\n+         return EA.all;\n+      end;\n    end First_Element;\n \n    -----------------\n@@ -874,7 +900,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n          declare\n-            E : Elements_Type renames Container.Elements.all;\n+            E : Elements_Array renames Container.Elements.EA;\n          begin\n             for I in Index_Type'First .. Container.Last - 1 loop\n                if Is_Less (E (I + 1), E (I)) then\n@@ -891,8 +917,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       -----------\n \n       procedure Merge (Target, Source : in out Vector) is\n-         I : Index_Type'Base := Target.Last;\n-         J : Index_Type'Base;\n+         I, J : Index_Type'Base;\n \n       begin\n          if Target.Last < Index_Type'First then\n@@ -913,23 +938,24 @@ package body Ada.Containers.Indefinite_Vectors is\n               \"attempt to tamper with elements (vector is busy)\";\n          end if;\n \n+         I := Target.Last;  -- original value (before Set_Length)\n          Target.Set_Length (Length (Target) + Length (Source));\n \n-         J := Target.Last;\n+         J := Target.Last;  -- new value (after Set_Length)\n          while Source.Last >= Index_Type'First loop\n             pragma Assert\n               (Source.Last <= Index_Type'First\n                  or else not (Is_Less\n-                                (Source.Elements (Source.Last),\n-                                 Source.Elements (Source.Last - 1))));\n+                                (Source.Elements.EA (Source.Last),\n+                                 Source.Elements.EA (Source.Last - 1))));\n \n             if I < Index_Type'First then\n                declare\n-                  Src : Elements_Type renames\n-                    Source.Elements (Index_Type'First .. Source.Last);\n+                  Src : Elements_Array renames\n+                    Source.Elements.EA (Index_Type'First .. Source.Last);\n \n                begin\n-                  Target.Elements (Index_Type'First .. J) := Src;\n+                  Target.Elements.EA (Index_Type'First .. J) := Src;\n                   Src := (others => null);\n                end;\n \n@@ -940,21 +966,21 @@ package body Ada.Containers.Indefinite_Vectors is\n             pragma Assert\n               (I <= Index_Type'First\n                  or else not (Is_Less\n-                                (Target.Elements (I),\n-                                 Target.Elements (I - 1))));\n+                                (Target.Elements.EA (I),\n+                                 Target.Elements.EA (I - 1))));\n \n             declare\n-               Src : Element_Access renames Source.Elements (Source.Last);\n-               Tgt : Element_Access renames Target.Elements (I);\n+               Src : Element_Access renames Source.Elements.EA (Source.Last);\n+               Tgt : Element_Access renames Target.Elements.EA (I);\n \n             begin\n                if Is_Less (Src, Tgt) then\n-                  Target.Elements (J) := Tgt;\n+                  Target.Elements.EA (J) := Tgt;\n                   Tgt := null;\n                   I := I - 1;\n \n                else\n-                  Target.Elements (J) := Src;\n+                  Target.Elements.EA (J) := Src;\n                   Src := null;\n                   Source.Last := Source.Last - 1;\n                end if;\n@@ -974,7 +1000,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             new Generic_Array_Sort\n              (Index_Type   => Index_Type,\n               Element_Type => Element_Access,\n-              Array_Type   => Elements_Type,\n+              Array_Type   => Elements_Array,\n               \"<\"          => Is_Less);\n \n       --  Start of processing for Sort\n@@ -989,7 +1015,7 @@ package body Ada.Containers.Indefinite_Vectors is\n               \"attempt to tamper with cursors (vector is locked)\";\n          end if;\n \n-         Sort (Container.Elements (Index_Type'First .. Container.Last));\n+         Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n       end Sort;\n \n    end Generic_Sorting;\n@@ -1073,22 +1099,20 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Elements = null then\n-         Container.Elements :=\n-           new Elements_Type (Index_Type'First .. New_Last);\n-\n+         Container.Elements := new Elements_Type (New_Last);\n          Container.Last := No_Index;\n \n-         for J in Container.Elements'Range loop\n-            Container.Elements (J) := new Element_Type'(New_Item);\n+         for J in Container.Elements.EA'Range loop\n+            Container.Elements.EA (J) := new Element_Type'(New_Item);\n             Container.Last := J;\n          end loop;\n \n          return;\n       end if;\n \n-      if New_Last <= Container.Elements'Last then\n+      if New_Last <= Container.Elements.Last then\n          declare\n-            E : Elements_Type renames Container.Elements.all;\n+            E : Elements_Array renames Container.Elements.EA;\n \n          begin\n             if Before <= Container.Last then\n@@ -1131,7 +1155,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          C, CC : UInt;\n \n       begin\n-         C := UInt'Max (1, Container.Elements'Length);\n+         C := UInt'Max (1, Container.Elements.EA'Length);  -- ???\n          while C < New_Length loop\n             if C > UInt'Last / 2 then\n                C := UInt'Last;\n@@ -1163,7 +1187,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                          Index_Type (First + UInt'Pos (C) - Int'(1));\n \n          begin\n-            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+            Dst := new Elements_Type (Dst_Last);\n          end;\n       end;\n \n@@ -1177,17 +1201,17 @@ package body Ada.Containers.Indefinite_Vectors is\n             Src : Elements_Access := Container.Elements;\n \n          begin\n-            Dst (Index_Type'First .. Before - 1) :=\n-              Src (Index_Type'First .. Before - 1);\n+            Dst.EA (Index_Type'First .. Before - 1) :=\n+              Src.EA (Index_Type'First .. Before - 1);\n \n-            Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+            Dst.EA (Index .. New_Last) := Src.EA (Before .. Container.Last);\n \n             Container.Elements := Dst;\n             Container.Last := New_Last;\n             Free (Src);\n \n             for J in Before .. Index - 1 loop\n-               Dst (J) := new Element_Type'(New_Item);\n+               Dst.EA (J) := new Element_Type'(New_Item);\n             end loop;\n          end;\n \n@@ -1196,14 +1220,14 @@ package body Ada.Containers.Indefinite_Vectors is\n             Src : Elements_Access := Container.Elements;\n \n          begin\n-            Dst (Index_Type'First .. Container.Last) :=\n-              Src (Index_Type'First .. Container.Last);\n+            Dst.EA (Index_Type'First .. Container.Last) :=\n+              Src.EA (Index_Type'First .. Container.Last);\n \n             Container.Elements := Dst;\n             Free (Src);\n \n             for J in Before .. New_Last loop\n-               Dst (J) := new Element_Type'(New_Item);\n+               Dst.EA (J) := new Element_Type'(New_Item);\n                Container.Last := J;\n             end loop;\n          end;\n@@ -1242,16 +1266,19 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          Dst_Last : constant Index_Type := Index_Type (Dst_Last_As_Int);\n \n-         Dst : Elements_Type renames\n-                 Container.Elements (Before .. Dst_Last);\n+         Dst : Elements_Array renames\n+                 Container.Elements.EA (Before .. Dst_Last);\n \n          Dst_Index : Index_Type'Base := Before - 1;\n \n       begin\n          if Container'Address /= New_Item'Address then\n             declare\n-               Src : Elements_Type renames\n-                       New_Item.Elements (Index_Type'First .. New_Item.Last);\n+               subtype Src_Index_Subtype is Index_Type'Base range\n+                 Index_Type'First .. New_Item.Last;\n+\n+               Src : Elements_Array renames\n+                       New_Item.Elements.EA (Src_Index_Subtype);\n \n             begin\n                for Src_Index in Src'Range loop\n@@ -1270,8 +1297,8 @@ package body Ada.Containers.Indefinite_Vectors is\n             subtype Src_Index_Subtype is Index_Type'Base range\n               Index_Type'First .. Before - 1;\n \n-            Src : Elements_Type renames\n-                    Container.Elements (Src_Index_Subtype);\n+            Src : Elements_Array renames\n+                    Container.Elements.EA (Src_Index_Subtype);\n \n          begin\n             for Src_Index in Src'Range loop\n@@ -1291,8 +1318,8 @@ package body Ada.Containers.Indefinite_Vectors is\n             subtype Src_Index_Subtype is Index_Type'Base range\n               Dst_Last + 1 .. Container.Last;\n \n-            Src : Elements_Type renames\n-                    Container.Elements (Src_Index_Subtype);\n+            Src : Elements_Array renames\n+                    Container.Elements.EA (Src_Index_Subtype);\n \n          begin\n             for Src_Index in Src'Range loop\n@@ -1535,16 +1562,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Elements = null then\n-         Container.Elements :=\n-           new Elements_Type (Index_Type'First .. New_Last);\n-\n+         Container.Elements := new Elements_Type (New_Last);\n          Container.Last := New_Last;\n          return;\n       end if;\n \n-      if New_Last <= Container.Elements'Last then\n+      if New_Last <= Container.Elements.Last then\n          declare\n-            E : Elements_Type renames Container.Elements.all;\n+            E : Elements_Array renames Container.Elements.EA;\n \n          begin\n             if Before <= Container.Last then\n@@ -1569,7 +1594,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          C, CC : UInt;\n \n       begin\n-         C := UInt'Max (1, Container.Elements'Length);\n+         C := UInt'Max (1, Container.Elements.EA'Length);  -- ???\n          while C < New_Length loop\n             if C > UInt'Last / 2 then\n                C := UInt'Last;\n@@ -1601,7 +1626,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                          Index_Type (First + UInt'Pos (C) - 1);\n \n          begin\n-            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+            Dst := new Elements_Type (Dst_Last);\n          end;\n       end;\n \n@@ -1617,15 +1642,15 @@ package body Ada.Containers.Indefinite_Vectors is\n                Index : constant Index_Type := Index_Type (Index_As_Int);\n \n             begin\n-               Dst (Index_Type'First .. Before - 1) :=\n-                 Src (Index_Type'First .. Before - 1);\n+               Dst.EA (Index_Type'First .. Before - 1) :=\n+                 Src.EA (Index_Type'First .. Before - 1);\n \n-               Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+               Dst.EA (Index .. New_Last) := Src.EA (Before .. Container.Last);\n             end;\n \n          else\n-            Dst (Index_Type'First .. Container.Last) :=\n-              Src (Index_Type'First .. Container.Last);\n+            Dst.EA (Index_Type'First .. Container.Last) :=\n+              Src.EA (Index_Type'First .. Container.Last);\n          end if;\n \n          Container.Elements := Dst;\n@@ -1735,7 +1760,21 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function Last_Element (Container : Vector) return Element_Type is\n    begin\n-      return Element (Container, Container.Last);\n+      if Container.Last = No_Index then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      declare\n+         EA : constant Element_Access :=\n+                Container.Elements.EA (Container.Last);\n+\n+      begin\n+         if EA = null then\n+            raise Constraint_Error with \"last element is empty\";\n+         end if;\n+\n+         return EA.all;\n+      end;\n    end Last_Element;\n \n    ----------------\n@@ -1894,15 +1933,15 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if V.Elements (Index) = null then\n+      if V.Elements.EA (Index) = null then\n          raise Constraint_Error with \"element is null\";\n       end if;\n \n       B := B + 1;\n       L := L + 1;\n \n       begin\n-         Process (V.Elements (Index).all);\n+         Process (V.Elements.EA (Index).all);\n       exception\n          when others =>\n             L := L - 1;\n@@ -1954,7 +1993,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          Boolean'Read (Stream, B);\n \n          if B then\n-            Container.Elements (Last) :=\n+            Container.Elements.EA (Last) :=\n               new Element_Type'(Element_Type'Input (Stream));\n          end if;\n \n@@ -1990,9 +2029,9 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         X : Element_Access := Container.Elements (Index);\n+         X : Element_Access := Container.Elements.EA (Index);\n       begin\n-         Container.Elements (Index) := new Element_Type'(New_Item);\n+         Container.Elements.EA (Index) := new Element_Type'(New_Item);\n          Free (X);\n       end;\n    end Replace_Element;\n@@ -2011,7 +2050,21 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      Replace_Element (Container, Position.Index, New_Item);\n+      if Position.Index > Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n+      end if;\n+\n+      declare\n+         X : Element_Access := Container.Elements.EA (Position.Index);\n+      begin\n+         Container.Elements.EA (Position.Index) := new Element_Type'(New_Item);\n+         Free (X);\n+      end;\n    end Replace_Element;\n \n    ----------------------\n@@ -2034,7 +2087,7 @@ package body Ada.Containers.Indefinite_Vectors is\n                Free (X);\n             end;\n \n-         elsif N < Container.Elements'Length then\n+         elsif N < Container.Elements.EA'Length then\n             if Container.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n@@ -2044,16 +2097,13 @@ package body Ada.Containers.Indefinite_Vectors is\n                subtype Array_Index_Subtype is Index_Type'Base range\n                  Index_Type'First .. Container.Last;\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Array_Index_Subtype);\n-\n-               subtype Array_Subtype is\n-                 Elements_Type (Array_Index_Subtype);\n+               Src : Elements_Array renames\n+                       Container.Elements.EA (Array_Index_Subtype);\n \n                X : Elements_Access := Container.Elements;\n \n             begin\n-               Container.Elements := new Array_Subtype'(Src);\n+               Container.Elements := new Elements_Type'(Container.Last, Src);\n                Free (X);\n             end;\n          end if;\n@@ -2074,19 +2124,16 @@ package body Ada.Containers.Indefinite_Vectors is\n             declare\n                Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-               subtype Array_Subtype is\n-                 Elements_Type (Index_Type'First .. Last);\n-\n             begin\n-               Container.Elements := new Array_Subtype;\n+               Container.Elements := new Elements_Type (Last);\n             end;\n          end;\n \n          return;\n       end if;\n \n       if Capacity <= N then\n-         if N < Container.Elements'Length then\n+         if N < Container.Elements.EA'Length then\n             if Container.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n@@ -2096,24 +2143,21 @@ package body Ada.Containers.Indefinite_Vectors is\n                subtype Array_Index_Subtype is Index_Type'Base range\n                  Index_Type'First .. Container.Last;\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Array_Index_Subtype);\n-\n-               subtype Array_Subtype is\n-                 Elements_Type (Array_Index_Subtype);\n+               Src : Elements_Array renames\n+                       Container.Elements.EA (Array_Index_Subtype);\n \n                X : Elements_Access := Container.Elements;\n \n             begin\n-               Container.Elements := new Array_Subtype'(Src);\n+               Container.Elements := new Elements_Type'(Container.Last, Src);\n                Free (X);\n             end;\n          end if;\n \n          return;\n       end if;\n \n-      if Capacity = Container.Elements'Length then\n+      if Capacity = Container.Elements.EA'Length then\n          return;\n       end if;\n \n@@ -2133,21 +2177,20 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n+            X    : Elements_Access := Container.Elements;\n \n-            subtype Array_Subtype is\n-              Elements_Type (Index_Type'First .. Last);\n-\n-            X : Elements_Access := Container.Elements;\n+            subtype Index_Subtype is Index_Type'Base range\n+              Index_Type'First .. Container.Last;\n \n          begin\n-            Container.Elements := new Array_Subtype;\n+            Container.Elements := new Elements_Type (Last);\n \n             declare\n-               Src : Elements_Type renames\n-                       X (Index_Type'First .. Container.Last);\n+               Src : Elements_Array renames\n+                       X.EA (Index_Subtype);\n \n-               Tgt : Elements_Type renames\n-                       Container.Elements (Index_Type'First .. Container.Last);\n+               Tgt : Elements_Array renames\n+                       Container.Elements.EA (Index_Subtype);\n \n             begin\n                Tgt := Src;\n@@ -2176,7 +2219,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          I : Index_Type;\n          J : Index_Type;\n-         E : Elements_Type renames Container.Elements.all;\n+         E : Elements_Array renames Container.Elements.EA;\n \n       begin\n          I := Index_Type'First;\n@@ -2223,8 +2266,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements (Indx) /= null\n-           and then Container.Elements (Indx).all = Item\n+         if Container.Elements.EA (Indx) /= null\n+           and then Container.Elements.EA (Indx).all = Item\n          then\n             return (Container'Unchecked_Access, Indx);\n          end if;\n@@ -2252,8 +2295,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements (Indx) /= null\n-           and then Container.Elements (Indx).all = Item\n+         if Container.Elements.EA (Indx) /= null\n+           and then Container.Elements.EA (Indx).all = Item\n          then\n             return Indx;\n          end if;\n@@ -2313,10 +2356,10 @@ package body Ada.Containers.Indefinite_Vectors is\n          for Index in 1 .. N - Length loop\n             declare\n                J : constant Index_Type := Container.Last;\n-               X : Element_Access := Container.Elements (J);\n+               X : Element_Access := Container.Elements.EA (J);\n \n             begin\n-               Container.Elements (J) := null;\n+               Container.Elements.EA (J) := null;\n                Container.Last := J - 1;\n                Free (X);\n             end;\n@@ -2365,8 +2408,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         EI : Element_Access renames Container.Elements (I);\n-         EJ : Element_Access renames Container.Elements (J);\n+         EI : Element_Access renames Container.Elements.EA (I);\n+         EJ : Element_Access renames Container.Elements.EA (J);\n \n          EI_Copy : constant Element_Access := EI;\n \n@@ -2455,7 +2498,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type (Index_Type'First .. Last);\n+         Elements := new Elements_Type (Last);\n \n          return (Controlled with Elements, Last, 0, 0);\n       end;\n@@ -2482,20 +2525,21 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type (Index_Type'First .. Last);\n+         Elements := new Elements_Type (Last);\n \n          Last := Index_Type'First;\n \n          begin\n             loop\n-               Elements (Last) := new Element_Type'(New_Item);\n-               exit when Last = Elements'Last;\n+               Elements.EA (Last) := new Element_Type'(New_Item);\n+               exit when Last = Elements.Last;\n                Last := Last + 1;\n             end loop;\n+\n          exception\n             when others =>\n                for J in Index_Type'First .. Last - 1 loop\n-                  Free (Elements (J));\n+                  Free (Elements.EA (J));\n                end loop;\n \n                Free (Elements);\n@@ -2523,15 +2567,15 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      if Container.Elements (Index) = null then\n+      if Container.Elements.EA (Index) = null then\n          raise Constraint_Error with \"element is null\";\n       end if;\n \n       B := B + 1;\n       L := L + 1;\n \n       begin\n-         Process (Container.Elements (Index).all);\n+         Process (Container.Elements.EA (Index).all);\n       exception\n          when others =>\n             L := L - 1;\n@@ -2578,7 +2622,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         E : Elements_Type renames Container.Elements.all;\n+         E : Elements_Array renames Container.Elements.EA;\n \n       begin\n          for Indx in Index_Type'First .. Container.Last loop"}, {"sha": "0026272d10523bff79582519106170df4a0645bc", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,8 +33,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Finalization;\n-with Ada.Streams;\n+private with Ada.Finalization;\n+private with Ada.Streams;\n \n generic\n    type Index_Type is range <>;\n@@ -44,6 +44,7 @@ generic\n \n package Ada.Containers.Indefinite_Vectors is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    subtype Extended_Index is Index_Type'Base\n      range Index_Type'First - 1 ..\n@@ -301,12 +302,17 @@ private\n    pragma Inline (Update_Element);\n    pragma Inline (Replace_Element);\n    pragma Inline (Contains);\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n \n    type Element_Access is access Element_Type;\n \n-   type Elements_Type is array (Index_Type range <>) of Element_Access;\n+   type Elements_Array is array (Index_Type range <>) of Element_Access;\n+   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   function \"=\" (L, R : Elements_Type) return Boolean is abstract;\n+   type Elements_Type (Last : Index_Type) is limited record\n+      EA : Elements_Array (Index_Type'First .. Last);\n+   end record;\n \n    type Elements_Access is access Elements_Type;\n \n@@ -319,8 +325,10 @@ private\n       Lock     : Natural := 0;\n    end record;\n \n+   overriding\n    procedure Adjust (Container : in out Vector);\n \n+   overriding\n    procedure Finalize (Container : in out Vector);\n \n    use Ada.Streams;"}, {"sha": "64c2a16aa6eccc6f5090a61af5784bfc0e880bd9", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 176, "deletions": 172, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,11 +57,11 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          declare\n-            RE : Elements_Type renames\n-                   Right.Elements (Index_Type'First .. Right.Last);\n+            RE : Elements_Array renames\n+                   Right.Elements.EA (Index_Type'First .. Right.Last);\n \n             Elements : constant Elements_Access :=\n-                         new Elements_Type'(RE);\n+                         new Elements_Type'(Right.Last, RE);\n \n          begin\n             return (Controlled with Elements, Right.Last, 0, 0);\n@@ -70,11 +70,11 @@ package body Ada.Containers.Vectors is\n \n       if RN = 0 then\n          declare\n-            LE : Elements_Type renames\n-                   Left.Elements (Index_Type'First .. Left.Last);\n+            LE : Elements_Array renames\n+                   Left.Elements.EA (Index_Type'First .. Left.Last);\n \n             Elements : constant Elements_Access :=\n-                         new Elements_Type'(LE);\n+                         new Elements_Type'(Left.Last, LE);\n \n          begin\n             return (Controlled with Elements, Left.Last, 0, 0);\n@@ -100,14 +100,14 @@ package body Ada.Containers.Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            LE : Elements_Type renames\n-                   Left.Elements (Index_Type'First .. Left.Last);\n+            LE : Elements_Array renames\n+                   Left.Elements.EA (Index_Type'First .. Left.Last);\n \n-            RE : Elements_Type renames\n-                   Right.Elements (Index_Type'First .. Right.Last);\n+            RE : Elements_Array renames\n+                   Right.Elements.EA (Index_Type'First .. Right.Last);\n \n             Elements : constant Elements_Access :=\n-                         new Elements_Type'(LE & RE);\n+                         new Elements_Type'(Last, LE & RE);\n \n          begin\n             return (Controlled with Elements, Last, 0, 0);\n@@ -121,11 +121,10 @@ package body Ada.Containers.Vectors is\n    begin\n       if LN = 0 then\n          declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. Index_Type'First);\n-\n             Elements : constant Elements_Access :=\n-                         new Elements_Subtype'(others => Right);\n+                         new Elements_Type'\n+                               (Last => Index_Type'First,\n+                                EA   => (others => Right));\n \n          begin\n             return (Controlled with Elements, Index_Type'First, 0, 0);\n@@ -149,12 +148,13 @@ package body Ada.Containers.Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            LE : Elements_Type renames\n-                   Left.Elements (Index_Type'First .. Left.Last);\n-\n-            subtype ET is Elements_Type (Index_Type'First .. Last);\n+            LE : Elements_Array renames\n+                   Left.Elements.EA (Index_Type'First .. Left.Last);\n \n-            Elements : constant Elements_Access := new ET'(LE & Right);\n+            Elements : constant Elements_Access :=\n+                         new Elements_Type'\n+                               (Last => Last,\n+                                EA   => LE & Right);\n \n          begin\n             return (Controlled with Elements, Last, 0, 0);\n@@ -168,11 +168,10 @@ package body Ada.Containers.Vectors is\n    begin\n       if RN = 0 then\n          declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. Index_Type'First);\n-\n             Elements : constant Elements_Access :=\n-                         new Elements_Subtype'(others => Left);\n+                         new Elements_Type'\n+                               (Last => Index_Type'First,\n+                                EA   => (others => Left));\n \n          begin\n             return (Controlled with Elements, Index_Type'First, 0, 0);\n@@ -196,12 +195,13 @@ package body Ada.Containers.Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            RE : Elements_Type renames\n-                   Right.Elements (Index_Type'First .. Right.Last);\n+            RE : Elements_Array renames\n+                   Right.Elements.EA (Index_Type'First .. Right.Last);\n \n-            subtype ET is Elements_Type (Index_Type'First .. Last);\n-\n-            Elements : constant Elements_Access := new ET'(Left & RE);\n+            Elements : constant Elements_Access :=\n+                         new Elements_Type'\n+                               (Last => Last,\n+                                EA   => Left & RE);\n \n          begin\n             return (Controlled with Elements, Last, 0, 0);\n@@ -218,9 +218,10 @@ package body Ada.Containers.Vectors is\n       declare\n          Last : constant Index_Type := Index_Type'First + 1;\n \n-         subtype ET is Elements_Type (Index_Type'First .. Last);\n-\n-         Elements : constant Elements_Access := new ET'(Left, Right);\n+         Elements : constant Elements_Access :=\n+                      new Elements_Type'\n+                            (Last => Last,\n+                             EA   => (Left, Right));\n \n       begin\n          return (Controlled with Elements, Last, 0, 0);\n@@ -242,7 +243,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       for J in Index_Type range Index_Type'First .. Left.Last loop\n-         if Left.Elements (J) /= Right.Elements (J) then\n+         if Left.Elements.EA (J) /= Right.Elements.EA (J) then\n             return False;\n          end if;\n       end loop;\n@@ -262,15 +263,17 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         E : constant Elements_Access := Container.Elements;\n-         L : constant Index_Type := Container.Last;\n+         L  : constant Index_Type := Container.Last;\n+         EA : Elements_Array renames\n+                Container.Elements.EA (Index_Type'First .. L);\n \n       begin\n          Container.Elements := null;\n          Container.Last := No_Index;\n          Container.Busy := 0;\n          Container.Lock := 0;\n-         Container.Elements := new Elements_Type'(E (Index_Type'First .. L));\n+\n+         Container.Elements := new Elements_Type'(L, EA);\n          Container.Last := L;\n       end;\n    end Adjust;\n@@ -326,7 +329,7 @@ package body Ada.Containers.Vectors is\n          return 0;\n       end if;\n \n-      return Container.Elements'Length;\n+      return Container.Elements.EA'Length;\n    end Capacity;\n \n    -----------\n@@ -402,15 +405,15 @@ package body Ada.Containers.Vectors is\n \n          else\n             declare\n-               J : constant Index_Type := Index_Type (J_As_Int);\n-               E : Elements_Type renames Container.Elements.all;\n+               J  : constant Index_Type := Index_Type (J_As_Int);\n+               EA : Elements_Array renames Container.Elements.EA;\n \n                New_Last_As_Int : constant Int'Base := Old_Last_As_Int - N;\n                New_Last        : constant Index_Type :=\n                                    Index_Type (New_Last_As_Int);\n \n             begin\n-               E (Index .. New_Last) := E (J .. Container.Last);\n+               EA (Index .. New_Last) := EA (J .. Container.Last);\n                Container.Last := New_Last;\n             end;\n          end if;\n@@ -436,17 +439,6 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       Delete (Container, Position.Index, Count);\n-\n-      --  This is the old behavior, prior to the York API (2005/06):\n-\n-      --  if Position.Index <= Container.Last then\n-      --    Position := (Container'Unchecked_Access, Position.Index);\n-      --  else\n-      --    Position := No_Element;\n-      --  end if;\n-\n-      --  This is the behavior specified by the York API:\n-\n       Position := No_Element;\n    end Delete;\n \n@@ -513,7 +505,7 @@ package body Ada.Containers.Vectors is\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      return Container.Elements (Index);\n+      return Container.Elements.EA (Index);\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n@@ -522,7 +514,11 @@ package body Ada.Containers.Vectors is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      return Element (Position.Container.all, Position.Index);\n+      if Position.Index > Position.Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      return Position.Container.Elements.EA (Position.Index);\n    end Element;\n \n    --------------\n@@ -564,7 +560,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       for J in Position.Index .. Container.Last loop\n-         if Container.Elements (J) = Item then\n+         if Container.Elements.EA (J) = Item then\n             return (Container'Unchecked_Access, J);\n          end if;\n       end loop;\n@@ -583,7 +579,7 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       for Indx in Index .. Container.Last loop\n-         if Container.Elements (Indx) = Item then\n+         if Container.Elements.EA (Indx) = Item then\n             return Indx;\n          end if;\n       end loop;\n@@ -610,7 +606,11 @@ package body Ada.Containers.Vectors is\n \n    function First_Element (Container : Vector) return Element_Type is\n    begin\n-      return Element (Container, Index_Type'First);\n+      if Container.Last = No_Index then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      return Container.Elements.EA (Index_Type'First);\n    end First_Element;\n \n    -----------------\n@@ -640,10 +640,10 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          declare\n-            E : Elements_Type renames Container.Elements.all;\n+            EA : Elements_Array renames Container.Elements.EA;\n          begin\n             for I in Index_Type'First .. Container.Last - 1 loop\n-               if E (I + 1) < E (I) then\n+               if EA (I + 1) < EA (I) then\n                   return False;\n                end if;\n             end loop;\n@@ -681,35 +681,40 @@ package body Ada.Containers.Vectors is\n \n          Target.Set_Length (Length (Target) + Length (Source));\n \n-         J := Target.Last;\n-         while Source.Last >= Index_Type'First loop\n-            pragma Assert (Source.Last <= Index_Type'First\n-                             or else not (Source.Elements (Source.Last) <\n-                                          Source.Elements (Source.Last - 1)));\n-\n-            if I < Index_Type'First then\n-               Target.Elements (Index_Type'First .. J) :=\n-                 Source.Elements (Index_Type'First .. Source.Last);\n+         declare\n+            TA : Elements_Array renames Target.Elements.EA;\n+            SA : Elements_Array renames Source.Elements.EA;\n \n-               Source.Last := No_Index;\n-               return;\n-            end if;\n+         begin\n+            J := Target.Last;\n+            while Source.Last >= Index_Type'First loop\n+               pragma Assert (Source.Last <= Index_Type'First\n+                                or else not (SA (Source.Last) <\n+                                             SA (Source.Last - 1)));\n+\n+               if I < Index_Type'First then\n+                  TA (Index_Type'First .. J) :=\n+                    SA (Index_Type'First .. Source.Last);\n+\n+                  Source.Last := No_Index;\n+                  return;\n+               end if;\n \n-            pragma Assert (I <= Index_Type'First\n-                             or else not (Target.Elements (I) <\n-                                          Target.Elements (I - 1)));\n+               pragma Assert (I <= Index_Type'First\n+                                or else not (TA (I) < TA (I - 1)));\n \n-            if Source.Elements (Source.Last) < Target.Elements (I) then\n-               Target.Elements (J) := Target.Elements (I);\n-               I := I - 1;\n+               if SA (Source.Last) < TA (I) then\n+                  TA (J) := TA (I);\n+                  I := I - 1;\n \n-            else\n-               Target.Elements (J) := Source.Elements (Source.Last);\n-               Source.Last := Source.Last - 1;\n-            end if;\n+               else\n+                  TA (J) := SA (Source.Last);\n+                  Source.Last := Source.Last - 1;\n+               end if;\n \n-            J := J - 1;\n-         end loop;\n+               J := J - 1;\n+            end loop;\n+         end;\n       end Merge;\n \n       ----------\n@@ -722,7 +727,7 @@ package body Ada.Containers.Vectors is\n             new Generic_Array_Sort\n              (Index_Type   => Index_Type,\n               Element_Type => Element_Type,\n-              Array_Type   => Elements_Type,\n+              Array_Type   => Elements_Array,\n               \"<\"          => \"<\");\n \n       begin\n@@ -735,7 +740,7 @@ package body Ada.Containers.Vectors is\n               \"attempt to tamper with cursors (vector is locked)\";\n          end if;\n \n-         Sort (Container.Elements (Index_Type'First .. Container.Last));\n+         Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n       end Sort;\n \n    end Generic_Sorting;\n@@ -819,20 +824,16 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Elements = null then\n-         declare\n-            subtype Elements_Subtype is\n-              Elements_Type (Index_Type'First .. New_Last);\n-         begin\n-            Container.Elements := new Elements_Subtype'(others => New_Item);\n-         end;\n-\n+         Container.Elements := new Elements_Type'\n+                                     (Last => New_Last,\n+                                      EA   => (others => New_Item));\n          Container.Last := New_Last;\n          return;\n       end if;\n \n-      if New_Last <= Container.Elements'Last then\n+      if New_Last <= Container.Elements.Last then\n          declare\n-            E : Elements_Type renames Container.Elements.all;\n+            EA : Elements_Array renames Container.Elements.EA;\n \n          begin\n             if Before <= Container.Last then\n@@ -843,14 +844,14 @@ package body Ada.Containers.Vectors is\n                   Index : constant Index_Type := Index_Type (Index_As_Int);\n \n                begin\n-                  E (Index .. New_Last) := E (Before .. Container.Last);\n+                  EA (Index .. New_Last) := EA (Before .. Container.Last);\n \n-                  E (Before .. Index_Type'Pred (Index)) :=\n+                  EA (Before .. Index_Type'Pred (Index)) :=\n                       (others => New_Item);\n                end;\n \n             else\n-               E (Before .. New_Last) := (others => New_Item);\n+               EA (Before .. New_Last) := (others => New_Item);\n             end if;\n          end;\n \n@@ -862,7 +863,7 @@ package body Ada.Containers.Vectors is\n          C, CC : UInt;\n \n       begin\n-         C := UInt'Max (1, Container.Elements'Length);\n+         C := UInt'Max (1, Container.Elements.EA'Length);  -- ???\n          while C < New_Length loop\n             if C > UInt'Last / 2 then\n                C := UInt'Last;\n@@ -894,16 +895,17 @@ package body Ada.Containers.Vectors is\n                          Index_Type (First + UInt'Pos (C) - 1);\n \n          begin\n-            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+            Dst := new Elements_Type (Dst_Last);\n          end;\n       end;\n \n       declare\n-         Src : Elements_Type renames Container.Elements.all;\n+         SA : Elements_Array renames Container.Elements.EA;\n+         DA : Elements_Array renames Dst.EA;\n \n       begin\n-         Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n-           Src (Index_Type'First .. Index_Type'Pred (Before));\n+         DA (Index_Type'First .. Index_Type'Pred (Before)) :=\n+           SA (Index_Type'First .. Index_Type'Pred (Before));\n \n          if Before <= Container.Last then\n             declare\n@@ -913,12 +915,12 @@ package body Ada.Containers.Vectors is\n                Index : constant Index_Type := Index_Type (Index_As_Int);\n \n             begin\n-               Dst (Before .. Index_Type'Pred (Index)) := (others => New_Item);\n-               Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+               DA (Before .. Index_Type'Pred (Index)) := (others => New_Item);\n+               DA (Index .. New_Last) := SA (Before .. Container.Last);\n             end;\n \n          else\n-            Dst (Before .. New_Last) := (others => New_Item);\n+            DA (Before .. New_Last) := (others => New_Item);\n          end if;\n       exception\n          when others =>\n@@ -969,8 +971,8 @@ package body Ada.Containers.Vectors is\n \n       begin\n          if Container'Address /= New_Item'Address then\n-            Container.Elements (Before .. Dst_Last) :=\n-              New_Item.Elements (Index_Type'First .. New_Item.Last);\n+            Container.Elements.EA (Before .. Dst_Last) :=\n+              New_Item.Elements.EA (Index_Type'First .. New_Item.Last);\n \n             return;\n          end if;\n@@ -979,17 +981,17 @@ package body Ada.Containers.Vectors is\n             subtype Src_Index_Subtype is Index_Type'Base range\n               Index_Type'First .. Before - 1;\n \n-            Src : Elements_Type renames\n-                    Container.Elements (Src_Index_Subtype);\n+            Src : Elements_Array renames\n+                    Container.Elements.EA (Src_Index_Subtype);\n \n             Index_As_Int : constant Int'Base :=\n                              Int (Before) + Src'Length - 1;\n \n             Index : constant Index_Type'Base :=\n                       Index_Type'Base (Index_As_Int);\n \n-            Dst : Elements_Type renames\n-                    Container.Elements (Before .. Index);\n+            Dst : Elements_Array renames\n+                    Container.Elements.EA (Before .. Index);\n \n          begin\n             Dst := Src;\n@@ -1003,17 +1005,17 @@ package body Ada.Containers.Vectors is\n             subtype Src_Index_Subtype is Index_Type'Base range\n               Dst_Last + 1 .. Container.Last;\n \n-            Src : Elements_Type renames\n-                    Container.Elements (Src_Index_Subtype);\n+            Src : Elements_Array renames\n+                    Container.Elements.EA (Src_Index_Subtype);\n \n             Index_As_Int : constant Int'Base :=\n                              Dst_Last_As_Int - Src'Length + 1;\n \n             Index : constant Index_Type :=\n                       Index_Type (Index_As_Int);\n \n-            Dst : Elements_Type renames\n-                    Container.Elements (Index .. Dst_Last);\n+            Dst : Elements_Array renames\n+                    Container.Elements.EA (Index .. Dst_Last);\n \n          begin\n             Dst := Src;\n@@ -1275,16 +1277,14 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Elements = null then\n-         Container.Elements :=\n-           new Elements_Type (Index_Type'First .. New_Last);\n-\n+         Container.Elements := new Elements_Type (New_Last);\n          Container.Last := New_Last;\n          return;\n       end if;\n \n-      if New_Last <= Container.Elements'Last then\n+      if New_Last <= Container.Elements.Last then\n          declare\n-            E : Elements_Type renames Container.Elements.all;\n+            EA : Elements_Array renames Container.Elements.EA;\n          begin\n             if Before <= Container.Last then\n                declare\n@@ -1294,7 +1294,7 @@ package body Ada.Containers.Vectors is\n                   Index : constant Index_Type := Index_Type (Index_As_Int);\n \n                begin\n-                  E (Index .. New_Last) := E (Before .. Container.Last);\n+                  EA (Index .. New_Last) := EA (Before .. Container.Last);\n                end;\n             end if;\n          end;\n@@ -1307,7 +1307,7 @@ package body Ada.Containers.Vectors is\n          C, CC : UInt;\n \n       begin\n-         C := UInt'Max (1, Container.Elements'Length);\n+         C := UInt'Max (1, Container.Elements.EA'Length);  -- ???\n          while C < New_Length loop\n             if C > UInt'Last / 2 then\n                C := UInt'Last;\n@@ -1339,16 +1339,17 @@ package body Ada.Containers.Vectors is\n                          Index_Type (First + UInt'Pos (C) - 1);\n \n          begin\n-            Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n+            Dst := new Elements_Type (Dst_Last);\n          end;\n       end;\n \n       declare\n-         Src : Elements_Type renames Container.Elements.all;\n+         SA : Elements_Array renames Container.Elements.EA;\n+         DA : Elements_Array renames Dst.EA;\n \n       begin\n-         Dst (Index_Type'First .. Index_Type'Pred (Before)) :=\n-           Src (Index_Type'First .. Index_Type'Pred (Before));\n+         DA (Index_Type'First .. Index_Type'Pred (Before)) :=\n+           SA (Index_Type'First .. Index_Type'Pred (Before));\n \n          if Before <= Container.Last then\n             declare\n@@ -1358,7 +1359,7 @@ package body Ada.Containers.Vectors is\n                Index : constant Index_Type := Index_Type (Index_As_Int);\n \n             begin\n-               Dst (Index .. New_Last) := Src (Before .. Container.Last);\n+               DA (Index .. New_Last) := SA (Before .. Container.Last);\n             end;\n          end if;\n       exception\n@@ -1477,7 +1478,11 @@ package body Ada.Containers.Vectors is\n \n    function Last_Element (Container : Vector) return Element_Type is\n    begin\n-      return Element (Container, Container.Last);\n+      if Container.Last = No_Index then\n+         raise Constraint_Error with \"Container is empty\";\n+      end if;\n+\n+      return Container.Elements.EA (Container.Last);\n    end Last_Element;\n \n    ----------------\n@@ -1643,7 +1648,7 @@ package body Ada.Containers.Vectors is\n       L := L + 1;\n \n       begin\n-         Process (V.Elements (Index));\n+         Process (V.Elements.EA (Index));\n       exception\n          when others =>\n             L := L - 1;\n@@ -1689,7 +1694,7 @@ package body Ada.Containers.Vectors is\n \n       for J in Count_Type range 1 .. Length loop\n          Last := Last + 1;\n-         Element_Type'Read (Stream, Container.Elements (Last));\n+         Element_Type'Read (Stream, Container.Elements.EA (Last));\n          Container.Last := Last;\n       end loop;\n    end Read;\n@@ -1721,7 +1726,7 @@ package body Ada.Containers.Vectors is\n            \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n-      Container.Elements (Index) := New_Item;\n+      Container.Elements.EA (Index) := New_Item;\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -1738,7 +1743,16 @@ package body Ada.Containers.Vectors is\n          raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n-      Replace_Element (Container, Position.Index, New_Item);\n+      if Position.Index > Container.Last then\n+         raise Constraint_Error with \"Position cursor is out of range\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n+      end if;\n+\n+      Container.Elements.EA (Position.Index) := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -1761,26 +1775,23 @@ package body Ada.Containers.Vectors is\n                Free (X);\n             end;\n \n-         elsif N < Container.Elements'Length then\n+         elsif N < Container.Elements.EA'Length then\n             if Container.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n             declare\n-               subtype Array_Index_Subtype is Index_Type'Base range\n+               subtype Src_Index_Subtype is Index_Type'Base range\n                  Index_Type'First .. Container.Last;\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Array_Index_Subtype);\n-\n-               subtype Array_Subtype is\n-                 Elements_Type (Array_Index_Subtype);\n+               Src : Elements_Array renames\n+                       Container.Elements.EA (Src_Index_Subtype);\n \n                X : Elements_Access := Container.Elements;\n \n             begin\n-               Container.Elements := new Array_Subtype'(Src);\n+               Container.Elements := new Elements_Type'(Container.Last, Src);\n                Free (X);\n             end;\n          end if;\n@@ -1801,38 +1812,32 @@ package body Ada.Containers.Vectors is\n             declare\n                Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-               subtype Array_Subtype is\n-                 Elements_Type (Index_Type'First .. Last);\n-\n             begin\n-               Container.Elements := new Array_Subtype;\n+               Container.Elements := new Elements_Type (Last);\n             end;\n          end;\n \n          return;\n       end if;\n \n       if Capacity <= N then\n-         if N < Container.Elements'Length then\n+         if N < Container.Elements.EA'Length then\n             if Container.Busy > 0 then\n                raise Program_Error with\n                  \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n             declare\n-               subtype Array_Index_Subtype is Index_Type'Base range\n+               subtype Src_Index_Subtype is Index_Type'Base range\n                  Index_Type'First .. Container.Last;\n \n-               Src : Elements_Type renames\n-                       Container.Elements (Array_Index_Subtype);\n-\n-               subtype Array_Subtype is\n-                 Elements_Type (Array_Index_Subtype);\n+               Src : Elements_Array renames\n+                       Container.Elements.EA (Src_Index_Subtype);\n \n                X : Elements_Access := Container.Elements;\n \n             begin\n-               Container.Elements := new Array_Subtype'(Src);\n+               Container.Elements := new Elements_Type'(Container.Last, Src);\n                Free (X);\n             end;\n \n@@ -1841,7 +1846,7 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Capacity = Container.Elements'Length then\n+      if Capacity = Container.Elements.EA'Length then\n          return;\n       end if;\n \n@@ -1862,18 +1867,17 @@ package body Ada.Containers.Vectors is\n          declare\n             Last : constant Index_Type := Index_Type (Last_As_Int);\n \n-            subtype Array_Subtype is\n-              Elements_Type (Index_Type'First .. Last);\n-\n-            E : Elements_Access := new Array_Subtype;\n+            E : Elements_Access := new Elements_Type (Last);\n \n          begin\n             declare\n-               Src : Elements_Type renames\n-                       Container.Elements (Index_Type'First .. Container.Last);\n+               subtype Index_Subtype is Index_Type'Base range\n+                 Index_Type'First .. Container.Last;\n+\n+               Src : Elements_Array renames\n+                       Container.Elements.EA (Index_Subtype);\n \n-               Tgt : Elements_Type renames\n-                       E (Index_Type'First .. Container.Last);\n+               Tgt : Elements_Array renames E.EA (Index_Subtype);\n \n             begin\n                Tgt := Src;\n@@ -1918,11 +1922,11 @@ package body Ada.Containers.Vectors is\n          J := Container.Last;\n          while I < J loop\n             declare\n-               EI : constant Element_Type := E (I);\n+               EI : constant Element_Type := E.EA (I);\n \n             begin\n-               E (I) := E (J);\n-               E (J) := EI;\n+               E.EA (I) := E.EA (J);\n+               E.EA (J) := EI;\n             end;\n \n             I := I + 1;\n@@ -1958,7 +1962,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements (Indx) = Item then\n+         if Container.Elements.EA (Indx) = Item then\n             return (Container'Unchecked_Access, Indx);\n          end if;\n       end loop;\n@@ -1985,7 +1989,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       for Indx in reverse Index_Type'First .. Last loop\n-         if Container.Elements (Indx) = Item then\n+         if Container.Elements.EA (Indx) = Item then\n             return Indx;\n          end if;\n       end loop;\n@@ -2071,8 +2075,8 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         EI : Element_Type renames Container.Elements (I);\n-         EJ : Element_Type renames Container.Elements (J);\n+         EI : Element_Type renames Container.Elements.EA (I);\n+         EJ : Element_Type renames Container.Elements.EA (J);\n \n          EI_Copy : constant Element_Type := EI;\n \n@@ -2158,7 +2162,7 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type (Index_Type'First .. Last);\n+         Elements := new Elements_Type (Last);\n \n          return Vector'(Controlled with Elements, Last, 0, 0);\n       end;\n@@ -2185,7 +2189,7 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n-         Elements := new Elements_Type'(Index_Type'First .. Last => New_Item);\n+         Elements := new Elements_Type'(Last, EA => (others => New_Item));\n \n          return Vector'(Controlled with Elements, Last, 0, 0);\n       end;\n@@ -2212,7 +2216,7 @@ package body Ada.Containers.Vectors is\n       L := L + 1;\n \n       begin\n-         Process (Container.Elements (Index));\n+         Process (Container.Elements.EA (Index));\n       exception\n          when others =>\n             L := L - 1;\n@@ -2253,7 +2257,7 @@ package body Ada.Containers.Vectors is\n       Count_Type'Base'Write (Stream, Length (Container));\n \n       for J in Index_Type'First .. Container.Last loop\n-         Element_Type'Write (Stream, Container.Elements (J));\n+         Element_Type'Write (Stream, Container.Elements.EA (J));\n       end loop;\n    end Write;\n "}, {"sha": "9dc5c547162cb11dc7fa358f1dfae1d64a5b32ec", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -32,8 +32,9 @@\n --                                                                          --\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n-with Ada.Finalization;\n-with Ada.Streams;\n+\n+private with Ada.Finalization;\n+private with Ada.Streams;\n \n generic\n    type Index_Type is range <>;\n@@ -43,6 +44,7 @@ generic\n \n package Ada.Containers.Vectors is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    subtype Extended_Index is Index_Type'Base\n      range Index_Type'First - 1 ..\n@@ -311,10 +313,15 @@ private\n    pragma Inline (Update_Element);\n    pragma Inline (Replace_Element);\n    pragma Inline (Contains);\n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n \n-   type Elements_Type is array (Index_Type range <>) of Element_Type;\n+   type Elements_Array is array (Index_Type range <>) of Element_Type;\n+   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   function \"=\" (L, R : Elements_Type) return Boolean is abstract;\n+   type Elements_Type (Last : Index_Type) is limited record\n+      EA : Elements_Array (Index_Type'First .. Last);\n+   end record;\n \n    type Elements_Access is access Elements_Type;\n \n@@ -327,8 +334,10 @@ private\n       Lock     : Natural := 0;\n    end record;\n \n+   overriding\n    procedure Adjust (Container : in out Vector);\n \n+   overriding\n    procedure Finalize (Container : in out Vector);\n \n    use Ada.Streams;"}, {"sha": "917c1c7b1e00834735a89264082ad39dbbaa1f0c", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,6 +46,7 @@ generic\n \n package Ada.Containers.Ordered_Maps is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n@@ -181,6 +182,9 @@ package Ada.Containers.Ordered_Maps is\n \n private\n \n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "bdb2150e014c6e9fa66b31be3f2b65c156908117", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,6 +45,7 @@ generic\n \n package Ada.Containers.Ordered_Multisets is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n@@ -245,6 +246,9 @@ package Ada.Containers.Ordered_Multisets is\n \n private\n \n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "2df6353fa3b597e265c28f1c550ff49c733e25e8", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97ccb3a84b27374661fd1f9540efb360d976019/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=f97ccb3a84b27374661fd1f9540efb360d976019", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -45,6 +45,7 @@ generic\n \n package Ada.Containers.Ordered_Sets is\n    pragma Preelaborate;\n+   pragma Remote_Types;\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n@@ -233,6 +234,9 @@ package Ada.Containers.Ordered_Sets is\n \n private\n \n+   pragma Inline (Next);\n+   pragma Inline (Previous);\n+\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}]}