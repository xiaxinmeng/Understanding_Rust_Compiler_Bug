{"sha": "e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFlZTVjZGNiZjIwOWQyZjE2NDczYTJmZjZlOTFmZjc3NGVkYjNlNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-12-18T23:20:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-18T23:20:19Z"}, "message": "tree.c (build_range_type): Allow creation of ranges with no maximum.\n\n\t* tree.c (build_range_type): Allow creation of ranges with no maximum.\n\t* dbxout.c (dbxout_range_type): Handle missing TYPE_MAX_VALUE.\n\t* dwarf2out.c (add_subscript_info): Likewise.\n\t* dwarfout.c (subscript_data_attribute, byte_size_attribute): Likewise.\n\t* sdbout.c (plain_type_1): Likewise.\n\t* stmt.c (pushcase_range, all_cases_count, node_has_high_bound):\n\tLikewise.\n\t* fold-const.c (int_const_binop, fold_convert, make_range, fold):\n\tLikewise.\n\nFrom-SVN: r17142", "tree": {"sha": "f6256a46a8fe9fd54c5f8fa94aaed268e376f33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6256a46a8fe9fd54c5f8fa94aaed268e376f33b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/comments", "author": null, "committer": null, "parents": [{"sha": "8342981f2de7306bf857c96b8b418be8882a0c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8342981f2de7306bf857c96b8b418be8882a0c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8342981f2de7306bf857c96b8b418be8882a0c63"}], "stats": {"total": 114, "additions": 89, "deletions": 25}, "files": [{"sha": "c1add15087b852e5c0a16479ec16f736bf20fb2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -1,3 +1,15 @@\n+Fri Dec 19 00:19:42 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* tree.c (build_range_type): Allow creation of ranges with no maximum.\n+\t* dbxout.c (dbxout_range_type): Handle missing TYPE_MAX_VALUE.\n+\t* dwarf2out.c (add_subscript_info): Likewise.\n+\t* dwarfout.c (subscript_data_attribute, byte_size_attribute): Likewise.\n+\t* sdbout.c (plain_type_1): Likewise.\n+\t* stmt.c (pushcase_range, all_cases_count, node_has_high_bound):\n+\tLikewise.\n+\t* fold-const.c (int_const_binop, fold_convert, make_range, fold):\n+\tLikewise.\n+\n Thu Dec 18 17:05:10 1997  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n  \n         * mips.c (fatal): Remove declaration."}, {"sha": "fcb5d86650ea0aa223a070470ee8820581a1648e", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -954,7 +954,8 @@ dbxout_range_type (type)\n \t     TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)));\n   else\n     fprintf (asmfile, \";0\");\n-  if (TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST)\n+  if (TYPE_MAX_VALUE (type) \n+      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST)\n     fprintf (asmfile, \";%d;\", \n \t     TREE_INT_CST_LOW (TYPE_MAX_VALUE (type)));\n   else"}, {"sha": "f41cd5efeb0318ea99d9120db07bc43632157b9b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -7195,8 +7195,16 @@ add_subscript_info (type_die, type)\n \t\t\t\t    type_die);\n \t    }\n \n+\t  /* ??? If upper is NULL, the array has unspecified length,\n+\t     but it does have a lower bound.  This happens with Fortran\n+\t       dimension arr(N:*)\n+       \t     Since the debugger is definitely going to need to know N\n+\t     to produce useful results, go ahead and output the lower\n+\t     bound solo, and hope the debugger can cope.  */\n+\n \t  add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n-\t  add_bound_info (subrange_die, DW_AT_upper_bound, upper);\n+\t  if (upper)\n+\t    add_bound_info (subrange_die, DW_AT_upper_bound, upper);\n \t}\n       else\n \t/* We have an array type with an unspecified length.  The DWARF-2"}, {"sha": "528886a34f8b955b457d7d2d2eea549290b105ac", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -2587,9 +2587,8 @@ subscript_data_attribute (type)\n \t  /* Output the representation format byte for this dimension.  */\n \n \t  ASM_OUTPUT_DWARF_FMT_BYTE (asm_out_file,\n-\t\t\t\t  FMT_CODE (1,\n-\t\t\t\t\t    TREE_CODE (lower) == INTEGER_CST,\n-\t\t\t\t\t    TREE_CODE (upper) == INTEGER_CST));\n+\t\t  FMT_CODE (1, TREE_CODE (lower) == INTEGER_CST,\n+\t\t\t    (upper && TREE_CODE (upper) == INTEGER_CST)));\n \n \t  /* Output the index type for this dimension.\t*/\n \n@@ -2675,9 +2674,9 @@ byte_size_attribute (tree_node)\n       case ARRAY_TYPE:\n \t{\n \t  /* The lower bound is zero, so the length is the upper bound + 1.  */\n-\t  register tree upper_bound;\n-\t  upper_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (tree_node));\n-\t  size = (unsigned) TREE_INT_CST_LOW (upper_bound) + 1;\n+\t  register tree upper;\n+\t  upper = TYPE_MAX_VALUE (TYPE_DOMAIN (tree_node));\n+\t  size = upper ? (unsigned) TREE_INT_CST_LOW (upper) + 1 : -1;\n \t  break;\n \t}\n "}, {"sha": "adcb1877d8368f18e6e8fafa194477b3a09eec30", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -1215,7 +1215,9 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n     }\n \n   if (TREE_TYPE (arg1) == sizetype && hi == 0\n-      && low >= 0 && low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype))\n+      && low >= 0\n+      && (TYPE_MAX_VALUE (sizetype) == NULL\n+\t  || low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype)))\n       && ! overflow\n       && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n     t = size_int (low);\n@@ -1532,25 +1534,34 @@ fold_convert (t, arg1)\n \t  REAL_VALUE_TYPE l;\n \t  REAL_VALUE_TYPE u;\n \t  tree type1 = TREE_TYPE (arg1);\n+\t  int no_upper_bound;\n \n \t  x = TREE_REAL_CST (arg1);\n \t  l = real_value_from_int_cst (type1, TYPE_MIN_VALUE (type));\n-\t  u = real_value_from_int_cst (type1, TYPE_MAX_VALUE (type));\n+\n+\t  no_upper_bound = (TYPE_MAX_VALUE (type) == NULL);\n+\t  if (!no_upper_bound)\n+\t    u = real_value_from_int_cst (type1, TYPE_MAX_VALUE (type));\n+\n \t  /* See if X will be in range after truncation towards 0.\n \t     To compensate for truncation, move the bounds away from 0,\n \t     but reject if X exactly equals the adjusted bounds.  */\n #ifdef REAL_ARITHMETIC\n \t  REAL_ARITHMETIC (l, MINUS_EXPR, l, dconst1);\n-\t  REAL_ARITHMETIC (u, PLUS_EXPR, u, dconst1);\n+\t  if (!no_upper_bound)\n+\t    REAL_ARITHMETIC (u, PLUS_EXPR, u, dconst1);\n #else\n \t  l--;\n-\t  u++;\n+\t  if (!no_upper_bound)\n+\t    u++;\n #endif\n \t  /* If X is a NaN, use zero instead and show we have an overflow.\n \t     Otherwise, range check.  */\n \t  if (REAL_VALUE_ISNAN (x))\n \t    overflow = 1, x = dconst0;\n-\t  else if (! (REAL_VALUES_LESS (l, x) && REAL_VALUES_LESS (x, u)))\n+\t  else if (! (REAL_VALUES_LESS (l, x)\n+\t\t      && !no_upper_bound\n+\t\t      && REAL_VALUES_LESS (x, u)))\n \t    overflow = 1;\n \n #ifndef REAL_ARITHMETIC\n@@ -2922,11 +2933,22 @@ make_range (exp, pin_p, plow, phigh)\n \t  if (TREE_UNSIGNED (type) && ! TREE_UNSIGNED (TREE_TYPE (exp)))\n \t    {\n \t      tree equiv_type = type_for_mode (TYPE_MODE (type), 1);\n-\t      tree high_positive\n-\t\t= fold (build (RSHIFT_EXPR, type,\n-\t\t\t       convert (type,\n-\t\t\t\t\tTYPE_MAX_VALUE (equiv_type)),\n-\t\t\t       convert (type, integer_one_node)));\n+\t      tree high_positive;\n+\n+\t      /* A range without an upper bound is, naturally, unbounded.\n+\t\t Since convert would have cropped a very large value, use\n+\t\t  the max value for the destination type.  */\n+\n+\t      high_positive = TYPE_MAX_VALUE (equiv_type);\n+\t      if (!high_positive)\n+\t\t{\n+\t\t  high_positive = TYPE_MAX_VALUE (type);\n+\t\t  if (!high_positive)\n+\t\t    abort();\n+\t\t}\n+\t      high_positive = fold (build (RSHIFT_EXPR, type,\n+\t\t\t\t\t   convert (type, high_positive),\n+\t\t\t\t\t   convert (type, integer_one_node)));\n \t\t\t\n \t      /* If the low bound is specified, \"and\" the range with the\n \t\t range for which the original unsigned value will be\n@@ -4914,6 +4936,7 @@ fold (expr)\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn arg0;\n       if (INTEGRAL_TYPE_P (type)\n+\t  && TYPE_MAX_VALUE (type)\n \t  && operand_equal_p (arg1, TYPE_MAX_VALUE (type), 1))\n \treturn omit_one_operand (type, arg1, arg0);\n       goto associate;\n@@ -5397,6 +5420,8 @@ fold (expr)\n \t      && ! (TREE_CONSTANT (cval1) && TREE_CONSTANT (cval2))\n \t      && TREE_TYPE (cval1) == TREE_TYPE (cval2)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (cval1))\n+\t      && TYPE_MAX_VALUE (TREE_TYPE (cval1))\n+\t      && TYPE_MAX_VALUE (TREE_TYPE (cval2))\n \t      && ! operand_equal_p (TYPE_MIN_VALUE (TREE_TYPE (cval1)),\n \t\t\t\t    TYPE_MAX_VALUE (TREE_TYPE (cval2)), 0))\n \t    {"}, {"sha": "14c5b40dc329f9be6aee6d4f83396a38476630a3", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -584,6 +584,7 @@ plain_type_1 (type, level)\n \tif (sdb_n_dims < SDB_MAX_DIM)\n \t  sdb_dims[sdb_n_dims++]\n \t    = (TYPE_DOMAIN (type)\n+\t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n \t       && TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INTEGER_CST\n \t       && TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) == INTEGER_CST\n \t       ? (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))"}, {"sha": "9779015963bc6929a7318ea72c55f4ed1ada861e", "filename": "gcc/stmt.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -4624,10 +4624,16 @@ pushcase_range (value1, value2, converter, label, duplicate)\n \n   /* Fail if the range is empty.  Do this before any conversion since\n      we want to allow out-of-range empty ranges.  */\n-  if (tree_int_cst_lt (value2, value1))\n+  if (value2 && tree_int_cst_lt (value2, value1))\n     return 4;\n \n   value1 = (*converter) (nominal_type, value1);\n+\n+  /* If the max was unbounded, use the max of the nominal_type we are \n+     converting to.  Do this after the < check above to suppress false\n+     positives.  */\n+  if (!value2)\n+    value2 = TYPE_MAX_VALUE (nominal_type);\n   value2 = (*converter) (nominal_type, value2);\n \n   /* Fail if these values are out of range.  */\n@@ -4955,6 +4961,7 @@ all_cases_count (type, spareness)\n     default:\n     case INTEGER_TYPE:\n       if (TREE_CODE (TYPE_MIN_VALUE (type)) != INTEGER_CST\n+\t  || TYPE_MAX_VALUE (type) == NULL\n \t  || TREE_CODE (TYPE_MAX_VALUE (type)) != INTEGER_CST)\n \treturn -1;\n       else\n@@ -6194,6 +6201,11 @@ node_has_high_bound (node, index_type)\n   tree high_plus_one;\n   case_node_ptr pnode;\n \n+  /* If there is no upper bound, obviously no test is needed.  */\n+\n+  if (TYPE_MAX_VALUE (index_type) == NULL)\n+    return 1;\n+\n   /* If the upper bound of this node is the highest value in the type\n      of the index expression, we need not test against it.  */\n "}, {"sha": "492b6734961af59a7688853357812a58c4e24463", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e1ee5cdcbf209d2f16473a2ff6e91ff774edb3e7", "patch": "@@ -4002,19 +4002,25 @@ build_range_type (type, lowval, highval)\n \n   push_obstacks (TYPE_OBSTACK (itype), TYPE_OBSTACK (itype));\n   TYPE_MIN_VALUE (itype) = convert (type, lowval);\n-  TYPE_MAX_VALUE (itype) = convert (type, highval);\n+  TYPE_MAX_VALUE (itype) = highval ? convert (type, highval) : NULL;\n   pop_obstacks ();\n \n   TYPE_PRECISION (itype) = TYPE_PRECISION (type);\n   TYPE_MODE (itype) = TYPE_MODE (type);\n   TYPE_SIZE (itype) = TYPE_SIZE (type);\n   TYPE_ALIGN (itype) = TYPE_ALIGN (type);\n-  if ((TREE_CODE (lowval) == INTEGER_CST)\n-      && (TREE_CODE (highval) == INTEGER_CST))\n+  if (TREE_CODE (lowval) == INTEGER_CST)\n     {\n-      HOST_WIDE_INT highint = TREE_INT_CST_LOW (highval);\n-      HOST_WIDE_INT lowint = TREE_INT_CST_LOW (lowval);\n-      int maxint = (int) (highint - lowint);\n+      HOST_WIDE_INT lowint, highint;\n+      int maxint;\n+\n+      lowint = TREE_INT_CST_LOW (lowval);\n+      if (highval && TREE_CODE (highval) == INTEGER_CST)\n+\thighint = TREE_INT_CST_LOW (highval);\n+      else\n+\thighint = (~(unsigned HOST_WIDE_INT)0) >> 1;\n+\n+      maxint = (int) (highint - lowint);\n       return type_hash_canon (maxint < 0 ? ~maxint : maxint, itype);\n     }\n   else"}]}