{"sha": "ec386958dacc648b01a60b0b32d21c6fdcfc3c49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMzODY5NThkYWNjNjQ4YjAxYTYwYjBiMzJkMjFjNmZkY2ZjM2M0OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-26T18:57:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-26T18:57:57Z"}, "message": "class.c (layout_empty_base): Handle empty bases with non-byte alignment.\n\n\t* class.c (layout_empty_base): Handle empty bases with non-byte\n\talignment.\n\t(build_base_field): Likewise.\n\t(layout_virtual_bases): Likewise.\n\n\t* class.c (finish_struct_1): Fix typo in this change:\n\n\tSat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\nFrom-SVN: r32750", "tree": {"sha": "a5cd814f41ab7a67a87a3928d6dc0aa3c90307bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5cd814f41ab7a67a87a3928d6dc0aa3c90307bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec386958dacc648b01a60b0b32d21c6fdcfc3c49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec386958dacc648b01a60b0b32d21c6fdcfc3c49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec386958dacc648b01a60b0b32d21c6fdcfc3c49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec386958dacc648b01a60b0b32d21c6fdcfc3c49/comments", "author": null, "committer": null, "parents": [{"sha": "a69beca121baeb70efa57d7f381cf7376778d21a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a69beca121baeb70efa57d7f381cf7376778d21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a69beca121baeb70efa57d7f381cf7376778d21a"}], "stats": {"total": 66, "additions": 42, "deletions": 24}, "files": [{"sha": "970be622d41df2db14d9fb249b03951a275f2192", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec386958dacc648b01a60b0b32d21c6fdcfc3c49/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec386958dacc648b01a60b0b32d21c6fdcfc3c49/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ec386958dacc648b01a60b0b32d21c6fdcfc3c49", "patch": "@@ -1,3 +1,14 @@\n+2000-03-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (layout_empty_base): Handle empty bases with non-byte\n+\talignment.\n+\t(build_base_field): Likewise.\n+\t(layout_virtual_bases): Likewise.\n+\n+\t* class.c (finish_struct_1): Fix typo in this change:\n+\t\n+\tSat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n 2000-03-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (grokdeclarator): Count partial specializations when"}, {"sha": "fe636a244409d68b068f185f5e1ebbbd226e7fe0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec386958dacc648b01a60b0b32d21c6fdcfc3c49/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec386958dacc648b01a60b0b32d21c6fdcfc3c49/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ec386958dacc648b01a60b0b32d21c6fdcfc3c49", "patch": "@@ -4267,25 +4267,22 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n }\n \n /* Layout the empty base BINFO.  EOC indicates the byte currently just\n-   past the end of the class; BINFO_OFFSETS gives the offsets of the\n-   other bases allocated so far.  */\n+   past the end of the class, and should be correctly aligned for a\n+   class of the type indicated by BINFO; BINFO_OFFSETS gives the\n+   offsets of the other bases allocated so far.  */\n \n static void\n layout_empty_base (binfo, eoc, binfo_offsets)\n      tree binfo;\n      tree eoc;\n      varray_type binfo_offsets;\n {\n+  tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n   \n   /* This routine should only be used for empty classes.  */\n   my_friendly_assert (is_empty_class (basetype), 20000321);\n-\n-  /* This code assumes that zero-sized classes have one-byte\n-     alignment.  There might someday be a system where that's not\n-     true.  */\n-  my_friendly_assert (TYPE_ALIGN (basetype) == BITS_PER_UNIT, \n-\t\t      20000314);\n+  alignment = ssize_int (CLASSTYPE_ALIGN (basetype));\n \n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n@@ -4301,7 +4298,7 @@ layout_empty_base (binfo, eoc, binfo_offsets)\n \t    break;\n \n \t  /* There's overlap here, too.  Bump along to the next spot.  */\n-\t  propagate_binfo_offsets (binfo, ssize_int (1));\n+\t  propagate_binfo_offsets (binfo, alignment);\n \t}\n     }\n }\n@@ -4360,7 +4357,15 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n       layout_nonempty_base_or_field (rli, decl, binfo, *v);\n     }\n   else\n-    layout_empty_base (binfo, rli_size_unit_so_far (rli), *v);\n+    {\n+      unsigned HOST_WIDE_INT eoc;\n+\n+      /* On some platforms (ARM), even empty classes will not be\n+\t byte-aligned.  */\n+      eoc = tree_low_cst (rli_size_unit_so_far (rli), 0);\n+      eoc = CEIL (eoc, DECL_ALIGN (decl)) * DECL_ALIGN (decl);\n+      layout_empty_base (binfo, size_int (eoc), *v);\n+    }\n \n   /* Check for inaccessible base classes.  If the same base class\n      appears more than once in the hierarchy, but isn't virtual, then\n@@ -4847,6 +4852,19 @@ layout_virtual_bases (t, base_offsets)\n \n \tbasetype = BINFO_TYPE (vbase);\n \n+\tif (flag_new_abi)\n+\t  desired_align = CLASSTYPE_ALIGN (basetype);\n+\telse\n+\t  /* Under the old ABI, virtual bases were aligned as for the\n+\t     entire base object (including its virtual bases).  That's\n+\t     wasteful, in general.  */\n+\t  desired_align = TYPE_ALIGN (basetype);\n+\tTYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n+\n+\t/* Add padding so that we can put the virtual base class at an\n+\t   appropriately aligned offset.  */\n+\tdsize = CEIL (dsize, desired_align) * desired_align;\n+\n \t/* Under the new ABI, we try to squish empty virtual bases in\n \t   just like ordinary empty bases.  */\n \tif (flag_new_abi && is_empty_class (basetype))\n@@ -4855,18 +4873,6 @@ layout_virtual_bases (t, base_offsets)\n \t\t\t     *base_offsets);\n \telse\n \t  {\n-\t    if (flag_new_abi)\n-\t      desired_align = CLASSTYPE_ALIGN (basetype);\n-\t    else\n-\t      /* Under the old ABI, virtual bases were aligned as for\n-\t\t the entire base object (including its virtual bases).\n-\t\t That's wasteful, in general.  */\n-\t      desired_align = TYPE_ALIGN (basetype);\n-\t    TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n-\n-\t    /* Add padding so that we can put the virtual base class at an\n-\t       appropriately aligned offset.  */\n-\t    dsize = CEIL (dsize, desired_align) * desired_align;\n \t    /* And compute the offset of the virtual base.  */\n \t    propagate_binfo_offsets (vbase, \n \t\t\t\t     ssize_int (CEIL (dsize, BITS_PER_UNIT)));\n@@ -5262,14 +5268,15 @@ finish_struct_1 (t)\n   if (vfield != NULL_TREE\n       && DECL_FIELD_CONTEXT (vfield) != t)\n     {\n+      tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n+\n       vfield = copy_node (vfield);\n       copy_lang_decl (vfield);\n \n       DECL_FIELD_CONTEXT (vfield) = t;\n       DECL_FIELD_OFFSET (vfield)\n \t= size_binop (PLUS_EXPR,\n-\t\t      BINFO_OFFSET (get_binfo (DECL_FIELD_CONTEXT (vfield),\n-\t\t\t\t\t       t, 0)),\n+\t\t      BINFO_OFFSET (binfo),\n \t\t      DECL_FIELD_OFFSET (vfield));\n       TYPE_VFIELD (t) = vfield;\n     }"}]}