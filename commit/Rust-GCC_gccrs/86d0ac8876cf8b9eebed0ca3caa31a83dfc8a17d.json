{"sha": "86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZkMGFjODg3NmNmOGI5ZWViZWQwY2EzY2FhMzFhODNkZmM4YTE3ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-01-13T22:14:46Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-01-13T22:14:46Z"}, "message": "jit: New API entrypoint: gcc_jit_context_dump_reproducer_to_file\n\ngcc/jit/ChangeLog:\n\t* docs/cp/topics/contexts.rst (Debugging): Add\n\tgccjit::context::dump_reproducer_to_file.\n\t* docs/internals/index.rst (Design notes): New section,\n\tdiscussing input validation and\n\tgcc_jit_context_dump_reproducer_to_file.\n\t* docs/topics/contexts.rst (Debugging): Add\n\tgcc_jit_context_dump_reproducer_to_file.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* jit-common.h (gcc::jit::dump::get_context): New accessor.\n\t* jit-recording.c: Include \"hash-map.h\".\n\tWithin namespace ::gcc::jit...\n\t(dump::write): Flush each line.\n\t(dump::make_location): Pass false for new param \"created_by_user\".\n\t(class allocator): New class.\n\t(allocator::~allocator): New function.\n\t(allocator::xstrdup_printf): New function.\n\t(allocator::xstrdup_printf_va): New function.\n\t(class reproducer): New subclass of dump.\n\t(reproducer::reproducer): New function.\n\t(reproducer::write_params): New function.\n\t(reproducer::write_args): New function.\n\t(reproducer::make_identifier): New function.\n\t(reproducer::make_tmp_identifier): New function.\n\t(reproducer::get_identifier): New pair of functions.\n\t(reproducer::get_identifier_as_rvalue): New function.\n\t(reproducer::get_identifier_as_lvalue): New function.\n\t(reproducer::get_identifier_as_type): New function.\n\t(reproducer::xstrdup_printf): New function.\n\t(recording::context::context): Initialize m_toplevel_ctxt.\n\t(recording::context::new_location): Add param created_by_user.\n\t(str_option_reproducer_strings): New table of strings.\n\t(int_option_reproducer_strings): Likewise.\n\t(bool_option_reproducer_strings): Likewise.\n\t(get_type_enum_strings): Likewise.\n\t(names_of_function_kinds): Likewise.\n\t(global_kind_reproducer_strings): Likewise.\n\t(unary_op_reproducer_strings): Likewise.\n\t(binary_op_reproducer_strings): Likewise.\n\t(comparison_reproducer_strings): Likewise.\n\tWithin namespace ::gcc::jit::recording::...\n\t(context::dump_reproducer_to_file): New function.\n\t(string::write_reproducer): Likewise.\n\t(location::write_reproducer): Likewise.\n\t(type::access_as_type): Likewise.\n\t(memento_of_get_type::write_reproducer): Likewise.\n\t(memento_of_get_pointer::write_reproducer): Likewise.\n\t(memento_of_get_const::write_reproducer): Likewise.\n\t(memento_of_get_volatile::write_reproducer): Likewise.\n\t(array_type::write_reproducer): Likewise.\n\t(function_type::write_reproducer): Likewise.\n\t(function_type::write_deferred_reproducer): Likewise.\n\t(field::write_reproducer): Likewise.\n\t(struct_::access_as_type): Likewise.\n\t(struct_::write_reproducer): Likewise.\n\t(union_::write_reproducer): Likewise.\n\t(fields::write_reproducer): Likewise.\n\t(rvalue::access_as_rvalue): Likewise.\n\t(lvalue::access_as_rvalue): Likewise.\n\t(lvalue::access_as_lvalue): Likewise.\n\t(param::access_as_rvalue): Likewise.\n\t(param::access_as_lvalue): Likewise.\n\t(param::write_reproducer): Likewise.\n\t(function::write_reproducer): Likewise.\n\t(block::write_reproducer): Likewise.\n\t(global::write_reproducer): Likewise.\n\t(memento_of_new_rvalue_from_const <int>::write_reproducer):\n\tLikewise.\n\t(memento_of_new_rvalue_from_const <long>::write_reproducer):\n\tLikewise.\n\t(memento_of_new_rvalue_from_const <double>::write_reproducer):\n\tLikewise.\n\t(memento_of_new_rvalue_from_const <void *>::write_reproducer):\n\tLikewise.\n\t(memento_of_new_string_literal::write_reproducer): Likewise.\n\t(unary_op::write_reproducer): Likewise.\n\t(binary_op::write_reproducer): Likewise.\n\t(comparison::write_reproducer): Likewise.\n\t(cast::write_reproducer): Likewise.\n\t(call::write_reproducer): Likewise.\n\t(call_through_ptr::write_reproducer): Likewise.\n\t(array_access::write_reproducer): Likewise.\n\t(access_field_of_lvalue::write_reproducer): Likewise.\n\t(access_field_rvalue::write_reproducer): Likewise.\n\t(dereference_field_rvalue::write_reproducer): Likewise.\n\t(dereference_rvalue::write_reproducer): Likewise.\n\t(get_address_of_lvalue::write_reproducer): Likewise.\n\t(local::write_reproducer): Likewise.\n\t(eval::write_reproducer): Likewise.\n\t(assignment::write_reproducer): Likewise.\n\t(assignment_op::write_reproducer): Likewise.\n\t(comment::write_reproducer): Likewise.\n\t(conditional::write_reproducer): Likewise.\n\t(jump::write_reproducer): Likewise.\n\t(return_::write_reproducer): Likewise.\n\t* jit-recording.h (gcc::jit::reproducer): New forward declararion.\n\tWithin namespace ::gcc::jit::recording::...\n\t(context::new_location): Add \"created_by_user\" param.\n\t(context::dump_reproducer_to_file): New method.\n\t(context::m_toplevel_ctxt): New field.\n\t(memento::write_reproducer): New pure virtual function.\n\t(memento::dyn_cast_location): New virtual function.\n\t(string::write_reproducer):\n\t(location::location): Add \"created_by_user\" param.\n\t(location::dyn_cast_location): New function.\n\t(location::created_by_user): New accessor.\n\t(location::write_reproducer): New function.\n\t(location::m_created_by_user): New field.\n\t(type::access_as_type): New virtual function.\n\t(location::write_reproducer): Likewise.\n\t(type::access_as_type): Likewise.\n\t(memento_of_get_type::write_reproducer): Likewise.\n\t(memento_of_get_pointer::write_reproducer): Likewise.\n\t(memento_of_get_const::write_reproducer): Likewise.\n\t(memento_of_get_volatile::write_reproducer): Likewise.\n\t(array_type::write_reproducer): Likewise.\n\t(function_type::write_reproducer): Likewise.\n\t(function_type::write_deferred_reproducer): Likewise.\n\t(field::write_reproducer): Likewise.\n\t(struct_::access_as_type): Likewise.\n\t(struct_::write_reproducer): Likewise.\n\t(union_::write_reproducer): Likewise.\n\t(union_::m_fields): Remove stray unused field.\n\t(fields::length): New accessor.\n\t(fields::get_field): New accessor.\n\t(fields::write_reproducer): New function.\n\t(rvalue::access_as_rvalue): Likewise.\n\t(lvalue::access_as_rvalue): Likewise.\n\t(lvalue::access_as_lvalue): Likewise.\n\t(param::access_as_rvalue): Likewise.\n\t(param::access_as_lvalue): Likewise.\n\t(param::write_reproducer): Likewise.\n\t(function::write_reproducer): Likewise.\n\t(block::write_reproducer): Likewise.\n\t(global::write_reproducer): Likewise.\n\t(memento_of_new_rvalue_from_const <HOST_TYPE>::write_reproducer):\n\tLikewise.\n\t(memento_of_new_string_literal::write_reproducer): Likewise.\n\t(unary_op::write_reproducer): Likewise.\n\t(binary_op::write_reproducer): Likewise.\n\t(comparison::write_reproducer): Likewise.\n\t(cast::write_reproducer): Likewise.\n\t(call::write_reproducer): Likewise.\n\t(call_through_ptr::write_reproducer): Likewise.\n\t(array_access::write_reproducer): Likewise.\n\t(access_field_of_lvalue::write_reproducer): Likewise.\n\t(access_field_rvalue::write_reproducer): Likewise.\n\t(dereference_field_rvalue::write_reproducer): Likewise.\n\t(dereference_rvalue::write_reproducer): Likewise.\n\t(get_address_of_lvalue::write_reproducer): Likewise.\n\t(local::write_reproducer): Likewise.\n\t(eval::write_reproducer): Likewise.\n\t(assignment::write_reproducer): Likewise.\n\t(assignment_op::write_reproducer): Likewise.\n\t(comment::write_reproducer): Likewise.\n\t(conditional::write_reproducer): Likewise.\n\t(jump::write_reproducer): Likewise.\n\t(return_::write_reproducer): Likewise.\n\t* libgccjit++.h (gccjit::context::dump_reproducer_to_file): New.\n\t* libgccjit.c (gcc_jit_context_new_location): Pass \"true\" as\n\tparam \"created_by_user\".\n\t(gcc_jit_context_dump_reproducer_to_file): New API entrypoint.\n\t* libgccjit.h (gcc_jit_context_dump_reproducer_to_file): New API\n\tentrypoint.\n\t* libgccjit.map (gcc_jit_context_dump_reproducer_to_file): New API\n\tentrypoint.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/harness.h (set_up_logging): Move string concatenation\n\tinto...\n\t(concat_strings): New function.\n\t(dump_reproducer): New function.\n\t(test_jit): Call dump_reproducer.\n\t* jit.dg/jit.exp (is_testcase_meant_to_generate_a_reproducer): New\n\tfunction.\n\t(jit-dg-test): Delete any generated reproducer from previous runs.\n\tVerify that a generated reproducer was created, and verify that it\n\tcompiles.\n\t* jit.dg/test-nested-contexts.c (main): Call\n\tgcc_jit_context_dump_reproducer_to_file.\n\nFrom-SVN: r219564", "tree": {"sha": "c0d87a4832ffd8054d13953a55395ade2a0f8583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d87a4832ffd8054d13953a55395ade2a0f8583"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c80f9197ef4bce167065c39a74e79d9dd7ac879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c80f9197ef4bce167065c39a74e79d9dd7ac879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c80f9197ef4bce167065c39a74e79d9dd7ac879"}], "stats": {"total": 2767, "additions": 2354, "deletions": 413}, "files": [{"sha": "d15a21424b2d6fd99ac2ac9f9b56208d53fa8d8c", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -1,3 +1,171 @@\n+2015-01-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/topics/contexts.rst (Debugging): Add\n+\tgccjit::context::dump_reproducer_to_file.\n+\t* docs/internals/index.rst (Design notes): New section,\n+\tdiscussing input validation and\n+\tgcc_jit_context_dump_reproducer_to_file.\n+\t* docs/topics/contexts.rst (Debugging): Add\n+\tgcc_jit_context_dump_reproducer_to_file.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* jit-common.h (gcc::jit::dump::get_context): New accessor.\n+\t* jit-recording.c: Include \"hash-map.h\".\n+\tWithin namespace ::gcc::jit...\n+\t(dump::write): Flush each line.\n+\t(dump::make_location): Pass false for new param \"created_by_user\".\n+\t(class allocator): New class.\n+\t(allocator::~allocator): New function.\n+\t(allocator::xstrdup_printf): New function.\n+\t(allocator::xstrdup_printf_va): New function.\n+\t(class reproducer): New subclass of dump.\n+\t(reproducer::reproducer): New function.\n+\t(reproducer::write_params): New function.\n+\t(reproducer::write_args): New function.\n+\t(reproducer::make_identifier): New function.\n+\t(reproducer::make_tmp_identifier): New function.\n+\t(reproducer::get_identifier): New pair of functions.\n+\t(reproducer::get_identifier_as_rvalue): New function.\n+\t(reproducer::get_identifier_as_lvalue): New function.\n+\t(reproducer::get_identifier_as_type): New function.\n+\t(reproducer::xstrdup_printf): New function.\n+\t(recording::context::context): Initialize m_toplevel_ctxt.\n+\t(recording::context::new_location): Add param created_by_user.\n+\t(str_option_reproducer_strings): New table of strings.\n+\t(int_option_reproducer_strings): Likewise.\n+\t(bool_option_reproducer_strings): Likewise.\n+\t(get_type_enum_strings): Likewise.\n+\t(names_of_function_kinds): Likewise.\n+\t(global_kind_reproducer_strings): Likewise.\n+\t(unary_op_reproducer_strings): Likewise.\n+\t(binary_op_reproducer_strings): Likewise.\n+\t(comparison_reproducer_strings): Likewise.\n+\tWithin namespace ::gcc::jit::recording::...\n+\t(context::dump_reproducer_to_file): New function.\n+\t(string::write_reproducer): Likewise.\n+\t(location::write_reproducer): Likewise.\n+\t(type::access_as_type): Likewise.\n+\t(memento_of_get_type::write_reproducer): Likewise.\n+\t(memento_of_get_pointer::write_reproducer): Likewise.\n+\t(memento_of_get_const::write_reproducer): Likewise.\n+\t(memento_of_get_volatile::write_reproducer): Likewise.\n+\t(array_type::write_reproducer): Likewise.\n+\t(function_type::write_reproducer): Likewise.\n+\t(function_type::write_deferred_reproducer): Likewise.\n+\t(field::write_reproducer): Likewise.\n+\t(struct_::access_as_type): Likewise.\n+\t(struct_::write_reproducer): Likewise.\n+\t(union_::write_reproducer): Likewise.\n+\t(fields::write_reproducer): Likewise.\n+\t(rvalue::access_as_rvalue): Likewise.\n+\t(lvalue::access_as_rvalue): Likewise.\n+\t(lvalue::access_as_lvalue): Likewise.\n+\t(param::access_as_rvalue): Likewise.\n+\t(param::access_as_lvalue): Likewise.\n+\t(param::write_reproducer): Likewise.\n+\t(function::write_reproducer): Likewise.\n+\t(block::write_reproducer): Likewise.\n+\t(global::write_reproducer): Likewise.\n+\t(memento_of_new_rvalue_from_const <int>::write_reproducer):\n+\tLikewise.\n+\t(memento_of_new_rvalue_from_const <long>::write_reproducer):\n+\tLikewise.\n+\t(memento_of_new_rvalue_from_const <double>::write_reproducer):\n+\tLikewise.\n+\t(memento_of_new_rvalue_from_const <void *>::write_reproducer):\n+\tLikewise.\n+\t(memento_of_new_string_literal::write_reproducer): Likewise.\n+\t(unary_op::write_reproducer): Likewise.\n+\t(binary_op::write_reproducer): Likewise.\n+\t(comparison::write_reproducer): Likewise.\n+\t(cast::write_reproducer): Likewise.\n+\t(call::write_reproducer): Likewise.\n+\t(call_through_ptr::write_reproducer): Likewise.\n+\t(array_access::write_reproducer): Likewise.\n+\t(access_field_of_lvalue::write_reproducer): Likewise.\n+\t(access_field_rvalue::write_reproducer): Likewise.\n+\t(dereference_field_rvalue::write_reproducer): Likewise.\n+\t(dereference_rvalue::write_reproducer): Likewise.\n+\t(get_address_of_lvalue::write_reproducer): Likewise.\n+\t(local::write_reproducer): Likewise.\n+\t(eval::write_reproducer): Likewise.\n+\t(assignment::write_reproducer): Likewise.\n+\t(assignment_op::write_reproducer): Likewise.\n+\t(comment::write_reproducer): Likewise.\n+\t(conditional::write_reproducer): Likewise.\n+\t(jump::write_reproducer): Likewise.\n+\t(return_::write_reproducer): Likewise.\n+\t* jit-recording.h (gcc::jit::reproducer): New forward declararion.\n+\tWithin namespace ::gcc::jit::recording::...\n+\t(context::new_location): Add \"created_by_user\" param.\n+\t(context::dump_reproducer_to_file): New method.\n+\t(context::m_toplevel_ctxt): New field.\n+\t(memento::write_reproducer): New pure virtual function.\n+\t(memento::dyn_cast_location): New virtual function.\n+\t(string::write_reproducer):\n+\t(location::location): Add \"created_by_user\" param.\n+\t(location::dyn_cast_location): New function.\n+\t(location::created_by_user): New accessor.\n+\t(location::write_reproducer): New function.\n+\t(location::m_created_by_user): New field.\n+\t(type::access_as_type): New virtual function.\n+\t(location::write_reproducer): Likewise.\n+\t(type::access_as_type): Likewise.\n+\t(memento_of_get_type::write_reproducer): Likewise.\n+\t(memento_of_get_pointer::write_reproducer): Likewise.\n+\t(memento_of_get_const::write_reproducer): Likewise.\n+\t(memento_of_get_volatile::write_reproducer): Likewise.\n+\t(array_type::write_reproducer): Likewise.\n+\t(function_type::write_reproducer): Likewise.\n+\t(function_type::write_deferred_reproducer): Likewise.\n+\t(field::write_reproducer): Likewise.\n+\t(struct_::access_as_type): Likewise.\n+\t(struct_::write_reproducer): Likewise.\n+\t(union_::write_reproducer): Likewise.\n+\t(union_::m_fields): Remove stray unused field.\n+\t(fields::length): New accessor.\n+\t(fields::get_field): New accessor.\n+\t(fields::write_reproducer): New function.\n+\t(rvalue::access_as_rvalue): Likewise.\n+\t(lvalue::access_as_rvalue): Likewise.\n+\t(lvalue::access_as_lvalue): Likewise.\n+\t(param::access_as_rvalue): Likewise.\n+\t(param::access_as_lvalue): Likewise.\n+\t(param::write_reproducer): Likewise.\n+\t(function::write_reproducer): Likewise.\n+\t(block::write_reproducer): Likewise.\n+\t(global::write_reproducer): Likewise.\n+\t(memento_of_new_rvalue_from_const <HOST_TYPE>::write_reproducer):\n+\tLikewise.\n+\t(memento_of_new_string_literal::write_reproducer): Likewise.\n+\t(unary_op::write_reproducer): Likewise.\n+\t(binary_op::write_reproducer): Likewise.\n+\t(comparison::write_reproducer): Likewise.\n+\t(cast::write_reproducer): Likewise.\n+\t(call::write_reproducer): Likewise.\n+\t(call_through_ptr::write_reproducer): Likewise.\n+\t(array_access::write_reproducer): Likewise.\n+\t(access_field_of_lvalue::write_reproducer): Likewise.\n+\t(access_field_rvalue::write_reproducer): Likewise.\n+\t(dereference_field_rvalue::write_reproducer): Likewise.\n+\t(dereference_rvalue::write_reproducer): Likewise.\n+\t(get_address_of_lvalue::write_reproducer): Likewise.\n+\t(local::write_reproducer): Likewise.\n+\t(eval::write_reproducer): Likewise.\n+\t(assignment::write_reproducer): Likewise.\n+\t(assignment_op::write_reproducer): Likewise.\n+\t(comment::write_reproducer): Likewise.\n+\t(conditional::write_reproducer): Likewise.\n+\t(jump::write_reproducer): Likewise.\n+\t(return_::write_reproducer): Likewise.\n+\t* libgccjit++.h (gccjit::context::dump_reproducer_to_file): New.\n+\t* libgccjit.c (gcc_jit_context_new_location): Pass \"true\" as\n+\tparam \"created_by_user\".\n+\t(gcc_jit_context_dump_reproducer_to_file): New API entrypoint.\n+\t* libgccjit.h (gcc_jit_context_dump_reproducer_to_file): New API\n+\tentrypoint.\n+\t* libgccjit.map (gcc_jit_context_dump_reproducer_to_file): New API\n+\tentrypoint.\n+\n 2015-01-12  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-recording.c (class gcc::jit::rvalue_usage_validator): New."}, {"sha": "8213f9a8d00c42b29e672521cd69e63f3aaea8a0", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 437, "deletions": 386, "changes": 823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d"}, {"sha": "eb54e7732afd65d76a8409424e760cc38918621d", "filename": "gcc/jit/docs/cp/topics/contexts.rst", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -144,6 +144,16 @@ Debugging\n    :c:macro:`GCCJIT::BOOL_OPTION_DEBUGINFO` to allow stepping through the\n    code in a debugger.\n \n+.. function:: void\\\n+              gccjit::context::dump_reproducer_to_file (gcc_jit_context *ctxt,\\\n+                                                        const char *path)\n+\n+   This is a thin wrapper around the C API\n+   :c:func:`gcc_jit_context_dump_reproducer_to_file`, and hence works the\n+   same way.\n+\n+   Note that the generated source is C code, not C++; this might be of use\n+   for seeing what the C++ bindings are doing at the C level.\n \n Options\n -------"}, {"sha": "0d8d5f650f212955f64546f5720f2eb20ea06af6", "filename": "gcc/jit/docs/internals/index.rst", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Finternals%2Findex.rst?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -277,3 +277,13 @@ generated via this call:\n \n .. literalinclude:: test-hello-world.exe.log.txt\n     :lines: 1-\n+\n+Design notes\n+------------\n+It should not be possible for client code to cause an internal compiler\n+error.  If this *does* happen, the root cause should be isolated (perhaps\n+using :c:func:`gcc_jit_context_dump_reproducer_to_file`) and the cause\n+should be rejected via additional checking.  The checking ideally should\n+be within the libgccjit API entrypoints in libgccjit.c, since this is as\n+close as possible to the error; failing that, a good place is within\n+``recording::context::validate ()`` in jit-recording.c."}, {"sha": "d62217befcdb8c4a8f8bb289852f5981f43c3e2c", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -218,6 +218,30 @@ current state of a context to the given path, whereas\n :c:func:`gcc_jit_context_set_logfile` enables on-going logging of\n future activies on a context to the given `FILE *`.\n \n+\n+.. function:: void\\\n+              gcc_jit_context_dump_reproducer_to_file (gcc_jit_context *ctxt,\\\n+                                                       const char *path)\n+\n+   Write C source code into `path` that can be compiled into a\n+   self-contained executable (i.e. with libgccjit as the only dependency).\n+   The generated code will attempt to replay the API calls that have been\n+   made into the given context.\n+\n+   This may be useful when debugging the library or client code, for\n+   reducing a complicated recipe for reproducing a bug into a simpler\n+   form.  For example, consider client code that parses some source file\n+   into some internal representation, and then walks this IR, calling into\n+   libgccjit.  If this encounters a bug, a call to\n+   `gcc_jit_context_dump_reproducer_to_file` will write out C code for\n+   a much simpler executable that performs the equivalent calls into\n+   libgccjit, without needing the client code and its data.\n+\n+   Typically you need to supply :option:`-Wno-unused-variable` when\n+   compiling the generated file (since the result of each API call is\n+   assigned to a unique variable within the generated C source, and not\n+   all are necessarily then used).\n+\n .. function:: void\\\n               gcc_jit_context_enable_dump (gcc_jit_context *ctxt,\\\n                                            const char *dumpname, \\"}, {"sha": "09d63badd9c9765ff968c12e07b30adb50e1fe4c", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -168,6 +168,8 @@ class dump\n \tbool update_locations);\n   ~dump ();\n \n+  recording::context &get_context () { return m_ctxt; }\n+\n   void write (const char *fmt, ...)\n     GNU_PRINTF(2, 3);\n "}, {"sha": "76eabbdf3c7b2ed45b3aa87007ef077996715d89", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 1452, "deletions": 10, "changes": 1462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"pretty-print.h\"\n+#include \"hash-map.h\"\n \n #include <pthread.h>\n \n@@ -98,6 +99,9 @@ dump::write (const char *fmt, ...)\n     m_ctxt.add_error (NULL, \"error writing to dump file %s\",\n \t\t      m_filename);\n \n+  /* Flush after each line, to ease debugging crashes.  */\n+  fflush (m_file);\n+\n   /* Update line/column: */\n   for (const char *ptr = buf; *ptr; ptr++)\n     {\n@@ -119,7 +123,291 @@ dump::write (const char *fmt, ...)\n recording::location *\n dump::make_location () const\n {\n-  return m_ctxt.new_location (m_filename, m_line, m_column);\n+  return m_ctxt.new_location (m_filename, m_line, m_column,\n+\t\t\t      /* We need to flag such locations as *not*\n+\t\t\t\t created by the user, so that\n+\t\t\t\t reproducer::get_identifier can cope with\n+\t\t\t\t them appearing *after* the memento that\n+\t\t\t\t refers to them.  */\n+\t\t\t      false);\n+}\n+\n+/* A collection of allocations, all of which can be released together, to\n+   avoid needing to track and release them individually.  */\n+\n+class allocator\n+{\n+ public:\n+  ~allocator ();\n+\n+  char *\n+  xstrdup_printf (const char *, ...)\n+    ATTRIBUTE_RETURNS_NONNULL\n+    GNU_PRINTF(2, 3);\n+\n+  char *\n+  xstrdup_printf_va (const char *, va_list ap)\n+    ATTRIBUTE_RETURNS_NONNULL\n+    GNU_PRINTF(2, 0);\n+\n+ private:\n+  auto_vec <void *> m_buffers;\n+};\n+\n+/* allocator's destructor.  Call \"free\" on all of the allocations.  */\n+\n+allocator::~allocator ()\n+{\n+  unsigned i;\n+  void *buffer;\n+  FOR_EACH_VEC_ELT (m_buffers, i, buffer)\n+    free (buffer);\n+}\n+\n+/* Formatted printing, allocating to a buffer (or exiting the process if\n+   the allocation fails).\n+\n+   The buffer exists until the allocator is cleaned up, and is freed at\n+   that point, so the caller doesn't need to track the result.  */\n+\n+char *\n+allocator::xstrdup_printf (const char *fmt, ...)\n+{\n+  char *result;\n+  va_list ap;\n+  va_start (ap, fmt);\n+  result = xstrdup_printf_va (fmt, ap);\n+  va_end (ap);\n+  return result;\n+}\n+\n+/* Formatted printing, allocating to a buffer (or exiting the process if\n+   the allocation fails).\n+\n+   The buffer exists until the allocator is cleaned up, and is freed at\n+   that point, so the caller doesn't need to track the result.  */\n+\n+char *\n+allocator::xstrdup_printf_va (const char *fmt, va_list ap)\n+{\n+  char *result = xvasprintf (fmt, ap);\n+  m_buffers.safe_push (result);\n+  return result;\n+}\n+\n+/* gcc::jit::reproducer is a subclass of gcc::jit::dump, used for\n+   implementing gcc_jit_context_dump_reproducer_to_file.  */\n+\n+class reproducer : public dump\n+{\n+ public:\n+  reproducer (recording::context &ctxt,\n+\t      const char *filename);\n+\n+  void\n+  write_params (const vec <recording::context *> &contexts);\n+\n+  void\n+  write_args (const vec <recording::context *> &contexts);\n+\n+  const char *\n+  make_identifier (recording::memento *m, const char *prefix);\n+\n+  const char *\n+  make_tmp_identifier (const char *prefix, recording::memento *m);\n+\n+  const char *\n+  get_identifier (recording::context *ctxt);\n+\n+  const char *\n+  get_identifier (recording::memento *m);\n+\n+  const char *\n+  get_identifier_as_rvalue (recording::rvalue *m);\n+\n+  const char *\n+  get_identifier_as_lvalue (recording::lvalue *m);\n+\n+  const char *\n+  get_identifier_as_type (recording::type *m);\n+\n+  char *\n+  xstrdup_printf (const char *, ...)\n+    ATTRIBUTE_RETURNS_NONNULL\n+    GNU_PRINTF(2, 3);\n+\n+ private:\n+  hash_map<recording::memento *, const char *> m_identifiers;\n+  allocator m_allocator;\n+};\n+\n+/* gcc::jit::reproducer's constructor.  */\n+\n+reproducer::reproducer (recording::context &ctxt,\n+\t\t\tconst char *filename) :\n+  dump (ctxt, filename, 0),\n+  m_identifiers (),\n+  m_allocator ()\n+{\n+}\n+\n+/* Write out a list of contexts as a set of parameters within a\n+   C function declaration.  */\n+\n+void\n+reproducer::write_params (const vec <recording::context *> &contexts)\n+{\n+  unsigned i;\n+  recording::context *ctxt;\n+  FOR_EACH_VEC_ELT (contexts, i, ctxt)\n+    {\n+      write (\"gcc_jit_context *%s\",\n+\t     get_identifier (ctxt));\n+      if (i < contexts.length () - 1)\n+\twrite (\",\\n\"\n+\t       \"             \");\n+    }\n+}\n+\n+/* Write out a list of contexts as a set of arguments within a call\n+   to a C function.  */\n+\n+void\n+reproducer::write_args (const vec <recording::context *> &contexts)\n+{\n+  unsigned i;\n+  recording::context *ctxt;\n+  FOR_EACH_VEC_ELT (contexts, i, ctxt)\n+    {\n+      write (\"%s\",\n+\t     get_identifier (ctxt));\n+      if (i < contexts.length () - 1)\n+\twrite (\",\\n\"\n+\t       \"               \");\n+    }\n+}\n+\n+/* Generate a C identifier for the given memento, associating the generated\n+   buffer with the memento (for future calls to get_identifier et al).\n+\n+   The reproducer will eventually clean up the buffer in its dtor.  */\n+const char *\n+reproducer::make_identifier (recording::memento *m, const char *prefix)\n+{\n+  char *result;\n+  if (strlen (m->get_debug_string ()) < 100)\n+    {\n+      result = m_allocator.xstrdup_printf (\"%s_%s_%p\",\n+\t\t\t\t\t   prefix,\n+\t\t\t\t\t   m->get_debug_string (),\n+\t\t\t\t\t   (void *) m);\n+      for (char *p = result; *p; p++)\n+\tif (!ISALNUM (*p))\n+\t  *p = '_';\n+    }\n+  else\n+    result = m_allocator.xstrdup_printf (\"%s_%p\",\n+\t\t\t\t\t prefix, (void *) m);\n+  m_identifiers.put (m, result);\n+  return result;\n+}\n+\n+/* Generate a C identifier for a temporary variable.\n+   The reproducer will eventually clean up the buffer in its dtor.  */\n+\n+const char *\n+reproducer::make_tmp_identifier (const char *prefix, recording::memento *m)\n+{\n+  return m_allocator.xstrdup_printf (\"%s_%s\",\n+\t\t\t\t     prefix, get_identifier (m));\n+}\n+\n+/* Generate a C identifier for the given context.\n+   The reproducer will eventually clean up the buffer in its dtor.  */\n+\n+const char *\n+reproducer::get_identifier (recording::context *ctxt)\n+{\n+  return m_allocator.xstrdup_printf (\"ctxt_%p\",\n+\t\t\t\t     (void *)ctxt);\n+}\n+\n+/* Locate the C identifier for the given memento, which is assumed to\n+   have already been created via make_identifier.  */\n+\n+const char *\n+reproducer::get_identifier (recording::memento *m)\n+{\n+  if (!m)\n+    return \"NULL\";\n+\n+  /* gcc_jit_context_dump_to_file (, , 1) generates and writes locations,\n+     and hence these locations appear in the context's memento list\n+     out-of-order: they appear in the context's memento list *after*\n+     the memento that refers to them.  For this case, it's simplest to\n+     pretend that they're NULL when writing out the code to recreate the\n+     memento that uses them.  */\n+  if (recording::location *loc = m->dyn_cast_location ())\n+    if (!loc->created_by_user ())\n+      return \"NULL\";\n+\n+  const char **slot = m_identifiers.get (m);\n+  if (!slot)\n+    {\n+      get_context ().add_error (NULL,\n+\t\t\t\t\"unable to find identifier for %p: %s\",\n+\t\t\t\t(void *)m,\n+\t\t\t\tm->get_debug_string ());\n+      gcc_unreachable ();\n+    }\n+  return *slot;\n+}\n+\n+/* Locate the C identifier for the given rvalue, wrapping it within\n+   a gcc_*_as_rvalue upcast if necessary.  */\n+\n+const char *\n+reproducer::get_identifier_as_rvalue (recording::rvalue *m)\n+{\n+  return m->access_as_rvalue (*this);\n+}\n+\n+/* Locate the C identifier for the given lvalue, wrapping it within\n+   a gcc_*_as_lvalue upcast if necessary.  */\n+\n+const char *\n+reproducer::get_identifier_as_lvalue (recording::lvalue *m)\n+{\n+  return m->access_as_lvalue (*this);\n+}\n+\n+/* Locate the C identifier for the given type, wrapping it within\n+   a gcc_*_as_type upcast if necessary.  */\n+\n+const char *\n+reproducer::get_identifier_as_type (recording::type *m)\n+{\n+  return m->access_as_type (*this);\n+}\n+\n+/* Formatted printing, allocating to a buffer (or exiting the process if\n+   the allocation fails).\n+\n+   The buffer exists until the allocator is cleaned up, and is freed at\n+   that point, so the caller doesn't need to track the result.\n+\n+   Note that we can't use ggc_printf since we're not within the compiler\n+   proper (when within gcc_jit_context_dump_reproducer_to_file).  */\n+\n+char *\n+reproducer::xstrdup_printf (const char *fmt, ...)\n+{\n+  char *result;\n+  va_list ap;\n+  va_start (ap, fmt);\n+  result = m_allocator.xstrdup_printf_va (fmt, ap);\n+  va_end (ap);\n+  return result;\n }\n \n /**********************************************************************\n@@ -170,6 +458,7 @@ recording::playback_block (recording::block *b)\n recording::context::context (context *parent_ctxt)\n   : log_user (NULL),\n     m_parent_ctxt (parent_ctxt),\n+    m_toplevel_ctxt (m_parent_ctxt ? m_parent_ctxt->m_toplevel_ctxt : this),\n     m_error_count (0),\n     m_first_error_str (NULL),\n     m_owns_first_error_str (false),\n@@ -349,13 +638,15 @@ recording::context::new_string (const char *text)\n \n recording::location *\n recording::context::new_location (const char *filename,\n-\t\t\t\t int line,\n-\t\t\t\t int column)\n+\t\t\t\t  int line,\n+\t\t\t\t  int column,\n+\t\t\t\t  bool created_by_user)\n {\n   recording::location *result =\n     new recording::location (this,\n-\t\t\t    new_string (filename),\n-\t\t\t    line, column);\n+\t\t\t     new_string (filename),\n+\t\t\t     line, column,\n+\t\t\t     created_by_user);\n   record (result);\n   return result;\n }\n@@ -1036,6 +1327,196 @@ recording::context::dump_to_file (const char *path, bool update_locations)\n     }\n }\n \n+static const char * const\n+ str_option_reproducer_strings[GCC_JIT_NUM_STR_OPTIONS] = {\n+  \"GCC_JIT_STR_OPTION_PROGNAME\"\n+};\n+\n+static const char * const\n+ int_option_reproducer_strings[GCC_JIT_NUM_INT_OPTIONS] = {\n+  \"GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL\"\n+};\n+\n+static const char * const\n+ bool_option_reproducer_strings[GCC_JIT_NUM_BOOL_OPTIONS] = {\n+  \"GCC_JIT_BOOL_OPTION_DEBUGINFO\",\n+  \"GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE\",\n+  \"GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE\",\n+  \"GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE\",\n+  \"GCC_JIT_BOOL_OPTION_DUMP_SUMMARY\",\n+  \"GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING\",\n+  \"GCC_JIT_BOOL_OPTION_SELFCHECK_GC\",\n+  \"GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES\"\n+};\n+\n+/* Write C source code to PATH that attempts to replay the API\n+   calls made to this context (and its parents), for use in\n+   minimizing test cases for libgccjit.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_context_dump_reproducer_to_file.  */\n+\n+void\n+recording::context::dump_reproducer_to_file (const char *path)\n+{\n+  JIT_LOG_SCOPE (get_logger ());\n+  reproducer r (*this, path);\n+\n+  /* Generate the \"ancestry\" of this context, as a list.  */\n+  auto_vec <context *> ascending_contexts;\n+  for (context *ctxt = this; ctxt; ctxt = ctxt->m_parent_ctxt)\n+    ascending_contexts.safe_push (ctxt);\n+\n+  /* Reverse the list, giving a list of contexts from\n+     top-most parent context down through to youngest child context.\n+     We will use this list as the parameters of the functions in\n+     our generated file.  */\n+  unsigned num_ctxts = ascending_contexts.length ();\n+  auto_vec <context *> contexts (num_ctxts);\n+  for (unsigned i = 0; i < num_ctxts; i++)\n+    contexts.safe_push (ascending_contexts[num_ctxts - (i + 1)]);\n+\n+  /* contexts[0] should be the top-level context.  */\n+  gcc_assert (contexts[0]);\n+  gcc_assert (contexts[0]->m_toplevel_ctxt == contexts[0]);\n+\n+  /* The final element in contexts should be \"this\".  */\n+  gcc_assert (contexts[contexts.length () - 1] == this);\n+  gcc_assert (contexts[contexts.length () - 1]->m_toplevel_ctxt\n+\t      == contexts[0]);\n+\n+  r.write (\"/* This code was autogenerated by\"\n+\t   \" gcc_jit_context_dump_reproducer_to_file.  */\\n\\n\");\n+  r.write (\"#include <libgccjit.h>\\n\\n\");\n+  r.write (\"static void\\nset_options (\");\n+  r.write_params (contexts);\n+  r.write (\");\\n\\n\");\n+  r.write (\"static void\\ncreate_code (\");\n+  r.write_params (contexts);\n+  r.write (\");\\n\\n\");\n+  r.write (\"int\\nmain (int argc, const char **argv)\\n\");\n+  r.write (\"{\\n\");\n+  for (unsigned i = 0; i < num_ctxts; i++)\n+    r.write (\"  gcc_jit_context *%s;\\n\",\n+\t     r.get_identifier (contexts[i]));\n+  r.write (\"  gcc_jit_result *result;\\n\"\n+\t   \"\\n\");\n+\n+  /* Create the contexts.\n+     The top-level context is acquired from a clean slate, the others as\n+     children of the prior context.  */\n+  r.write (\"  %s = gcc_jit_context_acquire ();\\n\",\n+\t   r.get_identifier (contexts[0]));\n+  for (unsigned i = 1; i < num_ctxts; i++)\n+    r.write (\"  %s = gcc_jit_context_new_child_context (%s);\\n\",\n+\t     r.get_identifier (contexts[i]),\n+\t     r.get_identifier (contexts[i - 1]));\n+  r.write (\"  set_options (\");\n+  r.write_args (contexts);\n+  r.write (\");\\n\");\n+  r.write (\"  create_code (\");\n+  r.write_args (contexts);\n+  r.write (\");\\n\");\n+\n+  r.write (\"  result = gcc_jit_context_compile (%s);\\n\",\n+\t   r.get_identifier (this));\n+\n+  for (unsigned i = num_ctxts; i > 0; i--)\n+    r.write (\"  gcc_jit_context_release (%s);\\n\",\n+\t     r.get_identifier (contexts[i - 1]));\n+\n+  r.write (\"  gcc_jit_result_release (result);\\n\"\n+\t   \"  return 0;\\n\"\n+\t   \"}\\n\\n\");\n+\n+  /* Define (char *) variables for use in calls to\n+     gcc_jit_context_enable_dump.  */\n+  for (unsigned ctxt_idx = 0; ctxt_idx < num_ctxts; ctxt_idx++)\n+    {\n+      if (m_requested_dumps.length ())\n+\t{\n+\t  r.write (\"/* Requested dumps for %s.  */\\n\",\n+\t\t   r.get_identifier (contexts[ctxt_idx]));\n+\t  for (unsigned i = 0; i < m_requested_dumps.length (); i++)\n+\t    r.write (\"static char *dump_%p;\\n\",\n+\t\t     (void *)&m_requested_dumps[i]);\n+\t  r.write (\"\\n\");\n+\t}\n+    }\n+\n+  /* Write out values of options.  */\n+  r.write (\"static void\\nset_options (\");\n+  r.write_params (contexts);\n+  r.write (\")\\n{\\n\");\n+  for (unsigned ctxt_idx = 0; ctxt_idx < num_ctxts; ctxt_idx++)\n+    {\n+      if (ctxt_idx > 0)\n+\tr.write (\"\\n\");\n+\n+      r.write (\"  /* Set options for %s.  */\\n\",\n+\t       r.get_identifier (contexts[ctxt_idx]));\n+\n+      r.write (\"  /* String options.  */\\n\");\n+      for (int opt_idx = 0; opt_idx < GCC_JIT_NUM_STR_OPTIONS; opt_idx++)\n+\tr.write (\"  gcc_jit_context_set_str_option (%s,\\n\"\n+\t\t \"                                  %s,\\n\"\n+\t\t \"                                  \\\"%s\\\");\\n\",\n+\t\t r.get_identifier (contexts[ctxt_idx]),\n+\t\t str_option_reproducer_strings[opt_idx],\n+\t\t m_str_options[opt_idx] ? m_str_options[opt_idx] : \"NULL\");\n+      r.write (\"  /* Int options.  */\\n\");\n+      for (int opt_idx = 0; opt_idx < GCC_JIT_NUM_INT_OPTIONS; opt_idx++)\n+\tr.write (\"  gcc_jit_context_set_int_option (%s,\\n\"\n+\t\t \"                                  %s,\\n\"\n+\t\t \"                                  %i);\\n\",\n+\t\t r.get_identifier (contexts[ctxt_idx]),\n+\t\t int_option_reproducer_strings[opt_idx],\n+\t\t m_int_options[opt_idx]);\n+      r.write (\"  /* Boolean options.  */\\n\");\n+      for (int opt_idx = 0; opt_idx < GCC_JIT_NUM_BOOL_OPTIONS; opt_idx++)\n+\tr.write (\"  gcc_jit_context_set_bool_option (%s,\\n\"\n+\t\t \"                                  %s,\\n\"\n+\t\t \"                                  %i);\\n\",\n+\t\t r.get_identifier (contexts[ctxt_idx]),\n+\t\t bool_option_reproducer_strings[opt_idx],\n+\t\t m_bool_options[opt_idx]);\n+\n+      if (m_requested_dumps.length ())\n+\t{\n+\t  r.write (\"  /* Requested dumps.  */\\n\");\n+\t  /* Dumpfiles that were requested via gcc_jit_context_enable_dump.  */\n+\t  for (unsigned i = 0; i < m_requested_dumps.length (); i++)\n+\t    {\n+\t      r.write (\"  gcc_jit_context_enable_dump (%s,\\n\"\n+\t\t       \"                               \\\"%s\\\",\\n\"\n+\t\t       \"                               &dump_%p);\\n\",\n+\t\t       r.get_identifier (contexts[ctxt_idx]),\n+\t\t       m_requested_dumps[i].m_dumpname,\n+\t\t       (void *)&m_requested_dumps[i]);\n+\t    }\n+\t}\n+    }\n+  r.write (\"}\\n\\n\");\n+\n+  r.write (\"static void\\ncreate_code (\");\n+  r.write_params (contexts);\n+  r.write (\")\\n\"\n+\t   \"{\\n\");\n+  for (unsigned ctxt_idx = 0; ctxt_idx < num_ctxts; ctxt_idx++)\n+    {\n+      memento *m;\n+      int i;\n+      if (ctxt_idx > 0)\n+\tr.write (\"\\n\\n\");\n+\n+      r.write (\"  /* Replay of API calls for %s.  */\\n\",\n+\t       r.get_identifier (contexts[ctxt_idx]));\n+      FOR_EACH_VEC_ELT (contexts[ctxt_idx]->m_mementos, i, m)\n+\tm->write_reproducer (r);\n+    }\n+  r.write (\"}\\n\");\n+}\n+\n /* Copy the requested dumps within this context and all ancestors into\n    OUT. */\n \n@@ -1182,6 +1663,14 @@ recording::string::make_debug_string ()\n   return result;\n }\n \n+/* Implementation of recording::memento::write_reproducer for strings. */\n+\n+void\n+recording::string::write_reproducer (reproducer &)\n+{\n+  /* Empty.  */\n+}\n+\n /* The implementation of class gcc::jit::recording::location.  */\n \n /* Implementation of recording::memento::replay_into for locations.\n@@ -1211,6 +1700,23 @@ recording::location::make_debug_string ()\n \t\t\t      m_filename->c_str (), m_line, m_column);\n }\n \n+/* Implementation of recording::memento::write_reproducer for locations. */\n+\n+void\n+recording::location::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"loc\");\n+  r.write (\"  gcc_jit_location *%s =\\n\"\n+\t   \"    gcc_jit_context_new_location (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"    %s, /* const char *filename */\\n\"\n+\t   \"    %i, /* int line */\\n\"\n+\t   \"    %i);/* int column */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   m_filename->get_debug_string (),\n+\t   m_line, m_column);\n+}\n+\n /* The implementation of class gcc::jit::recording::type.  */\n \n /* Given a type T, get the type T*.\n@@ -1260,6 +1766,12 @@ recording::type::get_volatile ()\n   return result;\n }\n \n+const char *\n+recording::type::access_as_type (reproducer &r)\n+{\n+  return r.get_identifier (this);\n+}\n+\n /* Implementation of pure virtual hook recording::type::dereference for\n    recording::memento_of_get_type.  */\n \n@@ -1529,6 +2041,42 @@ recording::memento_of_get_type::make_debug_string ()\n   return m_ctxt->new_string (get_type_strings[m_kind]);\n }\n \n+static const char * const get_type_enum_strings[] = {\n+  \"GCC_JIT_TYPE_VOID\",\n+  \"GCC_JIT_TYPE_VOID_PTR\",\n+  \"GCC_JIT_TYPE_BOOL\",\n+  \"GCC_JIT_TYPE_CHAR\",\n+  \"GCC_JIT_TYPE_SIGNED_CHAR\",\n+  \"GCC_JIT_TYPE_UNSIGNED_CHAR\",\n+  \"GCC_JIT_TYPE_SHORT\",\n+  \"GCC_JIT_TYPE_UNSIGNED_SHORT\",\n+  \"GCC_JIT_TYPE_INT\",\n+  \"GCC_JIT_TYPE_UNSIGNED_INT\",\n+  \"GCC_JIT_TYPE_LONG\",\n+  \"GCC_JIT_TYPE_UNSIGNED_LONG\",\n+  \"GCC_JIT_TYPE_LONG_LONG\",\n+  \"GCC_JIT_TYPE_UNSIGNED_LONG_LONG\",\n+  \"GCC_JIT_TYPE_FLOAT\",\n+  \"GCC_JIT_TYPE_DOUBLE\",\n+  \"GCC_JIT_TYPE_LONG_DOUBLE\",\n+  \"GCC_JIT_TYPE_CONST_CHAR_PTR\",\n+  \"GCC_JIT_TYPE_SIZE_T\",\n+  \"GCC_JIT_TYPE_FILE_PTR\",\n+  \"GCC_JIT_TYPE_COMPLEX_FLOAT\",\n+  \"GCC_JIT_TYPE_COMPLEX_DOUBLE\",\n+  \"GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE\"\n+};\n+\n+void\n+recording::memento_of_get_type::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"type\");\n+  r.write (\"  gcc_jit_type *%s = gcc_jit_context_get_type (%s, %s);\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   get_type_enum_strings[m_kind]);\n+}\n+\n /* The implementation of class gcc::jit::recording::memento_of_get_pointer.  */\n \n /* Override of default implementation of\n@@ -1576,6 +2124,26 @@ recording::memento_of_get_pointer::make_debug_string ()\n \t\t\t      \"%s *\", m_other_type->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for get_pointer.  */\n+\n+void\n+recording::memento_of_get_pointer::write_reproducer (reproducer &r)\n+{\n+  /* We need to special-case function pointer types; see the notes in\n+     recording::function_type::write_deferred_reproducer.  */\n+  if (function_type *fn_type = m_other_type->dyn_cast_function_type ())\n+    {\n+      fn_type->write_deferred_reproducer (r, this);\n+      return;\n+    }\n+\n+  const char *id = r.make_identifier (this, \"type\");\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_type_get_pointer (%s);\\n\",\n+\t   id,\n+\t   r.get_identifier_as_type (m_other_type));\n+}\n+\n /* The implementation of class gcc::jit::recording::memento_of_get_const.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -1597,6 +2165,18 @@ recording::memento_of_get_const::make_debug_string ()\n \t\t\t      \"const %s\", m_other_type->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for const types. */\n+\n+void\n+recording::memento_of_get_const::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"type\");\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_type_get_const (%s);\\n\",\n+\t   id,\n+\t   r.get_identifier_as_type (m_other_type));\n+}\n+\n /* The implementation of class gcc::jit::recording::memento_of_get_volatile.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -1618,6 +2198,19 @@ recording::memento_of_get_volatile::make_debug_string ()\n \t\t\t      \"volatile %s\", m_other_type->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for volatile\n+   types. */\n+\n+void\n+recording::memento_of_get_volatile::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"type\");\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_type_get_volatile (%s);\\n\",\n+\t   id,\n+\t   r.get_identifier_as_type (m_other_type));\n+}\n+\n /* The implementation of class gcc::jit::recording::array_type */\n \n /* Implementation of pure virtual hook recording::type::dereference for\n@@ -1652,6 +2245,25 @@ recording::array_type::make_debug_string ()\n \t\t\t      m_num_elements);\n }\n \n+/* Implementation of recording::memento::write_reproducer for array\n+   types. */\n+\n+void\n+recording::array_type::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"array_type\");\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_context_new_array_type (%s,\\n\"\n+\t   \"                                    %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                    %s, /* gcc_jit_type *element_type */\\n\"\n+\t   \"                                    %i); /* int num_elements */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (m_element_type),\n+\t   m_num_elements);\n+}\n+\n /* The implementation of class gcc::jit::recording::function_type */\n \n /* Constructor for gcc::jit::recording::function_type.  */\n@@ -1775,6 +2387,55 @@ recording::function_type::make_debug_string_with (const char *insert)\n   return result;\n }\n \n+/* Implementation of recording::memento::write_reproducer for function\n+   types.  */\n+\n+void\n+recording::function_type::write_reproducer (reproducer &)\n+{\n+  /* see notes below.  */\n+}\n+\n+/* There's a get_pointer within context::new_function_ptr_type:\n+   the type received by client code isn't the memento for the\n+   function_type, but instead the result of get_pointer on it.\n+\n+   Hence we can't directly write a reproducer that gives function_type.\n+   Instead we special-case things within get_pointer, detecting this\n+   case, calling the following function.  */\n+\n+void\n+recording::function_type::write_deferred_reproducer (reproducer &r,\n+\t\t\t\t\t\t     memento *ptr_type)\n+{\n+  gcc_assert (ptr_type);\n+  r.make_identifier (this, \"function_type\");\n+  const char *ptr_id = r.make_identifier (ptr_type, \"ptr_to\");\n+  const char *param_types_id = r.make_tmp_identifier (\"params_for\", this);\n+  r.write (\"  gcc_jit_type *%s[%i] = {\\n\",\n+\t   param_types_id,\n+\t   m_param_types.length ());\n+  int i;\n+  type *param_type;\n+  FOR_EACH_VEC_ELT (m_param_types, i, param_type)\n+    r.write (\"    %s,\\n\", r.get_identifier_as_type (param_type));\n+  r.write (\"  };\\n\");\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_context_new_function_ptr_type (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                                           %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                           %s, /* gcc_jit_type *return_type */\\n\"\n+\t   \"                                           %i, /* int num_params */\\n\"\n+\t   \"                                           %s, /* gcc_jit_type **param_types */\\n\"\n+\t   \"                                           %i); /* int is_variadic */\\n\",\n+\t   ptr_id,\n+\t   r.get_identifier (get_context ()),\n+\t   \"NULL\", /* location is not stored */\n+\t   r.get_identifier_as_type (m_return_type),\n+\t   m_param_types.length (),\n+\t   param_types_id,\n+\t   m_is_variadic);\n+}\n+\n /* The implementation of class gcc::jit::recording::field.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -1811,6 +2472,24 @@ recording::field::make_debug_string ()\n   return m_name;\n }\n \n+/* Implementation of recording::memento::write_reproducer for fields.  */\n+\n+void\n+recording::field::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"field\");\n+  r.write(\"  gcc_jit_field *%s =\\n\"\n+\t  \"    gcc_jit_context_new_field (%s,\\n\"\n+\t  \"                               %s, /* gcc_jit_location *loc */\\n\"\n+\t  \"                               %s, /* gcc_jit_type *type, */\\n\"\n+\t  \"                               %s); /* const char *name */\\n\",\n+\t  id,\n+\t  r.get_identifier (get_context ()),\n+\t  r.get_identifier (m_loc),\n+\t  r.get_identifier_as_type (m_type),\n+\t  m_name->get_debug_string ());\n+}\n+\n /* The implementation of class gcc::jit::recording::compound_type */\n \n /* The constructor for gcc::jit::recording::compound_type.  */\n@@ -1875,6 +2554,13 @@ recording::struct_::replay_into (replayer *r)\n \t\t\t  true /* is_struct */));\n }\n \n+const char *\n+recording::struct_::access_as_type (reproducer &r)\n+{\n+  return r.xstrdup_printf (\"gcc_jit_struct_as_type (%s)\",\n+\t\t\t   r.get_identifier (this));\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    structs.  */\n \n@@ -1885,6 +2571,20 @@ recording::struct_::make_debug_string ()\n \t\t\t      \"struct %s\", get_name ()->c_str ());\n }\n \n+void\n+recording::struct_::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"struct\");\n+  r.write (\"  gcc_jit_struct *%s =\\n\"\n+\t   \"    gcc_jit_context_new_opaque_struct (%s,\\n\"\n+\t   \"                                       %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                       %s); /* const char *name */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   get_name ()->get_debug_string ());\n+}\n+\n /* The implementation of class gcc::jit::recording::union_.  */\n \n /* The constructor for gcc::jit::recording::union_.  */\n@@ -1918,6 +2618,35 @@ recording::union_::make_debug_string ()\n \t\t\t      \"union %s\", get_name ()->c_str ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for unions.  */\n+\n+void\n+recording::union_::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"union\");\n+\n+  const char *fields_id = r.make_tmp_identifier (\"fields_for\", this);\n+  r.write (\"  gcc_jit_field *%s[%i] = {\\n\",\n+\t   fields_id,\n+\t   get_fields ()->length ());\n+  for (int i = 0; i < get_fields ()->length (); i++)\n+    r.write (\"    %s,\\n\", r.get_identifier (get_fields ()->get_field (i)));\n+  r.write (\"  };\\n\");\n+\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_context_new_union_type (%s,\\n\"\n+\t   \"                                    %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                    %s, /* const char *name */\\n\"\n+\t   \"                                    %i, /* int num_fields */\\n\"\n+\t   \"                                    %s); /* gcc_jit_field **fields */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   get_name ()->get_debug_string (),\n+\t   get_fields ()->length (),\n+\t   fields_id);\n+}\n+\n /* The implementation of class gcc::jit::recording::fields.  */\n \n /* The constructor for gcc::jit::recording::fields.  */\n@@ -1975,6 +2704,38 @@ recording::fields::write_to_dump (dump &d)\n   d.write (\"};\\n\");\n }\n \n+/* Implementation of recording::memento::write_reproducer for the fields\n+   subclass.  */\n+\n+void\n+recording::fields::write_reproducer (reproducer &r)\n+{\n+  if (m_struct_or_union)\n+    if (NULL == m_struct_or_union->dyn_cast_struct ())\n+      /* We have a union; the fields have already been written by\n+\t union::write_reproducer.  */\n+      return;\n+\n+  const char *fields_id = r.make_identifier (this, \"fields\");\n+  r.write (\"  gcc_jit_field *%s[%i] = {\\n\",\n+\t   fields_id,\n+\t   m_fields.length ());\n+  int i;\n+  field *field;\n+  FOR_EACH_VEC_ELT (m_fields, i, field)\n+    r.write (\"    %s,\\n\", r.get_identifier (field));\n+  r.write (\"  };\\n\");\n+\n+  r.write (\"  gcc_jit_struct_set_fields (%s, /* gcc_jit_struct *struct_type */\\n\"\n+\t   \"                             %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                             %i, /* int num_fields */\\n\"\n+\t   \"                             %s); /* gcc_jit_field **fields */\\n\",\n+\t   r.get_identifier (m_struct_or_union),\n+\t   r.get_identifier ((memento *)NULL),\n+\t   m_fields.length (),\n+\t   fields_id);\n+}\n+\n /* Implementation of recording::memento::make_debug_string for\n    field tables.  */\n \n@@ -2143,6 +2904,17 @@ recording::rvalue::set_scope (function *scope)\n }\n \n \n+/* Implementation of recording::rvalue::access_as_rvalue for rvalues\n+   themselves.\n+   Instances of rvalue don't need an upcast call.  */\n+\n+const char *\n+recording::rvalue::access_as_rvalue (reproducer &r)\n+{\n+  return r.get_identifier (this);\n+}\n+\n+\n /* The implementation of class gcc::jit::recording::lvalue.  */\n \n /* Create a recording::new_access_field_of_lvalue instance and add it to\n@@ -2161,6 +2933,26 @@ recording::lvalue::access_field (recording::location *loc,\n   return result;\n }\n \n+/* Implementation of recording::rvalue::access_as_rvalue for lvalues.\n+   Instances of lvalue need to be wrapped in a gcc_jit_lvalue_as_rvalue\n+   upcast call.  */\n+\n+const char *\n+recording::lvalue::access_as_rvalue (reproducer &r)\n+{\n+  return r.xstrdup_printf (\"gcc_jit_lvalue_as_rvalue (%s)\",\n+\t\t\t   r.get_identifier (this));\n+}\n+\n+/* Implementation of recording::lvalue::access_as_lvalue for lvalues.\n+   Instances of lvalue don't need to be upcast.  */\n+\n+const char *\n+recording::lvalue::access_as_lvalue (reproducer &r)\n+{\n+  return r.get_identifier (this);\n+}\n+\n /* Create a recording::get_address_of_lvalue instance and add it to\n    the lvalue's context's list of mementos.\n \n@@ -2189,6 +2981,45 @@ recording::param::replay_into (replayer *r)\n \t\t\t\t  m_name->c_str ()));\n }\n \n+/* Implementation of recording::rvalue::access_as_rvalue for params.\n+   Instances of param need to be wrapped in a gcc_jit_param_as_rvalue\n+   upcast call.  */\n+\n+const char *\n+recording::param::access_as_rvalue (reproducer &r)\n+{\n+  return r.xstrdup_printf (\"gcc_jit_param_as_rvalue (%s)\",\n+\t\t\t   r.get_identifier (this));\n+}\n+\n+/* Implementation of recording::lvalue::access_as_lvalue for params.\n+   Instances of param need to be wrapped in a gcc_jit_param_as_lvalue\n+   upcast call.  */\n+\n+const char *\n+recording::param::access_as_lvalue (reproducer &r)\n+{\n+  return r.xstrdup_printf (\"gcc_jit_param_as_lvalue (%s)\",\n+\t\t\t   r.get_identifier (this));\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for params. */\n+\n+void\n+recording::param::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"param\");\n+  r.write (\"  gcc_jit_param *%s =\\n\"\n+\t   \"    gcc_jit_context_new_param (%s,\\n\"\n+\t   \"                               %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                               %s, /*gcc_jit_type *type */\\n\"\n+\t   \"                               %s); /* const char *name */\\n\",\n+\t   id,\n+    r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (m_type),\n+\t   m_name->get_debug_string ());\n+}\n \n /* The implementation of class gcc::jit::recording::function.  */\n \n@@ -2502,6 +3333,63 @@ recording::function::make_debug_string ()\n   return m_name;\n }\n \n+/* A table of enum gcc_jit_function_kind values expressed in string\n+   form.  */\n+\n+static const char * const names_of_function_kinds[] = {\n+  \"GCC_JIT_FUNCTION_EXPORTED\",\n+  \"GCC_JIT_FUNCTION_INTERNAL\",\n+  \"GCC_JIT_FUNCTION_IMPORTED\",\n+  \"GCC_JIT_FUNCTION_ALWAYS_INLINE\"\n+};\n+\n+/* Implementation of recording::memento::write_reproducer for functions. */\n+\n+void\n+recording::function::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"func\");\n+\n+  if (m_builtin_id)\n+    {\n+      r.write (\"  gcc_jit_function *%s =\\n\"\n+\t       \"    gcc_jit_context_get_builtin_function (%s,\\n\"\n+\t       \"                                          %s);\\n\",\n+\t       id,\n+\t       r.get_identifier (get_context ()),\n+\t       m_name->get_debug_string ());\n+      return;\n+    }\n+  const char *params_id = r.make_tmp_identifier (\"params_for\", this);\n+  r.write (\"  gcc_jit_param *%s[%i] = {\\n\",\n+\t   params_id,\n+\t   m_params.length ());\n+  int i;\n+  param *param;\n+  FOR_EACH_VEC_ELT (m_params, i, param)\n+    r.write (\"    %s,\\n\", r.get_identifier (param));\n+  r.write (\"  };\\n\");\n+  r.write (\"  gcc_jit_function *%s =\\n\"\n+\t   \"    gcc_jit_context_new_function (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                                  %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                  %s, /* enum gcc_jit_function_kind kind */\\n\"\n+\t   \"                                  %s, /* gcc_jit_type *return_type */\\n\"\n+\t   \"                                  %s, /* const char *name */\\n\"\n+\t   \"                                  %i, /* int num_params */\\n\"\n+\t   \"                                  %s, /* gcc_jit_param **params */\\n\"\n+\t   \"                                  %i); /* int is_variadic */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   names_of_function_kinds[m_kind],\n+\t   r.get_identifier_as_type (m_return_type),\n+\t   m_name->get_debug_string (),\n+\t   m_params.length (),\n+\t   params_id,\n+\t   m_is_variadic);\n+}\n+\n+\n /* The implementation of class gcc::jit::recording::block.  */\n \n /* Create a recording::eval instance and add it to\n@@ -2750,6 +3638,19 @@ recording::block::make_debug_string ()\n \t\t\t\t(void *)this);\n }\n \n+/* Implementation of recording::memento::write_reproducer for blocks. */\n+\n+void\n+recording::block::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"block\");\n+  r.write (\"  gcc_jit_block *%s =\\n\"\n+\t   \"    gcc_jit_function_new_block (%s, %s);\\n\",\n+\t   id,\n+\t   r.get_identifier (m_func),\n+\t   m_name ? m_name->get_debug_string () : \"NULL\");\n+}\n+\n /* Dump a block in graphviz form into PP, capturing the block name (if\n    any) and the statements.  */\n \n@@ -2856,6 +3757,35 @@ recording::global::write_to_dump (dump &d)\n \t   get_debug_string ());\n }\n \n+/* A table of enum gcc_jit_global_kind values expressed in string\n+   form.  */\n+\n+static const char * const global_kind_reproducer_strings[] = {\n+  \"GCC_JIT_GLOBAL_EXPORTED\",\n+  \"GCC_JIT_GLOBAL_INTERNAL\",\n+  \"GCC_JIT_GLOBAL_IMPORTED\"\n+};\n+\n+/* Implementation of recording::memento::write_reproducer for globals. */\n+\n+void\n+recording::global::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"block\");\n+  r.write (\"  gcc_jit_lvalue *%s =\\n\"\n+    \"    gcc_jit_context_new_global (%s, /* gcc_jit_context *ctxt */\\n\"\n+    \"                                %s, /* gcc_jit_location *loc */\\n\"\n+    \"                                %s, /* enum gcc_jit_global_kind kind */\\n\"\n+    \"                                %s, /* gcc_jit_type *type */\\n\"\n+    \"                                %s); /* const char *name */\\n\",\n+    id,\n+    r.get_identifier (get_context ()),\n+    r.get_identifier (m_loc),\n+    global_kind_reproducer_strings[m_kind],\n+    r.get_identifier_as_type (get_type ()),\n+    m_name->get_debug_string ());\n+}\n+\n /* The implementation of the various const-handling classes:\n    gcc::jit::recording::memento_of_new_rvalue_from_const <HOST_TYPE>.  */\n \n@@ -2878,9 +3808,10 @@ memento_of_new_rvalue_from_const <HOST_TYPE>::replay_into (replayer *r)\n \t\t\t\t\t     m_value));\n }\n \n-/* The make_debug_string method varies between the various\n-   memento_of_new_rvalue_from_const <HOST_TYPE> classes, so we explicitly\n-   write specializations of it.\n+/* The make_debug_string and write_reproducer methods vary between the\n+   various\n+     memento_of_new_rvalue_from_const <HOST_TYPE>\n+   classes, so we explicitly write specializations of them.\n \n    I (dmalcolm) find the code to be clearer if the \"recording\" vs \"playback\"\n    namespaces are written out explicitly, which is why most of this file\n@@ -2908,6 +3839,23 @@ memento_of_new_rvalue_from_const <int>::make_debug_string ()\n \t\t\t      m_value);\n }\n \n+/* The write_reproducer specialization for <int>.  */\n+\n+template <>\n+void\n+memento_of_new_rvalue_from_const <int>::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+    \"    gcc_jit_context_new_rvalue_from_int (%s, /* gcc_jit_context *ctxt */\\n\"\n+    \"                                         %s, /* gcc_jit_type *numeric_type */\\n\"\n+    \"                                         %i); /* int value */\\n\",\n+    id,\n+    r.get_identifier (get_context ()),\n+    r.get_identifier_as_type (m_type),\n+    m_value);\n+}\n+\n /* The make_debug_string specialization for <long>, rendering it as\n      (TARGET_TYPE)LITERAL\n    e.g.\n@@ -2923,6 +3871,44 @@ memento_of_new_rvalue_from_const <long>::make_debug_string ()\n \t\t\t      m_value);\n }\n \n+/* The write_reproducer specialization for <long>.  */\n+\n+template <>\n+void\n+recording::memento_of_new_rvalue_from_const <long>::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+\n+  /* We have to special-case LONG_MIN, since e.g.\n+       -9223372036854775808L\n+     is parsed as\n+       -(9223372036854775808L)\n+     and hence we'd get:\n+\terror: integer constant is so large that it is unsigned [-Werror]\n+\tWorkaround this by writing (LONG_MIN + 1) - 1.  */\n+  if (m_value == LONG_MIN)\n+    {\n+      r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t       \"    gcc_jit_context_new_rvalue_from_long (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t       \"                                          %s, /* gcc_jit_type *numeric_type */\\n\"\n+\t       \"                                          %ldL - 1); /* long value */\\n\",\n+\t       id,\n+\t       r.get_identifier (get_context ()),\n+\t       r.get_identifier_as_type (m_type),\n+\t       m_value + 1);;\n+      return;\n+    }\n+\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_rvalue_from_long (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                                          %s, /* gcc_jit_type *numeric_type */\\n\"\n+\t   \"                                          %ldL); /* long value */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier_as_type (m_type),\n+\t   m_value);\n+\t   }\n+\n /* The make_debug_string specialization for <double>, rendering it as\n      (TARGET_TYPE)LITERAL\n    e.g.\n@@ -2938,6 +3924,23 @@ memento_of_new_rvalue_from_const <double>::make_debug_string ()\n \t\t\t      m_value);\n }\n \n+/* The write_reproducer specialization for <double>.  */\n+\n+template <>\n+void\n+recording::memento_of_new_rvalue_from_const <double>::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+    \"    gcc_jit_context_new_rvalue_from_double (%s, /* gcc_jit_context *ctxt */\\n\"\n+    \"                                            %s, /* gcc_jit_type *numeric_type */\\n\"\n+    \"                                            %f); /* double value */\\n\",\n+    id,\n+    r.get_identifier (get_context ()),\n+    r.get_identifier_as_type (m_type),\n+    m_value);\n+}\n+\n /* The make_debug_string specialization for <void *>, rendering it as\n      (TARGET_TYPE)HEX\n    e.g.\n@@ -2960,8 +3963,34 @@ memento_of_new_rvalue_from_const <void *>::make_debug_string ()\n \t\t\t\tm_type->get_debug_string ());\n }\n \n-/* We're done specializing make_debug_string, so we can exit the\n-   gcc::jit::recording namespace.  */\n+/* Implementation of recording::memento::write_reproducer for <void *>\n+   values. */\n+\n+template <>\n+void\n+memento_of_new_rvalue_from_const <void *>::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  if (m_value)\n+    r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t     \"    gcc_jit_context_new_rvalue_from_ptr (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t     \"                                         %s, /* gcc_jit_type *pointer_type */\\n\"\n+\t     \"                                         (void *)%p); /* void *value */\\n\",\n+\t     id,\n+\t     r.get_identifier (get_context ()),\n+\t     r.get_identifier_as_type (m_type),\n+\t     m_value);\n+  else\n+    r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t     \"    gcc_jit_context_null (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t     \"                          %s); /* gcc_jit_type *pointer_type */\\n\",\n+\t     id,\n+\t     r.get_identifier (get_context ()),\n+\t     r.get_identifier_as_type (m_type));\n+}\n+\n+/* We're done specializing make_debug_string and write_reproducer, so we\n+   can exit the gcc::jit::recording namespace.  */\n \n } // namespace recording\n \n@@ -2986,6 +4015,21 @@ recording::memento_of_new_string_literal::make_debug_string ()\n \t\t\t      m_value->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for string literal\n+   values. */\n+\n+void\n+recording::memento_of_new_string_literal::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+    \"    gcc_jit_context_new_string_literal (%s, /* gcc_jit_context *ctxt */\\n\"\n+    \"                                        %s); /* const char *value */\\n\",\n+    id,\n+    r.get_identifier (get_context ()),\n+    m_value->get_debug_string ());\n+}\n+\n /* The implementation of class gcc::jit::recording::unary_op.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3027,6 +4071,33 @@ recording::unary_op::make_debug_string ()\n \t\t\t      m_a->get_debug_string ());\n }\n \n+static const char * const unary_op_reproducer_strings[] = {\n+  \"GCC_JIT_UNARY_OP_MINUS\",\n+  \"GCC_JIT_UNARY_OP_BITWISE_NEGATE\",\n+  \"GCC_JIT_UNARY_OP_LOGICAL_NEGATE\",\n+  \"GCC_JIT_UNARY_OP_ABS\"\n+};\n+\n+/* Implementation of recording::memento::write_reproducer for unary ops.  */\n+\n+void\n+recording::unary_op::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_unary_op (%s,\\n\"\n+\t   \"                                  %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                  %s, /* enum gcc_jit_unary_op op */\\n\"\n+\t   \"                                  %s, /* gcc_jit_type *result_type */\\n\"\n+\t   \"                                  %s); /* gcc_jit_rvalue *a */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   unary_op_reproducer_strings[m_op],\n+\t   r.get_identifier_as_type (get_type ()),\n+\t   r.get_identifier_as_rvalue (m_a));\n+}\n+\n /* The implementation of class gcc::jit::recording::binary_op.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3079,6 +4150,43 @@ recording::binary_op::make_debug_string ()\n \t\t\t      m_b->get_debug_string ());\n }\n \n+static const char * const binary_op_reproducer_strings[] = {\n+  \"GCC_JIT_BINARY_OP_PLUS\",\n+  \"GCC_JIT_BINARY_OP_MINUS\",\n+  \"GCC_JIT_BINARY_OP_MULT\",\n+  \"GCC_JIT_BINARY_OP_DIVIDE\",\n+  \"GCC_JIT_BINARY_OP_MODULO\",\n+  \"GCC_JIT_BINARY_OP_BITWISE_AND\",\n+  \"GCC_JIT_BINARY_OP_BITWISE_XOR\",\n+  \"GCC_JIT_BINARY_OP_BITWISE_OR\",\n+  \"GCC_JIT_BINARY_OP_LOGICAL_AND\",\n+  \"GCC_JIT_BINARY_OP_LOGICAL_OR\",\n+  \"GCC_JIT_BINARY_OP_LSHIFT\",\n+  \"GCC_JIT_BINARY_OP_RSHIFT\"\n+};\n+\n+/* Implementation of recording::memento::write_reproducer for binary ops.  */\n+\n+void\n+recording::binary_op::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_binary_op (%s,\\n\"\n+\t   \"                                   %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                   %s, /* enum gcc_jit_binary_op op */\\n\"\n+\t   \"                                   %s, /* gcc_jit_type *result_type */\\n\"\n+\t   \"                                   %s, /* gcc_jit_rvalue *a */\\n\"\n+\t   \"                                   %s); /* gcc_jit_rvalue *b */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   binary_op_reproducer_strings[m_op],\n+\t   r.get_identifier_as_type (get_type ()),\n+\t   r.get_identifier_as_rvalue (m_a),\n+\t   r.get_identifier_as_rvalue (m_b));\n+}\n+\n /* The implementation of class gcc::jit::recording::comparison.  */\n \n /* Implementation of recording::memento::make_debug_string for\n@@ -3104,6 +4212,39 @@ recording::comparison::make_debug_string ()\n \t\t\t      m_b->get_debug_string ());\n }\n \n+/* A table of enum gcc_jit_comparison values expressed in string\n+   form.  */\n+\n+static const char * const comparison_reproducer_strings[] =\n+{\n+  \"GCC_JIT_COMPARISON_EQ\",\n+  \"GCC_JIT_COMPARISON_NE\",\n+  \"GCC_JIT_COMPARISON_LT\",\n+  \"GCC_JIT_COMPARISON_LE\",\n+  \"GCC_JIT_COMPARISON_GT\",\n+  \"GCC_JIT_COMPARISON_GE\"\n+};\n+\n+/* Implementation of recording::memento::write_reproducer for comparisons.  */\n+\n+void\n+recording::comparison::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_comparison (%s,\\n\"\n+\t   \"                                    %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                    %s, /* enum gcc_jit_comparison op */\\n\"\n+\t   \"                                    %s, /* gcc_jit_rvalue *a */\\n\"\n+\t   \"                                    %s); /* gcc_jit_rvalue *b */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   comparison_reproducer_strings[m_op],\n+\t   r.get_identifier_as_rvalue (m_a),\n+\t   r.get_identifier_as_rvalue (m_b));\n+}\n+\n /* Implementation of pure virtual hook recording::memento::replay_into\n    for recording::comparison.  */\n \n@@ -3157,6 +4298,24 @@ recording::cast::make_debug_string ()\n \t\t\t      m_rvalue->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for casts.  */\n+\n+void\n+recording::cast::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_cast (%s,\\n\"\n+\t   \"                              %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                              %s, /* gcc_jit_rvalue *rvalue */\\n\"\n+\t   \"                              %s); /* gcc_jit_type *type */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_rvalue (m_rvalue),\n+\t   r.get_identifier_as_type (get_type ()));\n+}\n+\n /* The implementation of class gcc::jit::recording::call.  */\n \n /* The constructor for gcc::jit::recording::call.  */\n@@ -3242,6 +4401,31 @@ recording::call::make_debug_string ()\n   return result;\n }\n \n+void\n+recording::call::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"call\");\n+  const char *args_id = r.make_tmp_identifier (\"args_for_\", this);\n+  r.write (\"  gcc_jit_rvalue *%s[%i] = {\\n\",\n+\t   args_id,\n+\t   m_args.length ());\n+  for (unsigned i = 0; i< m_args.length (); i++)\n+    r.write (\"    %s,\\n\", r.get_identifier_as_rvalue (m_args[i]));\n+  r.write (\"  };\\n\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_call (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                              %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                              %s, /* gcc_jit_function *func */\\n\"\n+\t   \"                              %i, /* int numargs  */ \\n\"\n+\t   \"                              %s); /* gcc_jit_rvalue **args*/\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier (m_func),\n+\t   m_args.length (),\n+\t   args_id);\n+}\n+\n /* The implementation of class gcc::jit::recording::call_through_ptr.  */\n \n /* The constructor for recording::call_through_ptr. */\n@@ -3330,6 +4514,34 @@ recording::call_through_ptr::make_debug_string ()\n   return result;\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   call_through_ptr.  */\n+\n+void\n+recording::call_through_ptr::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"call\");\n+  const char *args_id = r.make_tmp_identifier (\"args_for_\", this);\n+  r.write (\"  gcc_jit_rvalue *%s[%i] = {\\n\",\n+\t     args_id,\n+\t     m_args.length ());\n+  for (unsigned i = 0; i< m_args.length (); i++)\n+    r.write (\"    %s,\\n\", r.get_identifier_as_rvalue (m_args[i]));\n+  r.write (\"  };\\n\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_context_new_call_through_ptr (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                              %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                              %s, /* gcc_jit_rvalue *fn_ptr */\\n\"\n+\t   \"                              %i, /* int numargs  */ \\n\"\n+\t   \"                              %s); /* gcc_jit_rvalue **args*/\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_rvalue (m_fn_ptr),\n+\t   m_args.length (),\n+\t   args_id);\n+}\n+\n /* The implementation of class gcc::jit::recording::array_access.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3366,6 +4578,25 @@ recording::array_access::make_debug_string ()\n \t\t\t      m_index->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   array_access.  */\n+\n+void\n+recording::array_access::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"lvalue\");\n+  r.write (\"  gcc_jit_lvalue *%s = \\n\"\n+\t   \"    gcc_jit_context_new_array_access (%s, /* gcc_jit_context *ctxt */\\n\"\n+\t   \"                                      %s, /*gcc_jit_location *loc */\\n\"\n+\t   \"                                      %s, /* gcc_jit_rvalue *ptr */\\n\"\n+\t   \"                                      %s); /* gcc_jit_rvalue *index */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_rvalue (m_ptr),\n+\t   r.get_identifier_as_rvalue (m_index));\n+}\n+\n /* The implementation of class gcc::jit::recording::access_field_of_lvalue.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3402,6 +4633,23 @@ recording::access_field_of_lvalue::make_debug_string ()\n \t\t\t      m_field->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   access_field_of_lvalue.  */\n+\n+void\n+recording::access_field_of_lvalue::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"lvalue\");\n+  r.write (\"  gcc_jit_lvalue *%s = \\n\"\n+\t   \"    gcc_jit_lvalue_access_field (%s, /*gcc_jit_lvalue *struct_or_union */\\n\"\n+\t   \"                                 %s, /*gcc_jit_location *loc */\\n\"\n+\t   \"                                 %s);\\n\",\n+\t   id,\n+\t   r.get_identifier_as_lvalue (m_lvalue),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier (m_field));\n+}\n+\n /* The implementation of class gcc::jit::recording::access_field_rvalue.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3437,6 +4685,23 @@ recording::access_field_rvalue::make_debug_string ()\n \t\t\t      m_field->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   access_field_rvalue.  */\n+\n+void\n+recording::access_field_rvalue::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  r.write (\"  gcc_jit_rvalue *%s = \\n\"\n+\t   \"    gcc_jit_rvalue_access_field (%s, /*gcc_jit_rvalue *struct_or_union */\\n\"\n+\t   \"                                 %s, /*gcc_jit_location *loc */\\n\"\n+\t   \"                                 %s);\\n\",\n+\t   id,\n+\t   r.get_identifier_as_rvalue (m_rvalue),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier (m_field));\n+}\n+\n /* The implementation of class\n    gcc::jit::recording::dereference_field_rvalue.  */\n \n@@ -3473,6 +4738,23 @@ recording::dereference_field_rvalue::make_debug_string ()\n \t\t\t      m_field->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   dereference_field_rvalue.  */\n+\n+void\n+recording::dereference_field_rvalue::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"lvalue\");\n+  r.write (\"  gcc_jit_lvalue *%s=\\n\"\n+\t   \"    gcc_jit_rvalue_dereference_field (%s, /* gcc_jit_rvalue *ptr */\\n\"\n+\t   \"                                      %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                      %s); /* gcc_jit_field *field */\\n\",\n+\t   id,\n+\t   r.get_identifier_as_rvalue (m_rvalue),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier (m_field));\n+}\n+\n /* The implementation of class gcc::jit::recording::dereference_rvalue.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3506,6 +4788,21 @@ recording::dereference_rvalue::make_debug_string ()\n \t\t\t      m_rvalue->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   dereference_rvalue.  */\n+\n+void\n+recording::dereference_rvalue::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"dereference\");\n+  r.write (\"  gcc_jit_lvalue *%s =\\n\"\n+\t   \"    gcc_jit_rvalue_dereference (%s, /* gcc_jit_rvalue *rvalue */\\n\"\n+\t   \"                                %s); /* gcc_jit_location *loc */\\n\",\n+\t   id,\n+\t   r.get_identifier_as_rvalue (m_rvalue),\n+\t   r.get_identifier (m_loc));\n+}\n+\n /* The implementation of class gcc::jit::recording::get_address_of_lvalue.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3539,6 +4836,21 @@ recording::get_address_of_lvalue::make_debug_string ()\n \t\t\t      m_lvalue->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   get_address_of_lvalue.  */\n+\n+void\n+recording::get_address_of_lvalue::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"address_of\");\n+  r.write (\"  gcc_jit_rvalue *%s =\\n\"\n+\t   \"    gcc_jit_lvalue_get_address (%s, /* gcc_jit_lvalue *lvalue */\\n\"\n+\t   \"                                %s); /* gcc_jit_location *loc */\\n\",\n+\t   id,\n+\t   r.get_identifier_as_lvalue (m_lvalue),\n+\t   r.get_identifier (m_loc));\n+}\n+\n /* The implementation of class gcc::jit::recording::local.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3570,6 +4882,22 @@ recording::local::write_to_dump (dump &d)\n \t  get_debug_string ());\n }\n \n+void\n+recording::local::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"local\");\n+  r.write (\"  gcc_jit_lvalue *%s =\\n\"\n+\t   \"    gcc_jit_function_new_local (%s, /* gcc_jit_function *func */\\n\"\n+\t   \"                                %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                %s, /* gcc_jit_type *type */\\n\"\n+\t   \"                                %s); /* const char *name */\\n\",\n+\t   id,\n+\t   r.get_identifier (m_func),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (m_type),\n+\t   m_name->get_debug_string ());\n+}\n+\n /* The implementation of class gcc::jit::recording::statement.  */\n \n /* We poison the default implementation of\n@@ -3624,6 +4952,20 @@ recording::eval::make_debug_string ()\n \t\t\t      m_rvalue->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   eval statements.  */\n+\n+void\n+recording::eval::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_block_add_eval (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                          %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                          %s); /* gcc_jit_rvalue *rvalue */\\n\",\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   r.get_identifier_as_rvalue (m_rvalue));\n+}\n+\n /* The implementation of class gcc::jit::recording::assignment.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3650,6 +4992,22 @@ recording::assignment::make_debug_string ()\n \t\t\t      m_rvalue->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   assignment statements.  */\n+\n+void\n+recording::assignment::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_block_add_assignment (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                                %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                %s, /* gcc_jit_lvalue *lvalue */\\n\"\n+\t   \"                                %s); /* gcc_jit_rvalue *rvalue */\\n\",\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   r.get_identifier_as_lvalue (m_lvalue),\n+\t   r.get_identifier_as_rvalue (m_rvalue));\n+}\n+\n /* The implementation of class gcc::jit::recording::assignment_op.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3687,6 +5045,24 @@ recording::assignment_op::make_debug_string ()\n \t\t\t      m_rvalue->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   assignment_op statements.  */\n+\n+void\n+recording::assignment_op::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_block_add_assignment_op (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                                   %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                   %s, /* gcc_jit_lvalue *lvalue */\\n\"\n+\t   \"                                   %s, /* enum gcc_jit_binary_op op */\\n\"\n+\t   \"                                   %s); /* gcc_jit_rvalue *rvalue */\\n\",\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   r.get_identifier_as_lvalue (m_lvalue),\n+\t   binary_op_reproducer_strings[m_op],\n+\t   r.get_identifier_as_rvalue (m_rvalue));\n+}\n+\n /* The implementation of class gcc::jit::recording::comment.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3711,6 +5087,20 @@ recording::comment::make_debug_string ()\n \t\t\t      m_text->c_str ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   comments.  */\n+\n+void\n+recording::comment::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_block_add_comment (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                             %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                             %s); /* const char *text */\\n\",\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   m_text->get_debug_string ());\n+}\n+\n /* The implementation of class gcc::jit::recording::conditional.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3759,6 +5149,24 @@ recording::conditional::make_debug_string ()\n \t\t\t\tm_on_true->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   conditional statements.  */\n+\n+void\n+recording::conditional::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_block_end_with_conditional (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                                      %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                                      %s, /* gcc_jit_rvalue *boolval */\\n\"\n+\t   \"                                      %s, /* gcc_jit_block *on_true */\\n\"\n+\t   \"                                      %s); /* gcc_jit_block *on_false */\\n\",\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   r.get_identifier_as_rvalue (m_boolval),\n+\t   r.get_identifier (m_on_true),\n+\t   r.get_identifier (m_on_false));\n+}\n+\n /* The implementation of class gcc::jit::recording::jump.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3796,6 +5204,20 @@ recording::jump::make_debug_string ()\n \t\t\t      m_target->get_debug_string ());\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   jump statements.  */\n+\n+void\n+recording::jump::write_reproducer (reproducer &r)\n+{\n+  r.write (\"  gcc_jit_block_end_with_jump (%s, /*gcc_jit_block *block */\\n\"\n+\t   \"                               %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                               %s); /* gcc_jit_block *target */\\n\",\n+\t   r.get_identifier (get_block ()),\n+\t   r.get_identifier (get_loc ()),\n+\t   r.get_identifier (m_target));\n+}\n+\n /* The implementation of class gcc::jit::recording::return_.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3836,6 +5258,26 @@ recording::return_::make_debug_string ()\n \t\t\t\t\"return;\");\n }\n \n+/* Implementation of recording::memento::write_reproducer for\n+   return statements.  */\n+\n+void\n+recording::return_::write_reproducer (reproducer &r)\n+{\n+  if (m_rvalue)\n+    r.write (\"  gcc_jit_block_end_with_return (%s, /*gcc_jit_block *block */\\n\"\n+\t     \"                                 %s, /* gcc_jit_location *loc */\\n\"\n+\t     \"                                 %s); /* gcc_jit_rvalue *rvalue */\\n\",\n+\t     r.get_identifier (get_block ()),\n+\t     r.get_identifier (get_loc ()),\n+\t     r.get_identifier_as_rvalue (m_rvalue));\n+  else\n+    r.write (\"  gcc_jit_block_end_with_void_return (%s, /*gcc_jit_block *block */\\n\"\n+\t     \"                                      %s); /* gcc_jit_location *loc */\\n\",\n+\t     r.get_identifier (get_block ()),\n+\t     r.get_identifier (get_loc ()));\n+}\n+\n } // namespace gcc::jit\n \n } // namespace gcc"}, {"sha": "57e71675c377ecd2135e40783d010379da0db0c9", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -30,6 +30,7 @@ namespace jit {\n \n class result;\n class dump;\n+class reproducer;\n \n /**********************************************************************\n  Recording.\n@@ -73,7 +74,8 @@ class context : public log_user\n   location *\n   new_location (const char *filename,\n \t\tint line,\n-\t\tint column);\n+\t\tint column,\n+\t\tbool created_by_user);\n \n   type *\n   get_type (enum gcc_jit_types type);\n@@ -244,6 +246,8 @@ class context : public log_user\n \n   void dump_to_file (const char *path, bool update_locations);\n \n+  void dump_reproducer_to_file (const char *path);\n+\n   void\n   get_all_requested_dumps (vec <recording::requested_dump> *out);\n \n@@ -253,6 +257,10 @@ class context : public log_user\n private:\n   context *m_parent_ctxt;\n \n+  /* The ultimate ancestor of the contexts within a family tree of\n+     contexts.  This has itself as its own m_toplevel_ctxt.  */\n+  context *m_toplevel_ctxt;\n+\n   int m_error_count;\n \n   char *m_first_error_str;\n@@ -314,6 +322,8 @@ class memento\n   get_debug_string ();\n \n   virtual void write_to_dump (dump &d);\n+  virtual void write_reproducer (reproducer &r) = 0;\n+  virtual location *dyn_cast_location () { return NULL; }\n \n protected:\n   memento (context *ctxt)\n@@ -355,6 +365,7 @@ class string : public memento\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   size_t m_len;\n@@ -364,11 +375,13 @@ class string : public memento\n class location : public memento\n {\n public:\n-  location (context *ctxt, string *filename, int line, int column)\n+  location (context *ctxt, string *filename, int line, int column,\n+\t    bool created_by_user)\n   : memento (ctxt),\n     m_filename (filename),\n     m_line (line),\n-    m_column (column)\n+    m_column (column),\n+    m_created_by_user (created_by_user)\n  {}\n \n   void replay_into (replayer *r);\n@@ -400,13 +413,18 @@ class location : public memento\n     return static_cast <playback::location *> (m_playback_obj);\n   }\n \n+  location *dyn_cast_location () { return this; }\n+  bool created_by_user () const { return m_created_by_user; }\n+\n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   string *m_filename;\n   int m_line;\n   int m_column;\n+  bool m_created_by_user;\n };\n \n class type : public memento\n@@ -458,6 +476,8 @@ class type : public memento\n     return static_cast <playback::type *> (m_playback_obj);\n   }\n \n+  virtual const char *access_as_type (reproducer &r);\n+\n protected:\n   type (context *ctxt)\n     : memento (ctxt),\n@@ -504,6 +524,7 @@ class memento_of_get_type : public type\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   enum gcc_jit_types m_kind;\n@@ -531,6 +552,7 @@ class memento_of_get_pointer : public type\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   type *m_other_type;\n@@ -565,6 +587,7 @@ class memento_of_get_const : public type\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   type *m_other_type;\n@@ -593,6 +616,7 @@ class memento_of_get_volatile : public type\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   type *m_other_type;\n@@ -623,6 +647,7 @@ class array_type : public type\n \n  private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n  private:\n   location *m_loc;\n@@ -657,9 +682,14 @@ class function_type : public type\n \n   string * make_debug_string_with_ptr ();\n \n+  void\n+  write_deferred_reproducer (reproducer &r,\n+\t\t\t     memento *ptr_type);\n+\n  private:\n   string * make_debug_string ();\n   string * make_debug_string_with (const char *);\n+  void write_reproducer (reproducer &r);\n \n private:\n   type *m_return_type;\n@@ -698,6 +728,7 @@ class field : public memento\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   location *m_loc;\n@@ -757,9 +788,11 @@ class struct_ : public compound_type\n \n   void replay_into (replayer *r);\n \n+  const char *access_as_type (reproducer &r);\n+\n private:\n   string * make_debug_string ();\n-\n+  void write_reproducer (reproducer &r);\n };\n \n // memento of struct_::set_fields\n@@ -774,8 +807,12 @@ class fields : public memento\n \n   void write_to_dump (dump &d);\n \n+  int length () const { return m_fields.length (); }\n+  field *get_field (int i) const { return m_fields[i]; }\n+\n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   compound_type *m_struct_or_union;\n@@ -793,11 +830,11 @@ class union_ : public compound_type\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   location *m_loc;\n   string *m_name;\n-  fields *m_fields;\n };\n \n /* An abstract base class for operations that visit all rvalues within an\n@@ -861,6 +898,8 @@ class rvalue : public memento\n   /* Dynamic cast.  */\n   virtual param *dyn_cast_param () { return NULL; }\n \n+  virtual const char *access_as_rvalue (reproducer &r);\n+\n protected:\n   location *m_loc;\n   type *m_type;\n@@ -893,6 +932,9 @@ class lvalue : public rvalue\n \n   rvalue *\n   as_rvalue () { return this; }\n+\n+  const char *access_as_rvalue (reproducer &r);\n+  virtual const char *access_as_lvalue (reproducer &r);\n };\n \n class param : public lvalue\n@@ -920,8 +962,12 @@ class param : public lvalue\n \n   param *dyn_cast_param () { return this; }\n \n+  const char *access_as_rvalue (reproducer &r);\n+  const char *access_as_lvalue (reproducer &r);\n+\n private:\n   string * make_debug_string () { return m_name; }\n+  void write_reproducer (reproducer &r);\n \n private:\n   string *m_name;\n@@ -978,6 +1024,7 @@ class function : public memento\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   location *m_loc;\n@@ -1065,6 +1112,7 @@ class block : public memento\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n   void replay_into (replayer *r);\n \n@@ -1103,6 +1151,7 @@ class global : public lvalue\n \n private:\n   string * make_debug_string () { return m_name; }\n+  void write_reproducer (reproducer &r);\n \n private:\n   enum gcc_jit_global_kind m_kind;\n@@ -1126,6 +1175,7 @@ class memento_of_new_rvalue_from_const : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   HOST_TYPE m_value;\n@@ -1146,6 +1196,7 @@ class memento_of_new_string_literal : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   string *m_value;\n@@ -1170,6 +1221,7 @@ class unary_op : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   enum gcc_jit_unary_op m_op;\n@@ -1195,6 +1247,7 @@ class binary_op : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   enum gcc_jit_binary_op m_op;\n@@ -1221,6 +1274,7 @@ class comparison : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   enum gcc_jit_comparison m_op;\n@@ -1245,6 +1299,7 @@ class cast : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_rvalue;\n@@ -1265,6 +1320,7 @@ class call : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   function *m_func;\n@@ -1286,6 +1342,7 @@ class call_through_ptr : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_fn_ptr;\n@@ -1310,6 +1367,7 @@ class array_access : public lvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_ptr;\n@@ -1334,6 +1392,7 @@ class access_field_of_lvalue : public lvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   lvalue *m_lvalue;\n@@ -1358,6 +1417,7 @@ class access_field_rvalue : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_rvalue;\n@@ -1382,6 +1442,7 @@ class dereference_field_rvalue : public lvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_rvalue;\n@@ -1403,6 +1464,7 @@ class dereference_rvalue : public lvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_rvalue;\n@@ -1424,6 +1486,7 @@ class get_address_of_lvalue : public rvalue\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   lvalue *m_lvalue;\n@@ -1448,6 +1511,7 @@ class local : public lvalue\n \n private:\n   string * make_debug_string () { return m_name; }\n+  void write_reproducer (reproducer &r);\n \n private:\n   function *m_func;\n@@ -1495,6 +1559,7 @@ class eval : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_rvalue;\n@@ -1515,6 +1580,7 @@ class assignment : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   lvalue *m_lvalue;\n@@ -1538,6 +1604,7 @@ class assignment_op : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   lvalue *m_lvalue;\n@@ -1558,6 +1625,7 @@ class comment : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   string *m_text;\n@@ -1583,6 +1651,7 @@ class conditional : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_boolval;\n@@ -1606,6 +1675,7 @@ class jump : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   block *m_target;\n@@ -1627,6 +1697,7 @@ class return_ : public statement\n \n private:\n   string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n \n private:\n   rvalue *m_rvalue;"}, {"sha": "9b55c91df45ba66463b8bc343bb777513337bce2", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -106,6 +106,8 @@ namespace gccjit\n \t\t      int flags,\n \t\t      int verbosity);\n \n+    void dump_reproducer_to_file (const char *path);\n+\n     void set_str_option (enum gcc_jit_str_option opt,\n \t\t\t const char *value);\n \n@@ -558,6 +560,13 @@ context::set_logfile (FILE *logfile,\n \t\t\t       verbosity);\n }\n \n+inline void\n+context::dump_reproducer_to_file (const char *path)\n+{\n+  gcc_jit_context_dump_reproducer_to_file (m_inner_ctxt,\n+\t\t\t\t\t   path);\n+}\n+\n inline void\n context::set_str_option (enum gcc_jit_str_option opt,\n \t\t\t const char *value)"}, {"sha": "a78b3e7514cd9a922e52c04c52d69776ae1cc7a8", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -386,7 +386,7 @@ gcc_jit_context_new_location (gcc_jit_context *ctxt,\n {\n   RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n   JIT_LOG_FUNC (ctxt->get_logger ());\n-  return (gcc_jit_location *)ctxt->new_location (filename, line, column);\n+  return (gcc_jit_location *)ctxt->new_location (filename, line, column, true);\n }\n \n /* Public entrypoint.  See description in libgccjit.h.\n@@ -2234,6 +2234,22 @@ gcc_jit_context_set_logfile (gcc_jit_context *ctxt,\n   ctxt->set_logger (logger);\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::dump_reproducer_to_file method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_context_dump_reproducer_to_file (gcc_jit_context *ctxt,\n+\t\t\t\t\t const char *path)\n+{\n+  RETURN_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_IF_FAIL (path, ctxt, NULL, \"NULL path\");\n+  ctxt->dump_reproducer_to_file (path);\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the"}, {"sha": "2f410875c828686f13555c812d87e20d8ae6c717", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -1051,6 +1051,24 @@ gcc_jit_context_new_child_context (gcc_jit_context *parent_ctxt);\n  Implementation support.\n  **********************************************************************/\n \n+/* Write C source code into \"path\" that can be compiled into a\n+   self-contained executable (i.e. with libgccjit as the only dependency).\n+   The generated code will attempt to replay the API calls that have been\n+   made into the given context.\n+\n+   This may be useful when debugging the library or client code, for\n+   reducing a complicated recipe for reproducing a bug into a simpler\n+   form.\n+\n+   Typically you need to supply the option \"-Wno-unused-variable\" when\n+   compiling the generated file (since the result of each API call is\n+   assigned to a unique variable within the generated C source, and not\n+   all are necessarily then used).  */\n+\n+extern void\n+gcc_jit_context_dump_reproducer_to_file (gcc_jit_context *ctxt,\n+\t\t\t\t\t const char *path);\n+\n /* Enable the dumping of a specific set of internal state from the\n    compilation, capturing the result in-memory as a buffer.\n "}, {"sha": "93d5c26c8fece5d19b14e5411e6654b93020c6e1", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -33,6 +33,7 @@\n     gcc_jit_context_acquire;\n     gcc_jit_context_compile;\n     gcc_jit_context_dump_to_file;\n+    gcc_jit_context_dump_reproducer_to_file;\n     gcc_jit_context_enable_dump;\n     gcc_jit_context_get_builtin_function;\n     gcc_jit_context_get_first_error;"}, {"sha": "334e3e5af6567ee5b9612624a50c04930a0816b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -1,3 +1,18 @@\n+2015-01-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/harness.h (set_up_logging): Move string concatenation\n+\tinto...\n+\t(concat_strings): New function.\n+\t(dump_reproducer): New function.\n+\t(test_jit): Call dump_reproducer.\n+\t* jit.dg/jit.exp (is_testcase_meant_to_generate_a_reproducer): New\n+\tfunction.\n+\t(jit-dg-test): Delete any generated reproducer from previous runs.\n+\tVerify that a generated reproducer was created, and verify that it\n+\tcompiles.\n+\t* jit.dg/test-nested-contexts.c (main): Call\n+\tgcc_jit_context_dump_reproducer_to_file.\n+\n 2015-01-13  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.dg/aru-2.c: Add dg-require-profiling."}, {"sha": "6bbe7a7b2838bfc40708f74aba42b46072ce03cc", "filename": "gcc/testsuite/jit.dg/harness.h", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fharness.h?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -250,6 +250,23 @@ static void set_options (gcc_jit_context *ctxt, const char *argv0)\n     0);\n }\n \n+/* Concatenate two strings.  The result must be released using \"free\".  */\n+\n+char *\n+concat_strings (const char *prefix, const char *suffix)\n+{\n+  char *result = (char *)malloc (strlen (prefix) + strlen (suffix) + 1);\n+  if (!result)\n+    {\n+      fail (\"malloc failure\");\n+      return NULL;\n+    }\n+  strcpy (result, prefix);\n+  strcpy (result + strlen (prefix), suffix);\n+  result[strlen (prefix) + strlen (suffix)] = '\\0';\n+  return result;\n+}\n+\n #ifndef TEST_ESCHEWS_TEST_JIT\n /* Set up logging to a logfile of the form \"test-FOO.exe.log.txt\".\n \n@@ -271,18 +288,9 @@ set_up_logging (gcc_jit_context *ctxt, const char *argv0)\n   FILE *logfile = NULL;\n \n   /* Build a logfile name of the form \"test-FOO.exe.log.txt\".  */\n-  logfile_name = (char *)malloc (strlen (argv0)\n-\t\t\t\t + strlen (logfile_name_suffix)\n-\t\t\t\t + 1);\n+  logfile_name = concat_strings (argv0, logfile_name_suffix);\n   if (!logfile_name)\n-    {\n-      fail (\"malloc failure\");\n-      return NULL;\n-    }\n-  strcpy (logfile_name, argv0);\n-  strcpy (logfile_name + strlen (argv0), logfile_name_suffix);\n-  logfile_name[strlen (argv0) + strlen (logfile_name_suffix)] = '\\0';\n-\n+    return NULL;\n   logfile = fopen (logfile_name, \"w\");\n   CHECK_NON_NULL (logfile);\n   free (logfile_name);\n@@ -293,6 +301,21 @@ set_up_logging (gcc_jit_context *ctxt, const char *argv0)\n   return logfile;\n }\n \n+/* Exercise the API entrypoint:\n+     gcc_jit_context_dump_reproducer_to_file\n+   by calling it on the context, using the path expected by jit.exp.  */\n+static void\n+dump_reproducer (gcc_jit_context *ctxt, const char *argv0)\n+{\n+  char *reproducer_name;\n+  reproducer_name = concat_strings (argv0, \".reproducer.c\");\n+  if (!reproducer_name)\n+    return;\n+  note (\"%s: writing reproducer to %s\", test, reproducer_name);\n+  gcc_jit_context_dump_reproducer_to_file (ctxt, reproducer_name);\n+  free (reproducer_name);\n+}\n+\n /* Run one iteration of the test.  */\n static void\n test_jit (const char *argv0, void *user_data)\n@@ -314,6 +337,8 @@ test_jit (const char *argv0, void *user_data)\n \n   create_code (ctxt, user_data);\n \n+  dump_reproducer (ctxt, argv0);\n+\n   /* This actually calls into GCC and runs the build, all\n      in a mutex for now.  */\n   result = gcc_jit_context_compile (ctxt);"}, {"sha": "3caccceb3b246dd19b8c0c87f52810c545ba4717", "filename": "gcc/testsuite/jit.dg/jit.exp", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fjit.exp?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -301,6 +301,21 @@ set tests [lsort $tests]\n \n verbose \"tests: $tests\"\n \n+# Is testcase NAME meant to generate a reproducer?\n+proc is_testcase_meant_to_generate_a_reproducer {name} {\n+    # We expect most testcases to generate a reproducer.\n+    # The exceptions are the tutorials (which don't have a \"test-\"\n+    # prefix), and test-threads.c (which is unique).\n+    verbose \"is_testcase_meant_to_generate_a_reproducer: $name\"\n+    if { [string match \"*test-*\" $name] } {\n+\tif { [string match \"*test-threads.c\" $name] } {\n+\t    return 0\n+\t}\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n # libgloss has found the driver (as \"xgcc\" or \"gcc) and stored\n # its full path as GCC_UNDER_TEST.\n proc get_path_of_driver {} {\n@@ -365,6 +380,14 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n       return\n     }\n \n+    # Most of the test cases use gcc_jit_context_dump_reproducer_to_file\n+    # as they run to write out a .c file that reproduces their behavior,\n+    # exercising that API.\n+    set generated_reproducer \"${output_file}.reproducer.c\"\n+\n+    # Delete any such generated .c file from a previous run.\n+    catch \"exec rm -f $generated_reproducer\"\n+\n     # Run the test executable, capturing the PASS/FAIL textual output\n     # from the C API, converting it into the Tcl API.\n \n@@ -456,6 +479,54 @@ proc jit-dg-test { prog do_what extra_tool_flags } {\n \n     restore_ld_library_path_env_vars\n \n+    # Most of the test cases use gcc_jit_context_dump_reproducer_to_file\n+    # as they run to write out a .c file that reproduces their behavior,\n+    # exercising that API.\n+\n+    if { [is_testcase_meant_to_generate_a_reproducer $name] } {\n+\tverbose \"$name is meant to generate a reproducer\"\n+\t# Verify that a reproducer was generated\n+\tif { [file exists $generated_reproducer] == 1} {\n+\t    pass \"found generated reproducer: $generated_reproducer\"\n+\t    set output_file \"${generated_reproducer}.exe\"\n+\t    # (this overwrites output_file)\n+\n+\t    # Try to compile the generated reproducer\n+\t    verbose \"compilation_function=$compilation_function\"\n+\n+\t    # The .c file written by gcc_jit_context_dump_reproducer_to_file\n+\t    # assigns the result of each API call to a unique variable, and not\n+\t    # all are necessarily used, so we need -Wno-unused-variable.\n+\t    set options \\\n+\t\t\"{additional_flags=$extra_tool_flags -Wno-unused-variable}\"\n+\t    verbose \"options=$options\"\n+\n+\t    set comp_output2 [$compilation_function $generated_reproducer \\\n+\t\t\t\t  $output_file \"executable\" $options]\n+\t    if ![jit_check_compile \"generated reproducer from $name\" \"initial compilation\" \\\n+\t\t     $output_file $comp_output2] then {\n+\t\t\t return\n+\t\t     }\n+\n+\t    # The caller, dg-test, will verify comp_output, which contains\n+\t    # the output from compiling the testcase and will issue a fail\n+\t    # if it's non-empty (e.g. containing warnings, the\n+\t    # \"test for excess errors\").\n+\t    #\n+\t    # Append the output from compiling the reproducer, so that this is also\n+\t    # verified:\n+\t    append comp_output $comp_output2\n+\n+\t    # TODO: we should try to run the built executable\n+\t    # It's not quite a quine, since it embeds ptrs which could change\n+\t    # from run to run.\n+\t} else {\n+\t    fail \"did not find a generated reproducer: $generated_reproducer\"\n+\t}\n+    } else {\n+\tverbose \"$name is not meant to generate a reproducer\"\n+    }\n+\n     return [list $comp_output $output_file]\n }\n "}, {"sha": "451d69b22a5bad6129c947514ce463d56888e25a", "filename": "gcc/testsuite/jit.dg/test-nested-contexts.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-nested-contexts.c?ref=86d0ac8876cf8b9eebed0ca3caa31a83dfc8a17d", "patch": "@@ -626,6 +626,14 @@ main (int argc, char **argv)\n \t\t\t\t\t    \"dump-of-test-nested-contexts-bottom.c\",\n \t\t\t\t\t    1);\n \n+\t      /* Dump a reproducer for the bottom context.\n+\t\t The generated reproducer needs to also regenerate the\n+\t\t parent contexts, so this gives us test coverage for\n+\t\t that case.  */\n+\t      gcc_jit_context_dump_reproducer_to_file (\n+\t\tbottom_level.ctxt,\n+\t\t\"test-nested-contexts.c.exe.reproducer.c\");\n+\n \t      gcc_jit_result *bottom_result =\n \t\tgcc_jit_context_compile (bottom_level.ctxt);\n \t      verify_bottom_code (bottom_level.ctxt, bottom_result);"}]}