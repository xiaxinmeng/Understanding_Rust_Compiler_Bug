{"sha": "4ba9a1aa641fb88c0ede517de0cf4e86cd305b58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJhOWExYWE2NDFmYjg4YzBlZGU1MTdkZTBjZjRlODZjZDMwNWI1OA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-01-06T17:49:36Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-01-06T17:49:36Z"}, "message": "check-init.c: New file.\n\n \n\t* check-init.c:  New file.  Checks for definite assignment.\nVarious minor other changes;  see ChangeLog.\n\nFrom-SVN: r24522", "tree": {"sha": "93b2e15837f07366e2cd099a9483028a58ce79a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93b2e15837f07366e2cd099a9483028a58ce79a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58/comments", "author": null, "committer": null, "parents": [{"sha": "db84cc462232ae771283b4a81ef151e0008fa4d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db84cc462232ae771283b4a81ef151e0008fa4d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db84cc462232ae771283b4a81ef151e0008fa4d1"}], "stats": {"total": 702, "additions": 699, "deletions": 3}, "files": [{"sha": "e1630d4576f7e79f08f564c06a04bfa75799a28b", "filename": "gcc/java/check-init.c", "status": "added", "additions": 699, "deletions": 0, "changes": 699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=4ba9a1aa641fb88c0ede517de0cf4e86cd305b58", "patch": "@@ -0,0 +1,699 @@\n+/* Code to test for \"definitive assignment\".\n+\n+   Copyright (C) 1999  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, January 1999. */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"java-tree.h\"\n+#include \"toplev.h\" /* Needed for fatal. */\n+\n+/* The basic idea is that we assign each local variable declaration\n+   an index, and then we pass around bitstrings, where the i'th bit\n+   is set if decl whose DECL_BIT_INDEX is i is definitely assigned. */\n+\n+/* One segment of a bitstring. */\n+typedef unsigned int word;\n+\n+/* Pointer to a bitstring. */\n+typedef word *words;\n+\n+/* For a local VAR_DECL, holds the index into a words bitstring that\n+   specifies if this decl is definitively assigned.\n+   A DECL_BIT_INDEX of -1 means we no longer care. */\n+#define DECL_BIT_INDEX(DECL) DECL_FIELD_SIZE(DECL)\n+\n+/* Number of locals variables currently active. */\n+int num_current_locals = 0;\n+\n+/* The index of the first local variable in the current block.\n+\n+   The variables whose DECL_BIT_INDEX are in the range from\n+   start_current_locals (inclusive) up to num_current_locals (exclusive)\n+   are declared in the \"current\" block.  If there is a loop or branch\n+   form, we set start_current_locals to num_current_locals to indicate\n+   there is no current block.\n+\n+   The point is that if a variable in the current block is set,\n+   there are no other control paths that we have to worry about.\n+   Hence, we can remove it from the set of variables we are\n+   checking, making its bit index available for some other variable.\n+   For simplicity, we only do that if the variable's bit index\n+   is (num_current_locals-1);  freeing up its bit index is then\n+   just a simple matter of decrementing num_current_locals.\n+   The reason this is worth doing is that it is simple, and\n+   allows us to use short (usually one-word) bit-strings,\n+   even for methods with thousands of local variables, as\n+   long as most of them are initialized immediately after or in\n+   their declaration. */\n+int start_current_locals = 0;\n+\n+int num_current_words = 1;\n+\n+static tree wfl;\n+\n+#define COPYN(DST, SRC, NWORDS) memcpy (DST, SRC, NWORDS * sizeof(word))\n+#define COPY(DST, SRC) COPYN (DST, SRC, num_current_words)\n+\n+#define SET_ALL(DST) memset (DST, ~0, num_current_words * sizeof(word))\n+#define CLEAR_ALL(DST) memset (DST, 0, num_current_words * sizeof(word))\n+\n+#define INTERSECTN(DST, SRC1, SRC2, N) \\\n+  do { int n = N; \\\n+  while (--n >= 0) DST[n] = SRC1[n] & SRC2[n]; \\\n+  } while (0)\n+\n+#define UNION(DST, SRC1, SRC2) \\\n+  UNIONN (DST, SRC1, SRC2, num_current_words)\n+\n+#define UNIONN(DST, SRC1, SRC2, N) \\\n+  do { int n = N; \\\n+  while (--n >= 0) DST[n] = SRC1[n] | SRC2[n]; \\\n+  } while (0)\n+\n+#define INTERSECT(DST, SRC1, SRC2) \\\n+  INTERSECTN (DST, SRC1, SRC2, num_current_words)\n+\n+#define WORD_SIZE  ((unsigned int)(sizeof(word) * 8))\n+\n+static void check_bool_init PROTO ((tree, words, words, words));\n+static void check_init PROTO ((tree, words));\n+\n+#if 0\n+#define ALLOC_WORDS(NUM) ((word*) xmalloc ((NUM) * sizeof (word)))\n+#define FREE_WORDS(PTR) (free (PTR))\n+#else\n+#define ALLOC_WORDS(NUM) ((word*)alloca ((NUM) * sizeof (word)))\n+#define FREE_WORDS(PTR) ((void)0)\n+#endif\n+\n+#define SET_P(WORDS, BIT) \\\n+  (WORDS[BIT / WORD_SIZE] & (1 << (BIT % WORD_SIZE)))\n+\n+#define CLEAR_BIT(WORDS, BIT) \\\n+  (WORDS[BIT / WORD_SIZE] &= ~ (1 << (BIT % WORD_SIZE)))\n+\n+#define SET_BIT(WORDS, BIT) \\\n+  (WORDS[BIT / WORD_SIZE] |= (1 << (BIT % WORD_SIZE)))\n+\n+#define WORDS_NEEDED(BITS) (((BITS)+(WORD_SIZE-1))/(WORD_SIZE))\n+\n+/* Check a conditional form (TEST_EXP ? THEN_EXP : ELSE_EXP) for\n+   definite assignment.\n+   BEFORE, WHEN_FALSE, and WHEN_TRUE are as in check_bool_init. */\n+\n+void\n+check_cond_init (test_exp, then_exp, else_exp,\n+\t\t before, when_false, when_true)\n+     tree test_exp, then_exp, else_exp;\n+     words before, when_false, when_true;\n+{\n+  words tmp = ALLOC_WORDS (6 * num_current_words);\n+  words test_false = tmp;\n+  words test_true = tmp + num_current_words;\n+  words then_false = tmp + 2 * num_current_words;\n+  words then_true = tmp + 3 * num_current_words;\n+  words else_false = tmp + 4 * num_current_words;\n+  words else_true = tmp + 5 * num_current_words;\n+  check_bool_init (test_exp, before, test_false, test_true);\n+  check_bool_init (then_exp, test_true, then_false, then_true);\n+  check_bool_init (else_exp, test_false, else_false, else_true);\n+  INTERSECT (when_false, then_false, else_false);\n+  INTERSECT (when_true, then_true, else_true);\n+  FREE_WORDS (tmp);\n+}\n+\n+/* Check a boolean binary form CODE (EXP0, EXP1),\n+   where CODE is one of EQ_EXPR, BIT_AND_EXPR, or BIT_OR_EXPR.\n+   BEFORE, WHEN_FALSE, and WHEN_TRUE are as in check_bool_init. */\n+\n+static void\n+check_bool2_init (code, exp0, exp1, before, when_false, when_true)\n+     enumtree_code code;  tree exp0, exp1;\n+     words before, when_false, when_true;\n+{\n+  word buf[4];\n+  words tmp = num_current_words <= 1 ? buf\n+    : ALLOC_WORDS (4 * num_current_words);\n+  words when_false_0 = tmp;\n+  words when_false_1 = tmp+num_current_words;\n+  words when_true_0 = tmp+2*num_current_words;\n+  words when_true_1 = tmp+3*num_current_words;\n+  check_bool_init (exp0, before, when_false_0, when_true_0);\n+  INTERSECT (before, when_false_0, when_true_0);\n+  check_bool_init (exp1, before, when_false_1, when_true_1);\n+\n+  INTERSECT (before, when_false_1, when_true_1);\n+\n+  if (code == EQ_EXPR)\n+    {\n+      /* Now set:\n+       * when_true = (when_false_1 INTERSECTION when_true_1)\n+       *   UNION (when_true_0 INTERSECTION when_false_1)\n+       *   UNION (when_false_0 INTERSECTION when_true_1);\n+       * using when_false and before as temporary working areas.  */\n+      INTERSECT (when_true, when_true_0, when_false_1);\n+      INTERSECT (when_false, when_true_0, when_false_1);\n+      UNION (when_true, when_true, when_false);\n+      UNION (when_true, when_true, before);\n+\n+      /* Now set:\n+       * when_false = (when_false_1 INTERSECTION when_true_1)\n+       *   UNION (when_true_0 INTERSECTION when_true_1)\n+       *   UNION (when_false_0 INTERSECTION when_false_1);\n+       * using before as a temporary working area.  */\n+      INTERSECT (when_false, when_true_0, when_true_1);\n+      UNION (when_false, when_false, before);\n+      INTERSECT (before, when_false_0, when_false_1);\n+      UNION (when_false, when_false, before);\n+    }\n+  else if (code == BIT_AND_EXPR)\n+    {\n+      UNION (when_true, when_true_0, when_true_1);\n+      INTERSECT (when_false, when_false_0, when_false_1);\n+      UNION (when_false, before);\n+    }\n+  else /* if (code == BIT_OR_EXPR) */\n+    {\n+      UNION (when_false, when_false_0, when_false_1);\n+      INTERSECT (when_true, when_true_0, when_true_1);\n+      UNION (when_true, before);\n+    }\n+\n+  if (tmp != buf)\n+    FREE_WORDS (tmp);\n+}\n+\n+/* Check a boolean expression EXP for definite assignment.\n+   BEFORE is the set of variables definitely assigned before the conditional.\n+   (This bitstring may be modified arbitrarily in this function.)\n+   On output, WHEN_FALSE is the set of variables definitely assigned after\n+   the conditional when the conditional is false.\n+   On output, WHEN_TRUE is the set of variables definitely assigned after\n+   the conditional when the conditional is true.\n+   (WHEN_FALSE and WHEN_TRUE are overwriten with initial values ignored.)\n+   (None of BEFORE, WHEN_FALSE, or WHEN_TRUE can overlap, as they may\n+   be used as temporary working areas. */\n+*/\n+\n+static void\n+check_bool_init (exp, before, when_false, when_true)\n+     tree exp;\n+     words before, when_false, when_true;\n+{\n+  switch (TREE_CODE (exp))\n+    {\n+    case COND_EXPR:\n+      check_cond_init (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       TREE_OPERAND (exp, 2),\n+\t\t       before, when_false, when_true);\n+      return;\n+\n+    case TRUTH_ANDIF_EXPR:\n+      check_cond_init (TREE_OPERAND (exp, 0),\n+\t\t       TREE_OPERAND (exp, 1), boolean_false_node,\n+\t\t       before, when_false, when_true);\n+      return;\n+    case TRUTH_ORIF_EXPR:\n+      check_cond_init (TREE_OPERAND (exp, 0),\n+\t\t       boolean_true_node, TREE_OPERAND (exp, 1),\n+\t\t       before, when_false, when_true);\n+      return;\n+    case TRUTH_NOT_EXPR:\n+      check_bool_init (TREE_OPERAND (exp, 0), before, when_true, when_false);\n+      return;\n+    case MODIFY_EXPR:\n+      {\n+\ttree tmp = TREE_OPERAND (exp, 0);\n+\tif (TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n+\t  {\n+\t    int index;\n+\t    check_bool_init (TREE_OPERAND (exp, 1), before,\n+\t\t\t     when_false, when_true);\n+\t    index = DECL_BIT_INDEX (tmp);\n+\t    if (index >= 0)\n+\t      {\n+\t\tSET_BIT (when_false, index);\n+\t\tSET_BIT (when_true, index);\n+\t      }\n+\t    break;\n+\t  }\n+      }\n+      goto do_default;\n+\n+    case BIT_AND_EXPR:\n+    case BIT_OR_EXPR:\n+    case EQ_EXPR:\n+      check_bool2_init (TREE_CODE (exp),\n+\t\t\tTREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t\tbefore, when_false, when_true);\n+      return;\n+\n+    case BIT_XOR_EXPR:\n+    case NE_EXPR:\n+      /* Just like EQ_EXPR, but switch when_true and when_false. */\n+      check_bool2_init (EQ_EXPR, TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t\tbefore, when_true, when_false);\n+\n+      return;\n+\n+    case INTEGER_CST:\n+      if (integer_zerop (exp))\n+\t{\n+\t  SET_ALL (when_true);\n+\t  COPY (when_false, before);\n+\t}\n+      else\n+\t{\n+\t  SET_ALL (when_false);\n+\t  COPY (when_true, before);\n+\t}\n+      break;\n+    default:\n+    do_default:\n+      check_init (exp, before);\n+      COPY (when_false, before);\n+      COPY (when_true, before);\n+    }\n+}\n+\n+/* Used to keep track of control flow branches. */\n+\n+struct alternatives\n+{\n+  struct alternatives *outer;\n+\n+  /* The value of num_current_locals at the start of this compound. */\n+  int num_locals;\n+\n+  /* The value of the \"before\" set at the start of the control stucture.\n+   Used for SWITCH_EXPR but not set for LABELED_BLOCK_EXPR. */\n+  words saved;\n+\n+  int save_start_current_locals;\n+\n+  /* If num_current_words==1, combined==&one_word, for efficiency. */\n+  word one_word;\n+\n+  /* The intersection of the \"after\" sets from previous branches. */\n+  words combined;\n+\n+  tree block;\n+};\n+\n+struct alternatives * alternatives = NULL;\n+\n+#define BEGIN_ALTERNATIVES(before, current) \\\n+{ \\\n+  current.saved = NULL; \\\n+  current.num_locals = num_current_locals; \\\n+  current.combined = num_current_words <= 1 ? &current.one_word \\\n+    : ALLOC_WORDS (num_current_words); \\\n+  SET_ALL (current.combined); \\\n+  current.outer = alternatives; \\\n+  alternatives = &current; \\\n+  current.save_start_current_locals = start_current_locals; \\\n+  start_current_locals = num_current_locals; \\\n+}\n+\n+static void\n+done_alternative (after, current)\n+     words after;\n+     struct alternatives *current; \n+{\n+  INTERSECTN (current->combined, current->combined, after,\n+\t      WORDS_NEEDED (current->num_locals));\n+}\n+\n+#define END_ALTERNATIVES(after, current) \\\n+{ \\\n+  alternatives = current.outer; \\\n+  COPY (after, current.combined); \\\n+  if (current.combined != &current.one_word) \\\n+    FREE_WORDS (current.combined); \\\n+  start_current_locals = current.save_start_current_locals; \\\n+}\n+\n+/* Check for (un)initialized local variables in EXP.\n+*/\n+\n+static void\n+check_init (exp, before)\n+     tree exp;\n+     words before;\n+{\n+  tree tmp;\n+ again:\n+  switch (TREE_CODE (exp))\n+    {\n+    case VAR_DECL:\n+      if (! FIELD_STATIC (exp) && DECL_NAME (exp) != NULL_TREE)\n+\t{\n+\t  int index = DECL_BIT_INDEX (exp);\n+\t  if (index >= 0 && ! SET_P (before, index))\n+\t    {\n+#if 1\n+\t      parse_error_context (wfl,\n+\t\t\t\t   \"Variable `%s' may not have been initialized\"\n+\t\t\t\t   , IDENTIFIER_POINTER (DECL_NAME (exp)));\n+#else\n+\t      error_with_decl (exp, \"variable may be used uninitialized\");\n+#endif\n+\t      /* Suppress further errors. */\n+\t      DECL_BIT_INDEX (exp) = -1;\n+\t    }\n+\t}\n+      break;\n+    case MODIFY_EXPR:\n+      tmp = TREE_OPERAND (exp, 0);\n+      if (TREE_CODE (tmp) == VAR_DECL && ! FIELD_STATIC (tmp))\n+\t{\n+\t  int index;\n+\t  check_init (TREE_OPERAND (exp, 1), before);\n+\t  index = DECL_BIT_INDEX (tmp);\n+\t  if (index >= 0)\n+\t    SET_BIT (before, index);\n+\t  /* Minor optimization.  See comment for start_current_locals. */\n+\t  if (index >= start_current_locals\n+\t      && index == num_current_locals - 1)\n+\t    {\n+\t      num_current_locals--;\n+\t      DECL_BIT_INDEX (tmp) = -1;\n+\t    }\n+\t break;\n+       }\n+     else\n+       goto binop;\n+    case BLOCK:\n+      if (BLOCK_EXPR_BODY (exp))\n+\t{\n+\t  tree decl = BLOCK_EXPR_DECLS (exp);\n+\t  int words_needed;\n+\t  word* tmp;\n+\t  int i;\n+\t  int save_start_current_locals = start_current_locals;\n+\t  int save_num_current_words = num_current_words;\n+\t  start_current_locals = num_current_locals;\n+\t  for (;  decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t    {\n+\t      DECL_BIT_INDEX (decl) = num_current_locals++;\n+\t    }\n+\t  words_needed = WORDS_NEEDED (num_current_locals);\n+\t  if (words_needed > num_current_words)\n+\t    {\n+\t      tmp = ALLOC_WORDS (words_needed);\n+\t      COPY (tmp, before);\n+\t      num_current_words = words_needed;\n+\t    }\n+\t  else\n+\t    tmp = before;\n+\t  for (i = start_current_locals;  i < num_current_locals;  i++)\n+\t    CLEAR_BIT (tmp, i);\n+\t  check_init (BLOCK_EXPR_BODY (exp), tmp);\n+\t  num_current_locals = start_current_locals;\n+\t  start_current_locals = save_start_current_locals;\n+\t  if (tmp != before)\n+\t    {\n+\t      num_current_words = save_num_current_words;\n+\t      COPY (before, tmp);\n+\t      FREE_WORDS (tmp);\n+\t    }\n+\t}\n+      break;\n+    case LOOP_EXPR:\n+      {\n+\tstruct alternatives alt;\n+\tBEGIN_ALTERNATIVES (before, alt);\n+\talt.block = exp;\n+\tcheck_init (TREE_OPERAND (exp, 0), before);\n+\tdone_alternative (before, &alt);\n+\tEND_ALTERNATIVES (before, alt);\n+\treturn;\n+      }\n+    case EXIT_EXPR:\n+      {\n+\tstruct alternatives *alt = alternatives;\n+\twords tmp = ALLOC_WORDS (2 * num_current_words);\n+\twords when_true = tmp;\n+\twords when_false = tmp + num_current_words;\n+#ifdef ENABLE_CHECKING\n+\tif (TREE_CODE (alt->block) != LOOP_EXPR)\n+\t  fatal (\"internal error in check-init:  EXIT_EXPR not in LOOP_EXPR\");\n+#endif\n+\tcheck_bool_init (TREE_OPERAND (exp, 0), before, when_false, when_true);\n+\tdone_alternative (when_true, alt);\n+\tCOPY (before, when_false);\n+\tFREE_WORDS (tmp);\n+\treturn;\n+      }\n+    case LABELED_BLOCK_EXPR:\n+      {\n+\tstruct alternatives alt;\n+\tBEGIN_ALTERNATIVES (before, alt);\n+\talt.block = exp;\n+\tcheck_init (LABELED_BLOCK_BODY (exp), before);\n+\tdone_alternative (before, &alt);\n+\tEND_ALTERNATIVES (before, alt);\n+\treturn;\n+      }\n+    case EXIT_BLOCK_EXPR:\n+      {\n+\ttree block = TREE_OPERAND (exp, 0);\n+\tstruct alternatives *alt = alternatives;\n+\twhile (alt->block != block)\n+\t  alt = alt->outer;\n+\tdone_alternative (before, alt);\n+\tSET_ALL (before);\n+\treturn;\n+      }\n+    case SWITCH_EXPR:\n+      {\n+\tstruct alternatives alt;\n+\tcheck_init (TREE_OPERAND (exp, 0), before);\n+\tBEGIN_ALTERNATIVES (before, alt);\n+\talt.saved = ALLOC_WORDS (num_current_words);\n+\tCOPY (alt.saved, before);\n+\talt.block = exp;\n+\tcheck_init (TREE_OPERAND (exp, 1), before);\n+\tdone_alternative (before, &alt);\n+\tFREE_WORDS (alt.saved);\n+\tEND_ALTERNATIVES (before, alt);\n+\treturn;\n+      }\n+    case CASE_EXPR:\n+    case DEFAULT_EXPR:\n+      {\n+\tint i;\n+\tstruct alternatives *alt = alternatives;\n+\twhile (TREE_CODE (alt->block) != SWITCH_EXPR)\n+\t  alt = alt->outer;\n+\tCOPYN (before, alt->saved, alt->num_locals);\n+\tfor (i = alt->num_locals;  i < num_current_locals;  i++)\n+\t  CLEAR_BIT (before, i);\n+\tbreak;\n+      }\n+\n+    case CLEANUP_POINT_EXPR:\n+      {\n+\tstruct alternatives alt;\n+\tBEGIN_ALTERNATIVES (before, alt);\n+\tCLEAR_ALL (alt.combined);\n+\tcheck_init (TREE_OPERAND (exp, 0), before); \n+\tUNION (alt.combined, alt.combined, before);\n+\tEND_ALTERNATIVES (before, alt);\n+      }\n+      return;\n+    case WITH_CLEANUP_EXPR:\n+      {\n+\tstruct alternatives *alt = alternatives;\t\n+#ifdef ENABLE_CHECKING\n+\tif (TREE_CODE (alt->block) != CLEANUP_POIN_EXPR)\n+\t  fatal (\"internal error in check-init:  WITH_CLEANUP_EXPR not in CLEANUP_POINT_EXPR\");\n+#endif\n+\tcheck_init (TREE_OPERAND (exp, 0), before);\n+\tUNION (alt->combined, alt->combined, before);\n+\tcheck_init (TREE_OPERAND (exp, 2), alt->combined);\n+\treturn;\n+      }\n+\n+    case TRY_EXPR:\n+      {\n+\ttree try_clause = TREE_OPERAND (exp, 0);\n+\ttree clause = TREE_OPERAND (exp, 1);\n+        tree finally = TREE_OPERAND (exp, 2);\n+\twords save = ALLOC_WORDS (num_current_words);\n+\twords tmp = ALLOC_WORDS (num_current_words);\n+\tstruct alternatives alt;\n+\tBEGIN_ALTERNATIVES (before, alt);\n+\tCOPY (save, before);\n+\tCOPY (tmp, save);\n+\tcheck_init (try_clause, tmp);\n+\tdone_alternative (tmp, &alt);\n+\tfor ( ; clause != NULL_TREE;  clause = TREE_CHAIN (clause))\n+\t  {\n+\t    tree catch_clause = TREE_OPERAND (clause, 0);\n+\t    COPY (tmp, save);\n+\t    check_init (catch_clause, tmp);\n+\t    done_alternative (tmp, &alt);\n+\t  }\n+\tif (finally != NULL_TREE)\n+\t  {\n+\t    check_init (finally, save);\n+\t    UNION (alt.combined, alt.combined, save);\n+\t  }\n+\tFREE_WORDS (tmp);\n+\tFREE_WORDS (save);\n+\tEND_ALTERNATIVES (before, alt);\n+      }\n+    return;\n+\n+    case RETURN_EXPR:\n+    case THROW_EXPR:\n+      if (TREE_OPERAND (exp, 0))\n+\tcheck_init (TREE_OPERAND (exp, 0), before);\n+      SET_ALL (before);\n+      return;\n+\n+    case ERROR_MARK:\n+      SET_ALL (before);\n+      break;\n+      \n+    case COND_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      {\n+\twords tmp = ALLOC_WORDS (2 * num_current_words);\n+\twords when_true = tmp;\n+\twords when_false = tmp + num_current_words;\n+\tcheck_bool_init (exp, before, when_false, when_true);\n+\tINTERSECT (before, when_false, when_true);\n+\tFREE_WORDS (tmp);\n+      }\n+      break;\n+    case UNARY_PLUS_EXPR:\n+    case NEGATE_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case BIT_NOT_EXPR:\n+    case CONVERT_EXPR:\n+    case COMPONENT_REF:\n+    case NOP_EXPR:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case INDIRECT_REF:\n+    case ADDR_EXPR:\n+    case SAVE_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case INSTANCEOF_EXPR:\n+      /* Avoid needless recursion. */\n+      exp = TREE_OPERAND (exp, 0);\n+      goto again;\n+\n+    case COMPOUND_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case URSHIFT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_IOR_EXPR:\n+    case EQ_EXPR: \n+    case NE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case ARRAY_REF:\n+    binop:\n+      check_init (TREE_OPERAND (exp, 0), before);\n+      /* Avoid needless recursion, especially for COMPOUND_EXPR. */\n+      exp = TREE_OPERAND (exp, 1);\n+      goto again;\n+\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case FUNCTION_DECL:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+      break;\n+\n+    case NEW_CLASS_EXPR:\n+    case CALL_EXPR:\n+      {\n+\ttree x = TREE_OPERAND (exp, 1);\n+\tcheck_init (TREE_OPERAND (exp, 0), before);\n+\t\n+\tfor ( ;  x != NULL_TREE;  x = TREE_CHAIN (x))\n+\t  check_init (TREE_VALUE (x), before);\n+      }\n+      break;\n+\n+    case NEW_ARRAY_INIT:\n+      {\n+\ttree x = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n+\tfor ( ;  x != NULL_TREE;  x = TREE_CHAIN (x))\n+\t  check_init (TREE_VALUE (x), before);\n+      }\n+      break;\n+\n+    case EXPR_WITH_FILE_LOCATION:\n+      {\n+\tchar *saved_input_filename = input_filename;\n+\ttree saved_wfl = wfl;\n+\ttree body = EXPR_WFL_NODE (exp);\n+\tint saved_lineno = lineno;\n+\tif (body == empty_stmt_node)\n+\t  break;\n+\twfl = exp;\n+\tinput_filename = EXPR_WFL_FILENAME (exp);\n+\tlineno = EXPR_WFL_LINENO (exp);\n+\tcheck_init (body, before);\n+\tinput_filename = saved_input_filename;\n+\tlineno = saved_lineno;\n+\twfl = saved_wfl;\n+      }\n+      break;\n+      \n+    default:\n+      fatal (\"internal error in check-init: tree code not implemented: %s\",\n+\t    tree_code_name [(int) TREE_CODE (exp)]);\n+    }\n+}\n+\n+void\n+check_for_initialization (body)\n+     tree body;\n+{\n+  word before = 0;\n+  check_init (body, &before);\n+}"}, {"sha": "72beb58aec73f16e790a5d53dc8b4f129df0f8a7", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba9a1aa641fb88c0ede517de0cf4e86cd305b58/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=4ba9a1aa641fb88c0ede517de0cf4e86cd305b58", "patch": "@@ -459,9 +459,6 @@ static jdeplist *reverse_jdep_list ();\n     BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl)) = (NODE); \\\n   }\n \n-#define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n-#define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)\n-\n /* For an artificial BLOCK (created to house a local variable declaration not\n    at the start of an existing block), the parent block;  otherwise NULL. */\n #define BLOCK_EXPR_ORIGIN(NODE) BLOCK_ABSTRACT_ORIGIN(NODE)"}]}