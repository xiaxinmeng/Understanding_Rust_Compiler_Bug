{"sha": "d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIwODhiYjZkNGIxNDc5YjIwY2RhMzM1NjZmZTliMmE1ZDkzZWY3MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-06-18T23:04:28Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-06-18T23:04:28Z"}, "message": "re PR fortran/20863 ([4.2 only] Pointer problems in PURE procedures)\n\n2007-06-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20863\n\tPR fortran/20082\n\t* resolve.c (resolve_code): Use gfc_impure_variable as a\n\tcondition for rejecting derived types with pointers, in pure\n\tprocedures.\n\t(gfc_impure_variable): Add test for dummy arguments of pure\n\tprocedures; any for functions and INTENT_IN for subroutines.\n\n\tPR fortran/32236\n\t* data.c (gfc_assign_data_value): Change the ICE on an array\n\treference initializer not being an array into an error and\n\tclear init to prevent a repetition of the error.\n\n2007-06-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20863\n\tPR fortran/20082\n\t* gfortran.dg/impure_assignment_2.f90 : New test.\n\n\tPR fortran/32236\n\t* gfortran.dg/data_initialized_2.f90 : New test.\n\n\t* gfortran.dg/equiv_7.f90 : Test for endianess and call the\n\tappropriate version of 'dmach'.\n\nFrom-SVN: r125831", "tree": {"sha": "7d45bf1db41df308e809b253c3da9adb9df0e104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d45bf1db41df308e809b253c3da9adb9df0e104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/comments", "author": null, "committer": null, "parents": [{"sha": "80dcd3aa9b5758de4ac34c687d71e1457e45e572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80dcd3aa9b5758de4ac34c687d71e1457e45e572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80dcd3aa9b5758de4ac34c687d71e1457e45e572"}], "stats": {"total": 178, "additions": 164, "deletions": 14}, "files": [{"sha": "74b8103d61e9a38194e051aa8c4aa56e9f28e959", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -1,3 +1,18 @@\n+2007-06-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20863\n+\tPR fortran/20082\n+\t* resolve.c (resolve_code): Use gfc_impure_variable as a\n+\tcondition for rejecting derived types with pointers, in pure\n+\tprocedures.\n+\t(gfc_impure_variable): Add test for dummy arguments of pure\n+\tprocedures; any for functions and INTENT_IN for subroutines.\n+\n+\tPR fortran/32236\n+\t* data.c (gfc_assign_data_value): Change the ICE on an array\n+\treference initializer not being an array into an error and\n+\tclear init to prevent a repetition of the error.\n+\n 2007-06-17  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* gfortran.texi: Add documentation for GFORTRAN_UNBUFFERED_n"}, {"sha": "35213a8fdb3897e08fc108e8f8e7ceacde251e12", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -288,6 +288,15 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n       switch (ref->type)\n \t{\n \tcase REF_ARRAY:\n+\t  if (init && expr->expr_type != EXPR_ARRAY)\n+\t    {\n+\t      gfc_error (\"'%s' at %L already is initialized at %L\",\n+\t\t\t lvalue->symtree->n.sym->name, &lvalue->where,\n+\t\t\t &init->where);\n+\t      gfc_free_expr (init);\n+\t      init = NULL;\n+\t    }\n+\n \t  if (init == NULL)\n \t    {\n \t      /* The element typespec will be the same as the array\n@@ -297,8 +306,6 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n \t      expr->expr_type = EXPR_ARRAY;\n \t      expr->rank = ref->u.ar.as->rank;\n \t    }\n-\t  else\n-\t    gcc_assert (expr->expr_type == EXPR_ARRAY);\n \n \t  if (ref->u.ar.type == AR_ELEMENT)\n \t    get_array_index (&ref->u.ar, &offset);"}, {"sha": "cbf4f7cea29921e1065b57c6e7dbec1784a07f98", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -5266,17 +5266,20 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t\t  break;\n \t\t}\n \n-\t      if (code->expr2->ts.type == BT_DERIVED\n-\t\t  && derived_pointer (code->expr2->ts.derived))\n+\t      if (code->expr->ts.type == BT_DERIVED\n+\t\t    && code->expr->expr_type == EXPR_VARIABLE\n+\t\t    && derived_pointer (code->expr->ts.derived)\n+\t\t    && gfc_impure_variable (code->expr2->symtree->n.sym))\n \t\t{\n-\t\t  gfc_error (\"Right side of assignment at %L is a derived \"\n-\t\t\t     \"type containing a POINTER in a PURE procedure\",\n+\t\t  gfc_error (\"The impure variable at %L is assigned to \"\n+\t\t\t     \"a derived type variable with a POINTER \"\n+\t\t\t     \"component in a PURE procedure (12.6)\",\n \t\t\t     &code->expr2->where);\n \t\t  break;\n \t\t}\n \t    }\n \n-\t  gfc_check_assign (code->expr, code->expr2, 1);\n+\t    gfc_check_assign (code->expr, code->expr2, 1);\n \t  break;\n \n \tcase EXEC_LABEL_ASSIGN:\n@@ -6800,21 +6803,36 @@ resolve_data (gfc_data * d)\n }\n \n \n+/* 12.6 Constraint: In a pure subprogram any variable which is in common or\n+   accessed by host or use association, is a dummy argument to a pure function,\n+   is a dummy argument with INTENT (IN) to a pure subroutine, or an object that\n+   is storage associated with any such variable, shall not be used in the\n+   following contexts: (clients of this function).  */\n+\n /* Determines if a variable is not 'pure', ie not assignable within a pure\n    procedure.  Returns zero if assignment is OK, nonzero if there is a\n    problem.  */\n-\n int\n gfc_impure_variable (gfc_symbol *sym)\n {\n+  gfc_symbol *proc;\n+\n   if (sym->attr.use_assoc || sym->attr.in_common)\n     return 1;\n \n   if (sym->ns != gfc_current_ns)\n     return !sym->attr.function;\n \n-  /* TODO: Check storage association through EQUIVALENCE statements */\n+  proc = sym->ns->proc_name;\n+  if (sym->attr.dummy && gfc_pure (proc)\n+\t&& ((proc->attr.subroutine && sym->attr.intent == INTENT_IN)\n+\t\t||\n+\t     proc->attr.function))\n+    return 1;\n \n+  /* TODO: Sort out what can be storage associated, if anything, and include\n+     it here.  In principle equivalences should be scanned but it does not\n+     seem to be possible to storage associate an impure variable this way.  */\n   return 0;\n }\n "}, {"sha": "583804722155535ffcf34c20ab182a9d59504556", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -1,3 +1,15 @@\n+2007-06-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20863\n+\tPR fortran/20082\n+\t* gfortran.dg/impure_assignment_2.f90 : New test.\n+\n+\tPR fortran/32236\n+\t* gfortran.dg/data_initialized_2.f90 : New test.\n+\n+\t* gfortran.dg/equiv_7.f90 : Test for endianess and call the\n+\tappropriate version of 'dmach'.\n+\n 2007-06-18  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/32389"}, {"sha": "c6331cd0c4f95ab06eef81484cbd04bf53ae2308", "filename": "gcc/testsuite/gfortran.dg/data_initialized_2.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_initialized_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_initialized_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_initialized_2.f90?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+! Tests the fix for PR32236, in which the error below manifested itself\n+! as an ICE.\n+! Contributed by Bob Arduini <r.f.arduini@larc.nasa.gov>\n+  real :: x(2) = 1.0 ! { dg-error \"already is initialized\" }\n+  data x /1.0, 2.0/  ! { dg-error \"already is initialized\" }\n+  print *, x\n+end"}, {"sha": "925f40ac1b448c8218d634e9138c8b3798ed555c", "filename": "gcc/testsuite/gfortran.dg/equiv_7.f90", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_7.f90?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -13,16 +13,26 @@\n   data cb /99/\n end block data\n \n+  integer(4), parameter :: abcd = ichar (\"a\") + 256_4 * (ichar(\"b\") + 256_4 * &\n+                                 (ichar (\"c\") + 256_4 * ichar (\"d\")))\n+  logical(4), parameter :: bigendian = transfer (abcd, \"wxyz\") .eq. \"abcd\"\n+\n   call int4_int4\n   call real4_real4\n   call complex_real\n   call check_block_data\n   call derived_types         ! Thanks to Tobias Burnus for this:)\n !\n-! This came up in PR29786 comment #9\n+! This came up in PR29786 comment #9 - Note the need to treat endianess\n+! Thanks Dominique d'Humieres:)\n !\n-  if (d1mach (1) .ne. transfer ((/0_4, 1048576_4/), 1d0)) call abort ()\n-  if (d1mach (2) .ne. transfer ((/-1_4,2146435071_4/), 1d0)) call abort ()\n+  if (bigendian) then\n+    if (d1mach_little (1) .ne. transfer ((/0_4, 1048576_4/), 1d0)) call abort ()\n+    if (d1mach_little (2) .ne. transfer ((/-1_4,2146435071_4/), 1d0)) call abort ()\n+  else\n+    if (d1mach_big (1) .ne. transfer ((/1048576_4, 0_4/), 1d0)) call abort ()\n+    if (d1mach_big (2) .ne. transfer ((/2146435071_4,-1_4/), 1d0)) call abort ()\n+  end if \n !\n contains\n   subroutine int4_int4\n@@ -59,7 +69,7 @@ subroutine check_block_data\n       integer(4) ca\n       if (any (ca .ne. (/42, 43, 99, 44/))) call abort ()\n   end subroutine check_block_data\n-  function d1mach(i)\n+  function d1mach_little(i) result(d1mach)\n     implicit none\n     double precision d1mach,dmach(5)\n     integer i,large(4),small(4)\n@@ -68,7 +78,17 @@ function d1mach(i)\n     data small(1),small(2) / 0,   1048576/\n     data large(1),large(2) /-1,2146435071/\n     d1mach = dmach(i) \n-  end function d1mach\n+  end function d1mach_little\n+  function d1mach_big(i) result(d1mach)\n+    implicit none\n+    double precision d1mach,dmach(5)\n+    integer i,large(4),small(4)\n+    equivalence ( dmach(1), small(1) )\n+    equivalence ( dmach(2), large(1) )\n+    data small(1),small(2) /1048576,    0/\n+    data large(1),large(2) /2146435071,-1/\n+    d1mach = dmach(i) \n+  end function d1mach_big\n     subroutine derived_types\n       TYPE T1\n         sequence"}, {"sha": "3b212c198972d05d80640803faf1aef1396de460", "filename": "gcc/testsuite/gfortran.dg/impure_assignment_2.f90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2088bb6d4b1479b20cda33566fe9b2a5d93ef70/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_2.f90?ref=d2088bb6d4b1479b20cda33566fe9b2a5d93ef70", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do compile }\n+! Tests the fix for PR20863 and PR20882, which were concerned with incorrect\n+! application of constraints associated with \"impure\" variables in PURE\n+! procedures.\n+!\n+! resolve.c (gfc_impure_variable) detects the following: \n+! 12.6 Constraint: In a pure subprogram any variable which is in common or\n+! accessed by host or use association, is a dummy argument to a pure function,\n+! is a dummy argument with INTENT (IN) to a pure subroutine, or an object that\n+! is storage associated with any such variable, shall not be used in the\n+! following contexts: (clients of this function).  */\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+MODULE pr20863\n+ TYPE node_type\n+  TYPE(node_type), POINTER :: next=>null()\n+ END TYPE\n+CONTAINS\n+! Original bug - pointer assignments to \"impure\" derived type with\n+! pointer component.\n+  PURE FUNCTION give_next1(node)\n+     TYPE(node_type), POINTER :: node\n+     TYPE(node_type), POINTER :: give_next\n+     give_next => node%next ! { dg-error \"Bad target\" }\n+     node%next => give_next ! { dg-error \"Bad pointer object\" }\n+  END FUNCTION\n+! Comment #2\n+  PURE integer FUNCTION give_next2(i)\n+     TYPE node_type\n+       sequence\n+       TYPE(node_type), POINTER :: next\n+     END TYPE\n+     TYPE(node_type), POINTER :: node\n+     TYPE(node_type), target  :: t\n+     integer, intent(in)      :: i\n+     node%next = t          ! This is OK\n+     give_next2 = i\n+  END FUNCTION\n+  PURE FUNCTION give_next3(node)\n+     TYPE(node_type), intent(in) :: node\n+     TYPE(node_type) :: give_next\n+     give_next = node ! { dg-error \"impure variable\" }\n+  END FUNCTION\n+END MODULE pr20863\n+\n+MODULE pr20882\n+  TYPE T1\n+    INTEGER :: I\n+  END TYPE T1\n+  TYPE(T1), POINTER :: B\n+CONTAINS\n+  PURE FUNCTION TST(A) RESULT(RES)\n+    TYPE(T1), INTENT(IN), TARGET :: A\n+    TYPE(T1), POINTER :: RES\n+    RES => A  ! { dg-error \"Bad target\" }\n+    RES => B  ! { dg-error \"Bad target\" }\n+    B => RES  ! { dg-error \"Bad pointer object\" }\n+  END FUNCTION\n+  PURE FUNCTION TST2(A) RESULT(RES)\n+    TYPE(T1), INTENT(IN), TARGET :: A\n+    TYPE(T1), POINTER :: RES\n+    allocate (RES)\n+    RES = A\n+    B = RES  ! { dg-error \"Cannot assign\" }\n+    RES = B\n+  END FUNCTION\n+END MODULE pr20882\n+! { dg-final { cleanup-modules \"pr20863 pr20882\" } }\n+"}]}