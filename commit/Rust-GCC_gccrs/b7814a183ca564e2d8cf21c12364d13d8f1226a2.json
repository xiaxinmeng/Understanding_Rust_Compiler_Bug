{"sha": "b7814a183ca564e2d8cf21c12364d13d8f1226a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4MTRhMTgzY2E1NjRlMmQ4Y2YyMWMxMjM2NGQxM2Q4ZjEyMjZhMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-04-02T12:54:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-04-02T12:54:08Z"}, "message": "re PR tree-optimization/14495 ([tree-ssa] Propagate range info into a switch statement)\n\n2008-04-02  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/14495\n\tPR tree-optimization/34793\n\t* tree-vrp.c (struct switch_update): New structure.\n\t(to_remove_edges, to_update_switch_stmts): New VECs.\n\t(simplify_switch_using_ranges): New function.  Remove not taken\n\tcase labels and edges.\n\t(simplify_stmt_using_ranges): Call it.\n\t(identify_jump_threads): Mark edges we have queued for removal\n\tso we don't thread them.\n\t(execute_vrp): Remove edges queued for removal, update SWITCH_STMT\n\tcase label vector.\n\t* tree-cfg.c (group_case_labels): Deal with missing default label.\n\t(tree_verify_flow_info): Allow missing default label.\n\t* stmt.c (emit_case_bit_tests): Deal with NULL default_label.\n\t(emit_case_nodes): Likewise.\n\t(expand_case): Do not rely on the default label to be present.\n\t* expr.c (try_casesi): Deal with NULL default_label.\n\t(do_tablejump): Likewise.\n\n\t* gcc.dg/tree-ssa/vrp41.c: New testcase.\n\t* gcc.dg/tree-ssa/vrp42.c: Likewise.\n\nFrom-SVN: r133835", "tree": {"sha": "aff8bcca1cbe2777fd11b65bc13de7e52af54d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aff8bcca1cbe2777fd11b65bc13de7e52af54d3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7814a183ca564e2d8cf21c12364d13d8f1226a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7814a183ca564e2d8cf21c12364d13d8f1226a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7814a183ca564e2d8cf21c12364d13d8f1226a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7814a183ca564e2d8cf21c12364d13d8f1226a2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0"}], "stats": {"total": 319, "additions": 276, "deletions": 43}, "files": [{"sha": "2bd5c04b214da2433053bd4047efd54d3d61ce17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -1,3 +1,24 @@\n+2008-04-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/14495\n+\tPR tree-optimization/34793\n+\t* tree-vrp.c (struct switch_update): New structure.\n+\t(to_remove_edges, to_update_switch_stmts): New VECs.\n+\t(simplify_switch_using_ranges): New function.  Remove not taken\n+\tcase labels and edges.\n+\t(simplify_stmt_using_ranges): Call it.\n+\t(identify_jump_threads): Mark edges we have queued for removal\n+\tso we don't thread them.\n+\t(execute_vrp): Remove edges queued for removal, update SWITCH_STMT\n+\tcase label vector.\n+\t* tree-cfg.c (group_case_labels): Deal with missing default label.\n+\t(tree_verify_flow_info): Allow missing default label.\n+\t* stmt.c (emit_case_bit_tests): Deal with NULL default_label.\n+\t(emit_case_nodes): Likewise.\n+\t(expand_case): Do not rely on the default label to be present.\n+\t* expr.c (try_casesi): Deal with NULL default_label.\n+\t(do_tablejump): Likewise.\n+\n 2008-04-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/14495"}, {"sha": "a2bd86c4d0910a7cc6cc3f7f53a33e28d9295747", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -9851,8 +9851,9 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \t\t\t   index_expr, minval);\n       minval = integer_zero_node;\n       index = expand_normal (index_expr);\n-      emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n-\t\t\t       omode, 1, default_label);\n+      if (default_label)\n+        emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n+\t\t\t\t omode, 1, default_label);\n       /* Now we can safely truncate.  */\n       index = convert_to_mode (index_mode, index, 0);\n     }\n@@ -9931,8 +9932,9 @@ do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n      or equal to the minimum value of the range and less than or equal to\n      the maximum value of the range.  */\n \n-  emit_cmp_and_jump_insns (index, range, GTU, NULL_RTX, mode, 1,\n-\t\t\t   default_label);\n+  if (default_label)\n+    emit_cmp_and_jump_insns (index, range, GTU, NULL_RTX, mode, 1,\n+\t\t\t     default_label);\n \n   /* If index is in range, it must fit in Pmode.\n      Convert to Pmode so we can index with it.  */"}, {"sha": "6f8d4948d550b6820742b8a043a4898b44414067", "filename": "gcc/stmt.c", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -2258,8 +2258,9 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n \n   mode = TYPE_MODE (index_type);\n   expr = expand_normal (range);\n-  emit_cmp_and_jump_insns (index, expr, GTU, NULL_RTX, mode, 1,\n-\t\t\t   default_label);\n+  if (default_label)\n+    emit_cmp_and_jump_insns (index, expr, GTU, NULL_RTX, mode, 1,\n+\t\t\t     default_label);\n \n   index = convert_to_mode (word_mode, index, 0);\n   index = expand_binop (word_mode, ashl_optab, const1_rtx,\n@@ -2274,7 +2275,8 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n \t\t\t       word_mode, 1, test[i].label);\n     }\n \n-  emit_jump (default_label);\n+  if (default_label)\n+    emit_jump (default_label);\n }\n \n #ifndef HAVE_casesi\n@@ -2320,7 +2322,7 @@ expand_case (tree exp)\n   struct case_node *case_list = 0;\n \n   /* Label to jump to if no case matches.  */\n-  tree default_label_decl;\n+  tree default_label_decl = NULL_TREE;\n \n   alloc_pool case_node_pool = create_alloc_pool (\"struct case_node pool\",\n                                                  sizeof (struct case_node),\n@@ -2338,18 +2340,21 @@ expand_case (tree exp)\n     {\n       tree elt;\n       bitmap label_bitmap;\n+      int vl = TREE_VEC_LENGTH (vec);\n \n       /* cleanup_tree_cfg removes all SWITCH_EXPR with their index\n \t expressions being INTEGER_CST.  */\n       gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n \n-      /* The default case is at the end of TREE_VEC.  */\n-      elt = TREE_VEC_ELT (vec, TREE_VEC_LENGTH (vec) - 1);\n-      gcc_assert (!CASE_HIGH (elt));\n-      gcc_assert (!CASE_LOW (elt));\n-      default_label_decl = CASE_LABEL (elt);\n+      /* The default case, if ever taken, is at the end of TREE_VEC.  */\n+      elt = TREE_VEC_ELT (vec, vl - 1);\n+      if (!CASE_LOW (elt) && !CASE_HIGH (elt))\n+\t{\n+\t  default_label_decl = CASE_LABEL (elt);\n+\t  --vl;\n+\t}\n \n-      for (i = TREE_VEC_LENGTH (vec) - 1; --i >= 0; )\n+      for (i = vl - 1; i >= 0; --i)\n \t{\n \t  tree low, high;\n \t  elt = TREE_VEC_ELT (vec, i);\n@@ -2368,7 +2373,8 @@ expand_case (tree exp)\n \n \n       before_case = start = get_last_insn ();\n-      default_label = label_rtx (default_label_decl);\n+      if (default_label_decl)\n+\tdefault_label = label_rtx (default_label_decl);\n \n       /* Get upper and lower bounds of case values.  */\n \n@@ -2413,7 +2419,8 @@ expand_case (tree exp)\n \t type, so we may still get a zero here.  */\n       if (count == 0)\n \t{\n-\t  emit_jump (default_label);\n+\t  if (default_label)\n+\t    emit_jump (default_label);\n           free_alloc_pool (case_node_pool);\n \t  return;\n \t}\n@@ -2509,7 +2516,8 @@ expand_case (tree exp)\n \t       && estimate_case_costs (case_list));\n \t  balance_case_nodes (&case_list, NULL);\n \t  emit_case_nodes (index, case_list, default_label, index_type);\n-\t  emit_jump (default_label);\n+\t  if (default_label)\n+\t    emit_jump (default_label);\n \t}\n       else\n \t{\n@@ -2559,9 +2567,10 @@ expand_case (tree exp)\n \t    }\n \n \t  /* Fill in the gaps with the default.  */\n-\t  for (i = 0; i < ncases; i++)\n-\t    if (labelvec[i] == 0)\n-\t      labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n+\t  if (default_label)\n+\t    for (i = 0; i < ncases; i++)\n+\t      if (labelvec[i] == 0)\n+\t        labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n \n \t  /* Output the table.  */\n \t  emit_label (table_label);\n@@ -3043,7 +3052,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      emit_case_nodes (index, node->left, default_label, index_type);\n \t      /* If left-hand subtree does nothing,\n \t\t go to default.  */\n-\t      emit_jump (default_label);\n+\t      if (default_label)\n+\t        emit_jump (default_label);\n \n \t      /* Code branches here for the right-hand subtree.  */\n \t      expand_label (test_label);\n@@ -3178,7 +3188,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t    {\n \t      /* If the left-hand subtree fell through,\n \t\t don't let it fall into the right-hand subtree.  */\n-\t      emit_jump (default_label);\n+\t      if (default_label)\n+\t\temit_jump (default_label);\n \n \t      expand_label (test_label);\n \t      emit_case_nodes (index, node->right, default_label, index_type);"}, {"sha": "432e9e019a0951d226480f6e65b0d03e8b3284c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -1,3 +1,10 @@\n+2008-04-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/14495\n+\tPR tree-optimization/34793\n+\t* gcc.dg/tree-ssa/vrp41.c: New testcase.\n+\t* gcc.dg/tree-ssa/vrp42.c: Likewise.\n+\n 2008-04-02  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/14495"}, {"sha": "d573fbb0a437f3eefe2275c92257cf6ee4438bdf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp41.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp41.c?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+void bar0 (void);\n+void bar1 (void);\n+void bar2 (void);\n+void bar3 (void);\n+\n+void\n+foo (int a)\n+{\n+  if (a < 100)\n+    return;\n+  if (200 < a)\n+    return;\n+\n+  switch (a)\n+    {\n+    case  99: bar0 (); return;\n+    case 100: bar1 (); return;\n+    case 101: bar2 (); return;\n+    case 102: bar3 (); return;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"case 99:\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "79eb22cb1e4f35bb223375b823932a214dfcfd46", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp42.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp42.c?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wuninitialized\" } */\n+\n+int foo(int val)\n+{\n+  int tmp;\n+  if ((val > 5) && (val < 8))\n+    {\n+      switch (val)\n+        {\n+        case 6:\n+          tmp = 1;\n+          break;\n+        case 7:\n+          tmp = 2;\n+          break;\n+        }\n+      return tmp; /* { dg-bogus \"used uninitialized\" } */\n+    }\n+  return 0;\n+}\n+"}, {"sha": "70d0404bc0ebbc045f545814f647cbd3b752e4c7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -1060,18 +1060,23 @@ group_case_labels (void)\n \t  tree labels = SWITCH_LABELS (stmt);\n \t  int old_size = TREE_VEC_LENGTH (labels);\n \t  int i, j, new_size = old_size;\n-\t  tree default_case = TREE_VEC_ELT (labels, old_size - 1);\n-\t  tree default_label;\n+\t  tree default_case = NULL_TREE;\n+\t  tree default_label = NULL_TREE;\n \n \t  /* The default label is always the last case in a switch\n-\t     statement after gimplification.  */\n-\t  default_label = CASE_LABEL (default_case);\n+\t     statement after gimplification if it was not optimized\n+\t     away.  */\n+\t  if (!CASE_LOW (TREE_VEC_ELT (labels, old_size - 1))\n+\t      && !CASE_HIGH (TREE_VEC_ELT (labels, old_size - 1)))\n+\t    {\n+\t      default_case = TREE_VEC_ELT (labels, old_size - 1);\n+\t      default_label = CASE_LABEL (default_case);\n+\t      old_size--;\n+\t    }\n \n-\t  /* Look for possible opportunities to merge cases.\n-\t     Ignore the last element of the label vector because it\n-\t     must be the default case.  */\n+\t  /* Look for possible opportunities to merge cases.  */\n           i = 0;\n-\t  while (i < old_size - 1)\n+\t  while (i < old_size)\n \t    {\n \t      tree base_case, base_label, base_high;\n \t      base_case = TREE_VEC_ELT (labels, i);\n@@ -1095,7 +1100,7 @@ group_case_labels (void)\n \t      /* Try to merge case labels.  Break out when we reach the end\n \t\t of the label vector or when we cannot merge the next case\n \t\t label with the current one.  */\n-\t      while (i < old_size - 1)\n+\t      while (i < old_size)\n \t\t{\n \t\t  tree merge_case = TREE_VEC_ELT (labels, i);\n \t          tree merge_label = CASE_LABEL (merge_case);\n@@ -4604,13 +4609,16 @@ tree_verify_flow_info (void)\n \n \t    /* Verify that the case labels are sorted.  */\n \t    prev = TREE_VEC_ELT (vec, 0);\n-\t    for (i = 1; i < n - 1; ++i)\n+\t    for (i = 1; i < n; ++i)\n \t      {\n \t\ttree c = TREE_VEC_ELT (vec, i);\n \t\tif (! CASE_LOW (c))\n \t\t  {\n-\t\t    error (\"found default case not at end of case vector\");\n-\t\t    err = 1;\n+\t\t    if (i != n - 1)\n+\t\t      {\n+\t\t\terror (\"found default case not at end of case vector\");\n+\t\t\terr = 1;\n+\t\t      }\n \t\t    continue;\n \t\t  }\n \t\tif (! tree_int_cst_lt (CASE_LOW (prev), CASE_LOW (c)))\n@@ -4624,11 +4632,9 @@ tree_verify_flow_info (void)\n \t\t  }\n \t\tprev = c;\n \t      }\n-\t    if (CASE_LOW (TREE_VEC_ELT (vec, n - 1)))\n-\t      {\n-\t\terror (\"no default case found at end of case vector\");\n-\t\terr = 1;\n-\t      }\n+\t    /* VRP will remove the default case if it can prove it will\n+\t       never be executed.  So do not verify there always exists\n+\t       a default case here.  */\n \n \t    FOR_EACH_EDGE (e, ei, bb->succs)\n \t      {"}, {"sha": "65635285df91bf69da78e95a4003e878294a771d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 141, "deletions": 4, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7814a183ca564e2d8cf21c12364d13d8f1226a2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b7814a183ca564e2d8cf21c12364d13d8f1226a2", "patch": "@@ -104,6 +104,16 @@ static value_range_t **vr_value;\n    node.  */\n static int *vr_phi_edge_counts;\n \n+typedef struct {\n+  tree stmt;\n+  tree vec;\n+} switch_update;\n+\n+static VEC (edge, heap) *to_remove_edges;\n+DEF_VEC_O(switch_update);\n+DEF_VEC_ALLOC_O(switch_update, heap);\n+static VEC (switch_update, heap) *to_update_switch_stmts;\n+\n \n /* Return the maximum value for TYPEs base type.  */\n \n@@ -6298,6 +6308,106 @@ simplify_cond_using_ranges (tree stmt)\n     }\n }\n \n+/* Simplify a switch statement using the value range of the switch\n+   argument.  */\n+\n+static void\n+simplify_switch_using_ranges (tree stmt)\n+{\n+  tree op = TREE_OPERAND (stmt, 0);\n+  value_range_t *vr;\n+  bool take_default;\n+  edge e;\n+  edge_iterator ei;\n+  size_t i = 0, j = 0, n, n2;\n+  tree vec, vec2;\n+  switch_update su;\n+\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return;\n+\n+  vr = get_value_range (op);\n+\n+  /* We can only handle integer ranges.  */\n+  if (vr->type != VR_RANGE\n+      || symbolic_range_p (vr))\n+    return;\n+\n+  /* Find case label for min/max of the value range.  */\n+  vec = SWITCH_LABELS (stmt);\n+  n = TREE_VEC_LENGTH (vec);\n+  take_default = !find_case_label_index (vec, 0, vr->min, &i);\n+  take_default |= !find_case_label_index (vec, i, vr->max, &j);\n+\n+  /* If the case label range is continuous, we do not need to\n+     preserve the default case label.  Verify that.  */\n+  if (!take_default && j > i)\n+    {\n+      tree low, high;\n+      size_t k;\n+\n+      high = CASE_LOW (TREE_VEC_ELT (vec, i));\n+      if (CASE_HIGH (TREE_VEC_ELT (vec, i)))\n+\thigh = CASE_HIGH (TREE_VEC_ELT (vec, i));\n+      for (k = i + 1; k <= j; ++k)\n+\t{\n+\t  low = CASE_LOW (TREE_VEC_ELT (vec, k));\n+\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high, 0)))\n+\t    {\n+\t      take_default = true;\n+\t      break;\n+\t    }\n+\t  high = low;\n+\t  if (CASE_HIGH (TREE_VEC_ELT (vec, k)))\n+\t    high = CASE_HIGH (TREE_VEC_ELT (vec, k));\n+\t}\n+    }\n+\n+  /* Bail out if this is just all edges taken.  */\n+  if (i == 0\n+      && j == n - 2\n+      && take_default)\n+    return;\n+\n+  /* Build a new vector of taken case labels.  */\n+  vec2 = make_tree_vec (j - i + 1 + (int)take_default);\n+  for (n2 = 0; i <= j; ++i, ++n2)\n+    TREE_VEC_ELT (vec2, n2) = TREE_VEC_ELT (vec, i);\n+\n+  /* Add the default edge, if necessary.  */\n+  if (take_default)\n+    TREE_VEC_ELT (vec2, n2++) = TREE_VEC_ELT (vec, n - 1);\n+\n+  /* Mark needed edges.  */\n+  for (i = 0; i < n2; ++i)\n+    {\n+      e = find_edge (bb_for_stmt (stmt),\n+\t\t     label_to_block (CASE_LABEL (TREE_VEC_ELT (vec2, i))));\n+      e->aux = (void *)-1;\n+    }\n+\n+  /* Queue not needed edges for later removal.  */\n+  FOR_EACH_EDGE (e, ei, bb_for_stmt (stmt)->succs)\n+    {\n+      if (e->aux == (void *)-1)\n+\t{\n+\t  e->aux = NULL;\n+\t  continue;\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"removing unreachable case label\\n\");\n+\t}\n+      VEC_safe_push (edge, heap, to_remove_edges, e);\n+    }\n+\n+  /* And queue an update for the stmt.  */\n+  su.stmt = stmt;\n+  su.vec = vec2;\n+  VEC_safe_push (switch_update, heap, to_update_switch_stmts, &su);\n+}\n+\n /* Simplify STMT using ranges if possible.  */\n \n void\n@@ -6324,9 +6434,9 @@ simplify_stmt_using_ranges (tree stmt)\n     }\n   else if (TREE_CODE (stmt) == COND_EXPR\n \t   && COMPARISON_CLASS_P (COND_EXPR_COND (stmt)))\n-    {\n-      simplify_cond_using_ranges (stmt);\n-    }\n+    simplify_cond_using_ranges (stmt);\n+  else if (TREE_CODE (stmt) == SWITCH_EXPR)\n+    simplify_switch_using_ranges (stmt);\n }\n \n /* Stack of dest,src equivalency pairs that need to be restored after\n@@ -6378,6 +6488,8 @@ identify_jump_threads (void)\n {\n   basic_block bb;\n   tree dummy;\n+  int i;\n+  edge e;\n \n   /* Ugh.  When substituting values earlier in this pass we can\n      wipe the dominance information.  So rebuild the dominator\n@@ -6391,6 +6503,11 @@ identify_jump_threads (void)\n      recompute it.  */\n   mark_dfs_back_edges ();\n \n+  /* Do not thread across edges we are about to remove.  Just marking\n+     them as EDGE_DFS_BACK will do.  */\n+  for (i = 0; VEC_iterate (edge, to_remove_edges, i, e); ++i)\n+    e->flags |= EDGE_DFS_BACK;\n+\n   /* Allocate our unwinder stack to unwind any temporary equivalences\n      that might be recorded.  */\n   stack = VEC_alloc (tree, heap, 20);\n@@ -6436,7 +6553,6 @@ identify_jump_threads (void)\n \t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))))\n \t{\n \t  edge_iterator ei;\n-\t  edge e;\n \n \t  /* We've got a block with multiple predecessors and multiple\n \t     successors which also ends in a suitable conditional.  For\n@@ -6603,6 +6719,10 @@ record_numbers_of_iterations (void)\n static unsigned int\n execute_vrp (void)\n {\n+  int i;\n+  edge e;\n+  switch_update *su;\n+\n   loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n   scev_initialize ();\n@@ -6620,10 +6740,27 @@ execute_vrp (void)\n      ranges are corrected.  */\n   record_numbers_of_iterations ();\n \n+  to_remove_edges = VEC_alloc (edge, heap, 10);\n+  to_update_switch_stmts = VEC_alloc (switch_update, heap, 5);\n+\n   vrp_initialize ();\n   ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);\n   vrp_finalize ();\n \n+  /* Remove dead edges from SWITCH_EXPR optimization.  This leaves the\n+     CFG in a broken state and requires a cfg_cleanup run.  */\n+  for (i = 0; VEC_iterate (edge, to_remove_edges, i, e); ++i)\n+    remove_edge (e);\n+  /* Update SWITCH_EXPR case label vector.  */\n+  for (i = 0; VEC_iterate (switch_update, to_update_switch_stmts, i, su); ++i)\n+    SWITCH_LABELS (su->stmt) = su->vec;\n+\n+  if (VEC_length (edge, to_remove_edges) > 0)\n+    free_dominance_info (CDI_DOMINATORS);\n+\n+  VEC_free (edge, heap, to_remove_edges);\n+  VEC_free (switch_update, heap, to_update_switch_stmts);\n+\n   /* ASSERT_EXPRs must be removed before finalizing jump threads\n      as finalizing jump threads calls the CFG cleanup code which\n      does not properly handle ASSERT_EXPRs.  */"}]}