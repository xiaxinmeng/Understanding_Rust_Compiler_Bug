{"sha": "ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU1Zjg2ZGNkNzdlMzgwMjlkZDhjNmUyMWQzMWNiMTIzZDg0NzJjYw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-11-22T05:25:15Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-11-22T05:25:15Z"}, "message": "[multiple changes]\n\n2000-10-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (outer_field_access_p): Inherited fields aren't\n\tconsider outer fields.\n\t(maybe_build_thisn_access_method): Use\n\tPURE_INNER_CLASS_TYPE_P instead of INNER_CLASS_TYPE_P.\n\t(resolve_expression_name): Trigger an error if a static field\n\tis being accessed as an outer field.\n\n2000-10-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n       * parse.h (INNER_ENCLOSING_SCOPE_CHECK): Check inherited type in\n       scope.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-11/msg01217.html)\n\nFrom-SVN: r37645", "tree": {"sha": "3ec6f9dedc5c7547f9b4b97ed415f645edd1b217", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ec6f9dedc5c7547f9b4b97ed415f645edd1b217"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/comments", "author": null, "committer": null, "parents": [{"sha": "a125d8555a7c049962de97f73829f5938e7fb4e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a125d8555a7c049962de97f73829f5938e7fb4e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a125d8555a7c049962de97f73829f5938e7fb4e9"}], "stats": {"total": 37, "additions": 34, "deletions": 3}, "files": [{"sha": "1bce1cb1f3b07e1c1a505c389d9122b7c6b9dd95", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "patch": "@@ -127,6 +127,15 @@\n \tInclude flags.h.\n \t* jv-scan.c (pedantic): New global.\n \n+2000-10-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (outer_field_access_p): Inherited fields aren't\n+\tconsider outer fields.\n+\t(maybe_build_thisn_access_method): Use\n+\tPURE_INNER_CLASS_TYPE_P instead of INNER_CLASS_TYPE_P.\n+\t(resolve_expression_name): Trigger an error if a static field\n+\tis being accessed as an outer field.\n+\n 2000-10-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n  \n \t* Make-lang.in (LIBGCJ_ZIP_FILE): Define with `$(prefix)'.\n@@ -152,6 +161,11 @@\n \tcurrent class. Fixed comment.\n \tFixes gcj/361.\n \n+2000-10-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+       * parse.h (INNER_ENCLOSING_SCOPE_CHECK): Check inherited type in\n+       scope.\n+\n 2000-10-24  Tom Tromey  <tromey@cygnus.com>\n \n \t* lex.c (java_new_lexer): Initialize new fields.  Work around"}, {"sha": "3db25803138de8377c8ef5b9d9e4c11cdd3fbf11", "filename": "gcc/java/parse.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "patch": "@@ -860,7 +860,12 @@ struct parser_ctxt {\n \t&& !inherits_from_p (TREE_TYPE (TREE_TYPE (current_this)),\t      \\\n \t\t\t     TREE_TYPE (DECL_CONTEXT (TYPE_NAME (T))))\t      \\\n         && !common_enclosing_context_p (TREE_TYPE (TREE_TYPE (current_this)), \\\n-\t\t\t\t\t(T)))\t\t\t\t      \\\n+\t\t\t\t\t(T))                                  \\\n+\t&& INNER_CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (current_this)))          \\\n+\t&& !inherits_from_p                                                   \\\n+\t      (TREE_TYPE (DECL_CONTEXT                                        \\\n+\t\t\t  (TYPE_NAME (TREE_TYPE (TREE_TYPE (current_this))))),\\\n+\t       TREE_TYPE (DECL_CONTEXT (TYPE_NAME (T)))))                     \\\n        /* We don't have a this. */\t\t\t\t\t      \\\n        || !current_this))\n "}, {"sha": "60d5077c32babee6cc99c7572b4fe9678cd9e3dc", "filename": "gcc/java/parse.y", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee5f86dcd77e38029dd8c6e21d31cb123d8472cc/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=ee5f86dcd77e38029dd8c6e21d31cb123d8472cc", "patch": "@@ -7887,6 +7887,11 @@ outer_field_access_p (type, decl)\n       || TREE_CODE (decl) != FIELD_DECL\n       || DECL_CONTEXT (decl) == type)\n     return 0;\n+  \n+  /* If the inner class extends the declaration context of the field\n+     we're try to acces, then this isn't an outer field access */\n+  if (inherits_from_p (type, DECL_CONTEXT (decl)))\n+    return 0;\n \n   for (type = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type))); ;\n        type = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type))))\n@@ -8238,7 +8243,7 @@ maybe_build_thisn_access_method (type)\n \n   /* If TYPE is a top-level class, no access method is required.\n      If there already is such an access method, bail out. */\n-  if (CLASS_ACCESS0_GENERATED_P (type) || !INNER_CLASS_TYPE_P (type))\n+  if (CLASS_ACCESS0_GENERATED_P (type) || !PURE_INNER_CLASS_TYPE_P (type))\n     return NULL_TREE;\n \n   /* We generate the method. The method looks like:\n@@ -8866,7 +8871,14 @@ resolve_expression_name (id, orig)\n \t\t to access a field belonging to an outer class, build\n \t\t the access to the field */\n \t      if (!fs && outer_field_access_p (current_class, decl))\n-\t\treturn build_outer_field_access (id, decl);\n+\t\t{\n+\t\t  if (CLASS_STATIC (TYPE_NAME (current_class)))\n+\t\t    {\n+\t\t      static_ref_err (id, DECL_NAME (decl), current_class);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  return build_outer_field_access (id, decl);\n+\t\t}\n \n \t      /* Otherwise build what it takes to access the field */\n \t      access = build_field_ref ((fs ? NULL_TREE : current_this),"}]}