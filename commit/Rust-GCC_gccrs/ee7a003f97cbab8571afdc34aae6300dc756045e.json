{"sha": "ee7a003f97cbab8571afdc34aae6300dc756045e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3YTAwM2Y5N2NiYWI4NTcxYWZkYzM0YWFlNjMwMGRjNzU2MDQ1ZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-05-06T07:23:35Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-05-06T07:23:35Z"}, "message": "Fix GNU coding style in lto-common.c.\n\n2019-05-06  Martin Liska  <mliska@suse.cz>\n\n\t* lto-common.c: Update coding style.\n\t* lto.c (materialize_cgraph): Likewise.\n\nFrom-SVN: r270898", "tree": {"sha": "6f0f5bb005b3cc6b219ddc17e95412c225ac06ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f0f5bb005b3cc6b219ddc17e95412c225ac06ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee7a003f97cbab8571afdc34aae6300dc756045e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7a003f97cbab8571afdc34aae6300dc756045e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee7a003f97cbab8571afdc34aae6300dc756045e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7a003f97cbab8571afdc34aae6300dc756045e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66d62d9f2e6b059be6a018397fba555147133a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d62d9f2e6b059be6a018397fba555147133a9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d62d9f2e6b059be6a018397fba555147133a9a"}], "stats": {"total": 249, "additions": 133, "deletions": 116}, "files": [{"sha": "f7b177f01754d8f0153a6e4c04d77ba27517e1e5", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7a003f97cbab8571afdc34aae6300dc756045e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7a003f97cbab8571afdc34aae6300dc756045e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ee7a003f97cbab8571afdc34aae6300dc756045e", "patch": "@@ -1,3 +1,8 @@\n+2019-05-06  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-common.c: Update coding style.\n+\t* lto.c (materialize_cgraph): Likewise.\n+\n 2019-05-06  Hrishikesh Kulkarni  <hrishikeshparag@gmail.com>\n \t    Martin Liska  <mliska@suse.cz>\n "}, {"sha": "aa64d8b779ef1d189e22e63ab934819c76469f7f", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 110, "deletions": 104, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7a003f97cbab8571afdc34aae6300dc756045e/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7a003f97cbab8571afdc34aae6300dc756045e/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=ee7a003f97cbab8571afdc34aae6300dc756045e", "patch": "@@ -76,15 +76,15 @@ hash_name (const void *p)\n static int\n eq_name (const void *p1, const void *p2)\n {\n-  const struct lto_section_slot *s1 =\n-    (const struct lto_section_slot *) p1;\n-  const struct lto_section_slot *s2 =\n-    (const struct lto_section_slot *) p2;\n+  const struct lto_section_slot *s1\n+    = (const struct lto_section_slot *) p1;\n+  const struct lto_section_slot *s2\n+    = (const struct lto_section_slot *) p2;\n \n   return strcmp (s1->name, s2->name) == 0;\n }\n \n-/* Free lto_section_slot */\n+/* Free lto_section_slot.  */\n \n static void\n free_with_string (void *arg)\n@@ -95,9 +95,9 @@ free_with_string (void *arg)\n   free (arg);\n }\n \n-/* Create section hash table */\n+/* Create section hash table.  */\n \n-htab_t \n+htab_t\n lto_obj_create_section_hash_table (void)\n {\n   return htab_create (37, hash_name, eq_name, free_with_string);\n@@ -145,9 +145,9 @@ lto_splay_tree_id_equal_p (splay_tree_key key, unsigned HOST_WIDE_INT id)\n   return *(unsigned HOST_WIDE_INT *) key == id;\n }\n \n-/* Insert a splay tree node into tree T with ID as key and FILE_DATA as value. \n+/* Insert a splay tree node into tree T with ID as key and FILE_DATA as value.\n    The ID is allocated separately because we need HOST_WIDE_INTs which may\n-   be wider than a splay_tree_key. */\n+   be wider than a splay_tree_key.  */\n \n static void\n lto_splay_tree_insert (splay_tree t, unsigned HOST_WIDE_INT id,\n@@ -164,13 +164,13 @@ static splay_tree\n lto_splay_tree_new (void)\n {\n   return splay_tree_new (lto_splay_tree_compare_ids,\n-\t \t         lto_splay_tree_delete_id,\n+\t\t\t lto_splay_tree_delete_id,\n \t\t\t NULL);\n }\n \n /* Decode the content of memory pointed to by DATA in the in decl\n-   state object STATE. DATA_IN points to a data_in structure for\n-   decoding. Return the address after the decoded object in the\n+   state object STATE.  DATA_IN points to a data_in structure for\n+   decoding.  Return the address after the decoded object in the\n    input.  */\n \n static const uint32_t *\n@@ -255,7 +255,7 @@ hash_canonical_type (tree type)\n     {\n       hstate.add_int (TYPE_PRECISION (type));\n       if (!type_with_interoperable_signedness (type))\n-        hstate.add_int (TYPE_UNSIGNED (type));\n+\thstate.add_int (TYPE_UNSIGNED (type));\n     }\n \n   if (VECTOR_TYPE_P (type))\n@@ -437,8 +437,8 @@ gimple_register_canonical_type (tree t)\n     TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_MAIN_VARIANT (t));\n   else\n     {\n-      gimple_register_canonical_type_1 (TYPE_MAIN_VARIANT (t),\n-\t\t\t\t\thash_canonical_type (TYPE_MAIN_VARIANT (t)));\n+      hashval_t h = hash_canonical_type (TYPE_MAIN_VARIANT (t));\n+      gimple_register_canonical_type_1 (TYPE_MAIN_VARIANT (t), h);\n       TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_MAIN_VARIANT (t));\n     }\n }\n@@ -460,7 +460,7 @@ lto_register_canonical_types (tree node, bool first_p)\n       || TREE_CODE (node) == ARRAY_TYPE)\n     lto_register_canonical_types (TREE_TYPE (node), first_p);\n \n- if (!first_p) \n+ if (!first_p)\n     gimple_register_canonical_type (node);\n }\n \n@@ -534,7 +534,7 @@ mentions_vars_p_decl_with_vis (tree t)\n   if (mentions_vars_p_decl_common (t))\n     return true;\n \n-  /* Accessor macro has side-effects, use field-name here. */\n+  /* Accessor macro has side-effects, use field-name here.  */\n   CHECK_NO_VAR (DECL_ASSEMBLER_NAME_RAW (t));\n   return false;\n }\n@@ -594,7 +594,7 @@ mentions_vars_p_type (tree t)\n   CHECK_VAR (TYPE_MIN_VALUE_RAW (t));\n   CHECK_VAR (TYPE_MAX_VALUE_RAW (t));\n \n-  /* Accessor is for derived node types only. */\n+  /* Accessor is for derived node types only.  */\n   CHECK_NO_VAR (TYPE_LANG_SLOT_1 (t));\n \n   CHECK_VAR (TYPE_CONTEXT (t));\n@@ -748,7 +748,7 @@ mentions_vars_p (tree t)\n }\n \n \n-/* Return the resolution for the decl with index INDEX from DATA_IN. */\n+/* Return the resolution for the decl with index INDEX from DATA_IN.  */\n \n static enum ld_plugin_symbol_resolution\n get_resolution (struct data_in *data_in, unsigned index)\n@@ -758,7 +758,7 @@ get_resolution (struct data_in *data_in, unsigned index)\n       ld_plugin_symbol_resolution_t ret;\n       /* We can have references to not emitted functions in\n \t DECL_FUNCTION_PERSONALITY at least.  So we can and have\n-\t to indeed return LDPR_UNKNOWN in some cases.   */\n+\t to indeed return LDPR_UNKNOWN in some cases.  */\n       if (data_in->globals_resolution.length () <= index)\n \treturn LDPR_UNKNOWN;\n       ret = data_in->globals_resolution[index];\n@@ -1090,7 +1090,7 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n       if (code == VAR_DECL)\n \t{\n \t  compare_values (DECL_HARD_REGISTER);\n-          /* DECL_IN_TEXT_SECTION is set during final asm output only.  */\n+\t  /* DECL_IN_TEXT_SECTION is set during final asm output only.  */\n \t  compare_values (DECL_IN_CONSTANT_POOL);\n \t}\n     }\n@@ -1143,8 +1143,8 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n       compare_values (TYPE_PRECISION);\n       compare_values (TYPE_ALIGN);\n       /* Do not compare TYPE_ALIAS_SET.  Doing so introduce ordering issues\n-         with calls to get_alias_set which may initialize it for streamed\n- \t in types.  */\n+\t with calls to get_alias_set which may initialize it for streamed\n+\t in types.  */\n     }\n \n   /* We don't want to compare locations, so there is nothing do compare\n@@ -1479,7 +1479,7 @@ compare_tree_sccs (tree_scc *pscc, tree_scc *scc,\n \t  return true;\n \t}\n       /* Reset TREE_ASM_WRITTEN on scc for the next compare or in case\n-         the SCC prevails.  */\n+\t the SCC prevails.  */\n       for (unsigned j = 0; j < scc->len; ++j)\n \tTREE_ASM_WRITTEN (scc->entries[j]) = 0;\n     }\n@@ -1582,7 +1582,7 @@ unify_scc (struct data_in *data_in, unsigned from,\n \t  if (len == 1)\n \t    {\n \t      /* If we got a debug reference queued, see if the prevailing\n-\t         tree has a debug reference and if not, register the one\n+\t\t tree has a debug reference and if not, register the one\n \t\t for the tree we are about to throw away.  */\n \t      if (dref_queue.length () == 1)\n \t\t{\n@@ -1807,19 +1807,19 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   data_in->location_cache.apply_location_cache ();\n \n   /* Read in lto_in_decl_state objects.  */\n-  data_ptr = (const uint32_t *) ((const char*) data + decl_offset); \n-  data_end =\n-     (const uint32_t *) ((const char*) data_ptr + header->decl_state_size);\n+  data_ptr = (const uint32_t *) ((const char*) data + decl_offset);\n+  data_end\n+    = (const uint32_t *) ((const char*) data_ptr + header->decl_state_size);\n   num_decl_states = *data_ptr++;\n-  \n+\n   gcc_assert (num_decl_states > 0);\n   decl_data->global_decl_state = lto_new_in_decl_state ();\n   data_ptr = lto_read_in_decl_state (data_in, data_ptr,\n \t\t\t\t     decl_data->global_decl_state);\n \n   /* Read in per-function decl states and enter them in hash table.  */\n-  decl_data->function_decl_states =\n-    hash_table<decl_state_hasher>::create_ggc (37);\n+  decl_data->function_decl_states\n+    = hash_table<decl_state_hasher>::create_ggc (37);\n \n   for (i = 1; i < num_decl_states; i++)\n     {\n@@ -1835,7 +1835,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   if (data_ptr != data_end)\n     internal_error (\"bytecode stream: garbage at the end of symbols section\");\n \n-  /* Set the current decl state to be the global state. */\n+  /* Set the current decl state to be the global state.  */\n   decl_data->current_decl_state = decl_data->global_decl_state;\n \n   lto_data_in_delete (data_in);\n@@ -1854,40 +1854,40 @@ lto_parse_hex (const char *p)\n       unsigned char part;\n       ret <<= 4;\n       if (c >= '0' && c <= '9')\n-        part = c - '0';\n+\tpart = c - '0';\n       else if (c >= 'a' && c <= 'f')\n-        part = c - 'a' + 10;\n+\tpart = c - 'a' + 10;\n       else if (c >= 'A' && c <= 'F')\n-        part = c - 'A' + 10;\n+\tpart = c - 'A' + 10;\n       else\n-        internal_error (\"could not parse hex number\");\n+\tinternal_error (\"could not parse hex number\");\n       ret |= part;\n     }\n \n   return ret;\n }\n \n-/* Read resolution for file named FILE_NAME. The resolution is read from\n-   RESOLUTION. */\n+/* Read resolution for file named FILE_NAME.  The resolution is read from\n+   RESOLUTION.  */\n \n static void\n lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n {\n   /* We require that objects in the resolution file are in the same\n-     order as the lto1 command line. */\n+     order as the lto1 command line.  */\n   unsigned int name_len;\n   char *obj_name;\n   unsigned int num_symbols;\n   unsigned int i;\n   struct lto_file_decl_data *file_data;\n-  splay_tree_node nd = NULL; \n+  splay_tree_node nd = NULL;\n \n   if (!resolution)\n     return;\n \n   name_len = strlen (file->filename);\n   obj_name = XNEWVEC (char, name_len + 1);\n-  fscanf (resolution, \" \");   /* Read white space. */\n+  fscanf (resolution, \" \");   /* Read white space.  */\n \n   fread (obj_name, sizeof (char), name_len, resolution);\n   obj_name[name_len] = '\\0';\n@@ -1901,10 +1901,10 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n       int64_t offset;\n       t = fscanf (resolution, \"@0x%16s\", offset_p);\n       if (t != 1)\n-        internal_error (\"could not parse file offset\");\n+\tinternal_error (\"could not parse file offset\");\n       offset = lto_parse_hex (offset_p);\n       if (offset != file->offset)\n-        internal_error (\"unexpected offset\");\n+\tinternal_error (\"unexpected offset\");\n     }\n \n   free (obj_name);\n@@ -1919,14 +1919,14 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n       char r_str[27];\n       enum ld_plugin_symbol_resolution r = (enum ld_plugin_symbol_resolution) 0;\n       unsigned int j;\n-      unsigned int lto_resolution_str_len =\n-\tsizeof (lto_resolution_str) / sizeof (char *);\n+      unsigned int lto_resolution_str_len\n+\t= sizeof (lto_resolution_str) / sizeof (char *);\n       res_pair rp;\n \n-      t = fscanf (resolution, \"%u \" HOST_WIDE_INT_PRINT_HEX_PURE \" %26s %*[^\\n]\\n\", \n-\t\t  &index, &id, r_str);\n+      t = fscanf (resolution, \"%u \" HOST_WIDE_INT_PRINT_HEX_PURE\n+\t\t  \" %26s %*[^\\n]\\n\", &index, &id, r_str);\n       if (t != 3)\n-        internal_error (\"invalid line in the resolution file\");\n+\tinternal_error (\"invalid line in the resolution file\");\n \n       for (j = 0; j < lto_resolution_str_len; j++)\n \t{\n@@ -1947,25 +1947,25 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n \t}\n \n       file_data = (struct lto_file_decl_data *)nd->value;\n-      /* The indexes are very sparse. To save memory save them in a compact\n-         format that is only unpacked later when the subfile is processed. */\n+      /* The indexes are very sparse.  To save memory save them in a compact\n+\t format that is only unpacked later when the subfile is processed.  */\n       rp.res = r;\n       rp.index = index;\n       file_data->respairs.safe_push (rp);\n       if (file_data->max_index < index)\n-        file_data->max_index = index;\n+\tfile_data->max_index = index;\n     }\n }\n \n-/* List of file_decl_datas */\n+/* List of file_decl_datas.  */\n struct file_data_list\n-  {\n-    struct lto_file_decl_data *first, *last;\n-  };\n+{\n+  struct lto_file_decl_data *first, *last;\n+};\n \n /* Is the name for a id'ed LTO section? */\n \n-static int \n+static int\n lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n {\n   const char *s;\n@@ -1981,11 +1981,11 @@ lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n   return sscanf (s, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, id) == 1;\n }\n \n-/* Create file_data of each sub file id */\n+/* Create file_data of each sub file id.  */\n \n-static int \n+static int\n create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n-                            struct file_data_list *list)\n+\t\t\t    struct file_data_list *list)\n {\n   struct lto_section_slot s_slot, *new_slot;\n   unsigned HOST_WIDE_INT id;\n@@ -1996,8 +1996,8 @@ create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n \n   if (!lto_section_with_id (ls->name, &id))\n     return 1;\n-  \n-  /* Find hash table of sub module id */\n+\n+  /* Find hash table of sub module id.  */\n   nd = lto_splay_tree_lookup (file_ids, id);\n   if (nd != NULL)\n     {\n@@ -2011,15 +2011,16 @@ create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n       file_data->section_hash_table = lto_obj_create_section_hash_table ();\n       lto_splay_tree_insert (file_ids, id, file_data);\n \n-      /* Maintain list in linker order */\n+      /* Maintain list in linker order.  */\n       if (!list->first)\n-        list->first = file_data;\n+\tlist->first = file_data;\n       if (list->last)\n-        list->last->next = file_data;\n+\tlist->last->next = file_data;\n+\n       list->last = file_data;\n     }\n \n-  /* Copy section into sub module hash table */\n+  /* Copy section into sub module hash table.  */\n   new_name = XDUPVEC (char, ls->name, strlen (ls->name) + 1);\n   s_slot.name = new_name;\n   hash_slot = htab_find_slot (file_data->section_hash_table, &s_slot, INSERT);\n@@ -2031,7 +2032,7 @@ create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n   return 1;\n }\n \n-/* Read declarations and other initializations for a FILE_DATA. */\n+/* Read declarations and other initializations for a FILE_DATA.  */\n \n static void\n lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n@@ -2043,8 +2044,8 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n   int i;\n   res_pair *rp;\n \n-  /* Create vector for fast access of resolution. We do this lazily\n-     to save memory. */ \n+  /* Create vector for fast access of resolution.  We do this lazily\n+     to save memory.  */\n   resolutions.safe_grow_cleared (file_data->max_index + 1);\n   for (i = 0; file_data->respairs.iterate (i, &rp); i++)\n     resolutions[rp->index] = rp->res;\n@@ -2063,14 +2064,14 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n       internal_error (\"cannot read LTO decls from %s\", file_data->file_name);\n       return;\n     }\n-  /* Frees resolutions */\n+  /* Frees resolutions.  */\n   lto_read_decls (file_data, data, resolutions);\n   lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n }\n \n-/* Finalize FILE_DATA in FILE and increase COUNT. */\n+/* Finalize FILE_DATA in FILE and increase COUNT.  */\n \n-static int \n+static int\n lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data,\n \t\t\t   int *count)\n {\n@@ -2084,11 +2085,11 @@ lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data,\n }\n \n /* Generate a TREE representation for all types and external decls\n-   entities in FILE.  \n+   entities in FILE.\n \n    Read all of the globals out of the file.  Then read the cgraph\n    and process the .o index into the cgraph nodes so that it can open\n-   the .o file to load the functions and ipa information.   */\n+   the .o file to load the functions and ipa information.  */\n \n static struct lto_file_decl_data *\n lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n@@ -2099,8 +2100,8 @@ lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n   struct lto_section_slot *section;\n   struct file_data_list file_list;\n   struct lto_section_list section_list;\n- \n-  memset (&section_list, 0, sizeof (struct lto_section_list)); \n+\n+  memset (&section_list, 0, sizeof (struct lto_section_list));\n   section_hash_table = lto_obj_build_section_table (file, &section_list);\n \n   /* Dump the details of LTO objects.  */\n@@ -2115,19 +2116,20 @@ lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n   }\n \n   /* Find all sub modules in the object and put their sections into new hash\n-     tables in a splay tree. */\n+     tables in a splay tree.  */\n   file_ids = lto_splay_tree_new ();\n   memset (&file_list, 0, sizeof (struct file_data_list));\n   for (section = section_list.first; section != NULL; section = section->next)\n     create_subid_section_table (section, file_ids, &file_list);\n \n-  /* Add resolutions to file ids */\n+  /* Add resolutions to file ids.  */\n   lto_resolution_read (file_ids, resolution_file, file);\n \n-  /* Finalize each lto file for each submodule in the merged object */\n-  for (file_data = file_list.first; file_data != NULL; file_data = file_data->next)\n+  /* Finalize each lto file for each submodule in the merged object.  */\n+  for (file_data = file_list.first; file_data != NULL;\n+       file_data = file_data->next)\n     lto_create_files_from_ids (file, file_data, count);\n- \n+\n   splay_tree_delete (file_ids);\n   htab_delete (section_hash_table);\n \n@@ -2176,10 +2178,10 @@ lto_read_section_data (struct lto_file_decl_data *file_data,\n     {\n       fd = open (file_data->file_name, O_RDONLY|O_BINARY);\n       if (fd == -1)\n-        {\n+\t{\n \t  fatal_error (input_location, \"Cannot open %s\", file_data->file_name);\n \t  return NULL;\n-        }\n+\t}\n       fd_name = xstrdup (file_data->file_name);\n     }\n \n@@ -2213,8 +2215,8 @@ lto_read_section_data (struct lto_file_decl_data *file_data,\n       result = NULL;\n     }\n #ifdef __MINGW32__\n-  /* Native windows doesn't supports delayed unlink on opened file. So\n-     we close file here again. This produces higher I/O load, but at least\n+  /* Native windows doesn't supports delayed unlink on opened file.  So\n+     we close file here again.  This produces higher I/O load, but at least\n      it prevents to have dangling file handles preventing unlink.  */\n   free (fd_name);\n   fd_name = NULL;\n@@ -2223,7 +2225,7 @@ lto_read_section_data (struct lto_file_decl_data *file_data,\n #endif\n   return result;\n #endif\n-}    \n+}\n \n \n /* Get the section data from FILE_DATA of SECTION_TYPE with NAME.\n@@ -2239,7 +2241,8 @@ get_section_data (struct lto_file_decl_data *file_data,\n   htab_t section_hash_table = file_data->section_hash_table;\n   struct lto_section_slot *f_slot;\n   struct lto_section_slot s_slot;\n-  const char *section_name = lto_get_section_name (section_type, name, file_data);\n+  const char *section_name = lto_get_section_name (section_type, name,\n+\t\t\t\t\t\t   file_data);\n   char *data = NULL;\n \n   *len = 0;\n@@ -2291,7 +2294,7 @@ static lto_file *current_lto_file;\n     if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n \t&& (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n       { \\\n-        tt = lto_symtab_prevailing_decl (tt); \\\n+\ttt = lto_symtab_prevailing_decl (tt); \\\n \tfixed = true; \\\n       } \\\n   } while (0)\n@@ -2312,7 +2315,7 @@ lto_fixup_prevailing_decls (tree t)\n   LTO_NO_PREVAIL (TREE_TYPE (t));\n   if (CODE_CONTAINS_STRUCT (code, TS_COMMON)\n       /* lto_symtab_prevail_decl use TREE_CHAIN to link to the prevailing decl.\n-\t in the case T is a prevailed declaration we would ICE here. */\n+\t in the case T is a prevailed declaration we would ICE here.  */\n       && !VAR_OR_FUNCTION_DECL_P (t))\n     LTO_NO_PREVAIL (TREE_CHAIN (t));\n   if (DECL_P (t))\n@@ -2401,7 +2404,7 @@ lto_fixup_prevailing_decls (tree t)\n #undef LTO_SET_PREVAIL\n #undef LTO_NO_PREVAIL\n \n-/* Helper function of lto_fixup_decls. Walks the var and fn streams in STATE,\n+/* Helper function of lto_fixup_decls.  Walks the var and fn streams in STATE,\n    replaces var and function decls with the corresponding prevailing def.  */\n \n static void\n@@ -2427,7 +2430,7 @@ lto_fixup_state (struct lto_in_decl_state *state)\n     }\n }\n \n-/* Fix the decls from all FILES. Replaces each decl with the corresponding\n+/* Fix the decls from all FILES.  Replaces each decl with the corresponding\n    prevailing one.  */\n \n static void\n@@ -2457,10 +2460,11 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n static GTY((length (\"lto_stats.num_input_files + 1\"))) struct lto_file_decl_data **all_file_decl_data;\n \n /* Turn file datas for sub files into a single array, so that they look\n-   like separate files for further passes. */\n+   like separate files for further passes.  */\n \n static void\n-lto_flatten_files (struct lto_file_decl_data **orig, int count, int last_file_ix)\n+lto_flatten_files (struct lto_file_decl_data **orig, int count,\n+\t\t   int last_file_ix)\n {\n   struct lto_file_decl_data *n, *next;\n   int i, k;\n@@ -2470,7 +2474,7 @@ lto_flatten_files (struct lto_file_decl_data **orig, int count, int last_file_ix\n     = ggc_cleared_vec_alloc<lto_file_decl_data_ptr> (count + 1);\n   /* Set the hooks so that all of the ipa passes can read in their data.  */\n   lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n-  for (i = 0, k = 0; i < last_file_ix; i++) \n+  for (i = 0, k = 0; i < last_file_ix; i++)\n     {\n       for (n = orig[i]; n != NULL; n = next)\n \t{\n@@ -2613,7 +2617,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   delete canonical_type_hash_cache;\n   canonical_type_hash_cache = NULL;\n \n-  /* At this stage we know that majority of GGC memory is reachable.  \n+  /* At this stage we know that majority of GGC memory is reachable.\n      Growing the limits prevents unnecesary invocation of GGC.  */\n   ggc_grow ();\n   ggc_collect ();\n@@ -2648,19 +2652,19 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \t  {\n \t    if (snode->output_to_lto_symbol_table_p ())\n \t      fatal_error (input_location, \"missing resolution data for %s\",\n-\t\t           IDENTIFIER_POINTER\n+\t\t\t   IDENTIFIER_POINTER\n \t\t\t     (DECL_ASSEMBLER_NAME (snode->decl)));\n \t  }\n \telse\n-          snode->resolution = *res;\n+\t  snode->resolution = *res;\n       }\n   for (i = 0; all_file_decl_data[i]; i++)\n     if (all_file_decl_data[i]->resolution_map)\n       {\n-        delete all_file_decl_data[i]->resolution_map;\n-        all_file_decl_data[i]->resolution_map = NULL;\n+\tdelete all_file_decl_data[i]->resolution_map;\n+\tall_file_decl_data[i]->resolution_map = NULL;\n       }\n-  \n+\n   timevar_pop (TV_IPA_LTO_CGRAPH_IO);\n \n   if (!quiet_flag)\n@@ -2706,9 +2710,11 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       gcc_assert (all_file_decl_data[i]->symtab_node_encoder);\n       lto_symtab_encoder_delete (all_file_decl_data[i]->symtab_node_encoder);\n       all_file_decl_data[i]->symtab_node_encoder = NULL;\n-      lto_free_function_in_decl_state (all_file_decl_data[i]->global_decl_state);\n+      lto_in_decl_state *global_decl_state\n+\t= all_file_decl_data[i]->global_decl_state;\n+      lto_free_function_in_decl_state (global_decl_state);\n       all_file_decl_data[i]->global_decl_state = NULL;\n-      all_file_decl_data[i]->current_decl_state = NULL; \n+      all_file_decl_data[i]->current_decl_state = NULL;\n     }\n \n   if (!flag_ltrans)\n@@ -2732,7 +2738,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       ggc_collect ();\n \n       if (dump_file)\n-        dump_end (lto_link_dump_id, dump_file);\n+\tdump_end (lto_link_dump_id, dump_file);\n       dump_file = NULL;\n       timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n     }\n@@ -2838,9 +2844,9 @@ lto_eh_personality (void)\n   return lto_eh_personality_decl;\n }\n \n-/* Set the process name based on the LTO mode. */\n+/* Set the process name based on the LTO mode.  */\n \n-static void \n+static void\n lto_process_name (void)\n {\n   if (flag_lto)"}, {"sha": "bf7902097016fd2b1f935d7d556f14934c33bcac", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7a003f97cbab8571afdc34aae6300dc756045e/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7a003f97cbab8571afdc34aae6300dc756045e/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ee7a003f97cbab8571afdc34aae6300dc756045e", "patch": "@@ -118,7 +118,7 @@ lto_materialize_function (struct cgraph_node *node)\n static void\n materialize_cgraph (void)\n {\n-  struct cgraph_node *node; \n+  struct cgraph_node *node;\n   timevar_id_t lto_timer;\n \n   if (!quiet_flag)\n@@ -252,7 +252,7 @@ stream_out_partitions (char *temp_filename, int blen, int min, int max,\n \t}\n       /* Fork failed; lets do the job ourseleves.  */\n       else if (cpid == -1)\n-        stream_out_partitions_1 (temp_filename, blen, min, max);\n+\tstream_out_partitions_1 (temp_filename, blen, min, max);\n       else\n \tnruns++;\n     }\n@@ -291,7 +291,8 @@ lto_wpa_write_files (void)\n   timevar_push (TV_WHOPR_WPA);\n \n   FOR_EACH_VEC_ELT (ltrans_partitions, i, part)\n-    lto_stats.num_output_symtab_nodes += lto_symtab_encoder_size (part->encoder);\n+    lto_stats.num_output_symtab_nodes\n+    += lto_symtab_encoder_size (part->encoder);\n \n   timevar_pop (TV_WHOPR_WPA);\n \n@@ -324,15 +325,18 @@ lto_wpa_write_files (void)\n       sprintf (temp_filename + blen, \"%u.o\", i);\n \n       if (!quiet_flag)\n-\tfprintf (stderr, \" %s (%s %i insns)\", temp_filename, part->name, part->insns);\n+\tfprintf (stderr, \" %s (%s %i insns)\", temp_filename, part->name,\n+\t\t part->insns);\n       if (symtab->dump_file)\n \t{\n-          lto_symtab_encoder_iterator lsei;\n-\t  \n-\t  fprintf (symtab->dump_file, \"Writing partition %s to file %s, %i insns\\n\",\n+\t  lto_symtab_encoder_iterator lsei;\n+\n+\t  fprintf (symtab->dump_file,\n+\t\t   \"Writing partition %s to file %s, %i insns\\n\",\n \t\t   part->name, temp_filename, part->insns);\n \t  fprintf (symtab->dump_file, \"  Symbols in partition: \");\n-\t  for (lsei = lsei_start_in_partition (part->encoder); !lsei_end_p (lsei);\n+\t  for (lsei = lsei_start_in_partition (part->encoder);\n+\t       !lsei_end_p (lsei);\n \t       lsei_next_in_partition (&lsei))\n \t    {\n \t      symtab_node *node = lsei_node (lsei);\n@@ -348,13 +352,15 @@ lto_wpa_write_files (void)\n \t\t  fprintf (symtab->dump_file, \"%s \", node->asm_name ());\n \t\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \t\t  if (cnode\n-\t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cnode))\n+\t\t      && lto_symtab_encoder_encode_body_p (part->encoder,\n+\t\t\t\t\t\t\t   cnode))\n \t\t    fprintf (symtab->dump_file, \"(body included)\");\n \t\t  else\n \t\t    {\n \t\t      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n \t\t      if (vnode\n-\t\t\t  && lto_symtab_encoder_encode_initializer_p (part->encoder, vnode))\n+\t\t\t  && lto_symtab_encoder_encode_initializer_p (part->encoder,\n+\t\t\t\t\t\t\t\t      vnode))\n \t\t\tfprintf (symtab->dump_file, \"(initializer included)\");\n \t\t    }\n \t\t}\n@@ -396,7 +402,7 @@ lto_wpa_write_files (void)\n     fatal_error (input_location,\n \t\t \"closing LTRANS output list %s: %m\", ltrans_output_list);\n \n-  free_ltrans_partitions();\n+  free_ltrans_partitions ();\n   free (temp_filename);\n \n   timevar_pop (TV_WHOPR_WPA_IO);\n@@ -634,7 +640,7 @@ lto_main (void)\n \t  debuginfo_early_stop ();\n \n \t  /* Let the middle end know that we have read and merged all of\n-\t     the input files.  */ \n+\t     the input files.  */\n \t  symtab->compile ();\n \n \t  timevar_stop (TV_PHASE_OPT_GEN);"}]}