{"sha": "097fdf65a05396d05141261b11af098ad63b346e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3ZmRmNjVhMDUzOTZkMDUxNDEyNjFiMTFhZjA5OGFkNjNiMzQ2ZQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:06:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:06:39Z"}, "message": "sem_ch12.ads, [...] (Save_References): If node is an operator that has been constant-folded...\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n        \n        * sem_ch12.ads, sem_ch12.adb (Save_References): If node is an operator\n\tthat has been constant-folded, preserve information of original tree,\n\tfor ASIS uses.\n\t(Analyze_Formal_Derived_Type): Set the limited present flag of the newly\n\tgenerated private extension declaration if the formal derived type is\n\tsynchronized. Carry synchronized present over to the generated private\n\textension.\n\t(Validate_Derived_Type_Instance): Ensure that the actual of a\n\tsynchronized formal derived type is a synchronized tagged type.\n\t(Instantiate_Formal_Package): When creating the instantiation used to\n\tvalidate the actual package of a formal declared without a box, check\n\twhether the formal itself depends on a prior actual.\n\t(Instantiate_Formal_Subprogram): Create new entities for the defining\n\tidentifiers of the formals in the renaming declaration, for ASIS use.\n\t(Instantiate_Formal_Subprogram, Instantiate_Formal_Type): When creating\n\ta renaming declaration or a subtype declaration for an actual in an\n\tinstance, capture location information of declaration in generic, for\n\tASIS use.\n\t(Instantiate_Formal_Package): Add comments on needed additional tests.\n\tAI-317 (partial parametrization) is fully implemented.\n\t(Validate_Private_Type_Instance): Add check for actual which\n\tmust have preelaborable initialization\n\tUse new // insertion for some continuation messages\n\t(Analyze_Formal_Object_Declaration): Change usage of Expression to\n\tDefault_Expression. Add type retrieval when the declaration has an\n\taccess definition. Update premature usage of incomplete type check.\n\t(Check_Access_Definition): New subsidiary routine. Check whether the\n\tcurrent compilation version is Ada 05 and the supplied node has an\n\taccess definition.\n\t(Instantiate object): Alphabetize local variables. Handle the creation\n\tof new renaming declarations with respect to the kind of definition\n\tused - either an access definition or a subtype mark. Guard against\n\tunnecessary error message in the context of anonymous access types after\n\tthey have been resolved. Add check for required null exclusion in a\n\tformal object declaration.\n\t(Switch_View): A private subtype of a non-private type needs to be\n\tswitched (the base type can have been switched without its private\n\tdependents because of the last branch of Check_Private_View.\n\t(Check_Private_View): Do not recompute Base_Type (T), instead use cached\n\tvalue from BT.\n\t(Instantiate_Type): Emit an error message whenever a class-wide type of\n\ta tagged incomplete type is used as a generic actual.\n\t(Find_Actual_Type): Extend routine to handle a component type in a child\n\tunit that is imported from a formal package in a parent.\n\t(Validate_Derived_Type_Instance): Check that analyzed formal and actual\n\tagree on constrainedness, rather than checking against ultimate ancestor\n\t(Instantiate_Subprogram_Body): Create a cross-reference link to the\n\tgeneric body, for navigation purposes.\n\nFrom-SVN: r118300", "tree": {"sha": "842e7b40243cbf4961daacf08eb8c1a0ed6ca8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/842e7b40243cbf4961daacf08eb8c1a0ed6ca8a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/097fdf65a05396d05141261b11af098ad63b346e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097fdf65a05396d05141261b11af098ad63b346e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097fdf65a05396d05141261b11af098ad63b346e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097fdf65a05396d05141261b11af098ad63b346e/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6109adeb7d392421306416182d2cf3241b7ba3ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6109adeb7d392421306416182d2cf3241b7ba3ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6109adeb7d392421306416182d2cf3241b7ba3ac"}], "stats": {"total": 1321, "additions": 983, "deletions": 338}, "files": [{"sha": "4a2e283b5cfed3db43737fea0eeb47c52666fde7", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 968, "deletions": 337, "changes": 1305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097fdf65a05396d05141261b11af098ad63b346e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097fdf65a05396d05141261b11af098ad63b346e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=097fdf65a05396d05141261b11af098ad63b346e", "patch": "@@ -78,13 +78,13 @@ package body Sem_Ch12 is\n \n    ----------------------------------------------------------\n    -- Implementation of Generic Analysis and Instantiation --\n-   -----------------------------------------------------------\n+   ----------------------------------------------------------\n \n-   --  GNAT implements generics by macro expansion. No attempt is made to\n-   --  share generic instantiations (for now). Analysis of a generic definition\n-   --  does not perform any expansion action, but the expander must be called\n-   --  on the tree for each instantiation, because the expansion may of course\n-   --  depend on the generic actuals. All of this is best achieved as follows:\n+   --  GNAT implements generics by macro expansion. No attempt is made to share\n+   --  generic instantiations (for now). Analysis of a generic definition does\n+   --  not perform any expansion action, but the expander must be called on the\n+   --  tree for each instantiation, because the expansion may of course depend\n+   --  on the generic actuals. All of this is best achieved as follows:\n    --\n    --  a) Semantic analysis of a generic unit is performed on a copy of the\n    --  tree for the generic unit. All tree modifications that follow analysis\n@@ -93,7 +93,7 @@ package body Sem_Ch12 is\n    --  the generic, and propagate them to each instance (recall that name\n    --  resolution is done on the generic declaration: generics are not really\n    --  macros!). This is summarized in the following diagram:\n-   --\n+\n    --              .-----------.               .----------.\n    --              |  semantic |<--------------|  generic |\n    --              |    copy   |               |    unit  |\n@@ -108,13 +108,13 @@ package body Sem_Ch12 is\n    --                                          |__|  |          |\n    --                                             |__| instance |\n    --                                                |__________|\n-   --\n+\n    --  b) Each instantiation copies the original tree, and inserts into it a\n    --  series of declarations that describe the mapping between generic formals\n    --  and actuals. For example, a generic In OUT parameter is an object\n    --  renaming of the corresponing actual, etc. Generic IN parameters are\n    --  constant declarations.\n-   --\n+\n    --  c) In order to give the right visibility for these renamings, we use\n    --  a different scheme for package and subprogram instantiations. For\n    --  packages, the list of renamings is inserted into the package\n@@ -154,16 +154,16 @@ package body Sem_Ch12 is\n \n    --  Visibility within nested generic units requires special handling.\n    --  Consider the following scheme:\n-   --\n+\n    --  type Global is ...         --  outside of generic unit.\n    --  generic ...\n    --  package Outer is\n    --     ...\n    --     type Semi_Global is ... --  global to inner.\n-   --\n+\n    --     generic ...                                         -- 1\n    --     procedure inner (X1 : Global;  X2 : Semi_Global);\n-   --\n+\n    --     procedure in2 is new inner (...);                   -- 4\n    --  end Outer;\n \n@@ -221,31 +221,78 @@ package body Sem_Ch12 is\n    -- Detection of Instantiation Circularities --\n    ----------------------------------------------\n \n-   --  If we have a chain of instantiations that is circular, this is a\n-   --  static error which must be detected at compile time. The detection\n-   --  of these circularities is carried out at the point that we insert\n-   --  a generic instance spec or body. If there is a circularity, then\n-   --  the analysis of the offending spec or body will eventually result\n-   --  in trying to load the same unit again, and we detect this problem\n-   --  as we analyze the package instantiation for the second time.\n+   --  If we have a chain of instantiations that is circular, this is static\n+   --  error which must be detected at compile time. The detection of these\n+   --  circularities is carried out at the point that we insert a generic\n+   --  instance spec or body. If there is a circularity, then the analysis of\n+   --  the offending spec or body will eventually result in trying to load the\n+   --  same unit again, and we detect this problem as we analyze the package\n+   --  instantiation for the second time.\n \n-   --  At least in some cases after we have detected the circularity, we\n-   --  get into trouble if we try to keep going. The following flag is\n-   --  set if a circularity is detected, and used to abandon compilation\n-   --  after the messages have been posted.\n+   --  At least in some cases after we have detected the circularity, we get\n+   --  into trouble if we try to keep going. The following flag is set if a\n+   --  circularity is detected, and used to abandon compilation after the\n+   --  messages have been posted.\n \n    Circularity_Detected : Boolean := False;\n    --  This should really be reset on encountering a new main unit, but in\n    --  practice we are not using multiple main units so it is not critical.\n \n+   -------------------------------------------------\n+   -- Formal packages and partial parametrization --\n+   -------------------------------------------------\n+\n+   --  When compiling a generic, a formal package is a local instantiation. If\n+   --  declared with a box, its generic formals are visible in the enclosing\n+   --  generic. If declared with a partial list of actuals, those actuals that\n+   --  are defaulted (covered by an Others clause, or given an explicit box\n+   --  initialization) are also visible in the enclosing generic, while those\n+   --  that have a corresponding actual are not.\n+\n+   --  In our source model of instantiation, the same visibility must be\n+   --  present in the spec and body of an instance: the names of the formals\n+   --  that are defaulted must be made visible within the instance, and made\n+   --  invisible (hidden) after the instantiation is complete, so that they\n+   --  are not accessible outside of the instance.\n+\n+   --  In a generic, a formal package is treated like a special instantiation.\n+   --  Our Ada95 compiler handled formals with and without box in different\n+   --  ways. With partial parametrization, we use a single model for both.\n+   --  We create a package declaration that consists of the specification of\n+   --  the generic package, and a set of declarations that map the actuals\n+   --  into local renamings, just as we do for bona fide instantiations. For\n+   --  defaulted parameters and formals with a box, we copy directly the\n+   --  declarations of the formal into this local package. The result is a\n+   --  a package whose visible declarations may include generic formals. This\n+   --  package is only used for type checking and visibility analysis, and\n+   --  never reaches the back-end, so it can freely violate the placement\n+   --  rules for generic formal declarations.\n+\n+   --  The list of declarations (renamings and copies of formals) is built\n+   --  by Analyze_Associations, just as for regular instantiations.\n+\n+   --  At the point of instantiation, conformance checking must be applied only\n+   --  to those parameters that were specified in the formal. We perform this\n+   --  checking by creating another internal instantiation, this one including\n+   --  only the renamings and the formals (the rest of the package spec is not\n+   --  relevant to conformance checking). We can then traverse two lists: the\n+   --  list of actuals in the instance that corresponds to the formal package,\n+   --  and the list of actuals produced for this bogus instantiation. We apply\n+   --  the conformance rules to those actuals that are not defaulted (i.e.\n+   --  which still appear as generic formals.\n+\n+   --  When we compile an instance body we must make the right parameters\n+   --  visible again. The predicate Is_Generic_Formal indicates which of the\n+   --  formals should have its Is_Hidden flag reset.\n+\n    -----------------------\n    -- Local subprograms --\n    -----------------------\n \n    procedure Abandon_Instantiation (N : Node_Id);\n    pragma No_Return (Abandon_Instantiation);\n-   --  Posts an error message \"instantiation abandoned\" at the indicated\n-   --  node and then raises the exception Instantiation_Error to do it.\n+   --  Posts an error message \"instantiation abandoned\" at the indicated node\n+   --  and then raises the exception Instantiation_Error to do it.\n \n    procedure Analyze_Formal_Array_Type\n      (T   : in out Entity_Id;\n@@ -286,12 +333,12 @@ package body Sem_Ch12 is\n      (N   : Node_Id;\n       T   : Entity_Id;\n       Def : Node_Id);\n-   --  This needs comments???\n+   --  Creates a new private type, which does not require completion\n \n    procedure Analyze_Generic_Formal_Part (N : Node_Id);\n \n    procedure Analyze_Generic_Access_Type (T : Entity_Id; Def : Node_Id);\n-   --  This needs comments ???\n+   --  Create a new access type with the given designated type\n \n    function Analyze_Associations\n      (I_Node  : Node_Id;\n@@ -321,6 +368,10 @@ package body Sem_Ch12 is\n    --  nodes or subprogram body and declaration nodes depending on the case).\n    --  On return, the node N has been rewritten with the actual body.\n \n+   procedure Check_Access_Definition (N : Node_Id);\n+   --  Subsidiary routine to null exclusion processing. Perform an assertion\n+   --  check on Ada version and the presence of an access definition in N.\n+\n    procedure Check_Formal_Packages (P_Id : Entity_Id);\n    --  Apply the following to all formal packages in generic associations\n \n@@ -345,16 +396,6 @@ package body Sem_Ch12 is\n    --  instance, we need to make an explicit test that it is not hidden by\n    --  a child instance of the same name and parent.\n \n-   procedure Check_Private_View (N : Node_Id);\n-   --  Check whether the type of a generic entity has a different view between\n-   --  the point of generic analysis and the point of instantiation. If the\n-   --  view has changed, then at the point of instantiation we restore the\n-   --  correct view to perform semantic analysis of the instance, and reset\n-   --  the current view after instantiation. The processing is driven by the\n-   --  current private status of the type of the node, and Has_Private_View,\n-   --  a flag that is set at the point of generic compilation. If view and\n-   --  flag are inconsistent then the type is updated appropriately.\n-\n    procedure Check_Generic_Actuals\n      (Instance      : Entity_Id;\n       Is_Formal_Box : Boolean);\n@@ -393,8 +434,14 @@ package body Sem_Ch12 is\n    --  When validating the actual types of a child instance, check whether\n    --  the formal is a formal type of the parent unit, and retrieve the current\n    --  actual for it. Typ is the entity in the analyzed formal type declaration\n-   --  (component or index type of an array type) and Gen_Scope is the scope of\n-   --  the analyzed formal array type.\n+   --  (component or index type of an array type, or designated type of an\n+   --  access formal) and Gen_Scope is the scope of the analyzed formal array\n+   --  or access type. The desired actual may be a formal of a parent, or may\n+   --  be declared in a formal package of a parent. In both cases it is a\n+   --  generic actual type because it appears within a visible instance.\n+   --  Ambiguities may still arise if two homonyms are declared in two formal\n+   --  packages, and the prefix of the formal type may be needed to resolve\n+   --  the ambiguity in the instance ???\n \n    function In_Same_Declarative_Part\n      (F_Node : Node_Id;\n@@ -410,6 +457,12 @@ package body Sem_Ch12 is\n    --  Used to determine whether its body should be elaborated to allow\n    --  front-end inlining.\n \n+   function Is_Generic_Formal (E : Entity_Id) return Boolean;\n+   --  Utility to determine whether a given entity is declared by means of\n+   --  of a formal parameter declaration. Used to set properly the visiblity\n+   --  of generic formals of a generic package declared with a box or with\n+   --  partial parametrization.\n+\n    procedure Set_Instance_Env\n      (Gen_Unit : Entity_Id;\n       Act_Unit : Entity_Id);\n@@ -531,6 +584,15 @@ package body Sem_Ch12 is\n    --  apply these rules is to repeat the instantiation of the formal package\n    --  in the context of the enclosing instance, and compare the generic\n    --  associations of this instantiation with those of the actual package.\n+   --  This internal instantiation only needs to contain the renamings of the\n+   --  formals: the visible and private declarations themselves need not be\n+   --  created.\n+\n+   --  In Ada2005, the formal package may be only partially parametrized. In\n+   --  that case the visibility step must make visible those actuals whose\n+   --  corresponding formals were given with a box. A final complication\n+   --  involves inherited operations from formal derived types, which must be\n+   --  visible if the type is.\n \n    function Is_In_Main_Unit (N : Node_Id) return Boolean;\n    --  Test if given node is in the main unit\n@@ -768,7 +830,7 @@ package body Sem_Ch12 is\n \n    procedure Abandon_Instantiation (N : Node_Id) is\n    begin\n-      Error_Msg_N (\"instantiation abandoned!\", N);\n+      Error_Msg_N (\"\\instantiation abandoned!\", N);\n       raise Instantiation_Error;\n    end Abandon_Instantiation;\n \n@@ -783,7 +845,7 @@ package body Sem_Ch12 is\n    is\n       Actual_Types : constant Elist_Id  := New_Elmt_List;\n       Assoc        : constant List_Id   := New_List;\n-      Defaults     : constant Elist_Id  := New_Elmt_List;\n+      Default_Actuals : constant Elist_Id  := New_Elmt_List;\n       Gen_Unit     : constant Entity_Id := Defining_Entity (Parent (F_Copy));\n       Actuals         : List_Id;\n       Actual          : Node_Id;\n@@ -794,11 +856,26 @@ package body Sem_Ch12 is\n       Match           : Node_Id;\n       Named           : Node_Id;\n       First_Named     : Node_Id := Empty;\n+\n+      Default_Formals : constant List_Id := New_List;\n+      --  If an Other_Choice is present, some of the formals may be defaulted.\n+      --  To simplify the treatement of visibility in an instance, we introduce\n+      --  individual defaults for each such formal. These defaults are\n+      --  appended to the list of associations and replace the Others_Choice.\n+\n       Found_Assoc     : Node_Id;\n+      --  Association for the current formal being match. Empty if there are\n+      --  no remaining actuals, or if there is no named association with the\n+      --  name of the formal.\n+\n       Is_Named_Assoc  : Boolean;\n       Num_Matched     : Int := 0;\n       Num_Actuals     : Int := 0;\n \n+      Others_Present  : Boolean := False;\n+      --  In Ada 2005, indicates partial parametrization of of a formal\n+      --  package. As usual an others association must be last in the list.\n+\n       function Matching_Actual\n         (F   : Entity_Id;\n          A_F : Entity_Id) return Node_Id;\n@@ -808,6 +885,21 @@ package body Sem_Ch12 is\n       --  A_F is the corresponding entity in the analyzed generic,which is\n       --  placed on the selector name for ASIS use.\n \n+      --  In Ada 2005, a named association may be given with a box, in which\n+      --  case Matching_Actual sets Found_Assoc to the generic association,\n+      --  but return Empty for the actual itself. In this case the code below\n+      --  creates a corresponding declaration for the formal.\n+\n+      function Partial_Parametrization return Boolean;\n+      --  Ada 2005: if no match is found for a given formal, check if the\n+      --  association for it includes a box, or whether the associations\n+      --  include an Others clause.\n+\n+      procedure Process_Default (F : Entity_Id);\n+      --  Add a copy of the declaration of generic formal  F to the list of\n+      --  associations, and add an explicit box association for F  if there\n+      --  is none yet, and the default comes from an Others_Choice.\n+\n       procedure Set_Analyzed_Formal;\n       --  Find the node in the generic copy that corresponds to a given formal.\n       --  The semantic information on this node is used to perform legality\n@@ -825,22 +917,23 @@ package body Sem_Ch12 is\n         (F   : Entity_Id;\n          A_F : Entity_Id) return Node_Id\n       is\n-         Found : Node_Id;\n          Prev  : Node_Id;\n+         Act   : Node_Id;\n \n       begin\n          Is_Named_Assoc := False;\n \n          --  End of list of purely positional parameters\n \n          if No (Actual) then\n-            Found := Empty;\n+            Found_Assoc := Empty;\n+            Act         := Empty;\n \n          --  Case of positional parameter corresponding to current formal\n \n          elsif No (Selector_Name (Actual)) then\n-            Found := Explicit_Generic_Actual_Parameter (Actual);\n             Found_Assoc := Actual;\n+            Act :=  Explicit_Generic_Actual_Parameter (Actual);\n             Num_Matched := Num_Matched + 1;\n             Next (Actual);\n \n@@ -849,16 +942,17 @@ package body Sem_Ch12 is\n \n          else\n             Is_Named_Assoc := True;\n-            Found := Empty;\n-            Prev  := Empty;\n+            Found_Assoc := Empty;\n+            Act         := Empty;\n+            Prev        := Empty;\n \n             while Present (Actual) loop\n                if Chars (Selector_Name (Actual)) = Chars (F) then\n-                  Found := Explicit_Generic_Actual_Parameter (Actual);\n                   Set_Entity (Selector_Name (Actual), A_F);\n                   Set_Etype  (Selector_Name (Actual), Etype (A_F));\n                   Generate_Reference (A_F, Selector_Name (Actual));\n                   Found_Assoc := Actual;\n+                  Act :=  Explicit_Generic_Actual_Parameter (Actual);\n                   Num_Matched := Num_Matched + 1;\n                   exit;\n                end if;\n@@ -885,9 +979,41 @@ package body Sem_Ch12 is\n             Actual := First_Named;\n          end if;\n \n-         return Found;\n+         return Act;\n       end Matching_Actual;\n \n+      -----------------------------\n+      -- Partial_Parametrization --\n+      -----------------------------\n+\n+      function Partial_Parametrization return Boolean is\n+      begin\n+         return Others_Present\n+          or else (Present (Found_Assoc) and then Box_Present (Found_Assoc));\n+      end Partial_Parametrization;\n+\n+      ---------------------\n+      -- Process_Default --\n+      ---------------------\n+\n+      procedure Process_Default (F : Entity_Id)  is\n+         Loc     : constant Source_Ptr := Sloc (I_Node);\n+         Default : Node_Id;\n+\n+      begin\n+         Append (Copy_Generic_Node (F, Empty, True), Assoc);\n+\n+         if No (Found_Assoc) then\n+            Default :=\n+               Make_Generic_Association (Loc,\n+               Selector_Name                     =>\n+                 New_Occurrence_Of (Defining_Identifier (F), Loc),\n+               Explicit_Generic_Actual_Parameter => Empty);\n+            Set_Box_Present (Default);\n+            Append (Default, Default_Formals);\n+         end if;\n+      end Process_Default;\n+\n       -------------------------\n       -- Set_Analyzed_Formal --\n       -------------------------\n@@ -912,7 +1038,9 @@ package body Sem_Ch12 is\n                   exit when\n                     Kind = N_Formal_Package_Declaration\n                       or else\n-                    Kind = N_Generic_Package_Declaration;\n+                    Kind = N_Generic_Package_Declaration\n+                      or else\n+                    Kind = N_Package_Declaration;\n \n                when N_Use_Package_Clause | N_Use_Type_Clause => exit;\n \n@@ -933,20 +1061,37 @@ package body Sem_Ch12 is\n \n             Next (Analyzed_Formal);\n          end loop;\n-\n       end Set_Analyzed_Formal;\n \n    --  Start of processing for Analyze_Associations\n \n    begin\n-      --  If named associations are present, save the first named association\n-      --  (it may of course be Empty) to facilitate subsequent name search.\n-\n       Actuals := Generic_Associations (I_Node);\n \n       if Present (Actuals) then\n-         First_Named := First (Actuals);\n \n+         --  check for an Others choice, indicating a partial parametrization\n+         --  for a formal package.\n+\n+         Actual := First (Actuals);\n+         while Present (Actual) loop\n+            if Nkind (Actual) = N_Others_Choice then\n+               Others_Present := True;\n+               if Present (Next (Actual)) then\n+                  Error_Msg_N (\"others must be last association\", Actual);\n+               end if;\n+\n+               Remove (Actual);\n+               exit;\n+            end if;\n+\n+            Next (Actual);\n+         end loop;\n+\n+         --  If named associations are present, save first named association\n+         --  (it may of course be Empty) to facilitate subsequent name search.\n+\n+         First_Named := First (Actuals);\n          while Present (First_Named)\n            and then No (Selector_Name (First_Named))\n          loop\n@@ -997,9 +1142,13 @@ package body Sem_Ch12 is\n                       Defining_Identifier (Formal),\n                       Defining_Identifier (Analyzed_Formal));\n \n-                  Append_List\n-                    (Instantiate_Object (Formal, Match, Analyzed_Formal),\n-                     Assoc);\n+                  if No (Match) and then Partial_Parametrization then\n+                     Process_Default (Formal);\n+                  else\n+                     Append_List\n+                       (Instantiate_Object (Formal, Match, Analyzed_Formal),\n+                        Assoc);\n+                  end if;\n \n                when N_Formal_Type_Declaration =>\n                   Match :=\n@@ -1008,13 +1157,19 @@ package body Sem_Ch12 is\n                       Defining_Identifier (Analyzed_Formal));\n \n                   if No (Match) then\n-                     Error_Msg_Sloc := Sloc (Gen_Unit);\n-                     Error_Msg_NE\n-                       (\"missing actual&\",\n-                         Instantiation_Node, Defining_Identifier (Formal));\n-                     Error_Msg_NE (\"\\in instantiation of & declared#\",\n-                         Instantiation_Node, Gen_Unit);\n-                     Abandon_Instantiation (Instantiation_Node);\n+                     if Partial_Parametrization then\n+                        Process_Default (Formal);\n+\n+                     else\n+                        Error_Msg_Sloc := Sloc (Gen_Unit);\n+                        Error_Msg_NE\n+                          (\"missing actual&\",\n+                            Instantiation_Node,\n+                              Defining_Identifier (Formal));\n+                        Error_Msg_NE (\"\\in instantiation of & declared#\",\n+                            Instantiation_Node, Gen_Unit);\n+                        Abandon_Instantiation (Instantiation_Node);\n+                     end if;\n \n                   else\n                      Analyze (Match);\n@@ -1082,12 +1237,15 @@ package body Sem_Ch12 is\n                     Instantiate_Formal_Subprogram\n                       (Formal, Match, Analyzed_Formal));\n \n-                  if No (Match)\n-                    and then Box_Present (Formal)\n-                  then\n-                     Append_Elmt\n-                       (Defining_Unit_Name (Specification (Last (Assoc))),\n-                         Defaults);\n+                  if No (Match) then\n+                     if  Partial_Parametrization then\n+                        Process_Default (Formal);\n+\n+                     elsif Box_Present (Formal) then\n+                        Append_Elmt\n+                          (Defining_Unit_Name (Specification (Last (Assoc))),\n+                            Default_Actuals);\n+                     end if;\n                   end if;\n \n                when N_Formal_Package_Declaration =>\n@@ -1097,14 +1255,19 @@ package body Sem_Ch12 is\n                       Defining_Identifier (Original_Node (Analyzed_Formal)));\n \n                   if No (Match) then\n-                     Error_Msg_Sloc := Sloc (Gen_Unit);\n-                     Error_Msg_NE\n-                       (\"missing actual&\",\n-                         Instantiation_Node, Defining_Identifier (Formal));\n-                     Error_Msg_NE (\"\\in instantiation of & declared#\",\n-                         Instantiation_Node, Gen_Unit);\n+                     if Partial_Parametrization then\n+                        Process_Default (Formal);\n \n-                     Abandon_Instantiation (Instantiation_Node);\n+                     else\n+                        Error_Msg_Sloc := Sloc (Gen_Unit);\n+                        Error_Msg_NE\n+                          (\"missing actual&\",\n+                            Instantiation_Node, Defining_Identifier (Formal));\n+                        Error_Msg_NE (\"\\in instantiation of & declared#\",\n+                            Instantiation_Node, Gen_Unit);\n+\n+                        Abandon_Instantiation (Instantiation_Node);\n+                     end if;\n \n                   else\n                      Analyze (Match);\n@@ -1114,15 +1277,21 @@ package body Sem_Ch12 is\n                         Assoc);\n                   end if;\n \n-               --  For use type and use package appearing in the context\n-               --  clause, we have already copied them, so we can just\n+               --  For use type and use package appearing in the generic\n+               --  part, we have already copied them, so we can just\n                --  move them where they belong (we mustn't recopy them\n                --  since this would mess up the Sloc values).\n \n                when N_Use_Package_Clause |\n                     N_Use_Type_Clause    =>\n-                  Remove (Formal);\n-                  Append (Formal, Assoc);\n+                  if Nkind (Original_Node (I_Node)) =\n+                    N_Formal_Package_Declaration\n+                  then\n+                     Append (New_Copy_Tree (Formal), Assoc);\n+                  else\n+                     Remove (Formal);\n+                     Append (Formal, Assoc);\n+                  end if;\n \n                when others =>\n                   raise Program_Error;\n@@ -1174,7 +1343,7 @@ package body Sem_Ch12 is\n          New_D : Node_Id;\n \n       begin\n-         Elmt := First_Elmt (Defaults);\n+         Elmt := First_Elmt (Default_Actuals);\n          while Present (Elmt) loop\n             if No (Actuals) then\n                Actuals := New_List;\n@@ -1193,6 +1362,14 @@ package body Sem_Ch12 is\n          end loop;\n       end;\n \n+      --  If this is a formal package. normalize the parameter list by\n+      --  adding explicit box asssociations for the formals that are covered\n+      --  by an Others_Choice.\n+\n+      if not Is_Empty_List (Default_Formals) then\n+         Append_List (Default_Formals, Formals);\n+      end if;\n+\n       return Assoc;\n    end Analyze_Associations;\n \n@@ -1311,19 +1488,29 @@ package body Sem_Ch12 is\n    -------------------------------------------\n \n    procedure Analyze_Formal_Derived_Interface_Type\n-     (T : Entity_Id;\n+     (T   : Entity_Id;\n       Def : Node_Id)\n    is\n+      Ifaces_List : Elist_Id;\n+\n    begin\n       Enter_Name (T);\n       Set_Ekind  (T, E_Record_Type);\n       Set_Etype  (T, T);\n       Analyze (Subtype_Indication (Def));\n       Analyze_Interface_Declaration (T, Def);\n       Make_Class_Wide_Type (T);\n-      Set_Primitive_Operations (T, New_Elmt_List);\n       Analyze_List (Interface_List (Def));\n-      Collect_Interfaces (Def, T);\n+\n+      --  Ada 2005 (AI-251): Collect the list of progenitors that are not\n+      --  already covered by the parents.\n+\n+      Collect_Abstract_Interfaces\n+        (T                         => T,\n+         Ifaces_List               => Ifaces_List,\n+         Exclude_Parent_Interfaces => True);\n+\n+      Set_Abstract_Interfaces (T, Ifaces_List);\n    end Analyze_Formal_Derived_Interface_Type;\n \n    ---------------------------------\n@@ -1348,10 +1535,12 @@ package body Sem_Ch12 is\n              Defining_Identifier           => T,\n              Discriminant_Specifications   => Discriminant_Specifications (N),\n              Unknown_Discriminants_Present => Unk_Disc,\n-             Subtype_Indication            => Subtype_Mark (Def));\n+             Subtype_Indication            => Subtype_Mark (Def),\n+             Interface_List                => Interface_List (Def));\n \n-         Set_Abstract_Present (New_N, Abstract_Present (Def));\n-         Set_Limited_Present  (New_N, Limited_Present  (Def));\n+         Set_Abstract_Present     (New_N, Abstract_Present     (Def));\n+         Set_Limited_Present      (New_N, Limited_Present      (Def));\n+         Set_Synchronized_Present (New_N, Synchronized_Present (Def));\n \n       else\n          New_N :=\n@@ -1366,7 +1555,7 @@ package body Sem_Ch12 is\n          Set_Abstract_Present\n            (Type_Definition (New_N), Abstract_Present (Def));\n          Set_Limited_Present\n-           (Type_Definition (New_N), Limited_Present (Def));\n+           (Type_Definition (New_N), Limited_Present  (Def));\n       end if;\n \n       Rewrite (N, New_N);\n@@ -1516,7 +1705,7 @@ package body Sem_Ch12 is\n    ---------------------------------------\n \n    procedure Analyze_Formal_Object_Declaration (N : Node_Id) is\n-      E  : constant Node_Id := Expression (N);\n+      E  : constant Node_Id := Default_Expression (N);\n       Id : constant Node_Id := Defining_Identifier (N);\n       K  : Entity_Kind;\n       T  : Node_Id;\n@@ -1537,11 +1726,33 @@ package body Sem_Ch12 is\n          K := E_Generic_In_Parameter;\n       end if;\n \n-      Find_Type (Subtype_Mark (N));\n-      T  := Entity (Subtype_Mark (N));\n+      if Present (Subtype_Mark (N)) then\n+         Find_Type (Subtype_Mark (N));\n+         T := Entity (Subtype_Mark (N));\n+\n+      --  Ada 2005 (AI-423): Formal object with an access definition\n+\n+      else\n+         Check_Access_Definition (N);\n+         T := Access_Definition\n+                (Related_Nod => N,\n+                 N           => Access_Definition (N));\n+      end if;\n \n       if Ekind (T) = E_Incomplete_Type then\n-         Error_Msg_N (\"premature usage of incomplete type\", Subtype_Mark (N));\n+         declare\n+            Error_Node : Node_Id;\n+\n+         begin\n+            if Present (Subtype_Mark (N)) then\n+               Error_Node := Subtype_Mark (N);\n+            else\n+               Check_Access_Definition (N);\n+               Error_Node := Access_Definition (N);\n+            end if;\n+\n+            Error_Msg_N (\"premature usage of incomplete type\", Error_Node);\n+         end;\n       end if;\n \n       if K = E_Generic_In_Parameter then\n@@ -1666,6 +1877,110 @@ package body Sem_Ch12 is\n       Renaming         : Node_Id;\n       Parent_Instance  : Entity_Id;\n       Renaming_In_Par  : Entity_Id;\n+      No_Associations  : Boolean := False;\n+\n+      function Build_Local_Package return Node_Id;\n+      --  The formal package is rewritten so that its parameters are replaced\n+      --  with corresponding declarations. For parameters with bona fide\n+      --  associations these declarations are created by Analyze_Associations\n+      --  as for aa regular instantiation. For boxed parameters, we preserve\n+      --  the formal declarations and analyze them, in order to introduce\n+      --  entities of the right kind in the environment of the formal.\n+\n+      -------------------------\n+      -- Build_Local_Package --\n+      -------------------------\n+\n+      function Build_Local_Package return Node_Id is\n+         Decls     : List_Id;\n+         Pack_Decl : Node_Id;\n+\n+      begin\n+         --  Within the formal, the name of the generic package is a renaming\n+         --  of the formal (as for a regular instantiation).\n+\n+         Pack_Decl :=\n+           Make_Package_Declaration (Loc,\n+             Specification =>\n+               Copy_Generic_Node\n+                 (Specification (Original_Node (Gen_Decl)),\n+                    Empty, Instantiating => True));\n+\n+         Renaming := Make_Package_Renaming_Declaration (Loc,\n+             Defining_Unit_Name =>\n+               Make_Defining_Identifier (Loc, Chars (Gen_Unit)),\n+             Name => New_Occurrence_Of (Formal, Loc));\n+\n+         if Nkind (Gen_Id) = N_Identifier\n+           and then Chars (Gen_Id) = Chars (Pack_Id)\n+         then\n+            Error_Msg_NE\n+              (\"& is hidden within declaration of instance\", Gen_Id, Gen_Unit);\n+         end if;\n+\n+         --  If the formal is declared with a box, or with an others choice,\n+         --  create corresponding declarations for all entities in the formal\n+         --  part, so that names with the proper types are available in the\n+         --  specification of the formal package.\n+\n+         if No_Associations then\n+            declare\n+               Formal_Decl : Node_Id;\n+\n+            begin\n+               --  TBA : for a formal package, need to recurse\n+\n+               Decls := New_List;\n+               Formal_Decl :=\n+                 First\n+                   (Generic_Formal_Declarations (Original_Node (Gen_Decl)));\n+               while Present (Formal_Decl) loop\n+                  Append_To\n+                    (Decls, Copy_Generic_Node (Formal_Decl, Empty, True));\n+                  Next (Formal_Decl);\n+               end loop;\n+            end;\n+\n+         --  If generic associations are present, use Analyze_Associations to\n+         --  create the proper renaming declarations.\n+\n+         else\n+            declare\n+               Act_Tree : constant Node_Id :=\n+                            Copy_Generic_Node\n+                              (Original_Node (Gen_Decl), Empty,\n+                               Instantiating => True);\n+\n+            begin\n+               Generic_Renamings.Set_Last (0);\n+               Generic_Renamings_HTable.Reset;\n+               Instantiation_Node := N;\n+\n+               Decls :=\n+                 Analyze_Associations\n+                   (Original_Node (N),\n+                      Generic_Formal_Declarations (Act_Tree),\n+                      Generic_Formal_Declarations (Gen_Decl));\n+            end;\n+         end if;\n+\n+         Append (Renaming, To => Decls);\n+\n+         --  Add generated declarations ahead of local declarations in\n+         --  the package.\n+\n+         if No (Visible_Declarations (Specification (Pack_Decl))) then\n+            Set_Visible_Declarations (Specification (Pack_Decl), Decls);\n+         else\n+            Insert_List_Before\n+              (First (Visible_Declarations (Specification (Pack_Decl))),\n+                 Decls);\n+         end if;\n+\n+         return Pack_Decl;\n+      end Build_Local_Package;\n+\n+   --  Start of processing for Analyze_Formal_Package\n \n    begin\n       Text_IO_Kludge (Gen_Id);\n@@ -1714,107 +2029,114 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n-      --  The formal package is treated like a regular instance, but only\n-      --  the specification needs to be instantiated, to make entities visible.\n+      if Box_Present (N)\n+        or else No (Generic_Associations (N))\n+        or else Nkind (First (Generic_Associations (N))) = N_Others_Choice\n+      then\n+         No_Associations := True;\n+      end if;\n \n-      if not Box_Present (N) then\n-         Hidden_Entities := New_Elmt_List;\n-         Analyze_Package_Instantiation (N);\n+      --  If there are no generic associations, the generic parameters\n+      --  appear as local entities and are instantiated like them. We copy\n+      --  the generic package declaration as if it were an instantiation,\n+      --  and analyze it like a regular package, except that we treat the\n+      --  formals as additional visible components.\n \n-         if Parent_Installed then\n-            Remove_Parent;\n-         end if;\n+      Gen_Decl := Unit_Declaration_Node (Gen_Unit);\n \n-      else\n-         --  If there are no generic associations, the generic parameters\n-         --  appear as local entities and are instantiated like them. We copy\n-         --  the generic package declaration as if it were an instantiation,\n-         --  and analyze it like a regular package, except that we treat the\n-         --  formals as additional visible components.\n+      if In_Extended_Main_Source_Unit (N) then\n+         Set_Is_Instantiated (Gen_Unit);\n+         Generate_Reference  (Gen_Unit, N);\n+      end if;\n \n-         Gen_Decl := Unit_Declaration_Node (Gen_Unit);\n+      Formal := New_Copy (Pack_Id);\n+      Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n \n-         if In_Extended_Main_Source_Unit (N) then\n-            Set_Is_Instantiated (Gen_Unit);\n-            Generate_Reference  (Gen_Unit, N);\n-         end if;\n+      --  Make local generic without formals. The formals will be replaced\n+      --  with internal declarations..\n \n-         Formal := New_Copy (Pack_Id);\n-         Create_Instantiation_Source (N, Gen_Unit, False, S_Adjustment);\n+      New_N := Build_Local_Package;\n+      Rewrite (N, New_N);\n+      Set_Defining_Unit_Name (Specification (New_N), Formal);\n+      Set_Generic_Parent (Specification (N), Gen_Unit);\n+      Set_Instance_Env (Gen_Unit, Formal);\n+      Set_Is_Generic_Instance (Formal);\n \n-         New_N :=\n-           Copy_Generic_Node\n-             (Original_Node (Gen_Decl), Empty, Instantiating => True);\n-         Rewrite (N, New_N);\n-         Set_Defining_Unit_Name (Specification (New_N), Formal);\n-         Set_Generic_Parent (Specification (N), Gen_Unit);\n-         Set_Instance_Env (Gen_Unit, Formal);\n+      Enter_Name (Formal);\n+      Set_Ekind  (Formal, E_Package);\n+      Set_Etype  (Formal, Standard_Void_Type);\n+      Set_Inner_Instances (Formal, New_Elmt_List);\n+      New_Scope  (Formal);\n \n-         Enter_Name (Formal);\n-         Set_Ekind  (Formal, E_Generic_Package);\n-         Set_Etype  (Formal, Standard_Void_Type);\n-         Set_Inner_Instances (Formal, New_Elmt_List);\n-         New_Scope  (Formal);\n+      if Is_Child_Unit (Gen_Unit)\n+        and then Parent_Installed\n+      then\n+         --  Similarly, we have to make the name of the formal visible in\n+         --  the parent instance, to resolve properly fully qualified names\n+         --  that may appear in the generic unit. The parent instance has\n+         --  been placed on the scope stack ahead of the current scope.\n+\n+         Parent_Instance := Scope_Stack.Table (Scope_Stack.Last - 1).Entity;\n+\n+         Renaming_In_Par :=\n+           Make_Defining_Identifier (Loc, Chars (Gen_Unit));\n+         Set_Ekind (Renaming_In_Par, E_Package);\n+         Set_Etype (Renaming_In_Par, Standard_Void_Type);\n+         Set_Scope (Renaming_In_Par, Parent_Instance);\n+         Set_Parent (Renaming_In_Par, Parent (Formal));\n+         Set_Renamed_Object (Renaming_In_Par, Formal);\n+         Append_Entity (Renaming_In_Par, Parent_Instance);\n+      end if;\n \n-         --  Within the formal, the name of the generic package is a renaming\n-         --  of the formal (as for a regular instantiation).\n+      Analyze (Specification (N));\n \n-         Renaming := Make_Package_Renaming_Declaration (Loc,\n-             Defining_Unit_Name =>\n-               Make_Defining_Identifier (Loc, Chars (Gen_Unit)),\n-             Name => New_Reference_To (Formal, Loc));\n+      --  The formals for which associations are provided are not visible\n+      --  outside of the formal package. The others are still declared by\n+      --  a formal parameter declaration.\n \n-         if Present (Visible_Declarations (Specification (N))) then\n-            Prepend (Renaming, To => Visible_Declarations (Specification (N)));\n-         elsif Present (Private_Declarations (Specification (N))) then\n-            Prepend (Renaming, To => Private_Declarations (Specification (N)));\n-         end if;\n+      if not No_Associations then\n+         declare\n+            E : Entity_Id;\n \n-         if Is_Child_Unit (Gen_Unit)\n-           and then Parent_Installed\n-         then\n-            --  Similarly, we have to make the name of the formal visible in\n-            --  the parent instance, to resolve properly fully qualified names\n-            --  that may appear in the generic unit. The parent instance has\n-            --  been placed on the scope stack ahead of the current scope.\n+         begin\n+            E := First_Entity (Formal);\n+            while Present (E) loop\n+               exit when Ekind (E) = E_Package\n+                 and then Renamed_Entity (E) = Formal;\n \n-            Parent_Instance := Scope_Stack.Table (Scope_Stack.Last - 1).Entity;\n+               if not Is_Generic_Formal (E) then\n+                  Set_Is_Hidden (E);\n+               end if;\n \n-            Renaming_In_Par :=\n-              Make_Defining_Identifier (Loc, Chars (Gen_Unit));\n-            Set_Ekind (Renaming_In_Par, E_Package);\n-            Set_Etype (Renaming_In_Par, Standard_Void_Type);\n-            Set_Scope (Renaming_In_Par, Parent_Instance);\n-            Set_Parent (Renaming_In_Par, Parent (Formal));\n-            Set_Renamed_Object (Renaming_In_Par, Formal);\n-            Append_Entity (Renaming_In_Par, Parent_Instance);\n-         end if;\n+               Next_Entity (E);\n+            end loop;\n+         end;\n+      end if;\n \n-         Analyze_Generic_Formal_Part (N);\n-         Analyze (Specification (N));\n-         End_Package_Scope (Formal);\n+      End_Package_Scope (Formal);\n \n-         if Parent_Installed then\n-            Remove_Parent;\n-         end if;\n+      if Parent_Installed then\n+         Remove_Parent;\n+      end if;\n \n-         Restore_Env;\n+      Restore_Env;\n \n-         --  Inside the generic unit, the formal package is a regular\n-         --  package, but no body is needed for it. Note that after\n-         --  instantiation, the defining_unit_name we need is in the\n-         --  new tree and not in the original. (see Package_Instantiation).\n-         --  A generic formal package is an instance, and can be used as\n-         --  an actual for an inner instance.\n+      --  Inside the generic unit, the formal package is a regular\n+      --  package, but no body is needed for it. Note that after\n+      --  instantiation, the defining_unit_name we need is in the\n+      --  new tree and not in the original. (see Package_Instantiation).\n+      --  A generic formal package is an instance, and can be used as\n+      --  an actual for an inner instance.\n \n-         Set_Ekind (Formal, E_Package);\n-         Set_Has_Completion (Formal, True);\n+      Set_Has_Completion (Formal, True);\n \n-         Set_Ekind (Pack_Id, E_Package);\n-         Set_Etype (Pack_Id, Standard_Void_Type);\n-         Set_Scope (Pack_Id, Scope (Formal));\n-         Set_Has_Completion (Pack_Id, True);\n-      end if;\n+      --  Add semantic information to the original defining identifier.\n+      --  for ASIS use.\n+\n+      Set_Ekind (Pack_Id, E_Package);\n+      Set_Etype (Pack_Id, Standard_Void_Type);\n+      Set_Scope (Pack_Id, Scope (Formal));\n+      Set_Has_Completion (Pack_Id, True);\n    end Analyze_Formal_Package;\n \n    ---------------------------------\n@@ -2374,10 +2696,6 @@ package body Sem_Ch12 is\n    -- Analyze_Package_Instantiation --\n    -----------------------------------\n \n-   --  Note: this procedure is also used for formal package declarations, in\n-   --  which case the argument N is an N_Formal_Package_Declaration node.\n-   --  This should really be noted in the spec! ???\n-\n    procedure Analyze_Package_Instantiation (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Gen_Id : constant Node_Id    := Name (N);\n@@ -2925,9 +3243,6 @@ package body Sem_Ch12 is\n                end if;\n             end if;\n \n-            --  There is a problem with inlining here\n-            --  More comments needed??? what problem\n-\n             Set_Unit (Parent (N), Act_Decl);\n             Set_Parent_Spec (Act_Decl, Parent_Spec (N));\n             Set_Package_Instantiation (Act_Decl_Id, N);\n@@ -3852,6 +4167,18 @@ package body Sem_Ch12 is\n       Build_Elaboration_Entity (Decl_Cunit, New_Main);\n    end Build_Instance_Compilation_Unit_Nodes;\n \n+   -----------------------------\n+   -- Check_Access_Definition --\n+   -----------------------------\n+\n+   procedure Check_Access_Definition (N : Node_Id) is\n+   begin\n+      pragma Assert\n+        (Ada_Version >= Ada_05\n+           and then Present (Access_Definition (N)));\n+      null;\n+   end Check_Access_Definition;\n+\n    -----------------------------------\n    -- Check_Formal_Package_Instance --\n    -----------------------------------\n@@ -3892,8 +4219,19 @@ package body Sem_Ch12 is\n       --------------------\n \n       procedure Check_Mismatch (B : Boolean) is\n+         Kind : constant Node_Kind := Nkind (Parent (E2));\n+\n       begin\n-         if B then\n+         if Kind = N_Formal_Type_Declaration then\n+            return;\n+\n+         elsif Kind = N_Formal_Object_Declaration\n+           or else Kind in N_Formal_Subprogram_Declaration\n+           or else Kind = N_Formal_Package_Declaration\n+         then\n+            null;\n+\n+         elsif B then\n             Error_Msg_NE\n               (\"actual for & in actual instance does not match formal\",\n                Parent (Actual_Pack), E1);\n@@ -3990,6 +4328,9 @@ package body Sem_Ch12 is\n             --  Itypes generated for other parameters need not be checked,\n             --  the check will be performed on the parameters themselves.\n \n+            --  If E2 is a formal type declaration, it is a defaulted\n+            --  parameter and needs no checking.\n+\n             if not Is_Itype (E1)\n               and then not Is_Itype (E2)\n             then\n@@ -4086,7 +4427,8 @@ package body Sem_Ch12 is\n          elsif Is_Overloadable (E1) then\n \n             --  Verify that the names of the  entities match.\n-            --  What if actual is an attribute ???\n+            --  Note that actuals that are attributes are rewritten\n+            --  as subprograms.\n \n             Check_Mismatch\n               (Ekind (E2) /= Ekind (E1) or else (Alias (E1)) /= Alias (E2));\n@@ -4128,6 +4470,12 @@ package body Sem_Ch12 is\n             elsif not Box_Present (Parent (Associated_Formal_Package (E))) then\n                Formal_P := Next_Entity (E);\n                Check_Formal_Package_Instance (Formal_P, E);\n+\n+               --  After checking, remove the internal validating package. It\n+               --  is only needed for semantic checks, and as it may contain\n+               --  generic formal declarations it should not reach gigi.\n+\n+               Remove (Unit_Declaration_Node (Formal_P));\n             end if;\n          end if;\n \n@@ -4287,9 +4635,14 @@ package body Sem_Ch12 is\n             elsif Denotes_Formal_Package (E) then\n                null;\n \n-            elsif Present (Associated_Formal_Package (E)) then\n+            elsif Present (Associated_Formal_Package (E))\n+              and then not Is_Generic_Formal (E)\n+            then\n                if Box_Present (Parent (Associated_Formal_Package (E))) then\n                   Check_Generic_Actuals (Renamed_Object (E), True);\n+\n+               else\n+                  Check_Generic_Actuals (Renamed_Object (E), False);\n                end if;\n \n                Set_Is_Hidden (E, False);\n@@ -4301,8 +4654,13 @@ package body Sem_Ch12 is\n          elsif Is_Wrapper_Package (Instance) then\n             Set_Is_Hidden (E, False);\n \n-         else\n-            Set_Is_Hidden (E, not Is_Formal_Box);\n+         --  If the formal package is declared with a box, or if the formal\n+         --  parameter is defaulted, it is visible in the body.\n+\n+         elsif Is_Formal_Box\n+           or else Is_Visible_Formal (E)\n+         then\n+            Set_Is_Hidden (E, False);\n          end if;\n \n          Next_Entity (E);\n@@ -4743,15 +5101,21 @@ package body Sem_Ch12 is\n          then\n             Switch_View (T);\n \n-         --  Finally, a non-private subtype may have a private base type,\n-         --  which must be exchanged for consistency. This can happen when\n-         --  instantiating a package body, when the scope stack is empty\n-         --  but in fact the subtype and the base type are declared in an\n-         --  enclosing scope.\n+         --  Finally, a non-private subtype may have a private base type, which\n+         --  must be exchanged for consistency. This can happen when\n+         --  instantiating a package body, when the scope stack is empty but in\n+         --  fact the subtype and the base type are declared in an enclosing\n+         --  scope.\n+\n+         --  Note that in this case we introduce an inconsistency in the view\n+         --  set, because we switch the base type BT, but there could be some\n+         --  private dependent subtypes of BT which remain unswitched. Such\n+         --  subtypes might need to be switched at a later point (see specific\n+         --  provision for that case in Switch_View).\n \n          elsif not Is_Private_Type (T)\n            and then not Has_Private_View (N)\n-           and then Is_Private_Type (Base_Type (T))\n+           and then Is_Private_Type (BT)\n            and then Present (Full_View (BT))\n            and then not Is_Generic_Type (BT)\n            and then not In_Open_Scopes (BT)\n@@ -5465,7 +5829,9 @@ package body Sem_Ch12 is\n       then\n          return True;\n \n-      elsif Nkind (Parent (Pack)) = N_Formal_Package_Declaration then\n+      elsif Nkind (Original_Node (Unit_Declaration_Node (Pack))) =\n+        N_Formal_Package_Declaration\n+      then\n          return True;\n \n       elsif No (Par) then\n@@ -5482,6 +5848,7 @@ package body Sem_Ch12 is\n               or else Nkind (Parent (E)) /= N_Package_Renaming_Declaration\n             then\n                null;\n+\n             elsif Renamed_Object (E) = Par then\n                return False;\n \n@@ -5535,6 +5902,9 @@ package body Sem_Ch12 is\n          while Present (T) loop\n             if In_Open_Scopes (Scope (T)) then\n                return T;\n+\n+            elsif Is_Generic_Actual_Type (T) then\n+               return T;\n             end if;\n \n             T := Homonym (T);\n@@ -5898,7 +6268,7 @@ package body Sem_Ch12 is\n             return Unit (Parent (Decl));\n          end if;\n \n-      elsif Nkind (Decl) = N_Generic_Package_Declaration\n+      elsif Nkind (Decl) = N_Package_Declaration\n         and then Nkind (Original_Node (Decl)) = N_Formal_Package_Declaration\n       then\n          return Original_Node (Decl);\n@@ -6874,6 +7244,7 @@ package body Sem_Ch12 is\n             Ent := First_Entity (Formal);\n             while Present (Ent) loop\n                Set_Is_Hidden (Ent, False);\n+               Set_Is_Visible_Formal (Ent);\n                Set_Is_Potentially_Use_Visible\n                  (Ent, Is_Potentially_Use_Visible (Formal));\n \n@@ -6969,64 +7340,114 @@ package body Sem_Ch12 is\n          --  handle checking of actual parameter associations for later\n          --  formals that depend on actuals declared in the formal package.\n \n-         if Box_Present (Formal) then\n-            declare\n-               Gen_Decl    : constant Node_Id :=\n-                               Unit_Declaration_Node (Gen_Parent);\n-               Formals     : constant List_Id :=\n-                               Generic_Formal_Declarations (Gen_Decl);\n-               Actual_Ent  : Entity_Id;\n-               Formal_Node : Node_Id;\n-               Formal_Ent  : Entity_Id;\n+         --  In Ada 2005, partial parametrization requires that we make\n+         --  visible the actuals corresponding to formals that were defaulted\n+         --  in the formal package. There formals are identified because they\n+         --  remain formal generics within the formal package, rather than\n+         --  being renamings of the actuals supplied.\n \n-            begin\n-               if Present (Formals) then\n-                  Formal_Node := First_Non_Pragma (Formals);\n-               else\n-                  Formal_Node := Empty;\n-               end if;\n+         declare\n+            Gen_Decl    : constant Node_Id :=\n+                            Unit_Declaration_Node (Gen_Parent);\n+            Formals     : constant List_Id :=\n+                            Generic_Formal_Declarations (Gen_Decl);\n+            Actual_Ent  : Entity_Id;\n+            Formal_Node : Node_Id;\n+            Formal_Ent  : Entity_Id;\n \n-               Actual_Ent := First_Entity (Actual_Pack);\n+         begin\n+            if Present (Formals) then\n+               Formal_Node := First_Non_Pragma (Formals);\n+            else\n+               Formal_Node := Empty;\n+            end if;\n \n-               while Present (Actual_Ent)\n-                 and then Actual_Ent /= First_Private_Entity (Actual_Pack)\n-               loop\n-                  Set_Is_Hidden (Actual_Ent, False);\n-                  Set_Is_Potentially_Use_Visible\n-                    (Actual_Ent, In_Use (Actual_Pack));\n+            Actual_Ent := First_Entity (Actual_Pack);\n+            while Present (Actual_Ent)\n+              and then Actual_Ent /= First_Private_Entity (Actual_Pack)\n+            loop\n+               if Present (Formal_Node) then\n+                  Formal_Ent := Get_Formal_Entity (Formal_Node);\n+\n+                  if Present (Formal_Ent) then\n+                     Find_Matching_Actual (Formal_Node, Actual_Ent);\n+                     Match_Formal_Entity\n+                       (Formal_Node, Formal_Ent, Actual_Ent);\n \n-                  if Ekind (Actual_Ent) = E_Package then\n-                     Process_Nested_Formal (Actual_Ent);\n+                     if Box_Present (Formal)\n+                       or else\n+                         (Present (Formal_Node)\n+                           and then Is_Generic_Formal (Formal_Ent))\n+                     then\n+                        --  This may make too many formal entities visible,\n+                        --  but it's hard to build an example that exposes\n+                        --  this excess visibility. If a reference in the\n+                        --  generic resolved to a global variable then the\n+                        --  extra visibility in an instance does not affect\n+                        --  the captured entity. If the reference resolved\n+                        --  to a local entity it will resolve again in the\n+                        --  instance. Nevertheless, we should build tests\n+                        --  to make sure that hidden entities in the generic\n+                        --  remain hidden in the instance.\n+\n+                        Set_Is_Hidden (Actual_Ent, False);\n+                        Set_Is_Visible_Formal (Actual_Ent);\n+                        Set_Is_Potentially_Use_Visible\n+                          (Actual_Ent, In_Use (Actual_Pack));\n+\n+                        if Ekind (Actual_Ent) = E_Package then\n+                           Process_Nested_Formal (Actual_Ent);\n+                        end if;\n+                     end if;\n                   end if;\n \n-                  if Present (Formal_Node) then\n-                     Formal_Ent := Get_Formal_Entity (Formal_Node);\n+                  Next_Non_Pragma (Formal_Node);\n \n-                     if Present (Formal_Ent) then\n-                        Find_Matching_Actual (Formal_Node, Actual_Ent);\n-                        Match_Formal_Entity\n-                          (Formal_Node, Formal_Ent, Actual_Ent);\n-                     end if;\n+               else\n+                  --  No further formals to match, but the generic\n+                  --  part may contain inherited operation that are\n+                  --  not hidden in the enclosing instance.\n \n-                     Next_Non_Pragma (Formal_Node);\n+                  Next_Entity (Actual_Ent);\n+               end if;\n \n-                  else\n-                     --  No further formals to match, but the generic\n-                     --  part may contain inherited operation that are\n-                     --  not hidden in the enclosing instance.\n+            end loop;\n \n-                     Next_Entity (Actual_Ent);\n-                  end if;\n+            --  Inherited subprograms generated by formal derived types are\n+            --  also visible if the types are.\n \n-               end loop;\n-            end;\n+            Actual_Ent := First_Entity (Actual_Pack);\n+            while Present (Actual_Ent)\n+              and then Actual_Ent /= First_Private_Entity (Actual_Pack)\n+            loop\n+               if Is_Overloadable (Actual_Ent)\n+                 and then\n+                   Nkind (Parent (Actual_Ent)) = N_Subtype_Declaration\n+                 and then\n+                   not Is_Hidden (Defining_Identifier (Parent (Actual_Ent)))\n+               then\n+                  Set_Is_Hidden (Actual_Ent, False);\n+                  Set_Is_Potentially_Use_Visible\n+                    (Actual_Ent, In_Use (Actual_Pack));\n+               end if;\n \n-         --  If the formal is not declared with a box, reanalyze it as\n-         --  an instantiation, to verify the matching rules of 12.7. The\n-         --  actual checks are performed after the generic associations\n-         --  been analyzed.\n+               Next_Entity (Actual_Ent);\n+            end loop;\n+         end;\n \n-         else\n+         --  If the formal is not declared with a box, reanalyze it as\n+         --  an abbreviated instantiation, to verify the matching rules\n+         --  of 12.7. The actual checks are performed after the generic\n+         --  associations have been analyzed, to guarantee the same\n+         --  visibility for this instantiation and for the actuals.\n+\n+         --  In Ada 2005, the generic associations for the formal can include\n+         --  defaulted parameters. These are ignored during check. This\n+         --  internal instantiation is removed from the tree after conformance\n+         --  checking, because it contains formal declarations for those\n+         --  defaulted parameters, and those should not reach the back-end.\n+\n+         if not Box_Present (Formal) then\n             declare\n                I_Pack : constant Entity_Id :=\n                           Make_Defining_Identifier (Sloc (Actual),\n@@ -7038,7 +7459,9 @@ package body Sem_Ch12 is\n                Append_To (Decls,\n                  Make_Package_Instantiation (Sloc (Actual),\n                    Defining_Unit_Name => I_Pack,\n-                   Name => New_Occurrence_Of (Gen_Parent, Sloc (Actual)),\n+                   Name =>\n+                     New_Occurrence_Of\n+                       (Get_Instance_Of (Gen_Parent), Sloc (Actual)),\n                    Generic_Associations =>\n                      Generic_Associations (Formal)));\n             end;\n@@ -7057,7 +7480,7 @@ package body Sem_Ch12 is\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id) return Node_Id\n    is\n-      Loc        : Source_Ptr := Sloc (Instantiation_Node);\n+      Loc        : Source_Ptr;\n       Formal_Sub : constant Entity_Id :=\n                      Defining_Unit_Name (Specification (Formal));\n       Analyzed_S : constant Entity_Id :=\n@@ -7136,11 +7559,34 @@ package body Sem_Ch12 is\n    begin\n       New_Spec := New_Copy_Tree (Specification (Formal));\n \n+      --  The tree copy has created the proper instantiation sloc for the\n+      --  new specification. Use this location for all other constructed\n+      --  declarations.\n+\n+      Loc := Sloc (Defining_Unit_Name (New_Spec));\n+\n       --  Create new entity for the actual (New_Copy_Tree does not)\n \n       Set_Defining_Unit_Name\n         (New_Spec, Make_Defining_Identifier (Loc, Chars (Formal_Sub)));\n \n+      --  Create new entities for the each of the formals in the\n+      --  specification of the renaming declaration built for the actual.\n+\n+      if Present (Parameter_Specifications (New_Spec)) then\n+         declare\n+            F : Node_Id;\n+         begin\n+            F := First (Parameter_Specifications (New_Spec));\n+            while Present (F) loop\n+               Set_Defining_Identifier (F,\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Chars (Defining_Identifier (F))));\n+               Next (F);\n+            end loop;\n+         end;\n+      end if;\n+\n       --  Find entity of actual. If the actual is an attribute reference, it\n       --  cannot be resolved here (its formal is missing) but is handled\n       --  instead in Attribute_Renaming. If the actual is overloaded, it is\n@@ -7332,18 +7778,28 @@ package body Sem_Ch12 is\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id) return List_Id\n    is\n-      Formal_Id : constant Entity_Id  := Defining_Identifier (Formal);\n-      Type_Id   : constant Node_Id    := Subtype_Mark (Formal);\n-      Loc       : constant Source_Ptr := Sloc (Actual);\n-      Act_Assoc : constant Node_Id    := Parent (Actual);\n-      Orig_Ftyp : constant Entity_Id  :=\n-                    Etype (Defining_Identifier (Analyzed_Formal));\n-      List      : constant List_Id    := New_List;\n-      Ftyp      : Entity_Id;\n-      Decl_Node : Node_Id;\n-      Subt_Decl : Node_Id := Empty;\n+      Acc_Def     : Node_Id             := Empty;\n+      Act_Assoc   : constant Node_Id    := Parent (Actual);\n+      Actual_Decl : Node_Id             := Empty;\n+      Formal_Id   : constant Entity_Id  := Defining_Identifier (Formal);\n+      Decl_Node   : Node_Id;\n+      Def         : Node_Id;\n+      Ftyp        : Entity_Id;\n+      List        : constant List_Id    := New_List;\n+      Loc         : constant Source_Ptr := Sloc (Actual);\n+      Orig_Ftyp   : constant Entity_Id  :=\n+                      Etype (Defining_Identifier (Analyzed_Formal));\n+      Subt_Decl   : Node_Id             := Empty;\n+      Subt_Mark   : Node_Id             := Empty;\n \n    begin\n+      if Present (Subtype_Mark (Formal)) then\n+         Subt_Mark := Subtype_Mark (Formal);\n+      else\n+         Check_Access_Definition (Formal);\n+         Acc_Def := Access_Definition (Formal);\n+      end if;\n+\n       --  Sloc for error message on missing actual\n \n       Error_Msg_Sloc := Sloc (Scope (Defining_Identifier (Analyzed_Formal)));\n@@ -7377,11 +7833,20 @@ package body Sem_Ch12 is\n             Abandon_Instantiation (Instantiation_Node);\n          end if;\n \n-         Decl_Node :=\n-           Make_Object_Renaming_Declaration (Loc,\n-             Defining_Identifier => New_Copy (Formal_Id),\n-             Subtype_Mark        => New_Copy_Tree (Type_Id),\n-             Name                => Actual);\n+         if Present (Subt_Mark) then\n+            Decl_Node :=\n+              Make_Object_Renaming_Declaration (Loc,\n+                Defining_Identifier => New_Copy (Formal_Id),\n+                Subtype_Mark        => New_Copy_Tree (Subt_Mark),\n+                Name                => Actual);\n+\n+         else pragma Assert (Present (Acc_Def));\n+            Decl_Node :=\n+              Make_Object_Renaming_Declaration (Loc,\n+                Defining_Identifier => New_Copy (Formal_Id),\n+                Access_Definition   => New_Copy_Tree (Acc_Def),\n+                Name                => Actual);\n+         end if;\n \n          Set_Corresponding_Generic_Association (Decl_Node, Act_Assoc);\n \n@@ -7447,9 +7912,22 @@ package body Sem_Ch12 is\n               (\"actual for& must be a variable\", Actual, Formal_Id);\n \n          elsif Base_Type (Ftyp) /= Base_Type (Etype (Actual)) then\n-            Error_Msg_NE (\n-              \"type of actual does not match type of&\", Actual, Formal_Id);\n \n+            --  Ada 2005 (AI-423): For a generic formal object of mode in\n+            --  out, the type of the actual shall resolve to a specific\n+            --  anonymous access type.\n+\n+            if Ada_Version < Ada_05\n+              or else\n+                Ekind (Base_Type (Ftyp)) /=\n+                  E_Anonymous_Access_Type\n+              or else\n+                Ekind (Base_Type (Etype (Actual))) /=\n+                  E_Anonymous_Access_Type\n+            then\n+               Error_Msg_NE (\"type of actual does not match type of&\",\n+                             Actual, Formal_Id);\n+            end if;\n          end if;\n \n          Note_Possible_Modification (Actual);\n@@ -7475,17 +7953,23 @@ package body Sem_Ch12 is\n       --  OUT not present\n \n       else\n-         --  The instantiation of a generic formal in-parameter\n-         --  is a constant declaration. The actual is the expression for\n+         --  The instantiation of a generic formal in-parameter is a\n+         --  constant declaration. The actual is the expression for\n          --  that declaration.\n \n          if Present (Actual) then\n+            if Present (Subt_Mark) then\n+               Def := Subt_Mark;\n+            else pragma Assert (Present (Acc_Def));\n+               Def := Acc_Def;\n+            end if;\n \n-            Decl_Node := Make_Object_Declaration (Loc,\n-              Defining_Identifier => New_Copy (Formal_Id),\n-              Constant_Present => True,\n-              Object_Definition => New_Copy_Tree (Type_Id),\n-              Expression => Actual);\n+            Decl_Node :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => New_Copy (Formal_Id),\n+                Constant_Present    => True,\n+                Object_Definition   => New_Copy_Tree (Def),\n+                Expression          => Actual);\n \n             Set_Corresponding_Generic_Association (Decl_Node, Act_Assoc);\n \n@@ -7532,16 +8016,23 @@ package body Sem_Ch12 is\n                end if;\n             end;\n \n-         elsif Present (Expression (Formal)) then\n+         elsif Present (Default_Expression (Formal)) then\n \n             --  Use default to construct declaration\n \n+            if Present (Subt_Mark) then\n+               Def := Subt_Mark;\n+            else pragma Assert (Present (Acc_Def));\n+               Def := Acc_Def;\n+            end if;\n+\n             Decl_Node :=\n               Make_Object_Declaration (Sloc (Formal),\n                 Defining_Identifier => New_Copy (Formal_Id),\n                 Constant_Present    => True,\n-                Object_Definition   => New_Copy (Type_Id),\n-                Expression          => New_Copy_Tree (Expression (Formal)));\n+                Object_Definition   => New_Copy (Def),\n+                Expression          => New_Copy_Tree (Default_Expression\n+                                        (Formal)));\n \n             Append (Decl_Node, List);\n             Set_Analyzed (Expression (Decl_Node), False);\n@@ -7560,23 +8051,55 @@ package body Sem_Ch12 is\n                --  Create dummy constant declaration so that instance can\n                --  be analyzed, to minimize cascaded visibility errors.\n \n+               if Present (Subt_Mark) then\n+                  Def := Subt_Mark;\n+               else pragma Assert (Present (Acc_Def));\n+                  Def := Acc_Def;\n+               end if;\n+\n                Decl_Node :=\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => New_Copy (Formal_Id),\n                    Constant_Present    => True,\n-                   Object_Definition   => New_Copy (Type_Id),\n+                   Object_Definition   => New_Copy (Def),\n                    Expression          =>\n                       Make_Attribute_Reference (Sloc (Formal_Id),\n                         Attribute_Name => Name_First,\n-                        Prefix         => New_Copy (Type_Id)));\n+                        Prefix         => New_Copy (Def)));\n \n                Append (Decl_Node, List);\n \n             else\n                Abandon_Instantiation (Instantiation_Node);\n             end if;\n          end if;\n+      end if;\n \n+      if Nkind (Actual) in N_Has_Entity then\n+         Actual_Decl := Parent (Entity (Actual));\n+      end if;\n+\n+      --  Ada 2005 (AI-423): For a formal object declaration with a null\n+      --  exclusion or an access definition that has a null exclusion: If\n+      --  the actual matching the formal object declaration denotes a generic\n+      --  formal object of another generic unit G, and the instantiation\n+      --  containing the actual occurs within the body of G or within the\n+      --  body of a generic unit declared within the declarative region of G,\n+      --  then the declaration of the formal object of G shall have a null\n+      --  exclusion. Otherwise, the subtype of the actual matching the formal\n+      --  object declaration shall exclude null.\n+\n+      if Ada_Version >= Ada_05\n+        and then Present (Actual_Decl)\n+        and then\n+          (Nkind (Actual_Decl) = N_Formal_Object_Declaration\n+             or else Nkind (Actual_Decl) = N_Object_Declaration)\n+        and then Nkind (Analyzed_Formal) = N_Formal_Object_Declaration\n+        and then Has_Null_Exclusion (Actual_Decl)\n+        and then not Has_Null_Exclusion (Analyzed_Formal)\n+      then\n+         Error_Msg_N (\"null-exclusion required in formal object declaration\",\n+                      Analyzed_Formal);\n       end if;\n \n       return List;\n@@ -7897,6 +8420,14 @@ package body Sem_Ch12 is\n          Set_Has_Completion (Anon_Id);\n          Check_Generic_Actuals (Pack_Id, False);\n \n+         --  Generate a reference to link the visible subprogram instance to\n+         --  the the generic body, which for navigation purposes is the only\n+         --  available source for the instance.\n+\n+         Generate_Reference\n+           (Related_Instance (Pack_Id),\n+             Gen_Body_Id, 'b', Set_Ref => False, Force => True);\n+\n          --  If it is a child unit, make the parent instance (which is an\n          --  instance of the parent of the generic) visible. The parent\n          --  instance is the prefix of the name of the generic unit.\n@@ -8074,13 +8605,14 @@ package body Sem_Ch12 is\n       Analyzed_Formal : Node_Id;\n       Actual_Decls    : List_Id) return Node_Id\n    is\n-      Loc       : constant Source_Ptr := Sloc (Actual);\n       Gen_T     : constant Entity_Id  := Defining_Identifier (Formal);\n       A_Gen_T   : constant Entity_Id  := Defining_Identifier (Analyzed_Formal);\n       Ancestor  : Entity_Id := Empty;\n       Def       : constant Node_Id    := Formal_Type_Definition (Formal);\n       Act_T     : Entity_Id;\n       Decl_Node : Node_Id;\n+      Loc       : Source_Ptr;\n+      Subt      : Entity_Id;\n \n       procedure Validate_Array_Type_Instance;\n       procedure Validate_Access_Subprogram_Instance;\n@@ -8470,6 +9002,33 @@ package body Sem_Ch12 is\n             Abandon_Instantiation (Actual);\n          end if;\n \n+         --  Ada 2005 (AI-443): Synchronized formal derived type ckecks. Note\n+         --  that the formal type declaration has been rewritten as a private\n+         --  extension.\n+\n+         if Ada_Version >= Ada_05\n+           and then Nkind (Parent (A_Gen_T)) = N_Private_Extension_Declaration\n+           and then Synchronized_Present (Parent (A_Gen_T))\n+         then\n+            --  The actual must be a synchronized tagged type\n+\n+            if not Is_Tagged_Type (Act_T) then\n+               Error_Msg_N\n+                 (\"actual of synchronized type must be tagged\", Actual);\n+               Abandon_Instantiation (Actual);\n+\n+            elsif Nkind (Parent (Act_T)) = N_Full_Type_Declaration\n+              and then Nkind (Type_Definition (Parent (Act_T))) =\n+                         N_Derived_Type_Definition\n+              and then not Synchronized_Present (Type_Definition\n+                             (Parent (Act_T)))\n+            then\n+               Error_Msg_N\n+                 (\"actual of synchronized type must be synchronized\", Actual);\n+               Abandon_Instantiation (Actual);\n+            end if;\n+         end if;\n+\n          --  Perform atomic/volatile checks (RM C.6(12))\n \n          if Is_Atomic (Act_T) and then not Is_Atomic (Ancestor) then\n@@ -8508,11 +9067,15 @@ package body Sem_Ch12 is\n                   Abandon_Instantiation (Actual);\n                end if;\n \n-            --  Ancestor is unconstrained\n+            --  Ancestor is unconstrained, Check if generic formal and\n+            --  actual agree on constrainedness. The check only applies\n+            --  to array types and discriminated types.\n \n             elsif Is_Constrained (Act_T) then\n                if Ekind (Ancestor) = E_Access_Type\n-                 or else Is_Composite_Type (Ancestor)\n+                 or else\n+                   (not Is_Constrained (A_Gen_T)\n+                     and then Is_Composite_Type (A_Gen_T))\n                then\n                   Error_Msg_N\n                     (\"actual subtype must be unconstrained\", Actual);\n@@ -8628,11 +9191,18 @@ package body Sem_Ch12 is\n            and then not Is_Limited_Type (A_Gen_T)\n          then\n             Error_Msg_NE\n-              (\"actual for non-limited  & cannot be a limited type\", Actual,\n+              (\"actual for non-limited & cannot be a limited type\", Actual,\n                Gen_T);\n             Explain_Limited_Type (Act_T, Actual);\n             Abandon_Instantiation (Actual);\n \n+         elsif Known_To_Have_Preelab_Init (A_Gen_T)\n+           and then not Has_Preelaborable_Initialization (Act_T)\n+         then\n+            Error_Msg_NE\n+              (\"actual for & must have preelaborable initialization\", Actual,\n+               Gen_T);\n+\n          elsif Is_Indefinite_Subtype (Act_T)\n             and then not Is_Indefinite_Subtype (A_Gen_T)\n             and then Ada_Version >= Ada_95\n@@ -8764,8 +9334,14 @@ package body Sem_Ch12 is\n \n          --  Deal with error of using incomplete type as generic actual\n \n-         if Ekind (Act_T) = E_Incomplete_Type then\n-            if No (Underlying_Type (Act_T)) then\n+         if Ekind (Act_T) = E_Incomplete_Type\n+           or else (Is_Class_Wide_Type (Act_T)\n+                      and then\n+                         Ekind (Root_Type (Act_T)) = E_Incomplete_Type)\n+         then\n+            if Is_Class_Wide_Type (Act_T)\n+              or else No (Underlying_Type (Act_T))\n+            then\n                Error_Msg_N (\"premature use of incomplete type\", Actual);\n                Abandon_Instantiation (Actual);\n             else\n@@ -8890,9 +9466,16 @@ package body Sem_Ch12 is\n \n       end case;\n \n+      Subt := New_Copy (Gen_T);\n+\n+      --  Use adjusted sloc of subtype name as the location for other\n+      --  nodes in the subtype declaration.\n+\n+      Loc  := Sloc (Subt);\n+\n       Decl_Node :=\n         Make_Subtype_Declaration (Loc,\n-          Defining_Identifier => New_Copy (Gen_T),\n+          Defining_Identifier => Subt,\n           Subtype_Indication  => New_Reference_To (Act_T, Loc));\n \n       if Is_Private_Type (Act_T) then\n@@ -8918,6 +9501,20 @@ package body Sem_Ch12 is\n       return Decl_Node;\n    end Instantiate_Type;\n \n+   -----------------------\n+   -- Is_Generic_Formal --\n+   -----------------------\n+\n+   function Is_Generic_Formal (E : Entity_Id) return Boolean is\n+      Kind : constant Node_Kind := Nkind (Parent (E));\n+   begin\n+      return\n+        Kind = N_Formal_Object_Declaration\n+          or else Kind = N_Formal_Package_Declaration\n+          or else Kind in N_Formal_Subprogram_Declaration\n+          or else Kind = N_Formal_Type_Declaration;\n+   end Is_Generic_Formal;\n+\n    ---------------------\n    -- Is_In_Main_Unit --\n    ---------------------\n@@ -9248,51 +9845,52 @@ package body Sem_Ch12 is\n \n    begin\n       Assoc := First (Generic_Associations (N));\n-\n       while Present (Assoc) loop\n-         Act := Explicit_Generic_Actual_Parameter (Assoc);\n+         if Nkind (Assoc) /= N_Others_Choice then\n+            Act := Explicit_Generic_Actual_Parameter (Assoc);\n \n-         --  Within a nested instantiation, a defaulted actual is an\n-         --  empty association, so nothing to analyze. If the actual for\n-         --  a subprogram is an attribute, analyze prefix only, because\n-         --  actual is not a complete attribute reference.\n+            --  Within a nested instantiation, a defaulted actual is an empty\n+            --  association, so nothing to analyze. If the subprogram actual\n+            --  isan attribute, analyze prefix only, because actual is not a\n+            --  complete attribute reference.\n \n-         --  If actual is an allocator, analyze expression only. The full\n-         --  analysis can generate code, and if the instance is a compilation\n-         --  unit we have to wait until the package instance is installed to\n-         --  have a proper place to insert this code.\n+            --  If actual is an allocator, analyze expression only. The full\n+            --  analysis can generate code, and if instance is a compilation\n+            --  unit we have to wait until the package instance is installed\n+            --  to have a proper place to insert this code.\n \n-         --  String literals may be operators, but at this point we do not\n-         --  know whether the actual is a formal subprogram or a string.\n+            --  String literals may be operators, but at this point we do not\n+            --  know whether the actual is a formal subprogram or a string.\n \n-         if No (Act) then\n-            null;\n+            if No (Act) then\n+               null;\n \n-         elsif Nkind (Act) = N_Attribute_Reference then\n-            Analyze (Prefix (Act));\n+            elsif Nkind (Act) = N_Attribute_Reference then\n+               Analyze (Prefix (Act));\n \n-         elsif Nkind (Act) = N_Explicit_Dereference then\n-            Analyze (Prefix (Act));\n+            elsif Nkind (Act) = N_Explicit_Dereference then\n+               Analyze (Prefix (Act));\n \n-         elsif Nkind (Act) = N_Allocator then\n-            declare\n-               Expr : constant Node_Id := Expression (Act);\n+            elsif Nkind (Act) = N_Allocator then\n+               declare\n+                  Expr : constant Node_Id := Expression (Act);\n \n-            begin\n-               if Nkind (Expr) = N_Subtype_Indication then\n-                  Analyze (Subtype_Mark (Expr));\n-                  Analyze_List (Constraints (Constraint (Expr)));\n-               else\n-                  Analyze (Expr);\n-               end if;\n-            end;\n+               begin\n+                  if Nkind (Expr) = N_Subtype_Indication then\n+                     Analyze (Subtype_Mark (Expr));\n+                     Analyze_List (Constraints (Constraint (Expr)));\n+                  else\n+                     Analyze (Expr);\n+                  end if;\n+               end;\n \n-         elsif Nkind (Act) /= N_Operator_Symbol then\n-            Analyze (Act);\n-         end if;\n+            elsif Nkind (Act) /= N_Operator_Symbol then\n+               Analyze (Act);\n+            end if;\n \n-         if Errs /= Serious_Errors_Detected then\n-            Abandon_Instantiation (Act);\n+            if Errs /= Serious_Errors_Detected then\n+               Abandon_Instantiation (Act);\n+            end if;\n          end if;\n \n          Next (Assoc);\n@@ -9428,17 +10026,16 @@ package body Sem_Ch12 is\n \n       procedure Restore_Nested_Formal (Formal : Entity_Id) is\n          Ent : Entity_Id;\n+\n       begin\n          if Present (Renamed_Object (Formal))\n            and then Denotes_Formal_Package (Renamed_Object (Formal), True)\n          then\n             return;\n \n-         elsif Present (Associated_Formal_Package (Formal))\n-          and then Box_Present (Parent (Associated_Formal_Package (Formal)))\n-         then\n-            Ent := First_Entity (Formal);\n+         elsif Present (Associated_Formal_Package (Formal)) then\n \n+            Ent := First_Entity (Formal);\n             while Present (Ent) loop\n                exit when Ekind (Ent) = E_Package\n                  and then Renamed_Entity (Ent) = Renamed_Entity (Formal);\n@@ -9457,6 +10054,8 @@ package body Sem_Ch12 is\n          end if;\n       end Restore_Nested_Formal;\n \n+   --  Start of processing for Restore_Private_Views\n+\n    begin\n       M := First_Elmt (Exchanged_Views);\n       while Present (M) loop\n@@ -9473,7 +10072,6 @@ package body Sem_Ch12 is\n            or else Ekind (Typ) = E_Record_Type_With_Private\n          then\n             Dep_Elmt := First_Elmt (Private_Dependents (Typ));\n-\n             while Present (Dep_Elmt) loop\n                Dep_Typ := Node (Dep_Elmt);\n \n@@ -9500,7 +10098,6 @@ package body Sem_Ch12 is\n       --  types into subtypes of the actuals again.\n \n       E := First_Entity (Pack_Id);\n-\n       while Present (E) loop\n          Set_Is_Hidden (E, True);\n \n@@ -10152,19 +10749,39 @@ package body Sem_Ch12 is\n                  or else Nkind (N2) = N_Real_Literal\n                  or else Nkind (N2) = N_String_Literal\n                then\n-                  --  Operation was constant-folded, perform the same\n-                  --  replacement in generic.\n+                  if Present (Original_Node (N2))\n+                    and then Nkind (Original_Node (N2)) = Nkind (N)\n+                  then\n \n-                  Rewrite (N, New_Copy (N2));\n-                  Set_Analyzed (N, False);\n+                     --  Operation was constant-folded. Whenever possible,\n+                     --  recover semantic information from unfolded node,\n+                     --  for ASIS use.\n+\n+                     Set_Associated_Node (N, Original_Node (N2));\n+\n+                     if Nkind (N) = N_Op_Concat then\n+                        Set_Is_Component_Left_Opnd (N,\n+                          Is_Component_Left_Opnd  (Get_Associated_Node (N)));\n+                        Set_Is_Component_Right_Opnd (N,\n+                          Is_Component_Right_Opnd (Get_Associated_Node (N)));\n+                     end if;\n+\n+                     Reset_Entity (N);\n+\n+                  else\n+                     --  If original node is already modified, propagate\n+                     --  constant-folding to template.\n+\n+                     Rewrite (N, New_Copy (N2));\n+                     Set_Analyzed (N, False);\n+                  end if;\n \n                elsif Nkind (N2) = N_Identifier\n                  and then Ekind (Entity (N2)) = E_Enumeration_Literal\n                then\n-                  --  Same if call was folded into a literal, but in this\n-                  --  case retain the entity to avoid spurious ambiguities\n-                  --  if id is overloaded at the point of instantiation or\n-                  --  inlining.\n+                  --  Same if call was folded into a literal, but in this case\n+                  --  retain the entity to avoid spurious ambiguities if id is\n+                  --  overloaded at the point of instantiation or inlining.\n \n                   Rewrite (N, New_Copy (N2));\n                   Set_Analyzed (N, False);\n@@ -10181,9 +10798,9 @@ package body Sem_Ch12 is\n          elsif Nkind (N) = N_Identifier then\n             if Nkind (N) = Nkind (Get_Associated_Node (N)) then\n \n-               --  If this is a discriminant reference, always save it.\n-               --  It is used in the instance to find the corresponding\n-               --  discriminant positionally rather than  by name.\n+               --  If this is a discriminant reference, always save it. It is\n+               --  used in the instance to find the corresponding discriminant\n+               --  positionally rather than by name.\n \n                Set_Original_Discriminant\n                  (N, Original_Discriminant (Get_Associated_Node (N)));\n@@ -10195,8 +10812,8 @@ package body Sem_Ch12 is\n                if Nkind (N2) = N_Function_Call then\n                   E := Entity (Name (N2));\n \n-                  --  Name resolves to a call to parameterless function.\n-                  --  If original entity is global, mark node as resolved.\n+                  --  Name resolves to a call to parameterless function. If\n+                  --  original entity is global, mark node as resolved.\n \n                   if Present (E)\n                     and then Is_Global (E)\n@@ -10208,16 +10825,25 @@ package body Sem_Ch12 is\n                   end if;\n \n                elsif\n-                 Nkind (N2) = N_Integer_Literal or else\n-                 Nkind (N2) = N_Real_Literal    or else\n-                 Nkind (N2) = N_String_Literal\n+                 (Nkind (N2) = N_Integer_Literal\n+                    or else\n+                  Nkind (N2) = N_Real_Literal)\n+                 and then Is_Entity_Name (Original_Node (N2))\n                then\n                   --  Name resolves to named number that is constant-folded,\n-                  --  or to string literal from concatenation.\n-                  --  Perform the same replacement in generic.\n+                  --  We must preserve the original name for ASIS use, and\n+                  --  undo the constant-folding, which will be repeated in\n+                  --  each instance.\n+\n+                  Set_Associated_Node (N, Original_Node (N2));\n+                  Reset_Entity (N);\n+\n+               elsif Nkind (N2) = N_String_Literal then\n+\n+                  --  Name resolves to string literal. Perform the same\n+                  --  replacement in generic.\n \n                   Rewrite (N, New_Copy (N2));\n-                  Set_Analyzed (N, False);\n \n                elsif Nkind (N2) = N_Explicit_Dereference then\n \n@@ -10474,9 +11100,14 @@ package body Sem_Ch12 is\n \n    begin\n       --  T may be private but its base type may have been exchanged through\n-      --  some other occurrence, in which case there is nothing to switch.\n+      --  some other occurrence, in which case there is nothing to switch\n+      --  besides T itself. Note that a private dependent subtype of a private\n+      --  type might not have been switched even if the base type has been,\n+      --  because of the last branch of Check_Private_View (see comment there).\n \n       if not Is_Private_Type (BT) then\n+         Prepend_Elmt (Full_View (T), Exchanged_Views);\n+         Exchange_Declarations (T);\n          return;\n       end if;\n "}, {"sha": "2c32536b0f56fda053e97a4894bb2651b67859da", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097fdf65a05396d05141261b11af098ad63b346e/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097fdf65a05396d05141261b11af098ad63b346e/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=097fdf65a05396d05141261b11af098ad63b346e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -126,4 +126,18 @@ package Sem_Ch12 is\n    procedure Initialize;\n    --  Initializes internal data structures\n \n+   procedure Check_Private_View (N : Node_Id);\n+   --  Check whether the type of a generic entity has a different view between\n+   --  the point of generic analysis and the point of instantiation. If the\n+   --  view has changed, then at the point of instantiation we restore the\n+   --  correct view to perform semantic analysis of the instance, and reset\n+   --  the current view after instantiation. The processing is driven by the\n+   --  current private status of the type of the node, and Has_Private_View,\n+   --  a flag that is set at the point of generic compilation. If view and\n+   --  flag are inconsistent then the type is updated appropriately.\n+   --\n+   --  This subprogram is used in Check_Generic_Actuals and Copy_Generic_Node,\n+   --  and is exported here for the purpose of front-end inlining (see Exp_Ch6.\n+   --  Expand_Inlined_Call.Process_Formals).\n+\n end Sem_Ch12;"}]}