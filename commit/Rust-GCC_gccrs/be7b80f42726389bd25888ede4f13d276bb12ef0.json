{"sha": "be7b80f42726389bd25888ede4f13d276bb12ef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU3YjgwZjQyNzI2Mzg5YmQyNTg4OGVkZTRmMTNkMjc2YmIxMmVmMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-15T07:17:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-15T07:17:29Z"}, "message": "alpha.h (TARGET_ABI_OSF): New.\n\n        * config/alpha/alpha.h (TARGET_ABI_OSF): New.\n        (TARGET_ABI_WINDOWS_NT, TARGET_ABI_OPEN_VMS): Rename; update users.\n        * config/alpha/alpha-protos.h: Update TARGET_ABI_* users.\n        * config/alpha/alpha.c: Likewise.\n        * config/alpha/alpha.md: Likewise.\n        * config/alpha/alpha32.h: Likewise.\n        * config/alpha/vms.h: Likewise.\n        (OPEN_VMS): Remove.\n\nFrom-SVN: r44016", "tree": {"sha": "dff3d108662cdda2dbc8d2f9a916e7dcebd3c4c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dff3d108662cdda2dbc8d2f9a916e7dcebd3c4c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be7b80f42726389bd25888ede4f13d276bb12ef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7b80f42726389bd25888ede4f13d276bb12ef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be7b80f42726389bd25888ede4f13d276bb12ef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be7b80f42726389bd25888ede4f13d276bb12ef0/comments", "author": null, "committer": null, "parents": [{"sha": "4a82c9509df641811f41ab3e6684fa06c7c01825", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a82c9509df641811f41ab3e6684fa06c7c01825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a82c9509df641811f41ab3e6684fa06c7c01825"}], "stats": {"total": 317, "additions": 166, "deletions": 151}, "files": [{"sha": "b7e9e881ce8c5caf9da5f866edf95b8bd4274db2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -1,3 +1,14 @@\n+2001-07-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.h (TARGET_ABI_OSF): New.\n+\t(TARGET_ABI_WINDOWS_NT, TARGET_ABI_OPEN_VMS): Rename; update users.\n+\t* config/alpha/alpha-protos.h: Update TARGET_ABI_* users.\n+\t* config/alpha/alpha.c: Likewise.\n+\t* config/alpha/alpha.md: Likewise.\n+\t* config/alpha/alpha32.h: Likewise.\n+\t* config/alpha/vms.h: Likewise.\n+\t(OPEN_VMS): Remove.\n+\n 2001-07-14  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.md: Use define_constants for unspec values."}, {"sha": "c6c4b7b9c5a8d97a0fd2efd7d4e76e366d0bfd66", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -111,7 +111,7 @@ extern int check_float_value PARAMS ((enum machine_mode,\n \t\t\t\t     REAL_VALUE_TYPE *, int));\n #endif\n \n-#if OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n #ifdef HAVE_MACHINE_MODES\n extern enum avms_arg_type alpha_arg_type PARAMS ((enum machine_mode));\n #endif\n@@ -121,7 +121,7 @@ extern rtx alpha_arg_info_reg_val PARAMS ((CUMULATIVE_ARGS));\n #ifdef BUFSIZ\n extern void alpha_write_linkage PARAMS ((FILE *));\n #endif\n-#endif /* OPEN_VMS */\n+#endif /* TARGET_ABI_OPEN_VMS */\n \n #ifdef RTX_CODE\n extern rtx alpha_need_linkage PARAMS ((const char *, int));"}, {"sha": "5daa1b9ff7c2b82a0411fb5bcfa35a189ee096f6", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -133,7 +133,7 @@ static void alpha_output_function_end_prologue\n   PARAMS ((FILE *));\n \n /* Get the number of args of a function in one of two ways.  */\n-#ifdef OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n #define NUM_ARGS current_function_args_info.num_args\n #else\n #define NUM_ARGS current_function_args_info\n@@ -143,7 +143,7 @@ static void alpha_output_function_end_prologue\n #define REG_RA 26\n \f\n /* Initialize the GCC target structure.  */\n-#ifdef OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n    static int vms_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n #  undef TARGET_VALID_DECL_ATTRIBUTE\n #  define TARGET_VALID_DECL_ATTRIBUTE vms_valid_decl_attribute_p\n@@ -740,9 +740,17 @@ call_operand (op, mode)\n   if (mode != Pmode)\n     return 0;\n \n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  || (GET_CODE (op) == REG\n-\t      && (TARGET_OPEN_VMS || TARGET_WINDOWS_NT || REGNO (op) == 27)));\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return 1;\n+  if (GET_CODE (op) == REG)\n+    {\n+      if (TARGET_ABI_OSF)\n+\treturn REGNO (op) == 27;\n+      else\n+\treturn 1;\n+    }\n+\n+  return 0;\n }\n \n /* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n@@ -1059,7 +1067,9 @@ addition_operation (op, mode)\n int\n direct_return ()\n {\n-  return (! TARGET_OPEN_VMS && reload_completed && alpha_sa_size () == 0\n+  return (! TARGET_ABI_OPEN_VMS\n+\t  && reload_completed\n+\t  && alpha_sa_size () == 0\n \t  && get_frame_size () == 0\n \t  && current_function_outgoing_args_size == 0\n \t  && current_function_pretend_args_size == 0);\n@@ -2156,7 +2166,7 @@ alpha_lookup_xfloating_lib_func (code)\n      knowledge of the G_floating routines.  */\n   if (TARGET_FLOAT_VAX)\n     {\n-      if (TARGET_OPEN_VMS)\n+      if (TARGET_ABI_OPEN_VMS)\n \t{\n \t  if (code == FLOAT_EXTEND)\n \t    return \"OTS$CVT_FLOAT_G_X\";\n@@ -2172,7 +2182,7 @@ alpha_lookup_xfloating_lib_func (code)\n \t}\n     }\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     ops = vms_xfloating_ops;\n   else\n     ops = osf_xfloating_ops;\n@@ -4057,7 +4067,7 @@ alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n {\n   rtx temp, temp1, addr;\n   /* VMS really uses DImode pointers in memory at this point.  */\n-  enum machine_mode mode = TARGET_OPEN_VMS ? Pmode : ptr_mode;\n+  enum machine_mode mode = TARGET_ABI_OPEN_VMS ? Pmode : ptr_mode;\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n   fnaddr = convert_memory_address (mode, fnaddr);\n@@ -4126,7 +4136,14 @@ function_arg (cum, mode, type, named)\n   int basereg;\n   int num_args;\n \n-#ifndef OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n+  if (mode == VOIDmode)\n+    return alpha_arg_info_reg_val (cum);\n+\n+  num_args = cum.num_args;\n+  if (num_args >= 6 || MUST_PASS_IN_STACK (mode, type))\n+    return NULL_RTX;\n+#else\n   if (cum >= 6)\n     return NULL_RTX;\n   num_args = cum;\n@@ -4138,14 +4155,7 @@ function_arg (cum, mode, type, named)\n     return NULL_RTX;\n   else if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n     basereg = 16;\n-#else\n-  if (mode == VOIDmode)\n-    return alpha_arg_info_reg_val (cum);\n-\n-  num_args = cum.num_args;\n-  if (num_args >= 6 || MUST_PASS_IN_STACK (mode, type))\n-    return NULL_RTX;\n-#endif /* OPEN_VMS */\n+#endif /* TARGET_ABI_OPEN_VMS */\n   else if (TARGET_FPREGS\n \t   && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n \t       || GET_MODE_CLASS (mode) == MODE_FLOAT))\n@@ -4161,7 +4171,7 @@ alpha_build_va_list ()\n {\n   tree base, ofs, record, type_decl;\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     return ptr_type_node;\n \n   record = make_lang_type (RECORD_TYPE);\n@@ -4198,7 +4208,7 @@ alpha_va_start (stdarg_p, valist, nextarg)\n   if (TREE_CODE (TREE_TYPE (valist)) == ERROR_MARK)\n     return;\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n \n   /* For Unix, SETUP_INCOMING_VARARGS moves the starting address base\n@@ -4246,7 +4256,7 @@ alpha_va_arg (valist, type)\n   tree wide_type, wide_ofs;\n   int indirect = 0;\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     return std_expand_builtin_va_arg (valist, type);\n \n   tsize = ((TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_UNIT + 7) / 8) * 8;\n@@ -4343,7 +4353,7 @@ alpha_sa_mask (imaskP, fmaskP)\n   if (!current_function_is_thunk)\n #endif\n     {\n-      if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n+      if (TARGET_ABI_OPEN_VMS && vms_is_stack_procedure)\n \timask |= (1L << HARD_FRAME_POINTER_REGNUM);\n \n       /* One for every register we have to save.  */\n@@ -4396,7 +4406,7 @@ alpha_sa_size ()\n \t  sa_size++;\n     }\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Start by assuming we can use a register procedure if we don't\n \t make any calls (REG_RA not used) or need to save any\n@@ -4462,7 +4472,7 @@ alpha_using_fp ()\n   return vms_unwind_regno == HARD_FRAME_POINTER_REGNUM;\n }\n \n-#ifdef OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n \n static int\n vms_valid_decl_attribute_p (decl, attributes, identifier, args)\n@@ -4484,7 +4494,7 @@ alpha_does_function_need_gp ()\n   rtx insn;\n \n   /* We never need a GP for Windows/NT or VMS.  */\n-  if (TARGET_WINDOWS_NT || TARGET_OPEN_VMS)\n+  if (TARGET_ABI_WINDOWS_NT || TARGET_ABI_OPEN_VMS)\n     return 0;\n \n   if (TARGET_PROFILING_NEEDS_GP && profile_flag)\n@@ -4593,7 +4603,7 @@ alpha_expand_prologue ()\n   sa_size = alpha_sa_size ();\n \n   frame_size = get_frame_size ();\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     frame_size = ALPHA_ROUND (sa_size \n \t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n \t\t\t      + frame_size\n@@ -4604,15 +4614,15 @@ alpha_expand_prologue ()\n \t\t  + ALPHA_ROUND (frame_size\n \t\t\t\t + current_function_pretend_args_size));\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8;\n   else\n     reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n \n   alpha_sa_mask (&imask, &fmask);\n \n   /* Emit an insn to reload GP, if needed.  */\n-  if (!TARGET_OPEN_VMS && !TARGET_WINDOWS_NT)\n+  if (TARGET_ABI_OSF)\n     {\n       alpha_function_needs_gp = alpha_does_function_need_gp ();\n       if (alpha_function_needs_gp)\n@@ -4682,7 +4692,7 @@ alpha_expand_prologue ()\n \t  emit_move_insn (last, const0_rtx);\n \t}\n \n-      if (TARGET_WINDOWS_NT)\n+      if (TARGET_ABI_WINDOWS_NT)\n \t{\n \t  /* For NT stack unwind (done by 'reverse execution'), it's\n \t     not OK to take the result of a loop, even though the value\n@@ -4737,7 +4747,7 @@ alpha_expand_prologue ()\n     }\n     \n   /* Save regs in stack order.  Beginning with VMS PV.  */\n-  if (TARGET_OPEN_VMS && vms_is_stack_procedure)\n+  if (TARGET_ABI_OPEN_VMS && vms_is_stack_procedure)\n     {\n       mem = gen_rtx_MEM (DImode, stack_pointer_rtx);\n       set_mem_alias_set (mem, alpha_sr_alias_set);\n@@ -4773,7 +4783,7 @@ alpha_expand_prologue ()\n \treg_offset += 8;\n       }\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       if (!vms_is_stack_procedure)\n \t/* Register frame procedures fave the fp.  */\n@@ -4847,7 +4857,7 @@ alpha_start_function (file, fnname, decl)\n   sa_size = alpha_sa_size ();\n \n   frame_size = get_frame_size ();\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     frame_size = ALPHA_ROUND (sa_size \n \t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n \t\t\t      + frame_size\n@@ -4858,7 +4868,7 @@ alpha_start_function (file, fnname, decl)\n \t\t  + ALPHA_ROUND (frame_size\n \t\t\t\t + current_function_pretend_args_size));\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8;\n   else\n     reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n@@ -4883,16 +4893,15 @@ alpha_start_function (file, fnname, decl)\n     }\n \n   /* Issue function start and label.  */\n-  if (TARGET_OPEN_VMS || !flag_inhibit_size_directive)\n+  if (TARGET_ABI_OPEN_VMS || !flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.ent \", file);\n       assemble_name (file, fnname);\n       putc ('\\n', file);\n \n       /* If the function needs GP, we'll write the \"..ng\" label there.\n \t Otherwise, do it here.  */\n-      if (! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\n-\t  && ! alpha_function_needs_gp)\n+      if (TARGET_ABI_OSF && ! alpha_function_needs_gp)\n \t{\n \t  putc ('$', file);\n \t  assemble_name (file, fnname);\n@@ -4901,15 +4910,15 @@ alpha_start_function (file, fnname, decl)\n     }\n \n   strcpy (entry_label, fnname);\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     strcat (entry_label, \"..en\");\n   ASM_OUTPUT_LABEL (file, entry_label);\n   inside_function = TRUE;\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     fprintf (file, \"\\t.base $%d\\n\", vms_base_regno);\n \n-  if (!TARGET_OPEN_VMS && TARGET_IEEE_CONFORMANT\n+  if (!TARGET_ABI_OPEN_VMS && TARGET_IEEE_CONFORMANT\n       && !flag_inhibit_size_directive)\n     {\n       /* Set flags in procedure descriptor to request IEEE-conformant\n@@ -4925,7 +4934,7 @@ alpha_start_function (file, fnname, decl)\n   /* Describe our frame.  If the frame size is larger than an integer,\n      print it as zero to avoid an assembler error.  We won't be\n      properly describing such a frame, but that's the best we can do.  */\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       fprintf (file, \"\\t.frame $%d,\", vms_unwind_regno);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n@@ -4945,7 +4954,7 @@ alpha_start_function (file, fnname, decl)\n     }\n \n   /* Describe which registers were spilled.  */\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       if (imask)\n         /* ??? Does VMS care if mask contains ra?  The old code did'nt\n@@ -4979,7 +4988,7 @@ alpha_start_function (file, fnname, decl)\n \t}\n     }\n \n-#ifdef OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n   /* Ifdef'ed cause readonly_section and link_section are only\n      available then.  */\n   readonly_section ();\n@@ -5009,9 +5018,9 @@ static void\n alpha_output_function_end_prologue (file)\n      FILE *file;\n {\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     fputs (\"\\t.prologue\\n\", file);\n-  else if (TARGET_WINDOWS_NT)\n+  else if (TARGET_ABI_WINDOWS_NT)\n     fputs (\"\\t.prologue 0\\n\", file);\n   else if (!flag_inhibit_size_directive)\n     fprintf (file, \"\\t.prologue %d\\n\", alpha_function_needs_gp);\n@@ -5046,7 +5055,7 @@ alpha_expand_epilogue ()\n   sa_size = alpha_sa_size ();\n \n   frame_size = get_frame_size ();\n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     frame_size = ALPHA_ROUND (sa_size \n \t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n \t\t\t      + frame_size\n@@ -5057,15 +5066,15 @@ alpha_expand_epilogue ()\n \t\t  + ALPHA_ROUND (frame_size\n \t\t\t\t + current_function_pretend_args_size));\n \n-  if (TARGET_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     reg_offset = 8;\n   else\n     reg_offset = ALPHA_ROUND (current_function_outgoing_args_size);\n \n   alpha_sa_mask (&imask, &fmask);\n \n-  fp_is_frame_pointer = ((TARGET_OPEN_VMS && vms_is_stack_procedure)\n-\t\t\t || (!TARGET_OPEN_VMS && frame_pointer_needed));\n+  fp_is_frame_pointer = ((TARGET_ABI_OPEN_VMS && vms_is_stack_procedure)\n+\t\t\t || (!TARGET_ABI_OPEN_VMS && frame_pointer_needed));\n   fp_offset = 0;\n   sa_reg = stack_pointer_rtx;\n \n@@ -5077,9 +5086,9 @@ alpha_expand_epilogue ()\n   if (sa_size)\n     {\n       /* If we have a frame pointer, restore SP from it.  */\n-      if ((TARGET_OPEN_VMS\n+      if ((TARGET_ABI_OPEN_VMS\n \t   && vms_unwind_regno == HARD_FRAME_POINTER_REGNUM)\n-\t  || (!TARGET_OPEN_VMS && frame_pointer_needed))\n+\t  || (!TARGET_ABI_OPEN_VMS && frame_pointer_needed))\n \tFRP (emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx));\n \n       /* Cope with very large offsets to the register save area.  */\n@@ -5188,7 +5197,7 @@ alpha_expand_epilogue ()\n \t  set_mem_alias_set (mem, alpha_sr_alias_set);\n \t  FRP (emit_move_insn (hard_frame_pointer_rtx, mem));\n \t}\n-      else if (TARGET_OPEN_VMS)\n+      else if (TARGET_ABI_OPEN_VMS)\n \t{\n \t  emit_insn (gen_blockage ());\n \t  FRP (emit_move_insn (hard_frame_pointer_rtx,\n@@ -5202,7 +5211,7 @@ alpha_expand_epilogue ()\n     }\n   else \n     {\n-      if (TARGET_OPEN_VMS && !vms_is_stack_procedure)\n+      if (TARGET_ABI_OPEN_VMS && !vms_is_stack_procedure)\n         {\n           emit_insn (gen_blockage ());\n           FRP (emit_move_insn (hard_frame_pointer_rtx,\n@@ -6270,7 +6279,7 @@ check_float_value (mode, d, overflow)\n   return 0;\n }\n \n-#if OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n \n /* Return the VMS argument type corresponding to MODE.  */\n \n@@ -6466,4 +6475,4 @@ alpha_need_linkage (name, is_local)\n   return NULL_RTX;\n }\n \n-#endif /* OPEN_VMS */\n+#endif /* TARGET_ABI_OPEN_VMS */"}, {"sha": "1a1bb7133c0e3847cc477827c8d9cffd183cdb1c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -173,12 +173,9 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #define TARGET_SUPPORT_ARCH\t(target_flags & MASK_SUPPORT_ARCH)\n \n /* These are for target os support and cannot be changed at runtime.  */\n-#ifndef TARGET_WINDOWS_NT\n-#define TARGET_WINDOWS_NT 0\n-#endif\n-#ifndef TARGET_OPEN_VMS\n-#define TARGET_OPEN_VMS 0\n-#endif\n+#define TARGET_ABI_WINDOWS_NT 0\n+#define TARGET_ABI_OPEN_VMS 0\n+#define TARGET_ABI_OSF (!TARGET_ABI_WINDOWS_NT && !TARGET_ABI_OPEN_VMS)\n \n #ifndef TARGET_AS_CAN_SUBTRACT_LABELS\n #define TARGET_AS_CAN_SUBTRACT_LABELS TARGET_GAS\n@@ -2147,7 +2144,7 @@ literal_section ()\t\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  fprintf (FILE, \"\\t.%s $L%d\\n\", TARGET_WINDOWS_NT ? \"long\" : \"gprel32\", \\\n+  fprintf (FILE, \"\\t.%s $L%d\\n\", TARGET_ABI_WINDOWS_NT ? \"long\" : \"gprel32\", \\\n \t   (VALUE))\n \n /* This is how to output an assembler line\n@@ -2197,7 +2194,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   const char *fn_name = XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0);\t\\\n   int reg;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  if (! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT)\t\t\t\t\\\n+  if (TARGET_ABI_OSF)\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tldgp $29,0($27)\\n\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* Mark end of prologue.  */\t\t\t\t\t\t\\"}, {"sha": "dc9f5078cc2c4a541cae0d596e71cace002bff82", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -227,14 +227,14 @@\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fadd,fcmov,fmul,fcpys,fbr,fdiv\"))\n   4 1)\n-  \n+\n (define_function_unit \"ev5_fm\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fmul\"))\n   4 1)\n \n ; Add and cmov as you would expect; fbr never produces a result;\n-; fdiv issues through fa to the divider, \n+; fdiv issues through fa to the divider,\n (define_function_unit \"ev5_fa\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fadd,fcmov,fbr,fdiv\"))\n@@ -259,7 +259,7 @@\n ;; EV6 has two symmetric pairs (\"clusters\") of two asymetric integer units\n ;; (\"upper\" and \"lower\"), yielding pipe names U0, U1, L0, L1.\n \n-;; Conditional moves decompose into two independant primitives, each \n+;; Conditional moves decompose into two independant primitives, each\n ;; taking one cycle.  Since ev6 is out-of-order, we can't see anything\n ;; but two cycles.\n (define_function_unit \"ev6_ebox\" 4 0\n@@ -344,7 +344,7 @@\n \n ;; For the FPU we are very similar to EV5, except there's no insn that\n ;; can issue to fm & fa, so we get to leave that out.\n-  \n+\n (define_function_unit \"ev6_fm\" 1 0\n   (and (eq_attr \"cpu\" \"ev6\")\n        (eq_attr \"type\" \"fmul\"))\n@@ -614,7 +614,7 @@\n ;;   (that's a bug, but not one we can do anything about).  As of NT4.0 SP3,\n ;;   the exception handling code will loop if a subq is used and an\n ;;   exception occurs.\n-;;  \n+;;\n ;;   The 19980616 change to emit prologues as RTL also confused some\n ;;   versions of GDB, which also interprets prologues.  This has been\n ;;   fixed as of GDB 4.18, but it does not harm to unconditionally\n@@ -986,7 +986,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"udivsi3\"\n@@ -1000,7 +1000,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"modsi3\"\n@@ -1014,7 +1014,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"umodsi3\"\n@@ -1028,7 +1028,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"divdi3\"\n@@ -1041,7 +1041,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"udivdi3\"\n@@ -1054,7 +1054,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"moddi3\"\n@@ -1067,7 +1067,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"umoddi3\"\n@@ -1080,7 +1080,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n ;; Lengths of 8 for ldq $t12,__divq($gp); jsr $t9,($t12),__divq as\n@@ -1091,7 +1091,7 @@\n \t\t\t[(reg:DI 24) (reg:DI 25)])))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"%E0 $24,$25,$27\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -1102,7 +1102,7 @@\n \t\t\t[(reg:DI 24) (reg:DI 25)]))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"!TARGET_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS\"\n   \"%E0 $24,$25,$27\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -1212,7 +1212,7 @@\n   if (! TARGET_BWX)\n     operands[1] = force_reg (QImode, operands[1]);\n }\")\n-  \n+\n (define_insn \"*zero_extendqidi2_bwx\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n@@ -1228,7 +1228,7 @@\n   \"! TARGET_BWX\"\n   \"and %1,0xff,%0\"\n   [(set_attr \"type\" \"ilog\")])\n-  \n+\n (define_expand \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n@@ -1339,7 +1339,7 @@\n   \"eqv %r1,%2,%0\"\n   [(set_attr \"type\" \"ilog\")])\n \f\n-;; Handle the FFS insn iff we support CIX. \n+;; Handle the FFS insn iff we support CIX.\n \n (define_expand \"ffsdi2\"\n   [(set (match_dup 2)\n@@ -1361,7 +1361,7 @@\n \t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] UNSPEC_CTTZ))]\n   \"TARGET_CIX\"\n   \"cttz %1,%0\"\n-  ; EV6 calls all mvi and cttz/ctlz/popc class imisc, so just \n+  ; EV6 calls all mvi and cttz/ctlz/popc class imisc, so just\n   ; reuse the existing type name.\n   [(set_attr \"type\" \"mvi\")])\n \f\n@@ -1407,7 +1407,7 @@\n ;;    return \\\"s%P2addl %r1,0,%0\\\";\n ;; }\"\n ;;  [(set_attr \"type\" \"iadd\")])\n-\t\t\t  \n+\n (define_insn \"lshrdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1440,7 +1440,7 @@\n \t\t\t\t   force_reg (QImode, operands[1])));\n       DONE;\n     }\n- \n+\n  /* If we have an unaligned MEM, extend to DImode (which we do\n      specially) and then copy to the result.  */\n   if (unaligned_memory_operand (operands[1], HImode))\n@@ -1687,7 +1687,7 @@\n   [(set_attr \"type\" \"shift\")])\n \n ;; Combine has some strange notion of preserving existing undefined behaviour\n-;; in shifts larger than a word size.  So capture these patterns that it \n+;; in shifts larger than a word size.  So capture these patterns that it\n ;; should have turned into zero_extracts.\n \n (define_insn \"*extxl_1\"\n@@ -1774,11 +1774,11 @@\n ;;\t\t   (match_dup 4)))]\n ;;  \"\n ;;{\n-;;  operands[6] = plus_constant (operands[3], \n+;;  operands[6] = plus_constant (operands[3],\n ;;\t\t\t       INTVAL (operands[2]) / BITS_PER_UNIT);\n ;;  operands[7] = GEN_INT (- INTVAL (operands[2]) / BITS_PER_UNIT);\n ;;}\")\n-  \n+\n (define_insn \"*insbl_const\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\"))\n@@ -2353,7 +2353,7 @@\n      bit at bit 48 of the fraction, which is representable in DFmode,\n      which prevents rounding error in the final conversion to SFmode.  */\n \n-  emit_insn (gen_rtx_SET (VOIDmode, sticky, \n+  emit_insn (gen_rtx_SET (VOIDmode, sticky,\n \t\t\t  gen_rtx_NE (DImode, lo, const0_rtx)));\n   emit_insn (gen_iordi3 (hi, hi, sticky));\n   emit_insn (gen_trunctfdf2 (tmpf, arg));\n@@ -3039,7 +3039,7 @@\n   [(set_attr \"type\" \"icmov\")])\n \n (define_expand \"umaxdi3\"\n-  [(set (match_dup 3) \n+  [(set (match_dup 3)\n \t(leu:DI (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n \t\t(match_operand:DI 2 \"reg_or_8bit_operand\" \"\")))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3250,7 +3250,7 @@\n \n (define_insn \"*movdfcc_internal\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:DF \n+\t(if_then_else:DF\n \t (match_operator 3 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DF 4 \"reg_or_fp0_operand\" \"fG,fG\")\n \t\t\t  (match_operand:DF 2 \"fp0_operand\" \"G,G\")])\n@@ -3264,7 +3264,7 @@\n \n (define_insn \"*movsfcc_internal\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:SF \n+\t(if_then_else:SF\n \t (match_operator 3 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DF 4 \"reg_or_fp0_operand\" \"fG,fG\")\n \t\t\t  (match_operand:DF 2 \"fp0_operand\" \"G,G\")])\n@@ -3278,7 +3278,7 @@\n \n (define_insn \"*movdfcc_ext1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:DF \n+\t(if_then_else:DF\n \t (match_operator 3 \"signed_comparison_operator\"\n \t\t\t [(match_operand:DF 4 \"reg_or_fp0_operand\" \"fG,fG\")\n \t\t\t  (match_operand:DF 2 \"fp0_operand\" \"G,G\")])\n@@ -3292,9 +3292,9 @@\n \n (define_insn \"*movdfcc_ext2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:DF \n+\t(if_then_else:DF\n \t (match_operator 3 \"signed_comparison_operator\"\n-\t\t\t [(float_extend:DF \n+\t\t\t [(float_extend:DF\n \t\t\t   (match_operand:SF 4 \"reg_or_fp0_operand\" \"fG,fG\"))\n \t\t\t  (match_operand:DF 2 \"fp0_operand\" \"G,G\")])\n \t (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG,0\")\n@@ -3307,7 +3307,7 @@\n \n (define_insn \"*movdfcc_ext3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:SF \n+\t(if_then_else:SF\n \t (match_operator 3 \"signed_comparison_operator\"\n \t\t\t [(float_extend:DF\n \t\t\t   (match_operand:SF 4 \"reg_or_fp0_operand\" \"fG,fG\"))\n@@ -3322,7 +3322,7 @@\n \n (define_insn \"*movdfcc_ext4\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:DF \n+\t(if_then_else:DF\n \t (match_operator 3 \"signed_comparison_operator\"\n \t\t\t [(float_extend:DF\n \t\t\t   (match_operand:SF 4 \"reg_or_fp0_operand\" \"fG,fG\"))\n@@ -3766,7 +3766,7 @@\n        && ! (extended_count (operands[2], DImode, unsignedp) >= 1\n \t     && extended_count (operands[3], DImode, unsignedp) >= 1)))\n     FAIL;\n- \n+\n   if (GET_CODE (operands[3]) == CONST_INT)\n     tem = gen_rtx_PLUS (SImode, operands[2],\n \t\t\tGEN_INT (- INTVAL (operands[3])));\n@@ -3842,7 +3842,7 @@\n \t\t\tGEN_INT (- INTVAL (operands[3])));\n   else\n     tem = gen_rtx_MINUS (SImode, operands[2], operands[3]);\n-  \n+\n   operands[5] = gen_rtx_SIGN_EXTEND (DImode, tem);\n   operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n \t\t\t\toperands[4], const0_rtx);\n@@ -4082,9 +4082,9 @@\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n   \"\n-{ if (TARGET_WINDOWS_NT)\n+{ if (TARGET_ABI_WINDOWS_NT)\n     emit_call_insn (gen_call_nt (operands[0], operands[1]));\n-  else if (TARGET_OPEN_VMS)\n+  else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_vms (operands[0], operands[2]));\n   else\n     emit_call_insn (gen_call_osf (operands[0], operands[1]));\n@@ -4095,7 +4095,7 @@\n (define_expand \"sibcall\"\n   [(call (mem:DI (match_operand 0 \"\" \"\"))\n \t\t (match_operand 1 \"\" \"\"))]\n-  \"!TARGET_OPEN_VMS && !TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_OSF\"\n   \"\n {\n   if (GET_CODE (operands[0]) != MEM)\n@@ -4187,9 +4187,10 @@\n    (use (match_operand 4 \"\" \"\"))]\n   \"\"\n   \"\n-{ if (TARGET_WINDOWS_NT)\n+{\n+  if (TARGET_ABI_WINDOWS_NT)\n     emit_call_insn (gen_call_value_nt (operands[0], operands[1], operands[2]));\n-  else if (TARGET_OPEN_VMS)\n+  else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_value_vms (operands[0], operands[1],\n \t\t\t\t\toperands[3]));\n   else\n@@ -4202,7 +4203,7 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand 1 \"\" \"\"))\n \t      (match_operand 2 \"\" \"\")))]\n-  \"!TARGET_OPEN_VMS && !TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_OSF\"\n   \"\n {\n   if (GET_CODE (operands[1]) != MEM)\n@@ -4288,32 +4289,31 @@\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:DI 27))\n    (clobber (reg:DI 26))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS\n-   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  \"TARGET_ABI_OSF && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n   \"@\n    jsr $26,($27),0\n    bsr $26,$%0..ng\n    jsr $26,%0\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"*,*,8\")])\n-      \n+\n (define_insn \"*call_osf_1\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:DI 27))\n    (clobber (reg:DI 26))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OSF\"\n   \"@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,$%0..ng\n    jsr $26,%0\\;ldgp $29,0($26)\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"12,*,16\")])\n-      \n+\n (define_insn \"*sibcall_osf_1\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"R,i\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OSF\"\n   \"@\n    br $31,$%0..ng\n    jmp $31,%0\"\n@@ -4324,22 +4324,22 @@\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:DI 26))]\n-  \"TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_WINDOWS_NT\"\n   \"@\n    jsr $26,(%0)\n    bsr $26,%0\n    jsr $26,%0\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"*,*,12\")])\n-      \n+\n (define_insn \"*call_vms_1\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,i\"))\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand:DI 2 \"nonimmediate_operand\" \"r,m\"))\n    (use (reg:DI 25))\n    (use (reg:DI 26))\n    (clobber (reg:DI 27))]\n-  \"TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OPEN_VMS\"\n   \"@\n    mov %2,$27\\;jsr $26,0\\;ldq $27,0($29)\n    ldq $27,%2\\;jsr $26,%0\\;ldq $27,0($29)\"\n@@ -4414,9 +4414,9 @@\n   \"\"\n   \"\n {\n-  if (TARGET_WINDOWS_NT)\n+  if (TARGET_ABI_WINDOWS_NT)\n     emit_jump_insn (gen_tablejump_nt (operands[0], operands[1]));\n-  else if (TARGET_OPEN_VMS)\n+  else if (TARGET_ABI_OPEN_VMS)\n     emit_jump_insn (gen_tablejump_vms (operands[0], operands[1]));\n   else\n     emit_jump_insn (gen_tablejump_osf (operands[0], operands[1]));\n@@ -4465,7 +4465,7 @@\n \t(plus (match_operand:DI 0 \"register_operand\" \"r\")\n \t      (label_ref (match_operand 1 \"\" \"\"))))\n    (clobber (match_scratch:DI 2 \"=r\"))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && next_active_insn (insn) != 0\n+  \"TARGET_ABI_OSF && next_active_insn (insn) != 0\n    && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n    && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n   \"*\n@@ -4509,7 +4509,7 @@\n   [(set (pc)\n \t(match_operand:DI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_WINDOWS_NT && next_active_insn (insn) != 0\n+  \"TARGET_ABI_WINDOWS_NT && next_active_insn (insn) != 0\n    && GET_CODE (PATTERN (next_active_insn (insn))) == ADDR_DIFF_VEC\n    && PREV_INSN (next_active_insn (insn)) == operands[1]\"\n   \"*\n@@ -4557,7 +4557,7 @@\n   [(set (pc)\n \t(plus (match_operand:DI 0 \"register_operand\" \"r\")\n \t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OPEN_VMS\"\n   \"jmp $31,(%0),0\"\n   [(set_attr \"type\" \"ibr\")])\n \n@@ -4724,7 +4724,7 @@\n (define_insn \"*movsi_nofix\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*f,*f,m\")\n \t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,*fJ,m,*f\"))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && ! TARGET_FIX\n+  \"TARGET_ABI_OSF && ! TARGET_FIX\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n@@ -4741,7 +4741,7 @@\n (define_insn \"*movsi_fix\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*f,*f,m,r,*f\")\n \t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,*fJ,m,*f,*f,r\"))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && TARGET_FIX\n+  \"TARGET_ABI_OSF && TARGET_FIX\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n@@ -4760,7 +4760,7 @@\n (define_insn \"*movsi_nt_vms\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,m\")\n \t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,m,*f\"))]\n-  \"(TARGET_WINDOWS_NT || TARGET_OPEN_VMS)\n+  \"(TARGET_ABI_WINDOWS_NT || TARGET_ABI_OPEN_VMS)\n     && (register_operand (operands[0], SImode)\n         || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n@@ -4953,7 +4953,7 @@\n \t    }\n \t  else\n \t    abort();\n-\t  \n+\n           tem = alpha_emit_set_long_const (operands[0], i0, i1);\n           if (rtx_equal_p (tem, operands[0]))\n \t    DONE;\n@@ -5012,21 +5012,21 @@\n \t(zero_extract:DI (subreg:DI (match_dup 3) 0)\n \t\t\t (const_int 8)\n \t\t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n-\t \n+\n   \"\"\n   \"\")\n-  \n+\n (define_expand \"aligned_loadhi\"\n   [(set (match_operand:SI 3 \"register_operand\" \"\")\n \t(match_operand:SI 1 \"memory_operand\" \"\"))\n    (set (subreg:DI (match_operand:HI 0 \"register_operand\" \"\") 0)\n \t(zero_extract:DI (subreg:DI (match_dup 3) 0)\n \t\t\t (const_int 16)\n \t\t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n-\t \n+\n   \"\"\n   \"\")\n-  \n+\n ;; Similar for unaligned loads, where we use the sequence from the\n ;; Alpha Architecture manual.\n ;;\n@@ -5060,7 +5060,7 @@\n   \"\")\n \n ;; Storing an aligned byte or word requires two temporaries.  Operand 0 is the\n-;; aligned SImode MEM.  Operand 1 is the register containing the \n+;; aligned SImode MEM.  Operand 1 is the register containing the\n ;; byte or word to store.  Operand 2 is the number of bits within the word that\n ;; the value should be placed.  Operands 3 and 4 are SImode temporaries.\n \n@@ -5212,7 +5212,7 @@\n     }\n \n   else if (GET_CODE (operands[0]) == MEM\n-\t   || (GET_CODE (operands[0]) == SUBREG \n+\t   || (GET_CODE (operands[0]) == SUBREG\n \t       && GET_CODE (SUBREG_REG (operands[0])) == MEM)\n \t   || (reload_in_progress && GET_CODE (operands[0]) == REG\n \t       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n@@ -5330,7 +5330,7 @@\n     }\n \n   else if (GET_CODE (operands[0]) == MEM\n-\t   || (GET_CODE (operands[0]) == SUBREG \n+\t   || (GET_CODE (operands[0]) == SUBREG\n \t       && GET_CODE (SUBREG_REG (operands[0])) == MEM)\n \t   || (reload_in_progress && GET_CODE (operands[0]) == REG\n \t       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n@@ -5423,7 +5423,7 @@\n \n   if (aligned_memory_operand (operands[1], HImode))\n     {\n-      seq = gen_reload_inhi_help (operands[0], operands[1], \n+      seq = gen_reload_inhi_help (operands[0], operands[1],\n \t\t\t\t  gen_rtx_REG (SImode, REGNO (operands[2])));\n     }\n   else\n@@ -5567,7 +5567,7 @@\n \t\t\t\t operands[2]));\n   DONE;\n }\")\n-  \n+\n (define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n         (match_operand:HI 1 \"memory_operand\" \"\"))\n@@ -5582,7 +5582,7 @@\n \t\t\t\t operands[2]));\n   DONE;\n }\")\n-  \n+\n (define_split\n   [(set (match_operand:QI 0 \"memory_operand\" \"\")\n         (match_operand:QI 1 \"register_operand\" \"\"))\n@@ -5750,7 +5750,7 @@\n ;; bytes, we need do nothing.\n ;;\n ;; If it is more than 4096 bytes, we need to probe the stack\n-;; periodically. \n+;; periodically.\n (define_expand \"allocate_stack\"\n   [(set (reg:DI 30)\n \t(plus:DI (reg:DI 30)\n@@ -5901,7 +5901,7 @@\n \n (define_expand \"sibcall_epilogue\"\n   [(return)]\n-  \"!TARGET_OPEN_VMS && !TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_OSF\"\n   \"\n {\n   alpha_expand_epilogue ();\n@@ -5921,7 +5921,7 @@\n \n (define_expand \"builtin_longjmp\"\n   [(use (match_operand:DI 0 \"register_operand\" \"r\"))]\n-  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_OSF\"\n   \"\n {\n   /* The elements of the buffer are, in order:  */\n@@ -5957,21 +5957,21 @@\n \n (define_insn \"*builtin_setjmp_receiver_sub_label\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n-  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT && TARGET_AS_CAN_SUBTRACT_LABELS\"\n+  \"TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS\"\n   \"\\\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi\")])\n \n (define_insn \"builtin_setjmp_receiver\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n-  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_OSF\"\n   \"br $29,$LSJ%=\\\\n$LSJ%=:\\;ldgp $29,0($29)\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"multi\")])\n \n (define_expand \"exception_receiver\"\n   [(unspec_volatile [(match_dup 0)] UNSPECV_EHR)]\n-  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_OSF\"\n   \"\n {\n   if (TARGET_LD_BUGGY_LDGP)\n@@ -6005,7 +6005,7 @@\n    (set (reg:DI 27) (mem:DI (reg:DI 29)))\n    (unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)\n    (use (reg:DI 27))]\n-  \"TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_insn \"arg_home\"\n@@ -6028,7 +6028,7 @@\n    (clobber (reg:DI 24))\n    (clobber (reg:DI 25))\n    (clobber (reg:DI 0))]\n-  \"TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OPEN_VMS\"\n   \"lda $0,OTS$HOME_ARGS\\;ldq $0,8($0)\\;jsr $0,OTS$HOME_ARGS\"\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"multi\")])\n@@ -6077,7 +6077,7 @@\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:DI 27))\n    (clobber (reg:DI 26))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OSF\"\n   \"@\n    jsr $26,($27),0\\;ldgp $29,0($26)\n    bsr $26,$%1..ng\n@@ -6089,7 +6089,7 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"R,i\"))\n \t      (match_operand 2 \"\" \"\")))]\n-  \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OSF\"\n   \"@\n    br $31,$%1..ng\n    jmp $31,%1\"\n@@ -6101,7 +6101,7 @@\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r,R,i\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:DI 26))]\n-  \"TARGET_WINDOWS_NT\"\n+  \"TARGET_ABI_WINDOWS_NT\"\n   \"@\n    jsr $26,(%1)\n    bsr $26,%1\n@@ -6117,7 +6117,7 @@\n    (use (reg:DI 25))\n    (use (reg:DI 26))\n    (clobber (reg:DI 27))]\n-  \"TARGET_OPEN_VMS\"\n+  \"TARGET_ABI_OPEN_VMS\"\n   \"@\n    mov %3,$27\\;jsr $26,0\\;ldq $27,0($29)\n    ldq $27,%3\\;jsr $26,%1\\;ldq $27,0($29)\""}, {"sha": "8ef83330de179fa7003f6020d382e4e08404411e", "filename": "gcc/config/alpha/alpha32.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Falpha32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha32.h?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -30,8 +30,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#undef TARGET_WINDOWS_NT\n-#define TARGET_WINDOWS_NT 1\n+#undef TARGET_ABI_WINDOWS_NT\n+#define TARGET_ABI_WINDOWS_NT 1\n \n /* WinNT (and thus Interix) use unsigned int */\n #define SIZE_TYPE \"unsigned int\""}, {"sha": "3f8fa0702140a1f47fc60961bcda663a6f2667f3", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be7b80f42726389bd25888ede4f13d276bb12ef0/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=be7b80f42726389bd25888ede4f13d276bb12ef0", "patch": "@@ -18,8 +18,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#define OPEN_VMS 1\n-\n #define TARGET_OBJECT_SUFFIX \".obj\"\n #define TARGET_EXECUTABLE_SUFFIX \".exe\"\n \n@@ -69,8 +67,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_FP|MASK_FPREGS|MASK_GAS)\n-#undef TARGET_OPEN_VMS\n-#define TARGET_OPEN_VMS 1\n+#undef TARGET_ABI_OPEN_VMS\n+#define TARGET_ABI_OPEN_VMS 1\n \n #undef TARGET_NAME   \n #define TARGET_NAME \"OpenVMS/Alpha\""}]}