{"sha": "fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkNTQzYzhiOGJjOWM5YzJjYTk4ZjI4YjEzMTgyZGMyOGU2NWEyOA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-05-05T09:49:40Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-05-05T09:52:32Z"}, "message": "Add locations to implicit inference variables and partially revert 91c5b94\n\nWhen we have expression paths to generic functions we need to resolve all\ntype parameters to something otherwise we are left with orphaned inference\nvariables.\n\nThis adds the same checks from rustc back in, previously the\nPathInExpression resolver abused inference variables as it was implemented\nincorrectly since this is fixed in previous PRs we can bring this back in\nto make typing more strict again.\n\nFixes #375", "tree": {"sha": "920e61b1df2c0b39934d08c5338a9f27e283ca57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/920e61b1df2c0b39934d08c5338a9f27e283ca57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe"}], "stats": {"total": 76, "additions": 31, "deletions": 45}, "files": [{"sha": "d82e82b2ee56feb3e1c6898c4dcb55f76ca48bc2", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "patch": "@@ -696,6 +696,7 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::ArrayExpr &expr) override\n   {\n     HIR::ArrayElems *elements = expr.get_internal_elements ();\n+    root_array_expr_locus = expr.get_locus ();\n \n     elements->accept_vis (*this);\n     if (infered_array_elems == nullptr)\n@@ -717,7 +718,8 @@ class TypeCheckExpr : public TypeCheckBase\n       return true;\n     });\n \n-    infered_array_elems = TyTy::TyVar::get_implicit_infer_var ().get_tyty ();\n+    infered_array_elems\n+      = TyTy::TyVar::get_implicit_infer_var (root_array_expr_locus).get_tyty ();\n \n     for (auto &type : types)\n       {\n@@ -1152,6 +1154,7 @@ class TypeCheckExpr : public TypeCheckBase\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n   Bexpression *folded_array_capacity;\n+  Location root_array_expr_locus;\n \n   bool inside_loop;\n }; // namespace Resolver"}, {"sha": "c9500409afc8cfb9740d629c2d8a4002c86c573e", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "patch": "@@ -50,7 +50,6 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   if (saw_errors ())\n     return;\n \n-  auto resolver = Resolver::Resolver::get ();\n   auto mappings = Analysis::Mappings::get ();\n   auto context = TypeCheckContext::get ();\n \n@@ -70,7 +69,13 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n-    if (ok)\n+    if (!ok)\n+      {\n+\trust_error_at (mappings->lookup_location (id),\n+\t\t       \"type annotations needed\");\n+\treturn true;\n+      }\n+    else\n       {\n \tauto result = ty->unify (default_type);\n \tresult->set_ref (id);\n@@ -82,42 +87,6 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \n     return true;\n   });\n-\n-  // scan the ribs to ensure the decls are all setup correctly\n-  resolver->iterate_name_ribs ([&] (Rib *r) -> bool {\n-    r->iterate_decls ([&] (NodeId decl_node_id, Location locus) -> bool {\n-      Definition def;\n-      if (!resolver->lookup_definition (decl_node_id, &def))\n-\t{\n-\t  rust_error_at (locus, \"failed to lookup decl def\");\n-\t  return true;\n-\t}\n-\n-      HirId hir_node = UNKNOWN_HIRID;\n-      if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t def.parent, &hir_node))\n-\t{\n-\t  rust_error_at (locus, \"failed to lookup type hir node id\");\n-\t  return true;\n-\t}\n-\n-      // lookup the ty\n-      TyTy::BaseType *ty = nullptr;\n-      bool ok = context->lookup_type (hir_node, &ty);\n-      if (!ok)\n-\t{\n-\t  rust_error_at (locus, \"failed to lookup type for decl node_id: %u\",\n-\t\t\t decl_node_id);\n-\t  return true;\n-\t}\n-\n-      if (!ty->is_concrete ())\n-\trust_error_at (locus, \"unable to determine type\");\n-\n-      return true;\n-    });\n-    return true;\n-  });\n }\n \n // RUST_HIR_TYPE_CHECK_EXPR\n@@ -269,8 +238,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \n   // everything is ok, now we need to ensure all field values are ordered\n   // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n-  // assigned field in the constructor is in the same order as the field in the\n-  // type\n+  // assigned field in the constructor is in the same order as the field in\n+  // the type\n \n   std::vector<std::unique_ptr<HIR::StructExprField> > expr_fields\n     = struct_expr.get_fields_as_owner ();"}, {"sha": "dcf9203bc1632eb07c1dbd803b8479db67ce51a5", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "patch": "@@ -52,7 +52,7 @@ TyVar::get_tyty () const\n }\n \n TyVar\n-TyVar::get_implicit_infer_var ()\n+TyVar::get_implicit_infer_var (Location locus)\n {\n   auto mappings = Analysis::Mappings::get ();\n   auto context = Resolver::TypeCheckContext::get ();\n@@ -64,6 +64,8 @@ TyVar::get_implicit_infer_var ()\n \t\t\t\t\t       infer->get_ref (),\n \t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n \t\t\tinfer);\n+  mappings->insert_location (mappings->get_current_crate (), infer->get_ref (),\n+\t\t\t     locus);\n   return TyVar (infer->get_ref ());\n }\n "}, {"sha": "442b23b7beb364a8ec56915cee28f50b5e15e02b", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "patch": "@@ -171,7 +171,7 @@ class TyVar\n \n   BaseType *get_tyty () const;\n \n-  static TyVar get_implicit_infer_var ();\n+  static TyVar get_implicit_infer_var (Location locus);\n \n private:\n   HirId ref;\n@@ -695,7 +695,7 @@ class SubstitutionRef\n     std::vector<SubstitutionArg> args;\n     for (auto &sub : get_substs ())\n       {\n-\tTyVar infer_var = TyVar::get_implicit_infer_var ();\n+\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n \targs.push_back (SubstitutionArg (&sub, infer_var.get_tyty ()));\n       }\n "}, {"sha": "191f533ff8d0365f786265e4e66be9a8f8c0d44c", "filename": "gcc/testsuite/rust.test/xfail_compile/array_empty_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs?ref=fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "patch": "@@ -1,4 +1,4 @@\n-// { dg-error \"unable to determine type\" \"\" { target { *-*-* } } 0 }\n fn main() {\n     let arr = [];\n+    // { dg-error \"type annotations needed\" \"\" { target { *-*-* } } .-1 }\n }"}, {"sha": "fc46b2e5434db0041bffe1be766815354a696e34", "filename": "gcc/testsuite/rust.test/xfail_compile/generics11.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics11.rs?ref=fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<T>(T, bool);\n+\n+impl<T> Foo<T> {\n+    fn test() -> i32 {\n+        123\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo::test();\n+    // { dg-error \"type annotations needed\" \"\" { target { *-*-* } } .-1 }\n+}"}]}