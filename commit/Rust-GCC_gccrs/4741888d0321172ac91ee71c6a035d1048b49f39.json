{"sha": "4741888d0321172ac91ee71c6a035d1048b49f39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc0MTg4OGQwMzIxMTcyYWM5MWVlNzFjNmEwMzVkMTA0OGI0OWYzOQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-08T22:04:03Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-08T22:04:03Z"}, "message": "In gcc/objc/: 2010-11-08 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_add_synthesize_declaration_for_property):\n        Iterate over IMPL_PROPERTY_DECL, not CLASS_PROPERTY_DECL, when\n        checking for an existing @synthesize or @dynamic declaration.\n        Search for an inherited @property declaration if none is found in\n        the local interface.  If the required instance variable does not\n        exist, return instead of trying to continue to prevent a compiler\n        crash later.  Check that the instance variable is not already\n        being used by another @synthesize.\n        (objc_add_dynamic_declaration_for_property): Iterate over\n        IMPL_PROPERTY_DECL, not CLASS_PROPERTY_DECL, when checking for an\n        existing @synthesize or @dynamic declaration.\n        (objc_synthesize_getter): Search for the getter declaration in\n        protocols and superclasses as well.\n        (objc_synthesize_setter): Search for the setter declaration in\n        protocols and superclasses as well.\n\nIn gcc/testsuite/:\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/synthesize-3.m: New.\n        * objc.dg/property/synthesize-4.m: New.\n        * objc.dg/property/synthesize-5.m: New.\n        * objc.dg/property/synthesize-6.m: New.\n        * obj-c++.dg/property/synthesize-3.mm: New.\n        * obj-c++.dg/property/synthesize-4.mm: New.\n        * obj-c++.dg/property/synthesize-5.mm: New.\n        * obj-c++.dg/property/synthesize-6.mm: New.\n\nFrom-SVN: r166456", "tree": {"sha": "e521b56c661feaac63138566fed5a623b044b767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e521b56c661feaac63138566fed5a623b044b767"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4741888d0321172ac91ee71c6a035d1048b49f39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4741888d0321172ac91ee71c6a035d1048b49f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4741888d0321172ac91ee71c6a035d1048b49f39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4741888d0321172ac91ee71c6a035d1048b49f39/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87"}], "stats": {"total": 463, "additions": 438, "deletions": 25}, "files": [{"sha": "6ba9514af101d3cf6c9839d2ea16ed6aa19211b1", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -1,3 +1,21 @@\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_add_synthesize_declaration_for_property):\n+\tIterate over IMPL_PROPERTY_DECL, not CLASS_PROPERTY_DECL, when\n+\tchecking for an existing @synthesize or @dynamic declaration.\n+\tSearch for an inherited @property declaration if none is found in\n+\tthe local interface.  If the required instance variable does not\n+\texist, return instead of trying to continue to prevent a compiler\n+\tcrash later.  Check that the instance variable is not already\n+\tbeing used by another @synthesize.\n+\t(objc_add_dynamic_declaration_for_property): Iterate over\n+\tIMPL_PROPERTY_DECL, not CLASS_PROPERTY_DECL, when checking for an\n+\texisting @synthesize or @dynamic declaration.\n+\t(objc_synthesize_getter): Search for the getter declaration in\n+\tprotocols and superclasses as well.\n+\t(objc_synthesize_setter): Search for the setter declaration in\n+\tprotocols and superclasses as well.\n+\t\n 2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (lookup_property): When checking categories, also"}, {"sha": "ff694147ce29d46d53f492af3a99b631696d1c4c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -9363,7 +9363,7 @@ lookup_ivar (tree interface, tree instance_variable_name)\n /* This routine synthesizes a 'getter' method.  This is only called\n    for @synthesize properties.  */\n static void\n-objc_synthesize_getter (tree klass, tree class_method, tree property)\n+objc_synthesize_getter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree property)\n {\n   location_t location = DECL_SOURCE_LOCATION (property);\n   tree fn, decl;\n@@ -9375,9 +9375,9 @@ objc_synthesize_getter (tree klass, tree class_method, tree property)\n \t\t     PROPERTY_GETTER_NAME (property)))\n     return;\n \n-  /* Find declaration of the property getter in the interface. There\n-     must be one.  TODO: Search superclasses as well.  */\n-  decl = lookup_method (CLASS_NST_METHODS (class_method), PROPERTY_GETTER_NAME (property));\n+  /* Find declaration of the property getter in the interface (or\n+     superclass, or protocol). There must be one.  */\n+  decl = lookup_method_static (klass, PROPERTY_GETTER_NAME (property), 0);\n \n   /* If one not declared in the interface, this condition has already\n      been reported as user error (because property was not declared in\n@@ -9542,7 +9542,7 @@ objc_synthesize_getter (tree klass, tree class_method, tree property)\n /* This routine synthesizes a 'setter' method.  */\n \n static void\n-objc_synthesize_setter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree property)\n+objc_synthesize_setter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree property)\n {\n   location_t location = DECL_SOURCE_LOCATION (property);\n   tree fn, decl;\n@@ -9554,9 +9554,9 @@ objc_synthesize_setter (tree klass ATTRIBUTE_UNUSED, tree class_method, tree pro\n \t\t     PROPERTY_SETTER_NAME (property)))\n     return;\n \n-  /* Find declaration of the property setter in the interface. There\n-     must be one.  TODO: Search superclasses as well.  */\n-  decl = lookup_method (CLASS_NST_METHODS (class_method), PROPERTY_SETTER_NAME (property));\n+  /* Find declaration of the property setter in the interface (or\n+     superclass, or protocol). There must be one.  */\n+  decl = lookup_method_static (klass, PROPERTY_SETTER_NAME (property), 0);\n \n   /* If one not declared in the interface, this condition has already\n      been reported as user error (because property was not declared in\n@@ -9736,10 +9736,11 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n {\n   /* Find the @property declaration.  */\n   tree property;\n+  tree x;\n \n   /* Check that synthesize or dynamic has not already been used for\n      the same property.  */\n-  for (property = CLASS_PROPERTY_DECL (objc_implementation_context); property; property = TREE_CHAIN (property))\n+  for (property = IMPL_PROPERTY_DECL (objc_implementation_context); property; property = TREE_CHAIN (property))\n     if (PROPERTY_NAME (property) == property_name)\n       {\n \tlocation_t original_location = DECL_SOURCE_LOCATION (property);\n@@ -9756,12 +9757,9 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n \treturn;\n       }\n \n-  /* Check that the property is declared in the interface.  */\n-  /* TODO: This only check the immediate class; we need to check the\n-     superclass (and categories ?) as well.  */\n-  for (property = CLASS_PROPERTY_DECL (interface); property; property = TREE_CHAIN (property))\n-    if (PROPERTY_NAME (property) == property_name)\n-      break;\n+  /* Check that the property is declared in the interface.  It could\n+     also be declared in a superclass or protocol.  */\n+  property = lookup_property (interface, property_name);\n \n   if (!property)\n     {\n@@ -9783,18 +9781,37 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n   if (ivar_name == NULL_TREE)\n     ivar_name = property_name;\n \n-  /* Check that the instance variable exists.  You can only use an\n-     instance variable from the same class, not one from the\n-     superclass.  */\n+  /* Check that the instance variable exists.  You can only use a\n+     non-private instance variable from the same class, not one from\n+     the superclass (this makes sense as it allows us to check that an\n+     instance variable is only used in one synthesized property).  */\n   if (!is_ivar (CLASS_IVARS (interface), ivar_name))\n-    error_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\", \n-\t      IDENTIFIER_POINTER (property_name));\n+    {\n+      error_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\", \n+\t\tIDENTIFIER_POINTER (property_name));\n+      return;\n+    }\n \n   /* TODO: Check that the types of the instance variable and of the\n      property match.  */\n \n-  /* TODO: Check that no other property is using the same instance\n+  /* Check that no other property is using the same instance\n      variable.  */\n+  for (x = IMPL_PROPERTY_DECL (objc_implementation_context); x; x = TREE_CHAIN (x))\n+    if (PROPERTY_IVAR_NAME (x) == ivar_name)\n+      {\n+\tlocation_t original_location = DECL_SOURCE_LOCATION (x);\n+\t\n+\terror_at (location, \"property %qs is using the same instance variable as property %qs\",\n+\t\t  IDENTIFIER_POINTER (property_name),\n+\t\t  IDENTIFIER_POINTER (PROPERTY_NAME (x)));\n+\t\n+\tif (original_location != UNKNOWN_LOCATION)\n+\t  inform (original_location, \"originally specified here\");\n+\t\n+\t/* We keep going on.  This won't cause the compiler to fail;\n+\t   the failure would most likely be at runtime.  */\n+      }\n \n   /* Note that a @synthesize (and only a @synthesize) always sets\n      PROPERTY_IVAR_NAME to a non-NULL_TREE.  You can recognize a\n@@ -9876,7 +9893,7 @@ objc_add_dynamic_declaration_for_property (location_t location, tree interface,\n \n   /* Check that synthesize or dynamic has not already been used for\n      the same property.  */\n-  for (property = CLASS_PROPERTY_DECL (objc_implementation_context); property; property = TREE_CHAIN (property))\n+  for (property = IMPL_PROPERTY_DECL (objc_implementation_context); property; property = TREE_CHAIN (property))\n     if (PROPERTY_NAME (property) == property_name)\n       {\n \tlocation_t original_location = DECL_SOURCE_LOCATION (property);\n@@ -9912,9 +9929,10 @@ objc_add_dynamic_declaration_for_property (location_t location, tree interface,\n \t METHOD_PROPERTY_CONTEXT that points to the original\n \t PROPERTY_DECL; when we check that these methods have been\n \t implemented, we need to easily find that they are associated\n-\t with a dynamic property.  TODO: Clean this up; maybe the\n-\t @property PROPERTY_DECL should contain a reference to the\n-\t @dynamic PROPERTY_DECL ? */\n+\t with a dynamic property.  TODO: Remove this hack; it will not\n+\t work with properties in a protocol that may be implemented by\n+\t different classes and be @dynamic in some, and non-@dynamic\n+\t in other ones.  */\n       PROPERTY_DYNAMIC (property) = 1;\n \n       /* We have to copy the property, because we want to chain it to"}, {"sha": "d4d274a04d4c169db0e9f60b75f90916768a9b44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -1,3 +1,14 @@\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/synthesize-3.m: New.\n+\t* objc.dg/property/synthesize-4.m: New.\n+\t* objc.dg/property/synthesize-5.m: New.\n+\t* objc.dg/property/synthesize-6.m: New.\n+\t* obj-c++.dg/property/synthesize-3.mm: New.\n+\t* obj-c++.dg/property/synthesize-4.mm: New.\n+\t* obj-c++.dg/property/synthesize-5.mm: New.\n+\t* obj-c++.dg/property/synthesize-6.mm: New.\t\n+\t\n 2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/property/at-property-5.m: Updated test.\t"}, {"sha": "8669905316a119be7ed6dfce7b8e2f585cb335d3", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-3.mm", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-3.mm?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,66 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @synthesize for a @property which is not declared directly in\n+   the @interface, but in a @protocol that the @interface conforms\n+   to.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol MyProtocol\n+@property int v1;\n+@end\n+\n+@protocol MyProtocol2\n+@property int v2;\n+@end\n+\n+@interface Test : MyRootClass <MyProtocol, MyProtocol2>\n+{\n+  int v1;\n+  int _v2;\n+}\n+@end\n+\n+@implementation Test\n+@synthesize v1;\n+@synthesize v2 = _v2;\n+@end\n+\n+int main (void)\n+{\n+  Test *object = [[Test alloc] init];\n+\n+  /* Check that the synthesized methods exist and work.  Do not invoke\n+     them via property syntax - that is another test.  Here we just\n+     want to test the synthesis of the methods.  */\n+  [object setV1: 400];\n+\n+  if ([object v1] != 400)\n+    abort ();\n+\n+  [object setV2: 31];\n+\n+  if ([object v2] != 31)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "602dc68b468ead477af13afceb5a0674bf80ac22", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-4.mm", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-4.mm?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,67 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @synthesize for a @property where the setter/getter are also\n+   declared by the user.  This is fine.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol MyProtocol\n+@property int v1;\n+@end\n+\n+@protocol MyProtocol2\n+@property int v2;\n+@end\n+\n+@interface Test : MyRootClass <MyProtocol, MyProtocol2>\n+{\n+  int v1;\n+  int _v2;\n+}\n+- (int)v1;\n+- (void)setV1: (int)aNumber;\n+- (int)v2;\n+@end\n+\n+@implementation Test\n+@synthesize v1;\n+@synthesize v2 = _v2;\n+@end\n+\n+int main (void)\n+{\n+  Test *object = [[Test alloc] init];\n+\n+  /* We use dot-syntax here as this is just a general test that\n+     user-declared setters/getters don't cause confusion.  */\n+  object.v1 = 400;\n+\n+  if (object.v1 != 400)\n+    abort ();\n+\n+  object.v2 = 31;\n+\n+  if (object.v2 != 31)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "0871b63ee2195610dcf205b69d0b9662a00b11ed", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-5.mm", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-5.mm?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,18 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that @synthesize does not ICE if asked to use a non-existing\n+   ivar.  */\n+\n+#include <objc/objc.h>\n+\n+@interface Test\n+@property int v1;\n+@end\n+\n+@implementation Test\n+@synthesize v1;       /* { dg-error \"must be an existing ivar\" } */\n+@end\n+/* { dg-warning \"incomplete implementation\" \"\" { target *-*-* } 15 } */\n+/* { dg-warning \"method definition for .-setV1:. not found\" \"\" { target *-*-* } 15 } */\n+/* { dg-warning \"method definition for .-v1. not found\" \"\" { target *-*-* } 15 } */"}, {"sha": "2d0392794306d6dd2c87aa9f02c10544468f025c", "filename": "gcc/testsuite/obj-c++.dg/property/synthesize-6.mm", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-6.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-6.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fsynthesize-6.mm?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,32 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that each @synthesize is using a different instance variable,\n+   and that it must belong to the class (not to a superclass).  */\n+\n+#include <objc/objc.h>\n+\n+@interface Test\n+{\n+  int v;\n+  int w;\n+}\n+@property int v1;\n+@property int v2;\n+@end\n+#if 0 /* This is a problem in the testsuite; the compiler is fine, but the testsuite still barfs on the following.  */\n+@implementation Test\n+@synthesize v1 = v;  /* dg-message \"originally specified here\" */\n+@synthesize v2 = v;  /* dg-error \"property .v2. is using the same instance variable as property .v1.\" */\n+@end\n+#endif\n+@interface Test2 : Test\n+@property int w1;\n+@end\n+\n+@implementation Test2\n+@synthesize w1;      /* { dg-error \"ivar .w1. used by .@synthesize. declaration must be an existing ivar\" } */\n+@end\n+/* { dg-warning \"incomplete implementation\" \"\" { target *-*-* } 29 } */\n+/* { dg-warning \"method definition for .-setW1:. not found\" \"\" { target *-*-* } 29 } */\n+/* { dg-warning \"method definition for .-w1. not found\" \"\" { target *-*-* } 29 } */"}, {"sha": "8669905316a119be7ed6dfce7b8e2f585cb335d3", "filename": "gcc/testsuite/objc.dg/property/synthesize-3.m", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-3.m?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,66 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @synthesize for a @property which is not declared directly in\n+   the @interface, but in a @protocol that the @interface conforms\n+   to.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol MyProtocol\n+@property int v1;\n+@end\n+\n+@protocol MyProtocol2\n+@property int v2;\n+@end\n+\n+@interface Test : MyRootClass <MyProtocol, MyProtocol2>\n+{\n+  int v1;\n+  int _v2;\n+}\n+@end\n+\n+@implementation Test\n+@synthesize v1;\n+@synthesize v2 = _v2;\n+@end\n+\n+int main (void)\n+{\n+  Test *object = [[Test alloc] init];\n+\n+  /* Check that the synthesized methods exist and work.  Do not invoke\n+     them via property syntax - that is another test.  Here we just\n+     want to test the synthesis of the methods.  */\n+  [object setV1: 400];\n+\n+  if ([object v1] != 400)\n+    abort ();\n+\n+  [object setV2: 31];\n+\n+  if ([object v2] != 31)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "602dc68b468ead477af13afceb5a0674bf80ac22", "filename": "gcc/testsuite/objc.dg/property/synthesize-4.m", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-4.m?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,67 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test @synthesize for a @property where the setter/getter are also\n+   declared by the user.  This is fine.  */\n+\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol MyProtocol\n+@property int v1;\n+@end\n+\n+@protocol MyProtocol2\n+@property int v2;\n+@end\n+\n+@interface Test : MyRootClass <MyProtocol, MyProtocol2>\n+{\n+  int v1;\n+  int _v2;\n+}\n+- (int)v1;\n+- (void)setV1: (int)aNumber;\n+- (int)v2;\n+@end\n+\n+@implementation Test\n+@synthesize v1;\n+@synthesize v2 = _v2;\n+@end\n+\n+int main (void)\n+{\n+  Test *object = [[Test alloc] init];\n+\n+  /* We use dot-syntax here as this is just a general test that\n+     user-declared setters/getters don't cause confusion.  */\n+  object.v1 = 400;\n+\n+  if (object.v1 != 400)\n+    abort ();\n+\n+  object.v2 = 31;\n+\n+  if (object.v2 != 31)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "0871b63ee2195610dcf205b69d0b9662a00b11ed", "filename": "gcc/testsuite/objc.dg/property/synthesize-5.m", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-5.m?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,18 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that @synthesize does not ICE if asked to use a non-existing\n+   ivar.  */\n+\n+#include <objc/objc.h>\n+\n+@interface Test\n+@property int v1;\n+@end\n+\n+@implementation Test\n+@synthesize v1;       /* { dg-error \"must be an existing ivar\" } */\n+@end\n+/* { dg-warning \"incomplete implementation\" \"\" { target *-*-* } 15 } */\n+/* { dg-warning \"method definition for .-setV1:. not found\" \"\" { target *-*-* } 15 } */\n+/* { dg-warning \"method definition for .-v1. not found\" \"\" { target *-*-* } 15 } */"}, {"sha": "19f7c953491128dac011ba000cba0d0711e6abab", "filename": "gcc/testsuite/objc.dg/property/synthesize-6.m", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4741888d0321172ac91ee71c6a035d1048b49f39/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fsynthesize-6.m?ref=4741888d0321172ac91ee71c6a035d1048b49f39", "patch": "@@ -0,0 +1,32 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test that each @synthesize is using a different instance variable,\n+   and that it must belong to the class (not to a superclass).  */\n+\n+#include <objc/objc.h>\n+\n+@interface Test\n+{\n+  int v;\n+  int w;\n+}\n+@property int v1;\n+@property int v2;\n+@end\n+\n+@implementation Test\n+@synthesize v1 = v;  /* { dg-message \"originally specified here\" } */\n+@synthesize v2 = v;  /* { dg-error \"property .v2. is using the same instance variable as property .v1.\" } */\n+@end\n+\n+@interface Test2 : Test\n+@property int w1;\n+@end\n+\n+@implementation Test2\n+@synthesize w1;      /* { dg-error \"ivar .w1. used by .@synthesize. declaration must be an existing ivar\" } */\n+@end\n+/* { dg-warning \"incomplete implementation\" \"\" { target *-*-* } 29 } */\n+/* { dg-warning \"method definition for .-setW1:. not found\" \"\" { target *-*-* } 29 } */\n+/* { dg-warning \"method definition for .-w1. not found\" \"\" { target *-*-* } 29 } */"}]}