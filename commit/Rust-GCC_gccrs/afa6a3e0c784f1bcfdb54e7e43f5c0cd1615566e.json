{"sha": "afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZhNmEzZTBjNzg0ZjFiY2ZkYjU0ZTdlNDNmNWMwY2QxNjE1NTY2ZQ==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-11-17T18:36:40Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-11-17T18:36:40Z"}, "message": "a bit of a brain-dump from earlier this year\n\nFrom-SVN: r30557", "tree": {"sha": "b5610aa7258d38a5816f0627751f53c41d4c0bcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5610aa7258d38a5816f0627751f53c41d4c0bcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e/comments", "author": null, "committer": null, "parents": [{"sha": "fc99263b01f761cd27881520d93eb8b0a3bbab17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc99263b01f761cd27881520d93eb8b0a3bbab17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc99263b01f761cd27881520d93eb8b0a3bbab17"}], "stats": {"total": 83, "additions": 66, "deletions": 17}, "files": [{"sha": "8e019fa3229b239e46da49171a3de53af5142657", "filename": "gcc/f/ffe.texi", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e/gcc%2Ff%2Fffe.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e/gcc%2Ff%2Fffe.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fffe.texi?ref=afa6a3e0c784f1bcfdb54e7e43f5c0cd1615566e", "patch": "@@ -19,7 +19,7 @@ as of late May, 1999.\n To find about things that are ``To Be Determined'' or ``To Be Done'',\n search for the string TBD.\n If you want to help by working on one or more of these items,\n-email me at @email{@value{email-burley}}.\n+email @email{gcc@@gcc.gnu.org}.\n If you're planning to do more than just research issues and offer comments,\n see @uref{http://www.gnu.org/software/contribute.html} for steps you might\n need to take first.\n@@ -267,6 +267,12 @@ Lexing (@file{lex.c})\n @item\n Stand-alone statement identification (@file{sta.c})\n \n+@item\n+INCLUDE handling (@file{sti.c})\n+\n+@item\n+Order-dependent statement identification (@file{stq.c})\n+\n @item\n Parsing (@file{stb.c} and @file{expr.c})\n \n@@ -329,7 +335,18 @@ Since the second lexeme is @samp{(},\n the first must represent an array for this to be an assignment statement,\n else it's a statement function.\n \n-Either way, @file{sta.c} hands off the statement to @file{stb.c}\n+Either way, @file{sta.c} hands off the statement to @file{stq.c}\n+(via @file{sti.c}, which expands INCLUDE files).\n+@file{stq.c} figures out what a statement that is,\n+on its own, ambiguous, must actually be based on the context\n+established by previous statements.\n+\n+So, @file{stq.c} watches the statement stream for executable statements,\n+END statements, and so on, so it knows whether @samp{A(B)=C} is\n+(intended as) a statement-function definition or an assignment statement.\n+\n+After establishing the context-aware statement info, @file{stq.c}\n+passes the original sample statement on to @file{stb.c}\n (either its statement-function parser or its assignment-statement parser).\n \n @file{stb.c} forms a\n@@ -379,6 +396,8 @@ decimal numbering is used, and so on.\n * g77stripcard::\n * lex.c::\n * sta.c::\n+* sti.c::\n+* stq.c::\n * stb.c::\n * expr.c::\n * stc.c::\n@@ -527,6 +546,8 @@ as necessary to reach column @var{n},\n where dividing @samp{(@var{n} - 1)} by eight\n results in a remainder of zero.\n \n+That saves having to pass most source files through @code{expand}.\n+\n @item\n Linefeeds (ASCII code 10)\n mark the ends of lines.\n@@ -631,16 +652,25 @@ to the appropriate @code{CHARACTER} constants.\n Then @code{g77} wouldn't have to define a prefix syntax for Hollerith\n constants specifying whether they want C-style or straight-through\n backslashes.\n+\n+@item\n+To allow for form-neutral INCLUDE files without requiring them\n+to be preprocessed,\n+the fixed-form lexer should offer an extension (if possible)\n+allowing a trailing @samp{&} to be ignored, especially if after\n+column 72, as it would be using the traditional Unix Fortran source\n+model (which ignores @emph{everything} after column 72).\n @end itemize\n \n The above implements nearly exactly what is specified by\n @ref{Character Set},\n and\n @ref{Lines},\n except it also provides automatic conversion of tabs\n-and ignoring of newline-related carriage returns.\n+and ignoring of newline-related carriage returns,\n+as well as accommodating form-neutral INCLUDE files.\n \n-It also affects the ``pure visual'' model,\n+It also implements the ``pure visual'' model,\n by which is meant that a user viewing his code\n in a typical text editor\n (assuming it's not preprocessed via @code{g77stripcard} or similar)\n@@ -672,10 +702,10 @@ the GNU Fortran ``pure visual'' model meets these requirements.\n Any language or user-visible source form\n requiring special tagging of tabs,\n the ends of lines after spaces/tabs,\n-and so on, is broken by this definition.\n-Fortunately, Fortran @emph{itself} is not broken,\n-even if most vendor-supplied defaults for their Fortran compilers @emph{are}\n-in this regard.)\n+and so on, fails to meet this fairly straightforward specification.\n+Fortunately, Fortran @emph{itself} does not mandate such a failure,\n+though most vendor-supplied defaults for their Fortran compilers @emph{do}\n+fail to meet this specification for readability.)\n \n Further, this model provides a clean interface\n to whatever preprocessors or code-generators are used\n@@ -685,6 +715,12 @@ Mainly, they need not worry about long lines.\n @node sta.c\n @subsection sta.c\n \n+@node sti.c\n+@subsection sti.c\n+\n+@node stq.c\n+@subsection stq.c\n+\n @node stb.c\n @subsection stb.c\n \n@@ -987,14 +1023,6 @@ and implementing it.\n Specific issues to resolve:\n \n @itemize @bullet\n-@item\n-Just where should @code{INCLUDE} processing take place?\n-\n-Clearly before (or part of) statement identification (@file{sta.c}),\n-since determining whether @samp{I(J)=K} is a statement-function\n-definition or an assignment statement requires knowing the context,\n-which in turn requires having processed @code{INCLUDE} files.\n-\n @item\n Just where should (if it was implemented) @code{USE} processing take place?\n \n@@ -1050,6 +1078,9 @@ and @samp{-fcase-initcap} options?\n I've asked @email{info-gnu-fortran@@gnu.org} for input on this.\n Not having to support these makes it easier to write the new front end,\n and might also avoid complicated its design.\n+\n+The consensus to date (1999-11-17) has been to drop this support.\n+Can't recall anybody saying they're using it, in fact.\n @end itemize\n \n @node Philosophy of Code Generation\n@@ -1203,6 +1234,21 @@ were worked out.\n The FFE was changed back to default to using that native facility,\n leaving emulation as an option.\n \n+Later during the release cycle\n+(which was called EGCS 1.2, but soon became GCC 2.95),\n+bugs in the native facility were found.\n+Reactions among various people included\n+``the last thing we should do is change the default back'',\n+``we must change the default back'',\n+and ``let's figure out whether we can narrow down the bugs to\n+few enough cases to allow the now-months-long-tested default\n+to remain the same''.\n+The latter viewpoint won that particular time.\n+The bugs exposed other concerns regarding ABI compliance\n+when the ABI specified treatment of complex data as different\n+from treatment of what Fortran and GNU C consider the equivalent\n+aggregation (structure) of real (or float) pairs.\n+\n Other Fortran constructs---arrays, character strings,\n complex division, @code{COMMON} and @code{EQUIVALENCE} aggregates,\n and so on---involve issues similar to those pertaining to complex arithmetic.\n@@ -1460,7 +1506,10 @@ be supported.\n Both this mythical, and today's real, GBE caters to its GBEL\n by, sometimes, scrambling around, cleaning up after itself---after\n discovering that assumptions it made earlier during code generation\n-are incorrect.)\n+are incorrect.\n+That's not a great design, since it indicates significant code\n+paths that might be rarely tested but used in some key production\n+environments.)\n \n So, the FFE handles these discrepancies---between the order in which\n it discovers facts about the code it is compiling,"}]}