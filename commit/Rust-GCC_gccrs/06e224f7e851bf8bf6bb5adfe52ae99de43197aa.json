{"sha": "06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlMjI0ZjdlODUxYmY4YmY2YmI1YWRmZTUyYWU5OWRlNDMxOTdhYQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-02-26T19:05:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-02-26T19:05:26Z"}, "message": "dwarf2out.c (gen_inlined_subroutine_die): If block is abstract, generate a die for the lexical block.\n\n* dwarf2out.c (gen_inlined_subroutine_die): If block is abstract,\ngenerate a die for the lexical block.\n\nFrom-SVN: r50056", "tree": {"sha": "1b047e09d20c790b04c70b61dd892a3fc628d0c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b047e09d20c790b04c70b61dd892a3fc628d0c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/comments", "author": null, "committer": null, "parents": [{"sha": "40367e2d81cd7c78a253eb9264ea63cc8376ec48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40367e2d81cd7c78a253eb9264ea63cc8376ec48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40367e2d81cd7c78a253eb9264ea63cc8376ec48"}], "stats": {"total": 83, "additions": 83, "deletions": 0}, "files": [{"sha": "2918066933cbd054e934586461ff3f048a986708", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "patch": "@@ -1,3 +1,8 @@\n+2002-02-26  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* dwarf2out.c (gen_inlined_subroutine_die): If block is abstract,\n+\tgenerate a die for the lexical block.\n+\n 2002-02-26  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300-protos.h: Add a prototype for"}, {"sha": "f4c298a124a2728207640bc6e9a6c6f5a3a312b8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "patch": "@@ -10579,6 +10579,20 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n       decls_for_scope (stmt, subr_die, depth);\n       current_function_has_inlines = 1;\n     }\n+  else\n+    /* We may get here if we're the outer block of function A that was\n+       inlined into function B that was inlined into function C.  When\n+       generating debugging info for C, dwarf2out_abstract_function(B)\n+       would mark all inlined blocks as abstract, including this one.\n+       So, we wouldn't (and shouldn't) expect labels to be generated\n+       for this one.  Instead, just emit debugging info for\n+       declarations within the block.  This is particularly important\n+       in the case of initializers of arguments passed from B to us:\n+       if they're statement expressions containing declarations, we\n+       wouldn't generate dies for their abstract variables, and then,\n+       when generating dies for the real variables, we'd die (pun\n+       intended :-)  */\n+    gen_lexical_block_die (stmt, context_die, depth);\n }\n \n /* Generate a DIE for a field in a record, or structure.  */"}, {"sha": "8505241abef03bc98122b9d28302201cb86f9a53", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "patch": "@@ -1,3 +1,7 @@\n+2002-02-26  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* gcc.dg/debug/20020224-1.c: New.\n+\n 2002-02-25  Kazu Hirata  <kazu@hxi.com>\n \n \t* gcc.c-torture/execute/960416-1.x: New."}, {"sha": "c61a17aed10db65c132c5a04cdde4f7b1271888b", "filename": "gcc/testsuite/gcc.dg/debug/20020224-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20020224-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e224f7e851bf8bf6bb5adfe52ae99de43197aa/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20020224-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2F20020224-1.c?ref=06e224f7e851bf8bf6bb5adfe52ae99de43197aa", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+\n+/* Here's the deal: f3 is not inlined because it's too big, but f2 and\n+   f1 are inlined into it.  We used to fail to emit debugging info for\n+   t1, because it was moved inside the (inlined) block of f1, marked\n+   as abstract, then we'd crash.  */\n+\n+#define UNUSED __attribute__((unused))\n+#define EXT __extension__\n+\n+int undef(void);\n+\n+inline static void\n+f1 (int i UNUSED)\n+{\n+}\n+\n+inline static void\n+f2 (void)\n+{\n+  f1 (EXT ({ int t1 UNUSED; undef (); }));\n+}\n+\n+inline static void\n+f3 (void)\n+{\n+  int v1 UNUSED;\n+  int v2 UNUSED;\n+\n+  EXT ({ int t2 UNUSED; if (0) undef (); 0; })\n+    && EXT ({ int t3 UNUSED; if (0) undef (); 0; });\n+\n+  if (1)\n+    {\n+      undef ();\n+      if (1)\n+        f2 ();\n+    }\n+\n+  {\n+    undef ();\n+  }\n+}\n+\n+inline static void\n+f4 (void)\n+{\n+  EXT ({ undef (); 1; }) && EXT ({ int t4 UNUSED = ({ 1; }); 1; });\n+\n+  { }\n+\n+  EXT ({ int t5 UNUSED; if (0) undef (); 0; });\n+\n+  f4 ();\n+\n+  undef ();\n+  f3 ();\n+\n+  return;\n+}"}]}