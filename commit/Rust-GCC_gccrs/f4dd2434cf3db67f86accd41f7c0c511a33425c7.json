{"sha": "f4dd2434cf3db67f86accd41f7c0c511a33425c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRkZDI0MzRjZjNkYjY3Zjg2YWNjZDQxZjdjMGM1MTFhMzM0MjVjNw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-26T14:08:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-26T14:08:28Z"}, "message": "Merge #592\n\n592: TypeCastExpr r=philberty a=philberty\n\nThis is the initial type casting rules more test cases will be added over time. To find gaps.\r\n\r\nFixes #158\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "44fd8555d42abd6b04b3cd9f653c28d6a25d9e44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44fd8555d42abd6b04b3cd9f653c28d6a25d9e44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4dd2434cf3db67f86accd41f7c0c511a33425c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg/sHcCRBK7hj4Ov3rIwAAabsIAHtQWFBn+ZnDUpBP44vBC6Au\n+eLfsRMJ0HbUpc1rXER7VQVnPUv+dODEWtZER/inmQCy0XVvA8pFyg5C0viDSOaz\nAVixOcOGWNTu5eswbK+WbtLJJIVjvV5v2HTSgmxnmMHAxxOs3itDVfipDlY1snS1\nezvARyh0pTrGvpAD+DplskumZoGyDLJTxJQOLkoraeGu9H/3L/BP4MQbOoUhHDc0\nAD4AFnQy04hsnp/6/rhgJCcHXG0Xv8kbXr89V6qbqjPrcYhzf5WuVGh23CgbqwWd\nsfnFyzlHAI2mIPYr9n0lYn9C81p5Ah+avoPZlf7mAwqvL1kJEHW6AiCs1enssaU=\n=excG\n-----END PGP SIGNATURE-----\n", "payload": "tree 44fd8555d42abd6b04b3cd9f653c28d6a25d9e44\nparent a4e3ffd3768b4a985aa7a137c9a553a4588acaba\nparent 5313e4fbe7cd5cead248e6b61c558d9edbe91236\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627308508 +0000\ncommitter GitHub <noreply@github.com> 1627308508 +0000\n\nMerge #592\n\n592: TypeCastExpr r=philberty a=philberty\n\nThis is the initial type casting rules more test cases will be added over time. To find gaps.\r\n\r\nFixes #158\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4dd2434cf3db67f86accd41f7c0c511a33425c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4dd2434cf3db67f86accd41f7c0c511a33425c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4dd2434cf3db67f86accd41f7c0c511a33425c7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4e3ffd3768b4a985aa7a137c9a553a4588acaba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4e3ffd3768b4a985aa7a137c9a553a4588acaba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4e3ffd3768b4a985aa7a137c9a553a4588acaba"}, {"sha": "5313e4fbe7cd5cead248e6b61c558d9edbe91236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5313e4fbe7cd5cead248e6b61c558d9edbe91236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5313e4fbe7cd5cead248e6b61c558d9edbe91236"}], "stats": {"total": 1524, "additions": 1520, "deletions": 4}, "files": [{"sha": "2a147abcf096a0c4c0012e43808464ceb00b50c3", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -417,6 +417,24 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n   }\n \n+  void visit (HIR::TypeCastExpr &expr) override\n+  {\n+    TyTy::BaseType *tyty_to_cast_to = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &tyty_to_cast_to))\n+      {\n+\ttranslated = ctx->get_backend ()->error_expression ();\n+\treturn;\n+      }\n+\n+    auto type_to_cast_to = TyTyResolveCompile::compile (ctx, tyty_to_cast_to);\n+    auto casted_expr\n+      = CompileExpr::Compile (expr.get_casted_expr ().get (), ctx);\n+    translated\n+      = ctx->get_backend ()->convert_expression (type_to_cast_to, casted_expr,\n+\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n   void visit (HIR::IfExpr &expr) override\n   {\n     auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);"}, {"sha": "742cb1d317086c0b50a1f00fa8107e5103d0c75f", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -295,6 +295,8 @@ class ASTLoweringBase : public AST::ASTVisitor\n   HIR::GenericArgsBinding lower_binding (AST::GenericArgsBinding &binding);\n \n   HIR::SelfParam lower_self (AST::SelfParam &self);\n+\n+  HIR::Type *lower_type_no_bounds (AST::TypeNoBounds *type);\n };\n \n } // namespace HIR"}, {"sha": "1c486513a5803cf2897b50daa17ff3a1cdb28daa", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -410,6 +410,25 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t       expr.get_locus ());\n   }\n \n+  void visit (AST::TypeCastExpr &expr) override\n+  {\n+    HIR::Expr *expr_to_cast_to\n+      = ASTLoweringExpr::translate (expr.get_casted_expr ().get ());\n+    HIR::Type *type_to_cast_to\n+      = lower_type_no_bounds (expr.get_type_to_cast_to ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TypeCastExpr (mapping,\n+\t\t\t       std::unique_ptr<HIR::Expr> (expr_to_cast_to),\n+\t\t\t       std::unique_ptr<HIR::Type> (type_to_cast_to),\n+\t\t\t       expr.get_locus ());\n+  }\n+\n   /* Compound assignment expression is compiled away. */\n   void visit (AST::CompoundAssignmentExpr &expr) override\n   {"}, {"sha": "04587ed66863bf023d277ecf52147c53771a843b", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -21,6 +21,7 @@\n #include \"rust-ast-lower-implitem.h\"\n #include \"rust-ast-lower-expr.h\"\n #include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-type.h\"\n \n namespace Rust {\n namespace HIR {\n@@ -394,5 +395,13 @@ ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n     segment.get_locus ());\n }\n \n+// rust-ast-lower-base\n+\n+HIR::Type *\n+ASTLoweringBase::lower_type_no_bounds (AST::TypeNoBounds *type)\n+{\n+  return ASTLoweringType::translate (type);\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "65c40d60bdfe52bda2605ed54d7051cc94a79250", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -538,7 +538,7 @@ class LazyBooleanExpr : public OperatorExpr\n // Binary infix \"as\" chir expression.\n class TypeCastExpr : public OperatorExpr\n {\n-  std::unique_ptr<TypeNoBounds> type_to_convert_to;\n+  std::unique_ptr<Type> type_to_convert_to;\n \n   // Note: only certain type casts allowed, outlined in reference\n public:\n@@ -547,7 +547,7 @@ class TypeCastExpr : public OperatorExpr\n   // Constructor requires calling protected constructor of OperatorExpr\n   TypeCastExpr (Analysis::NodeMapping mappings,\n \t\tstd::unique_ptr<Expr> expr_to_cast,\n-\t\tstd::unique_ptr<TypeNoBounds> type_to_cast_to, Location locus)\n+\t\tstd::unique_ptr<Type> type_to_cast_to, Location locus)\n     : OperatorExpr (std::move (mappings), std::move (expr_to_cast),\n \t\t    AST::AttrVec (), locus),\n       type_to_convert_to (std::move (type_to_cast_to))\n@@ -557,15 +557,15 @@ class TypeCastExpr : public OperatorExpr\n   // Copy constructor also requires calling protected constructor\n   TypeCastExpr (TypeCastExpr const &other)\n     : OperatorExpr (other),\n-      type_to_convert_to (other.type_to_convert_to->clone_type_no_bounds ())\n+      type_to_convert_to (other.type_to_convert_to->clone_type ())\n   {}\n \n   // Overload assignment operator to deep copy\n   TypeCastExpr &operator= (TypeCastExpr const &other)\n   {\n     OperatorExpr::operator= (other);\n     // main_or_left_expr = other.main_or_left_expr->clone_expr();\n-    type_to_convert_to = other.type_to_convert_to->clone_type_no_bounds ();\n+    type_to_convert_to = other.type_to_convert_to->clone_type ();\n \n     return *this;\n   }\n@@ -576,6 +576,18 @@ class TypeCastExpr : public OperatorExpr\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_casted_expr ()\n+  {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  std::unique_ptr<Type> &get_type_to_convert_to ()\n+  {\n+    rust_assert (type_to_convert_to != nullptr);\n+    return type_to_convert_to;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "e7e37d4ec3dfb7c0d545eba6c4106329463200a8", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -174,6 +174,12 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_negated_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::TypeCastExpr &expr) override\n+  {\n+    ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_casted_expr ().get (), expr.get_node_id ());\n+  }\n+\n   void visit (AST::IfExpr &expr) override\n   {\n     ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());"}, {"sha": "bd42b4cc783f0259d80fae89d8f13911ec924e22", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -1147,6 +1147,16 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n   }\n \n+  void visit (HIR::TypeCastExpr &expr) override\n+  {\n+    TyTy::BaseType *expr_to_convert\n+      = TypeCheckExpr::Resolve (expr.get_casted_expr ().get (), false);\n+    TyTy::BaseType *tyty_to_convert_to\n+      = TypeCheckType::Resolve (expr.get_type_to_convert_to ().get ());\n+\n+    infered = expr_to_convert->cast (tyty_to_convert_to);\n+  }\n+\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),"}, {"sha": "de59b327e7659c719ab8d8478ec8fe0f71c8e4bd", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "added", "additions": 1256, "deletions": 0, "changes": 1256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -0,0 +1,1256 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CAST_RULES\n+#define RUST_TYTY_CAST_RULES\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+extern ::Backend *\n+rust_get_backend ();\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseCastRules : public TyVisitor\n+{\n+public:\n+  virtual ~BaseCastRules () {}\n+\n+  virtual BaseType *cast (BaseType *other)\n+  {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tParamType *p = static_cast<ParamType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+\n+    other->accept_vis (*this);\n+    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+      return resolved;\n+\n+    resolved->append_reference (get_base ()->get_ref ());\n+    resolved->append_reference (other->get_ref ());\n+    for (auto ref : get_base ()->get_combined_refs ())\n+      resolved->append_reference (ref);\n+    for (auto ref : other->get_combined_refs ())\n+      resolved->append_reference (ref);\n+\n+    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n+    bool results_is_non_general_infer_var\n+      = (result_is_infer_var\n+\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n+\t      != TyTy::InferType::GENERAL);\n+    if (result_resolved || results_is_non_general_infer_var)\n+      {\n+\tfor (auto &ref : resolved->get_combined_refs ())\n+\t  {\n+\t    TyTy::BaseType *ref_tyty = nullptr;\n+\t    bool ok = context->lookup_type (ref, &ref_tyty);\n+\t    if (!ok)\n+\t      continue;\n+\n+\t    // if any of the types are inference variables lets fix them\n+\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t      {\n+\t\tcontext->insert_type (\n+\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t UNKNOWN_NODEID, ref,\n+\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n+\t\t  resolved->clone ());\n+\t      }\n+\t  }\n+      }\n+    return resolved;\n+  }\n+\n+  virtual void visit (TupleType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ADTType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (InferType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnPtr &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ArrayType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (BoolType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (IntType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (UintType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (USizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ISizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FloatType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ErrorType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (CharType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ReferenceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (PointerType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ParamType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (StrType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (NeverType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (PlaceholderType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"invalid cast [%s] to [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+protected:\n+  BaseCastRules (BaseType *base)\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()),\n+      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n+  /* Temporary storage for the result of a unification.\n+     We could return the result directly instead of storing it in the rule\n+     object, but that involves modifying the visitor pattern to accommodate\n+     the return value, which is too complex. */\n+  BaseType *resolved;\n+\n+private:\n+  /* Returns a pointer to the ty that created this rule. */\n+  virtual BaseType *get_base () = 0;\n+};\n+\n+class InferCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  InferCastRules (InferType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = type.clone ();\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (CharType &type) override\n+  {\n+    {\n+      bool is_valid\n+\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+      if (is_valid)\n+\t{\n+\t  resolved = type.clone ();\n+\t  return;\n+\t}\n+\n+      BaseCastRules::visit (type);\n+    }\n+  }\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (PointerType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCastRules::visit (type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  InferType *base;\n+};\n+\n+class FnCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  FnCastRules (FnType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto unified_param = a->unify (b);\n+\tif (unified_param == nullptr)\n+\t  {\n+\t    BaseCastRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    auto unified_return\n+      = base->get_return_type ()->unify (type.get_return_type ());\n+    if (unified_return == nullptr)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnType *base;\n+};\n+\n+class FnptrCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  FnptrCastRules (FnPtr *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnPtr &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCastRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCastRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnPtr *base;\n+};\n+\n+class ArrayCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  ArrayCastRules (ArrayType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (ArrayType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    auto backend = rust_get_backend ();\n+\n+    // need to check the base types and capacity\n+    if (!backend->const_values_equal (type.get_capacity (),\n+\t\t\t\t      base->get_capacity ()))\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t       type.get_capacity (), TyVar (base_resolved->get_ref ()));\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ArrayType *base;\n+};\n+\n+class BoolCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  BoolCastRules (BoolType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (type.get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = base->clone ();\n+\tbreak;\n+\n+      default:\n+\tBaseCastRules::visit (type);\n+\tbreak;\n+      }\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  BoolType *base;\n+};\n+\n+class IntCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  IntCastRules (IntType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override { resolved = type.clone (); }\n+\n+  void visit (UintType &type) override { resolved = type.clone (); }\n+\n+  void visit (FloatType &type) override { resolved = type.clone (); }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  IntType *base;\n+};\n+\n+class UintCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  UintCastRules (UintType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override { resolved = type.clone (); }\n+\n+  void visit (UintType &type) override { resolved = type.clone (); }\n+\n+  void visit (FloatType &type) override { resolved = type.clone (); }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+  void visit (CharType &type) override\n+  {\n+    // error[E0604]: only `u8` can be cast as `char`, not `i32`\n+    if (base->get_uint_kind () != UintType::UintKind::U8)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  UintType *base;\n+};\n+\n+class FloatCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  FloatCastRules (FloatType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override { resolved = type.clone (); }\n+\n+  void visit (UintType &type) override { resolved = type.clone (); }\n+\n+  void visit (FloatType &type) override { resolved = type.clone (); }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FloatType *base;\n+};\n+\n+class ADTCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  ADTCastRules (ADTType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (ADTType &type) override\n+  {\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < type.num_fields (); ++i)\n+      {\n+\tTyTy::StructFieldType *base_field = base->get_field (i);\n+\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\n+\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ADTType *base;\n+};\n+\n+class TupleCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  TupleCastRules (TupleType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (TupleType &type) override\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    std::vector<TyVar> fields;\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tBaseType *bo = base->get_field (i);\n+\tBaseType *fo = type.get_field (i);\n+\n+\tBaseType *unified_ty = bo->unify (fo);\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+\n+\tfields.push_back (TyVar (unified_ty->get_ref ()));\n+      }\n+\n+    resolved\n+      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  TupleType *base;\n+};\n+\n+class USizeCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  USizeCastRules (USizeType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override { resolved = type.clone (); }\n+\n+  void visit (UintType &type) override { resolved = type.clone (); }\n+\n+  void visit (FloatType &type) override { resolved = type.clone (); }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  USizeType *base;\n+};\n+\n+class ISizeCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  ISizeCastRules (ISizeType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override { resolved = type.clone (); }\n+\n+  void visit (UintType &type) override { resolved = type.clone (); }\n+\n+  void visit (FloatType &type) override { resolved = type.clone (); }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ISizeType *base;\n+};\n+\n+class CharCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  CharCastRules (CharType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (CharType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  CharType *base;\n+};\n+\n+class ReferenceCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  ReferenceCastRules (ReferenceType *base) : BaseCastRules (base), base (base)\n+  {}\n+\n+  void visit (ReferenceType &type) override { resolved = type.clone (); }\n+\n+  void visit (PointerType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n+    if (base_resolved == nullptr\n+\t|| base_resolved->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ReferenceType *base;\n+};\n+\n+class PointerCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  PointerCastRules (PointerType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n+    if (base_resolved == nullptr\n+\t|| base_resolved->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (PointerType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PointerType *base;\n+};\n+\n+class ParamCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  ParamCastRules (ParamType *base) : BaseCastRules (base), base (base) {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  BaseType *cast (BaseType *other) override final\n+  {\n+    if (base->get_ref () == base->get_ty_ref ())\n+      return BaseCastRules::cast (other);\n+\n+    auto context = Resolver::TypeCheckContext::get ();\n+    BaseType *lookup = nullptr;\n+    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n+    rust_assert (ok);\n+\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ParamType *base;\n+};\n+\n+class StrCastRules : public BaseCastRules\n+{\n+  // FIXME we will need a enum for the StrType like ByteBuf etc..\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  StrCastRules (StrType *base) : BaseCastRules (base), base (base) {}\n+\n+  void visit (StrType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  StrType *base;\n+};\n+\n+class NeverCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  NeverCastRules (NeverType *base) : BaseCastRules (base), base (base) {}\n+\n+  virtual void visit (NeverType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  NeverType *base;\n+};\n+\n+class PlaceholderCastRules : public BaseCastRules\n+{\n+  using Rust::TyTy::BaseCastRules::visit;\n+\n+public:\n+  PlaceholderCastRules (PlaceholderType *base)\n+    : BaseCastRules (base), base (base)\n+  {}\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PlaceholderType *base;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CAST_RULES"}, {"sha": "bb5d6c0bb154268bf4d22ba303cb9d1e28df0b8a", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty-rules.h\"\n #include \"rust-tyty-cmp.h\"\n #include \"rust-tyty-coercion.h\"\n+#include \"rust-tyty-cast.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n \n@@ -118,6 +119,13 @@ InferType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+InferType::cast (BaseType *other)\n+{\n+  InferCastRules r (this);\n+  return r.cast (other);\n+}\n+\n BaseType *\n InferType::clone ()\n {\n@@ -186,6 +194,12 @@ ErrorType::coerce (BaseType *other)\n   return this;\n }\n \n+BaseType *\n+ErrorType::cast (BaseType *other)\n+{\n+  return this;\n+}\n+\n BaseType *\n ErrorType::clone ()\n {\n@@ -459,6 +473,13 @@ ADTType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+ADTType::cast (BaseType *other)\n+{\n+  ADTCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n ADTType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -633,6 +654,13 @@ TupleType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+TupleType::cast (BaseType *other)\n+{\n+  TupleCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n TupleType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -730,6 +758,13 @@ FnType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+FnType::cast (BaseType *other)\n+{\n+  FnCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n FnType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -938,6 +973,13 @@ FnPtr::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+FnPtr::cast (BaseType *other)\n+{\n+  FnptrCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1018,6 +1060,13 @@ ArrayType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+ArrayType::cast (BaseType *other)\n+{\n+  ArrayCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1086,6 +1135,13 @@ BoolType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+BoolType::cast (BaseType *other)\n+{\n+  BoolCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n BoolType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1145,6 +1201,13 @@ IntType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+IntType::cast (BaseType *other)\n+{\n+  IntCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n IntType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1215,6 +1278,13 @@ UintType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+UintType::cast (BaseType *other)\n+{\n+  UintCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n UintType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1279,6 +1349,13 @@ FloatType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+FloatType::cast (BaseType *other)\n+{\n+  FloatCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n FloatType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1335,6 +1412,13 @@ USizeType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+USizeType::cast (BaseType *other)\n+{\n+  USizeCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n USizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1380,6 +1464,13 @@ ISizeType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+ISizeType::cast (BaseType *other)\n+{\n+  ISizeCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1425,6 +1516,13 @@ CharType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+CharType::cast (BaseType *other)\n+{\n+  CharCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n CharType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1471,6 +1569,13 @@ ReferenceType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+ReferenceType::cast (BaseType *other)\n+{\n+  ReferenceCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1550,6 +1655,13 @@ PointerType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+PointerType::cast (BaseType *other)\n+{\n+  PointerCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n PointerType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1638,6 +1750,13 @@ ParamType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+ParamType::cast (BaseType *other)\n+{\n+  ParamCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n ParamType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1751,6 +1870,13 @@ StrType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+StrType::cast (BaseType *other)\n+{\n+  StrCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n StrType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1796,6 +1922,13 @@ NeverType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+NeverType::cast (BaseType *other)\n+{\n+  NeverCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n NeverType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1841,6 +1974,13 @@ PlaceholderType::coerce (BaseType *other)\n   return r.coerce (other);\n }\n \n+BaseType *\n+PlaceholderType::cast (BaseType *other)\n+{\n+  PlaceholderCastRules r (this);\n+  return r.cast (other);\n+}\n+\n bool\n PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n {"}, {"sha": "cecf69ad0f5d6e6a82c7db6f3adda673fbdddb66", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -174,6 +174,9 @@ class BaseType\n   // this is the base coercion interface for types\n   virtual BaseType *coerce (BaseType *other) = 0;\n \n+  // this is the cast interface for TypeCastExpr\n+  virtual BaseType *cast (BaseType *other) = 0;\n+\n   // Check value equality between two ty. Type inference rules are ignored. Two\n   //   ty are considered equal if they're of the same kind, and\n   //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n@@ -295,6 +298,7 @@ class InferType : public BaseType\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -331,6 +335,7 @@ class ErrorType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -361,6 +366,7 @@ class ParamType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -448,6 +454,7 @@ class TupleType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -882,6 +889,7 @@ class ADTType : public BaseType, public SubstitutionRef\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1003,6 +1011,7 @@ class FnType : public BaseType, public SubstitutionRef\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1104,6 +1113,7 @@ class FnPtr : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1148,6 +1158,7 @@ class ArrayType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1189,6 +1200,7 @@ class BoolType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1224,6 +1236,7 @@ class IntType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   IntKind get_int_kind () const { return int_kind; }\n \n@@ -1266,6 +1279,7 @@ class UintType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   UintKind get_uint_kind () const { return uint_kind; }\n \n@@ -1306,6 +1320,7 @@ class FloatType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   FloatKind get_float_kind () const { return float_kind; }\n \n@@ -1338,6 +1353,7 @@ class USizeType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1363,6 +1379,7 @@ class ISizeType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1388,6 +1405,7 @@ class CharType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1417,6 +1435,7 @@ class ReferenceType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1462,6 +1481,7 @@ class PointerType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1504,6 +1524,7 @@ class StrType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1539,6 +1560,7 @@ class NeverType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -1569,6 +1591,7 @@ class PlaceholderType : public BaseType\n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n+  BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () final override;\n "}, {"sha": "74c4b1eaac4c773165abb95d7a63aa256814d686", "filename": "gcc/testsuite/rust/compile/cast1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcast1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcast1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcast1.rs?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a: i32 = 123;\n+    let b = a as char;\n+    // { dg-error \"invalid cast .i32. to .char.\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "845d08cea01a55fb9690c243b7e8433cbf1885b9", "filename": "gcc/testsuite/rust/compile/torture/cast1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast1.rs?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a: *const i32 = &123;\n+    let b: *mut i32 = (a as *mut i32);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "82925e93271ccfb09c077c3327c9f26d6cd0c4b7", "filename": "gcc/testsuite/rust/compile/torture/cast2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast2.rs?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a: i32 = 123i32;\n+    let b: u8 = a as u8;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "1de95687039b43a0cabe8106393a8a20901fcf26", "filename": "gcc/testsuite/rust/compile/torture/cast3.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4dd2434cf3db67f86accd41f7c0c511a33425c7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcast3.rs?ref=f4dd2434cf3db67f86accd41f7c0c511a33425c7", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let a = \"foo\\0\";\n+    let b = a as *const str;\n+    let c = b as *const i8;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}]}