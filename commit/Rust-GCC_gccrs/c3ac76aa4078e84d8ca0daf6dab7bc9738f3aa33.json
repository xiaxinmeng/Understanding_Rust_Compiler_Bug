{"sha": "c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNhYzc2YWE0MDc4ZTg0ZDhjYTBkYWY2ZGFiN2JjOTczOGYzYWEzMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-07-31T07:49:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-07-31T07:49:56Z"}, "message": "re PR middle-end/91301 (ICE in omp_add_variable on random access iterator distribute parallel for private (iterator))\n\n\tPR middle-end/91301\n\t* gimplify.c (gimplify_omp_for): If for class iterator on\n\tdistribute parallel for there is no data sharing clause\n\ton inner_for_stmt, look for private clause on combined\n\tparallel too and if found, move it to inner_for_stmt.\n\n\t* testsuite/libgomp.c++/for-27.C: New test.\n\nFrom-SVN: r273922", "tree": {"sha": "c13a0daa48a9a1a3af2429643d918d7c43b54641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c13a0daa48a9a1a3af2429643d918d7c43b54641"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a25f3e8efbbc7182fa58c445574848a73856e9b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25f3e8efbbc7182fa58c445574848a73856e9b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25f3e8efbbc7182fa58c445574848a73856e9b4"}], "stats": {"total": 198, "additions": 198, "deletions": 0}, "files": [{"sha": "29325388de1847298108b9bdb05a195a79c61e1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "patch": "@@ -1,3 +1,11 @@\n+2019-07-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/91301\n+\t* gimplify.c (gimplify_omp_for): If for class iterator on\n+\tdistribute parallel for there is no data sharing clause\n+\ton inner_for_stmt, look for private clause on combined\n+\tparallel too and if found, move it to inner_for_stmt.\n+\n 2019-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* lra-int.h (lra_operand_data): Remove early_clobber field."}, {"sha": "6a1a7f0b1ac4dac669455fbecfe285845b7f1827", "filename": "gcc/gimplify.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "patch": "@@ -10662,6 +10662,22 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t   || OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LASTPRIVATE)\n \t\t  && OMP_CLAUSE_DECL (*pc) == orig_decl)\n \t\tbreak;\n+\t    if (*pc == NULL_TREE)\n+\t      {\n+\t\ttree *spc;\n+\t\tfor (spc = &OMP_PARALLEL_CLAUSES (*data[1]);\n+\t\t     *spc; spc = &OMP_CLAUSE_CHAIN (*spc))\n+\t\t  if (OMP_CLAUSE_CODE (*spc) == OMP_CLAUSE_PRIVATE\n+\t\t      && OMP_CLAUSE_DECL (*spc) == orig_decl)\n+\t\t    break;\n+\t\tif (*spc)\n+\t\t  {\n+\t\t    tree c = *spc;\n+\t\t    *spc = OMP_CLAUSE_CHAIN (c);\n+\t\t    OMP_CLAUSE_CHAIN (c) = NULL_TREE;\n+\t\t    *pc = c;\n+\t\t  }\n+\t      }\n \t    if (*pc == NULL_TREE)\n \t      ;\n \t    else if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_PRIVATE)"}, {"sha": "5adcd74a4ece3772745d77b312e829a9c3ec3341", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "patch": "@@ -1,3 +1,8 @@\n+2019-07-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/91301\n+\t* testsuite/libgomp.c++/for-27.C: New test.\n+\n 2019-07-23  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* testsuite/libgomp.fortran/reduction4.f90: Update BOZ usage"}, {"sha": "7dca4305f85ecd354471bc295ecc4712c2b33eef", "filename": "libgomp/testsuite/libgomp.c++/for-27.C", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-27.C?ref=c3ac76aa4078e84d8ca0daf6dab7bc9738f3aa33", "patch": "@@ -0,0 +1,169 @@\n+// { dg-do run }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+int a[2000];\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T> \n+void\n+baz (I<T> &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    abort ();\n+  results[*i]++;\n+}\n+\n+static inline void\n+baz (int i)\n+{\n+  results[i]++;\n+}\n+\n+void\n+f1 ()\n+{\n+#pragma omp simd\n+  for (auto i : a)\n+    baz (i);\n+}\n+\n+void\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp distribute parallel for\n+  for (i = x; i <= y; i += 6)\n+    baz (*i);\n+}\n+\n+void\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp distribute parallel for private (i)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (*i);\n+}\n+\n+void\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp teams distribute parallel for lastprivate (i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (*i);\n+}\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < 2000; i++)\n+    a[i] = i;\n+  f1 ();\n+  check (1);\n+  #pragma omp teams\n+  f2 (&a[10], &a[1990]);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  #pragma omp teams\n+  f3 (&a[0], &a[1999]);\n+  check (i < 1998 && (i & 1) == 0);\n+  f4 (&a[0], &a[30]);\n+  check (i > 40 && i <= 2000 - 64);\n+}"}]}