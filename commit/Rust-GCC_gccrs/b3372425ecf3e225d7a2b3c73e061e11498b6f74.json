{"sha": "b3372425ecf3e225d7a2b3c73e061e11498b6f74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMzNzI0MjVlY2YzZTIyNWQ3YTJiM2M3M2UwNjFlMTE0OThiNmY3NA==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2020-06-04T02:09:01Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-06-11T08:26:54Z"}, "message": "vect: Rename fully_masked_p to using_partial_vectors_p\n\nPower supports vector memory access with length (in bytes) instructions.\nLike existing fully masking for SVE, it is another approach to vectorize\nthe loop using partially-populated vectors.\n\nAs Richard Sandiford suggested, this patch is to update the existing\nfully_masked_p field to using_partial_vectors_p.  Introduce one macro\nLOOP_VINFO_USING_PARTIAL_VECTORS_P for partial vectorization checking\nusage, update the LOOP_VINFO_FULLY_MASKED_P with\nLOOP_VINFO_USING_PARTIAL_VECTORS_P && !masks.is_empty() and still use\nit for mask-based partial vectors approach specific checks.\n\nBootstrapped/regtested on aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop-manip.c (vect_set_loop_condition): Rename\n\tLOOP_VINFO_FULLY_MASKED_P to LOOP_VINFO_USING_PARTIAL_VECTORS_P.\n\t(vect_gen_vector_loop_niters): Likewise.\n\t(vect_do_peeling): Likewise.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Rename\n\tfully_masked_p to using_partial_vectors_p.\n\t(vect_analyze_loop_costing): Rename LOOP_VINFO_FULLY_MASKED_P to\n\tLOOP_VINFO_USING_PARTIAL_VECTORS_P.\n\t(determine_peel_for_niter): Likewise.\n\t(vect_estimate_min_profitable_iters): Likewise.\n\t(vect_transform_loop): Likewise.\n\t* tree-vectorizer.h (LOOP_VINFO_FULLY_MASKED_P): Updated.\n\t(LOOP_VINFO_USING_PARTIAL_VECTORS_P): New macro.", "tree": {"sha": "af7caddd007715254f4c61fb526c3c918f29a352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af7caddd007715254f4c61fb526c3c918f29a352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3372425ecf3e225d7a2b3c73e061e11498b6f74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3372425ecf3e225d7a2b3c73e061e11498b6f74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3372425ecf3e225d7a2b3c73e061e11498b6f74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3372425ecf3e225d7a2b3c73e061e11498b6f74/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "042f4082979aa22e08c008ed4c5b4bab3915a9c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/042f4082979aa22e08c008ed4c5b4bab3915a9c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/042f4082979aa22e08c008ed4c5b4bab3915a9c2"}], "stats": {"total": 49, "additions": 28, "deletions": 21}, "files": [{"sha": "4bb1c19e8d8d0c6a7b0ddc949cf7c40502f821c3", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3372425ecf3e225d7a2b3c73e061e11498b6f74/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3372425ecf3e225d7a2b3c73e061e11498b6f74/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b3372425ecf3e225d7a2b3c73e061e11498b6f74", "patch": "@@ -912,7 +912,7 @@ vect_set_loop_condition (class loop *loop, loop_vec_info loop_vinfo,\n   gcond *orig_cond = get_loop_exit_condition (loop);\n   gimple_stmt_iterator loop_cond_gsi = gsi_for_stmt (orig_cond);\n \n-  if (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+  if (loop_vinfo && LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     cond_stmt = vect_set_loop_condition_masked (loop, loop_vinfo, niters,\n \t\t\t\t\t\tfinal_iv, niters_maybe_zero,\n \t\t\t\t\t\tloop_cond_gsi);\n@@ -1939,7 +1939,7 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n \n   unsigned HOST_WIDE_INT const_vf;\n   if (vf.is_constant (&const_vf)\n-      && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n       /* Create: niters >> log2(vf) */\n       /* If it's known that niters == number of latch executions + 1 doesn't\n@@ -2471,7 +2471,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   poly_uint64 bound_epilog = 0;\n-  if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n       && LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo))\n     bound_epilog += vf - 1;\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))"}, {"sha": "a9a32e550634f22f738c10a1594f7e1bede88edf", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3372425ecf3e225d7a2b3c73e061e11498b6f74/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3372425ecf3e225d7a2b3c73e061e11498b6f74/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b3372425ecf3e225d7a2b3c73e061e11498b6f74", "patch": "@@ -815,7 +815,7 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     vec_inside_cost (0),\n     vectorizable (false),\n     can_use_partial_vectors_p (true),\n-    fully_masked_p (false),\n+    using_partial_vectors_p (false),\n     peeling_for_gaps (false),\n     peeling_for_niter (false),\n     no_data_dependencies (false),\n@@ -1634,9 +1634,9 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n \n-  /* Only fully-masked loops can have iteration counts less than the\n-     vectorization factor.  */\n-  if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+  /* Only loops that can handle partially-populated vectors can have iteration\n+     counts less than the vectorization factor.  */\n+  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n       HOST_WIDE_INT max_niter;\n \n@@ -1872,7 +1872,7 @@ determine_peel_for_niter (loop_vec_info loop_vinfo)\n     th = LOOP_VINFO_COST_MODEL_THRESHOLD (LOOP_VINFO_ORIG_LOOP_INFO\n \t\t\t\t\t  (loop_vinfo));\n \n-  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     /* The main loop handles all iterations.  */\n     LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n   else if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n@@ -2146,7 +2146,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \n   /* Decide whether to use a fully-masked loop for this vectorization\n      factor.  */\n-  LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+  LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n     = (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n        && vect_verify_full_masking (loop_vinfo));\n   if (dump_enabled_p ())\n@@ -2164,7 +2164,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n      enough iterations for vectorization.  */\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n       && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n       poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       tree scalar_niters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n@@ -2175,10 +2175,11 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t\t\t       \" support peeling for gaps.\\n\");\n     }\n \n-  /* If we're vectorizing an epilogue loop, we either need a fully-masked\n-     loop or a loop that has a lower VF than the main loop.  */\n+  /* If we're vectorizing an epilogue loop, the vectorized loop either needs\n+     to be able to handle fewer than VF scalars, or needs to have a lower VF\n+     than the main loop.  */\n   if (LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n-      && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n       && maybe_ge (LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n \t\t   LOOP_VINFO_VECT_FACTOR (orig_loop_vinfo)))\n     return opt_result::failure_at (vect_location,\n@@ -2249,7 +2250,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t}\n \n       /* Niters for at least one iteration of vectorized loop.  */\n-      if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+      if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n \tniters_th += LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       /* One additional iteration because of peeling for gap.  */\n       if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n@@ -3826,7 +3827,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t \"  Calculated minimum iters for profitability: %d\\n\",\n \t\t min_profitable_iters);\n \n-  if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+  if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n       && min_profitable_iters < (assumed_vf + peel_iters_prologue))\n     /* We want the vectorized loop to execute at least once.  */\n     min_profitable_iters = assumed_vf + peel_iters_prologue;\n@@ -8582,7 +8583,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n   if (niters_vector == NULL_TREE)\n     {\n       if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t  && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+\t  && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n \t  && known_eq (lowest_vf, vf))\n \t{\n \t  niters_vector\n@@ -8751,7 +8752,8 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \n   /* True if the final iteration might not handle a full vector's\n      worth of scalar iterations.  */\n-  bool final_iter_may_be_partial = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n+  bool final_iter_may_be_partial\n+    = LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo);\n   /* The minimum number of iterations performed by the epilogue.  This\n      is 1 when peeling for gaps because we always need a final scalar\n      iteration.  */\n@@ -8762,7 +8764,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n   int bias_for_lowest = 1 - min_epilogue_iters;\n   int bias_for_assumed = bias_for_lowest;\n   int alignment_npeels = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-  if (alignment_npeels && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+  if (alignment_npeels && LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n       /* When the amount of peeling is known at compile time, the first\n \t iteration will have exactly alignment_npeels active elements."}, {"sha": "9be4d1599ee5ad060562e5b19db8ac11f148cbe8", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3372425ecf3e225d7a2b3c73e061e11498b6f74/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3372425ecf3e225d7a2b3c73e061e11498b6f74/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b3372425ecf3e225d7a2b3c73e061e11498b6f74", "patch": "@@ -637,8 +637,9 @@ typedef class _loop_vec_info : public vec_info {\n      fewer than VF scalars.  */\n   bool can_use_partial_vectors_p;\n \n-  /* True if have decided to use a fully-masked loop.  */\n-  bool fully_masked_p;\n+  /* True if we've decided to use partially-populated vectors, so that\n+     the vector loop can handle fewer than VF scalars.  */\n+  bool using_partial_vectors_p;\n \n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n@@ -702,7 +703,7 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_VERSIONING_THRESHOLD(L) (L)->versioning_threshold\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n #define LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P(L) (L)->can_use_partial_vectors_p\n-#define LOOP_VINFO_FULLY_MASKED_P(L)       (L)->fully_masked_p\n+#define LOOP_VINFO_USING_PARTIAL_VECTORS_P(L) (L)->using_partial_vectors_p\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n #define LOOP_VINFO_MAX_VECT_FACTOR(L)      (L)->max_vectorization_factor\n #define LOOP_VINFO_MASKS(L)                (L)->masks\n@@ -739,6 +740,10 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_ORIG_LOOP_INFO(L)       (L)->orig_loop_info\n #define LOOP_VINFO_SIMD_IF_COND(L)         (L)->simd_if_cond\n \n+#define LOOP_VINFO_FULLY_MASKED_P(L)\t\t\\\n+  (LOOP_VINFO_USING_PARTIAL_VECTORS_P (L)\t\\\n+   && !LOOP_VINFO_MASKS (L).is_empty ())\n+\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)\t\t\\"}]}