{"sha": "b77068f27bbad156e88352bb1a3382a96b66acbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc3MDY4ZjI3YmJhZDE1NmU4ODM1MmJiMWEzMzgyYTk2YjY2YWNiZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-10-27T21:58:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-10-27T21:58:09Z"}, "message": "Allow no-capture lambdas to convert to function pointer.\n\n\t* semantics.c (maybe_add_lambda_conv_op): New.\n\t* parser.c (cp_parser_lambda_expression): Call it.\n\t(cp_parser_lambda_declarator_opt): Make op() static if\n\tno captures.\n\t* mangle.c (write_closure_type_name): Adjust.\n\t* semantics.c (finish_this_expr): Adjust.\n\t* decl.c (grok_op_properties): Allow it.\n\t* call.c (build_user_type_conversion_1): Handle static conversion op.\n\t(build_op_call): And op().\n\nFrom-SVN: r153617", "tree": {"sha": "000402686698d1995b0a51ccb183ff709533ba84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/000402686698d1995b0a51ccb183ff709533ba84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b77068f27bbad156e88352bb1a3382a96b66acbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77068f27bbad156e88352bb1a3382a96b66acbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b77068f27bbad156e88352bb1a3382a96b66acbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77068f27bbad156e88352bb1a3382a96b66acbf/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "73d28034382a7ba65ec46d6a1cebd828f32b16c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d28034382a7ba65ec46d6a1cebd828f32b16c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73d28034382a7ba65ec46d6a1cebd828f32b16c9"}], "stats": {"total": 178, "additions": 142, "deletions": 36}, "files": [{"sha": "ba4caf84624d7d9d1453ebdaf18496880dd3ea27", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -1,3 +1,16 @@\n+2009-10-27  Jason Merrill  <jason@redhat.com>\n+\n+\tAllow no-capture lambdas to convert to function pointer.\n+\t* semantics.c (maybe_add_lambda_conv_op): New.\n+\t* parser.c (cp_parser_lambda_expression): Call it.\n+\t(cp_parser_lambda_declarator_opt): Make op() static if\n+\tno captures.\n+\t* mangle.c (write_closure_type_name): Adjust.\n+\t* semantics.c (finish_this_expr): Adjust.\n+\t* decl.c (grok_op_properties): Allow it.\n+\t* call.c (build_user_type_conversion_1): Handle static conversion op.\n+\t(build_op_call): And op().\n+\n 2009-10-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/41828"}, {"sha": "d4bdcbae66ef5bb9cb9dc1e00cc9d9a6a85e0884", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -2953,11 +2953,16 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       for (fns = TREE_VALUE (conv_fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n+\t  tree first = first_arg;\n \n \t  if (DECL_NONCONVERTING_P (fn)\n \t      && (flags & LOOKUP_ONLYCONVERTING))\n \t    continue;\n \n+\t  /* Lambdas have a static conversion op.  */\n+\t  if (DECL_STATIC_FUNCTION_P (fn))\n+\t    first = NULL_TREE;\n+\n \t  /* [over.match.funcs] For conversion functions, the function\n \t     is considered to be a member of the class of the implicit\n \t     object argument for the purpose of defining the type of\n@@ -2968,14 +2973,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    cand = add_template_candidate (&candidates, fn, fromtype,\n \t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   first_arg, NULL, totype,\n+\t\t\t\t\t   first, NULL, totype,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags,\n \t\t\t\t\t   DEDUCE_CONV);\n \t  else\n \t    cand = add_function_candidate (&candidates, fn, fromtype,\n-\t\t\t\t\t   first_arg, NULL,\n+\t\t\t\t\t   first, NULL,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags);\n@@ -3382,20 +3387,30 @@ build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n       for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n+\n+\t  tree lfirst = first_mem_arg;\n+\t  if (DECL_STATIC_FUNCTION_P (fn))\n+\t    lfirst = NULL_TREE;\n+\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    add_template_candidate (&candidates, fn, base, NULL_TREE,\n-\t\t\t\t    first_mem_arg, *args, NULL_TREE,\n+\t\t\t\t    lfirst, *args, NULL_TREE,\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    LOOKUP_NORMAL, DEDUCE_CALL);\n \t  else\n \t    add_function_candidate\n-\t      (&candidates, fn, base, first_mem_arg, *args, TYPE_BINFO (type),\n+\t      (&candidates, fn, base, lfirst, *args, TYPE_BINFO (type),\n \t       TYPE_BINFO (type), LOOKUP_NORMAL);\n \t}\n     }\n \n-  convs = lookup_conversions (type);\n+  /* Rather than mess with handling static conversion ops here, just don't\n+     look at conversions in lambdas.  */\n+  if (LAMBDA_TYPE_P (type))\n+    convs = NULL_TREE;\n+  else\n+    convs = lookup_conversions (type);\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {"}, {"sha": "dc4c6b39c9a81dbb43415912b717f8626593beac", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -2677,7 +2677,8 @@ add_implicitly_declared_members (tree t,\n       CLASSTYPE_LAZY_COPY_CTOR (t) = 1;\n     }\n \n-  /* Currently only lambdas get a lazy move ctor.  */\n+  /* Currently only lambdas get a lazy move ctor, but N2987 adds them for\n+     other classes.  */\n   if (LAMBDA_TYPE_P (t))\n     CLASSTYPE_LAZY_MOVE_CTOR (t) = 1;\n "}, {"sha": "5c51a6fd7b626ab50e4b36dc7f0716a7f408713f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -5073,6 +5073,7 @@ extern void apply_lambda_return_type            (tree, tree);\n extern tree add_capture                         (tree, tree, tree, bool, bool);\n extern tree add_default_capture                 (tree, tree, tree);\n extern tree lambda_expr_this_capture            (tree);\n+extern void maybe_add_lambda_conv_op            (tree);\n \n /* in tree.c */\n void cp_free_lang_data \t\t\t\t(tree t);"}, {"sha": "33023a7649c0d151985688eac82f2c9ace996552", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -10209,8 +10209,13 @@ grok_op_properties (tree decl, bool complain)\n \t      || operator_code == ARRAY_REF\n \t      || operator_code == NOP_EXPR)\n \t    {\n-\t      error (\"%qD must be a nonstatic member function\", decl);\n-\t      return false;\n+\t      if (class_type && LAMBDA_TYPE_P (class_type))\n+\t\t/* Lambdas can have static op() and conv ops.  */;\n+\t      else\n+\t\t{\n+\t\t  error (\"%qD must be a nonstatic member function\", decl);\n+\t\t  return false;\n+\t\t}\n \t    }\n \t  else\n \t    {"}, {"sha": "874df748f81d513ad6c49b057d6f3245b8510354", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -1309,7 +1309,7 @@ write_closure_type_name (const tree type)\n   MANGLE_TRACE_TREE (\"closure-type-name\", type);\n \n   write_string (\"Ul\");\n-  write_method_parms (parms, /*method_p=*/1, fn);\n+  write_method_parms (parms, DECL_NONSTATIC_MEMBER_FUNCTION_P (fn), fn);\n   write_char ('E');\n   write_compact_number (LAMBDA_EXPR_DISCRIMINATOR (lambda));\n }"}, {"sha": "2a0cc37d877575fdeec6ee18530a10c2b32bdfbd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -7090,6 +7090,8 @@ cp_parser_lambda_expression (cp_parser* parser)\n       LAMBDA_EXPR_CAPTURE_LIST (lambda_expr) = newlist;\n     }\n \n+    maybe_add_lambda_conv_op (type);\n+\n     type = finish_struct (type, /*attributes=*/NULL_TREE);\n \n     parser->num_template_parameter_lists = saved_num_template_parameter_lists;\n@@ -7347,15 +7349,25 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     declarator = make_id_declarator (NULL_TREE, ansi_opname (CALL_EXPR),\n \t\t\t\t     sfk_none);\n \n-    quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)\n-\t     ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);\n+    quals = TYPE_UNQUALIFIED;\n+    if (LAMBDA_EXPR_CAPTURE_LIST (lambda_expr) == NULL_TREE\n+\t&& LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_NONE)\n+      {\n+\t/* A lambda with no captures has a static op() and a conversion op\n+\t   to function type.  */\n+\tif (LAMBDA_EXPR_MUTABLE_P (lambda_expr))\n+\t  error (\"lambda expression with no captures declared mutable\");\n+\treturn_type_specs.storage_class = sc_static;\n+      }\n+    else if (!LAMBDA_EXPR_MUTABLE_P (lambda_expr))\n+      quals = TYPE_QUAL_CONST;\n     declarator = make_call_declarator (declarator, param_list, quals,\n \t\t\t\t       exception_spec,\n                                        /*late_return_type=*/NULL_TREE);\n \n     fco = grokmethod (&return_type_specs,\n-                        declarator,\n-                        attributes);\n+\t\t      declarator,\n+\t\t      attributes);\n     DECL_INITIALIZED_IN_CLASS_P (fco) = 1;\n     DECL_ARTIFICIAL (fco) = 1;\n "}, {"sha": "e270a734fa0633d04a6bddc116300467d4eb784e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -2063,17 +2063,13 @@ finish_this_expr (void)\n {\n   tree result;\n \n-  if (current_class_ptr)\n-    {\n-      tree type = TREE_TYPE (current_class_ref);\n-\n-      /* In a lambda expression, 'this' refers to the captured 'this'.  */\n-      if (LAMBDA_TYPE_P (type))\n-        result = lambda_expr_this_capture (CLASSTYPE_LAMBDA_EXPR (type));\n-      else\n-        result = current_class_ptr;\n-\n-    }\n+  /* In a lambda expression, 'this' refers to the captured 'this'.  */\n+  if (current_function_decl\n+      && LAMBDA_FUNCTION_P (current_function_decl))\n+    result = (lambda_expr_this_capture\n+\t      (CLASSTYPE_LAMBDA_EXPR (current_class_type)));\n+  else if (current_class_ptr)\n+    result = current_class_ptr;\n   else if (current_function_decl\n \t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n     {\n@@ -5759,4 +5755,55 @@ lambda_expr_this_capture (tree lambda)\n   return result;\n }\n \n+/* If the closure TYPE has a static op(), also add a conversion to function\n+   pointer.  */\n+\n+void\n+maybe_add_lambda_conv_op (tree type)\n+{\n+  bool nested = (current_function_decl != NULL_TREE);\n+  tree callop = lambda_function (type);\n+  tree rettype, name, fntype, fn, body, compound_stmt;\n+\n+  if (!DECL_STATIC_FUNCTION_P (callop))\n+    return;\n+\n+  rettype = build_pointer_type (TREE_TYPE (callop));\n+  name = mangle_conv_op_name_for_type (rettype);\n+  fntype = build_function_type (rettype, void_list_node);\n+  fn = build_lang_decl (FUNCTION_DECL, name, fntype);\n+  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n+\n+  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n+      && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n+    DECL_ALIGN (fn) = 2 * BITS_PER_UNIT;\n+\n+  SET_OVERLOADED_OPERATOR_CODE (fn, TYPE_EXPR);\n+  grokclassfn (type, fn, NO_SPECIAL);\n+  set_linkage_according_to_type (type, fn);\n+  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n+  DECL_IN_AGGR_P (fn) = 1;\n+  DECL_ARTIFICIAL (fn) = 1;\n+  DECL_NOT_REALLY_EXTERN (fn) = 1;\n+  DECL_DECLARED_INLINE_P (fn) = 1;\n+  DECL_STATIC_FUNCTION_P (fn) = 1;\n+\n+  add_method (type, fn, NULL_TREE);\n+\n+  if (nested)\n+    push_function_context ();\n+  start_preparsed_function (fn, NULL_TREE,\n+\t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n+  body = begin_function_body ();\n+  compound_stmt = begin_compound_stmt (0);\n+\n+  finish_return_stmt (decay_conversion (callop));\n+\n+  finish_compound_stmt (compound_stmt);\n+  finish_function_body (body);\n+\n+  expand_or_defer_fn (finish_function (2));\n+  if (nested)\n+    pop_function_context ();\n+}\n #include \"gt-cp-semantics.h\""}, {"sha": "6b1d818c660191a11d51d7a0e7c44adf590bc240", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -1,3 +1,10 @@\n+2009-10-27  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/lambda/lambda-conv.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-const-neg.C: Adjust.\n+\t* g++.dg/cpp0x/lambda/lambda-mangle.C: Adjust.\n+\t* g++.dg/cpp0x/lambda/lambda-non-const.C: Adjust.\n+\n 2009-10-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/null_pointer_deref1.adb: Accept Constraint_Error."}, {"sha": "0e329e5e1618db96f646f87178ec5884f4cbf4b0", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const-neg.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -3,11 +3,11 @@\n #include <cassert>\n \n template<typename F>\n-void call(const F& f) { f(); }\t// { dg-error \"discards qualifiers\" }\n+void call(const F& f) { f(); }\n \n int main() {\n   call([] () -> void {});\n-  call([] () mutable -> void {}); // { dg-message \"\" \"`f' does not have const `operator()'\" }\n+  call([] () mutable -> void {}); // { dg-message \"\" \"declared mutable\" }\n \n   int i = -1;\n   call([&i] () -> void { i = 0; });"}, {"sha": "e308248b657d8740b8ff6b6bda88cdfcf6af303f", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv.C?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options -std=c++0x }\n+\n+int main()\n+{\n+  void (*pfn)() = []{};\n+}"}, {"sha": "aa7462b4fcf07904c93370ee4859b62937ffc9fc", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -9,8 +9,8 @@ inline void g(int n) {\n   // The closure type is encoded as Z1giEUlvE_.\n   // The call operator of that type is _ZZ1giENKUlvE_clEv.\n \n-// { dg-final { scan-assembler \"_ZZ1giENKUlvE_clEv\" } }\n-// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZZ1giENKUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"_ZZ1giENUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZZ1giENUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n \n   algo([=]{return n+bef();});\n   // The captured entities do not participate in <lambda-sig>\n@@ -31,17 +31,17 @@ struct S {\n   void f(int =\n \t // Type: ZN1S1fEiiEd0_UlvE_\n \t // Operator: _ZZN1S1fEiiEd0_NKUlvE_clEv\n-// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NKUlvE_clEv\" } }\n-// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZZN1S1fEiiEd0_NKUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZZN1S1fEiiEd0_NUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n \t []{return 1;}()\n \t // Type: ZN1S1fEiiEd0_UlvE0_\n \t // Operator: _ZZN1S1fEiiEd0_NKUlvE0_clEv\n-// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NKUlvE0_clEv\" } }\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NUlvE0_clEv\" } }\n \t + []{return 2;}(),\n \t int =\n \t // Type: ZN1S1fEiiEd_UlvE_\n \t // Operator: _ZZN1S1fEiiEd_NKUlvE_clEv\n-// { dg-final { scan-assembler \"_ZZN1S1fEiiEd_NKUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd_NUlvE_clEv\" } }\n \t []{return 3;}());\n };\n \n@@ -52,8 +52,8 @@ template<typename T> int R<T>::x = []{return 1;}();\n template int R<int>::x;\n // Type of lambda in intializer of R<int>::x: N1RIiE1xMUlvE_E\n // Corresponding operator(): _ZNK1RIiE1xMUlvE_clEv\n-// { dg-final { scan-assembler \"_ZNK1RIiE1xMUlvE_clEv\" } }\n-// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZNK1RIiE1xMUlvE_clEv\" { target { ! { *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"_ZN1RIiE1xMUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[ \\t\\]*_?_ZN1RIiE1xMUlvE_clEv\" { target { ! { *-*-mingw* *-*-cygwin } } } } }\n \n void bar()\n {\n@@ -63,7 +63,7 @@ void bar()\n }\n \n // lambdas used in non-template, non-class body initializers are internal.\n-// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*_ZNKUlv\" } }\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*_ZNUlv\" } }\n // { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*variable\" } }\n int variable = []{return 1;}();\n "}, {"sha": "9ff8c029d5c19687fff86851656277275efac1b8", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-non-const.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77068f27bbad156e88352bb1a3382a96b66acbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C?ref=b77068f27bbad156e88352bb1a3382a96b66acbf", "patch": "@@ -8,7 +8,6 @@ void call(F f) { f(); }\n \n int main() {\n   call([] () -> void {});\n-  call([] () mutable -> void {});\n \n   int i = -1;\n   call([i] () mutable -> void { i = 0; });"}]}