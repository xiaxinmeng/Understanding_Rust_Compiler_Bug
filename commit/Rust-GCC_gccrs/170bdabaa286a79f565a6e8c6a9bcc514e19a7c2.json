{"sha": "170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcwYmRhYmFhMjg2YTc5ZjU2NWE2ZThjNmE5YmNjNTE0ZTE5YTdjMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-03-07T09:02:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-03-07T09:02:14Z"}, "message": "i386.c (output_set_got): Add a GOT initialization sequence for VxWorks PIC.\n\ngcc/\n\t* config/i386/i386.c (output_set_got): Add a GOT initialization\n\tsequence for VxWorks PIC.\n\t(legitimate_pic_address_disp_p): Allow UNSPEC_GOT wrappers\n\taround labels as well as symbols.  Use gotoff_operand instead\n\tof local_symbolic_operand.\n\t(legitimize_pic_address): Use gotoff_operand instead of\n\tlocal_symbolic_operand.  Use @GOT accesses for labels as\n\twell as symbols.\n\t(ix86_output_addr_diff_elt): Use PC-relative rather than\n\tGP-relative offsets for VxWorks PIC.\n\t(ix86_expand_move): Pass NULL_RTX to legitimize_pic_address unless\n\tno_new_pseudos.  Check whether the returned register is op0.\n\t* config/i386/i386.md (tablejump): Use PC-relative rather than\n\tGP-relative offsets for VxWorks PIC.\n\t* config/i386/predicates.md (gotoff_operand): New predicate.\n\nFrom-SVN: r122654", "tree": {"sha": "eb38f6b5024536d2a0d27737e35ec58fac5d7355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb38f6b5024536d2a0d27737e35ec58fac5d7355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/comments", "author": null, "committer": null, "parents": [{"sha": "26b5109ffe854436b7146e9eea898083a3b063de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b5109ffe854436b7146e9eea898083a3b063de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b5109ffe854436b7146e9eea898083a3b063de"}], "stats": {"total": 80, "additions": 71, "deletions": 9}, "files": [{"sha": "47057a74863009029fb6b7ee7c9bb01dcf6205aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "patch": "@@ -1,3 +1,21 @@\n+2007-03-07  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/i386/i386.c (output_set_got): Add a GOT initialization\n+\tsequence for VxWorks PIC.\n+\t(legitimate_pic_address_disp_p): Allow UNSPEC_GOT wrappers\n+\taround labels as well as symbols.  Use gotoff_operand instead\n+\tof local_symbolic_operand.\n+\t(legitimize_pic_address): Use gotoff_operand instead of\n+\tlocal_symbolic_operand.  Use @GOT accesses for labels as\n+\twell as symbols.\n+\t(ix86_output_addr_diff_elt): Use PC-relative rather than\n+\tGP-relative offsets for VxWorks PIC.\n+\t(ix86_expand_move): Pass NULL_RTX to legitimize_pic_address unless\n+\tno_new_pseudos.  Check whether the returned register is op0.\n+\t* config/i386/i386.md (tablejump): Use PC-relative rather than\n+\tGP-relative offsets for VxWorks PIC.\n+\t* config/i386/predicates.md (gotoff_operand): New predicate.\n+\n 2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/vxworks.h (VXWORKS_GOTT_BASE, VXWORKS_GOTT_INDEX): Undefine"}, {"sha": "bd086012e51931294496079aae632dc6dad1469e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "patch": "@@ -5371,6 +5371,23 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n   rtx xops[3];\n \n   xops[0] = dest;\n+\n+  if (TARGET_VXWORKS_RTP && flag_pic)\n+    {\n+      /* Load (*VXWORKS_GOTT_BASE) into the PIC register.  */\n+      xops[2] = gen_rtx_MEM (Pmode,\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, VXWORKS_GOTT_BASE));\n+      output_asm_insn (\"mov{l}\\t{%2, %0|%0, %2}\", xops);\n+\n+      /* Load (*VXWORKS_GOTT_BASE)[VXWORKS_GOTT_INDEX] into the PIC register.\n+\t Use %P and a local symbol in order to print VXWORKS_GOTT_INDEX as\n+\t an unadorned address.  */\n+      xops[2] = gen_rtx_SYMBOL_REF (Pmode, VXWORKS_GOTT_INDEX);\n+      SYMBOL_REF_FLAGS (xops[2]) |= SYMBOL_FLAG_LOCAL;\n+      output_asm_insn (\"mov{l}\\t{%P2(%0), %0|%0, DWORD PTR %P2[%0]}\", xops);\n+      return \"\";\n+    }\n+\n   xops[1] = gen_rtx_SYMBOL_REF (Pmode, GOT_SYMBOL_NAME);\n \n   if (! TARGET_DEEP_BRANCH_PREDICTION || !flag_pic)\n@@ -6762,15 +6779,19 @@ legitimate_pic_address_disp_p (rtx disp)\n     case UNSPEC_GOT:\n       if (saw_plus)\n \treturn false;\n-      return GET_CODE (XVECEXP (disp, 0, 0)) == SYMBOL_REF;\n+      /* We need to check for both symbols and labels because VxWorks loads\n+\t text labels with @GOT rather than @GOTOFF.  See gotoff_operand for\n+\t details.  */\n+      return (GET_CODE (XVECEXP (disp, 0, 0)) == SYMBOL_REF\n+\t      || GET_CODE (XVECEXP (disp, 0, 0)) == LABEL_REF);\n     case UNSPEC_GOTOFF:\n       /* Refuse GOTOFF in 64bit mode since it is always 64bit when used.\n \t While ABI specify also 32bit relocation but we don't produce it in\n \t small PIC model at all.  */\n       if ((GET_CODE (XVECEXP (disp, 0, 0)) == SYMBOL_REF\n \t   || GET_CODE (XVECEXP (disp, 0, 0)) == LABEL_REF)\n \t  && !TARGET_64BIT)\n-        return local_symbolic_operand (XVECEXP (disp, 0, 0), Pmode);\n+        return gotoff_operand (XVECEXP (disp, 0, 0), Pmode);\n       return false;\n     case UNSPEC_GOTTPOFF:\n     case UNSPEC_GOTNTPOFF:\n@@ -7091,7 +7112,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n     new = addr;\n   else if (TARGET_64BIT\n \t   && ix86_cmodel != CM_SMALL_PIC\n-\t   && local_symbolic_operand (addr, Pmode))\n+\t   && gotoff_operand (addr, Pmode))\n     {\n       rtx tmpreg;\n       /* This symbol may be referenced via a displacement from the PIC\n@@ -7123,7 +7144,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t}\n       else new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmpreg);\n     }\n-  else if (!TARGET_64BIT && local_symbolic_operand (addr, Pmode))\n+  else if (!TARGET_64BIT && gotoff_operand (addr, Pmode))\n     {\n       /* This symbol may be referenced via a displacement from the PIC\n \t base address (@GOTOFF).  */\n@@ -7148,7 +7169,10 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  new = reg;\n \t}\n     }\n-  else if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (addr) == 0)\n+  else if ((GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (addr) == 0)\n+\t   /* We can't use @GOTOFF for text labels on VxWorks;\n+\t      see gotoff_operand.  */\n+\t   || (TARGET_VXWORKS_RTP && GET_CODE (addr) == LABEL_REF))\n     {\n       if (TARGET_64BIT && ix86_cmodel != CM_LARGE_PIC)\n \t{\n@@ -7218,7 +7242,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n \t  /* Check first to see if this is a constant offset from a @GOTOFF\n \t     symbol reference.  */\n-\t  if (local_symbolic_operand (op0, Pmode)\n+\t  if (gotoff_operand (op0, Pmode)\n \t      && CONST_INT_P (op1))\n \t    {\n \t      if (!TARGET_64BIT)\n@@ -9379,7 +9403,8 @@ ix86_output_addr_diff_elt (FILE *file, int value, int rel)\n #else\n   gcc_assert (!TARGET_64BIT);\n #endif\n-  if (TARGET_64BIT)\n+  /* We can't use @GOTOFF for text labels on VxWorks; see gotoff_operand.  */\n+  if (TARGET_64BIT || TARGET_VXWORKS_RTP)\n     fprintf (file, \"%s%s%d-%s%d\\n\",\n \t     directive, LPREFIX, value, LPREFIX, rel);\n   else if (HAVE_AS_GOTOFF_IN_DATA)\n@@ -9502,7 +9527,12 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \t  if (MEM_P (op0))\n \t    op1 = force_reg (Pmode, op1);\n \t  else if (!TARGET_64BIT || !x86_64_movabs_operand (op1, Pmode))\n-\t    op1 = legitimize_pic_address (op1, op0);\n+\t    {\n+\t      rtx reg = no_new_pseudos ? op0 : NULL_RTX;\n+\t      op1 = legitimize_pic_address (op1, reg);\n+\t      if (op0 == op1)\n+\t\treturn;\n+\t    }\n \t}\n     }\n   else"}, {"sha": "507edd690659f15197d9a6666908b7d31190ba4c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "patch": "@@ -14353,7 +14353,9 @@\n       rtx op0, op1;\n       enum rtx_code code;\n \n-      if (TARGET_64BIT)\n+      /* We can't use @GOTOFF for text labels on VxWorks;\n+\t see gotoff_operand.  */\n+      if (TARGET_64BIT || TARGET_VXWORKS_RTP)\n \t{\n \t  code = PLUS;\n \t  op0 = operands[0];"}, {"sha": "be2141c13f25f4b67ee12a2b63d52380188f603e", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170bdabaa286a79f565a6e8c6a9bcc514e19a7c2/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=170bdabaa286a79f565a6e8c6a9bcc514e19a7c2", "patch": "@@ -456,6 +456,18 @@\n   return 0;\n })\n \n+;; Test for a legitimate @GOTOFF operand.\n+;;\n+;; VxWorks does not impose a fixed gap between segments; the run-time\n+;; gap can be different from the object-file gap.  We therefore can't\n+;; use @GOTOFF unless we are absolutely sure that the symbol is in the\n+;; same segment as the GOT.  Unfortunately, the flexibility of linker\n+;; scripts means that we can't be sure of that in general, so assume\n+;; that @GOTOFF is never valid on VxWorks.\n+(define_predicate \"gotoff_operand\"\n+  (and (match_test \"!TARGET_VXWORKS_RTP\")\n+       (match_operand 0 \"local_symbolic_operand\")))\n+\n ;; Test for various thread-local symbols.\n (define_predicate \"tls_symbolic_operand\"\n   (and (match_code \"symbol_ref\")"}]}