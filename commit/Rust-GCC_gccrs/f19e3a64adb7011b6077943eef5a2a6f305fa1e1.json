{"sha": "f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5ZTNhNjRhZGI3MDExYjYwNzc5NDNlZWY1YTJhNmYzMDVmYTFlMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-04-05T20:20:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-04-05T20:20:42Z"}, "message": "[multiple changes]\n\n2005-04-05  Jakub Jelinek  <jakub@redhat.com>\n\n\t* config/i386/i386.c (init_cumulative_args): For -m32 -mfpmath=sse\n\tand local functions, set sse_nregs to 8 and float_in_sse.\n\t(function_arg_advance, function_arg): If float_in_sse, pass\n\tSFmode and DFmode arguments in SSE registers.\n\t* config/i386/i386.h (CUMULATIVE_ARGS): Add float_in_sse field.\n\n\t* config/i386/i386.c (ix86_value_regno): Only optimize local functions\n\tof -funit-at-a-time.\n\n2005-04-05  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* config/i386/i386-protos.h (ix86_function_value): Accept two\n\targuments, like the target macro.\n\t* config/i386/i386.h (FUNCTION_VALUE): Pass both arguments.\n\t* config/i386/i386.c (ix86_function_value): Accept the second\n\targument of the target macro.\n\t(ix86_function_ok_for_sibcall): Pass a function pointer to\n\tix86_function_value.\n\t(ix86_function_value, ix86_libcall_value) [!TARGET_64BIT]: Adjust\n\tcall to ix86_value_regno).\n\t(ix86_value_regno): Add support for returning floating point values\n\tin SSE registers.\n\n2005-04-05  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* gcc.dg/i386-ssefn-1.c: New test.\n\t* gcc.dg/i386-ssefn-2.c: New test.\n\t* gcc.dg/i386-ssefn-3.c: New test.\n\t* gcc.dg/i386-ssefn-4.c: New test.\n\nFrom-SVN: r97654", "tree": {"sha": "e178b5d0998cb486d80a7eac89c6335431e33d22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e178b5d0998cb486d80a7eac89c6335431e33d22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/comments", "author": null, "committer": null, "parents": [{"sha": "4b2841117bd44ef5b9179c02151a507dc1bd23f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2841117bd44ef5b9179c02151a507dc1bd23f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b2841117bd44ef5b9179c02151a507dc1bd23f5"}], "stats": {"total": 261, "additions": 246, "deletions": 15}, "files": [{"sha": "12c9ab95891c1be2f12953b7fa25f3599362fc8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -1,3 +1,28 @@\n+2005-04-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/i386/i386.c (init_cumulative_args): For -m32 -mfpmath=sse\n+\tand local functions, set sse_nregs to 8 and float_in_sse.\n+\t(function_arg_advance, function_arg): If float_in_sse, pass\n+\tSFmode and DFmode arguments in SSE registers.\n+\t* config/i386/i386.h (CUMULATIVE_ARGS): Add float_in_sse field.\n+\n+\t* config/i386/i386.c (ix86_value_regno): Only optimize local functions\n+\tof -funit-at-a-time.\n+\n+2005-04-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* config/i386/i386-protos.h (ix86_function_value): Accept two\n+\targuments, like the target macro.\n+\t* config/i386/i386.h (FUNCTION_VALUE): Pass both arguments.\n+\t* config/i386/i386.c (ix86_function_value): Accept the second\n+\targument of the target macro.\n+\t(ix86_function_ok_for_sibcall): Pass a function pointer to\n+\tix86_function_value.\n+\t(ix86_function_value, ix86_libcall_value) [!TARGET_64BIT]: Adjust\n+\tcall to ix86_value_regno).\n+\t(ix86_value_regno): Add support for returning floating point values\n+\tin SSE registers.\n+\n 2005-04-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/20076"}, {"sha": "fa9c03af9261ea5dcc4ea13fd1685c2e852bd8fc", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -204,7 +204,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int);\n-extern rtx ix86_function_value (tree);\n+extern rtx ix86_function_value (tree, tree);\n #endif\n \n #endif"}, {"sha": "5eeb54867c4aa9b6126a11138a35c0ab3076c992", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 64, "deletions": 13, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -915,7 +915,7 @@ const struct attribute_spec ix86_attribute_table[];\n static bool ix86_function_ok_for_sibcall (tree, tree);\n static tree ix86_handle_cdecl_attribute (tree *, tree, tree, int, bool *);\n static tree ix86_handle_regparm_attribute (tree *, tree, tree, int, bool *);\n-static int ix86_value_regno (enum machine_mode);\n+static int ix86_value_regno (enum machine_mode, tree);\n static bool contains_128bit_aligned_vector_p (tree);\n static rtx ix86_struct_value_rtx (tree, int);\n static bool ix86_ms_bitfield_layout_p (tree);\n@@ -1645,19 +1645,27 @@ const struct attribute_spec ix86_attribute_table[] =\n static bool\n ix86_function_ok_for_sibcall (tree decl, tree exp)\n {\n+  tree func;\n+\n   /* If we are generating position-independent code, we cannot sibcall\n      optimize any indirect call, or a direct call to a global function,\n      as the PLT requires %ebx be live.  */\n   if (!TARGET_64BIT && flag_pic && (!decl || TREE_PUBLIC (decl)))\n     return false;\n \n+  if (decl)\n+    func = decl;\n+  else\n+    func = NULL;\n+\n   /* If we are returning floats on the 80387 register stack, we cannot\n      make a sibcall from a function that doesn't return a float to a\n      function that does or, conversely, from a function that does return\n      a float to a function that doesn't; the necessary stack adjustment\n      would not be executed.  */\n-  if (STACK_REG_P (ix86_function_value (TREE_TYPE (exp)))\n-      != STACK_REG_P (ix86_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)))))\n+  if (STACK_REG_P (ix86_function_value (TREE_TYPE (exp), func))\n+      != STACK_REG_P (ix86_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),\n+\t\t\t\t\t   cfun->decl)))\n     return false;\n \n   /* If this call is indirect, we'll need to be able to use a call-clobbered\n@@ -2037,7 +2045,22 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n     }\n   if ((!fntype && !libname)\n       || (fntype && !TYPE_ARG_TYPES (fntype)))\n-    cum->maybe_vaarg = 1;\n+    cum->maybe_vaarg = true;\n+\n+  /* For local functions, pass SFmode (and DFmode for SSE2) arguments\n+     in SSE registers even for 32-bit mode and not just 3, but up to\n+     8 SSE arguments in registers.  */\n+  if (!TARGET_64BIT && !cum->maybe_vaarg && !cum->fastcall\n+      && cum->sse_nregs == SSE_REGPARM_MAX && fndecl\n+      && TARGET_SSE_MATH && flag_unit_at_a_time && !profile_flag)\n+    {\n+      struct cgraph_local_info *i = cgraph_local_info (fndecl);\n+      if (i && i->local)\n+\t{\n+\t  cum->sse_nregs = 8;\n+\t  cum->float_in_sse = true;\n+\t}\n+    }\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr, \", nregs=%d )\\n\", cum->nregs);\n@@ -2728,6 +2751,14 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    }\n \t  break;\n \n+\tcase DFmode:\n+\t  if (!TARGET_SSE2)\n+\t    break;\n+\tcase SFmode:\n+\t  if (!cum->float_in_sse)\n+\t    break;\n+\t  /* FALLTHRU */\n+\n \tcase TImode:\n \tcase V16QImode:\n \tcase V8HImode:\n@@ -2849,6 +2880,13 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode orig_mode,\n \t    ret = gen_rtx_REG (mode, regno);\n \t  }\n \tbreak;\n+      case DFmode:\n+\tif (!TARGET_SSE2)\n+\t  break;\n+      case SFmode:\n+\tif (!cum->float_in_sse)\n+\t  break;\n+\t/* FALLTHRU */\n       case TImode:\n       case V16QImode:\n       case V8HImode:\n@@ -3040,7 +3078,7 @@ ix86_function_value_regno_p (int regno)\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n rtx\n-ix86_function_value (tree valtype)\n+ix86_function_value (tree valtype, tree func)\n {\n   enum machine_mode natmode = type_natural_mode (valtype);\n \n@@ -3056,7 +3094,7 @@ ix86_function_value (tree valtype)\n       return ret;\n     }\n   else\n-    return gen_rtx_REG (TYPE_MODE (valtype), ix86_value_regno (natmode));\n+    return gen_rtx_REG (TYPE_MODE (valtype), ix86_value_regno (natmode, func));\n }\n \n /* Return false iff type is returned in memory.  */\n@@ -3158,23 +3196,36 @@ ix86_libcall_value (enum machine_mode mode)\n \t}\n     }\n   else\n-    return gen_rtx_REG (mode, ix86_value_regno (mode));\n+    return gen_rtx_REG (mode, ix86_value_regno (mode, NULL));\n }\n \n /* Given a mode, return the register to use for a return value.  */\n \n static int\n-ix86_value_regno (enum machine_mode mode)\n+ix86_value_regno (enum machine_mode mode, tree func)\n {\n-  /* Floating point return values in %st(0).  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_FLOAT_RETURNS_IN_80387)\n-    return FIRST_FLOAT_REG;\n+  gcc_assert (!TARGET_64BIT);\n+\n   /* 16-byte vector modes in %xmm0.  See ix86_return_in_memory for where\n      we prevent this case when sse is not available.  */\n   if (mode == TImode || (VECTOR_MODE_P (mode) && GET_MODE_SIZE (mode) == 16))\n     return FIRST_SSE_REG;\n-  /* Everything else in %eax.  */\n-  return 0;\n+\n+  /* Most things go in %eax, except (unless -mno-fp-ret-in-387) fp values.  */\n+  if (GET_MODE_CLASS (mode) != MODE_FLOAT || !TARGET_FLOAT_RETURNS_IN_80387)\n+    return 0;\n+\n+  /* Floating point return values in %st(0), except for local functions when\n+     SSE math is enabled.  */\n+  if (func && SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH\n+      && flag_unit_at_a_time)\n+    {\n+      struct cgraph_local_info *i = cgraph_local_info (func);\n+      if (i && i->local)\n+\treturn FIRST_SSE_REG;\n+    }\n+\n+  return FIRST_FLOAT_REG;\n }\n \f\n /* Create the va_list data type.  */"}, {"sha": "819b0b2367d74306f90bccf90819a83944049ce7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -1698,7 +1698,7 @@ enum reg_class\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-   ix86_function_value (VALTYPE)\n+   ix86_function_value (VALTYPE, FUNC)\n \n #define FUNCTION_VALUE_REGNO_P(N) \\\n   ix86_function_value_regno_p (N)\n@@ -1738,6 +1738,8 @@ typedef struct ix86_args {\n   int mmx_nregs;\t\t/* # mmx registers available for passing */\n   int mmx_regno;\t\t/* next available mmx register number */\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n+  int float_in_sse;\t\t/* true if in 32-bit mode SFmode/DFmode should\n+\t\t\t\t   be passed in SSE registers.  */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}, {"sha": "78e6d98282baab87ee78c28a469df145aae7c684", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -1,3 +1,10 @@\n+2005-04-05  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* gcc.dg/i386-ssefn-1.c: New test.\n+\t* gcc.dg/i386-ssefn-2.c: New test.\n+\t* gcc.dg/i386-ssefn-3.c: New test.\n+\t* gcc.dg/i386-ssefn-4.c: New test.\n+\n 2005-04-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/20076"}, {"sha": "a8b0b14e73cd53169c95ec2b9079a1bfeb88d5a2", "filename": "gcc/testsuite/gcc.dg/i386-ssefn-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-1.c?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -0,0 +1,30 @@\n+/* Test argument passing with SSE and local functions\n+   Written by Paolo Bonzini, 25 January 2005 */\n+\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-final { scan-assembler \"movss\" } } */\n+/* { dg-final { scan-assembler \"mulss\" } } */\n+/* { dg-final { scan-assembler-not \"movsd\" } } */\n+/* { dg-final { scan-assembler-not \"mulsd\" } } */\n+/* { dg-options \"-O2 -msse -mfpmath=sse -fno-inline\" } */\n+\n+static float xs (void)\n+{\n+  return 3.14159265;\n+}\n+\n+float ys (float a)\n+{\n+  return xs () * a;\n+}\n+\n+static double xd (void)\n+{\n+  return 3.1415926535;\n+}\n+\n+double yd (double a)\n+{\n+  return xd () * a;\n+}\n+"}, {"sha": "0e1970032e9a1b88bef8f7c320700e6bbe10a291", "filename": "gcc/testsuite/gcc.dg/i386-ssefn-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-2.c?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -0,0 +1,30 @@\n+/* Test argument passing with SSE2 and local functions\n+   Written by Paolo Bonzini, 25 January 2005 */\n+\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-final { scan-assembler \"movss\" } } */\n+/* { dg-final { scan-assembler \"mulss\" } } */\n+/* { dg-final { scan-assembler \"movsd\" } } */\n+/* { dg-final { scan-assembler \"mulsd\" } } */\n+/* { dg-options \"-O2 -msse2 -mfpmath=sse -fno-inline\" } */\n+\n+static float xs (void)\n+{\n+  return 3.14159265;\n+}\n+\n+float ys (float a)\n+{\n+  return xs () * a;\n+}\n+\n+static double xd (void)\n+{\n+  return 3.1415926535;\n+}\n+\n+double yd (double a)\n+{\n+  return xd () * a;\n+}\n+"}, {"sha": "2816919f7c27afab58d70d0812937a1fb86ea089", "filename": "gcc/testsuite/gcc.dg/i386-ssefn-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-3.c?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -0,0 +1,43 @@\n+/* Execution test for argument passing with SSE and local functions\n+   Written by Paolo Bonzini, 25 January 2005 */\n+\n+/* { dg-do run { target i?86-*-* } } */\n+/* { dg-options \"-O2 -msse -mfpmath=sse\" } */\n+#include <assert.h>\n+#include \"i386-cpuid.h\"\n+\n+static float xs (void)\n+{\n+  return 3.14159265;\n+}\n+\n+float ys (float a)\n+{\n+  return xs () * a;\n+}\n+\n+static double xd (void)\n+{\n+  return 3.1415926535;\n+}\n+\n+double yd (double a)\n+{\n+  return xd () * a;\n+}\n+\n+int main()\n+{\n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_cpuid ();\n+\n+  if (cpu_facilities & bit_SSE)\n+    {\n+      assert (ys (1) == xs ());\n+      assert (ys (2) == xs () * 2);\n+      assert (yd (1) == xd ());\n+      assert (yd (2) == xd () * 2);\n+    }\n+  return 0;\n+}"}, {"sha": "353afcec0a17079c945dbe082acf0f46c7b5dd04", "filename": "gcc/testsuite/gcc.dg/i386-ssefn-4.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19e3a64adb7011b6077943eef5a2a6f305fa1e1/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssefn-4.c?ref=f19e3a64adb7011b6077943eef5a2a6f305fa1e1", "patch": "@@ -0,0 +1,43 @@\n+/* Execution test for argument passing with SSE2 and local functions\n+   Written by Paolo Bonzini, 25 January 2005 */\n+\n+/* { dg-do run { target i?86-*-* } } */\n+/* { dg-options \"-O2 -msse2 -mfpmath=sse\" } */\n+#include <assert.h>\n+#include \"i386-cpuid.h\"\n+\n+static float xs (void)\n+{\n+  return 3.14159265;\n+}\n+\n+float ys (float a)\n+{\n+  return xs () * a;\n+}\n+\n+static double xd (void)\n+{\n+  return 3.1415926535;\n+}\n+\n+double yd (double a)\n+{\n+  return xd () * a;\n+}\n+\n+int main()\n+{\n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_cpuid ();\n+\n+  if (cpu_facilities & bit_SSE2)\n+    {\n+      assert (ys (1) == xs ());\n+      assert (ys (2) == xs () * 2);\n+      assert (yd (1) == xd ());\n+      assert (yd (2) == xd () * 2);\n+    }\n+  return 0;\n+}"}]}