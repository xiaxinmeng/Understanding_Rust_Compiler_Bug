{"sha": "dfc0f53a96ce9d3598b747b716c2ff166d60df49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZjMGY1M2E5NmNlOWQzNTk4Yjc0N2I3MTZjMmZmMTY2ZDYwZGY0OQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2012-10-03T19:13:01Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2012-10-03T19:13:01Z"}, "message": "reginfo.c (max_regno_since_last_resize): New.\n\n2012-09-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* reginfo.c (max_regno_since_last_resize): New.\n\t(reg_preferred_class, reg_alternate_class): Add assert.\n\t(allocate_reg_info): Initialize allocated reg info.\n\t(resize_reg_info): Make bigger reg_info and initialize new memory.\n\t(reginfo_init): Initialize max_regno_since_last_resize.\n\t(setup_reg_classes): Change assert.\n\nFrom-SVN: r192047", "tree": {"sha": "b9aed234fb209b5e26f59fa0f8090636c08b8909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9aed234fb209b5e26f59fa0f8090636c08b8909"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfc0f53a96ce9d3598b747b716c2ff166d60df49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc0f53a96ce9d3598b747b716c2ff166d60df49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfc0f53a96ce9d3598b747b716c2ff166d60df49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc0f53a96ce9d3598b747b716c2ff166d60df49/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "953ac96606791f50ed0c4bdc886b79279cda9e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/953ac96606791f50ed0c4bdc886b79279cda9e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/953ac96606791f50ed0c4bdc886b79279cda9e35"}], "stats": {"total": 53, "additions": 43, "deletions": 10}, "files": [{"sha": "2baddf0227c65a2c3e99cb40da67505ee8054063", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfc0f53a96ce9d3598b747b716c2ff166d60df49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfc0f53a96ce9d3598b747b716c2ff166d60df49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfc0f53a96ce9d3598b747b716c2ff166d60df49", "patch": "@@ -1,3 +1,12 @@\n+2012-09-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* reginfo.c (max_regno_since_last_resize): New.\n+\t(reg_preferred_class, reg_alternate_class): Add assert.\n+\t(allocate_reg_info): Initialize allocated reg info.\n+\t(resize_reg_info): Make bigger reg_info and initialize new memory.\n+\t(reginfo_init): Initialize max_regno_since_last_resize.\n+\t(setup_reg_classes): Change assert.\n+\n 2012-10-03  Andrew W. Nosenko <andrew.w.nosenko@gmail.com>\n \n \t*  config/i386/driver-i386.c (host_detect_local_cpu): Fix logic"}, {"sha": "076036c5c5744da8b60f6d91ec3dec39ec00f639", "filename": "gcc/reginfo.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfc0f53a96ce9d3598b747b716c2ff166d60df49/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfc0f53a96ce9d3598b747b716c2ff166d60df49/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=dfc0f53a96ce9d3598b747b716c2ff166d60df49", "patch": "@@ -839,6 +839,8 @@ static struct reg_pref *reg_pref;\n \n /* Current size of reg_info.  */\n static int reg_info_size;\n+/* Max_reg_num still last resize_reg_info call.  */\n+static int max_regno_since_last_resize;\n \n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n@@ -849,6 +851,7 @@ reg_preferred_class (int regno)\n   if (reg_pref == 0)\n     return GENERAL_REGS;\n \n+  gcc_assert (regno < reg_info_size);\n   return (enum reg_class) reg_pref[regno].prefclass;\n }\n \n@@ -858,6 +861,7 @@ reg_alternate_class (int regno)\n   if (reg_pref == 0)\n     return ALL_REGS;\n \n+  gcc_assert (regno < reg_info_size);\n   return (enum reg_class) reg_pref[regno].altclass;\n }\n \n@@ -868,45 +872,64 @@ reg_allocno_class (int regno)\n   if (reg_pref == 0)\n     return NO_REGS;\n \n+  gcc_assert (regno < reg_info_size);\n   return (enum reg_class) reg_pref[regno].allocnoclass;\n }\n \n \f\n \n-/* Allocate space for reg info.  */\n+/* Allocate space for reg info and initilize it.  */\n static void\n allocate_reg_info (void)\n {\n-  reg_info_size = max_reg_num ();\n+  int i;\n+\n+  max_regno_since_last_resize = max_reg_num ();\n+  reg_info_size = max_regno_since_last_resize * 3 / 2 + 1;\n   gcc_assert (! reg_pref && ! reg_renumber);\n   reg_renumber = XNEWVEC (short, reg_info_size);\n   reg_pref = XCNEWVEC (struct reg_pref, reg_info_size);\n   memset (reg_renumber, -1, reg_info_size * sizeof (short));\n+  for (i = 0; i < reg_info_size; i++)\n+    {\n+      reg_pref[i].prefclass = GENERAL_REGS;\n+      reg_pref[i].altclass = ALL_REGS;\n+      reg_pref[i].allocnoclass = GENERAL_REGS;\n+    }\n }\n \n \n-/* Resize reg info. The new elements will be uninitialized.  Return\n-   TRUE if new elements (for new pseudos) were added.  */\n+/* Resize reg info. The new elements will be initialized.  Return TRUE\n+   if new pseudos were added since the last call.  */\n bool\n resize_reg_info (void)\n {\n-  int old;\n+  int old, i;\n+  bool change_p;\n \n   if (reg_pref == NULL)\n     {\n       allocate_reg_info ();\n       return true;\n     }\n-  if (reg_info_size == max_reg_num ())\n-    return false;\n+  change_p = max_regno_since_last_resize != max_reg_num ();\n+  max_regno_since_last_resize = max_reg_num ();\n+  if (reg_info_size >= max_reg_num ())\n+    return change_p;\n   old = reg_info_size;\n-  reg_info_size = max_reg_num ();\n+  reg_info_size = max_reg_num () * 3 / 2 + 1;\n   gcc_assert (reg_pref && reg_renumber);\n   reg_renumber = XRESIZEVEC (short, reg_renumber, reg_info_size);\n   reg_pref = XRESIZEVEC (struct reg_pref, reg_pref, reg_info_size);\n   memset (reg_pref + old, -1,\n \t  (reg_info_size - old) * sizeof (struct reg_pref));\n   memset (reg_renumber + old, -1, (reg_info_size - old) * sizeof (short));\n+  for (i = old; i < reg_info_size; i++)\n+    {\n+      reg_pref[i].prefclass = GENERAL_REGS;\n+      reg_pref[i].altclass = ALL_REGS;\n+      reg_pref[i].allocnoclass = GENERAL_REGS;\n+    }\n   return true;\n }\n \n@@ -938,6 +961,7 @@ reginfo_init (void)\n   /* This prevents dump_reg_info from losing if called\n      before reginfo is run.  */\n   reg_pref = NULL;\n+  reg_info_size = max_regno_since_last_resize = 0;\n   /* No more global register variables may be declared.  */\n   no_global_reg_vars = 1;\n   return 1;\n@@ -964,7 +988,7 @@ struct rtl_opt_pass pass_reginfo_init =\n \n \f\n \n-/* Set up preferred, alternate, and cover classes for REGNO as\n+/* Set up preferred, alternate, and allocno classes for REGNO as\n    PREFCLASS, ALTCLASS, and ALLOCNOCLASS.  */\n void\n setup_reg_classes (int regno,\n@@ -973,7 +997,7 @@ setup_reg_classes (int regno,\n {\n   if (reg_pref == NULL)\n     return;\n-  gcc_assert (reg_info_size == max_reg_num ());\n+  gcc_assert (reg_info_size >= max_reg_num ());\n   reg_pref[regno].prefclass = prefclass;\n   reg_pref[regno].altclass = altclass;\n   reg_pref[regno].allocnoclass = allocnoclass;"}]}