{"sha": "7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U3YzlkNDBkMTdlMGVmYjI3NjkxZmU5ZGZjNGM4MzFkMDNjN2ZmMg==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2015-09-25T00:01:34Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2015-09-25T00:01:34Z"}, "message": "pa-linux.h (HAVE_sync_compare_and_swapdi): Define.\n\n\t* config/pa/pa-linux.h (HAVE_sync_compare_and_swapdi): Define.\n\t* config/pa/pa-protos.h (pa_maybe_emit_compare_and_swap_exchange_loop):\n\tDeclare.\n\t* config/pa/pa.c (pa_init_libfuncs): Init sync libfuncs up to 8 bytes.\n\t(pa_expand_compare_and_swap_loop): New.\n\t(pa_maybe_emit_compare_and_swap_exchange_loop): New.\n\t* config/pa/pa.md (atomic_storeqi, atomic_storehi, atomic_storesi,\n\tatomic_storesf, atomic_loaddf, atomic_storedf): New expanders.\n\t(atomic_loaddf_1, atomic_storedf_1): New insn patterns.\n\t(atomic_loaddi, atomic_loaddi_1, atomic_storedi, atomic_storedi_1):\n\tRevise.\n\nFrom-SVN: r228104", "tree": {"sha": "2b7872002777ddf16e2fc54b210c920b56922e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b7872002777ddf16e2fc54b210c920b56922e35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/comments", "author": null, "committer": null, "parents": [{"sha": "4fe017f67af0b6ac09c568626227460d7a1209c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe017f67af0b6ac09c568626227460d7a1209c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe017f67af0b6ac09c568626227460d7a1209c1"}], "stats": {"total": 307, "additions": 284, "deletions": 23}, "files": [{"sha": "d6ea9677419bbf170c435d2ca08e52bcce1ddbd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "patch": "@@ -1,3 +1,17 @@\n+2015-09-24  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa-linux.h (HAVE_sync_compare_and_swapdi): Define.\n+\t* config/pa/pa-protos.h (pa_maybe_emit_compare_and_swap_exchange_loop):\n+\tDeclare.\n+\t* config/pa/pa.c (pa_init_libfuncs): Init sync libfuncs up to 8 bytes.\n+\t(pa_expand_compare_and_swap_loop): New.\n+\t(pa_maybe_emit_compare_and_swap_exchange_loop): New.\n+\t* config/pa/pa.md (atomic_storeqi, atomic_storehi, atomic_storesi,\n+\tatomic_storesf, atomic_loaddf, atomic_storedf): New expanders.\n+\t(atomic_loaddf_1, atomic_storedf_1): New insn patterns.\n+\t(atomic_loaddi, atomic_loaddi_1, atomic_storedi, atomic_storedi_1):\n+\tRevise.\n+\n 2015-09-24  Michael Collison  <michael.collison@linaro.org>\n \n \tPR other/57195"}, {"sha": "957a274249bdf0e36a7ddc5367c567058c8b51d6", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "patch": "@@ -140,3 +140,4 @@ along with GCC; see the file COPYING3.  If not see\n #define HAVE_sync_compare_and_swapqi 1\n #define HAVE_sync_compare_and_swaphi 1\n #define HAVE_sync_compare_and_swapsi 1\n+#define HAVE_sync_compare_and_swapdi 1"}, {"sha": "82ca9b2cc30208f8d8566798eb707b68a50c4da9", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "patch": "@@ -79,6 +79,7 @@ extern enum direction pa_function_arg_padding (machine_mode, const_tree);\n #endif /* ARGS_SIZE_RTX */\n extern int pa_insn_refs_are_delayed (rtx_insn *);\n extern rtx pa_get_deferred_plabel (rtx);\n+extern rtx pa_maybe_emit_compare_and_swap_exchange_loop (rtx, rtx, rtx);\n #endif /* RTX_CODE */\n \n extern int pa_and_mask_p (unsigned HOST_WIDE_INT);"}, {"sha": "38daa5fec711b8fc487bfcd7f69f22b509e37862", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "patch": "@@ -5749,7 +5749,7 @@ pa_init_libfuncs (void)\n     }\n \n   if (TARGET_SYNC_LIBCALL)\n-    init_sync_libfuncs (UNITS_PER_WORD);\n+    init_sync_libfuncs (8);\n }\n \n /* HP's millicode routines mean something special to the assembler.\n@@ -10555,4 +10555,79 @@ pa_output_addr_diff_vec (rtx lab, rtx body)\n     fputs (\"\\t.end_brtab\\n\", asm_out_file);\n }\n \n+/* This is a helper function for the other atomic operations.  This function\n+   emits a loop that contains SEQ that iterates until a compare-and-swap\n+   operation at the end succeeds.  MEM is the memory to be modified.  SEQ is\n+   a set of instructions that takes a value from OLD_REG as an input and\n+   produces a value in NEW_REG as an output.  Before SEQ, OLD_REG will be\n+   set to the current contents of MEM.  After SEQ, a compare-and-swap will\n+   attempt to update MEM with NEW_REG.  The function returns true when the\n+   loop was generated successfully.  */\n+\n+static bool\n+pa_expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n+{\n+  machine_mode mode = GET_MODE (mem);\n+  rtx_code_label *label;\n+  rtx cmp_reg, success, oldval;\n+\n+  /* The loop we want to generate looks like\n+\n+        cmp_reg = mem;\n+      label:\n+        old_reg = cmp_reg;\n+        seq;\n+        (success, cmp_reg) = compare-and-swap(mem, old_reg, new_reg)\n+        if (success)\n+          goto label;\n+\n+     Note that we only do the plain load from memory once.  Subsequent\n+     iterations use the value loaded by the compare-and-swap pattern.  */\n+\n+  label = gen_label_rtx ();\n+  cmp_reg = gen_reg_rtx (mode);\n+\n+  emit_move_insn (cmp_reg, mem);\n+  emit_label (label);\n+  emit_move_insn (old_reg, cmp_reg);\n+  if (seq)\n+    emit_insn (seq);\n+\n+  success = NULL_RTX;\n+  oldval = cmp_reg;\n+  if (!expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,\n+                                       new_reg, false, MEMMODEL_SYNC_SEQ_CST,\n+                                       MEMMODEL_RELAXED))\n+    return false;\n+\n+  if (oldval != cmp_reg)\n+    emit_move_insn (cmp_reg, oldval);\n+\n+  /* Mark this jump predicted not taken.  */\n+  emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n+                           GET_MODE (success), 1, label, 0);\n+  return true;\n+}\n+\n+/* This function tries to implement an atomic exchange operation using a \n+   compare_and_swap loop. VAL is written to *MEM.  The previous contents of\n+   *MEM are returned, using TARGET if possible.  No memory model is required\n+   since a compare_and_swap loop is seq-cst.  */\n+\n+rtx\n+pa_maybe_emit_compare_and_swap_exchange_loop (rtx target, rtx mem, rtx val)\n+{\n+  machine_mode mode = GET_MODE (mem);\n+\n+  if (can_compare_and_swap_p (mode, true))\n+    {\n+      if (!target || !register_operand (target, mode))\n+        target = gen_reg_rtx (mode);\n+      if (pa_expand_compare_and_swap_loop (mem, target, val, NULL_RTX))\n+        return target;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n #include \"gt-pa.h\""}, {"sha": "36efb84806a4d1a3f0f3b2867faf137a2ca687c6", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 192, "deletions": 22, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=7e7c9d40d17e0efb27691fe9dfc4c831d03c7ff2", "patch": "@@ -699,59 +699,229 @@\n ;; doubleword loads and stores are not guaranteed to be atomic\n ;; when referencing the I/O address space.\n \n-;; Implement atomic DImode load using 64-bit floating point load and copy.\n+;; The kernel cmpxchg operation on linux is not atomic with respect to\n+;; memory stores on SMP machines, so we must do stores using a cmpxchg\n+;; operation.\n+\n+;; Implement atomic QImode store using exchange.\n+\n+(define_expand \"atomic_storeqi\"\n+  [(match_operand:QI 0 \"memory_operand\")                ;; memory\n+   (match_operand:QI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic HImode stores using exchange.\n+\n+(define_expand \"atomic_storehi\"\n+  [(match_operand:HI 0 \"memory_operand\")                ;; memory\n+   (match_operand:HI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic SImode store using exchange.\n+\n+(define_expand \"atomic_storesi\"\n+  [(match_operand:SI 0 \"memory_operand\")                ;; memory\n+   (match_operand:SI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic SFmode store using exchange.\n+\n+(define_expand \"atomic_storesf\"\n+  [(match_operand:SF 0 \"memory_operand\")                ;; memory\n+   (match_operand:SF 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic DImode load using 64-bit floating point load.\n \n (define_expand \"atomic_loaddi\"\n   [(match_operand:DI 0 \"register_operand\")              ;; val out\n    (match_operand:DI 1 \"memory_operand\")                ;; memory\n    (match_operand:SI 2 \"const_int_operand\")]            ;; model\n-  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+  \"\"\n {\n-  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+  enum memmodel model;\n+\n+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)\n+    FAIL;\n+\n+  model = memmodel_from_int (INTVAL (operands[2]));\n   operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n-  operands[2] = gen_reg_rtx (DImode);\n   expand_mem_thread_fence (model);\n-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));\n   if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n   DONE;\n })\n \n (define_insn \"atomic_loaddi_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (mem:DI (match_operand:SI 1 \"register_operand\" \"r\")))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=&f\"))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f,r\")\n+        (mem:DI (match_operand:SI 1 \"register_operand\" \"r,r\")))\n+   (clobber (match_scratch:DI 2 \"=X,f\"))]\n   \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n-  \"{fldds|fldd} 0(%1),%2\\;{fstds|fstd} %2,-16(%%sp)\\;{ldws|ldw} -16(%%sp),%0\\;{ldws|ldw} -12(%%sp),%R0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"16\")])\n+  \"@\n+   {fldds|fldd} 0(%1),%0\n+   {fldds|fldd} 0(%1),%2\\n\\t{fstds|fstd} %2,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\\n\\t{ldws|ldw} -12(%%sp),%R0\"\n+  [(set_attr \"type\" \"move,move\")\n+   (set_attr \"length\" \"4,16\")])\n \n-;; Implement atomic DImode store using copy and 64-bit floating point store.\n+;; Implement atomic DImode store.\n \n (define_expand \"atomic_storedi\"\n   [(match_operand:DI 0 \"memory_operand\")                ;; memory\n    (match_operand:DI 1 \"register_operand\")              ;; val out\n    (match_operand:SI 2 \"const_int_operand\")]            ;; model\n-  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+  \"\"\n {\n-  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+  enum memmodel model;\n+\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+\n+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)\n+    FAIL;\n+\n+  model = memmodel_from_int (INTVAL (operands[2]));\n   operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n-  operands[2] = gen_reg_rtx (DImode);\n   expand_mem_thread_fence (model);\n-  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));\n   if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n   DONE;\n })\n \n (define_insn \"atomic_storedi_1\"\n-  [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r\"))\n-        (match_operand:DI 1 \"register_operand\" \"r\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=&f\"))]\n+  [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r,r\"))\n+        (match_operand:DI 1 \"register_operand\" \"f,r\"))\n+   (clobber (match_scratch:DI 2 \"=X,f\"))]\n+  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL\"\n+  \"@\n+   {fstds|fstd} %1,0(%0)\n+   {stws|stw} %1,-16(%%sp)\\n\\t{stws|stw} %R1,-12(%%sp)\\n\\t{fldds|fldd} -16(%%sp),%2\\n\\t{fstds|fstd} %2,0(%0)\"\n+  [(set_attr \"type\" \"move,move\")\n+   (set_attr \"length\" \"4,16\")])\n+\n+;; Implement atomic DFmode load using 64-bit floating point load.\n+\n+(define_expand \"atomic_loaddf\"\n+  [(match_operand:DF 0 \"register_operand\")              ;; val out\n+   (match_operand:DF 1 \"memory_operand\")                ;; memory\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  enum memmodel model;\n+\n+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)\n+    FAIL;\n+\n+  model = memmodel_from_int (INTVAL (operands[2]));\n+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n+  expand_mem_thread_fence (model);\n+  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));\n+  if (is_mm_seq_cst (model))\n+    expand_mem_thread_fence (model);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_loaddf_1\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,r\")\n+        (mem:DF (match_operand:SI 1 \"register_operand\" \"r,r\")))\n+   (clobber (match_scratch:DF 2 \"=X,f\"))]\n   \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n-  \"{stws|stw} %1,-16(%%sp)\\;{stws|stw} %R1,-12(%%sp)\\;{fldds|fldd} -16(%%sp),%2\\;{fstds|fstd} %2,0(%0)\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"16\")])\n+  \"@\n+   {fldds|fldd} 0(%1),%0\n+   {fldds|fldd} 0(%1),%2\\n\\t{fstds|fstd} %2,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\\n\\t{ldws|ldw} -12(%%sp),%R0\"\n+  [(set_attr \"type\" \"move,move\")\n+   (set_attr \"length\" \"4,16\")])\n+\n+;; Implement atomic DFmode store using 64-bit floating point store.\n+\n+(define_expand \"atomic_storedf\"\n+  [(match_operand:DF 0 \"memory_operand\")                ;; memory\n+   (match_operand:DF 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  enum memmodel model;\n+\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+\n+  if (TARGET_64BIT || TARGET_SOFT_FLOAT)\n+    FAIL;\n+\n+  model = memmodel_from_int (INTVAL (operands[2]));\n+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n+  expand_mem_thread_fence (model);\n+  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));\n+  if (is_mm_seq_cst (model))\n+    expand_mem_thread_fence (model);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_storedf_1\"\n+  [(set (mem:DF (match_operand:SI 0 \"register_operand\" \"r,r\"))\n+        (match_operand:DF 1 \"register_operand\" \"f,r\"))\n+   (clobber (match_scratch:DF 2 \"=X,f\"))]\n+  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+  \"@\n+   {fstds|fstd} %1,0(%0)\n+   {stws|stw} %1,-16(%%sp)\\n\\t{stws|stw} %R1,-12(%%sp)\\n\\t{fldds|fldd} -16(%%sp),%2\\n\\t{fstds|fstd} %2,0(%0)\"\n+  [(set_attr \"type\" \"move,move\")\n+   (set_attr \"length\" \"4,16\")])\n \n ;; Compare instructions.\n ;; This controls RTL generation and register allocation."}]}