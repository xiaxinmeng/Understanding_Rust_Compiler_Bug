{"sha": "fefa31b568664d9efb6257a35ae7b014766faa69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmYTMxYjU2ODY2NGQ5ZWZiNjI1N2EzNWFlN2IwMTQ3NjZmYWE2OQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-11-19T21:57:13Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-11-19T21:57:13Z"}, "message": "Eliminate ENTRY_BLOCK_PTR and EXIT_BLOCK_PTR macros\n\ngcc/\n\n\t* basic-block.h (ENTRY_BLOCK_PTR_FOR_FUNCTION): Rename macro to...\n\t(EXIT_BLOCK_PTR_FOR_FUNCTION): ...this.\n\t(ENTRY_BLOCK_PTR_FOR_FN): Renamed macro to...\n\t(EXIT_BLOCK_PTR_FOR_FN): ...this.\n\t(ENTRY_BLOCK_PTR): Eliminate macro as work towards making uses of\n\tcfun be explicit.\n\t(EXIT_BLOCK_PTR): Likewise.\n\t(FOR_ALL_BB): Rework for now to eliminate use of \"ENTRY_BLOCK_PTR\".\n\t(FOR_ALL_BB_FN): Update for renaming of\n\t\"ENTRY_BLOCK_PTR_FOR_FUNCTION\" to \"ENTRY_BLOCK_PTR_FOR_FN\".\n\n\t* cfg.c (init_flow): Likewise.\n\t(check_bb_profile): Likewise.\n\t* cfganal.c (pre_and_rev_post_order_compute_fn): Likewise.\n\t* cfgcleanup.c (walk_to_nondebug_insn): Likewise.\n\t* cfghooks.c (account_profile_record): Likewise.\n\t* cfgloop.c (init_loops_structure): Likewise.\n\t* cgraphbuild.c (record_eh_tables): Likewise.\n\t(compute_call_stmt_bb_frequency): Likewise.\n\t* ipa-inline-analysis.c (compute_bb_predicates): Likewise.\n\t* lto-streamer-in.c (input_cfg): Likewise.\n\t* predict.c (maybe_hot_frequency_p): Likewise.\n\t* tree-cfg.c (init_empty_tree_cfg_for_function): Likewise.\n\t* tree-inline.c (initialize_cfun): Likewise.\n\t(copy_cfg_body): Likewise.\n\t(copy_body): Likewise.\n\t(tree_function_versioning): Likewise.\n\n\t* bb-reorder.c (add_labels_and_missing_jumps): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(duplicate_computed_gotos): Remove usage of EXIT_BLOCK_PTR macro.\n\t(find_rarely_executed_basic_blocks_and_crossing_edges): Remove uses of\n\tmacros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(connect_traces): Likewise.\n\t(rest_of_handle_reorder_blocks): Remove usage of EXIT_BLOCK_PTR macro.\n\t(bb_to_key): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(fix_crossing_conditional_branches): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t(find_traces_1_round): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(fix_up_fall_thru_edges): Remove usage of EXIT_BLOCK_PTR macro.\n\t(find_traces): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(fix_up_crossing_landing_pad): Remove usage of EXIT_BLOCK_PTR macro.\n\t(rotate_loop): Likewise.\n\t* bt-load.c (migrate_btr_def): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* cfg.c (clear_aux_for_edges): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(alloc_aux_for_edges): Likewise.\n\t(clear_bb_flags): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(cached_make_edge): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(compact_blocks): Likewise.\n\t(clear_edges): Likewise.\n\t* cfganal.c (single_pred_before_succ_order): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(bitmap_union_of_succs): Remove usage of EXIT_BLOCK_PTR macro.\n\t(bitmap_union_of_preds): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(bitmap_intersection_of_succs): Remove usage of EXIT_BLOCK_PTR macro.\n\t(bitmap_intersection_of_preds): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(inverted_post_order_compute): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(compute_dominance_frontiers_1): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(post_order_compute): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(connect_infinite_loops_to_exit): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t(remove_fake_edges): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(add_noreturn_fake_exit_edges): Remove usage of EXIT_BLOCK_PTR macro.\n\t(find_pdom): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(remove_fake_exit_edges): Remove usage of EXIT_BLOCK_PTR macro.\n\t(verify_edge_list): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(print_edge_list): Likewise.\n\t(create_edge_list): Likewise.\n\t(find_unreachable_blocks): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(mark_dfs_back_edges): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t* cfgbuild.c (find_bb_boundaries): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(find_many_sub_basic_blocks): Remove usage of EXIT_BLOCK_PTR macro.\n\t(make_edges): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* cfgcleanup.c (delete_unreachable_blocks): Likewise.\n\t(try_optimize_cfg): Likewise.\n\t(try_head_merge_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(try_crossjump_to_edge): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(try_crossjump_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(merge_blocks_move): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(outgoing_edges_match): Remove usage of EXIT_BLOCK_PTR macro.\n\t(try_forward_edges): Likewise.\n\t(try_simplify_condjump): Likewise.\n\t* cfgexpand.c (gimple_expand_cfg): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(construct_exit_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(construct_init_block): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(expand_gimple_basic_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(expand_gimple_tailcall): Likewise.\n\t* cfghooks.c (can_duplicate_block_p): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(tidy_fallthru_edges): Likewise.\n\t(verify_flow_info): Likewise.\n\t* cfgloop.c (flow_bb_inside_loop_p): Likewise.\n\t(num_loop_branches): Remove usage of EXIT_BLOCK_PTR macro.\n\t(disambiguate_multiple_latches): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(get_loop_exit_edges): Remove usage of EXIT_BLOCK_PTR macro.\n\t(bb_loop_header_p): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(get_loop_body_in_bfs_order): Remove usage of EXIT_BLOCK_PTR macro.\n\t(get_loop_body_in_dom_order): Likewise.\n\t(get_loop_body): Likewise.\n\t* cfgloopanal.c (mark_irreducible_loops): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* cfgloopmanip.c (create_preheader): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(remove_path): Remove usage of EXIT_BLOCK_PTR macro.\n\t(fix_bb_placement): Likewise.\n\t* cfgrtl.c (rtl_block_empty_p): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(rtl_can_remove_branch_p): Remove usage of EXIT_BLOCK_PTR macro.\n\t(cfg_layout_split_edge): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(rtl_flow_call_edges_add): Remove usage of EXIT_BLOCK_PTR macro.\n\t(cfg_layout_can_merge_blocks_p): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(cfg_layout_redirect_edge_and_branch): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(fixup_fallthru_exit_predecessor): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(fixup_reorder_chain): Likewise.\n\t(relink_block_chain): Likewise.\n\t(cfg_layout_delete_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(rtl_verify_bb_layout): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(cfg_layout_duplicate_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(force_one_exit_fallthru): Likewise.\n\t(rtl_verify_fallthru): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(rtl_verify_edges): Likewise.\n\t(commit_edge_insertions): Likewise.\n\t(commit_one_edge_insertion): Likewise.\n\t(rtl_split_edge): Likewise.\n\t(force_nonfallthru_and_redirect): Likewise.\n\t(outof_cfg_layout_mode): Remove usage of EXIT_BLOCK_PTR macro.\n\t(skip_insns_after_block): Likewise.\n\t(fixup_partition_crossing): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(purge_dead_edges): Remove usage of EXIT_BLOCK_PTR macro.\n\t(rtl_can_merge_blocks): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(contains_no_active_insn_p): Likewise.\n\t(emit_insn_at_entry): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(entry_of_function): Likewise.\n\t(last_bb_in_partition): Remove usage of EXIT_BLOCK_PTR macro.\n\t(fixup_new_cold_bb): Likewise.\n\t(patch_jump_insn): Likewise.\n\t(try_redirect_by_replacing_jump): Likewise.\n\t(block_label): Likewise.\n\t(could_fall_through): Likewise.\n\t(can_fallthru): Likewise.\n\t* cgraphbuild.c (cgraph_rebuild_references): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(rebuild_cgraph_edges): Likewise.\n\t* cgraphunit.c (init_lowered_empty_function): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(expand_thunk): Remove usage of EXIT_BLOCK_PTR macro.\n\t* combine.c (get_last_value): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(distribute_links): Remove usage of EXIT_BLOCK_PTR macro.\n\t(get_last_value_validate): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(try_combine): Remove usage of EXIT_BLOCK_PTR macro.\n\t(reg_num_sign_bit_copies_for_combine): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(reg_nonzero_bits_for_combine): Likewise.\n\t(set_nonzero_bits_and_sign_copies): Likewise.\n\t(combine_instructions): Likewise.\n\t* cprop.c (one_cprop_pass): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(bypass_conditional_jumps): Likewise.\n\t(bypass_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(find_implicit_sets): Likewise.\n\t(cprop_jump): Likewise.\n\t* cse.c (cse_cc_succs): Likewise.\n\t(cse_find_path): Likewise.\n\t* df-problems.c (df_lr_confluence_0): Likewise.\n\t* df-scan.c (df_entry_block_defs_collect): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(df_exit_block_uses_collect): Remove usage of EXIT_BLOCK_PTR macro.\n\t* dominance.c (iterate_fix_dominators): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(calc_idoms): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(determine_dominators_for_sons): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(calc_dfs_tree): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(prune_bbs_to_update_dominators): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(calc_dfs_tree_nonrec): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t* domwalk.c (cmp_bb_postorder): Likewise.\n\t* dse.c (dse_step1): Remove usage of EXIT_BLOCK_PTR macro.\n\t* except.c (finish_eh_generation): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(sjlj_emit_function_enter): Likewise.\n\t* final.c (compute_alignments): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Remove uses of\n\tmacros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(reposition_prologue_and_epilogue_notes): Remove usage of\n\tEXIT_BLOCK_PTR macro.\n\t(convert_jumps_to_returns): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(regno_clobbered_at_setjmp): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(next_block_for_reg): Remove usage of EXIT_BLOCK_PTR macro.\n\t* gcse.c (hoist_code): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(update_bb_reg_pressure): Remove usage of EXIT_BLOCK_PTR macro.\n\t(compute_code_hoist_vbeinout): Likewise.\n\t(should_hoist_expr_to_dom): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(pre_expr_reaches_here_p_work): Likewise.\n\t* gimple-iterator.c (gsi_commit_edge_inserts): Likewise.\n\t(gimple_find_edge_insert_loc): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t* gimple-ssa-strength-reduction.c (slsr_process_phi): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* graph.c (draw_cfg_nodes_for_loop): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t* graphite-clast-to-gimple.c (translate_clast_user): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* graphite-scop-detection.c (build_scops): Likewise.\n\t(create_sese_edges): Remove usage of EXIT_BLOCK_PTR macro.\n\t(scopdet_basic_block_info): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* haifa-sched.c (restore_bb_notes): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t(unlink_bb_notes): Likewise.\n\t(create_check_block_twin): Likewise.\n\t(init_before_recovery): Likewise.\n\t(sched_extend_bb): Likewise.\n\t(priority): Likewise.\n\t* hw-doloop.c (reorder_loops): Likewise.\n\t(discover_loop): Likewise.\n\t* ifcvt.c (dead_or_predicable): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(find_if_case_1): Remove usage of EXIT_BLOCK_PTR macro.\n\t(block_has_only_trap): Likewise.\n\t(cond_exec_find_if_block): Likewise.\n\t(merge_if_block): Likewise.\n\t* ipa-inline-analysis.c (param_change_prob): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(record_modified): Likewise.\n\t* ipa-pure-const.c (execute_warn_function_noreturn): Remove usage of\n\tEXIT_BLOCK_PTR macro.\n\t(local_pure_const): Likewise.\n\t* ipa-split.c (split_function): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(find_split_points): Likewise.\n\t(consider_split): Likewise.\n\t(find_return_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(verify_non_ssa_vars): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* ira-build.c (ira_loop_tree_body_rev_postorder): Likewise.\n\t* ira-color.c (print_loop_title): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t* ira-emit.c (entered_from_non_parent_p): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(ira_emit): Remove usage of EXIT_BLOCK_PTR macro.\n\t* ira-int.h (ira_assert): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* ira.c (split_live_ranges_for_shrink_wrap): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* lcm.c (compute_rev_insert_delete): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(compute_nearerout): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(compute_farthest): Likewise.\n\t(compute_available): Likewise.\n\t(compute_insert_delete): Remove usage of EXIT_BLOCK_PTR macro.\n\t(compute_laterin): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(compute_earliest): Likewise.\n\t(compute_antinout_edge): Likewise.\n\t* loop-iv.c (simplify_using_initial_values): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* loop-unswitch.c (unswitch_loop): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t* lra-assigns.c (find_hard_regno_for): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t* lra-constraints.c (lra_inheritance): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t* lra-lives.c (lra_create_live_ranges): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* lra.c (has_nonexceptional_receiver): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t* lto-streamer-in.c (input_function): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t* lto-streamer-out.c (output_cfg): Likewise.\n\t* mcf.c (adjust_cfg_counts): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(create_fixup_graph): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* mode-switching.c (optimize_mode_switching): Likewise.\n\t(create_pre_exit): Remove usage of EXIT_BLOCK_PTR macro.\n\t* modulo-sched.c (rest_of_handle_sms): Likewise.\n\t(canon_loop): Likewise.\n\t* omp-low.c (build_omp_regions): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t* postreload-gcse.c (eliminate_partially_redundant_loads): Remove uses\n\tof macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* predict.c (rebuild_frequencies): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(propagate_freq): Remove usage of EXIT_BLOCK_PTR macro.\n\t(estimate_bb_frequencies): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(tree_estimate_probability_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(expensive_function_p): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(tree_bb_level_predictions): Remove usage of EXIT_BLOCK_PTR macro.\n\t(counts_to_freqs): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(apply_return_prediction): Remove usage of EXIT_BLOCK_PTR macro.\n\t(estimate_loops): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(gimple_predict_edge): Likewise.\n\t(probably_never_executed): Likewise.\n\t* profile.c (find_spanning_tree): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(branch_prob): Likewise.\n\t(compute_branch_probabilities): Likewise.\n\t(compute_frequency_overlap): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(is_inconsistent): Remove usage of EXIT_BLOCK_PTR macro.\n\t(read_profile_edge_counts): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(set_bb_counts): Likewise.\n\t(correct_negative_edge_counts): Likewise.\n\t(get_exec_counts): Likewise.\n\t(instrument_values): Likewise.\n\t(instrument_edges): Likewise.\n\t* reg-stack.c (convert_regs): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(compensate_edges): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(convert_regs_exit): Remove usage of EXIT_BLOCK_PTR macro.\n\t(convert_regs_entry): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(reg_to_stack): Likewise.\n\t* regs.h (REG_N_SETS): Likewise.\n\t* reload.c (find_dummy_reload): Likewise.\n\t(combine_reloads): Likewise.\n\t(push_reload): Likewise.\n\t* reload1.c (has_nonexceptional_receiver): Remove usage of\n\tEXIT_BLOCK_PTR macro.\n\t* resource.c (mark_target_live_regs): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(find_basic_block): Likewise.\n\t* sched-ebb.c (ebb_add_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(schedule_ebbs): Likewise.\n\t* sched-int.h (sel_sched_p): Likewise.\n\t* sched-rgn.c (compute_dom_prob_ps): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(rgn_add_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(haifa_find_rgns): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(propagate_deps): Remove usage of EXIT_BLOCK_PTR macro.\n\t(extend_rgns): Likewise.\n\t(find_single_block_region): Likewise.\n\t* sel-sched-ir.c (sel_remove_loop_preheader): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(setup_nop_and_exit_insns): Remove usage of EXIT_BLOCK_PTR macro.\n\t(sel_create_recovery_block): Likewise.\n\t(bb_ends_ebb_p): Likewise.\n\t(sel_bb_end): Likewise.\n\t(sel_bb_head): Likewise.\n\t(free_lv_sets): Likewise.\n\t(init_lv_sets): Likewise.\n\t(tidy_control_flow): Likewise.\n\t(maybe_tidy_empty_bb): Likewise.\n\t* sel-sched-ir.h (_succ_iter_cond): Likewise.\n\t(_succ_iter_start): Likewise.\n\t(sel_bb_empty_or_nop_p): Likewise.\n\t(get_loop_exit_edges_unique_dests): Likewise.\n\t(inner_loop_header_p): Likewise.\n\t* sel-sched.c (create_block_for_bookkeeping): Likewise.\n\t(find_block_for_bookkeeping): Likewise.\n\t* store-motion.c (remove_reachable_equiv_notes): Likewise.\n\t(insert_store): Likewise.\n\t* trans-mem.c (ipa_tm_transform_clone): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(tm_memopt_compute_available): Remove usage of EXIT_BLOCK_PTR macro.\n\t(ipa_tm_scan_irr_function): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(gate_tm_init): Likewise.\n\t(tm_region_init): Likewise.\n\t* tree-cfg.c (execute_fixup_cfg): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(execute_warn_function_return): Remove usage of EXIT_BLOCK_PTR macro.\n\t(split_critical_edges): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(print_loops): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(move_sese_region_to_fn): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(gimple_redirect_edge_and_branch): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(gimple_verify_flow_info): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(remove_edge_and_dominated_blocks): Remove usage of EXIT_BLOCK_PTR\n\tmacro.\n\t(make_edges): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(gimple_flow_call_edges_add): Remove usage of EXIT_BLOCK_PTR macro.\n\t(make_blocks): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(build_gimple_cfg): Likewise.\n\t(gimple_duplicate_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(gimple_can_merge_blocks_p): Likewise.\n\t* tree-cfgcleanup.c (tree_forwarder_block_p): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* tree-complex.c (update_parameter_components): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* tree-if-conv.c (get_loop_body_in_if_conv_order): Remove usage of\n\tEXIT_BLOCK_PTR macro.\n\t* tree-inline.c (tree_function_versioning): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(delete_unreachable_blocks_update_callgraph): Likewise.\n\t(initialize_cfun): Likewise.\n\t(copy_cfg_body): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(copy_edges_for_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(remap_ssa_name): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* tree-into-ssa.c (update_ssa): Likewise.\n\t(maybe_register_def): Remove usage of EXIT_BLOCK_PTR macro.\n\t(insert_updated_phi_nodes_for): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(rewrite_into_ssa): Likewise.\n\t(rewrite_debug_stmt_uses): Likewise.\n\t* tree-outof-ssa.c (expand_phi_nodes): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* tree-profile.c (gimple_gen_ic_func_profiler): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* tree-scalar-evolution.h (block_before_loop): Likewise.\n\t* tree-sra.c (sra_ipa_reset_debug_stmts): Likewise.\n\t(dump_dereferences_table): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(analyze_caller_dereference_legality): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(propagate_dereference_distances): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(initialize_parameter_reductions): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t* tree-ssa-ccp.c (gsi_prev_dom_bb_nondebug): Likewise.\n\t(optimize_stack_restore): Remove usage of EXIT_BLOCK_PTR macro.\n\t* tree-ssa-coalesce.c (create_outofssa_var_map): Likewise.\n\t* tree-ssa-dce.c (eliminate_unnecessary_stmts): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(remove_dead_stmt): Remove usage of EXIT_BLOCK_PTR macro.\n\t(propagate_necessity): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(mark_control_dependent_edges_necessary): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t* tree-ssa-dom.c (eliminate_degenerate_phis): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(tree_ssa_dominator_optimize): Remove usage of EXIT_BLOCK_PTR macro.\n\t* tree-ssa-live.c (verify_live_on_entry): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(calculate_live_on_exit): Likewise.\n\t(set_var_live_on_entry): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(loe_visit_block): Likewise.\n\t* tree-ssa-live.h (live_on_exit): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(live_on_entry): Likewise.\n\t* tree-ssa-loop-ivopts.c (find_interesting_uses): Remove usage of\n\tEXIT_BLOCK_PTR macro.\n\t* tree-ssa-loop-manip.c (compute_live_loop_exits): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* tree-ssa-loop-niter.c (simplify_using_initial_conditions): Likewise.\n\t(bound_difference): Likewise.\n\t* tree-ssa-loop-prefetch.c (may_use_storent_in_loop_p): Remove usage\n\tof EXIT_BLOCK_PTR macro.\n\t* tree-ssa-loop-unswitch.c (simplify_using_entry_checks): Remove usage\n\tof ENTRY_BLOCK_PTR macro.\n\t* tree-ssa-math-opts.c (register_division_in): Likewise.\n\t* tree-ssa-phiprop.c (tree_ssa_phiprop): Likewise.\n\t* tree-ssa-pre.c (compute_avail): Likewise.\n\t(compute_antic): Remove usage of EXIT_BLOCK_PTR macro.\n\t(insert): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* tree-ssa-propagate.c (ssa_prop_init): Likewise.\n\t(simulate_block): Remove usage of EXIT_BLOCK_PTR macro.\n\t(cfg_blocks_add): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t(add_control_edge): Remove usage of EXIT_BLOCK_PTR macro.\n\t* tree-ssa-reassoc.c (do_reassoc): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(build_and_add_sum): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* tree-ssa-sink.c (nearest_common_dominator_of_uses): Likewise.\n\t(execute_sink_code): Remove usage of EXIT_BLOCK_PTR macro.\n\t* tree-ssa-uninit.c (find_dom): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(compute_control_dep_chain): Remove usage of EXIT_BLOCK_PTR macro.\n\t(find_pdom): Likewise.\n\t(warn_uninitialized_vars): Remove usage of ENTRY_BLOCK_PTR macro.\n\t* tree-stdarg.c (reachable_at_most_once): Likewise.\n\t* tree-tailcall.c (tree_optimize_tail_calls_1): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(eliminate_tail_call): Likewise.\n\t* tsan.c (instrument_func_entry): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t(instrument_func_exit): Remove usage of EXIT_BLOCK_PTR macro.\n\t* var-tracking.c (vt_initialize): Remove uses of macros:\n\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n\t(vt_add_function_parameter): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(vt_find_locations): Remove usage of EXIT_BLOCK_PTR macro.\n\t(vt_stack_adjustments): Remove uses of macros: ENTRY_BLOCK_PTR,\n\tEXIT_BLOCK_PTR.\n\t* varasm.c (assemble_start_function): Remove usage of ENTRY_BLOCK_PTR\n\tmacro.\n\t* config/bfin/bfin.c (hwloop_optimize): Likewise.\n\t* config/nds32/nds32.c (nds32_fp_as_gp_check_available): Remove usage\n\tof EXIT_BLOCK_PTR macro.\n\t* config/arm/arm.c (require_pic_register): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t(arm_r3_live_at_start_p): Likewise.\n\t(any_sibcall_could_use_r3): Remove usage of EXIT_BLOCK_PTR macro.\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n\t* config/frv/frv.c (frv_optimize_membar_global): Likewise.\n\t* config/alpha/alpha.c (alpha_gp_save_rtx): Remove usage of\n\tENTRY_BLOCK_PTR macro.\n\t* config/i386/i386.c (ix86_count_insn): Likewise.\n\t(ix86_seh_fixup_eh_fallthru): Remove usage of EXIT_BLOCK_PTR macro.\n\t(ix86_pad_short_function): Likewise.\n\t(ix86_compute_frame_layout): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(ix86_pad_returns): Remove usage of EXIT_BLOCK_PTR macro.\n\t(ix86_eax_live_at_start_p): Remove usage of ENTRY_BLOCK_PTR macro.\n\t(add_condition_to_bb): Remove usage of EXIT_BLOCK_PTR macro.\n\t(ix86_expand_epilogue): Likewise.\n\t* config/ia64/ia64.c (ia64_asm_unwind_emit): Likewise.\n\t(ia64_expand_prologue): Likewise.\n\nFrom-SVN: r205055", "tree": {"sha": "bf62fc2c600b2a991c83dcc24f3f71c115154851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf62fc2c600b2a991c83dcc24f3f71c115154851"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fefa31b568664d9efb6257a35ae7b014766faa69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fefa31b568664d9efb6257a35ae7b014766faa69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fefa31b568664d9efb6257a35ae7b014766faa69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fefa31b568664d9efb6257a35ae7b014766faa69/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "faaa3afb19f2e58947f96c7282331403d2e644b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faaa3afb19f2e58947f96c7282331403d2e644b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faaa3afb19f2e58947f96c7282331403d2e644b2"}], "stats": {"total": 2222, "additions": 1431, "deletions": 791}, "files": [{"sha": "f06ccfbd8adca0720ca5f10f86eb3e2aad728fbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1,3 +1,520 @@\n+2013-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* basic-block.h (ENTRY_BLOCK_PTR_FOR_FUNCTION): Rename macro to...\n+\t(EXIT_BLOCK_PTR_FOR_FUNCTION): ...this.\n+\t(ENTRY_BLOCK_PTR_FOR_FN): Renamed macro to...\n+\t(EXIT_BLOCK_PTR_FOR_FN): ...this.\n+\t(ENTRY_BLOCK_PTR): Eliminate macro as work towards making uses of\n+\tcfun be explicit.\n+\t(EXIT_BLOCK_PTR): Likewise.\n+\t(FOR_ALL_BB): Rework for now to eliminate use of \"ENTRY_BLOCK_PTR\".\n+\t(FOR_ALL_BB_FN): Update for renaming of\n+\t\"ENTRY_BLOCK_PTR_FOR_FUNCTION\" to \"ENTRY_BLOCK_PTR_FOR_FN\".\n+\n+\t* cfg.c (init_flow): Likewise.\n+\t(check_bb_profile): Likewise.\n+\t* cfganal.c (pre_and_rev_post_order_compute_fn): Likewise.\n+\t* cfgcleanup.c (walk_to_nondebug_insn): Likewise.\n+\t* cfghooks.c (account_profile_record): Likewise.\n+\t* cfgloop.c (init_loops_structure): Likewise.\n+\t* cgraphbuild.c (record_eh_tables): Likewise.\n+\t(compute_call_stmt_bb_frequency): Likewise.\n+\t* ipa-inline-analysis.c (compute_bb_predicates): Likewise.\n+\t* lto-streamer-in.c (input_cfg): Likewise.\n+\t* predict.c (maybe_hot_frequency_p): Likewise.\n+\t* tree-cfg.c (init_empty_tree_cfg_for_function): Likewise.\n+\t* tree-inline.c (initialize_cfun): Likewise.\n+\t(copy_cfg_body): Likewise.\n+\t(copy_body): Likewise.\n+\t(tree_function_versioning): Likewise.\n+\n+\t* bb-reorder.c (add_labels_and_missing_jumps): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(duplicate_computed_gotos): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): Remove uses of\n+\tmacros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(connect_traces): Likewise.\n+\t(rest_of_handle_reorder_blocks): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(bb_to_key): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(fix_crossing_conditional_branches): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t(find_traces_1_round): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(fix_up_fall_thru_edges): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(find_traces): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(fix_up_crossing_landing_pad): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(rotate_loop): Likewise.\n+\t* bt-load.c (migrate_btr_def): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* cfg.c (clear_aux_for_edges): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(alloc_aux_for_edges): Likewise.\n+\t(clear_bb_flags): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(cached_make_edge): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(compact_blocks): Likewise.\n+\t(clear_edges): Likewise.\n+\t* cfganal.c (single_pred_before_succ_order): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(bitmap_union_of_succs): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(bitmap_union_of_preds): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(bitmap_intersection_of_succs): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(bitmap_intersection_of_preds): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(inverted_post_order_compute): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(compute_dominance_frontiers_1): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(post_order_compute): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(connect_infinite_loops_to_exit): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t(remove_fake_edges): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(add_noreturn_fake_exit_edges): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(find_pdom): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(remove_fake_exit_edges): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(verify_edge_list): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(print_edge_list): Likewise.\n+\t(create_edge_list): Likewise.\n+\t(find_unreachable_blocks): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(mark_dfs_back_edges): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t* cfgbuild.c (find_bb_boundaries): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(find_many_sub_basic_blocks): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(make_edges): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* cfgcleanup.c (delete_unreachable_blocks): Likewise.\n+\t(try_optimize_cfg): Likewise.\n+\t(try_head_merge_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(try_crossjump_to_edge): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(try_crossjump_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(merge_blocks_move): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(outgoing_edges_match): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(try_forward_edges): Likewise.\n+\t(try_simplify_condjump): Likewise.\n+\t* cfgexpand.c (gimple_expand_cfg): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(construct_exit_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(construct_init_block): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(expand_gimple_basic_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(expand_gimple_tailcall): Likewise.\n+\t* cfghooks.c (can_duplicate_block_p): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(tidy_fallthru_edges): Likewise.\n+\t(verify_flow_info): Likewise.\n+\t* cfgloop.c (flow_bb_inside_loop_p): Likewise.\n+\t(num_loop_branches): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(disambiguate_multiple_latches): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(get_loop_exit_edges): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(bb_loop_header_p): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(get_loop_body_in_bfs_order): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(get_loop_body_in_dom_order): Likewise.\n+\t(get_loop_body): Likewise.\n+\t* cfgloopanal.c (mark_irreducible_loops): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* cfgloopmanip.c (create_preheader): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(remove_path): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(fix_bb_placement): Likewise.\n+\t* cfgrtl.c (rtl_block_empty_p): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(rtl_can_remove_branch_p): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(cfg_layout_split_edge): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(rtl_flow_call_edges_add): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(cfg_layout_can_merge_blocks_p): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(cfg_layout_redirect_edge_and_branch): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(fixup_fallthru_exit_predecessor): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(fixup_reorder_chain): Likewise.\n+\t(relink_block_chain): Likewise.\n+\t(cfg_layout_delete_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(rtl_verify_bb_layout): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(cfg_layout_duplicate_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(force_one_exit_fallthru): Likewise.\n+\t(rtl_verify_fallthru): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(rtl_verify_edges): Likewise.\n+\t(commit_edge_insertions): Likewise.\n+\t(commit_one_edge_insertion): Likewise.\n+\t(rtl_split_edge): Likewise.\n+\t(force_nonfallthru_and_redirect): Likewise.\n+\t(outof_cfg_layout_mode): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(skip_insns_after_block): Likewise.\n+\t(fixup_partition_crossing): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(purge_dead_edges): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(rtl_can_merge_blocks): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(contains_no_active_insn_p): Likewise.\n+\t(emit_insn_at_entry): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(entry_of_function): Likewise.\n+\t(last_bb_in_partition): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(fixup_new_cold_bb): Likewise.\n+\t(patch_jump_insn): Likewise.\n+\t(try_redirect_by_replacing_jump): Likewise.\n+\t(block_label): Likewise.\n+\t(could_fall_through): Likewise.\n+\t(can_fallthru): Likewise.\n+\t* cgraphbuild.c (cgraph_rebuild_references): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(rebuild_cgraph_edges): Likewise.\n+\t* cgraphunit.c (init_lowered_empty_function): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(expand_thunk): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* combine.c (get_last_value): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(distribute_links): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(get_last_value_validate): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(try_combine): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(reg_num_sign_bit_copies_for_combine): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(reg_nonzero_bits_for_combine): Likewise.\n+\t(set_nonzero_bits_and_sign_copies): Likewise.\n+\t(combine_instructions): Likewise.\n+\t* cprop.c (one_cprop_pass): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(bypass_conditional_jumps): Likewise.\n+\t(bypass_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(find_implicit_sets): Likewise.\n+\t(cprop_jump): Likewise.\n+\t* cse.c (cse_cc_succs): Likewise.\n+\t(cse_find_path): Likewise.\n+\t* df-problems.c (df_lr_confluence_0): Likewise.\n+\t* df-scan.c (df_entry_block_defs_collect): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(df_exit_block_uses_collect): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* dominance.c (iterate_fix_dominators): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(calc_idoms): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(determine_dominators_for_sons): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(calc_dfs_tree): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(prune_bbs_to_update_dominators): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(calc_dfs_tree_nonrec): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t* domwalk.c (cmp_bb_postorder): Likewise.\n+\t* dse.c (dse_step1): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* except.c (finish_eh_generation): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(sjlj_emit_function_enter): Likewise.\n+\t* final.c (compute_alignments): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Remove uses of\n+\tmacros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(reposition_prologue_and_epilogue_notes): Remove usage of\n+\tEXIT_BLOCK_PTR macro.\n+\t(convert_jumps_to_returns): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(regno_clobbered_at_setjmp): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(next_block_for_reg): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* gcse.c (hoist_code): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(update_bb_reg_pressure): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(compute_code_hoist_vbeinout): Likewise.\n+\t(should_hoist_expr_to_dom): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(pre_expr_reaches_here_p_work): Likewise.\n+\t* gimple-iterator.c (gsi_commit_edge_inserts): Likewise.\n+\t(gimple_find_edge_insert_loc): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t* gimple-ssa-strength-reduction.c (slsr_process_phi): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* graph.c (draw_cfg_nodes_for_loop): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t* graphite-clast-to-gimple.c (translate_clast_user): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* graphite-scop-detection.c (build_scops): Likewise.\n+\t(create_sese_edges): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(scopdet_basic_block_info): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* haifa-sched.c (restore_bb_notes): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t(unlink_bb_notes): Likewise.\n+\t(create_check_block_twin): Likewise.\n+\t(init_before_recovery): Likewise.\n+\t(sched_extend_bb): Likewise.\n+\t(priority): Likewise.\n+\t* hw-doloop.c (reorder_loops): Likewise.\n+\t(discover_loop): Likewise.\n+\t* ifcvt.c (dead_or_predicable): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(find_if_case_1): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(block_has_only_trap): Likewise.\n+\t(cond_exec_find_if_block): Likewise.\n+\t(merge_if_block): Likewise.\n+\t* ipa-inline-analysis.c (param_change_prob): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(record_modified): Likewise.\n+\t* ipa-pure-const.c (execute_warn_function_noreturn): Remove usage of\n+\tEXIT_BLOCK_PTR macro.\n+\t(local_pure_const): Likewise.\n+\t* ipa-split.c (split_function): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(find_split_points): Likewise.\n+\t(consider_split): Likewise.\n+\t(find_return_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(verify_non_ssa_vars): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* ira-build.c (ira_loop_tree_body_rev_postorder): Likewise.\n+\t* ira-color.c (print_loop_title): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t* ira-emit.c (entered_from_non_parent_p): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(ira_emit): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* ira-int.h (ira_assert): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* ira.c (split_live_ranges_for_shrink_wrap): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* lcm.c (compute_rev_insert_delete): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(compute_nearerout): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(compute_farthest): Likewise.\n+\t(compute_available): Likewise.\n+\t(compute_insert_delete): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(compute_laterin): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(compute_earliest): Likewise.\n+\t(compute_antinout_edge): Likewise.\n+\t* loop-iv.c (simplify_using_initial_values): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* loop-unswitch.c (unswitch_loop): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t* lra-assigns.c (find_hard_regno_for): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t* lra-constraints.c (lra_inheritance): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t* lra-lives.c (lra_create_live_ranges): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* lra.c (has_nonexceptional_receiver): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t* lto-streamer-in.c (input_function): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t* lto-streamer-out.c (output_cfg): Likewise.\n+\t* mcf.c (adjust_cfg_counts): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(create_fixup_graph): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* mode-switching.c (optimize_mode_switching): Likewise.\n+\t(create_pre_exit): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* modulo-sched.c (rest_of_handle_sms): Likewise.\n+\t(canon_loop): Likewise.\n+\t* omp-low.c (build_omp_regions): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t* postreload-gcse.c (eliminate_partially_redundant_loads): Remove uses\n+\tof macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* predict.c (rebuild_frequencies): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(propagate_freq): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(estimate_bb_frequencies): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(tree_estimate_probability_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(expensive_function_p): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(tree_bb_level_predictions): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(counts_to_freqs): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(apply_return_prediction): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(estimate_loops): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(gimple_predict_edge): Likewise.\n+\t(probably_never_executed): Likewise.\n+\t* profile.c (find_spanning_tree): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(branch_prob): Likewise.\n+\t(compute_branch_probabilities): Likewise.\n+\t(compute_frequency_overlap): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(is_inconsistent): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(read_profile_edge_counts): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(set_bb_counts): Likewise.\n+\t(correct_negative_edge_counts): Likewise.\n+\t(get_exec_counts): Likewise.\n+\t(instrument_values): Likewise.\n+\t(instrument_edges): Likewise.\n+\t* reg-stack.c (convert_regs): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(compensate_edges): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(convert_regs_exit): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(convert_regs_entry): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(reg_to_stack): Likewise.\n+\t* regs.h (REG_N_SETS): Likewise.\n+\t* reload.c (find_dummy_reload): Likewise.\n+\t(combine_reloads): Likewise.\n+\t(push_reload): Likewise.\n+\t* reload1.c (has_nonexceptional_receiver): Remove usage of\n+\tEXIT_BLOCK_PTR macro.\n+\t* resource.c (mark_target_live_regs): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(find_basic_block): Likewise.\n+\t* sched-ebb.c (ebb_add_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(schedule_ebbs): Likewise.\n+\t* sched-int.h (sel_sched_p): Likewise.\n+\t* sched-rgn.c (compute_dom_prob_ps): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(rgn_add_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(haifa_find_rgns): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(propagate_deps): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(extend_rgns): Likewise.\n+\t(find_single_block_region): Likewise.\n+\t* sel-sched-ir.c (sel_remove_loop_preheader): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(setup_nop_and_exit_insns): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(sel_create_recovery_block): Likewise.\n+\t(bb_ends_ebb_p): Likewise.\n+\t(sel_bb_end): Likewise.\n+\t(sel_bb_head): Likewise.\n+\t(free_lv_sets): Likewise.\n+\t(init_lv_sets): Likewise.\n+\t(tidy_control_flow): Likewise.\n+\t(maybe_tidy_empty_bb): Likewise.\n+\t* sel-sched-ir.h (_succ_iter_cond): Likewise.\n+\t(_succ_iter_start): Likewise.\n+\t(sel_bb_empty_or_nop_p): Likewise.\n+\t(get_loop_exit_edges_unique_dests): Likewise.\n+\t(inner_loop_header_p): Likewise.\n+\t* sel-sched.c (create_block_for_bookkeeping): Likewise.\n+\t(find_block_for_bookkeeping): Likewise.\n+\t* store-motion.c (remove_reachable_equiv_notes): Likewise.\n+\t(insert_store): Likewise.\n+\t* trans-mem.c (ipa_tm_transform_clone): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(tm_memopt_compute_available): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(ipa_tm_scan_irr_function): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(gate_tm_init): Likewise.\n+\t(tm_region_init): Likewise.\n+\t* tree-cfg.c (execute_fixup_cfg): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(execute_warn_function_return): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(split_critical_edges): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(print_loops): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(move_sese_region_to_fn): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(gimple_redirect_edge_and_branch): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(gimple_verify_flow_info): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(remove_edge_and_dominated_blocks): Remove usage of EXIT_BLOCK_PTR\n+\tmacro.\n+\t(make_edges): Remove uses of macros: ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(gimple_flow_call_edges_add): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(make_blocks): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(build_gimple_cfg): Likewise.\n+\t(gimple_duplicate_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(gimple_can_merge_blocks_p): Likewise.\n+\t* tree-cfgcleanup.c (tree_forwarder_block_p): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* tree-complex.c (update_parameter_components): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* tree-if-conv.c (get_loop_body_in_if_conv_order): Remove usage of\n+\tEXIT_BLOCK_PTR macro.\n+\t* tree-inline.c (tree_function_versioning): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(delete_unreachable_blocks_update_callgraph): Likewise.\n+\t(initialize_cfun): Likewise.\n+\t(copy_cfg_body): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(copy_edges_for_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(remap_ssa_name): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* tree-into-ssa.c (update_ssa): Likewise.\n+\t(maybe_register_def): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(insert_updated_phi_nodes_for): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(rewrite_into_ssa): Likewise.\n+\t(rewrite_debug_stmt_uses): Likewise.\n+\t* tree-outof-ssa.c (expand_phi_nodes): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* tree-profile.c (gimple_gen_ic_func_profiler): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* tree-scalar-evolution.h (block_before_loop): Likewise.\n+\t* tree-sra.c (sra_ipa_reset_debug_stmts): Likewise.\n+\t(dump_dereferences_table): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(analyze_caller_dereference_legality): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(propagate_dereference_distances): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(initialize_parameter_reductions): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t* tree-ssa-ccp.c (gsi_prev_dom_bb_nondebug): Likewise.\n+\t(optimize_stack_restore): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* tree-ssa-coalesce.c (create_outofssa_var_map): Likewise.\n+\t* tree-ssa-dce.c (eliminate_unnecessary_stmts): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(remove_dead_stmt): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(propagate_necessity): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(mark_control_dependent_edges_necessary): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t* tree-ssa-dom.c (eliminate_degenerate_phis): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(tree_ssa_dominator_optimize): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* tree-ssa-live.c (verify_live_on_entry): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(calculate_live_on_exit): Likewise.\n+\t(set_var_live_on_entry): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(loe_visit_block): Likewise.\n+\t* tree-ssa-live.h (live_on_exit): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(live_on_entry): Likewise.\n+\t* tree-ssa-loop-ivopts.c (find_interesting_uses): Remove usage of\n+\tEXIT_BLOCK_PTR macro.\n+\t* tree-ssa-loop-manip.c (compute_live_loop_exits): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* tree-ssa-loop-niter.c (simplify_using_initial_conditions): Likewise.\n+\t(bound_difference): Likewise.\n+\t* tree-ssa-loop-prefetch.c (may_use_storent_in_loop_p): Remove usage\n+\tof EXIT_BLOCK_PTR macro.\n+\t* tree-ssa-loop-unswitch.c (simplify_using_entry_checks): Remove usage\n+\tof ENTRY_BLOCK_PTR macro.\n+\t* tree-ssa-math-opts.c (register_division_in): Likewise.\n+\t* tree-ssa-phiprop.c (tree_ssa_phiprop): Likewise.\n+\t* tree-ssa-pre.c (compute_avail): Likewise.\n+\t(compute_antic): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(insert): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* tree-ssa-propagate.c (ssa_prop_init): Likewise.\n+\t(simulate_block): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(cfg_blocks_add): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t(add_control_edge): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* tree-ssa-reassoc.c (do_reassoc): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(build_and_add_sum): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* tree-ssa-sink.c (nearest_common_dominator_of_uses): Likewise.\n+\t(execute_sink_code): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* tree-ssa-uninit.c (find_dom): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(compute_control_dep_chain): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(find_pdom): Likewise.\n+\t(warn_uninitialized_vars): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t* tree-stdarg.c (reachable_at_most_once): Likewise.\n+\t* tree-tailcall.c (tree_optimize_tail_calls_1): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(eliminate_tail_call): Likewise.\n+\t* tsan.c (instrument_func_entry): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t(instrument_func_exit): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* var-tracking.c (vt_initialize): Remove uses of macros:\n+\tENTRY_BLOCK_PTR, EXIT_BLOCK_PTR.\n+\t(vt_add_function_parameter): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(vt_find_locations): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(vt_stack_adjustments): Remove uses of macros: ENTRY_BLOCK_PTR,\n+\tEXIT_BLOCK_PTR.\n+\t* varasm.c (assemble_start_function): Remove usage of ENTRY_BLOCK_PTR\n+\tmacro.\n+\t* config/bfin/bfin.c (hwloop_optimize): Likewise.\n+\t* config/nds32/nds32.c (nds32_fp_as_gp_check_available): Remove usage\n+\tof EXIT_BLOCK_PTR macro.\n+\t* config/arm/arm.c (require_pic_register): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t(arm_r3_live_at_start_p): Likewise.\n+\t(any_sibcall_could_use_r3): Remove usage of EXIT_BLOCK_PTR macro.\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n+\t* config/frv/frv.c (frv_optimize_membar_global): Likewise.\n+\t* config/alpha/alpha.c (alpha_gp_save_rtx): Remove usage of\n+\tENTRY_BLOCK_PTR macro.\n+\t* config/i386/i386.c (ix86_count_insn): Likewise.\n+\t(ix86_seh_fixup_eh_fallthru): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(ix86_pad_short_function): Likewise.\n+\t(ix86_compute_frame_layout): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(ix86_pad_returns): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(ix86_eax_live_at_start_p): Remove usage of ENTRY_BLOCK_PTR macro.\n+\t(add_condition_to_bb): Remove usage of EXIT_BLOCK_PTR macro.\n+\t(ix86_expand_epilogue): Likewise.\n+\t* config/ia64/ia64.c (ia64_asm_unwind_emit): Likewise.\n+\t(ia64_expand_prologue): Likewise.\n+\n 2013-11-19  Catherine Moore  <clm@codesourcery.com>\n \n \t* doc/invoke.texi (mfix-rm7000, mno-fix-rm7000): Document."}, {"sha": "58bacc33f879a48e14244e2c2fc0160a848ea9d7", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -312,8 +312,8 @@ struct GTY(()) control_flow_graph {\n };\n \n /* Defines for accessing the fields of the CFG structure for function FN.  */\n-#define ENTRY_BLOCK_PTR_FOR_FUNCTION(FN)     ((FN)->cfg->x_entry_block_ptr)\n-#define EXIT_BLOCK_PTR_FOR_FUNCTION(FN)\t     ((FN)->cfg->x_exit_block_ptr)\n+#define ENTRY_BLOCK_PTR_FOR_FN(FN)\t     ((FN)->cfg->x_entry_block_ptr)\n+#define EXIT_BLOCK_PTR_FOR_FN(FN)\t     ((FN)->cfg->x_exit_block_ptr)\n #define basic_block_info_for_function(FN)    ((FN)->cfg->x_basic_block_info)\n #define n_basic_blocks_for_fn(FN)\t     ((FN)->cfg->x_n_basic_blocks)\n #define n_edges_for_fn(FN)\t\t     ((FN)->cfg->x_n_edges)\n@@ -327,8 +327,6 @@ struct GTY(()) control_flow_graph {\n   ((*basic_block_info_for_function (FN))[(N)] = (BB))\n \n /* Defines for textual backward source compatibility.  */\n-#define ENTRY_BLOCK_PTR\t\t(cfun->cfg->x_entry_block_ptr)\n-#define EXIT_BLOCK_PTR\t\t(cfun->cfg->x_exit_block_ptr)\n #define basic_block_info\t(cfun->cfg->x_basic_block_info)\n #define last_basic_block\t(cfun->cfg->x_last_basic_block)\n #define label_to_block_map\t(cfun->cfg->x_label_to_block_map)\n@@ -378,10 +376,10 @@ struct GTY(()) control_flow_graph {\n    exit block).  */\n \n #define FOR_ALL_BB(BB) \\\n-  for (BB = ENTRY_BLOCK_PTR; BB; BB = BB->next_bb)\n+  for (BB = ENTRY_BLOCK_PTR_FOR_FN (cfun); BB; BB = BB->next_bb)\n \n #define FOR_ALL_BB_FN(BB, FN) \\\n-  for (BB = ENTRY_BLOCK_PTR_FOR_FUNCTION (FN); BB; BB = BB->next_bb)\n+  for (BB = ENTRY_BLOCK_PTR_FOR_FN (FN); BB; BB = BB->next_bb)\n \n \f\n /* Stuff for recording basic block info.  */"}, {"sha": "fc7b5b758eaf60004bd1a666a02bf4220a2114f3", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -275,7 +275,7 @@ find_traces (int *n_traces, struct trace *traces)\n   heap = fibheap_new ();\n   max_entry_frequency = 0;\n   max_entry_count = 0;\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     {\n       bbd[e->dest->index].heap = heap;\n       bbd[e->dest->index].node = fibheap_insert (heap, bb_to_key (e->dest),\n@@ -348,7 +348,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n       edge_iterator ei;\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t    && bb_visited_trace (e->dest) != trace_n\n \t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t    && !(e->flags & EDGE_COMPLEX))\n@@ -524,7 +524,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t    {\n \t      gcc_assert (!(e->flags & EDGE_FAKE));\n \n-\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\tcontinue;\n \n \t      if (bb_visited_trace (e->dest)\n@@ -605,7 +605,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      if (e == best_edge\n-\t\t  || e->dest == EXIT_BLOCK_PTR\n+\t\t  || e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  || bb_visited_trace (e->dest))\n \t\tcontinue;\n \n@@ -680,7 +680,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t     header is not the first block of the function\n \t\t\t     we can rotate the loop.  */\n \n-\t\t\t  if (best_edge->dest != ENTRY_BLOCK_PTR->next_bb)\n+\t\t\t  if (best_edge->dest\n+\t\t\t      != ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb)\n \t\t\t    {\n \t\t\t      if (dump_file)\n \t\t\t\t{\n@@ -776,7 +777,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t is an end of the trace).  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  if (e->dest == EXIT_BLOCK_PTR\n+\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      || bb_visited_trace (e->dest))\n \t    continue;\n \n@@ -885,7 +886,8 @@ bb_to_key (basic_block bb)\n      or whose predecessor edge is EDGE_DFS_BACK.  */\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      if ((e->src != ENTRY_BLOCK_PTR && bbd[e->src->index].end_of_trace >= 0)\n+      if ((e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t   && bbd[e->src->index].end_of_trace >= 0)\n \t  || (e->flags & EDGE_DFS_BACK))\n \t{\n \t  int edge_freq = EDGE_FREQUENCY (e);\n@@ -1098,7 +1100,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t    {\n \t      int si = e->src->index;\n \n-\t      if (e->src != ENTRY_BLOCK_PTR\n+\t      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && (e->flags & EDGE_CAN_FALLTHRU)\n \t\t  && !(e->flags & EDGE_COMPLEX)\n \t\t  && bbd[si].end_of_trace >= 0\n@@ -1141,7 +1143,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t    {\n \t      int di = e->dest->index;\n \n-\t      if (e->dest != EXIT_BLOCK_PTR\n+\t      if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && (e->flags & EDGE_CAN_FALLTHRU)\n \t\t  && !(e->flags & EDGE_COMPLEX)\n \t\t  && bbd[di].start_of_trace >= 0\n@@ -1212,7 +1214,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t      bool try_copy = false;\n \n \t      FOR_EACH_EDGE (e, ei, traces[t].last->succs)\n-\t\tif (e->dest != EXIT_BLOCK_PTR\n+\t\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t\t    && !(e->flags & EDGE_COMPLEX)\n \t\t    && (!best || e->probability > best->probability))\n@@ -1237,7 +1239,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t      {\n \t\t\tint di = e2->dest->index;\n \n-\t\t\tif (e2->dest == EXIT_BLOCK_PTR\n+\t\t\tif (e2->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t    || ((e2->flags & EDGE_CAN_FALLTHRU)\n \t\t\t\t&& !(e2->flags & EDGE_COMPLEX)\n \t\t\t\t&& bbd[di].start_of_trace >= 0\n@@ -1253,7 +1255,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t  {\n \t\t\t    best = e;\n \t\t\t    best2 = e2;\n-\t\t\t    if (e2->dest != EXIT_BLOCK_PTR)\n+\t\t\t    if (e2->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t\t      best2_len = traces[bbd[di].start_of_trace].length;\n \t\t\t    else\n \t\t\t      best2_len = INT_MAX;\n@@ -1282,15 +1284,15 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t       traces[t].last->index, best->dest->index);\n \t\t      if (!next_bb)\n \t\t\tfputc ('\\n', dump_file);\n-\t\t      else if (next_bb == EXIT_BLOCK_PTR)\n+\t\t      else if (next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t\tfprintf (dump_file, \"exit\\n\");\n \t\t      else\n \t\t\tfprintf (dump_file, \"%d\\n\", next_bb->index);\n \t\t    }\n \n \t\t  new_bb = copy_bb (best->dest, best, traces[t].last, t);\n \t\t  traces[t].last = new_bb;\n-\t\t  if (next_bb && next_bb != EXIT_BLOCK_PTR)\n+\t\t  if (next_bb && next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t    {\n \t\t      t = bbd[next_bb->index].start_of_trace;\n \t\t      traces[last_trace].last->aux = traces[t].first;\n@@ -1413,7 +1415,7 @@ fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n   JUMP_LABEL (jump) = post_label;\n \n   /* Create new basic block to be dest for lp.  */\n-  last_bb = EXIT_BLOCK_PTR->prev_bb;\n+  last_bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n   new_bb = create_basic_block (new_label, jump, last_bb);\n   new_bb->aux = last_bb->aux;\n   last_bb->aux = new_bb;\n@@ -1663,8 +1665,8 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n         /* We should never have EDGE_CROSSING set yet.  */\n \tgcc_checking_assert ((flags & EDGE_CROSSING) == 0);\n \n-\tif (e->src != ENTRY_BLOCK_PTR\n-\t    && e->dest != EXIT_BLOCK_PTR\n+\tif (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t    && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t    && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n \t  {\n \t    crossing_edges.safe_push (e);\n@@ -1731,14 +1733,14 @@ add_labels_and_missing_jumps (vec<edge> crossing_edges)\n       basic_block dest = e->dest;\n       rtx label, new_jump;\n \n-      if (dest == EXIT_BLOCK_PTR)\n+      if (dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       /* Make sure dest has a label.  */\n       label = block_label (dest);\n \n       /* Nothing to do for non-fallthru edges.  */\n-      if (src == ENTRY_BLOCK_PTR)\n+      if (src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n       if ((e->flags & EDGE_FALLTHRU) == 0)\n \tcontinue;\n@@ -1832,7 +1834,7 @@ fix_up_fall_thru_edges (void)\n \t      }\n \t}\n \n-      if (fall_thru && (fall_thru->dest != EXIT_BLOCK_PTR))\n+      if (fall_thru && (fall_thru->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)))\n \t{\n \t  /* Check to see if the fall-thru edge is a crossing edge.  */\n \n@@ -2066,7 +2068,7 @@ fix_crossing_conditional_branches (void)\n \t\t  new_jump = emit_jump_insn (gen_jump (old_label));\n \t\t  JUMP_LABEL (new_jump) = old_label;\n \n-\t\t  last_bb = EXIT_BLOCK_PTR->prev_bb;\n+\t\t  last_bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n \t\t  new_bb = create_basic_block (new_label, new_jump, last_bb);\n \t\t  new_bb->aux = last_bb->aux;\n \t\t  last_bb->aux = new_bb;\n@@ -2319,7 +2321,7 @@ rest_of_handle_reorder_blocks (void)\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n \n   FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n+    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n       bb->aux = bb->next_bb;\n   cfg_layout_finalize ();\n \n@@ -2415,7 +2417,7 @@ duplicate_computed_gotos (void)\n       int size, all_flags;\n \n       /* Build the reorder chain for the original order of blocks.  */\n-      if (bb->next_bb != EXIT_BLOCK_PTR)\n+      if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tbb->aux = bb->next_bb;\n \n       /* Obviously the block has to end in a computed jump.  */\n@@ -2465,7 +2467,7 @@ duplicate_computed_gotos (void)\n \t the exit block or the next block.\n \t The destination must have more than one predecessor.  */\n       if (!single_succ_p (bb)\n-\t  || single_succ (bb) == EXIT_BLOCK_PTR\n+\t  || single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  || single_succ (bb) == bb->next_bb\n \t  || single_pred_p (single_succ (bb)))\n \tcontinue;"}, {"sha": "09eea06e379868e877754f5a9ceefaf79e9e16ac", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1328,7 +1328,8 @@ migrate_btr_def (btr_def def, int min_cost)\n   def_basic_block_freq = basic_block_freq (def->bb);\n \n   for (attempt = get_immediate_dominator (CDI_DOMINATORS, def->bb);\n-       !give_up && attempt && attempt != ENTRY_BLOCK_PTR && def->cost >= min_cost;\n+       !give_up && attempt && attempt != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+       && def->cost >= min_cost;\n        attempt = get_immediate_dominator (CDI_DOMINATORS, attempt))\n     {\n       /* Try to move the instruction that sets the target register into"}, {"sha": "e35eee9a9bcd803b090822c89392c164c7915ec8", "filename": "gcc/cfg.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -70,16 +70,16 @@ init_flow (struct function *the_fun)\n   if (!the_fun->cfg)\n     the_fun->cfg = ggc_alloc_cleared_control_flow_graph ();\n   n_edges_for_fn (the_fun) = 0;\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)\n+  ENTRY_BLOCK_PTR_FOR_FN (the_fun)\n     = ggc_alloc_cleared_basic_block_def ();\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)->index = ENTRY_BLOCK;\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)\n+  ENTRY_BLOCK_PTR_FOR_FN (the_fun)->index = ENTRY_BLOCK;\n+  EXIT_BLOCK_PTR_FOR_FN (the_fun)\n     = ggc_alloc_cleared_basic_block_def ();\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)->index = EXIT_BLOCK;\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)->next_bb\n-    = EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun);\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)->prev_bb\n-    = ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun);\n+  EXIT_BLOCK_PTR_FOR_FN (the_fun)->index = EXIT_BLOCK;\n+  ENTRY_BLOCK_PTR_FOR_FN (the_fun)->next_bb\n+    = EXIT_BLOCK_PTR_FOR_FN (the_fun);\n+  EXIT_BLOCK_PTR_FOR_FN (the_fun)->prev_bb\n+    = ENTRY_BLOCK_PTR_FOR_FN (the_fun);\n }\n \f\n /* Helper function for remove_edge and clear_edges.  Frees edge structure\n@@ -109,10 +109,10 @@ clear_edges (void)\n       vec_safe_truncate (bb->preds, 0);\n     }\n \n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     free_edge (e);\n-  vec_safe_truncate (EXIT_BLOCK_PTR->preds, 0);\n-  vec_safe_truncate (ENTRY_BLOCK_PTR->succs, 0);\n+  vec_safe_truncate (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds, 0);\n+  vec_safe_truncate (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs, 0);\n \n   gcc_assert (!n_edges_for_fn (cfun));\n }\n@@ -153,8 +153,8 @@ compact_blocks (void)\n {\n   int i;\n \n-  SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n-  SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n+  SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   if (df)\n     df_compact_blocks ();\n@@ -282,8 +282,8 @@ edge\n cached_make_edge (sbitmap edge_cache, basic_block src, basic_block dst, int flags)\n {\n   if (edge_cache == NULL\n-      || src == ENTRY_BLOCK_PTR\n-      || dst == EXIT_BLOCK_PTR)\n+      || src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+      || dst == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return make_edge (src, dst, flags);\n \n   /* Does the requested edge already exist?  */\n@@ -387,7 +387,7 @@ clear_bb_flags (void)\n {\n   basic_block bb;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     bb->flags &= BB_FLAGS_TO_PRESERVE;\n }\n \f\n@@ -411,7 +411,7 @@ check_bb_profile (basic_block bb, FILE * file, int indent, int flags)\n   if (profile_status_for_function (fun) == PROFILE_ABSENT)\n     return;\n \n-  if (bb != EXIT_BLOCK_PTR_FOR_FUNCTION (fun))\n+  if (bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tsum += e->probability;\n@@ -428,7 +428,7 @@ check_bb_profile (basic_block bb, FILE * file, int indent, int flags)\n \t\t (flags & TDF_COMMENT) ? \";; \" : \"\", s_indent,\n \t\t (int) lsum, (int) bb->count);\n     }\n-    if (bb != ENTRY_BLOCK_PTR_FOR_FUNCTION (fun))\n+    if (bb != ENTRY_BLOCK_PTR_FOR_FN (fun))\n     {\n       sum = 0;\n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -641,7 +641,8 @@ alloc_aux_for_edges (int size)\n     {\n       basic_block bb;\n \n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t      EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n@@ -660,7 +661,8 @@ clear_aux_for_edges (void)\n   basic_block bb;\n   edge e;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "30376b3db4c0c555e0b4ab3163110853a8197c06", "filename": "gcc/cfganal.c", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -86,7 +86,7 @@ mark_dfs_back_edges (void)\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n \n   while (sp)\n     {\n@@ -101,7 +101,8 @@ mark_dfs_back_edges (void)\n       ei_edge (ei)->flags &= ~EDGE_DFS_BACK;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! bitmap_bit_p (visited, dest->index))\n+      if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun) && ! bitmap_bit_p (visited,\n+\t\t\t\t\t\t\t\t  dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n \t  bitmap_set_bit (visited, dest->index);\n@@ -118,12 +119,14 @@ mark_dfs_back_edges (void)\n \t}\n       else\n \t{\n-\t  if (dest != EXIT_BLOCK_PTR && src != ENTRY_BLOCK_PTR\n+\t  if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t      && src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t      && pre[src->index] >= pre[dest->index]\n \t      && post[dest->index] == 0)\n \t    ei_edge (ei)->flags |= EDGE_DFS_BACK, found = true;\n \n-\t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR)\n+\t  if (ei_one_before_end_p (ei)\n+\t      && src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    post[src->index] = postnum++;\n \n \t  if (!ei_one_before_end_p (ei))\n@@ -163,7 +166,7 @@ find_unreachable_blocks (void)\n      be only one.  It isn't inconceivable that we might one day directly\n      support Fortran alternate entry points.  */\n \n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     {\n       *tos++ = e->dest;\n \n@@ -217,7 +220,8 @@ create_edge_list (void)\n   /* Determine the number of edges in the flow graph by counting successor\n      edges on each basic block.  */\n   num_edges = 0;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       num_edges += EDGE_COUNT (bb->succs);\n     }\n@@ -229,7 +233,8 @@ create_edge_list (void)\n   num_edges = 0;\n \n   /* Follow successors of blocks, and register these edges.  */\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       elist->index_to_edge[num_edges++] = e;\n \n@@ -261,12 +266,12 @@ print_edge_list (FILE *f, struct edge_list *elist)\n   for (x = 0; x < elist->num_edges; x++)\n     {\n       fprintf (f, \" %-4d - edge(\", x);\n-      if (INDEX_EDGE_PRED_BB (elist, x) == ENTRY_BLOCK_PTR)\n+      if (INDEX_EDGE_PRED_BB (elist, x) == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tfprintf (f, \"entry,\");\n       else\n \tfprintf (f, \"%d,\", INDEX_EDGE_PRED_BB (elist, x)->index);\n \n-      if (INDEX_EDGE_SUCC_BB (elist, x) == EXIT_BLOCK_PTR)\n+      if (INDEX_EDGE_SUCC_BB (elist, x) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tfprintf (f, \"exit)\\n\");\n       else\n \tfprintf (f, \"%d)\\n\", INDEX_EDGE_SUCC_BB (elist, x)->index);\n@@ -285,7 +290,8 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n   basic_block bb, p, s;\n   edge_iterator ei;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n@@ -310,8 +316,9 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n   /* We've verified that all the edges are in the list, now lets make sure\n      there are no spurious edges in the list.  This is an expensive check!  */\n \n-  FOR_BB_BETWEEN (p, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n-    FOR_BB_BETWEEN (s, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n+  FOR_BB_BETWEEN (p, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n+    FOR_BB_BETWEEN (s, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb, NULL, next_bb)\n       {\n \tint found_edge = 0;\n \n@@ -348,9 +355,9 @@ void\n control_dependences::set_control_dependence_map_bit (basic_block bb,\n \t\t\t\t\t\t     int edge_index)\n {\n-  if (bb == ENTRY_BLOCK_PTR)\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     return;\n-  gcc_assert (bb != EXIT_BLOCK_PTR);\n+  gcc_assert (bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n   bitmap_set_bit (control_dependence_map[bb->index], edge_index);\n }\n \n@@ -367,15 +374,15 @@ control_dependences::clear_control_dependence_bitmap (basic_block bb)\n static inline basic_block\n find_pdom (basic_block block)\n {\n-  gcc_assert (block != ENTRY_BLOCK_PTR);\n+  gcc_assert (block != ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n-  if (block == EXIT_BLOCK_PTR)\n-    return EXIT_BLOCK_PTR;\n+  if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+    return EXIT_BLOCK_PTR_FOR_FN (cfun);\n   else\n     {\n       basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n       if (! bb)\n-\treturn EXIT_BLOCK_PTR;\n+\treturn EXIT_BLOCK_PTR_FOR_FN (cfun);\n       return bb;\n     }\n }\n@@ -389,15 +396,17 @@ control_dependences::find_control_dependence (int edge_index)\n   basic_block current_block;\n   basic_block ending_block;\n \n-  gcc_assert (INDEX_EDGE_PRED_BB (m_el, edge_index) != EXIT_BLOCK_PTR);\n+  gcc_assert (INDEX_EDGE_PRED_BB (m_el, edge_index)\n+\t      != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n-  if (INDEX_EDGE_PRED_BB (m_el, edge_index) == ENTRY_BLOCK_PTR)\n-    ending_block = single_succ (ENTRY_BLOCK_PTR);\n+  if (INDEX_EDGE_PRED_BB (m_el, edge_index) == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+    ending_block = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   else\n     ending_block = find_pdom (INDEX_EDGE_PRED_BB (m_el, edge_index));\n \n   for (current_block = INDEX_EDGE_SUCC_BB (m_el, edge_index);\n-       current_block != ending_block && current_block != EXIT_BLOCK_PTR;\n+       current_block != ending_block\n+       && current_block != EXIT_BLOCK_PTR_FOR_FN (cfun);\n        current_block = find_pdom (current_block))\n     {\n       edge e = INDEX_EDGE (m_el, edge_index);\n@@ -523,7 +532,7 @@ remove_fake_edges (void)\n {\n   basic_block bb;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb, NULL, next_bb)\n     remove_fake_predecessors (bb);\n }\n \n@@ -532,7 +541,7 @@ remove_fake_edges (void)\n void\n remove_fake_exit_edges (void)\n {\n-  remove_fake_predecessors (EXIT_BLOCK_PTR);\n+  remove_fake_predecessors (EXIT_BLOCK_PTR_FOR_FN (cfun));\n }\n \n \n@@ -547,7 +556,7 @@ add_noreturn_fake_exit_edges (void)\n \n   FOR_EACH_BB (bb)\n     if (EDGE_COUNT (bb->succs) == 0)\n-      make_single_succ_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+      make_single_succ_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n }\n \n /* This function adds a fake edge between any infinite loops to the\n@@ -564,14 +573,14 @@ add_noreturn_fake_exit_edges (void)\n void\n connect_infinite_loops_to_exit (void)\n {\n-  basic_block unvisited_block = EXIT_BLOCK_PTR;\n+  basic_block unvisited_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n   basic_block deadend_block;\n   struct depth_first_search_dsS dfs_ds;\n \n   /* Perform depth-first search in the reverse graph to find nodes\n      reachable from the exit block.  */\n   flow_dfs_compute_reverse_init (&dfs_ds);\n-  flow_dfs_compute_reverse_add_bb (&dfs_ds, EXIT_BLOCK_PTR);\n+  flow_dfs_compute_reverse_add_bb (&dfs_ds, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   /* Repeatedly add fake edges, updating the unreachable nodes.  */\n   while (1)\n@@ -582,7 +591,7 @@ connect_infinite_loops_to_exit (void)\n \tbreak;\n \n       deadend_block = dfs_find_deadend (unvisited_block);\n-      make_edge (deadend_block, EXIT_BLOCK_PTR, EDGE_FAKE);\n+      make_edge (deadend_block, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n       flow_dfs_compute_reverse_add_bb (&dfs_ds, deadend_block);\n     }\n \n@@ -619,7 +628,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n \n   while (sp)\n     {\n@@ -633,7 +642,8 @@ post_order_compute (int *post_order, bool include_entry_exit,\n       dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! bitmap_bit_p (visited, dest->index))\n+      if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t  && ! bitmap_bit_p (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n \t  bitmap_set_bit (visited, dest->index);\n@@ -647,7 +657,8 @@ post_order_compute (int *post_order, bool include_entry_exit,\n \t}\n       else\n \t{\n-\t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR)\n+\t  if (ei_one_before_end_p (ei)\n+\t      && src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    post_order[post_order_num++] = src->index;\n \n \t  if (!ei_one_before_end_p (ei))\n@@ -671,7 +682,8 @@ post_order_compute (int *post_order, bool include_entry_exit,\n     {\n       basic_block b;\n       basic_block next_bb;\n-      for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n+      for (b = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; b\n+\t   != EXIT_BLOCK_PTR_FOR_FN (cfun); b = next_bb)\n \t{\n \t  next_bb = b->next_bb;\n \n@@ -813,7 +825,8 @@ inverted_post_order_compute (int *post_order)\n             }\n           else\n             {\n-              if (bb != EXIT_BLOCK_PTR && ei_one_before_end_p (ei))\n+\t      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t\t  && ei_one_before_end_p (ei))\n                 post_order[post_order_num++] = bb->index;\n \n               if (!ei_one_before_end_p (ei))\n@@ -826,7 +839,8 @@ inverted_post_order_compute (int *post_order)\n       /* Detect any infinite loop and activate the kludge.\n          Note that this doesn't check EXIT_BLOCK itself\n          since EXIT_BLOCK is always added after the outer do-while loop.  */\n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t      EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n         if (!bitmap_bit_p (visited, bb->index))\n           {\n             has_unvisited_bb = true;\n@@ -859,7 +873,7 @@ inverted_post_order_compute (int *post_order)\n         {\n           /* No blocks are reachable from EXIT at all.\n              Find a dead-end from the ENTRY, and restart the iteration. */\n-          basic_block be = dfs_find_deadend (ENTRY_BLOCK_PTR);\n+\t  basic_block be = dfs_find_deadend (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n           gcc_assert (be != NULL);\n           bitmap_set_bit (visited, be->index);\n           stack[sp++] = ei_start (be->preds);\n@@ -923,7 +937,7 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FUNCTION (fn)->succs);\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (fn)->succs);\n \n   while (sp)\n     {\n@@ -937,7 +951,7 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n       dest = ei_edge (ei)->dest;\n \n       /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR_FOR_FUNCTION (fn)\n+      if (dest != EXIT_BLOCK_PTR_FOR_FN (fn)\n \t  && ! bitmap_bit_p (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n@@ -960,7 +974,7 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n       else\n \t{\n \t  if (ei_one_before_end_p (ei)\n-\t      && src != ENTRY_BLOCK_PTR_FOR_FUNCTION (fn)\n+\t      && src != ENTRY_BLOCK_PTR_FOR_FN (fn)\n \t      && rev_post_order)\n \t    /* There are no more successors for the SRC node\n \t       so assign its reverse completion number.  */\n@@ -1230,7 +1244,7 @@ compute_dominance_frontiers_1 (bitmap_head *frontiers)\n \t    {\n \t      basic_block runner = p->src;\n \t      basic_block domsb;\n-\t      if (runner == ENTRY_BLOCK_PTR)\n+\t      if (runner == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t\tcontinue;\n \n \t      domsb = get_immediate_dominator (CDI_DOMINATORS, b);\n@@ -1337,7 +1351,7 @@ bitmap_intersection_of_succs (sbitmap dst, sbitmap *src, basic_block b)\n   for (e = NULL, ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n     {\n       e = EDGE_SUCC (b, ix);\n-      if (e->dest == EXIT_BLOCK_PTR)\n+      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       bitmap_copy (dst, src[e->dest->index]);\n@@ -1353,7 +1367,7 @@ bitmap_intersection_of_succs (sbitmap dst, sbitmap *src, basic_block b)\n \tSBITMAP_ELT_TYPE *p, *r;\n \n \te = EDGE_SUCC (b, ix);\n-\tif (e->dest == EXIT_BLOCK_PTR)\n+\tif (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  continue;\n \n \tp = src[e->dest->index]->elms;\n@@ -1378,7 +1392,7 @@ bitmap_intersection_of_preds (sbitmap dst, sbitmap *src, basic_block b)\n   for (e = NULL, ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n     {\n       e = EDGE_PRED (b, ix);\n-      if (e->src == ENTRY_BLOCK_PTR)\n+      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       bitmap_copy (dst, src[e->src->index]);\n@@ -1394,7 +1408,7 @@ bitmap_intersection_of_preds (sbitmap dst, sbitmap *src, basic_block b)\n \tSBITMAP_ELT_TYPE *p, *r;\n \n \te = EDGE_PRED (b, ix);\n-\tif (e->src == ENTRY_BLOCK_PTR)\n+\tif (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t  continue;\n \n \tp = src[e->src->index]->elms;\n@@ -1419,7 +1433,7 @@ bitmap_union_of_succs (sbitmap dst, sbitmap *src, basic_block b)\n   for (ix = 0; ix < EDGE_COUNT (b->succs); ix++)\n     {\n       e = EDGE_SUCC (b, ix);\n-      if (e->dest == EXIT_BLOCK_PTR)\n+      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       bitmap_copy (dst, src[e->dest->index]);\n@@ -1435,7 +1449,7 @@ bitmap_union_of_succs (sbitmap dst, sbitmap *src, basic_block b)\n \tSBITMAP_ELT_TYPE *p, *r;\n \n \te = EDGE_SUCC (b, ix);\n-\tif (e->dest == EXIT_BLOCK_PTR)\n+\tif (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  continue;\n \n \tp = src[e->dest->index]->elms;\n@@ -1460,7 +1474,7 @@ bitmap_union_of_preds (sbitmap dst, sbitmap *src, basic_block b)\n   for (ix = 0; ix < EDGE_COUNT (b->preds); ix++)\n     {\n       e = EDGE_PRED (b, ix);\n-      if (e->src== ENTRY_BLOCK_PTR)\n+      if (e->src== ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       bitmap_copy (dst, src[e->src->index]);\n@@ -1476,7 +1490,7 @@ bitmap_union_of_preds (sbitmap dst, sbitmap *src, basic_block b)\n \tSBITMAP_ELT_TYPE *p, *r;\n \n \te = EDGE_PRED (b, ix);\n-\tif (e->src == ENTRY_BLOCK_PTR)\n+\tif (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t  continue;\n \n \tp = src[e->src->index]->elms;\n@@ -1504,7 +1518,7 @@ single_pred_before_succ_order (void)\n \n   bitmap_clear (visited);\n \n-  MARK_VISITED (ENTRY_BLOCK_PTR);\n+  MARK_VISITED (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   FOR_EACH_BB (x)\n     {\n       if (VISITED_P (x))"}, {"sha": "08534d4bdde18fe2e2eb80e24b17204c0d19e26e", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -213,8 +213,8 @@ make_edges (basic_block min, basic_block max, int update_p)\n \n   /* By nature of the way these get numbered, ENTRY_BLOCK_PTR->next_bb block\n      is always the entry.  */\n-  if (min == ENTRY_BLOCK_PTR->next_bb)\n-    make_edge (ENTRY_BLOCK_PTR, min, EDGE_FALLTHRU);\n+  if (min == ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb)\n+    make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), min, EDGE_FALLTHRU);\n \n   FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n     {\n@@ -233,14 +233,14 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t  if (update_p)\n \t    {\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t  bitmap_set_bit (edge_cache, e->dest->index);\n \t    }\n \t}\n \n       if (LABEL_P (BB_HEAD (bb))\n \t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n-\tcached_make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n+\tcached_make_edge (NULL, ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, 0);\n \n       /* Examine the last instruction of the block, and discover the\n \t ways we can leave the block.  */\n@@ -294,7 +294,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \n \t  /* Returns create an exit out.  */\n \t  else if (returnjump_p (insn))\n-\t    cached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, 0);\n+\t    cached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \n \t  /* Recognize asm goto and do the right thing.  */\n \t  else if ((tmp = extract_asm_operands (PATTERN (insn))) != NULL)\n@@ -318,7 +318,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t worry about EH edges, since we wouldn't have created the sibling call\n \t in the first place.  */\n       if (code == CALL_INSN && SIBLING_CALL_P (insn))\n-\tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR,\n+\tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t\t\t  EDGE_SIBCALL | EDGE_ABNORMAL);\n \n       /* If this is a CALL_INSN, then mark it as reaching the active EH\n@@ -359,7 +359,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \n       /* Find out if we can drop through to the next block.  */\n       insn = NEXT_INSN (insn);\n-      e = find_edge (bb, EXIT_BLOCK_PTR);\n+      e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n       if (e && e->flags & EDGE_FALLTHRU)\n \tinsn = NULL;\n \n@@ -369,8 +369,9 @@ make_edges (basic_block min, basic_block max, int update_p)\n \tinsn = NEXT_INSN (insn);\n \n       if (!insn)\n-\tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n-      else if (bb->next_bb != EXIT_BLOCK_PTR)\n+\tcached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t  EDGE_FALLTHRU);\n+      else if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  if (insn == BB_HEAD (bb->next_bb))\n \t    cached_make_edge (edge_cache, bb, bb->next_bb, EDGE_FALLTHRU);\n@@ -480,7 +481,7 @@ find_bb_boundaries (basic_block bb)\n \t  remove_edge (fallthru);\n \t  flow_transfer_insn = NULL_RTX;\n \t  if (code == CODE_LABEL && LABEL_ALT_ENTRY_P (insn))\n-\t    make_edge (ENTRY_BLOCK_PTR, bb, 0);\n+\t    make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, 0);\n \t}\n       else if (code == BARRIER)\n \t{\n@@ -607,7 +608,7 @@ find_many_sub_basic_blocks (sbitmap blocks)\n       break;\n \n   min = max = bb;\n-  for (; bb != EXIT_BLOCK_PTR; bb = bb->next_bb)\n+  for (; bb != EXIT_BLOCK_PTR_FOR_FN (cfun); bb = bb->next_bb)\n     if (STATE (bb) != BLOCK_ORIGINAL)\n       max = bb;\n "}, {"sha": "9c126102a543bc075cd9f85c7c4dd70909a97141", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -134,7 +134,7 @@ try_simplify_condjump (basic_block cbranch_block)\n      unconditional jump.  */\n   jump_block = cbranch_fallthru_edge->dest;\n   if (!single_pred_p (jump_block)\n-      || jump_block->next_bb == EXIT_BLOCK_PTR\n+      || jump_block->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n       || !FORWARDER_BLOCK_P (jump_block))\n     return false;\n   jump_dest_block = single_succ (jump_block);\n@@ -157,7 +157,7 @@ try_simplify_condjump (basic_block cbranch_block)\n      unconditional branch.  */\n   cbranch_dest_block = cbranch_jump_edge->dest;\n \n-  if (cbranch_dest_block == EXIT_BLOCK_PTR\n+  if (cbranch_dest_block == EXIT_BLOCK_PTR_FOR_FN (cfun)\n       || !can_fallthru (jump_block, cbranch_dest_block))\n     return false;\n \n@@ -455,7 +455,7 @@ try_forward_edges (int mode, basic_block b)\n \t bb-reorder.c:partition_hot_cold_basic_blocks for complete\n \t details.  */\n \n-      if (first != EXIT_BLOCK_PTR\n+      if (first != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && find_reg_note (BB_END (first), REG_CROSSING_JUMP, NULL_RTX))\n \treturn changed;\n \n@@ -467,7 +467,7 @@ try_forward_edges (int mode, basic_block b)\n \n \t  if (FORWARDER_BLOCK_P (target)\n \t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n-\t      && single_succ (target) != EXIT_BLOCK_PTR)\n+\t      && single_succ (target) != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      /* Bypass trivial infinite loops.  */\n \t      new_target = single_succ (target);\n@@ -580,7 +580,7 @@ try_forward_edges (int mode, basic_block b)\n \t  e->goto_locus = goto_locus;\n \n \t  /* Don't force if target is exit block.  */\n-\t  if (threaded && target != EXIT_BLOCK_PTR)\n+\t  if (threaded && target != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      notice_new_block (redirect_edge_and_branch_force (e, target));\n \t      if (dump_file)\n@@ -793,7 +793,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n \tfprintf (dump_file, \"Merged %d and %d without moving.\\n\",\n \t\t b_index, c_index);\n \n-      return b->prev_bb == ENTRY_BLOCK_PTR ? b : b->prev_bb;\n+      return b->prev_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun) ? b : b->prev_bb;\n     }\n \n   /* Otherwise we will need to move code around.  Do that only if expensive\n@@ -831,7 +831,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       if (! c_has_outgoing_fallthru)\n \t{\n \t  merge_blocks_move_successor_nojumps (b, c);\n-\t  return next == ENTRY_BLOCK_PTR ? next->next_bb : next;\n+\t  return next == ENTRY_BLOCK_PTR_FOR_FN (cfun) ? next->next_bb : next;\n \t}\n \n       /* If B does not have an incoming fallthru, then it can be moved\n@@ -843,15 +843,15 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n \t{\n \t  basic_block bb;\n \n-\t  if (b_fallthru_edge->src == ENTRY_BLOCK_PTR)\n+\t  if (b_fallthru_edge->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    return NULL;\n \t  bb = force_nonfallthru (b_fallthru_edge);\n \t  if (bb)\n \t    notice_new_block (bb);\n \t}\n \n       merge_blocks_move_predecessor_nojumps (b, c);\n-      return next == ENTRY_BLOCK_PTR ? next->next_bb : next;\n+      return next == ENTRY_BLOCK_PTR_FOR_FN (cfun) ? next->next_bb : next;\n     }\n \n   return NULL;\n@@ -1267,7 +1267,7 @@ walk_to_nondebug_insn (rtx *i1, basic_block *bb1, bool follow_fallthru,\n         return;\n \n       fallthru = find_fallthru_edge ((*bb1)->preds);\n-      if (!fallthru || fallthru->src == ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+      if (!fallthru || fallthru->src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n           || !single_succ_p (fallthru->src))\n         return;\n \n@@ -1540,7 +1540,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n      whether they went through the prologue.  Sibcalls are fine, we know\n      that we either didn't need or inserted an epilogue before them.  */\n   if (crtl->shrink_wrapped\n-      && single_succ_p (bb1) && single_succ (bb1) == EXIT_BLOCK_PTR\n+      && single_succ_p (bb1)\n+      && single_succ (bb1) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n       && !JUMP_P (BB_END (bb1))\n       && !(CALL_P (BB_END (bb1)) && SIBLING_CALL_P (BB_END (bb1))))\n     return false;\n@@ -1902,7 +1903,8 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n     e2 = single_pred_edge (src2), src2 = e2->src;\n \n   /* Nothing to do if we reach ENTRY, or a common source block.  */\n-  if (src1 == ENTRY_BLOCK_PTR || src2 == ENTRY_BLOCK_PTR)\n+  if (src1 == ENTRY_BLOCK_PTR_FOR_FN (cfun) || src2\n+      == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     return false;\n   if (src1 == src2)\n     return false;\n@@ -2146,7 +2148,7 @@ try_crossjump_bb (int mode, basic_block bb)\n   /* Don't crossjump if this block ends in a computed jump,\n      unless we are optimizing for size.  */\n   if (optimize_bb_for_size_p (bb)\n-      && bb != EXIT_BLOCK_PTR\n+      && bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n       && computed_jump_p (BB_END (bb)))\n     return false;\n \n@@ -2287,7 +2289,7 @@ try_head_merge_bb (basic_block bb)\n   /* Don't crossjump if this block ends in a computed jump,\n      unless we are optimizing for size.  */\n   if (optimize_bb_for_size_p (bb)\n-      && bb != EXIT_BLOCK_PTR\n+      && bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n       && computed_jump_p (BB_END (bb)))\n     return false;\n \n@@ -2303,7 +2305,7 @@ try_head_merge_bb (basic_block bb)\n     }\n \n   for (ix = 0; ix < nedges; ix++)\n-    if (EDGE_SUCC (bb, ix)->dest == EXIT_BLOCK_PTR)\n+    if (EDGE_SUCC (bb, ix)->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n       return false;\n \n   for (ix = 0; ix < nedges; ix++)\n@@ -2623,7 +2625,8 @@ try_optimize_cfg (int mode)\n \t\t     \"\\n\\ntry_optimize_cfg iteration %i\\n\\n\",\n \t\t     iterations);\n \n-\t  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR;)\n+\t  for (b = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; b\n+\t       != EXIT_BLOCK_PTR_FOR_FN (cfun);)\n \t    {\n \t      basic_block c;\n \t      edge s;\n@@ -2640,7 +2643,8 @@ try_optimize_cfg (int mode)\n \t      if (EDGE_COUNT (b->preds) == 0\n \t\t  || (EDGE_COUNT (b->succs) == 0\n \t\t      && trivially_empty_bb_p (b)\n-\t\t      && single_succ_edge (ENTRY_BLOCK_PTR)->dest != b))\n+\t\t      && single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->dest\n+\t\t      != b))\n \t\t{\n \t\t  c = b->prev_bb;\n \t\t  if (EDGE_COUNT (b->preds) > 0)\n@@ -2681,7 +2685,7 @@ try_optimize_cfg (int mode)\n \t\t  delete_basic_block (b);\n \t\t  changed = true;\n \t\t  /* Avoid trying to remove ENTRY_BLOCK_PTR.  */\n-\t\t  b = (c == ENTRY_BLOCK_PTR ? c->next_bb : c);\n+\t\t  b = (c == ENTRY_BLOCK_PTR_FOR_FN (cfun) ? c->next_bb : c);\n \t\t  continue;\n \t\t}\n \n@@ -2696,7 +2700,7 @@ try_optimize_cfg (int mode)\n \t\t     if CASE_DROPS_THRU, this can be a tablejump with\n \t\t     some element going to the same place as the\n \t\t     default (fallthru).  */\n-\t\t  && (single_pred (b) == ENTRY_BLOCK_PTR\n+\t\t  && (single_pred (b) == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t\t      || !JUMP_P (BB_END (single_pred (b)))\n \t\t      || ! label_is_jump_target_p (BB_HEAD (b),\n \t\t\t\t\t\t   BB_END (single_pred (b)))))\n@@ -2723,7 +2727,8 @@ try_optimize_cfg (int mode)\n \t\t\t     \"Deleting fallthru block %i.\\n\",\n \t\t\t     b->index);\n \n-\t\t  c = b->prev_bb == ENTRY_BLOCK_PTR ? b->next_bb : b->prev_bb;\n+\t\t  c = ((b->prev_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t\t       ? b->next_bb : b->prev_bb);\n \t\t  redirect_edge_succ_nodup (single_pred_edge (b),\n \t\t\t\t\t    single_succ (b));\n \t\t  delete_basic_block (b);\n@@ -2736,7 +2741,7 @@ try_optimize_cfg (int mode)\n \t      if (single_succ_p (b)\n \t\t  && (s = single_succ_edge (b))\n \t\t  && !(s->flags & EDGE_COMPLEX)\n-\t\t  && (c = s->dest) != EXIT_BLOCK_PTR\n+\t\t  && (c = s->dest) != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && single_pred_p (c)\n \t\t  && b != c)\n \t\t{\n@@ -2780,7 +2785,7 @@ try_optimize_cfg (int mode)\n \t\t can either delete the jump entirely, or replace it\n \t\t with a simple unconditional jump.  */\n \t      if (single_succ_p (b)\n-\t\t  && single_succ (b) != EXIT_BLOCK_PTR\n+\t\t  && single_succ (b) != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && onlyjump_p (BB_END (b))\n \t\t  && !find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX)\n \t\t  && try_redirect_by_replacing_jump (single_succ_edge (b),\n@@ -2819,7 +2824,7 @@ try_optimize_cfg (int mode)\n \t    }\n \n \t  if ((mode & CLEANUP_CROSSJUMP)\n-\t      && try_crossjump_bb (mode, EXIT_BLOCK_PTR))\n+\t      && try_crossjump_bb (mode, EXIT_BLOCK_PTR_FOR_FN (cfun)))\n \t    changed = true;\n \n \t  if (block_was_dirty)\n@@ -2876,7 +2881,8 @@ delete_unreachable_blocks (void)\n   if (MAY_HAVE_DEBUG_INSNS && current_ir_type () == IR_GIMPLE\n       && dom_info_available_p (CDI_DOMINATORS))\n     {\n-      for (b = EXIT_BLOCK_PTR->prev_bb; b != ENTRY_BLOCK_PTR; b = prev_bb)\n+      for (b = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n+\t   b != ENTRY_BLOCK_PTR_FOR_FN (cfun); b = prev_bb)\n \t{\n \t  prev_bb = b->prev_bb;\n \n@@ -2912,7 +2918,8 @@ delete_unreachable_blocks (void)\n     }\n   else\n     {\n-      for (b = EXIT_BLOCK_PTR->prev_bb; b != ENTRY_BLOCK_PTR; b = prev_bb)\n+      for (b = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n+\t   b != ENTRY_BLOCK_PTR_FOR_FN (cfun); b = prev_bb)\n \t{\n \t  prev_bb = b->prev_bb;\n "}, {"sha": "d431c8dea5eb5914652d0d2608a64af3d684ce93", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3363,7 +3363,7 @@ expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n     {\n       if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n \t{\n-\t  if (e->dest != EXIT_BLOCK_PTR)\n+\t  if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      e->dest->count -= e->count;\n \t      e->dest->frequency -= EDGE_FREQUENCY (e);\n@@ -3399,7 +3399,8 @@ expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n       delete_insn (NEXT_INSN (last));\n     }\n \n-  e = make_edge (bb, EXIT_BLOCK_PTR, EDGE_ABNORMAL | EDGE_SIBCALL);\n+  e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_ABNORMAL\n+\t\t | EDGE_SIBCALL);\n   e->probability += probability;\n   e->count += count;\n   BB_END (bb) = last;\n@@ -4840,9 +4841,9 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n       gimple ret_stmt = gsi_stmt (gsi);\n \n       gcc_assert (single_succ_p (bb));\n-      gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR);\n+      gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n-      if (bb->next_bb == EXIT_BLOCK_PTR\n+      if (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && !gimple_return_retval (ret_stmt))\n \t{\n \t  gsi_remove (&gsi, false);\n@@ -5184,17 +5185,17 @@ construct_init_block (void)\n   int flags;\n \n   /* Multiple entry points not supported yet.  */\n-  gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR->succs) == 1);\n-  init_rtl_bb_info (ENTRY_BLOCK_PTR);\n-  init_rtl_bb_info (EXIT_BLOCK_PTR);\n-  ENTRY_BLOCK_PTR->flags |= BB_RTL;\n-  EXIT_BLOCK_PTR->flags |= BB_RTL;\n+  gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs) == 1);\n+  init_rtl_bb_info (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  init_rtl_bb_info (EXIT_BLOCK_PTR_FOR_FN (cfun));\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->flags |= BB_RTL;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->flags |= BB_RTL;\n \n-  e = EDGE_SUCC (ENTRY_BLOCK_PTR, 0);\n+  e = EDGE_SUCC (ENTRY_BLOCK_PTR_FOR_FN (cfun), 0);\n \n   /* When entry edge points to first basic block, we don't need jump,\n      otherwise we have to jump into proper target.  */\n-  if (e && e->dest != ENTRY_BLOCK_PTR->next_bb)\n+  if (e && e->dest != ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb)\n     {\n       tree label = gimple_block_label (e->dest);\n \n@@ -5206,21 +5207,21 @@ construct_init_block (void)\n \n   init_block = create_basic_block (NEXT_INSN (get_insns ()),\n \t\t\t\t   get_last_insn (),\n-\t\t\t\t   ENTRY_BLOCK_PTR);\n-  init_block->frequency = ENTRY_BLOCK_PTR->frequency;\n-  init_block->count = ENTRY_BLOCK_PTR->count;\n-  if (current_loops && ENTRY_BLOCK_PTR->loop_father)\n-    add_bb_to_loop (init_block, ENTRY_BLOCK_PTR->loop_father);\n+\t\t\t\t   ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  init_block->frequency = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n+  init_block->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+  if (current_loops && ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father)\n+    add_bb_to_loop (init_block, ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n   if (e)\n     {\n       first_block = e->dest;\n       redirect_edge_succ (e, init_block);\n       e = make_edge (init_block, first_block, flags);\n     }\n   else\n-    e = make_edge (init_block, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+    e = make_edge (init_block, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FALLTHRU);\n   e->probability = REG_BR_PROB_BASE;\n-  e->count = ENTRY_BLOCK_PTR->count;\n+  e->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n   update_bb_for_insn (init_block);\n   return init_block;\n@@ -5251,9 +5252,9 @@ construct_exit_block (void)\n   edge e, e2;\n   unsigned ix;\n   edge_iterator ei;\n-  rtx orig_end = BB_END (EXIT_BLOCK_PTR->prev_bb);\n+  rtx orig_end = BB_END (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n \n-  rtl_profile_for_bb (EXIT_BLOCK_PTR);\n+  rtl_profile_for_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   /* Make sure the locus is set to the end of the function, so that\n      epilogue line numbers and warnings are set properly.  */\n@@ -5268,30 +5269,30 @@ construct_exit_block (void)\n     return;\n   /* While emitting the function end we could move end of the last basic block.\n    */\n-  BB_END (EXIT_BLOCK_PTR->prev_bb) = orig_end;\n+  BB_END (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb) = orig_end;\n   while (NEXT_INSN (head) && NOTE_P (NEXT_INSN (head)))\n     head = NEXT_INSN (head);\n   exit_block = create_basic_block (NEXT_INSN (head), end,\n-\t\t\t\t   EXIT_BLOCK_PTR->prev_bb);\n-  exit_block->frequency = EXIT_BLOCK_PTR->frequency;\n-  exit_block->count = EXIT_BLOCK_PTR->count;\n-  if (current_loops && EXIT_BLOCK_PTR->loop_father)\n-    add_bb_to_loop (exit_block, EXIT_BLOCK_PTR->loop_father);\n+\t\t\t\t   EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n+  exit_block->frequency = EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency;\n+  exit_block->count = EXIT_BLOCK_PTR_FOR_FN (cfun)->count;\n+  if (current_loops && EXIT_BLOCK_PTR_FOR_FN (cfun)->loop_father)\n+    add_bb_to_loop (exit_block, EXIT_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n \n   ix = 0;\n-  while (ix < EDGE_COUNT (EXIT_BLOCK_PTR->preds))\n+  while (ix < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds))\n     {\n-      e = EDGE_PRED (EXIT_BLOCK_PTR, ix);\n+      e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), ix);\n       if (!(e->flags & EDGE_ABNORMAL))\n \tredirect_edge_succ (e, exit_block);\n       else\n \tix++;\n     }\n \n-  e = make_edge (exit_block, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+  e = make_edge (exit_block, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FALLTHRU);\n   e->probability = REG_BR_PROB_BASE;\n-  e->count = EXIT_BLOCK_PTR->count;\n-  FOR_EACH_EDGE (e2, ei, EXIT_BLOCK_PTR->preds)\n+  e->count = EXIT_BLOCK_PTR_FOR_FN (cfun)->count;\n+  FOR_EACH_EDGE (e2, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (e2 != e)\n       {\n \te->count -= e2->count;\n@@ -5521,7 +5522,7 @@ gimple_expand_cfg (void)\n   /* Dominators are not kept up-to-date as we may create new basic-blocks.  */\n   free_dominance_info (CDI_DOMINATORS);\n \n-  rtl_profile_for_bb (ENTRY_BLOCK_PTR);\n+  rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   insn_locations_init ();\n   if (!DECL_IS_BUILTIN (current_function_decl))\n@@ -5685,11 +5686,12 @@ gimple_expand_cfg (void)\n \n   /* Clear EDGE_EXECUTABLE on the entry edge(s).  It is cleaned from the\n      remaining edges later.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     e->flags &= ~EDGE_EXECUTABLE;\n \n   lab_rtx_for_bb = pointer_map_create ();\n-  FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  next_bb)\n     bb = expand_gimple_basic_block (bb, var_ret_seq != NULL_RTX);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n@@ -5734,7 +5736,8 @@ gimple_expand_cfg (void)\n      split edges which edge insertions might do.  */\n   rebuild_jump_labels (get_insns ());\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -5745,8 +5748,8 @@ gimple_expand_cfg (void)\n \t      rebuild_jump_labels_chain (e->insns.r);\n \t      /* Put insns after parm birth, but before\n \t\t NOTE_INSNS_FUNCTION_BEG.  */\n-\t      if (e->src == ENTRY_BLOCK_PTR\n-\t\t  && single_succ_p (ENTRY_BLOCK_PTR))\n+\t      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t\t  && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n \t\t{\n \t\t  rtx insns = e->insns.r;\n \t\t  e->insns.r = NULL_RTX;\n@@ -5767,7 +5770,8 @@ gimple_expand_cfg (void)\n   /* We're done expanding trees to RTL.  */\n   currently_expanding_to_rtl = 0;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb,\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       edge e;\n       edge_iterator ei;"}, {"sha": "2535c9027bea3d3f5bd1d0e12dc409673a393cc8", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -102,10 +102,10 @@ verify_flow_info (void)\n   edge_checksum = XCNEWVEC (size_t, last_basic_block);\n \n   /* Check bb chain & numbers.  */\n-  last_bb_seen = ENTRY_BLOCK_PTR;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n+  last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb, NULL, next_bb)\n     {\n-      if (bb != EXIT_BLOCK_PTR\n+      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && bb != BASIC_BLOCK (bb->index))\n \t{\n \t  error (\"bb %d on wrong place\", bb->index);\n@@ -234,21 +234,21 @@ verify_flow_info (void)\n     edge e;\n     edge_iterator ei;\n \n-    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+    FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n       edge_checksum[e->dest->index] += (size_t) e;\n \n-    FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n       edge_checksum[e->dest->index] -= (size_t) e;\n   }\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     if (edge_checksum[bb->index])\n       {\n \terror (\"basic block %i edge lists are corrupted\", bb->index);\n \terr = 1;\n       }\n \n-  last_bb_seen = ENTRY_BLOCK_PTR;\n+  last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Clean up.  */\n   free (last_visited);\n@@ -938,10 +938,11 @@ tidy_fallthru_edges (void)\n   if (!cfg_hooks->tidy_fallthru_edge)\n     return;\n \n-  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return;\n \n-  FOR_BB_BETWEEN (b, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR->prev_bb, next_bb)\n+  FOR_BB_BETWEEN (b, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb,\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb, next_bb)\n     {\n       edge s;\n \n@@ -1011,7 +1012,7 @@ can_duplicate_block_p (const_basic_block bb)\n     internal_error (\"%s does not support can_duplicate_block_p\",\n \t\t    cfg_hooks->name);\n \n-  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     return false;\n \n   return cfg_hooks->can_duplicate_block_p (bb);\n@@ -1409,7 +1410,7 @@ account_profile_record (struct profile_record *record, int after_pass)\n \n   FOR_ALL_BB (bb)\n    {\n-      if (bb != EXIT_BLOCK_PTR_FOR_FUNCTION (cfun)\n+      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status != PROFILE_ABSENT)\n \t{\n \t  sum = 0;\n@@ -1424,7 +1425,7 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t      && (lsum - bb->count > 100 || lsum - bb->count < -100))\n \t    record->num_mismatched_count_out[after_pass]++;\n \t}\n-      if (bb != ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+      if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  && profile_status != PROFILE_ABSENT)\n \t{\n \t  sum = 0;\n@@ -1440,8 +1441,8 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t  if (lsum - bb->count > 100 || lsum - bb->count < -100)\n \t    record->num_mismatched_count_in[after_pass]++;\n \t}\n-      if (bb == ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n-\t  || bb == EXIT_BLOCK_PTR_FOR_FUNCTION (cfun))\n+      if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n       gcc_assert (cfg_hooks->account_profile_record);\n       cfg_hooks->account_profile_record (bb, after_pass, record);"}, {"sha": "4b3ad5bd3bdc23d34b97364a140e0cd81934de33", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -352,10 +352,10 @@ init_loops_structure (struct function *fn,\n   /* Dummy loop containing whole function.  */\n   root = alloc_loop ();\n   root->num_nodes = n_basic_blocks_for_fn (fn);\n-  root->latch = EXIT_BLOCK_PTR_FOR_FUNCTION (fn);\n-  root->header = ENTRY_BLOCK_PTR_FOR_FUNCTION (fn);\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (fn)->loop_father = root;\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (fn)->loop_father = root;\n+  root->latch = EXIT_BLOCK_PTR_FOR_FN (fn);\n+  root->header = ENTRY_BLOCK_PTR_FOR_FN (fn);\n+  ENTRY_BLOCK_PTR_FOR_FN (fn)->loop_father = root;\n+  EXIT_BLOCK_PTR_FOR_FN (fn)->loop_father = root;\n \n   loops->larray->quick_push (root);\n   loops->tree_root = root;\n@@ -382,7 +382,7 @@ bb_loop_header_p (basic_block header)\n   FOR_EACH_EDGE (e, ei, header->preds)\n     {\n       basic_block latch = e->src;\n-      if (latch != ENTRY_BLOCK_PTR\n+      if (latch != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  && dominated_by_p (CDI_DOMINATORS, latch, header))\n \treturn true;\n     }\n@@ -745,7 +745,7 @@ disambiguate_multiple_latches (struct loop *loop)\n      block.  This would cause problems if the entry edge was the one from the\n      entry block.  To avoid having to handle this case specially, split\n      such entry edge.  */\n-  e = find_edge (ENTRY_BLOCK_PTR, loop->header);\n+  e = find_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), loop->header);\n   if (e)\n     split_edge (e);\n \n@@ -781,7 +781,8 @@ flow_bb_inside_loop_p (const struct loop *loop, const_basic_block bb)\n {\n   struct loop *source_loop;\n \n-  if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+      || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return 0;\n \n   source_loop = bb->loop_father;\n@@ -826,13 +827,13 @@ get_loop_body (const struct loop *loop)\n \n   body = XNEWVEC (basic_block, loop->num_nodes);\n \n-  if (loop->latch == EXIT_BLOCK_PTR)\n+  if (loop->latch == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       /* There may be blocks unreachable from EXIT_BLOCK, hence we need to\n \t special-case the fake loop that contains the whole function.  */\n       gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks_for_fn (cfun));\n       body[tv++] = loop->header;\n-      body[tv++] = EXIT_BLOCK_PTR;\n+      body[tv++] = EXIT_BLOCK_PTR_FOR_FN (cfun);\n       FOR_EACH_BB (bb)\n \tbody[tv++] = bb;\n     }\n@@ -886,7 +887,7 @@ get_loop_body_in_dom_order (const struct loop *loop)\n \n   tovisit = XNEWVEC (basic_block, loop->num_nodes);\n \n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   tv = 0;\n   fill_sons_in_loop (loop, loop->header, tovisit, &tv);\n@@ -921,7 +922,7 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   unsigned int vc = 1;\n \n   gcc_assert (loop->num_nodes);\n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   blocks = XNEWVEC (basic_block, loop->num_nodes);\n   visited = BITMAP_ALLOC (NULL);\n@@ -1143,7 +1144,7 @@ get_loop_exit_edges (const struct loop *loop)\n   edge_iterator ei;\n   struct loop_exit *exit;\n \n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   /* If we maintain the lists of exits, use them.  Otherwise we must\n      scan the body of the loop.  */\n@@ -1175,7 +1176,7 @@ num_loop_branches (const struct loop *loop)\n   unsigned i, n;\n   basic_block * body;\n \n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   body = get_loop_body (loop);\n   n = 0;"}, {"sha": "0cee6c68b28bca1dc4d149b4bd41498c941cf194", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -85,7 +85,8 @@ mark_irreducible_loops (void)\n   gcc_assert (current_loops != NULL);\n \n   /* Reset the flags.  */\n-  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       act->flags &= ~BB_IRREDUCIBLE_LOOP;\n       FOR_EACH_EDGE (e, ei, act->succs)\n@@ -95,11 +96,12 @@ mark_irreducible_loops (void)\n   /* Create the edge lists.  */\n   g = new_graph (last_basic_block + num);\n \n-  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     FOR_EACH_EDGE (e, ei, act->succs)\n       {\n \t/* Ignore edges to exit.  */\n-\tif (e->dest == EXIT_BLOCK_PTR)\n+\tif (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  continue;\n \n \tsrc = BB_REPR (act);"}, {"sha": "6baa15afadeb810a8001a5cf4162e9bcd0d43ac1", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -92,7 +92,7 @@ fix_bb_placement (basic_block bb)\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      if (e->dest == EXIT_BLOCK_PTR)\n+      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       act = e->dest->loop_father;\n@@ -352,7 +352,8 @@ remove_path (edge e)\n     bitmap_set_bit (seen, rem_bbs[i]->index);\n   if (!irred_invalidated)\n     FOR_EACH_EDGE (ae, ei, e->src->succs)\n-      if (ae != e && ae->dest != EXIT_BLOCK_PTR && !bitmap_bit_p (seen, ae->dest->index)\n+      if (ae != e && ae->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t  && !bitmap_bit_p (seen, ae->dest->index)\n \t  && ae->flags & EDGE_IRREDUCIBLE_LOOP)\n \t{\n \t  irred_invalidated = true;\n@@ -363,7 +364,8 @@ remove_path (edge e)\n     {\n       bb = rem_bbs[i];\n       FOR_EACH_EDGE (ae, ei, rem_bbs[i]->succs)\n-\tif (ae->dest != EXIT_BLOCK_PTR && !bitmap_bit_p (seen, ae->dest->index))\n+\tif (ae->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t    && !bitmap_bit_p (seen, ae->dest->index))\n \t  {\n \t    bitmap_set_bit (seen, ae->dest->index);\n \t    bord_bbs[n_bord_bbs++] = ae->dest;\n@@ -1519,7 +1521,7 @@ create_preheader (struct loop *loop, int flags)\n \n       /* We do not allow entry block to be the loop preheader, since we\n \t     cannot emit code there.  */\n-      if (single_entry->src == ENTRY_BLOCK_PTR)\n+      if (single_entry->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n         need_forwarder_block = true;\n       else\n         {"}, {"sha": "7ad38721606af64809610a9c90d4c001c7b103a0", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 95, "deletions": 77, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -501,15 +501,15 @@ rtx\n entry_of_function (void)\n {\n   return (n_basic_blocks_for_fn (cfun) > NUM_FIXED_BLOCKS ?\n-\t  BB_HEAD (ENTRY_BLOCK_PTR->next_bb) : get_insns ());\n+\t  BB_HEAD (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb) : get_insns ());\n }\n \n /* Emit INSN at the entry point of the function, ensuring that it is only\n    executed once per function.  */\n void\n emit_insn_at_entry (rtx insn)\n {\n-  edge_iterator ei = ei_start (ENTRY_BLOCK_PTR->succs);\n+  edge_iterator ei = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n   edge e = ei_safe_edge (ei);\n   gcc_assert (e->flags & EDGE_FALLTHRU);\n \n@@ -573,7 +573,7 @@ contains_no_active_insn_p (const_basic_block bb)\n {\n   rtx insn;\n \n-  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       || !single_succ_p (bb))\n     return false;\n \n@@ -620,7 +620,7 @@ can_fallthru (basic_block src, basic_block target)\n   edge e;\n   edge_iterator ei;\n \n-  if (target == EXIT_BLOCK_PTR)\n+  if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return true;\n   if (src->next_bb != target)\n     return false;\n@@ -630,7 +630,7 @@ can_fallthru (basic_block src, basic_block target)\n     return false;\n \n   FOR_EACH_EDGE (e, ei, src->succs)\n-    if (e->dest == EXIT_BLOCK_PTR\n+    if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t&& e->flags & EDGE_FALLTHRU)\n       return false;\n \n@@ -650,10 +650,10 @@ could_fall_through (basic_block src, basic_block target)\n   edge e;\n   edge_iterator ei;\n \n-  if (target == EXIT_BLOCK_PTR)\n+  if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return true;\n   FOR_EACH_EDGE (e, ei, src->succs)\n-    if (e->dest == EXIT_BLOCK_PTR\n+    if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t&& e->flags & EDGE_FALLTHRU)\n       return 0;\n   return true;\n@@ -958,7 +958,8 @@ rtl_can_merge_blocks (basic_block a, basic_block b)\n \t  /* Must be simple edge.  */\n \t  && !(single_succ_edge (a)->flags & EDGE_COMPLEX)\n \t  && a->next_bb == b\n-\t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n+\t  && a != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  && b != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */\n \t  && (!JUMP_P (BB_END (a))\n@@ -972,7 +973,7 @@ rtl_can_merge_blocks (basic_block a, basic_block b)\n rtx\n block_label (basic_block block)\n {\n-  if (block == EXIT_BLOCK_PTR)\n+  if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return NULL_RTX;\n \n   if (!LABEL_P (BB_HEAD (block)))\n@@ -1084,13 +1085,13 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t INSN_UID (insn), e->dest->index, target->index);\n       if (!redirect_jump (insn, block_label (target), 0))\n \t{\n-\t  gcc_assert (target == EXIT_BLOCK_PTR);\n+\t  gcc_assert (target == EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t  return NULL;\n \t}\n     }\n \n   /* Cannot do anything for target exit block.  */\n-  else if (target == EXIT_BLOCK_PTR)\n+  else if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return NULL;\n \n   /* Or replace possibly complicated jump insn by simple jump insn.  */\n@@ -1178,7 +1179,7 @@ patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n       int j;\n       rtx new_label = block_label (new_bb);\n \n-      if (new_bb == EXIT_BLOCK_PTR)\n+      if (new_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \treturn false;\n       if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n \tvec = XVEC (PATTERN (tmp), 0);\n@@ -1211,7 +1212,7 @@ patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n       int i, n = ASM_OPERANDS_LABEL_LENGTH (tmp);\n       rtx new_label, note;\n \n-      if (new_bb == EXIT_BLOCK_PTR)\n+      if (new_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \treturn false;\n       new_label = block_label (new_bb);\n \n@@ -1268,7 +1269,7 @@ patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n \t     target is exit block on some arches.  */\n \t  if (!redirect_jump (insn, block_label (new_bb), 0))\n \t    {\n-\t      gcc_assert (new_bb == EXIT_BLOCK_PTR);\n+\t      gcc_assert (new_bb == EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t      return false;\n \t    }\n \t}\n@@ -1324,7 +1325,8 @@ fixup_partition_crossing (edge e)\n {\n   rtx note;\n \n-  if (e->src == ENTRY_BLOCK_PTR || e->dest == EXIT_BLOCK_PTR)\n+  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun) || e->dest\n+      == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return;\n   /* If we redirected an existing edge, it may already be marked\n      crossing, even though the new src is missing a reg crossing note.\n@@ -1392,7 +1394,7 @@ fixup_new_cold_bb (basic_block bb)\n          boundary fixup by calling fixup_partition_crossing itself.  */\n       if ((e->flags & EDGE_FALLTHRU)\n           && BB_PARTITION (bb) != BB_PARTITION (e->dest)\n-          && e->dest != EXIT_BLOCK_PTR)\n+\t  && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n         force_nonfallthru (e);\n       else\n         fixup_partition_crossing (e);\n@@ -1470,7 +1472,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n   /* In the case the last instruction is conditional jump to the next\n      instruction, first redirect the jump itself and then continue\n      by creating a basic block afterwards to redirect fallthru edge.  */\n-  if (e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR\n+  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+      && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n       && any_condjump_p (BB_END (e->src))\n       && JUMP_LABEL (BB_END (e->src)) == BB_HEAD (e->dest))\n     {\n@@ -1512,7 +1515,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n   else\n     {\n       gcc_assert (e->flags & EDGE_FALLTHRU);\n-      if (e->src == ENTRY_BLOCK_PTR)\n+      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  /* We can't redirect the entry block.  Create an empty block\n \t     at the start of the function which we use to add the new\n@@ -1521,16 +1524,18 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t  edge_iterator ei;\n \t  bool found = false;\n \n-\t  basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n+\t  basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL,\n+\t\t\t\t\t       ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n \t  /* Change the existing edge's source to be the new block, and add\n \t     a new edge from the entry block to the new block.  */\n \t  e->src = bb;\n-\t  for (ei = ei_start (ENTRY_BLOCK_PTR->succs); (tmp = ei_safe_edge (ei)); )\n+\t  for (ei = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n+\t       (tmp = ei_safe_edge (ei)); )\n \t    {\n \t      if (tmp == e)\n \t\t{\n-\t\t  ENTRY_BLOCK_PTR->succs->unordered_remove (ei.index);\n+\t\t  ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs->unordered_remove (ei.index);\n \t\t  found = true;\n \t\t  break;\n \t\t}\n@@ -1541,14 +1546,15 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t  gcc_assert (found);\n \n \t  vec_safe_push (bb->succs, e);\n-\t  make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n+\t  make_single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb,\n+\t\t\t\t EDGE_FALLTHRU);\n \t}\n     }\n \n   /* If e->src ends with asm goto, see if any of the ASM_OPERANDS_LABELs\n      don't point to the target or fallthru label.  */\n   if (JUMP_P (BB_END (e->src))\n-      && target != EXIT_BLOCK_PTR\n+      && target != EXIT_BLOCK_PTR_FOR_FN (cfun)\n       && (e->flags & EDGE_FALLTHRU)\n       && (note = extract_asm_operands (PATTERN (BB_END (e->src)))))\n     {\n@@ -1650,7 +1656,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \n   loc = e->goto_locus;\n   e->flags &= ~EDGE_FALLTHRU;\n-  if (target == EXIT_BLOCK_PTR)\n+  if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       if (jump_label == ret_rtx)\n \t{\n@@ -1784,7 +1790,7 @@ static basic_block\n last_bb_in_partition (basic_block start_bb)\n {\n   basic_block bb;\n-  FOR_BB_BETWEEN (bb, start_bb, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, start_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       if (BB_PARTITION (start_bb) != BB_PARTITION (bb->next_bb))\n         return bb;\n@@ -1820,22 +1826,23 @@ rtl_split_edge (edge edge_in)\n     }\n \n   /* Create the basic block note.  */\n-  if (edge_in->dest != EXIT_BLOCK_PTR)\n+  if (edge_in->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     before = BB_HEAD (edge_in->dest);\n   else\n     before = NULL_RTX;\n \n   /* If this is a fall through edge to the exit block, the blocks might be\n      not adjacent, and the right place is after the source.  */\n-  if ((edge_in->flags & EDGE_FALLTHRU) && edge_in->dest == EXIT_BLOCK_PTR)\n+  if ((edge_in->flags & EDGE_FALLTHRU)\n+      && edge_in->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       before = NEXT_INSN (BB_END (edge_in->src));\n       bb = create_basic_block (before, NULL, edge_in->src);\n       BB_COPY_PARTITION (bb, edge_in->src);\n     }\n   else\n     {\n-      if (edge_in->src == ENTRY_BLOCK_PTR)\n+      if (edge_in->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n         {\n           bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n           BB_COPY_PARTITION (bb, edge_in->dest);\n@@ -1873,7 +1880,7 @@ rtl_split_edge (edge edge_in)\n \n   /* Can't allow a region crossing edge to be fallthrough.  */\n   if (BB_PARTITION (bb) != BB_PARTITION (edge_in->dest)\n-      && edge_in->dest != EXIT_BLOCK_PTR)\n+      && edge_in->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       new_bb = force_nonfallthru (single_succ_edge (bb));\n       gcc_assert (!new_bb);\n@@ -1888,15 +1895,15 @@ rtl_split_edge (edge edge_in)\n     }\n   else\n     {\n-      if (edge_in->src != ENTRY_BLOCK_PTR)\n+      if (edge_in->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  /* For asm goto even splitting of fallthru edge might\n \t     need insn patching, as other labels might point to the\n \t     old label.  */\n \t  rtx last = BB_END (edge_in->src);\n \t  if (last\n \t      && JUMP_P (last)\n-\t      && edge_in->dest != EXIT_BLOCK_PTR\n+\t      && edge_in->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      && extract_asm_operands (PATTERN (last)) != NULL_RTX\n \t      && patch_jump_insn (last, before, bb))\n \t    df_set_bb_dirty (edge_in->src);\n@@ -1943,7 +1950,7 @@ commit_one_edge_insertion (edge e)\n \n   /* Figure out where to put these insns.  If the destination has\n      one predecessor, insert there.  Except for the exit block.  */\n-  if (single_pred_p (e->dest) && e->dest != EXIT_BLOCK_PTR)\n+  if (single_pred_p (e->dest) && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       bb = e->dest;\n \n@@ -1972,7 +1979,7 @@ commit_one_edge_insertion (edge e)\n      the basic block.  */\n   else if ((e->flags & EDGE_ABNORMAL) == 0\n \t   && single_succ_p (e->src)\n-\t   && e->src != ENTRY_BLOCK_PTR\n+\t   && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t   && (!JUMP_P (BB_END (e->src))\n \t       || simplejump_p (BB_END (e->src))))\n     {\n@@ -2025,7 +2032,7 @@ commit_one_edge_insertion (edge e)\n \t to EXIT.  */\n \n       e = single_succ_edge (bb);\n-      gcc_assert (e->dest == EXIT_BLOCK_PTR\n+      gcc_assert (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && single_succ_p (bb) && (e->flags & EDGE_FALLTHRU));\n \n       e->flags &= ~EDGE_FALLTHRU;\n@@ -2057,7 +2064,8 @@ commit_edge_insertions (void)\n   verify_flow_info ();\n #endif\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -2428,8 +2436,8 @@ rtl_verify_edges (void)\n \t    n_fallthru++, fallthru = e;\n \n \t  is_crossing = (BB_PARTITION (e->src) != BB_PARTITION (e->dest)\n-\t\t\t && e->src != ENTRY_BLOCK_PTR\n-\t\t\t && e->dest != EXIT_BLOCK_PTR);\n+\t\t\t && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t\t\t && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun));\n           has_crossing_edge |= is_crossing;\n \t  if (e->flags & EDGE_CROSSING)\n \t    {\n@@ -2832,8 +2840,8 @@ rtl_verify_fallthru (void)\n \t\tbreak;\n \t    }\n \t}\n-      else if (e->src != ENTRY_BLOCK_PTR\n-\t       && e->dest != EXIT_BLOCK_PTR)\n+      else if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t       && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  rtx insn;\n \n@@ -2872,10 +2880,10 @@ rtl_verify_bb_layout (void)\n   rtx x;\n   int num_bb_notes;\n   const rtx rtx_first = get_insns ();\n-  basic_block last_bb_seen = ENTRY_BLOCK_PTR, curr_bb = NULL;\n+  basic_block last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun), curr_bb = NULL;\n \n   num_bb_notes = 0;\n-  last_bb_seen = ENTRY_BLOCK_PTR;\n+  last_bb_seen = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   for (x = rtx_first; x; x = NEXT_INSN (x))\n     {\n@@ -3062,15 +3070,16 @@ purge_dead_edges (basic_block bb)\n \t      ei_next (&ei);\n \t      continue;\n \t    }\n-\t  else if (e->dest != EXIT_BLOCK_PTR\n+\t  else if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t   && BB_HEAD (e->dest) == JUMP_LABEL (insn))\n \t    /* If the destination block is the target of the jump,\n \t       keep the edge.  */\n \t    {\n \t      ei_next (&ei);\n \t      continue;\n \t    }\n-\t  else if (e->dest == EXIT_BLOCK_PTR && returnjump_p (insn))\n+\t  else if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t\t   && returnjump_p (insn))\n \t    /* If the destination block is the exit block, and this\n \t       instruction is a return, then keep the edge.  */\n \t    {\n@@ -3319,7 +3328,7 @@ skip_insns_after_block (basic_block bb)\n   rtx insn, last_insn, next_head, prev;\n \n   next_head = NULL_RTX;\n-  if (bb->next_bb != EXIT_BLOCK_PTR)\n+  if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     next_head = BB_HEAD (bb->next_bb);\n \n   for (last_insn = insn = BB_END (bb); (insn = NEXT_INSN (insn)) != 0; )\n@@ -3468,7 +3477,7 @@ outof_cfg_layout_mode (void)\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n+    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n       bb->aux = bb->next_bb;\n \n   cfg_layout_finalize ();\n@@ -3577,7 +3586,8 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Reordered sequence:\\n\");\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n+      for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb, index =\n+\t   NUM_FIXED_BLOCKS;\n \t   bb;\n \t   bb = (basic_block) bb->aux, index++)\n \t{\n@@ -3595,15 +3605,15 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n     }\n \n   /* Now reorder the blocks.  */\n-  prev_bb = ENTRY_BLOCK_PTR;\n-  bb = ENTRY_BLOCK_PTR->next_bb;\n+  prev_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n   for (; bb; prev_bb = bb, bb = (basic_block) bb->aux)\n     {\n       bb->prev_bb = prev_bb;\n       prev_bb->next_bb = bb;\n     }\n-  prev_bb->next_bb = EXIT_BLOCK_PTR;\n-  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n+  prev_bb->next_bb = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb = prev_bb;\n \n   /* Then, clean up the aux fields.  */\n   FOR_ALL_BB (bb)\n@@ -3644,7 +3654,8 @@ fixup_reorder_chain (void)\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = (basic_block) bb->aux)\n+  for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb; bb = (basic_block)\n+       bb->aux)\n     {\n       if (BB_HEADER (bb))\n \t{\n@@ -3687,7 +3698,8 @@ fixup_reorder_chain (void)\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = (basic_block) bb->aux)\n+  for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ; bb = (basic_block)\n+       bb->aux)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -3728,7 +3740,7 @@ fixup_reorder_chain (void)\n \n \t      /* If the old fallthru is still next, nothing to do.  */\n \t      if (bb->aux == e_fall->dest\n-\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n+\t\t  || e_fall->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\tcontinue;\n \n \t      /* The degenerated case of conditional jump jumping to the next\n@@ -3749,7 +3761,8 @@ fixup_reorder_chain (void)\n \t\t  if (note\n \t\t      && XINT (note, 0) < REG_BR_PROB_BASE / 2\n \t\t      && invert_jump (bb_end_insn,\n-\t\t\t\t      (e_fall->dest == EXIT_BLOCK_PTR\n+\t\t\t\t      (e_fall->dest\n+\t\t\t\t       == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t\t       ? NULL_RTX\n \t\t\t\t       : label_for_bb (e_fall->dest)), 0))\n \t\t    {\n@@ -3771,7 +3784,8 @@ fixup_reorder_chain (void)\n \t      /* Otherwise we can try to invert the jump.  This will\n \t\t basically never fail, however, keep up the pretense.  */\n \t      else if (invert_jump (bb_end_insn,\n-\t\t\t\t    (e_fall->dest == EXIT_BLOCK_PTR\n+\t\t\t\t    (e_fall->dest\n+\t\t\t\t     == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t\t     ? NULL_RTX\n \t\t\t\t     : label_for_bb (e_fall->dest)), 0))\n \t\t{\n@@ -3793,7 +3807,7 @@ fixup_reorder_chain (void)\n \t\t __builtin_unreachable ()), nothing to do.  */\n \t      if (! e_fall\n \t\t  || bb->aux == e_fall->dest\n-\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n+\t\t  || e_fall->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\tcontinue;\n \n \t      /* Otherwise we'll have to use the fallthru fixup below.  */\n@@ -3820,7 +3834,7 @@ fixup_reorder_chain (void)\n \t    continue;\n \n \t  /* A fallthru to exit block.  */\n-\t  if (e_fall->dest == EXIT_BLOCK_PTR)\n+\t  if (e_fall->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    continue;\n \t}\n \n@@ -3880,7 +3894,7 @@ fixup_reorder_chain (void)\n \t\t  continue;\n \t\t}\n \t      dest = e->dest;\n-\t      if (dest == EXIT_BLOCK_PTR)\n+\t      if (dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t{\n \t\t  /* Non-fallthru edges to the exit block cannot be split.  */\n \t\t  if (!(e->flags & EDGE_FALLTHRU))\n@@ -3958,13 +3972,13 @@ fixup_fallthru_exit_predecessor (void)\n      value.  */\n   gcc_assert (reload_completed);\n \n-  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n+  e = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n   if (e)\n     bb = e->src;\n \n   if (bb && bb->aux)\n     {\n-      basic_block c = ENTRY_BLOCK_PTR->next_bb;\n+      basic_block c = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;\n \n       /* If the very first block is the one with the fall-through exit\n \t edge, we have to split that block.  */\n@@ -4000,7 +4014,7 @@ force_one_exit_fallthru (void)\n   edge_iterator ei;\n   basic_block forwarder, bb;\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       {\n \tif (predecessor == NULL)\n@@ -4018,7 +4032,8 @@ force_one_exit_fallthru (void)\n   /* Exit has several fallthru predecessors.  Create a forwarder block for\n      them.  */\n   forwarder = split_edge (predecessor);\n-  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n+  for (ei = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n+       (e = ei_safe_edge (ei)); )\n     {\n       if (e->src == forwarder\n \t  || !(e->flags & EDGE_FALLTHRU))\n@@ -4166,7 +4181,7 @@ cfg_layout_duplicate_bb (basic_block bb)\n   insn = duplicate_insn_chain (BB_HEAD (bb), BB_END (bb));\n   new_bb = create_basic_block (insn,\n \t\t\t       insn ? get_last_insn () : NULL,\n-\t\t\t       EXIT_BLOCK_PTR->prev_bb);\n+\t\t\t       EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n \n   BB_COPY_PARTITION (new_bb, bb);\n   if (BB_HEADER (bb))\n@@ -4313,14 +4328,14 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->dest == dest)\n     return e;\n \n-  if (e->src != ENTRY_BLOCK_PTR\n+  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       && (ret = try_redirect_by_replacing_jump (e, dest, true)))\n     {\n       df_set_bb_dirty (src);\n       return ret;\n     }\n \n-  if (e->src == ENTRY_BLOCK_PTR\n+  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       && (e->flags & EDGE_FALLTHRU) && !(e->flags & EDGE_COMPLEX))\n     {\n       if (dump_file)\n@@ -4447,7 +4462,7 @@ cfg_layout_delete_block (basic_block bb)\n \t    set_last_insn (insn);\n \t}\n     }\n-  if (bb->next_bb != EXIT_BLOCK_PTR)\n+  if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     to = &BB_HEADER (bb->next_bb);\n   else\n     to = &cfg_layout_function_footer;\n@@ -4504,7 +4519,7 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n   if (NEXT_INSN (BB_END (a)) != BB_HEAD (b))\n     {\n       edge e = find_fallthru_edge (b->succs);\n-      if (e && e->dest == EXIT_BLOCK_PTR)\n+      if (e && e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \treturn false;\n     }\n \n@@ -4515,7 +4530,8 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n \t  && a != b\n \t  /* Must be simple edge.  */\n \t  && !(single_succ_edge (a)->flags & EDGE_COMPLEX)\n-\t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n+\t  && a != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  && b != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  /* If the jump insn has side effects, we can't kill the edge.\n \t     When not optimizing, try_redirect_by_replacing_jump will\n \t     not allow us to redirect an edge by replacing a table jump.  */\n@@ -4634,11 +4650,11 @@ static basic_block\n cfg_layout_split_edge (edge e)\n {\n   basic_block new_bb =\n-    create_basic_block (e->src != ENTRY_BLOCK_PTR\n+    create_basic_block (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t? NEXT_INSN (BB_END (e->src)) : get_insns (),\n \t\t\tNULL_RTX, e->src);\n \n-  if (e->dest == EXIT_BLOCK_PTR)\n+  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     BB_COPY_PARTITION (new_bb, e->src);\n   else\n     BB_COPY_PARTITION (new_bb, e->dest);\n@@ -4663,7 +4679,8 @@ rtl_block_empty_p (basic_block bb)\n {\n   rtx insn;\n \n-  if (bb == ENTRY_BLOCK_PTR || bb == EXIT_BLOCK_PTR)\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+      || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return true;\n \n   FOR_BB_INSNS (bb, insn)\n@@ -4770,7 +4787,8 @@ rtl_flow_call_edges_add (sbitmap blocks)\n   if (! blocks)\n     check_last_block = true;\n   else\n-    check_last_block = bitmap_bit_p (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n+    check_last_block = bitmap_bit_p (blocks,\n+\t\t\t\t     EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb->index);\n \n   /* In the last basic block, before epilogue generation, there will be\n      a fallthru edge to EXIT.  Special care is required if the last insn\n@@ -4786,7 +4804,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n      Handle this by adding a dummy instruction in a new last basic block.  */\n   if (check_last_block)\n     {\n-      basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n+      basic_block bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n       rtx insn = BB_END (bb);\n \n       /* Back up past insns that must be kept in the same block as a call.  */\n@@ -4798,7 +4816,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \t{\n \t  edge e;\n \n-\t  e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t  e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t  if (e)\n \t    {\n \t      insert_insn_on_edge (gen_use (const0_rtx), e);\n@@ -4846,7 +4864,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n #ifdef ENABLE_CHECKING\n \t      if (split_at_insn == BB_END (bb))\n \t\t{\n-\t\t  e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t\t  e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t\t  gcc_assert (e == NULL);\n \t\t}\n #endif\n@@ -4860,7 +4878,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \t\t    blocks_split++;\n \t\t}\n \n-\t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+\t      make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n \t    }\n \n \t  if (insn == BB_HEAD (bb))\n@@ -4952,7 +4970,7 @@ rtl_can_remove_branch_p (const_edge e)\n   const_rtx insn = BB_END (src), set;\n \n   /* The conditions are taken from try_redirect_by_replacing_jump.  */\n-  if (target == EXIT_BLOCK_PTR)\n+  if (target == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return false;\n \n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))"}, {"sha": "21f6ebe8d09185ad1415fefdccab932874d2b1f9", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -198,7 +198,7 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n int\n compute_call_stmt_bb_frequency (tree decl, basic_block bb)\n {\n-  int entry_freq = ENTRY_BLOCK_PTR_FOR_FUNCTION\n+  int entry_freq = ENTRY_BLOCK_PTR_FOR_FN\n   \t\t     (DECL_STRUCT_FUNCTION (decl))->frequency;\n   int freq = bb->frequency;\n \n@@ -441,7 +441,7 @@ rebuild_cgraph_edges (void)\n   cgraph_node_remove_callees (node);\n   ipa_remove_all_references (&node->ref_list);\n \n-  node->count = ENTRY_BLOCK_PTR->count;\n+  node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n   FOR_EACH_BB (bb)\n     {\n@@ -493,7 +493,7 @@ cgraph_rebuild_references (void)\n     else\n       i++;\n \n-  node->count = ENTRY_BLOCK_PTR->count;\n+  node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n   FOR_EACH_BB (bb)\n     {"}, {"sha": "fb23abed8daa859f452c063a0c5a695e8f0a45ca", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1336,10 +1336,10 @@ init_lowered_empty_function (tree decl, bool in_ssa)\n   loops_for_fn (cfun)->state |= LOOPS_MAY_HAVE_MULTIPLE_LATCHES;\n \n   /* Create BB for body of the function and connect it properly.  */\n-  bb = create_basic_block (NULL, (void *) 0, ENTRY_BLOCK_PTR);\n-  make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n-  make_edge (bb, EXIT_BLOCK_PTR, 0);\n-  add_bb_to_loop (bb, ENTRY_BLOCK_PTR->loop_father);\n+  bb = create_basic_block (NULL, (void *) 0, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FALLTHRU);\n+  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+  add_bb_to_loop (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father);\n \n   return bb;\n }\n@@ -1627,7 +1627,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks)\n \t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n \t\t  make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n \t\t  make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n-\t\t  make_edge (return_bb, EXIT_BLOCK_PTR, 0);\n+\t\t  make_edge (return_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \t\t  make_edge (then_bb, return_bb, EDGE_FALLTHRU);\n \t\t  make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n \t\t  bsi = gsi_last_bb (then_bb);"}, {"sha": "d685a7f6a660acb66b4782193bb3a52f4ec0cdeb", "filename": "gcc/combine.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1157,7 +1157,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   setup_incoming_promotions (first);\n   /* Allow the entry block and the first block to fall into the same EBB.\n      Conceptually the incoming promotions are assigned to the entry block.  */\n-  last_bb = ENTRY_BLOCK_PTR;\n+  last_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   create_log_links ();\n   FOR_EACH_BB (this_basic_block)\n@@ -1209,7 +1209,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   label_tick = label_tick_ebb_start = 1;\n   init_reg_last ();\n   setup_incoming_promotions (first);\n-  last_bb = ENTRY_BLOCK_PTR;\n+  last_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   FOR_EACH_BB (this_basic_block)\n     {\n@@ -1592,7 +1592,7 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n       && ! REGNO_REG_SET_P\n-           (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x))\n+\t   (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb), REGNO (x))\n       && HWI_COMPUTABLE_MODE_P (GET_MODE (x)))\n     {\n       reg_stat_type *rsp = &reg_stat[REGNO (x)];\n@@ -3938,7 +3938,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \tni2dest = SET_DEST (newi2pat);\n \n       for (insn = NEXT_INSN (i3);\n-\t   insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n+\t   insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t    || insn != BB_HEAD (this_basic_block->next_bb));\n \t   insn = NEXT_INSN (insn))\n \t{\n@@ -4054,7 +4054,8 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p,\n \t      && ! find_reg_note (i2, REG_UNUSED,\n \t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n \t    for (temp = NEXT_INSN (i2);\n-\t\t temp && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n+\t\t temp\n+\t\t && (this_basic_block->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t  || BB_HEAD (this_basic_block) != temp);\n \t\t temp = NEXT_INSN (temp))\n \t      if (temp != i3 && INSN_P (temp))\n@@ -9468,7 +9469,8 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && !REGNO_REG_SET_P\n-\t          (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x)))))\n+\t\t  (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n+\t\t   REGNO (x)))))\n     {\n       *nonzero &= rsp->last_set_nonzero_bits;\n       return NULL;\n@@ -9535,7 +9537,8 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && !REGNO_REG_SET_P\n-\t          (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), REGNO (x)))))\n+\t\t  (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n+\t\t   REGNO (x)))))\n     {\n       *result = rsp->last_set_sign_bit_copies;\n       return NULL;\n@@ -12564,7 +12567,8 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \t      || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t     && REG_N_SETS (regno) == 1\n \t\t     && (!REGNO_REG_SET_P\n-\t\t\t (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), regno)))\n+\t\t\t (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n+\t\t\t  regno)))\n \t\t  && rsp->last_set_label > tick))\n \t  {\n \t    if (replace)\n@@ -12679,7 +12683,7 @@ get_last_value (const_rtx x)\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || REGNO_REG_SET_P\n-\t\t (DF_LR_IN (ENTRY_BLOCK_PTR->next_bb), regno))))\n+\t\t (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb), regno))))\n     return 0;\n \n   /* If the value was set in a later insn than the ones we are processing,\n@@ -13740,7 +13744,7 @@ distribute_links (struct insn_link *links)\n \t since most links don't point very far away.  */\n \n       for (insn = NEXT_INSN (link->insn);\n-\t   (insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n+\t   (insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t     || BB_HEAD (this_basic_block->next_bb) != insn));\n \t   insn = NEXT_INSN (insn))\n \tif (DEBUG_INSN_P (insn))"}, {"sha": "c55835e7fe19596b51ebc21b7d081ae5035fe8df", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -4835,7 +4835,8 @@ alpha_gp_save_rtx (void)\n \t label.  Emit the sequence properly on the edge.  We are only\n \t invoked from dw2_build_landing_pads and finish_eh_generation\n \t will call commit_edge_insertions thanks to a kludge.  */\n-      insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR));\n+      insert_insn_on_edge (seq,\n+\t\t\t   single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \n       cfun->machine->gp_save_rtx = m;\n     }"}, {"sha": "e8b5f8376ec9c55975570cc1fc043bf82abc5185", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -5943,7 +5943,8 @@ require_pic_register (void)\n \t         we can't yet emit instructions directly in the final\n \t\t insn stream.  Queue the insns on the entry edge, they will\n \t\t be committed after everything else is expanded.  */\n-\t      insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR));\n+\t      insert_insn_on_edge (seq,\n+\t\t\t\t   single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t    }\n \t}\n     }\n@@ -18386,7 +18387,8 @@ arm_r3_live_at_start_p (void)\n   /* Just look at cfg info, which is still close enough to correct at this\n      point.  This gives false positives for broken functions that might use\n      uninitialized data that happens to be allocated in r3, but who cares?  */\n-  return REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR), 3);\n+  return REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t  3);\n }\n \n /* Compute the number of bytes used to store the static chain register on the\n@@ -19919,7 +19921,7 @@ any_sibcall_could_use_r3 (void)\n \n   if (!crtl->tail_call_emit)\n     return false;\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (e->flags & EDGE_SIBCALL)\n       {\n \trtx call = BB_END (e->src);"}, {"sha": "d7af939ebdaec8c714a0d7be1dc9c69fcf80bf82", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3600,7 +3600,7 @@ hwloop_optimize (hwloop_info loop)\n \n       if (single_pred_p (bb)\n \t  && single_pred_edge (bb)->flags & EDGE_FALLTHRU\n-\t  && single_pred (bb) != ENTRY_BLOCK_PTR)\n+\t  && single_pred (bb) != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  bb = single_pred (bb);\n \t  last_insn = BB_END (bb);"}, {"sha": "a5eb2c1c8444690fc8ebfe3adc741af99722bf2b", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -8027,7 +8027,7 @@ frv_optimize_membar_global (basic_block bb, struct frv_io *first_io,\n   /* We need to keep the membar if there is an edge to the exit block.  */\n   FOR_EACH_EDGE (succ, ei, bb->succs)\n   /* for (succ = bb->succ; succ != 0; succ = succ->succ_next) */\n-    if (succ->dest == EXIT_BLOCK_PTR)\n+    if (succ->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n       return;\n \n   /* Work out the union of all successor blocks.  */"}, {"sha": "b702413d5e32aa749e28368eee1facf2f9b68869", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -5593,7 +5593,7 @@ ix86_eax_live_at_start_p (void)\n      to correct at this point.  This gives false positives for broken\n      functions that might use uninitialized data that happens to be\n      allocated in eax, but who cares?  */\n-  return REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR), 0);\n+  return REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)), 0);\n }\n \n static bool\n@@ -9301,7 +9301,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      Recompute the value as needed.  Do not recompute when amount of registers\n      didn't change as reload does multiple calls to the function and does not\n      expect the decision to change within single iteration.  */\n-  else if (!optimize_bb_for_size_p (ENTRY_BLOCK_PTR)\n+  else if (!optimize_bb_for_size_p (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n            && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n     {\n       int count = frame->nregs;\n@@ -11390,7 +11390,7 @@ ix86_expand_epilogue (int style)\n       /* Leave results in shorter dependency chains on CPUs that are\n \t able to grok it fast.  */\n       else if (TARGET_USE_LEAVE\n-\t       || optimize_bb_for_size_p (EXIT_BLOCK_PTR)\n+\t       || optimize_bb_for_size_p (EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t       || !cfun->machine->use_fast_prologue_epilogue)\n \tix86_emit_leave ();\n       else\n@@ -29838,7 +29838,7 @@ add_condition_to_bb (tree function_decl, tree version_decl,\n   make_edge (bb1, bb3, EDGE_FALSE_VALUE); \n \n   remove_edge (e23);\n-  make_edge (bb2, EXIT_BLOCK_PTR, 0);\n+  make_edge (bb2, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \n   pop_cfun ();\n \n@@ -36573,7 +36573,7 @@ ix86_pad_returns (void)\n   edge e;\n   edge_iterator ei;\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       basic_block bb = e->src;\n       rtx ret = BB_END (bb);\n@@ -36673,14 +36673,14 @@ ix86_count_insn (basic_block bb)\n       edge prev_e;\n       edge_iterator prev_ei;\n \n-      if (e->src == ENTRY_BLOCK_PTR)\n+      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  min_prev_count = 0;\n \t  break;\n \t}\n       FOR_EACH_EDGE (prev_e, prev_ei, e->src->preds)\n \t{\n-\t  if (prev_e->src == ENTRY_BLOCK_PTR)\n+\t  if (prev_e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      int count = ix86_count_insn_bb (e->src);\n \t      if (count < min_prev_count)\n@@ -36704,7 +36704,7 @@ ix86_pad_short_function (void)\n   edge e;\n   edge_iterator ei;\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       rtx ret = BB_END (e->src);\n       if (JUMP_P (ret) && ANY_RETURN_P (PATTERN (ret)))\n@@ -36744,7 +36744,7 @@ ix86_seh_fixup_eh_fallthru (void)\n   edge e;\n   edge_iterator ei;\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       rtx insn, next;\n "}, {"sha": "71bc666b685035cf08266eb712eacfc7866adb27", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3492,7 +3492,7 @@ ia64_expand_prologue (void)\n       edge e;\n       edge_iterator ei;\n \n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \tif ((e->flags & EDGE_FAKE) == 0\n \t    && (e->flags & EDGE_FALLTHRU) != 0)\n \t  break;\n@@ -10187,7 +10187,8 @@ ia64_asm_unwind_emit (FILE *asm_out_file, rtx insn)\n \n   if (NOTE_INSN_BASIC_BLOCK_P (insn))\n     {\n-      last_block = NOTE_BASIC_BLOCK (insn)->next_bb == EXIT_BLOCK_PTR;\n+      last_block = NOTE_BASIC_BLOCK (insn)->next_bb\n+     == EXIT_BLOCK_PTR_FOR_FN (cfun);\n \n       /* Restore unwind state from immediately before the epilogue.  */\n       if (need_copy_state)"}, {"sha": "008f088df571ed7497343c9ad8cf89c7913ad639", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -4566,7 +4566,7 @@ nds32_fp_as_gp_check_available (void)\n       || frame_pointer_needed\n       || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n       || (cfun->stdarg == 1)\n-      || (find_fallthru_edge (EXIT_BLOCK_PTR->preds) == NULL))\n+      || (find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == NULL))\n     return 0;\n \n   /* Now we can check the possibility of using fp_as_gp optimization.  */"}, {"sha": "7556eb6385e5fa43412bd2f5694367c6a3b1dfa7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -22953,7 +22953,7 @@ rs6000_emit_prologue (void)\n \t\t\t\t      && DEFAULT_ABI == ABI_V4\n \t\t\t\t      && flag_pic\n \t\t\t\t      && ! info->lr_save_p\n-\t\t\t\t      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0);\n+\t\t\t\t      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) > 0);\n       if (save_LR_around_toc_setup)\n \t{\n \t  rtx lr = gen_rtx_REG (Pmode, LR_REGNO);"}, {"sha": "9b8bd1e0c4b5b57aaa149e782e3ad854d6fd080a", "filename": "gcc/cprop.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -967,7 +967,7 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n       edge_iterator ei;\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t    && BB_HEAD (e->dest) == JUMP_LABEL (jump))\n \t  {\n \t    e->flags |= EDGE_FALLTHRU;\n@@ -1376,7 +1376,7 @@ find_implicit_sets (void)\n \t? BRANCH_EDGE (bb)->dest : FALLTHRU_EDGE (bb)->dest;\n \n       /* If DEST doesn't go anywhere, ignore it.  */\n-      if (! dest || dest == EXIT_BLOCK_PTR)\n+      if (! dest || dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       /* We have found a suitable implicit set.  Try to record it now as\n@@ -1612,7 +1612,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  old_dest = e->dest;\n \t  if (dest != NULL\n \t      && dest != old_dest\n-\t      && dest != EXIT_BLOCK_PTR)\n+\t      && dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n             {\n \t      redirect_edge_and_branch_force (e, dest);\n \n@@ -1664,15 +1664,15 @@ bypass_conditional_jumps (void)\n   rtx dest;\n \n   /* Note we start at block 1.  */\n-  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return 0;\n \n   bypass_last_basic_block = last_basic_block;\n   mark_dfs_back_edges ();\n \n   changed = 0;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb,\n-\t\t  EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->next_bb,\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       /* Check for more than one predecessor.  */\n       if (!single_pred_p (bb))\n@@ -1836,7 +1836,8 @@ one_cprop_pass (void)\n       /* Allocate vars to track sets of regs.  */\n       reg_set_bitmap = ALLOC_REG_SET (NULL);\n \n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR,\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->next_bb,\n+\t\t      EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t\t      next_bb)\n \t{\n \t  /* Reset tables used to keep track of what's still valid [since"}, {"sha": "e0f77964c15286fdeaff2c5cc5efdec9d6ed29e7", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -6200,7 +6200,7 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n \t      && e == BRANCH_EDGE (previous_bb_in_path))\n \t    {\n \t      bb = FALLTHRU_EDGE (previous_bb_in_path)->dest;\n-\t      if (bb != EXIT_BLOCK_PTR\n+\t      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && single_pred_p (bb)\n \t\t  /* We used to assert here that we would only see blocks\n \t\t     that we have not visited yet.  But we may end up\n@@ -6254,7 +6254,7 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n \n \t  if (e\n \t      && !((e->flags & EDGE_ABNORMAL_CALL) && cfun->has_nonlocal_label)\n-\t      && e->dest != EXIT_BLOCK_PTR\n+\t      && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      && single_pred_p (e->dest)\n \t      /* Avoid visiting basic blocks twice.  The large comment\n \t\t above explains why this can happen.  */\n@@ -7166,7 +7166,7 @@ cse_cc_succs (basic_block bb, basic_block orig_bb, rtx cc_reg, rtx cc_src,\n \tcontinue;\n \n       if (EDGE_COUNT (e->dest->preds) != 1\n-\t  || e->dest == EXIT_BLOCK_PTR\n+\t  || e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  /* Avoid endless recursion on unreachable blocks.  */\n \t  || e->dest == orig_bb)\n \tcontinue;"}, {"sha": "c6349c8b0a5389acfe2abbff95e9aa79c36cc482", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1007,7 +1007,7 @@ static void\n df_lr_confluence_0 (basic_block bb)\n {\n   bitmap op1 = &df_lr_get_bb_info (bb->index)->out;\n-  if (bb != EXIT_BLOCK_PTR)\n+  if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     bitmap_copy (op1, &df->hardware_regs_used);\n }\n "}, {"sha": "eb7e4d47e0ca673812a11156ef664e94265c7e1d", "filename": "gcc/df-scan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3873,7 +3873,7 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n       df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n-\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0);\n+\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, DF_REF_REG_DEF, 0);\n     }\n \n   df_canonize_collection_rec (collection_rec);\n@@ -4034,17 +4034,17 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);\n+\t\t   EXIT_BLOCK_PTR_FOR_FN (cfun), NULL, DF_REF_REG_USE, 0);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n   /* It is deliberate that this is not put in the exit block uses but\n      I do not know why.  */\n   if (reload_completed\n       && !bitmap_bit_p (exit_block_uses, ARG_POINTER_REGNUM)\n-      && bb_has_eh_pred (EXIT_BLOCK_PTR)\n+      && bb_has_eh_pred (EXIT_BLOCK_PTR_FOR_FN (cfun))\n       && fixed_regs[ARG_POINTER_REGNUM])\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);\n+\t\t   EXIT_BLOCK_PTR_FOR_FN (cfun), NULL, DF_REF_REG_USE, 0);\n #endif\n \n   df_canonize_collection_rec (collection_rec);"}, {"sha": "3d88c0d3ed109de0e52ec0ef04faea245cb2b9ee", "filename": "gcc/dominance.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -240,14 +240,14 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n   if (reverse)\n     {\n       ei = ei_start (bb->preds);\n-      en_block = EXIT_BLOCK_PTR;\n-      ex_block = ENTRY_BLOCK_PTR;\n+      en_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+      ex_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n     }\n   else\n     {\n       ei = ei_start (bb->succs);\n-      en_block = ENTRY_BLOCK_PTR;\n-      ex_block = EXIT_BLOCK_PTR;\n+      en_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+      ex_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n     }\n \n   /* When the stack is empty we break out of this loop.  */\n@@ -333,7 +333,8 @@ static void\n calc_dfs_tree (struct dom_info *di, bool reverse)\n {\n   /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n-  basic_block begin = reverse ? EXIT_BLOCK_PTR : ENTRY_BLOCK_PTR;\n+  basic_block begin = (reverse\n+\t\t       ? EXIT_BLOCK_PTR_FOR_FN (cfun) : ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   di->dfs_order[last_basic_block] = di->dfsnum;\n   di->dfs_to_bb[di->dfsnum] = begin;\n   di->dfsnum++;\n@@ -501,9 +502,9 @@ calc_idoms (struct dom_info *di, bool reverse)\n   edge_iterator ei, einext;\n \n   if (reverse)\n-    en_block = EXIT_BLOCK_PTR;\n+    en_block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n   else\n-    en_block = ENTRY_BLOCK_PTR;\n+    en_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Go backwards in DFS order, to first look at the leafs.  */\n   v = di->nodes;\n@@ -1097,7 +1098,7 @@ prune_bbs_to_update_dominators (vec<basic_block> bbs,\n \n   for (i = 0; bbs.iterate (i, &bb);)\n     {\n-      if (bb == ENTRY_BLOCK_PTR)\n+      if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tgoto succeed;\n \n       if (single_pred_p (bb))\n@@ -1171,7 +1172,7 @@ determine_dominators_for_sons (struct graph *g, vec<basic_block> bbs,\n   if (son[y] == -1)\n     return;\n   if (y == (int) bbs.length ())\n-    ybb = ENTRY_BLOCK_PTR;\n+    ybb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n   else\n     ybb = bbs[y];\n \n@@ -1344,7 +1345,7 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n \tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n       *map->insert (bb) = i;\n     }\n-  *map->insert (ENTRY_BLOCK_PTR) = n;\n+  *map->insert (ENTRY_BLOCK_PTR_FOR_FN (cfun)) = n;\n \n   g = new_graph (n + 1);\n   for (y = 0; y < g->n_vertices; y++)"}, {"sha": "3350e4bb510b9906280b06cd2d4356cdba61c855", "filename": "gcc/domwalk.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -169,8 +169,8 @@ dom_walker::walk (basic_block bb)\n     {\n       /* Don't worry about unreachable blocks.  */\n       if (EDGE_COUNT (bb->preds) > 0\n-\t  || bb == ENTRY_BLOCK_PTR\n-\t  || bb == EXIT_BLOCK_PTR)\n+\t  || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  /* Callback for subclasses to do custom things before we have walked\n \t     the dominator children, but before we walk statements.  */"}, {"sha": "6584ea35bbe1abb3ac7de6ae5acc2972de88f37b", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -2751,7 +2751,7 @@ dse_step1 (void)\n \t  if (stores_off_frame_dead_at_return\n \t      && (EDGE_COUNT (bb->succs) == 0\n \t\t  || (single_succ_p (bb)\n-\t\t      && single_succ (bb) == EXIT_BLOCK_PTR\n+\t\t      && single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t      && ! crtl->calls_eh_return)))\n \t    {\n \t      insn_info_t i_ptr = active_local_stores;"}, {"sha": "f7dc193ce4778ebed65d3bf24a6b9dc25b46830d", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1241,7 +1241,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n       }\n \n   if (fn_begin_outside_block)\n-    insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR));\n+    insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n   else\n     emit_insn_after (seq, fn_begin);\n }\n@@ -1509,7 +1509,7 @@ finish_eh_generation (void)\n \n   if (targetm_common.except_unwind_info (&global_options) == UI_SJLJ\n       /* Kludge for Alpha (see alpha_gp_save_rtx).  */\n-      || single_succ_edge (ENTRY_BLOCK_PTR)->insns.r)\n+      || single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->insns.r)\n     commit_edge_insertions ();\n \n   /* Redirect all EH edges from the post_landing_pad to the landing pad.  */"}, {"sha": "f2adde969751114d545ff6fcf23db707adec78ce", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -762,7 +762,7 @@ compute_alignments (void)\n \t  && (branch_frequency > freq_threshold\n \t      || (bb->frequency > bb->prev_bb->frequency * 10\n \t\t  && (bb->prev_bb->frequency\n-\t\t      <= ENTRY_BLOCK_PTR->frequency / 2))))\n+\t\t      <= ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency / 2))))\n \t{\n \t  log = JUMP_ALIGN (label);\n \t  if (dump_file)"}, {"sha": "fde4a8e6d07be5b7673dae870f01cbafb6c3c572", "filename": "gcc/function.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3978,7 +3978,8 @@ regno_clobbered_at_setjmp (bitmap setjmp_crosses, int regno)\n     return false;\n \n   return ((REG_N_SETS (regno) > 1\n-\t   || REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR), regno))\n+\t   || REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t       regno))\n \t  && REGNO_REG_SET_P (setjmp_crosses, regno));\n }\n \n@@ -5400,7 +5401,7 @@ next_block_for_reg (basic_block bb, int regno, int end_regno)\n \n   /* We can sometimes encounter dead code.  Don't try to move it\n      into the exit block.  */\n-  if (!live_edge || live_edge->dest == EXIT_BLOCK_PTR)\n+  if (!live_edge || live_edge->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return NULL;\n \n   /* Reject targets of abnormal edges.  This is needed for correctness\n@@ -5725,7 +5726,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \n   src_bbs.create (EDGE_COUNT (last_bb->preds));\n   FOR_EACH_EDGE (e, ei, last_bb->preds)\n-    if (e->src != ENTRY_BLOCK_PTR)\n+    if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n       src_bbs.quick_push (e->src);\n \n   label = BB_HEAD (last_bb);\n@@ -5805,7 +5806,7 @@ convert_jumps_to_returns (basic_block last_bb, bool simple_p,\n \t}\n \n       /* Fix up the CFG for the successful change we just made.  */\n-      redirect_edge_succ (e, EXIT_BLOCK_PTR);\n+      redirect_edge_succ (e, EXIT_BLOCK_PTR_FOR_FN (cfun));\n       e->flags &= ~EDGE_CROSSING;\n     }\n   src_bbs.release ();\n@@ -5897,7 +5898,7 @@ thread_prologue_and_epilogue_insns (void)\n \n   df_analyze ();\n \n-  rtl_profile_for_bb (ENTRY_BLOCK_PTR);\n+  rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   inserted = false;\n   seq = NULL_RTX;\n@@ -5907,8 +5908,8 @@ thread_prologue_and_epilogue_insns (void)\n   /* Can't deal with multiple successors of the entry block at the\n      moment.  Function should always have at least one entry\n      point.  */\n-  gcc_assert (single_succ_p (ENTRY_BLOCK_PTR));\n-  entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n+  gcc_assert (single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+  entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   orig_entry_edge = entry_edge;\n \n   split_prologue_seq = NULL_RTX;\n@@ -6081,15 +6082,15 @@ thread_prologue_and_epilogue_insns (void)\n \t  basic_block tmp_bb = vec.pop ();\n \n \t  FOR_EACH_EDGE (e, ei, tmp_bb->succs)\n-\t    if (e->dest != EXIT_BLOCK_PTR\n+\t    if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t&& bitmap_set_bit (&bb_flags, e->dest->index))\n \t      vec.quick_push (e->dest);\n \t}\n \n       /* Find the set of basic blocks that need no prologue, have a\n \t single successor, can be duplicated, meet a max size\n \t requirement, and go to the exit via like blocks.  */\n-      vec.quick_push (EXIT_BLOCK_PTR);\n+      vec.quick_push (EXIT_BLOCK_PTR_FOR_FN (cfun));\n       while (!vec.is_empty ())\n \t{\n \t  basic_block tmp_bb = vec.pop ();\n@@ -6266,7 +6267,7 @@ thread_prologue_and_epilogue_insns (void)\n \t\t  {\n \t\t    /* Otherwise put the copy at the end of the function.  */\n \t\t    copy_bb = create_basic_block (NULL_RTX, NULL_RTX,\n-\t\t\t\t\t\t  EXIT_BLOCK_PTR->prev_bb);\n+\t\t\t\t\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n \t\t    BB_COPY_PARTITION (copy_bb, bb);\n \t\t  }\n \n@@ -6280,7 +6281,7 @@ thread_prologue_and_epilogue_insns (void)\n \t\t    dup_block_and_redirect (tbb, copy_bb, insert_point,\n \t\t\t\t\t    &bb_flags);\n \t\t    tbb = single_succ (tbb);\n-\t\t    if (tbb == EXIT_BLOCK_PTR)\n+\t\t    if (tbb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t      break;\n \t\t    e = split_block (copy_bb, PREV_INSN (insert_point));\n \t\t    copy_bb = e->dest;\n@@ -6294,7 +6295,8 @@ thread_prologue_and_epilogue_insns (void)\n \t\tif (CALL_P (PREV_INSN (insert_point))\n \t\t    && SIBLING_CALL_P (PREV_INSN (insert_point)))\n \t\t  eflags = EDGE_SIBCALL | EDGE_ABNORMAL;\n-\t\tmake_single_succ_edge (copy_bb, EXIT_BLOCK_PTR, eflags);\n+\t\tmake_single_succ_edge (copy_bb, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t\t       eflags);\n \n \t\t/* verify_flow_info doesn't like a note after a\n \t\t   sibling call.  */\n@@ -6325,15 +6327,15 @@ thread_prologue_and_epilogue_insns (void)\n \n   /* If the exit block has no non-fake predecessors, we don't need\n      an epilogue.  */\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if ((e->flags & EDGE_FAKE) == 0)\n       break;\n   if (e == NULL)\n     goto epilogue_done;\n \n-  rtl_profile_for_bb (EXIT_BLOCK_PTR);\n+  rtl_profile_for_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n-  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n+  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n   /* If we're allowed to generate a simple return instruction, then by\n      definition we don't need a full epilogue.  If the last basic\n@@ -6349,10 +6351,10 @@ thread_prologue_and_epilogue_insns (void)\n \n \t  /* convert_jumps_to_returns may add to EXIT_BLOCK_PTR->preds\n \t     (but won't remove).  Stop at end of current preds.  */\n-\t  last = EDGE_COUNT (EXIT_BLOCK_PTR->preds);\n+\t  last = EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \t  for (i = 0; i < last; i++)\n \t    {\n-\t      e = EDGE_I (EXIT_BLOCK_PTR->preds, i);\n+\t      e = EDGE_I (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds, i);\n \t      if (LABEL_P (BB_HEAD (e->src))\n \t\t  && !bitmap_bit_p (&bb_flags, e->src->index)\n \t\t  && !active_insn_between (BB_HEAD (e->src), BB_END (e->src)))\n@@ -6416,7 +6418,7 @@ thread_prologue_and_epilogue_insns (void)\n      code.  In order to be able to properly annotate these with unwind\n      info, try to split them now.  If we get a valid split, drop an\n      EPILOGUE_BEG note and mark the insns as epilogue insns.  */\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       rtx prev, last, trial;\n \n@@ -6507,7 +6509,7 @@ thread_prologue_and_epilogue_insns (void)\n \n       /* The epilogue insns we inserted may cause the exit edge to no longer\n \t be fallthru.  */\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \t{\n \t  if (((e->flags & EDGE_FALLTHRU) != 0)\n \t      && returnjump_p (BB_END (e->src)))\n@@ -6544,7 +6546,7 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n \n       /* Also check returns we might need to add to tail blocks.  */\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \tif (EDGE_COUNT (e->src->preds) != 0\n \t    && (e->flags & EDGE_FAKE) != 0\n \t    && !bitmap_bit_p (&bb_flags, e->src->index))\n@@ -6559,7 +6561,7 @@ thread_prologue_and_epilogue_insns (void)\n          inserting new BBs at the end of the function. Do this\n          after the call to split_block above which may split\n          the original exit pred.  */\n-      exit_pred = EXIT_BLOCK_PTR->prev_bb;\n+      exit_pred = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n \n       FOR_EACH_VEC_ELT (unconverted_simple_returns, i, e)\n \t{\n@@ -6596,7 +6598,7 @@ thread_prologue_and_epilogue_insns (void)\n \t      emit_barrier_after (start);\n \n \t      *pdest_bb = bb;\n-\t      make_edge (bb, EXIT_BLOCK_PTR, 0);\n+\t      make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \t    }\n \t  redirect_edge_and_branch_force (e, *pdest_bb);\n \t}\n@@ -6605,7 +6607,7 @@ thread_prologue_and_epilogue_insns (void)\n \n   if (entry_edge != orig_entry_edge)\n     {\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \tif (EDGE_COUNT (e->src->preds) != 0\n \t    && (e->flags & EDGE_FAKE) != 0\n \t    && !bitmap_bit_p (&bb_flags, e->src->index))\n@@ -6618,7 +6620,9 @@ thread_prologue_and_epilogue_insns (void)\n \n #ifdef HAVE_sibcall_epilogue\n   /* Emit sibling epilogues before any sibling call sites.  */\n-  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n+  for (ei = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); (e =\n+\t\t\t\t\t\t\t     ei_safe_edge (ei));\n+\t\t\t\t\t\t\t     )\n     {\n       basic_block bb = e->src;\n       rtx insn = BB_END (bb);\n@@ -6749,7 +6753,7 @@ reposition_prologue_and_epilogue_notes (void)\n       edge_iterator ei;\n       edge e;\n \n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \t{\n \t  rtx insn, first = NULL, note = NULL;\n \t  basic_block bb = e->src;"}, {"sha": "3012c4d1d3671499d340cecfdb45775dcc7503ff", "filename": "gcc/gcse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -2063,7 +2063,7 @@ pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr,\n     {\n       basic_block pred_bb = pred->src;\n \n-      if (pred->src == ENTRY_BLOCK_PTR\n+      if (pred->src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t  /* Has predecessor has already been visited?  */\n \t  || visited[pred_bb->index])\n \t;/* Nothing to do.  */\n@@ -2830,7 +2830,7 @@ compute_code_hoist_vbeinout (void)\n \t the convergence.  */\n       FOR_EACH_BB_REVERSE (bb)\n \t{\n-\t  if (bb->next_bb != EXIT_BLOCK_PTR)\n+\t  if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      bitmap_intersection_of_succs (hoist_vbeout[bb->index],\n \t\t\t\t\t    hoist_vbein, bb);\n@@ -2908,7 +2908,7 @@ update_bb_reg_pressure (basic_block bb, rtx from)\n       FOR_EACH_EDGE (succ, ei, bb->succs)\n \t{\n \t  succ_bb = succ->dest;\n-\t  if (succ_bb == EXIT_BLOCK_PTR)\n+\t  if (succ_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    continue;\n \n \t  if (bitmap_bit_p (BB_DATA (succ_bb)->live_in, REGNO (dreg)))\n@@ -3041,7 +3041,7 @@ should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n     {\n       basic_block pred_bb = pred->src;\n \n-      if (pred->src == ENTRY_BLOCK_PTR)\n+      if (pred->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tbreak;\n       else if (pred_bb == expr_bb)\n \tcontinue;\n@@ -3185,16 +3185,16 @@ hoist_code (void)\n       bb_size[bb->index] = to_head;\n     }\n \n-  gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR->succs) == 1\n-\t      && (EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n-\t\t  == ENTRY_BLOCK_PTR->next_bb));\n+  gcc_assert (EDGE_COUNT (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs) == 1\n+\t      && (EDGE_SUCC (ENTRY_BLOCK_PTR_FOR_FN (cfun), 0)->dest\n+\t\t  == ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb));\n \n   from_bbs = BITMAP_ALLOC (NULL);\n   if (flag_ira_hoist_pressure)\n     hoisted_bbs = BITMAP_ALLOC (NULL);\n \n   dom_tree_walk = get_all_dominated_blocks (CDI_DOMINATORS,\n-\t\t\t\t\t    ENTRY_BLOCK_PTR->next_bb);\n+\t\t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb);\n \n   /* Walk over each basic block looking for potentially hoistable\n      expressions, nothing gets hoisted from the entry block.  */"}, {"sha": "a3e74fe5012fbb8a6f9b12940ff78538e7989d42", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -713,7 +713,7 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n  restart:\n   if (single_pred_p (dest)\n       && gimple_seq_empty_p (phi_nodes (dest))\n-      && dest != EXIT_BLOCK_PTR)\n+      && dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       *gsi = gsi_start_bb (dest);\n       if (gsi_end_p (*gsi))\n@@ -744,7 +744,7 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n   src = e->src;\n   if ((e->flags & EDGE_ABNORMAL) == 0\n       && single_succ_p (src)\n-      && src != ENTRY_BLOCK_PTR)\n+      && src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     {\n       *gsi = gsi_last_bb (src);\n       if (gsi_end_p (*gsi))\n@@ -830,7 +830,8 @@ gsi_commit_edge_inserts (void)\n   edge e;\n   edge_iterator ei;\n \n-  gsi_commit_one_edge_insert (single_succ_edge (ENTRY_BLOCK_PTR), NULL);\n+  gsi_commit_one_edge_insert (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t      NULL);\n \n   FOR_EACH_BB (bb)\n     FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "72c62844fa67a2420e48ecc1302acb7748f77318", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -735,7 +735,7 @@ slsr_process_phi (gimple phi, bool speed)\n \t  derived_base_name = arg;\n \n \t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n-\t    arg_bb = single_succ (ENTRY_BLOCK_PTR);\n+\t    arg_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \t  else\n \t    gimple_bb (SSA_NAME_DEF_STMT (arg));\n \t}"}, {"sha": "b75135af7420af3de71fc2cdae731a3b8c94eeda", "filename": "gcc/graph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -195,7 +195,7 @@ draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n   const char *fillcolors[3] = { \"grey88\", \"grey77\", \"grey66\" };\n \n   if (loop->header != NULL\n-      && loop->latch != EXIT_BLOCK_PTR)\n+      && loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     pp_printf (pp,\n \t       \"\\tsubgraph cluster_%d_%d {\\n\"\n \t       \"\\tstyle=\\\"filled\\\";\\n\"\n@@ -214,7 +214,7 @@ draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n   if (loop->header == NULL)\n     return;\n \n-  if (loop->latch == EXIT_BLOCK_PTR)\n+  if (loop->latch == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     body = get_loop_body (loop);\n   else\n     body = get_loop_body_in_bfs_order (loop);\n@@ -228,7 +228,7 @@ draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n \n   free (body);\n \n-  if (loop->latch != EXIT_BLOCK_PTR)\n+  if (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     pp_printf (pp, \"\\t}\\n\");\n }\n "}, {"sha": "ad3e1dc4ede71478d3f5131c8af890ea62cb275c", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1098,7 +1098,7 @@ translate_clast_user (struct clast_user_stmt *stmt, edge next_e,\n   gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n   vec<tree> iv_map;\n \n-  if (GBB_BB (gbb) == ENTRY_BLOCK_PTR)\n+  if (GBB_BB (gbb) == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     return next_e;\n \n   nb_loops = number_of_loops (cfun);"}, {"sha": "0cfb5a59cc9986926aed94de6937a5b87f91142c", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -448,7 +448,7 @@ scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n   gimple stmt;\n \n   /* XXX: ENTRY_BLOCK_PTR could be optimized in later steps.  */\n-  basic_block entry_block = ENTRY_BLOCK_PTR;\n+  basic_block entry_block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n   stmt = harmful_stmt_in_bb (entry_block, outermost_loop, bb);\n   result.difficult = (stmt != NULL);\n   result.exit = NULL;\n@@ -1030,7 +1030,7 @@ create_sese_edges (vec<sd_region> regions)\n   FOR_EACH_VEC_ELT (regions, i, s)\n     /* Don't handle multiple edges exiting the function.  */\n     if (!find_single_exit_edge (s)\n-\t&& s->exit != EXIT_BLOCK_PTR)\n+\t&& s->exit != EXIT_BLOCK_PTR_FOR_FN (cfun))\n       create_single_exit_edge (s);\n \n   unmark_exit_edges (regions);\n@@ -1402,7 +1402,8 @@ build_scops (vec<scop_p> *scops)\n   stack_vec<sd_region, 3> regions;\n \n   canonicalize_loop_closed_ssa_form ();\n-  build_scops_1 (single_succ (ENTRY_BLOCK_PTR), ENTRY_BLOCK_PTR->loop_father,\n+  build_scops_1 (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t ENTRY_BLOCK_PTR_FOR_FN (cfun)->loop_father,\n \t\t &regions, loop);\n   create_sese_edges (regions);\n   build_graphite_scops (regions, scops);"}, {"sha": "c98b36c1ab6be723ba2664213073ad792e53f6cf", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1615,7 +1615,7 @@ priority (rtx insn)\n \n           /* Selective scheduling does not define RECOVERY_BLOCK macro.  */\n \t  rec = sel_sched_p () ? NULL : RECOVERY_BLOCK (insn);\n-\t  if (!rec || rec == EXIT_BLOCK_PTR)\n+\t  if (!rec || rec == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      prev_first = PREV_INSN (insn);\n \t      twin = insn;\n@@ -7522,7 +7522,7 @@ static void\n sched_extend_bb (void)\n {\n   /* The following is done to keep current_sched_info->next_tail non null.  */\n-  rtx end = BB_END (EXIT_BLOCK_PTR->prev_bb);\n+  rtx end = BB_END (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n   rtx insn = DEBUG_INSN_P (end) ? prev_nondebug_insn (end) : end;\n   if (NEXT_INSN (end) == 0\n       || (!NOTE_P (insn)\n@@ -7533,7 +7533,7 @@ sched_extend_bb (void)\n       rtx note = emit_note_after (NOTE_INSN_DELETED, end);\n       /* Make note appear outside BB.  */\n       set_block_for_insn (note, NULL);\n-      BB_END (EXIT_BLOCK_PTR->prev_bb) = end;\n+      BB_END (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb) = end;\n     }\n }\n \n@@ -7551,7 +7551,7 @@ init_before_recovery (basic_block *before_recovery_ptr)\n   basic_block last;\n   edge e;\n \n-  last = EXIT_BLOCK_PTR->prev_bb;\n+  last = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n   e = find_fallthru_edge_from (last);\n \n   if (e)\n@@ -7591,7 +7591,8 @@ init_before_recovery (basic_block *before_recovery_ptr)\n \n       redirect_edge_succ (e, single);\n       make_single_succ_edge (single, empty, 0);\n-      make_single_succ_edge (empty, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+      make_single_succ_edge (empty, EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t     EDGE_FALLTHRU);\n \n       label = block_label (empty);\n       x = emit_jump_insn_after (gen_jump (label), BB_END (single));\n@@ -7734,14 +7735,14 @@ create_check_block_twin (rtx insn, bool mutate_p)\n     }\n   else\n     {\n-      rec = EXIT_BLOCK_PTR;\n+      rec = EXIT_BLOCK_PTR_FOR_FN (cfun);\n       label = NULL_RTX;\n     }\n \n   /* Emit CHECK.  */\n   check = targetm.sched.gen_spec_check (insn, label, todo_spec);\n \n-  if (rec != EXIT_BLOCK_PTR)\n+  if (rec != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       /* To have mem_reg alive at the beginning of second_bb,\n \t we emit check BEFORE insn, so insn after splitting\n@@ -7774,7 +7775,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n   /* Initialize TWIN (twin is a duplicate of original instruction\n      in the recovery block).  */\n-  if (rec != EXIT_BLOCK_PTR)\n+  if (rec != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       sd_iterator_def sd_it;\n       dep_t dep;\n@@ -7811,7 +7812,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n      provide correct value for INSN_TICK (TWIN).  */\n   sd_copy_back_deps (twin, insn, true);\n \n-  if (rec != EXIT_BLOCK_PTR)\n+  if (rec != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     /* In case of branchy check, fix CFG.  */\n     {\n       basic_block first_bb, second_bb;\n@@ -7823,7 +7824,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n       sched_create_recovery_edges (first_bb, rec, second_bb);\n \n       sched_init_only_bb (second_bb, first_bb);\n-      sched_init_only_bb (rec, EXIT_BLOCK_PTR);\n+      sched_init_only_bb (rec, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n       jump = BB_END (rec);\n       haifa_init_insn (jump);\n@@ -7864,7 +7865,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n       init_dep_1 (new_dep, pro, check, DEP_TYPE (dep), ds);\n       sd_add_dep (new_dep, false);\n \n-      if (rec != EXIT_BLOCK_PTR)\n+      if (rec != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  DEP_CON (new_dep) = twin;\n \t  sd_add_dep (new_dep, false);\n@@ -7913,7 +7914,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n   /* Future speculations: call the helper.  */\n   process_insn_forw_deps_be_in_spec (insn, twin, fs);\n \n-  if (rec != EXIT_BLOCK_PTR)\n+  if (rec != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       /* Which types of dependencies should we use here is,\n \t generally, machine-dependent question...  But, for now,\n@@ -8127,7 +8128,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n   bb_header = XNEWVEC (rtx, last_basic_block);\n \n   /* Make a sentinel.  */\n-  if (last->next_bb != EXIT_BLOCK_PTR)\n+  if (last->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     bb_header[last->next_bb->index] = 0;\n \n   first = first->next_bb;\n@@ -8171,7 +8172,7 @@ restore_bb_notes (basic_block first)\n   first = first->next_bb;\n   /* Remember: FIRST is actually a second basic block in the ebb.  */\n \n-  while (first != EXIT_BLOCK_PTR\n+  while (first != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t && bb_header[first->index])\n     {\n       rtx prev, label, note, next;"}, {"sha": "77c8149f806d510d902a66e2fc355f343e790a06", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -260,7 +260,7 @@ discover_loop (hwloop_info loop, basic_block tail_bb, rtx tail_insn, rtx reg)\n     {\n       edge e;\n       edge_iterator ei;\n-      if (bb == EXIT_BLOCK_PTR)\n+      if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  /* We've reached the exit block.  The loop must be bad. */\n \t  if (dump_file)\n@@ -539,7 +539,7 @@ reorder_loops (hwloop_info loops)\n   \n   FOR_EACH_BB (bb)\n     {\n-      if (bb->next_bb != EXIT_BLOCK_PTR)\n+      if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tbb->aux = bb->next_bb;\n       else\n \tbb->aux = NULL;"}, {"sha": "ac0276cea041ae547886fc517bc5666f7cd81a1f", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3185,7 +3185,8 @@ merge_if_block (struct ce_if_block * ce_info)\n       /* There should still be something at the end of the THEN or ELSE\n          blocks taking us to our final destination.  */\n \tgcc_assert (JUMP_P (last)\n-\t\t    || (EDGE_SUCC (combo_bb, 0)->dest == EXIT_BLOCK_PTR\n+\t\t    || (EDGE_SUCC (combo_bb, 0)->dest\n+\t\t\t== EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t&& CALL_P (last)\n \t\t\t&& SIBLING_CALL_P (last))\n \t\t    || ((EDGE_SUCC (combo_bb, 0)->flags & EDGE_EH)\n@@ -3199,7 +3200,7 @@ merge_if_block (struct ce_if_block * ce_info)\n      may be zero incoming edges if the THEN block didn't actually join\n      back up (as with a call to a non-return function).  */\n   else if (EDGE_COUNT (join_bb->preds) < 2\n-\t   && join_bb != EXIT_BLOCK_PTR)\n+\t   && join_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       /* We can merge the JOIN cleanly and update the dataflow try\n \t again on this pass.*/\n@@ -3216,7 +3217,7 @@ merge_if_block (struct ce_if_block * ce_info)\n \t\t  && single_succ (combo_bb) == join_bb);\n \n       /* Remove the jump and cruft from the end of the COMBO block.  */\n-      if (join_bb != EXIT_BLOCK_PTR)\n+      if (join_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \ttidy_fallthru_edge (single_succ_edge (combo_bb));\n     }\n \n@@ -3495,7 +3496,7 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n      code processing.  ??? we should fix this in the future.  */\n   if (EDGE_COUNT (then_bb->succs) == 0)\n     {\n-      if (single_pred_p (else_bb) && else_bb != EXIT_BLOCK_PTR)\n+      if (single_pred_p (else_bb) && else_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  rtx last_insn = BB_END (then_bb);\n \n@@ -3586,7 +3587,8 @@ cond_exec_find_if_block (struct ce_if_block * ce_info)\n   next = then_bb;\n   if (else_bb && (next = next->next_bb) != else_bb)\n     return FALSE;\n-  if ((next = next->next_bb) != join_bb && join_bb != EXIT_BLOCK_PTR)\n+  if ((next = next->next_bb) != join_bb\n+      && join_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       if (else_bb)\n \tjoin_bb = NULL;\n@@ -3725,7 +3727,7 @@ block_has_only_trap (basic_block bb)\n   rtx trap;\n \n   /* We're not the exit block.  */\n-  if (bb == EXIT_BLOCK_PTR)\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return NULL_RTX;\n \n   /* The block must have no successors.  */\n@@ -3881,7 +3883,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t\t\t\t    predictable_edge_p (then_edge)))))\n     return FALSE;\n \n-  if (else_bb == EXIT_BLOCK_PTR)\n+  if (else_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       rtx jump = BB_END (else_edge->src);\n       gcc_assert (JUMP_P (jump));\n@@ -3902,12 +3904,12 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   if (then_bb->next_bb == else_bb\n       && then_bb->prev_bb == test_bb\n-      && else_bb != EXIT_BLOCK_PTR)\n+      && else_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       redirect_edge_succ (FALLTHRU_EDGE (test_bb), else_bb);\n       new_bb = 0;\n     }\n-  else if (else_bb == EXIT_BLOCK_PTR)\n+  else if (else_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     new_bb = force_nonfallthru_and_redirect (FALLTHRU_EDGE (test_bb),\n \t\t\t\t\t     else_bb, else_target);\n   else\n@@ -4196,9 +4198,9 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t saved in caller-saved regs.  A caller-saved reg requires the\n \t prologue, killing a shrink-wrap opportunity.  */\n       if ((flag_shrink_wrap && HAVE_simple_return && !epilogue_completed)\n-\t  && ENTRY_BLOCK_PTR->next_bb == test_bb\n+\t  && ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb == test_bb\n \t  && single_succ_p (new_dest)\n-\t  && single_succ (new_dest) == EXIT_BLOCK_PTR\n+\t  && single_succ (new_dest) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && bitmap_intersect_p (df_get_live_in (new_dest), merge_set))\n \t{\n \t  regset return_regs;\n@@ -4213,8 +4215,10 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t\t&& targetm.calls.function_value_regno_p (i))\n \t      bitmap_set_bit (return_regs, INCOMING_REGNO (i));\n \n-\t  bitmap_and_into (return_regs, df_get_live_out (ENTRY_BLOCK_PTR));\n-\t  bitmap_and_into (return_regs, df_get_live_in (EXIT_BLOCK_PTR));\n+\t  bitmap_and_into (return_regs,\n+\t\t\t   df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t  bitmap_and_into (return_regs,\n+\t\t\t   df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)));\n \t  if (!bitmap_empty_p (return_regs))\n \t    {\n \t      FOR_BB_INSNS_REVERSE (new_dest, insn)\n@@ -4259,7 +4263,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n     {\n       if (JUMP_P (BB_END (dest_edge->src)))\n \tnew_dest_label = JUMP_LABEL (BB_END (dest_edge->src));\n-      else if (new_dest == EXIT_BLOCK_PTR)\n+      else if (new_dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tnew_dest_label = ret_rtx;\n       else\n \tnew_dest_label = block_label (new_dest);"}, {"sha": "3d95de144f9df45a1251574f00a9ebabdbcb53bd", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1841,9 +1841,9 @@ compute_bb_predicates (struct cgraph_node *node,\n     }\n \n   /* Entry block is always executable.  */\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n+  ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n     = pool_alloc (edge_predicate_pool);\n-  *(struct predicate *) ENTRY_BLOCK_PTR_FOR_FUNCTION (my_function)->aux\n+  *(struct predicate *) ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n     = true_predicate ();\n \n   /* A simple dataflow propagation of predicates forward in the CFG.\n@@ -2066,7 +2066,7 @@ record_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n     return false;\n   bitmap_set_bit (info->bb_set,\n \t\t  SSA_NAME_IS_DEFAULT_DEF (vdef)\n-\t\t  ? ENTRY_BLOCK_PTR->index\n+\t\t  ? ENTRY_BLOCK_PTR_FOR_FN (cfun)->index\n \t\t  : gimple_bb (SSA_NAME_DEF_STMT (vdef))->index);\n   return false;\n }\n@@ -2102,7 +2102,7 @@ param_change_prob (gimple stmt, int i)\n \treturn REG_BR_PROB_BASE;\n \n       if (SSA_NAME_IS_DEFAULT_DEF (op))\n-\tinit_freq = ENTRY_BLOCK_PTR->frequency;\n+\tinit_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n       else\n \tinit_freq = gimple_bb (SSA_NAME_DEF_STMT (op))->frequency;\n \n@@ -2142,8 +2142,8 @@ param_change_prob (gimple stmt, int i)\n       /* Assume that every memory is initialized at entry.\n          TODO: Can we easilly determine if value is always defined\n          and thus we may skip entry block?  */\n-      if (ENTRY_BLOCK_PTR->frequency)\n-\tmax = ENTRY_BLOCK_PTR->frequency;\n+      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency)\n+\tmax = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n       else\n \tmax = 1;\n "}, {"sha": "ed96c3c21ffcc325f5b6c79ee7afd6eb874b13b1", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1587,7 +1587,7 @@ local_pure_const (void)\n \n   /* Do NORETURN discovery.  */\n   if (!skip && !TREE_THIS_VOLATILE (current_function_decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == 0)\n     {\n       warn_function_noreturn (cfun->decl);\n       if (dump_file)\n@@ -1723,7 +1723,7 @@ static unsigned int\n execute_warn_function_noreturn (void)\n {\n   if (!TREE_THIS_VOLATILE (current_function_decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == 0)\n     warn_function_noreturn (current_function_decl);\n   return 0;\n }"}, {"sha": "d7d6b8fd70f9db1db40bc4479a237ceba0995dac", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -210,7 +210,7 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n   bool ok = true;\n \n   FOR_EACH_EDGE (e, ei, current->entry_bb->preds)\n-    if (e->src != ENTRY_BLOCK_PTR\n+    if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t&& !bitmap_bit_p (current->split_bbs, e->src->index))\n       {\n         worklist.safe_push (e->src);\n@@ -223,7 +223,7 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n       basic_block bb = worklist.pop ();\n \n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (e->src != ENTRY_BLOCK_PTR\n+\tif (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t    && bitmap_set_bit (seen, e->src->index))\n \t  {\n \t    gcc_checking_assert (!bitmap_bit_p (current->split_bbs,\n@@ -396,7 +396,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \n   /* Do not split when we would end up calling function anyway.  */\n   if (incoming_freq\n-      >= (ENTRY_BLOCK_PTR->frequency\n+      >= (ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency\n \t  * PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100))\n     {\n       /* When profile is guessed, we can not expect it to give us\n@@ -406,13 +406,13 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \t is likely noticeable win.  */\n       if (back_edge\n \t  && profile_status != PROFILE_READ\n-\t  && incoming_freq < ENTRY_BLOCK_PTR->frequency)\n+\t  && incoming_freq < ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n \t\t     \"  Split before loop, accepting despite low frequencies %i %i.\\n\",\n \t\t     incoming_freq,\n-\t\t     ENTRY_BLOCK_PTR->frequency);\n+\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency);\n \t}\n       else\n \t{\n@@ -583,7 +583,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \n   /* split_function fixes up at most one PHI non-virtual PHI node in return_bb,\n      for the return value.  If there are other PHIs, give up.  */\n-  if (return_bb != EXIT_BLOCK_PTR)\n+  if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       gimple_stmt_iterator psi;\n \n@@ -650,15 +650,15 @@ static basic_block\n find_return_bb (void)\n {\n   edge e;\n-  basic_block return_bb = EXIT_BLOCK_PTR;\n+  basic_block return_bb = EXIT_BLOCK_PTR_FOR_FN (cfun);\n   gimple_stmt_iterator bsi;\n   bool found_return = false;\n   tree retval = NULL_TREE;\n \n-  if (!single_pred_p (EXIT_BLOCK_PTR))\n+  if (!single_pred_p (EXIT_BLOCK_PTR_FOR_FN (cfun)))\n     return return_bb;\n \n-  e = single_pred_edge (EXIT_BLOCK_PTR);\n+  e = single_pred_edge (EXIT_BLOCK_PTR_FOR_FN (cfun));\n   for (bsi = gsi_last_bb (e->src); !gsi_end_p (bsi); gsi_prev (&bsi))\n     {\n       gimple stmt = gsi_stmt (bsi);\n@@ -937,7 +937,7 @@ find_split_points (int overall_time, int overall_size)\n   current.split_size = 0;\n   current.ssa_names_to_pass = BITMAP_ALLOC (NULL);\n \n-  first.bb = ENTRY_BLOCK_PTR;\n+  first.bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n   first.edge_num = 0;\n   first.overall_time = 0;\n   first.overall_size = 0;\n@@ -946,7 +946,7 @@ find_split_points (int overall_time, int overall_size)\n   first.used_ssa_names = 0;\n   first.bbs_visited = 0;\n   stack.safe_push (first);\n-  ENTRY_BLOCK_PTR->aux = (void *)(intptr_t)-1;\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->aux = (void *)(intptr_t)-1;\n \n   while (!stack.is_empty ())\n     {\n@@ -957,7 +957,7 @@ find_split_points (int overall_time, int overall_size)\n          articulation, we want to have processed everything reachable\n \t from articulation but nothing that reaches into it.  */\n       if (entry->edge_num == EDGE_COUNT (entry->bb->succs)\n-\t  && entry->bb != ENTRY_BLOCK_PTR)\n+\t  && entry->bb != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  int pos = stack.length ();\n \t  entry->can_split &= visit_bb (entry->bb, return_bb,\n@@ -1009,7 +1009,7 @@ find_split_points (int overall_time, int overall_size)\n \t  entry->edge_num++;\n \n \t  /* New BB to visit, push it to the stack.  */\n-\t  if (dest != return_bb && dest != EXIT_BLOCK_PTR\n+\t  if (dest != return_bb && dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      && !dest->aux)\n \t    {\n \t      stack_entry new_entry;\n@@ -1037,7 +1037,7 @@ find_split_points (int overall_time, int overall_size)\n \t}\n       /* We are done with examining the edges.  Pop off the value from stack\n \t and merge stuff we accumulate during the walk.  */\n-      else if (entry->bb != ENTRY_BLOCK_PTR)\n+      else if (entry->bb != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  stack_entry *prev = &stack[stack.length () - 2];\n \n@@ -1063,7 +1063,7 @@ find_split_points (int overall_time, int overall_size)\n       else\n         stack.pop ();\n     }\n-  ENTRY_BLOCK_PTR->aux = NULL;\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->aux = NULL;\n   FOR_EACH_BB (bb)\n     bb->aux = NULL;\n   stack.release ();\n@@ -1139,7 +1139,7 @@ split_function (struct split_point *split_point)\n   if (!split_part_return_p)\n     ;\n   /* We have no return block, so nothing is needed.  */\n-  else if (return_bb == EXIT_BLOCK_PTR)\n+  else if (return_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     ;\n   /* When we do not want to return value, we need to construct\n      new return block with empty return statement.\n@@ -1166,7 +1166,7 @@ split_function (struct split_point *split_point)\n \t\tbreak;\n \t      }\n \t}\n-      e = make_edge (new_return_bb, EXIT_BLOCK_PTR, 0);\n+      e = make_edge (new_return_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n       e->probability = REG_BR_PROB_BASE;\n       e->count = new_return_bb->count;\n       if (current_loops)\n@@ -1183,7 +1183,7 @@ split_function (struct split_point *split_point)\n \n      Note this can happen whether or not we have a return value.  If we have\n      a return value, then RETURN_BB may have PHIs for real operands too.  */\n-  if (return_bb != EXIT_BLOCK_PTR)\n+  if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       bool phi_p = false;\n       for (gsi = gsi_start_phis (return_bb); !gsi_end_p (gsi);)\n@@ -1325,7 +1325,7 @@ split_function (struct split_point *split_point)\n       push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n       var = BLOCK_VARS (DECL_INITIAL (node->decl));\n       i = vec_safe_length (*debug_args);\n-      cgsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+      cgsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n       do\n \t{\n \t  i -= 2;\n@@ -1366,13 +1366,14 @@ split_function (struct split_point *split_point)\n   else\n     {\n       e = make_edge (call_bb, return_bb,\n-\t\t     return_bb == EXIT_BLOCK_PTR ? 0 : EDGE_FALLTHRU);\n+\t\t     return_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t\t     ? 0 : EDGE_FALLTHRU);\n       e->count = call_bb->count;\n       e->probability = REG_BR_PROB_BASE;\n \n       /* If there is return basic block, see what value we need to store\n          return value into and put call just before it.  */\n-      if (return_bb != EXIT_BLOCK_PTR)\n+      if (return_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  real_retval = retval = find_retval (return_bb);\n "}, {"sha": "e249ba0dcff2696d8c29cef53db0ff94f6a1be61", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1745,7 +1745,7 @@ ira_loop_tree_body_rev_postorder (ira_loop_tree_node_t loop_node ATTRIBUTE_UNUSE\n \t\t  ira_loop_tree_node_t pred_node;\n \t\t  basic_block pred_bb = e->src;\n \n-\t\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t\t  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t\t    continue;\n \n \t\t  pred_node = IRA_BB_NODE_BY_INDEX (pred_bb->index);"}, {"sha": "30282aad974eac4637f2d5176b2c6d8cfd05c489", "filename": "gcc/ira-color.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3100,7 +3100,7 @@ print_loop_title (ira_loop_tree_node_t loop_tree_node)\n       {\n \tfprintf (ira_dump_file, \" %d\", subloop_node->bb->index);\n \tFOR_EACH_EDGE (e, ei, subloop_node->bb->succs)\n-\t  if (e->dest != EXIT_BLOCK_PTR\n+\t  if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      && ((dest_loop_node = IRA_BB_NODE (e->dest)->parent)\n \t\t  != loop_tree_node))\n \t    fprintf (ira_dump_file, \"(->%d:l%d)\","}, {"sha": "198fa47b702434b2597babbd10fc2fa4c13e9ff3", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -403,7 +403,7 @@ entered_from_non_parent_p (ira_loop_tree_node_t loop_node)\n     if (bb_node->bb != NULL)\n       {\n \tFOR_EACH_EDGE (e, ei, bb_node->bb->preds)\n-\t  if (e->src != ENTRY_BLOCK_PTR\n+\t  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t      && (src_loop_node = IRA_BB_NODE (e->src)->parent) != loop_node)\n \t    {\n \t      for (parent = src_loop_node->parent;\n@@ -1263,7 +1263,7 @@ ira_emit (bool loops_p)\n       at_bb_start[bb->index] = NULL;\n       at_bb_end[bb->index] = NULL;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR)\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  generate_edge_moves (e);\n     }\n   allocno_last_set"}, {"sha": "b46e7b0027419fc6bc5ba3695ff58d1c541053ea", "filename": "gcc/ira-int.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -43,8 +43,9 @@ along with GCC; see the file COPYING3.  If not see\n    executed, frequency is always equivalent.  Otherwise rescale the\n    edge frequency.  */\n #define REG_FREQ_FROM_EDGE_FREQ(freq)\t\t\t\t\t   \\\n-  (optimize_size || (flag_branch_probabilities && !ENTRY_BLOCK_PTR->count) \\\n-   ? REG_FREQ_MAX : (freq * REG_FREQ_MAX / BB_FREQ_MAX)\t\t\t   \\\n+  (optimize_size || (flag_branch_probabilities\t\t\t\t   \\\n+\t\t     && !ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\t\t   \\\n+   ? REG_FREQ_MAX : (freq * REG_FREQ_MAX / BB_FREQ_MAX)\t\t   \\\n    ? (freq * REG_FREQ_MAX / BB_FREQ_MAX) : 1)\n \n /* A modified value of flag `-fira-verbose' used internally.  */"}, {"sha": "f5a5af88838f4762597836bcfede0e4c6cd8ca61", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -4865,7 +4865,7 @@ static bool\n split_live_ranges_for_shrink_wrap (void)\n {\n   basic_block bb, call_dom = NULL;\n-  basic_block first = single_succ (ENTRY_BLOCK_PTR);\n+  basic_block first = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   rtx insn, last_interesting_insn = NULL;\n   bitmap_head need_new, reachable;\n   vec<basic_block> queue;\n@@ -4910,7 +4910,7 @@ split_live_ranges_for_shrink_wrap (void)\n \n       bb = queue.pop ();\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t    && bitmap_set_bit (&reachable, e->dest->index))\n \t  queue.quick_push (e->dest);\n     }"}, {"sha": "aa63c7272f0443760e7a2d1cbb3656e315bacd80", "filename": "gcc/lcm.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -121,8 +121,8 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \n   /* Mark blocks which are predecessors of the exit block so that we\n      can easily identify them below.  */\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    e->src->aux = EXIT_BLOCK_PTR;\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n+    e->src->aux = EXIT_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Iterate until the worklist is empty.  */\n   while (qlen)\n@@ -134,7 +134,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n       if (qout >= qend)\n \tqout = worklist;\n \n-      if (bb->aux == EXIT_BLOCK_PTR)\n+      if (bb->aux == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t/* Do not clear the aux field for blocks which are predecessors of\n \t   the EXIT block.  That way we never add then to the worklist\n \t   again.  */\n@@ -153,7 +153,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n \t   to add the predecessors of this block to the worklist\n \t   if they are not already on the worklist.  */\n \tFOR_EACH_EDGE (e, ei, bb->preds)\n-\t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n+\t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      *qin++ = e->src;\n \t      e->src->aux = e;\n@@ -188,11 +188,11 @@ compute_earliest (struct edge_list *edge_list, int n_exprs, sbitmap *antin,\n     {\n       pred = INDEX_EDGE_PRED_BB (edge_list, x);\n       succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n-      if (pred == ENTRY_BLOCK_PTR)\n+      if (pred == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tbitmap_copy (earliest[x], antin[succ->index]);\n       else\n \t{\n-\t  if (succ == EXIT_BLOCK_PTR)\n+\t  if (succ == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    bitmap_clear (earliest[x]);\n \t  else\n \t    {\n@@ -276,7 +276,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      do not want to be overly optimistic.  Consider an outgoing edge from\n      the entry block.  That edge should always have a LATER value the\n      same as EARLIEST for that edge.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     bitmap_copy (later[(size_t) e->aux], earliest[(size_t) e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n@@ -317,7 +317,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n \t\t\t\t      antloc[e->src->index])\n \t    /* If LATER for an outgoing edge was changed, then we need\n \t       to add the target of the outgoing edge to the worklist.  */\n-\t    && e->dest != EXIT_BLOCK_PTR && e->dest->aux == 0)\n+\t    && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun) && e->dest->aux == 0)\n \t  {\n \t    *qin++ = e->dest;\n \t    e->dest->aux = e;\n@@ -331,7 +331,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      for the EXIT block.  We allocated an extra entry in the LATERIN array\n      for just this purpose.  */\n   bitmap_ones (laterin[last_basic_block]);\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     bitmap_and (laterin[last_basic_block],\n \t\t     laterin[last_basic_block],\n \t\t     later[(size_t) e->aux]);\n@@ -358,7 +358,7 @@ compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n     {\n       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n \n-      if (b == EXIT_BLOCK_PTR)\n+      if (b == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tbitmap_and_compl (insert[x], later[x], laterin[last_basic_block]);\n       else\n \tbitmap_and_compl (insert[x], later[x], laterin[b->index]);\n@@ -500,8 +500,8 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \n   /* Mark blocks which are successors of the entry block so that we\n      can easily identify them below.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    e->dest->aux = ENTRY_BLOCK_PTR;\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n+    e->dest->aux = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Iterate until the worklist is empty.  */\n   while (qlen)\n@@ -516,7 +516,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n       /* If one of the predecessor blocks is the ENTRY block, then the\n \t intersection of avouts is the null set.  We can identify such blocks\n \t by the special value in the AUX field in the block structure.  */\n-      if (bb->aux == ENTRY_BLOCK_PTR)\n+      if (bb->aux == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t/* Do not clear the aux field for blocks which are successors of the\n \t   ENTRY block.  That way we never add then to the worklist again.  */\n \tbitmap_clear (avin[bb->index]);\n@@ -534,7 +534,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n \t   to add the successors of this block to the worklist\n \t   if they are not already on the worklist.  */\n \tFOR_EACH_EDGE (e, ei, bb->succs)\n-\t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n+\t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      *qin++ = e->dest;\n \t      e->dest->aux = e;\n@@ -570,11 +570,11 @@ compute_farthest (struct edge_list *edge_list, int n_exprs,\n     {\n       pred = INDEX_EDGE_PRED_BB (edge_list, x);\n       succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n-      if (succ == EXIT_BLOCK_PTR)\n+      if (succ == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tbitmap_copy (farthest[x], st_avout[pred->index]);\n       else\n \t{\n-\t  if (pred == ENTRY_BLOCK_PTR)\n+\t  if (pred == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    bitmap_clear (farthest[x]);\n \t  else\n \t    {\n@@ -624,7 +624,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n      do not want to be overly optimistic.  Consider an incoming edge to\n      the exit block.  That edge should always have a NEARER value the\n      same as FARTHEST for that edge.  */\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     bitmap_copy (nearer[(size_t)e->aux], farthest[(size_t)e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit\n@@ -656,7 +656,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n \t\t\t\t      st_avloc[e->dest->index])\n \t    /* If NEARER for an incoming edge was changed, then we need\n \t       to add the source of the incoming edge to the worklist.  */\n-\t    && e->src != ENTRY_BLOCK_PTR && e->src->aux == 0)\n+\t    && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun) && e->src->aux == 0)\n \t  {\n \t    *tos++ = e->src;\n \t    e->src->aux = e;\n@@ -667,7 +667,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array\n      for just this purpose.  */\n   bitmap_ones (nearerout[last_basic_block]);\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     bitmap_and (nearerout[last_basic_block],\n \t\t     nearerout[last_basic_block],\n \t\t     nearer[(size_t) e->aux]);\n@@ -693,7 +693,7 @@ compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n       basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);\n-      if (b == ENTRY_BLOCK_PTR)\n+      if (b == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tbitmap_and_compl (insert[x], nearer[x], nearerout[last_basic_block]);\n       else\n \tbitmap_and_compl (insert[x], nearer[x], nearerout[b->index]);"}, {"sha": "c01ee1783051357df04f09d422003a95cdb235f1", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1937,7 +1937,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n     return;\n \n   e = loop_preheader_edge (loop);\n-  if (e->src == ENTRY_BLOCK_PTR)\n+  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     return;\n \n   altered = ALLOC_REG_SET (&reg_obstack);\n@@ -2068,7 +2068,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \t}\n \n       if (!single_pred_p (e->src)\n-\t  || single_pred (e->src) == ENTRY_BLOCK_PTR)\n+\t  || single_pred (e->src) == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tbreak;\n       e = single_pred_edge (e->src);\n     }"}, {"sha": "c8f1281a0ef8a6b98b09241d693aa1ec807b062b", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -433,7 +433,7 @@ unswitch_loop (struct loop *loop, basic_block unswitch_on, rtx cond, rtx cinsn)\n \n   /* Create a block with the condition.  */\n   prob = true_edge->probability;\n-  switch_bb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n+  switch_bb = create_empty_bb (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n   seq = compare_and_jump_seq (XEXP (cond, 0), XEXP (cond, 1), GET_CODE (cond),\n \t\t\t      block_label (true_edge->dest),\n \t\t\t      prob, cinsn);"}, {"sha": "88fc693bf2dd1ffe6fb3a7343fea99cfac7b1547", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -612,7 +612,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n \t\t&& ! df_regs_ever_live_p (hard_regno + j))\n \t      /* It needs save restore.\t */\n \t      hard_regno_costs[hard_regno]\n-\t\t+= 2 * ENTRY_BLOCK_PTR->next_bb->frequency + 1;\n+\t\t+= 2 * ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->frequency + 1;\n \t  priority = targetm.register_priority (hard_regno);\n \t  if (best_hard_regno < 0 || hard_regno_costs[hard_regno] < best_cost\n \t      || (hard_regno_costs[hard_regno] == best_cost"}, {"sha": "94b6e2559ef4453be720b8fceb6fafc3ddf4245a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -5295,7 +5295,8 @@ lra_inheritance (void)\n \t{\n \t  if (lra_dump_file != NULL)\n \t    fprintf (lra_dump_file, \" %d\", bb->index);\n-\t  if (bb->next_bb == EXIT_BLOCK_PTR || LABEL_P (BB_HEAD (bb->next_bb)))\n+\t  if (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t      || LABEL_P (BB_HEAD (bb->next_bb)))\n \t    break;\n \t  e = find_fallthru_edge (bb->succs);\n \t  if (! e)"}, {"sha": "efc19f2014058c0749a47741a6845b0944f7a7a1", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1002,7 +1002,8 @@ lra_create_live_ranges (bool all_p)\n   for (i = n_blocks_inverted - 1; i >= 0; --i)\n     {\n       bb = BASIC_BLOCK (post_order_rev_cfg[i]);\n-      if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n+      if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb\n+\t  == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n       process_bb_lives (bb, curr_point);\n     }"}, {"sha": "0deae88e85a3dea39479cecdbe05c18a2f528833", "filename": "gcc/lra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -2065,8 +2065,8 @@ has_nonexceptional_receiver (void)\n     bb->flags &= ~BB_REACHABLE;\n \n   /* Place the exit block on our worklist.  */\n-  EXIT_BLOCK_PTR->flags |= BB_REACHABLE;\n-  *tos++ = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->flags |= BB_REACHABLE;\n+  *tos++ = EXIT_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Iterate: find everything reachable from what we've already seen.  */\n   while (tos != worklist)"}, {"sha": "de25925b6235d3e06034f485d82a61056c12a3c5", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -659,7 +659,7 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n       index = streamer_read_hwi (ib);\n     }\n \n-  p_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION (fn);\n+  p_bb = ENTRY_BLOCK_PTR_FOR_FN (fn);\n   index = streamer_read_hwi (ib);\n   while (index != -1)\n     {\n@@ -996,7 +996,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n      of a gimple body is used by the cgraph routines, but we should\n      really use the presence of the CFG.  */\n   {\n-    edge_iterator ei = ei_start (ENTRY_BLOCK_PTR->succs);\n+    edge_iterator ei = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n     gimple_set_body (fn_decl, bb_seq (ei_edge (ei)->dest));\n   }\n "}, {"sha": "6f1585a2bf967f9d286781cb42a11d8b3ad775bd", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1594,7 +1594,7 @@ output_cfg (struct output_block *ob, struct function *fn)\n \n   streamer_write_hwi (ob, -1);\n \n-  bb = ENTRY_BLOCK_PTR;\n+  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n   while (bb->next_bb)\n     {\n       streamer_write_hwi (ob, bb->next_bb->index);"}, {"sha": "e709f2ac2c65f8424af24dbfb91004e75868fc0e", "filename": "gcc/mcf.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -508,7 +508,7 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n \n   /* Compute constants b, k_pos, k_neg used in the cost function calculation.\n      b = sqrt(avg_vertex_weight(cfg)); k_pos = b; k_neg = 50b.  */\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     total_vertex_weight += bb->count;\n \n   sqrt_avg_vertex_weight = mcf_sqrt (total_vertex_weight /\n@@ -523,7 +523,7 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n   if (dump_file)\n     fprintf (dump_file, \"\\nVertex transformation:\\n\");\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n   {\n     /* v'->v'': index1->(index1+1).  */\n     i = 2 * bb->index;\n@@ -1125,7 +1125,8 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n   if (dump_file)\n     fprintf (dump_file, \"\\nadjust_cfg_counts():\\n\");\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       i = 2 * bb->index;\n \n@@ -1238,8 +1239,10 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n         }\n     }\n \n-  ENTRY_BLOCK_PTR->count = sum_edge_counts (ENTRY_BLOCK_PTR->succs);\n-  EXIT_BLOCK_PTR->count = sum_edge_counts (EXIT_BLOCK_PTR->preds);\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n+\t\t     sum_edge_counts (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n+\t\t     sum_edge_counts (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n   /* Compute edge probabilities.  */\n   FOR_ALL_BB (bb)"}, {"sha": "ed45094c3959aa6a463c34d9b4f8a6191424e1b6", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -211,7 +211,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n      fallthrough edge; there can be at most one, but there could be\n      none at all, e.g. when exit is called.  */\n   pre_exit = 0;\n-  FOR_EACH_EDGE (eg, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (eg, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (eg->flags & EDGE_FALLTHRU)\n       {\n \tbasic_block src_bb = eg->src;\n@@ -221,7 +221,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t/* If this function returns a value at the end, we have to\n \t   insert the final mode switch before the return value copy\n \t   to its hard register.  */\n-\tif (EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 1\n+\tif (EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == 1\n \t    && NONJUMP_INSN_P ((last_insn = BB_END (src_bb)))\n \t    && GET_CODE (PATTERN (last_insn)) == USE\n \t    && GET_CODE ((ret_reg = XEXP (PATTERN (last_insn), 0))) == REG)\n@@ -492,7 +492,7 @@ optimize_mode_switching (void)\n #if defined (MODE_ENTRY) && defined (MODE_EXIT)\n   /* Split the edge from the entry block, so that we can note that\n      there NORMAL_MODE is supplied.  */\n-  post_entry = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+  post_entry = split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n   pre_exit = create_pre_exit (n_entities, entity_map, num_modes);\n #endif\n "}, {"sha": "f3130449909873d4238dcc61150aaf1a3b63d4fa", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1308,7 +1308,7 @@ canon_loop (struct loop *loop)\n \n   /* Avoid annoying special cases of edges going to exit\n      block.  */\n-  FOR_EACH_EDGE (e, i, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, i, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if ((e->flags & EDGE_FALLTHRU) && (EDGE_COUNT (e->src->succs) > 1))\n       split_edge (e);\n \n@@ -3344,7 +3344,7 @@ rest_of_handle_sms (void)\n \n   /* Finalize layout changes.  */\n   FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n+    if (bb->next_bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n       bb->aux = bb->next_bb;\n   free_dominance_info (CDI_DOMINATORS);\n   cfg_layout_finalize ();"}, {"sha": "bf834bfd7b4b24e41e8499b7cdab583edc30dfc5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -8235,7 +8235,7 @@ build_omp_regions (void)\n {\n   gcc_assert (root_omp_region == NULL);\n   calculate_dominance_info (CDI_DOMINATORS);\n-  build_omp_regions_1 (ENTRY_BLOCK_PTR, NULL, false);\n+  build_omp_regions_1 (ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, false);\n }\n \n /* Main entry point for expanding OMP-GIMPLE into runtime calls.  */"}, {"sha": "9ce17e50793d07289d99d6860709c6cd40c63a24", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1158,12 +1158,12 @@ eliminate_partially_redundant_loads (void)\n \n   /* Note we start at block 1.  */\n \n-  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return;\n \n   FOR_BB_BETWEEN (bb,\n-\t\t  ENTRY_BLOCK_PTR->next_bb->next_bb,\n-\t\t  EXIT_BLOCK_PTR,\n+\t\t  ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->next_bb,\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun),\n \t\t  next_bb)\n     {\n       /* Don't try anything on basic blocks with strange predecessors.  */"}, {"sha": "919dbe90b3e712c80a14334a98cef74e596740ab", "filename": "gcc/predict.c", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -129,11 +129,11 @@ maybe_hot_frequency_p (struct function *fun, int freq)\n   if (profile_status_for_function (fun) == PROFILE_ABSENT)\n     return true;\n   if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n-      && freq < (ENTRY_BLOCK_PTR_FOR_FUNCTION (fun)->frequency * 2 / 3))\n+      && freq < (ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency * 2 / 3))\n     return false;\n   if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0)\n     return false;\n-  if (freq < (ENTRY_BLOCK_PTR_FOR_FUNCTION (fun)->frequency\n+  if (freq < (ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency\n \t      / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n     return false;\n   return true;\n@@ -251,24 +251,27 @@ probably_never_executed (struct function *fun,\n \treturn false;\n       if (!frequency)\n \treturn true;\n-      if (!ENTRY_BLOCK_PTR->frequency)\n+      if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency)\n \treturn false;\n-      if (ENTRY_BLOCK_PTR->count)\n+      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\n \t{\n           gcov_type computed_count;\n           /* Check for possibility of overflow, in which case entry bb count\n              is large enough to do the division first without losing much\n              precision.  */\n-          if (ENTRY_BLOCK_PTR->count < REG_BR_PROB_BASE * REG_BR_PROB_BASE)\n+\t  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count < REG_BR_PROB_BASE *\n+\t      REG_BR_PROB_BASE)\n             {\n               gcov_type scaled_count\n-                  = frequency * ENTRY_BLOCK_PTR->count * unlikely_count_fraction;\n-              computed_count = RDIV (scaled_count, ENTRY_BLOCK_PTR->frequency);\n+\t\t  = frequency * ENTRY_BLOCK_PTR_FOR_FN (cfun)->count *\n+\t     unlikely_count_fraction;\n+\t      computed_count = RDIV (scaled_count,\n+\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency);\n             }\n           else\n             {\n-              computed_count = RDIV (ENTRY_BLOCK_PTR->count,\n-                                     ENTRY_BLOCK_PTR->frequency);\n+\t      computed_count = RDIV (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count,\n+\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency);\n               computed_count *= frequency * unlikely_count_fraction;\n             }\n           if (computed_count >= profile_info->runs)\n@@ -613,7 +616,8 @@ void\n gimple_predict_edge (edge e, enum br_predictor predictor, int probability)\n {\n   gcc_assert (profile_status != PROFILE_GUESSED);\n-  if ((e->src != ENTRY_BLOCK_PTR && EDGE_COUNT (e->src->succs) > 1)\n+  if ((e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun) && EDGE_COUNT (e->src->succs) >\n+       1)\n       && flag_guess_branch_prob && optimize)\n     {\n       struct edge_prediction *i = XNEW (struct edge_prediction);\n@@ -2170,7 +2174,7 @@ apply_return_prediction (void)\n   enum prediction direction;\n   edge_iterator ei;\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       return_stmt = last_stmt (e->src);\n       if (return_stmt\n@@ -2218,7 +2222,7 @@ tree_bb_level_predictions (void)\n   edge e;\n   edge_iterator ei;\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (!(e->flags & (EDGE_ABNORMAL | EDGE_FAKE | EDGE_EH)))\n       {\n         has_return_edges = true;\n@@ -2286,7 +2290,7 @@ tree_estimate_probability_bb (basic_block bb)\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       /* Predict edges to user labels with attributes.  */\n-      if (e->dest != EXIT_BLOCK_PTR)\n+      if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  gimple_stmt_iterator gi;\n \t  for (gi = gsi_start_bb (e->dest); !gsi_end_p (gi); gsi_next (&gi))\n@@ -2324,9 +2328,9 @@ tree_estimate_probability_bb (basic_block bb)\n \t return_block:\n \t return_stmt.  */\n       if (e->dest != bb->next_bb\n-\t  && e->dest != EXIT_BLOCK_PTR\n+\t  && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && single_succ_p (e->dest)\n-\t  && single_succ_edge (e->dest)->dest == EXIT_BLOCK_PTR\n+\t  && single_succ_edge (e->dest)->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && (last = last_stmt (e->dest)) != NULL\n \t  && gimple_code (last) == GIMPLE_RETURN)\n \t{\n@@ -2350,7 +2354,7 @@ tree_estimate_probability_bb (basic_block bb)\n \n       /* Look for block we are guarding (ie we dominate it,\n \t but it doesn't postdominate us).  */\n-      if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n+      if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun) && e->dest != bb\n \t  && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n \t  && !dominated_by_p (CDI_POST_DOMINATORS, e->src, e->dest))\n \t{\n@@ -2612,7 +2616,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t}\n       BLOCK_INFO (bb)->npredecessors = count;\n       /* When function never returns, we will never process exit block.  */\n-      if (!count && bb == EXIT_BLOCK_PTR)\n+      if (!count && bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \tbb->count = bb->frequency = 0;\n     }\n \n@@ -2762,7 +2766,7 @@ estimate_loops (void)\n     {\n       bitmap_set_bit (tovisit, bb->index);\n     }\n-  propagate_freq (ENTRY_BLOCK_PTR, tovisit);\n+  propagate_freq (ENTRY_BLOCK_PTR_FOR_FN (cfun), tovisit);\n   BITMAP_FREE (tovisit);\n }\n \n@@ -2892,14 +2896,14 @@ counts_to_freqs (void)\n   /* Don't overwrite the estimated frequencies when the profile for\n      the function is missing.  We may drop this function PROFILE_GUESSED\n      later in drop_profile ().  */\n-  if (!ENTRY_BLOCK_PTR->count)\n+  if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\n     return 0;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     true_count_max = MAX (bb->count, true_count_max);\n \n   count_max = MAX (true_count_max, 1);\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     bb->frequency = (bb->count * BB_FREQ_MAX + count_max / 2) / count_max;\n \n   return true_count_max;\n@@ -2924,11 +2928,11 @@ expensive_function_p (int threshold)\n   /* Frequencies are out of range.  This either means that function contains\n      internal loop executing more than BB_FREQ_MAX times or profile feedback\n      is available and function has not been executed at all.  */\n-  if (ENTRY_BLOCK_PTR->frequency == 0)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency == 0)\n     return true;\n \n   /* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */\n-  limit = ENTRY_BLOCK_PTR->frequency * threshold;\n+  limit = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency * threshold;\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n@@ -2973,12 +2977,13 @@ estimate_bb_frequencies (bool force)\n \n       mark_dfs_back_edges ();\n \n-      single_succ_edge (ENTRY_BLOCK_PTR)->probability = REG_BR_PROB_BASE;\n+      single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))->probability =\n+\t REG_BR_PROB_BASE;\n \n       /* Set up block info for each basic block.  */\n       alloc_aux_for_blocks (sizeof (struct block_info_def));\n       alloc_aux_for_edges (sizeof (struct edge_info_def));\n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n@@ -3002,7 +3007,7 @@ estimate_bb_frequencies (bool force)\n \t  memcpy (&freq_max, &BLOCK_INFO (bb)->frequency, sizeof (freq_max));\n \n       sreal_div (&freq_max, &real_bb_freq_max, &freq_max);\n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n \t{\n \t  sreal tmp;\n \n@@ -3186,7 +3191,7 @@ rebuild_frequencies (void)\n      max counts.  */\n   gcov_type count_max = 0;\n   basic_block bb;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     count_max = MAX (bb->count, count_max);\n \n   if (profile_status == PROFILE_GUESSED"}, {"sha": "85671b30bc47f7e109cbd2ba89cd9e51b9b40607", "filename": "gcc/profile.c", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -117,7 +117,7 @@ instrument_edges (struct edge_list *el)\n   int num_edges = NUM_EDGES (el);\n   basic_block bb;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -192,7 +192,8 @@ instrument_values (histogram_values values)\n \n   case HIST_TYPE_TIME_PROFILE:\n     {\n-      basic_block bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+      basic_block bb =\n+     split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n       gimple_stmt_iterator gsi = gsi_start_bb (bb);\n \n       gimple_gen_time_profiler (t, 0, gsi);\n@@ -272,7 +273,7 @@ get_exec_counts (unsigned cfg_checksum, unsigned lineno_checksum)\n   gcov_type *counts;\n \n   /* Count the edges to be (possibly) instrumented.  */\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -332,7 +333,7 @@ correct_negative_edge_counts (void)\n   edge e;\n   edge_iterator ei;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         {\n@@ -383,7 +384,8 @@ is_inconsistent (void)\n \t  inconsistent = true;\n \t}\n       if (bb->count != sum_edge_counts (bb->succs) &&\n-          ! (find_edge (bb, EXIT_BLOCK_PTR) != NULL && block_ends_with_call_p (bb)))\n+\t  ! (find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun)) != NULL\n+\t     && block_ends_with_call_p (bb)))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -408,7 +410,7 @@ static void\n set_bb_counts (void)\n {\n   basic_block bb;\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       bb->count = sum_edge_counts (bb->succs);\n       gcc_assert (bb->count >= 0);\n@@ -427,7 +429,7 @@ read_profile_edge_counts (gcov_type *exec_counts)\n   /* The first count in the .da file is the number of times that the function\n      was entered.  This is the exec_count for block zero.  */\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -491,7 +493,7 @@ compute_frequency_overlap (void)\n   int overlap = 0;\n   basic_block bb;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       count_total += bb->count;\n       freq_total += bb->frequency;\n@@ -500,7 +502,7 @@ compute_frequency_overlap (void)\n   if (count_total == 0 || freq_total == 0)\n     return 0;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     overlap += MIN (bb->count * OVERLAP_BASE / count_total,\n \t\t    bb->frequency * OVERLAP_BASE / freq_total);\n \n@@ -537,7 +539,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \n   /* Attach extra info block to each bb.  */\n   alloc_aux_for_blocks (sizeof (struct bb_info));\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -551,8 +553,8 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n     }\n \n   /* Avoid predicting entry on exit nodes.  */\n-  BB_INFO (EXIT_BLOCK_PTR)->succ_count = 2;\n-  BB_INFO (ENTRY_BLOCK_PTR)->pred_count = 2;\n+  BB_INFO (EXIT_BLOCK_PTR_FOR_FN (cfun))->succ_count = 2;\n+  BB_INFO (ENTRY_BLOCK_PTR_FOR_FN (cfun))->pred_count = 2;\n \n   num_edges = read_profile_edge_counts (exec_counts);\n \n@@ -582,7 +584,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n     {\n       passes++;\n       changes = 0;\n-      FOR_BB_BETWEEN (bb, EXIT_BLOCK_PTR, NULL, prev_bb)\n+      FOR_BB_BETWEEN (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), NULL, prev_bb)\n \t{\n \t  struct bb_info *bi = BB_INFO (bb);\n \t  if (! bi->count_valid)\n@@ -724,7 +726,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n     hist_br_prob[i] = 0;\n   num_branches = 0;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -743,9 +745,9 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t     already present.  We get negative frequency from the entry\n \t     point.  */\n \t  if ((e->count < 0\n-\t       && e->dest == EXIT_BLOCK_PTR)\n+\t       && e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t      || (e->count > bb->count\n-\t\t  && e->dest != EXIT_BLOCK_PTR))\n+\t\t  && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)))\n \t    {\n \t      if (block_ends_with_call_p (bb))\n \t\te->count = e->count < 0 ? 0 : bb->count;\n@@ -1064,17 +1066,17 @@ branch_prob (void)\n \t      ne->goto_locus = e->goto_locus;\n \t    }\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n-\t       && e->dest != EXIT_BLOCK_PTR)\n+\t       && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    need_exit_edge = 1;\n-\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    have_exit_edge = 1;\n \t}\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n-\t       && e->src != ENTRY_BLOCK_PTR)\n+\t       && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    need_entry_edge = 1;\n-\t  if (e->src == ENTRY_BLOCK_PTR)\n+\t  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    have_entry_edge = 1;\n \t}\n \n@@ -1083,14 +1085,14 @@ branch_prob (void)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Adding fake exit edge to bb %i\\n\",\n \t\t     bb->index);\n-\t  make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+\t  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n \t}\n       if (need_entry_edge && !have_entry_edge)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Adding fake entry edge to bb %i\\n\",\n \t\t     bb->index);\n-\t  make_edge (ENTRY_BLOCK_PTR, bb, EDGE_FAKE);\n+\t  make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FAKE);\n \t  /* Avoid bbs that have both fake entry edge and also some\n \t     exit edge.  One of those edges wouldn't be added to the\n \t     spanning tree, but we can't instrument any of them.  */\n@@ -1146,7 +1148,8 @@ branch_prob (void)\n \n       /* Mark edges we've replaced by fake edges above as ignored.  */\n       if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n-\t  && e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR)\n+\t  && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  EDGE_INFO (e)->ignore = 1;\n \t  ignored_edges++;\n@@ -1213,7 +1216,8 @@ branch_prob (void)\n       gcov_write_length (offset);\n \n       /* Arcs */\n-      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+      FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t      EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n@@ -1257,7 +1261,7 @@ branch_prob (void)\n \t  gimple_stmt_iterator gsi;\n \t  gcov_position_t offset = 0;\n \n-\t  if (bb == ENTRY_BLOCK_PTR->next_bb)\n+\t  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb)\n \t    {\n \t      expanded_location curr_location =\n \t\texpand_location (DECL_SOURCE_LOCATION (current_function_decl));\n@@ -1381,11 +1385,11 @@ find_spanning_tree (struct edge_list *el)\n   basic_block bb;\n \n   /* We use aux field for standard union-find algorithm.  */\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     bb->aux = bb;\n \n   /* Add fake edge exit to entry we can't instrument.  */\n-  union_groups (EXIT_BLOCK_PTR, ENTRY_BLOCK_PTR);\n+  union_groups (EXIT_BLOCK_PTR_FOR_FN (cfun), ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   /* First add all abnormal edges to the tree unless they form a cycle. Also\n      add all edges to EXIT_BLOCK_PTR to avoid inserting profiling code behind\n@@ -1394,7 +1398,7 @@ find_spanning_tree (struct edge_list *el)\n     {\n       edge e = INDEX_EDGE (el, i);\n       if (((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n-\t   || e->dest == EXIT_BLOCK_PTR)\n+\t   || e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  && !EDGE_INFO (e)->ignore\n \t  && (find_group (e->src) != find_group (e->dest)))\n \t{"}, {"sha": "6aad46684d665a4b3120f5d1b55a809c5353a46c", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -2649,7 +2649,7 @@ convert_regs_entry (void)\n      Note that we are inserting converted code here.  This code is\n      never seen by the convert_regs pass.  */\n \n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     {\n       basic_block block = e->dest;\n       block_info bi = BLOCK_INFO (block);\n@@ -2693,7 +2693,7 @@ convert_regs_exit (void)\n       value_reg_high = END_HARD_REGNO (retvalue) - 1;\n     }\n \n-  output_stack = &BLOCK_INFO (EXIT_BLOCK_PTR)->stack_in;\n+  output_stack = &BLOCK_INFO (EXIT_BLOCK_PTR_FOR_FN (cfun))->stack_in;\n   if (value_reg_low == -1)\n     output_stack->top = -1;\n   else\n@@ -2847,7 +2847,7 @@ compensate_edges (void)\n   starting_stack_p = false;\n \n   FOR_EACH_BB (bb)\n-    if (bb != ENTRY_BLOCK_PTR)\n+    if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n       {\n         edge e;\n         edge_iterator ei;\n@@ -3141,14 +3141,14 @@ convert_regs (void)\n \n   /* Construct the desired stack for function exit.  */\n   convert_regs_exit ();\n-  BLOCK_INFO (EXIT_BLOCK_PTR)->done = 1;\n+  BLOCK_INFO (EXIT_BLOCK_PTR_FOR_FN (cfun))->done = 1;\n \n   /* ??? Future: process inner loops first, and give them arbitrary\n      initial stacks which emit_swap_insn can modify.  This ought to\n      prevent double fxch that often appears at the head of a loop.  */\n \n   /* Process all blocks reachable from all entry points.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     cfg_altered |= convert_regs_2 (e->dest);\n \n   /* ??? Process all unreachable blocks.  Though there's no excuse\n@@ -3221,7 +3221,7 @@ reg_to_stack (void)\n \n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (!(e->flags & EDGE_DFS_BACK)\n-\t    && e->src != ENTRY_BLOCK_PTR)\n+\t    && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t  bi->predecessors++;\n \n       /* Set current register status at last instruction `uninitialized'.  */"}, {"sha": "9bf426cd175da5dce38b25588924ede9a174807b", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -137,7 +137,7 @@ extern size_t reg_info_p_size;\n    frequency.  */\n #define REG_FREQ_FROM_BB(bb) (optimize_size\t\t\t\t      \\\n \t\t\t      || (flag_branch_probabilities\t\t      \\\n-\t\t\t\t  && !ENTRY_BLOCK_PTR->count)\t\t      \\\n+\t\t\t\t  && !ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)   \\\n \t\t\t      ? REG_FREQ_MAX\t\t\t\t      \\\n \t\t\t      : ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n \t\t\t      ? ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\"}, {"sha": "96619f6782096e476bfad5760e351c2288e28df7", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1615,7 +1615,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && reg_mentioned_p (XEXP (note, 0), in)\n \t    /* Check that a former pseudo is valid; see find_dummy_reload.  */\n \t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t|| (! bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n+\t\t|| (! bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t\t    ORIGINAL_REGNO (XEXP (note, 0)))\n \t\t    && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1))\n \t    && ! refers_to_regno_for_reload_p (regno,\n@@ -1939,7 +1939,7 @@ combine_reloads (void)\n \t&& !fixed_regs[regno]\n \t/* Check that a former pseudo is valid; see find_dummy_reload.  */\n \t&& (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t    || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n+\t    || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t       ORIGINAL_REGNO (XEXP (note, 0)))\n \t\t&& hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1)))\n       {\n@@ -2098,7 +2098,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t     can ignore the conflict).  We must never introduce writes\n \t     to such hardregs, as they would clobber the other live\n \t     pseudo.  See PR 20973.  */\n-          || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n+\t  || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t     ORIGINAL_REGNO (in))\n \t      /* Similarly, only do this if we can be sure that the death\n \t\t note is still valid.  global can assign some hardreg to"}, {"sha": "6864ec1667fac8d1ad47689ec18c7e13a6ff27e6", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -617,8 +617,8 @@ has_nonexceptional_receiver (void)\n     bb->flags &= ~BB_REACHABLE;\n \n   /* Place the exit block on our worklist.  */\n-  EXIT_BLOCK_PTR->flags |= BB_REACHABLE;\n-  *tos++ = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->flags |= BB_REACHABLE;\n+  *tos++ = EXIT_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Iterate: find everything reachable from what we've already seen.  */\n   while (tos != worklist)"}, {"sha": "4609c3ad963742c9838568d316325102ab982fd0", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -147,7 +147,7 @@ find_basic_block (rtx insn, int search_limit)\n \n   /* The start of the function.  */\n   else if (insn == 0)\n-    return ENTRY_BLOCK_PTR->next_bb->index;\n+    return ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->index;\n \n   /* See if any of the upcoming CODE_LABELs start a basic block.  If we reach\n      anything other than a CODE_LABEL or note, we can't find this code.  */\n@@ -966,7 +966,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \n       /* Get starting and ending insn, handling the case where each might\n \t be a SEQUENCE.  */\n-      start_insn = (b == ENTRY_BLOCK_PTR->next_bb->index ?\n+      start_insn = (b == ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->index ?\n \t\t    insns : BB_HEAD (BASIC_BLOCK (b)));\n       stop_insn = target;\n "}, {"sha": "955501a9547ba26ae5325c665bca17a9f855feb9", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -648,7 +648,7 @@ schedule_ebbs (void)\n \t{\n \t  edge e;\n \t  tail = BB_END (bb);\n-\t  if (bb->next_bb == EXIT_BLOCK_PTR\n+\t  if (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      || LABEL_P (BB_HEAD (bb->next_bb)))\n \t    break;\n \t  e = find_fallthru_edge (bb->succs);\n@@ -683,7 +683,7 @@ ebb_add_block (basic_block bb, basic_block after)\n   /* Recovery blocks are always bounded by BARRIERS,\n      therefore, they always form single block EBB,\n      therefore, we can use rec->index to identify such EBBs.  */\n-  if (after == EXIT_BLOCK_PTR)\n+  if (after == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     bitmap_set_bit (&dont_calc_deps, bb->index);\n   else if (after == last_bb)\n     last_bb = bb;"}, {"sha": "070404c42450d2d8b91503a83be4794af1c9d58a", "filename": "gcc/sched-int.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -945,14 +945,15 @@ extern vec<haifa_deps_insn_data_def> h_d_i_d;\n /* INSN is a speculation check that will simply reexecute the speculatively\n    scheduled instruction if the speculation fails.  */\n #define IS_SPECULATION_SIMPLE_CHECK_P(INSN) \\\n-  (RECOVERY_BLOCK (INSN) == EXIT_BLOCK_PTR)\n+  (RECOVERY_BLOCK (INSN) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \n /* INSN is a speculation check that will branch to RECOVERY_BLOCK if the\n    speculation fails.  Insns in that block will reexecute the speculatively\n    scheduled code and then will return immediately after INSN thus preserving\n    semantics of the program.  */\n #define IS_SPECULATION_BRANCHY_CHECK_P(INSN) \\\n-  (RECOVERY_BLOCK (INSN) != NULL && RECOVERY_BLOCK (INSN) != EXIT_BLOCK_PTR)\n+  (RECOVERY_BLOCK (INSN) != NULL             \\\n+   && RECOVERY_BLOCK (INSN) != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \n \f\n /* Dep status (aka ds_t) of the link encapsulates all information for a given"}, {"sha": "1663e2fd95dae337d6861e2e13562a39760cd022", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -495,7 +495,7 @@ find_single_block_region (bool ebbs_p)\n             BLOCK_TO_BB (bb->index) = i - RGN_BLOCKS (nr_regions);\n             i++;\n \n-            if (bb->next_bb == EXIT_BLOCK_PTR\n+\t    if (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n                 || LABEL_P (BB_HEAD (bb->next_bb)))\n               break;\n \n@@ -665,7 +665,7 @@ haifa_find_rgns (void)\n \n   /* DFS traversal to find inner loops in the cfg.  */\n \n-  current_edge = ei_start (single_succ (ENTRY_BLOCK_PTR)->succs);\n+  current_edge = ei_start (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun))->succs);\n   sp = -1;\n \n   while (1)\n@@ -840,7 +840,7 @@ haifa_find_rgns (void)\n \t      /* If we exited the loop early, then I is the header of\n \t\t a non-reducible loop and we should quit processing it\n \t\t now.  */\n-\t      if (jbb != EXIT_BLOCK_PTR)\n+\t      if (jbb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\tcontinue;\n \n \t      /* I is a header of an inner loop, or block 0 in a subroutine\n@@ -858,7 +858,7 @@ haifa_find_rgns (void)\n \t      /* Decrease degree of all I's successors for topological\n \t\t ordering.  */\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t  --degree[e->dest->index];\n \n \t      /* Estimate # insns, and count # blocks in the region.  */\n@@ -875,7 +875,7 @@ haifa_find_rgns (void)\n \t\t    /* Leaf nodes have only a single successor which must\n \t\t       be EXIT_BLOCK.  */\n \t\t    if (single_succ_p (jbb)\n-\t\t\t&& single_succ (jbb) == EXIT_BLOCK_PTR)\n+\t\t\t&& single_succ (jbb) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t      {\n \t\t\tqueue[++tail] = jbb->index;\n \t\t\tbitmap_set_bit (in_queue, jbb->index);\n@@ -893,7 +893,7 @@ haifa_find_rgns (void)\n \n \t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t    {\n-\t\t      if (e->src == ENTRY_BLOCK_PTR)\n+\t\t      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t\t\tcontinue;\n \n \t\t      node = e->src->index;\n@@ -954,7 +954,7 @@ haifa_find_rgns (void)\n \n \t\t      /* See discussion above about nodes not marked as in\n \t\t\t this loop during the initial DFS traversal.  */\n-\t\t      if (e->src == ENTRY_BLOCK_PTR\n+\t\t      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t\t\t  || max_hdr[node] != loop_head)\n \t\t\t{\n \t\t\t  tail = -1;\n@@ -1006,7 +1006,7 @@ haifa_find_rgns (void)\n \t\t\t  queue[head] = queue[tail--];\n \n \t\t\t  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (child)->succs)\n-\t\t\t    if (e->dest != EXIT_BLOCK_PTR)\n+\t\t\t    if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t\t      --degree[e->dest->index];\n \t\t\t}\n \t\t      else\n@@ -1026,7 +1026,7 @@ haifa_find_rgns (void)\n \t\t     This may provide several smaller regions instead\n \t\t     of one too_large region.  */\n                   FOR_EACH_EDGE (e, ei, bb->succs)\n-                    if (e->dest != EXIT_BLOCK_PTR)\n+\t\t    if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n                       bitmap_set_bit (extended_rgn_header, e->dest->index);\n                 }\n \t    }\n@@ -1305,7 +1305,7 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n \t      BLOCK_TO_BB (bbn) = 0;\n \n \t      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (bbn)->succs)\n-\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t  degree[e->dest->index]--;\n \n \t      if (!large)\n@@ -1362,7 +1362,7 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n \t\t      idx++;\n \n \t\t      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (succn)->succs)\n-\t\t\tif (e->dest != EXIT_BLOCK_PTR)\n+\t\t\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t\t  degree[e->dest->index]--;\n \t\t    }\n \t\t}\n@@ -1426,7 +1426,7 @@ compute_dom_prob_ps (int bb)\n       edge out_edge;\n       edge_iterator out_ei;\n \n-      if (in_edge->src == ENTRY_BLOCK_PTR)\n+      if (in_edge->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n \n       pred_bb = BLOCK_TO_BB (in_edge->src->index);\n@@ -2663,7 +2663,7 @@ propagate_deps (int bb, struct deps_desc *pred_deps)\n   FOR_EACH_EDGE (e, ei, block->succs)\n     {\n       /* Only bbs \"below\" bb, in the same region, are interesting.  */\n-      if (e->dest == EXIT_BLOCK_PTR\n+      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  || CONTAINING_RGN (block->index) != CONTAINING_RGN (e->dest->index)\n \t  || BLOCK_TO_BB (e->dest->index) <= bb)\n \tcontinue;\n@@ -3454,10 +3454,11 @@ rgn_add_block (basic_block bb, basic_block after)\n   extend_regions ();\n   bitmap_set_bit (&not_in_df, bb->index);\n \n-  if (after == 0 || after == EXIT_BLOCK_PTR)\n+  if (after == 0 || after == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       rgn_make_new_region_out_of_new_block (bb);\n-      RGN_DONT_CALC_DEPS (nr_regions - 1) = (after == EXIT_BLOCK_PTR);\n+      RGN_DONT_CALC_DEPS (nr_regions - 1) = (after\n+\t\t\t\t\t     == EXIT_BLOCK_PTR_FOR_FN (cfun));\n     }\n   else\n     {"}, {"sha": "7dfc70327d7a53cef504c31f39b500752f258e48", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3682,7 +3682,7 @@ maybe_tidy_empty_bb (basic_block bb)\n      successors.  Otherwise remove it.  */\n   if (!sel_bb_empty_p (bb)\n       || (single_succ_p (bb)\n-          && single_succ (bb) == EXIT_BLOCK_PTR\n+\t  && single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n           && (!single_pred_p (bb)\n               || !(single_pred_edge (bb)->flags & EDGE_FALLTHRU)))\n       || EDGE_COUNT (bb->preds) == 0\n@@ -3853,7 +3853,7 @@ tidy_control_flow (basic_block xbb, bool full_tidying)\n       && EDGE_COUNT (xbb->succs) == 1\n       && (EDGE_SUCC (xbb, 0)->flags & EDGE_FALLTHRU)\n       /* When successor is an EXIT block, it may not be the next block.  */\n-      && single_succ (xbb) != EXIT_BLOCK_PTR\n+      && single_succ (xbb) != EXIT_BLOCK_PTR_FOR_FN (cfun)\n       /* And unconditional jump in previous basic block leads to\n          next basic block of XBB and this jump can be safely removed.  */\n       && in_current_region_p (xbb->prev_bb)\n@@ -4325,7 +4325,7 @@ init_lv_sets (void)\n     init_lv_set (bb);\n \n   /* Don't forget EXIT_BLOCK.  */\n-  init_lv_set (EXIT_BLOCK_PTR);\n+  init_lv_set (EXIT_BLOCK_PTR_FOR_FN (cfun));\n }\n \n /* Release lv set of HEAD.  */\n@@ -4346,7 +4346,7 @@ free_lv_sets (void)\n   basic_block bb;\n \n   /* Don't forget EXIT_BLOCK.  */\n-  free_lv_set (EXIT_BLOCK_PTR);\n+  free_lv_set (EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   /* Free LV sets.  */\n   FOR_EACH_BB (bb)\n@@ -4524,7 +4524,7 @@ sel_bb_head (basic_block bb)\n {\n   insn_t head;\n \n-  if (bb == EXIT_BLOCK_PTR)\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       gcc_assert (exit_insn != NULL_RTX);\n       head = exit_insn;\n@@ -4557,7 +4557,7 @@ sel_bb_end (basic_block bb)\n   if (sel_bb_empty_p (bb))\n     return NULL_RTX;\n \n-  gcc_assert (bb != EXIT_BLOCK_PTR);\n+  gcc_assert (bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   return BB_END (bb);\n }\n@@ -4852,7 +4852,7 @@ bb_ends_ebb_p (basic_block bb)\n   basic_block next_bb = bb_next_bb (bb);\n   edge e;\n \n-  if (next_bb == EXIT_BLOCK_PTR\n+  if (next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n       || bitmap_bit_p (forced_ebb_heads, next_bb->index)\n       || (LABEL_P (BB_HEAD (next_bb))\n \t  /* NB: LABEL_NUSES () is not maintained outside of jump.c.\n@@ -5538,7 +5538,7 @@ sel_create_recovery_block (insn_t orig_insn)\n \n   recovery_block = sched_create_recovery_block (&before_recovery);\n   if (before_recovery)\n-    copy_lv_set_from (before_recovery, EXIT_BLOCK_PTR);\n+    copy_lv_set_from (before_recovery, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   gcc_assert (sel_bb_empty_p (recovery_block));\n   sched_create_recovery_edges (first_bb, recovery_block, second_bb);\n@@ -5821,7 +5821,7 @@ setup_nop_and_exit_insns (void)\n   emit_insn (nop_pattern);\n   exit_insn = get_insns ();\n   end_sequence ();\n-  set_block_for_insn (exit_insn, EXIT_BLOCK_PTR);\n+  set_block_for_insn (exit_insn, EXIT_BLOCK_PTR_FOR_FN (cfun));\n }\n \n /* Free special insns used in the scheduler.  */\n@@ -6396,7 +6396,7 @@ sel_remove_loop_preheader (void)\n                  If it is so - delete this jump and clear data sets of its\n                  basic block if it becomes empty.  */\n \t      if (next_bb->prev_bb == prev_bb\n-                  && prev_bb != ENTRY_BLOCK_PTR\n+\t\t  && prev_bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n                   && bb_has_removable_jump_to_p (prev_bb, next_bb))\n                 {\n                   redirect_edge_and_branch (EDGE_SUCC (prev_bb, 0), next_bb);"}, {"sha": "ff99e519cf9805d0be864d6f92be1304916c3be7", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1024,7 +1024,7 @@ inner_loop_header_p (basic_block bb)\n   if (!current_loop_nest)\n     return false;\n \n-  if (bb == EXIT_BLOCK_PTR)\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return false;\n \n   inner_loop = bb->loop_father;\n@@ -1050,7 +1050,7 @@ get_loop_exit_edges_unique_dests (const struct loop *loop)\n   vec<edge> edges = vNULL;\n   struct loop_exit *exit;\n \n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun)\n               && current_loops->state & LOOPS_HAVE_RECORDED_EXITS);\n \n   for (exit = loop->exits->next; exit->e; exit = exit->next)\n@@ -1083,7 +1083,7 @@ sel_bb_empty_or_nop_p (basic_block bb)\n   if (!INSN_NOP_P (first))\n     return false;\n \n-  if (bb == EXIT_BLOCK_PTR)\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return false;\n \n   last = sel_bb_end (bb);\n@@ -1204,7 +1204,7 @@ _succ_iter_start (insn_t *succp, insn_t insn, int flags)\n   i.current_exit = -1;\n   i.loop_exits.create (0);\n \n-  if (bb != EXIT_BLOCK_PTR && BB_END (bb) != insn)\n+  if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun) && BB_END (bb) != insn)\n     {\n       i.bb_end = false;\n \n@@ -1308,7 +1308,7 @@ _succ_iter_cond (succ_iterator *ip, rtx *succp, rtx insn,\n \t{\n \t  basic_block bb = ip->e2->dest;\n \n-\t  if (bb == EXIT_BLOCK_PTR || bb == after_recovery)\n+\t  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb == after_recovery)\n \t    *succp = exit_insn;\n \t  else\n \t    {"}, {"sha": "1e3fcf0da5a85f14dcd205792e089b62ee458919", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -4551,7 +4551,8 @@ find_block_for_bookkeeping (edge e1, edge e2, bool lax)\n   edge e;\n \n   /* Loop over edges from E1 to E2, inclusive.  */\n-  for (e = e1; !lax || e->dest != EXIT_BLOCK_PTR; e = EDGE_SUCC (e->dest, 0))\n+  for (e = e1; !lax || e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun); e =\n+       EDGE_SUCC (e->dest, 0))\n     {\n       if (EDGE_COUNT (e->dest->preds) == 2)\n \t{\n@@ -4642,7 +4643,7 @@ create_block_for_bookkeeping (edge e1, edge e2)\n       if (DEBUG_INSN_P (insn)\n \t  && single_succ_p (new_bb)\n \t  && (succ = single_succ (new_bb))\n-\t  && succ != EXIT_BLOCK_PTR\n+\t  && succ != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  && DEBUG_INSN_P ((last = sel_bb_end (new_bb))))\n \t{\n \t  while (insn != last && (DEBUG_INSN_P (insn) || NOTE_P (insn)))"}, {"sha": "378d6c7e8ba7342878ac976befd235def0da1fc9", "filename": "gcc/store-motion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -805,7 +805,7 @@ insert_store (struct st_expr * expr, edge e)\n \n   /* If tmp is NULL, we found an insertion on every edge, blank the\n      insertion vector for these edges, and insert at the start of the BB.  */\n-  if (!tmp && bb != EXIT_BLOCK_PTR)\n+  if (!tmp && bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       FOR_EACH_EDGE (tmp, ei, e->dest->preds)\n \t{\n@@ -869,7 +869,7 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n \t}\n       bb = act->dest;\n \n-      if (bb == EXIT_BLOCK_PTR\n+      if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t  || bitmap_bit_p (visited, bb->index))\n \t{\n \t  if (!ei_end_p (ei))"}, {"sha": "271f600323b14517abd1a75a4d4cec8a7098f4ce", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1950,7 +1950,7 @@ tm_region_init (struct tm_region *region)\n   vec<tm_region_p> bb_regions = vNULL;\n \n   all_tm_regions = region;\n-  bb = single_succ (ENTRY_BLOCK_PTR);\n+  bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   /* We could store this information in bb->aux, but we may get called\n      through get_all_tm_blocks() from another pass that may be already\n@@ -2016,7 +2016,7 @@ gate_tm_init (void)\n       struct tm_region *region = (struct tm_region *)\n \tobstack_alloc (&tm_obstack.obstack, sizeof (struct tm_region));\n       memset (region, 0, sizeof (*region));\n-      region->entry_block = single_succ (ENTRY_BLOCK_PTR);\n+      region->entry_block = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n       /* For a clone, the entire function is the region.  But even if\n \t we don't need to record any exit blocks, we may need to\n \t record irrevocable blocks.  */\n@@ -3633,7 +3633,8 @@ tm_memopt_compute_available (struct tm_region *region,\n \t/* If the out state of this block changed, then we need to add\n \t   its successors to the worklist if they are not already in.  */\n \tFOR_EACH_EDGE (e, ei, bb->succs)\n-\t  if (!AVAIL_IN_WORKLIST_P (e->dest) && e->dest != EXIT_BLOCK_PTR)\n+\t  if (!AVAIL_IN_WORKLIST_P (e->dest)\n+\t      && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      *qin++ = e->dest;\n \t      AVAIL_IN_WORKLIST_P (e->dest) = true;\n@@ -4539,12 +4540,14 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n   if (for_clone)\n     {\n       old_irr = d->irrevocable_blocks_clone;\n-      queue.quick_push (single_succ (ENTRY_BLOCK_PTR));\n+      queue.quick_push (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n       if (ipa_tm_scan_irr_blocks (&queue, new_irr, old_irr, NULL))\n \t{\n-\t  ipa_tm_propagate_irr (single_succ (ENTRY_BLOCK_PTR), new_irr,\n+\t  ipa_tm_propagate_irr (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t\tnew_irr,\n \t\t\t\told_irr, NULL);\n-\t  ret = bitmap_bit_p (new_irr, single_succ (ENTRY_BLOCK_PTR)->index);\n+\t  ret = bitmap_bit_p (new_irr,\n+\t\t\t      single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun))->index);\n \t}\n     }\n   else\n@@ -5294,7 +5297,8 @@ ipa_tm_transform_clone (struct cgraph_node *node)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   need_ssa_rename =\n-    ipa_tm_transform_calls (d->clone, NULL, single_succ (ENTRY_BLOCK_PTR),\n+    ipa_tm_transform_calls (d->clone, NULL,\n+\t\t\t    single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t    d->irrevocable_blocks_clone);\n \n   if (need_ssa_rename)"}, {"sha": "b9fb7195bd2c795d8a81b9eda878684597724a5f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -190,14 +190,14 @@ init_empty_tree_cfg_for_function (struct function *fn)\n \t\t\t initial_cfg_capacity);\n \n   SET_BASIC_BLOCK_FOR_FUNCTION (fn, ENTRY_BLOCK,\n-\t\t\t\tENTRY_BLOCK_PTR_FOR_FUNCTION (fn));\n+\t\t\t\tENTRY_BLOCK_PTR_FOR_FN (fn));\n   SET_BASIC_BLOCK_FOR_FUNCTION (fn, EXIT_BLOCK,\n-\t\t   EXIT_BLOCK_PTR_FOR_FUNCTION (fn));\n+\t\t   EXIT_BLOCK_PTR_FOR_FN (fn));\n \n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (fn)->next_bb\n-    = EXIT_BLOCK_PTR_FOR_FUNCTION (fn);\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (fn)->prev_bb\n-    = ENTRY_BLOCK_PTR_FOR_FUNCTION (fn);\n+  ENTRY_BLOCK_PTR_FOR_FN (fn)->next_bb\n+    = EXIT_BLOCK_PTR_FOR_FN (fn);\n+  EXIT_BLOCK_PTR_FOR_FN (fn)->prev_bb\n+    = ENTRY_BLOCK_PTR_FOR_FN (fn);\n }\n \n void\n@@ -236,7 +236,7 @@ build_gimple_cfg (gimple_seq seq)\n \n   /* Make sure there is always at least one block, even if it's empty.  */\n   if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n-    create_empty_bb (ENTRY_BLOCK_PTR);\n+    create_empty_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   /* Adjust the size of the array.  */\n   if (basic_block_info->length () < (size_t) n_basic_blocks_for_fn (cfun))\n@@ -518,7 +518,7 @@ make_blocks (gimple_seq seq)\n   gimple stmt = NULL;\n   bool start_new_block = true;\n   bool first_stmt_of_seq = true;\n-  basic_block bb = ENTRY_BLOCK_PTR;\n+  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   while (!gsi_end_p (i))\n     {\n@@ -669,7 +669,8 @@ make_edges (void)\n \n   /* Create an edge from entry to the first block with executable\n      statements in it.  */\n-  make_edge (ENTRY_BLOCK_PTR, BASIC_BLOCK (NUM_FIXED_BLOCKS), EDGE_FALLTHRU);\n+  make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), BASIC_BLOCK (NUM_FIXED_BLOCKS),\n+\t     EDGE_FALLTHRU);\n \n   /* Traverse the basic block array placing edges.  */\n   FOR_EACH_BB (bb)\n@@ -687,7 +688,7 @@ make_edges (void)\n \t      fallthru = false;\n \t      break;\n \t    case GIMPLE_RETURN:\n-\t      make_edge (bb, EXIT_BLOCK_PTR, 0);\n+\t      make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \t      fallthru = false;\n \t      break;\n \t    case GIMPLE_COND:\n@@ -719,7 +720,8 @@ make_edges (void)\n \n \t      /* BUILTIN_RETURN is really a return statement.  */\n \t      if (gimple_call_builtin_p (last, BUILT_IN_RETURN))\n-\t\tmake_edge (bb, EXIT_BLOCK_PTR, 0), fallthru = false;\n+\t\tmake_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0), fallthru =\n+\t     false;\n \t      /* Some calls are known not to return.  */\n \t      else\n \t        fallthru = !(gimple_call_flags (last) & ECF_NORETURN);\n@@ -1503,7 +1505,7 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   if (!single_pred_p (b))\n     return false;\n \n-  if (b == EXIT_BLOCK_PTR)\n+  if (b == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return false;\n \n   /* If A ends by a statement causing exceptions or something similar, we\n@@ -4849,19 +4851,21 @@ gimple_verify_flow_info (void)\n   edge e;\n   edge_iterator ei;\n \n-  if (ENTRY_BLOCK_PTR->il.gimple.seq || ENTRY_BLOCK_PTR->il.gimple.phi_nodes)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->il.gimple.seq\n+      || ENTRY_BLOCK_PTR_FOR_FN (cfun)->il.gimple.phi_nodes)\n     {\n       error (\"ENTRY_BLOCK has IL associated with it\");\n       err = 1;\n     }\n \n-  if (EXIT_BLOCK_PTR->il.gimple.seq || EXIT_BLOCK_PTR->il.gimple.phi_nodes)\n+  if (EXIT_BLOCK_PTR_FOR_FN (cfun)->il.gimple.seq\n+      || EXIT_BLOCK_PTR_FOR_FN (cfun)->il.gimple.phi_nodes)\n     {\n       error (\"EXIT_BLOCK has IL associated with it\");\n       err = 1;\n     }\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     if (e->flags & EDGE_FALLTHRU)\n       {\n \terror (\"fallthru to exit from bb %d\", e->src->index);\n@@ -5041,7 +5045,7 @@ gimple_verify_flow_info (void)\n \t      error (\"wrong outgoing edge flags at end of bb %d\", bb->index);\n \t      err = 1;\n \t    }\n-\t  if (single_succ (bb) != EXIT_BLOCK_PTR)\n+\t  if (single_succ (bb) != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      error (\"return edge does not point to exit in bb %d\",\n \t\t     bb->index);\n@@ -5281,7 +5285,7 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->flags & EDGE_EH)\n     return redirect_eh_edge (e, dest);\n \n-  if (e->src != ENTRY_BLOCK_PTR)\n+  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     {\n       ret = gimple_try_redirect_by_replacing_jump (e, dest);\n       if (ret)\n@@ -5564,7 +5568,7 @@ gimple_duplicate_bb (basic_block bb)\n   gimple_seq phis = phi_nodes (bb);\n   gimple phi, stmt, copy;\n \n-  new_bb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n+  new_bb = create_empty_bb (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);\n \n   /* Copy the PHI nodes.  We ignore PHI node arguments here because\n      the incoming edges have not been setup yet.  */\n@@ -6901,9 +6905,9 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n      FIXME, this is silly.  The CFG ought to become a parameter to\n      these helpers.  */\n   push_cfun (dest_cfun);\n-  make_edge (ENTRY_BLOCK_PTR, entry_bb, EDGE_FALLTHRU);\n+  make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), entry_bb, EDGE_FALLTHRU);\n   if (exit_bb)\n-    make_edge (exit_bb,  EXIT_BLOCK_PTR, 0);\n+    make_edge (exit_bb,  EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n   pop_cfun ();\n \n   /* Back in the original function, the SESE region has disappeared,\n@@ -7247,7 +7251,7 @@ print_loops (FILE *file, int verbosity)\n {\n   basic_block bb;\n \n-  bb = ENTRY_BLOCK_PTR;\n+  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n   if (bb && bb->loop_father)\n     print_loop_and_siblings (file, bb->loop_father, 0, verbosity);\n }\n@@ -7416,7 +7420,8 @@ gimple_flow_call_edges_add (sbitmap blocks)\n   if (! blocks)\n     check_last_block = true;\n   else\n-    check_last_block = bitmap_bit_p (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n+    check_last_block = bitmap_bit_p (blocks,\n+\t\t\t\t     EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb->index);\n \n   /* In the last basic block, before epilogue generation, there will be\n      a fallthru edge to EXIT.  Special care is required if the last insn\n@@ -7432,7 +7437,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n      Handle this by adding a dummy instruction in a new last basic block.  */\n   if (check_last_block)\n     {\n-      basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n+      basic_block bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n       gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n       gimple t = NULL;\n \n@@ -7443,7 +7448,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n \t{\n \t  edge e;\n \n-\t  e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t  e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t  if (e)\n \t    {\n \t      gsi_insert_on_edge (e, gimple_build_nop ());\n@@ -7486,7 +7491,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n #ifdef ENABLE_CHECKING\n \t\t  if (stmt == last_stmt)\n \t\t    {\n-\t\t      e = find_edge (bb, EXIT_BLOCK_PTR);\n+\t\t      e = find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t\t      gcc_assert (e == NULL);\n \t\t    }\n #endif\n@@ -7499,7 +7504,7 @@ gimple_flow_call_edges_add (sbitmap blocks)\n \t\t      if (e)\n \t\t\tblocks_split++;\n \t\t    }\n-\t\t  make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+\t\t  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n \t\t}\n \t      gsi_prev (&gsi);\n \t    }\n@@ -7537,7 +7542,7 @@ remove_edge_and_dominated_blocks (edge e)\n     }\n \n   /* No updating is needed for edges to exit.  */\n-  if (e->dest == EXIT_BLOCK_PTR)\n+  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       if (cfgcleanup_altered_bbs)\n \tbitmap_set_bit (cfgcleanup_altered_bbs, e->src->index);\n@@ -7577,7 +7582,7 @@ remove_edge_and_dominated_blocks (edge e)\n \t{\n \t  FOR_EACH_EDGE (f, ei, bb->succs)\n \t    {\n-\t      if (f->dest != EXIT_BLOCK_PTR)\n+\t      if (f->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\tbitmap_set_bit (df, f->dest->index);\n \t    }\n \t}\n@@ -7928,8 +7933,8 @@ split_critical_edges (void)\n \t     gimple_find_edge_insert_loc.  */\n \t  else if ((!single_pred_p (e->dest)\n \t            || !gimple_seq_empty_p (phi_nodes (e->dest))\n-\t            || e->dest == EXIT_BLOCK_PTR)\n-\t\t   && e->src != ENTRY_BLOCK_PTR\n+\t\t    || e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\t   && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t           && !(e->flags & EDGE_ABNORMAL))\n \t    {\n \t      gimple_stmt_iterator gsi;\n@@ -8053,10 +8058,10 @@ execute_warn_function_return (void)\n \n   /* If we have a path to EXIT, then we do return.  */\n   if (TREE_THIS_VOLATILE (cfun->decl)\n-      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0)\n+      && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) > 0)\n     {\n       location = UNKNOWN_LOCATION;\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \t{\n \t  last = last_stmt (e->src);\n \t  if ((gimple_code (last) == GIMPLE_RETURN\n@@ -8073,10 +8078,10 @@ execute_warn_function_return (void)\n      without returning a value.  */\n   else if (warn_return_type\n \t   && !TREE_NO_WARNING (cfun->decl)\n-\t   && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0\n+\t   && EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) > 0\n \t   && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (cfun->decl))))\n     {\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \t{\n \t  gimple last = last_stmt (e->src);\n \t  if (gimple_code (last) == GIMPLE_RETURN\n@@ -8293,13 +8298,15 @@ execute_fixup_cfg (void)\n \n   count_scale\n       = GCOV_COMPUTE_SCALE (cgraph_get_node (current_function_decl)->count,\n-                            ENTRY_BLOCK_PTR->count);\n+\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n \n-  ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;\n-  EXIT_BLOCK_PTR->count = apply_scale (EXIT_BLOCK_PTR->count,\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n+\t\t\t    cgraph_get_node (current_function_decl)->count;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n+\t\t\t    apply_scale (EXIT_BLOCK_PTR_FOR_FN (cfun)->count,\n                                        count_scale);\n \n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     e->count = apply_scale (e->count, count_scale);\n \n   FOR_EACH_BB (bb)"}, {"sha": "4e5adc28a06aadb36c0b1e54941ae63e1597e46e", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -251,14 +251,14 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n \t Otherwise, BB must have PHI nodes.  */\n       || gimple_seq_empty_p (phi_nodes (bb)) == phi_wanted\n       /* BB may not be a predecessor of EXIT_BLOCK_PTR.  */\n-      || single_succ (bb) == EXIT_BLOCK_PTR\n+      || single_succ (bb) == EXIT_BLOCK_PTR_FOR_FN (cfun)\n       /* Nor should this be an infinite loop.  */\n       || single_succ (bb) == bb\n       /* BB may not have an abnormal outgoing edge.  */\n       || (single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n     return false;\n \n-  gcc_checking_assert (bb != ENTRY_BLOCK_PTR);\n+  gcc_checking_assert (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   locus = single_succ_edge (bb)->goto_locus;\n \n@@ -268,7 +268,7 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n     edge e;\n \n     FOR_EACH_EDGE (e, ei, bb->preds)\n-      if (e->src == ENTRY_BLOCK_PTR || (e->flags & EDGE_EH))\n+      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun) || (e->flags & EDGE_EH))\n \treturn false;\n       /* If goto_locus of any of the edges differs, prevent removing\n \t the forwarder block for -O0.  */"}, {"sha": "7bc3458165f4ce634b45501867c3b869159ea9ad", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -690,7 +690,7 @@ update_complex_assignment (gimple_stmt_iterator *gsi, tree r, tree i)\n static void\n update_parameter_components (void)\n {\n-  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n+  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   tree parm;\n \n   for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = DECL_CHAIN (parm))"}, {"sha": "907b403e43c147d77bf61518cb3eeaba391cfcfa", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -918,7 +918,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   unsigned int visited_count = 0;\n \n   gcc_assert (loop->num_nodes);\n-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   blocks = XCNEWVEC (basic_block, loop->num_nodes);\n   visited = BITMAP_ALLOC (NULL);"}, {"sha": "25705a9d0fb78b0364ed846e2ca8e3d2814fdff9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -199,7 +199,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n       if (SSA_NAME_IS_DEFAULT_DEF (name)\n \t  && TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL\n \t  && id->entry_bb == NULL\n-\t  && single_succ_p (ENTRY_BLOCK_PTR))\n+\t  && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n \t{\n \t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n \t  gimple def_temp;\n@@ -218,7 +218,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  DECL_ARTIFICIAL (vexpr) = 1;\n \t  TREE_TYPE (vexpr) = TREE_TYPE (name);\n \t  DECL_MODE (vexpr) = DECL_MODE (SSA_NAME_VAR (name));\n-\t  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\t  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n \t  return vexpr;\n \t}\n@@ -300,7 +300,8 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name)\n \t      && (!SSA_NAME_VAR (name)\n \t\t  || TREE_CODE (SSA_NAME_VAR (name)) != PARM_DECL)\n-\t      && (id->entry_bb != EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n+\t      && (id->entry_bb != EDGE_SUCC (ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t\t\t     0)->dest\n \t\t  || EDGE_COUNT (id->entry_bb->preds) != 1))\n \t    {\n \t      gimple_stmt_iterator gsi = gsi_last_bb (id->entry_bb);\n@@ -1978,7 +1979,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \n \t/* Return edges do get a FALLTHRU flag when the get inlined.  */\n \tif (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n-\t    && old_edge->dest->aux != EXIT_BLOCK_PTR)\n+\t    && old_edge->dest->aux != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n \tnew_edge->count = apply_scale (old_edge->count, count_scale);\n@@ -2163,10 +2164,10 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   if (!DECL_RESULT (new_fndecl))\n     DECL_RESULT (new_fndecl) = DECL_RESULT (callee_fndecl);\n \n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count)\n     count_scale\n         = GCOV_COMPUTE_SCALE (count,\n-                              ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n+                              ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n   else\n     count_scale = REG_BR_PROB_BASE;\n \n@@ -2202,16 +2203,16 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   init_empty_tree_cfg ();\n \n   profile_status_for_function (cfun) = profile_status_for_function (src_cfun);\n-  ENTRY_BLOCK_PTR->count =\n-    (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n+    (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count * count_scale /\n      REG_BR_PROB_BASE);\n-  ENTRY_BLOCK_PTR->frequency\n-    = ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency;\n-  EXIT_BLOCK_PTR->count =\n-    (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency\n+    = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->frequency;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n+    (EXIT_BLOCK_PTR_FOR_FN (src_cfun)->count * count_scale /\n      REG_BR_PROB_BASE);\n-  EXIT_BLOCK_PTR->frequency =\n-    EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency =\n+    EXIT_BLOCK_PTR_FOR_FN (src_cfun)->frequency;\n   if (src_cfun->eh)\n     init_eh_for_function ();\n \n@@ -2410,7 +2411,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n      before inlining, using the guessed edge frequencies, so that we don't\n      end up with a 0-count inline body which can confuse downstream\n      optimizations such as function splitting.  */\n-  if (!ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count && count)\n+  if (!ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count && count)\n     {\n       /* Apply the larger of the call bb count and the total incoming\n          call edge count to the callee.  */\n@@ -2422,10 +2423,10 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n       freqs_to_counts (id->src_node, count > in_count ? count : in_count);\n     }\n \n-  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n+  if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count)\n     count_scale\n         = GCOV_COMPUTE_SCALE (count,\n-                              ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n+                              ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n   else\n     count_scale = REG_BR_PROB_BASE;\n \n@@ -2450,20 +2451,20 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n       incoming_count = apply_scale (incoming_count, count_scale);\n       incoming_frequency\n \t= apply_scale ((gcov_type)incoming_frequency, frequency_scale);\n-      ENTRY_BLOCK_PTR->count = incoming_count;\n-      ENTRY_BLOCK_PTR->frequency = incoming_frequency;\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = incoming_count;\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency = incoming_frequency;\n     }\n \n   /* Must have a CFG here at this point.  */\n-  gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION\n+  gcc_assert (ENTRY_BLOCK_PTR_FOR_FN\n \t      (DECL_STRUCT_FUNCTION (callee_fndecl)));\n \n   cfun_to_copy = id->src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n \n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = entry_block_map;\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = exit_block_map;\n-  entry_block_map->aux = ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy);\n-  exit_block_map->aux = EXIT_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy);\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun_to_copy)->aux = entry_block_map;\n+  EXIT_BLOCK_PTR_FOR_FN (cfun_to_copy)->aux = exit_block_map;\n+  entry_block_map->aux = ENTRY_BLOCK_PTR_FOR_FN (cfun_to_copy);\n+  exit_block_map->aux = EXIT_BLOCK_PTR_FOR_FN (cfun_to_copy);\n \n   /* Duplicate any exception-handling regions.  */\n   if (cfun->eh)\n@@ -2694,7 +2695,7 @@ copy_body (copy_body_data *id, gcov_type count, int frequency_scale,\n   tree body;\n \n   /* If this body has a CFG, walk CFG and copy.  */\n-  gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fndecl)));\n+  gcc_assert (ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (fndecl)));\n   body = copy_cfg_body (id, count, frequency_scale, entry_block_map, exit_block_map,\n \t\t\tnew_entry);\n   copy_debug_stmts (id);\n@@ -5098,7 +5099,8 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \n   /* Delete all unreachable basic blocks.  */\n \n-  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n+  for (b = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; b\n+       != EXIT_BLOCK_PTR_FOR_FN (cfun); b = next_bb)\n     {\n       next_bb = b->next_bb;\n \n@@ -5294,7 +5296,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   id.transform_parameter = false;\n   id.transform_lang_insert_block = NULL;\n \n-  old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n+  old_entry_block = ENTRY_BLOCK_PTR_FOR_FN\n     (DECL_STRUCT_FUNCTION (old_decl));\n   DECL_RESULT (new_decl) = DECL_RESULT (old_decl);\n   DECL_ARGUMENTS (new_decl) = DECL_ARGUMENTS (old_decl);\n@@ -5413,15 +5415,16 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   /* Copy the Function's body.  */\n   copy_body (&id, old_entry_block->count, REG_BR_PROB_BASE,\n-\t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, new_entry);\n+\t     ENTRY_BLOCK_PTR_FOR_FN (cfun), EXIT_BLOCK_PTR_FOR_FN (cfun),\n+\t     new_entry);\n \n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (new_decl);\n \n   /* We want to create the BB unconditionally, so that the addition of\n      debug stmts doesn't affect BB count, which may in the end cause\n      codegen differences.  */\n-  bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+  bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n   while (init_stmts.length ())\n     insert_init_stmt (&id, bb, init_stmts.pop ());\n   update_clone_info (&id);\n@@ -5458,7 +5461,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n       struct cgraph_edge *e;\n       rebuild_frequencies ();\n \n-      new_version_node->count = ENTRY_BLOCK_PTR->count;\n+      new_version_node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n       for (e = new_version_node->callees; e; e = e->next_callee)\n \t{\n \t  basic_block bb = gimple_bb (e->call_stmt);"}, {"sha": "6cae27e34b7f40ffb13845a134c4cf8b0f60063f", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1221,10 +1221,12 @@ rewrite_debug_stmt_uses (gimple stmt)\n       def = info->current_def;\n       if (!def)\n \t{\n-\t  if (TREE_CODE (var) == PARM_DECL && single_succ_p (ENTRY_BLOCK_PTR))\n+\t  if (TREE_CODE (var) == PARM_DECL\n+\t      && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n \t    {\n \t      gimple_stmt_iterator gsi\n-\t\t= gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\t\t=\n+\t     gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t      int lim;\n \t      /* Search a few source bind stmts at the start of first bb to\n \t\t see if a DEBUG_EXPR_DECL can't be reused.  */\n@@ -1253,7 +1255,8 @@ rewrite_debug_stmt_uses (gimple stmt)\n \t\t  DECL_ARTIFICIAL (def) = 1;\n \t\t  TREE_TYPE (def) = TREE_TYPE (var);\n \t\t  DECL_MODE (def) = DECL_MODE (var);\n-\t\t  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\t\t  gsi =\n+\t\t gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t\t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n \t\t}\n \t      update = true;\n@@ -1868,7 +1871,7 @@ maybe_register_def (def_operand_p def_p, gimple stmt,\n \t\t     bind stmts, but there wouldn't be a PC to bind\n \t\t     them to either, so avoid diverging the CFG.  */\n \t\t  if (ef && single_pred_p (ef->dest)\n-\t\t      && ef->dest != EXIT_BLOCK_PTR)\n+\t\t      && ef->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t    {\n \t\t      /* If there were PHI nodes in the node, we'd\n \t\t\t have to make sure the value we're binding\n@@ -2331,7 +2334,7 @@ rewrite_into_ssa (void)\n   insert_phi_nodes (dfs);\n \n   /* 4- Rename all the blocks.  */\n-  rewrite_blocks (ENTRY_BLOCK_PTR, REWRITE_ALL);\n+  rewrite_blocks (ENTRY_BLOCK_PTR_FOR_FN (cfun), REWRITE_ALL);\n \n   /* Free allocated memory.  */\n   FOR_EACH_BB (bb)\n@@ -3017,7 +3020,7 @@ insert_updated_phi_nodes_for (tree var, bitmap_head *dfs, bitmap blocks,\n \t     common dominator of all the definition blocks.  */\n \t  entry = nearest_common_dominator_for_set (CDI_DOMINATORS,\n \t\t\t\t\t\t    db->def_blocks);\n-\t  if (entry != ENTRY_BLOCK_PTR)\n+\t  if (entry != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    EXECUTE_IF_SET_IN_BITMAP (idf, 0, i, bi)\n \t      if (BASIC_BLOCK (i) != entry\n \t\t  && dominated_by_p (CDI_DOMINATORS, BASIC_BLOCK (i), entry))\n@@ -3216,7 +3219,7 @@ update_ssa (unsigned update_flags)\n \t be possible to determine the nearest block that had a\n \t definition for each of the symbols that are marked for\n \t updating.  For now this seems more work than it's worth.  */\n-      start_bb = ENTRY_BLOCK_PTR;\n+      start_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n       /* Traverse the CFG looking for existing definitions and uses of\n \t symbols in SSA operands.  Mark interesting blocks and\n@@ -3299,7 +3302,7 @@ update_ssa (unsigned update_flags)\n       /* Insertion of PHI nodes may have added blocks to the region.\n \t We need to re-compute START_BB to include the newly added\n \t blocks.  */\n-      if (start_bb != ENTRY_BLOCK_PTR)\n+      if (start_bb != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tstart_bb = nearest_common_dominator_for_set (CDI_DOMINATORS,\n \t\t\t\t\t\t     blocks_to_update);\n     }"}, {"sha": "9a7a73f407994d713f15c71b690350a970ba45b6", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -931,7 +931,8 @@ expand_phi_nodes (struct ssaexpand *sa)\n   elim_graph g = new_elim_graph (sa->map->num_partitions);\n   g->map = sa->map;\n \n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb,\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     if (!gimple_seq_empty_p (phi_nodes (bb)))\n       {\n \tedge e;"}, {"sha": "0adc51a51aa960bd74b684a3f0255c943db02b42", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -440,7 +440,8 @@ gimple_gen_ic_func_profiler (void)\n     stmt1: __gcov_indirect_call_profiler_v2 (profile_id,\n \t\t\t\t\t     &current_function_decl)\n    */\n-  gsi = gsi_after_labels (split_edge (single_succ_edge (ENTRY_BLOCK_PTR)));\n+  gsi =\n+\t\t\t\t\t     gsi_after_labels (split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun))));\n \n   cur_func = force_gimple_operand_gsi (&gsi,\n \t\t\t\t       build_addr (current_function_decl,"}, {"sha": "8846fbe50cca77d7903576a081cb957742d38b39", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -47,7 +47,7 @@ static inline basic_block\n block_before_loop (loop_p loop)\n {\n   edge preheader = loop_preheader_edge (loop);\n-  return (preheader ? preheader->src : ENTRY_BLOCK_PTR);\n+  return (preheader ? preheader->src : ENTRY_BLOCK_PTR_FOR_FN (cfun));\n }\n \n /* Analyze all the parameters of the chrec that were left under a"}, {"sha": "5432048854eee4db1a054aaf14731475b15d80d3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -3409,7 +3409,7 @@ initialize_parameter_reductions (void)\n \n   seq = gsi_seq (gsi);\n   if (seq)\n-    gsi_insert_seq_on_edge_immediate (single_succ_edge (ENTRY_BLOCK_PTR), seq);\n+    gsi_insert_seq_on_edge_immediate (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);\n }\n \n /* The \"main\" function of intraprocedural SRA passes.  Runs the analysis and if\n@@ -3788,7 +3788,7 @@ propagate_dereference_distances (void)\n   basic_block bb;\n \n   queue.create (last_basic_block_for_function (cfun));\n-  queue.quick_push (ENTRY_BLOCK_PTR);\n+  queue.quick_push (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   FOR_EACH_BB (bb)\n     {\n       queue.quick_push (bb);\n@@ -3818,7 +3818,7 @@ propagate_dereference_distances (void)\n \t  {\n \t    int succ_idx = e->dest->index * func_param_count + i;\n \n-\t    if (e->src == EXIT_BLOCK_PTR)\n+\t    if (e->src == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t      continue;\n \n \t    if (first)\n@@ -3859,10 +3859,11 @@ dump_dereferences_table (FILE *f, const char *str, HOST_WIDE_INT *table)\n   basic_block bb;\n \n   fprintf (dump_file, str);\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t  EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n     {\n       fprintf (f, \"%4i  %i   \", bb->index, bitmap_bit_p (final_bbs, bb->index));\n-      if (bb != EXIT_BLOCK_PTR)\n+      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t{\n \t  int i;\n \t  for (i = 0; i < func_param_count; i++)\n@@ -3914,7 +3915,7 @@ analyze_caller_dereference_legality (vec<access_p> representatives)\n   for (i = 0; i < func_param_count; i++)\n     {\n       struct access *repr = representatives[i];\n-      int idx = ENTRY_BLOCK_PTR->index * func_param_count + i;\n+      int idx = ENTRY_BLOCK_PTR_FOR_FN (cfun)->index * func_param_count + i;\n \n       if (!repr || no_accesses_p (repr))\n \tcontinue;\n@@ -4728,9 +4729,9 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n   int i, len;\n   gimple_stmt_iterator *gsip = NULL, gsi;\n \n-  if (MAY_HAVE_DEBUG_STMTS && single_succ_p (ENTRY_BLOCK_PTR))\n+  if (MAY_HAVE_DEBUG_STMTS && single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n     {\n-      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n       gsip = &gsi;\n     }\n   len = adjustments.length ();"}, {"sha": "3a9875de2e85b1328da79a993661e5ebe5919940", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1824,7 +1824,7 @@ gsi_prev_dom_bb_nondebug (gimple_stmt_iterator *i)\n   while (gsi_end_p (*i))\n     {\n       dom = get_immediate_dominator (CDI_DOMINATORS, i->bb);\n-      if (dom == NULL || dom == ENTRY_BLOCK_PTR)\n+      if (dom == NULL || dom == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \treturn;\n \n       *i = gsi_last_bb (dom);\n@@ -2314,7 +2314,7 @@ optimize_stack_restore (gimple_stmt_iterator i)\n     case 0:\n       break;\n     case 1:\n-      if (single_succ_edge (bb)->dest != EXIT_BLOCK_PTR)\n+      if (single_succ_edge (bb)->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \treturn NULL_TREE;\n       break;\n     default:"}, {"sha": "d6fbb1cc27f2f4b451315820f2ef1a987427a76f", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1078,7 +1078,7 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\t  v2 = SSA_NAME_VERSION (var);\n \t\t  bitmap_set_bit (used_in_copy, v1);\n \t\t  bitmap_set_bit (used_in_copy, v2);\n-\t\t  cost = coalesce_cost_bb (EXIT_BLOCK_PTR);\n+\t\t  cost = coalesce_cost_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n \t\t  add_coalesce (cl, v1, v2, cost);\n \t\t}\n \t    }"}, {"sha": "0c8110fb71a4628175006b54ad7d926ddc642dc1", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -328,9 +328,9 @@ mark_control_dependent_edges_necessary (basic_block bb, bool ignore_self)\n   unsigned edge_number;\n   bool skipped = false;\n \n-  gcc_assert (bb != EXIT_BLOCK_PTR);\n+  gcc_assert (bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n-  if (bb == ENTRY_BLOCK_PTR)\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n     return;\n \n   EXECUTE_IF_SET_IN_BITMAP (cd->get_edges_dependent_on (bb->index),\n@@ -636,7 +636,7 @@ propagate_necessity (bool aggressive)\n \t     containing STMT is control dependent, but only if we haven't\n \t     already done so.  */\n \t  basic_block bb = gimple_bb (stmt);\n-\t  if (bb != ENTRY_BLOCK_PTR\n+\t  if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t      && !bitmap_bit_p (visited_control_parents, bb->index))\n \t    mark_control_dependent_edges_necessary (bb, false);\n \t}\n@@ -742,7 +742,7 @@ propagate_necessity (bool aggressive)\n \t\t      if (!bitmap_bit_p (last_stmt_necessary, arg_bb->index))\n \t\t\tmark_last_stmt_necessary (arg_bb);\n \t\t    }\n-\t\t  else if (arg_bb != ENTRY_BLOCK_PTR\n+\t\t  else if (arg_bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n \t\t           && !bitmap_bit_p (visited_control_parents,\n \t\t\t\t\t arg_bb->index))\n \t\t    mark_control_dependent_edges_necessary (arg_bb, true);\n@@ -1076,7 +1076,7 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n \t fake edges in the dominator tree.  */\n       if (e)\n         ;\n-      else if (! post_dom_bb || post_dom_bb == EXIT_BLOCK_PTR)\n+      else if (! post_dom_bb || post_dom_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \te = EDGE_SUCC (bb, 0);\n       else\n         e = forward_edge_to_pdom (EDGE_SUCC (bb, 0), post_dom_bb);\n@@ -1168,7 +1168,8 @@ eliminate_unnecessary_stmts (void)\n \n      as desired.  */\n   gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n-  h = get_all_dominated_blocks (CDI_DOMINATORS, single_succ (ENTRY_BLOCK_PTR));\n+  h = get_all_dominated_blocks (CDI_DOMINATORS,\n+\t\t\t\tsingle_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \n   while (h.length ())\n     {\n@@ -1265,7 +1266,8 @@ eliminate_unnecessary_stmts (void)\n       find_unreachable_blocks ();\n \n       /* Delete all unreachable basic blocks in reverse dominator order.  */\n-      for (bb = EXIT_BLOCK_PTR->prev_bb; bb != ENTRY_BLOCK_PTR; bb = prev_bb)\n+      for (bb = EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb;\n+\t   bb != ENTRY_BLOCK_PTR_FOR_FN (cfun); bb = prev_bb)\n \t{\n \t  prev_bb = bb->prev_bb;\n "}, {"sha": "a286c105615977e44c5da1d71316044487548db1", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -902,7 +902,7 @@ tree_ssa_dominator_optimize (void)\n \t  while (single_succ_p (bb)\n \t\t && (single_succ_edge (bb)->flags & EDGE_EH) == 0)\n \t    bb = single_succ (bb);\n-\t  if (bb == EXIT_BLOCK_PTR)\n+\t  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    continue;\n \t  if ((unsigned) bb->index != i)\n \t    bitmap_set_bit (need_eh_cleanup, bb->index);\n@@ -3054,7 +3054,8 @@ eliminate_degenerate_phis (void)\n      phase in dominator order.  Presumably this is because walking\n      in dominator order leaves fewer PHIs for later examination\n      by the worklist phase.  */\n-  eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR, interesting_names);\n+  eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (cfun),\n+\t\t\t       interesting_names);\n \n   /* Second phase.  Eliminate second order degenerate PHIs as well\n      as trivial copies or constant initializations identified by"}, {"sha": "51b41017c2f1a09d9329387cf02900f0f22ee2a9", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1009,7 +1009,7 @@ loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       pred_bb = e->src;\n-      if (pred_bb == ENTRY_BLOCK_PTR)\n+      if (pred_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \tcontinue;\n       /* TMP is variables live-on-entry from BB that aren't defined in the\n \t predecessor block.  This should be the live on entry vars to pred.\n@@ -1087,7 +1087,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n \tbitmap_set_bit (&live->liveout[def_bb->index], p);\n     }\n   else\n-    def_bb = ENTRY_BLOCK_PTR;\n+    def_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n   /* Visit each use of SSA_NAME and if it isn't in the same block as the def,\n      add it to the list of live on entry blocks.  */\n@@ -1103,7 +1103,7 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n \t     defined in that block, or whether its live on entry.  */\n \t  int index = PHI_ARG_INDEX_FROM_USE (use);\n \t  edge e = gimple_phi_arg_edge (use_stmt, index);\n-\t  if (e->src != ENTRY_BLOCK_PTR)\n+\t  if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      if (e->src != def_bb)\n \t\tadd_block = e->src;\n@@ -1169,14 +1169,14 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n \t      if (p == NO_PARTITION)\n \t\tcontinue;\n \t      e = gimple_phi_arg_edge (phi, i);\n-\t      if (e->src != ENTRY_BLOCK_PTR)\n+\t      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t\tbitmap_set_bit (&liveinfo->liveout[e->src->index], p);\n \t    }\n \t}\n \n       /* Add each successors live on entry to this bock live on exit.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-        if (e->dest != EXIT_BLOCK_PTR)\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  bitmap_ior_into (&liveinfo->liveout[bb->index],\n \t\t\t   live_on_entry (liveinfo, e->dest));\n     }\n@@ -1369,12 +1369,12 @@ verify_live_on_entry (tree_live_info_p live)\n    /* Check for live on entry partitions and report those with a DEF in\n       the program. This will typically mean an optimization has done\n       something wrong.  */\n-  bb = ENTRY_BLOCK_PTR;\n+  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n   num = 0;\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       int entry_block = e->dest->index;\n-      if (e->dest == EXIT_BLOCK_PTR)\n+      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n         continue;\n       for (i = 0; i < (unsigned)num_var_partitions (map); i++)\n \t{"}, {"sha": "e8074bd425e2f13d5033b60d1e7540f6cca79b1b", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -273,8 +273,8 @@ static inline bitmap\n live_on_entry (tree_live_info_p live, basic_block bb)\n {\n   gcc_checking_assert (live->livein\n-\t\t       && bb != ENTRY_BLOCK_PTR\n-\t\t       && bb != EXIT_BLOCK_PTR);\n+\t\t       && bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t\t       && bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   return &live->livein[bb->index];\n }\n@@ -287,8 +287,8 @@ static inline bitmap\n live_on_exit (tree_live_info_p live, basic_block bb)\n {\n   gcc_checking_assert (live->liveout\n-\t\t       && bb != ENTRY_BLOCK_PTR\n-\t\t       && bb != EXIT_BLOCK_PTR);\n+\t\t       && bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t\t       && bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n   return &live->liveout[bb->index];\n }"}, {"sha": "6d7d78ea6e458a34b2dceb44fda9571c4aa9fcb2", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -2007,7 +2007,7 @@ find_interesting_uses (struct ivopts_data *data)\n       bb = body[i];\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t    && !flow_bb_inside_loop_p (data->current_loop, e->dest))\n \t  find_interesting_uses_outside (data, e);\n "}, {"sha": "67291670418b72517930999d76250b7114b28d9f", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -231,7 +231,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n \t  bool pred_visited;\n \n \t  /* We should have met DEF_BB along the way.  */\n-\t  gcc_assert (pred != ENTRY_BLOCK_PTR);\n+\t  gcc_assert (pred != ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n \t  if (pred_loop_depth >= def_loop_depth)\n \t    {"}, {"sha": "9c61c3c97a4a743942b6f1de139fb2a89d93729c", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -496,7 +496,7 @@ bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n   /* Now walk the dominators of the loop header and use the entry\n      guards to refine the estimates.  */\n   for (bb = loop->header;\n-       bb != ENTRY_BLOCK_PTR && cnt < MAX_DOMINATORS_TO_WALK;\n+       bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) && cnt < MAX_DOMINATORS_TO_WALK;\n        bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n       if (!single_pred_p (bb))\n@@ -1781,7 +1781,7 @@ simplify_using_initial_conditions (struct loop *loop, tree expr)\n      the number of BBs times the number of loops in degenerate\n      cases.  */\n   for (bb = loop->header;\n-       bb != ENTRY_BLOCK_PTR && cnt < MAX_DOMINATORS_TO_WALK;\n+       bb != ENTRY_BLOCK_PTR_FOR_FN (cfun) && cnt < MAX_DOMINATORS_TO_WALK;\n        bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n       if (!single_pred_p (bb))"}, {"sha": "f2b4e95f8738d6eeaee355b2f40c73302aa710b1", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1282,7 +1282,7 @@ may_use_storent_in_loop_p (struct loop *loop)\n \n       FOR_EACH_VEC_ELT (exits, i, exit)\n \tif ((exit->flags & EDGE_ABNORMAL)\n-\t    && exit->dest == EXIT_BLOCK_PTR)\n+\t    && exit->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  ret = false;\n \n       exits.release ();"}, {"sha": "27f52b28025f19f4b0934da4901132efb6423355", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -194,7 +194,7 @@ simplify_using_entry_checks (struct loop *loop, tree cond)\n \treturn cond;\n \n       e = single_pred_edge (e->src);\n-      if (e->src == ENTRY_BLOCK_PTR)\n+      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \treturn cond;\n     }\n }"}, {"sha": "ce7116ee4fcd481879794d954b1d22654e7b0b68", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -288,7 +288,7 @@ register_division_in (basic_block bb)\n   if (!occ)\n     {\n       occ = occ_new (bb, NULL);\n-      insert_bb (occ, ENTRY_BLOCK_PTR, &occ_head);\n+      insert_bb (occ, ENTRY_BLOCK_PTR_FOR_FN (cfun), &occ_head);\n     }\n \n   occ->bb_has_division = true;"}, {"sha": "389423b04c45ac5336a92337188b1804a9b0dce9", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -381,7 +381,7 @@ tree_ssa_phiprop (void)\n \n   /* Walk the dominator tree in preorder.  */\n   bbs = get_all_dominated_blocks (CDI_DOMINATORS,\n-\t\t\t\t  single_succ (ENTRY_BLOCK_PTR));\n+\t\t\t\t  single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       did_something |= propagate_with_phi (bb, gsi_stmt (gsi), phivn, n);"}, {"sha": "29d56b1c660330f7942722dd3e7ef0abdc69eaad", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -2467,7 +2467,7 @@ compute_antic (void)\n     }\n \n   /* At the exit block we anticipate nothing.  */\n-  BB_VISITED (EXIT_BLOCK_PTR) = 1;\n+  BB_VISITED (EXIT_BLOCK_PTR_FOR_FN (cfun)) = 1;\n \n   changed_blocks = sbitmap_alloc (last_basic_block + 1);\n   bitmap_ones (changed_blocks);\n@@ -3668,7 +3668,7 @@ insert (void)\n       num_iterations++;\n       if (dump_file && dump_flags & TDF_DETAILS)\n \tfprintf (dump_file, \"Starting insert iteration %d\\n\", num_iterations);\n-      new_stuff = insert_aux (ENTRY_BLOCK_PTR);\n+      new_stuff = insert_aux (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n       /* Clear the NEW sets before the next iteration.  We have already\n          fully propagated its contents.  */\n@@ -3713,15 +3713,16 @@ compute_avail (void)\n \n       e = get_or_alloc_expr_for_name (name);\n       add_to_value (get_expr_value_id (e), e);\n-      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), e);\n-      bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), e);\n+      bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR_FOR_FN (cfun)), e);\n+      bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t\t    e);\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      print_bitmap_set (dump_file, TMP_GEN (ENTRY_BLOCK_PTR),\n+      print_bitmap_set (dump_file, TMP_GEN (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t\"tmp_gen\", ENTRY_BLOCK);\n-      print_bitmap_set (dump_file, AVAIL_OUT (ENTRY_BLOCK_PTR),\n+      print_bitmap_set (dump_file, AVAIL_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t\"avail_out\", ENTRY_BLOCK);\n     }\n \n@@ -3730,7 +3731,7 @@ compute_avail (void)\n \n   /* Seed the algorithm by putting the dominator children of the entry\n      block on the worklist.  */\n-  for (son = first_dom_son (CDI_DOMINATORS, ENTRY_BLOCK_PTR);\n+  for (son = first_dom_son (CDI_DOMINATORS, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n     worklist[sp++] = son;"}, {"sha": "b9db34c5057369ad11a37580399b9a273bfd3d89", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -184,7 +184,8 @@ cfg_blocks_add (basic_block bb)\n {\n   bool head = false;\n \n-  gcc_assert (bb != ENTRY_BLOCK_PTR && bb != EXIT_BLOCK_PTR);\n+  gcc_assert (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t      && bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n   gcc_assert (!bitmap_bit_p (bb_in_list, bb->index));\n \n   if (cfg_blocks_empty_p ())\n@@ -279,7 +280,7 @@ static void\n add_control_edge (edge e)\n {\n   basic_block bb = e->dest;\n-  if (bb == EXIT_BLOCK_PTR)\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return;\n \n   /* If the edge had already been executed, skip it.  */\n@@ -408,7 +409,7 @@ simulate_block (basic_block block)\n   gimple_stmt_iterator gsi;\n \n   /* There is nothing to do for the exit block.  */\n-  if (block == EXIT_BLOCK_PTR)\n+  if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -519,7 +520,7 @@ ssa_prop_init (void)\n \n   /* Seed the algorithm by adding the successors of the entry block to the\n      edge worklist.  */\n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     add_control_edge (e);\n }\n "}, {"sha": "4c4924c721c26c79a204b9c009b8adbb928ac400", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1270,11 +1270,11 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n   if ((!op1def || gimple_nop_p (op1def))\n       && (!op2def || gimple_nop_p (op2def)))\n     {\n-      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n       if (gsi_end_p (gsi))\n \t{\n \t  gimple_stmt_iterator gsi2\n-\t    = gsi_last_bb (single_succ (ENTRY_BLOCK_PTR));\n+\t    = gsi_last_bb (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \t  gimple_set_uid (sum,\n \t\t\t  gsi_end_p (gsi2) ? 1 : gimple_uid (gsi_stmt (gsi2)));\n \t}\n@@ -4529,8 +4529,8 @@ debug_ops_vector (vec<operand_entry_t> ops)\n static void\n do_reassoc (void)\n {\n-  break_up_subtract_bb (ENTRY_BLOCK_PTR);\n-  reassociate_bb (EXIT_BLOCK_PTR);\n+  break_up_subtract_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  reassociate_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n }\n \n /* Initialize the reassociation pass.  */"}, {"sha": "305882dd06fd473f50cdb59bae86025b80ce712d", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -170,7 +170,7 @@ nearest_common_dominator_of_uses (gimple stmt, bool *debug_stmts)\n \t    }\n \n \t  /* Short circuit. Nothing dominates the entry block.  */\n-\t  if (useblock == ENTRY_BLOCK_PTR)\n+\t  if (useblock == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n \t    {\n \t      BITMAP_FREE (blocks);\n \t      return NULL;\n@@ -568,7 +568,7 @@ execute_sink_code (void)\n   memset (&sink_stats, 0, sizeof (sink_stats));\n   calculate_dominance_info (CDI_DOMINATORS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n-  sink_code_in_bb (EXIT_BLOCK_PTR);\n+  sink_code_in_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n   statistics_counter_event (cfun, \"Sunk statements\", sink_stats.sunk);\n   free_dominance_info (CDI_POST_DOMINATORS);\n   remove_fake_exit_edges ();"}, {"sha": "3b8d1df9c8514daf6b8b78daaafd5f2405f38d61", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -175,7 +175,7 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n   FOR_EACH_BB (bb)\n     {\n       bool always_executed = dominated_by_p (CDI_POST_DOMINATORS,\n-\t\t\t\t\t     single_succ (ENTRY_BLOCK_PTR), bb);\n+\t\t\t\t\t     single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)), bb);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n@@ -315,14 +315,14 @@ compute_uninit_opnds_pos (gimple phi)\n static inline basic_block\n find_pdom (basic_block block)\n {\n-   if (block == EXIT_BLOCK_PTR)\n-     return EXIT_BLOCK_PTR;\n+   if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+     return EXIT_BLOCK_PTR_FOR_FN (cfun);\n    else\n      {\n        basic_block bb\n            = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n        if (! bb)\n-         return EXIT_BLOCK_PTR;\n+\t return EXIT_BLOCK_PTR_FOR_FN (cfun);\n        return bb;\n      }\n }\n@@ -333,13 +333,13 @@ find_pdom (basic_block block)\n static inline basic_block\n find_dom (basic_block block)\n {\n-   if (block == ENTRY_BLOCK_PTR)\n-     return ENTRY_BLOCK_PTR;\n+   if (block == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+     return ENTRY_BLOCK_PTR_FOR_FN (cfun);\n    else\n      {\n        basic_block bb = get_immediate_dominator (CDI_DOMINATORS, block);\n        if (! bb)\n-         return ENTRY_BLOCK_PTR;\n+\t return ENTRY_BLOCK_PTR_FOR_FN (cfun);\n        return bb;\n      }\n }\n@@ -454,7 +454,8 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n \n           cd_bb = find_pdom (cd_bb);\n           post_dom_check++;\n-          if (cd_bb == EXIT_BLOCK_PTR || post_dom_check > MAX_POSTDOM_CHECK)\n+\t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || post_dom_check >\n+\t      MAX_POSTDOM_CHECK)\n             break;\n         }\n       cur_cd_chain->pop ();"}, {"sha": "982937462db376425775196335d521e71da42cbe", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -97,7 +97,7 @@ reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n \t  break;\n \t}\n \n-      gcc_assert (src != ENTRY_BLOCK_PTR);\n+      gcc_assert (src != ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n       if (! bitmap_bit_p (visited, src->index))\n \t{"}, {"sha": "9a30400c0d942c679b753362044cdc7146369cdb", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -821,7 +821,7 @@ eliminate_tail_call (struct tailcall *t)\n \n   gcc_assert (is_gimple_call (stmt));\n \n-  first = single_succ (ENTRY_BLOCK_PTR);\n+  first = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   /* Remove the code after call_gsi that will become unreachable.  The\n      possibly unreachable code in other blocks is removed later in\n@@ -842,9 +842,10 @@ eliminate_tail_call (struct tailcall *t)\n \n   /* Number of executions of function has reduced by the tailcall.  */\n   e = single_succ_edge (gsi_bb (t->call_gsi));\n-  decrease_profile (EXIT_BLOCK_PTR, e->count, EDGE_FREQUENCY (e));\n-  decrease_profile (ENTRY_BLOCK_PTR, e->count, EDGE_FREQUENCY (e));\n-  if (e->dest != EXIT_BLOCK_PTR)\n+  decrease_profile (EXIT_BLOCK_PTR_FOR_FN (cfun), e->count, EDGE_FREQUENCY (e));\n+  decrease_profile (ENTRY_BLOCK_PTR_FOR_FN (cfun), e->count,\n+\t\t    EDGE_FREQUENCY (e));\n+  if (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n     decrease_profile (e->dest, e->count, EDGE_FREQUENCY (e));\n \n   /* Replace the call by a jump to the start of function.  */\n@@ -948,7 +949,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   bool phis_constructed = false;\n   struct tailcall *tailcalls = NULL, *act, *next;\n   bool changed = false;\n-  basic_block first = single_succ (ENTRY_BLOCK_PTR);\n+  basic_block first = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   tree param;\n   gimple stmt;\n   edge_iterator ei;\n@@ -958,7 +959,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   if (opt_tailcalls)\n     opt_tailcalls = suitable_for_tail_call_opt_p ();\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       /* Only traverse the normal exits, i.e. those that end with return\n \t statement.  */\n@@ -982,7 +983,8 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t     or if there are existing degenerate PHI nodes.  */\n \t  if (!single_pred_p (first)\n \t      || !gimple_seq_empty_p (phi_nodes (first)))\n-\t    first = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+\t    first =\n+\t      split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n \n \t  /* Copy the args if needed.  */\n \t  for (param = DECL_ARGUMENTS (current_function_decl);\n@@ -1029,7 +1031,7 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n   if (a_acc || m_acc)\n     {\n       /* Modify the remaining return statements.  */\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n \t{\n \t  stmt = last_stmt (e->src);\n "}, {"sha": "9330074ce3069bd26d4cb33784a38c722b7b0773", "filename": "gcc/tsan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -652,7 +652,7 @@ instrument_func_entry (void)\n   tree ret_addr, builtin_decl;\n   gimple g;\n \n-  succ_bb = single_succ (ENTRY_BLOCK_PTR);\n+  succ_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   gsi = gsi_after_labels (succ_bb);\n \n   builtin_decl = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n@@ -682,7 +682,7 @@ instrument_func_exit (void)\n   edge_iterator ei;\n \n   /* Find all function exits.  */\n-  exit_bb = EXIT_BLOCK_PTR;\n+  exit_bb = EXIT_BLOCK_PTR_FOR_FN (cfun);\n   FOR_EACH_EDGE (e, ei, exit_bb->preds)\n     {\n       gsi = gsi_last_bb (e->src);"}, {"sha": "591747be516772d2e169054c532cd242fb9bf9e6", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -836,16 +836,18 @@ vt_stack_adjustments (void)\n   int sp;\n \n   /* Initialize entry block.  */\n-  VTI (ENTRY_BLOCK_PTR)->visited = true;\n-  VTI (ENTRY_BLOCK_PTR)->in.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n-  VTI (ENTRY_BLOCK_PTR)->out.stack_adjust = INCOMING_FRAME_SP_OFFSET;\n+  VTI (ENTRY_BLOCK_PTR_FOR_FN (cfun))->visited = true;\n+  VTI (ENTRY_BLOCK_PTR_FOR_FN (cfun))->in.stack_adjust =\n+ INCOMING_FRAME_SP_OFFSET;\n+  VTI (ENTRY_BLOCK_PTR_FOR_FN (cfun))->out.stack_adjust =\n+ INCOMING_FRAME_SP_OFFSET;\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n   sp = 0;\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR->succs);\n+  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n \n   while (sp)\n     {\n@@ -866,7 +868,7 @@ vt_stack_adjustments (void)\n \t  VTI (dest)->visited = true;\n \t  VTI (dest)->in.stack_adjust = offset = VTI (src)->out.stack_adjust;\n \n-\t  if (dest != EXIT_BLOCK_PTR)\n+\t  if (dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t    for (insn = BB_HEAD (dest);\n \t\t insn != NEXT_INSN (BB_END (dest));\n \t\t insn = NEXT_INSN (insn))\n@@ -7035,7 +7037,7 @@ vt_find_locations (void)\n \t\t{\n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    {\n-\t\t      if (e->dest == EXIT_BLOCK_PTR)\n+\t\t      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t\t\tcontinue;\n \n \t\t      if (bitmap_bit_p (visited, e->dest->index))\n@@ -9584,7 +9586,7 @@ vt_add_function_parameter (tree parm)\n   if (!track_loc_p (incoming, parm, offset, false, &mode, &offset))\n     return;\n \n-  out = &VTI (ENTRY_BLOCK_PTR)->out;\n+  out = &VTI (ENTRY_BLOCK_PTR_FOR_FN (cfun))->out;\n \n   dv = dv_from_decl (parm);\n \n@@ -9931,7 +9933,7 @@ vt_initialize (void)\n       for (;;)\n \t{\n \t  edge e;\n-\t  if (bb->next_bb == EXIT_BLOCK_PTR\n+\t  if (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t      || ! single_pred_p (bb->next_bb))\n \t    break;\n \t  e = find_edge (bb, bb->next_bb);\n@@ -10034,7 +10036,7 @@ vt_initialize (void)\n     }\n \n   hard_frame_pointer_adjustment = -1;\n-  VTI (ENTRY_BLOCK_PTR)->flooded = true;\n+  VTI (ENTRY_BLOCK_PTR_FOR_FN (cfun))->flooded = true;\n   cfa_base_rtx = NULL_RTX;\n   return true;\n }"}, {"sha": "3ca4700b71b204e3ee20b09076c0e2dc642a493d", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefa31b568664d9efb6257a35ae7b014766faa69/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fefa31b568664d9efb6257a35ae7b014766faa69", "patch": "@@ -1639,7 +1639,7 @@ assemble_start_function (tree decl, const char *fnname)\n \t align the hot section and write out the hot section label.\n \t But if the current function is a thunk, we do not have a CFG.  */\n       if (!cfun->is_thunk\n-\t  && BB_PARTITION (ENTRY_BLOCK_PTR->next_bb) == BB_COLD_PARTITION)\n+\t  && BB_PARTITION (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb) == BB_COLD_PARTITION)\n \t{\n \t  switch_to_section (text_section);\n \t  assemble_align (DECL_ALIGN (decl));"}]}