{"sha": "7d167afd46ed1252cef65dbb043c2815b082fd89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QxNjdhZmQ0NmVkMTI1MmNlZjY1ZGJiMDQzYzI4MTViMDgyZmQ4OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-03-24T21:48:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-03-24T21:48:01Z"}, "message": "sibcall.c (skip_copy_to_return_value): Use OUTGOING_REGNO for comparison if regno's are equal.\n\n\t* sibcall.c (skip_copy_to_return_value): Use OUTGOING_REGNO for\n\tcomparison if regno's are equal.\n\t* calls.c (initialize_argument_informat): Add ecf_flags argument.\n\tUse FUNCTION_INCOMING_ARG if available and ECF_SIBCALL.\n\t(expand_call): Update caller.\n\tAvoid making a sibling call if argument size of the callee is larger\n\tthan argument size of the caller.\n\tCall hard_function_value with outgoing set if in sibcall pass.\n\tUse FUNCTION_INCOMING_ARG if available and ECF_SIBCALL.\n\n\t* final.c (permitted_reg_in_leaf_functions, only_leaf_regs_used):\n\tChange LEAF_REGISTERS from an array initializer to actual array\n\tidentifier. Move static global variable into the function.\n\t(leaf_function_p): Allow SIBLING_CALL_P calls even outside of\n\tsequences for leaf functions.\n\t* global.c (global_alloc): Likewise.\n\t* tm.texi (LEAF_REGISTERS): Update documentation.\n\n\t* config/sparc/sparc.h (CONDITIONAL_REGISTER_USAGE): Remove the ugly\n\tTARGET_FLAT leaf disabling hack.\n\t(LEAF_REGISTERS): Changed from an array initializer to actual array\n\tidentifier to avoid duplication and remove the above hack.\n\t(FUNCTION_OK_FOR_SIBCALL): Define.\n\t* config/sparc/sparc.md (sibcall): New attr type. Use it almost\n\talways like call attribute.\n\t(eligible_for_sibcall_delay): New attribute.\n\t(sibcall): New delay type.\n\t(sibcall, sibcall_value, sibcall_epilogue): New expands.\n\t(sibcall_symbolic_sp32, sibcall_symbolic_sp64,\n\tsibcall_value_symbolic_sp32, sibcall_value_symbolic_sp64): New insns.\n\t* config/sparc/sparc.c (sparc_leaf_regs): New array.\n\t(eligible_for_sibcall_delay, output_restore_regs, output_sibcall):\n\tNew functions.\n\t(output_function_epilogue): Move part of the code into\n\toutput_restore_regs.\n\t(ultra_code_from_mask, ultrasparc_sched_reorder): Handle\n\tTYPE_SIBCALL.\n\t* sparc-protos.h (output_sibcall, eligible_for_sibcall_delay): New\n\tprototypes.\n\nFrom-SVN: r32730", "tree": {"sha": "f90c05f553aeeb028e19de1c5837ae1bb6663362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f90c05f553aeeb028e19de1c5837ae1bb6663362"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d167afd46ed1252cef65dbb043c2815b082fd89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d167afd46ed1252cef65dbb043c2815b082fd89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d167afd46ed1252cef65dbb043c2815b082fd89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d167afd46ed1252cef65dbb043c2815b082fd89/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ad5a9844bd95909a89dd2e0fd374ddd413ccda6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad5a9844bd95909a89dd2e0fd374ddd413ccda6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad5a9844bd95909a89dd2e0fd374ddd413ccda6"}], "stats": {"total": 534, "additions": 454, "deletions": 80}, "files": [{"sha": "71bc926322728d9898b8b16d5ab00158ac939b1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -1,3 +1,45 @@\n+2000-03-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* sibcall.c (skip_copy_to_return_value): Use OUTGOING_REGNO for\n+\tcomparison if regno's are equal.\n+\t* calls.c (initialize_argument_informat): Add ecf_flags argument.\n+\tUse FUNCTION_INCOMING_ARG if available and ECF_SIBCALL.\n+\t(expand_call): Update caller.\n+\tAvoid making a sibling call if argument size of the callee is larger\n+\tthan argument size of the caller.\n+\tCall hard_function_value with outgoing set if in sibcall pass.\n+\tUse FUNCTION_INCOMING_ARG if available and ECF_SIBCALL.\n+\n+\t* final.c (permitted_reg_in_leaf_functions, only_leaf_regs_used):\n+\tChange LEAF_REGISTERS from an array initializer to actual array\n+\tidentifier. Move static global variable into the function.\n+\t(leaf_function_p): Allow SIBLING_CALL_P calls even outside of\n+\tsequences for leaf functions.\n+\t* global.c (global_alloc): Likewise.\n+\t* tm.texi (LEAF_REGISTERS): Update documentation.\n+\n+\t* config/sparc/sparc.h (CONDITIONAL_REGISTER_USAGE): Remove the ugly\n+\tTARGET_FLAT leaf disabling hack.\n+\t(LEAF_REGISTERS): Changed from an array initializer to actual array\n+\tidentifier to avoid duplication and remove the above hack.\n+\t(FUNCTION_OK_FOR_SIBCALL): Define.\n+\t* config/sparc/sparc.md (sibcall): New attr type. Use it almost\n+\talways like call attribute.\n+\t(eligible_for_sibcall_delay): New attribute.\n+\t(sibcall): New delay type.\n+\t(sibcall, sibcall_value, sibcall_epilogue): New expands.\n+\t(sibcall_symbolic_sp32, sibcall_symbolic_sp64,\n+\tsibcall_value_symbolic_sp32, sibcall_value_symbolic_sp64): New insns.\n+\t* config/sparc/sparc.c (sparc_leaf_regs): New array.\n+\t(eligible_for_sibcall_delay, output_restore_regs, output_sibcall):\n+\tNew functions.\n+\t(output_function_epilogue): Move part of the code into\n+\toutput_restore_regs.\n+\t(ultra_code_from_mask, ultrasparc_sched_reorder): Handle\n+\tTYPE_SIBCALL.\n+\t* sparc-protos.h (output_sibcall, eligible_for_sibcall_delay): New\n+\tprototypes.\n+\n Fri Mar 24 13:49:45 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* integrate.c (save_for_inline_nocopy): Clear in_nonparm_insns here."}, {"sha": "0a8688c6885f8c5bed448787d6e159d3f551911f", "filename": "gcc/calls.c", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -165,7 +165,7 @@ static void initialize_argument_information\tPARAMS ((int,\n \t\t\t\t\t\t\t int, tree, tree,\n \t\t\t\t\t\t\t CUMULATIVE_ARGS *,\n \t\t\t\t\t\t\t int, rtx *, int *,\n-\t\t\t\t\t\t\t int *, int *));\n+\t\t\t\t\t\t\t int *, int *, int));\n static void compute_argument_addresses\t\tPARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t rtx, int));\n static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n@@ -980,7 +980,8 @@ static void\n initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t\t\t\t actparms, fndecl, args_so_far,\n \t\t\t\t reg_parm_stack_space, old_stack_level,\n-\t\t\t\t old_pending_adj, must_preallocate, is_const)\n+\t\t\t\t old_pending_adj, must_preallocate, is_const,\n+\t\t\t\t ecf_flags)\n      int num_actuals ATTRIBUTE_UNUSED;\n      struct arg_data *args;\n      struct args_size *args_size;\n@@ -993,6 +994,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n      int *old_pending_adj;\n      int *must_preallocate;\n      int *is_const;\n+     int ecf_flags;\n {\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n@@ -1150,8 +1152,19 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \n       args[i].unsignedp = unsignedp;\n       args[i].mode = mode;\n-      args[i].reg = FUNCTION_ARG (*args_so_far, mode, type,\n-\t\t\t\t  argpos < n_named_args);\n+\n+#ifdef FUNCTION_INCOMING_ARG\n+      /* If this is a sibling call and the machine has register windows, the\n+\t register window has to be unwinded before calling the routine, so\n+\t arguments have to go into the incoming registers.  */\n+      if (ecf_flags & ECF_SIBCALL)\n+\targs[i].reg = FUNCTION_INCOMING_ARG (*args_so_far, mode, type,\n+\t\t\t\t\t     argpos < n_named_args);\n+      else\n+#endif\n+\targs[i].reg = FUNCTION_ARG (*args_so_far, mode, type,\n+\t\t\t\t    argpos < n_named_args);\n+\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n       if (args[i].reg)\n \targs[i].partial\n@@ -2131,7 +2144,7 @@ expand_call (exp, target, ignore)\n \t call expansion.  */\n       int save_pending_stack_adjust;\n       rtx insns;\n-      rtx before_call;\n+      rtx before_call, next_arg_reg;\n \n       if (pass == 0)\n \t{\n@@ -2284,7 +2297,8 @@ expand_call (exp, target, ignore)\n \t\t\t\t       n_named_args, actparms, fndecl,\n \t\t\t\t       &args_so_far, reg_parm_stack_space,\n \t\t\t\t       &old_stack_level, &old_pending_adj,\n-\t\t\t\t       &must_preallocate, &is_const);\n+\t\t\t\t       &must_preallocate, &is_const,\n+\t\t\t\t       (pass == 0) ? ECF_SIBCALL : 0);\n \n #ifdef FINAL_REG_PARM_STACK_SPACE\n       reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n@@ -2305,6 +2319,13 @@ expand_call (exp, target, ignore)\n \t  sibcall_failure = 1;\n \t}\n \n+      if (args_size.constant > current_function_args_size)\n+\t{\n+\t  /* If this function requires more stack slots than the current\n+\t     function, we cannot change it into a sibling call.  */\n+\t  sibcall_failure = 1;\n+\t}\n+\n       /* Compute the actual size of the argument block required.  The variable\n \t and constant sizes must be combined, the size may have to be rounded,\n \t and there may be a minimum required size.  When generating a sibcall\n@@ -2569,9 +2590,9 @@ expand_call (exp, target, ignore)\n \t{\n \t  if (pcc_struct_value)\n \t    valreg = hard_function_value (build_pointer_type (TREE_TYPE (exp)),\n-\t\t\t\t\t  fndecl, 0);\n+\t\t\t\t\t  fndecl, (pass == 0));\n \t  else\n-\t    valreg = hard_function_value (TREE_TYPE (exp), fndecl, 0);\n+\t    valreg = hard_function_value (TREE_TYPE (exp), fndecl, (pass == 0));\n \t}\n \n       /* Precompute all register parameters.  It isn't safe to compute anything\n@@ -2665,14 +2686,24 @@ expand_call (exp, target, ignore)\n \t later safely search backwards to find the CALL_INSN.  */\n       before_call = get_last_insn ();\n \n+      /* Set up next argument register.  For sibling calls on machines\n+\t with register windows this should be the incoming register.  */\n+#ifdef FUNCTION_INCOMING_ARG\n+      if (pass == 0)\n+\tnext_arg_reg = FUNCTION_INCOMING_ARG (args_so_far, VOIDmode,\n+\t\t\t\t\t      void_type_node, 1);\n+      else\n+#endif\n+\tnext_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode,\n+\t\t\t\t     void_type_node, 1);\n+\n       /* All arguments and registers used for the call must be set up by\n \t now!  */\n \n       /* Generate the actual call instruction.  */\n       emit_call_1 (funexp, fndecl, funtype, unadjusted_args_size,\n \t\t   args_size.constant, struct_value_size,\n-\t\t   FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t\t   valreg, old_inhibit_defer_pop, call_fusage,\n+\t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n \t\t   ((is_const ? ECF_IS_CONST : 0)\n \t\t    | (nothrow ? ECF_NOTHROW : 0)\n \t\t    | (pass == 0 ? ECF_SIBCALL : 0)));\n@@ -2956,11 +2987,9 @@ expand_call (exp, target, ignore)\n \t{\n \t  tail_call_insns = insns;\n \n-\t  /* If the current function's argument block is not large enough\n-\t     to hold the outoing arguments, or we encountered some other\n-\t     situation we couldn't handle, zero out the sequence.  */\n-\t  if (current_function_args_size < args_size.constant\n-\t      || sibcall_failure)\n+\t  /* If something prevents making this a sibling call,\n+\t     zero out the sequence.  */\n+\t  if (sibcall_failure)\n \t    tail_call_insns = NULL_RTX;\n \n \t  /* Restore the pending stack adjustment now that we have"}, {"sha": "52d95f897628f8c9ad2c7d76d8d98d8ee4cd451d", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -96,6 +96,7 @@ extern int sparc_splitdi_legitimate PARAMS ((rtx, rtx));\n extern int sparc_absnegfloat_split_legitimate PARAMS ((rtx, rtx));\n extern char *output_cbranch PARAMS ((rtx, int, int, int, int, rtx));\n extern const char *output_return PARAMS ((rtx *));\n+extern const char *output_sibcall PARAMS ((rtx, rtx));\n extern char *output_v9branch PARAMS ((rtx, int, int, int, int, int, rtx));\n extern void emit_v9_brxx_insn PARAMS ((enum rtx_code, rtx, rtx));\n extern void output_double_int PARAMS ((FILE *, rtx));\n@@ -121,6 +122,7 @@ extern int cc_arithopn PARAMS ((rtx, enum machine_mode));\n extern int data_segment_operand PARAMS ((rtx, enum machine_mode));\n extern int eligible_for_epilogue_delay PARAMS ((rtx, int));\n extern int eligible_for_return_delay PARAMS ((rtx));\n+extern int eligible_for_sibcall_delay PARAMS ((rtx));\n extern int emit_move_sequence PARAMS ((rtx, enum machine_mode));\n extern int extend_op PARAMS ((rtx, enum machine_mode));\n extern int fcc_reg_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "8d8487512eb28b225dede5ee555c5818c4c43f1e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 280, "deletions": 28, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -99,6 +99,24 @@ char leaf_reg_remap[] =\n   88, 89, 90, 91, 92, 93, 94, 95,\n   96, 97, 98, 99, 100};\n \n+/* Vector, indexed by hard register number, which contains 1\n+   for a register that is allowable in a candidate for leaf\n+   function treatment.  */\n+char sparc_leaf_regs[] =\n+{ 1, 1, 1, 1, 1, 1, 1, 1,\n+  0, 0, 0, 0, 0, 0, 1, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,\n+  1, 1, 1, 1, 1, 1, 0, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1};\n+\n #endif\n \n /* Name of where we pretend to think the frame pointer points.\n@@ -2458,6 +2476,98 @@ eligible_for_epilogue_delay (trial, slot)\n   return 0;\n }\n \n+/* Return nonzero if TRIAL can go into the sibling call\n+   delay slot.  */\n+\n+int\n+eligible_for_sibcall_delay (trial)\n+     rtx trial;\n+{\n+  rtx pat, src;\n+\n+  if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n+    return 0;\n+\n+  if (get_attr_length (trial) != 1 || profile_block_flag == 2)\n+    return 0;\n+\n+  pat = PATTERN (trial);\n+\n+  if (current_function_uses_only_leaf_regs)\n+    {\n+      /* If the tail call is done using the call instruction,\n+\t we have to restore %o7 in the delay slot.  */\n+      if (TARGET_ARCH64 && ! TARGET_CM_MEDLOW)\n+\treturn 0;\n+\n+      /* %g1 is used to build the function address */\n+      if (reg_mentioned_p (gen_rtx_REG (Pmode, 1), pat))\n+\treturn 0;\n+\n+      return 1;\n+    }\n+\n+  /* Otherwise, only operations which can be done in tandem with\n+     a `restore' insn can go into the delay slot.  */\n+  if (GET_CODE (SET_DEST (pat)) != REG\n+      || REGNO (SET_DEST (pat)) < 24\n+      || REGNO (SET_DEST (pat)) >= 32)\n+    return 0;\n+\n+  /* If it mentions %o7, it can't go in, because sibcall will clobber it\n+     in most cases.  */\n+  if (reg_mentioned_p (gen_rtx_REG (Pmode, 15), pat))\n+    return 0;\n+\n+  src = SET_SRC (pat);\n+\n+  if (arith_operand (src, GET_MODE (src)))\n+    {\n+      if (TARGET_ARCH64)\n+        return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n+      else\n+        return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n+    }\n+\n+  else if (arith_double_operand (src, GET_MODE (src)))\n+    return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n+\n+  else if (! TARGET_FPU && restore_operand (SET_DEST (pat), SFmode)\n+\t   && register_operand (src, SFmode))\n+    return 1;\n+\n+  else if (GET_CODE (src) == PLUS\n+\t   && arith_operand (XEXP (src, 0), SImode)\n+\t   && arith_operand (XEXP (src, 1), SImode)\n+\t   && (register_operand (XEXP (src, 0), SImode)\n+\t       || register_operand (XEXP (src, 1), SImode)))\n+    return 1;\n+\n+  else if (GET_CODE (src) == PLUS\n+\t   && arith_double_operand (XEXP (src, 0), DImode)\n+\t   && arith_double_operand (XEXP (src, 1), DImode)\n+\t   && (register_operand (XEXP (src, 0), DImode)\n+\t       || register_operand (XEXP (src, 1), DImode)))\n+    return 1;\n+\n+  else if (GET_CODE (src) == LO_SUM\n+\t   && ! TARGET_CM_MEDMID\n+\t   && ((register_operand (XEXP (src, 0), SImode)\n+\t        && immediate_operand (XEXP (src, 1), SImode))\n+\t       || (TARGET_ARCH64\n+\t\t   && register_operand (XEXP (src, 0), DImode)\n+\t\t   && immediate_operand (XEXP (src, 1), DImode))))\n+    return 1;\n+\n+  else if (GET_CODE (src) == ASHIFT\n+\t   && (register_operand (XEXP (src, 0), SImode)\n+\t       || register_operand (XEXP (src, 0), DImode))\n+\t   && XEXP (src, 1) == const1_rtx)\n+    return 1;\n+\n+  return 0;\n+}\n+\n static int\n check_return_regs (x)\n      rtx x;\n@@ -3423,6 +3533,40 @@ output_function_prologue (file, size, leaf_function)\n     }\n }\n \n+/* Output code to restore any call saved registers.  */\n+\n+static void\n+output_restore_regs (file, leaf_function)\n+     FILE *file;\n+     int leaf_function;\n+{\n+  int offset, n_regs;\n+  const char *base;\n+\n+  offset = -apparent_fsize + frame_base_offset;\n+  if (offset < -4096 || offset + num_gfregs * 4 > 4096 - 8 /*double*/)\n+    {\n+      build_big_number (file, offset, \"%g1\");\n+      fprintf (file, \"\\tadd\\t%s, %%g1, %%g1\\n\", frame_base_name);\n+      base = \"%g1\";\n+      offset = 0;\n+    }\n+  else\n+    {\n+      base = frame_base_name;\n+    }\n+\n+  n_regs = 0;\n+  if (TARGET_EPILOGUE && ! leaf_function)\n+    /* ??? Originally saved regs 0-15 here.  */\n+    n_regs = restore_regs (file, 0, 8, base, offset, 0);\n+  else if (leaf_function)\n+    /* ??? Originally saved regs 0-31 here.  */\n+    n_regs = restore_regs (file, 0, 8, base, offset, 0);\n+  if (TARGET_EPILOGUE)\n+    restore_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n+}\n+\n /* Output code for the function epilogue.  */\n \n void\n@@ -3457,35 +3601,8 @@ output_function_epilogue (file, size, leaf_function)\n       goto output_vectors;                                                    \n     }\n \n-  /* Restore any call saved registers.  */\n   if (num_gfregs)\n-    {\n-      int offset, n_regs;\n-      const char *base;\n-\n-      offset = -apparent_fsize + frame_base_offset;\n-      if (offset < -4096 || offset + num_gfregs * 4 > 4096 - 8 /*double*/)\n-\t{\n-\t  build_big_number (file, offset, \"%g1\");\n-\t  fprintf (file, \"\\tadd\\t%s, %%g1, %%g1\\n\", frame_base_name);\n-\t  base = \"%g1\";\n-\t  offset = 0;\n-\t}\n-      else\n-\t{\n-\t  base = frame_base_name;\n-\t}\n-\n-      n_regs = 0;\n-      if (TARGET_EPILOGUE && ! leaf_function)\n-\t/* ??? Originally saved regs 0-15 here.  */\n-\tn_regs = restore_regs (file, 0, 8, base, offset, 0);\n-      else if (leaf_function)\n-\t/* ??? Originally saved regs 0-31 here.  */\n-\tn_regs = restore_regs (file, 0, 8, base, offset, 0);\n-      if (TARGET_EPILOGUE)\n-\trestore_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n-    }\n+    output_restore_regs (file, leaf_function);\n \n   /* Work out how to skip the caller's unimp instruction if required.  */\n   if (leaf_function)\n@@ -3575,6 +3692,139 @@ output_function_epilogue (file, size, leaf_function)\n  output_vectors:\n   sparc_output_deferred_case_vectors ();\n }\n+\n+/* Output a sibling call.  */\n+\n+const char *\n+output_sibcall (insn, call_operand)\n+     rtx insn, call_operand;\n+{\n+  int leaf_regs = current_function_uses_only_leaf_regs;\n+  rtx operands[3];\n+  int delay_slot = dbr_sequence_length () > 0;\n+\n+  if (num_gfregs)\n+    {\n+      /* Call to restore global regs might clobber\n+\t the delay slot. Instead of checking for this\n+\t output the delay slot now.  */\n+      if (delay_slot)\n+\t{\n+\t  rtx delay = NEXT_INSN (insn);\n+\n+\t  if (! delay)\n+\t    abort ();\n+\n+\t  final_scan_insn (delay, asm_out_file, 1, 0, 1);\n+\t  PATTERN (delay) = gen_blockage ();\n+\t  INSN_CODE (delay) = -1;\n+\t  delay_slot = 0;\n+\t}\n+      output_restore_regs (asm_out_file, leaf_regs);\n+    }\n+\n+  operands[0] = call_operand;\n+\n+  if (leaf_regs)\n+    {\n+      int spare_slot = (TARGET_ARCH32 || TARGET_CM_MEDLOW);\n+      int size = 0;\n+\n+      if ((actual_fsize || ! spare_slot) && delay_slot)\n+\t{\n+\t  rtx delay = NEXT_INSN (insn);\n+\n+\t  if (! delay)\n+\t    abort ();\n+\n+\t  final_scan_insn (delay, asm_out_file, 1, 0, 1);\n+\t  PATTERN (delay) = gen_blockage ();\n+\t  INSN_CODE (delay) = -1;\n+\t  delay_slot = 0;\n+\t}\n+      if (actual_fsize)\n+\t{\n+\t  if (actual_fsize <= 4096)\n+\t    size = actual_fsize;\n+\t  else if (actual_fsize <= 8192)\n+\t    {\n+\t      fputs (\"\\tsub\\t%sp, -4096, %sp\\n\", asm_out_file);\n+\t      size = actual_fsize - 4096;\n+\t    }\n+\t  else if ((actual_fsize & 0x3ff) == 0)\n+\t    fprintf (asm_out_file,\n+\t\t     \"\\tsethi\\t%%hi(%d), %%g1\\n\\tadd\\t%%sp, %%g1, %%sp\\n\",\n+\t\t     actual_fsize);\n+\t  else\n+\t    {\n+\t      fprintf (asm_out_file,\n+\t\t       \"\\tsethi\\t%%hi(%d), %%g1\\n\\tor\\t%%g1, %%lo(%d), %%g1\\n\",\n+\t\t       actual_fsize, actual_fsize);\n+\t      fputs (\"\\tadd\\t%%sp, %%g1, %%sp\\n\", asm_out_file);\n+\t    }\n+\t}\n+      if (spare_slot)\n+\t{\n+\t  output_asm_insn (\"sethi\\t%%hi(%a0), %%g1\", operands);\n+\t  output_asm_insn (\"jmpl\\t%%g1 + %%lo(%a0), %%g0\", operands);\n+\t  if (size)\n+\t    fprintf (asm_out_file, \"\\t sub\\t%%sp, -%d, %%sp\\n\", size);\n+\t  else if (! delay_slot)\n+\t    fputs (\"\\t nop\\n\", asm_out_file);\n+\t}\n+      else\n+\t{\n+\t  if (size)\n+\t    fprintf (asm_out_file, \"\\tsub\\t%%sp, -%d, %%sp\\n\", size);\n+\t  output_asm_insn (\"mov\\t%%o7, %%g1\", operands);\n+\t  output_asm_insn (\"call\\t%a0, 0\", operands);\n+\t  output_asm_insn (\" mov\\t%%g1, %%o7\", operands);\n+\t}\n+      return \"\";\n+    }\n+\n+  output_asm_insn (\"call\\t%a0, 0\", operands);\n+  if (delay_slot)\n+    {\n+      rtx delay = NEXT_INSN (insn), pat;\n+\n+      if (! delay)\n+\tabort ();\n+\n+      pat = PATTERN (delay);\n+      if (GET_CODE (pat) != SET)\n+\tabort ();\n+\n+      operands[0] = SET_DEST (pat);\n+      pat = SET_SRC (pat);\n+      switch (GET_CODE (pat))\n+\t{\n+\tcase PLUS:\n+\t  operands[1] = XEXP (pat, 0);\n+\t  operands[2] = XEXP (pat, 1);\n+\t  output_asm_insn (\" restore %r1, %2, %Y0\", operands);\n+\t  break;\n+\tcase LO_SUM:\n+\t  operands[1] = XEXP (pat, 0);\n+\t  operands[2] = XEXP (pat, 1);\n+\t  output_asm_insn (\" restore %r1, %%lo(%a2), %Y0\", operands);\n+\t  break;\n+\tcase ASHIFT:\n+\t  operands[1] = XEXP (pat, 0);\n+\t  output_asm_insn (\" restore %r1, %r1, %Y0\", operands);\n+\t  break;\n+\tdefault:\n+\t  operands[1] = pat;\n+\t  output_asm_insn (\" restore %%g0, %1, %Y0\", operands);\n+\t  break;\n+\t}\n+      PATTERN (delay) = gen_blockage ();\n+      INSN_CODE (delay) = -1;\n+    }\n+  else\n+    fputs (\"\\t restore\\n\", asm_out_file);\n+  return \"\";\n+}\n \f\n /* Functions for handling argument passing.\n \n@@ -7014,6 +7264,7 @@ ultra_code_from_mask (type_mask)\n     return IEU0;\n   else if (type_mask & (TMASK (TYPE_COMPARE) |\n \t\t\tTMASK (TYPE_CALL) |\n+\t\t\tTMASK (TYPE_SIBCALL) |\n \t\t\tTMASK (TYPE_UNCOND_BRANCH)))\n     return IEU1;\n   else if (type_mask & (TMASK (TYPE_IALU) | TMASK (TYPE_BINARY) |\n@@ -7486,6 +7737,7 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n \t/* If we are not in the process of emptying out the pipe, try to\n \t   obtain an instruction which must be the first in it's group.  */\n \tip = ultra_find_type ((TMASK (TYPE_CALL) |\n+\t\t\t       TMASK (TYPE_SIBCALL) |\n \t\t\t       TMASK (TYPE_CALL_NO_DELAY_SLOT) |\n \t\t\t       TMASK (TYPE_UNCOND_BRANCH)),\n \t\t\t      ready, this_insn);"}, {"sha": "d11f387b671a059bd25952c82b990eeb0783b69a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -1066,8 +1066,8 @@ do\t\t\t\t\t\t\t\t\\\n \t   %fp, but output it as %i7.  */\t\t\t\\\n \tfixed_regs[31] = 1;\t\t\t\t\t\\\n \treg_names[FRAME_POINTER_REGNUM] = \"%i7\";\t\t\\\n-\t/* ??? This is a hack to disable leaf functions.  */\t\\\n-\tglobal_regs[7] = 1;\t\t\t\t\t\\\n+\t/* Disable leaf functions */\t\t\t\t\\\n+\tbzero (sparc_leaf_regs, FIRST_PSEUDO_REGISTER);\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n     if (profile_block_flag)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n@@ -1373,26 +1373,8 @@ extern enum reg_class sparc_regno_reg_class[];\n   \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n-/* ??? %g7 is not a leaf register to effectively #undef LEAF_REGISTERS when\n-   -mflat is used.  Function only_leaf_regs_used will return 0 if a global\n-   register is used and is not permitted in a leaf function.  We make %g7\n-   a global reg if -mflat and voila.  Since %g7 is a system register and is\n-   fixed it won't be used by gcc anyway.  */\n-\n-#define LEAF_REGISTERS \\\n-{ 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1, 0, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1}\n+extern char sparc_leaf_regs[];\n+#define LEAF_REGISTERS sparc_leaf_regs\n \n extern char leaf_reg_remap[];\n #define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n@@ -2145,6 +2127,10 @@ LFLGRET\"ID\":\\n\\\n \n #define STRICT_ARGUMENT_NAMING TARGET_V9\n \n+/* We do not allow sibling calls if -mflat, nor\n+   we do not allow indirect calls to be optimized into sibling calls.  */\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) (DECL && ! TARGET_FLAT)\n+\n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */\n #define SETUP_FRAME_ADDRESSES()\t\t\\"}, {"sha": "3b62a5eff7de9bba52b38b46b977bdebf2ad86da", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -88,7 +88,7 @@\n ;; type \"call_no_delay_slot\" is a call followed by an unimp instruction.\n \n (define_attr \"type\"\n-  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,return,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrts,fpsqrtd,cmove,multi,misc\"\n+  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,sibcall,call_no_delay_slot,return,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrts,fpsqrtd,cmove,multi,misc\"\n   (const_string \"binary\"))\n \n ;; Set true if insn uses call-clobbered intermediate register.\n@@ -131,7 +131,7 @@\n ;; Attributes for instruction and branch scheduling\n \n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,call_no_delay_slot,return,multi\")\n+  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,sibcall,call_no_delay_slot,return,multi\")\n \t \t(const_string \"false\")\n \t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n \t \t(if_then_else (eq_attr \"length\" \"1\")\n@@ -148,6 +148,12 @@\n (define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n+(define_attr \"eligible_for_sibcall_delay\" \"false,true\"\n+  (symbol_ref \"eligible_for_sibcall_delay(insn)\"))\n+\n+(define_delay (eq_attr \"type\" \"sibcall\")\n+  [(eq_attr \"eligible_for_sibcall_delay\" \"true\") (nil) (nil)])\n+\n (define_attr \"leaf_function\" \"false,true\"\n   (const (symbol_ref \"current_function_uses_only_leaf_regs\")))\n \n@@ -179,19 +185,19 @@\n ;; because it prevents us from moving back the final store of inner loops.\n \n (define_attr \"in_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n (define_attr \"in_uncond_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n (define_attr \"in_annul_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n@@ -453,7 +459,7 @@\n \n (define_function_unit \"ieuN\" 2 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"ialu,binary,move,unary,shift,compare,call,call_no_delay_slot,uncond_branch\"))\n+    (eq_attr \"type\" \"ialu,binary,move,unary,shift,compare,call,sibcall,call_no_delay_slot,uncond_branch\"))\n   1 1)\n \n (define_function_unit \"ieu0\" 1 0\n@@ -468,7 +474,7 @@\n \n (define_function_unit \"ieu1\" 1 0\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"compare,call,call_no_delay_slot,uncond_branch\"))\n+    (eq_attr \"type\" \"compare,call,sibcall,call_no_delay_slot,uncond_branch\"))\n   1 1)\n \n (define_function_unit \"cti\" 1 0\n@@ -8570,6 +8576,59 @@\n   DONE;\n }\")\n \n+;;- tail calls\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand 0 \"call_operand\" \"\") (const_int 0))\n+\t      (return)])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*sibcall_symbolic_sp32\"\n+  [(call (mem:SI (match_operand:SI 0 \"symbolic_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (return)]\n+  \"! TARGET_PTR64\"\n+  \"* return output_sibcall(insn, operands[0]);\"\n+  [(set_attr \"type\" \"sibcall\")])\n+\n+(define_insn \"*sibcall_symbolic_sp64\"\n+  [(call (mem:SI (match_operand:DI 0 \"symbolic_operand\" \"s\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (return)]\n+  \"TARGET_PTR64\"\n+  \"* return output_sibcall(insn, operands[0]);\"\n+  [(set_attr \"type\" \"sibcall\")])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=rf\")\n+\t\t(call (match_operand:SI 1 \"\" \"\") (const_int 0)))\n+\t      (return)])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*sibcall_value_symbolic_sp32\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"symbolic_operand\" \"s\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (return)]\n+  \"! TARGET_PTR64\"\n+  \"* return output_sibcall(insn, operands[1]);\"\n+  [(set_attr \"type\" \"sibcall\")])\n+\n+(define_insn \"*sibcall_value_symbolic_sp64\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:DI 1 \"symbolic_operand\" \"s\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (return)]\n+  \"TARGET_PTR64\"\n+  \"* return output_sibcall(insn, operands[1]);\"\n+  [(set_attr \"type\" \"sibcall\")])\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"DONE;\")\n+\n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n "}, {"sha": "5693d460ef88974c4846dbfae17e8c8aba391314", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -4015,7 +4015,8 @@ leaf_function_p ()\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (GET_CODE (insn) == CALL_INSN\n+\t  && ! SIBLING_CALL_P (insn))\n \treturn 0;\n       if (GET_CODE (insn) == INSN\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE\n@@ -4025,7 +4026,8 @@ leaf_function_p ()\n     }\n   for (insn = current_function_epilogue_delay_list; insn; insn = XEXP (insn, 1))\n     {\n-      if (GET_CODE (XEXP (insn, 0)) == CALL_INSN)\n+      if (GET_CODE (XEXP (insn, 0)) == CALL_INSN\n+\t  && ! SIBLING_CALL_P (insn))\n \treturn 0;\n       if (GET_CODE (XEXP (insn, 0)) == INSN\n \t  && GET_CODE (PATTERN (XEXP (insn, 0))) == SEQUENCE\n@@ -4048,15 +4050,14 @@ leaf_function_p ()\n \n #ifdef LEAF_REGISTERS\n \n-static char permitted_reg_in_leaf_functions[] = LEAF_REGISTERS;\n-\n /* Return 1 if this function uses only the registers that can be\n    safely renumbered.  */\n \n int\n only_leaf_regs_used ()\n {\n   int i;\n+  char *permitted_reg_in_leaf_functions = LEAF_REGISTERS;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if ((regs_ever_live[i] || global_regs[i])"}, {"sha": "f672076aeb5bab34b4d770369920f27034fce4ed", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -374,7 +374,7 @@ global_alloc (file)\n      a leaf function.  */\n   {\n     char *cheap_regs;\n-    static char leaf_regs[] = LEAF_REGISTERS;\n+    char *leaf_regs = LEAF_REGISTERS;\n \n     if (only_leaf_regs_used () && leaf_function_p ())\n       cheap_regs = leaf_regs;"}, {"sha": "1a3a310388dd069e9421e4582c2be190d1a90be1", "filename": "gcc/sibcall.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -140,9 +140,13 @@ skip_copy_to_return_value (orig_insn, hardret, softret)\n      called function's return value was copied.  Otherwise we're returning\n      some other value.  */\n \n+#ifndef OUTGOING_REGNO\n+#define OUTGOING_REGNO(N) (N)\n+#endif\n+\n   if (SET_DEST (set) == current_function_return_rtx\n       && REG_P (SET_DEST (set))\n-      && REGNO (SET_DEST (set)) == REGNO (hardret)\n+      && OUTGOING_REGNO (REGNO (SET_DEST (set))) == REGNO (hardret)\n       && SET_SRC (set) == softret)\n     return insn;\n \n@@ -353,7 +357,6 @@ replace_call_placeholder (insn, use)\n   NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n }\n \n-\n /* Given a (possibly empty) set of potential sibling or tail recursion call\n    sites, determine if optimization is possible.\n "}, {"sha": "1a1396f91a815333620ebd846140954a704e25f2", "filename": "gcc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d167afd46ed1252cef65dbb043c2815b082fd89/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=7d167afd46ed1252cef65dbb043c2815b082fd89", "patch": "@@ -1652,7 +1652,7 @@ accomplish this.\n @table @code\n @findex LEAF_REGISTERS\n @item LEAF_REGISTERS\n-A C initializer for a vector, indexed by hard register number, which\n+Name of a char vector, indexed by hard register number, which\n contains 1 for a register that is allowable in a candidate for leaf\n function treatment.\n "}]}