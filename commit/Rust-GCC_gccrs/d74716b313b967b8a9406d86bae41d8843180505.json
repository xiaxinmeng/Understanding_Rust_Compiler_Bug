{"sha": "d74716b313b967b8a9406d86bae41d8843180505", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NzE2YjMxM2I5NjdiOGE5NDA2ZDg2YmFlNDFkODg0MzE4MDUwNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T08:54:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T08:54:25Z"}, "message": "[multiple changes]\n\n2016-04-21  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_aggr.adb: Minor reformatting and code cleanup.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Resolve_Name): Omit quantified expressions from\n\tresolution, because they introduce local names. Full resolution\n\twill take place when predicate function is constructed.\n\nFrom-SVN: r235316", "tree": {"sha": "4086d26f474e9b39bddb2caea0e866385292fadb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4086d26f474e9b39bddb2caea0e866385292fadb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74716b313b967b8a9406d86bae41d8843180505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74716b313b967b8a9406d86bae41d8843180505", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74716b313b967b8a9406d86bae41d8843180505", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74716b313b967b8a9406d86bae41d8843180505/comments", "author": null, "committer": null, "parents": [{"sha": "f0305f3a5b2d64cc8143ad3a1aa8a704c10f91c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0305f3a5b2d64cc8143ad3a1aa8a704c10f91c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0305f3a5b2d64cc8143ad3a1aa8a704c10f91c7"}], "stats": {"total": 120, "additions": 67, "deletions": 53}, "files": [{"sha": "c4845dc9f1e3355c9873b425e69a3d353e81ab27", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74716b313b967b8a9406d86bae41d8843180505/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74716b313b967b8a9406d86bae41d8843180505/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d74716b313b967b8a9406d86bae41d8843180505", "patch": "@@ -1,3 +1,13 @@\n+2016-04-21  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_aggr.adb: Minor reformatting and code cleanup.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Resolve_Name): Omit quantified expressions from\n+\tresolution, because they introduce local names. Full resolution\n+\twill take place when predicate function is constructed.\n+\n 2016-04-21  Arnaud Charlet  <charlet@adacore.com>\n \n \t* exp_aggr.adb (Component_Not_OK_For_Backend): Refine previous"}, {"sha": "5d6907b67a27186589926bb3ba687c3d6457ab37", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74716b313b967b8a9406d86bae41d8843180505/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74716b313b967b8a9406d86bae41d8843180505/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=d74716b313b967b8a9406d86bae41d8843180505", "patch": "@@ -202,7 +202,7 @@ package body Exp_Aggr is\n    --    N is the (sub-)aggregate node to be expanded into code. This node has\n    --    been fully analyzed, and its Etype is properly set.\n    --\n-   --    Index is the index node corresponding to the array sub-aggregate N\n+   --    Index is the index node corresponding to the array subaggregate N\n    --\n    --    Into is the target expression into which we are copying the aggregate.\n    --    Note that this node may not have been analyzed yet, and so the Etype\n@@ -555,9 +555,9 @@ package body Exp_Aggr is\n \n       function Component_Check (N : Node_Id; Index : Node_Id) return Boolean;\n       --  This routine checks components of aggregate N, enforcing checks\n-      --  1, 7, 8, 9, 11 and 12. In the multi-dimensional case, these checks\n+      --  1, 7, 8, 9, 11, and 12. In the multidimensional case, these checks\n       --  are performed on subaggregates. The Index value is the current index\n-      --  being checked in the multi-dimensional case.\n+      --  being checked in the multidimensional case.\n \n       ---------------------\n       -- Component_Check --\n@@ -653,7 +653,7 @@ package body Exp_Aggr is\n          return False;\n       end if;\n \n-      --  Checks 4 (array must not be multi-dimensional Fortran case)\n+      --  Checks 4 (array must not be multidimensional Fortran case)\n \n       if Convention (Typ) = Convention_Fortran\n         and then Number_Dimensions (Typ) > 1\n@@ -705,7 +705,7 @@ package body Exp_Aggr is\n \n    --  The code that we generate from a one dimensional aggregate is\n \n-   --  1. If the sub-aggregate contains discrete choices we\n+   --  1. If the subaggregate contains discrete choices we\n \n    --     (a) Sort the discrete choices\n \n@@ -767,9 +767,9 @@ package body Exp_Aggr is\n       --  Returns a new reference to the index type name\n \n       function Gen_Assign (Ind : Node_Id; Expr : Node_Id) return List_Id;\n-      --  Ind must be a side-effect free expression. If the input aggregate\n-      --  N to Build_Loop contains no sub-aggregates, then this function\n-      --  returns the assignment statement:\n+      --  Ind must be a side-effect-free expression. If the input aggregate N\n+      --  to Build_Loop contains no subaggregates, then this function returns\n+      --  the assignment statement:\n       --\n       --     Into (Indexes, Ind) := Expr;\n       --\n@@ -779,22 +779,22 @@ package body Exp_Aggr is\n       --  is empty and we generate a call to the corresponding IP subprogram.\n \n       function Gen_Loop (L, H : Node_Id; Expr : Node_Id) return List_Id;\n-      --  Nodes L and H must be side-effect free expressions.\n-      --  If the input aggregate N to Build_Loop contains no sub-aggregates,\n-      --  This routine returns the for loop statement\n+      --  Nodes L and H must be side-effect-free expressions. If the input\n+      --  aggregate N to Build_Loop contains no subaggregates, this routine\n+      --  returns the for loop statement:\n       --\n       --     for J in Index_Base'(L) .. Index_Base'(H) loop\n       --        Into (Indexes, J) := Expr;\n       --     end loop;\n       --\n       --  Otherwise we call Build_Code recursively.\n-      --  As an optimization if the loop covers 3 or less scalar elements we\n+      --  As an optimization if the loop covers 3 or fewer scalar elements we\n       --  generate a sequence of assignments.\n \n       function Gen_While (L, H : Node_Id; Expr : Node_Id) return List_Id;\n-      --  Nodes L and H must be side-effect free expressions.\n-      --  If the input aggregate N to Build_Loop contains no sub-aggregates,\n-      --  This routine returns the while loop statement\n+      --  Nodes L and H must be side-effect-free expressions. If the input\n+      --  aggregate N to Build_Loop contains no subaggregates, this routine\n+      --  returns the while loop statement:\n       --\n       --     J : Index_Base := L;\n       --     while J < H loop\n@@ -1223,7 +1223,7 @@ package body Exp_Aggr is\n             Set_No_Ctrl_Actions (A);\n \n             --  If this is an aggregate for an array of arrays, each\n-            --  sub-aggregate will be expanded as well, and even with\n+            --  subaggregate will be expanded as well, and even with\n             --  No_Ctrl_Actions the assignments of inner components will\n             --  require attachment in their assignments to temporaries. These\n             --  temporaries must be finalized for each subaggregate, to prevent\n@@ -1282,7 +1282,7 @@ package body Exp_Aggr is\n             --  list associated with the scope.\n \n             --  If the component is itself an array of controlled types, whose\n-            --  value is given by a sub-aggregate, then the attach calls have\n+            --  value is given by a subaggregate, then the attach calls have\n             --  been generated when individual subcomponent are assigned, and\n             --  must not be done again to prevent malformed finalization chains\n             --  (see comments above, concerning the creation of a block to hold\n@@ -1632,9 +1632,9 @@ package body Exp_Aggr is\n \n       Aggr_L : constant Node_Id := Low_Bound (Aggregate_Bounds (N));\n       Aggr_H : constant Node_Id := High_Bound (Aggregate_Bounds (N));\n-      --  The aggregate bounds of this specific sub-aggregate. Note that if\n-      --  the code generated by Build_Array_Aggr_Code is executed then these\n-      --  bounds are OK. Otherwise a Constraint_Error would have been raised.\n+      --  The aggregate bounds of this specific subaggregate. Note that if the\n+      --  code generated by Build_Array_Aggr_Code is executed then these bounds\n+      --  are OK. Otherwise a Constraint_Error would have been raised.\n \n       Aggr_Low  : constant Node_Id := Duplicate_Subexpr_No_Checks (Aggr_L);\n       Aggr_High : constant Node_Id := Duplicate_Subexpr_No_Checks (Aggr_H);\n@@ -4114,7 +4114,7 @@ package body Exp_Aggr is\n          Analyze_And_Resolve (N, Typ);\n       end if;\n \n-      --  If Static_Eaboration_Desired has been specified, diagnose aggregates\n+      --  If Static_Elaboration_Desired has been specified, diagnose aggregates\n       --  that will still require initialization code.\n \n       if (Ekind (Current_Scope) = E_Package\n@@ -4213,8 +4213,8 @@ package body Exp_Aggr is\n \n       Others_Present : array (1 .. Aggr_Dimension) of Boolean :=\n         (others => False);\n-      --  If Others_Present (J) is True, then there is an others choice\n-      --  in one of the sub-aggregates of N at dimension J.\n+      --  If Others_Present (J) is True, then there is an others choice in one\n+      --  of the subaggregates of N at dimension J.\n \n       function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean;\n       --  Returns true if an aggregate assignment can be done by the back end\n@@ -4229,31 +4229,31 @@ package body Exp_Aggr is\n       --  by Index_Bounds.\n \n       procedure Check_Same_Aggr_Bounds (Sub_Aggr : Node_Id; Dim : Pos);\n-      --  Checks that in a multi-dimensional array aggregate all subaggregates\n-      --  corresponding to the same dimension have the same bounds.\n-      --  Sub_Aggr is an array sub-aggregate. Dim is the dimension\n-      --  corresponding to the sub-aggregate.\n+      --  Checks that in a multidimensional array aggregate all subaggregates\n+      --  corresponding to the same dimension have the same bounds. Sub_Aggr is\n+      --  an array subaggregate. Dim is the dimension corresponding to the\n+      --  subaggregate.\n \n       procedure Compute_Others_Present (Sub_Aggr : Node_Id; Dim : Pos);\n-      --  Computes the values of array Others_Present. Sub_Aggr is the\n-      --  array sub-aggregate we start the computation from. Dim is the\n-      --  dimension corresponding to the sub-aggregate.\n+      --  Computes the values of array Others_Present. Sub_Aggr is the array\n+      --  subaggregate we start the computation from. Dim is the dimension\n+      --  corresponding to the subaggregate.\n \n       function In_Place_Assign_OK return Boolean;\n       --  Simple predicate to determine whether an aggregate assignment can\n       --  be done in place, because none of the new values can depend on the\n       --  components of the target of the assignment.\n \n       procedure Others_Check (Sub_Aggr : Node_Id; Dim : Pos);\n-      --  Checks that if an others choice is present in any sub-aggregate no\n+      --  Checks that if an others choice is present in any subaggregate, no\n       --  aggregate index is outside the bounds of the index constraint.\n-      --  Sub_Aggr is an array sub-aggregate. Dim is the dimension\n-      --  corresponding to the sub-aggregate.\n+      --  Sub_Aggr is an array subaggregate. Dim is the dimension corresponding\n+      --  to the subaggregate.\n \n       function Safe_Left_Hand_Side (N : Node_Id) return Boolean;\n       --  In addition to Maybe_In_Place_OK, in order for an aggregate to be\n       --  built directly into the target of the assignment it must be free\n-      --  of side-effects.\n+      --  of side effects.\n \n       ------------------------------------\n       -- Aggr_Assignment_OK_For_Backend --\n@@ -4542,7 +4542,7 @@ package body Exp_Aggr is\n       procedure Check_Same_Aggr_Bounds (Sub_Aggr : Node_Id; Dim : Pos) is\n          Sub_Lo : constant Node_Id := Low_Bound (Aggregate_Bounds (Sub_Aggr));\n          Sub_Hi : constant Node_Id := High_Bound (Aggregate_Bounds (Sub_Aggr));\n-         --  The bounds of this specific sub-aggregate\n+         --  The bounds of this specific subaggregate\n \n          Aggr_Lo : constant Node_Id := Aggr_Low (Dim);\n          Aggr_Hi : constant Node_Id := Aggr_High (Dim);\n@@ -4606,7 +4606,7 @@ package body Exp_Aggr is\n                 Reason    => CE_Length_Check_Failed));\n          end if;\n \n-         --  Now look inside the sub-aggregate to see if there is more work\n+         --  Now look inside the subaggregate to see if there is more work\n \n          if Dim < Aggr_Dimension then\n \n@@ -4650,7 +4650,7 @@ package body Exp_Aggr is\n             end if;\n          end if;\n \n-         --  Now look inside the sub-aggregate to see if there is more work\n+         --  Now look inside the subaggregate to see if there is more work\n \n          if Dim < Aggr_Dimension then\n \n@@ -4690,8 +4690,8 @@ package body Exp_Aggr is\n          Obj_Hi  : Node_Id;\n \n          function Safe_Aggregate (Aggr : Node_Id) return Boolean;\n-         --  Check recursively that each component of a (sub)aggregate does\n-         --  not depend on the variable being assigned to.\n+         --  Check recursively that each component of a (sub)aggregate does not\n+         --  depend on the variable being assigned to.\n \n          function Safe_Component (Expr : Node_Id) return Boolean;\n          --  Verify that an expression cannot depend on the variable being\n@@ -4900,10 +4900,10 @@ package body Exp_Aggr is\n \n          Choices_Lo : Node_Id := Empty;\n          Choices_Hi : Node_Id := Empty;\n-         --  The lowest and highest discrete choices for a named sub-aggregate\n+         --  The lowest and highest discrete choices for a named subaggregate\n \n          Nb_Choices : Int := -1;\n-         --  The number of discrete non-others choices in this sub-aggregate\n+         --  The number of discrete non-others choices in this subaggregate\n \n          Nb_Elements : Uint := Uint_0;\n          --  The number of elements in a positional aggregate\n@@ -4916,7 +4916,7 @@ package body Exp_Aggr is\n \n       begin\n          --  Check if we have an others choice. If we do make sure that this\n-         --  sub-aggregate contains at least one element in addition to the\n+         --  subaggregate contains at least one element in addition to the\n          --  others choice.\n \n          if Range_Checks_Suppressed (Ind_Typ) then\n@@ -4960,7 +4960,7 @@ package body Exp_Aggr is\n             Need_To_Check := False;\n          end if;\n \n-         --  If we are dealing with a positional sub-aggregate with an others\n+         --  If we are dealing with a positional subaggregate with an others\n          --  choice then compute the number or positional elements.\n \n          if Need_To_Check and then Present (Expressions (Sub_Aggr)) then\n@@ -5013,7 +5013,7 @@ package body Exp_Aggr is\n             end Compute_Choices_Lo_And_Choices_Hi;\n          end if;\n \n-         --  If no others choice in this sub-aggregate, or the aggregate\n+         --  If no others choice in this subaggregate, or the aggregate\n          --  comprises only an others choice, nothing to do.\n \n          if not Need_To_Check then\n@@ -5078,7 +5078,7 @@ package body Exp_Aggr is\n             --  CE_Range_Check_Failed ???\n          end if;\n \n-         --  Now look inside the sub-aggregate to see if there is more work\n+         --  Now look inside the subaggregate to see if there is more work\n \n          if Dim < Aggr_Dimension then\n \n@@ -5112,7 +5112,7 @@ package body Exp_Aggr is\n       function Safe_Left_Hand_Side (N : Node_Id) return Boolean is\n          function Is_Safe_Index (Indx : Node_Id) return Boolean;\n          --  If the left-hand side includes an indexed component, check that\n-         --  the indexes are free of side-effect.\n+         --  the indexes are free of side effects.\n \n          -------------------\n          -- Is_Safe_Index --\n@@ -5238,17 +5238,17 @@ package body Exp_Aggr is\n          for J in 1 .. Aggr_Dimension loop\n             --  There is no need to emit a check if an others choice is present\n             --  for this array aggregate dimension since in this case one of\n-            --  N's sub-aggregates has taken its bounds from the context and\n+            --  N's subaggregates has taken its bounds from the context and\n             --  these bounds must have been checked already. In addition all\n-            --  sub-aggregates corresponding to the same dimension must all\n-            --  have the same bounds (checked in (c) below).\n+            --  subaggregates corresponding to the same dimension must all have\n+            --  the same bounds (checked in (c) below).\n \n             if not Range_Checks_Suppressed (Etype (Index_Constraint))\n               and then not Others_Present (J)\n             then\n                --  We don't use Checks.Apply_Range_Check here because it emits\n                --  a spurious check. Namely it checks that the range defined by\n-               --  the aggregate bounds is non empty. But we know this already\n+               --  the aggregate bounds is nonempty. But we know this already\n                --  if we get here.\n \n                Check_Bounds (Aggr_Index_Range, Index_Constraint);\n@@ -6024,8 +6024,7 @@ package body Exp_Aggr is\n                return True;\n \n             elsif Modify_Tree_For_C\n-              and then Nkind (C) in N_Entity\n-              and then Has_Per_Object_Constraint (C)\n+              and then Ekind (Etype (Expr_Q)) = E_String_Literal_Subtype\n             then\n                Static_Components := False;\n                return True;"}, {"sha": "29a4996d38cb22a46d1014405a7edfb2ed762f62", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74716b313b967b8a9406d86bae41d8843180505/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74716b313b967b8a9406d86bae41d8843180505/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d74716b313b967b8a9406d86bae41d8843180505", "patch": "@@ -12602,7 +12602,9 @@ package body Sem_Ch13 is\n       --  of references to the current entity, denote visible entities. This\n       --  is done only to detect visibility errors, as the expression will be\n       --  properly analyzed/expanded during analysis of the predicate function\n-      --  body.\n+      --  body. We omit quantified expressions from this test, given that they\n+      --  introduce a local identifier that would require proper expansion to\n+      --  handle properly.\n \n       ------------------\n       -- Resolve_Name --\n@@ -12622,6 +12624,9 @@ package body Sem_Ch13 is\n          elsif Nkind (N) = N_Identifier and then Chars (N) /= Chars (E) then\n             Find_Direct_Name (N);\n             Set_Entity (N, Empty);\n+\n+         elsif Nkind (N) = N_Quantified_Expression then\n+            return Skip;\n          end if;\n \n          return OK;"}]}