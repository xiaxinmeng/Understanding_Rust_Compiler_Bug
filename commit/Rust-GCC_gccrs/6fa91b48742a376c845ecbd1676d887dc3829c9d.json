{"sha": "6fa91b48742a376c845ecbd1676d887dc3829c9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhOTFiNDg3NDJhMzc2Yzg0NWVjYmQxNjc2ZDg4N2RjMzgyOWM5ZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-12-20T11:26:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-12-20T11:26:47Z"}, "message": "re PR middle-end/18191 (Struct member is not getting default-initialized)\n\ngcc/\n\tPR middle-end/18191\n\tPR middle-end/18965\n\tPR middle-end/18999\n\t* expr.c (categorize_ctor_elements_1): Count the total number\n\tof elements in the constructor.\n\t(categorize_ctor_elements): Return it in a new argument.\n\t* tree.h (categorize_ctor_elements): Adjust prototype.\n\t* gimplify.c (gimplify_init_ctor_eval_range): New.\n\t(gimplify_init_ctor_eval): Gimplify RANGE_EXPR.\n\t(gimplify_init_constructor): Block clear the object if the\n\tconstructor has fewer elements than the object type.  Only try\n\tto add assignments to individual elements when we have to.\n\ntestsuite/\n\t * gcc.dg/20041219-1.c: New test.\n\nCo-Authored-By: Andrew Pinski <pinskia@physics.uc.edu>\n\nFrom-SVN: r92415", "tree": {"sha": "9c25a2d0ac01a41629a94a7371f5c14a2e9e6fe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c25a2d0ac01a41629a94a7371f5c14a2e9e6fe0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa91b48742a376c845ecbd1676d887dc3829c9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa91b48742a376c845ecbd1676d887dc3829c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa91b48742a376c845ecbd1676d887dc3829c9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa91b48742a376c845ecbd1676d887dc3829c9d/comments", "author": null, "committer": null, "parents": [{"sha": "8f7e12f0dac20ed85fdb563070d3967c12f7ae3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7e12f0dac20ed85fdb563070d3967c12f7ae3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f7e12f0dac20ed85fdb563070d3967c12f7ae3e"}], "stats": {"total": 281, "additions": 234, "deletions": 47}, "files": [{"sha": "b8876afdfab252c7e787acd4c5dead9249316ab3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fa91b48742a376c845ecbd1676d887dc3829c9d", "patch": "@@ -1,3 +1,19 @@\n+2004-12-20  Steven Bosscher  <stevenb@suse.de>\n+\t    Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR middle-end/18191\n+\tPR middle-end/18965\n+\tPR middle-end/18999\n+\t* expr.c (categorize_ctor_elements_1): Count the total number\n+\tof elements in the constructor.\n+\t(categorize_ctor_elements): Return it in a new argument.\n+\t* tree.h (categorize_ctor_elements): Adjust prototype.\n+\t* gimplify.c (gimplify_init_ctor_eval_range): New.\n+\t(gimplify_init_ctor_eval): Gimplify RANGE_EXPR.\n+\t(gimplify_init_constructor): Block clear the object if the\n+\tconstructor has fewer elements than the object type.  Only try\n+\tto add assignments to individual elements when we have to.\n+\n 2004-12-20  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_init_mmx_sse_builtins): Use "}, {"sha": "de11afffe3f06e0d489d90cb63d681dc5ad293ca", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6fa91b48742a376c845ecbd1676d887dc3829c9d", "patch": "@@ -4220,19 +4220,25 @@ store_expr (tree exp, rtx target, int call_param_p)\n   return NULL_RTX;\n }\n \f\n-/* Examine CTOR.  Discover how many scalar fields are set to nonzero\n-   values and place it in *P_NZ_ELTS.  Discover how many scalar fields\n-   are set to non-constant values and place it in  *P_NC_ELTS.  */\n+/* Examine CTOR to discover:\n+   * how many scalar fields are set to nonzero values,\n+     and place it in *P_NZ_ELTS;\n+   * how many scalar fields are set to non-constant values,\n+     and place it in  *P_NC_ELTS; and\n+   * how many scalar fields in total are in CTOR,\n+     and place it in *P_ELT_COUNT.  */\n \n static void\n categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n-\t\t\t    HOST_WIDE_INT *p_nc_elts)\n+\t\t\t    HOST_WIDE_INT *p_nc_elts,\n+\t\t\t    HOST_WIDE_INT *p_elt_count)\n {\n-  HOST_WIDE_INT nz_elts, nc_elts;\n+  HOST_WIDE_INT nz_elts, nc_elts, elt_count;\n   tree list;\n \n   nz_elts = 0;\n   nc_elts = 0;\n+  elt_count = 0;\n \n   for (list = CONSTRUCTOR_ELTS (ctor); list; list = TREE_CHAIN (list))\n     {\n@@ -4255,41 +4261,49 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t{\n \tcase CONSTRUCTOR:\n \t  {\n-\t    HOST_WIDE_INT nz = 0, nc = 0;\n-\t    categorize_ctor_elements_1 (value, &nz, &nc);\n+\t    HOST_WIDE_INT nz = 0, nc = 0, count = 0;\n+\t    categorize_ctor_elements_1 (value, &nz, &nc, &count);\n \t    nz_elts += mult * nz;\n \t    nc_elts += mult * nc;\n+\t    elt_count += mult * count;\n \t  }\n \t  break;\n \n \tcase INTEGER_CST:\n \tcase REAL_CST:\n \t  if (!initializer_zerop (value))\n \t    nz_elts += mult;\n+\t  elt_count += mult;\n \t  break;\n \n \tcase STRING_CST:\n \t  nz_elts += mult * TREE_STRING_LENGTH (value);\n+\t  elt_count += mult * TREE_STRING_LENGTH (value);\n \t  break;\n \n \tcase COMPLEX_CST:\n \t  if (!initializer_zerop (TREE_REALPART (value)))\n \t    nz_elts += mult;\n \t  if (!initializer_zerop (TREE_IMAGPART (value)))\n \t    nz_elts += mult;\n+\t  elt_count += mult;\n \t  break;\n \n \tcase VECTOR_CST:\n \t  {\n \t    tree v;\n \t    for (v = TREE_VECTOR_CST_ELTS (value); v; v = TREE_CHAIN (v))\n-\t      if (!initializer_zerop (TREE_VALUE (v)))\n-\t        nz_elts += mult;\n+\t      {\n+\t\tif (!initializer_zerop (TREE_VALUE (v)))\n+\t\t  nz_elts += mult;\n+\t\telt_count += mult;\n+\t      }\n \t  }\n \t  break;\n \n \tdefault:\n \t  nz_elts += mult;\n+\t  elt_count += mult;\n \t  if (!initializer_constant_valid_p (value, TREE_TYPE (value)))\n \t    nc_elts += mult;\n \t  break;\n@@ -4298,15 +4312,18 @@ categorize_ctor_elements_1 (tree ctor, HOST_WIDE_INT *p_nz_elts,\n \n   *p_nz_elts += nz_elts;\n   *p_nc_elts += nc_elts;\n+  *p_elt_count += elt_count;\n }\n \n void\n categorize_ctor_elements (tree ctor, HOST_WIDE_INT *p_nz_elts,\n-\t\t\t  HOST_WIDE_INT *p_nc_elts)\n+\t\t\t  HOST_WIDE_INT *p_nc_elts,\n+\t\t\t  HOST_WIDE_INT *p_elt_count)\n {\n   *p_nz_elts = 0;\n   *p_nc_elts = 0;\n-  categorize_ctor_elements_1 (ctor, p_nz_elts, p_nc_elts);\n+  *p_elt_count = 0;\n+  categorize_ctor_elements_1 (ctor, p_nz_elts, p_nc_elts, p_elt_count);\n }\n \n /* Count the number of scalars in TYPE.  Return -1 on overflow or\n@@ -4395,9 +4412,9 @@ mostly_zeros_p (tree exp)\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n \n     {\n-      HOST_WIDE_INT nz_elts, nc_elts, elts;\n+      HOST_WIDE_INT nz_elts, nc_elts, count, elts;\n \n-      categorize_ctor_elements (exp, &nz_elts, &nc_elts);\n+      categorize_ctor_elements (exp, &nz_elts, &nc_elts, &count);\n       elts = count_type_elements (TREE_TYPE (exp));\n \n       return nz_elts < elts / 4;"}, {"sha": "34b22cc678175b70d83980868993afc1e20ab03a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 135, "deletions": 33, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6fa91b48742a376c845ecbd1676d887dc3829c9d", "patch": "@@ -2367,6 +2367,95 @@ gimplify_init_ctor_preeval (tree *expr_p, tree *pre_p, tree *post_p,\n   *expr_p = get_formal_tmp_var (*expr_p, pre_p);\n }\n \n+/* A subroutine of gimplify_init_ctor_eval.  Create a loop for\n+   a RANGE_EXPR in a CONSTRUCTOR for an array.\n+\n+      var = lower;\n+    loop_entry:\n+      object[var] = value;\n+      if (var == upper)\n+\tgoto loop_exit;\n+      var = var + 1;\n+      goto loop_entry;\n+    loop_exit:\n+\n+   We increment var _after_ the loop exit check because we might otherwise\n+   fail if upper == TYPE_MAX_VALUE (type for upper).\n+\n+   Note that we never have to deal with SAVE_EXPRs here, because this has\n+   already been taken care of for us, in gimplify_init_ctor_preeval().  */\n+\n+static void gimplify_init_ctor_eval (tree, tree, tree *, bool);\n+\n+static void\n+gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n+\t\t\t       tree value, tree array_elt_type,\n+\t\t\t       tree *pre_p, bool cleared)\n+{\n+  tree loop_entry_label, loop_exit_label;\n+  tree var, var_type, cref;\n+\n+  loop_entry_label = create_artificial_label ();\n+  loop_exit_label = create_artificial_label ();\n+\n+  /* Create and initialize the index variable.  */\n+  var_type = TREE_TYPE (upper);\n+  var = create_tmp_var (var_type, NULL);\n+  append_to_statement_list (build2 (MODIFY_EXPR, var_type, var, lower), pre_p);\n+\n+  /* Add the loop entry label.  */\n+  append_to_statement_list (build1 (LABEL_EXPR,\n+\t\t\t\t    void_type_node,\n+\t\t\t\t    loop_entry_label),\n+\t\t\t    pre_p);\n+\n+  /* Build the reference.  */\n+  cref = build4 (ARRAY_REF, array_elt_type, unshare_expr (object),\n+\t\t var, NULL_TREE, NULL_TREE);\n+\n+  /* If we are a constructor, just call gimplify_init_ctor_eval to do\n+     the store.  Otherwise just assign value to the reference.  */\n+\n+  if (TREE_CODE (value) == CONSTRUCTOR)\n+    /* NB we might have to call ourself recursively through\n+       gimplify_init_ctor_eval if the value is a constructor.  */\n+    gimplify_init_ctor_eval (cref, CONSTRUCTOR_ELTS (value),\n+\t\t\t     pre_p, cleared);\n+  else\n+    append_to_statement_list (build2 (MODIFY_EXPR, TREE_TYPE (cref),\n+\t\t\t\t      cref, value),\n+\t\t\t      pre_p);\n+\n+  /* We exit the loop when the index var is equal to the upper bound.  */\n+  gimplify_and_add (build3 (COND_EXPR, void_type_node,\n+\t\t\t    build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t    var, upper),\n+\t\t\t    build1 (GOTO_EXPR,\n+\t\t\t\t    void_type_node,\n+\t\t\t\t    loop_exit_label),\n+\t\t\t    NULL_TREE),\n+\t\t    pre_p);\n+\n+  /* Otherwise, increment the index var...  */\n+  append_to_statement_list (build2 (MODIFY_EXPR, var_type, var,\n+\t\t\t\t    build2 (PLUS_EXPR, var_type, var,\n+\t\t\t\t\t    fold_convert (var_type,\n+\t\t\t\t\t\t\t  integer_one_node))),\n+\t\t\t    pre_p);\n+\n+  /* ...and jump back to the loop entry.  */\n+  append_to_statement_list (build1 (GOTO_EXPR,\n+\t\t\t\t    void_type_node,\n+\t\t\t\t    loop_entry_label),\n+\t\t\t    pre_p);\n+\n+  /* Add the loop exit label.  */\n+  append_to_statement_list (build1 (LABEL_EXPR,\n+\t\t\t\t    void_type_node,\n+\t\t\t\t    loop_exit_label),\n+\t\t\t    pre_p);\n+}\n+\n /* A subroutine of gimplify_init_constructor.  Generate individual\n    MODIFY_EXPRs for a CONSTRUCTOR.  OBJECT is the LHS against which the\n    assignments should happen.  LIST is the CONSTRUCTOR_ELTS of the\n@@ -2395,14 +2484,31 @@ gimplify_init_ctor_eval (tree object, tree list, tree *pre_p, bool cleared)\n       if (cleared && initializer_zerop (value))\n \tcontinue;\n \n-      if (array_elt_type)\n+      /* ??? Here's to hoping the front end fills in all of the indices,\n+\t so we don't have to figure out what's missing ourselves.  */\n+      gcc_assert (purpose);\n+\n+      /* If we have a RANGE_EXPR, we have to build a loop to assign the\n+\t whole range.  */\n+      if (TREE_CODE (purpose) == RANGE_EXPR)\n \t{\n-\t  /* ??? Here's to hoping the front end fills in all of the indicies,\n-\t     so we don't have to figure out what's missing ourselves.  */\n-\t  gcc_assert (purpose);\n-\t  /* ??? Need to handle this.  */\n-\t  gcc_assert (TREE_CODE (purpose) != RANGE_EXPR);\n+\t  tree lower = TREE_OPERAND (purpose, 0);\n+\t  tree upper = TREE_OPERAND (purpose, 1);\n+\n+\t  /* If the lower bound is equal to upper, just treat it as if\n+\t     upper was the index.  */\n+\t  if (simple_cst_equal (lower, upper))\n+\t    purpose = upper;\n+\t  else\n+\t    {\n+\t      gimplify_init_ctor_eval_range (object, lower, upper, value,\n+\t\t\t\t\t     array_elt_type, pre_p, cleared);\n+\t      continue;\n+\t    }\n+\t}\n \n+      if (array_elt_type)\n+\t{\n \t  cref = build (ARRAY_REF, array_elt_type, unshare_expr (object),\n \t\t\tpurpose, NULL_TREE, NULL_TREE);\n \t}\n@@ -2458,8 +2564,8 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n     case ARRAY_TYPE:\n       {\n \tstruct gimplify_init_ctor_preeval_data preeval_data;\n-\tHOST_WIDE_INT num_elements, num_nonzero_elements;\n-\tHOST_WIDE_INT num_nonconstant_elements;\n+\tHOST_WIDE_INT num_type_elements, num_ctor_elements;\n+\tHOST_WIDE_INT num_nonzero_elements, num_nonconstant_elements;\n \tbool cleared;\n \n \t/* Aggregate types must lower constructors to initialization of\n@@ -2469,7 +2575,8 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t  break;\n \n \tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n-\t\t\t\t  &num_nonconstant_elements);\n+\t\t\t\t  &num_nonconstant_elements,\n+\t\t\t\t  &num_ctor_elements);\n \n \t/* If a const aggregate variable is being initialized, then it\n \t   should never be a lose to promote the variable to be static.  */\n@@ -2552,32 +2659,21 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t   parts in, then generate code for the non-constant parts.  */\n \t/* TODO.  There's code in cp/typeck.c to do this.  */\n \n-\tnum_elements = count_type_elements (TREE_TYPE (ctor));\n+\tnum_type_elements = count_type_elements (TREE_TYPE (ctor));\n \n \t/* If there are \"lots\" of zeros, then block clear the object first.  */\n \tcleared = false;\n-\tif (num_elements - num_nonzero_elements > CLEAR_RATIO\n-\t    && num_nonzero_elements < num_elements/4)\n+\tif (num_type_elements - num_nonzero_elements > CLEAR_RATIO\n+\t    && num_nonzero_elements < num_type_elements/4)\n \t  cleared = true;\n \n \t/* ??? This bit ought not be needed.  For any element not present\n \t   in the initializer, we should simply set them to zero.  Except\n \t   we'd need to *find* the elements that are not present, and that\n \t   requires trickery to avoid quadratic compile-time behavior in\n \t   large cases or excessive memory use in small cases.  */\n-\telse\n-\t  {\n-\t    HOST_WIDE_INT len = list_length (elt_list);\n-\t    if (TREE_CODE (type) == ARRAY_TYPE)\n-\t      {\n-\t\ttree nelts = array_type_nelts (type);\n-\t\tif (!host_integerp (nelts, 1)\n-\t\t    || tree_low_cst (nelts, 1) + 1 != len)\n-\t\t  cleared = true;\n-\t      }\n-\t    else if (len != fields_length (type))\n-\t      cleared = true;\n-\t  }\n+\telse if (num_ctor_elements < num_type_elements)\n+\t  cleared = true;\n \n \tif (cleared)\n \t  {\n@@ -2590,14 +2686,20 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    append_to_statement_list (*expr_p, pre_p);\n \t  }\n \n-\tpreeval_data.lhs_base_decl = get_base_address (object);\n-\tif (!DECL_P (preeval_data.lhs_base_decl))\n-\t  preeval_data.lhs_base_decl = NULL;\n-\tpreeval_data.lhs_alias_set = get_alias_set (object);\n-\n-\tgimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),\n-\t\t\t\t    pre_p, post_p, &preeval_data);\n-\tgimplify_init_ctor_eval (object, elt_list, pre_p, cleared);\n+\t/* If we have not block cleared the object, or if there are nonzero\n+\t   elements in the constructor, add assignments to the individual\n+\t   scalar fields of the object.  */\n+\tif (!cleared || num_nonzero_elements > 0)\n+\t  {\n+\t    preeval_data.lhs_base_decl = get_base_address (object);\n+\t    if (!DECL_P (preeval_data.lhs_base_decl))\n+\t      preeval_data.lhs_base_decl = NULL;\n+\t    preeval_data.lhs_alias_set = get_alias_set (object);\n+\n+\t    gimplify_init_ctor_preeval (&TREE_OPERAND (*expr_p, 1),\n+\t\t\t\t\tpre_p, post_p, &preeval_data);\n+\t    gimplify_init_ctor_eval (object, elt_list, pre_p, cleared);\n+\t  }\n \n \t*expr_p = NULL_TREE;\n       }"}, {"sha": "c1c21c400ab9ab487a4e01a08582d225aa41e163", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fa91b48742a376c845ecbd1676d887dc3829c9d", "patch": "@@ -1,3 +1,7 @@\n+2004-12-20  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* gcc.dg/20041219-1.c: New test.\n+\n 2004-12-19  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/19068"}, {"sha": "4fdc9540d51ac36d355600038040e8da7eac3b03", "filename": "gcc/testsuite/gcc.dg/20041219-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Ftestsuite%2Fgcc.dg%2F20041219-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Ftestsuite%2Fgcc.dg%2F20041219-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20041219-1.c?ref=6fa91b48742a376c845ecbd1676d887dc3829c9d", "patch": "@@ -0,0 +1,47 @@\n+/* PR18191 Struct member is not getting default-initialized.\n+   Origin: Grigory Zagorodnev  <grigory.zagorodnev@intel.com>  */\n+\n+/* { dg-do run } */\n+\n+extern int printf (__const char *__restrict __format, ...);\n+\n+typedef struct S {\n+  const char* s;\n+  int         i;\n+} S;\n+\n+void\n+foo (void)\n+{\n+  S dummy[2];\n+  unsigned i;\n+\n+  /* Put some garbage on the stack.  */\n+  for (i = 0; i < sizeof(dummy); i++)\n+    ((char *)&dummy)[i] = -1;\n+}\n+\n+int\n+bar (void)\n+{\n+  /* Allocate object on the stack.  */\n+  S obj[2] = { {\"m0\"}, {\"m1\"} };\n+\n+  /* Assume fields those not explicitly initialized\n+     are default initialized to 0 [8.5.1/7 and 8.5/5].  */\n+  if (obj[0].i == 0)\n+    return 0;\n+  else\n+    {\n+      printf(\"Failed: obj[0].i == '%d', expecting '0'\\n\", obj[0].i);\n+      return 1;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  foo();\n+  return bar();\n+}\n+"}, {"sha": "90d17e5cc41ce992d3064a37588534ddf74fda9d", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa91b48742a376c845ecbd1676d887dc3829c9d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6fa91b48742a376c845ecbd1676d887dc3829c9d", "patch": "@@ -3226,7 +3226,8 @@ extern int fields_length (tree);\n \n extern bool initializer_zerop (tree);\n \n-extern void categorize_ctor_elements (tree, HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern void categorize_ctor_elements (tree, HOST_WIDE_INT *,\n+\t\t\t\t      HOST_WIDE_INT *, HOST_WIDE_INT *);\n extern HOST_WIDE_INT count_type_elements (tree);\n \n /* add_var_to_bind_expr (bind_expr, var) binds var to bind_expr.  */"}]}