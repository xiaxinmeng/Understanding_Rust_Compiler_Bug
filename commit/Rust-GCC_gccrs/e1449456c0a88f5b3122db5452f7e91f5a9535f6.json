{"sha": "e1449456c0a88f5b3122db5452f7e91f5a9535f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE0NDk0NTZjMGE4OGY1YjMxMjJkYjU0NTJmN2U5MWY1YTk1MzVmNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-05-26T16:46:59Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-05-26T16:46:59Z"}, "message": "Reorganize the analysis of basic block predication.\n\n2010-05-26  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-if-conv.c (add_to_dst_predicate_list): Do not pass a statemet\n\titerator in parameter.  Do not generate code during the analysis.\n\t(tree_if_convert_cond_stmt): Removed.\n\t(tree_if_convert_stmt): Removed.\n\t(predicate_bbs): New.\n\t(if_convertible_loop_p): Call predicate_bbs.\n\t(tree_if_conversion): Simplify the top-level logic as predicate_bbs\n\tnow contains all the analysis part.\n\nFrom-SVN: r159886", "tree": {"sha": "4125a7ce634951430f71f1dd0fd39dc48e9795f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4125a7ce634951430f71f1dd0fd39dc48e9795f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1449456c0a88f5b3122db5452f7e91f5a9535f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1449456c0a88f5b3122db5452f7e91f5a9535f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1449456c0a88f5b3122db5452f7e91f5a9535f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1449456c0a88f5b3122db5452f7e91f5a9535f6/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76b8477663ca9d034979fa5aeaae429f10e64827", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b8477663ca9d034979fa5aeaae429f10e64827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b8477663ca9d034979fa5aeaae429f10e64827"}], "stats": {"total": 324, "additions": 161, "deletions": 163}, "files": [{"sha": "ed863df906ceeba55c9452fc8d0b3d79cce61149", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1449456c0a88f5b3122db5452f7e91f5a9535f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1449456c0a88f5b3122db5452f7e91f5a9535f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1449456c0a88f5b3122db5452f7e91f5a9535f6", "patch": "@@ -1,3 +1,14 @@\n+2010-05-26  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-if-conv.c (add_to_dst_predicate_list): Do not pass a statemet\n+\titerator in parameter.  Do not generate code during the analysis.\n+\t(tree_if_convert_cond_stmt): Removed.\n+\t(tree_if_convert_stmt): Removed.\n+\t(predicate_bbs): New.\n+\t(if_convertible_loop_p): Call predicate_bbs.\n+\t(tree_if_conversion): Simplify the top-level logic as predicate_bbs\n+\tnow contains all the analysis part.\n+\n 2010-05-26  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-if-conv.c (tree_if_convert_cond_stmt): Do not remove"}, {"sha": "da6b1cde27aa57a1de61df7c3443179d146d6de7", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 150, "deletions": 163, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1449456c0a88f5b3122db5452f7e91f5a9535f6/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1449456c0a88f5b3122db5452f7e91f5a9535f6/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=e1449456c0a88f5b3122db5452f7e91f5a9535f6", "patch": "@@ -147,15 +147,13 @@ add_to_predicate_list (basic_block bb, tree new_cond)\n   bb->aux = cond;\n }\n \n-/* Add the condition COND to the previous condition PREV_COND, and add this\n-   to the predicate list of the destination of edge E.  GSI is the\n-   place where the gimplification of the resulting condition should\n-   output code.  LOOP is the loop to be if-converted.  */\n+/* Add the condition COND to the previous condition PREV_COND, and add\n+   this to the predicate list of the destination of edge E.  LOOP is\n+   the loop to be if-converted.  */\n \n static tree\n add_to_dst_predicate_list (struct loop *loop, edge e,\n-\t\t\t   tree prev_cond, tree cond,\n-\t\t\t   gimple_stmt_iterator *gsi)\n+\t\t\t   tree prev_cond, tree cond)\n {\n   tree new_cond = NULL_TREE;\n \n@@ -166,25 +164,13 @@ add_to_dst_predicate_list (struct loop *loop, edge e,\n     new_cond = unshare_expr (cond);\n   else\n     {\n-      tree tmp;\n-      gimple tmp_stmt = NULL;\n-\n-      prev_cond = force_gimple_operand_gsi (gsi, unshare_expr (prev_cond),\n-\t\t\t\t\t    true, NULL, true, GSI_SAME_STMT);\n-\n-      cond = force_gimple_operand_gsi (gsi, unshare_expr (cond),\n-\t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n-\n       /* Add the condition COND to the e->aux field.  In case the edge\n \t destination is a PHI node, this condition will be added to\n \t the block predicate to construct a complete condition.  */\n       e->aux = cond;\n \n-      tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t    unshare_expr (prev_cond), cond);\n-      tmp_stmt = ifc_temp_var (boolean_type_node, tmp);\n-      gsi_insert_before (gsi, tmp_stmt, GSI_SAME_STMT);\n-      new_cond = gimple_assign_lhs (tmp_stmt);\n+      new_cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t      unshare_expr (prev_cond), cond);\n     }\n \n   add_to_predicate_list (e->dest, new_cond);\n@@ -206,84 +192,6 @@ bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n   return false;\n }\n \n-/* STMT is a GIMPLE_COND.  Update two destination's predicate list.\n-   Otherwise update the exit condition of LOOP appropriately.  GSI\n-   points to the statement STMT.  */\n-\n-static void\n-tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n-\t\t\t   gimple_stmt_iterator *gsi)\n-{\n-  tree c2;\n-  edge true_edge, false_edge;\n-  location_t loc = gimple_location (stmt);\n-  tree c = fold_build2_loc (loc, gimple_cond_code (stmt), boolean_type_node,\n-\t\t\t    gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n-\n-  extract_true_false_edges_from_block (gimple_bb (stmt),\n- \t\t\t\t       &true_edge, &false_edge);\n-\n-  /* Add new condition into destination's predicate list.  */\n-\n-  /* If C is true, then TRUE_EDGE is taken.  */\n-  add_to_dst_predicate_list (loop, true_edge, cond, c, gsi);\n-\n-  /* If C is false, then FALSE_EDGE is taken.  */\n-  c2 = invert_truthvalue_loc (loc, unshare_expr (c));\n-  add_to_dst_predicate_list (loop, false_edge, cond, c2, gsi);\n-}\n-\n-/* If-convert stmt T which is part of LOOP.\n-\n-   For conditional expressions, add a condition in the destination\n-   basic block's predicate list.  GSI points to the statement T.  */\n-\n-static tree\n-tree_if_convert_stmt (struct loop *loop, gimple t, tree cond,\n-\t\t      gimple_stmt_iterator *gsi)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"------if-convert stmt\\n\");\n-      print_gimple_stmt (dump_file, t, 0, TDF_SLIM);\n-      print_generic_stmt (dump_file, cond, TDF_SLIM);\n-    }\n-\n-  switch (gimple_code (t))\n-    {\n-      /* Labels are harmless here.  */\n-    case GIMPLE_LABEL:\n-      break;\n-\n-    case GIMPLE_DEBUG:\n-      /* ??? Should there be conditional GIMPLE_DEBUG_BINDs?  */\n-      if (gimple_debug_bind_p (gsi_stmt (*gsi)))\n-\t{\n-\t  gimple_debug_bind_reset_value (gsi_stmt (*gsi));\n-\t  update_stmt (gsi_stmt (*gsi));\n-\t}\n-      break;\n-\n-    case GIMPLE_ASSIGN:\n-      /* This GIMPLE_ASSIGN is killing previous value of LHS.  Appropriate\n-\t value will be selected by PHI node based on condition.  It is possible\n-\t that before this transformation, PHI nodes was selecting default\n-\t value and now it will use this new value.  This is OK because it does\n-\t not change the validity of the program.  */\n-      break;\n-\n-    case GIMPLE_COND:\n-      tree_if_convert_cond_stmt (loop, t, cond, gsi);\n-      cond = NULL_TREE;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return cond;\n-}\n-\n /* Return true when PHI is if-convertible.  PHI is part of loop LOOP\n    and it belongs to basic block BB.\n \n@@ -560,6 +468,126 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   return blocks;\n }\n \n+/* Returns true when the analysis of the predicates for all the basic\n+   blocks in LOOP succeeded.\n+\n+   predicate_bbs first clears the ->aux fields of the edges and basic\n+   blocks.  These fields are then initialized with the tree\n+   expressions representing the predicates under which a basic block\n+   is executed in the LOOP.  As the loop->header is executed at each\n+   iteration, it has the \"true\" predicate.  Other statements executed\n+   under a condition are predicated with that condition, for example\n+\n+   | if (x)\n+   |   S1;\n+   | else\n+   |   S2;\n+\n+   S1 will be predicated with \"x\", and S2 will be predicated with\n+   \"!x\".  */\n+\n+static bool\n+predicate_bbs (loop_p loop)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      basic_block bb = ifc_bbs [i];\n+      gimple_stmt_iterator itr = gsi_start_phis (bb);\n+\n+      if (!gsi_end_p (itr))\n+\tFOR_EACH_EDGE (e, ei, bb->preds)\n+\t  e->aux = NULL;\n+\n+      bb->aux = NULL;\n+    }\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = ifc_bbs [i];\n+      tree cond = (tree) bb->aux;\n+      gimple_stmt_iterator itr;\n+\n+      for (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n+\t{\n+\t  gimple stmt = gsi_stmt (itr);\n+\n+\t  switch (gimple_code (stmt))\n+\t    {\n+\t    case GIMPLE_LABEL:\n+\t    case GIMPLE_ASSIGN:\n+\t    case GIMPLE_CALL:\n+\t      break;\n+\n+\t    case GIMPLE_DEBUG:\n+\t      /* ??? Should there be conditional GIMPLE_DEBUG_BINDs?  */\n+\t      if (gimple_debug_bind_p (gsi_stmt (itr)))\n+\t\t{\n+\t\t  gimple_debug_bind_reset_value (gsi_stmt (itr));\n+\t\t  update_stmt (gsi_stmt (itr));\n+\t\t}\n+\t      break;\n+\n+\t    case GIMPLE_COND:\n+\t      {\n+\t\ttree c2;\n+\t\tedge true_edge, false_edge;\n+\t\tlocation_t loc = gimple_location (stmt);\n+\t\ttree c = fold_build2_loc (loc, gimple_cond_code (stmt),\n+\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  gimple_cond_lhs (stmt),\n+\t\t\t\t\t  gimple_cond_rhs (stmt));\n+\n+\t\textract_true_false_edges_from_block (gimple_bb (stmt),\n+\t\t\t\t\t\t     &true_edge, &false_edge);\n+\n+\t\t/* Add new condition into destination's predicate list.  */\n+\n+\t\t/* If C is true, then TRUE_EDGE is taken.  */\n+\t\tadd_to_dst_predicate_list (loop, true_edge, cond, c);\n+\n+\t\t/* If C is false, then FALSE_EDGE is taken.  */\n+\t\tc2 = invert_truthvalue_loc (loc, unshare_expr (c));\n+\t\tadd_to_dst_predicate_list (loop, false_edge, cond, c2);\n+\n+\t\tcond = NULL_TREE;\n+\t\tbreak;\n+\t      }\n+\n+\t    case GIMPLE_SWITCH:\n+\t      /* Not handled yet in if-conversion.  */\n+\t      return false;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      /* If current bb has only one successor, then consider it as an\n+\t unconditional goto.  */\n+      if (single_succ_p (bb))\n+\t{\n+\t  basic_block bb_n = single_succ (bb);\n+\n+\t  /* The successor bb inherits the predicate of its\n+\t     predecessor.  If there is no predicate in the predecessor\n+\t     bb, then consider the successor bb as always executed.  */\n+\t  if (cond == NULL_TREE)\n+\t    cond = boolean_true_node;\n+\n+\t  add_to_predicate_list (bb_n, cond);\n+\t}\n+    }\n+\n+  /* The loop header is always executed.  */\n+  loop->header->aux = boolean_true_node;\n+\n+  return true;\n+}\n+\n /* Return true when LOOP is if-convertible.\n    LOOP is if-convertible if:\n    - it is innermost,\n@@ -571,8 +599,6 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n static bool\n if_convertible_loop_p (struct loop *loop)\n {\n-  basic_block bb;\n-  gimple_stmt_iterator itr;\n   unsigned int i;\n   edge e;\n   edge_iterator ei;\n@@ -639,27 +665,30 @@ if_convertible_loop_p (struct loop *loop)\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      bb = ifc_bbs[i];\n+      basic_block bb = ifc_bbs[i];\n \n       if (!if_convertible_bb_p (loop, bb, exit_bb))\n \treturn false;\n \n+      if (bb_with_exit_edge_p (loop, bb))\n+\texit_bb = bb;\n+    }\n+\n+  if (!predicate_bbs (loop))\n+    return false;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = ifc_bbs[i];\n+      gimple_stmt_iterator itr;\n+\n       for (itr = gsi_start_bb (bb); !gsi_end_p (itr); gsi_next (&itr))\n \tif (!if_convertible_stmt_p (loop, bb, gsi_stmt (itr)))\n \t  return false;\n \n-      itr = gsi_start_phis (bb);\n-\n-      if (!gsi_end_p (itr))\n-\tFOR_EACH_EDGE (e, ei, bb->preds)\n-\t  e->aux = NULL;\n-\n-      for (; !gsi_end_p (itr); gsi_next (&itr))\n+      for (itr = gsi_start_phis (bb); !gsi_end_p (itr); gsi_next (&itr))\n \tif (!if_convertible_phi_p (loop, bb, gsi_stmt (itr)))\n \t  return false;\n-\n-      if (bb_with_exit_edge_p (loop, bb))\n-\texit_bb = bb;\n     }\n \n   if (dump_file)\n@@ -1030,65 +1059,23 @@ combine_blocks (struct loop *loop)\n static void\n tree_if_conversion (struct loop *loop)\n {\n-  gimple_stmt_iterator itr;\n-  unsigned int i;\n-\n   ifc_bbs = NULL;\n \n-  /* If-conversion is not appropriate for all loops.  First, check if\n-     the loop is if-convertible.  */\n   if (!if_convertible_loop_p (loop))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"-------------------------\\n\");\n-      if (ifc_bbs)\n-\t{\n-\t  free (ifc_bbs);\n-\t  ifc_bbs = NULL;\n-\t}\n-      return;\n-    }\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block bb = ifc_bbs [i];\n-      tree cond = (tree) bb->aux;\n-\n-      /* Predicate basic block(s) with the condition expressions\n-\t leading to their execution.  */\n-      for (itr = gsi_start_bb (bb); !gsi_end_p (itr); /* empty */)\n-\t{\n-\t  gimple t = gsi_stmt (itr);\n-\t  cond = tree_if_convert_stmt (loop, t, cond, &itr);\n-\t  if (!gsi_end_p (itr))\n-\t    gsi_next (&itr);\n-\t}\n-\n-      /* If current bb has only one successor, then consider it as an\n-\t unconditional goto.  */\n-      if (single_succ_p (bb))\n-\t{\n-\t  basic_block bb_n = single_succ (bb);\n-\n-\t  /* The successor bb inherits the predicate of its\n-\t     predecessor.  If there is no predicate in the predecessor\n-\t     bb, then consider the successor bb as always executed.  */\n-\t  if (cond == NULL_TREE)\n-\t    cond = boolean_true_node;\n+    goto cleanup;\n \n-\t  add_to_predicate_list (bb_n, cond);\n-\t}\n-    }\n-\n-  /* Now, all statements are if-converted and basic blocks are\n-     annotated appropriately.  Combine all the basic blocks into one\n-     huge basic block.  */\n+  /* Now all statements are if-convertible.  Combine all the basic\n+     blocks into one huge basic block doing the if-conversion\n+     on-the-fly.  */\n   combine_blocks (loop);\n \n-  /* clean up */\n+ cleanup:\n   clean_predicate_lists (loop);\n-  free (ifc_bbs);\n-  ifc_bbs = NULL;\n+  if (ifc_bbs)\n+    {\n+      free (ifc_bbs);\n+      ifc_bbs = NULL;\n+    }\n }\n \n /* Tree if-conversion pass management.  */"}]}