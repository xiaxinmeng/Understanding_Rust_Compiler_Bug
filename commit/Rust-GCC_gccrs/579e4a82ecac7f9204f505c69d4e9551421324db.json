{"sha": "579e4a82ecac7f9204f505c69d4e9551421324db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5ZTRhODJlY2FjN2Y5MjA0ZjUwNWM2OWQ0ZTk1NTE0MjEzMjRkYg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-06-04T22:05:35Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-06-04T22:05:35Z"}, "message": "reg-stack.c (struct block_info_def): Correct grammar typo.\n\n\n\t* reg-stack.c (struct block_info_def): Correct grammar typo.\n\t(compensate_edge): Clean-up.  Perform as little work as possible\n\twhen src and dest stacks match.  Avoid modifying block_info.\n\tReorder and simplify assertion checks.  Avoid unnecessary copying\n\tof regstack structure.\n\t(convert_regs_1): Set the done flag here...\n\t(convert_regs_2): ... instead of here.\n\nFrom-SVN: r100602", "tree": {"sha": "8335f5fc6555b2980dc3a9d65b5fd1347670edd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8335f5fc6555b2980dc3a9d65b5fd1347670edd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/579e4a82ecac7f9204f505c69d4e9551421324db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579e4a82ecac7f9204f505c69d4e9551421324db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579e4a82ecac7f9204f505c69d4e9551421324db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579e4a82ecac7f9204f505c69d4e9551421324db/comments", "author": null, "committer": null, "parents": [{"sha": "6d0a809119630fb9f86f9a88d0d3c64f57a50fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0a809119630fb9f86f9a88d0d3c64f57a50fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d0a809119630fb9f86f9a88d0d3c64f57a50fc9"}], "stats": {"total": 92, "additions": 44, "deletions": 48}, "files": [{"sha": "df16d2a2c85f4ea520ace5ea032b52fcd040c486", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579e4a82ecac7f9204f505c69d4e9551421324db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579e4a82ecac7f9204f505c69d4e9551421324db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=579e4a82ecac7f9204f505c69d4e9551421324db", "patch": "@@ -1,3 +1,13 @@\n+2005-06-04  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* reg-stack.c (struct block_info_def): Correct grammar typo.\n+\t(compensate_edge): Clean-up.  Perform as little work as possible\n+\twhen src and dest stacks match.  Avoid modifying block_info.\n+\tReorder and simplify assertion checks.  Avoid unnecessary copying\n+\tof regstack structure.\n+\t(convert_regs_1): Set the done flag here...\n+\t(convert_regs_2): ... instead of here.\n+\n 2005-06-04  Dale Johannesen  <dalej@apple.com>\n \n \t* config/rs6000/rs6000.c (no_global_regs_above): New."}, {"sha": "7007fcb2bd6034a8d85b36b3698f8cedc9834b25", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/579e4a82ecac7f9204f505c69d4e9551421324db/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/579e4a82ecac7f9204f505c69d4e9551421324db/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=579e4a82ecac7f9204f505c69d4e9551421324db", "patch": "@@ -208,7 +208,7 @@ typedef struct block_info_def\n   struct stack_def stack_out;\t/* Output stack configuration.  */\n   HARD_REG_SET out_reg_set;\t/* Stack regs live on output.  */\n   int done;\t\t\t/* True if block already converted.  */\n-  int predecessors;\t\t/* Number of predecessors that needs\n+  int predecessors;\t\t/* Number of predecessors that need\n \t\t\t\t   to be visited.  */\n } *block_info;\n \n@@ -2629,24 +2629,22 @@ propagate_stack (edge e)\n static bool\n compensate_edge (edge e, FILE *file)\n {\n-  basic_block block = e->src, target = e->dest;\n-  block_info bi = BLOCK_INFO (block);\n-  struct stack_def regstack, tmpstack;\n+  basic_block source = e->src, target = e->dest;\n   stack target_stack = &BLOCK_INFO (target)->stack_in;\n+  stack source_stack = &BLOCK_INFO (source)->stack_out;\n+  struct stack_def regstack;\n   int reg;\n \n-  current_block = block;\n-  regstack = bi->stack_out;\n   if (file)\n-    fprintf (file, \"Edge %d->%d: \", block->index, target->index);\n+    fprintf (file, \"Edge %d->%d: \", source->index, target->index);\n \n   gcc_assert (target_stack->top != -2);\n \n   /* Check whether stacks are identical.  */\n-  if (target_stack->top == regstack.top)\n+  if (target_stack->top == source_stack->top)\n     {\n       for (reg = target_stack->top; reg >= 0; --reg)\n-\tif (target_stack->reg[reg] != regstack.reg[reg])\n+\tif (target_stack->reg[reg] != source_stack->reg[reg])\n \t  break;\n \n       if (reg == -1)\n@@ -2663,68 +2661,56 @@ compensate_edge (edge e, FILE *file)\n       print_stack (file, target_stack);\n     }\n \n-  /* Care for non-call EH edges specially.  The normal return path have\n-     values in registers.  These will be popped en masse by the unwind\n-     library.  */\n-  if ((e->flags & (EDGE_EH | EDGE_ABNORMAL_CALL)) == EDGE_EH)\n-    target_stack->top = -1;\n-\n-  /* Other calls may appear to have values live in st(0), but the\n+  /* Abnormal calls may appear to have values live in st(0), but the\n      abnormal return path will not have actually loaded the values.  */\n-  else if (e->flags & EDGE_ABNORMAL_CALL)\n+  if (e->flags & EDGE_ABNORMAL_CALL)\n     {\n       /* Assert that the lifetimes are as we expect -- one value\n          live at st(0) on the end of the source block, and no\n          values live at the beginning of the destination block.  */\n-      HARD_REG_SET tmp;\n-\n-      CLEAR_HARD_REG_SET (tmp);\n-      GO_IF_HARD_REG_EQUAL (target_stack->reg_set, tmp, eh1);\n-      gcc_unreachable ();\n-    eh1:\n-\n-      /* We are sure that there is st(0) live, otherwise we won't compensate.\n-\t For complex return values, we may have st(1) live as well.  */\n-      SET_HARD_REG_BIT (tmp, FIRST_STACK_REG);\n-      if (TEST_HARD_REG_BIT (regstack.reg_set, FIRST_STACK_REG + 1))\n-        SET_HARD_REG_BIT (tmp, FIRST_STACK_REG + 1);\n-      GO_IF_HARD_REG_EQUAL (regstack.reg_set, tmp, eh2);\n-      gcc_unreachable ();\n-    eh2:\n+      gcc_assert (source_stack->top == 0);\n+      gcc_assert (target_stack->top == -1);\n+      return false;\n+    }\n \n-      target_stack->top = -1;\n+  /* Handle non-call EH edges specially.  The normal return path have\n+     values in registers.  These will be popped en masse by the unwind\n+     library.  */\n+  if (e->flags & EDGE_EH)\n+    {\n+      gcc_assert (target_stack->top == -1);\n+      return false;\n     }\n \n+  /* We don't support abnormal edges.  Global takes care to\n+     avoid any live register across them, so we should never\n+     have to insert instructions on such edges.  */\n+  gcc_assert (! (e->flags & EDGE_ABNORMAL));\n+\n+  /* Make a copy of source_stack as change_stack is destructive.  */\n+  regstack = *source_stack;\n+\n   /* It is better to output directly to the end of the block\n      instead of to the edge, because emit_swap can do minimal\n      insn scheduling.  We can do this when there is only one\n      edge out, and it is not abnormal.  */\n-  else if (EDGE_COUNT (block->succs) == 1 && !(e->flags & EDGE_ABNORMAL))\n+  if (EDGE_COUNT (source->succs) == 1)\n     {\n-      /* change_stack kills values in regstack.  */\n-      tmpstack = regstack;\n-\n-      change_stack (BB_END (block), &tmpstack, target_stack,\n-\t\t    (JUMP_P (BB_END (block))\n-\t\t     ? EMIT_BEFORE : EMIT_AFTER));\n+      current_block = source;\n+      change_stack (BB_END (source), &regstack, target_stack,\n+\t\t    (JUMP_P (BB_END (source)) ? EMIT_BEFORE : EMIT_AFTER));\n     }\n   else\n     {\n       rtx seq, after;\n \n-      /* We don't support abnormal edges.  Global takes care to\n-         avoid any live register across them, so we should never\n-         have to insert instructions on such edges.  */\n-      gcc_assert (!(e->flags & EDGE_ABNORMAL));\n-\n       current_block = NULL;\n       start_sequence ();\n \n       /* ??? change_stack needs some point to emit insns after.  */\n       after = emit_note (NOTE_INSN_DELETED);\n \n-      tmpstack = regstack;\n-      change_stack (after, &tmpstack, target_stack, EMIT_BEFORE);\n+      change_stack (after, &regstack, target_stack, EMIT_BEFORE);\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -2928,6 +2914,7 @@ convert_regs_1 (FILE *file, basic_block block)\n   gcc_assert (any_malformed_asm);\n  win:\n   bi->stack_out = regstack;\n+  bi->done = true;\n }\n \n /* Convert registers in all blocks reachable from BLOCK.  */\n@@ -2975,7 +2962,6 @@ convert_regs_2 (FILE *file, basic_block block)\n \t  }\n \n       convert_regs_1 (file, block);\n-      BLOCK_INFO (block)->done = 1;\n     }\n   while (sp != stack);\n "}]}