{"sha": "f02392c8b378a68fb2525098a41a90bd16faa7fd", "node_id": "C_kwDOANBUbNoAKGYwMjM5MmM4YjM3OGE2OGZiMjUyNTA5OGE0MWE5MGJkMTZmYWE3ZmQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-07T17:19:01Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-11T08:21:29Z"}, "message": "macros: Replace macro invocations with expanded nodes\n\nDifferent parsing functions need to be called based on the context\nsurrounding the macro invocation. This commit adds a flowchart trying to\nexplain the base resolving rules\n\nMacro expansion happens at the same level as stripping, where nodes\nmight get removed if they are gated behind an unmet predicate. We also\nperform macro expansion during this visitor's pass.\n\nWhat we can do is thus to replace macro invocations with new items that\nmight have resulted from macro expansion: Since we're already mutating\nnumerous elements by removing them if they should be stripped, we can\nalso add elements if they should be expanded.\n\nThis commit also \"fixes\" macro test cases so that they are now accepted\nby the new parser, which is more strict than it should for now.\n\nCo-authored-by: SimplyTheOther <simplytheother@gmail.com>\nCo-authored-by: philberty <philip.herron@embecosm.com>", "tree": {"sha": "5ed1ad4ae2afdde2a1a92644ea39802a3971b197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ed1ad4ae2afdde2a1a92644ea39802a3971b197"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f02392c8b378a68fb2525098a41a90bd16faa7fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02392c8b378a68fb2525098a41a90bd16faa7fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f02392c8b378a68fb2525098a41a90bd16faa7fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02392c8b378a68fb2525098a41a90bd16faa7fd/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c04258300be68a36b80f2f23929a97e8af1865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c04258300be68a36b80f2f23929a97e8af1865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c04258300be68a36b80f2f23929a97e8af1865"}], "stats": {"total": 730, "additions": 475, "deletions": 255}, "files": [{"sha": "d07501eba693d385bd20df7885c32e9b745e6a54", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 105, "deletions": 14, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -1491,21 +1491,21 @@ class SingleASTNode\n   };\n \n   SingleASTNode (std::unique_ptr<Expr> expr)\n-    : type (EXPRESSION), expr (std::move (expr)), item (nullptr), stmt (nullptr)\n+    : kind (EXPRESSION), expr (std::move (expr)), item (nullptr), stmt (nullptr)\n   {}\n \n   SingleASTNode (std::unique_ptr<Item> item)\n-    : type (ITEM), expr (nullptr), item (std::move (item)), stmt (nullptr)\n+    : kind (ITEM), expr (nullptr), item (std::move (item)), stmt (nullptr)\n   {}\n \n   SingleASTNode (std::unique_ptr<Stmt> stmt)\n-    : type (STMT), expr (nullptr), item (nullptr), stmt (std::move (stmt))\n+    : kind (STMT), expr (nullptr), item (nullptr), stmt (std::move (stmt))\n   {}\n \n   SingleASTNode (SingleASTNode const &other)\n   {\n-    type = other.type;\n-    switch (type)\n+    kind = other.kind;\n+    switch (kind)\n       {\n       case EXPRESSION:\n \texpr = other.expr->clone_expr ();\n@@ -1523,8 +1523,8 @@ class SingleASTNode\n \n   SingleASTNode operator= (SingleASTNode const &other)\n   {\n-    type = other.type;\n-    switch (type)\n+    kind = other.kind;\n+    switch (kind)\n       {\n       case EXPRESSION:\n \texpr = other.expr->clone_expr ();\n@@ -1544,27 +1544,52 @@ class SingleASTNode\n   SingleASTNode (SingleASTNode &&other) = default;\n   SingleASTNode &operator= (SingleASTNode &&other) = default;\n \n-  std::unique_ptr<Expr> &get_expr ()\n+  NodeType get_kind () const { return kind; }\n+\n+  std::unique_ptr<Expr> &get_inner ()\n   {\n-    rust_assert (type == EXPRESSION);\n+    rust_assert (kind == EXPRESSION);\n     return expr;\n   }\n \n   std::unique_ptr<Item> &get_item ()\n   {\n-    rust_assert (type == ITEM);\n+    rust_assert (kind == ITEM);\n     return item;\n   }\n \n   std::unique_ptr<Stmt> &get_stmt ()\n   {\n-    rust_assert (type == STMT);\n+    rust_assert (kind == STMT);\n     return stmt;\n   }\n \n+  /**\n+   * Access the inner nodes and take ownership of them.\n+   * You can only call these functions once per node\n+   */\n+\n+  std::unique_ptr<Stmt> take_stmt ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (stmt);\n+  }\n+\n+  std::unique_ptr<Expr> take_expr ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (expr);\n+  }\n+\n+  std::unique_ptr<Item> take_item ()\n+  {\n+    rust_assert (!is_error ());\n+    return std::move (item);\n+  }\n+\n   void accept_vis (ASTVisitor &vis)\n   {\n-    switch (type)\n+    switch (kind)\n       {\n       case EXPRESSION:\n \texpr->accept_vis (vis);\n@@ -1580,8 +1605,38 @@ class SingleASTNode\n       }\n   }\n \n+  bool is_error ()\n+  {\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\treturn expr == nullptr;\n+      case ITEM:\n+\treturn item == nullptr;\n+      case STMT:\n+\treturn stmt == nullptr;\n+      default:\n+\treturn true;\n+      }\n+  }\n+\n+  std::string as_string ()\n+  {\n+    switch (kind)\n+      {\n+      case EXPRESSION:\n+\treturn \"Expr: \" + expr->as_string ();\n+      case ITEM:\n+\treturn \"Item: \" + item->as_string ();\n+      case STMT:\n+\treturn \"Stmt: \" + stmt->as_string ();\n+      default:\n+\treturn \"\";\n+      }\n+  }\n+\n private:\n-  NodeType type;\n+  NodeType kind;\n \n   // FIXME make this a union\n   std::unique_ptr<Expr> expr;\n@@ -1604,11 +1659,18 @@ class ASTFragment\n    * ability for a macro to expand to two statements, for instance. */\n \n   std::vector<SingleASTNode> nodes;\n+  bool fragment_is_error;\n \n public:\n-  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n+  ASTFragment (std::vector<SingleASTNode> nodes, bool fragment_is_error = false)\n+    : nodes (std::move (nodes)), fragment_is_error (fragment_is_error)\n+  {\n+    if (fragment_is_error)\n+      rust_assert (nodes.empty ());\n+  }\n \n   ASTFragment (ASTFragment const &other)\n+    : fragment_is_error (other.fragment_is_error)\n   {\n     nodes.clear ();\n     nodes.reserve (other.nodes.size ());\n@@ -1620,18 +1682,47 @@ class ASTFragment\n \n   ASTFragment &operator= (ASTFragment const &other)\n   {\n+    fragment_is_error = other.fragment_is_error;\n     nodes.clear ();\n     nodes.reserve (other.nodes.size ());\n     for (auto &n : other.nodes)\n       {\n \tnodes.push_back (n);\n       }\n+\n     return *this;\n   }\n \n   static ASTFragment create_empty () { return ASTFragment ({}); }\n+  static ASTFragment create_error () { return ASTFragment ({}, true); }\n \n   std::vector<SingleASTNode> &get_nodes () { return nodes; }\n+  bool is_error () const { return fragment_is_error; }\n+\n+  bool should_expand () const { return !is_error () && !nodes.empty (); }\n+\n+  /**\n+   * We need to make a special case for Expression fragments as only one\n+   * Node will be extracted from the `nodes` vector\n+   */\n+\n+  bool is_expression_fragment () const\n+  {\n+    return nodes.size () == 1\n+\t   && nodes[0].get_kind () == SingleASTNode::NodeType::EXPRESSION;\n+  }\n+\n+  std::unique_ptr<Expr> take_expression_fragment ()\n+  {\n+    rust_assert (is_expression_fragment ());\n+    return nodes[0].take_expr ();\n+  }\n+\n+  void accept_vis (ASTVisitor &vis)\n+  {\n+    for (auto &node : nodes)\n+      node.accept_vis (vis);\n+  }\n };\n \n // A crate AST object - holds all the data for a single compilation unit"}, {"sha": "bf07dd08cf4902812b4f3d4a56e73b2c3317d08e", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -464,9 +464,6 @@ class MacroInvocation : public TypeNoBounds,\n   MacroInvocData invoc_data;\n   Location locus;\n \n-  // this is the expanded macro\n-  ASTFragment fragment;\n-\n   // Important for when we actually expand the macro\n   bool is_semi_coloned;\n \n@@ -480,7 +477,6 @@ class MacroInvocation : public TypeNoBounds,\n \t\t   bool is_semi_coloned = false)\n     : outer_attrs (std::move (outer_attrs)),\n       invoc_data (std::move (invoc_data)), locus (locus),\n-      fragment (ASTFragment::create_empty ()),\n       is_semi_coloned (is_semi_coloned),\n       node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n@@ -513,10 +509,6 @@ class MacroInvocation : public TypeNoBounds,\n \n   MacroInvocData &get_invoc_data () { return invoc_data; }\n \n-  ASTFragment &get_fragment () { return fragment; }\n-\n-  void set_fragment (ASTFragment &&f) { fragment = std::move (f); }\n-\n   bool has_semicolon () const { return is_semi_coloned; }\n \n protected:"}, {"sha": "fab7f56de31330fd9f69decf35ea2026aa9a315b", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 222, "deletions": 86, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -331,12 +331,6 @@ class AttrVisitor : public AST::ASTVisitor\n       expander.expand_invoc_semi (macro_invoc);\n     else\n       expander.expand_invoc (macro_invoc);\n-\n-    // we need to visit the expanded fragments since it may need cfg\n-    // expansion\n-    // and it may be recursive\n-    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n-      node.accept_vis (*this);\n   }\n \n   void visit (AST::PathInExpression &path) override\n@@ -531,10 +525,25 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* should have no possibility for outer attrs as would be parsed\n      * with outer expr */\n-    expr.get_left_expr ()->accept_vis (*this);\n+    auto &l_expr = expr.get_left_expr ();\n+    l_expr->accept_vis (*this);\n+    auto l_fragment = expander.take_expanded_fragment ();\n+    if (l_fragment.should_expand ())\n+      {\n+\tl_fragment.accept_vis (*this);\n+\tl_expr = l_fragment.take_expression_fragment ();\n+      }\n+\n     /* should syntactically not have outer attributes, though this may\n      * not have worked in practice */\n-    expr.get_right_expr ()->accept_vis (*this);\n+    auto &r_expr = expr.get_right_expr ();\n+    r_expr->accept_vis (*this);\n+    auto r_fragment = expander.take_expanded_fragment ();\n+    if (r_fragment.should_expand ())\n+      {\n+\tr_fragment.accept_vis (*this);\n+\tr_expr = r_fragment.take_expression_fragment ();\n+      }\n \n     // ensure that they are not marked for strip\n     if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -645,10 +654,25 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* should have no possibility for outer attrs as would be parsed\n      * with outer expr */\n-    expr.get_left_expr ()->accept_vis (*this);\n+    auto &l_expr = expr.get_left_expr ();\n+    l_expr->accept_vis (*this);\n+    auto l_frag = expander.take_expanded_fragment ();\n+    if (l_frag.should_expand ())\n+      {\n+\tl_frag.accept_vis (*this);\n+\tl_expr = l_frag.take_expression_fragment ();\n+      }\n+\n     /* should syntactically not have outer attributes, though this may\n      * not have worked in practice */\n-    expr.get_right_expr ()->accept_vis (*this);\n+    auto &r_expr = expr.get_right_expr ();\n+    r_expr->accept_vis (*this);\n+    auto r_frag = expander.take_expanded_fragment ();\n+    if (r_frag.should_expand ())\n+      {\n+\tr_frag.accept_vis (*this);\n+\tr_expr = r_frag.take_expression_fragment ();\n+      }\n \n     // ensure that they are not marked for strip\n     if (expr.get_left_expr ()->is_marked_for_strip ())\n@@ -975,7 +999,33 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* spec says outer attributes are specifically allowed for elements\n      * of call expressions, so full stripping possible */\n+    // FIXME: Arthur: Figure out how to refactor this - This is similar to\n+    // expanding items in the crate or stmts in blocks\n     expand_pointer_allow_strip (expr.get_params ());\n+    auto &params = expr.get_params ();\n+    for (auto it = params.begin (); it != params.end ();)\n+      {\n+\tauto &stmt = *it;\n+\n+\tstmt->accept_vis (*this);\n+\n+\tauto fragment = expander.take_expanded_fragment ();\n+\tif (fragment.should_expand ())\n+\t  {\n+\t    fragment.accept_vis (*this);\n+\t    // Remove the current expanded invocation\n+\t    it = params.erase (it);\n+\t    for (auto &node : fragment.get_nodes ())\n+\t      {\n+\t\tit = params.insert (it, node.take_expr ());\n+\t\tit++;\n+\t      }\n+\t  }\n+\telse if (stmt->is_marked_for_strip ())\n+\t  it = params.erase (it);\n+\telse\n+\t  it++;\n+      }\n   }\n   void visit (AST::MethodCallExpr &expr) override\n   {\n@@ -1072,14 +1122,44 @@ class AttrVisitor : public AST::ASTVisitor\n       }\n \n     // strip all statements\n-    expand_pointer_allow_strip (expr.get_statements ());\n+    auto &stmts = expr.get_statements ();\n+    for (auto it = stmts.begin (); it != stmts.end ();)\n+      {\n+\tauto &stmt = *it;\n+\n+\tstmt->accept_vis (*this);\n+\n+\tauto fragment = expander.take_expanded_fragment ();\n+\tif (fragment.should_expand ())\n+\t  {\n+\t    fragment.accept_vis (*this);\n+\t    // Remove the current expanded invocation\n+\t    it = stmts.erase (it);\n+\t    for (auto &node : fragment.get_nodes ())\n+\t      {\n+\t\tit = stmts.insert (it, node.take_stmt ());\n+\t\tit++;\n+\t      }\n+\t  }\n+\n+\telse if (stmt->is_marked_for_strip ())\n+\t  it = stmts.erase (it);\n+\telse\n+\t  it++;\n+      }\n \n     // strip tail expression if exists - can actually fully remove it\n     if (expr.has_tail_expr ())\n       {\n \tauto &tail_expr = expr.get_tail_expr ();\n \n \ttail_expr->accept_vis (*this);\n+\tauto fragment = expander.take_expanded_fragment ();\n+\tif (fragment.should_expand ())\n+\t  {\n+\t    fragment.accept_vis (*this);\n+\t    tail_expr = fragment.take_expression_fragment ();\n+\t  }\n \n \tif (tail_expr->is_marked_for_strip ())\n \t  expr.strip_tail_expr ();\n@@ -2819,10 +2899,18 @@ class AttrVisitor : public AST::ASTVisitor\n       {\n \tauto &init_expr = stmt.get_init_expr ();\n \tinit_expr->accept_vis (*this);\n+\n \tif (init_expr->is_marked_for_strip ())\n \t  rust_error_at (init_expr->get_locus (),\n \t\t\t \"cannot strip expression in this position - outer \"\n \t\t\t \"attributes not allowed\");\n+\n+\tauto fragment = expander.take_expanded_fragment ();\n+\tif (fragment.should_expand ())\n+\t  {\n+\t    fragment.accept_vis (*this);\n+\t    init_expr = fragment.take_expression_fragment ();\n+\t  }\n       }\n   }\n   void visit (AST::ExprStmtWithoutBlock &stmt) override\n@@ -3125,7 +3213,7 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n       RichLocation r (invoc_locus);\n       r.add_range (rules_def.get_locus ());\n       rust_error_at (r, \"Failed to match any rule within macro\");\n-      return AST::ASTFragment::create_empty ();\n+      return AST::ASTFragment::create_error ();\n     }\n \n   return transcribe_rule (*matched_rule, invoc_token_tree, matched_fragments,\n@@ -3187,10 +3275,10 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n     fragment\n       = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, false);\n \n-  // lets attach this fragment to the invocation\n-  invoc.set_fragment (std::move (fragment));\n+  set_expanded_fragment (std::move (fragment));\n }\n \n+// FIXME: Arthur: Refactor these two functions, they're really similar\n void\n MacroExpander::expand_invoc_semi (AST::MacroInvocation &invoc)\n {\n@@ -3228,8 +3316,7 @@ MacroExpander::expand_invoc_semi (AST::MacroInvocation &invoc)\n     fragment\n       = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n \n-  // lets attach this fragment to the invocation\n-  invoc.set_fragment (std::move (fragment));\n+  set_expanded_fragment (std::move (fragment));\n }\n \n /* Determines whether any cfg predicate is false and hence item with attributes\n@@ -3363,10 +3450,22 @@ MacroExpander::expand_crate ()\n       // mark for stripping if required\n       item->accept_vis (attr_visitor);\n \n-      if (item->is_marked_for_strip ())\n+      auto fragment = take_expanded_fragment ();\n+      if (fragment.should_expand ())\n+\t{\n+\t  fragment.accept_vis (attr_visitor);\n+\t  // Remove the current expanded invocation\n+\t  it = items.erase (it);\n+\t  for (auto &node : fragment.get_nodes ())\n+\t    {\n+\t      it = items.insert (it, node.take_item ());\n+\t      it++;\n+\t    }\n+\t}\n+      else if (item->is_marked_for_strip ())\n \tit = items.erase (it);\n       else\n-\t++it;\n+\tit++;\n     }\n \n   pop_context ();\n@@ -3756,6 +3855,73 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n   return res;\n }\n \n+/**\n+ * Helper function to refactor calling a parsing function 0 or more times\n+ */\n+static std::vector<AST::SingleASTNode>\n+parse_many (Parser<MacroInvocLexer> &parser, TokenId &delimiter,\n+\t    std::function<AST::SingleASTNode ()> parse_fn)\n+{\n+  std::vector<AST::SingleASTNode> nodes;\n+\n+  while (true)\n+    {\n+      if (parser.peek_current_token ()->get_id () == delimiter)\n+\tbreak;\n+\n+      auto node = parse_fn ();\n+      nodes.emplace_back (std::move (node));\n+    }\n+\n+  return nodes;\n+}\n+\n+/**\n+ * Transcribe 0 or more items from a macro invocation\n+ *\n+ * @param parser Parser to extract items from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_items (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto item = parser.parse_item (true);\n+    return AST::SingleASTNode (std::move (item));\n+  });\n+}\n+\n+/**\n+ * Transcribe 0 or more statements from a macro invocation\n+ *\n+ * @param parser Parser to extract statements from\n+ * @param delimiter Id of the token on which parsing should stop\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n+{\n+  // FIXME: This is invalid! It needs to also handle cases where the macro\n+  // transcriber is an expression, but since the macro call is followed by\n+  // a semicolon, it's a valid ExprStmt\n+  return parse_many (parser, delimiter, [&parser] () {\n+    auto stmt = parser.parse_stmt ();\n+    return AST::SingleASTNode (std::move (stmt));\n+  });\n+}\n+\n+/**\n+ * Transcribe one expression from a macro invocation\n+ *\n+ * @param parser Parser to extract statements from\n+ */\n+static std::vector<AST::SingleASTNode>\n+transcribe_expression (Parser<MacroInvocLexer> &parser)\n+{\n+  auto expr = parser.parse_expr ();\n+\n+  return {AST::SingleASTNode (std::move (expr))};\n+}\n+\n AST::ASTFragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n@@ -3775,20 +3941,24 @@ MacroExpander::transcribe_rule (\n   std::vector<std::unique_ptr<AST::Token>> substituted_tokens\n     = substitute_context.substitute_tokens ();\n \n-  // // handy for debugging\n+  // parse it to an ASTFragment\n+  MacroInvocLexer lex (std::move (substituted_tokens));\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  // handy for debugging\n   // for (auto &tok : substituted_tokens)\n   //   {\n   //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n   //   }\n \n-  // parse it to an ASTFragment\n-  MacroInvocLexer lex (std::move (substituted_tokens));\n-  Parser<MacroInvocLexer> parser (std::move (lex));\n+  auto last_token_id = TokenId::RIGHT_CURLY;\n+  std::vector<AST::SingleASTNode> nodes;\n \n   // this is used so we can check that we delimit the stream correctly.\n   switch (transcribe_tree.get_delim_type ())\n     {\n     case AST::DelimType::PARENS:\n+      last_token_id = TokenId::RIGHT_PAREN;\n       rust_assert (parser.skip_token (LEFT_PAREN));\n       break;\n \n@@ -3797,6 +3967,7 @@ MacroExpander::transcribe_rule (\n       break;\n \n     case AST::DelimType::SQUARE:\n+      last_token_id = TokenId::RIGHT_SQUARE;\n       rust_assert (parser.skip_token (LEFT_SQUARE));\n       break;\n     }\n@@ -3811,79 +3982,44 @@ MacroExpander::transcribe_rule (\n   //   as a statement (either via ExpressionStatement or\n   //   MacroInvocationWithSemi)\n \n-  // parse the item\n-  std::vector<AST::SingleASTNode> nodes;\n-  switch (invoc_token_tree.get_delim_type ())\n-    {\n-    case AST::DelimType::PARENS:\n-      case AST::DelimType::SQUARE: {\n-\tswitch (ctx)\n-\t  {\n-\t    case ContextType::ITEM: {\n-\t      auto item = parser.parse_item (true);\n-\t      if (item != nullptr && !parser.has_errors ())\n-\t\t{\n-\t\t  rust_debug (\"HELLO WORLD: [%s]\", item->as_string ().c_str ());\n-\t\t  nodes.push_back (std::move (item));\n-\t\t}\n-\t    }\n-\t    break;\n-\n-\t    case ContextType::BLOCK: {\n-\t      auto expr = parser.parse_expr ();\n-\t      if (expr != nullptr && !parser.has_errors ())\n-\t\tnodes.push_back (std::move (expr));\n-\t    }\n-\t    break;\n-\t  }\n+  // The flow-chart in order to choose a parsing function is as follows:\n+  //\n+  // [is in item context?]\n+  //     -- Yes --> parser.parse_item();\n+  //     -- No --> [has semicolon?]\n+  //                 -- Yes --> parser.parse_stmt();\n+  //                 -- No --> [switch invocation.delimiter()]\n+  //                             -- { } --> parser.parse_stmt();\n+  //                             -- _ --> parser.parse_expr();\n+\n+  // If there is a semicolon OR we are expanding a MacroInvocationSemi, then\n+  // we can parse multiple items. Otherwise, parse *one* expression\n+\n+  if (ctx == ContextType::ITEM)\n+    nodes = transcribe_many_items (parser, last_token_id);\n+  else if (semicolon)\n+    nodes = transcribe_many_stmts (parser, last_token_id);\n+  else\n+    switch (invoc_token_tree.get_delim_type ())\n+      {\n+      case AST::CURLY:\n+\tnodes = transcribe_many_stmts (parser, last_token_id);\n+\tbreak;\n+      default:\n+\tnodes = transcribe_expression (parser);\n+\tbreak;\n       }\n-      break;\n-\n-      case AST::DelimType::CURLY: {\n-\tswitch (ctx)\n-\t  {\n-\t    case ContextType::ITEM: {\n-\t      auto item = parser.parse_item (true);\n-\t      if (item != nullptr && !parser.has_errors ())\n-\t\tnodes.push_back (std::move (item));\n-\t    }\n-\t    break;\n-\n-\t    case ContextType::BLOCK: {\n-\t      auto stmt = parser.parse_stmt ();\n-\t      if (stmt != nullptr && !parser.has_errors ())\n-\t\tnodes.push_back (std::move (stmt));\n-\t    }\n-\t    break;\n-\t  }\n-      }\n-      break;\n-    }\n \n   // emit any errors\n   if (parser.has_errors ())\n     {\n       for (auto &err : parser.get_errors ())\n-\t{\n-\t  rust_error_at (err.locus, \"%s\", err.message.c_str ());\n-\t}\n-      return AST::ASTFragment::create_empty ();\n+\trust_error_at (err.locus, \"%s\", err.message.c_str ());\n+      return AST::ASTFragment::create_error ();\n     }\n \n   // are all the tokens used?\n-  bool did_delimit = false;\n-  switch (transcribe_tree.get_delim_type ())\n-    {\n-    case AST::DelimType::PARENS:\n-      did_delimit = parser.skip_token (RIGHT_PAREN);\n-      break;\n-    case AST::DelimType::SQUARE:\n-      did_delimit = parser.skip_token (RIGHT_SQUARE);\n-      break;\n-    case AST::DelimType::CURLY:\n-      did_delimit = parser.skip_token (RIGHT_CURLY);\n-      break;\n-    }\n+  bool did_delimit = parser.skip_token (last_token_id);\n \n   bool reached_end_of_stream = did_delimit && parser.skip_token (END_OF_FILE);\n   if (!reached_end_of_stream)"}, {"sha": "3433e646664f22987b97cde23ef6632decf90c2e", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -137,7 +137,9 @@ struct MacroExpander\n \n   MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n     : cfg (cfg), crate (crate), session (session),\n-      sub_stack (SubstitutionScope ()), resolver (Resolver::Resolver::get ()),\n+      sub_stack (SubstitutionScope ()),\n+      expanded_fragment (AST::ASTFragment::create_empty ()),\n+      resolver (Resolver::Resolver::get ()),\n       mappings (Analysis::Mappings::get ())\n   {}\n \n@@ -223,11 +225,25 @@ struct MacroExpander\n \n   ContextType peek_context () { return context.back (); }\n \n+  void set_expanded_fragment (AST::ASTFragment &&fragment)\n+  {\n+    expanded_fragment = std::move (fragment);\n+  }\n+\n+  AST::ASTFragment take_expanded_fragment ()\n+  {\n+    AST::ASTFragment old_fragment = std::move (expanded_fragment);\n+    expanded_fragment = AST::ASTFragment::create_empty ();\n+\n+    return old_fragment;\n+  }\n+\n private:\n   AST::Crate &crate;\n   Session &session;\n   SubstitutionScope sub_stack;\n   std::vector<ContextType> context;\n+  AST::ASTFragment expanded_fragment;\n \n public:\n   Resolver::Resolver *resolver;"}, {"sha": "e31686811f165b19d724056a56c87593a881006e", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -102,12 +102,10 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::MacroInvocation &expr) override\n   {\n-    AST::ASTFragment &fragment = expr.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n+    rust_fatal_error (\n+      expr.get_locus (),\n+      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n+      \"as they should disappear during expansion\");\n   }\n \n   void visit (AST::TupleIndexExpr &expr) override"}, {"sha": "5d674ca168b7b73957bacd6c1442d5da5d3cc9b3", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -54,15 +54,10 @@ class ASTLowerImplItem : public ASTLoweringBase\n \n   void visit (AST::MacroInvocation &invoc) override\n   {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n+    rust_fatal_error (\n+      invoc.get_locus (),\n+      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n+      \"as they should disappear during expansion\");\n   }\n \n   void visit (AST::TypeAlias &alias) override\n@@ -323,15 +318,10 @@ class ASTLowerTraitItem : public ASTLoweringBase\n \n   void visit (AST::MacroInvocation &invoc) override\n   {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n+    rust_fatal_error (\n+      invoc.get_locus (),\n+      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n+      \"as they should disappear during expansion\");\n   }\n \n   void visit (AST::TraitItemFunc &func) override"}, {"sha": "6974ffccc84b16ed08c231c894b0304e996b2263", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -53,15 +53,10 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::MacroInvocation &invoc) override\n   {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n+    rust_fatal_error (\n+      invoc.get_locus (),\n+      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n+      \"as they should disappear during expansion\");\n   }\n \n   void visit (AST::Module &module) override"}, {"sha": "d0a1d382bb388259ab0dd6e3265dd3180457fb59", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -47,15 +47,10 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::MacroInvocation &invoc) override\n   {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    // FIXME\n-    // this assertion might go away, maybe on failure's to expand a macro?\n-    rust_assert (!fragment.get_nodes ().empty ());\n-    fragment.get_nodes ().at (0).accept_vis (*this);\n+    rust_fatal_error (\n+      invoc.get_locus (),\n+      \"macro expansion failed: No macro invocation should get lowered to HIR \"\n+      \"as they should disappear during expansion\");\n   }\n \n   void visit (AST::ExprStmtWithBlock &stmt) override"}, {"sha": "e551802bb4327079b5d4e0c43518b7c322c28cb0", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -34,14 +34,6 @@ ResolveExpr::go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n   expr->accept_vis (resolver);\n }\n \n-void\n-ResolveExpr::visit (AST::MacroInvocation &expr)\n-{\n-  AST::ASTFragment &fragment = expr.get_fragment ();\n-  for (auto &node : fragment.get_nodes ())\n-    node.accept_vis (*this);\n-}\n-\n void\n ResolveExpr::visit (AST::TupleIndexExpr &expr)\n {"}, {"sha": "a049ba1c7705019e96748dab50e0e90777c9e16b", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -62,8 +62,6 @@ class ResolveExpr : public ResolverBase\n   static void go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n \t\t  const CanonicalPath &canonical_prefix);\n \n-  void visit (AST::MacroInvocation &expr) override;\n-\n   void visit (AST::TupleIndexExpr &expr) override;\n \n   void visit (AST::TupleExpr &expr) override;"}, {"sha": "f17b2226a40e11075426b037d0dd3ae97afeb556", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -49,16 +49,6 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::TypeAlias &type) override\n   {\n     auto decl\n@@ -147,16 +137,6 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::TraitItemFunc &function) override\n   {\n     auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (function);\n@@ -260,16 +240,6 @@ class ResolveToplevelExternItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::ExternalFunctionItem &function) override\n   {\n     auto decl = CanonicalPath::new_seg (function.get_node_id (),"}, {"sha": "5d32c0022d01327d84856aae0229691178b3fcf4", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -45,16 +45,6 @@ class ResolveTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::TraitItemType &type) override\n   {\n     auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n@@ -237,16 +227,6 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::TypeAlias &alias) override\n   {\n     auto talias = CanonicalPath::new_seg (alias.get_node_id (),"}, {"sha": "3afed532afa15a1120db25e0bda942234eb17e6d", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -44,17 +44,6 @@ class ResolveStmt : public ResolverBase\n     stmt->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    if (!invoc.has_semicolon ())\n-      return;\n-\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n     ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,"}, {"sha": "7aba67fe7e7337c8e7eb7300e04005e068ec8b4c", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -43,13 +43,6 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  void visit (AST::MacroInvocation &invoc) override\n-  {\n-    AST::ASTFragment &fragment = invoc.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::Module &module) override\n   {\n     auto mod"}, {"sha": "97b89a12d84e53a3bbc76598386d4361269f00a4", "filename": "gcc/testsuite/rust/compile/macro11.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro11.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -0,0 +1,11 @@\n+macro_rules! call_f {\n+    ($($f:ident)*) => { $($f();)* }\n+}\n+\n+fn f() {}\n+\n+// This is valid and should parse items\n+fn main() {\n+    call_f!(f f f f);\n+}\n+"}, {"sha": "b75fbad2c2fa24485162435471be096f49725421", "filename": "gcc/testsuite/rust/compile/macro12.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro12.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -0,0 +1,8 @@\n+// { dg-additional-options \"-w\" }\n+macro_rules! define_vars {\n+    ($($v:ident)*) => { $(let $v = 15;)* }\n+}\n+\n+fn main() {\n+    define_vars!(a0 b f __some_identifier);\n+}"}, {"sha": "eb8dfbbf3938600afb396f70b29a4276b7199f38", "filename": "gcc/testsuite/rust/compile/macro13.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro13.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -0,0 +1,12 @@\n+// { dg-additional-options \"-w\" }\n+macro_rules! create_type {\n+    ($s:ident) => {\n+        struct $s;\n+    };\n+}\n+\n+fn main() {\n+    create_type!(A);\n+\n+    let a = A;\n+}"}, {"sha": "b18c56eefc8a920a4fa5f5fdbca9dfb2f74a3d87", "filename": "gcc/testsuite/rust/compile/macro14.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro14.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro14.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro14.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -0,0 +1,10 @@\n+// { dg-additional-options \"-w\" }\n+macro_rules! define_vars {\n+    ($($v:ident)*) => { $(let $v = 15;)* }\n+}\n+\n+fn main() -> i32 {\n+    define_vars!(a0 b f __some_identifier);\n+\n+    b\n+}"}, {"sha": "02c739e415e93ea5bee04421b9c9850252259b62", "filename": "gcc/testsuite/rust/compile/macro15.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro15.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro15.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro15.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -0,0 +1,12 @@\n+// { dg-additional-options \"-w\" }\n+macro_rules! create_type {\n+    ($s:ident) => {\n+        struct $s;\n+    };\n+}\n+\n+create_type!(SomeOuterType);\n+\n+fn main() {\n+    let a = SomeOuterType;\n+}"}, {"sha": "0ca35ba688848e37c3bf7c5752fdb50a9164f400", "filename": "gcc/testsuite/rust/compile/macro6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro6.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -1,6 +1,6 @@\n macro_rules! zero_or_one {\n     ($($a:literal)?) => { // { dg-error \"invalid amount of matches for macro invocation. Expected between 0 and 1, got 2\" }\n-        f()\n+        f();\n     }\n }\n "}, {"sha": "abc48057c5458cc958ad45f4a1b996dac7363cac", "filename": "gcc/testsuite/rust/compile/macro7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro7.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -2,8 +2,8 @@ fn f() {}\n \n macro_rules! one_or_more {\n     ($($a:literal)+) => { // { dg-error \"invalid amount of matches for macro invocation\" }\n-        f()\n-    }\n+        f();\n+    };\n }\n \n fn main() {"}, {"sha": "d3e8af93a6ed5ac3a45543abf07115cff2aa9f63", "filename": "gcc/testsuite/rust/compile/macro8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro8.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -2,8 +2,8 @@ fn f() {}\n \n macro_rules! expr {\n     ($($a:expr)?) => {\n-        f()\n-    }\n+        f();\n+    };\n }\n \n fn main() {"}, {"sha": "5bde97d3dd4d8407517583648c118a3cf197db5e", "filename": "gcc/testsuite/rust/execute/torture/macros11.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros11.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -7,7 +7,9 @@ fn print_int(value: i32) {\n     let s = \"%d\\n\\0\";\n     let s_p = s as *const str;\n     let c_p = s_p as *const i8;\n-    unsafe { printf(c_p, value); }\n+    unsafe {\n+        printf(c_p, value);\n+    }\n }\n \n macro_rules! add_exprs {\n@@ -16,7 +18,8 @@ macro_rules! add_exprs {\n \n fn main() -> i32 {\n     // 2\n-    print_int(add_exprs!(2));\n+    let a = add_exprs!(2);\n+    print_int(a);\n \n     0\n }"}, {"sha": "390352ec47fc716619e5a830b62aa49af4870175", "filename": "gcc/testsuite/rust/execute/torture/macros17.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros17.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros17.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros17.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -5,9 +5,9 @@ macro_rules! two {\n }\n \n macro_rules! one {\n-    (1) => {\n+    (1) => {{\n         two!(2)\n-    };\n+    }};\n }\n \n fn main() -> i32 {"}, {"sha": "ba5098710ea084bcdd103d274738a81d0d489cdb", "filename": "gcc/testsuite/rust/execute/torture/macros2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros2.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -15,19 +15,19 @@ fn f() {\n \n macro_rules! kw0 {\n     (keyword) => {\n-        f()\n+        f();\n     };\n }\n \n macro_rules! kw1 {\n     (fn) => {\n-        f()\n+        f();\n     };\n }\n \n macro_rules! kw2 {\n     (kw0 kw1 kw3) => {\n-        f()\n+        f();\n     };\n }\n "}, {"sha": "973af23860b4ff6a91877f770c2621f1826ada1a", "filename": "gcc/testsuite/rust/execute/torture/macros22.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros22.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros22.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros22.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -0,0 +1,23 @@\n+// { dg-output \"1\\n2\\nNaN\\n3\\n\" }\n+\n+macro_rules! print_num {\n+    ($l:literal) => {\n+        printf(\"%d\\n\\0\" as *const str as *const i8, $l);\n+    };\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+// Check to make sure that expanding macros does not break the flow of calls\n+fn main() -> i32 {\n+    print_num!(1);\n+    print_num!(2);\n+\n+    printf(\"NaN\\n\\0\" as *const str as *const i8);\n+\n+    print_num!(3);\n+\n+    0\n+}"}, {"sha": "00f6d253f5039f40ba9822dab6b9ad3e9e6cfbfb", "filename": "gcc/testsuite/rust/execute/torture/macros3.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros3.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -15,35 +15,35 @@ fn f() {\n \n macro_rules! invocation0 {\n     (valid) => {\n-        f()\n+        f();\n     };\n     () => {};\n }\n \n macro_rules! invocation1 {\n     (valid) => {};\n     () => {\n-        f()\n+        f();\n     };\n }\n \n macro_rules! invocation2 {\n     (valid) => {\n-        f()\n+        f();\n     };\n     (invalid) => {};\n }\n \n macro_rules! invocation3 {\n     (this is a valid invocation) => {\n-        f()\n+        f();\n     };\n     (not this one) => {};\n }\n \n macro_rules! invocation4 {\n     (fn f() {}) => {\n-        f()\n+        f();\n     };\n     (not a keyword) => {};\n }"}, {"sha": "ed1f922f581b24538ba5ad39e64521b4a04a0753", "filename": "gcc/testsuite/rust/execute/torture/macros7.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros7.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -8,13 +8,15 @@ fn f() {\n     let s_p = r_s as *const str;\n     let c_p = s_p as *const i8;\n \n-    unsafe { printf(c_p); }\n+    unsafe {\n+        printf(c_p);\n+    }\n }\n \n macro_rules! any {\n     ($($a:expr)*) => {\n-        f()\n-    }\n+        f();\n+    };\n }\n \n fn main() -> i32 {"}, {"sha": "a12aca4910e2534809d25aeaacde96137ff2f363", "filename": "gcc/testsuite/rust/execute/torture/macros8.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros8.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -8,13 +8,15 @@ fn f() {\n     let s_p = r_s as *const str;\n     let c_p = s_p as *const i8;\n \n-    unsafe { printf(c_p); }\n+    unsafe {\n+        printf(c_p);\n+    }\n }\n \n macro_rules! zero_or_one {\n     ($($a:expr)?) => {\n-        f()\n-    }\n+        f();\n+    };\n }\n \n fn main() -> i32 {"}, {"sha": "0e3fd24e8a91a7ff80f17355e36ae280be7bac6d", "filename": "gcc/testsuite/rust/execute/torture/macros9.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02392c8b378a68fb2525098a41a90bd16faa7fd/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros9.rs?ref=f02392c8b378a68fb2525098a41a90bd16faa7fd", "patch": "@@ -8,13 +8,15 @@ fn f() {\n     let s_p = r_s as *const str;\n     let c_p = s_p as *const i8;\n \n-    unsafe { printf(c_p); }\n+    unsafe {\n+        printf(c_p);\n+    }\n }\n \n macro_rules! one_or_more {\n     ($($a:expr)+) => {\n-        f()\n-    }\n+        f();\n+    };\n }\n \n fn main() -> i32 {"}]}