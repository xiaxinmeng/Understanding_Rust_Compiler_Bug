{"sha": "5076fb182e2f99b46dca619f7be8e6e158bc902f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3NmZiMTgyZTJmOTliNDZkY2E2MTlmN2JlOGU2ZTE1OGJjOTAyZg==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2019-08-12T09:00:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-12T09:00:27Z"}, "message": "[Ada] Implement Ada.Directories.Hierarchical_File_Names\n\nThis patch corrects certain behaviors within Ada.Directories to better\nconform to conformance tests and implements the package\nAda.Directories.Hierarchical_File_Names outlined in AI05-0049-1.\n\nOnly partial test sources are included.\n\n------------\n-- Source --\n------------\n\n--  main.ads\n\nwith Ada.Directories.Hierarchical_File_Names;\nuse Ada.Directories.Hierarchical_File_Names;\n\nwith Ada.Exceptions; use Ada.Exceptions;\nwith Ada.Text_IO;    use Ada.Text_IO;\n\nprocedure Main is\n   FULL_PATH_A : constant String := \"/export/work/user/bug\";\n   FULL_PATH_B : constant String := \"/export/work/user\";\n\n   RELATIVE_PATH_A : constant String := \"export/work/user/bug/\";\n   RELATIVE_PATH_B : constant String := \"export/work/user/bug\";\n\n   SIMPLE_PATH_A : constant String := \"bug/\";\n   SIMPLE_PATH_B : constant String := \"bug\";\n\n   ROOT_PATH : constant String := \"/\";\n\n   CURRENT_DIR : constant String := \".\";\n   PARENT_DIR  : constant String := \"..\";\n\n   RELATIVE_WITH_CURRENT : constant String := RELATIVE_PATH_A & \".\";\n   RELATIVE_WITH_PARENT  : constant String := RELATIVE_PATH_A & \"..\";\nbegin\n   Put_Line (\"Simple_Name\");\n   Put_Line (Is_Simple_Name (FULL_PATH_A)'Image);\n   Put_Line (Is_Simple_Name (FULL_PATH_B)'Image);\n   Put_Line (Is_Simple_Name (RELATIVE_PATH_A)'Image);\n   Put_Line (Is_Simple_Name (RELATIVE_PATH_B)'Image);\n   Put_Line (Is_Simple_Name (SIMPLE_PATH_A)'Image);\n   Put_Line (Is_Simple_Name (SIMPLE_PATH_B)'Image);\n   Put_Line (Is_Simple_Name (ROOT_PATH)'Image);\n   Put_Line (Is_Simple_Name (CURRENT_DIR)'Image);\n   Put_Line (Is_Simple_Name (PARENT_DIR)'Image);\n   Put_Line (Is_Simple_Name (RELATIVE_WITH_CURRENT)'Image);\n   Put_Line (Is_Simple_Name (RELATIVE_WITH_PARENT)'Image);\n   Put_Line (Simple_Name (FULL_PATH_A));\n   Put_Line (Simple_Name (FULL_PATH_B));\n   Put_Line (Simple_Name (RELATIVE_PATH_A));\n   Put_Line (Simple_Name (RELATIVE_PATH_B));\n   Put_Line (Simple_Name (SIMPLE_PATH_A));\n   Put_Line (Simple_Name (SIMPLE_PATH_B));\n   Put_Line (Simple_Name (ROOT_PATH));\n   Put_Line (Simple_Name (CURRENT_DIR));\n   Put_Line (Simple_Name (PARENT_DIR));\n   Put_Line (Simple_Name (RELATIVE_WITH_CURRENT));\n   Put_Line (Simple_Name (RELATIVE_WITH_PARENT));\n\n   Put_Line (\"Root_Directory_Name\");\n   Put_Line (Is_Root_Directory_Name (FULL_PATH_A)'Image);\n   Put_Line (Is_Root_Directory_Name (FULL_PATH_B)'Image);\n   Put_Line (Is_Root_Directory_Name (RELATIVE_PATH_A)'Image);\n   Put_Line (Is_Root_Directory_Name (RELATIVE_PATH_B)'Image);\n   Put_Line (Is_Root_Directory_Name (SIMPLE_PATH_A)'Image);\n   Put_Line (Is_Root_Directory_Name (SIMPLE_PATH_B)'Image);\n   Put_Line (Is_Root_Directory_Name (ROOT_PATH)'Image);\n   Put_Line (Is_Root_Directory_Name (CURRENT_DIR)'Image);\n   Put_Line (Is_Root_Directory_Name (PARENT_DIR)'Image);\n   Put_Line (Is_Root_Directory_Name (RELATIVE_WITH_CURRENT)'Image);\n   Put_Line (Is_Root_Directory_Name (RELATIVE_WITH_PARENT)'Image);\n\n   Put_Line (\"Is_Parent_Directory_Name\");\n   Put_Line (Is_Parent_Directory_Name (FULL_PATH_A)'Image);\n   Put_Line (Is_Parent_Directory_Name (FULL_PATH_B)'Image);\n   Put_Line (Is_Parent_Directory_Name (RELATIVE_PATH_A)'Image);\n   Put_Line (Is_Parent_Directory_Name (RELATIVE_PATH_B)'Image);\n   Put_Line (Is_Parent_Directory_Name (SIMPLE_PATH_A)'Image);\n   Put_Line (Is_Parent_Directory_Name (SIMPLE_PATH_B)'Image);\n   Put_Line (Is_Parent_Directory_Name (ROOT_PATH)'Image);\n   Put_Line (Is_Parent_Directory_Name (CURRENT_DIR)'Image);\n   Put_Line (Is_Parent_Directory_Name (PARENT_DIR)'Image);\n   Put_Line (Is_Parent_Directory_Name (RELATIVE_WITH_CURRENT)'Image);\n   Put_Line (Is_Parent_Directory_Name (RELATIVE_WITH_PARENT)'Image);\n\n   Put_Line (\"Is_Current_Directory_Name\");\n   Put_Line (Is_Current_Directory_Name (FULL_PATH_A)'Image);\n   Put_Line (Is_Current_Directory_Name (FULL_PATH_B)'Image);\n   Put_Line (Is_Current_Directory_Name (RELATIVE_PATH_A)'Image);\n   Put_Line (Is_Current_Directory_Name (RELATIVE_PATH_B)'Image);\n   Put_Line (Is_Current_Directory_Name (SIMPLE_PATH_A)'Image);\n   Put_Line (Is_Current_Directory_Name (SIMPLE_PATH_B)'Image);\n   Put_Line (Is_Current_Directory_Name (ROOT_PATH)'Image);\n   Put_Line (Is_Current_Directory_Name (CURRENT_DIR)'Image);\n   Put_Line (Is_Current_Directory_Name (PARENT_DIR)'Image);\n   Put_Line (Is_Current_Directory_Name (RELATIVE_WITH_CURRENT)'Image);\n   Put_Line (Is_Current_Directory_Name (RELATIVE_WITH_PARENT)'Image);\n\n   Put_Line (\"Is_Full_Name\");\n   Put_Line (Is_Full_Name (FULL_PATH_A)'Image);\n   Put_Line (Is_Full_Name (FULL_PATH_B)'Image);\n   Put_Line (Is_Full_Name (RELATIVE_PATH_A)'Image);\n   Put_Line (Is_Full_Name (RELATIVE_PATH_B)'Image);\n   Put_Line (Is_Full_Name (SIMPLE_PATH_A)'Image);\n   Put_Line (Is_Full_Name (SIMPLE_PATH_B)'Image);\n   Put_Line (Is_Full_Name (ROOT_PATH)'Image);\n   Put_Line (Is_Full_Name (CURRENT_DIR)'Image);\n   Put_Line (Is_Full_Name (PARENT_DIR)'Image);\n   Put_Line (Is_Full_Name (RELATIVE_WITH_CURRENT)'Image);\n   Put_Line (Is_Full_Name (RELATIVE_WITH_PARENT)'Image);\n\n   Put_Line (\"Relative_Name\");\n   Put_Line (Is_Relative_Name (FULL_PATH_A)'Image);\n   Put_Line (Is_Relative_Name (FULL_PATH_B)'Image);\n   Put_Line (Is_Relative_Name (RELATIVE_PATH_A)'Image);\n   Put_Line (Is_Relative_Name (RELATIVE_PATH_B)'Image);\n   Put_Line (Is_Relative_Name (SIMPLE_PATH_A)'Image);\n   Put_Line (Is_Relative_Name (SIMPLE_PATH_B)'Image);\n   Put_Line (Is_Relative_Name (ROOT_PATH)'Image);\n   Put_Line (Is_Relative_Name (CURRENT_DIR)'Image);\n   Put_Line (Is_Relative_Name (PARENT_DIR)'Image);\n   Put_Line (Is_Relative_Name (RELATIVE_WITH_CURRENT)'Image);\n   Put_Line (Is_Relative_Name (RELATIVE_WITH_PARENT)'Image);\n   Put_Line (Relative_Name (FULL_PATH_A));\n   Put_Line (Relative_Name (FULL_PATH_B));\n   Put_Line (Relative_Name (RELATIVE_PATH_A));\n   Put_Line (Relative_Name (RELATIVE_PATH_B));\n   begin\n      Put_Line (Relative_Name (SIMPLE_PATH_A));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   begin\n      Put_Line (Relative_Name (SIMPLE_PATH_B));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   begin\n      Put_Line (Relative_Name (ROOT_PATH));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   begin\n      Put_Line (Relative_Name (CURRENT_DIR));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   begin\n      Put_Line (Relative_Name (PARENT_DIR));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   Put_Line (Relative_Name (RELATIVE_WITH_CURRENT));\n   Put_Line (Relative_Name (RELATIVE_WITH_PARENT));\n\n   Put_Line (\"Containing_Directory\");\n   Put_Line (Containing_Directory (FULL_PATH_A));\n   Put_Line (Containing_Directory (FULL_PATH_B));\n   Put_Line (Containing_Directory (RELATIVE_PATH_A));\n   Put_Line (Containing_Directory (RELATIVE_PATH_B));\n   Put_Line (Containing_Directory (SIMPLE_PATH_A));\n   Put_Line (Containing_Directory (SIMPLE_PATH_B));\n   begin\n      Put_Line (Containing_Directory (ROOT_PATH));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   begin\n      Put_Line (Containing_Directory (CURRENT_DIR));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   begin\n      Put_Line (Containing_Directory (PARENT_DIR));\n   exception\n      when E: others =>\n         Put_Line (Exception_Information (E));\n   end;\n   Put_Line (Containing_Directory (RELATIVE_WITH_CURRENT));\n   Put_Line (Containing_Directory (RELATIVE_WITH_PARENT));\n\n   Put_Line (\"Initial_Directory\");\n   Put_Line (Initial_Directory (FULL_PATH_A));\n   Put_Line (Initial_Directory (FULL_PATH_B));\n   Put_Line (Initial_Directory (RELATIVE_PATH_A));\n   Put_Line (Initial_Directory (RELATIVE_PATH_B));\n   Put_Line (Initial_Directory (SIMPLE_PATH_A));\n   Put_Line (Initial_Directory (SIMPLE_PATH_B));\n   Put_Line (Initial_Directory (ROOT_PATH));\n   Put_Line (Initial_Directory (CURRENT_DIR));\n   Put_Line (Initial_Directory (PARENT_DIR));\n   Put_Line (Initial_Directory (RELATIVE_WITH_CURRENT));\n   Put_Line (Initial_Directory (RELATIVE_WITH_PARENT));\nend;\n\n-----------------\n-- Compilation --\n-----------------\n\n$ gnatmake -q main.adb\nSimple_Name\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\nTRUE\nFALSE\nTRUE\nTRUE\nFALSE\nFALSE\nbug\nuser\nbug\nbug\nbug\nbug\n/\n.\n..\n.\n..\nRoot_Directory_Name\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nFALSE\nFALSE\nIs_Parent_Directory_Name\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nIs_Current_Directory_Name\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nFALSE\nIs_Full_Name\nTRUE\nTRUE\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\nFALSE\nFALSE\nRelative_Name\nFALSE\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\nTRUE\nTRUE\nTRUE\nTRUE\nexport/work/user/bug\nexport/work/user\nwork/user/bug/\nwork/user/bug\nraised ADA.IO_EXCEPTIONS.NAME_ERROR : relative path name \"bug/\" is\ncomposed of a single part\n\nraised ADA.IO_EXCEPTIONS.NAME_ERROR : relative path name \"bug\" is\ncomposed of a single part\n\nraised ADA.IO_EXCEPTIONS.NAME_ERROR : relative path name \"/\" is\ncomposed of a single part\n\nraised ADA.IO_EXCEPTIONS.NAME_ERROR : relative path name \".\" is\ncomposed of a single part\n\nraised ADA.IO_EXCEPTIONS.NAME_ERROR : relative path name \"..\" is\ncomposed of a single part\n\nwork/user/bug/.\nwork/user/bug/..\nContaining_Directory\n/export/work/user\n/export/work\nexport/work/user/bug\nexport/work/user\nbug\n.\nraised ADA.IO_EXCEPTIONS.USE_ERROR : directory \"/\" has no containing directory\n\nraised ADA.IO_EXCEPTIONS.USE_ERROR : directory \".\" has no containing directory\n\nraised ADA.IO_EXCEPTIONS.USE_ERROR : directory \"..\" has no containing directory\n\nexport/work/user/bug\nexport/work/user/bug\nInitial_Directory\n/\n/\nexport\nexport\nbug\nbug\n/\n.\n..\nexport\nexport\n\n2019-08-12  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-dhfina.adb, libgnat/a-dhfina.ads (Is_Simple_Name,\n\tIs_Root_Directory, Is_Parent_Directory,\n\tIs_Current_Directory_Name, Is_Relative_Name, Initial_Directory,\n\tRelative_Name, Compose): Add implementation and documentation.\n\t* libgnat/a-direct.adb (Containing_Directory): Modify routine to\n\tuse routines from Ada.Directories.Hierarchical_File_Names and\n\tremove incorrect special case for parent directories.\n\t(Fetch_Next_Entry): Add check for current directory and parent\n\tdirectory and ignore them under certain circumstances.\n\t(Simple_Nmae): Add check for null result from\n\tSimple_Name_Internal and raise Name_Error.\n\t(Simple_Name_Internal): Add explicit check for root directories,\n\tsanitize trailing directory separators, and modify behavior so\n\tthat current and parent directories are considered valid\n\tresults.\n\t* Makefile.rtl: Add entry to GNATRTL_NONTASKING_OBJS.\n\nFrom-SVN: r274295", "tree": {"sha": "c9ee8c1894c6ee0e7c10abf4f232b7e72d64c0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9ee8c1894c6ee0e7c10abf4f232b7e72d64c0c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5076fb182e2f99b46dca619f7be8e6e158bc902f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5076fb182e2f99b46dca619f7be8e6e158bc902f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5076fb182e2f99b46dca619f7be8e6e158bc902f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5076fb182e2f99b46dca619f7be8e6e158bc902f/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62f0fa2170c3875c28171caa4e1ce3a16a0dc18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62f0fa2170c3875c28171caa4e1ce3a16a0dc18b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62f0fa2170c3875c28171caa4e1ce3a16a0dc18b"}], "stats": {"total": 516, "additions": 466, "deletions": 50}, "files": [{"sha": "244e91799738c8ec9be16d86362954ad5d6e58ff", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5076fb182e2f99b46dca619f7be8e6e158bc902f", "patch": "@@ -1,3 +1,22 @@\n+2019-08-12  Justin Squirek  <squirek@adacore.com>\n+\n+\t* libgnat/a-dhfina.adb, libgnat/a-dhfina.ads (Is_Simple_Name,\n+\tIs_Root_Directory, Is_Parent_Directory,\n+\tIs_Current_Directory_Name, Is_Relative_Name, Initial_Directory,\n+\tRelative_Name, Compose): Add implementation and documentation.\n+\t* libgnat/a-direct.adb (Containing_Directory): Modify routine to\n+\tuse routines from Ada.Directories.Hierarchical_File_Names and\n+\tremove incorrect special case for parent directories.\n+\t(Fetch_Next_Entry): Add check for current directory and parent\n+\tdirectory and ignore them under certain circumstances.\n+\t(Simple_Nmae): Add check for null result from\n+\tSimple_Name_Internal and raise Name_Error.\n+\t(Simple_Name_Internal): Add explicit check for root directories,\n+\tsanitize trailing directory separators, and modify behavior so\n+\tthat current and parent directories are considered valid\n+\tresults.\n+\t* Makefile.rtl: Add entry to GNATRTL_NONTASKING_OBJS.\n+\n 2019-08-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* freeze.adb (Freeze_Entity): Give the same error for an"}, {"sha": "d6dd1514f4abc07b30282a591b7d04dc50d21d2d", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=5076fb182e2f99b46dca619f7be8e6e158bc902f", "patch": "@@ -171,6 +171,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cwila1$(objext) \\\n   a-cwila9$(objext) \\\n   a-decima$(objext) \\\n+  a-dhfina$(objext) \\\n   a-diocst$(objext) \\\n   a-direct$(objext) \\\n   a-direio$(objext) \\"}, {"sha": "df7c3454bb8c4fd01b9f9f21d8a8b8d65c9fb9f4", "filename": "gcc/ada/libgnat/a-dhfina.adb", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2Flibgnat%2Fa-dhfina.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2Flibgnat%2Fa-dhfina.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-dhfina.adb?ref=5076fb182e2f99b46dca619f7be8e6e158bc902f", "patch": "@@ -0,0 +1,332 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  ADA.DIRECTORIES.HIERARCHICAL_FILE_NAMES                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Characters.Handling;  use Ada.Characters.Handling;\n+with Ada.Directories.Validity; use Ada.Directories.Validity;\n+with Ada.Strings.Fixed;        use Ada.Strings.Fixed;\n+with System;                   use System;\n+\n+package body Ada.Directories.Hierarchical_File_Names is\n+\n+   Dir_Separator : constant Character;\n+   pragma Import (C, Dir_Separator, \"__gnat_dir_separator\");\n+   --  Running system default directory separator\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   function Equivalent_File_Names\n+     (Left  : String;\n+      Right : String)\n+      return Boolean;\n+   --  Perform an OS-independent comparison between two file paths\n+\n+   function Is_Absolute_Path (Name : String) return Boolean;\n+   --  Returns True if Name is an absolute path name, i.e. it designates a\n+   --  file or directory absolutely rather than relative to another directory.\n+\n+   ---------------------------\n+   -- Equivalent_File_Names --\n+   ---------------------------\n+\n+   function Equivalent_File_Names\n+     (Left  : String;\n+      Right : String)\n+      return Boolean\n+   is\n+   begin\n+      --  Check the validity of the input paths\n+\n+      if not Is_Valid_Path_Name (Left)\n+        or else not Is_Valid_Path_Name (Right)\n+      then\n+         return False;\n+      end if;\n+\n+      --  Normalize the paths by removing any trailing directory separators and\n+      --  perform the comparison.\n+\n+      declare\n+         Normal_Left  : constant String :=\n+           (if Index (Left, Dir_Separator & \"\", Strings.Backward) = Left'Last\n+              and then not Is_Root_Directory_Name (Left)\n+            then\n+               Left (Left'First .. Left'Last - 1)\n+            else\n+               Left);\n+\n+         Normal_Right : constant String :=\n+           (if Index (Right, Dir_Separator & \"\", Strings.Backward) = Right'Last\n+              and then not Is_Root_Directory_Name (Right)\n+            then\n+               Right (Right'First .. Right'Last - 1)\n+            else\n+               Right);\n+      begin\n+         --  Within Windows we assume case insensitivity\n+\n+         if not Windows then\n+            return Normal_Left = Normal_Right;\n+         end if;\n+\n+         --  Otherwise do a straight comparison\n+\n+         return To_Lower (Normal_Left) = To_Lower (Normal_Right);\n+      end;\n+   end Equivalent_File_Names;\n+\n+   ----------------------\n+   -- Is_Absolute_Path --\n+   ----------------------\n+\n+   function Is_Absolute_Path (Name : String) return Boolean is\n+      function Is_Absolute_Path\n+        (Name   : Address;\n+         Length : Integer) return Integer;\n+      pragma Import (C, Is_Absolute_Path, \"__gnat_is_absolute_path\");\n+   begin\n+      return Is_Absolute_Path (Name'Address, Name'Length) /= 0;\n+   end Is_Absolute_Path;\n+\n+   --------------------\n+   -- Is_Simple_Name --\n+   --------------------\n+\n+   function Is_Simple_Name (Name : String) return Boolean is\n+   begin\n+      --  Verify the file path name is valid and that it is not a root\n+\n+      if not Is_Valid_Path_Name (Name)\n+        or else Is_Root_Directory_Name (Name)\n+      then\n+         return False;\n+      end if;\n+\n+      --  Check for the special paths \".\" and \"..\", which are considered simple\n+\n+      if Is_Parent_Directory_Name (Name)\n+        or else Is_Current_Directory_Name (Name)\n+      then\n+         return True;\n+      end if;\n+\n+      --  Perform a comparison with the calculated simple path name\n+\n+      return Equivalent_File_Names (Simple_Name (Name), Name);\n+   end Is_Simple_Name;\n+\n+   ----------------------------\n+   -- Is_Root_Directory_Name --\n+   ----------------------------\n+\n+   function Is_Root_Directory_Name (Name : String) return Boolean is\n+   begin\n+      --  Check if the path name is a root directory by looking for a slash in\n+      --  the general case, and a drive letter in the case of Windows.\n+\n+      return Name = \"/\"\n+               or else\n+                 (Windows\n+                   and then\n+                     (Name = \"\\\"\n+                       or else\n+                         (Name'Length = 3\n+                           and then Name (Name'Last - 1) = ':'\n+                           and then Name (Name'Last) in '/' | '\\'\n+                           and then (Name (Name'First) in 'a' .. 'z'\n+                                      or else\n+                                        Name (Name'First) in 'A' .. 'Z'))\n+                       or else\n+                         (Name'Length = 2\n+                           and then Name (Name'Last) = ':'\n+                           and then (Name (Name'First) in 'a' .. 'z'\n+                                      or else\n+                                        Name (Name'First) in 'A' .. 'Z'))));\n+   end Is_Root_Directory_Name;\n+\n+   ------------------------------\n+   -- Is_Parent_Directory_Name --\n+   ------------------------------\n+\n+   function Is_Parent_Directory_Name (Name : String) return Boolean is\n+   begin\n+      return Name = \"..\";\n+   end Is_Parent_Directory_Name;\n+\n+   -------------------------------\n+   -- Is_Current_Directory_Name --\n+   -------------------------------\n+\n+   function Is_Current_Directory_Name (Name : String) return Boolean is\n+   begin\n+      return Name = \".\";\n+   end Is_Current_Directory_Name;\n+\n+   ------------------\n+   -- Is_Full_Name --\n+   ------------------\n+\n+   function Is_Full_Name (Name : String) return Boolean is\n+   begin\n+      return Equivalent_File_Names (Full_Name (Name), Name);\n+   end Is_Full_Name;\n+\n+   ----------------------\n+   -- Is_Relative_Name --\n+   ----------------------\n+\n+   function Is_Relative_Name (Name : String) return Boolean is\n+   begin\n+      return not Is_Absolute_Path (Name)\n+               and then Is_Valid_Path_Name (Name);\n+   end Is_Relative_Name;\n+\n+   -----------------------\n+   -- Initial_Directory --\n+   -----------------------\n+\n+   function Initial_Directory (Name : String) return String is\n+      Start : constant Integer := Index (Name, Dir_Separator & \"\");\n+   begin\n+      --  Verify path name\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error with \"invalid path name \"\"\" & Name & '\"';\n+      end if;\n+\n+      --  When there is no starting directory separator or the path name is a\n+      --  root directory then the path name is already simple - so return it.\n+\n+      if Is_Root_Directory_Name (Name) or else Start = 0 then\n+         return Name;\n+      end if;\n+\n+      --  When the initial directory of the path name is a root directory then\n+      --  the starting directory separator is part of the result so we must\n+      --  return it in the slice.\n+\n+      if Is_Root_Directory_Name (Name (Name'First .. Start)) then\n+         return Name (Name'First .. Start);\n+      end if;\n+\n+      --  Otherwise we grab a slice up to the starting directory separator\n+\n+      return Name (Name'First .. Start - 1);\n+   end Initial_Directory;\n+\n+   -------------------\n+   -- Relative_Name --\n+   -------------------\n+\n+   function Relative_Name (Name : String) return String is\n+   begin\n+      --  We cannot derive a relative name if Name does not exist\n+\n+      if not Is_Relative_Name (Name)\n+        and then not Is_Valid_Path_Name (Name)\n+      then\n+         raise Name_Error with \"invalid relative path name \"\"\" & Name & '\"';\n+      end if;\n+\n+      --  Name only has a single part and thus cannot be made relative\n+\n+      if Is_Simple_Name (Name)\n+        or else Is_Root_Directory_Name (Name)\n+      then\n+         raise Name_Error with\n+           \"relative path name \"\"\" & Name & \"\"\" is composed of a single part\";\n+      end if;\n+\n+      --  Trim the input according to the initial directory and maintain proper\n+      --  directory separation due to the fact that root directories may\n+      --  contain separators.\n+\n+      declare\n+         Init_Dir : constant String := Initial_Directory (Name);\n+      begin\n+         if Init_Dir (Init_Dir'Last) = Dir_Separator then\n+            return Name (Name'First + Init_Dir'Length .. Name'Last);\n+         end if;\n+\n+         return Name (Name'First + Init_Dir'Length + 1 .. Name'Last);\n+      end;\n+   end Relative_Name;\n+\n+   -------------\n+   -- Compose --\n+   -------------\n+\n+   function Compose\n+     (Directory     : String := \"\";\n+      Relative_Name : String;\n+      Extension     : String := \"\") return String\n+   is\n+      --  Append a directory separator if none is present\n+\n+      Separated_Dir : constant String :=\n+        (if    Directory = \"\" then \"\"\n+         elsif Directory (Directory'Last) = Dir_Separator then Directory\n+         else  Directory & Dir_Separator);\n+   begin\n+      --  Check that relative name is valid\n+\n+      if not Is_Relative_Name (Relative_Name) then\n+         raise Name_Error with\n+           \"invalid relative path name \"\"\" & Relative_Name & '\"';\n+      end if;\n+\n+      --  Check that directory is valid\n+\n+      if Separated_Dir /= \"\"\n+        and then (not Is_Valid_Path_Name (Separated_Dir & Relative_Name))\n+      then\n+         raise Name_Error with\n+           \"invalid path composition \"\"\" & Separated_Dir & Relative_Name & '\"';\n+      end if;\n+\n+      --  Check that the extension is valid\n+\n+      if Extension /= \"\"\n+        and then not Is_Valid_Path_Name\n+                       (Separated_Dir & Relative_Name & Extension)\n+      then\n+         raise Name_Error with\n+           \"invalid path composition \"\"\"\n+             & Separated_Dir & Relative_Name & Extension & '\"';\n+      end if;\n+\n+      --  Concatenate the result\n+\n+      return Separated_Dir & Relative_Name & Extension;\n+   end Compose;\n+\n+end Ada.Directories.Hierarchical_File_Names;"}, {"sha": "fe32d01c8983383d680dc2ba4031f408ff08db75", "filename": "gcc/ada/libgnat/a-dhfina.ads", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2Flibgnat%2Fa-dhfina.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2Flibgnat%2Fa-dhfina.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-dhfina.ads?ref=5076fb182e2f99b46dca619f7be8e6e158bc902f", "patch": "@@ -6,41 +6,101 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT.  In accordance with the copyright of that document, you can freely --\n--- copy and modify this specification,  provided that if you redistribute a --\n--- modified version,  any changes that you have made are clearly indicated. --\n+--          Copyright (C) 2004-2019, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n package Ada.Directories.Hierarchical_File_Names is\n-   pragma Unimplemented_Unit;\n \n    function Is_Simple_Name (Name : String) return Boolean;\n+   --  Returns True if Name is a simple name, and returns False otherwise.\n \n    function Is_Root_Directory_Name (Name : String) return Boolean;\n+   --  Returns True if Name is syntactically a root (a directory that cannot\n+   --  be decomposed further), and returns False otherwise.\n \n    function Is_Parent_Directory_Name (Name : String) return Boolean;\n+   --  Returns True if Name can be used to indicate symbolically the parent\n+   --  directory of any directory, and returns False otherwise.\n \n    function Is_Current_Directory_Name (Name : String) return Boolean;\n+   --  Returns True if Name can be used to indicate symbolically the directory\n+   --  itself for any directory, and returns False otherwise.\n \n    function Is_Full_Name (Name : String) return Boolean;\n+   --  Returns True if the leftmost directory part of Name is a root, and\n+   --  returns False otherwise.\n \n    function Is_Relative_Name (Name : String) return Boolean;\n+   --  Returns True if Name allows the identification of an external file\n+   --  (including directories and special files) but is not a full name, and\n+   --  returns False otherwise.\n \n    function Simple_Name (Name : String) return String\n      renames Ada.Directories.Simple_Name;\n+   --  Returns the simple name portion of the file name specified by Name. The\n+   --  exception Name_Error is propagated if the string given as Name does not\n+   --  allow the identification of an external file (including directories and\n+   --  special files).\n \n    function Containing_Directory (Name : String) return String\n      renames Ada.Directories.Containing_Directory;\n+   --  Returns the name of the containing directory of the external file\n+   --  (including directories) identified by Name. If more than one directory\n+   --  can contain Name, the directory name returned is implementation-defined.\n+   --  The exception Name_Error is propagated if the string given as Name does\n+   --  not allow the identification of an external file. The exception\n+   --  Use_Error is propagated if the external file does not have a containing\n+   --  directory.\n \n    function Initial_Directory (Name : String) return String;\n+   --  Returns the leftmost directory part in Name. That is, it returns a root\n+   --  directory name (for a full name), or one of a parent directory name, a\n+   --  current directory name, or a simple name (for a relative name). The\n+   --  exception Name_Error is propagated if the string given as Name does not\n+   --  allow the identification of an external file (including directories and\n+   --  special files).\n \n    function Relative_Name (Name : String) return String;\n+   --  Returns the entire file name except the Initial_Directory portion. The\n+   --  exception Name_Error is propagated if the string given as Name does not\n+   --  allow the identification of an external file (including directories and\n+   --  special files), or if Name has a single part (this includes if any of\n+   --  Is_Simple_Name, Is_Root_Directory_Name, Is_Parent_Directory_Name, or\n+   --  Is_Current_Directory_Name are True).\n \n    function Compose\n      (Directory      : String := \"\";\n       Relative_Name  : String;\n       Extension      : String := \"\") return String;\n+   --  Returns the name of the external file with the specified Directory,\n+   --  Relative_Name, and Extension. The exception Name_Error is propagated if\n+   --  the string given as Directory is not the null string and does not allow\n+   --  the identification of a directory, or if Is_Relative_Name\n+   --  (Relative_Name) is False, or if the string given as Extension is not\n+   --  the null string and is not a possible extension, or if Extension is not\n+   --  the null string and Simple_Name (Relative_Name) is not a base name.\n+   --\n+   --  The result of Compose is a full name if Is_Full_Name (Directory) is\n+   --  True; result is a relative name otherwise.\n \n end Ada.Directories.Hierarchical_File_Names;"}, {"sha": "1a1b7085ee2c056ffe531fecdfb0f836ac520626", "filename": "gcc/ada/libgnat/a-direct.adb", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2Flibgnat%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5076fb182e2f99b46dca619f7be8e6e158bc902f/gcc%2Fada%2Flibgnat%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-direct.adb?ref=5076fb182e2f99b46dca619f7be8e6e158bc902f", "patch": "@@ -33,6 +33,8 @@ with Ada.Calendar;               use Ada.Calendar;\n with Ada.Calendar.Formatting;    use Ada.Calendar.Formatting;\n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n with Ada.Directories.Validity;   use Ada.Directories.Validity;\n+with Ada.Directories.Hierarchical_File_Names;\n+use Ada.Directories.Hierarchical_File_Names;\n with Ada.Strings.Fixed;\n with Ada.Strings.Maps;           use Ada.Strings.Maps;\n with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n@@ -224,31 +226,22 @@ package body Ada.Directories is\n               Strings.Fixed.Index (Name, Dir_Seps, Going => Strings.Backward);\n \n          begin\n-            if Last_DS = 0 then\n-\n-               --  There is no directory separator, returns \".\" representing\n-               --  the current working directory.\n-\n-               return \".\";\n-\n             --  If Name indicates a root directory, raise Use_Error, because\n             --  it has no containing directory.\n \n-            elsif Name = \"/\"\n-              or else\n-                (Windows\n-                  and then\n-                  (Name = \"\\\"\n-                      or else\n-                        (Name'Length = 3\n-                          and then Name (Name'Last - 1 .. Name'Last) = \":\\\"\n-                          and then (Name (Name'First) in 'a' .. 'z'\n-                                     or else\n-                                       Name (Name'First) in 'A' .. 'Z'))))\n+            if Is_Parent_Directory_Name (Name)\n+              or else Is_Current_Directory_Name (Name)\n+              or else Is_Root_Directory_Name (Name)\n             then\n                raise Use_Error with\n                  \"directory \"\"\" & Name & \"\"\" has no containing directory\";\n \n+            elsif Last_DS = 0 then\n+               --  There is no directory separator, so return \".\", representing\n+               --  the current working directory.\n+\n+               return \".\";\n+\n             else\n                declare\n                   Last   : Positive := Last_DS - Name'First + 1;\n@@ -262,31 +255,14 @@ package body Ada.Directories is\n                   --  number on Windows.\n \n                   while Last > 1 loop\n-                     exit when\n-                       Result (Last) /= '/'\n-                         and then\n-                       Result (Last) /= Directory_Separator;\n-\n-                     exit when Windows\n-                       and then Last = 3\n-                       and then Result (2) = ':'\n-                       and then\n-                         (Result (1) in 'A' .. 'Z'\n-                           or else\n-                          Result (1) in 'a' .. 'z');\n+                     exit when Is_Root_Directory_Name (Result (1 .. Last))\n+                                 or else (Result (Last) /= Directory_Separator\n+                                           and then Result (Last) /= '/');\n \n                      Last := Last - 1;\n                   end loop;\n \n-                  --  Special case of \"..\": the current directory may be a root\n-                  --  directory.\n-\n-                  if Last = 2 and then Result (1 .. 2) = \"..\" then\n-                     return Containing_Directory (Current_Directory);\n-\n-                  else\n-                     return Result (1 .. Last);\n-                  end if;\n+                  return Result (1 .. Last);\n                end;\n             end if;\n          end;\n@@ -806,6 +782,20 @@ package body Ada.Directories is\n                end if;\n \n                if Exists = 1 then\n+                  --  Ignore special directories \".\" and \"..\"\n+\n+                  if (Full_Name'Length > 1\n+                       and then\n+                         Full_Name\n+                            (Full_Name'Last - 1 .. Full_Name'Last) = \"\\.\")\n+                    or else\n+                     (Full_Name'Length > 2\n+                        and then\n+                          Full_Name\n+                            (Full_Name'Last - 2 .. Full_Name'Last) = \"\\..\")\n+                  then\n+                     Exists := 0;\n+                  end if;\n \n                   --  Now check if the file kind matches the filter\n \n@@ -1280,16 +1270,30 @@ package body Ada.Directories is\n       function Simple_Name_Internal (Path : String) return String is\n          Cut_Start : Natural :=\n            Strings.Fixed.Index (Path, Dir_Seps, Going => Strings.Backward);\n-         Cut_End   : Natural;\n+\n+         --  Cut_End points to the last simple name character\n+\n+         Cut_End   : Natural := Path'Last;\n \n       begin\n-         --  Cut_Start pointS to the first simple name character\n+         --  Root directories are considered simple\n \n-         Cut_Start := (if Cut_Start = 0 then Path'First else Cut_Start + 1);\n+         if Is_Root_Directory_Name (Path) then\n+            return Path;\n+         end if;\n+\n+         --  Handle trailing directory separators\n+\n+         if Cut_Start = Path'Last then\n+            Cut_End   := Path'Last - 1;\n+            Cut_Start := Strings.Fixed.Index\n+                           (Path (Path'First .. Path'Last - 1),\n+                             Dir_Seps, Going => Strings.Backward);\n+         end if;\n \n-         --  Cut_End point to the last simple name character\n+         --  Cut_Start points to the first simple name character\n \n-         Cut_End := Path'Last;\n+         Cut_Start := (if Cut_Start = 0 then Path'First else Cut_Start + 1);\n \n          Check_For_Standard_Dirs : declare\n             BN : constant String := Path (Cut_Start .. Cut_End);\n@@ -1301,7 +1305,7 @@ package body Ada.Directories is\n \n          begin\n             if BN = \".\" or else BN = \"..\" then\n-               return \"\";\n+               return BN;\n \n             elsif Has_Drive_Letter\n               and then BN'Length > 2"}]}