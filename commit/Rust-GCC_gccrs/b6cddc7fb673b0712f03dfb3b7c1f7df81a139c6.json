{"sha": "b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjZGRjN2ZiNjczYjA3MTJmMDNkZmIzYjdjMWY3ZGY4MWExMzljNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-03-01T20:23:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-01T20:23:21Z"}, "message": "re PR ipa/65245 (internal compiler error: in address_matters_p, at symtab.c:1908)\n\n\n2015-02-28  Martin Liska  <mliska@suse.cz>\n\t    Jan Hubicka   <hubicka@ucw.cz>\n\n\tPR ipa/65245\n\t* ipa-icf-gimple.c (func_checker::compare_function_decl):\n\tRemove.\n\t(func_checker::compare_variable_decl): Skip symtab vars.\n\t(func_checker::compare_cst_or_decl): Update.\n\t* ipa-icf.c (sem_function::parse): Do not consider aliases.\n\t(sem_function::compare_cgraph_references): Add ADDRESS parameter;\n\tuse correct symtab predicates.\n\t(sem_function::equals_wpa): Update uses of compare_cgraph_references.\n\t(sem_variable::parse):  Update comment.\n\t(sem_item_optimizer::build_graph): Consider ultimate aliases\n\tfor references.\n\n\t* gcc.dg/ipa/ipa-icf-34.c: New test.\n\n\nCo-Authored-By: Jan Hubicka <hubicka@ucw.cz>\n\nFrom-SVN: r221090", "tree": {"sha": "fe24d2aee9562db1a7e4fe3b11e9626f5700ae13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe24d2aee9562db1a7e4fe3b11e9626f5700ae13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0e677d2e0e9252bd9cb32f3f606ebc7612217ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e677d2e0e9252bd9cb32f3f606ebc7612217ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0e677d2e0e9252bd9cb32f3f606ebc7612217ba"}], "stats": {"total": 152, "additions": 88, "deletions": 64}, "files": [{"sha": "ef9292f0f81a7064461de4e015bf6e64b711e39a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "patch": "@@ -1,3 +1,19 @@\n+2015-02-28  Martin Liska  <mliska@suse.cz>\n+\t    Jan Hubicka   <hubicka@ucw.cz>\n+\n+\tPR ipa/65245\n+\t* ipa-icf-gimple.c (func_checker::compare_function_decl):\n+\tRemove.\n+\t(func_checker::compare_variable_decl): Skip symtab vars.\n+\t(func_checker::compare_cst_or_decl): Update.\n+\t* ipa-icf.c (sem_function::parse): Do not consider aliases.\n+\t(sem_function::compare_cgraph_references): Add ADDRESS parameter;\n+\tuse correct symtab predicates.\n+\t(sem_function::equals_wpa): Update uses of compare_cgraph_references.\n+\t(sem_variable::parse):  Update comment.\n+\t(sem_item_optimizer::build_graph): Consider ultimate aliases\n+\tfor references.\n+\n 2015-02-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-icf-gimple.c (func_checker::compare_operand): Fix handling"}, {"sha": "7cc58d461e2905bbd123317716c703a7fb305610", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 7, "deletions": 51, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "patch": "@@ -312,10 +312,9 @@ func_checker::compare_cst_or_decl (tree t1, tree t2)\n \treturn return_with_debug (ret);\n       }\n     case FUNCTION_DECL:\n-      {\n-\tret = compare_function_decl (t1, t2);\n-\treturn return_with_debug (ret);\n-      }\n+      /* All function decls are in the symbol table and known to match\n+\t before we start comparing bodies.  */\n+      return true;\n     case VAR_DECL:\n       return return_with_debug (compare_variable_decl (t1, t2));\n     case FIELD_DECL:\n@@ -537,39 +536,6 @@ func_checker::compare_tree_list_operand (tree t1, tree t2)\n   return true;\n }\n \n-/* Verifies that trees T1 and T2, representing function declarations\n-   are equivalent from perspective of ICF.  */\n-\n-bool\n-func_checker::compare_function_decl (tree t1, tree t2)\n-{\n-  bool ret = false;\n-\n-  if (t1 == t2)\n-    return true;\n-\n-  symtab_node *n1 = symtab_node::get (t1);\n-  symtab_node *n2 = symtab_node::get (t2);\n-\n-  if (m_ignored_source_nodes != NULL && m_ignored_target_nodes != NULL)\n-    {\n-      ret = m_ignored_source_nodes->contains (n1)\n-\t    && m_ignored_target_nodes->contains (n2);\n-\n-      if (ret)\n-\treturn true;\n-    }\n-\n-  /* If function decl is WEAKREF, we compare targets.  */\n-  cgraph_node *f1 = cgraph_node::get (t1);\n-  cgraph_node *f2 = cgraph_node::get (t2);\n-\n-  if(f1 && f2 && f1->weakref && f2->weakref)\n-    ret = f1->alias_target == f2->alias_target;\n-\n-  return ret;\n-}\n-\n /* Verifies that trees T1 and T2 do correspond.  */\n \n bool\n@@ -590,20 +556,10 @@ func_checker::compare_variable_decl (tree t1, tree t2)\n       && DECL_ASSEMBLER_NAME (t1) != DECL_ASSEMBLER_NAME (t2))\n     return return_false_with_msg (\"HARD REGISTERS are different\");\n \n-  if (TREE_CODE (t1) == VAR_DECL && (DECL_EXTERNAL (t1) || TREE_STATIC (t1)))\n-    {\n-      symtab_node *n1 = symtab_node::get (t1);\n-      symtab_node *n2 = symtab_node::get (t2);\n-\n-      if (m_ignored_source_nodes != NULL && m_ignored_target_nodes != NULL)\n-\t{\n-\t  ret = m_ignored_source_nodes->contains (n1)\n-\t\t&& m_ignored_target_nodes->contains (n2);\n-\n-\t  if (ret)\n-\t    return true;\n-\t}\n-    }\n+  /* Symbol table variables are known to match before we start comparing\n+     bodies.  */\n+  if (decl_in_symtab_p (t1))\n+    return decl_in_symtab_p (t2);\n   ret = compare_decl (t1, t2);\n \n   return return_with_debug (ret);"}, {"sha": "0de69a83fb5a4d78f0c68aeacb53ca709096e72c", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "patch": "@@ -335,17 +335,26 @@ sem_function::get_hash (void)\n \n /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n    point to a same function. Comparison can be skipped if IGNORED_NODES\n-   contains these nodes.  */\n+   contains these nodes.  ADDRESS indicate if address is taken.  */\n \n bool\n-sem_function::compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n-    &ignored_nodes,\n-    symtab_node *n1, symtab_node *n2)\n+sem_function::compare_cgraph_references (\n+    hash_map <symtab_node *, sem_item *> &ignored_nodes,\n+    symtab_node *n1, symtab_node *n2, bool address)\n {\n-  if (n1 == n2 || (ignored_nodes.get (n1) && ignored_nodes.get (n2)))\n+  enum availability avail1, avail2;\n+\n+  if (address && n1->equal_address_to (n2) == 1)\n+    return true;\n+  if (!address && n1->semantically_equivalent_p (n2))\n     return true;\n \n-  /* TODO: add more precise comparison for weakrefs, etc.  */\n+  n1 = n1->ultimate_alias_target (&avail1);\n+  n2 = n2->ultimate_alias_target (&avail2);\n+\n+  if (avail1 >= AVAIL_INTERPOSABLE && ignored_nodes.get (n1)\n+      && avail2 >= AVAIL_INTERPOSABLE && ignored_nodes.get (n2))\n+    return true;\n \n   return return_false_with_msg (\"different references\");\n }\n@@ -412,7 +421,9 @@ sem_function::equals_wpa (sem_item *item,\n     {\n       item->node->iterate_reference (i, ref2);\n \n-      if (!compare_cgraph_references (ignored_nodes, ref->referred, ref2->referred))\n+      if (!compare_cgraph_references (ignored_nodes, ref->referred,\n+\t\t\t\t      ref2->referred,\n+\t\t\t\t      ref->address_matters_p ()))\n \treturn false;\n     }\n \n@@ -421,7 +432,8 @@ sem_function::equals_wpa (sem_item *item,\n \n   while (e1 && e2)\n     {\n-      if (!compare_cgraph_references (ignored_nodes, e1->callee, e2->callee))\n+      if (!compare_cgraph_references (ignored_nodes, e1->callee,\n+\t\t\t\t      e2->callee, false))\n \treturn false;\n \n       e1 = e1->next_callee;\n@@ -1117,7 +1129,7 @@ sem_function::parse (cgraph_node *node, bitmap_obstack *stack)\n   tree fndecl = node->decl;\n   function *func = DECL_STRUCT_FUNCTION (fndecl);\n \n-  /* TODO: add support for thunks and aliases.  */\n+  /* TODO: add support for thunks.  */\n \n   if (!func || !node->has_gimple_body_p ())\n     return NULL;\n@@ -1429,6 +1441,9 @@ sem_variable::parse (varpool_node *node, bitmap_obstack *stack)\n {\n   tree decl = node->decl;\n \n+  if (node->alias)\n+    return NULL;\n+\n   bool readonly = TYPE_P (decl) ? TYPE_READONLY (decl) : TREE_READONLY (decl);\n   if (!readonly)\n     return NULL;\n@@ -2086,7 +2101,8 @@ sem_item_optimizer::build_graph (void)\n \t  cgraph_edge *e = cnode->callees;\n \t  while (e)\n \t    {\n-\t      sem_item **slot = m_symtab_node_map.get (e->callee);\n+\t      sem_item **slot = m_symtab_node_map.get\n+\t\t(e->callee->ultimate_alias_target ());\n \t      if (slot)\n \t\titem->add_reference (*slot);\n \n@@ -2097,7 +2113,8 @@ sem_item_optimizer::build_graph (void)\n       ipa_ref *ref = NULL;\n       for (unsigned i = 0; item->node->iterate_reference (i, ref); i++)\n \t{\n-\t  sem_item **slot = m_symtab_node_map.get (ref->referred);\n+\t  sem_item **slot = m_symtab_node_map.get\n+\t    (ref->referred->ultimate_alias_target ());\n \t  if (slot)\n \t    item->add_reference (*slot);\n \t}"}, {"sha": "bf01cf09f213a967a15318fece3cc8cc157ce05d", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "patch": "@@ -353,10 +353,11 @@ class sem_function: public sem_item\n \n   /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n      point to a same function. Comparison can be skipped if IGNORED_NODES\n-     contains these nodes.  */\n+     contains these nodes.  ADDRESS indicate if address is taken.  */\n   bool compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n \t\t\t\t  &ignored_nodes,\n-\t\t\t\t  symtab_node *n1, symtab_node *n2);\n+\t\t\t\t  symtab_node *n1, symtab_node *n2,\n+\t\t\t\t  bool address);\n \n   /* Processes function equality comparison.  */\n   bool equals_private (sem_item *item,"}, {"sha": "e397689d287c731c36dbe7b97b4c8b400524b555", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "patch": "@@ -1,3 +1,9 @@\n+2015-02-28  Martin Liska  <mliska@suse.cz>\n+\t    Jan Hubicka   <hubicka@ucw.cz>\n+\n+\tPR ipa/65245\n+\t* gcc.dg/ipa/ipa-icf-34.c: New test.\n+\n 2015-03-01  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/61142"}, {"sha": "698044ae22d096f9d43921aec3d1db3058074136", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-icf-34.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-34.c?ref=b6cddc7fb673b0712f03dfb3b7c1f7df81a139c6", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -fipa-icf -fdump-ipa-icf\"  } */\n+\n+static int do_work(void)\n+{\n+  return 0;\n+}\n+\n+static int foo() __attribute__((alias(\"do_work\")));\n+static int bar() __attribute__((alias(\"do_work\")));\n+\n+static int a()\n+{\n+  return foo();\n+}\n+\n+static int b()\n+{\n+  return bar();\n+}\n+\n+int main()\n+{\n+  return a() + b();\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Equal symbols: 1\" \"icf\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"icf\" } } */"}]}