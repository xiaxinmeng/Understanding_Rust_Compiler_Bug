{"sha": "c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzllOTI2Y2UyYmRjOGJkY2U1ZmQ5ODkyNDQzY2Y2MTQ3ODY4ZTdmNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-17T18:47:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-17T18:47:44Z"}, "message": "Add genmatch support for internal functions\n\nThis patch makes genmatch match calls based on combined_fn rather\nthan built_in_function and extends the matching to internal functions.\nIt also uses fold_const_call to fold the calls to a constant, rather\nthan going through fold_builtin_n.\n\nIn order to slightly simplify the code and remove potential\nambiguity, the patch enforces lower case for tree codes\n(foo->FOO_EXPR), caps for functions (no built_in_hypot->BUILT_IN_HYPOT)\nand requires an exact match for user-defined identifiers.  The first two\nwere already met in practice but there were a couple of cases where\noperator lists were defined in one case and used in another.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* match.pd: Use HYPOT and COS rather than hypot and cos.\n\tUse CASE_CFN_* macros.  Guard log/exp folds with\n\tSCALAR_FLOAT_TYPE_P.\n\t* genmatch.c (internal_fn): New enum.\n\t(fn_id::fn): Change to an unsigned int.\n\t(fn_id::fn_id): Accept internal_fn too.\n\t(add_builtin): Rename to...\n\t(add_function): ...this and turn into a template.\n\t(get_operator): Only try one variation if the original name fails.\n\tOnly add _EXPR if the original name was all lower case.\n\tTry converting internal and built-in function names to their\n\tCFN equivalents.\n\t(expr::gen_transform): Use maybe_build_call_expr_loc for generic.\n\t(dt_simplify::gen_1): Likewise.\n\t(dt_node::gen_kids_1): Use gimple_call_combined_fn for gimple\n\tand get_call_combined_fn for generic.\n\t(dt_simplify::gen): Use combined_fn as the type of fn_ids.\n\t(decision_tree::gen): Likewise.\n\t(main): Use lower case in the strings for {VIEW_,}CONVERT[012].\n\tUse add_function rather than add_builtin.  Register internal\n\tfunctions too.\n\t* generic-match-head.c: Include case-cfn-macros.h.\n\t* gimple-fold.c (replace_stmt_with_simplification): Use\n\tgimple_call_combined_fn to test whether we can keep an\n\texisting call.\n\t* gimple-match.h (code_helper): Replace built_in_function\n\twith combined_fn.\n\t* gimple-match-head.c: Include fold-const-call.h, internal-fn.h\n\tand case-fn-macros.h.\n\t(gimple_resimplify1): Use fold_const_call.\n\t(gimple_resimplify2, gimple_resimplify3): Likewise.\n\t(build_call_internal, build_call): New functions.\n\t(maybe_push_res_to_seq): Use them.\n\t(gimple_simplify): Use fold_const_call.  Set *rcode to a combined_fn\n\trather than a built-in function.\n\t* tree.h (build_call_expr_internal_loc): Declare.\n\t(maybe_build_call_expr_loc): Likewise.\n\t* tree.c (build_call_expr_internal_loc_array): New function.\n\t(maybe_build_call_expr_loc): Likewise.\n\nFrom-SVN: r230484", "tree": {"sha": "85646c7ff97526585c06596877a86bf8c493a6b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85646c7ff97526585c06596877a86bf8c493a6b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b03ff92e67280a98ab1587e0460069eea0fd5a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03ff92e67280a98ab1587e0460069eea0fd5a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03ff92e67280a98ab1587e0460069eea0fd5a8b"}], "stats": {"total": 550, "additions": 309, "deletions": 241}, "files": [{"sha": "af6477a6b6d9bed5496d3c52ab97b801dd7637d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -1,3 +1,45 @@\n+2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* match.pd: Use HYPOT and COS rather than hypot and cos.\n+\tUse CASE_CFN_* macros.  Guard log/exp folds with\n+\tSCALAR_FLOAT_TYPE_P.\n+\t* genmatch.c (internal_fn): New enum.\n+\t(fn_id::fn): Change to an unsigned int.\n+\t(fn_id::fn_id): Accept internal_fn too.\n+\t(add_builtin): Rename to...\n+\t(add_function): ...this and turn into a template.\n+\t(get_operator): Only try one variation if the original name fails.\n+\tOnly add _EXPR if the original name was all lower case.\n+\tTry converting internal and built-in function names to their\n+\tCFN equivalents.\n+\t(expr::gen_transform): Use maybe_build_call_expr_loc for generic.\n+\t(dt_simplify::gen_1): Likewise.\n+\t(dt_node::gen_kids_1): Use gimple_call_combined_fn for gimple\n+\tand get_call_combined_fn for generic.\n+\t(dt_simplify::gen): Use combined_fn as the type of fn_ids.\n+\t(decision_tree::gen): Likewise.\n+\t(main): Use lower case in the strings for {VIEW_,}CONVERT[012].\n+\tUse add_function rather than add_builtin.  Register internal\n+\tfunctions too.\n+\t* generic-match-head.c: Include case-cfn-macros.h.\n+\t* gimple-fold.c (replace_stmt_with_simplification): Use\n+\tgimple_call_combined_fn to test whether we can keep an\n+\texisting call.\n+\t* gimple-match.h (code_helper): Replace built_in_function\n+\twith combined_fn.\n+\t* gimple-match-head.c: Include fold-const-call.h, internal-fn.h\n+\tand case-fn-macros.h.\n+\t(gimple_resimplify1): Use fold_const_call.\n+\t(gimple_resimplify2, gimple_resimplify3): Likewise.\n+\t(build_call_internal, build_call): New functions.\n+\t(maybe_push_res_to_seq): Use them.\n+\t(gimple_simplify): Use fold_const_call.  Set *rcode to a combined_fn\n+\trather than a built-in function.\n+\t* tree.h (build_call_expr_internal_loc): Declare.\n+\t(maybe_build_call_expr_loc): Likewise.\n+\t* tree.c (build_call_expr_internal_loc_array): New function.\n+\t(maybe_build_call_expr_loc): Likewise.\n+\n 2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* builtins.h (mathfn_built_in): Add a variant that takes"}, {"sha": "f55f91e7fb998128b5c67cc83dac62a9dbaf2225", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"builtins.h\"\n #include \"dumpfile.h\"\n+#include \"case-cfn-macros.h\"\n \n \n /* Routine to determine if the types T1 and T2 are effectively"}, {"sha": "daa66d93ef3de07814b55e05326f4531cfcbe2b1", "filename": "gcc/genmatch.c", "status": "modified", "additions": 77, "deletions": 80, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -230,6 +230,12 @@ enum built_in_function {\n END_BUILTINS\n };\n \n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) IFN_##CODE,\n+enum internal_fn {\n+#include \"internal-fn.def\"\n+  IFN_LAST\n+};\n+\n /* Return true if CODE represents a commutative tree code.  Otherwise\n    return false.  */\n bool\n@@ -341,13 +347,15 @@ struct operator_id : public id_base\n   const char *tcc;\n };\n \n-/* Identifier that maps to a builtin function code.  */\n+/* Identifier that maps to a builtin or internal function code.  */\n \n struct fn_id : public id_base\n {\n   fn_id (enum built_in_function fn_, const char *id_)\n       : id_base (id_base::FN, id_), fn (fn_) {}\n-  enum built_in_function fn;\n+  fn_id (enum internal_fn fn_, const char *id_)\n+      : id_base (id_base::FN, id_), fn (int (END_BUILTINS) + int (fn_)) {}\n+  unsigned int fn;\n };\n \n struct simplify;\n@@ -447,10 +455,12 @@ add_operator (enum tree_code code, const char *id,\n   *slot = op;\n }\n \n-/* Add a builtin identifier to the hash.  */\n+/* Add a built-in or internal function identifier to the hash.  ID is\n+   the name of its CFN_* enumeration value.  */\n \n+template <typename T>\n static void\n-add_builtin (enum built_in_function code, const char *id)\n+add_function (T code, const char *id)\n {\n   fn_id *fn = new fn_id (code, id);\n   id_base **slot = operators->find_slot_with_hash (fn, fn->hashval, INSERT);\n@@ -485,30 +495,32 @@ get_operator (const char *id)\n       return op;\n     }\n \n-  /* Try all-uppercase.  */\n-  char *id2 = xstrdup (id);\n-  for (unsigned i = 0; i < strlen (id2); ++i)\n-    id2[i] = TOUPPER (id2[i]);\n-  new (&tem) id_base (id_base::CODE, id2);\n-  op = operators->find_with_hash (&tem, tem.hashval);\n-  if (op)\n+  char *id2;\n+  bool all_upper = true;\n+  bool all_lower = true;\n+  for (unsigned int i = 0; id[i]; ++i)\n+    if (ISUPPER (id[i]))\n+      all_lower = false;\n+    else if (ISLOWER (id[i]))\n+      all_upper = false;\n+  if (all_lower)\n     {\n-      free (id2);\n-      return op;\n+      /* Try in caps with _EXPR appended.  */\n+      id2 = ACONCAT ((id, \"_EXPR\", NULL));\n+      for (unsigned int i = 0; id2[i]; ++i)\n+\tid2[i] = TOUPPER (id2[i]);\n     }\n+  else if (all_upper && strncmp (id, \"IFN_\", 4) == 0)\n+    /* Try CFN_ instead of IFN_.  */\n+    id2 = ACONCAT ((\"CFN_\", id + 4, NULL));\n+  else if (all_upper && strncmp (id, \"BUILT_IN_\", 9) == 0)\n+    /* Try prepending CFN_.  */\n+    id2 = ACONCAT ((\"CFN_\", id, NULL));\n+  else\n+    return NULL;\n \n-  /* Try _EXPR appended.  */\n-  id2 = (char *)xrealloc (id2, strlen (id2) + sizeof (\"_EXPR\") + 1);\n-  strcat (id2, \"_EXPR\");\n   new (&tem) id_base (id_base::CODE, id2);\n-  op = operators->find_with_hash (&tem, tem.hashval);\n-  if (op)\n-    {\n-      free (id2);\n-      return op;\n-    }\n-\n-  return 0;\n+  return operators->find_with_hash (&tem, tem.hashval);\n }\n \n typedef hash_map<nofree_string_hash, unsigned> cid_map_t;\n@@ -2207,17 +2219,18 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       else\n \t{\n \t  fprintf_indent (f, indent, \"{\\n\");\n-\t  fprintf_indent (f, indent, \"  tree decl = builtin_decl_implicit (%s);\\n\",\n-\t\t\t  opr_name);\n-\t  fprintf_indent (f, indent, \"  if (!decl) return NULL_TREE;\\n\");\n-\t  fprintf_indent (f, indent, \"  res = build_call_expr_loc (loc, \"\n-\t\t\t  \"decl, %d\", ops.length());\n+\t  fprintf_indent (f, indent, \"  res = maybe_build_call_expr_loc (loc, \"\n+\t\t\t  \"%s, %s, %d\", opr_name, type, ops.length());\n \t}\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \", ops%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");\n       if (opr->kind != id_base::CODE)\n-\tfprintf_indent (f, indent, \"}\\n\");\n+\t{\n+\t  fprintf_indent (f, indent, \"  if (!res)\\n\");\n+\t  fprintf_indent (f, indent, \"    return NULL_TREE;\\n\");\n+\t  fprintf_indent (f, indent, \"}\\n\");\n+\t}\n       if (*opr == CONVERT_EXPR)\n \t{\n \t  indent -= 2;\n@@ -2665,20 +2678,14 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n       if (fns_len)\n \t{\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"%sif (gimple_call_builtin_p (def_stmt, BUILT_IN_NORMAL))\\n\",\n+\t\t\t  \"%sif (gcall *def = dyn_cast <gcall *>\"\n+\t\t\t  \" (def_stmt))\\n\",\n \t\t\t  exprs_len ? \"else \" : \"\");\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"  {\\n\");\n-\t  fprintf_indent (f, indent,\n-\t\t\t  \"    gcall *def = as_a <gcall *> (def_stmt);\\n\");\n-\t  fprintf_indent (f, indent,\n-\t\t\t  \"    tree fndecl = gimple_call_fndecl (def);\\n\");\n-\t  fprintf_indent (f, indent,\n-\t\t\t  \"    switch (DECL_FUNCTION_CODE (fndecl))\\n\");\n-\t  fprintf_indent (f, indent,\n-\t\t\t  \"      {\\n\");\n+\t\t\t  \"  switch (gimple_call_combined_fn (def))\\n\");\n \n-\t  indent += 6;\n+\t  indent += 4;\n+\t  fprintf_indent (f, indent, \"{\\n\");\n \t  for (unsigned i = 0; i < fns_len; ++i)\n \t    {\n \t      expr *e = as_a <expr *>(fns[i]->op);\n@@ -2691,8 +2698,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \n \t  fprintf_indent (f, indent, \"default:;\\n\");\n \t  fprintf_indent (f, indent, \"}\\n\");\n-\t  indent -= 6;\n-\t  fprintf_indent (f, indent, \"  }\\n\");\n+\t  indent -= 4;\n \t}\n \n       indent -= 6;\n@@ -2719,17 +2725,11 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n       fprintf_indent (f, indent,\n \t\t      \"case CALL_EXPR:\\n\");\n       fprintf_indent (f, indent,\n-\t\t      \"  {\\n\");\n-      fprintf_indent (f, indent,\n-\t\t      \"    tree fndecl = get_callee_fndecl (%s);\\n\",\n+\t\t      \"  switch (get_call_combined_fn (%s))\\n\",\n \t\t      kid_opname);\n       fprintf_indent (f, indent,\n-\t\t      \"    if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\\n\");\n-      fprintf_indent (f, indent,\n-\t\t      \"      switch (DECL_FUNCTION_CODE (fndecl))\\n\");\n-      fprintf_indent (f, indent,\n-\t\t      \"        {\\n\");\n-      indent += 8;\n+\t\t      \"    {\\n\");\n+      indent += 4;\n \n       for (unsigned j = 0; j < generic_fns.length (); ++j)\n \t{\n@@ -2742,12 +2742,11 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t  fprintf_indent (f, indent, \"    break;\\n\");\n \t  fprintf_indent (f, indent, \"  }\\n\");\n \t}\n+      fprintf_indent (f, indent, \"default:;\\n\");\n \n-      indent -= 8;\n-      fprintf_indent (f, indent, \"          default:;\\n\");\n-      fprintf_indent (f, indent, \"        }\\n\");\n-      fprintf_indent (f, indent, \"    break;\\n\");\n-      fprintf_indent (f, indent, \"  }\\n\");\n+      indent -= 4;\n+      fprintf_indent (f, indent, \"    }\\n\");\n+      fprintf_indent (f, indent, \"  break;\\n\");\n     }\n \n   /* Close switch (TREE_CODE ()).  */\n@@ -3108,24 +3107,18 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t\t\t    *e->operation == CONVERT_EXPR\n \t\t\t\t    ? \"NOP_EXPR\" : e->operation->id);\n \t\t  else\n-\t\t    {\n-\t\t      fprintf_indent (f, indent,\n-\t\t\t\t      \"{\\n\");\n-\t\t      fprintf_indent (f, indent,\n-\t\t\t\t      \"  tree decl = builtin_decl_implicit (%s);\\n\",\n-\t\t\t\t      e->operation->id);\n-\t\t      fprintf_indent (f, indent,\n-\t\t\t\t      \"  if (!decl) return NULL_TREE;\\n\");\n-\t\t      fprintf_indent (f, indent,\n-\t\t\t\t      \"  res = build_call_expr_loc \"\n-\t\t\t\t      \"(loc, decl, %d\",\n-\t\t\t\t      e->ops.length());\n-\t\t    }\n+\t\t    fprintf_indent (f, indent,\n+\t\t\t\t    \"res = maybe_build_call_expr_loc (loc, \"\n+\t\t\t\t    \"%s, type, %d\", e->operation->id,\n+\t\t\t\t    e->ops.length());\n \t\t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t\t    fprintf (f, \", res_op%d\", j);\n \t\t  fprintf (f, \");\\n\");\n \t\t  if (!is_a <operator_id *> (opr))\n-\t\t    fprintf_indent (f, indent, \"}\\n\");\n+\t\t    {\n+\t\t      fprintf_indent (f, indent, \"if (!res)\\n\");\n+\t\t      fprintf_indent (f, indent, \"  return NULL_TREE;\\n\");\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -3225,7 +3218,7 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t\t\t    s->for_subst_vec[i].first->id,\n \t\t\t    s->for_subst_vec[i].second->id);\n \t  else if (is_a <fn_id *> (s->for_subst_vec[i].second))\n-\t    fprintf_indent (f, indent, \"enum built_in_function %s = %s;\\n\",\n+\t    fprintf_indent (f, indent, \"combined_fn %s = %s;\\n\",\n \t\t\t    s->for_subst_vec[i].first->id,\n \t\t\t    s->for_subst_vec[i].second->id);\n \t  else\n@@ -3380,7 +3373,7 @@ decision_tree::gen (FILE *f, bool gimple)\n \t    fprintf (f, \", enum tree_code ARG_UNUSED (%s)\",\n \t\t     s->s->s->for_subst_vec[i].first->id);\n \t  else if (is_a <fn_id *> (s->s->s->for_subst_vec[i].second))\n-\t    fprintf (f, \", enum built_in_function ARG_UNUSED (%s)\",\n+\t    fprintf (f, \", combined_fn ARG_UNUSED (%s)\",\n \t\t     s->s->s->for_subst_vec[i].first->id);\n \t}\n \n@@ -4603,22 +4596,26 @@ main (int argc, char **argv)\n   add_operator (SYM, # SYM, # TYPE, NARGS);\n #define END_OF_BASE_TREE_CODES\n #include \"tree.def\"\n-add_operator (CONVERT0, \"CONVERT0\", \"tcc_unary\", 1);\n-add_operator (CONVERT1, \"CONVERT1\", \"tcc_unary\", 1);\n-add_operator (CONVERT2, \"CONVERT2\", \"tcc_unary\", 1);\n-add_operator (VIEW_CONVERT0, \"VIEW_CONVERT0\", \"tcc_unary\", 1);\n-add_operator (VIEW_CONVERT1, \"VIEW_CONVERT1\", \"tcc_unary\", 1);\n-add_operator (VIEW_CONVERT2, \"VIEW_CONVERT2\", \"tcc_unary\", 1);\n+add_operator (CONVERT0, \"convert0\", \"tcc_unary\", 1);\n+add_operator (CONVERT1, \"convert1\", \"tcc_unary\", 1);\n+add_operator (CONVERT2, \"convert2\", \"tcc_unary\", 1);\n+add_operator (VIEW_CONVERT0, \"view_convert0\", \"tcc_unary\", 1);\n+add_operator (VIEW_CONVERT1, \"view_convert1\", \"tcc_unary\", 1);\n+add_operator (VIEW_CONVERT2, \"view_convert2\", \"tcc_unary\", 1);\n #undef END_OF_BASE_TREE_CODES\n #undef DEFTREECODE\n \n   /* Pre-seed builtin functions.\n      ???  Cannot use N (name) as that is targetm.emultls.get_address\n      for BUILT_IN_EMUTLS_GET_ADDRESS ... */\n #define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA, AT, IM, COND) \\\n-  add_builtin (ENUM, # ENUM);\n+  add_function (ENUM, \"CFN_\" # ENUM);\n #include \"builtins.def\"\n \n+#define DEF_INTERNAL_FN(CODE, NAME, FNSPEC) \\\n+  add_function (IFN_##CODE, \"CFN_\" #CODE);\n+#include \"internal-fn.def\"\n+\n   /* Parse ahead!  */\n   parser p (r);\n "}, {"sha": "1ab20d11fa76fc1642411e53f339f1ee6ff2181f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -3369,7 +3369,7 @@ replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n \t}\n     }\n   else if (rcode.is_fn_code ()\n-\t   && gimple_call_builtin_p (stmt, rcode))\n+\t   && gimple_call_combined_fn (stmt) == rcode)\n     {\n       unsigned i;\n       for (i = 0; i < gimple_call_num_args (stmt); ++i)"}, {"sha": "bdc1f9828644a3793aa1a3a6840beea53112c1de", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 78, "deletions": 108, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -28,13 +28,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"cgraph.h\"\n #include \"fold-const.h\"\n+#include \"fold-const-call.h\"\n #include \"stor-layout.h\"\n #include \"gimple-fold.h\"\n #include \"calls.h\"\n #include \"tree-dfa.h\"\n #include \"builtins.h\"\n #include \"gimple-match.h\"\n #include \"tree-pass.h\"\n+#include \"internal-fn.h\"\n+#include \"case-cfn-macros.h\"\n \n \n /* Forward declarations of the private auto-generated matchers.\n@@ -81,19 +84,7 @@ gimple_resimplify1 (gimple_seq *seq,\n       if (res_code->is_tree_code ())\n \ttem = const_unop (*res_code, type, res_ops[0]);\n       else\n-\t{\n-\t  tree decl = builtin_decl_implicit (*res_code);\n-\t  if (decl)\n-\t    {\n-\t      tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 1, false);\n-\t      if (tem)\n-\t\t{\n-\t\t  /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n-\t\t  STRIP_NOPS (tem);\n-\t\t  tem = fold_convert (type, tem);\n-\t\t}\n-\t    }\n-\t}\n+\ttem = fold_const_call (combined_fn (*res_code), type, res_ops[0]);\n       if (tem != NULL_TREE\n \t  && CONSTANT_CLASS_P (tem))\n \t{\n@@ -137,19 +128,8 @@ gimple_resimplify2 (gimple_seq *seq,\n       if (res_code->is_tree_code ())\n \ttem = const_binop (*res_code, type, res_ops[0], res_ops[1]);\n       else\n-\t{\n-\t  tree decl = builtin_decl_implicit (*res_code);\n-\t  if (decl)\n-\t    {\n-\t      tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 2, false);\n-\t      if (tem)\n-\t\t{\n-\t\t  /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n-\t\t  STRIP_NOPS (tem);\n-\t\t  tem = fold_convert (type, tem);\n-\t\t}\n-\t    }\n-\t}\n+\ttem = fold_const_call (combined_fn (*res_code), type,\n+\t\t\t       res_ops[0], res_ops[1]);\n       if (tem != NULL_TREE\n \t  && CONSTANT_CLASS_P (tem))\n \t{\n@@ -208,19 +188,8 @@ gimple_resimplify3 (gimple_seq *seq,\n \ttem = fold_ternary/*_to_constant*/ (*res_code, type, res_ops[0],\n \t\t\t\t\t    res_ops[1], res_ops[2]);\n       else\n-\t{\n-\t  tree decl = builtin_decl_implicit (*res_code);\n-\t  if (decl)\n-\t    {\n-\t      tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 3, false);\n-\t      if (tem)\n-\t\t{\n-\t\t  /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n-\t\t  STRIP_NOPS (tem);\n-\t\t  tem = fold_convert (type, tem);\n-\t\t}\n-\t    }\n-\t}\n+\ttem = fold_const_call (combined_fn (*res_code), type,\n+\t\t\t       res_ops[0], res_ops[1], res_ops[2]);\n       if (tem != NULL_TREE\n \t  && CONSTANT_CLASS_P (tem))\n \t{\n@@ -282,6 +251,22 @@ maybe_build_generic_op (enum tree_code code, tree type,\n \n tree (*mprts_hook) (code_helper, tree, tree *);\n \n+/* Try to build a call to FN with return type TYPE and the NARGS\n+   arguments given in OPS.  Return null if the target doesn't support\n+   the function.  */\n+\n+static gcall *\n+build_call_internal (internal_fn fn, tree type, unsigned int nargs, tree *ops)\n+{\n+  if (direct_internal_fn_p (fn))\n+    {\n+      tree_pair types = direct_internal_fn_types (fn, type, ops);\n+      if (!direct_internal_fn_supported_p (fn, types))\n+\treturn NULL;\n+    }\n+  return gimple_build_call_internal (fn, nargs, ops[0], ops[1], ops[2]);\n+}\n+\n /* Push the exploded expression described by RCODE, TYPE and OPS\n    as a statement to SEQ if necessary and return a gimple value\n    denoting the value of the expression.  If RES is not NULL\n@@ -333,12 +318,7 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n     {\n       if (!seq)\n \treturn NULL_TREE;\n-      tree decl = builtin_decl_implicit (rcode);\n-      if (!decl)\n-\treturn NULL_TREE;\n-      /* We can't and should not emit calls to non-const functions.  */\n-      if (!(flags_from_decl_or_type (decl) & ECF_CONST))\n-\treturn NULL_TREE;\n+      combined_fn fn = rcode;\n       /* Play safe and do not allow abnormals to be mentioned in\n          newly created statements.  */\n       unsigned nargs;\n@@ -351,14 +331,35 @@ maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,\n \t    return NULL_TREE;\n \t}\n       gcc_assert (nargs != 0);\n+      gcall *new_stmt = NULL;\n+      if (internal_fn_p (fn))\n+\t{\n+\t  /* Generate the given function if we can.  */\n+\t  internal_fn ifn = as_internal_fn (fn);\n+\t  new_stmt = build_call_internal (ifn, type, nargs, ops);\n+\t  if (!new_stmt)\n+\t    return NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* Find the function we want to call.  */\n+\t  tree decl = builtin_decl_implicit (as_builtin_fn (fn));\n+\t  if (!decl)\n+\t    return NULL;\n+\n+\t  /* We can't and should not emit calls to non-const functions.  */\n+\t  if (!(flags_from_decl_or_type (decl) & ECF_CONST))\n+\t    return NULL;\n+\n+\t  new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n+\t}\n       if (!res)\n \t{\n \t  if (gimple_in_ssa_p (cfun))\n \t    res = make_ssa_name (type);\n \t  else\n \t    res = create_tmp_reg (type);\n \t}\n-      gimple *new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);\n       gimple_call_set_lhs (new_stmt, res);\n       gimple_seq_add_stmt_without_update (seq, new_stmt);\n       return res;\n@@ -471,25 +472,15 @@ gimple_simplify (enum built_in_function fn, tree type,\n {\n   if (constant_for_folding (arg0))\n     {\n-      tree decl = builtin_decl_implicit (fn);\n-      if (decl)\n-\t{\n-\t  tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, &arg0, 1, false);\n-\t  if (res)\n-\t    {\n-\t      /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n-\t      STRIP_NOPS (res);\n-\t      res = fold_convert (type, res);\n-\t      if (CONSTANT_CLASS_P (res))\n-\t\treturn res;\n-\t    }\n-\t}\n+      tree res = fold_const_call (as_combined_fn (fn), type, arg0);\n+      if (res && CONSTANT_CLASS_P (res))\n+\treturn res;\n     }\n \n   code_helper rcode;\n   tree ops[3] = {};\n   if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tfn, type, arg0))\n+\t\t\tas_combined_fn (fn), type, arg0))\n     return NULL_TREE;\n   return maybe_push_res_to_seq (rcode, type, ops, seq);\n }\n@@ -504,28 +495,15 @@ gimple_simplify (enum built_in_function fn, tree type,\n   if (constant_for_folding (arg0)\n       && constant_for_folding (arg1))\n     {\n-      tree decl = builtin_decl_implicit (fn);\n-      if (decl)\n-\t{\n-\t  tree args[2];\n-\t  args[0] = arg0;\n-\t  args[1] = arg1;\n-\t  tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, args, 2, false);\n-\t  if (res)\n-\t    {\n-\t      /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n-\t      STRIP_NOPS (res);\n-\t      res = fold_convert (type, res);\n-\t      if (CONSTANT_CLASS_P (res))\n-\t\treturn res;\n-\t    }\n-\t}\n+      tree res = fold_const_call (as_combined_fn (fn), type, arg0, arg1);\n+      if (res && CONSTANT_CLASS_P (res))\n+\treturn res;\n     }\n \n   code_helper rcode;\n   tree ops[3] = {};\n   if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tfn, type, arg0, arg1))\n+\t\t\tas_combined_fn (fn), type, arg0, arg1))\n     return NULL_TREE;\n   return maybe_push_res_to_seq (rcode, type, ops, seq);\n }\n@@ -541,29 +519,15 @@ gimple_simplify (enum built_in_function fn, tree type,\n       && constant_for_folding (arg1)\n       && constant_for_folding (arg2))\n     {\n-      tree decl = builtin_decl_implicit (fn);\n-      if (decl)\n-\t{\n-\t  tree args[3];\n-\t  args[0] = arg0;\n-\t  args[1] = arg1;\n-\t  args[2] = arg2;\n-\t  tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, args, 3, false);\n-\t  if (res)\n-\t    {\n-\t      /* fold_builtin_n wraps the result inside a NOP_EXPR.  */\n-\t      STRIP_NOPS (res);\n-\t      res = fold_convert (type, res);\n-\t      if (CONSTANT_CLASS_P (res))\n-\t\treturn res;\n-\t    }\n-\t}\n+      tree res = fold_const_call (as_combined_fn (fn), type, arg0, arg1, arg2);\n+      if (res && CONSTANT_CLASS_P (res))\n+\treturn res;\n     }\n \n   code_helper rcode;\n   tree ops[3] = {};\n   if (!gimple_simplify (&rcode, ops, seq, valueize,\n-\t\t\tfn, type, arg0, arg1, arg2))\n+\t\t\tas_combined_fn (fn), type, arg0, arg1, arg2))\n     return NULL_TREE;\n   return maybe_push_res_to_seq (rcode, type, ops, seq);\n }\n@@ -726,23 +690,29 @@ gimple_simplify (gimple *stmt,\n \t  && gimple_call_num_args (stmt) >= 1\n \t  && gimple_call_num_args (stmt) <= 3)\n \t{\n-\t  tree fn = gimple_call_fn (stmt);\n-\t  /* ???  Internal function support missing.  */\n-\t  if (!fn)\n-\t    return false;\n \t  bool valueized = false;\n-\t  fn = do_valueize (fn, top_valueize, valueized);\n-\t  if (TREE_CODE (fn) != ADDR_EXPR\n-\t      || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL)\n-\t    return false;\n+\t  if (gimple_call_internal_p (stmt))\n+\t    *rcode = as_combined_fn (gimple_call_internal_fn (stmt));\n+\t  else\n+\t    {\n+\t      tree fn = gimple_call_fn (stmt);\n+\t      if (!fn)\n+\t\treturn false;\n \n-\t  tree decl = TREE_OPERAND (fn, 0);\n-\t  if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL\n-\t      || !gimple_builtin_call_types_compatible_p (stmt, decl))\n-\t    return false;\n+\t      fn = do_valueize (fn, top_valueize, valueized);\n+\t      if (TREE_CODE (fn) != ADDR_EXPR\n+\t\t  || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL)\n+\t\treturn false;\n+\n+\t      tree decl = TREE_OPERAND (fn, 0);\n+\t      if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL\n+\t\t  || !gimple_builtin_call_types_compatible_p (stmt, decl))\n+\t\treturn false;\n+\n+\t      *rcode = as_combined_fn (DECL_FUNCTION_CODE (decl));\n+\t    }\n \n \t  tree type = TREE_TYPE (gimple_call_lhs (stmt));\n-\t  *rcode = DECL_FUNCTION_CODE (decl);\n \t  for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n \t    {\n \t      tree arg = gimple_call_arg (stmt, i);"}, {"sha": "1d5e444a3768743fe9987589ff915963ba8e206c", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -30,9 +30,9 @@ class code_helper\n public:\n   code_helper () {}\n   code_helper (tree_code code) : rep ((int) code) {}\n-  code_helper (built_in_function fn) : rep (-(int) fn) {}\n+  code_helper (combined_fn fn) : rep (-(int) fn) {}\n   operator tree_code () const { return (tree_code) rep; }\n-  operator built_in_function () const { return (built_in_function) -rep; }\n+  operator combined_fn () const { return (combined_fn) -rep; }\n   bool is_tree_code () const { return rep > 0; }\n   bool is_fn_code () const { return rep < 0; }\n   int get_rep () const { return rep; }"}, {"sha": "15bf2c9bf918306147b1a5a8d3441baf35b04cf5", "filename": "gcc/match.pd", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -2510,56 +2510,58 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       exps (EXP2 EXP10 POW10 EXP  EXP10 POW10 EXP   EXP2)\n   (simplify\n    (logs (exps @0))\n-   (with {\n-     tree x;\n-     switch (exps)\n-       {\n-       CASE_FLT_FN (BUILT_IN_EXP):\n-         /* Prepare to do logN(exp(exponent)) -> exponent*logN(e).  */\n-\t x = build_real_truncate (type, dconst_e ());\n-         break;\n-       CASE_FLT_FN (BUILT_IN_EXP2):\n-         /* Prepare to do logN(exp2(exponent)) -> exponent*logN(2).  */\n-         x = build_real (type, dconst2);\n-         break;\n-       CASE_FLT_FN (BUILT_IN_EXP10):\n-       CASE_FLT_FN (BUILT_IN_POW10):\n-\t /* Prepare to do logN(exp10(exponent)) -> exponent*logN(10).  */\n-\t {\n-\t   REAL_VALUE_TYPE dconst10;\n-\t   real_from_integer (&dconst10, VOIDmode, 10, SIGNED);\n-\t   x = build_real (type, dconst10);\n-\t }\n-         break;\n-       default:\n-\t gcc_unreachable ();\n-       }\n-     }\n-    (mult (logs { x; }) @0))))\n+   (if (SCALAR_FLOAT_TYPE_P (type))\n+    (with {\n+      tree x;\n+      switch (exps)\n+\t{\n+\tCASE_CFN_EXP:\n+\t  /* Prepare to do logN(exp(exponent)) -> exponent*logN(e).  */\n+\t  x = build_real_truncate (type, dconst_e ());\n+\t  break;\n+\tCASE_CFN_EXP2:\n+\t  /* Prepare to do logN(exp2(exponent)) -> exponent*logN(2).  */\n+\t  x = build_real (type, dconst2);\n+\t  break;\n+\tCASE_CFN_EXP10:\n+\tCASE_CFN_POW10:\n+\t  /* Prepare to do logN(exp10(exponent)) -> exponent*logN(10).  */\n+\t  {\n+\t    REAL_VALUE_TYPE dconst10;\n+\t    real_from_integer (&dconst10, VOIDmode, 10, SIGNED);\n+\t    x = build_real (type, dconst10);\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      }\n+     (mult (logs { x; }) @0)))))\n \n  (for logs (LOG LOG\n             LOG2 LOG2\n \t    LOG10 LOG10)\n       exps (SQRT CBRT)\n   (simplify\n    (logs (exps @0))\n-   (with {\n-     tree x;\n-     switch (exps)\n-       {\n-       CASE_FLT_FN (BUILT_IN_SQRT):\n-\t /* Prepare to do logN(sqrt(x)) -> 0.5*logN(x).  */\n-\t x = build_real (type, dconsthalf);\n-         break;\n-       CASE_FLT_FN (BUILT_IN_CBRT):\n-\t /* Prepare to do logN(cbrt(x)) -> (1/3)*logN(x).  */\n-         x = build_real_truncate (type, dconst_third ());\n-         break;\n-       default:\n-\t gcc_unreachable ();\n-       }\n-     }\n-    (mult { x; } (logs @0)))))\n+   (if (SCALAR_FLOAT_TYPE_P (type))\n+    (with {\n+      tree x;\n+      switch (exps)\n+\t{\n+\tCASE_CFN_SQRT:\n+\t  /* Prepare to do logN(sqrt(x)) -> 0.5*logN(x).  */\n+\t  x = build_real (type, dconsthalf);\n+\t  break;\n+\tCASE_CFN_CBRT:\n+\t  /* Prepare to do logN(cbrt(x)) -> (1/3)*logN(x).  */\n+\t  x = build_real_truncate (type, dconst_third ());\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      }\n+     (mult { x; } (logs @0))))))\n \n  /* logN(pow(x,exponent)) -> exponent*logN(x).  */\n  (for logs (LOG LOG2 LOG10)\n@@ -2616,7 +2618,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* hypot(x,0) and hypot(0,x) -> abs(x).  */\n (simplify\n- (hypot:c @0 real_zerop@1)\n+ (HYPOT:c @0 real_zerop@1)\n  (abs @0))\n \n /* pow(1,x) -> 1.  */\n@@ -2684,7 +2686,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (rdiv (SIN:s @0) (TAN:s @0))\n   (if (! HONOR_NANS (@0)\n        && ! HONOR_INFINITIES (@0))\n-   (cos @0)))\n+   (COS @0)))\n \n  /* Simplify tan(x) / sin(x) -> 1.0 / cos(x). */\n  (simplify"}, {"sha": "d5a71a3ded9e9fa9ffebd6cb049120e491c4efdc", "filename": "gcc/tree.c", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -11063,6 +11063,22 @@ build_call_expr (tree fndecl, int n, ...)\n   return build_call_expr_loc_array (UNKNOWN_LOCATION, fndecl, n, argarray);\n }\n \n+/* Build an internal call to IFN, with arguments ARGS[0:N-1] and with return\n+   type TYPE.  This is just like CALL_EXPR, except its CALL_EXPR_FN is NULL.\n+   It will get gimplified later into an ordinary internal function.  */\n+\n+tree\n+build_call_expr_internal_loc_array (location_t loc, internal_fn ifn,\n+\t\t\t\t    tree type, int n, const tree *args)\n+{\n+  tree t = build_call_1 (type, NULL_TREE, n);\n+  for (int i = 0; i < n; ++i)\n+    CALL_EXPR_ARG (t, i) = args[i];\n+  SET_EXPR_LOCATION (t, loc);\n+  CALL_EXPR_IFN (t) = ifn;\n+  return t;\n+}\n+\n /* Build internal call expression.  This is just like CALL_EXPR, except\n    its CALL_EXPR_FN is NULL.  It will get gimplified later into ordinary\n    internal function.  */\n@@ -11072,16 +11088,52 @@ build_call_expr_internal_loc (location_t loc, enum internal_fn ifn,\n \t\t\t      tree type, int n, ...)\n {\n   va_list ap;\n+  tree *argarray = XALLOCAVEC (tree, n);\n   int i;\n \n-  tree fn = build_call_1 (type, NULL_TREE, n);\n   va_start (ap, n);\n   for (i = 0; i < n; i++)\n-    CALL_EXPR_ARG (fn, i) = va_arg (ap, tree);\n+    argarray[i] = va_arg (ap, tree);\n   va_end (ap);\n-  SET_EXPR_LOCATION (fn, loc);\n-  CALL_EXPR_IFN (fn) = ifn;\n-  return fn;\n+  return build_call_expr_internal_loc_array (loc, ifn, type, n, argarray);\n+}\n+\n+/* Return a function call to FN, if the target is guaranteed to support it,\n+   or null otherwise.\n+\n+   N is the number of arguments, passed in the \"...\", and TYPE is the\n+   type of the return value.  */\n+\n+tree\n+maybe_build_call_expr_loc (location_t loc, combined_fn fn, tree type,\n+\t\t\t   int n, ...)\n+{\n+  va_list ap;\n+  tree *argarray = XALLOCAVEC (tree, n);\n+  int i;\n+\n+  va_start (ap, n);\n+  for (i = 0; i < n; i++)\n+    argarray[i] = va_arg (ap, tree);\n+  va_end (ap);\n+  if (internal_fn_p (fn))\n+    {\n+      internal_fn ifn = as_internal_fn (fn);\n+      if (direct_internal_fn_p (ifn))\n+\t{\n+\t  tree_pair types = direct_internal_fn_types (ifn, type, argarray);\n+\t  if (!direct_internal_fn_supported_p (ifn, types))\n+\t    return NULL_TREE;\n+\t}\n+      return build_call_expr_internal_loc_array (loc, ifn, type, n, argarray);\n+    }\n+  else\n+    {\n+      tree fndecl = builtin_decl_implicit (as_builtin_fn (fn));\n+      if (!fndecl)\n+\treturn NULL_TREE;\n+      return build_call_expr_loc_array (loc, fndecl, n, argarray);\n+    }\n }\n \n /* Create a new constant string literal and return a char* pointer to it."}, {"sha": "b9c400c50d47e627018b4694d4d91645697f2558", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "patch": "@@ -3957,6 +3957,10 @@ extern tree build_call_expr_loc (location_t, tree, int, ...);\n extern tree build_call_expr (tree, int, ...);\n extern tree build_call_expr_internal_loc (location_t, enum internal_fn,\n \t\t\t\t\t  tree, int, ...);\n+extern tree build_call_expr_internal_loc (location_t, enum internal_fn,\n+\t\t\t\t\t  tree, int, tree *);\n+extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,\n+\t\t\t\t       int, ...);\n extern tree build_string_literal (int, const char *);\n \n /* Construct various nodes representing data types.  */"}]}