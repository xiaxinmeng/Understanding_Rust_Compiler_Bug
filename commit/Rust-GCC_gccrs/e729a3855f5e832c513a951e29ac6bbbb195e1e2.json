{"sha": "e729a3855f5e832c513a951e29ac6bbbb195e1e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcyOWEzODU1ZjVlODMyYzUxM2E5NTFlMjlhYzZiYmJiMTk1ZTFlMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-12-08T21:45:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-12-08T21:45:22Z"}, "message": "struct-layout-1.exp: New file.\n\n\t* g++.dg/compat/struct-layout-1.exp: New file.\n\t* g++.dg/compat/struct-layout-1.h: New.\n\t* g++.dg/compat/struct-layout-1_generate.c: New.\n\t* g++.dg/compat/struct-layout-1_x1.h: New.\n\t* g++.dg/compat/struct-layout-1_x2.h: New.\n\t* g++.dg/compat/struct-layout-1_y1.h: New.\n\t* g++.dg/compat/struct-layout-1_y2.h: New.\n\nFrom-SVN: r108244", "tree": {"sha": "bafe02b8737ed7b2b7b5addd975816248df361e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bafe02b8737ed7b2b7b5addd975816248df361e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e729a3855f5e832c513a951e29ac6bbbb195e1e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e729a3855f5e832c513a951e29ac6bbbb195e1e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e729a3855f5e832c513a951e29ac6bbbb195e1e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e729a3855f5e832c513a951e29ac6bbbb195e1e2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88a6bf5e1929ae2f1243c0039cd25092451de3dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a6bf5e1929ae2f1243c0039cd25092451de3dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a6bf5e1929ae2f1243c0039cd25092451de3dd"}], "stats": {"total": 2346, "additions": 2346, "deletions": 0}, "files": [{"sha": "147e7ca0e8be5eb2a725fea95d54578e8e18a809", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -1,5 +1,13 @@\n 2005-12-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* g++.dg/compat/struct-layout-1.exp: New file.\n+\t* g++.dg/compat/struct-layout-1.h: New.\n+\t* g++.dg/compat/struct-layout-1_generate.c: New.\n+\t* g++.dg/compat/struct-layout-1_x1.h: New.\n+\t* g++.dg/compat/struct-layout-1_x2.h: New.\n+\t* g++.dg/compat/struct-layout-1_y1.h: New.\n+\t* g++.dg/compat/struct-layout-1_y2.h: New.\n+\n \t* gcc.dg/20050330-2.c: New test.\n \n 2005-12-08  Erik Edelmann  <eedelman@gcc.gnu.org>"}, {"sha": "d2e1de9857bbacdad6acac5bd03cc75f2479adc6", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1.exp", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.exp?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,164 @@\n+# Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+#\n+# This file was written by Jakub Jelinek, <jakub@redhat.com>\n+# Based on compat.exp writte by Janis Johnson, <janis187@us.ibm.com>\n+\n+\n+# Test interoperability of two compilers that follow the same ABI.\n+#\n+# Break simple tests into two pieces and see that they work when linked\n+# together.  If an alternate compiler is specified then the two main\n+# pieces of each test are compiled with different compilers.  The\n+# alternate compiler must be installed, and is specified by defining\n+# ALT_CXX_UNDER_TEST in the environment.\n+#\n+# struct-layout-1 are generated structure layout interoperability tests,\n+# so a generator first needs to be compiled on host, run there and the\n+# generated tests then compiled on build and executed on target.\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+global GXX_UNDER_TEST\n+global ld_library_path\n+\n+# Load procedures from common libraries. \n+load_lib standard.exp\n+load_lib g++.exp\n+load_lib target-libpath.exp\n+\n+#\n+# compat-use-alt-compiler -- make the alternate compiler the default\n+# \n+proc compat-use-alt-compiler { } {\n+    global GXX_UNDER_TEST ALT_CXX_UNDER_TEST\n+    global CXXFLAGS\n+    global ALWAYS_CXXFLAGS\n+    global ld_library_path alt_ld_library_path\n+    global same_alt\n+\n+    # We don't need to do this if the alternate compiler is actually\n+    # the same as the compiler under test.\n+    if { $same_alt == 0 } then {\n+\tset GXX_UNDER_TEST $ALT_CXX_UNDER_TEST\n+\tset CXXFLAGS \"\"\n+\tset ALWAYS_CXXFLAGS \"\"\n+\tset ld_library_path $alt_ld_library_path\n+\tset_ld_library_path_env_vars\n+    }\n+}\n+\n+#\n+# compat-use-tst-compiler -- make compiler under test the default\n+#\n+proc compat-use-tst-compiler { } {\n+    global GXX_UNDER_TEST save_gxx_under_test\n+    global CXXFLAGS save_cxxflags\n+    global ALWAYS_CXXFLAGS save_always_cxxflags\n+    global ld_library_path save_ld_library_path\n+    global same_alt\n+\n+    # We don't need to do this if the alternate compiler is actually\n+    # the same as the compiler under test.\n+\n+    if { $same_alt == 0 } then {\n+\tset GXX_UNDER_TEST $save_gxx_under_test\n+\tset CXXFLAGS $save_cxxflags\n+\tset ALWAYS_CXXFLAGS $save_always_cxxflags\n+\tset ld_library_path $save_ld_library_path\n+\tset_ld_library_path_env_vars\n+    }\n+}\n+\n+# Load the language-independent compabibility support procedures.\n+# This must be done after the compat-use-*-compiler definitions.\n+load_lib compat.exp\n+\n+g++_init\n+\n+# Save variables for the C++ compiler under test, which each test will\n+# change a couple of times.  This must be done after calling g++-init.\n+set save_gxx_under_test $GXX_UNDER_TEST\n+set save_cxxflags $CXXFLAGS\n+set save_always_cxxflags $ALWAYS_CXXFLAGS\n+set save_ld_library_path $ld_library_path\n+\n+# Define an identifier for use with this suite to avoid name conflicts\n+# with other compat tests running at the same time.\n+set sid \"cp_compat\"\n+\n+# Find out whether there is an alternate compiler to test.  If the\n+# variable is defined but is set to \"same\", that means we use the same\n+# compiler twice, which is meaningful if the two parts of COMPAT_OPTIONS\n+# are different.\n+set use_alt 0\n+set same_alt 0\n+set alt_ld_library_path \".\"\n+if [info exists ALT_CXX_UNDER_TEST] then {\n+    set use_alt 1\n+    if [string match \"same\" $ALT_CXX_UNDER_TEST] then {\n+\tset same_alt 1\n+    } else {\n+\tif [info exists ALT_LD_LIBRARY_PATH] then {\n+\t    append alt_ld_library_path \":${ALT_LD_LIBRARY_PATH}\"\n+\t}\n+    }\n+}\n+\n+set tstobjdir \"$tmpdir/g++.dg-struct-layout-1\"\n+set generator \"$tmpdir/g++.dg-struct-layout-1_generate\"\n+\n+set generator_src \"$srcdir/$subdir/struct-layout-1_generate.c\"\n+set generator_src \"$generator_src $srcdir/$subdir/../../gcc.dg/compat/generate-random.c\"\n+set generator_src \"$generator_src $srcdir/$subdir/../../gcc.dg/compat/generate-random_r.c\"\n+set generator_inc \"-I$srcdir/$subdir -I$srcdir/../../include\"\n+set generator_inc \"$generator_inc -I$rootme/../libiberty\"\n+set generator_lib \"-L$rootme/../libiberty -liberty\"\n+set generator_cmd \"-o $generator $generator_src $generator_inc $generator_lib\"\n+\n+set status [remote_exec host \"$HOSTCC $HOSTCFLAGS $generator_cmd\"]\n+set status [lindex $status 0]\n+if { $status == 0 } then {\n+    file delete -force $tstobjdir\n+    file mkdir $tstobjdir\n+    set generator_args \"-s $srcdir/$subdir -d $tstobjdir\"\n+    if [info exists env(RUN_ALL_COMPAT_TESTS) ] then {\n+\tset generator_args \"$generator_args -n 15000\"\n+    }\n+    set status [remote_exec host \"$generator $generator_args\"]\n+    set status [lindex $status 0]\n+    if { $status == 0 } then {\n+\tforeach src [lsort [find $tstobjdir *_main.C]] {\n+\t    # If we're only testing specific files and this isn't one\n+\t    # of them, skip it.\n+\t    if ![runtest_file_p $runtests $src] then {\n+\t\tcontinue\n+\t    }\n+\n+\t    compat-execute $src $sid $use_alt\n+\t}\n+    } else {\n+\twarning \"Could not execute g++.dg/compat/struct-layout-1 generator\"\n+    }\n+} else {\n+    warning \"Could not compile g++.dg/compat/struct-layout-1 generator\"\n+}\n+\n+# Restore the original compiler under test.\n+compat-use-tst-compiler"}, {"sha": "328c83b91f332757b50927d70ad6278da1704564", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1.h", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1.h?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,497 @@\n+#include <limits.h>\n+#include <stdarg.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"../../gcc.dg/compat/compat-common.h\"\n+\n+#ifndef SKIP_ATTRIBUTE\n+# include \"../../gcc.dg/compat/vector-defs.h\"\n+#else\n+typedef int qi;\n+typedef int hi;\n+typedef int si;\n+typedef int di;\n+typedef float sf;\n+typedef float df;\n+typedef int v8qi;\n+typedef int v16qi;\n+typedef int v2hi;\n+typedef int v4hi;\n+typedef int v8hi;\n+typedef int v2si;\n+typedef int v4si;\n+typedef int v1di;\n+typedef int v2di;\n+typedef int v2sf;\n+typedef int v4sf;\n+typedef int v16sf;\n+typedef int v2df;\n+typedef int u8qi;\n+typedef int u16qi;\n+typedef int u2hi;\n+typedef int u4hi;\n+typedef int u8hi;\n+typedef int u2si;\n+typedef int u4si;\n+typedef int u1di;\n+typedef int u2di;\n+typedef int u2sf;\n+typedef int u4sf;\n+typedef int u16sf;\n+typedef int u2df;\n+#endif\n+#if (defined __i386__ || defined __x86_64__) && !defined SKIP_ATTRIBUTE\n+# ifdef __MMX__\n+#  include <mmintrin.h>\n+# else\n+typedef int __m64;\n+# endif\n+# ifdef __SSE__\n+#  include <xmmintrin.h>\n+# else\n+typedef int __m128;\n+# endif\n+#else\n+typedef int __m64;\n+typedef int __m128;\n+#endif\n+\n+#define FLDS_MAX\t32\n+extern struct Info\n+{\n+  int nfields, nbitfields;\n+  void *sp, *a0p, *a3p;\n+  void *flds[FLDS_MAX];\n+  size_t sz, sizes[FLDS_MAX];\n+  size_t als, ala0, ala3, aligns[FLDS_MAX];\n+} info;\n+\n+extern int intarray[256];\n+extern int fn0 (void), fn1 (void), fn2 (void), fn3 (void), fn4 (void);\n+extern int fn5 (void), fn6 (void), fn7 (void), fn8 (void), fn9 (void);\n+\n+#ifdef DBG\n+#define FAIL(n, m) printf (\"fail %d.%d\\n\", n, m), ++fails\n+#else\n+#define FAIL(n, m) ++fails\n+#endif\n+\n+#ifdef SKIP_ATTRIBUTE\n+# define __attribute__(x)\n+#endif\n+#define atal\t\t__attribute__((aligned))\n+#define atpa\t\t__attribute__((packed))\n+#define atalpa\t\t__attribute__((aligned, packed))\n+#define atpaal\t\t__attribute__((packed, aligned))\n+#define atal1\t\t__attribute__((aligned (1)))\n+#define atal2\t\t__attribute__((aligned (2)))\n+#define atal4\t\t__attribute__((aligned (4)))\n+#define atal8\t\t__attribute__((aligned (8)))\n+#define atal16\t\t__attribute__((aligned (16)))\n+#define atal1pa\t\t__attribute__((aligned (1), packed))\n+#define atal2pa\t\t__attribute__((aligned (2), packed))\n+#define atal4pa\t\t__attribute__((aligned (4), packed))\n+#define atal8pa\t\t__attribute__((aligned (8), packed))\n+#define atal16pa\t__attribute__((aligned (16), packed))\n+#define atpaal1\t\t__attribute__((packed, aligned (1)))\n+#define atpaal2\t\t__attribute__((packed, aligned (2)))\n+#define atpaal4\t\t__attribute__((packed, aligned (4)))\n+#define atpaal8\t\t__attribute__((packed, aligned (8)))\n+#define atpaal16\t__attribute__((packed, aligned (16)))\n+\n+#if UCHAR_MAX == 255 && USHORT_MAX == 65535 && UINT_MAX == 4294967295U \\\n+    && ULLONG_MAX == 18446744073709551615ULL\n+/* For ILP32 and LP64 targets, assume float is at least 32-bit\n+   and double plus long double at least 64-bit.  */\n+# define atalx1\t\tatal1\n+# define atalx2\t\tatal2\n+# define atalx4\t\tatal4\n+# define atalx8\t\tatal8\n+# define atalx16\tatal16\n+# define atalx1pa\tatal1pa\n+# define atalx2pa\tatal2pa\n+# define atalx4pa\tatal4pa\n+# define atalx8pa\tatal8pa\n+# define atalx16pa\tatal16pa\n+# define atpaalx1\tatpaal1\n+# define atpaalx2\tatpaal2\n+# define atpaalx4\tatpaal4\n+# define atpaalx8\tatpaal8\n+# define atpaalx16\tatpaal16\n+# if ULONG_MAX > 4294967295UL\n+#  define ataly8\tatal8\n+#  define ataly8pa\tatal8pa\n+#  define atpaaly8\tatpaal8\n+#  define ataly16\tatal16\n+#  define ataly16pa\tatal16pa\n+#  define atpaaly16\tatpaal16\n+# else\n+#  define ataly8\n+#  define ataly8pa\n+#  define atpaaly8\n+#  define ataly16\n+#  define ataly16pa\n+#  define atpaaly16\n+# endif\n+#else\n+# define atalx1\n+# define atalx2\n+# define atalx4\n+# define atalx8\n+# define atalx16\n+# define atalx1pa\n+# define atalx2pa\n+# define atalx4pa\n+# define atalx8pa\n+# define atalx16pa\n+# define atpaalx1\n+# define atpaalx2\n+# define atpaalx4\n+# define atpaalx8\n+# define atpaalx16\n+# define ataly8\n+# define ataly8pa\n+# define atpaaly8\n+# define ataly16\n+# define ataly16pa\n+# define atpaaly16\n+#endif\n+\n+#define atQI\t\t__attribute__((mode (QI)))\n+#define atHI\t\t__attribute__((mode (HI)))\n+#define atSI\t\t__attribute__((mode (SI)))\n+#define atDI\t\t__attribute__((mode (DI)))\n+\n+enum E0 { e0_0 };\n+enum E1 { e1_0, e1_1 };\n+enum E2 { e2_m3 = -3, e2_m2, e2_m1, e2_0, e2_1, e2_2, e2_3 };\n+enum E3 { e3_m127 = -127, e3_m126, e3_m125, e3_0 = 0, e3_125 = 125, e3_126, e3_127 };\n+enum E4 { e4_0, e4_1, e4_2, e4_3, e4_253 = 253, e4_254, e4_255 };\n+enum E5 { e5_m32767 = -32767, e5_m32766, e5_m32765, e5_0 = 0, e5_32765 = 32765, e5_32766, e5_32767 };\n+enum E6 { e6_0, e6_1, e6_2, e6_3, e6_65533 = 65533, e6_65534, e6_65535 };\n+enum E7 { e7_m2147483647 = -2147483647, e7_m2147483646, e7_m2147483645,\n+\t  e7_0, e7_2147483645 = 2147483645, e7_2147483646, e7_2147483647 };\n+enum E8 { e8_0, e8_1, e8_2, e8_3, e8_4294967293 = 4294967293U, e8_4294967294, e8_4294967295 };\n+enum E9 { e9_m1099511627775 = -1099511627775LL, e9_m1099511627774, e9_m1099511627773,\n+\t  e9_0, e9_1099511627773 = 1099511627773LL, e9_1099511627774, e9_1099511627775 };\n+\n+typedef char Tchar;\n+typedef signed char Tschar;\n+typedef unsigned char Tuchar;\n+typedef short int Tshort;\n+typedef unsigned short int Tushort;\n+typedef int Tint;\n+typedef unsigned int Tuint;\n+typedef long int Tlong;\n+typedef unsigned long int Tulong;\n+typedef long long int Tllong;\n+typedef unsigned long long int Tullong;\n+typedef float Tfloat;\n+typedef double Tdouble;\n+typedef long double Tldouble;\n+typedef _Complex float Tcfloat;\n+typedef _Complex double Tcdouble;\n+typedef _Complex long double Tcldouble;\n+typedef bool Tbool;\n+typedef enum E0 TE0;\n+typedef enum E1 TE1;\n+typedef enum E2 TE2;\n+typedef enum E3 TE3;\n+typedef enum E4 TE4;\n+typedef enum E5 TE5;\n+typedef enum E6 TE6;\n+typedef enum E7 TE7;\n+typedef enum E8 TE8;\n+typedef enum E9 TE9;\n+typedef void *Tptr;\n+typedef char *Tcptr;\n+typedef int *Tiptr;\n+typedef char Talchar atal;\n+typedef signed char Talschar atal;\n+typedef unsigned char Taluchar atal;\n+typedef short int Talshort atal;\n+typedef unsigned short int Talushort atal;\n+typedef int Talint atal;\n+typedef unsigned int Taluint atal;\n+typedef long int Tallong atal;\n+typedef unsigned long int Talulong atal;\n+typedef long long int Talllong atal;\n+typedef unsigned long long int Talullong atal;\n+typedef float Talfloat atal;\n+typedef double Taldouble atal;\n+typedef long double Talldouble atal;\n+typedef _Complex float Talcfloat atal;\n+typedef _Complex double Talcdouble atal;\n+typedef _Complex long double Talcldouble atal;\n+typedef bool Talbool atal;\n+typedef enum E0 TalE0 atal;\n+typedef enum E1 TalE1 atal;\n+typedef enum E2 TalE2 atal;\n+typedef enum E3 TalE3 atal;\n+typedef enum E4 TalE4 atal;\n+typedef enum E5 TalE5 atal;\n+typedef enum E6 TalE6 atal;\n+typedef enum E7 TalE7 atal;\n+typedef enum E8 TalE8 atal;\n+typedef enum E9 TalE9 atal;\n+typedef void *Talptr atal;\n+typedef char *Talcptr atal;\n+typedef int *Taliptr atal;\n+typedef char Tal1char atal1;\n+typedef signed char Tal1schar atal1;\n+typedef unsigned char Tal1uchar atal1;\n+typedef short int Tal1short atal1;\n+typedef unsigned short int Tal1ushort atal1;\n+typedef int Tal1int atal1;\n+typedef unsigned int Tal1uint atal1;\n+typedef long int Tal1long atal1;\n+typedef unsigned long int Tal1ulong atal1;\n+typedef long long int Tal1llong atal1;\n+typedef unsigned long long int Tal1ullong atal1;\n+typedef float Tal1float atal1;\n+typedef double Tal1double atal1;\n+typedef long double Tal1ldouble atal1;\n+typedef _Complex float Tal1cfloat atal1;\n+typedef _Complex double Tal1cdouble atal1;\n+typedef _Complex long double Tal1cldouble atal1;\n+typedef bool Tal1bool atal1;\n+typedef enum E0 Tal1E0 atal1;\n+typedef enum E1 Tal1E1 atal1;\n+typedef enum E2 Tal1E2 atal1;\n+typedef enum E3 Tal1E3 atal1;\n+typedef enum E4 Tal1E4 atal1;\n+typedef enum E5 Tal1E5 atal1;\n+typedef enum E6 Tal1E6 atal1;\n+typedef enum E7 Tal1E7 atal1;\n+typedef enum E8 Tal1E8 atal1;\n+typedef enum E9 Tal1E9 atal1;\n+typedef void *Tal1ptr atal1;\n+typedef char *Tal1cptr atal1;\n+typedef int *Tal1iptr atal1;\n+typedef char Tal2char atal2;\n+typedef signed char Tal2schar atal2;\n+typedef unsigned char Tal2uchar atal2;\n+typedef short int Tal2short atal2;\n+typedef unsigned short int Tal2ushort atal2;\n+typedef int Tal2int atal2;\n+typedef unsigned int Tal2uint atal2;\n+typedef long int Tal2long atal2;\n+typedef unsigned long int Tal2ulong atal2;\n+typedef long long int Tal2llong atal2;\n+typedef unsigned long long int Tal2ullong atal2;\n+typedef float Tal2float atal2;\n+typedef double Tal2double atal2;\n+typedef long double Tal2ldouble atal2;\n+typedef _Complex float Tal2cfloat atal2;\n+typedef _Complex double Tal2cdouble atal2;\n+typedef _Complex long double Tal2cldouble atal2;\n+typedef bool Tal2bool atal2;\n+typedef enum E0 Tal2E0 atal2;\n+typedef enum E1 Tal2E1 atal2;\n+typedef enum E2 Tal2E2 atal2;\n+typedef enum E3 Tal2E3 atal2;\n+typedef enum E4 Tal2E4 atal2;\n+typedef enum E5 Tal2E5 atal2;\n+typedef enum E6 Tal2E6 atal2;\n+typedef enum E7 Tal2E7 atal2;\n+typedef enum E8 Tal2E8 atal2;\n+typedef enum E9 Tal2E9 atal2;\n+typedef void *Tal2ptr atal2;\n+typedef char *Tal2cptr atal2;\n+typedef int *Tal2iptr atal2;\n+typedef char Tal4char atal4;\n+typedef signed char Tal4schar atal4;\n+typedef unsigned char Tal4uchar atal4;\n+typedef short int Tal4short atal4;\n+typedef unsigned short int Tal4ushort atal4;\n+typedef int Tal4int atal4;\n+typedef unsigned int Tal4uint atal4;\n+typedef long int Tal4long atal4;\n+typedef unsigned long int Tal4ulong atal4;\n+typedef long long int Tal4llong atal4;\n+typedef unsigned long long int Tal4ullong atal4;\n+typedef float Tal4float atal4;\n+typedef double Tal4double atal4;\n+typedef long double Tal4ldouble atal4;\n+typedef _Complex float Tal4cfloat atal4;\n+typedef _Complex double Tal4cdouble atal4;\n+typedef _Complex long double Tal4cldouble atal4;\n+typedef bool Tal4bool atal4;\n+typedef enum E0 Tal4E0 atal4;\n+typedef enum E1 Tal4E1 atal4;\n+typedef enum E2 Tal4E2 atal4;\n+typedef enum E3 Tal4E3 atal4;\n+typedef enum E4 Tal4E4 atal4;\n+typedef enum E5 Tal4E5 atal4;\n+typedef enum E6 Tal4E6 atal4;\n+typedef enum E7 Tal4E7 atal4;\n+typedef enum E8 Tal4E8 atal4;\n+typedef enum E9 Tal4E9 atal4;\n+typedef void *Tal4ptr atal4;\n+typedef char *Tal4cptr atal4;\n+typedef int *Tal4iptr atal4;\n+typedef char Tal8char atal8;\n+typedef signed char Tal8schar atal8;\n+typedef unsigned char Tal8uchar atal8;\n+typedef short int Tal8short atal8;\n+typedef unsigned short int Tal8ushort atal8;\n+typedef int Tal8int atal8;\n+typedef unsigned int Tal8uint atal8;\n+typedef long int Tal8long atal8;\n+typedef unsigned long int Tal8ulong atal8;\n+typedef long long int Tal8llong atal8;\n+typedef unsigned long long int Tal8ullong atal8;\n+typedef float Tal8float atal8;\n+typedef double Tal8double atal8;\n+typedef long double Tal8ldouble atal8;\n+typedef _Complex float Tal8cfloat atal8;\n+typedef _Complex double Tal8cdouble atal8;\n+typedef _Complex long double Tal8cldouble atal8;\n+typedef bool Tal8bool atal8;\n+typedef enum E0 Tal8E0 atal8;\n+typedef enum E1 Tal8E1 atal8;\n+typedef enum E2 Tal8E2 atal8;\n+typedef enum E3 Tal8E3 atal8;\n+typedef enum E4 Tal8E4 atal8;\n+typedef enum E5 Tal8E5 atal8;\n+typedef enum E6 Tal8E6 atal8;\n+typedef enum E7 Tal8E7 atal8;\n+typedef enum E8 Tal8E8 atal8;\n+typedef enum E9 Tal8E9 atal8;\n+typedef void *Tal8ptr atal8;\n+typedef char *Tal8cptr atal8;\n+typedef int *Tal8iptr atal8;\n+typedef char Tal16char atal16;\n+typedef signed char Tal16schar atal16;\n+typedef unsigned char Tal16uchar atal16;\n+typedef short int Tal16short atal16;\n+typedef unsigned short int Tal16ushort atal16;\n+typedef int Tal16int atal16;\n+typedef unsigned int Tal16uint atal16;\n+typedef long int Tal16long atal16;\n+typedef unsigned long int Tal16ulong atal16;\n+typedef long long int Tal16llong atal16;\n+typedef unsigned long long int Tal16ullong atal16;\n+typedef float Tal16float atal16;\n+typedef double Tal16double atal16;\n+typedef long double Tal16ldouble atal16;\n+typedef _Complex float Tal16cfloat atal16;\n+typedef _Complex double Tal16cdouble atal16;\n+typedef _Complex long double Tal16cldouble atal16;\n+typedef bool Tal16bool atal16;\n+typedef enum E0 Tal16E0 atal16;\n+typedef enum E1 Tal16E1 atal16;\n+typedef enum E2 Tal16E2 atal16;\n+typedef enum E3 Tal16E3 atal16;\n+typedef enum E4 Tal16E4 atal16;\n+typedef enum E5 Tal16E5 atal16;\n+typedef enum E6 Tal16E6 atal16;\n+typedef enum E7 Tal16E7 atal16;\n+typedef enum E8 Tal16E8 atal16;\n+typedef enum E9 Tal16E9 atal16;\n+typedef void *Tal16ptr atal16;\n+typedef char *Tal16cptr atal16;\n+typedef int *Tal16iptr atal16;\n+typedef char Talx1char atalx1;\n+typedef signed char Talx1schar atalx1;\n+typedef unsigned char Talx1uchar atalx1;\n+typedef short int Talx1short atalx1;\n+typedef unsigned short int Talx1ushort atalx1;\n+typedef int Talx1int atalx1;\n+typedef unsigned int Talx1uint atalx1;\n+typedef long int Talx1long atalx1;\n+typedef unsigned long int Talx1ulong atalx1;\n+typedef long long int Talx1llong atalx1;\n+typedef unsigned long long int Talx1ullong atalx1;\n+typedef float Talx1float atalx1;\n+typedef double Talx1double atalx1;\n+typedef long double Talx1ldouble atalx1;\n+typedef _Complex float Talx1cfloat atalx1;\n+typedef _Complex double Talx1cdouble atalx1;\n+typedef _Complex long double Talx1cldouble atalx1;\n+typedef bool Talx1bool atalx1;\n+typedef enum E0 Talx1E0 atalx1;\n+typedef enum E1 Talx1E1 atalx1;\n+typedef enum E2 Talx1E2 atalx1;\n+typedef enum E3 Talx1E3 atalx1;\n+typedef enum E4 Talx1E4 atalx1;\n+typedef enum E5 Talx1E5 atalx1;\n+typedef enum E6 Talx1E6 atalx1;\n+typedef enum E7 Talx1E7 atalx1;\n+typedef enum E8 Talx1E8 atalx1;\n+typedef enum E9 Talx1E9 atalx1;\n+typedef void *Talx1ptr atalx1;\n+typedef char *Talx1cptr atalx1;\n+typedef int *Talx1iptr atalx1;\n+typedef short int Talx2short atalx2;\n+typedef unsigned short int Talx2ushort atalx2;\n+typedef int Talx2int atalx2;\n+typedef unsigned int Talx2uint atalx2;\n+typedef long int Talx2long atalx2;\n+typedef unsigned long int Talx2ulong atalx2;\n+typedef long long int Talx2llong atalx2;\n+typedef unsigned long long int Talx2ullong atalx2;\n+typedef float Talx2float atalx2;\n+typedef double Talx2double atalx2;\n+typedef long double Talx2ldouble atalx2;\n+typedef _Complex float Talx2cfloat atalx2;\n+typedef _Complex double Talx2cdouble atalx2;\n+typedef _Complex long double Talx2cldouble atalx2;\n+typedef enum E0 Talx2E0 atalx2;\n+typedef enum E1 Talx2E1 atalx2;\n+typedef enum E2 Talx2E2 atalx2;\n+typedef enum E3 Talx2E3 atalx2;\n+typedef enum E4 Talx2E4 atalx2;\n+typedef enum E5 Talx2E5 atalx2;\n+typedef enum E6 Talx2E6 atalx2;\n+typedef enum E7 Talx2E7 atalx2;\n+typedef enum E8 Talx2E8 atalx2;\n+typedef enum E9 Talx2E9 atalx2;\n+typedef void *Talx2ptr atalx2;\n+typedef char *Talx2cptr atalx2;\n+typedef int *Talx2iptr atalx2;\n+typedef int Talx4int atalx4;\n+typedef unsigned int Talx4uint atalx4;\n+typedef long int Talx4long atalx4;\n+typedef unsigned long int Talx4ulong atalx4;\n+typedef long long int Talx4llong atalx4;\n+typedef unsigned long long int Talx4ullong atalx4;\n+typedef float Talx4float atalx4;\n+typedef double Talx4double atalx4;\n+typedef long double Talx4ldouble atalx4;\n+typedef _Complex float Talx4cfloat atalx4;\n+typedef _Complex double Talx4cdouble atalx4;\n+typedef _Complex long double Talx4cldouble atalx4;\n+typedef enum E0 Talx4E0 atalx4;\n+typedef enum E1 Talx4E1 atalx4;\n+typedef enum E2 Talx4E2 atalx4;\n+typedef enum E3 Talx4E3 atalx4;\n+typedef enum E4 Talx4E4 atalx4;\n+typedef enum E5 Talx4E5 atalx4;\n+typedef enum E6 Talx4E6 atalx4;\n+typedef enum E7 Talx4E7 atalx4;\n+typedef enum E8 Talx4E8 atalx4;\n+typedef enum E9 Talx4E9 atalx4;\n+typedef void *Talx4ptr atalx4;\n+typedef char *Talx4cptr atalx4;\n+typedef int *Talx4iptr atalx4;\n+typedef long int Taly8long ataly8;\n+typedef unsigned long int Taly8ulong ataly8;\n+typedef long long int Talx8llong atalx8;\n+typedef unsigned long long int Talx8ullong atalx8;\n+typedef double Talx8double atalx8;\n+typedef long double Talx8ldouble atalx8;\n+typedef _Complex float Talx8cfloat atalx8;\n+typedef _Complex double Talx8cdouble atalx8;\n+typedef _Complex long double Talx8cldouble atalx8;\n+typedef void *Taly8ptr ataly8;\n+typedef char *Taly8cptr ataly8;\n+typedef int *Taly8iptr ataly8;\n+typedef _Complex double Talx16cdouble atalx16;\n+typedef _Complex long double Talx16cldouble atalx16;\n+typedef int (*Tfnptr) (void);\n+\n+#define T(n, fields, ops) TX(n, struct, , fields, ({ ops });)\n+#define U(n, fields, ops) TX(n, union, , fields, ({ ops });)"}, {"sha": "2951638de8094b1d2bec017ac358bf81123873d3", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c", "status": "added", "additions": 1450, "deletions": 0, "changes": 1450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_generate.c?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,1450 @@\n+/* Structure layout test generator.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* Compile with gcc -I$(srcdir)/../include -{I,L}$(objdir)/../libiberty/ \\\n+   -o struct-layout-1_generate{,.c} generate_random{,_r}.c -liberty */\n+\n+#include \"config.h\"\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#include \"libiberty.h\"\n+#include <stdio.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#include \"hashtab.h\"\n+#include \"getopt.h\"\n+/* We use our own pseudo-random number generator, so that it gives the same\n+   values on all hosts.  */\n+#include \"../../gcc.dg/compat/generate-random.h\"\n+\n+#if LLONG_MAX != 9223372036854775807LL && __LONG_LONG_MAX__ != 9223372036854775807LL\n+# error Need 64-bit long long\n+#endif\n+\n+enum TYPE\n+{\n+  TYPE_INT,\n+  TYPE_UINT,\n+  TYPE_FLOAT,\n+  TYPE_SENUM,\n+  TYPE_UENUM,\n+  TYPE_PTR,\n+  TYPE_FNPTR,\n+  TYPE_OTHER\n+};\n+\n+struct types\n+{\n+  const char *name;\n+  enum TYPE type;\n+  unsigned long long int maxval;\n+  char bitfld;\n+};\n+\n+struct types base_types[] = {\n+/* As we don't know whether char will be signed or not, just limit ourselves\n+   to unsigned values less than maximum signed char value.  */\n+{ \"char\", TYPE_UINT, 127, 'C' },\n+{ \"signed char\", TYPE_INT, 127, 'C' },\n+{ \"unsigned char\", TYPE_UINT, 255, 'C' },\n+{ \"short int\", TYPE_INT, 32767, 'S' },\n+{ \"unsigned short int\", TYPE_UINT, 65535, 'S' },\n+{ \"int\", TYPE_INT, 2147483647, 'I' },\n+{ \"unsigned int\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"long int\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"unsigned long int\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"long long int\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"unsigned long long int\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"bool\", TYPE_UINT, 1, 'B' },\n+{ \"void *\", TYPE_PTR, 0, 0 },\n+{ \"char *\", TYPE_PTR, 0, 0 },\n+{ \"int *\", TYPE_PTR, 0, 0 },\n+{ \"float\", TYPE_FLOAT, 0, 0 },\n+{ \"double\", TYPE_FLOAT, 0, 0 },\n+{ \"long double\", TYPE_FLOAT, 0, 0 },\n+#define NTYPES1 18\n+{ \"Tchar\", TYPE_UINT, 127, 'C' },\n+{ \"Tschar\", TYPE_INT, 127, 'C' },\n+{ \"Tuchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tshort\", TYPE_INT, 32767, 'S' },\n+{ \"Tushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tint\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tuint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tlong\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tllong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tbool\", TYPE_UINT, 1, 'B' },\n+{ \"size_t\", TYPE_UINT, 18446744073709551615ULL, 0 },\n+{ \"Tptr\", TYPE_PTR, 0, 0 },\n+{ \"Tcptr\", TYPE_PTR, 0, 0 },\n+{ \"Tiptr\", TYPE_PTR, 0, 0 },\n+{ \"Tfnptr\", TYPE_FNPTR, 0, 0 },\n+{ \"Tfloat\", TYPE_FLOAT, 0, 0 },\n+{ \"Tdouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"enum E0\", TYPE_UENUM, 0, ' ' },\n+{ \"enum E1\", TYPE_UENUM, 1, ' ' },\n+{ \"enum E2\", TYPE_SENUM, 3, ' ' },\n+{ \"enum E3\", TYPE_SENUM, 127, ' ' },\n+{ \"enum E4\", TYPE_UENUM, 255, ' ' },\n+{ \"enum E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"enum E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"enum E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"enum E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"enum E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"TE0\", TYPE_UENUM, 0, ' ' },\n+{ \"TE1\", TYPE_UENUM, 1, ' ' },\n+{ \"TE2\", TYPE_SENUM, 3, ' ' },\n+{ \"TE3\", TYPE_SENUM, 127, ' ' },\n+{ \"TE4\", TYPE_UENUM, 255, ' ' },\n+{ \"TE5\", TYPE_SENUM, 32767, ' ' },\n+{ \"TE6\", TYPE_UENUM, 65535, ' ' },\n+{ \"TE7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"TE8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"TE9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+/* vector-defs.h typedefs */\n+{ \"qi\", TYPE_INT, 127, 0 },\n+{ \"hi\", TYPE_INT, 32767, 0 },\n+{ \"si\", TYPE_INT, 2147483647, 0 },\n+{ \"di\", TYPE_INT, 9223372036854775807LL, 0 },\n+{ \"sf\", TYPE_FLOAT, 0, 0 },\n+{ \"df\", TYPE_FLOAT, 0, 0 }\n+#define NTYPES2 (sizeof (base_types) / sizeof (base_types[0]))\n+};\n+struct types vector_types[] = {\n+/* vector-defs.h typedefs */\n+{ \"v8qi\", TYPE_OTHER, 0, 0 },\n+{ \"v16qi\", TYPE_OTHER, 0, 0 },\n+{ \"v2hi\", TYPE_OTHER, 0, 0 },\n+{ \"v4hi\", TYPE_OTHER, 0, 0 },\n+{ \"v8hi\", TYPE_OTHER, 0, 0 },\n+{ \"v2si\", TYPE_OTHER, 0, 0 },\n+{ \"v4si\", TYPE_OTHER, 0, 0 },\n+{ \"v1di\", TYPE_OTHER, 0, 0 },\n+{ \"v2di\", TYPE_OTHER, 0, 0 },\n+{ \"v2sf\", TYPE_OTHER, 0, 0 },\n+{ \"v4sf\", TYPE_OTHER, 0, 0 },\n+{ \"v16sf\", TYPE_OTHER, 0, 0 },\n+{ \"v2df\", TYPE_OTHER, 0, 0 },\n+{ \"u8qi\", TYPE_OTHER, 0, 0 },\n+{ \"u16qi\", TYPE_OTHER, 0, 0 },\n+{ \"u2hi\", TYPE_OTHER, 0, 0 },\n+{ \"u4hi\", TYPE_OTHER, 0, 0 },\n+{ \"u8hi\", TYPE_OTHER, 0, 0 },\n+{ \"u2si\", TYPE_OTHER, 0, 0 },\n+{ \"u4si\", TYPE_OTHER, 0, 0 },\n+{ \"u1di\", TYPE_OTHER, 0, 0 },\n+{ \"u2di\", TYPE_OTHER, 0, 0 },\n+{ \"u2sf\", TYPE_OTHER, 0, 0 },\n+{ \"u4sf\", TYPE_OTHER, 0, 0 },\n+{ \"u16sf\", TYPE_OTHER, 0, 0 },\n+{ \"u2df\", TYPE_OTHER, 0, 0 },\n+{ \"__m64\", TYPE_OTHER, 0, 0 },\n+{ \"__m128\", TYPE_OTHER, 0, 0 }\n+#define NVTYPES2 (sizeof (vector_types) / sizeof (vector_types[0]))\n+};\n+struct types attrib_types[] = {\n+{ \"Talchar\", TYPE_UINT, 127, 'C' },\n+{ \"Talschar\", TYPE_INT, 127, 'C' },\n+{ \"Taluchar\", TYPE_UINT, 255, 'C' },\n+{ \"Talshort\", TYPE_INT, 32767, 'S' },\n+{ \"Talushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talint\", TYPE_INT, 2147483647, 'I' },\n+{ \"Taluint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tallong\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talllong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talbool\", TYPE_UINT, 1, 'B' },\n+{ \"Talptr\", TYPE_PTR, 0, 0 },\n+{ \"Talcptr\", TYPE_PTR, 0, 0 },\n+{ \"Taliptr\", TYPE_PTR, 0, 0 },\n+{ \"Talfloat\", TYPE_FLOAT, 0, 0 },\n+{ \"Taldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"TalE0\", TYPE_UENUM, 0, ' ' },\n+{ \"TalE1\", TYPE_UENUM, 1, ' ' },\n+{ \"TalE2\", TYPE_SENUM, 3, ' ' },\n+{ \"TalE3\", TYPE_SENUM, 127, ' ' },\n+{ \"TalE4\", TYPE_UENUM, 255, ' ' },\n+{ \"TalE5\", TYPE_SENUM, 32767, ' ' },\n+{ \"TalE6\", TYPE_UENUM, 65535, ' ' },\n+{ \"TalE7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"TalE8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"TalE9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal1char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal1schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal1uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal1short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal1ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal1int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal1uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal1long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal1ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal1llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal1ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal1bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal1ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal1E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal1E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal1E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal1E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal1E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal1E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal1E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal1E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal1E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal2char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal2schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal2uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal2short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal2ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal2int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal2uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal2long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal2ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal2llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal2ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal2bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal2ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal2E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal2E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal2E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal2E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal2E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal2E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal2E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal2E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal2E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal4char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal4schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal4uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal4short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal4ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal4int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal4uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal4long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal4ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal4llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal4ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal4bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal4ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal4E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal4E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal4E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal4E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal4E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal4E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal4E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal4E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal4E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal8char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal8schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal8uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal8short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal8ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal8int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal8uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal8long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal8ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal8llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal8ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal8bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal8ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal8E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal8E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal8E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal8E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal8E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal8E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal8E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal8E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal8E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal16char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal16schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal16uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal16short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal16ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal16int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal16uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal16long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal16ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal16llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal16ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal16bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal16ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal16E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal16E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal16E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal16E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal16E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal16E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal16E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal16E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal16E9\", TYPE_SENUM, 1099511627775LL, ' ' }\n+#define NATYPES2 (sizeof (attrib_types) / sizeof (attrib_types[0]))\n+};\n+\n+struct types bitfld_types[NTYPES2];\n+int n_bitfld_types;\n+struct types aligned_bitfld_types[NATYPES2];\n+int n_aligned_bitfld_types;\n+\n+const char *attributes[] = {\n+\"atal\", \n+\"atpa\", \n+\"atal1\", \n+\"atal2\", \n+\"atal4\", \n+\"atal8\", \n+\"atal16\", \n+#define NATTRIBS1 7\n+\"atalpa\", \n+\"atpaal\", \n+\"atal1pa\", \n+\"atal2pa\", \n+\"atal4pa\", \n+\"atal8pa\", \n+\"atal16pa\", \n+\"atpaal1\", \n+\"atpaal2\", \n+\"atpaal4\", \n+\"atpaal8\", \n+\"atpaal16\"\n+#define NATTRIBS2 (sizeof (attributes) / sizeof (attributes[0]))\n+};\n+\n+enum ETYPE\n+{\n+  ETYPE_TYPE,\n+  ETYPE_ARRAY,\n+  ETYPE_BITFLD,\n+  ETYPE_STRUCT,\n+  ETYPE_UNION,\n+  ETYPE_STRUCT_ARRAY,\n+  ETYPE_UNION_ARRAY\n+};\n+\n+struct entry\n+{\n+#ifdef __GNUC__\n+  enum ETYPE etype : 8;\n+#else\n+  unsigned char etype;\n+#endif\n+  unsigned short len;\n+  unsigned char arr_len;\n+  struct types *type;\n+  const char *attrib;\n+};\n+struct types attrib_array_types[] = {\n+{ \"Talx1char\", TYPE_UINT, 127, 'C' },\n+{ \"Talx1schar\", TYPE_INT, 127, 'C' },\n+{ \"Talx1uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Talx1short\", TYPE_INT, 32767, 'S' },\n+{ \"Talx1ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talx1int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx1uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx1long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx1ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx1llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx1ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx1bool\", TYPE_UINT, 1, 'B' },\n+{ \"Talx1ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx1E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx1E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx1E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx1E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx1E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx1E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx1E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx1E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx1E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Talx2short\", TYPE_INT, 32767, 'S' },\n+{ \"Talx2ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talx2int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx2uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx2long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx2ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx2llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx2ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx2ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx2E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx2E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx2E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx2E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx2E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx2E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx2E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx2E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx2E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Talx4int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx4uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx4long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx4ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx4llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx4ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx4ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx4E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx4E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx4E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx4E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx4E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx4E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx4E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx4E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx4E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Taly8long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Taly8ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx8llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx8ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Taly8ptr\", TYPE_PTR, 0, 0 },\n+{ \"Taly8cptr\", TYPE_PTR, 0, 0 },\n+{ \"Taly8iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx8double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx8ldouble\", TYPE_FLOAT, 0, 0 }\n+#define NAATYPES2 (sizeof (attrib_array_types) / sizeof (attrib_array_types[0]))\n+};\n+\n+static int idx, limidx, output_one;\n+static const char *destdir;\n+static const char *srcdir;\n+FILE *outfile;\n+\n+void\n+switchfiles (int fields)\n+{\n+  static int filecnt;\n+  static char *destbuf, *destptr;\n+  ++filecnt;\n+  if (outfile)\n+    fclose (outfile);\n+  if (output_one)\n+    {\n+      outfile = stdout;\n+      return;\n+    }\n+  if (destbuf == NULL)\n+    {\n+      size_t len = strlen (destdir);\n+      destbuf = xmalloc (len + 20);\n+      memcpy (destbuf, destdir, len);\n+      if (!len || destbuf[len - 1] != '/')\n+\tdestbuf[len++] = '/';\n+      destptr = destbuf + len;\n+    }\n+  sprintf (destptr, \"t%03d_main.C\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    {\n+    fail:\n+      fputs (\"failed to create test files\\n\", stderr);\n+      exit (1);\n+    }\n+  fprintf (outfile, \"\\\n+/* { dg-options \\\"-I%s\\\" } */\\n\\\n+/* { dg-options \\\"-I%s -fno-common\\\" { target hppa*-*-hpux* } } */\\n\\\n+/* { dg-options \\\"-I%s -mno-base-addresses\\\" { target mmix-*-* } } */\\n\\\n+#include \\\"struct-layout-1.h\\\"\\n\\\n+\\n\\\n+#define TX(n, type, attrs, fields, ops) extern void test##n (void);\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#undef TX\\n\\\n+\\n\\\n+int main (void)\\n\\\n+{\\n\\\n+#define TX(n, type, attrs, fields, ops)   test##n ();\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#undef TX\\n\\\n+  if (fails)\\n\\\n+    {\\n\\\n+      fflush (stdout);\\n\\\n+      abort ();\\n\\\n+    }\\n\\\n+  exit (0);\\n\\\n+}\\n\", srcdir, srcdir, srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_x.C\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  fprintf (outfile, \"\\\n+/* { dg-options \\\"-w -I%s\\\" } */\\n\\\n+/* { dg-options \\\"-w -I%s -fno-common\\\" { target hppa*-*-hpux* } } */\\n\\\n+/* { dg-options \\\"-w -I%s -mno-base-addresses\\\" { target mmix-*-* } } */\\n\\\n+#include \\\"struct-layout-1_x1.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#include \\\"struct-layout-1_x2.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\", srcdir, srcdir, srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_y.C\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  fprintf (outfile, \"\\\n+/* { dg-options \\\"-w -I%s\\\" } */\\n\\\n+/* { dg-options \\\"-w -I%s -fno-common\\\" { target hppa*-*-hpux* } } */\\n\\\n+/* { dg-options \\\"-w -I%s -mno-base-addresses\\\" { target mmix-*-* } } */\\n\\\n+#include \\\"struct-layout-1_y1.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#include \\\"struct-layout-1_y2.h\\\"\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\", srcdir, srcdir, srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_test.h\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  if (fields <= 2)\n+    limidx = idx + 300;\n+  else if (fields <= 4)\n+    limidx = idx + 200;\n+  else if (fields <= 6)\n+    limidx = idx + 100;\n+  else\n+    limidx = idx + 50;\n+}\n+\n+unsigned long long int\n+getrandll (void)\n+{\n+  unsigned long long int ret;\n+  ret = generate_random () & 0xffffff;\n+  ret |= (generate_random () & 0xffffffLL) << 24;\n+  ret |= ((unsigned long long int) generate_random ()) << 48;\n+  return ret;\n+}\n+\n+int\n+subfield (struct entry *e, char *letter)\n+{\n+  int i, type;\n+  char buf[20];\n+  const char *p;\n+  switch (e[0].etype)\n+    {\n+    case ETYPE_STRUCT:\n+    case ETYPE_UNION:\n+    case ETYPE_STRUCT_ARRAY:\n+    case ETYPE_UNION_ARRAY:\n+      type = e[0].attrib ? 1 + (generate_random () & 3) : 0;\n+      if (e[0].etype == ETYPE_STRUCT || e[0].etype == ETYPE_STRUCT_ARRAY)\n+\tp = \"struct\";\n+      else\n+\tp = \"union\";\n+      if (e[0].etype == ETYPE_STRUCT_ARRAY || e[0].etype == ETYPE_UNION_ARRAY)\n+\t{\n+\t  if (e[0].arr_len == 255)\n+\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t  else\n+\t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n+\t}\n+      else\n+\t{\n+\t  buf[0] = *letter;\n+\t  buf[1] = '\\0';\n+\t}\n+      ++*letter;\n+      switch (type)\n+\t{\n+\tcase 0:\n+\tcase 3:\n+\tcase 4:\n+\t  fprintf (outfile, \"%s{\", p);\n+\t  break;\n+\tcase 1:\n+\t  fprintf (outfile, \"%s %s{\", e[0].attrib, p);\n+\t  break;\n+\tcase 2:\n+\t  fprintf (outfile, \"%s %s{\", p, e[0].attrib);\n+\t  break;\n+\t}\n+\n+      for (i = 1; i <= e[0].len; )\n+\ti += subfield (e + i, letter);\n+\n+      switch (type)\n+\t{\n+\tcase 0:\n+\tcase 1:\n+\tcase 2:\n+\t  fprintf (outfile, \"}%s;\", buf);\n+\t  break;\n+\tcase 3:\n+\t  fprintf (outfile, \"}%s %s;\", e[0].attrib, buf);\n+\t  break;\n+\tcase 4:\n+\t  fprintf (outfile, \"}%s %s;\", buf, e[0].attrib);\n+\t  break;\n+\t}\n+      return 1 + e[0].len;\n+    case ETYPE_TYPE:\n+    case ETYPE_ARRAY:\n+      if (e[0].etype == ETYPE_ARRAY)\n+\t{\n+\t  if (e[0].arr_len == 255)\n+\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t  else\n+\t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n+\t}\n+      else\n+\t{\n+\t  buf[0] = *letter;\n+\t  buf[1] = '\\0';\n+\t}\n+      ++*letter;\n+      if (e[0].attrib)\n+\tswitch (generate_random () % 3)\n+\t  {\n+\t  case 0:\n+\t    fprintf (outfile, \"%s %s %s;\", e[0].attrib, e[0].type->name, buf);\n+\t    break;\n+\t  case 1:\n+\t    fprintf (outfile, \"%s %s %s;\", e[0].type->name, e[0].attrib, buf);\n+\t    break;\n+\t  case 2:\n+\t    fprintf (outfile, \"%s %s %s;\", e[0].type->name, buf, e[0].attrib);\n+\t    break;\n+\t  }\n+      else\n+\tfprintf (outfile, \"%s %s;\", e[0].type->name, buf);\n+      return 1;\n+    case ETYPE_BITFLD:\n+      if (e[0].len == 0)\n+\t{\n+\t  if (e[0].attrib)\n+\t    switch (generate_random () % 3)\n+\t      {\n+\t      case 0:\n+\t\tfprintf (outfile, \"%s %s:0;\", e[0].attrib, e[0].type->name);\n+\t\tbreak;\n+\t      case 1:\n+\t\tfprintf (outfile, \"%s %s:0;\", e[0].type->name, e[0].attrib);\n+\t\tbreak;\n+\t      case 2:\n+\t\tfprintf (outfile, \"%s:0 %s;\", e[0].type->name, e[0].attrib);\n+\t\tbreak;\n+\t      }\n+\t  else\n+\t    fprintf (outfile, \"%s:0;\", e[0].type->name);\n+\t  ++*letter;\n+\t  return 1;\n+\t}\n+      snprintf (buf, 20, \"%d\", e[0].len);\n+      if (e[0].attrib)\n+\tswitch (generate_random () % 3)\n+\t  {\n+\t  case 0:\n+\t    fprintf (outfile, \"%s %s %c:%s;\", e[0].attrib, e[0].type->name,\n+\t\t     *letter, buf);\n+\t    break;\n+\t  case 1:\n+\t    fprintf (outfile, \"%s %s %c:%s;\", e[0].type->name, e[0].attrib,\n+\t\t     *letter, buf);\n+\t    break;\n+\t  case 2:\n+\t    fprintf (outfile, \"%s %c:%s %s;\", e[0].type->name, *letter,\n+\t\t     buf, e[0].attrib);\n+\t    break;\n+\t  }\n+      else\n+\tfprintf (outfile, \"%s %c:%s;\", e[0].type->name, *letter, buf);\n+      ++*letter;\n+      return 1;\n+    default:\n+      abort ();\n+  }\n+}\n+\n+char namebuf[1024];\n+\n+void\n+output_FNB (char mode, struct entry *e)\n+{\n+  unsigned long long int l1, l2, m;\n+  int signs = 0;\n+  const char *p, *q;\n+\n+  if (e->type->type == TYPE_OTHER)\n+    {\n+      if (mode == 'B')\n+\tabort ();\n+      fprintf (outfile, \"N(%d,%s)\", idx, namebuf);\n+      return;\n+    }\n+  fprintf (outfile, \"%c(%d,%s,\", mode, idx, namebuf);\n+  l1 = getrandll ();\n+  l2 = getrandll ();\n+  switch (e->type->type)\n+    {\n+    case TYPE_INT:\n+      signs = generate_random () & 3;\n+      m = e->type->maxval;\n+      if (mode == 'B')\n+\tm &= e->len > 1 ? (1ULL << (e->len - 1)) - 1 : 1;\n+      l1 &= m;\n+      l2 &= m;\n+      fprintf (outfile, \"%s%llu%s,%s%llu%s\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      break;\n+    case TYPE_UINT:\n+      m = e->type->maxval;\n+      if (mode == 'B')\n+\tm &= (1ULL << e->len) - 1;\n+      l1 &= m;\n+      l2 &= m;\n+      fprintf (outfile, \"%lluU%s,%lluU%s\", l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      break;\n+    case TYPE_FLOAT:\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"%s%f,%s%f\", (signs & 1) ? \"-\" : \"\",\n+\t       ((double) l1) / 64, (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      break;\n+    case TYPE_UENUM:\n+      if (e->type->maxval == 0)\n+\tfputs (\"e0_0,e0_0\", outfile);\n+      else if (e->type->maxval == 1)\n+\tfprintf (outfile, \"e1_%lld,e1_%lld\", l1 & 1, l2 & 1);\n+      else\n+\t{\n+\t  p = strchr (e->type->name, '\\0');\n+\t  while (--p >= e->type->name && *p >= '0' && *p <= '9');\n+\t  p++;\n+\t  l1 %= 7;\n+\t  l2 %= 7;\n+\t  if (l1 > 3)\n+\t    l1 += e->type->maxval - 6;\n+\t  if (l2 > 3)\n+\t    l2 += e->type->maxval - 6;\n+\t  fprintf (outfile, \"e%s_%lld,e%s_%lld\", p, l1, p, l2);\n+\t}\n+      break;\n+    case TYPE_SENUM:\n+      p = strchr (e->type->name, '\\0');\n+      while (--p >= e->type->name && *p >= '0' && *p <= '9');\n+      p++;\n+      l1 %= 7;\n+      l2 %= 7;\n+      fprintf (outfile, \"e%s_%s%lld,e%s_%s%lld\",\n+\t       p, l1 < 3 ? \"m\" : \"\",\n+\t       l1 == 3 ? 0LL : e->type->maxval - (l1 & 3),\n+\t       p, l2 < 3 ? \"m\" : \"\",\n+\t       l2 == 3 ? 0LL : e->type->maxval - (l2 & 3));\n+      break;\n+    case TYPE_PTR:\n+      l1 %= 256;\n+      l2 %= 256;\n+      fprintf (outfile, \"(%s)&intarray[%lld],(%s)&intarray[%lld]\",\n+\t       e->type->name, l1, e->type->name, l2);\n+      break;\n+    case TYPE_FNPTR:\n+      l1 %= 10;\n+      l2 %= 10;\n+      fprintf (outfile, \"fn%lld,fn%lld\", l1, l2);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  fputs (\")\", outfile);\n+}\n+\n+int\n+subvalues (struct entry *e, char *p, char *letter)\n+{\n+  int i, j;\n+  char *q;\n+  if (p >= namebuf + sizeof (namebuf) - 32)\n+    abort ();\n+  p[0] = *letter;\n+  p[1] = '\\0';\n+  q = p + 1;\n+  switch (e[0].etype)\n+    {\n+    case ETYPE_STRUCT_ARRAY:\n+    case ETYPE_UNION_ARRAY:\n+      if (e[0].arr_len == 0 || e[0].arr_len == 255)\n+\t{\n+\t  *letter += 1 + e[0].len;\n+\t  return 1 + e[0].len;\n+\t}\n+      i = generate_random () % e[0].arr_len;\n+      snprintf (p, sizeof (namebuf) - (p - namebuf) - 1,\n+\t\t\"%c[%d]\", *letter, i);\n+      q = strchr (p, '\\0');\n+      /* FALLTHROUGH */\n+    case ETYPE_STRUCT:\n+    case ETYPE_UNION:\n+      *q++ = '.';\n+      ++*letter;\n+      for (i = 1; i <= e[0].len; )\n+\t{\n+\t  i += subvalues (e + i, q, letter);\n+\t  if (e[0].etype == ETYPE_UNION || e[0].etype == ETYPE_UNION_ARRAY)\n+\t    {\n+\t      *letter += e[0].len - i + 1;\n+\t      break;\n+\t    }\n+\t}\n+      return 1 + e[0].len;\n+    case ETYPE_TYPE:\n+      ++*letter;\n+      output_FNB ('F', e);\n+      return 1;\n+    case ETYPE_ARRAY:\n+      if (e[0].arr_len == 0 || e[0].arr_len == 255)\n+\t{\n+\t  ++*letter;\n+\t  return 1;\n+\t}\n+      i = generate_random () % e[0].arr_len;\n+      snprintf (p, sizeof (namebuf) - (p - namebuf),\n+\t\t\"%c[%d]\", *letter, i);\n+      output_FNB ('F', e);\n+      if ((generate_random () & 7) == 0)\n+\t{\n+\t  j = generate_random () % e[0].arr_len;\n+\t  if (i != j)\n+\t    {\n+\t      snprintf (p, sizeof (namebuf) - (p - namebuf),\n+\t\t\t\"%c[%d]\", *letter, j);\n+\t      output_FNB ('F', e);\n+\t    }\n+\t}\n+      ++*letter;\n+      return 1;\n+    case ETYPE_BITFLD:\n+      ++*letter;\n+      if (e[0].len != 0)\n+\toutput_FNB ('B', e);\n+      return 1;\n+    }\n+}\n+\n+hashval_t\n+e_hash (const void *a)\n+{\n+  const struct entry *e = a;\n+  hashval_t ret = 0;\n+  int i;\n+\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+  for (i = 0; i <= e[0].len; ++i)\n+    {\n+      int attriblen;\n+      ret = iterative_hash (&e[i], offsetof (struct entry, attrib), ret);\n+      attriblen = e[i].attrib ? strlen (e[i].attrib) : -1;\n+      ret = iterative_hash (&attriblen, sizeof (int), ret);\n+      if (e[i].attrib)\n+\tret = iterative_hash (e[i].attrib, attriblen, ret);\n+    }\n+  return ret;\n+}\n+\n+int\n+e_eq (const void *a, const void *b)\n+{\n+  const struct entry *ea = a, *eb = b;\n+  int i;\n+  if (ea[0].etype != ETYPE_STRUCT && ea[0].etype != ETYPE_UNION)\n+    abort ();\n+  if (ea[0].len != eb[0].len)\n+    return 0;\n+  for (i = 0; i <= ea[0].len; ++i)\n+    {\n+      if (ea[i].etype != eb[i].etype\n+\t  || ea[i].len != eb[i].len\n+\t  || ea[i].arr_len != eb[i].arr_len\n+\t  || ea[i].type != eb[i].type)\n+\treturn 0;\n+      if ((ea[i].attrib == NULL) ^ (eb[i].attrib == NULL))\n+\treturn 0;\n+      if (ea[i].attrib && strcmp (ea[i].attrib, eb[i].attrib) != 0)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+htab_t hasht;\n+\n+void\n+output (struct entry *e)\n+{\n+  int i;\n+  char c;\n+  void **p;\n+\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+\n+  p = htab_find_slot (hasht, e, INSERT);\n+  if (*p != NULL)\n+    return;\n+\n+  *p = malloc ((e[0].len + 1) * sizeof (struct entry));\n+  memcpy (*p, e, (e[0].len + 1) * sizeof (struct entry));\n+\n+  if (idx == limidx)\n+    switchfiles (e[0].len);\n+\n+  if (e[0].etype == ETYPE_STRUCT)\n+    fprintf (outfile, \"T(%d,\", idx);\n+  else\n+    fprintf (outfile, \"U(%d,\", idx);\n+  c = 'a';\n+  for (i = 1; i <= e[0].len; )\n+    i += subfield (e + i, &c);\n+  fputs (\",\", outfile);\n+  c = 'a';\n+  for (i = 1; i <= e[0].len; )\n+    {\n+      i += subvalues (e + i, namebuf, &c);\n+      if (e[0].etype == ETYPE_UNION)\n+\tbreak;\n+    }\n+  fputs (\")\\n\", outfile);\n+  if (output_one && idx == limidx)\n+    exit (0);\n+  ++idx;\n+}\n+\n+enum FEATURE\n+{\n+  FEATURE_VECTOR = 1,\n+  FEATURE_ALIGNEDPACKED = 2,\n+  FEATURE_ZEROARRAY = 4,\n+  FEATURE_ZEROBITFLD = 8,\n+  ALL_FEATURES = FEATURE_VECTOR | FEATURE_ZEROARRAY\n+\t\t | FEATURE_ALIGNEDPACKED | FEATURE_ZEROBITFLD\n+};\n+\n+void\n+singles (enum FEATURE features)\n+{\n+  struct entry e[2];\n+  int i;\n+  memset (e, 0, sizeof (e));\n+  e[0].etype = ETYPE_STRUCT;\n+  output (e);\n+  e[0].etype = ETYPE_UNION;\n+  output (e);\n+  e[0].len = 1;\n+  for (i = 0; i < NTYPES2; ++i)\n+    {\n+      e[0].etype = ETYPE_STRUCT;\n+      e[1].etype = ETYPE_TYPE;\n+      e[1].type = &base_types[i];\n+      output (e);\n+      e[0].etype = ETYPE_UNION;\n+      output (e);\n+    }\n+  if (features & FEATURE_VECTOR)\n+    for (i = 0; i < NVTYPES2; ++i)\n+      {\n+\te[0].etype = ETYPE_STRUCT;\n+\te[1].etype = ETYPE_TYPE;\n+\te[1].type = &vector_types[i];\n+\toutput (e);\n+\te[0].etype = ETYPE_UNION;\n+\toutput (e);\n+      }\n+}\n+\n+void\n+choose_type (enum FEATURE features, struct entry *e, int r, int in_array)\n+{\n+  int i;\n+\n+  i = NTYPES2 - NTYPES1;\n+  if (features & FEATURE_VECTOR)\n+    i += NVTYPES2;\n+  if ((r & 3) == 0)\n+    {\n+      if (in_array)\n+\ti += NAATYPES2;\n+      else\n+\ti += NATYPES2;\n+    }\n+  r >>= 2;\n+  r %= i;\n+  if (r < NTYPES2 - NTYPES1)\n+    e->type = &base_types[r + NTYPES1];\n+  r -= NTYPES2 - NTYPES1;\n+  if (e->type == NULL && (features & FEATURE_VECTOR))\n+    {\n+      if (r < NVTYPES2)\n+\te->type = &vector_types[r];\n+      r -= NVTYPES2;\n+    }\n+  if (e->type == NULL && !in_array)\n+    {\n+      if (r < NATYPES2)\n+\te->type = &attrib_types[r];\n+      r -= NATYPES2;\n+    }\n+  if (e->type == NULL && in_array)\n+    {\n+      if (r < NAATYPES2)\n+\te->type = &attrib_array_types[r];\n+      r -= NAATYPES2;\n+    }\n+  if (e->type == NULL)\n+    abort ();\n+}\n+\n+/* This is from gcc.c-torture/execute/builtin-bitops-1.c.  */\n+static int\n+my_ffsll (unsigned long long x)\n+{\n+  int i;\n+  if (x == 0)\n+    return 0;\n+  /* We've tested LLONG_MAX for 64 bits so this should be safe.  */\n+  for (i = 0; i < 64; i++)\n+    if (x & (1ULL << i))\n+      break;\n+  return i + 1;\n+}\n+\n+void\n+generate_fields (enum FEATURE features, struct entry *e, struct entry *parent,\n+\t\t int len)\n+{\n+  int r, i, j, ret = 1, n, incr, sametype;\n+\n+  for (n = 0; n < len; n += incr)\n+    {\n+      r = generate_random ();\n+      /* 50% ETYPE_TYPE base_types NTYPES1\n+\t 12.5% ETYPE_TYPE other\n+\t 12.5% ETYPE_ARRAY\n+\t 12.5% ETYPE_BITFLD\n+\t 12.5% ETYPE_STRUCT|ETYPE_UNION|ETYPE_STRUCT_ARRAY|ETYPE_UNION_ARRAY */\n+      i = (r & 7);\n+      r >>= 3;\n+      incr = 1;\n+      switch (i)\n+\t{\n+\tcase 0:\n+\tcase 1:\n+\tcase 2:\n+\tcase 3:\n+\t  e[n].etype = ETYPE_TYPE;\n+\t  e[n].type = &base_types[r % NTYPES1];\n+\t  break;\n+\tcase 4:\n+\t  e[n].etype = ETYPE_TYPE;\n+\t  choose_type (features, &e[n], r, 0);\n+\t  break;\n+\tcase 5:\n+\t  e[n].etype = ETYPE_ARRAY;\n+\t  i = r & 1;\n+\t  r >>= 1;\n+\t  if (i)\n+\t    e[n].type = &base_types[r % NTYPES1];\n+\t  else\n+\t    choose_type (features, &e[n], r, 1);\n+\t  r = generate_random ();\n+\t  if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n+\t    {\n+\t      e[n].arr_len = 0;\n+\t      if (n == len - 1 && (r & 4)\n+\t\t  && (parent->etype == ETYPE_STRUCT\n+\t\t      || parent->etype == ETYPE_STRUCT_ARRAY))\n+\t\t{\n+\t\t  int k;\n+\t\t  for (k = 0; k < n; ++k)\n+\t\t    if (e[k].etype != ETYPE_BITFLD || e[k].len)\n+\t\t      {\n+\t\t\te[n].arr_len = 255;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\t  else if ((r & 3) != 3)\n+\t    e[n].arr_len = (r >> 2) & 7;\n+\t  else\n+\t    e[n].arr_len = (r >> 2) & 31;\n+\t  break;\n+\tcase 6:\n+\t  sametype = 1;\n+\t  switch (r & 7)\n+\t    {\n+\t    case 0:\n+\t    case 1:\n+\t    case 2:\n+\t      break;\n+\t    case 3:\n+\t    case 4:\n+\t    case 5:\n+\t      incr = 1 + (r >> 3) % (len - n);\n+\t      break;\n+\t    case 6:\n+\t    case 7:\n+\t      sametype = 0;\n+\t      incr = 1 + (r >> 3) % (len - n);\n+\t      break;\n+\t    }\n+\t  for (j = n; j < n + incr; ++j)\n+\t    {\n+\t      int mi, ma;\n+\n+\t      e[j].etype = ETYPE_BITFLD;\n+\t      if (j == n || !sametype)\n+\t\t{\n+\t\t  int k;\n+\t\t  r = generate_random ();\n+\t\t  k = r & 3;\n+\t\t  r >>= 2;\n+\t\t  if (!k)\n+\t\t    e[j].type\n+\t\t      = &aligned_bitfld_types[r % n_aligned_bitfld_types];\n+\t\t  else\n+\t\t    e[j].type\n+\t\t      = &bitfld_types[r % n_bitfld_types];\n+\t\t}\n+\t      else\n+\t\te[j].type = e[n].type;\n+\t      r = generate_random ();\n+\t      mi = 0;\n+\t      ma = 0;\n+\t      switch (e[j].type->bitfld)\n+\t\t{\n+\t\tcase 'C': ma = 8; break;\n+\t\tcase 'S': ma = 16; break;\n+\t\tcase 'I': ma = 32; break;\n+\t\tcase 'L':\n+\t\tcase 'Q': ma = 64; break;\n+\t\tcase 'B': ma = 1; break;\n+\t\tcase ' ':\n+\t\t  if (e[j].type->type == TYPE_UENUM)\n+\t\t    mi = my_ffsll (e[j].type->maxval + 1) - 1;\n+\t\t  else if (e[j].type->type == TYPE_SENUM)\n+\t\t    mi = my_ffsll (e[j].type->maxval + 1);\n+\t\t  else\n+\t\t    abort ();\n+\t\t  if (!mi)\n+\t\t    mi = 1;\n+\t\t  if (mi <= 32)\n+\t\t    ma = 32;\n+\t\t  else\n+\t\t    ma = 64;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t      e[j].len = ma + 1;\n+\t      if (sametype && (r & 3) == 0 && ma > 1)\n+\t\t{\n+\t\t  int sum = 0, k;\n+\t\t  for (k = n; k < j; ++k)\n+\t\t    sum += e[k].len;\n+\t\t  sum %= ma;\n+\t\t  e[j].len = sum ? ma - sum : ma;\n+\t\t}\n+\t      r >>= 2;\n+\t      if (!sametype && (r & 7) == 0)\n+\t\tma *= 8;\n+\t      r >>= 3;\n+\t      if (! (features & FEATURE_ZEROBITFLD) && mi == 0)\n+\t\tmi = 1;\n+\t      if (e[j].len < mi || e[j].len > ma)\n+\t\te[j].len = mi + (r % (ma + 1 - mi));\n+\t      r >>= 6;\n+\t      if ((features & FEATURE_ZEROBITFLD) && (r & 3) == 0\n+\t\t  && mi == 0)\n+\t\te[j].len = 0;\n+\t    }\n+\t  break;\n+\tcase 7:\n+\t  switch (r & 7)\n+\t    {\n+\t    case 0:\n+\t    case 1:\n+\t    case 2:\n+\t      e[n].etype = ETYPE_STRUCT;\n+\t      break;\n+\t    case 3:\n+\t    case 4:\n+\t      e[n].etype = ETYPE_UNION;\n+\t      break;\n+\t    case 5:\n+\t    case 6:\n+\t      e[n].etype = ETYPE_STRUCT_ARRAY;\n+\t      break;\n+\t    case 7:\n+\t      e[n].etype = ETYPE_UNION_ARRAY;\n+\t      break;\n+\t    }\n+\t  r >>= 3;\n+\t  e[n].len = r % (len - n);\n+\t  incr = 1 + e[n].len;\n+\t  generate_fields (features, &e[n + 1], &e[n], e[n].len);\n+\t  if (e[n].etype == ETYPE_STRUCT_ARRAY\n+\t      || e[n].etype == ETYPE_UNION_ARRAY)\n+\t    {\n+\t      r = generate_random ();\n+\t      if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n+\t\t{\n+\t\t  e[n].arr_len = 0;\n+\t\t  if (n + incr == len && (r & 4)\n+\t\t      && (parent->etype == ETYPE_STRUCT\n+\t\t\t  || parent->etype == ETYPE_STRUCT_ARRAY))\n+\t\t    {\n+\t\t      int k;\n+\t\t      for (k = 0; k < n; ++k)\n+\t\t\tif (e[k].etype != ETYPE_BITFLD || e[k].len)\n+\t\t\t  {\n+\t\t\t    e[n].arr_len = 255;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t      else if ((r & 3) != 3)\n+\t\te[n].arr_len = (r >> 2) & 7;\n+\t      else\n+\t\te[n].arr_len = (r >> 2) & 31;\n+\t    }\n+\t  break;\n+\t}\n+      r = generate_random ();\n+      if ((r & 7) == 0)\n+\t{\n+\t  r >>= 3;\n+\t  i = (features & FEATURE_ALIGNEDPACKED) ? NATTRIBS2 : NATTRIBS1;\n+\t  e[n].attrib = attributes[r % i];\n+\t  if (! (features & FEATURE_ALIGNEDPACKED)\n+\t      && strcmp (e[n].attrib, \"atpa\") == 0\n+\t      && ((e[n].type >= &attrib_types[0]\n+\t\t   && e[n].type < &attrib_types[NATYPES2])\n+\t\t  || (e[n].type >= &attrib_array_types[0]\n+\t\t      && e[n].type < &attrib_array_types[NAATYPES2])\n+\t\t  || (e[n].type >= &aligned_bitfld_types[0]\n+\t\t      && e[n].type < &aligned_bitfld_types[n_aligned_bitfld_types])))\n+\t    e[n].attrib = NULL;\n+\n+\t  /* If this is an array type, do not put aligned attributes on\n+\t     elements.  Aligning elements to a value greater than their\n+\t     size will result in a compiler error.  */\n+\n+\t  if ((e[n].etype == ETYPE_ARRAY)\n+\t      && e[n].attrib != NULL\n+\t      && (strncmp (e[n].attrib, \"atal\", 4) == 0))\n+\t     e[n].attrib = NULL;\n+\t}\n+    }\n+}\n+\n+void\n+generate_random_tests (enum FEATURE features, int len)\n+{\n+  struct entry e[len + 1];\n+  int i, r;\n+  if (len > 'z' - 'a' + 1)\n+    abort ();\n+  memset (e, 0, sizeof (e));\n+  r = generate_random ();\n+  if ((r & 7) == 0)\n+    e[0].etype = ETYPE_UNION;\n+  else\n+    e[0].etype = ETYPE_STRUCT;\n+  r >>= 3;\n+  e[0].len = len;\n+  generate_fields (features, &e[1], &e[0], len);\n+  output (e);\n+}\n+\n+struct { const char *name; enum FEATURE f; }\n+features[] = {\n+{ \"normal\", 0 },\n+{ \"vector\", FEATURE_VECTOR },\n+{ \"[0] :0\", FEATURE_ZEROARRAY | FEATURE_ZEROBITFLD },\n+{ \"vector [0]\",\n+  FEATURE_VECTOR | FEATURE_ZEROARRAY },\n+{ \"aligned packed vector [0] :0\",\n+  FEATURE_VECTOR | FEATURE_ZEROARRAY\n+  | FEATURE_ALIGNEDPACKED | FEATURE_ZEROBITFLD },\n+};\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i, j, count, c, n = 3000;\n+\n+  if (sizeof (int) != 4 || sizeof (long long) != 8)\n+    return 1;\n+\n+  while ((c = getopt (argc, argv, \"d:i:n:s:\")) != -1)\n+    switch (c)\n+      {\n+      case 'n':\n+\tn = atoi (optarg);\n+\tbreak;\n+      case 'd':\n+\tdestdir = optarg;\n+\tbreak;\n+      case 's':\n+\tsrcdir = optarg;\n+\tbreak;\n+      case 'i':\n+\toutput_one = 1;\n+\tlimidx = atoi (optarg);\n+\tbreak;\n+      default:\n+\tgoto usage;\n+      }\n+\n+  if (output_one)\n+    {\n+      outfile = fopen (\"/dev/null\", \"w\");\n+      if (outfile == NULL)\n+\t{\n+\t  fputs (\"could not open /dev/null\", stderr);\n+\t  return 1;\n+\t}\n+      n = limidx + 1;\n+    }\n+\n+  if (destdir == NULL && !output_one)\n+    {\n+    usage:\n+      fprintf (stderr, \"Usage:\\n\\\n+%s [-s srcdir -d destdir] [-n count] [-i idx]\\n\\\n+Either -s srcdir -d destdir or -i idx must be used\\n\", argv[0]);\n+      return 1;\n+    }\n+\n+  if (srcdir == NULL && !output_one)\n+    goto usage;\n+\n+  hasht = htab_create (40000, e_hash, e_eq, NULL);\n+  for (i = 0; i < NTYPES2; ++i)\n+    if (base_types[i].bitfld)\n+      bitfld_types[n_bitfld_types++] = base_types[i];\n+  for (i = 0; i < NATYPES2; ++i)\n+    if (attrib_types[i].bitfld)\n+      aligned_bitfld_types[n_aligned_bitfld_types++] = attrib_types[i];\n+  for (i = 0; i < sizeof (features) / sizeof (features[0]); ++i)\n+    {\n+      int startidx = idx;\n+      if (! output_one)\n+\tlimidx = idx;\n+      if (!i)\n+\tcount = 200;\n+      else\n+\tcount = 20;\n+      for (j = 1; j <= 9; ++j)\n+\twhile (idx < startidx + j * count)\n+\t  generate_random_tests (features[i].f, j);\n+      while (idx < startidx + count * 10)\n+\tgenerate_random_tests (features[i].f, 10 + (generate_random () % 16));\n+    }\n+  for (i = 0; n > 3000 && i < sizeof (features) / sizeof (features[0]); ++i)\n+    {\n+      int startidx;\n+      startidx = idx;\n+      if (! output_one)\n+\tlimidx = idx;\n+      singles (features[i].f);\n+      if (!i)\n+\t{\n+\t  count = 1000;\n+\t  while (idx < startidx + 1000)\n+\t    generate_random_tests (features[i].f, 1);\n+\t}\n+      else\n+\t{\n+\t  startidx = idx;\n+\t  count = 100;\n+\t  while (idx < startidx + 100)\n+\t    generate_random_tests (features[i].f, 1);\n+\t}\n+      startidx = idx;\n+      for (j = 2; j <= 9; ++j)\n+\twhile (idx < startidx + (j - 1) * count)\n+\t  generate_random_tests (features[i].f, j);\n+      while (idx < startidx + count * 9)\n+\tgenerate_random_tests (features[i].f, 10 + (generate_random () % 16));\n+    }\n+  if (! output_one)\n+    limidx = idx;\n+  while (idx < n)\n+    generate_random_tests (ALL_FEATURES, 1 + (generate_random () % 25));\n+  fclose (outfile);\n+  return 0;\n+}"}, {"sha": "0c7696fa7dbe65f4a55fe37b82b8839d9a4fa906", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_x1.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_x1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_x1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_x1.h?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,68 @@\n+#include \"struct-layout-1.h\"\n+\n+struct Info info;\n+int fails;\n+int intarray[256];\n+int fn0 (void) { return 0; }\n+int fn1 (void) { return 1; }\n+int fn2 (void) { return 2; }\n+int fn3 (void) { return 3; }\n+int fn4 (void) { return 4; }\n+int fn5 (void) { return 5; }\n+int fn6 (void) { return 6; }\n+int fn7 (void) { return 7; }\n+int fn8 (void) { return 8; }\n+int fn9 (void) { return 9; }\n+\n+/* This macro is intended for fields where their\n+   addresses/sizes/alignments and value passing should be checked.  */\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  info.flds[i] = &s##n.x;\t\t\t\t\t\\\n+  info.sizes[i] = sizeof (s##n.x);\t\t\t\t\\\n+  info.aligns[i] = __alignof__ (s##n.x);\t\t\t\\\n+  s##n.x = v;\t\t\t\t\t\t\t\\\n+  a##n[2].x = w;\t\t\t\t\t\t\\\n+  ++i;\n+/* This macro is for fields where just their addresses/sizes/alignments\n+   should be checked.  */\n+#define N(n, x) \t\t\t\t\t\t\\\n+  info.flds[i] = &s##n.x;\t\t\t\t\t\\\n+  info.sizes[i] = sizeof (s##n.x);\t\t\t\t\\\n+  info.aligns[i] = __alignof__ (s##n.x);\t\t\t\\\n+  ++i;\n+/* This macro is for fields where just value passing should be checked.  */\n+#define B(n, x, v, w)\t\t\t\t\t\t\\\n+  s##n.x = v;\t\t\t\t\t\t\t\\\n+  a##n[2].x = w;\t\t\t\t\t\t\\\n+  ++j;\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+type S##n { fields } attrs;\t\t\t\t\t\\\n+type S##n s##n;\t\t\t\t\t\t\t\\\n+extern type S##n a##n[5];\t\t\t\t\t\\\n+extern type S##n check##n (type S##n, type S##n *,\t\t\\\n+\t\t\t     type S##n);\t\t\t\\\n+extern void check##n##va (int i, ...);\t\t\t\t\\\n+extern void checkx##n (type S##n);\t\t\t\t\\\n+void test##n (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  int i, j;\t\t\t\t\t\t\t\\\n+  memset (&s##n, '\\0', sizeof (s##n));\t\t\t\t\\\n+  memset (a##n, '\\0', sizeof (a##n));\t\t\t\t\\\n+  memset (&info, '\\0', sizeof (info));\t\t\t\t\\\n+  info.sp = &s##n;\t\t\t\t\t\t\\\n+  info.a0p = &a##n[0];\t\t\t\t\t\t\\\n+  info.a3p = &a##n[3];\t\t\t\t\t\t\\\n+  info.sz = sizeof (s##n);\t\t\t\t\t\\\n+  info.als = __alignof__ (s##n);\t\t\t\t\\\n+  info.ala0 = __alignof__ (a##n[0]);\t\t\t\t\\\n+  info.ala3 = __alignof__ (a##n[3]);\t\t\t\t\\\n+  if (((long) &a##n[3]) & (info.als - 1))\t\t\t\\\n+    FAIL (n, 1);\t\t\t\t\t\t\\\n+  i = 0; j = 0;\t\t\t\t\t\t\t\\\n+  ops\t\t\t\t\t\t\t\t\\\n+  info.nfields = i;\t\t\t\t\t\t\\\n+  info.nbitfields = j;\t\t\t\t\t\t\\\n+  checkx##n (check##n (s##n, &a##n[1], a##n[2]));\t\t\\\n+  check##n##va (1, 1.0, s##n, 2LL, a##n[2], a##n[2]);\t\t\\\n+  check##n##va (2, s##n, s##n, 2.0L, a##n[2], s##n);\t\t\\\n+}"}, {"sha": "907a2c9595583c8e95df052964c1cf2197c9b34f", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_x2.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_x2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_x2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_x2.h?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,14 @@\n+#undef F\n+#undef N\n+#undef B\n+#undef TX\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  if (arg.x != s##n.x) FAIL (n, 30);\n+#define N(n, x)\n+#define B(n, x, v, w)\t\t\t\t\t\t\\\n+  if (arg.x != s##n.x) FAIL (n, 30);\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+void checkx##n (type S##n arg)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  ops\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "9a5d2468a6ae78351505f97c1875c9839ff84430", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_y1.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_y1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_y1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_y1.h?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,76 @@\n+#include \"struct-layout-1.h\"\n+\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  if (info.flds[i] != &s##n.x)\t\t\t\t\t\\\n+    FAIL (n, 50);\t\t\t\t\t\t\\\n+  if (info.sizes[i] != sizeof (s##n.x))\t\t\t\t\\\n+    FAIL (n, 51);\t\t\t\t\t\t\\\n+  if (info.aligns[i] != __alignof__ (s##n.x))\t\t\t\\\n+    FAIL (n, 52);\t\t\t\t\t\t\\\n+  if (s##n.x != (__typeof__ (s##n.x)) v)\t\t\t\\\n+    FAIL (n, 53);\t\t\t\t\t\t\\\n+  if (a##n[2].x != (__typeof__ (s##n.x)) w)\t\t\t\\\n+    FAIL (n, 54);\t\t\t\t\t\t\\\n+  if (arg0.x != s##n.x)\t\t\t\t\t\t\\\n+    FAIL (n, 55);\t\t\t\t\t\t\\\n+  if (arg2.x != a##n[2].x)\t\t\t\t\t\\\n+    FAIL (n, 56);\t\t\t\t\t\t\\\n+  ret.x = s##n.x;\t\t\t\t\t\t\\\n+  ++i;\n+#define N(n, x) \t\t\t\t\t\t\\\n+  if (info.flds[i] != &s##n.x)\t\t\t\t\t\\\n+    FAIL (n, 50);\t\t\t\t\t\t\\\n+  if (info.sizes[i] != sizeof (s##n.x))\t\t\t\t\\\n+    FAIL (n, 51);\t\t\t\t\t\t\\\n+  if (info.aligns[i] != __alignof__ (s##n.x))\t\t\t\\\n+    FAIL (n, 52);\t\t\t\t\t\t\\\n+  ++i;\n+#define B(n, x, v, w) \t\t\t\t\t\t\\\n+  b1.x = v; b2.x = w;\t\t\t\t\t\t\\\n+  if (s##n.x != b1.x)\t\t\t\t\t\t\\\n+    FAIL (n, 53);\t\t\t\t\t\t\\\n+  if (a##n[2].x != b2.x)\t\t\t\t\t\\\n+    FAIL (n, 54);\t\t\t\t\t\t\\\n+  if (arg0.x != s##n.x)\t\t\t\t\t\t\\\n+    FAIL (n, 55);\t\t\t\t\t\t\\\n+  if (arg2.x != a##n[2].x)\t\t\t\t\t\\\n+    FAIL (n, 56);\t\t\t\t\t\t\\\n+  ret.x = s##n.x;\t\t\t\t\t\t\\\n+  ++j;\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+type S##n { fields } attrs;\t\t\t\t\t\\\n+extern type S##n s##n;\t\t\t\t\t\t\\\n+type S##n a##n[5];\t\t\t\t\t\t\\\n+type S##n\t\t\t\t\t\t\t\\\n+check##n (type S##n arg0, type S##n *arg1, type S##n arg2)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  type S##n ret;\t\t\t\t\t\t\\\n+  type S##n b1, b2;\t\t\t\t\t\t\\\n+  int i, j;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  memset (&ret, 0, sizeof (ret));\t\t\t\t\\\n+  memset (&b1, 0, sizeof (b1));\t\t\t\t\t\\\n+  memset (&b2, 0, sizeof (b2));\t\t\t\t\t\\\n+  if (info.sp != &s##n)\t\t\t\t\t\t\\\n+    FAIL (n, 10);\t\t\t\t\t\t\\\n+  if (info.a0p != &a##n[0])\t\t\t\t\t\\\n+    FAIL (n, 11);\t\t\t\t\t\t\\\n+  if (info.a3p != &a##n[3])\t\t\t\t\t\\\n+    FAIL (n, 12);\t\t\t\t\t\t\\\n+  if (info.sz != sizeof (s##n))\t\t\t\t\t\\\n+    FAIL (n, 13);\t\t\t\t\t\t\\\n+  if (info.als != __alignof__ (s##n))\t\t\t\t\\\n+    FAIL (n, 14);\t\t\t\t\t\t\\\n+  if (info.ala0 != __alignof__ (a##n[0]))\t\t\t\\\n+    FAIL (n, 15);\t\t\t\t\t\t\\\n+  if (info.ala3 != __alignof__ (a##n[3]))\t\t\t\\\n+    FAIL (n, 16);\t\t\t\t\t\t\\\n+  if (arg1 != &a##n[1])\t\t\t\t\t\t\\\n+    FAIL (n, 17);\t\t\t\t\t\t\\\n+  i = 0; j = 0;\t\t\t\t\t\t\t\\\n+  ops\t\t\t\t\t\t\t\t\\\n+  if (i != info.nfields || j != info.nbitfields)\t\t\\\n+    FAIL (n, 18);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  return ret;\t\t\t\t\t\t\t\\\n+}"}, {"sha": "02a341e1ccf2436055adde289c1bc945dc7e170a", "filename": "gcc/testsuite/g++.dg/compat/struct-layout-1_y2.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_y2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e729a3855f5e832c513a951e29ac6bbbb195e1e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_y2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcompat%2Fstruct-layout-1_y2.h?ref=e729a3855f5e832c513a951e29ac6bbbb195e1e2", "patch": "@@ -0,0 +1,69 @@\n+#undef F\n+#undef N\n+#undef B\n+#undef TX\n+\n+#ifdef SKIP_VA\n+const int test_va = 0;\n+#else\n+const int test_va = 1;\n+#endif\n+\n+#define F(n, x, v, w) \t\t\t\t\t\t\\\n+  if (p->x != arg.x) FAIL (n, 74);\n+#define N(n, x)\n+#define B(n, x, v, w) \t\t\t\t\t\t\\\n+  if (p->x != arg.x) FAIL (n, 74);\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+check##n##va (int z, ...)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  type S##n arg, *p;\t\t\t\t\t\t\\\n+  va_list ap;\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (test_va)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      va_start (ap, z);\t\t\t\t\t\t\\\n+      for (i = 0; i < 5; ++i)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  p = NULL;\t\t\t\t\t\t\\\n+\t  switch ((z << 4) | i)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t    case 0x10:\t\t\t\t\t\t\\\n+\t      if (va_arg (ap, double) != 1.0)\t\t\t\\\n+\t\tFAIL (n, 70);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x12:\t\t\t\t\t\t\\\n+\t      if (va_arg (ap, long long) != 2LL)\t\t\\\n+\t\tFAIL (n, 71);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x22:\t\t\t\t\t\t\\\n+\t      if (va_arg (ap, long double) != 2.0L)\t\t\\\n+\t\tFAIL (n, 72);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x11:\t\t\t\t\t\t\\\n+\t    case 0x20:\t\t\t\t\t\t\\\n+\t    case 0x21:\t\t\t\t\t\t\\\n+\t    case 0x24:\t\t\t\t\t\t\\\n+\t      p = &s##n;\t\t\t\t\t\\\n+\t      arg = va_arg (ap, type S##n);\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    case 0x13:\t\t\t\t\t\t\\\n+\t    case 0x14:\t\t\t\t\t\t\\\n+\t    case 0x23:\t\t\t\t\t\t\\\n+\t      p = &a##n[2];\t\t\t\t\t\\\n+\t      arg = va_arg (ap, type S##n);\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\t\\\n+\t      FAIL (n, 73);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  if (p)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      ops\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      va_end (ap);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}"}]}