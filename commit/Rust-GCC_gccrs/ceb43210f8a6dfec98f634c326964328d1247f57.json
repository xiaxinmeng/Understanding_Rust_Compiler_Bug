{"sha": "ceb43210f8a6dfec98f634c326964328d1247f57", "node_id": "C_kwDOANBUbNoAKGNlYjQzMjEwZjhhNmRmZWM5OGY2MzRjMzI2OTY0MzI4ZDEyNDdmNTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-08-31T13:21:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T13:21:19Z"}, "message": "Merge #1505\n\n1505: Create canonical process of compiling constant items r=philberty a=philberty\n\nIn order to compile a block expression constant, the simplest way for us\r\nwas to reuse what code we have and to generate an artifical function which\r\ndoes not get added to the translation unit. The constant then becomes\r\na CALL_EXPR to this artifical function which we can pass to the constexpr\r\nevaluator to resolve the result of this artifical 'CALL_EXPR'.\r\n\r\nBefore this patch we seperated the difference between block expressions\r\nand non block expressions in constants. So for non block expressions we\r\nsimply compiled them as if it was a simple constant but this is not\r\nguaranteed to be the case in rust, for example coercion sites can generate\r\ntemporaries during autoderef which we let the constant evaluator resolve\r\nfor us. This makes all constants handled in the same way to simplify the\r\nlogic here.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "5efa5f7aa3960f67a1ecde67febf9a99760f7a18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5efa5f7aa3960f67a1ecde67febf9a99760f7a18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceb43210f8a6dfec98f634c326964328d1247f57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjD2BPCRBK7hj4Ov3rIwAAVv8IADH5EDRMnxYBZadb2vT7CL9S\nOzlzOyHrLTtxXZrFbyojbGmw49Ur0LxEyRCYXIFa5XoT6WRiNNseAhDRkPv9aH7J\niVw/3rGBGpvb374Z4zBoGCJqduswxvL4C6M9bA6/mRQl2sOdrHEQqTHgmILQYYEc\nanL+SXDpxunRLdrryW3kC2OK9R9RaiaQjxQBcHroVzcllGbpFN65Nv2XSV1nSInB\n3AO/eRp4eFjyb+1+T65sgiaYOxD/dLUnTeiZPqRFrD60Fjfc9ukk/oZOOZp0L0hT\n+xlqCRilMblwNJbbvIKCyrQImqvvHyyfl9ZJeeYOG8CdCyUoPwz1cZSiEtnAyZo=\n=C5Sv\n-----END PGP SIGNATURE-----\n", "payload": "tree 5efa5f7aa3960f67a1ecde67febf9a99760f7a18\nparent 9b210f1c544ce4b0a4ff330c1e93d3ee83785484\nparent 5acb1375c9c57b4cc0af13f4ccea0d609942bc0a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1661952079 +0000\ncommitter GitHub <noreply@github.com> 1661952079 +0000\n\nMerge #1505\n\n1505: Create canonical process of compiling constant items r=philberty a=philberty\n\nIn order to compile a block expression constant, the simplest way for us\r\nwas to reuse what code we have and to generate an artifical function which\r\ndoes not get added to the translation unit. The constant then becomes\r\na CALL_EXPR to this artifical function which we can pass to the constexpr\r\nevaluator to resolve the result of this artifical 'CALL_EXPR'.\r\n\r\nBefore this patch we seperated the difference between block expressions\r\nand non block expressions in constants. So for non block expressions we\r\nsimply compiled them as if it was a simple constant but this is not\r\nguaranteed to be the case in rust, for example coercion sites can generate\r\ntemporaries during autoderef which we let the constant evaluator resolve\r\nfor us. This makes all constants handled in the same way to simplify the\r\nlogic here.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb43210f8a6dfec98f634c326964328d1247f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceb43210f8a6dfec98f634c326964328d1247f57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb43210f8a6dfec98f634c326964328d1247f57/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b210f1c544ce4b0a4ff330c1e93d3ee83785484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b210f1c544ce4b0a4ff330c1e93d3ee83785484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b210f1c544ce4b0a4ff330c1e93d3ee83785484"}, {"sha": "5acb1375c9c57b4cc0af13f4ccea0d609942bc0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acb1375c9c57b4cc0af13f4ccea0d609942bc0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5acb1375c9c57b4cc0af13f4ccea0d609942bc0a"}], "stats": {"total": 125, "additions": 56, "deletions": 69}, "files": [{"sha": "a5643d2f625d05c95305a74c305f7527e98c404b", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb43210f8a6dfec98f634c326964328d1247f57/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb43210f8a6dfec98f634c326964328d1247f57/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=ceb43210f8a6dfec98f634c326964328d1247f57", "patch": "@@ -652,65 +652,72 @@ HIRCompileBase::compile_constant_item (\n   bool is_block_expr\n     = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n \n-  // compile the expression\n-  tree folded_expr = error_mark_node;\n-  if (!is_block_expr)\n-    {\n-      tree value = CompileExpr::Compile (const_value_expr, ctx);\n-      folded_expr = fold_expr (value);\n-    }\n-  else\n-    {\n-      // in order to compile a block expr we want to reuse as much existing\n-      // machineary that we already have. This means the best approach is to\n-      // make a _fake_ function with a block so it can hold onto temps then\n-      // use our constexpr code to fold it completely or error_mark_node\n-      Backend::typed_identifier receiver;\n-      tree compiled_fn_type = ctx->get_backend ()->function_type (\n-\treceiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)},\n-\tNULL, locus);\n-\n-      tree fndecl\n-\t= ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n-      TREE_READONLY (fndecl) = 1;\n+  // in order to compile a block expr we want to reuse as much existing\n+  // machineary that we already have. This means the best approach is to\n+  // make a _fake_ function with a block so it can hold onto temps then\n+  // use our constexpr code to fold it completely or error_mark_node\n+  Backend::typed_identifier receiver;\n+  tree compiled_fn_type = ctx->get_backend ()->function_type (\n+    receiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)}, NULL,\n+    locus);\n+\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n+  TREE_READONLY (fndecl) = 1;\n+\n+  tree enclosing_scope = NULL_TREE;\n \n-      tree enclosing_scope = NULL_TREE;\n+  Location start_location = const_value_expr->get_locus ();\n+  Location end_location = const_value_expr->get_locus ();\n+  if (is_block_expr)\n+    {\n       HIR::BlockExpr *function_body\n \t= static_cast<HIR::BlockExpr *> (const_value_expr);\n-      Location start_location = function_body->get_locus ();\n-      Location end_location = function_body->get_end_locus ();\n+      start_location = function_body->get_locus ();\n+      end_location = function_body->get_end_locus ();\n+    }\n \n-      tree code_block\n-\t= ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t      start_location, end_location);\n-      ctx->push_block (code_block);\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n \n-      bool address_is_taken = false;\n-      tree ret_var_stmt = NULL_TREE;\n-      Bvariable *return_address\n-\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n-\t\t\t\t\t\t   const_type, NULL,\n-\t\t\t\t\t\t   address_is_taken, locus,\n-\t\t\t\t\t\t   &ret_var_stmt);\n+  bool address_is_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n+  Bvariable *return_address\n+    = ctx->get_backend ()->temporary_variable (fndecl, code_block, const_type,\n+\t\t\t\t\t       NULL, address_is_taken, locus,\n+\t\t\t\t\t       &ret_var_stmt);\n \n-      ctx->add_statement (ret_var_stmt);\n-      ctx->push_fn (fndecl, return_address);\n+  ctx->add_statement (ret_var_stmt);\n+  ctx->push_fn (fndecl, return_address);\n \n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *function_body\n+\t= static_cast<HIR::BlockExpr *> (const_value_expr);\n       compile_function_body (ctx, fndecl, *function_body, true);\n-      tree bind_tree = ctx->pop_block ();\n+    }\n+  else\n+    {\n+      tree value = CompileExpr::Compile (const_value_expr, ctx);\n+      tree return_expr = ctx->get_backend ()->return_statement (\n+\tfndecl, {value}, const_value_expr->get_locus ());\n+      ctx->add_statement (return_expr);\n+    }\n \n-      gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-      DECL_SAVED_TREE (fndecl) = bind_tree;\n-      DECL_DECLARED_CONSTEXPR_P (fndecl) = 1;\n-      maybe_save_constexpr_fundef (fndecl);\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+  DECL_DECLARED_CONSTEXPR_P (fndecl) = 1;\n+  maybe_save_constexpr_fundef (fndecl);\n \n-      ctx->pop_fn ();\n+  ctx->pop_fn ();\n \n-      // lets fold it into a call expr\n-      tree call = build_call_array_loc (locus.gcc_location (), const_type,\n-\t\t\t\t\tfndecl, 0, NULL);\n-      folded_expr = fold_expr (call);\n-    }\n+  // lets fold it into a call expr\n+  tree call\n+    = build_call_array_loc (locus.gcc_location (), const_type, fndecl, 0, NULL);\n+  tree folded_expr = fold_expr (call);\n \n   return named_constant_expression (const_type, ident, folded_expr, locus);\n }"}, {"sha": "f5878356841fa7154991c77a3d1a1d200a821bc4", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb43210f8a6dfec98f634c326964328d1247f57/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb43210f8a6dfec98f634c326964328d1247f57/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=ceb43210f8a6dfec98f634c326964328d1247f57", "patch": "@@ -2916,27 +2916,7 @@ comptypes (tree t1, tree t2, int strict)\n \t   perform a deep check. */\n \treturn structural_comptypes (t1, t2, strict);\n \n-      if (flag_checking && param_use_canonical_types)\n-\t{\n-\t  bool result = structural_comptypes (t1, t2, strict);\n-\n-\t  if (result && TYPE_CANONICAL (t1) != TYPE_CANONICAL (t2))\n-\t    /* The two types are structurally equivalent, but their\n-\t       canonical types were different. This is a failure of the\n-\t       canonical type propagation code.*/\n-\t    internal_error (\n-\t      \"canonical types differ for identical types %qT and %qT\", t1, t2);\n-\t  else if (!result && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-\t    /* Two types are structurally different, but the canonical\n-\t       types are the same. This means we were over-eager in\n-\t       assigning canonical types. */\n-\t    internal_error (\n-\t      \"same canonical type node for different types %qT and %qT\", t1,\n-\t      t2);\n-\n-\t  return result;\n-\t}\n-      if (!flag_checking && param_use_canonical_types)\n+      if (!flag_checking)\n \treturn TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n       else\n \treturn structural_comptypes (t1, t2, strict);"}]}