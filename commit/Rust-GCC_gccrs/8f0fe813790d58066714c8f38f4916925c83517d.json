{"sha": "8f0fe813790d58066714c8f38f4916925c83517d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYwZmU4MTM3OTBkNTgwNjY3MTRjOGYzOGY0OTE2OTI1YzgzNTE3ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2010-08-20T12:22:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2010-08-20T12:22:11Z"}, "message": "gimplify.c (gimplify_modify_expr): When assigning to volatiles, copy the src value and return a copy.\n\n\tgcc/\n\t* gimplify.c (gimplify_modify_expr): When assigning to volatiles,\n\tcopy the src value and return a copy.\n\t* doc/extend.texi (Volatiles): Move from C++ to C and expand.\n\t(C++ Volatiles): Adjust to describe C++ semantics only.\n\n\tgcc/testsuite/\n\t* gcc.target/i386/volatile-2.c: New.\n\nFrom-SVN: r163400", "tree": {"sha": "8203f44d134cc7bbd49bc190100542d7b66cfda0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8203f44d134cc7bbd49bc190100542d7b66cfda0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f0fe813790d58066714c8f38f4916925c83517d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0fe813790d58066714c8f38f4916925c83517d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f0fe813790d58066714c8f38f4916925c83517d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0fe813790d58066714c8f38f4916925c83517d/comments", "author": null, "committer": null, "parents": [{"sha": "f8fe0a4a8e1df13c21dd0f394740582a4d264f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fe0a4a8e1df13c21dd0f394740582a4d264f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8fe0a4a8e1df13c21dd0f394740582a4d264f03"}], "stats": {"total": 252, "additions": 218, "deletions": 34}, "files": [{"sha": "a12d21b8e8c4eebd236638adedfd93793092b19c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 118, "deletions": 33, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8f0fe813790d58066714c8f38f4916925c83517d", "patch": "@@ -66,6 +66,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Type Attributes::     Specifying attributes of types.\n * Alignment::           Inquiring about the alignment of a type or variable.\n * Inline::              Defining inline functions (as fast as macros).\n+* Volatiles::           What constitutes an access to a volatile object.\n * Extended Asm::        Assembler instructions with C expressions as operands.\n                         (With them you can define ``built-in'' functions.)\n * Constraints::         Constraints for asm operands\n@@ -5052,6 +5053,88 @@ The definition in the header file will cause most calls to the function\n to be inlined.  If any uses of the function remain, they will refer to\n the single copy in the library.\n \n+@node Volatiles\n+@section When is a Volatile Object Accessed?\n+@cindex accessing volatiles\n+@cindex volatile read\n+@cindex volatile write\n+@cindex volatile access\n+\n+C has the concept of volatile objects.  These are normally accessed by\n+pointers and used for accessing hardware or inter-thread\n+communication.  The standard encourage compilers to refrain from\n+optimizations concerning accesses to volatile objects, but leaves it\n+implementation defined as to what constitutes a volatile access.  The\n+minimum requirement is that at a sequence point all previous accesses\n+to volatile objects have stabilized and no subsequent accesses have\n+occurred.  Thus an implementation is free to reorder and combine\n+volatile accesses which occur between sequence points, but cannot do\n+so for accesses across a sequence point.  The use of volatiles does\n+not allow you to violate the restriction on updating objects multiple\n+times between two sequence points.\n+\n+Accesses to non-volatile objects are not ordered with respect to\n+volatile accesses.  You cannot use a volatile object as a memory\n+barrier to order a sequence of writes to non-volatile memory.  For\n+instance:\n+\n+@smallexample\n+int *ptr = @var{something};\n+volatile int vobj;\n+*ptr = @var{something};\n+vobj = 1;\n+@end smallexample\n+\n+Unless @var{*ptr} and @var{vobj} can be aliased, it is not guaranteed\n+that the write to @var{*ptr} will have occurred by the time the update\n+of @var{vobj} has happened.  If you need this guarantee, you must use\n+a stronger memory barrier such as:\n+\n+@smallexample\n+int *ptr = @var{something};\n+volatile int vobj;\n+*ptr = @var{something};\n+asm volatile (\"\" : : : \"memory\");\n+vobj = 1;\n+@end smallexample\n+\n+A scalar volatile object is read, when it is accessed in a void context:\n+\n+@smallexample\n+volatile int *src = @var{somevalue};\n+*src;\n+@end smallexample\n+\n+Such expressions are rvalues, and GCC implements this as a\n+read of the volatile object being pointed to.\n+\n+Assignments are also expressions and have an rvalue.  However when\n+assigning to a scalar volatile, the volatile object is not reread,\n+regardless of whether the assignment expression's rvalue is used or\n+not.  If the assignment's rvalue is used, the value is that assigned\n+to the volatile object.  For instance, there is no read of @var{vobj}\n+in all the following cases:\n+\n+@smallexample\n+int obj;\n+volatile int vobj;\n+vobj = @var{something};\n+obj = vobj = @var{something};\n+obj ? vobj = @var{onething} : vobj = @var{anotherthing};\n+obj = (@var{something}, vobj = @var{anotherthing});\n+@end smallexample\n+\n+If you need to read the volatile object after an assignment has\n+occurred, you must use a separate expression with an intervening\n+sequence point.\n+\n+As bitfields are not individually addressable, volatile bitfields may\n+be implicitly read when written to, or when adjacent bitfields are\n+accessed.  Bitfield operations may be optimized such that adjacent\n+bitfields are only partially accessed, if they straddle a storage unit\n+boundary.  For these reasons it is unwise to use volatile bitfields to\n+access hardware.\n+\n @node Extended Asm\n @section Assembler Instructions with C Expression Operands\n @cindex extended @code{asm}\n@@ -13152,7 +13235,7 @@ test specifically for GNU C++ (@pxref{Common Predefined Macros,,\n Predefined Macros,cpp,The GNU C Preprocessor}).\n \n @menu\n-* Volatiles::           What constitutes an access to a volatile object.\n+* C++ Volatiles::       What constitutes an access to a volatile object.\n * Restricted Pointers:: C99 restricted pointers and references.\n * Vague Linkage::       Where G++ puts inlines, vtables and such.\n * C++ Interface::       You can use a single C++ header file for both\n@@ -13169,50 +13252,40 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n * Backwards Compatibility:: Compatibilities with earlier definitions of C++.\n @end menu\n \n-@node Volatiles\n-@section When is a Volatile Object Accessed?\n+@node C++ Volatiles\n+@section When is a Volatile C++ Object Accessed?\n @cindex accessing volatiles\n @cindex volatile read\n @cindex volatile write\n @cindex volatile access\n \n-Both the C and C++ standard have the concept of volatile objects.  These\n-are normally accessed by pointers and used for accessing hardware.  The\n-standards encourage compilers to refrain from optimizations concerning\n-accesses to volatile objects.  The C standard leaves it implementation\n-defined  as to what constitutes a volatile access.  The C++ standard omits\n-to specify this, except to say that C++ should behave in a similar manner\n-to C with respect to volatiles, where possible.  The minimum either\n-standard specifies is that at a sequence point all previous accesses to\n-volatile objects have stabilized and no subsequent accesses have\n-occurred.  Thus an implementation is free to reorder and combine\n-volatile accesses which occur between sequence points, but cannot do so\n-for accesses across a sequence point.  The use of volatiles does not\n-allow you to violate the restriction on updating objects multiple times\n-within a sequence point.\n-\n-@xref{Qualifiers implementation, , Volatile qualifier and the C compiler}.\n+The C++ standard differs from the C standard in its treatment of\n+volatile objects.  It fails to specify what constitutes a volatile\n+access, except to say that C++ should behave in a similar manner to C\n+with respect to volatiles, where possible.  However, the different\n+lvalueness of expressions between C and C++ complicate the behaviour.\n+G++ behaves the same as GCC for volatile access, @xref{C\n+Extensions,,Volatiles}, for a description of GCC's behaviour.\n \n-The behavior differs slightly between C and C++ in the non-obvious cases:\n+The C and C++ language specifications differ when an object is\n+accessed in a void context:\n \n @smallexample\n volatile int *src = @var{somevalue};\n *src;\n @end smallexample\n \n-With C, such expressions are rvalues, and GCC interprets this either as a\n-read of the volatile object being pointed to or only as request to evaluate\n-the side-effects.  The C++ standard specifies that such expressions do not\n-undergo lvalue to rvalue conversion, and that the type of the dereferenced\n-object may be incomplete.  The C++ standard does not specify explicitly\n-that it is this lvalue to rvalue conversion which may be responsible for\n-causing an access.  However, there is reason to believe that it is,\n-because otherwise certain simple expressions become undefined.  However,\n-because it would surprise most programmers, G++ treats dereferencing a\n-pointer to volatile object of complete type when the value is unused as\n-GCC would do for an equivalent type in C@.  When the object has incomplete\n-type, G++ issues a warning; if you wish to force an error, you must\n-force a conversion to rvalue with, for instance, a static cast.\n+The C++ standard specifies that such expressions do not undergo lvalue\n+to rvalue conversion, and that the type of the dereferenced object may\n+be incomplete.  The C++ standard does not specify explicitly that it\n+is lvalue to rvalue conversion which is responsible for causing an\n+access.  There is reason to believe that it is, because otherwise\n+certain simple expressions become undefined.  However, because it\n+would surprise most programmers, G++ treats dereferencing a pointer to\n+volatile object of complete type as GCC would do for an equivalent\n+type in C@.  When the object has incomplete type, G++ issues a\n+warning; if you wish to force an error, you must force a conversion to\n+rvalue with, for instance, a static cast.\n \n When using a reference to volatile, G++ does not treat equivalent\n expressions as accesses to volatiles, but instead issues a warning that\n@@ -13222,6 +13295,18 @@ possible to ignore the return value from functions returning volatile\n references.  Again, if you wish to force a read, cast the reference to\n an rvalue.\n \n+G++ implements the same behaviour as GCC does when assigning to a\n+volatile object -- there is no reread of the assigned-to object, the\n+assigned rvalue is reused.  Note that in C++ assignment expressions\n+are lvalues, and if used as an lvalue, the volatile object will be\n+referred to.  For instance, @var{vref} will refer to @var{vobj}, as\n+expected, in the following example:\n+\n+@smallexample\n+volatile int vobj;\n+volatile int &vref = vobj = @var{something};\n+@end smallexample\n+\n @node Restricted Pointers\n @section Restricting Pointer Aliasing\n @cindex restricted pointers"}, {"sha": "6b654be9c11ddd81ae1be96278d221c815a96068", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8f0fe813790d58066714c8f38f4916925c83517d", "patch": "@@ -4576,6 +4576,9 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       SET_DECL_DEBUG_EXPR (*from_p, *to_p);\n    }\n \n+  if (want_value && TREE_THIS_VOLATILE (*to_p))\n+    *from_p = get_initialized_tmp_var (*from_p, pre_p, post_p);\n+\n   if (TREE_CODE (*from_p) == CALL_EXPR)\n     {\n       /* Since the RHS is a CALL_EXPR, we need to create a GIMPLE_CALL\n@@ -4603,7 +4606,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n   if (want_value)\n     {\n-      *expr_p = unshare_expr (*to_p);\n+      *expr_p = TREE_THIS_VOLATILE (*to_p) ? *from_p : unshare_expr (*to_p);\n       return GS_OK;\n     }\n   else"}, {"sha": "7d15024c0ade42bfee37fb910280da2117b4edcd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f0fe813790d58066714c8f38f4916925c83517d", "patch": "@@ -1,3 +1,7 @@\n+2010-08-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcc.target/i386/volatile-2.c: New.\n+\n 2010-08-19  Andrey Belevantsev  <abel@ispras.ru>\n \n \tPR rtl-optimization/44691"}, {"sha": "3f4d42547231a5214a15835051e74919c83ef018", "filename": "gcc/testsuite/gcc.target/i386/volatile-2.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0fe813790d58066714c8f38f4916925c83517d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-2.c?ref=8f0fe813790d58066714c8f38f4916925c83517d", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+/* Check volatiles are written, read or not re-read consistently */\n+\n+\n+/* simple assignments */\n+\n+extern int volatile obj_0;\n+void test_0 (int data)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_0\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_0,\" } } */\n+  obj_0 = data;\n+}\n+\n+extern int volatile obj_1;\n+int test_1 (int data)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_1\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_1,\" } } */\n+  return obj_1 = data;\n+}\n+\n+extern int volatile obj_2;\n+int test_2 (void)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_2\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_2,\" } } */\n+  return obj_2 = 0;\n+}\n+\n+\n+/* Assignments in compound exprs */\n+\n+extern int volatile obj_3;\n+int test_3 (int data)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_3\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_3,\" } } */\n+  return (obj_3 = data, 0);\n+}\n+\n+extern int volatile obj_4;\n+int test_4 (void)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_4\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_4,\" } } */\n+  return (obj_4 = 0, 0);\n+}\n+extern int volatile obj_5;\n+int test_5 (void)\n+{\n+  /* should reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_5\" } } */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]obj_5,\" } } */\n+  return (obj_5 = 0, obj_5);\n+}\n+\n+/* Assignments in conditional exprs */\n+\n+extern int volatile obj_6;\n+void test_6 (int data, int cond)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_6\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_6,\" } } */\n+  cond ? obj_6 = data : 0;\n+}\n+\n+extern int volatile obj_7;\n+int test_7 (int data, int cond)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_7\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_7,\" } } */\n+  return cond ? obj_7 = data : 0;\n+}\n+\n+extern int volatile obj_8;\n+int test_8 (int cond)\n+{\n+  /* should not reread obj */\n+  /* { dg-final { scan-assembler \"movl\\[ \\t\\]\\[^,\\]+, obj_8\" } } */\n+  /* { dg-final { scan-assembler-not \"movl\\[ \\t\\]obj_8,\" } } */\n+  return cond ? obj_8 = 0 : 0;\n+}"}]}