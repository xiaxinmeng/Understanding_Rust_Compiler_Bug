{"sha": "0889c52f15b21171977ad329ea8e6a096c1af827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg4OWM1MmYxNWIyMTE3MTk3N2FkMzI5ZWE4ZTZhMDk2YzFhZjgyNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-22T13:16:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-22T13:16:50Z"}, "message": "genmatch.c (struct operand): Add location member.\n\n2015-07-22  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (struct operand): Add location member.\n\t(predicate, expr, c_expr, capture, if_expr, with_expr): Adjust\n\tconstructors.\n\t(struct simplify): Remove match_location and result_location\n\tmembers.\n\t(elsehwere): Adjust.\n\nFrom-SVN: r226067", "tree": {"sha": "804a9a2689fb9bc2691592908a8de46726083ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/804a9a2689fb9bc2691592908a8de46726083ae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0889c52f15b21171977ad329ea8e6a096c1af827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0889c52f15b21171977ad329ea8e6a096c1af827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0889c52f15b21171977ad329ea8e6a096c1af827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0889c52f15b21171977ad329ea8e6a096c1af827/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6dd74463ea50706652a42ac993ac3a2e22b86b58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd74463ea50706652a42ac993ac3a2e22b86b58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd74463ea50706652a42ac993ac3a2e22b86b58"}], "stats": {"total": 148, "additions": 76, "deletions": 72}, "files": [{"sha": "e1e93ad9a27dcf52daee586e26457a2cbdd22b4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0889c52f15b21171977ad329ea8e6a096c1af827/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0889c52f15b21171977ad329ea8e6a096c1af827/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0889c52f15b21171977ad329ea8e6a096c1af827", "patch": "@@ -1,3 +1,12 @@\n+2015-07-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (struct operand): Add location member.\n+\t(predicate, expr, c_expr, capture, if_expr, with_expr): Adjust\n+\tconstructors.\n+\t(struct simplify): Remove match_location and result_location\n+\tmembers.\n+\t(elsehwere): Adjust.\n+\n 2015-07-22  Prachi Godbole  <prachi.godbole@imgtec.com>\n \n \t* config/mips/m5100.md: New file."}, {"sha": "169541767d13ffbad54286f656aae691b0ff118d", "filename": "gcc/genmatch.c", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0889c52f15b21171977ad329ea8e6a096c1af827/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0889c52f15b21171977ad329ea8e6a096c1af827/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=0889c52f15b21171977ad329ea8e6a096c1af827", "patch": "@@ -483,8 +483,10 @@ struct capture_info;\n \n struct operand {\n   enum op_type { OP_PREDICATE, OP_EXPR, OP_CAPTURE, OP_C_EXPR, OP_IF, OP_WITH };\n-  operand (enum op_type type_) : type (type_) {}\n+  operand (enum op_type type_, source_location loc_)\n+    : type (type_), location (loc_) {}\n   enum op_type type;\n+  source_location location;\n   virtual void gen_transform (FILE *, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0,\n@@ -496,7 +498,8 @@ struct operand {\n \n struct predicate : public operand\n {\n-  predicate (predicate_id *p_) : operand (OP_PREDICATE), p (p_) {}\n+  predicate (predicate_id *p_, source_location loc)\n+    : operand (OP_PREDICATE, loc), p (p_) {}\n   predicate_id *p;\n };\n \n@@ -505,12 +508,12 @@ struct predicate : public operand\n \n struct expr : public operand\n {\n-  expr (id_base *operation_, bool is_commutative_ = false)\n-    : operand (OP_EXPR), operation (operation_),\n+  expr (id_base *operation_, source_location loc, bool is_commutative_ = false)\n+    : operand (OP_EXPR, loc), operation (operation_),\n       ops (vNULL), expr_type (NULL), is_commutative (is_commutative_),\n       is_generic (false), force_single_use (false) {}\n   expr (expr *e)\n-    : operand (OP_EXPR), operation (e->operation),\n+    : operand (OP_EXPR, e->location), operation (e->operation),\n       ops (vNULL), expr_type (e->expr_type), is_commutative (e->is_commutative),\n       is_generic (e->is_generic), force_single_use (e->force_single_use) {}\n   void append_op (operand *op) { ops.safe_push (op); }\n@@ -546,10 +549,11 @@ struct c_expr : public operand\n     id_tab (const char *id_, const char *oper_): id (id_), oper (oper_) {}\n   };\n \n-  c_expr (cpp_reader *r_, vec<cpp_token> code_, unsigned nr_stmts_,\n+  c_expr (cpp_reader *r_, source_location loc,\n+\t  vec<cpp_token> code_, unsigned nr_stmts_,\n \t  vec<id_tab> ids_, cid_map_t *capture_ids_)\n-    : operand (OP_C_EXPR), r (r_), code (code_), capture_ids (capture_ids_),\n-      nr_stmts (nr_stmts_), ids (ids_) {}\n+    : operand (OP_C_EXPR, loc), r (r_), code (code_),\n+      capture_ids (capture_ids_), nr_stmts (nr_stmts_), ids (ids_) {}\n   /* cpplib tokens and state to transform this back to source.  */\n   cpp_reader *r;\n   vec<cpp_token> code;\n@@ -567,8 +571,8 @@ struct c_expr : public operand\n \n struct capture : public operand\n {\n-  capture (unsigned where_, operand *what_)\n-      : operand (OP_CAPTURE), where (where_), what (what_) {}\n+  capture (source_location loc, unsigned where_, operand *what_)\n+      : operand (OP_CAPTURE, loc), where (where_), what (what_) {}\n   /* Identifier index for the value.  */\n   unsigned where;\n   /* The captured value.  */\n@@ -582,8 +586,8 @@ struct capture : public operand\n \n struct if_expr : public operand\n {\n-  if_expr () : operand (OP_IF), cond (NULL), trueexpr (NULL),\n-    falseexpr (NULL) {}\n+  if_expr (source_location loc)\n+    : operand (OP_IF, loc), cond (NULL), trueexpr (NULL), falseexpr (NULL) {}\n   c_expr *cond;\n   operand *trueexpr;\n   operand *falseexpr;\n@@ -593,7 +597,8 @@ struct if_expr : public operand\n \n struct with_expr : public operand\n {\n-  with_expr () : operand (OP_WITH), with (NULL), subexpr (NULL) {}\n+  with_expr (source_location loc)\n+    : operand (OP_WITH, loc), with (NULL), subexpr (NULL) {}\n   c_expr *with;\n   operand *subexpr;\n };\n@@ -655,25 +660,20 @@ struct simplify\n {\n   enum simplify_kind { SIMPLIFY, MATCH };\n \n-  simplify (simplify_kind kind_,\n-\t    operand *match_, source_location match_location_,\n-\t    struct operand *result_, source_location result_location_,\n+  simplify (simplify_kind kind_, operand *match_, operand *result_,\n \t    vec<vec<user_id *> > for_vec_, cid_map_t *capture_ids_)\n-      : kind (kind_), match (match_), match_location (match_location_),\n-      result (result_), result_location (result_location_),\n+      : kind (kind_), match (match_), result (result_),\n       for_vec (for_vec_),\n       capture_ids (capture_ids_), capture_max (capture_ids_->elements () - 1) {}\n \n   simplify_kind kind;\n   /* The expression that is matched against the GENERIC or GIMPLE IL.  */\n   operand *match;\n-  source_location match_location;\n   /* For a (simplify ...) an expression with ifs and withs with the expression\n      produced when the pattern applies in the leafs.\n      For a (match ...) the leafs are either empty if it is a simple predicate\n      or the single expression specifying the matched operands.  */\n   struct operand *result;\n-  source_location result_location;\n   /* Collected 'for' expression operators that have to be replaced\n      in the lowering phase.  */\n   vec<vec<user_id *> > for_vec;\n@@ -772,7 +772,7 @@ commutate (operand *op)\n       vec<operand *> v = commutate (c->what);\n       for (unsigned i = 0; i < v.length (); ++i)\n \t{\n-\t  capture *nc = new capture (c->where, v[i]);\n+\t  capture *nc = new capture (c->location, c->where, v[i]);\n \t  ret.safe_push (nc);\n \t}\n       return ret;\n@@ -829,8 +829,7 @@ lower_commutative (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = commutate (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (s->kind, matchers[i], s->match_location,\n-\t\t\t\t   s->result, s->result_location,\n+      simplify *ns = new simplify (s->kind, matchers[i], s->result,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -846,7 +845,7 @@ lower_opt_convert (operand *o, enum tree_code oper,\n   if (capture *c = dyn_cast<capture *> (o))\n     {\n       if (c->what)\n-\treturn new capture (c->where,\n+\treturn new capture (c->location, c->where,\n \t\t\t    lower_opt_convert (c->what, oper, to_oper, strip));\n       else\n \treturn c;\n@@ -958,8 +957,7 @@ lower_opt_convert (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = lower_opt_convert (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (s->kind, matchers[i], s->match_location,\n-\t\t\t\t   s->result, s->result_location,\n+      simplify *ns = new simplify (s->kind, matchers[i], s->result,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -981,7 +979,7 @@ lower_cond (operand *o)\n \t  lop = lower_cond (c->what);\n \n \t  for (unsigned i = 0; i < lop.length (); ++i)\n-\t    ro.safe_push (new capture (c->where, lop[i]));\n+\t    ro.safe_push (new capture (c->location, c->where, lop[i]));\n \t  return ro;\n \t}\n     }\n@@ -1031,7 +1029,7 @@ lower_cond (operand *o)\n \t      for (unsigned j = 0; j < ocmp->ops.length (); ++j)\n \t\tcmp->append_op (ocmp->ops[j]);\n \t      cmp->is_generic = true;\n-\t      ne->ops[0] = new capture (c->where, cmp);\n+\t      ne->ops[0] = new capture (c->location, c->where, cmp);\n \t    }\n \t  else\n \t    {\n@@ -1058,8 +1056,7 @@ lower_cond (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = lower_cond (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (s->kind, matchers[i], s->match_location,\n-\t\t\t\t   s->result, s->result_location,\n+      simplify *ns = new simplify (s->kind, matchers[i], s->result,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -1076,7 +1073,8 @@ replace_id (operand *o, user_id *id, id_base *with)\n     {\n       if (!c->what)\n \treturn c;\n-      return new capture (c->where, replace_id (c->what, id, with));\n+      return new capture (c->location, c->where,\n+\t\t\t  replace_id (c->what, id, with));\n     }\n   else if (expr *e = dyn_cast<expr *> (o))\n     {\n@@ -1089,14 +1087,14 @@ replace_id (operand *o, user_id *id, id_base *with)\n     }\n   else if (with_expr *w = dyn_cast <with_expr *> (o))\n     {\n-      with_expr *nw = new with_expr ();\n+      with_expr *nw = new with_expr (w->location);\n       nw->with = as_a <c_expr *> (replace_id (w->with, id, with));\n       nw->subexpr = replace_id (w->subexpr, id, with);\n       return nw;\n     }\n   else if (if_expr *ife = dyn_cast <if_expr *> (o))\n     {\n-      if_expr *nife = new if_expr ();\n+      if_expr *nife = new if_expr (ife->location);\n       nife->cond = as_a <c_expr *> (replace_id (ife->cond, id, with));\n       nife->trueexpr = replace_id (ife->trueexpr, id, with);\n       if (ife->falseexpr)\n@@ -1110,7 +1108,8 @@ replace_id (operand *o, user_id *id, id_base *with)\n     {\n       vec<c_expr::id_tab> ids = ce->ids.copy ();\n       ids.safe_push (c_expr::id_tab (id->id, with->id));\n-      return new c_expr (ce->r, ce->code, ce->nr_stmts, ids, ce->capture_ids);\n+      return new c_expr (ce->r, ce->location,\n+\t\t\t ce->code, ce->nr_stmts, ids, ce->capture_ids);\n     }\n \n   return o;\n@@ -1155,8 +1154,7 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t\t  if (result_op)\n \t\t    result_op = replace_id (result_op, id, oper);\n \t\t}\n-\t      simplify *ns = new simplify (s->kind, match_op, s->match_location,\n-\t\t\t\t\t   result_op, s->result_location,\n+\t      simplify *ns = new simplify (s->kind, match_op, result_op,\n \t\t\t\t\t   vNULL, s->capture_ids);\n \t      worklist.safe_push (ns);\n \t    }\n@@ -2582,7 +2580,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t{\n \t  fprintf_indent (f, indent, \"{\\n\");\n \t  indent += 4;\n-\t  output_line_directive (f, w->with->code[0].src_loc);\n+\t  output_line_directive (f, w->location);\n \t  w->with->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n \t  gen_1 (f, indent, gimple, w->subexpr);\n \t  indent -= 4;\n@@ -2591,7 +2589,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t}\n       else if (if_expr *ife = dyn_cast <if_expr *> (result))\n \t{\n-\t  output_line_directive (f, ife->cond->code[0].src_loc);\n+\t  output_line_directive (f, ife->location);\n \t  fprintf_indent (f, indent, \"if (\");\n \t  ife->cond->gen_transform (f, indent, NULL, true, 1, \"type\", NULL);\n \t  fprintf (f, \")\\n\");\n@@ -2672,7 +2670,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \n   fprintf_indent (f, indent, \"if (dump_file && (dump_flags & TDF_DETAILS)) \"\n \t   \"fprintf (dump_file, \\\"Applying pattern \");\n-  output_line_directive (f, s->result_location, true);\n+  output_line_directive (f,\n+\t\t\t result ? result->location : s->match->location, true);\n   fprintf (f, \", %%s:%%d\\\\n\\\", __FILE__, __LINE__);\\n\");\n \n   if (!result)\n@@ -2868,7 +2867,8 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n {\n   fprintf_indent (f, indent, \"{\\n\");\n   indent += 2;\n-  output_line_directive (f, s->result_location);\n+  output_line_directive (f,\n+\t\t\t s->result ? s->result->location : s->match->location);\n   if (s->capture_max >= 0)\n     fprintf_indent (f, indent, \"tree captures[%u] ATTRIBUTE_UNUSED = {};\\n\",\n \t\t    s->capture_max + 1);\n@@ -3045,11 +3045,9 @@ class parser\n   void parse_pattern ();\n   operand *parse_result (operand *, predicate_id *);\n   void push_simplify (simplify::simplify_kind,\n-\t\t      vec<simplify *>&, operand *, source_location,\n-\t\t      operand *, source_location);\n+\t\t      vec<simplify *>&, operand *, operand *);\n   void parse_simplify (simplify::simplify_kind,\n-\t\t       source_location, vec<simplify *>&, predicate_id *,\n-\t\t       operand *);\n+\t\t       vec<simplify *>&, predicate_id *, operand *);\n   void parse_for (source_location);\n   void parse_if (source_location);\n   void parse_predicates (source_location);\n@@ -3269,7 +3267,7 @@ parser::parse_operation ()\n struct operand *\n parser::parse_capture (operand *op)\n {\n-  eat_token (CPP_ATSIGN);\n+  source_location src_loc = eat_token (CPP_ATSIGN)->src_loc;\n   const cpp_token *token = peek ();\n   const char *id = NULL;\n   if (token->type == CPP_NUMBER)\n@@ -3283,7 +3281,7 @@ parser::parse_capture (operand *op)\n   unsigned &num = capture_ids->get_or_insert (id, &existed);\n   if (!existed)\n     num = next_id;\n-  return new capture (num, op);\n+  return new capture (src_loc, num, op);\n }\n \n /* Parse an expression\n@@ -3292,8 +3290,9 @@ parser::parse_capture (operand *op)\n struct operand *\n parser::parse_expr ()\n {\n-  expr *e = new expr (parse_operation ());\n   const cpp_token *token = peek ();\n+  expr *e = new expr (parse_operation (), token->src_loc);\n+  token = peek ();\n   operand *op;\n   bool is_commutative = false;\n   bool force_capture = false;\n@@ -3345,7 +3344,7 @@ parser::parse_expr ()\n       capture_ids->get_or_insert (xstrdup (id), &existed);\n       if (existed)\n \tfatal_at (token, \"reserved capture id '%s' already used\", id);\n-      op = new capture (num, e);\n+      op = new capture (token->src_loc, num, e);\n     }\n   else\n     op = e;\n@@ -3386,7 +3385,7 @@ parser::parse_c_expr (cpp_ttype start)\n   unsigned opencnt;\n   vec<cpp_token> code = vNULL;\n   unsigned nr_stmts = 0;\n-  eat_token (start);\n+  source_location loc = eat_token (start)->src_loc;\n   if (start == CPP_OPEN_PAREN)\n     end = CPP_CLOSE_PAREN;\n   else if (start == CPP_OPEN_BRACE)\n@@ -3423,7 +3422,7 @@ parser::parse_c_expr (cpp_ttype start)\n       code.safe_push (*token);\n     }\n   while (1);\n-  return new c_expr (r, code, nr_stmts, vNULL, capture_ids);\n+  return new c_expr (r, loc, code, nr_stmts, vNULL, capture_ids);\n }\n \n /* Parse an operand which is either an expression, a predicate or\n@@ -3460,18 +3459,18 @@ parser::parse_op ()\n \t\tfatal_at (token, \"using an operator with operands as predicate\");\n \t      /* Parse the zero-operand operator \"predicates\" as\n \t\t expression.  */\n-\t      op = new expr (opr);\n+\t      op = new expr (opr, token->src_loc);\n \t    }\n \t  else if (user_id *code = dyn_cast <user_id *> (opr))\n \t    {\n \t      if (code->nargs != 0)\n \t\tfatal_at (token, \"using an operator with operands as predicate\");\n \t      /* Parse the zero-operand operator \"predicates\" as\n \t\t expression.  */\n-\t      op = new expr (opr);\n+\t      op = new expr (opr, token->src_loc);\n \t    }\n \t  else if (predicate_id *p = dyn_cast <predicate_id *> (opr))\n-\t    op = new predicate (p);\n+\t    op = new predicate (p, token->src_loc);\n \t  else\n \t    fatal_at (token, \"using an unsupported operator as predicate\");\n \t  if (!parsing_match_operand)\n@@ -3499,15 +3498,14 @@ parser::parse_op ()\n void\n parser::push_simplify (simplify::simplify_kind kind,\n \t\t       vec<simplify *>& simplifiers,\n-\t\t       operand *match, source_location match_loc,\n-\t\t       operand *result, source_location result_loc)\n+\t\t       operand *match, operand *result)\n {\n   /* Build and push a temporary for operator list uses in expressions.  */\n   if (!oper_lists.is_empty ())\n     active_fors.safe_push (oper_lists);\n \n   simplifiers.safe_push\n-    (new simplify (kind, match, match_loc, result, result_loc,\n+    (new simplify (kind, match, result,\n \t\t   active_fors.copy (), capture_ids));\n \n   if (!oper_lists.is_empty ())\n@@ -3531,7 +3529,7 @@ parser::parse_result (operand *result, predicate_id *matcher)\n   if (peek_ident (\"if\"))\n     {\n       eat_ident (\"if\");\n-      if_expr *ife = new if_expr ();\n+      if_expr *ife = new if_expr (token->src_loc);\n       ife->cond = parse_c_expr (CPP_OPEN_PAREN);\n       if (peek ()->type == CPP_OPEN_PAREN)\n \t{\n@@ -3563,7 +3561,7 @@ parser::parse_result (operand *result, predicate_id *matcher)\n   else if (peek_ident (\"with\"))\n     {\n       eat_ident (\"with\");\n-      with_expr *withe = new with_expr ();\n+      with_expr *withe = new with_expr (token->src_loc);\n       /* Parse (with c-expr expr) as (if-with (true) expr).  */\n       withe->with = parse_c_expr (CPP_OPEN_BRACE);\n       withe->with->nr_stmts = 0;\n@@ -3574,9 +3572,9 @@ parser::parse_result (operand *result, predicate_id *matcher)\n   else if (peek_ident (\"switch\"))\n     {\n       token = eat_ident (\"switch\");\n-      eat_token (CPP_OPEN_PAREN);\n+      source_location ifloc = eat_token (CPP_OPEN_PAREN)->src_loc;\n       eat_ident (\"if\");\n-      if_expr *ife = new if_expr ();\n+      if_expr *ife = new if_expr (ifloc);\n       operand *res = ife;\n       ife->cond = parse_c_expr (CPP_OPEN_PAREN);\n       if (peek ()->type == CPP_OPEN_PAREN)\n@@ -3593,9 +3591,9 @@ parser::parse_result (operand *result, predicate_id *matcher)\n \t    {\n \t      if (peek_ident (\"if\", 2))\n \t\t{\n-\t\t  eat_token (CPP_OPEN_PAREN);\n+\t\t  ifloc = eat_token (CPP_OPEN_PAREN)->src_loc;\n \t\t  eat_ident (\"if\");\n-\t\t  ife->falseexpr = new if_expr ();\n+\t\t  ife->falseexpr = new if_expr (ifloc);\n \t\t  ife = as_a <if_expr *> (ife->falseexpr);\n \t\t  ife->cond = parse_c_expr (CPP_OPEN_PAREN);\n \t\t  if (peek ()->type == CPP_OPEN_PAREN)\n@@ -3641,7 +3639,6 @@ parser::parse_result (operand *result, predicate_id *matcher)\n \n void\n parser::parse_simplify (simplify::simplify_kind kind,\n-\t\t\tsource_location match_location,\n \t\t\tvec<simplify *>& simplifiers, predicate_id *matcher,\n \t\t\toperand *result)\n {\n@@ -3668,7 +3665,7 @@ parser::parse_simplify (simplify::simplify_kind kind,\n   if_expr *active_if = NULL;\n   for (int i = active_ifs.length (); i > 0; --i)\n     {\n-      if_expr *ifc = new if_expr ();\n+      if_expr *ifc = new if_expr (active_ifs[i-1]->location);\n       ifc->cond = active_ifs[i-1];\n       ifc->trueexpr = active_if;\n       active_if = ifc;\n@@ -3690,8 +3687,7 @@ parser::parse_simplify (simplify::simplify_kind kind,\n \t  active_if->trueexpr = result;\n \t  result = outermost_if;\n \t}\n-      push_simplify (kind, simplifiers, match, match_location,\n-\t\t     result, token->src_loc);\n+      push_simplify (kind, simplifiers, match, result);\n       return;\n     }\n \n@@ -3704,8 +3700,7 @@ parser::parse_simplify (simplify::simplify_kind kind,\n   else\n     result = tem;\n \n-  push_simplify (kind, simplifiers, match, match_location,\n-\t\t result, token->src_loc);\n+  push_simplify (kind, simplifiers, match, result);\n }\n \n /* Parsing of the outer control structures.  */\n@@ -3930,13 +3925,13 @@ parser::parse_pattern ()\n   const char *id = get_ident ();\n   if (strcmp (id, \"simplify\") == 0)\n     {\n-      parse_simplify (simplify::SIMPLIFY,\n-\t\t      token->src_loc, simplifiers, NULL, NULL);\n+      parse_simplify (simplify::SIMPLIFY, simplifiers, NULL, NULL);\n       capture_ids = NULL;\n     }\n   else if (strcmp (id, \"match\") == 0)\n     {\n       bool with_args = false;\n+      source_location e_loc = peek ()->src_loc;\n       if (peek ()->type == CPP_OPEN_PAREN)\n \t{\n \t  eat_token (CPP_OPEN_PAREN);\n@@ -3959,7 +3954,7 @@ parser::parse_pattern ()\n       if (with_args)\n \t{\n \t  capture_ids = new cid_map_t;\n-\t  e = new expr (p);\n+\t  e = new expr (p, e_loc);\n \t  while (peek ()->type == CPP_ATSIGN)\n \t    e->append_op (parse_capture (NULL));\n \t  eat_token (CPP_CLOSE_PAREN);\n@@ -3969,7 +3964,7 @@ parser::parse_pattern ()\n \t      || (!e && p->nargs != 0)))\n \tfatal_at (token, \"non-matching number of match operands\");\n       p->nargs = e ? e->ops.length () : 0;\n-      parse_simplify (simplify::MATCH, token->src_loc, p->matchers, p, e);\n+      parse_simplify (simplify::MATCH, p->matchers, p, e);\n       capture_ids = NULL;\n     }\n   else if (strcmp (id, \"for\") == 0)"}]}