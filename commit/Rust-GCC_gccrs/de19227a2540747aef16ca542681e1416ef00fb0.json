{"sha": "de19227a2540747aef16ca542681e1416ef00fb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUxOTIyN2EyNTQwNzQ3YWVmMTZjYTU0MjY4MWUxNDE2ZWYwMGZiMA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T20:23:21Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T20:23:21Z"}, "message": "(schedule_block): Add a virtual cycle counter CLOCK.\n\n\tPass CLOCK to schedule_insn.\n\tCompute the tail in the scheduling loop, not before it.\n\tEnable the stall code that advances the insn queue.\n\tSelect the insn to schedule and block others with schedule_select.\n\t(adjust_priority): Renamed from launch_link.\n\t(schedule_insn): Renamed from launch_links.\n(insn_queue): Use INSN_QUEUE_SIZE.\n\n(insn_units, insn_blockage, insn_tick, unit_last_insn,\n\tunit_tick, unit_n_insns): New variables.\n\t(schedule_insns): Allocate and initialize insn_tick, insn_units, and\n\tinsn_blockage.\n\t(insn_unit, blockage_range, clear_units, prepare_unit, schedule_unit,\n\tactual_hazard_this_instance, actual_hazard, potential_hazard,\n\tschedule_select): New functions.\n\t(schedule_block): Add dependencies to force insns to remain in order\n\tat the end of a block rather than relying on having the scheduler\n\tissue them in priority order.\n(insn_cost): Add LINK and USED parameters.  All callers\n\tchanged.  Supply an ADJUST_COST interface.\n\t(insn_cost): Make a dependence from a USE insn free.\n\t(priority): Clear the link cost adjustment bits.\n\nFrom-SVN: r1951", "tree": {"sha": "248117125dc6820e070e8baf1abb491d81a3b462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/248117125dc6820e070e8baf1abb491d81a3b462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de19227a2540747aef16ca542681e1416ef00fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de19227a2540747aef16ca542681e1416ef00fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de19227a2540747aef16ca542681e1416ef00fb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de19227a2540747aef16ca542681e1416ef00fb0/comments", "author": null, "committer": null, "parents": [{"sha": "ef3fad04839638138ab28d7a00e40fca253f3d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3fad04839638138ab28d7a00e40fca253f3d45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3fad04839638138ab28d7a00e40fca253f3d45"}], "stats": {"total": 752, "additions": 645, "deletions": 107}, "files": [{"sha": "05c8a126c80f541f082511928ef4976806e33466", "filename": "gcc/sched.c", "status": "modified", "additions": 645, "deletions": 107, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de19227a2540747aef16ca542681e1416ef00fb0/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de19227a2540747aef16ca542681e1416ef00fb0/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=de19227a2540747aef16ca542681e1416ef00fb0", "patch": "@@ -46,12 +46,25 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    predecessors in the list according to their priority order.  We\n    consider this insn scheduled by setting the pointer to the \"end\" of\n    the list to point to the previous insn.  When an insn has no\n-   predecessors, we also add it to the ready list.  When all insns down\n-   to the lowest priority have been scheduled, the critical path of the\n-   basic block has been made as short as possible.  The remaining insns\n-   are then scheduled in remaining slots.\n-\n-   The following list shows the order in which we want to break ties:\n+   predecessors, we either queue it until sufficient time has elapsed\n+   or add it to the ready list.  As the instructions are scheduled or\n+   when stalls are introduced, the queue advances and dumps insns into\n+   the ready list.  When all insns down to the lowest priority have\n+   been scheduled, the critical path of the basic block has been made\n+   as short as possible.  The remaining insns are then scheduled in\n+   remaining slots.\n+\n+   Function unit conflicts are resolved during reverse list scheduling\n+   by tracking the time when each insn is committed to the schedule\n+   and from that, the time the function units it uses must be free.\n+   As insns on the ready list are considered for scheduling, those\n+   that would result in a blockage of the already committed insns are\n+   queued until no blockage will result.  Among the remaining insns on\n+   the ready list to be considered, the first one with the largest\n+   potential for causing a subsequent blockage is chosen.\n+\n+   The following list shows the order in which we want to break ties\n+   among insns in the ready list:\n \n \t1.  choose insn with lowest conflict cost, ties broken by\n \t2.  choose insn with the longest path to end of bb, ties broken by\n@@ -140,6 +153,30 @@ static int *insn_priority;\n static short *insn_costs;\n #define INSN_COST(INSN)\tinsn_costs[INSN_UID (INSN)]\n \n+/* Vector indexed by INSN_UID giving an encoding of the function units\n+   used.  */\n+static short *insn_units;\n+#define INSN_UNIT(INSN)\tinsn_units[INSN_UID (INSN)]\n+\n+/* Vector indexed by INSN_UID giving an encoding of the blockage range\n+   function.  The unit and the range are encoded.  */\n+static unsigned int *insn_blockage;\n+#define INSN_BLOCKAGE(INSN) insn_blockage[INSN_UID (INSN)]\n+#define UNIT_BITS 5\n+#define BLOCKAGE_MASK ((1 << BLOCKAGE_BITS) - 1)\n+#define ENCODE_BLOCKAGE(U,R)\t\t\t\t\\\n+  ((((U) << UNIT_BITS) << BLOCKAGE_BITS\t\t\t\\\n+    | MIN_BLOCKAGE_COST (R)) << BLOCKAGE_BITS\t\t\\\n+   | MAX_BLOCKAGE_COST (R))\n+#define UNIT_BLOCKED(B) ((B) >> (2 * BLOCKAGE_BITS))\n+#define BLOCKAGE_RANGE(B) \\\n+  (((((B) >> BLOCKAGE_BITS) & BLOCKAGE_MASK) << (HOST_BITS_PER_INT / 2)) \\\n+   | (B) & BLOCKAGE_MASK)\n+\n+/* Encodings of the `<name>_unit_blockage_range' function.  */\n+#define MIN_BLOCKAGE_COST(R) ((R) >> (HOST_BITS_PER_INT / 2))\n+#define MAX_BLOCKAGE_COST(R) ((R) & ((1 << (HOST_BITS_PER_INT / 2)) - 1))\n+\n #define DONE_PRIORITY\t-1\n #define MAX_PRIORITY\t0x7fffffff\n #define TAIL_PRIORITY\t0x7ffffffe\n@@ -188,34 +225,59 @@ static rtx dead_notes;\n /* An instruction is ready to be scheduled when all insns following it\n    have already been scheduled.  It is important to ensure that all\n    insns which use its result will not be executed until its result\n-   has been computed.  We maintain three lists (conceptually):\n-\n-   (1) a \"Ready\" list of unscheduled, uncommitted insns\n-   (2) a \"Scheduled\" list of scheduled insns\n-   (3) a \"Pending\" list of insns which can be scheduled, but\n-       for stalls.\n-\n-   Insns move from the \"Ready\" list to the \"Pending\" list when\n-   all insns following them have been scheduled.\n-\n-   Insns move from the \"Pending\" list to the \"Scheduled\" list\n-   when there is sufficient space in the pipeline to prevent\n-   stalls between the insn and scheduled insns which use it.\n-\n-   The \"Pending\" list acts as a buffer to prevent insns\n-   from avalanching.\n-\n-   The \"Ready\" list is implemented by the variable `ready'.\n-   The \"Pending\" list are the insns in the LOG_LINKS of ready insns.\n-   The \"Scheduled\" list is the new insn chain built by this pass.  */\n-\n-/* Implement a circular buffer from which instructions are issued.  */\n-#define Q_SIZE 128\n-static rtx insn_queue[Q_SIZE];\n+   has been computed.  An insn is maintained in one of four structures:\n+\n+   (P) the \"Pending\" set of insns which cannot be scheduled until\n+   their dependencies have been satisfied.\n+   (Q) the \"Queued\" set of insns that can be scheduled when sufficient\n+   time has passed.\n+   (R) the \"Ready\" list of unscheduled, uncommitted insns.\n+   (S) the \"Scheduled\" list of insns.\n+\n+   Initially, all insns are either \"Pending\" or \"Ready\" depending on\n+   whether their dependencies are satisfied.\n+\n+   Insns move from the \"Ready\" list to the \"Scheduled\" list as they\n+   are committed to the schedule.  As this occurs, the insns in the\n+   \"Pending\" list have their dependencies satisfied and move to either\n+   the \"Ready\" list or the \"Queued\" set depending on whether\n+   sufficient time has passed to make them ready.  As time passes,\n+   insns move from the \"Queued\" set to the \"Ready\" list.  Insns may\n+   move from the \"Ready\" list to the \"Queued\" set if they are blocked\n+   due to a function unit conflict.\n+\n+   The \"Pending\" list (P) are the insns in the LOG_LINKS of the unscheduled\n+   insns, i.e., those that are ready, queued, and pending.\n+   The \"Queued\" set (Q) is implemented by the variable `insn_queue'.\n+   The \"Ready\" list (R) is implemented by the variables `ready' and\n+   `n_ready'.\n+   The \"Scheduled\" list (S) is the new insn chain built by this pass.\n+\n+   The transition (R->S) is implemented in the scheduling loop in\n+   `schedule_block' when the best insn to schedule is chosen.\n+   The transition (R->Q) is implemented in `schedule_select' when an\n+   insn is found to to have a function unit conflict with the already\n+   committed insns.\n+   The transitions (P->R and P->Q) are implemented in `schedule_insn' as\n+   insns move from the ready list to the scheduled list.\n+   The transition (Q->R) is implemented at the top of the scheduling\n+   loop in `schedule_block' as time passes or stalls are introduced.  */\n+\n+/* Implement a circular buffer to delay instructions until sufficient\n+   time has passed.  INSN_QUEUE_SIZE is a power of two larger than\n+   MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the\n+   longest time an isnsn may be queued.  */\n+static rtx insn_queue[INSN_QUEUE_SIZE];\n static int q_ptr = 0;\n static int q_size = 0;\n-#define NEXT_Q(X) (((X)+1) & (Q_SIZE-1))\n-#define NEXT_Q_AFTER(X,C) (((X)+C) & (Q_SIZE-1))\n+#define NEXT_Q(X) (((X)+1) & (INSN_QUEUE_SIZE-1))\n+#define NEXT_Q_AFTER(X,C) (((X)+C) & (INSN_QUEUE_SIZE-1))\n+\n+/* Vector indexed by INSN_UID giving the minimum clock tick at which\n+   the insn becomes ready.  This is used to note timing constraints for\n+   insns in the pending list.  */\n+static int *insn_tick;\n+#define INSN_TICK(INSN) (insn_tick[INSN_UID (INSN)])\n \n /* Forward declarations.  */\n static void sched_analyze_2 ();\n@@ -908,38 +970,339 @@ find_insn_list (insn, list)\n   return 0;\n }\n \n-/* Compute cost of executing INSN.  This is the number of virtual\n-   cycles taken between instruction issue and instruction results.  */\n+/* Compute the function units used by INSN.  This caches the value\n+   returned by function_units_used.  A function unit is encoded as the\n+   unit number if the value is non-negative and the compliment of a\n+   mask if the value is negative.  A function unit index is the\n+   non-negative encoding.  */\n \n __inline static int\n-insn_cost (insn)\n+insn_unit (insn)\n      rtx insn;\n {\n-  register int cost;\n+  register int unit = INSN_UNIT (insn);\n+\n+  if (unit == 0)\n+    {\n+      recog_memoized (insn);\n+\n+      /* A USE insn, or something else we don't need to understand.\n+\t We can't pass these directly to function_units_used because it will\n+\t trigger a fatal error for unrecognizable insns.  */\n+      if (INSN_CODE (insn) < 0)\n+\tunit = -1;\n+      else\n+\t{\n+\t  unit = function_units_used (insn);\n+\t  /* Increment non-negative values so we can cache zero.  */\n+\t  if (unit >= 0) unit++;\n+\t}\n+      /* We only cache 16 bits of the result, so if the value is out of\n+\t range, don't cache it.  */\n+      if (FUNCTION_UNITS_SIZE < HOST_BITS_PER_SHORT\n+\t  || unit >= 0\n+\t  || (~unit & ((1 << (HOST_BITS_PER_SHORT - 1)) - 1)) == 0)\n+      INSN_UNIT (insn) = unit;\n+    }\n+  return (unit > 0 ? unit - 1 : unit);\n+}\n \n-  if (INSN_COST (insn))\n-    return INSN_COST (insn);\n+/* Compute the blockage range for executing INSN on UNIT.  This caches\n+   the value returned by the blockage_range_function for the unit.\n+   These values are encoded in an int where the upper half gives the\n+   minimum value and the lower half gives the maximum value.  */\n \n-  recog_memoized (insn);\n+__inline static unsigned int\n+blockage_range (unit, insn)\n+     int unit;\n+     rtx insn;\n+{\n+  unsigned int blockage = INSN_BLOCKAGE (insn);\n+  unsigned int range;\n \n-  /* A USE insn, or something else we don't need to understand.\n-     We can't pass these directly to result_ready_cost because it will trigger\n-     a fatal error for unrecognizable insns.  */\n-  if (INSN_CODE (insn) < 0)\n+  if (UNIT_BLOCKED (blockage) != unit + 1)\n     {\n-      INSN_COST (insn) = 1;\n-      return 1;\n+      range = function_units[unit].blockage_range_function (insn);\n+      /* We only cache the blockage range for one unit and then only if\n+\t the values fit.  */\n+      if (HOST_BITS_PER_INT >= UNIT_BITS + 2 * BLOCKAGE_BITS)\n+\tINSN_BLOCKAGE (insn) = ENCODE_BLOCKAGE (unit + 1, range);\n+    }\n+  else\n+    range = BLOCKAGE_RANGE (blockage);\n+\n+  return range;\n+}\n+\n+/* A vector indexed by function unit instance giving the last insn to use\n+   the unit.  The value of the function unit instance index for unit U\n+   instance I is (U + I * FUNCTION_UNITS_SIZE).  */\n+static rtx unit_last_insn[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n+\n+/* A vector indexed by function unit instance giving the minimum time when\n+   the unit will unblock based on the maximum blockage cost.  */\n+static int unit_tick[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n+\n+/* A vector indexed by function unit number giving the number of insns\n+   that remain to use the unit.  */\n+static int unit_n_insns[FUNCTION_UNITS_SIZE];\n+\n+/* Reset the function unit state to the null state.  */\n+\n+static void\n+clear_units ()\n+{\n+  int unit;\n+\n+  bzero (unit_last_insn, sizeof (unit_last_insn));\n+  bzero (unit_tick, sizeof (unit_tick));\n+  bzero (unit_n_insns, sizeof (unit_n_insns));\n+}\n+\n+/* Record an insn as one that will use the units encoded by UNIT.  */\n+\n+__inline static void\n+prepare_unit (unit)\n+     int unit;\n+{\n+  int i;\n+\n+  if (unit >= 0)\n+    unit_n_insns[unit]++;\n+  else\n+    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n+      if ((unit & 1) != 0)\n+\tprepare_unit (i);\n+}\n+\n+/* Return the actual hazard cost of executing INSN on the unit UNIT,\n+   instance INSTANCE at time CLOCK if the previous actual hazard cost\n+   was COST.  */\n+\n+__inline static int\n+actual_hazard_this_instance (unit, instance, insn, clock, cost)\n+     int unit, instance, clock, cost;\n+     rtx insn;\n+{\n+  int i;\n+  int tick = unit_tick[instance];\n+\n+  if (tick - clock > cost)\n+    {\n+      /* The scheduler is operating in reverse, so INSN is the executing\n+\t insn and the unit's last insn is the candidate insn.  We want a\n+\t more exact measure of the blockage if we execute INSN at CLOCK\n+\t given when we committed the execution of the unit's last insn.\n+\n+\t The blockage value is given by either the unit's max blockage\n+\t constant, blockage range function, or blockage function.  Use\n+\t the most exact form for the given unit.  */\n+\n+      if (function_units[unit].blockage_range_function)\n+\t{\n+\t  if (function_units[unit].blockage_function)\n+\t    tick += (function_units[unit].blockage_function\n+\t\t     (insn, unit_last_insn[instance])\n+\t\t     - function_units[unit].max_blockage);\n+\t  else\n+\t    tick += ((int) MAX_BLOCKAGE_COST (blockage_range (unit, insn))\n+\t\t     - function_units[unit].max_blockage);\n+\t}\n+      if (tick - clock > cost)\n+\tcost = tick - clock;\n+    }\n+  return cost;\n+}\n+\n+/* Record INSN as having begun execution on the units encoded by UNIT at\n+   time CLOCK.  */\n+\n+__inline static void\n+schedule_unit (unit, insn, clock)\n+     int unit, clock;\n+     rtx insn;\n+{\n+  int i;\n+\n+  if (unit >= 0)\n+    {\n+      int instance = unit;\n+#if MAX_MULTIPLICITY > 1\n+      /* Find the first free instance of the function unit and use that\n+\t one.  We assume that one is free.  */\n+      for (i = function_units[unit].multiplicity - 1; i > 0; i--)\n+\t{\n+\t  if (! actual_hazard_this_instance (unit, instance, insn, clock, 0))\n+\t    break;\n+\t  instance += FUNCTION_UNITS_SIZE;\n+\t}\n+#endif\n+      unit_last_insn[instance] = insn;\n+      unit_tick[instance] = (clock + function_units[unit].max_blockage);\n     }\n   else\n+    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n+      if ((unit & 1) != 0)\n+\tschedule_unit (i, insn, clock);\n+}\n+\n+/* Return the actual hazard cost of executing INSN on the units encoded by\n+   UNIT at time CLOCK if the previous actual hazard cost was COST.  */\n+\n+__inline static int\n+actual_hazard (unit, insn, clock, cost)\n+     int unit, clock, cost;\n+     rtx insn;\n+{\n+  int i;\n+\n+  if (unit >= 0)\n     {\n-      cost = result_ready_cost (insn);\n+      /* Find the instance of the function unit with the minimum hazard.  */\n+      int instance = unit;\n+      int best = instance;\n+      int best_cost = actual_hazard_this_instance (unit, instance, insn,\n+\t\t\t\t\t\t   clock, cost);\n+      int this_cost;\n+\n+#if MAX_MULTIPLICITY > 1\n+      if (best_cost > cost)\n+\t{\n+\t  for (i = function_units[unit].multiplicity - 1; i > 0; i--)\n+\t    {\n+\t      instance += FUNCTION_UNITS_SIZE;\n+\t      this_cost = actual_hazard_this_instance (unit, instance, insn,\n+\t\t\t\t\t\t       clock, cost);\n+\t      if (this_cost < best_cost)\n+\t\t{\n+\t\t  best = instance;\n+\t\t  best_cost = this_cost;\n+\t\t  if (this_cost <= cost)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+#endif\n+      cost = MAX (cost, best_cost);\n+    }\n+  else\n+    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n+      if ((unit & 1) != 0)\n+\tcost = actual_hazard (i, insn, clock, cost);\n+\n+  return cost;\n+}\n \n-      if (cost < 1)\n-\tcost = 1;\n+/* Return the potential hazard cost of executing an instruction on the\n+   units encoded by UNIT if the previous potential hazard cost was COST.\n+   An insn with a large blockage time is chosen in preference to one\n+   with a smaller time; an insn that uses a unit that is more likely\n+   to be used is chosen in preference to one with a unit that is less\n+   used.  We are trying to minimize a subsequent actual hazard.  */\n \n-      INSN_COST (insn) = cost;\n-      return cost;\n+__inline static int\n+potential_hazard (unit, insn, cost)\n+     int unit, cost;\n+     rtx insn;\n+{\n+  int i, ncost;\n+  unsigned int minb, maxb;\n+\n+  if (unit >= 0)\n+    {\n+      minb = maxb = function_units[unit].max_blockage;\n+      if (maxb > 1)\n+\t{\n+\t  if (function_units[unit].blockage_range_function)\n+\t    {\n+\t      maxb = minb = blockage_range (unit, insn);\n+\t      maxb = MAX_BLOCKAGE_COST (maxb);\n+\t      minb = MIN_BLOCKAGE_COST (minb);\n+\t    }\n+\n+\t  if (maxb > 1)\n+\t    {\n+\t      /* Make the number of instructions left dominate.  Make the\n+\t\t minimum delay dominate the maximum delay.  If all these\n+\t\t are the same, use the unit number to add an arbitrary\n+\t\t ordering.  Other terms can be added.  */\n+\t      ncost = minb * 0x40 + maxb;\n+\t      ncost *= (unit_n_insns[unit] - 1) * 0x1000 + unit;\n+\t      if (ncost > cost)\n+\t\tcost = ncost;\n+\t    }\n+\t}\n     }\n+  else\n+    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n+      if ((unit & 1) != 0)\n+\tcost = potential_hazard (i, insn, cost);\n+\n+  return cost;\n+}\n+\n+/* Compute cost of executing INSN given the dependence LINK on the insn USED.\n+   This is the number of virtual cycles taken between instruction issue and\n+   instruction results.  */\n+\n+__inline static int\n+insn_cost (insn, link, used)\n+     rtx insn, link, used;\n+{\n+  register int cost = INSN_COST (insn);\n+\n+  if (cost == 0)\n+    {\n+      recog_memoized (insn);\n+\n+      /* A USE insn, or something else we don't need to understand.\n+\t We can't pass these directly to result_ready_cost because it will\n+\t trigger a fatal error for unrecognizable insns.  */\n+      if (INSN_CODE (insn) < 0)\n+\t{\n+\t  INSN_COST (insn) = 1;\n+\t  return 1;\n+\t}\n+      else\n+\t{\n+\t  cost = result_ready_cost (insn);\n+\n+\t  if (cost < 1)\n+\t    cost = 1;\n+\n+\t  INSN_COST (insn) = cost;\n+\t}\n+    }\n+\n+  /* A USE insn should never require the value used to be computed.  This\n+     allows the computation of a function's result and parameter values to\n+     overlap the return and call.  */\n+  recog_memoized (used);\n+  if (INSN_CODE (used) < 0)\n+    LINK_COST_FREE (link) = 1;\n+\n+  /* If some dependencies vary the cost, compute the adjustment.  Most\n+     commonly, the adjustment is complete: either the cost is ignored\n+     (in the case of an output- or anti-dependence), or the cost is\n+     unchanged.  These values are cached in the link as LINK_COST_FREE\n+     and LINK_COST_ZERO.  */\n+\n+  if (LINK_COST_FREE (link))\n+    cost = 1;\n+#ifdef ADJUST_COST\n+  else if (! LINK_COST_ZERO (link))\n+    {\n+      int ncost = cost;\n+\n+      ADJUST_COST (used, link, insn, ncost);\n+      if (ncost <= 1)\n+\tLINK_COST_FREE (link) = ncost = 1;\n+      if (cost == ncost)\n+\tLINK_COST_ZERO (link) = 1;\n+      cost = ncost;\n+    }\n+#endif\n+  return cost;\n }\n \n /* Compute the priority number for INSN.  */\n@@ -985,6 +1348,12 @@ priority (insn)\n \t      continue;\n \t    }\n \n+\t  /* Clear the link cost adjustment bits.  */\n+\t  LINK_COST_FREE (prev) = 0;\n+#ifdef ADJUST_COST\n+\t  LINK_COST_ZERO (prev) = 0;\n+#endif\n+\n \t  /* This priority calculation was chosen because it results in the\n \t     least instruction movement, and does not hurt the performance\n \t     of the resulting code compared to the old algorithm.\n@@ -1003,7 +1372,7 @@ priority (insn)\n \n \t  if (REG_NOTE_KIND (prev) == 0)\n \t    /* Data dependence.  */\n-\t    prev_priority = priority (x) + insn_cost (x) - 1;\n+\t    prev_priority = priority (x) + insn_cost (x, prev, insn) - 1;\n \t  else\n \t    /* Anti or output dependence.  Don't add the latency of this\n \t       insn's result, because it isn't being used.  */\n@@ -1014,6 +1383,7 @@ priority (insn)\n \t  INSN_REF_COUNT (x) += 1;\n \t}\n \n+      prepare_unit (insn_unit (insn));\n       INSN_PRIORITY (insn) = max_priority;\n       return INSN_PRIORITY (insn);\n     }\n@@ -1753,7 +2123,7 @@ rank_for_schedule (x, y)\n {\n   rtx tmp = *y;\n   rtx tmp2 = *x;\n-  rtx tmp_dep, tmp2_dep;\n+  rtx link;\n   int tmp_class, tmp2_class;\n   int value;\n \n@@ -1768,18 +2138,18 @@ rank_for_schedule (x, y)\n \t 2) Anti/Output dependent on last scheduled insn.\n \t 3) Independent of last scheduled insn, or has latency of one.\n \t Choose the insn from the highest numbered class if different.  */\n-      tmp_dep = find_insn_list (tmp, LOG_LINKS (last_scheduled_insn));\n-      if (tmp_dep == 0 || insn_cost (tmp) == 1)\n+      link = find_insn_list (tmp, LOG_LINKS (last_scheduled_insn));\n+      if (link == 0 || insn_cost (tmp, link, last_scheduled_insn) == 1)\n \ttmp_class = 3;\n-      else if (REG_NOTE_KIND (tmp_dep) == 0)\n+      else if (REG_NOTE_KIND (link) == 0) /* Data dependence.  */\n \ttmp_class = 1;\n       else\n \ttmp_class = 2;\n \n-      tmp2_dep = find_insn_list (tmp2, LOG_LINKS (last_scheduled_insn));\n-      if (tmp2_dep == 0 || insn_cost (tmp2) == 1)\n+      link = find_insn_list (tmp2, LOG_LINKS (last_scheduled_insn));\n+      if (link == 0 || insn_cost (tmp2, link, last_scheduled_insn) == 1)\n \ttmp2_class = 3;\n-      else if (REG_NOTE_KIND (tmp2_dep) == 0)\n+      else if (REG_NOTE_KIND (link) == 0) /* Data dependence.  */\n \ttmp2_class = 1;\n       else\n \ttmp2_class = 2;\n@@ -1866,25 +2236,20 @@ birthing_insn_p (pat)\n   return 0;\n }\n \n-/* If PREV is an insn which is immediately ready to execute, return 1,\n-   otherwise return 0.  We may adjust its priority if that will help shorten\n-   register lifetimes.  */\n+/* PREV is an insn that is ready to execute.  Adjust its priority if that\n+   will help shorten register lifetimes.  */\n \n-static int\n-launch_link (prev)\n+__inline static void\n+adjust_priority (prev)\n      rtx prev;\n {\n-  rtx pat = PATTERN (prev);\n-  rtx note;\n-  /* MAX of (a) number of cycles needed by prev\n-\t    (b) number of cycles before needed resources are free.  */\n-  int n_cycles = insn_cost (prev);\n-  int n_deaths = 0;\n-\n   /* Trying to shorten register lives after reload has completed\n      is useless and wrong.  It gives inaccurate schedules.  */\n   if (reload_completed == 0)\n     {\n+      rtx note;\n+      int n_deaths = 0;\n+\n       for (note = REG_NOTES (prev); note; note = XEXP (note, 1))\n \tif (REG_NOTE_KIND (note) == REG_DEAD)\n \t  n_deaths += 1;\n@@ -1905,7 +2270,7 @@ launch_link (prev)\n \t  INSN_PRIORITY (prev) >>= 1;\n \t  break;\n \tcase 0:\n-\t  if (birthing_insn_p (pat))\n+\t  if (birthing_insn_p (PATTERN (prev)))\n \t    {\n \t      int max = max_priority;\n \n@@ -1915,31 +2280,30 @@ launch_link (prev)\n \t  break;\n \t}\n     }\n-\n-  if (n_cycles <= 1)\n-    return 1;\n-  queue_insn (prev, n_cycles);\n-  return 0;\n }\n \n /* INSN is the \"currently executing insn\".  Launch each insn which was\n    waiting on INSN (in the backwards dataflow sense).  READY is a\n    vector of insns which are ready to fire.  N_READY is the number of\n-   elements in READY.  */\n+   elements in READY.  CLOCK is the current virtual cycle.  */\n \n static int\n-launch_links (insn, ready, n_ready)\n+schedule_insn (insn, ready, n_ready, clock)\n      rtx insn;\n      rtx *ready;\n      int n_ready;\n+     int clock;\n {\n   rtx link;\n   int new_ready = n_ready;\n \n+  if (MAX_BLOCKAGE > 1)\n+    schedule_unit (insn_unit (insn), insn, clock);\n+\n   if (LOG_LINKS (insn) == 0)\n     return n_ready;\n \n-  /* This is used by the function launch_link above.  */\n+  /* This is used by the function adjust_priority above.  */\n   if (n_ready > 0)\n     max_priority = MAX (INSN_PRIORITY (ready[0]), INSN_PRIORITY (insn));\n   else\n@@ -1948,14 +2312,131 @@ launch_links (insn, ready, n_ready)\n   for (link = LOG_LINKS (insn); link != 0; link = XEXP (link, 1))\n     {\n       rtx prev = XEXP (link, 0);\n+      int cost = insn_cost (prev, link, insn);\n \n-      if ((INSN_REF_COUNT (prev) -= 1) == 0 && launch_link (prev))\n-\tready[new_ready++] = prev;\n+      if ((INSN_REF_COUNT (prev) -= 1) != 0)\n+\t{\n+\t  /* We satisfied one requirement to fire PREV.  Record the earliest\n+\t     time when PREV can fire.  No need to do this if the cost is 1,\n+\t     because PREV can fire no sooner than the next cycle.  */\n+\t  if (cost > 1)\n+\t    INSN_TICK (prev) = MAX (INSN_TICK (prev), clock + cost);\n+\t}\n+      else\n+\t{\n+\t  /* We satisfied the last requirement to fire PREV.  Ensure that all\n+\t     timing requirements are satisfied.  */\n+\t  if (INSN_TICK (prev) - clock > cost)\n+\t    cost = INSN_TICK (prev) - clock;\n+\n+\t  /* Adjust the priority of PREV and either put it on the ready\n+\t     list or queue it.  */\n+\t  adjust_priority (prev);\n+\t  if (cost <= 1)\n+\t    ready[new_ready++] = prev;\n+\t  else\n+\t    queue_insn (prev, cost);\n+\t}\n     }\n \n   return new_ready;\n }\n \n+/* Given N_READY insns in the ready list READY at time CLOCK, queue\n+   those that are blocked due to function unit hazards and rearrange\n+   the remaining ones to minimize subsequent function unit hazards.  */\n+\n+static int\n+schedule_select (ready, n_ready, clock, file)\n+     rtx *ready;\n+     int n_ready, clock;\n+     FILE *file;\n+{\n+  int pri = INSN_PRIORITY (ready[0]);\n+  int i, j, k, q, cost, best_cost, best_insn = 0, new_ready = n_ready;\n+  rtx insn;\n+\n+  /* Work down the ready list in groups of instructions with the same\n+     priority value.  Queue insns in the group that are blocked and\n+     select among those that remain for the one with the largest\n+     potential hazard.  */\n+  for (i = 0; i < n_ready; i = j)\n+    {\n+      int opri = pri;\n+      for (j = i + 1; j < n_ready; j++)\n+\tif ((pri = INSN_PRIORITY (ready[j])) != opri)\n+\t  break;\n+\n+      /* Queue insns in the group that are blocked.  */\n+      for (k = i, q = 0; k < j; k++)\n+\t{\n+\t  insn = ready[k];\n+\t  if ((cost = actual_hazard (insn_unit (insn), insn, clock, 0)) != 0)\n+\t    {\n+\t      q++;\n+\t      ready[k] = 0;\n+\t      queue_insn (insn, cost);\n+\t      if (file)\n+\t\tfprintf (file, \"\\n;; blocking insn %d for %d cycles\",\n+\t\t\t INSN_UID (insn), cost);\n+\t    }\n+\t}\n+      new_ready -= q;\n+\n+      /* Check the next group if all insns were queued.  */\n+      if (j - i - q == 0)\n+\tcontinue;\n+\n+      /* If more than one remains, select the first one with the largest\n+\t potential hazard.  */\n+      else if (j - i - q > 1)\n+\t{\n+\t  best_cost = -1;\n+\t  for (k = i; k < j; k++)\n+\t    {\n+\t      if ((insn = ready[k]) == 0)\n+\t\tcontinue;\n+\t      if ((cost = potential_hazard (insn_unit (insn), insn, 0))\n+\t\t  > best_cost)\n+\t\t{\n+\t\t  best_cost = cost;\n+\t\t  best_insn = k;\n+\t\t}\n+\t    }\n+\t}\n+      /* We have found a suitable insn to schedule.  */\n+      break;\n+    }\n+\n+  /* Move the best insn to be front of the ready list.  */\n+  if (best_insn != 0)\n+    {\n+      if (file)\n+\t{\n+\t  fprintf (file, \", now\");\n+\t  for (i = 0; i < n_ready; i++)\n+\t    if (ready[i])\n+\t      fprintf (file, \" %d\", INSN_UID (ready[i]));\n+\t  fprintf (file, \"\\n;; insn %d has a greater potential hazard\",\n+\t\t   INSN_UID (ready[best_insn]));\n+\t}\n+      for (i = best_insn; i > 0; i--)\n+\t{\n+\t  insn = ready[i-1];\n+\t  ready[i-1] = ready[i];\n+\t  ready[i] = insn;\n+\t}\n+    }\n+\n+  /* Compact the ready list.  */\n+  if (new_ready < n_ready)\n+    for (i = j = 0; i < n_ready; i++)\n+      if (ready[i])\n+\tready[j++] = ready[i];\n+\n+  return new_ready;\n+}\n+\n /* Add a REG_DEAD note for REG to INSN, reusing a REG_DEAD note from the\n    dead_notes list.  */\n \n@@ -2310,6 +2791,7 @@ schedule_block (b, file)\n   rtx *ready, link;\n   int i, j, n_ready = 0, new_ready, n_insns = 0;\n   int sched_n_insns = 0;\n+  int clock;\n #define NEED_NOTHING\t0\n #define NEED_HEAD\t1\n #define NEED_TAIL\t2\n@@ -2338,6 +2820,7 @@ schedule_block (b, file)\n   bzero (reg_last_uses, i * sizeof (rtx));\n   reg_last_sets = (rtx *) alloca (i * sizeof (rtx));\n   bzero (reg_last_sets, i * sizeof (rtx));\n+  clear_units ();\n \n   /* Remove certain insns at the beginning from scheduling,\n      by advancing HEAD.  */\n@@ -2438,14 +2921,15 @@ schedule_block (b, file)\n   insn = tail;\n \n   /* For all branches, calls, uses, and cc0 setters, force them to remain\n-     in order at the end of the block by giving them high priorities.\n-     There may be notes present, and prev_head may also be a note.\n+     in order at the end of the block by adding dependencies and giving\n+     the last a high priority.  There may be notes present, and prev_head\n+     may also be a note.\n \n      Branches must obviously remain at the end.  Calls should remain at the\n      end since moving them results in worse register allocation.  Uses remain\n      at the end to ensure proper register allocation.  cc0 setters remaim\n      at the end because they can't be moved away from their cc0 user.  */\n-  i = 0;\n+  last = 0;\n   while (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n \t || (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE)\n #ifdef HAVE_cc0\n@@ -2456,10 +2940,18 @@ schedule_block (b, file)\n       if (GET_CODE (insn) != NOTE)\n \t{\n \t  priority (insn);\n-\t  ready[n_ready++] = insn;\n-\t  INSN_PRIORITY (insn) = TAIL_PRIORITY - i;\n-\t  i++;\n-\t  INSN_REF_COUNT (insn) = 0;\n+\t  if (last == 0)\n+\t    {\n+\t      ready[n_ready++] = insn;\n+\t      INSN_PRIORITY (insn) = TAIL_PRIORITY - i;\n+\t      INSN_REF_COUNT (insn) = 0;\n+\t    }\n+\t  else if (! find_insn_list (insn, LOG_LINKS (last)))\n+\t    {\n+\t      add_dependence (last, insn, REG_DEP_ANTI);\n+\t      INSN_REF_COUNT (insn)++;\n+\t    }\n+\t  last = insn;\n \n \t  /* Skip over insns that are part of a group.  */\n \t  while (SCHED_GROUP_P (insn))\n@@ -2488,7 +2980,17 @@ schedule_block (b, file)\n \t{\n \t  priority (insn);\n \t  if (INSN_REF_COUNT (insn) == 0)\n-\t    ready[n_ready++] = insn;\n+\t    {\n+\t      if (last == 0)\n+\t\tready[n_ready++] = insn;\n+\t      else\n+\t\t{\n+\t\t  /* Make this dependent on the last of the instructions\n+\t\t     that must remain in order at the end of the block.  */\n+\t\t  add_dependence (last, insn, REG_DEP_ANTI);\n+\t\t  INSN_REF_COUNT (insn) = 1;\n+\t\t}\n+\t    }\n \t  if (SCHED_GROUP_P (insn))\n \t    {\n \t      while (SCHED_GROUP_P (insn))\n@@ -2788,10 +3290,10 @@ schedule_block (b, file)\n \n   /* Now HEAD and TAIL are going to become disconnected\n      entirely from the insn chain.  */\n-  tail = ready[0];\n+  tail = 0;\n \n   /* Q_SIZE will always be zero here.  */\n-  q_ptr = 0;\n+  q_ptr = 0; clock = 0;\n   bzero (insn_queue, sizeof (insn_queue));\n \n   /* Now, perform list scheduling.  */\n@@ -2807,15 +3309,15 @@ schedule_block (b, file)\n   new_ready = n_ready;\n   while (sched_n_insns < n_insns)\n     {\n-      q_ptr = NEXT_Q (q_ptr);\n+      q_ptr = NEXT_Q (q_ptr); clock++;\n \n       /* Add all pending insns that can be scheduled without stalls to the\n \t ready list.  */\n       for (insn = insn_queue[q_ptr]; insn; insn = NEXT_INSN (insn))\n \t{\n \t  if (file)\n-\t    fprintf (file, \";; launching %d before %d with no stalls\\n\",\n-\t\t     INSN_UID (insn), INSN_UID (last));\n+\t    fprintf (file, \";; launching %d before %d with no stalls at T-%d\\n\",\n+\t\t     INSN_UID (insn), INSN_UID (last), clock);\n \t  ready[new_ready++] = insn;\n \t  q_size -= 1;\n \t}\n@@ -2827,40 +3329,70 @@ schedule_block (b, file)\n \t{\n \t  register int stalls;\n \n-\t  for (stalls = 1; stalls < Q_SIZE; stalls++)\n+\t  for (stalls = 1; stalls < INSN_QUEUE_SIZE; stalls++)\n \t    if (insn = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)])\n \t      {\n \t\tfor (; insn; insn = NEXT_INSN (insn))\n \t\t  {\n \t\t    if (file)\n-\t\t      fprintf (file, \";; issue insn %d before %d with %d stalls\\n\",\n-\t\t\t       INSN_UID (insn), INSN_UID (last), stalls);\n+\t\t      fprintf (file, \";; launching %d before %d with %d stalls at T-%d\\n\",\n+\t\t\t       INSN_UID (insn), INSN_UID (last), stalls, clock);\n \t\t    ready[new_ready++] = insn;\n \t\t    q_size -= 1;\n \t\t  }\n \t\tinsn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = 0;\n \t\tbreak;\n \t      }\n \n-#if 0\n-\t  /* This looks logically correct, but on the SPEC benchmark set on\n-\t     the SPARC, I get better code without it.  */\n-\t  q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n-#endif\n+\t  q_ptr = NEXT_Q_AFTER (q_ptr, stalls); clock += stalls;\n \t}\n \n       /* There should be some instructions waiting to fire.  */\n       if (new_ready == 0)\n \tabort ();\n \n-      /* Sort the ready list and choose the best insn to schedule.\n+      if (file)\n+\t{\n+\t  fprintf (file, \";; ready list at T-%d:\", clock);\n+\t  for (i = 0; i < new_ready; i++)\n+\t    fprintf (file, \" %d (%x)\",\n+\t\t     INSN_UID (ready[i]), INSN_PRIORITY (ready[i]));\n+\t}\n+\n+      /* Sort the ready list and choose the best insn to schedule.  Select\n+\t which insn should issue in this cycle and queue those that are\n+\t blocked by function unit hazards.\n+\n \t N_READY holds the number of items that were scheduled the last time,\n \t minus the one instruction scheduled on the last loop iteration; it\n \t is not modified for any other reason in this loop.  */\n+\n       SCHED_SORT (ready, new_ready, n_ready);\n+      if (MAX_BLOCKAGE > 1)\n+\t{\n+\t  new_ready = schedule_select (ready, new_ready, clock, file);\n+\t  if (new_ready == 0)\n+\t    {\n+\t      if (file)\n+\t\tfprintf (file, \"\\n\");\n+\t      continue;\n+\t    }\n+\t}\n       n_ready = new_ready;\n       last_scheduled_insn = insn = ready[0];\n \n+      /* The first insn scheduled becomes the new tail.  */\n+      if (tail == 0)\n+\ttail = insn;\n+\n+      if (file)\n+\t{\n+\t  fprintf (file, \", now\");\n+\t  for (i = 0; i < n_ready; i++)\n+\t    fprintf (file, \" %d\", INSN_UID (ready[i]));\n+\t  fprintf (file, \"\\n\");\n+\t}\n+\n       if (DONE_PRIORITY_P (insn))\n \tabort ();\n \n@@ -3000,7 +3532,7 @@ schedule_block (b, file)\n \t ahead of all others.  Mark INSN as scheduled by changing its\n \t priority to -1.  */\n       INSN_PRIORITY (insn) = LAUNCH_PRIORITY;\n-      new_ready = launch_links (insn, ready, n_ready);\n+      new_ready = schedule_insn (insn, ready, n_ready, clock);\n       INSN_PRIORITY (insn) = DONE_PRIORITY;\n \n       /* Schedule all prior insns that must not be moved.  */\n@@ -3019,7 +3551,7 @@ schedule_block (b, file)\n \t  while (SCHED_GROUP_P (insn))\n \t    {\n \t      insn = PREV_INSN (insn);\n-\t      new_ready = launch_links (insn, ready, new_ready);\n+\t      new_ready = schedule_insn (insn, ready, new_ready, clock);\n \t      INSN_PRIORITY (insn) = DONE_PRIORITY;\n \n \t      sched_n_insns += 1;\n@@ -3128,8 +3660,8 @@ schedule_block (b, file)\n \n   if (file)\n     {\n-      fprintf (file, \";; new basic block head = %d\\n;; new basic block end = %d\\n\\n\",\n-\t       INSN_UID (basic_block_head[b]), INSN_UID (basic_block_end[b]));\n+      fprintf (file, \";; total time = %d\\n;; new basic block head = %d\\n;; new basic block end = %d\\n\\n\",\n+\t       clock, INSN_UID (basic_block_head[b]), INSN_UID (basic_block_end[b]));\n     }\n \n   /* Yow! We're done!  */\n@@ -3789,7 +4321,10 @@ schedule_insns (dump_file)\n      for what these vectors do.  */\n   insn_luid = (int *) alloca (max_uid * sizeof (int));\n   insn_priority = (int *) alloca (max_uid * sizeof (int));\n+  insn_tick = (int *) alloca (max_uid * sizeof (int));\n   insn_costs = (short *) alloca (max_uid * sizeof (short));\n+  insn_units = (short *) alloca (max_uid * sizeof (short));\n+  insn_blockage = (unsigned int *) alloca (max_uid * sizeof (unsigned int));\n   insn_ref_count = (int *) alloca (max_uid * sizeof (int));\n \n   if (reload_completed == 0)\n@@ -3840,7 +4375,10 @@ schedule_insns (dump_file)\n \n   bzero (insn_luid, max_uid * sizeof (int));\n   bzero (insn_priority, max_uid * sizeof (int));\n+  bzero (insn_tick, max_uid * sizeof (int));\n   bzero (insn_costs, max_uid * sizeof (short));\n+  bzero (insn_units, max_uid * sizeof (short));\n+  bzero (insn_blockage, max_uid * sizeof (unsigned int));\n   bzero (insn_ref_count, max_uid * sizeof (int));\n \n   /* Schedule each basic block, block by block.  */"}]}