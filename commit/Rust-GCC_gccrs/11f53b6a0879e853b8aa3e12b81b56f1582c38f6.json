{"sha": "11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmNTNiNmEwODc5ZTg1M2I4YWEzZTEyYjgxYjU2ZjE1ODJjMzhmNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-09-06T05:52:51Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-09-06T05:52:51Z"}, "message": "tree.c (walk_tree): Expose tail recursion.\n\n\t* tree.c (walk_tree): Expose tail recursion.\n\t(walk_stmt_tree): New function.\n\t* cp-tree.h: Prototype walk_stmt_tree.\n\t* semantics.c (prune_unused_decls): Operate on SCOPE_STMTs not\n\tthe BLOCKs directly.  If a BLOCK has no variables after\n\tpruning, discard it.\n\t(finish_stmt_tree): Use walk_stmt_tree.  No need to save and\n\trestore the line number.\n\nFrom-SVN: r36178", "tree": {"sha": "70e50e84e9a226d6722859ba63eba0a30b37d9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e50e84e9a226d6722859ba63eba0a30b37d9c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/comments", "author": null, "committer": null, "parents": [{"sha": "3392dafcfdcbe74f8c60e14fa0f3ea73363552ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3392dafcfdcbe74f8c60e14fa0f3ea73363552ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3392dafcfdcbe74f8c60e14fa0f3ea73363552ab"}], "stats": {"total": 121, "additions": 103, "deletions": 18}, "files": [{"sha": "d0a48517ff4168e53446c26abef5dcbfd6e7bea0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "patch": "@@ -1,3 +1,14 @@\n+2000-09-05  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* tree.c (walk_tree): Expose tail recursion.\n+\t(walk_stmt_tree): New function.\n+\t* cp-tree.h: Prototype walk_stmt_tree.\n+\t* semantics.c (prune_unused_decls): Operate on SCOPE_STMTs not\n+\tthe BLOCKs directly.  If a BLOCK has no variables after\n+\tpruning, discard it.\n+\t(finish_stmt_tree): Use walk_stmt_tree.  No need to save and\n+\trestore the line number.\n+\n 2000-09-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Makefile.in (CXX_TREE_H): Add dependency on HTAB_H."}, {"sha": "0a62dfe796ad810e878ebc275887e1a5acc71269", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "patch": "@@ -4543,6 +4543,9 @@ extern tree walk_tree                           PARAMS ((tree *,\n extern tree walk_tree_without_duplicates        PARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n \t\t\t\t\t\t\t void *));\n+extern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n+\t\t\t\t\t\t\t walk_tree_fn,\n+\t\t\t\t\t\t\t void *));\n extern tree copy_tree_r                         PARAMS ((tree *, int *, void *));\n extern int cp_valid_lang_attribute\t\tPARAMS ((tree, tree, tree, tree));\n extern tree make_ptrmem_cst                     PARAMS ((tree, tree));"}, {"sha": "295c37a7de39ebea940c116c60769571f54dd8bb", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "patch": "@@ -2274,21 +2274,28 @@ prune_unused_decls (tp, walk_subtrees, data)\n \t  return prune_unused_decls (tp, walk_subtrees, data);\n \t}\n     }\n-  else if (TREE_CODE (t) == BLOCK)\n+  else if (TREE_CODE (t) == SCOPE_STMT)\n     {\n-      /* walk_tree doesn't inspect BLOCK_VARS, so we must do it by hand.  */\n-      tree *vp;\n+      /* Remove all unused decls from the BLOCK of this SCOPE_STMT.  */\n+      tree block = SCOPE_STMT_BLOCK (t);\n \n-      for (vp = &BLOCK_VARS (t); *vp; )\n+      if (block)\n \t{\n-\t  tree v = *vp;\n-\t  if (! TREE_USED (v) && DECL_NAME (v) && DECL_SOURCE_LINE (v) == 0)\n-\t    *vp = TREE_CHAIN (v);  /* drop */\n-\t  else\n-\t    vp = &TREE_CHAIN (v);  /* advance */\n+\t  tree *vp;\n+\n+\t  for (vp = &BLOCK_VARS (block); *vp; )\n+\t    {\n+\t      tree v = *vp;\n+\t      if (! TREE_USED (v) && DECL_NAME (v) && DECL_SOURCE_LINE (v) == 0)\n+\t\t*vp = TREE_CHAIN (v);  /* drop */\n+\t      else\n+\t\tvp = &TREE_CHAIN (v);  /* advance */\n+\t    }\n+\t  /* If there are now no variables, the entire BLOCK can be dropped.\n+\t     (This causes SCOPE_NULLIFIED_P (t) to be true.)  */\n+\t  if (BLOCK_VARS (block) == NULL_TREE)\n+\t    SCOPE_STMT_BLOCK (t) = NULL_TREE;\n \t}\n-      if (BLOCK_VARS (t) == NULL_TREE)\n-\tTREE_USED (t) = 0;\n     }\n   return NULL_TREE;\n }\n@@ -2314,18 +2321,14 @@ finish_stmt_tree (t)\n      tree *t;\n {\n   tree stmt;\n-  int old_lineno;\n   \n   /* Remove the fake extra statement added in begin_stmt_tree.  */\n   stmt = TREE_CHAIN (*t);\n   *t = stmt;\n   SET_LAST_STMT (NULL_TREE);\n \n-  /* Remove unused decls from the stmt tree.  walk_tree messes with\n-     the line number, so save/restore it.  */\n-  old_lineno = lineno;\n-  walk_tree_without_duplicates (t, prune_unused_decls, NULL);\n-  lineno = old_lineno;\n+  /* Remove unused decls from the stmt tree.  */\n+  walk_stmt_tree (t, prune_unused_decls, NULL);\n \n   if (cfun)\n     {"}, {"sha": "0f886692bbd7e47557c20298a7e927eea08f773b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f53b6a0879e853b8aa3e12b81b56f1582c38f6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=11f53b6a0879e853b8aa3e12b81b56f1582c38f6", "patch": "@@ -1319,7 +1319,8 @@ walk_tree (tp, func, data, htab)\n \t      WALK_SUBTREE (DECL_SIZE_UNIT (DECL_STMT_DECL (*tp)));\n \t    }\n \n-\t  WALK_SUBTREE (TREE_CHAIN (*tp));\n+\t  /* This can be tail-recursion optimized if we write it this way.  */\n+\t  return walk_tree (&TREE_CHAIN (*tp), func, data, htab);\n \t}\n \n       /* We didn't find what we were looking for.  */\n@@ -1454,6 +1455,73 @@ walk_tree_without_duplicates (tp, func, data)\n   return result;\n }\n \n+/* Like walk_tree, but only examines statement nodes.  We don't need a\n+   without_duplicates variant of this one because the statement tree is\n+   a tree, not a graph.  */\n+\n+tree \n+walk_stmt_tree (tp, func, data)\n+     tree *tp;\n+     walk_tree_fn func;\n+     void *data;\n+{\n+  enum tree_code code;\n+  int walk_subtrees;\n+  tree result;\n+  int i, len;\n+\n+#define WALK_SUBTREE(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = walk_stmt_tree (&(NODE), func, data);\t\\\n+      if (result)\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+  /* Skip empty subtrees.  */\n+  if (!*tp)\n+    return NULL_TREE;\n+\n+  /* Skip subtrees below non-statement nodes.  */\n+  if (!statement_code_p (TREE_CODE (*tp)))\n+    return NULL_TREE;\n+\n+  /* Call the function.  */\n+  walk_subtrees = 1;\n+  result = (*func) (tp, &walk_subtrees, data);\n+\n+  /* If we found something, return it.  */\n+  if (result)\n+    return result;\n+\n+  /* Even if we didn't, FUNC may have decided that there was nothing\n+     interesting below this point in the tree.  */\n+  if (!walk_subtrees)\n+    return NULL_TREE;\n+\n+  /* FUNC may have modified the tree, recheck that we're looking at a\n+     statement node.  */\n+  code = TREE_CODE (*tp);\n+  if (!statement_code_p (code))\n+    return NULL_TREE;\n+\n+  /* Walk over all the sub-trees of this operand.  Statement nodes never\n+     contain RTL, and we needn't worry about TARGET_EXPRs.  */\n+  len = TREE_CODE_LENGTH (code);\n+\n+  /* Go through the subtrees.  We need to do this in forward order so\n+     that the scope of a FOR_EXPR is handled properly.  */\n+  for (i = 0; i < len; ++i)\n+    WALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\n+  /* Finally visit the chain.  This can be tail-recursion optimized if\n+     we write it this way.  */\n+  return walk_stmt_tree (&TREE_CHAIN (*tp), func, data);\n+\n+#undef WALK_SUBTREE\n+}\n+\n /* Called from count_trees via walk_tree.  */\n \n static tree"}]}