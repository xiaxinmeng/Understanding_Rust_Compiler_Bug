{"sha": "4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJmYjhlMTE0M2Y0NjI2ZTEyZGYzNDhhMWJkZTM0MDMwYzBmYjJlNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-03T21:25:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-03T21:25:10Z"}, "message": "re PR target/83641 (-fstack-clash-protection generates incorrect CFI on i386)\n\n\tPR target/83641\n\t* config/i386/i386.c (ix86_adjust_stack_and_probe_stack_clash): For\n\tnoreturn probe, use gen_pop instead of ix86_emit_restore_reg_using_pop,\n\tonly set RTX_FRAME_RELATED_P on both the push and pop if cfa_reg is sp\n\tand add REG_CFA_ADJUST_CFA notes in that case to both insns.\n\n\tPR target/83641\n\t* config/i386/i386.c (ix86_adjust_stack_and_probe_stack_clash): Do not\n\texplicitly probe *sp in a noreturn function if there were any callee\n\tregister saves or frame pointer is needed.\n\n\tPR target/83641\n\t* gcc.target/i386/stack-check-17.c: New test.\n\t* gcc.target/i386/stack-check-12.c: Drop unnecessary asm.\n\nFrom-SVN: r256191", "tree": {"sha": "b9a574fdad7d1e20dfd6905d89379d0a719e9370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9a574fdad7d1e20dfd6905d89379d0a719e9370"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/comments", "author": null, "committer": null, "parents": [{"sha": "e3bd17639b20e009238b15b2354bb0e87e29703e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3bd17639b20e009238b15b2354bb0e87e29703e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3bd17639b20e009238b15b2354bb0e87e29703e"}], "stats": {"total": 84, "additions": 79, "deletions": 5}, "files": [{"sha": "7aa0920fc653608809e0710b5b7a5de5f5ae3ea0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "patch": "@@ -1,3 +1,17 @@\n+2017-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\tPR target/83641\n+\t* config/i386/i386.c (ix86_adjust_stack_and_probe_stack_clash): For\n+\tnoreturn probe, use gen_pop instead of ix86_emit_restore_reg_using_pop,\n+\tonly set RTX_FRAME_RELATED_P on both the push and pop if cfa_reg is sp\n+\tand add REG_CFA_ADJUST_CFA notes in that case to both insns.\n+\n+\tPR target/83641\n+\t* config/i386/i386.c (ix86_adjust_stack_and_probe_stack_clash): Do not\n+\texplicitly probe *sp in a noreturn function if there were any callee\n+\tregister saves or frame pointer is needed.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/83621"}, {"sha": "c363de93e0238980213b2bbe443d1327b639d589", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "patch": "@@ -12217,21 +12217,39 @@ ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size)\n      pointer could be anywhere in the guard page.  The safe thing\n      to do is emit a probe now.\n \n+     The probe can be avoided if we have already emitted any callee\n+     register saves into the stack or have a frame pointer (which will\n+     have been saved as well).  Those saves will function as implicit\n+     probes.\n+\n      ?!? This should be revamped to work like aarch64 and s390 where\n      we track the offset from the most recent probe.  Normally that\n      offset would be zero.  For a noreturn function we would reset\n      it to PROBE_INTERVAL - (STACK_BOUNDARY / BITS_PER_UNIT).   Then\n      we just probe when we cross PROBE_INTERVAL.  */\n-  if (TREE_THIS_VOLATILE (cfun->decl))\n+  if (TREE_THIS_VOLATILE (cfun->decl)\n+      && !(m->frame.nregs || m->frame.nsseregs || frame_pointer_needed))\n     {\n       /* We can safely use any register here since we're just going to push\n \t its value and immediately pop it back.  But we do try and avoid\n \t argument passing registers so as not to introduce dependencies in\n \t the pipeline.  For 32 bit we use %esi and for 64 bit we use %rax.  */\n       rtx dummy_reg = gen_rtx_REG (word_mode, TARGET_64BIT ? AX_REG : SI_REG);\n-      rtx_insn *insn = emit_insn (gen_push (dummy_reg));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      ix86_emit_restore_reg_using_pop (dummy_reg);\n+      rtx_insn *insn_push = emit_insn (gen_push (dummy_reg));\n+      rtx_insn *insn_pop = emit_insn (gen_pop (dummy_reg));\n+      m->fs.sp_offset -= UNITS_PER_WORD;\n+      if (m->fs.cfa_reg == stack_pointer_rtx)\n+\t{\n+\t  m->fs.cfa_offset -= UNITS_PER_WORD;\n+\t  rtx x = plus_constant (Pmode, stack_pointer_rtx, -UNITS_PER_WORD);\n+\t  x = gen_rtx_SET (stack_pointer_rtx, x);\n+\t  add_reg_note (insn_push, REG_CFA_ADJUST_CFA, x);\n+\t  RTX_FRAME_RELATED_P (insn_push) = 1;\n+\t  x = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);\n+\t  x = gen_rtx_SET (stack_pointer_rtx, x);\n+\t  add_reg_note (insn_pop, REG_CFA_ADJUST_CFA, x);\n+\t  RTX_FRAME_RELATED_P (insn_pop) = 1;\n+\t}\n       emit_insn (gen_blockage ());\n     }\n "}, {"sha": "1b8e7ad6ea5a41e366af964a3847c3a568d3419d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Jeff Law  <law@redhat.com>\n+\n+\tPR target/83641\n+\t* gcc.target/i386/stack-check-17.c: New test.\n+\t* gcc.target/i386/stack-check-12.c: Drop unnecessary asm.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/83621"}, {"sha": "74d3a26cad1f2592a558fcd6045bdbebb122cce7", "filename": "gcc/testsuite/gcc.target/i386/stack-check-12.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-12.c?ref=4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "patch": "@@ -7,7 +7,6 @@ __attribute__ ((noreturn)) void exit (int);\n __attribute__ ((noreturn)) void\n f (void)\n {\n-  asm volatile (\"nop\" ::: \"edi\");\n   exit (1);\n }\n "}, {"sha": "d2ef83b348af7a94361a73b1170d603069ff4f21", "filename": "gcc/testsuite/gcc.target/i386/stack-check-17.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfb8e1143f4626e12df348a1bde34030c0fb2e7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-17.c?ref=4bfb8e1143f4626e12df348a1bde34030c0fb2e7", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection -mtune=generic -fomit-frame-pointer\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+\n+int x0, x1;\n+void f1 (void);\n+void f2 (int, int);\n+\n+__attribute__ ((noreturn))\n+void\n+f3 (void)\n+{ \n+  int y0 = x0;\n+  int y1 = x1;\n+  f1 ();\n+  f2 (y0, y1);\n+  while (1);\n+}\n+\n+/* Verify no explicit probes.  */\n+/* { dg-final { scan-assembler-not \"or\\[ql\\]\" } } */\n+\n+/* We also want to verify we did not use a push/pop sequence\n+   to probe *sp as the callee register saves are sufficient\n+   to probe *sp.\n+\n+   y0/y1 are live across the call and thus must be allocated\n+   into either a stack slot or callee saved register.  The former\n+   would be rather dumb.  So assume it does not happen.\n+\n+   So search for two/four pushes for the callee register saves/argument\n+   pushes and no pops (since the function has no reachable epilogue).  */\n+/* { dg-final { scan-assembler-times \"push\\[ql\\]\" 2 { target { ! ia32 } } } }  */\n+/* { dg-final { scan-assembler-times \"push\\[ql\\]\" 4 { target { ia32 } } } }  */\n+/* { dg-final { scan-assembler-not \"pop\" } } */\n+"}]}