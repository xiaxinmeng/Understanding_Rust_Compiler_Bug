{"sha": "9f857be34d9c17730e590ee95d0d39953bc1bad4", "node_id": "C_kwDOANBUbNoAKDlmODU3YmUzNGQ5YzE3NzMwZTU5MGVlOTVkMGQzOTk1M2JjMWJhZDQ", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2022-07-07T19:29:21Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-13T10:01:18Z"}, "message": "[Ada] Add support for defaulted Storage_Model_Type aspect and subaspects\n\nThe compiler currently rejects a Storage_Model_Type aspect that is not\nspecified with an aggregate, or that has an aggregate that does not\nspecify all defined \"subaspects\" (Address_Type, Null_Address, Allocate,\netc.). The RFC for this feature defines the aspect to fully default to\nthe native memory model when no aggregate is given, and also allows any\nsubaspects to be specified and others to default in the case where the\naddress type is the native address type (System.Address), whether that\naddress type is explicitly specified or defaulted. This set of changes\nnow supports that defaulting semantics. Note that the subaspect\nretrieval functions in Sem_Util.Storage_Model_Support (which are called\nby the compiler back ends) will now return Empty for any subprogram\nsubaspects (Allocate, Deallocate, etc.) that are defaulted in the aspect\n(that is, in the native model case where the address type is\nSystem.Address).  Also in the native case, retrieval of defaulted\nsubaspects Address_Type and Null_Address will return the entities for\nSystem.Address and System.Null_Address, respectively. Additionally,\nerror checks for multiple associations given for the same subaspect are\nnow done.\n\ngcc/ada/\n\n\t* aspects.ads (Aspect_Argument): Change the association for\n\tAspect_Storage_Model_Type from Expression to\n\tOptional_Expression.\n\t* exp_util.ads (Find_Storage_Op): Update comment to indicate\n\tthat Empty can be returned in the case where a storage-model\n\toperation is defaulted.\n\t* exp_util.adb (Find_Storage_Op): Allow the function to return\n\tEmpty in Storage_Model_Type case rather than raising\n\tProgram_Error, so that Procedure_To_Call fields in N_Allocator\n\tand N_Free_Statement nodes will be set to Empty in the defaulted\n\tnative storage-model case.\n\t* sem_ch13.adb: Add with and use of System.Case_Util (and\n\treformat context_clause).\n\t(Check_Aspect_At_Freeze_Point): Return with no action for a\n\tStorage_Model_Type aspect with no expression (fully-defaulted\n\tnative memory-model case).\n\t(Resolve_Storage_Model_Type_Argument): If an Address_Type has\n\tnot been explicitly specified, then set Addr_Type to denote type\n\tSystem.Address.\n\t(Validate_Storage_Model_Type_Aspect): Return immediately in the\n\tcase where the aspect has no Expression (fully-defaulted native\n\tmemory-model case).  No longer issue an error when Address_Type\n\tisn't specified, and instead use type System.Address as the\n\tdefault address type. When the address type is\n\tSystem.Address (whether specified or defaulted), no longer issue\n\terrors for any other \"subaspects\" that aren't specified, since\n\tin that case those are allowed to default as well. Remove ???\n\tcomment about needing to check for duplicates, which is now\n\taddressed.\n\t(Check_And_Resolve_Storage_Model_Type_Argument): New procedure\n\tto check that an association for a storage-model subaspect in\n\tthe aggregate has not been specified earlier in the aggregate,\n\tand to then resolve the expression of the association and save\n\tthe resolved entity. Called by\n\tValidate_Storage_Model_Type_Aspect.\n\t* sem_util.ads (Storage_Model_Support): Update comments on specs\n\tof the functions Get_Storage_Model_Type_Entity,\n\tStorage_Model_Address_Type, and Storage_Model_Null_Address to\n\tindicate the behavior when the address type is System.Address\n\t(the native memory-model case).\n\t* sem_util.adb\n\t(Storage_Model_Support.Get_Storage_Model_Type_Entity): Suppress\n\tthe search for the given subaspect name (Nam) when the\n\tStorage_Model_Type aspect is fully defaulted (i.e., no\n\tExpression is present) and simply return. In cases where the\n\tsearch is done, but no association that matches Nam is found,\n\treturn System.Address for the Name_Address_Type case, return\n\tSystem.Null_Address for the Name_Null_Address case, and return\n\tEmpty for all other cases.", "tree": {"sha": "a4b6e066ade6269aedbd8fba88697fe777083e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4b6e066ade6269aedbd8fba88697fe777083e45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f857be34d9c17730e590ee95d0d39953bc1bad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f857be34d9c17730e590ee95d0d39953bc1bad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f857be34d9c17730e590ee95d0d39953bc1bad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f857be34d9c17730e590ee95d0d39953bc1bad4/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6beeff028f40697a73ac01c3ee715960507849e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6beeff028f40697a73ac01c3ee715960507849e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6beeff028f40697a73ac01c3ee715960507849e4"}], "stats": {"total": 331, "additions": 202, "deletions": 129}, "files": [{"sha": "6559cda293a2d03bf76959ee1dd20ccf99d33bf4", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=9f857be34d9c17730e590ee95d0d39953bc1bad4", "patch": "@@ -441,7 +441,7 @@ package Aspects is\n       Aspect_SPARK_Mode                 => Optional_Name,\n       Aspect_Stable_Properties          => Expression,\n       Aspect_Static_Predicate           => Expression,\n-      Aspect_Storage_Model_Type         => Expression,\n+      Aspect_Storage_Model_Type         => Optional_Expression,\n       Aspect_Storage_Pool               => Name,\n       Aspect_Storage_Size               => Expression,\n       Aspect_Stream_Size                => Expression,"}, {"sha": "3286bf6c89634e603802b72f7b05a7921d301467", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=9f857be34d9c17730e590ee95d0d39953bc1bad4", "patch": "@@ -6406,16 +6406,7 @@ package body Exp_Util is\n \n    begin\n       if Has_Storage_Model_Type_Aspect (Typ) then\n-         declare\n-            SMT_Op : constant Entity_Id :=\n-                       Get_Storage_Model_Type_Entity (Typ, Nam);\n-         begin\n-            if not Present (SMT_Op) then\n-               raise Program_Error;\n-            else\n-               return SMT_Op;\n-            end if;\n-         end;\n+         return Get_Storage_Model_Type_Entity (Typ, Nam);\n \n       --  Otherwise we assume that Typ is a descendant of Root_Storage_Pool\n "}, {"sha": "d854672ccd8eb0aae7f92d9fea3a392cb64870e6", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=9f857be34d9c17730e590ee95d0d39953bc1bad4", "patch": "@@ -623,8 +623,10 @@ package Exp_Util is\n    --  specifies aspect Storage_Model_Type, returns the Entity_Id of the\n    --  subprogram associated with Nam, which must either be a primitive op of\n    --  the type in the case of a storage pool, or the operation corresponding\n-   --  to Nam as specified in the aspect Storage_Model_Type. It is an error if\n-   --  no operation corresponding to the given name is found.\n+   --  to Nam as specified in the aspect Storage_Model_Type. In the case of\n+   --  aspect Storage_Model_Type, returns Empty when no operation is found,\n+   --  indicating that the operation is defaulted in the aspect (can occur in\n+   --  the case where the storage-model address type is System.Address).\n \n    function Find_Hook_Context (N : Node_Id) return Node_Id;\n    --  Determine a suitable node on which to attach actions related to N that"}, {"sha": "9c3ae6fe33d0da17419e666f6377d2438011b44d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 158, "deletions": 102, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9f857be34d9c17730e590ee95d0d39953bc1bad4", "patch": "@@ -23,59 +23,60 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;        use Aspects;\n-with Atree;          use Atree;\n-with Checks;         use Checks;\n-with Contracts;      use Contracts;\n-with Debug;          use Debug;\n-with Einfo;          use Einfo;\n-with Einfo.Entities; use Einfo.Entities;\n-with Einfo.Utils;    use Einfo.Utils;\n-with Elists;         use Elists;\n-with Errout;         use Errout;\n-with Exp_Ch3;        use Exp_Ch3;\n-with Exp_Disp;       use Exp_Disp;\n-with Exp_Tss;        use Exp_Tss;\n-with Exp_Util;       use Exp_Util;\n-with Freeze;         use Freeze;\n-with Ghost;          use Ghost;\n-with Lib;            use Lib;\n-with Lib.Xref;       use Lib.Xref;\n-with Namet;          use Namet;\n-with Nlists;         use Nlists;\n-with Nmake;          use Nmake;\n-with Opt;            use Opt;\n-with Par_SCO;        use Par_SCO;\n-with Restrict;       use Restrict;\n-with Rident;         use Rident;\n-with Rtsfind;        use Rtsfind;\n-with Sem;            use Sem;\n-with Sem_Aux;        use Sem_Aux;\n-with Sem_Case;       use Sem_Case;\n-with Sem_Cat;        use Sem_Cat;\n-with Sem_Ch3;        use Sem_Ch3;\n-with Sem_Ch6;        use Sem_Ch6;\n-with Sem_Ch7;        use Sem_Ch7;\n-with Sem_Ch8;        use Sem_Ch8;\n-with Sem_Dim;        use Sem_Dim;\n-with Sem_Eval;       use Sem_Eval;\n-with Sem_Prag;       use Sem_Prag;\n-with Sem_Res;        use Sem_Res;\n-with Sem_Type;       use Sem_Type;\n-with Sem_Util;       use Sem_Util;\n-with Sem_Warn;       use Sem_Warn;\n-with Sinfo;          use Sinfo;\n-with Sinfo.Nodes;    use Sinfo.Nodes;\n-with Sinfo.Utils;    use Sinfo.Utils;\n-with Sinput;         use Sinput;\n-with Snames;         use Snames;\n-with Stand;          use Stand;\n+with Aspects;          use Aspects;\n+with Atree;            use Atree;\n+with Checks;           use Checks;\n+with Contracts;        use Contracts;\n+with Debug;            use Debug;\n+with Einfo;            use Einfo;\n+with Einfo.Entities;   use Einfo.Entities;\n+with Einfo.Utils;      use Einfo.Utils;\n+with Elists;           use Elists;\n+with Errout;           use Errout;\n+with Exp_Ch3;          use Exp_Ch3;\n+with Exp_Disp;         use Exp_Disp;\n+with Exp_Tss;          use Exp_Tss;\n+with Exp_Util;         use Exp_Util;\n+with Freeze;           use Freeze;\n+with Ghost;            use Ghost;\n+with Lib;              use Lib;\n+with Lib.Xref;         use Lib.Xref;\n+with Namet;            use Namet;\n+with Nlists;           use Nlists;\n+with Nmake;            use Nmake;\n+with Opt;              use Opt;\n+with Par_SCO;          use Par_SCO;\n+with Restrict;         use Restrict;\n+with Rident;           use Rident;\n+with Rtsfind;          use Rtsfind;\n+with Sem;              use Sem;\n+with Sem_Aux;          use Sem_Aux;\n+with Sem_Case;         use Sem_Case;\n+with Sem_Cat;          use Sem_Cat;\n+with Sem_Ch3;          use Sem_Ch3;\n+with Sem_Ch6;          use Sem_Ch6;\n+with Sem_Ch7;          use Sem_Ch7;\n+with Sem_Ch8;          use Sem_Ch8;\n+with Sem_Dim;          use Sem_Dim;\n+with Sem_Eval;         use Sem_Eval;\n+with Sem_Prag;         use Sem_Prag;\n+with Sem_Res;          use Sem_Res;\n+with Sem_Type;         use Sem_Type;\n+with Sem_Util;         use Sem_Util;\n+with Sem_Warn;         use Sem_Warn;\n+with Sinfo;            use Sinfo;\n+with Sinfo.Nodes;      use Sinfo.Nodes;\n+with Sinfo.Utils;      use Sinfo.Utils;\n+with Sinput;           use Sinput;\n+with Snames;           use Snames;\n+with Stand;            use Stand;\n+with System.Case_Util; use System.Case_Util;\n with Table;\n-with Targparm;       use Targparm;\n-with Ttypes;         use Ttypes;\n-with Tbuild;         use Tbuild;\n-with Urealp;         use Urealp;\n-with Warnsw;         use Warnsw;\n+with Targparm;         use Targparm;\n+with Ttypes;           use Ttypes;\n+with Tbuild;           use Tbuild;\n+with Urealp;           use Urealp;\n+with Warnsw;           use Warnsw;\n \n with GNAT.Heap_Sort_G;\n \n@@ -11356,6 +11357,16 @@ package body Sem_Ch13 is\n             return;\n \n          when Aspect_Storage_Model_Type =>\n+\n+            --  The aggregate argument of Storage_Model_Type is optional, and\n+            --  when not present the aspect defaults to the native storage\n+            --  model (where the address type is System.Address, and other\n+            --  arguments default to corresponding native storage operations).\n+\n+            if No (Expression (ASN)) then\n+               return;\n+            end if;\n+\n             T := Entity (ASN);\n \n             declare\n@@ -16559,12 +16570,14 @@ package body Sem_Ch13 is\n \n          return;\n \n+      --  If Addr_Type is not present as the first association, then we default\n+      --  it to System.Address.\n+\n       elsif not Present (Addr_Type) then\n-         Error_Msg_N (\"argument association for Address_Type missing; \"\n-                         & \"must be specified as first aspect argument\", N);\n-         return;\n+         Addr_Type := RTE (RE_Address);\n+      end if;\n \n-      elsif Nam = Name_Null_Address then\n+      if Nam = Name_Null_Address then\n          if not Is_Entity_Name (N)\n            or else not Is_Constant_Object (Entity (N))\n            or else\n@@ -17335,9 +17348,10 @@ package body Sem_Ch13 is\n    procedure Validate_Storage_Model_Type_Aspect\n      (Typ : Entity_Id; ASN : Node_Id)\n    is\n-      Assoc  : Node_Id;\n-      Choice : Entity_Id;\n-      Expr   : Node_Id;\n+      Assoc       : Node_Id;\n+      Choice      : Entity_Id;\n+      Choice_Name : Name_Id;\n+      Expr        : Node_Id;\n \n       Address_Type_Id : Entity_Id := Empty;\n       Null_Address_Id : Entity_Id := Empty;\n@@ -17347,7 +17361,47 @@ package body Sem_Ch13 is\n       Copy_To_Id      : Entity_Id := Empty;\n       Storage_Size_Id : Entity_Id := Empty;\n \n+      procedure Check_And_Resolve_Storage_Model_Type_Argument\n+        (Expr        : Node_Id;\n+         Typ         : Entity_Id;\n+         Argument_Id : in out Entity_Id;\n+         Nam         : Name_Id);\n+      --  Checks that the subaspect for Nam has not already been specified for\n+      --  Typ's Storage_Model_Type aspect (i.e., checks Argument_Id = Empty),\n+      --  resolves Expr, and sets Argument_Id to the entity resolved for Expr.\n+\n+      procedure Check_And_Resolve_Storage_Model_Type_Argument\n+        (Expr        : Node_Id;\n+         Typ         : Entity_Id;\n+         Argument_Id : in out Entity_Id;\n+         Nam         : Name_Id)\n+      is\n+         Name_String : constant String := To_Mixed (Get_Name_String (Nam));\n+\n+      begin\n+         if Present (Argument_Id) then\n+            Error_Msg_String (1 .. Name_String'Length) := Name_String;\n+            Error_Msg_Strlen := Name_String'Length;\n+\n+            Error_Msg_N (\"~ already specified\", Expr);\n+         end if;\n+\n+         Resolve_Storage_Model_Type_Argument (Expr, Typ, Address_Type_Id, Nam);\n+         Argument_Id := Entity (Expr);\n+      end Check_And_Resolve_Storage_Model_Type_Argument;\n+\n+   --  Start of processing for Validate_Storage_Model_Type_Aspect\n+\n    begin\n+      --  The aggregate argument of Storage_Model_Type is optional, and when\n+      --  not present the aspect defaults to the native storage model (where\n+      --  the address type is System.Address, and other arguments default to\n+      --  the corresponding native storage operations).\n+\n+      if No (Expression (ASN)) then\n+         return;\n+      end if;\n+\n       --  Each expression must resolve to an entity of the right kind or proper\n       --  profile.\n \n@@ -17358,65 +17412,67 @@ package body Sem_Ch13 is\n \n          Choice := First (Choices (Assoc));\n \n+         Choice_Name := Chars (Choice);\n+\n          if Nkind (Choice) /= N_Identifier or else Present (Next (Choice)) then\n             Error_Msg_N (\"illegal name in association\", Choice);\n \n-         elsif Chars (Choice) = Name_Address_Type then\n+         elsif Choice_Name = Name_Address_Type then\n             if Assoc /= First (Component_Associations (Expression (ASN))) then\n                Error_Msg_N (\"Address_Type must be first association\", Choice);\n             end if;\n \n-            Resolve_Storage_Model_Type_Argument\n+            Check_And_Resolve_Storage_Model_Type_Argument\n               (Expr, Typ, Address_Type_Id, Name_Address_Type);\n-            Address_Type_Id := Entity (Expr);\n \n-         --  Shouldn't we check for duplicates of the same subaspect name,\n-         --  and issue an error in such cases???\n+         else\n+            --  It's allowed to leave out the Address_Type argument, in which\n+            --  case the address type is defined to default to System.Address.\n \n-         elsif not Present (Address_Type_Id) then\n-            Error_Msg_N\n-              (\"Address_Type missing, must be first association\", Choice);\n-\n-         elsif Chars (Choice) = Name_Null_Address then\n-            Resolve_Storage_Model_Type_Argument\n-              (Expr, Typ, Address_Type_Id, Name_Null_Address);\n-            Null_Address_Id := Entity (Expr);\n-\n-         elsif Chars (Choice) = Name_Allocate then\n-            Resolve_Storage_Model_Type_Argument\n-              (Expr, Typ, Address_Type_Id, Name_Allocate);\n-            Allocate_Id := Entity (Expr);\n-\n-         elsif Chars (Choice) = Name_Deallocate then\n-            Resolve_Storage_Model_Type_Argument\n-              (Expr, Typ, Address_Type_Id, Name_Deallocate);\n-            Deallocate_Id := Entity (Expr);\n-\n-         elsif Chars (Choice) = Name_Copy_From then\n-            Resolve_Storage_Model_Type_Argument\n-              (Expr, Typ, Address_Type_Id, Name_Copy_From);\n-            Copy_From_Id := Entity (Expr);\n-\n-         elsif Chars (Choice) = Name_Copy_To then\n-            Resolve_Storage_Model_Type_Argument\n-              (Expr, Typ, Address_Type_Id, Name_Copy_To);\n-            Copy_To_Id := Entity (Expr);\n-\n-         elsif Chars (Choice) = Name_Storage_Size then\n-            Resolve_Storage_Model_Type_Argument\n-              (Expr, Typ, Address_Type_Id, Name_Storage_Size);\n-            Storage_Size_Id := Entity (Expr);\n+            if No (Address_Type_Id) then\n+               Address_Type_Id := RTE (RE_Address);\n+            end if;\n \n-         else\n-            Error_Msg_N\n-              (\"invalid name for Storage_Model_Type argument\", Choice);\n+            if Choice_Name = Name_Null_Address then\n+               Check_And_Resolve_Storage_Model_Type_Argument\n+                 (Expr, Typ, Null_Address_Id, Name_Null_Address);\n+\n+            elsif Choice_Name = Name_Allocate then\n+               Check_And_Resolve_Storage_Model_Type_Argument\n+                 (Expr, Typ, Allocate_Id, Name_Allocate);\n+\n+            elsif Choice_Name = Name_Deallocate then\n+               Check_And_Resolve_Storage_Model_Type_Argument\n+                 (Expr, Typ, Deallocate_Id, Name_Deallocate);\n+\n+            elsif Choice_Name = Name_Copy_From then\n+               Check_And_Resolve_Storage_Model_Type_Argument\n+                 (Expr, Typ, Copy_From_Id, Name_Copy_From);\n+\n+            elsif Choice_Name = Name_Copy_To then\n+               Check_And_Resolve_Storage_Model_Type_Argument\n+                 (Expr, Typ, Copy_To_Id, Name_Copy_To);\n+\n+            elsif Choice_Name = Name_Storage_Size then\n+               Check_And_Resolve_Storage_Model_Type_Argument\n+                 (Expr, Typ, Storage_Size_Id, Name_Storage_Size);\n+\n+            else\n+               Error_Msg_N\n+                 (\"invalid name for Storage_Model_Type argument\", Choice);\n+            end if;\n          end if;\n \n          Next (Assoc);\n       end loop;\n \n-      if No (Address_Type_Id) then\n-         Error_Msg_N (\"match for Address_Type not found\", ASN);\n+      --  If Address_Type has been specified as or defaults to System.Address,\n+      --  then other \"subaspect\" arguments can be specified, but are optional.\n+      --  Otherwise, all other arguments are required and an error is flagged\n+      --  about any that are missing.\n+\n+      if Address_Type_Id = RTE (RE_Address) then\n+         return;\n \n       elsif No (Null_Address_Id) then\n          Error_Msg_N (\"match for Null_Address primitive not found\", ASN);"}, {"sha": "13ffb11f0a9af8ebd45734b408042582db83b59c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9f857be34d9c17730e590ee95d0d39953bc1bad4", "patch": "@@ -32575,18 +32575,37 @@ package body Sem_Util is\n            Find_Value_Of_Aspect (Typ, Aspect_Storage_Model_Type);\n \n       begin\n-         pragma Assert (Present (SMT_Aspect_Value));\n+         --  When the aspect has an aggregate expression, search through it\n+         --  to locate a match for the name of the given \"subaspect\" and return\n+         --  the entity of the aggregate association's expression.\n+\n+         if Present (SMT_Aspect_Value) then\n+            Assoc := First (Component_Associations (SMT_Aspect_Value));\n+            while Present (Assoc) loop\n+               if Chars (First (Choices (Assoc))) = Nam then\n+                  return Entity (Expression (Assoc));\n+               end if;\n \n-         Assoc := First (Component_Associations (SMT_Aspect_Value));\n-         while Present (Assoc) loop\n-            if Chars (First (Choices (Assoc))) = Nam then\n-               return Entity (Expression (Assoc));\n-            end if;\n+               Next (Assoc);\n+            end loop;\n+         end if;\n \n-            Next (Assoc);\n-         end loop;\n+         --  The aggregate argument of Storage_Model_Type is optional, and when\n+         --  not present the aspect defaults to the native storage model, where\n+         --  the address type is System.Address. In that case, we return\n+         --  System.Address for Name_Address_Type and System.Null_Address for\n+         --  Name_Null_Address, but return Empty for other cases, and leave it\n+         --  to the back end to map those to the appropriate native operations.\n \n-         return Empty;\n+         if Nam = Name_Address_Type then\n+            return RTE (RE_Address);\n+\n+         elsif Nam = Name_Null_Address then\n+            return RTE (RE_Null_Address);\n+\n+         else\n+            return Empty;\n+         end if;\n       end Get_Storage_Model_Type_Entity;\n \n       --------------------------------"}, {"sha": "dde5b27faa33bac9758d6961826bc943c41179e0", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f857be34d9c17730e590ee95d0d39953bc1bad4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9f857be34d9c17730e590ee95d0d39953bc1bad4", "patch": "@@ -3680,21 +3680,26 @@ package Sem_Util is\n       --  Given a type with aspect Storage_Model_Type or an object of such a\n       --  type, and Nam denoting the name of one of the argument kinds allowed\n       --  for that aspect, returns the Entity_Id corresponding to the entity\n-      --  associated with Nam in the aspect. If such an entity is not present,\n-      --  then returns Empty. (Note: This function is modeled on function\n-      --  Get_Iterable_Type_Primitive.)\n+      --  associated with Nam in the aspect. If an entity was not explicitly\n+      --  specified for Nam, then returns Empty, except that in the defaulted\n+      --  Address_Type case, System.Address will be returned, and in the\n+      --  defaulted Null_Address case, System.Null_Address will be returned.\n+      --  (Note: This function is modeled on Get_Iterable_Type_Primitive.)\n \n       function Storage_Model_Address_Type\n         (SM_Obj_Or_Type : Entity_Id) return Entity_Id;\n       --  Given a type with aspect Storage_Model_Type or an object of such a\n       --  type, returns the type specified for the Address_Type choice in that\n-      --  aspect; returns Empty if the type isn't specified.\n+      --  aspect; returns type System.Address if the address type was not\n+      --  explicitly specified (indicating use of the native memory model).\n \n       function Storage_Model_Null_Address\n         (SM_Obj_Or_Type : Entity_Id) return Entity_Id;\n       --  Given a type with aspect Storage_Model_Type or an object of such a\n       --  type, returns the constant specified for the Null_Address choice in\n-      --  that aspect; returns Empty if the constant object isn't specified.\n+      --  that aspect; returns Empty if the constant object isn't specified,\n+      --  unless the native memory model is in use (System.Address), in which\n+      --  case it returns System.Null_Address.\n \n       function Storage_Model_Allocate\n         (SM_Obj_Or_Type : Entity_Id) return Entity_Id;"}]}