{"sha": "12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJlMGM0MWMxMTNlNjg4NTRlYzcxZjA1OWM3ZGMxOWUwM2E3ZGNmNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-04T12:51:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-11-04T12:51:47Z"}, "message": "re PR ada/12806 (Program_Error sinput.adb:397)\n\n\t* sysdep.c: Problem discovered during IA64 VMS port.\n\t[VMS] #include <unixio.h> to get proper prototypes.\n\n\t* adaint.c:\n\tIssues discovered/problems fixed during IA64 VMS port.\n\t[VMS] #define _POSIX_EXIT for proper semantics.\n\t[VMS] #include <unixio.h> for proper prototypes.\n\t[VMS] (fork): #define IA64 version.\n\t(__gnat_os_exit): Remove unnecessary VMS specific code.\n\n\t* 3vtrasym.adb: Minor reformatting\n\tUse terminology encoded/decoded name, rather than C++ specific notion\n\tof mangling (this is the terminology used throughout GNAT).\n\n\t* einfo.h: Regenerated\n\n\t* einfo.ads, einfo.adb: Add new flag Is_Thread_Body\n\n\t* exp_ch6.adb:\n\t(Expand_N_Subprogram_Body): Handle expansion of thread body procedure\n\n\t* par-prag.adb: Add dummy entry for Thread_Body pragma\n\n\t* rtsfind.ads:\n\tAdd entries for System.Threads entities for thread body processing\n\n\t* sem_attr.adb:\n\t(Analyze_Pragma, Access attributes): Check these are not applied to a\n\tthread body, since this is not permitted\n\n\t* sem_prag.adb: Add processing for Thread_Body pragma.\n\tMinor comment fix.\n\n\t* sem_res.adb:\n\t(Resolve_Call): Check for incorrect attempt to call a thread body\n\t procedure with a direct call.\n\n\t* snames.ads, snames.adb: Add entry for Thread_Body pragma\n\tAdd names associated with thread body expansion\n\n\t* snames.h: Add entry for Thread_Body pragma\n\n\t* s-thread.adb: Add entries for thread body processing\n\tThese are dummy bodies so far\n\n\t* s-thread.ads: Add documentation on thread body handling.\n\tAdd entries for thread body processing.\n\n\t* sem_ch10.adb:\n\t(Build_Limited_Views): Return after posting an error in case of limited\n\twith_clause on subprograms, generics, instances or generic renamings\n\t(Install_Limited_Withed_Unit): Do nothing in case of limited with_clause\n\ton subprograms, generics, instances or generic renamings\n\n\t* raise.c (setup_to_install): Correct mistake in last revision; two\n\targuments out of order.\n\n\t* trans.c, cuintp.c, argv.c, aux-io.c, cal.c, errno.c, exit.c,\n\tgnatbl.c, init.c, stringt.h, utils.c, utils2.c: Update copyright\n\tnotice, missed in previous change.\n\tRemove trailing blanks and other style errors introduced in previous\n\tchange.\n\n\t* decl.c (gnat_to_gnu_field): Adjust the conditions under which we get\n\trid of the wrapper for a LJM type, ensuring we don't do that if the\n\tfield is addressable.  This avoids potential low level type view\n\tmismatches later on, for instance in a by-reference argument passing\n\tprocess.\n\n\t* decl.c (gnat_to_gnu_field): No longer check for BLKmode being\n\taligned at byte boundary.\n\n\t* decl.c (components_to_record): Do not delete the empty variants from\n\tthe end of the union type.\n\n\t* exp_ch4.adb (Expand_N_Op_Eq): Use base type when locating primitive\n\toperation for a derived type, an explicit declaration may use a local\n\tsubtype of Boolean.\n\n\t* make.adb (Gnatmake): Allow main sources on the command line with a\n\tlibrary project when it is only for compilation (no binding or\n\tlinking).\n\n\tPart of PR ada/12806:\n\n\t* ada-tree.h (TYPE_DIGITS_VALUE, SET_TYPE_DIGITS_VALUE): Save count as\n\ttree, not integer.\n\n\t* decl.c:\n\t(gnat_to_gnu_entity, case E_Floating_Point_Type): Save count as tree,\n\tnot integer.\n\n\t* targtyps.c, decl.c, misc.c,\n\tgigi.h (fp_prec_to_size, fp_size_to_prec): Temporary\n\troutines to work around change in FP sizing semantics in GCC.\n\n\t* utils.c:\n\t(build_vms_descriptor): TYPE_DIGITS_VALUE is tree, not integer.\n\n\t* gigi.h: (enumerate_modes): New function.\n\n\t* Make-lang.in: (ada/misc.o): Add real.h.\n\n\t* misc.c: (enumerate_modes): New function.\n\nFrom-SVN: r73250", "tree": {"sha": "8a2906f87ff8dae462187a72710b5203b22a6c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a2906f87ff8dae462187a72710b5203b22a6c1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/comments", "author": null, "committer": null, "parents": [{"sha": "21e9fc4735eca1010ac051b76cd361943f3e6d4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e9fc4735eca1010ac051b76cd361943f3e6d4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e9fc4735eca1010ac051b76cd361943f3e6d4a"}], "stats": {"total": 5731, "additions": 3147, "deletions": 2584}, "files": [{"sha": "85f541d018bbc7b03161cc4281a5578def5e5f2c", "filename": "gcc/ada/3vtrasym.adb", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2F3vtrasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2F3vtrasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F3vtrasym.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -97,76 +97,73 @@ package body GNAT.Traceback.Symbolic is\n        Value, Value),\n        User_Act_Proc);\n \n-   function Demangle_Ada (Mangled : String) return String;\n-   --  Demangles an Ada symbol. Removes leading \"_ada_\" and trailing\n+   function Decode_Ada_Name (Encoded_Name : String) return String;\n+   --  Decodes an Ada identifier name. Removes leading \"_ada_\" and trailing\n    --  __{DIGIT}+ or ${DIGIT}+, converts other \"__\" to '.'\n \n+   ---------------------\n+   -- Decode_Ada_Name --\n+   ---------------------\n \n-   ------------------\n-   -- Demangle_Ada --\n-   ------------------\n+   function Decode_Ada_Name (Encoded_Name : String) return String is\n+      Decoded_Name : String (1 .. Encoded_Name'Length);\n+      Pos          : Integer := Encoded_Name'First;\n+      Last         : Integer := Encoded_Name'Last;\n+      DPos         : Integer := 1;\n \n-   function Demangle_Ada (Mangled : String) return String is\n-      Demangled : String (1 .. Mangled'Length);\n-      Pos  : Integer := Mangled'First;\n-      Last : Integer := Mangled'Last;\n-      DPos : Integer := 1;\n    begin\n-\n       if Pos > Last then\n          return \"\";\n       end if;\n \n       --  Skip leading _ada_\n \n-      if Mangled'Length > 4 and then Mangled (Pos .. Pos + 4) = \"_ada_\" then\n+      if Encoded_Name'Length > 4\n+        and then Encoded_Name (Pos .. Pos + 4) = \"_ada_\"\n+      then\n          Pos := Pos + 5;\n       end if;\n \n       --  Skip trailing __{DIGIT}+ or ${DIGIT}+\n \n-      if Mangled (Last) in '0' .. '9' then\n-\n+      if Encoded_Name (Last) in '0' .. '9' then\n          for J in reverse Pos + 2 .. Last - 1 loop\n-\n-            case Mangled (J) is\n+            case Encoded_Name (J) is\n                when '0' .. '9' =>\n                   null;\n                when '$' =>\n                   Last := J - 1;\n                   exit;\n                when '_' =>\n-                  if Mangled (J - 1) = '_' then\n+                  if Encoded_Name (J - 1) = '_' then\n                      Last := J - 2;\n                   end if;\n                   exit;\n                when others =>\n                   exit;\n             end case;\n-\n          end loop;\n-\n       end if;\n \n-      --  Now just copy Mangled to Demangled, converting \"__\" to '.' on the fly\n+      --  Now just copy encoded name to decoded name, converting \"__\" to '.'\n \n       while Pos <= Last loop\n-\n-         if Mangled (Pos) = '_' and then Mangled (Pos + 1) = '_'\n-           and then Pos /= Mangled'First then\n-            Demangled (DPos) := '.';\n+         if Encoded_Name (Pos) = '_' and then Encoded_Name (Pos + 1) = '_'\n+           and then Pos /= Encoded_Name'First\n+         then\n+            Decoded_Name (DPos) := '.';\n             Pos := Pos + 2;\n+\n          else\n-            Demangled (DPos) := Mangled (Pos);\n+            Decoded_Name (DPos) := Encoded_Name (Pos);\n             Pos := Pos + 1;\n          end if;\n \n          DPos := DPos + 1;\n-\n       end loop;\n \n-      return Demangled (1 .. DPos - 1);\n-   end Demangle_Ada;\n+      return Decoded_Name (1 .. DPos - 1);\n+   end Decode_Ada_Name;\n \n    ------------------------\n    -- Symbolic_Traceback --\n@@ -225,7 +222,7 @@ package body GNAT.Traceback.Symbolic is\n                First : Integer := Len + 1;\n                Last  : Integer := First + 80 - 1;\n                Pos   : Integer;\n-               Routine_Name_D : String := Demangle_Ada\n+               Routine_Name_D : String := Decode_Ada_Name\n                  (To_Ada\n                     (Routine_Name.Data (1 .. size_t (Routine_Name.Count)),\n                      False));"}, {"sha": "44b2f882e73b616d2a1aa40d9b5719a5f874b986", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -1201,7 +1201,7 @@ ada/misc.o : ada/misc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(LANGHOOKS_DEF_H) libfuncs.h $(OPTABS_H) ada/ada.h ada/types.h \\\n    ada/atree.h ada/nlists.h ada/elists.h ada/sinfo.h ada/einfo.h ada/namet.h \\\n    ada/stringt.h ada/uintp.h ada/fe.h $(ADA_TREE_H) ada/gigi.h \\\n-   ada/adadecode.h opts.h options.h target.h\n+   ada/adadecode.h opts.h options.h target.h real.h\n \n ada/targtyps.o : ada/targtyps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    ada/ada.h ada/types.h ada/atree.h ada/nlists.h ada/elists.h ada/uintp.h \\"}, {"sha": "c7574c82f2ef8c4157d6bc462e37a66c9368259a", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -174,14 +174,14 @@ struct lang_type GTY(())\n #define TYPE_INDEX_TYPE(NODE)\t\\\n   (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n #define SET_TYPE_INDEX_TYPE(NODE, X)\t\\\n-  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(X))\n+  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n \n /* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n    Digits_Value.  */\n-#define TYPE_DIGITS_VALUE(NODE)  \\\n-  ((long) TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)))\n+#define TYPE_DIGITS_VALUE(NODE) \\\n+  (&TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))->t.generic)\n #define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n-  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *)(size_t)(X))\n+  (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n \n /* For INTEGER_TYPE, stores the RM_Size of the type.  */\n #define TYPE_RM_SIZE_INT(NODE)\tTYPE_VALUES (INTEGER_TYPE_CHECK (NODE))\n@@ -271,10 +271,9 @@ struct lang_type GTY(())\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n \n-/* This is a horrible kludge to store the loop_id of a loop into a tree\n-   node.  We need to find some other place to store it!  */\n+/* This is the loop id for a GNAT_LOOP_ID node.  */\n #define TREE_LOOP_ID(NODE) \\\n-  (((union lang_tree_node *)TREE_CHECK (NODE, GNAT_LOOP_ID))->loop_id.loop_id)\n+  ((union lang_tree_node *) TREE_CHECK (NODE, GNAT_LOOP_ID))->loop_id.loop_id\n \n /* Define fields and macros for statements.\n "}, {"sha": "674df74dad478507ae0ce63b3bcefa573abd0425", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -50,13 +50,20 @@\n \n #endif /* VxWorks */\n \n+#ifdef VMS\n+#define _POSIX_EXIT 1\n+#endif\n+\n #ifdef IN_RTS\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n \n #include <sys/stat.h>\n #include <fcntl.h>\n #include <time.h>\n+#ifdef VMS\n+#include <unixio.h>\n+#endif\n \n /* We don't have libiberty, so use malloc.  */\n #define xmalloc(S) malloc (S)\n@@ -1463,8 +1470,13 @@ __gnat_is_symbolic_link (char *name ATTRIBUTE_UNUSED)\n \n #ifdef VMS\n /* Defined in VMS header files. */\n+#if defined (__ALPHA)\n #define fork() (decc$$alloc_vfork_blocks() >= 0 ? \\\n-               LIB$GET_CURRENT_INVO_CONTEXT (decc$$get_vfork_jmpbuf()) : -1)\n+\t\tLIB$GET_CURRENT_INVO_CONTEXT (decc$$get_vfork_jmpbuf()) : -1)\n+#elif defined (__IA64)\n+#define fork() (decc$$alloc_vfork_blocks() >= 0 ? \\\n+\t\tLIB$I64_GET_CURR_INVO_CONTEXT(decc$$get_vfork_jmpbuf()) : -1)\n+#endif\n #endif\n \n #if defined (sun) && defined (__SVR4)\n@@ -1816,12 +1828,7 @@ __gnat_waitpid (int pid)\n void\n __gnat_os_exit (int status)\n {\n-#ifdef VMS\n-  /* Exit without changing 0 to 1.  */\n-  __posix_exit (status);\n-#else\n   exit (status);\n-#endif\n }\n \n /* Locate a regular file, give a Path value.  */"}, {"sha": "4f78ac21198711c67c0bd557824bd1f5ea0d8688", "filename": "gcc/ada/argv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fargv.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *         Copyright (C) 1992-2002 Free Software Foundation, Inc.           *\n+ *         Copyright (C) 1992-2003 Free Software Foundation, Inc.           *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -83,7 +83,7 @@ __gnat_len_arg (int arg_num)\n }\n \n void\n-__gnat_fill_arg ( char *a, int i)\n+__gnat_fill_arg (char *a, int i)\n {\n   strncpy (a, gnat_argv[i], strlen(gnat_argv[i]));\n }"}, {"sha": "3ff9f3ed0f84d5d1109779304f91dd3a15fda9e1", "filename": "gcc/ada/aux-io.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Faux-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Faux-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faux-io.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *           Copyright (C) 1992-2001 Free Software Foundation, Inc.         *\n+ *           Copyright (C) 1992-2003 Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -52,20 +52,20 @@ void *null_function (void);\n int c_fileno (FILE *);\n \n FILE *\n-c_stdin (void) \n-{ \n-  return stdin; \n+c_stdin (void)\n+{\n+  return stdin;\n }\n \n FILE *\n-c_stdout (void) \n-{ \n+c_stdout (void)\n+{\n   return stdout;\n }\n \n FILE *\n-c_stderr (void) \n-{ \n+c_stderr (void)\n+{\n   return stderr;\n }\n \n@@ -75,25 +75,25 @@ c_stderr (void)\n #define SEEK_END 2  /* Set file pointer to the size of the file plus offset */\n #endif\n \n-int   \n-seek_set_function (void)  \n-{ \n-  return SEEK_SET; \n+int\n+seek_set_function (void)\n+{\n+  return SEEK_SET;\n }\n \n-int   \n-seek_end_function (void)  \n-{ \n-  return SEEK_END; \n+int\n+seek_end_function (void)\n+{\n+  return SEEK_END;\n }\n \n-void *null_function (void)  \n-{ \n-  return NULL;     \n+void *null_function (void)\n+{\n+  return NULL;\n }\n \n-int \n-c_fileno (FILE *s) \n-{ \n-  return fileno (s); \n+int\n+c_fileno (FILE *s)\n+{\n+  return fileno (s);\n }"}, {"sha": "8f8930e24ebabd81279afefb0b3809ca65ef4fbf", "filename": "gcc/ada/cal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fcal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fcal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcal.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2002, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "f83f5184ee61b9cd7a7604308d030929d400cc2d", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -62,7 +62,7 @@ UI_To_gnu (Uint Input, tree type)\n   tree gnu_ret;\n \n   if (Input <= Uint_Direct_Last)\n-    gnu_ret = convert (type, build_int_2 (Input - Uint_Direct_Bias, \n+    gnu_ret = convert (type, build_int_2 (Input - Uint_Direct_Bias,\n \t\t\t\t\t  Input < Uint_Direct_Bias ? -1 : 0));\n   else\n     {"}, {"sha": "41bcfa66e89bf0736bfa0f4b88bbeec32e01edb8", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -166,7 +166,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t&& UI_Is_In_Int_Range (Esize (gnat_entity)))\n        ? MIN (UI_To_Int (Esize (gnat_entity)),\n \t      IN (kind, Float_Kind)\n-\t      ? LONG_DOUBLE_TYPE_SIZE\n+\t      ? fp_prec_to_size (LONG_DOUBLE_TYPE_SIZE)\n \t      : IN (kind, Access_Kind) ? POINTER_SIZE * 2\n \t      : LONG_LONG_TYPE_SIZE)\n        : LONG_LONG_TYPE_SIZE);\n@@ -1337,14 +1337,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_type = make_signed_type (esize);\n \t  TYPE_VAX_FLOATING_POINT_P (gnu_type) = 1;\n \t  SET_TYPE_DIGITS_VALUE (gnu_type,\n-\t\t\t\t UI_To_Int (Digits_Value (gnat_entity)));\n+\t\t\t\t UI_To_gnu (Digits_Value (gnat_entity),\n+\t\t\t\t\t    sizetype));\n \t  break;\n \t}\n \n       /* The type of the Low and High bounds can be our type if this is\n \t a type from Standard, so set them at the end of the function.  */\n       gnu_type = make_node (REAL_TYPE);\n-      TYPE_PRECISION (gnu_type) = esize;\n+      TYPE_PRECISION (gnu_type) = fp_size_to_prec (esize);\n       layout_type (gnu_type);\n       break;\n \n@@ -1560,8 +1561,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttem = gnat_to_gnu_type (Component_Type (gnat_entity));\n \n \t/* Get and validate any specified Component_Size, but if Packed,\n-\t   ignore it since the front end will have taken care of it.  Also,\n-\t   allow sizes not a multiple of Storage_Unit if packed.  */\n+\t   ignore it since the front end will have taken care of it. */\n \tgnu_comp_size\n \t  = validate_size (Component_Size (gnat_entity), tem,\n \t\t\t   gnat_entity,\n@@ -1884,8 +1884,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  /* Get and validate any specified Component_Size, but if Packed,\n-\t     ignore it since the front end will have taken care of it.  Also,\n-\t     allow sizes not a multiple of Storage_Unit if packed.  */\n+\t     ignore it since the front end will have taken care of it. */\n \t  gnu_comp_size\n \t    = validate_size (Component_Size (gnat_entity), gnu_type,\n \t\t\t     gnat_entity,\n@@ -4924,10 +4923,14 @@ gnat_to_gnu_field (Entity_Id gnat_field,\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, 0, 1);\n \n-  /* If the field's type is a left-justified modular type, make the field\n-     the type of the inner object unless it is aliases.  We don't need\n-     the the wrapper here and it can prevent packing.  */\n-  if (! Is_Aliased (gnat_field) && TREE_CODE (gnu_field_type) == RECORD_TYPE\n+  /* If the field's type is left-justified modular, the wrapper can prevent\n+     packing so we make the field the type of the inner object unless the\n+     situation forbids it. We may not do that when the field is addressable_p,\n+     typically because in that case this field may later be passed by-ref for\n+     a formal argument expecting the left justification.  The condition below\n+     is then matching the addressable_p code for COMPONENT_REF.  */\n+  if (! Is_Aliased (gnat_field) && flag_strict_aliasing\n+      && TREE_CODE (gnu_field_type) == RECORD_TYPE\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (gnu_field_type))\n     gnu_field_type = TREE_TYPE (TYPE_FIELDS (gnu_field_type));\n \n@@ -5050,17 +5053,6 @@ gnat_to_gnu_field (Entity_Id gnat_field,\n \n       if (Is_Atomic (gnat_field))\n \tcheck_ok_for_atomic (gnu_field_type, gnat_field, 0);\n-\n-      if (gnu_pos != 0 && TYPE_MODE (gnu_field_type) == BLKmode\n-\t  && (! integer_zerop (size_binop (TRUNC_MOD_EXPR, gnu_pos,\n-\t\t\t\t\t   bitsize_unit_node)))\n-\t  && TYPE_MODE (gnu_field_type) == BLKmode)\n-\t{\n-\t  post_error_ne (\"fields of& must start at storage unit boundary\",\n-\t\t\t First_Bit (Component_Clause (gnat_field)),\n-\t\t\t Etype (gnat_field));\n-\t  gnu_pos = 0;\n-\t}\n     }\n \n   /* If the record has rep clauses and this is the tag field, make a rep\n@@ -5072,17 +5064,6 @@ gnat_to_gnu_field (Entity_Id gnat_field,\n       gnu_size = TYPE_SIZE (gnu_field_type);\n     }\n \n-  /* If a size is specified and this is a BLKmode field, it must be an\n-     integral number of bytes.  */\n-  if (gnu_size != 0 && TYPE_MODE (gnu_field_type) == BLKmode\n-      && ! integer_zerop (size_binop (TRUNC_MOD_EXPR, gnu_size,\n-\t\t\t\t      bitsize_unit_node)))\n-    {\n-      post_error_ne (\"size of fields of& must be multiple of a storage unit\",\n-\t\t     gnat_field, Etype (gnat_field));\n-      gnu_pos = gnu_size = 0;\n-    }\n-\n   /* We need to make the size the maximum for the type if it is\n      self-referential and an unconstrained type.  In that case, we can't\n      pack the field since we can't make a copy to align it.  */\n@@ -5341,11 +5322,11 @@ components_to_record (tree gnu_record_type,\n \t  gnu_variant_list = gnu_field;\n \t}\n \n-      /* We can delete any empty variants from the end.  This may leave none\n-\t left.  Note we cannot delete variants from anywhere else.  */\n-      while (gnu_variant_list != 0\n-\t     && TYPE_FIELDS (TREE_TYPE (gnu_variant_list)) == 0)\n-\tgnu_variant_list = TREE_CHAIN (gnu_variant_list);\n+      /* We use to delete the empty variants from the end. However,\n+         we no longer do that because we need them to generate complete\n+         debugging information for the variant record.  Otherwise,\n+         the union type definition will be missing the fields associated\n+         to these empty variants.  */\n \n       /* Only make the QUAL_UNION_TYPE if there are any non-empty variants.  */\n       if (gnu_variant_list != 0)"}, {"sha": "f1a9afa731796487351f1b329ccaa696298ab39b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -302,6 +302,7 @@ package body Einfo is\n    --    Is_CPP_Class                   Flag74\n    --    Has_Non_Standard_Rep           Flag75\n    --    Is_Constructor                 Flag76\n+   --    Is_Thread_Body                 Flag77\n    --    Is_Tag                         Flag78\n    --    Has_All_Calls_Remote           Flag79\n    --    Is_Constr_Subt_For_U_Nominal   Flag80\n@@ -420,7 +421,6 @@ package body Einfo is\n \n    --  Remaining flags are currently unused and available\n \n-   --    (unused)                       Flag77\n    --    (unused)                       Flag136\n    --    (unused)                       Flag183\n \n@@ -1640,6 +1640,11 @@ package body Einfo is\n       return Flag55 (Id);\n    end Is_Tagged_Type;\n \n+   function Is_Thread_Body (Id : E) return B is\n+   begin\n+      return Flag77 (Id);\n+   end Is_Thread_Body;\n+\n    function Is_True_Constant (Id : E) return B is\n    begin\n       return Flag163 (Id);\n@@ -3581,6 +3586,11 @@ package body Einfo is\n       Set_Flag55 (Id, V);\n    end Set_Is_Tagged_Type;\n \n+   procedure Set_Is_Thread_Body (Id : E; V : B := True) is\n+   begin\n+      Set_Flag77 (Id, V);\n+   end Set_Is_Thread_Body;\n+\n    procedure Set_Is_True_Constant (Id : E; V : B := True) is\n    begin\n       Set_Flag163 (Id, V);\n@@ -6199,6 +6209,7 @@ package body Einfo is\n       W (\"Is_Statically_Allocated\",       Flag28  (Id));\n       W (\"Is_Tag\",                        Flag78  (Id));\n       W (\"Is_Tagged_Type\",                Flag55  (Id));\n+      W (\"Is_Thread_Body\",                Flag77  (Id));\n       W (\"Is_True_Constant\",              Flag163 (Id));\n       W (\"Is_Unchecked_Union\",            Flag117 (Id));\n       W (\"Is_Unsigned_Type\",              Flag144 (Id));"}, {"sha": "24be5432e2da3ea464f6749a1da59d5aebc78171", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -2276,6 +2276,10 @@ package Einfo is\n --    Is_Task_Type (synthesized)\n --       Applies to all entities, true for task types and subtypes\n \n+--    Is_Thread_Body (Flag77)\n+--       Applies to subprogram entities. Set if a valid Thread_Body pragma\n+--       applies to this subprogram, which is thus a thread body.\n+\n --    Is_True_Constant (Flag163)\n --       This flag is set in constants and variables which have an initial\n --       value specified but which are never assigned, partially or in the\n@@ -4252,6 +4256,7 @@ package Einfo is\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n+   --    Is_Thread_Body                (Flag77)   (non-generic case only)\n    --    Is_Visible_Child_Unit         (Flag116)\n    --    Needs_No_Actuals              (Flag22)\n    --    Return_Present                (Flag54)\n@@ -4496,6 +4501,7 @@ package Einfo is\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n+   --    Is_Thread_Body                (Flag77)   (non-generic case only)\n    --    Is_Valued_Procedure           (Flag127)\n    --    Is_Visible_Child_Unit         (Flag116)\n    --    Needs_No_Actuals              (Flag22)\n@@ -5117,6 +5123,7 @@ package Einfo is\n    function Is_Statically_Allocated            (Id : E) return B;\n    function Is_Tag                             (Id : E) return B;\n    function Is_Tagged_Type                     (Id : E) return B;\n+   function Is_Thread_Body                     (Id : E) return B;\n    function Is_True_Constant                   (Id : E) return B;\n    function Is_Unchecked_Union                 (Id : E) return B;\n    function Is_Unsigned_Type                   (Id : E) return B;\n@@ -5589,6 +5596,7 @@ package Einfo is\n    procedure Set_Is_Statically_Allocated       (Id : E; V : B := True);\n    procedure Set_Is_Tag                        (Id : E; V : B := True);\n    procedure Set_Is_Tagged_Type                (Id : E; V : B := True);\n+   procedure Set_Is_Thread_Body                (Id : E; V : B := True);\n    procedure Set_Is_True_Constant              (Id : E; V : B := True);\n    procedure Set_Is_Unchecked_Union            (Id : E; V : B := True);\n    procedure Set_Is_Unsigned_Type              (Id : E; V : B := True);\n@@ -6111,6 +6119,7 @@ package Einfo is\n    pragma Inline (Is_Subprogram);\n    pragma Inline (Is_Tag);\n    pragma Inline (Is_Tagged_Type);\n+   pragma Inline (Is_Thread_Body);\n    pragma Inline (Is_True_Constant);\n    pragma Inline (Is_Task_Type);\n    pragma Inline (Is_Type);\n@@ -6418,6 +6427,7 @@ package Einfo is\n    pragma Inline (Set_Is_Statically_Allocated);\n    pragma Inline (Set_Is_Tag);\n    pragma Inline (Set_Is_Tagged_Type);\n+   pragma Inline (Set_Is_Thread_Body);\n    pragma Inline (Set_Is_True_Constant);\n    pragma Inline (Set_Is_Unchecked_Union);\n    pragma Inline (Set_Is_Unsigned_Type);"}, {"sha": "d34aca9457058c68decb19592288f172d3608081", "filename": "gcc/ada/einfo.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Feinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Feinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.h?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -450,6 +450,7 @@\n    INLINE B Is_Statically_Allocated            (E Id);\n    INLINE B Is_Tag                             (E Id);\n    INLINE B Is_Tagged_Type                     (E Id);\n+   INLINE B Is_Thread_Body                     (E Id);\n    INLINE B Is_True_Constant                   (E Id);\n    INLINE B Is_Unchecked_Union                 (E Id);\n    INLINE B Is_Unsigned_Type                   (E Id);\n@@ -1438,6 +1439,9 @@\n    INLINE B Is_Tagged_Type (E Id)\n       { return Flag55 (Id); }\n \n+   INLINE B Is_Thread_Body (E Id)\n+      { return Flag77 (Id); }\n+\n    INLINE B Is_True_Constant (E Id)\n       { return Flag163 (Id); }\n "}, {"sha": "fc6964b4ec2f144a612585a7e2f14cc563d4f6a6", "filename": "gcc/ada/errno.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Ferrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Ferrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrno.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *           Copyright (C) 1992-2001 Free Software Foundation, Inc.         *\n+ *           Copyright (C) 1992-2003 Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "2f21067faace6eb9ea92bba1132b87d08017de83", "filename": "gcc/ada/exit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexit.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "fd0631a265500e2d1a06606849cf467118c01aec", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -3713,7 +3713,8 @@ package body Exp_Ch4 is\n                   exit when Chars (Node (Prim)) = Name_Op_Eq\n                     and then Etype (First_Formal (Node (Prim))) =\n                              Etype (Next_Formal (First_Formal (Node (Prim))))\n-                    and then Etype (Node (Prim)) = Standard_Boolean;\n+                    and then\n+                      Base_Type (Etype (Node (Prim))) = Standard_Boolean;\n \n                   Next_Elmt (Prim);\n                   pragma Assert (Present (Prim));"}, {"sha": "9b5d3bfffe9fc76d8f375a42640434f5485f2a9e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -59,12 +59,14 @@ with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n@@ -2849,6 +2851,8 @@ package body Exp_Ch6 is\n \n    --  Reset Pure indication if any parameter has root type System.Address\n \n+   --  Wrap thread body\n+\n    procedure Expand_N_Subprogram_Body (N : Node_Id) is\n       Loc      : constant Source_Ptr := Sloc (N);\n       H        : constant Node_Id    := Handled_Statement_Sequence (N);\n@@ -2866,6 +2870,9 @@ package body Exp_Ch6 is\n       --  the latter test is not critical, it does not matter if we add a\n       --  few extra returns, since they get eliminated anyway later on.\n \n+      procedure Expand_Thread_Body;\n+      --  Perform required expansion of a thread body\n+\n       ----------------\n       -- Add_Return --\n       ----------------\n@@ -2882,6 +2889,165 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Return;\n \n+      ------------------------\n+      -- Expand_Thread_Body --\n+      ------------------------\n+\n+      --  The required expansion of a thread body is as follows\n+\n+      --  procedure <thread body procedure name> is\n+\n+      --    _Secondary_Stack : aliased\n+      --       Storage_Elements.Storage_Array\n+      --         (1 .. Storage_Offset (Sec_Stack_Size));\n+      --    for _Secondary_Stack'Alignment use Standard'Maximum_Alignment;\n+\n+      --    _Process_ATSD : aliased System.Threads.ATSD;\n+\n+      --  begin\n+      --     System.Threads.Thread_Body_Enter;\n+      --       (_Secondary_Stack'Address,\n+      --        _Secondary_Stack'Length,\n+      --        _Process_ATSD'Address);\n+\n+      --     declare\n+      --        <user declarations>\n+      --     begin\n+      --        <user statements>\n+      --     <user exception handlers>\n+      --     end;\n+\n+      --    System.Threads.Thread_Body_Leave;\n+\n+      --  exception\n+      --     when E : others =>\n+      --       System.Threads.Thread_Body_Exceptional_Exit (E);\n+      --  end;\n+\n+      --  Note the exception handler is omitted if pragma Restriction\n+      --  No_Exception_Handlers is currently active.\n+\n+      procedure Expand_Thread_Body is\n+         User_Decls    : constant List_Id := Declarations (N);\n+         Sec_Stack_Len : Node_Id;\n+\n+         TB_Pragma  : constant Node_Id :=\n+                        Get_Rep_Pragma (Spec_Id, Name_Thread_Body);\n+\n+         Ent_SS   : Entity_Id;\n+         Ent_ATSD : Entity_Id;\n+         Ent_EO   : Entity_Id;\n+\n+         Decl_SS   : Node_Id;\n+         Decl_ATSD : Node_Id;\n+\n+         Excep_Handlers : List_Id;\n+\n+      begin\n+         --  Get proper setting for secondary stack size\n+\n+         if List_Length (Pragma_Argument_Associations (TB_Pragma)) = 2 then\n+            Sec_Stack_Len :=\n+              Expression (Last (Pragma_Argument_Associations (TB_Pragma)));\n+         else\n+            Sec_Stack_Len :=\n+              Make_Integer_Literal (Loc,\n+                Intval =>\n+                  Expr_Value\n+                   (Expression (RTE (RE_Default_Secondary_Stack_Size))));\n+         end if;\n+\n+         Sec_Stack_Len := Convert_To (RTE (RE_Storage_Offset), Sec_Stack_Len);\n+\n+         --  Build and set declarations for the wrapped thread body\n+\n+         Ent_SS   := Make_Defining_Identifier (Loc, Name_uSecondary_Stack);\n+         Ent_ATSD := Make_Defining_Identifier (Loc, Name_uProcess_ATSD);\n+\n+         Decl_SS :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Ent_SS,\n+             Aliased_Present     => True,\n+             Object_Definition   =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Occurrence_Of (RTE (RE_Storage_Array), Loc),\n+                 Constraint   =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     Constraints => New_List (\n+                       Make_Range (Loc,\n+                         Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                         High_Bound => Sec_Stack_Len)))));\n+\n+         Decl_ATSD :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Ent_ATSD,\n+             Aliased_Present     => True,\n+             Object_Definition   => New_Occurrence_Of (RTE (RE_ATSD), Loc));\n+\n+         Set_Declarations (N, New_List (Decl_SS, Decl_ATSD));\n+         Analyze (Decl_SS);\n+         Analyze (Decl_ATSD);\n+         Set_Alignment (Ent_SS, UI_From_Int (Maximum_Alignment));\n+\n+         --  Create new exception handler\n+\n+         if Restrictions (No_Exception_Handlers) then\n+            Excep_Handlers := No_List;\n+\n+         else\n+            Check_Restriction (No_Exception_Handlers, N);\n+\n+            Ent_EO := Make_Defining_Identifier (Loc, Name_uE);\n+\n+            Excep_Handlers := New_List (\n+              Make_Exception_Handler (Loc,\n+                Choice_Parameter => Ent_EO,\n+                Exception_Choices => New_List (\n+                  Make_Others_Choice (Loc)),\n+                Statements => New_List (\n+                  Make_Procedure_Call_Statement (Loc,\n+                    Name =>\n+                      New_Occurrence_Of\n+                        (RTE (RE_Thread_Body_Exceptional_Exit), Loc),\n+                    Parameter_Associations => New_List (\n+                      New_Occurrence_Of (Ent_EO, Loc))))));\n+         end if;\n+\n+         --  Now build new handled statement sequence and analyze it\n+\n+         Set_Handled_Statement_Sequence (N,\n+           Make_Handled_Sequence_Of_Statements (Loc,\n+             Statements => New_List (\n+\n+               Make_Procedure_Call_Statement (Loc,\n+                 Name => New_Occurrence_Of (RTE (RE_Thread_Body_Enter), Loc),\n+                 Parameter_Associations => New_List (\n+\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Occurrence_Of (Ent_SS, Loc),\n+                     Attribute_Name => Name_Address),\n+\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Occurrence_Of (Ent_SS, Loc),\n+                     Attribute_Name => Name_Length),\n+\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Occurrence_Of (Ent_ATSD, Loc),\n+                     Attribute_Name => Name_Address))),\n+\n+               Make_Block_Statement (Loc,\n+                 Declarations => User_Decls,\n+                 Handled_Statement_Sequence => H),\n+\n+               Make_Procedure_Call_Statement (Loc,\n+                 Name => New_Occurrence_Of (RTE (RE_Thread_Body_Leave), Loc))),\n+\n+             Exception_Handlers => Excep_Handlers));\n+\n+         Analyze (Handled_Statement_Sequence (N));\n+      end Expand_Thread_Body;\n+\n    --  Start of processing for Expand_N_Subprogram_Body\n \n    begin\n@@ -3150,6 +3316,12 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n+      --  Deal with thread body\n+\n+      if Is_Thread_Body (Spec_Id) then\n+         Expand_Thread_Body;\n+      end if;\n+\n       --  If the subprogram does not have pending instantiations, then we\n       --  must generate the subprogram descriptor now, since the code for\n       --  the subprogram is complete, and this is our last chance. However"}, {"sha": "4d4467127bc58d1d626ed9267f07d8b5d9244cb0", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -570,7 +570,7 @@ extern tree create_param_decl (tree, tree, int);\n \n    INLINE_FLAG, PUBLIC_FLAG, and EXTERN_FLAG are used to set the appropriate\n    fields in the FUNCTION_DECL.  */\n-extern tree create_subprog_decl (tree, tree, tree, tree, int, int, int, \n+extern tree create_subprog_decl (tree, tree, tree, tree, int, int, int,\n \t\t\t\t struct attrib *);\n \n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n@@ -721,6 +721,25 @@ extern tree fill_vms_descriptor (tree, Entity_Id);\n    should not be allocated in a register.  Return true if successful.  */\n extern bool gnat_mark_addressable (tree);\n \n+/* This function is called by the front end to enumerate all the supported\n+   modes for the machine.  We pass a function which is called back with\n+   the following integer parameters:\n+\n+   FLOAT_P\tnonzero if this represents a floating-point mode\n+   COMPLEX_P\tnonzero is this represents a complex mode\n+   COUNT\tcount of number of items, nonzero for vector mode\n+   PRECISION\tnumber of bits in data representation\n+   MANTISSA\tnumber of bits in mantissa, if FP and known, else zero.\n+   SIZE\t\tnumber of bits used to store data\n+   ALIGN\tnumber of bits to which mode is aligned.  */\n+extern void enumerate_modes (void (*f) (int, int, int, int, int, int,\n+\t\t\t\t\tunsigned int));\n+\n+/* These are temporary function to deal with recent GCC changes related to\n+   FP type sizes and precisions.  */\n+extern int fp_prec_to_size (int);\n+extern int fp_size_to_prec (int);\n+\n /* These functions return the basic data type sizes and related parameters\n    about the target machine.  */\n "}, {"sha": "82284286676b4b85e8ddf9bdcaeb53a6cf1936ca", "filename": "gcc/ada/gnatbl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fgnatbl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fgnatbl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbl.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -289,7 +289,7 @@ main (int argc, char **argv)\n \t{\n \t  if (done_an_ali)\n \t    {\n-\t      fprintf (stderr, \n+\t      fprintf (stderr,\n \t\t       \"Sorry - cannot handle more than one ALI file\\n\");\n \t      exit (1);\n \t    }\n@@ -323,7 +323,7 @@ main (int argc, char **argv)\n \t\t    exit (retcode);\n \t\t}\n \t    }\n-\t  else \n+\t  else\n \t    addarg (argv[i]);\n \t}\n #ifdef MSDOS"}, {"sha": "b6161b36704278bc534773782fe574d948697083", "filename": "gcc/ada/init.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -82,17 +82,17 @@ extern struct Machine_State *(*Get_Machine_State_Addr) (void);\n \n #define Check_Abort_Status     \\\n                       system__soft_links__check_abort_status\n-extern int    (*Check_Abort_Status) (void);\n+extern int (*Check_Abort_Status) (void);\n \n #define Raise_From_Signal_Handler \\\n                       ada__exceptions__raise_from_signal_handler\n-extern void   Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n+extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n \n #define Propagate_Signal_Exception \\\n                       __gnat_propagate_sig_exc\n-extern void   Propagate_Signal_Exception (struct Machine_State *, \n-                                          struct Exception_Data *,\n-                                          const char *);\n+extern void Propagate_Signal_Exception (struct Machine_State *,\n+                                        struct Exception_Data *,\n+                                        const char *);\n \n /* Copies of global values computed by the binder */\n int   __gl_main_priority            = -1;"}, {"sha": "113b8d1633b9a102d82e2c7dba867002ab9f9cb7", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -3363,7 +3363,10 @@ package body Make is\n          --  cannot be specified on the command line.\n \n          if Osint.Number_Of_Files /= 0 then\n-            if Projects.Table (Main_Project).Library then\n+            if Projects.Table (Main_Project).Library\n+              and then not Unique_Compile\n+              and then ((not Make_Steps) or else Bind_Only or else Link_Only)\n+            then\n                Make_Failed (\"cannot specify a main program \" &\n                             \"on the command line for a library project file\");\n "}, {"sha": "42bb3fa30e1a20c703a12b9bc439da33a8785ebc", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 112, "deletions": 6, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -39,6 +39,7 @@\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"real.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n #include \"diagnostic.h\"\n@@ -146,7 +147,7 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n \n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n-/* Tables describing GCC tree codes used only by GNAT.  \n+/* Tables describing GCC tree codes used only by GNAT.\n \n    Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n@@ -272,7 +273,7 @@ gnat_handle_option (size_t scode, const char *arg, int value ATTRIBUTE_UNUSED)\n \n     case OPT_gant:\n       warning (\"`-gnat' misspelled as `-gant'\");\n- \n+\n       /* ... fall through ... */\n \n     case OPT_gnat:\n@@ -283,7 +284,7 @@ gnat_handle_option (size_t scode, const char *arg, int value ATTRIBUTE_UNUSED)\n       gnat_argc++;\n \n       if (arg[0] == 'O')\n-\tfor (i = 1; i < save_argc - 1; i++) \n+\tfor (i = 1; i < save_argc - 1; i++)\n \t  if (!strncmp (save_argv[i], \"-gnatO\", 6))\n \t    if (save_argv[++i][0] != '-')\n \t      {\n@@ -304,8 +305,8 @@ static unsigned int\n gnat_init_options (unsigned int argc, const char **argv)\n {\n   /* Initialize gnat_argv with save_argv size.  */\n-  gnat_argv = (char **) xmalloc ((argc + 1) * sizeof (argv[0])); \n-  gnat_argv[0] = xstrdup (argv[0]);     /* name of the command */ \n+  gnat_argv = (char **) xmalloc ((argc + 1) * sizeof (argv[0]));\n+  gnat_argv[0] = xstrdup (argv[0]);     /* name of the command */\n   gnat_argc = 1;\n \n   save_argc = argc;\n@@ -706,7 +707,7 @@ static int\n gnat_eh_type_covers (tree a, tree b)\n {\n   /* a catches b if they represent the same exception id or if a\n-     is an \"others\". \n+     is an \"others\".\n \n      ??? integer_zero_node for \"others\" is hardwired in too many places\n      currently.  */\n@@ -886,3 +887,108 @@ must_pass_by_ref (tree gnu_type)\n \t  || (TYPE_SIZE (gnu_type) != 0\n \t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n }\n+\n+/* This function is called by the front end to enumerate all the supported\n+   modes for the machine.  We pass a function which is called back with\n+   the following integer parameters:\n+\n+   FLOAT_P\tnonzero if this represents a floating-point mode\n+   COMPLEX_P\tnonzero is this represents a complex mode\n+   COUNT\tcount of number of items, nonzero for vector mode\n+   PRECISION\tnumber of bits in data representation\n+   MANTISSA\tnumber of bits in mantissa, if FP and known, else zero.\n+   SIZE\t\tnumber of bits used to store data\n+   ALIGN\tnumber of bits to which mode is aligned.  */\n+\n+void\n+enumerate_modes (void (*f) (int, int, int, int, int, int, unsigned int))\n+{\n+  enum machine_mode i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    {\n+      enum machine_mode j;\n+      bool float_p = 0;\n+      bool complex_p = 0;\n+      bool vector_p = 0;\n+      bool skip_p = 0;\n+      int mantissa = 0;\n+      enum machine_mode inner_mode = i;\n+\n+      switch (GET_MODE_CLASS (i))\n+\t{\n+\tcase MODE_INT:\n+\t  break;\n+\tcase MODE_FLOAT:\n+\t  float_p = 1;\n+\t  break;\n+\tcase MODE_COMPLEX_INT:\n+\t  complex_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tcase MODE_COMPLEX_FLOAT:\n+\t  float_p = 1;\n+\t  complex_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tcase MODE_VECTOR_INT:\n+\t  vector_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tcase MODE_VECTOR_FLOAT:\n+\t  float_p = 1;\n+\t  vector_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tdefault:\n+\t  skip_p = 1;\n+\t}\n+\n+      /* Skip this mode if it's one the front end doesn't need to know about\n+\t (e.g., the CC modes) or if there is no add insn for that mode (or\n+\t any wider mode), meaning it is not supported by the hardware.  If\n+\t this a complex or vector mode, we care about the inner mode.  */\n+      for (j = inner_mode; j != VOIDmode; j = GET_MODE_WIDER_MODE (j))\n+\tif (add_optab->handlers[j].insn_code != CODE_FOR_nothing)\n+\t  break;\n+\n+      if (float_p)\n+\t{\n+\t  const struct real_format *fmt = REAL_MODE_FORMAT (inner_mode);\n+\n+\t  mantissa = fmt->p * fmt->log2_b;\n+\t}\n+\n+      if (!skip_p && j != VOIDmode)\n+\t(*f) (float_p, complex_p, vector_p ? GET_MODE_NUNITS (i) : 0,\n+\t      GET_MODE_BITSIZE (i), mantissa,\n+\t      GET_MODE_SIZE (i) * BITS_PER_UNIT, GET_MODE_ALIGNMENT (i));\n+    }\n+}\n+\n+int\n+fp_prec_to_size (int prec)\n+{\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_BITSIZE (mode) == prec)\n+      return GET_MODE_SIZE (mode) * BITS_PER_UNIT;\n+\n+  abort ();\n+}\n+\n+int\n+fp_size_to_prec (int size)\n+{\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_SIZE (mode) * BITS_PER_UNIT == size)\n+      return GET_MODE_BITSIZE (mode);\n+\n+  abort ();\n+}\n+"}, {"sha": "19eefc42047a17dcdb5c5b1f79538d7406845a1a", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -980,6 +980,7 @@ begin\n            Pragma_Task_Info                    |\n            Pragma_Task_Name                    |\n            Pragma_Task_Storage                 |\n+           Pragma_Thread_Body                  |\n            Pragma_Time_Slice                   |\n            Pragma_Title                        |\n            Pragma_Unchecked_Union              |"}, {"sha": "8b1d082b0f414c9ed47eb52bf62f63390889947c", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -940,8 +940,8 @@ get_action_description_for (_Unwind_Context *uw_context,\n static void\n setup_to_install (_Unwind_Context *uw_context,\n                   _Unwind_Exception *uw_exception,\n-                  int uw_filter,\n-                  _Unwind_Ptr uw_landing_pad)\n+                  _Unwind_Ptr uw_landing_pad,\n+                  int uw_filter)\n {\n #ifndef EH_RETURN_DATA_REGNO\n   /* We should not be called if the appropriate underlying support is not"}, {"sha": "3ecd94842bd0f0e1acefb57b39dcd5db72e96707", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -298,6 +298,7 @@ package Rtsfind is\n       System_String_Ops_Concat_5,\n       System_Task_Info,\n       System_Tasking,\n+      System_Threads,\n       System_Unsigned_Types,\n       System_Val_Bool,\n       System_Val_Char,\n@@ -1034,6 +1035,7 @@ package Rtsfind is\n      RE_IS_Ilf,                          -- System.Scalar_Values\n      RE_IS_Ill,                          -- System.Scalar_Values\n \n+     RE_Default_Secondary_Stack_Size,    -- System.Secondary_Stack\n      RE_Mark_Id,                         -- System.Secondary_Stack\n      RE_SS_Allocate,                     -- System.Secondary_Stack\n      RE_SS_Pool,                         -- System.Secondary_Stack\n@@ -1164,6 +1166,11 @@ package Rtsfind is\n      RE_Get_GNAT_Exception,              -- System.Soft_Links\n      RE_Update_Exception,                -- System.Soft_Links\n \n+     RE_ATSD,                            -- System.Threads\n+     RE_Thread_Body_Enter,               -- System.Threads\n+     RE_Thread_Body_Exceptional_Exit,    -- System.Threads\n+     RE_Thread_Body_Leave,               -- System.Threads\n+\n      RE_Bits_1,                          -- System.Unsigned_Types\n      RE_Bits_2,                          -- System.Unsigned_Types\n      RE_Bits_4,                          -- System.Unsigned_Types\n@@ -1968,6 +1975,7 @@ package Rtsfind is\n      RE_IS_Ilf                           => System_Scalar_Values,\n      RE_IS_Ill                           => System_Scalar_Values,\n \n+     RE_Default_Secondary_Stack_Size     => System_Secondary_Stack,\n      RE_Mark_Id                          => System_Secondary_Stack,\n      RE_SS_Allocate                      => System_Secondary_Stack,\n      RE_SS_Mark                          => System_Secondary_Stack,\n@@ -2098,6 +2106,11 @@ package Rtsfind is\n      RE_Get_GNAT_Exception               => System_Soft_Links,\n      RE_Update_Exception                 => System_Soft_Links,\n \n+     RE_ATSD                             => System_Threads,\n+     RE_Thread_Body_Enter                => System_Threads,\n+     RE_Thread_Body_Exceptional_Exit     => System_Threads,\n+     RE_Thread_Body_Leave                => System_Threads,\n+\n      RE_Bits_1                           => System_Unsigned_Types,\n      RE_Bits_2                           => System_Unsigned_Types,\n      RE_Bits_4                           => System_Unsigned_Types,"}, {"sha": "97f9e88cff46f1a93ad379e92647fa1c4b73875f", "filename": "gcc/ada/s-thread.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fs-thread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fs-thread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -43,6 +43,8 @@ package body System.Threads is\n    function From_Address is\n       new Unchecked_Conversion (Address, ATSD_Access);\n \n+\n+\n    -----------------------\n    -- Get_Current_Excep --\n    -----------------------\n@@ -98,4 +100,41 @@ package body System.Threads is\n       CTSD.Sec_Stack_Addr := Addr;\n    end Set_Sec_Stack_Addr;\n \n+   -----------------------\n+   -- Thread_Body_Enter --\n+   -----------------------\n+\n+   procedure Thread_Body_Enter\n+     (Sec_Stack_Address    : System.Address;\n+      Sec_Stack_Size       : Natural;\n+      Process_ATSD_Address : System.Address)\n+   is\n+      pragma Unreferenced (Sec_Stack_Address);\n+      pragma Unreferenced (Sec_Stack_Size);\n+      pragma Unreferenced (Process_ATSD_Address);\n+   begin\n+      null;\n+   end Thread_Body_Enter;\n+\n+   ----------------------------------\n+   -- Thread_Body_Exceptional_Exit --\n+   ----------------------------------\n+\n+   procedure Thread_Body_Exceptional_Exit\n+     (EO : Ada.Exceptions.Exception_Occurrence)\n+   is\n+      pragma Unreferenced (EO);\n+   begin\n+      null;\n+   end Thread_Body_Exceptional_Exit;\n+\n+   -----------------------\n+   -- Thread_Body_Leave --\n+   -----------------------\n+\n+   procedure Thread_Body_Leave is\n+   begin\n+      null;\n+   end Thread_Body_Leave;\n+\n end System.Threads;"}, {"sha": "a316afc592b6e2ec47663ebad72859c148cd6fa8", "filename": "gcc/ada/s-thread.ads", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fs-thread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fs-thread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-thread.ads?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -48,7 +48,7 @@ package System.Threads is\n \n    type ATSD_Access is access ATSD;\n \n-   --  Get/Set for the attributes of the current thread.\n+   --  Get/Set for the attributes of the current thread\n \n    function  Get_Jmpbuf_Address return  Address;\n    pragma Inline (Get_Jmpbuf_Address);\n@@ -65,6 +65,73 @@ package System.Threads is\n    function Get_Current_Excep return EOA;\n    pragma Inline (Get_Current_Excep);\n \n+   --------------------------\n+   -- Thread Body Handling --\n+   --------------------------\n+\n+   --  The subprograms in this section are called by the expansion of a\n+   --  subprogram body to which a Thread_Body pragma has been applied:\n+\n+   --  Given a subprogram body\n+\n+   --     procedure xyz (params ....) is    -- can also be a function\n+   --       <user declarations>\n+   --     begin\n+   --       <user statements>\n+   --     <user exception handlers>\n+   --     end xyz;\n+\n+   --  The expansion resulting from use of the Thread_Body pragma is:\n+\n+   --     procedure xyz (params ...) is\n+\n+   --       _Secondary_Stack : aliased\n+   --          Storage_Elements.Storage_Array\n+   --            (1 .. Storage_Offset (Sec_Stack_Size));\n+   --       for _Secondary_Stack'Alignment use Standard'Maximum_Alignment;\n+\n+   --       _Process_ATSD : aliased System.Threads.ATSD;\n+\n+   --     begin\n+   --        System.Threads.Thread_Body_Enter;\n+   --          (_Secondary_Stack'Address,\n+   --           _Secondary_Stack'Length,\n+   --           _Process_ATSD'Address);\n+\n+   --        declare\n+   --           <user declarations>\n+   --        begin\n+   --           <user statements>\n+   --        <user exception handlers>\n+   --        end;\n+\n+   --       System.Threads.Thread_Body_Leave;\n+\n+   --     exception\n+   --        when E : others =>\n+   --          System.Threads.Thread_Body_Exceptional_Exit (E);\n+   --     end;\n+\n+   --  Note the exception handler is omitted if pragma Restriction\n+   --  No_Exception_Handlers is currently active.\n+\n+   --  Note: the secondary stack size (Sec_Stack_Size) comes either from\n+   --  the pragma, if specified, or is the default value taken from\n+   --  the declaration in System.Secondary_Stack.\n+\n+   procedure Thread_Body_Enter\n+     (Sec_Stack_Address    : System.Address;\n+      Sec_Stack_Size       : Natural;\n+      Process_ATSD_Address : System.Address);\n+   --  Enter thread body, see above for details\n+\n+   procedure Thread_Body_Leave;\n+   --  Leave thread body (normally), see above for details\n+\n+   procedure Thread_Body_Exceptional_Exit\n+     (EO : Ada.Exceptions.Exception_Occurrence);\n+   --  Leave thread body (abnormally on exception), see above for details\n+\n private\n \n    ------------------------"}, {"sha": "efefdb82068add2f88899fe16f00425692b42ebb", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -372,8 +372,8 @@ package body Sem_Attr is\n          ----------------------------------\n \n          procedure Build_Access_Subprogram_Type (P : Node_Id) is\n-            Index    : Interp_Index;\n-            It       : Interp;\n+            Index : Interp_Index;\n+            It    : Interp;\n \n             function Get_Kind (E : Entity_Id) return Entity_Kind;\n             --  Distinguish between access to regular and protected\n@@ -395,6 +395,10 @@ package body Sem_Attr is\n          --  Start of processing for Build_Access_Subprogram_Type\n \n          begin\n+            --  In the case of an access to subprogram, use the name of the\n+            --  subprogram itself as the designated type. Type-checking in\n+            --  this case compares the signatures of the designated types.\n+\n             if not Is_Overloaded (P) then\n                Acc_Type :=\n                  New_Internal_Entity\n@@ -408,7 +412,6 @@ package body Sem_Attr is\n                Set_Etype (N, Any_Type);\n \n                while Present (It.Nam) loop\n-\n                   if not Is_Intrinsic_Subprogram (It.Nam) then\n                      Acc_Type :=\n                        New_Internal_Entity\n@@ -437,17 +440,20 @@ package body Sem_Attr is\n               (\"prefix of % attribute cannot be enumeration literal\", P);\n          end if;\n \n-         --  In the case of an access to subprogram, use the name of the\n-         --  subprogram itself as the designated type. Type-checking in\n-         --  this case compares the signatures of the designated types.\n+         --  Case of access to subprogram\n \n          if Is_Entity_Name (P)\n            and then Is_Overloadable (Entity (P))\n          then\n+            --  Not allowed for nested subprograms if No_Implicit_Dynamic_Code\n+            --  restriction set (since in general a trampoline is required).\n+\n             if not Is_Library_Level_Entity (Entity (P)) then\n                Check_Restriction (No_Implicit_Dynamic_Code, P);\n             end if;\n \n+            --  Build the appropriate subprogram type\n+\n             Build_Access_Subprogram_Type (P);\n \n             --  For unrestricted access, kill current values, since this\n@@ -460,7 +466,7 @@ package body Sem_Attr is\n \n             return;\n \n-         --  Component is an operation of a protected type.\n+         --  Component is an operation of a protected type\n \n          elsif Nkind (P) = N_Selected_Component\n            and then Is_Overloadable (Entity (Selector_Name (P)))\n@@ -6406,7 +6412,6 @@ package body Sem_Attr is\n             end if;\n \n             if Is_Entity_Name (P) then\n-\n                if Is_Overloaded (P) then\n                   Get_First_Interp (P, Index, It);\n \n@@ -6437,19 +6442,18 @@ package body Sem_Attr is\n                   Resolve (P);\n                end if;\n \n+               Error_Msg_Name_1 := Aname;\n+\n                if not Is_Entity_Name (P) then\n                   null;\n \n                elsif Is_Abstract (Entity (P))\n                  and then Is_Overloadable (Entity (P))\n                then\n-                  Error_Msg_Name_1 := Aname;\n                   Error_Msg_N (\"prefix of % attribute cannot be abstract\", P);\n                   Set_Etype (N, Any_Type);\n \n                elsif Convention (Entity (P)) = Convention_Intrinsic then\n-                  Error_Msg_Name_1 := Aname;\n-\n                   if Ekind (Entity (P)) = E_Enumeration_Literal then\n                      Error_Msg_N\n                        (\"prefix of % attribute cannot be enumeration literal\",\n@@ -6460,6 +6464,10 @@ package body Sem_Attr is\n                   end if;\n \n                   Set_Etype (N, Any_Type);\n+\n+               elsif Is_Thread_Body (Entity (P)) then\n+                  Error_Msg_N\n+                    (\"prefix of % attribute cannot be a thread body\", P);\n                end if;\n \n                --  Assignments, return statements, components of aggregates,"}, {"sha": "fbdb14a438bcfdd486642cfc6c457be199e1a7e7", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -3233,8 +3233,7 @@ package body Sem_Ch10 is\n       Unum             : Unit_Number_Type :=\n                            Get_Source_Unit (Library_Unit (N));\n       P_Unit           : Entity_Id := Unit (Library_Unit (N));\n-      P                : Entity_Id :=\n-                           Defining_Unit_Name (Specification (P_Unit));\n+      P                : Entity_Id;\n       Lim_Elmt         : Elmt_Id;\n       Lim_Typ          : Entity_Id;\n       Is_Child_Package : Boolean := False;\n@@ -3261,6 +3260,33 @@ package body Sem_Ch10 is\n    --  Start of processing for Install_Limited_Withed_Unit\n \n    begin\n+      --  In case of limited with_clause on subprograms, generics, instances,\n+      --  or generic renamings, the corresponding error was previously posted\n+      --  and we have nothing to do here.\n+\n+      case Nkind (P_Unit) is\n+\n+         when N_Package_Declaration =>\n+            null;\n+\n+         when N_Subprogram_Declaration                 |\n+              N_Generic_Package_Declaration            |\n+              N_Generic_Subprogram_Declaration         |\n+              N_Package_Instantiation                  |\n+              N_Function_Instantiation                 |\n+              N_Procedure_Instantiation                |\n+              N_Generic_Package_Renaming_Declaration   |\n+              N_Generic_Procedure_Renaming_Declaration |\n+              N_Generic_Function_Renaming_Declaration =>\n+            return;\n+\n+         when others =>\n+            pragma Assert (False);\n+            null;\n+      end case;\n+\n+      P := Defining_Unit_Name (Specification (P_Unit));\n+\n       if Nkind (P) = N_Defining_Program_Unit_Name then\n \n          --  Retrieve entity of child package\n@@ -3803,23 +3829,27 @@ package body Sem_Ch10 is\n          when N_Subprogram_Declaration =>\n             Error_Msg_N (\"subprograms not allowed in \"\n                          & \"limited with_clauses\", N);\n+            return;\n \n          when N_Generic_Package_Declaration |\n               N_Generic_Subprogram_Declaration =>\n             Error_Msg_N (\"generics not allowed in \"\n                          & \"limited with_clauses\", N);\n+            return;\n \n          when N_Package_Instantiation |\n               N_Function_Instantiation |\n               N_Procedure_Instantiation =>\n             Error_Msg_N (\"generic instantiations not allowed in \"\n                          & \"limited with_clauses\", N);\n+            return;\n \n          when N_Generic_Package_Renaming_Declaration |\n               N_Generic_Procedure_Renaming_Declaration |\n               N_Generic_Function_Renaming_Declaration =>\n             Error_Msg_N (\"generic renamings not allowed in \"\n                          & \"limited with_clauses\", N);\n+            return;\n \n          when others =>\n             pragma Assert (False);"}, {"sha": "037650fa10cf19b72ac1c1457dcf26ed2c8d4ef5", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -9082,6 +9082,80 @@ package body Sem_Prag is\n             end if;\n          end Task_Storage;\n \n+         -----------------\n+         -- Thread_Body --\n+         -----------------\n+\n+         --  pragma Thread_Body\n+         --    (  [Entity =>]               LOCAL_NAME\n+         --     [,[Secondary_Stack_Size =>] static_integer_EXPRESSION]);\n+\n+         when Pragma_Thread_Body => Thread_Body : declare\n+            Id : Node_Id;\n+            SS : Node_Id;\n+            E  : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments (2);\n+            Check_Optional_Identifier (Arg1, Name_Entity);\n+            Check_Arg_Is_Local_Name (Arg1);\n+\n+            Id := Expression (Arg1);\n+\n+            if not Is_Entity_Name (Id)\n+              or else not Is_Subprogram (Entity (Id))\n+            then\n+               Error_Pragma_Arg (\"subprogram name required\", Arg1);\n+            end if;\n+\n+            E := Entity (Id);\n+\n+            --  Go to renamed subprogram if present, since Thread_Body applies\n+            --  to the actual renamed entity, not to the renaming entity.\n+\n+            if Present (Alias (E))\n+              and then Nkind (Parent (Declaration_Node (E))) =\n+                         N_Subprogram_Renaming_Declaration\n+            then\n+               E := Alias (E);\n+            end if;\n+\n+            --  Various error checks\n+\n+            if Nkind (Parent (Declaration_Node (E))) = N_Subprogram_Body then\n+               Error_Pragma\n+                 (\"pragma% requires separate spec and must come before body\");\n+\n+            elsif Rep_Item_Too_Early (E, N)\n+                 or else\n+               Rep_Item_Too_Late (E, N)\n+            then\n+               raise Pragma_Exit;\n+\n+            elsif Is_Thread_Body (E) then\n+               Error_Pragma_Arg\n+                 (\"only one thread body pragma allowed\", Arg1);\n+\n+            elsif Present (Homonym (E))\n+              and then Scope (Homonym (E)) = Current_Scope\n+            then\n+               Error_Pragma_Arg\n+                 (\"thread body subprogram must not be overloaded\", Arg1);\n+            end if;\n+\n+            Set_Is_Thread_Body (E);\n+\n+            --  Deal with secondary stack argument\n+\n+            if Arg_Count = 2 then\n+               Check_Optional_Identifier (Arg2, Name_Secondary_Stack_Size);\n+               SS := Expression (Arg2);\n+               Analyze_And_Resolve (SS, Any_Integer);\n+            end if;\n+         end Thread_Body;\n+\n          ----------------\n          -- Time_Slice --\n          ----------------\n@@ -9812,6 +9886,7 @@ package body Sem_Prag is\n       Pragma_Task_Info                    => -1,\n       Pragma_Task_Name                    => -1,\n       Pragma_Task_Storage                 =>  0,\n+      Pragma_Thread_Body                  => +2,\n       Pragma_Time_Slice                   => -1,\n       Pragma_Title                        => -1,\n       Pragma_Unchecked_Union              => -1,"}, {"sha": "88d8edce33518c6d24eb54b540e2fac9e44ae976", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -3315,7 +3315,6 @@ package body Sem_Res is\n       --  dereference made explicit in Analyze_Call.\n \n       if Ekind (Etype (Subp)) = E_Subprogram_Type then\n-\n          if not Is_Overloaded (Subp) then\n             Nam := Etype (Subp);\n \n@@ -3423,6 +3422,12 @@ package body Sem_Res is\n          end;\n       end if;\n \n+      --  Cannot call thread body directly\n+\n+      if Is_Thread_Body (Nam) then\n+         Error_Msg_N (\"cannot call thread body directly\", N);\n+      end if;\n+\n       --  If the subprogram is not global, then kill all checks. This is\n       --  a bit conservative, since in many cases we could do better, but\n       --  it is not worth the effort. Similarly, we kill constant values."}, {"sha": "aa603e13d40bdb2d787d069af90a030c324a2311", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 994, "deletions": 990, "changes": 1984, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -1,990 +1,994 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                               S N A M E S                                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Namet; use Namet;\n-with Table;\n-\n-package body Snames is\n-\n-   --  Table used to record convention identifiers\n-\n-   type Convention_Id_Entry is record\n-      Name       : Name_Id;\n-      Convention : Convention_Id;\n-   end record;\n-\n-   package Convention_Identifiers is new Table.Table (\n-     Table_Component_Type => Convention_Id_Entry,\n-     Table_Index_Type     => Int,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 50,\n-     Table_Increment      => 200,\n-     Table_Name           => \"Name_Convention_Identifiers\");\n-\n-   --  Table of names to be set by Initialize. Each name is terminated by a\n-   --  single #, and the end of the list is marked by a null entry, i.e. by\n-   --  two # marks in succession. Note that the table does not include the\n-   --  entries for a-z, since these are initialized by Namet itself.\n-\n-   Preset_Names : constant String :=\n-     \"_parent#\" &\n-     \"_tag#\" &\n-     \"off#\" &\n-     \"space#\" &\n-     \"time#\" &\n-     \"_alignment#\" &\n-     \"_abort_signal#\" &\n-     \"_assign#\" &\n-     \"_chain#\" &\n-     \"_clean#\" &\n-     \"_controller#\" &\n-     \"_entry_bodies#\" &\n-     \"_expunge#\" &\n-     \"_final_list#\" &\n-     \"_idepth#\" &\n-     \"_init#\" &\n-     \"_local_final_list#\" &\n-     \"_master#\" &\n-     \"_object#\" &\n-     \"_priority#\" &\n-     \"_service#\" &\n-     \"_size#\" &\n-     \"_tags#\" &\n-     \"_task#\" &\n-     \"_task_id#\" &\n-     \"_task_info#\" &\n-     \"_task_name#\" &\n-     \"_trace_sp#\" &\n-     \"initialize#\" &\n-     \"adjust#\" &\n-     \"finalize#\" &\n-     \"next#\" &\n-     \"prev#\" &\n-     \"allocate#\" &\n-     \"deallocate#\" &\n-     \"dereference#\" &\n-     \"decimal_io#\" &\n-     \"enumeration_io#\" &\n-     \"fixed_io#\" &\n-     \"float_io#\" &\n-     \"integer_io#\" &\n-     \"modular_io#\" &\n-     \"a_textio#\" &\n-     \"a_witeio#\" &\n-     \"const#\" &\n-     \"<error>#\" &\n-     \"go#\" &\n-     \"put#\" &\n-     \"put_line#\" &\n-     \"to#\" &\n-     \"finalization#\" &\n-     \"finalization_root#\" &\n-     \"interfaces#\" &\n-     \"standard#\" &\n-     \"system#\" &\n-     \"text_io#\" &\n-     \"wide_text_io#\" &\n-     \"addr#\" &\n-     \"async#\" &\n-     \"get_active_partition_id#\" &\n-     \"get_rci_package_receiver#\" &\n-     \"origin#\" &\n-     \"params#\" &\n-     \"partition#\" &\n-     \"partition_interface#\" &\n-     \"ras#\" &\n-     \"rci_name#\" &\n-     \"receiver#\" &\n-     \"result#\" &\n-     \"rpc#\" &\n-     \"subp_id#\" &\n-     \"Oabs#\" &\n-     \"Oand#\" &\n-     \"Omod#\" &\n-     \"Onot#\" &\n-     \"Oor#\" &\n-     \"Orem#\" &\n-     \"Oxor#\" &\n-     \"Oeq#\" &\n-     \"One#\" &\n-     \"Olt#\" &\n-     \"Ole#\" &\n-     \"Ogt#\" &\n-     \"Oge#\" &\n-     \"Oadd#\" &\n-     \"Osubtract#\" &\n-     \"Oconcat#\" &\n-     \"Omultiply#\" &\n-     \"Odivide#\" &\n-     \"Oexpon#\" &\n-     \"ada_83#\" &\n-     \"ada_95#\" &\n-     \"c_pass_by_copy#\" &\n-     \"compile_time_warning#\" &\n-     \"component_alignment#\" &\n-     \"convention_identifier#\" &\n-     \"discard_names#\" &\n-     \"elaboration_checks#\" &\n-     \"eliminate#\" &\n-     \"explicit_overriding#\" &\n-     \"extend_system#\" &\n-     \"extensions_allowed#\" &\n-     \"external_name_casing#\" &\n-     \"float_representation#\" &\n-     \"initialize_scalars#\" &\n-     \"interrupt_state#\" &\n-     \"license#\" &\n-     \"locking_policy#\" &\n-     \"long_float#\" &\n-     \"no_run_time#\" &\n-     \"normalize_scalars#\" &\n-     \"polling#\" &\n-     \"persistent_data#\" &\n-     \"persistent_object#\" &\n-     \"propagate_exceptions#\" &\n-     \"queuing_policy#\" &\n-     \"ravenscar#\" &\n-     \"restricted_run_time#\" &\n-     \"restrictions#\" &\n-     \"restriction_warnings#\" &\n-     \"reviewable#\" &\n-     \"source_file_name#\" &\n-     \"source_file_name_project#\" &\n-     \"style_checks#\" &\n-     \"suppress#\" &\n-     \"suppress_exception_locations#\" &\n-     \"task_dispatching_policy#\" &\n-     \"universal_data#\" &\n-     \"unsuppress#\" &\n-     \"use_vads_size#\" &\n-     \"validity_checks#\" &\n-     \"warnings#\" &\n-     \"abort_defer#\" &\n-     \"all_calls_remote#\" &\n-     \"annotate#\" &\n-     \"assert#\" &\n-     \"asynchronous#\" &\n-     \"atomic#\" &\n-     \"atomic_components#\" &\n-     \"attach_handler#\" &\n-     \"comment#\" &\n-     \"common_object#\" &\n-     \"complex_representation#\" &\n-     \"controlled#\" &\n-     \"convention#\" &\n-     \"cpp_class#\" &\n-     \"cpp_constructor#\" &\n-     \"cpp_virtual#\" &\n-     \"cpp_vtable#\" &\n-     \"debug#\" &\n-     \"elaborate#\" &\n-     \"elaborate_all#\" &\n-     \"elaborate_body#\" &\n-     \"export#\" &\n-     \"export_exception#\" &\n-     \"export_function#\" &\n-     \"export_object#\" &\n-     \"export_procedure#\" &\n-     \"export_value#\" &\n-     \"export_valued_procedure#\" &\n-     \"external#\" &\n-     \"finalize_storage_only#\" &\n-     \"ident#\" &\n-     \"import#\" &\n-     \"import_exception#\" &\n-     \"import_function#\" &\n-     \"import_object#\" &\n-     \"import_procedure#\" &\n-     \"import_valued_procedure#\" &\n-     \"inline#\" &\n-     \"inline_always#\" &\n-     \"inline_generic#\" &\n-     \"inspection_point#\" &\n-     \"interface#\" &\n-     \"interface_name#\" &\n-     \"interrupt_handler#\" &\n-     \"interrupt_priority#\" &\n-     \"java_constructor#\" &\n-     \"java_interface#\" &\n-     \"keep_names#\" &\n-     \"link_with#\" &\n-     \"linker_alias#\" &\n-     \"linker_options#\" &\n-     \"linker_section#\" &\n-     \"list#\" &\n-     \"machine_attribute#\" &\n-     \"main#\" &\n-     \"main_storage#\" &\n-     \"memory_size#\" &\n-     \"no_return#\" &\n-     \"obsolescent#\" &\n-     \"optimize#\" &\n-     \"optional_overriding#\" &\n-     \"overriding#\" &\n-     \"pack#\" &\n-     \"page#\" &\n-     \"passive#\" &\n-     \"preelaborate#\" &\n-     \"priority#\" &\n-     \"psect_object#\" &\n-     \"pure#\" &\n-     \"pure_function#\" &\n-     \"remote_call_interface#\" &\n-     \"remote_types#\" &\n-     \"share_generic#\" &\n-     \"shared#\" &\n-     \"shared_passive#\" &\n-     \"source_reference#\" &\n-     \"stream_convert#\" &\n-     \"subtitle#\" &\n-     \"suppress_all#\" &\n-     \"suppress_debug_info#\" &\n-     \"suppress_initialization#\" &\n-     \"system_name#\" &\n-     \"task_info#\" &\n-     \"task_name#\" &\n-     \"task_storage#\" &\n-     \"time_slice#\" &\n-     \"title#\" &\n-     \"unchecked_union#\" &\n-     \"unimplemented_unit#\" &\n-     \"unreferenced#\" &\n-     \"unreserve_all_interrupts#\" &\n-     \"volatile#\" &\n-     \"volatile_components#\" &\n-     \"weak_external#\" &\n-     \"ada#\" &\n-     \"assembler#\" &\n-     \"cobol#\" &\n-     \"cpp#\" &\n-     \"fortran#\" &\n-     \"intrinsic#\" &\n-     \"java#\" &\n-     \"stdcall#\" &\n-     \"stubbed#\" &\n-     \"asm#\" &\n-     \"assembly#\" &\n-     \"default#\" &\n-     \"dll#\" &\n-     \"win32#\" &\n-     \"as_is#\" &\n-     \"body_file_name#\" &\n-     \"casing#\" &\n-     \"code#\" &\n-     \"component#\" &\n-     \"component_size_4#\" &\n-     \"copy#\" &\n-     \"d_float#\" &\n-     \"descriptor#\" &\n-     \"dot_replacement#\" &\n-     \"dynamic#\" &\n-     \"entity#\" &\n-     \"external_name#\" &\n-     \"first_optional_parameter#\" &\n-     \"form#\" &\n-     \"g_float#\" &\n-     \"gcc#\" &\n-     \"gnat#\" &\n-     \"gpl#\" &\n-     \"ieee_float#\" &\n-     \"homonym_number#\" &\n-     \"internal#\" &\n-     \"link_name#\" &\n-     \"lowercase#\" &\n-     \"max_size#\" &\n-     \"mechanism#\" &\n-     \"mixedcase#\" &\n-     \"modified_gpl#\" &\n-     \"name#\" &\n-     \"nca#\" &\n-     \"no#\" &\n-     \"on#\" &\n-     \"parameter_types#\" &\n-     \"reference#\" &\n-     \"restricted#\" &\n-     \"result_mechanism#\" &\n-     \"result_type#\" &\n-     \"runtime#\" &\n-     \"sb#\" &\n-     \"section#\" &\n-     \"semaphore#\" &\n-     \"spec_file_name#\" &\n-     \"static#\" &\n-     \"stack_size#\" &\n-     \"subunit_file_name#\" &\n-     \"task_stack_size_default#\" &\n-     \"task_type#\" &\n-     \"time_slicing_enabled#\" &\n-     \"top_guard#\" &\n-     \"uba#\" &\n-     \"ubs#\" &\n-     \"ubsb#\" &\n-     \"unit_name#\" &\n-     \"unknown#\" &\n-     \"unrestricted#\" &\n-     \"uppercase#\" &\n-     \"user#\" &\n-     \"vax_float#\" &\n-     \"vms#\" &\n-     \"working_storage#\" &\n-     \"abort_signal#\" &\n-     \"access#\" &\n-     \"address#\" &\n-     \"address_size#\" &\n-     \"aft#\" &\n-     \"alignment#\" &\n-     \"asm_input#\" &\n-     \"asm_output#\" &\n-     \"ast_entry#\" &\n-     \"bit#\" &\n-     \"bit_order#\" &\n-     \"bit_position#\" &\n-     \"body_version#\" &\n-     \"callable#\" &\n-     \"caller#\" &\n-     \"code_address#\" &\n-     \"component_size#\" &\n-     \"compose#\" &\n-     \"constrained#\" &\n-     \"count#\" &\n-     \"default_bit_order#\" &\n-     \"definite#\" &\n-     \"delta#\" &\n-     \"denorm#\" &\n-     \"digits#\" &\n-     \"elaborated#\" &\n-     \"emax#\" &\n-     \"enum_rep#\" &\n-     \"epsilon#\" &\n-     \"exponent#\" &\n-     \"external_tag#\" &\n-     \"first#\" &\n-     \"first_bit#\" &\n-     \"fixed_value#\" &\n-     \"fore#\" &\n-     \"has_discriminants#\" &\n-     \"identity#\" &\n-     \"img#\" &\n-     \"integer_value#\" &\n-     \"large#\" &\n-     \"last#\" &\n-     \"last_bit#\" &\n-     \"leading_part#\" &\n-     \"length#\" &\n-     \"machine_emax#\" &\n-     \"machine_emin#\" &\n-     \"machine_mantissa#\" &\n-     \"machine_overflows#\" &\n-     \"machine_radix#\" &\n-     \"machine_rounds#\" &\n-     \"machine_size#\" &\n-     \"mantissa#\" &\n-     \"max_size_in_storage_elements#\" &\n-     \"maximum_alignment#\" &\n-     \"mechanism_code#\" &\n-     \"model_emin#\" &\n-     \"model_epsilon#\" &\n-     \"model_mantissa#\" &\n-     \"model_small#\" &\n-     \"modulus#\" &\n-     \"null_parameter#\" &\n-     \"object_size#\" &\n-     \"partition_id#\" &\n-     \"passed_by_reference#\" &\n-     \"pool_address#\" &\n-     \"pos#\" &\n-     \"position#\" &\n-     \"range#\" &\n-     \"range_length#\" &\n-     \"round#\" &\n-     \"safe_emax#\" &\n-     \"safe_first#\" &\n-     \"safe_large#\" &\n-     \"safe_last#\" &\n-     \"safe_small#\" &\n-     \"scale#\" &\n-     \"scaling#\" &\n-     \"signed_zeros#\" &\n-     \"size#\" &\n-     \"small#\" &\n-     \"storage_size#\" &\n-     \"storage_unit#\" &\n-     \"tag#\" &\n-     \"target_name#\" &\n-     \"terminated#\" &\n-     \"to_address#\" &\n-     \"type_class#\" &\n-     \"uet_address#\" &\n-     \"unbiased_rounding#\" &\n-     \"unchecked_access#\" &\n-     \"unconstrained_array#\" &\n-     \"universal_literal_string#\" &\n-     \"unrestricted_access#\" &\n-     \"vads_size#\" &\n-     \"val#\" &\n-     \"valid#\" &\n-     \"value_size#\" &\n-     \"version#\" &\n-     \"wchar_t_size#\" &\n-     \"wide_width#\" &\n-     \"width#\" &\n-     \"word_size#\" &\n-     \"adjacent#\" &\n-     \"ceiling#\" &\n-     \"copy_sign#\" &\n-     \"floor#\" &\n-     \"fraction#\" &\n-     \"image#\" &\n-     \"input#\" &\n-     \"machine#\" &\n-     \"max#\" &\n-     \"min#\" &\n-     \"model#\" &\n-     \"pred#\" &\n-     \"remainder#\" &\n-     \"rounding#\" &\n-     \"succ#\" &\n-     \"truncation#\" &\n-     \"value#\" &\n-     \"wide_image#\" &\n-     \"wide_value#\" &\n-     \"output#\" &\n-     \"read#\" &\n-     \"write#\" &\n-     \"elab_body#\" &\n-     \"elab_spec#\" &\n-     \"storage_pool#\" &\n-     \"base#\" &\n-     \"class#\" &\n-     \"ceiling_locking#\" &\n-     \"inheritance_locking#\" &\n-     \"fifo_queuing#\" &\n-     \"priority_queuing#\" &\n-     \"fifo_within_priorities#\" &\n-     \"access_check#\" &\n-     \"accessibility_check#\" &\n-     \"discriminant_check#\" &\n-     \"division_check#\" &\n-     \"elaboration_check#\" &\n-     \"index_check#\" &\n-     \"length_check#\" &\n-     \"overflow_check#\" &\n-     \"range_check#\" &\n-     \"storage_check#\" &\n-     \"tag_check#\" &\n-     \"all_checks#\" &\n-     \"abort#\" &\n-     \"abs#\" &\n-     \"accept#\" &\n-     \"and#\" &\n-     \"all#\" &\n-     \"array#\" &\n-     \"at#\" &\n-     \"begin#\" &\n-     \"body#\" &\n-     \"case#\" &\n-     \"constant#\" &\n-     \"declare#\" &\n-     \"delay#\" &\n-     \"do#\" &\n-     \"else#\" &\n-     \"elsif#\" &\n-     \"end#\" &\n-     \"entry#\" &\n-     \"exception#\" &\n-     \"exit#\" &\n-     \"for#\" &\n-     \"function#\" &\n-     \"generic#\" &\n-     \"goto#\" &\n-     \"if#\" &\n-     \"in#\" &\n-     \"is#\" &\n-     \"limited#\" &\n-     \"loop#\" &\n-     \"mod#\" &\n-     \"new#\" &\n-     \"not#\" &\n-     \"null#\" &\n-     \"of#\" &\n-     \"or#\" &\n-     \"others#\" &\n-     \"out#\" &\n-     \"package#\" &\n-     \"pragma#\" &\n-     \"private#\" &\n-     \"procedure#\" &\n-     \"raise#\" &\n-     \"record#\" &\n-     \"rem#\" &\n-     \"renames#\" &\n-     \"return#\" &\n-     \"reverse#\" &\n-     \"select#\" &\n-     \"separate#\" &\n-     \"subtype#\" &\n-     \"task#\" &\n-     \"terminate#\" &\n-     \"then#\" &\n-     \"type#\" &\n-     \"use#\" &\n-     \"when#\" &\n-     \"while#\" &\n-     \"with#\" &\n-     \"xor#\" &\n-     \"divide#\" &\n-     \"enclosing_entity#\" &\n-     \"exception_information#\" &\n-     \"exception_message#\" &\n-     \"exception_name#\" &\n-     \"file#\" &\n-     \"import_address#\" &\n-     \"import_largest_value#\" &\n-     \"import_value#\" &\n-     \"is_negative#\" &\n-     \"line#\" &\n-     \"rotate_left#\" &\n-     \"rotate_right#\" &\n-     \"shift_left#\" &\n-     \"shift_right#\" &\n-     \"shift_right_arithmetic#\" &\n-     \"source_location#\" &\n-     \"unchecked_conversion#\" &\n-     \"unchecked_deallocation#\" &\n-     \"to_pointer#\" &\n-     \"abstract#\" &\n-     \"aliased#\" &\n-     \"protected#\" &\n-     \"until#\" &\n-     \"requeue#\" &\n-     \"tagged#\" &\n-     \"raise_exception#\" &\n-     \"binder#\" &\n-     \"body_suffix#\" &\n-     \"builder#\" &\n-     \"compiler#\" &\n-     \"cross_reference#\" &\n-     \"default_switches#\" &\n-     \"exec_dir#\" &\n-     \"executable#\" &\n-     \"executable_suffix#\" &\n-     \"extends#\" &\n-     \"finder#\" &\n-     \"global_configuration_pragmas#\" &\n-     \"gnatls#\" &\n-     \"gnatstub#\" &\n-     \"implementation#\" &\n-     \"implementation_exceptions#\" &\n-     \"implementation_suffix#\" &\n-     \"languages#\" &\n-     \"library_dir#\" &\n-     \"library_auto_init#\" &\n-     \"library_gcc#\" &\n-     \"library_interface#\" &\n-     \"library_kind#\" &\n-     \"library_name#\" &\n-     \"library_options#\" &\n-     \"library_src_dir#\" &\n-     \"library_symbol_file#\" &\n-     \"library_version#\" &\n-     \"linker#\" &\n-     \"local_configuration_pragmas#\" &\n-     \"locally_removed_files#\" &\n-     \"naming#\" &\n-     \"object_dir#\" &\n-     \"pretty_printer#\" &\n-     \"project#\" &\n-     \"separate_suffix#\" &\n-     \"source_dirs#\" &\n-     \"source_files#\" &\n-     \"source_list_file#\" &\n-     \"spec#\" &\n-     \"spec_suffix#\" &\n-     \"specification#\" &\n-     \"specification_exceptions#\" &\n-     \"specification_suffix#\" &\n-     \"switches#\" &\n-     \"unaligned_valid#\" &\n-      \"#\";\n-\n-   ---------------------\n-   -- Generated Names --\n-   ---------------------\n-\n-   --  This section lists the various cases of generated names which are\n-   --  built from existing names by adding unique leading and/or trailing\n-   --  upper case letters. In some cases these names are built recursively,\n-   --  in particular names built from types may be built from types which\n-   --  themselves have generated names. In this list, xxx represents an\n-   --  existing name to which identifying letters are prepended or appended,\n-   --  and a trailing n represents a serial number in an external name that\n-   --  has some semantic significance (e.g. the n'th index type of an array).\n-\n-   --    xxxA    access type for formal xxx in entry param record   (Exp_Ch9)\n-   --    xxxB    tag table for tagged type xxx                      (Exp_Ch3)\n-   --    xxxB    task body procedure for task xxx                   (Exp_Ch9)\n-   --    xxxD    dispatch table for tagged type xxx                 (Exp_Ch3)\n-   --    xxxD    discriminal for discriminant xxx                   (Sem_Ch3)\n-   --    xxxDn   n'th discr check function for rec type xxx         (Exp_Ch3)\n-   --    xxxE    elaboration boolean flag for task xxx              (Exp_Ch9)\n-   --    xxxE    dispatch table pointer type for tagged type xxx    (Exp_Ch3)\n-   --    xxxE    parameters for accept body for entry xxx           (Exp_Ch9)\n-   --    xxxFn   n'th primitive of a tagged type (named xxx)        (Exp_Ch3)\n-   --    xxxJ    tag table type index for tagged type xxx           (Exp_Ch3)\n-   --    xxxM    master Id value for access type xxx                (Exp_Ch3)\n-   --    xxxP    tag table pointer type for tagged type xxx         (Exp_Ch3)\n-   --    xxxP    parameter record type for entry xxx                (Exp_Ch9)\n-   --    xxxPA   access to parameter record type for entry xxx      (Exp_Ch9)\n-   --    xxxPn   pointer type for n'th primitive of tagged type xxx (Exp_Ch3)\n-   --    xxxR    dispatch table pointer for tagged type xxx         (Exp_Ch3)\n-   --    xxxT    tag table type for tagged type xxx                 (Exp_Ch3)\n-   --    xxxT    literal table for enumeration type xxx             (Sem_Ch3)\n-   --    xxxV    type for task value record for task xxx            (Exp_Ch9)\n-   --    xxxX    entry index constant                               (Exp_Ch9)\n-   --    xxxY    dispatch table type for tagged type xxx            (Exp_Ch3)\n-   --    xxxZ    size variable for task xxx                         (Exp_Ch9)\n-\n-   --  TSS names\n-\n-   --    xxxDA   deep adjust routine for type xxx                   (Exp_TSS)\n-   --    xxxDF   deep finalize routine for type xxx                 (Exp_TSS)\n-   --    xxxDI   deep initialize routine for type xxx               (Exp_TSS)\n-   --    xxxEQ   composite equality routine for record type xxx     (Exp_TSS)\n-   --    xxxIP   initialization procedure for type xxx              (Exp_TSS)\n-   --    xxxRA   RAs type access routine for type xxx               (Exp_TSS)\n-   --    xxxRD   RAs type dereference routine for type xxx          (Exp_TSS)\n-   --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\n-   --    xxxSI   stream input attribute subprogram for type xxx     (Exp_TSS)\n-   --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\n-   --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)\n-   --    xxxSW   stream write attribute subprogram for type xxx     (Exp_TSS)\n-\n-   --  Implicit type names\n-\n-   --    TxxxT   type of literal table for enumeration type xxx     (Sem_Ch3)\n-\n-   --  (Note: this list is not complete or accurate ???)\n-\n-   ----------------------\n-   -- Get_Attribute_Id --\n-   ----------------------\n-\n-   function Get_Attribute_Id (N : Name_Id) return Attribute_Id is\n-   begin\n-      return Attribute_Id'Val (N - First_Attribute_Name);\n-   end Get_Attribute_Id;\n-\n-   ------------------\n-   -- Get_Check_Id --\n-   ------------------\n-\n-   function Get_Check_Id (N : Name_Id) return Check_Id is\n-   begin\n-      return Check_Id'Val (N - First_Check_Name);\n-   end Get_Check_Id;\n-\n-   -----------------------\n-   -- Get_Convention_Id --\n-   -----------------------\n-\n-   function Get_Convention_Id (N : Name_Id) return Convention_Id is\n-   begin\n-      case N is\n-         when Name_Ada        => return Convention_Ada;\n-         when Name_Assembler  => return Convention_Assembler;\n-         when Name_C          => return Convention_C;\n-         when Name_COBOL      => return Convention_COBOL;\n-         when Name_CPP        => return Convention_CPP;\n-         when Name_Fortran    => return Convention_Fortran;\n-         when Name_Intrinsic  => return Convention_Intrinsic;\n-         when Name_Java       => return Convention_Java;\n-         when Name_Stdcall    => return Convention_Stdcall;\n-         when Name_Stubbed    => return Convention_Stubbed;\n-\n-         --  If no direct match, then we must have a convention\n-         --  identifier pragma that has specified this name.\n-\n-         when others          =>\n-            for J in 1 .. Convention_Identifiers.Last loop\n-               if N = Convention_Identifiers.Table (J).Name then\n-                  return Convention_Identifiers.Table (J).Convention;\n-               end if;\n-            end loop;\n-\n-            raise Program_Error;\n-      end case;\n-   end Get_Convention_Id;\n-\n-   ---------------------------\n-   -- Get_Locking_Policy_Id --\n-   ---------------------------\n-\n-   function Get_Locking_Policy_Id (N : Name_Id) return Locking_Policy_Id is\n-   begin\n-      return Locking_Policy_Id'Val (N - First_Locking_Policy_Name);\n-   end Get_Locking_Policy_Id;\n-\n-   -------------------\n-   -- Get_Pragma_Id --\n-   -------------------\n-\n-   function Get_Pragma_Id (N : Name_Id) return Pragma_Id is\n-   begin\n-      if N = Name_AST_Entry then\n-         return Pragma_AST_Entry;\n-      elsif N = Name_Storage_Size then\n-         return Pragma_Storage_Size;\n-      elsif N = Name_Storage_Unit then\n-         return Pragma_Storage_Unit;\n-      elsif N not in First_Pragma_Name .. Last_Pragma_Name then\n-         return Unknown_Pragma;\n-      else\n-         return Pragma_Id'Val (N - First_Pragma_Name);\n-      end if;\n-   end Get_Pragma_Id;\n-\n-   ---------------------------\n-   -- Get_Queuing_Policy_Id --\n-   ---------------------------\n-\n-   function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id is\n-   begin\n-      return Queuing_Policy_Id'Val (N - First_Queuing_Policy_Name);\n-   end Get_Queuing_Policy_Id;\n-\n-   ------------------------------------\n-   -- Get_Task_Dispatching_Policy_Id --\n-   ------------------------------------\n-\n-   function Get_Task_Dispatching_Policy_Id (N : Name_Id)\n-     return Task_Dispatching_Policy_Id is\n-   begin\n-      return Task_Dispatching_Policy_Id'Val\n-        (N - First_Task_Dispatching_Policy_Name);\n-   end Get_Task_Dispatching_Policy_Id;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-      P_Index      : Natural;\n-      Discard_Name : Name_Id;\n-\n-   begin\n-      P_Index := Preset_Names'First;\n-\n-      loop\n-         Name_Len := 0;\n-\n-         while Preset_Names (P_Index) /= '#' loop\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := Preset_Names (P_Index);\n-            P_Index := P_Index + 1;\n-         end loop;\n-\n-         --  We do the Name_Find call to enter the name into the table, but\n-         --  we don't need to do anything with the result, since we already\n-         --  initialized all the preset names to have the right value (we\n-         --  are depending on the order of the names and Preset_Names).\n-\n-         Discard_Name := Name_Find;\n-         P_Index := P_Index + 1;\n-         exit when Preset_Names (P_Index) = '#';\n-      end loop;\n-\n-      --  Make sure that number of names in standard table is correct. If\n-      --  this check fails, run utility program XSNAMES to construct a new\n-      --  properly matching version of the body.\n-\n-      pragma Assert (Discard_Name = Last_Predefined_Name);\n-\n-      --  Initialize the convention identifiers table with the standard\n-      --  set of synonyms that we recognize for conventions.\n-\n-      Convention_Identifiers.Init;\n-\n-      Convention_Identifiers.Append ((Name_Asm,      Convention_Assembler));\n-      Convention_Identifiers.Append ((Name_Assembly, Convention_Assembler));\n-\n-      Convention_Identifiers.Append ((Name_Default,  Convention_C));\n-      Convention_Identifiers.Append ((Name_External, Convention_C));\n-\n-      Convention_Identifiers.Append ((Name_DLL,      Convention_Stdcall));\n-      Convention_Identifiers.Append ((Name_Win32,    Convention_Stdcall));\n-   end Initialize;\n-\n-   -----------------------\n-   -- Is_Attribute_Name --\n-   -----------------------\n-\n-   function Is_Attribute_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Attribute_Name .. Last_Attribute_Name;\n-   end Is_Attribute_Name;\n-\n-   -------------------\n-   -- Is_Check_Name --\n-   -------------------\n-\n-   function Is_Check_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Check_Name .. Last_Check_Name;\n-   end Is_Check_Name;\n-\n-   ------------------------\n-   -- Is_Convention_Name --\n-   ------------------------\n-\n-   function Is_Convention_Name (N : Name_Id) return Boolean is\n-   begin\n-      --  Check if this is one of the standard conventions\n-\n-      if N in First_Convention_Name .. Last_Convention_Name\n-        or else N = Name_C\n-      then\n-         return True;\n-\n-      --  Otherwise check if it is in convention identifier table\n-\n-      else\n-         for J in 1 .. Convention_Identifiers.Last loop\n-            if N = Convention_Identifiers.Table (J).Name then\n-               return True;\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end if;\n-   end Is_Convention_Name;\n-\n-   ------------------------------\n-   -- Is_Entity_Attribute_Name --\n-   ------------------------------\n-\n-   function Is_Entity_Attribute_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Entity_Attribute_Name .. Last_Entity_Attribute_Name;\n-   end Is_Entity_Attribute_Name;\n-\n-   --------------------------------\n-   -- Is_Function_Attribute_Name --\n-   --------------------------------\n-\n-   function Is_Function_Attribute_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in\n-        First_Renamable_Function_Attribute ..\n-          Last_Renamable_Function_Attribute;\n-   end Is_Function_Attribute_Name;\n-\n-   ----------------------------\n-   -- Is_Locking_Policy_Name --\n-   ----------------------------\n-\n-   function Is_Locking_Policy_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Locking_Policy_Name .. Last_Locking_Policy_Name;\n-   end Is_Locking_Policy_Name;\n-\n-   -----------------------------\n-   -- Is_Operator_Symbol_Name --\n-   -----------------------------\n-\n-   function Is_Operator_Symbol_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Operator_Name .. Last_Operator_Name;\n-   end Is_Operator_Symbol_Name;\n-\n-   --------------------\n-   -- Is_Pragma_Name --\n-   --------------------\n-\n-   function Is_Pragma_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Pragma_Name .. Last_Pragma_Name\n-        or else N = Name_AST_Entry\n-        or else N = Name_Storage_Size\n-        or else N = Name_Storage_Unit;\n-   end Is_Pragma_Name;\n-\n-   ---------------------------------\n-   -- Is_Procedure_Attribute_Name --\n-   ---------------------------------\n-\n-   function Is_Procedure_Attribute_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Procedure_Attribute .. Last_Procedure_Attribute;\n-   end Is_Procedure_Attribute_Name;\n-\n-   ----------------------------\n-   -- Is_Queuing_Policy_Name --\n-   ----------------------------\n-\n-   function Is_Queuing_Policy_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Queuing_Policy_Name .. Last_Queuing_Policy_Name;\n-   end Is_Queuing_Policy_Name;\n-\n-   -------------------------------------\n-   -- Is_Task_Dispatching_Policy_Name --\n-   -------------------------------------\n-\n-   function Is_Task_Dispatching_Policy_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Task_Dispatching_Policy_Name ..\n-                  Last_Task_Dispatching_Policy_Name;\n-   end Is_Task_Dispatching_Policy_Name;\n-\n-   ----------------------------\n-   -- Is_Type_Attribute_Name --\n-   ----------------------------\n-\n-   function Is_Type_Attribute_Name (N : Name_Id) return Boolean is\n-   begin\n-      return N in First_Type_Attribute_Name .. Last_Type_Attribute_Name;\n-   end Is_Type_Attribute_Name;\n-\n-   ----------------------------------\n-   -- Record_Convention_Identifier --\n-   ----------------------------------\n-\n-   procedure Record_Convention_Identifier\n-     (Id         : Name_Id;\n-      Convention : Convention_Id)\n-   is\n-   begin\n-      Convention_Identifiers.Append ((Id, Convention));\n-   end Record_Convention_Identifier;\n-\n-end Snames;\n+------------------------------------------------------------------------------\r\n+--                                                                          --\r\n+--                         GNAT COMPILER COMPONENTS                         --\r\n+--                                                                          --\r\n+--                               S N A M E S                                --\r\n+--                                                                          --\r\n+--                                 B o d y                                  --\r\n+--                                                                          --\r\n+--          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\r\n+--                                                                          --\r\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\r\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\r\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\r\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\r\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\r\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\r\n+-- for  more details.  You should have  received  a copy of the GNU General --\r\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\r\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\r\n+-- MA 02111-1307, USA.                                                      --\r\n+--                                                                          --\r\n+-- As a special exception,  if other files  instantiate  generics from this --\r\n+-- unit, or you link  this unit with other files  to produce an executable, --\r\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\r\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\r\n+-- however invalidate  any other reasons why  the executable file  might be --\r\n+-- covered by the  GNU Public License.                                      --\r\n+--                                                                          --\r\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\r\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\r\n+--                                                                          --\r\n+------------------------------------------------------------------------------\r\n+\r\n+with Namet; use Namet;\r\n+with Table;\r\n+\r\n+package body Snames is\r\n+\r\n+   --  Table used to record convention identifiers\r\n+\r\n+   type Convention_Id_Entry is record\r\n+      Name       : Name_Id;\r\n+      Convention : Convention_Id;\r\n+   end record;\r\n+\r\n+   package Convention_Identifiers is new Table.Table (\r\n+     Table_Component_Type => Convention_Id_Entry,\r\n+     Table_Index_Type     => Int,\r\n+     Table_Low_Bound      => 1,\r\n+     Table_Initial        => 50,\r\n+     Table_Increment      => 200,\r\n+     Table_Name           => \"Name_Convention_Identifiers\");\r\n+\r\n+   --  Table of names to be set by Initialize. Each name is terminated by a\r\n+   --  single #, and the end of the list is marked by a null entry, i.e. by\r\n+   --  two # marks in succession. Note that the table does not include the\r\n+   --  entries for a-z, since these are initialized by Namet itself.\r\n+\r\n+   Preset_Names : constant String :=\r\n+     \"_parent#\" &\r\n+     \"_tag#\" &\r\n+     \"off#\" &\r\n+     \"space#\" &\r\n+     \"time#\" &\r\n+     \"_abort_signal#\" &\r\n+     \"_alignment#\" &\r\n+     \"_assign#\" &\r\n+     \"_chain#\" &\r\n+     \"_clean#\" &\r\n+     \"_controller#\" &\r\n+     \"_entry_bodies#\" &\r\n+     \"_expunge#\" &\r\n+     \"_final_list#\" &\r\n+     \"_idepth#\" &\r\n+     \"_init#\" &\r\n+     \"_local_final_list#\" &\r\n+     \"_master#\" &\r\n+     \"_object#\" &\r\n+     \"_priority#\" &\r\n+     \"_process_atsd#\" &\r\n+     \"_secondary_stack#\" &\r\n+     \"_service#\" &\r\n+     \"_size#\" &\r\n+     \"_tags#\" &\r\n+     \"_task#\" &\r\n+     \"_task_id#\" &\r\n+     \"_task_info#\" &\r\n+     \"_task_name#\" &\r\n+     \"_trace_sp#\" &\r\n+     \"initialize#\" &\r\n+     \"adjust#\" &\r\n+     \"finalize#\" &\r\n+     \"next#\" &\r\n+     \"prev#\" &\r\n+     \"allocate#\" &\r\n+     \"deallocate#\" &\r\n+     \"dereference#\" &\r\n+     \"decimal_io#\" &\r\n+     \"enumeration_io#\" &\r\n+     \"fixed_io#\" &\r\n+     \"float_io#\" &\r\n+     \"integer_io#\" &\r\n+     \"modular_io#\" &\r\n+     \"a_textio#\" &\r\n+     \"a_witeio#\" &\r\n+     \"const#\" &\r\n+     \"<error>#\" &\r\n+     \"go#\" &\r\n+     \"put#\" &\r\n+     \"put_line#\" &\r\n+     \"to#\" &\r\n+     \"finalization#\" &\r\n+     \"finalization_root#\" &\r\n+     \"interfaces#\" &\r\n+     \"standard#\" &\r\n+     \"system#\" &\r\n+     \"text_io#\" &\r\n+     \"wide_text_io#\" &\r\n+     \"addr#\" &\r\n+     \"async#\" &\r\n+     \"get_active_partition_id#\" &\r\n+     \"get_rci_package_receiver#\" &\r\n+     \"origin#\" &\r\n+     \"params#\" &\r\n+     \"partition#\" &\r\n+     \"partition_interface#\" &\r\n+     \"ras#\" &\r\n+     \"rci_name#\" &\r\n+     \"receiver#\" &\r\n+     \"result#\" &\r\n+     \"rpc#\" &\r\n+     \"subp_id#\" &\r\n+     \"Oabs#\" &\r\n+     \"Oand#\" &\r\n+     \"Omod#\" &\r\n+     \"Onot#\" &\r\n+     \"Oor#\" &\r\n+     \"Orem#\" &\r\n+     \"Oxor#\" &\r\n+     \"Oeq#\" &\r\n+     \"One#\" &\r\n+     \"Olt#\" &\r\n+     \"Ole#\" &\r\n+     \"Ogt#\" &\r\n+     \"Oge#\" &\r\n+     \"Oadd#\" &\r\n+     \"Osubtract#\" &\r\n+     \"Oconcat#\" &\r\n+     \"Omultiply#\" &\r\n+     \"Odivide#\" &\r\n+     \"Oexpon#\" &\r\n+     \"ada_83#\" &\r\n+     \"ada_95#\" &\r\n+     \"c_pass_by_copy#\" &\r\n+     \"compile_time_warning#\" &\r\n+     \"component_alignment#\" &\r\n+     \"convention_identifier#\" &\r\n+     \"discard_names#\" &\r\n+     \"elaboration_checks#\" &\r\n+     \"eliminate#\" &\r\n+     \"explicit_overriding#\" &\r\n+     \"extend_system#\" &\r\n+     \"extensions_allowed#\" &\r\n+     \"external_name_casing#\" &\r\n+     \"float_representation#\" &\r\n+     \"initialize_scalars#\" &\r\n+     \"interrupt_state#\" &\r\n+     \"license#\" &\r\n+     \"locking_policy#\" &\r\n+     \"long_float#\" &\r\n+     \"no_run_time#\" &\r\n+     \"normalize_scalars#\" &\r\n+     \"polling#\" &\r\n+     \"persistent_data#\" &\r\n+     \"persistent_object#\" &\r\n+     \"propagate_exceptions#\" &\r\n+     \"queuing_policy#\" &\r\n+     \"ravenscar#\" &\r\n+     \"restricted_run_time#\" &\r\n+     \"restrictions#\" &\r\n+     \"restriction_warnings#\" &\r\n+     \"reviewable#\" &\r\n+     \"source_file_name#\" &\r\n+     \"source_file_name_project#\" &\r\n+     \"style_checks#\" &\r\n+     \"suppress#\" &\r\n+     \"suppress_exception_locations#\" &\r\n+     \"task_dispatching_policy#\" &\r\n+     \"universal_data#\" &\r\n+     \"unsuppress#\" &\r\n+     \"use_vads_size#\" &\r\n+     \"validity_checks#\" &\r\n+     \"warnings#\" &\r\n+     \"abort_defer#\" &\r\n+     \"all_calls_remote#\" &\r\n+     \"annotate#\" &\r\n+     \"assert#\" &\r\n+     \"asynchronous#\" &\r\n+     \"atomic#\" &\r\n+     \"atomic_components#\" &\r\n+     \"attach_handler#\" &\r\n+     \"comment#\" &\r\n+     \"common_object#\" &\r\n+     \"complex_representation#\" &\r\n+     \"controlled#\" &\r\n+     \"convention#\" &\r\n+     \"cpp_class#\" &\r\n+     \"cpp_constructor#\" &\r\n+     \"cpp_virtual#\" &\r\n+     \"cpp_vtable#\" &\r\n+     \"debug#\" &\r\n+     \"elaborate#\" &\r\n+     \"elaborate_all#\" &\r\n+     \"elaborate_body#\" &\r\n+     \"export#\" &\r\n+     \"export_exception#\" &\r\n+     \"export_function#\" &\r\n+     \"export_object#\" &\r\n+     \"export_procedure#\" &\r\n+     \"export_value#\" &\r\n+     \"export_valued_procedure#\" &\r\n+     \"external#\" &\r\n+     \"finalize_storage_only#\" &\r\n+     \"ident#\" &\r\n+     \"import#\" &\r\n+     \"import_exception#\" &\r\n+     \"import_function#\" &\r\n+     \"import_object#\" &\r\n+     \"import_procedure#\" &\r\n+     \"import_valued_procedure#\" &\r\n+     \"inline#\" &\r\n+     \"inline_always#\" &\r\n+     \"inline_generic#\" &\r\n+     \"inspection_point#\" &\r\n+     \"interface#\" &\r\n+     \"interface_name#\" &\r\n+     \"interrupt_handler#\" &\r\n+     \"interrupt_priority#\" &\r\n+     \"java_constructor#\" &\r\n+     \"java_interface#\" &\r\n+     \"keep_names#\" &\r\n+     \"link_with#\" &\r\n+     \"linker_alias#\" &\r\n+     \"linker_options#\" &\r\n+     \"linker_section#\" &\r\n+     \"list#\" &\r\n+     \"machine_attribute#\" &\r\n+     \"main#\" &\r\n+     \"main_storage#\" &\r\n+     \"memory_size#\" &\r\n+     \"no_return#\" &\r\n+     \"obsolescent#\" &\r\n+     \"optimize#\" &\r\n+     \"optional_overriding#\" &\r\n+     \"overriding#\" &\r\n+     \"pack#\" &\r\n+     \"page#\" &\r\n+     \"passive#\" &\r\n+     \"preelaborate#\" &\r\n+     \"priority#\" &\r\n+     \"psect_object#\" &\r\n+     \"pure#\" &\r\n+     \"pure_function#\" &\r\n+     \"remote_call_interface#\" &\r\n+     \"remote_types#\" &\r\n+     \"share_generic#\" &\r\n+     \"shared#\" &\r\n+     \"shared_passive#\" &\r\n+     \"source_reference#\" &\r\n+     \"stream_convert#\" &\r\n+     \"subtitle#\" &\r\n+     \"suppress_all#\" &\r\n+     \"suppress_debug_info#\" &\r\n+     \"suppress_initialization#\" &\r\n+     \"system_name#\" &\r\n+     \"task_info#\" &\r\n+     \"task_name#\" &\r\n+     \"task_storage#\" &\r\n+     \"thread_body#\" &\r\n+     \"time_slice#\" &\r\n+     \"title#\" &\r\n+     \"unchecked_union#\" &\r\n+     \"unimplemented_unit#\" &\r\n+     \"unreferenced#\" &\r\n+     \"unreserve_all_interrupts#\" &\r\n+     \"volatile#\" &\r\n+     \"volatile_components#\" &\r\n+     \"weak_external#\" &\r\n+     \"ada#\" &\r\n+     \"assembler#\" &\r\n+     \"cobol#\" &\r\n+     \"cpp#\" &\r\n+     \"fortran#\" &\r\n+     \"intrinsic#\" &\r\n+     \"java#\" &\r\n+     \"stdcall#\" &\r\n+     \"stubbed#\" &\r\n+     \"asm#\" &\r\n+     \"assembly#\" &\r\n+     \"default#\" &\r\n+     \"dll#\" &\r\n+     \"win32#\" &\r\n+     \"as_is#\" &\r\n+     \"body_file_name#\" &\r\n+     \"casing#\" &\r\n+     \"code#\" &\r\n+     \"component#\" &\r\n+     \"component_size_4#\" &\r\n+     \"copy#\" &\r\n+     \"d_float#\" &\r\n+     \"descriptor#\" &\r\n+     \"dot_replacement#\" &\r\n+     \"dynamic#\" &\r\n+     \"entity#\" &\r\n+     \"external_name#\" &\r\n+     \"first_optional_parameter#\" &\r\n+     \"form#\" &\r\n+     \"g_float#\" &\r\n+     \"gcc#\" &\r\n+     \"gnat#\" &\r\n+     \"gpl#\" &\r\n+     \"ieee_float#\" &\r\n+     \"homonym_number#\" &\r\n+     \"internal#\" &\r\n+     \"link_name#\" &\r\n+     \"lowercase#\" &\r\n+     \"max_size#\" &\r\n+     \"mechanism#\" &\r\n+     \"mixedcase#\" &\r\n+     \"modified_gpl#\" &\r\n+     \"name#\" &\r\n+     \"nca#\" &\r\n+     \"no#\" &\r\n+     \"on#\" &\r\n+     \"parameter_types#\" &\r\n+     \"reference#\" &\r\n+     \"restricted#\" &\r\n+     \"result_mechanism#\" &\r\n+     \"result_type#\" &\r\n+     \"runtime#\" &\r\n+     \"sb#\" &\r\n+     \"secondary_stack_size#\" &\r\n+     \"section#\" &\r\n+     \"semaphore#\" &\r\n+     \"spec_file_name#\" &\r\n+     \"static#\" &\r\n+     \"stack_size#\" &\r\n+     \"subunit_file_name#\" &\r\n+     \"task_stack_size_default#\" &\r\n+     \"task_type#\" &\r\n+     \"time_slicing_enabled#\" &\r\n+     \"top_guard#\" &\r\n+     \"uba#\" &\r\n+     \"ubs#\" &\r\n+     \"ubsb#\" &\r\n+     \"unit_name#\" &\r\n+     \"unknown#\" &\r\n+     \"unrestricted#\" &\r\n+     \"uppercase#\" &\r\n+     \"user#\" &\r\n+     \"vax_float#\" &\r\n+     \"vms#\" &\r\n+     \"working_storage#\" &\r\n+     \"abort_signal#\" &\r\n+     \"access#\" &\r\n+     \"address#\" &\r\n+     \"address_size#\" &\r\n+     \"aft#\" &\r\n+     \"alignment#\" &\r\n+     \"asm_input#\" &\r\n+     \"asm_output#\" &\r\n+     \"ast_entry#\" &\r\n+     \"bit#\" &\r\n+     \"bit_order#\" &\r\n+     \"bit_position#\" &\r\n+     \"body_version#\" &\r\n+     \"callable#\" &\r\n+     \"caller#\" &\r\n+     \"code_address#\" &\r\n+     \"component_size#\" &\r\n+     \"compose#\" &\r\n+     \"constrained#\" &\r\n+     \"count#\" &\r\n+     \"default_bit_order#\" &\r\n+     \"definite#\" &\r\n+     \"delta#\" &\r\n+     \"denorm#\" &\r\n+     \"digits#\" &\r\n+     \"elaborated#\" &\r\n+     \"emax#\" &\r\n+     \"enum_rep#\" &\r\n+     \"epsilon#\" &\r\n+     \"exponent#\" &\r\n+     \"external_tag#\" &\r\n+     \"first#\" &\r\n+     \"first_bit#\" &\r\n+     \"fixed_value#\" &\r\n+     \"fore#\" &\r\n+     \"has_discriminants#\" &\r\n+     \"identity#\" &\r\n+     \"img#\" &\r\n+     \"integer_value#\" &\r\n+     \"large#\" &\r\n+     \"last#\" &\r\n+     \"last_bit#\" &\r\n+     \"leading_part#\" &\r\n+     \"length#\" &\r\n+     \"machine_emax#\" &\r\n+     \"machine_emin#\" &\r\n+     \"machine_mantissa#\" &\r\n+     \"machine_overflows#\" &\r\n+     \"machine_radix#\" &\r\n+     \"machine_rounds#\" &\r\n+     \"machine_size#\" &\r\n+     \"mantissa#\" &\r\n+     \"max_size_in_storage_elements#\" &\r\n+     \"maximum_alignment#\" &\r\n+     \"mechanism_code#\" &\r\n+     \"model_emin#\" &\r\n+     \"model_epsilon#\" &\r\n+     \"model_mantissa#\" &\r\n+     \"model_small#\" &\r\n+     \"modulus#\" &\r\n+     \"null_parameter#\" &\r\n+     \"object_size#\" &\r\n+     \"partition_id#\" &\r\n+     \"passed_by_reference#\" &\r\n+     \"pool_address#\" &\r\n+     \"pos#\" &\r\n+     \"position#\" &\r\n+     \"range#\" &\r\n+     \"range_length#\" &\r\n+     \"round#\" &\r\n+     \"safe_emax#\" &\r\n+     \"safe_first#\" &\r\n+     \"safe_large#\" &\r\n+     \"safe_last#\" &\r\n+     \"safe_small#\" &\r\n+     \"scale#\" &\r\n+     \"scaling#\" &\r\n+     \"signed_zeros#\" &\r\n+     \"size#\" &\r\n+     \"small#\" &\r\n+     \"storage_size#\" &\r\n+     \"storage_unit#\" &\r\n+     \"tag#\" &\r\n+     \"target_name#\" &\r\n+     \"terminated#\" &\r\n+     \"to_address#\" &\r\n+     \"type_class#\" &\r\n+     \"uet_address#\" &\r\n+     \"unbiased_rounding#\" &\r\n+     \"unchecked_access#\" &\r\n+     \"unconstrained_array#\" &\r\n+     \"universal_literal_string#\" &\r\n+     \"unrestricted_access#\" &\r\n+     \"vads_size#\" &\r\n+     \"val#\" &\r\n+     \"valid#\" &\r\n+     \"value_size#\" &\r\n+     \"version#\" &\r\n+     \"wchar_t_size#\" &\r\n+     \"wide_width#\" &\r\n+     \"width#\" &\r\n+     \"word_size#\" &\r\n+     \"adjacent#\" &\r\n+     \"ceiling#\" &\r\n+     \"copy_sign#\" &\r\n+     \"floor#\" &\r\n+     \"fraction#\" &\r\n+     \"image#\" &\r\n+     \"input#\" &\r\n+     \"machine#\" &\r\n+     \"max#\" &\r\n+     \"min#\" &\r\n+     \"model#\" &\r\n+     \"pred#\" &\r\n+     \"remainder#\" &\r\n+     \"rounding#\" &\r\n+     \"succ#\" &\r\n+     \"truncation#\" &\r\n+     \"value#\" &\r\n+     \"wide_image#\" &\r\n+     \"wide_value#\" &\r\n+     \"output#\" &\r\n+     \"read#\" &\r\n+     \"write#\" &\r\n+     \"elab_body#\" &\r\n+     \"elab_spec#\" &\r\n+     \"storage_pool#\" &\r\n+     \"base#\" &\r\n+     \"class#\" &\r\n+     \"ceiling_locking#\" &\r\n+     \"inheritance_locking#\" &\r\n+     \"fifo_queuing#\" &\r\n+     \"priority_queuing#\" &\r\n+     \"fifo_within_priorities#\" &\r\n+     \"access_check#\" &\r\n+     \"accessibility_check#\" &\r\n+     \"discriminant_check#\" &\r\n+     \"division_check#\" &\r\n+     \"elaboration_check#\" &\r\n+     \"index_check#\" &\r\n+     \"length_check#\" &\r\n+     \"overflow_check#\" &\r\n+     \"range_check#\" &\r\n+     \"storage_check#\" &\r\n+     \"tag_check#\" &\r\n+     \"all_checks#\" &\r\n+     \"abort#\" &\r\n+     \"abs#\" &\r\n+     \"accept#\" &\r\n+     \"and#\" &\r\n+     \"all#\" &\r\n+     \"array#\" &\r\n+     \"at#\" &\r\n+     \"begin#\" &\r\n+     \"body#\" &\r\n+     \"case#\" &\r\n+     \"constant#\" &\r\n+     \"declare#\" &\r\n+     \"delay#\" &\r\n+     \"do#\" &\r\n+     \"else#\" &\r\n+     \"elsif#\" &\r\n+     \"end#\" &\r\n+     \"entry#\" &\r\n+     \"exception#\" &\r\n+     \"exit#\" &\r\n+     \"for#\" &\r\n+     \"function#\" &\r\n+     \"generic#\" &\r\n+     \"goto#\" &\r\n+     \"if#\" &\r\n+     \"in#\" &\r\n+     \"is#\" &\r\n+     \"limited#\" &\r\n+     \"loop#\" &\r\n+     \"mod#\" &\r\n+     \"new#\" &\r\n+     \"not#\" &\r\n+     \"null#\" &\r\n+     \"of#\" &\r\n+     \"or#\" &\r\n+     \"others#\" &\r\n+     \"out#\" &\r\n+     \"package#\" &\r\n+     \"pragma#\" &\r\n+     \"private#\" &\r\n+     \"procedure#\" &\r\n+     \"raise#\" &\r\n+     \"record#\" &\r\n+     \"rem#\" &\r\n+     \"renames#\" &\r\n+     \"return#\" &\r\n+     \"reverse#\" &\r\n+     \"select#\" &\r\n+     \"separate#\" &\r\n+     \"subtype#\" &\r\n+     \"task#\" &\r\n+     \"terminate#\" &\r\n+     \"then#\" &\r\n+     \"type#\" &\r\n+     \"use#\" &\r\n+     \"when#\" &\r\n+     \"while#\" &\r\n+     \"with#\" &\r\n+     \"xor#\" &\r\n+     \"divide#\" &\r\n+     \"enclosing_entity#\" &\r\n+     \"exception_information#\" &\r\n+     \"exception_message#\" &\r\n+     \"exception_name#\" &\r\n+     \"file#\" &\r\n+     \"import_address#\" &\r\n+     \"import_largest_value#\" &\r\n+     \"import_value#\" &\r\n+     \"is_negative#\" &\r\n+     \"line#\" &\r\n+     \"rotate_left#\" &\r\n+     \"rotate_right#\" &\r\n+     \"shift_left#\" &\r\n+     \"shift_right#\" &\r\n+     \"shift_right_arithmetic#\" &\r\n+     \"source_location#\" &\r\n+     \"unchecked_conversion#\" &\r\n+     \"unchecked_deallocation#\" &\r\n+     \"to_pointer#\" &\r\n+     \"abstract#\" &\r\n+     \"aliased#\" &\r\n+     \"protected#\" &\r\n+     \"until#\" &\r\n+     \"requeue#\" &\r\n+     \"tagged#\" &\r\n+     \"raise_exception#\" &\r\n+     \"binder#\" &\r\n+     \"body_suffix#\" &\r\n+     \"builder#\" &\r\n+     \"compiler#\" &\r\n+     \"cross_reference#\" &\r\n+     \"default_switches#\" &\r\n+     \"exec_dir#\" &\r\n+     \"executable#\" &\r\n+     \"executable_suffix#\" &\r\n+     \"extends#\" &\r\n+     \"finder#\" &\r\n+     \"global_configuration_pragmas#\" &\r\n+     \"gnatls#\" &\r\n+     \"gnatstub#\" &\r\n+     \"implementation#\" &\r\n+     \"implementation_exceptions#\" &\r\n+     \"implementation_suffix#\" &\r\n+     \"languages#\" &\r\n+     \"library_dir#\" &\r\n+     \"library_auto_init#\" &\r\n+     \"library_gcc#\" &\r\n+     \"library_interface#\" &\r\n+     \"library_kind#\" &\r\n+     \"library_name#\" &\r\n+     \"library_options#\" &\r\n+     \"library_src_dir#\" &\r\n+     \"library_symbol_file#\" &\r\n+     \"library_version#\" &\r\n+     \"linker#\" &\r\n+     \"local_configuration_pragmas#\" &\r\n+     \"locally_removed_files#\" &\r\n+     \"naming#\" &\r\n+     \"object_dir#\" &\r\n+     \"pretty_printer#\" &\r\n+     \"project#\" &\r\n+     \"separate_suffix#\" &\r\n+     \"source_dirs#\" &\r\n+     \"source_files#\" &\r\n+     \"source_list_file#\" &\r\n+     \"spec#\" &\r\n+     \"spec_suffix#\" &\r\n+     \"specification#\" &\r\n+     \"specification_exceptions#\" &\r\n+     \"specification_suffix#\" &\r\n+     \"switches#\" &\r\n+     \"unaligned_valid#\" &\r\n+      \"#\";\r\n+\r\n+   ---------------------\r\n+   -- Generated Names --\r\n+   ---------------------\r\n+\r\n+   --  This section lists the various cases of generated names which are\r\n+   --  built from existing names by adding unique leading and/or trailing\r\n+   --  upper case letters. In some cases these names are built recursively,\r\n+   --  in particular names built from types may be built from types which\r\n+   --  themselves have generated names. In this list, xxx represents an\r\n+   --  existing name to which identifying letters are prepended or appended,\r\n+   --  and a trailing n represents a serial number in an external name that\r\n+   --  has some semantic significance (e.g. the n'th index type of an array).\r\n+\r\n+   --    xxxA    access type for formal xxx in entry param record   (Exp_Ch9)\r\n+   --    xxxB    tag table for tagged type xxx                      (Exp_Ch3)\r\n+   --    xxxB    task body procedure for task xxx                   (Exp_Ch9)\r\n+   --    xxxD    dispatch table for tagged type xxx                 (Exp_Ch3)\r\n+   --    xxxD    discriminal for discriminant xxx                   (Sem_Ch3)\r\n+   --    xxxDn   n'th discr check function for rec type xxx         (Exp_Ch3)\r\n+   --    xxxE    elaboration boolean flag for task xxx              (Exp_Ch9)\r\n+   --    xxxE    dispatch table pointer type for tagged type xxx    (Exp_Ch3)\r\n+   --    xxxE    parameters for accept body for entry xxx           (Exp_Ch9)\r\n+   --    xxxFn   n'th primitive of a tagged type (named xxx)        (Exp_Ch3)\r\n+   --    xxxJ    tag table type index for tagged type xxx           (Exp_Ch3)\r\n+   --    xxxM    master Id value for access type xxx                (Exp_Ch3)\r\n+   --    xxxP    tag table pointer type for tagged type xxx         (Exp_Ch3)\r\n+   --    xxxP    parameter record type for entry xxx                (Exp_Ch9)\r\n+   --    xxxPA   access to parameter record type for entry xxx      (Exp_Ch9)\r\n+   --    xxxPn   pointer type for n'th primitive of tagged type xxx (Exp_Ch3)\r\n+   --    xxxR    dispatch table pointer for tagged type xxx         (Exp_Ch3)\r\n+   --    xxxT    tag table type for tagged type xxx                 (Exp_Ch3)\r\n+   --    xxxT    literal table for enumeration type xxx             (Sem_Ch3)\r\n+   --    xxxV    type for task value record for task xxx            (Exp_Ch9)\r\n+   --    xxxX    entry index constant                               (Exp_Ch9)\r\n+   --    xxxY    dispatch table type for tagged type xxx            (Exp_Ch3)\r\n+   --    xxxZ    size variable for task xxx                         (Exp_Ch9)\r\n+\r\n+   --  TSS names\r\n+\r\n+   --    xxxDA   deep adjust routine for type xxx                   (Exp_TSS)\r\n+   --    xxxDF   deep finalize routine for type xxx                 (Exp_TSS)\r\n+   --    xxxDI   deep initialize routine for type xxx               (Exp_TSS)\r\n+   --    xxxEQ   composite equality routine for record type xxx     (Exp_TSS)\r\n+   --    xxxIP   initialization procedure for type xxx              (Exp_TSS)\r\n+   --    xxxRA   RAs type access routine for type xxx               (Exp_TSS)\r\n+   --    xxxRD   RAs type dereference routine for type xxx          (Exp_TSS)\r\n+   --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\r\n+   --    xxxSI   stream input attribute subprogram for type xxx     (Exp_TSS)\r\n+   --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\r\n+   --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)\r\n+   --    xxxSW   stream write attribute subprogram for type xxx     (Exp_TSS)\r\n+\r\n+   --  Implicit type names\r\n+\r\n+   --    TxxxT   type of literal table for enumeration type xxx     (Sem_Ch3)\r\n+\r\n+   --  (Note: this list is not complete or accurate ???)\r\n+\r\n+   ----------------------\r\n+   -- Get_Attribute_Id --\r\n+   ----------------------\r\n+\r\n+   function Get_Attribute_Id (N : Name_Id) return Attribute_Id is\r\n+   begin\r\n+      return Attribute_Id'Val (N - First_Attribute_Name);\r\n+   end Get_Attribute_Id;\r\n+\r\n+   ------------------\r\n+   -- Get_Check_Id --\r\n+   ------------------\r\n+\r\n+   function Get_Check_Id (N : Name_Id) return Check_Id is\r\n+   begin\r\n+      return Check_Id'Val (N - First_Check_Name);\r\n+   end Get_Check_Id;\r\n+\r\n+   -----------------------\r\n+   -- Get_Convention_Id --\r\n+   -----------------------\r\n+\r\n+   function Get_Convention_Id (N : Name_Id) return Convention_Id is\r\n+   begin\r\n+      case N is\r\n+         when Name_Ada        => return Convention_Ada;\r\n+         when Name_Assembler  => return Convention_Assembler;\r\n+         when Name_C          => return Convention_C;\r\n+         when Name_COBOL      => return Convention_COBOL;\r\n+         when Name_CPP        => return Convention_CPP;\r\n+         when Name_Fortran    => return Convention_Fortran;\r\n+         when Name_Intrinsic  => return Convention_Intrinsic;\r\n+         when Name_Java       => return Convention_Java;\r\n+         when Name_Stdcall    => return Convention_Stdcall;\r\n+         when Name_Stubbed    => return Convention_Stubbed;\r\n+\r\n+         --  If no direct match, then we must have a convention\r\n+         --  identifier pragma that has specified this name.\r\n+\r\n+         when others          =>\r\n+            for J in 1 .. Convention_Identifiers.Last loop\r\n+               if N = Convention_Identifiers.Table (J).Name then\r\n+                  return Convention_Identifiers.Table (J).Convention;\r\n+               end if;\r\n+            end loop;\r\n+\r\n+            raise Program_Error;\r\n+      end case;\r\n+   end Get_Convention_Id;\r\n+\r\n+   ---------------------------\r\n+   -- Get_Locking_Policy_Id --\r\n+   ---------------------------\r\n+\r\n+   function Get_Locking_Policy_Id (N : Name_Id) return Locking_Policy_Id is\r\n+   begin\r\n+      return Locking_Policy_Id'Val (N - First_Locking_Policy_Name);\r\n+   end Get_Locking_Policy_Id;\r\n+\r\n+   -------------------\r\n+   -- Get_Pragma_Id --\r\n+   -------------------\r\n+\r\n+   function Get_Pragma_Id (N : Name_Id) return Pragma_Id is\r\n+   begin\r\n+      if N = Name_AST_Entry then\r\n+         return Pragma_AST_Entry;\r\n+      elsif N = Name_Storage_Size then\r\n+         return Pragma_Storage_Size;\r\n+      elsif N = Name_Storage_Unit then\r\n+         return Pragma_Storage_Unit;\r\n+      elsif N not in First_Pragma_Name .. Last_Pragma_Name then\r\n+         return Unknown_Pragma;\r\n+      else\r\n+         return Pragma_Id'Val (N - First_Pragma_Name);\r\n+      end if;\r\n+   end Get_Pragma_Id;\r\n+\r\n+   ---------------------------\r\n+   -- Get_Queuing_Policy_Id --\r\n+   ---------------------------\r\n+\r\n+   function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id is\r\n+   begin\r\n+      return Queuing_Policy_Id'Val (N - First_Queuing_Policy_Name);\r\n+   end Get_Queuing_Policy_Id;\r\n+\r\n+   ------------------------------------\r\n+   -- Get_Task_Dispatching_Policy_Id --\r\n+   ------------------------------------\r\n+\r\n+   function Get_Task_Dispatching_Policy_Id (N : Name_Id)\r\n+     return Task_Dispatching_Policy_Id is\r\n+   begin\r\n+      return Task_Dispatching_Policy_Id'Val\r\n+        (N - First_Task_Dispatching_Policy_Name);\r\n+   end Get_Task_Dispatching_Policy_Id;\r\n+\r\n+   ----------------\r\n+   -- Initialize --\r\n+   ----------------\r\n+\r\n+   procedure Initialize is\r\n+      P_Index      : Natural;\r\n+      Discard_Name : Name_Id;\r\n+\r\n+   begin\r\n+      P_Index := Preset_Names'First;\r\n+\r\n+      loop\r\n+         Name_Len := 0;\r\n+\r\n+         while Preset_Names (P_Index) /= '#' loop\r\n+            Name_Len := Name_Len + 1;\r\n+            Name_Buffer (Name_Len) := Preset_Names (P_Index);\r\n+            P_Index := P_Index + 1;\r\n+         end loop;\r\n+\r\n+         --  We do the Name_Find call to enter the name into the table, but\r\n+         --  we don't need to do anything with the result, since we already\r\n+         --  initialized all the preset names to have the right value (we\r\n+         --  are depending on the order of the names and Preset_Names).\r\n+\r\n+         Discard_Name := Name_Find;\r\n+         P_Index := P_Index + 1;\r\n+         exit when Preset_Names (P_Index) = '#';\r\n+      end loop;\r\n+\r\n+      --  Make sure that number of names in standard table is correct. If\r\n+      --  this check fails, run utility program XSNAMES to construct a new\r\n+      --  properly matching version of the body.\r\n+\r\n+      pragma Assert (Discard_Name = Last_Predefined_Name);\r\n+\r\n+      --  Initialize the convention identifiers table with the standard\r\n+      --  set of synonyms that we recognize for conventions.\r\n+\r\n+      Convention_Identifiers.Init;\r\n+\r\n+      Convention_Identifiers.Append ((Name_Asm,      Convention_Assembler));\r\n+      Convention_Identifiers.Append ((Name_Assembly, Convention_Assembler));\r\n+\r\n+      Convention_Identifiers.Append ((Name_Default,  Convention_C));\r\n+      Convention_Identifiers.Append ((Name_External, Convention_C));\r\n+\r\n+      Convention_Identifiers.Append ((Name_DLL,      Convention_Stdcall));\r\n+      Convention_Identifiers.Append ((Name_Win32,    Convention_Stdcall));\r\n+   end Initialize;\r\n+\r\n+   -----------------------\r\n+   -- Is_Attribute_Name --\r\n+   -----------------------\r\n+\r\n+   function Is_Attribute_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Attribute_Name .. Last_Attribute_Name;\r\n+   end Is_Attribute_Name;\r\n+\r\n+   -------------------\r\n+   -- Is_Check_Name --\r\n+   -------------------\r\n+\r\n+   function Is_Check_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Check_Name .. Last_Check_Name;\r\n+   end Is_Check_Name;\r\n+\r\n+   ------------------------\r\n+   -- Is_Convention_Name --\r\n+   ------------------------\r\n+\r\n+   function Is_Convention_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      --  Check if this is one of the standard conventions\r\n+\r\n+      if N in First_Convention_Name .. Last_Convention_Name\r\n+        or else N = Name_C\r\n+      then\r\n+         return True;\r\n+\r\n+      --  Otherwise check if it is in convention identifier table\r\n+\r\n+      else\r\n+         for J in 1 .. Convention_Identifiers.Last loop\r\n+            if N = Convention_Identifiers.Table (J).Name then\r\n+               return True;\r\n+            end if;\r\n+         end loop;\r\n+\r\n+         return False;\r\n+      end if;\r\n+   end Is_Convention_Name;\r\n+\r\n+   ------------------------------\r\n+   -- Is_Entity_Attribute_Name --\r\n+   ------------------------------\r\n+\r\n+   function Is_Entity_Attribute_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Entity_Attribute_Name .. Last_Entity_Attribute_Name;\r\n+   end Is_Entity_Attribute_Name;\r\n+\r\n+   --------------------------------\r\n+   -- Is_Function_Attribute_Name --\r\n+   --------------------------------\r\n+\r\n+   function Is_Function_Attribute_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in\r\n+        First_Renamable_Function_Attribute ..\r\n+          Last_Renamable_Function_Attribute;\r\n+   end Is_Function_Attribute_Name;\r\n+\r\n+   ----------------------------\r\n+   -- Is_Locking_Policy_Name --\r\n+   ----------------------------\r\n+\r\n+   function Is_Locking_Policy_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Locking_Policy_Name .. Last_Locking_Policy_Name;\r\n+   end Is_Locking_Policy_Name;\r\n+\r\n+   -----------------------------\r\n+   -- Is_Operator_Symbol_Name --\r\n+   -----------------------------\r\n+\r\n+   function Is_Operator_Symbol_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Operator_Name .. Last_Operator_Name;\r\n+   end Is_Operator_Symbol_Name;\r\n+\r\n+   --------------------\r\n+   -- Is_Pragma_Name --\r\n+   --------------------\r\n+\r\n+   function Is_Pragma_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Pragma_Name .. Last_Pragma_Name\r\n+        or else N = Name_AST_Entry\r\n+        or else N = Name_Storage_Size\r\n+        or else N = Name_Storage_Unit;\r\n+   end Is_Pragma_Name;\r\n+\r\n+   ---------------------------------\r\n+   -- Is_Procedure_Attribute_Name --\r\n+   ---------------------------------\r\n+\r\n+   function Is_Procedure_Attribute_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Procedure_Attribute .. Last_Procedure_Attribute;\r\n+   end Is_Procedure_Attribute_Name;\r\n+\r\n+   ----------------------------\r\n+   -- Is_Queuing_Policy_Name --\r\n+   ----------------------------\r\n+\r\n+   function Is_Queuing_Policy_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Queuing_Policy_Name .. Last_Queuing_Policy_Name;\r\n+   end Is_Queuing_Policy_Name;\r\n+\r\n+   -------------------------------------\r\n+   -- Is_Task_Dispatching_Policy_Name --\r\n+   -------------------------------------\r\n+\r\n+   function Is_Task_Dispatching_Policy_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Task_Dispatching_Policy_Name ..\r\n+                  Last_Task_Dispatching_Policy_Name;\r\n+   end Is_Task_Dispatching_Policy_Name;\r\n+\r\n+   ----------------------------\r\n+   -- Is_Type_Attribute_Name --\r\n+   ----------------------------\r\n+\r\n+   function Is_Type_Attribute_Name (N : Name_Id) return Boolean is\r\n+   begin\r\n+      return N in First_Type_Attribute_Name .. Last_Type_Attribute_Name;\r\n+   end Is_Type_Attribute_Name;\r\n+\r\n+   ----------------------------------\r\n+   -- Record_Convention_Identifier --\r\n+   ----------------------------------\r\n+\r\n+   procedure Record_Convention_Identifier\r\n+     (Id         : Name_Id;\r\n+      Convention : Convention_Id)\r\n+   is\r\n+   begin\r\n+      Convention_Identifiers.Append ((Id, Convention));\r\n+   end Record_Convention_Identifier;\r\n+\r\n+end Snames;\r"}, {"sha": "e7ce941ab9966944e05b3d14cbfcf719f1d866b3", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 1415, "deletions": 1410, "changes": 2825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6"}, {"sha": "d81122763c0c8a5edbfd665e0f386667d57d88b1", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -326,21 +326,22 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Task_Info                   124\n #define  Pragma_Task_Name                   125\n #define  Pragma_Task_Storage                126\n-#define  Pragma_Time_Slice                  127\n-#define  Pragma_Title                       128\n-#define  Pragma_Unchecked_Union             129\n-#define  Pragma_Unimplemented_Unit          130\n-#define  Pragma_Unreferenced                131\n-#define  Pragma_Unreserve_All_Interrupts    132\n-#define  Pragma_Volatile                    133\n-#define  Pragma_Volatile_Components         134\n-#define  Pragma_Weak_External               135\n+#define  Pragma_Thread_Body                 127\n+#define  Pragma_Time_Slice                  128\n+#define  Pragma_Title                       129\n+#define  Pragma_Unchecked_Union             130\n+#define  Pragma_Unimplemented_Unit          131\n+#define  Pragma_Unreferenced                132\n+#define  Pragma_Unreserve_All_Interrupts    133\n+#define  Pragma_Volatile                    134\n+#define  Pragma_Volatile_Components         135\n+#define  Pragma_Weak_External               136\n \n /* The following are deliberately out of alphabetical order, see Snames */\n \n-#define  Pragma_AST_Entry                   136\n-#define  Pragma_Storage_Size                137\n-#define  Pragma_Storage_Unit                138\n+#define  Pragma_AST_Entry                   137\n+#define  Pragma_Storage_Size                138\n+#define  Pragma_Storage_Unit                139\n \n /* Define the numeric values for the conventions.  */\n "}, {"sha": "f204ea6cf71d8c185912ba349efb6d88cf010081", "filename": "gcc/ada/stringt.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fstringt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fstringt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstringt.h?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -26,23 +26,23 @@\n \n /* This file is the C file that corresponds to the Ada package spec\n    Stringt. It was created manually from stringt.ads and stringt.adb\n-\t\t\t\t\t\t\t\t\t    \n+\n    Note: only the access functions are provided, since the tree transformer\n    is not allowed to modify the tree or its auxiliary structures.\n-\t\t\t\t\t\t\t\t\t    \n+\n    This package contains routines for handling the strings table which is\n    used to store string constants encountered in the source, and also those\n    additional string constants generated by compile time concatenation and\n    other similar processing.\n-\t\t\t\t\t\t\t\t\t    \n+\n    A string constant in this table consists of a series of Char_Code values,\n    so that 16-bit character codes can be properly handled if this feature is\n    implemented in the scanner.\n-\t\t\t\t\t\t\t\t\t    \n+\n    There is no guarantee that hashing is used in the implementation. This\n    means that the caller cannot count on having the same Id value for two\n    identical strings stored separately.\n-\t\t\t\t\t\t\t\t\t    \n+\n    The String_Id values reference entries in the Strings table, which\n    contains String_Entry records that record the length of each stored string\n    and its starting location in the String_Chars table.  */"}, {"sha": "1d2efadd83f2ea51de7f24dd6c528104e1338915", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -45,6 +45,9 @@\n #include <fcntl.h>\n #include <sys/stat.h>\n #include \"time.h\"\n+#ifdef VMS\n+#include <unixio.h>\n+#endif\n #else\n #include \"config.h\"\n #include \"system.h\""}, {"sha": "465edb672adeb6aa9421b26084275ffb090124fa", "filename": "gcc/ada/targtyps.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargtyps.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -120,21 +120,22 @@ get_target_long_long_size (void)\n Pos\n get_target_float_size (void)\n {\n-  return FLOAT_TYPE_SIZE;\n+  return fp_prec_to_size (FLOAT_TYPE_SIZE);\n }\n \n Pos\n get_target_double_size (void)\n {\n-  return DOUBLE_TYPE_SIZE;\n+  return fp_prec_to_size (DOUBLE_TYPE_SIZE);\n }\n \n Pos\n get_target_long_double_size (void)\n {\n-  return WIDEST_HARDWARE_FP_SIZE;\n+  return fp_prec_to_size (WIDEST_HARDWARE_FP_SIZE);\n }\n \n+\n Pos\n get_target_pointer_size (void)\n {"}, {"sha": "e0eec16911ca64277e273d0a4ae979a2352134e0", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -4406,7 +4406,7 @@ static void\n process_decls (List_Id gnat_decls,\n                List_Id gnat_decls2,\n                Node_Id gnat_end_list,\n-               int pass1p, \n+               int pass1p,\n                int pass2p)\n {\n   List_Id gnat_decl_array[2];"}, {"sha": "3a01bbee7abe0a18cffa3ec5ea0360c21ca97f13", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -2306,7 +2306,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n       if (TYPE_VAX_FLOATING_POINT_P (type))\n-\tswitch ((int) TYPE_DIGITS_VALUE (type))\n+\tswitch (tree_low_cst (TYPE_DIGITS_VALUE (type), 1))\n \t  {\n \t  case 6:\n \t    dtype = 10;\n@@ -2346,7 +2346,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     case COMPLEX_TYPE:\n       if (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n \t  && TYPE_VAX_FLOATING_POINT_P (type))\n-\tswitch ((int) TYPE_DIGITS_VALUE (type))\n+\tswitch (tree_low_cst (TYPE_DIGITS_VALUE (type), 1))\n \t  {\n \t  case 6:\n \t    dtype = 12;\n@@ -2544,7 +2544,8 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n /* Utility routine for above code to make a field.  */\n \n static tree\n-make_descriptor_field (const char *name, tree type, tree rec_type, tree initial)\n+make_descriptor_field (const char *name, tree type,\n+\t\t       tree rec_type, tree initial)\n {\n   tree field\n     = create_field_decl (get_identifier (name), type, rec_type, 0, 0, 0, 0);"}, {"sha": "a8f228d6eb038610aca201c2825a6b0ce2a69e12", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e0c41c113e68854ec71f059c7dc19e03a7dcf6/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=12e0c41c113e68854ec71f059c7dc19e03a7dcf6", "patch": "@@ -153,8 +153,8 @@ known_alignment (tree exp)\n      We always compute a type_alignment value and return the MAX of it\n      compared with what we get from the expression tree. Just set the\n      type_alignment value to 0 when the type information is to be ignored.  */\n-  type_alignment \n-    = ((POINTER_TYPE_P (TREE_TYPE (exp)) \n+  type_alignment\n+    = ((POINTER_TYPE_P (TREE_TYPE (exp))\n \t&& ! TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n        ? TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))) : 0);\n \n@@ -165,7 +165,7 @@ known_alignment (tree exp)\n     case NON_LVALUE_EXPR:\n       /* Conversions between pointers and integers don't change the alignment\n \t of the underlying object.  */\n-      this_alignment = known_alignment (TREE_OPERAND (exp, 0));\t \n+      this_alignment = known_alignment (TREE_OPERAND (exp, 0));\t\n       break;\n \n     case PLUS_EXPR:\n@@ -357,7 +357,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       tree comparison, this_a1_is_null, this_a2_is_null;\n \n       /* If the length of the first array is a constant, swap our operands\n-\t unless the length of the second array is the constant zero.  \n+\t unless the length of the second array is the constant zero.\n \t Note that we have set the `length' values to the length - 1.  */\n       if (TREE_CODE (length1) == INTEGER_CST\n \t  && ! integer_zerop (fold (build (PLUS_EXPR, bt, length2,\n@@ -406,7 +406,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  nbt = get_base_type (TREE_TYPE (ub1));\n \n \t  comparison\n-\t    = build_binary_op (EQ_EXPR, result_type, \n+\t    = build_binary_op (EQ_EXPR, result_type,\n \t\t\t       build_binary_op (MINUS_EXPR, nbt, ub1, lb1),\n \t\t\t       build_binary_op (MINUS_EXPR, nbt, ub2, lb2));\n \n@@ -491,7 +491,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n    modulus.  */\n \n static tree\n-nonbinary_modular_operation (enum tree_code op_code, \n+nonbinary_modular_operation (enum tree_code op_code,\n                              tree type,\n                              tree lhs,\n                              tree rhs)\n@@ -591,8 +591,8 @@ nonbinary_modular_operation (enum tree_code op_code,\n    have to do here is validate the work done by SEM and handle subtypes.  */\n \n tree\n-build_binary_op (enum tree_code op_code, \n-                 tree result_type, \n+build_binary_op (enum tree_code op_code,\n+                 tree result_type,\n                  tree left_operand,\n                  tree right_operand)\n {\n@@ -937,7 +937,7 @@ build_binary_op (enum tree_code op_code,\n \t    gigi_abort (505);\n \t}\n \n-      /* If we are comparing a fat pointer against zero, we need to \n+      /* If we are comparing a fat pointer against zero, we need to\n \t just compare the data pointer.  */\n       else if (TYPE_FAT_POINTER_P (left_base_type)\n \t       && TREE_CODE (right_operand) == CONSTRUCTOR\n@@ -1651,7 +1651,7 @@ build_simple_component_ref (tree record_variable,\n \t  if (DECL_INTERNAL_P (new_field))\n \t    {\n \t      tree field_ref\n-\t\t= build_simple_component_ref (record_variable, \n+\t\t= build_simple_component_ref (record_variable,\n \t\t\t\t\t      NULL_TREE, new_field, no_fold_p);\n \t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n \t\t\t\t\t\tno_fold_p);\n@@ -1731,7 +1731,7 @@ build_call_alloc_dealloc (tree gnu_obj,\n \n   if (Present (gnat_proc))\n     {\n-      /* The storage pools are obviously always tagged types, but the \n+      /* The storage pools are obviously always tagged types, but the\n \t secondary stack uses the same mechanism and is not tagged */\n       if (Is_Tagged_Type (Etype (gnat_pool)))\n \t{\n@@ -1763,7 +1763,7 @@ build_call_alloc_dealloc (tree gnu_obj,\n \t\t\t\t\tconvert (gnu_size_type, gnu_size)));\n \t  gnu_args\n \t    = chainon (gnu_args,\n-\t\t       build_tree_list (NULL_TREE, \n+\t\t       build_tree_list (NULL_TREE,\n \t\t\t\t\tconvert (gnu_size_type, gnu_align)));\n \n \t  gnu_call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (gnu_proc)),\n@@ -1776,7 +1776,7 @@ build_call_alloc_dealloc (tree gnu_obj,\n       else\n \t{\n \t  /* The size is the second parameter */\n-\t  Entity_Id gnat_size_type \n+\t  Entity_Id gnat_size_type\n \t    = Etype (Next_Formal (First_Formal (gnat_proc)));\n \t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n \t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n@@ -1998,7 +1998,7 @@ build_allocator (tree type,\n   return convert (result_type, result);\n }\n \f\n-/* Fill in a VMS descriptor for EXPR and return a constructor for it. \n+/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n    GNAT_FORMAL is how we find the descriptor record.  */\n \n tree"}]}