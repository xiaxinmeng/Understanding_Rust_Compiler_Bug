{"sha": "0b3ec8f48f291364676f1e472721391f27995f17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzZWM4ZjQ4ZjI5MTM2NDY3NmYxZTQ3MjcyMTM5MWYyNzk5NWYxNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-03-14T23:02:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-03-14T23:02:01Z"}, "message": "PR libstdc++/78420 Make std::less etc. yield total order for pointers\n\nIn order for std::less<T*> etc. to meet the total order requirements of\n[comparisons] p2 we need to cast unrelated pointers to uintptr_t before\ncomparing them. Those casts aren't allowed in constant expressions, so\nonly cast when __builtin_constant_p says the result of the comparison is\nnot a compile-time constant (because the arguments are not constants, or\nthe result of the comparison is unspecified). When the result is\nconstant just compare the pointers directly without casting.\n\nThis ensures that the function can be called in constant expressions\nwith suitable arguments, but still yields a total order even for\notherwise unspecified pointer comparisons.\n\nFor std::less<void> etc. add new overloads for pointers, which use\nstd::less<common_type_t<T*,U*>> directly. Also change the generic\noverloads to detect when the comparison would call a built-in relational\noperator with pointer operands, and dispatch that case to the\ncorresponding specialization for void pointers.\n\n\tPR libstdc++/78420\n\t* include/bits/stl_function.h (greater<_Tp*>, less<_Tp*>)\n\t(greater_equal<_Tp*>, less_equal<_Tp>*): Add partial specializations\n\tto ensure total order for pointers.\n\t(greater<void>, less<void>, greater_equal<void>, less_equal<void>):\n\tAdd operator() overloads for pointer arguments and make generic\n\toverloads dispatch to new _S_cmp functions when comparisons would\n\tuse built-in operators for pointers.\n\t* testsuite/20_util/function_objects/comparisons_pointer.cc: New.\n\nFrom-SVN: r258540", "tree": {"sha": "2cc7e822668858f2c90b9421515233ae9d9a32ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cc7e822668858f2c90b9421515233ae9d9a32ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b3ec8f48f291364676f1e472721391f27995f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3ec8f48f291364676f1e472721391f27995f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3ec8f48f291364676f1e472721391f27995f17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3ec8f48f291364676f1e472721391f27995f17/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcdfd47859e46ab2215bdc629fafe83e3c336f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcdfd47859e46ab2215bdc629fafe83e3c336f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcdfd47859e46ab2215bdc629fafe83e3c336f1c"}], "stats": {"total": 496, "additions": 478, "deletions": 18}, "files": [{"sha": "c8c465652106cc5e08e25f2521132158400deb9b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3ec8f48f291364676f1e472721391f27995f17/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3ec8f48f291364676f1e472721391f27995f17/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0b3ec8f48f291364676f1e472721391f27995f17", "patch": "@@ -1,3 +1,15 @@\n+2018-03-14  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/78420\n+\t* include/bits/stl_function.h (greater<_Tp*>, less<_Tp*>)\n+\t(greater_equal<_Tp*>, less_equal<_Tp>*): Add partial specializations\n+\tto ensure total order for pointers.\n+\t(greater<void>, less<void>, greater_equal<void>, less_equal<void>):\n+\tAdd operator() overloads for pointer arguments and make generic\n+\toverloads dispatch to new _S_cmp functions when comparisons would\n+\tuse built-in operators for pointers.\n+\t* testsuite/20_util/function_objects/comparisons_pointer.cc: New.\n+\n 2018-03-12  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/84773"}, {"sha": "0affaf7da3a9e9df526da61363508315a6fd9363", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "modified", "additions": 260, "deletions": 18, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3ec8f48f291364676f1e472721391f27995f17/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3ec8f48f291364676f1e472721391f27995f17/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=0b3ec8f48f291364676f1e472721391f27995f17", "patch": "@@ -406,14 +406,65 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return __x <= __y; }\n     };\n \n-#if __cplusplus > 201103L\n+  // Partial specialization of std::greater for pointers.\n+  template<typename _Tp>\n+    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n+    {\n+      _GLIBCXX14_CONSTEXPR bool\n+      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n+      {\n+\tif (__builtin_constant_p (__x > __y))\n+\t  return __x > __y;\n+\treturn (__UINTPTR_TYPE__)__x > (__UINTPTR_TYPE__)__y;\n+      }\n+    };\n+\n+  // Partial specialization of std::less for pointers.\n+  template<typename _Tp>\n+    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n+    {\n+      _GLIBCXX14_CONSTEXPR bool\n+      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n+      {\n+\tif (__builtin_constant_p (__x < __y))\n+\t  return __x < __y;\n+\treturn (__UINTPTR_TYPE__)__x < (__UINTPTR_TYPE__)__y;\n+      }\n+    };\n+\n+  // Partial specialization of std::greater_equal for pointers.\n+  template<typename _Tp>\n+    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n+    {\n+      _GLIBCXX14_CONSTEXPR bool\n+      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n+      {\n+\tif (__builtin_constant_p (__x >= __y))\n+\t  return __x >= __y;\n+\treturn (__UINTPTR_TYPE__)__x >= (__UINTPTR_TYPE__)__y;\n+      }\n+    };\n+\n+  // Partial specialization of std::less_equal for pointers.\n+  template<typename _Tp>\n+    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>\n+    {\n+      _GLIBCXX14_CONSTEXPR bool\n+      operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW\n+      {\n+\tif (__builtin_constant_p (__x <= __y))\n+\t  return __x <= __y;\n+\treturn (__UINTPTR_TYPE__)__x <= (__UINTPTR_TYPE__)__y;\n+      }\n+    };\n+\n+#if __cplusplus >= 201402L\n   /// One of the @link comparison_functors comparison functors@endlink.\n   template<>\n     struct equal_to<void>\n     {\n       template <typename _Tp, typename _Up>\n-\t_GLIBCXX14_CONSTEXPR\n-\tauto\n+\tconstexpr auto\n \toperator()(_Tp&& __t, _Up&& __u) const\n \tnoexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))\n \t-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))\n@@ -427,8 +478,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct not_equal_to<void>\n     {\n       template <typename _Tp, typename _Up>\n-\t_GLIBCXX14_CONSTEXPR\n-\tauto\n+\tconstexpr auto\n \toperator()(_Tp&& __t, _Up&& __u) const\n \tnoexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))\n \t-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))\n@@ -442,61 +492,253 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct greater<void>\n     {\n       template <typename _Tp, typename _Up>\n-\t_GLIBCXX14_CONSTEXPR\n-\tauto\n+\tconstexpr auto\n \toperator()(_Tp&& __t, _Up&& __u) const\n \tnoexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))\n \t-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))\n-\t{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }\n+\t{\n+\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n+\t\t\t__ptr_cmp<_Tp, _Up>{});\n+\t}\n+\n+      template<typename _Tp, typename _Up>\n+\tconstexpr bool\n+\toperator()(_Tp* __t, _Up* __u) const noexcept\n+\t{ return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n \n       typedef __is_transparent is_transparent;\n+\n+    private:\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr decltype(auto)\n+\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n+\t{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }\n+\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n+\t{\n+\t  return greater<const volatile void*>{}(\n+\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n+\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n+\t}\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded;\n+\n+      // False if we can call operator>(T,U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up, __void_t<\n+\t  decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded2 : true_type { };\n+\n+      // False if we can call T.operator>(U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n+\t  decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up> : __not_overloaded2<_Tp, _Up> { };\n+\n+      template<typename _Tp, typename _Up>\n+\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n+\t      is_convertible<_Tp, const volatile void*>,\n+\t      is_convertible<_Up, const volatile void*>>;\n     };\n \n   /// One of the @link comparison_functors comparison functors@endlink.\n   template<>\n     struct less<void>\n     {\n       template <typename _Tp, typename _Up>\n-\t_GLIBCXX14_CONSTEXPR\n-\tauto\n+\tconstexpr auto\n \toperator()(_Tp&& __t, _Up&& __u) const\n \tnoexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))\n \t-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))\n-\t{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }\n+\t{\n+\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n+\t\t\t__ptr_cmp<_Tp, _Up>{});\n+\t}\n+\n+      template<typename _Tp, typename _Up>\n+\tconstexpr bool\n+\toperator()(_Tp* __t, _Up* __u) const noexcept\n+\t{ return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n \n       typedef __is_transparent is_transparent;\n+\n+    private:\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr decltype(auto)\n+\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n+\t{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }\n+\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n+\t{\n+\t  return less<const volatile void*>{}(\n+\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n+\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n+\t}\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded;\n+\n+      // False if we can call operator<(T,U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up, __void_t<\n+\t  decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded2 : true_type { };\n+\n+      // False if we can call T.operator<(U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n+\t  decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up> : __not_overloaded2<_Tp, _Up> { };\n+\n+      template<typename _Tp, typename _Up>\n+\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n+\t      is_convertible<_Tp, const volatile void*>,\n+\t      is_convertible<_Up, const volatile void*>>;\n     };\n \n   /// One of the @link comparison_functors comparison functors@endlink.\n   template<>\n     struct greater_equal<void>\n     {\n       template <typename _Tp, typename _Up>\n-\t_GLIBCXX14_CONSTEXPR\n-\tauto\n+\tconstexpr auto\n \toperator()(_Tp&& __t, _Up&& __u) const\n \tnoexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))\n \t-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))\n-\t{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }\n+\t{\n+\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n+\t\t\t__ptr_cmp<_Tp, _Up>{});\n+\t}\n+\n+      template<typename _Tp, typename _Up>\n+\tconstexpr bool\n+\toperator()(_Tp* __t, _Up* __u) const noexcept\n+\t{ return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n \n       typedef __is_transparent is_transparent;\n+\n+    private:\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr decltype(auto)\n+\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n+\t{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }\n+\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n+\t{\n+\t  return greater_equal<const volatile void*>{}(\n+\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n+\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n+\t}\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded;\n+\n+      // False if we can call operator>=(T,U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up, __void_t<\n+\t  decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded2 : true_type { };\n+\n+      // False if we can call T.operator>=(U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n+\t  decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up> : __not_overloaded2<_Tp, _Up> { };\n+\n+      template<typename _Tp, typename _Up>\n+\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n+\t      is_convertible<_Tp, const volatile void*>,\n+\t      is_convertible<_Up, const volatile void*>>;\n     };\n \n   /// One of the @link comparison_functors comparison functors@endlink.\n   template<>\n     struct less_equal<void>\n     {\n       template <typename _Tp, typename _Up>\n-\t_GLIBCXX14_CONSTEXPR\n-\tauto\n+\tconstexpr auto\n \toperator()(_Tp&& __t, _Up&& __u) const\n \tnoexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))\n \t-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))\n-\t{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }\n+\t{\n+\t  return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),\n+\t\t\t__ptr_cmp<_Tp, _Up>{});\n+\t}\n+\n+      template<typename _Tp, typename _Up>\n+\tconstexpr bool\n+\toperator()(_Tp* __t, _Up* __u) const noexcept\n+\t{ return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }\n \n       typedef __is_transparent is_transparent;\n+\n+    private:\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr decltype(auto)\n+\t_S_cmp(_Tp&& __t, _Up&& __u, false_type)\n+\t{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }\n+\n+      template <typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept\n+\t{\n+\t  return less_equal<const volatile void*>{}(\n+\t      static_cast<const volatile void*>(std::forward<_Tp>(__t)),\n+\t      static_cast<const volatile void*>(std::forward<_Up>(__u)));\n+\t}\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded;\n+\n+      // False if we can call operator<=(T,U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up, __void_t<\n+\t  decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up, typename = void>\n+\tstruct __not_overloaded2 : true_type { };\n+\n+      // False if we can call T.operator<=(U)\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded2<_Tp, _Up, __void_t<\n+\t  decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>\n+\t: false_type { };\n+\n+      template<typename _Tp, typename _Up>\n+\tstruct __not_overloaded<_Tp, _Up> : __not_overloaded2<_Tp, _Up> { };\n+\n+      template<typename _Tp, typename _Up>\n+\tusing __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,\n+\t      is_convertible<_Tp, const volatile void*>,\n+\t      is_convertible<_Up, const volatile void*>>;\n     };\n-#endif\n+#endif // C++14\n   /** @}  */\n \n   // 20.3.4 logical operations"}, {"sha": "6b2b8be0f519ed885cfc35d018ff90b4d7a0ff9f", "filename": "libstdc++-v3/testsuite/20_util/function_objects/comparisons_pointer.cc", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3ec8f48f291364676f1e472721391f27995f17/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fcomparisons_pointer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3ec8f48f291364676f1e472721391f27995f17/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fcomparisons_pointer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fcomparisons_pointer.cc?ref=0b3ec8f48f291364676f1e472721391f27995f17", "patch": "@@ -0,0 +1,206 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+#include <functional>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+int b[8];\n+int a[8];\n+\n+void\n+test01()\n+{\n+  auto p = a + 8;\n+  std::greater<int*> gt;\n+\n+  std::stringstream ss;\n+  ss << gt(p, b) << ' ' << gt(b, p) << ' ' << (!gt(p, b) && !gt(b, p));\n+  int sum = 0, n = 0;\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+#if __cplusplus >= 201402L\n+  static_assert( gt(a+1, a), \"constexpr greater<int*>\" );\n+  static_assert( !gt(a, a+1), \"constexpr greater<int*>\" );\n+\n+  ss.str(\"\");\n+  ss.clear();\n+  sum = 0;\n+  auto p2 = a + 8;\n+  std::greater<> gt2;\n+  ss << gt2(p2, b) << ' ' << gt2(b, p2) << ' ' << (!gt2(p2, b) && !gt2(b, p2));\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+  static_assert( gt2(a+1, a), \"constexpr greater<>\" );\n+  static_assert( !gt2(a, a+1), \"constexpr greater<>\" );\n+#endif\n+}\n+\n+void\n+test02()\n+{\n+  auto p = a + 8;\n+  std::less<int*> lt;\n+\n+  std::stringstream ss;\n+  ss << lt(p, b) << ' ' << lt(b, p) << ' ' << (!lt(p, b) && !lt(b, p));\n+  int sum = 0, n = 0;\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+#if __cplusplus >= 201402L\n+  static_assert( lt(a, a+1), \"constexpr less<int*>\" );\n+  static_assert( !lt(a+1, a), \"constexpr less<int*>\" );\n+\n+  ss.str(\"\");\n+  ss.clear();\n+  sum = 0;\n+  auto p2 = a + 8;\n+  std::less<> lt2;\n+  ss << lt2(p2, b) << ' ' << lt2(b, p2) << ' ' << (!lt2(p2, b) && !lt2(b, p2));\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+  static_assert( lt2(a, a+1), \"constexpr less<>\" );\n+  static_assert( !lt2(a+1, a), \"constexpr less<>\" );\n+#endif\n+}\n+\n+void\n+test03()\n+{\n+  auto p = a + 8;\n+  std::greater_equal<int*> ge;\n+\n+  std::stringstream ss;\n+  ss << !ge(p, b) << ' ' << !ge(b, p) << ' ' << (ge(p, b) && ge(b, p));\n+  int sum = 0, n = 0;\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+#if __cplusplus >= 201402L\n+  static_assert( !ge(a, a+1), \"constexpr greater_equal<int*>\" );\n+  static_assert( ge(a, a), \"constexpr greater_equal<int*>\" );\n+  static_assert( ge(a+1, a), \"constexpr greater_equal<int*>\" );\n+\n+  ss.str(\"\");\n+  ss.clear();\n+  sum = 0;\n+  auto p2 = a + 8;\n+  std::greater_equal<> ge2;\n+  ss << !ge2(p2, b) << ' ' << !ge2(b, p2) << ' ' << (ge2(p2, b) && ge2(b, p2));\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+  static_assert( !ge2(a, a+1), \"constexpr greater_equal<>\" );\n+  static_assert( ge2(a, a), \"constexpr greater_equal<>\" );\n+  static_assert( ge2(a+1, a), \"constexpr greater_equal<>\" );\n+#endif\n+}\n+\n+void\n+test04()\n+{\n+  auto p = a + 8;\n+  std::less_equal<int*> le;\n+\n+  std::stringstream ss;\n+  ss << !le(p, b) << ' ' << !le(b, p) << ' ' << (le(p, b) && le(b, p));\n+  int sum = 0, n = 0;\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+#if __cplusplus >= 201402L\n+  static_assert( !le(a+1, a), \"constexpr less_equal<int*>\" );\n+  static_assert( le(a, a), \"constexpr less_equal<int*>\" );\n+  static_assert( le(a, a+1), \"constexpr less_equal<int*>\" );\n+\n+  ss.str(\"\");\n+  ss.clear();\n+  sum = 0;\n+  auto p2 = a + 8;\n+  std::less_equal<> le2;\n+  ss << !le2(p2, b) << ' ' << !le2(b, p2) << ' ' << (le2(p2, b) && le2(b, p2));\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+  static_assert( !le2(a+1, a), \"constexpr less_equal<>\" );\n+  static_assert( le2(a, a), \"constexpr less_equal<>\" );\n+  static_assert( le2(a, a+1), \"constexpr less_equal<>\" );\n+#endif\n+}\n+\n+struct X {\n+  operator const X*() const { return this; }\n+};\n+\n+X x;\n+X y[4];\n+\n+void\n+test05()\n+{\n+  std::less<const X*> lt;\n+  auto p = y + 4;\n+  std::stringstream ss;\n+  ss << lt(x, p) << ' ' << lt(p, x) << ' ' << (!lt(p, x) && !lt(x, p));\n+  int sum = 0;\n+  int n = 0;\n+  while (ss >> n)\n+    sum += n;\n+  assert( sum == 1 );\n+\n+#if __cplusplus >= 201402L\n+  static_assert( lt(y, y+1), \"constexpr less<const X*>\" );\n+  static_assert( !lt(y+1, y), \"constexpr less<const X*>\" );\n+\n+  ss.str(\"\");\n+  ss.clear();\n+  sum = 0;\n+  auto p2 = y + 4;\n+  std::less<> lt2;\n+  ss << lt2(x, p2) << ' ' << lt2(p2, x) << ' ' << (!lt2(x, p2) && !lt2(p2, x));\n+  while (ss >> n)\n+    sum += n;\n+  VERIFY( sum == 1 );\n+\n+  static_assert( lt2(y, y+1), \"constexpr less<>\" );\n+  static_assert( !lt2(y+1, y), \"constexpr less<>\" );\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}]}