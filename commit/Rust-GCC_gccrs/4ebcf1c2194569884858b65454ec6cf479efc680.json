{"sha": "4ebcf1c2194569884858b65454ec6cf479efc680", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViY2YxYzIxOTQ1Njk4ODQ4NThiNjU0NTRlYzZjZjQ3OWVmYzY4MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-06-04T15:17:29Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-06-04T15:17:29Z"}, "message": "[C++ PATCH] structure tag lookup\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-06/msg00179.html\n\t* name-lookup.c (lookup_type_scope_1): Reimplement, handle local\n\tand namespace scopes separately.\n\nFrom-SVN: r271912", "tree": {"sha": "abd33982bfebde560ac0165472f1e68e75668731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abd33982bfebde560ac0165472f1e68e75668731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ebcf1c2194569884858b65454ec6cf479efc680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebcf1c2194569884858b65454ec6cf479efc680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ebcf1c2194569884858b65454ec6cf479efc680", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebcf1c2194569884858b65454ec6cf479efc680/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b9202ea9ee9b9147a2c2e3f478f1f3eb0b5c174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b9202ea9ee9b9147a2c2e3f478f1f3eb0b5c174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b9202ea9ee9b9147a2c2e3f478f1f3eb0b5c174"}], "stats": {"total": 130, "additions": 60, "deletions": 70}, "files": [{"sha": "c28faf9014449a75cbb3c77d5de5be214dff398f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebcf1c2194569884858b65454ec6cf479efc680/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebcf1c2194569884858b65454ec6cf479efc680/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4ebcf1c2194569884858b65454ec6cf479efc680", "patch": "@@ -1,3 +1,8 @@\n+2019-06-04  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.c (lookup_type_scope_1): Reimplement, handle local\n+\tand namespace scopes separately.\n+\n 2019-06-04  Harald van Dijk  <harald@gigawatt.nl>\n \n \tPR c++/60531 - Wrong error about unresolved overloaded function"}, {"sha": "632253a0d8c38732cfd896b3fa3e39f31b8cefa6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 55, "deletions": 70, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebcf1c2194569884858b65454ec6cf479efc680/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebcf1c2194569884858b65454ec6cf479efc680/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4ebcf1c2194569884858b65454ec6cf479efc680", "patch": "@@ -6460,81 +6460,66 @@ lookup_name_prefer_type (tree name, int prefer_type)\n static tree\n lookup_type_scope_1 (tree name, tag_scope scope)\n {\n-  cxx_binding *iter = NULL;\n-  tree val = NULL_TREE;\n-  cp_binding_level *level = NULL;\n-\n-  /* Look in non-namespace scope first.  */\n-  if (current_binding_level->kind != sk_namespace)\n-    iter = outer_binding (name, NULL, /*class_p=*/ true);\n-  for (; iter; iter = outer_binding (name, iter, /*class_p=*/ true))\n-    {\n-      /* Check if this is the kind of thing we're looking for.\n-\t If SCOPE is TS_CURRENT, also make sure it doesn't come from\n-\t base class.  For ITER->VALUE, we can simply use\n-\t INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to use\n-\t our own check.\n-\n-\t We check ITER->TYPE before ITER->VALUE in order to handle\n-\t   typedef struct C {} C;\n-\t correctly.  */\n-\n-      if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES)\n-\t  && (scope != ts_current\n-\t      || LOCAL_BINDING_P (iter)\n-\t      || DECL_CONTEXT (iter->type) == iter->scope->this_entity))\n-\tval = iter->type;\n-      else if ((scope != ts_current\n-\t\t|| !INHERITED_VALUE_BINDING_P (iter))\n-\t       && qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n-\tval = iter->value;\n-\n-      if (val)\n-\tbreak;\n-    }\n+  cp_binding_level *b = current_binding_level;\n \n-  /* Look in namespace scope.  */\n-  if (val)\n-    level = iter->scope;\n-  else\n-    {\n-      tree ns = current_decl_namespace ();\n+  if (b->kind != sk_namespace)\n+    /* Look in non-namespace scopes.  */\n+    for (cxx_binding *iter = NULL;\n+\t (iter = outer_binding (name, iter, /*class_p=*/ true)); )\n+      {\n+\t/* First check we're supposed to be looking in this scope --\n+\t   if we're not, we're done.  */\n+\tfor (; b != iter->scope; b = b->level_chain)\n+\t  if (!(b->kind == sk_cleanup\n+\t\t|| b->kind == sk_template_parms\n+\t\t|| b->kind == sk_function_parms\n+\t\t|| (b->kind == sk_class\n+\t\t    && scope == ts_within_enclosing_non_class)))\n+\t    return NULL_TREE;\n+\n+\t/* Check if this is the kind of thing we're looking for.  If\n+\t   SCOPE is TS_CURRENT, also make sure it doesn't come from\n+\t   base class.  For ITER->VALUE, we can simply use\n+\t   INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to\n+\t   use our own check.\n+\n+\t   We check ITER->TYPE before ITER->VALUE in order to handle\n+\t     typedef struct C {} C;\n+\t   correctly.  */\n+\tif (tree type = iter->type)\n+\t  if ((scope != ts_current\n+\t       || LOCAL_BINDING_P (iter)\n+\t       || DECL_CONTEXT (type) == iter->scope->this_entity)\n+\t      && qualify_lookup (iter->type, LOOKUP_PREFER_TYPES))\n+\t    return iter->type;\n+\n+\tif ((scope != ts_current\n+\t     || !INHERITED_VALUE_BINDING_P (iter))\n+\t    && qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n+\t  return iter->value;\n+      }\n \n-      if (tree *slot = find_namespace_slot (ns, name))\n-\t{\n-\t  /* If this is the kind of thing we're looking for, we're done.  */\n-\t  if (tree type = MAYBE_STAT_TYPE (*slot))\n-\t    if (qualify_lookup (type, LOOKUP_PREFER_TYPES))\n-\t      val = type;\n-\t  if (!val)\n-\t    {\n-\t      if (tree decl = MAYBE_STAT_DECL (*slot))\n-\t\tif (qualify_lookup (decl, LOOKUP_PREFER_TYPES))\n-\t\t  val = decl;\n-\t    }\n-\t  level = NAMESPACE_LEVEL (ns);\n-\t}\n-    }\n+  /* Now check if we can look in namespace scope.  */\n+  for (; b->kind != sk_namespace; b = b->level_chain)\n+    if (!(b->kind == sk_cleanup\n+\t  || b->kind == sk_template_parms\n+\t  || b->kind == sk_function_parms\n+\t  || (b->kind == sk_class\n+\t      && scope == ts_within_enclosing_non_class)))\n+      return NULL_TREE;\n \n-  /* Type found, check if it is in the allowed scopes, ignoring cleanup\n-     and template parameter scopes.  */\n-  if (val)\n+  /* Look in the innermost namespace.  */\n+  tree ns = b->this_entity;\n+  if (tree *slot = find_namespace_slot (ns, name))\n     {\n-      cp_binding_level *b = current_binding_level;\n-      while (b)\n-\t{\n-\t  if (level == b)\n-\t    return val;\n+      /* If this is the kind of thing we're looking for, we're done.  */\n+      if (tree type = MAYBE_STAT_TYPE (*slot))\n+\tif (qualify_lookup (type, LOOKUP_PREFER_TYPES))\n+\t  return type;\n \n-\t  if (b->kind == sk_cleanup || b->kind == sk_template_parms\n-\t      || b->kind == sk_function_parms)\n-\t    b = b->level_chain;\n-\t  else if (b->kind == sk_class\n-\t\t   && scope == ts_within_enclosing_non_class)\n-\t    b = b->level_chain;\n-\t  else\n-\t    break;\n-\t}\n+      if (tree decl = MAYBE_STAT_DECL (*slot))\n+\tif (qualify_lookup (decl, LOOKUP_PREFER_TYPES))\n+\t  return decl;\n     }\n \n   return NULL_TREE;"}]}