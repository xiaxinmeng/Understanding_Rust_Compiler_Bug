{"sha": "a7502c4a614238ac3f80271886b217b156bdf923", "node_id": "C_kwDOANBUbNoAKGE3NTAyYzRhNjE0MjM4YWMzZjgwMjcxODg2YjIxN2IxNTZiZGY5MjM", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2023-02-07T04:23:00Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2023-02-07T04:24:15Z"}, "message": "Enable 512 bit vector for zen4\n\nWhile internally 512 registers are splits into two 256 halves, 512 bit vectors\nreduces number of instructions to retire and has chance to improve paralelism.\nThere are few tsvc benchmarks that improves significantly:\n\n           runtime\nbenchmark  256bit  512bit\ns2275      48.57   20.67    -58%\ns311       32.29   16.06    -50%\ns312       32.30   16.07    -50%\nvsumr      32.30   16.07    -50%\ns314       10.77   5.42     -50%\ns313       21.52   10.85    -50%\nvdotr      43.05   21.69    -50%\ns316       10.80   5.64     -48%\ns235       61.72   33.91    -45%\ns161       15.91   9.95     -38%\ns3251      32.13   20.31    -36%\n\nAnd there are no benchmarks with off-noise regression.  The basic matrix\nmultiplication loop improves by 32%.  It is also expected that 512 bit\nvectors are more power effecient (I can't masure that).\n\nThe down side is that loops with low trip counts may get slower when the\nunvectorized prologue and epilogue is hit more often.  With SPECfp this\nproblem happens with x264 (12% regression) and bwaves (6% regression)\nand this is tracked in\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=108410\nand will need more work on vectorizer to support masked epilogues.\n\nAfter some additional testing it seems that using 512 bit vectors by\ndefault is now overall better choice.\n\nBootstrapped/regtested x86_64-linux. Plan to commit it tomorrow.\n\n\t* config/i386/x86-tune.def (X86_TUNE_AVX256_OPTIMAL): Turn off\n\tfor znver4.", "tree": {"sha": "0c559825291ae69f4641981ee44114a4576a94d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c559825291ae69f4641981ee44114a4576a94d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7502c4a614238ac3f80271886b217b156bdf923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7502c4a614238ac3f80271886b217b156bdf923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7502c4a614238ac3f80271886b217b156bdf923", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7502c4a614238ac3f80271886b217b156bdf923/comments", "author": null, "committer": null, "parents": [{"sha": "f0e73dd031135695249f87589a0d250bf2f334b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e73dd031135695249f87589a0d250bf2f334b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0e73dd031135695249f87589a0d250bf2f334b6"}], "stats": {"total": 2, "additions": 1, "deletions": 1}, "files": [{"sha": "3054656a12c27e8cc7673be1c84af41548fb6e2c", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7502c4a614238ac3f80271886b217b156bdf923/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7502c4a614238ac3f80271886b217b156bdf923/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=a7502c4a614238ac3f80271886b217b156bdf923", "patch": "@@ -551,7 +551,7 @@ DEF_TUNE (X86_TUNE_AVX128_OPTIMAL, \"avx128_optimal\", m_BDVER | m_BTVER2\n \n /* X86_TUNE_AVX256_OPTIMAL: Use 256-bit AVX instructions instead of 512-bit AVX\n    instructions in the auto-vectorizer.  */\n-DEF_TUNE (X86_TUNE_AVX256_OPTIMAL, \"avx256_optimal\", m_CORE_AVX512 | m_ZNVER4)\n+DEF_TUNE (X86_TUNE_AVX256_OPTIMAL, \"avx256_optimal\", m_CORE_AVX512)\n \n /* X86_TUNE_AVX256_SPLIT_REGS: if true, AVX512 ops are split into two AVX256 ops.  */\n DEF_TUNE (X86_TUNE_AVX512_SPLIT_REGS, \"avx512_split_regs\", m_ZNVER4)"}]}