{"sha": "8c2289931106421819cb14ee25976ab8b1c06ff1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMyMjg5OTMxMTA2NDIxODE5Y2IxNGVlMjU5NzZhYjhiMWMwNmZmMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-08-02T09:31:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-08-02T09:31:34Z"}, "message": "vec.h (vec::sort): Add gcc_qsort_r support.\n\n2019-08-02  Richard Biener  <rguenther@suse.de>\n\n\t* vec.h (vec::sort): Add gcc_qsort_r support.\n\t(vec::bsearch): Add an overload with gcc_qsort_r style callbacks.\n\t* tree-ssa-loop-im.c (sort_bbs_in_loop_postorder_cmp): Adjust\n\tto gcc_qsort_r style callback.\n\t(sort_locs_in_loop_postorder_cmp): Likewise.\n\t(analyze_memory_references): Use gcc_sort_r interfaces.\n\t(find_ref_loc_in_loop_cmp): Use new bsearch overload.\n\nFrom-SVN: r274004", "tree": {"sha": "22adc8d5c7ec0ac2286218d43def72455da6055d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22adc8d5c7ec0ac2286218d43def72455da6055d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c2289931106421819cb14ee25976ab8b1c06ff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2289931106421819cb14ee25976ab8b1c06ff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2289931106421819cb14ee25976ab8b1c06ff1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2289931106421819cb14ee25976ab8b1c06ff1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e006ead5230560030c44856952967ca0cfea4db2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e006ead5230560030c44856952967ca0cfea4db2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e006ead5230560030c44856952967ca0cfea4db2"}], "stats": {"total": 113, "additions": 105, "deletions": 8}, "files": [{"sha": "c0e3cd84d7b612acf9aa29c1798189566bfb8395", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2289931106421819cb14ee25976ab8b1c06ff1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2289931106421819cb14ee25976ab8b1c06ff1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c2289931106421819cb14ee25976ab8b1c06ff1", "patch": "@@ -1,3 +1,13 @@\n+2019-08-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* vec.h (vec::sort): Add gcc_qsort_r support.\n+\t(vec::bsearch): Add an overload with gcc_qsort_r style callbacks.\n+\t* tree-ssa-loop-im.c (sort_bbs_in_loop_postorder_cmp): Adjust\n+\tto gcc_qsort_r style callback.\n+\t(sort_locs_in_loop_postorder_cmp): Likewise.\n+\t(analyze_memory_references): Use gcc_sort_r interfaces.\n+\t(find_ref_loc_in_loop_cmp): Use new bsearch overload.\n+\n 2019-08-02  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/91313"}, {"sha": "e194a41a08e04a8c501e7d5dbae7455bd76556e6", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2289931106421819cb14ee25976ab8b1c06ff1/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2289931106421819cb14ee25976ab8b1c06ff1/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=8c2289931106421819cb14ee25976ab8b1c06ff1", "patch": "@@ -1579,8 +1579,10 @@ static unsigned *bb_loop_postorder;\n /* qsort sort function to sort blocks after their loop fathers postorder.  */\n \n static int\n-sort_bbs_in_loop_postorder_cmp (const void *bb1_, const void *bb2_)\n+sort_bbs_in_loop_postorder_cmp (const void *bb1_, const void *bb2_,\n+\t\t\t\tvoid *bb_loop_postorder_)\n {\n+  unsigned *bb_loop_postorder = (unsigned *)bb_loop_postorder_;\n   basic_block bb1 = *(basic_block *)const_cast<void *>(bb1_);\n   basic_block bb2 = *(basic_block *)const_cast<void *>(bb2_);\n   class loop *loop1 = bb1->loop_father;\n@@ -1593,8 +1595,10 @@ sort_bbs_in_loop_postorder_cmp (const void *bb1_, const void *bb2_)\n /* qsort sort function to sort ref locs after their loop fathers postorder.  */\n \n static int\n-sort_locs_in_loop_postorder_cmp (const void *loc1_, const void *loc2_)\n+sort_locs_in_loop_postorder_cmp (const void *loc1_, const void *loc2_,\n+\t\t\t\t void *bb_loop_postorder_)\n {\n+  unsigned *bb_loop_postorder = (unsigned *)bb_loop_postorder_;\n   mem_ref_loc *loc1 = (mem_ref_loc *)const_cast<void *>(loc1_);\n   mem_ref_loc *loc2 = (mem_ref_loc *)const_cast<void *>(loc2_);\n   class loop *loop1 = gimple_bb (loc1->stmt)->loop_father;\n@@ -1622,7 +1626,8 @@ analyze_memory_references (void)\n     if (bb->loop_father != current_loops->tree_root)\n       bbs[i++] = bb;\n   n = i;\n-  qsort (bbs, n, sizeof (basic_block), sort_bbs_in_loop_postorder_cmp);\n+  gcc_sort_r (bbs, n, sizeof (basic_block), sort_bbs_in_loop_postorder_cmp,\n+\t      bb_loop_postorder);\n \n   /* Visit blocks in loop postorder and assign mem-ref IDs in that order.\n      That results in better locality for all the bitmaps.  */\n@@ -1637,10 +1642,10 @@ analyze_memory_references (void)\n      loop postorder number.  */\n   im_mem_ref *ref;\n   FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n-    ref->accesses_in_loop.qsort (sort_locs_in_loop_postorder_cmp);\n+    ref->accesses_in_loop.sort (sort_locs_in_loop_postorder_cmp,\n+\t\t\t\tbb_loop_postorder);\n \n   free (bbs);\n-//  free (bb_loop_postorder);\n \n   /* Propagate the information about accessed memory references up\n      the loop hierarchy.  */\n@@ -1700,8 +1705,10 @@ mem_refs_may_alias_p (im_mem_ref *mem1, im_mem_ref *mem2,\n    in a loop.  */\n \n static int\n-find_ref_loc_in_loop_cmp (const void *loop_, const void *loc_)\n+find_ref_loc_in_loop_cmp (const void *loop_, const void *loc_,\n+\t\t\t  void *bb_loop_postorder_)\n {\n+  unsigned *bb_loop_postorder = (unsigned *)bb_loop_postorder_;\n   class loop *loop = (class loop *)const_cast<void *>(loop_);\n   mem_ref_loc *loc = (mem_ref_loc *)const_cast<void *>(loc_);\n   class loop *loc_loop = gimple_bb (loc->stmt)->loop_father;\n@@ -1726,7 +1733,8 @@ for_all_locs_in_loop (class loop *loop, im_mem_ref *ref, FN fn)\n \n   /* Search for the cluster of locs in the accesses_in_loop vector\n      which is sorted after postorder index of the loop father.  */\n-  loc = ref->accesses_in_loop.bsearch (loop, find_ref_loc_in_loop_cmp);\n+  loc = ref->accesses_in_loop.bsearch (loop, find_ref_loc_in_loop_cmp,\n+\t\t\t\t       bb_loop_postorder);\n   if (!loc)\n     return false;\n "}, {"sha": "091056b37bcc59245edda1d0d7e4c0a495c4e987", "filename": "gcc/vec.h", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2289931106421819cb14ee25976ab8b1c06ff1/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2289931106421819cb14ee25976ab8b1c06ff1/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=8c2289931106421819cb14ee25976ab8b1c06ff1", "patch": "@@ -593,7 +593,10 @@ struct GTY((user)) vec<T, A, vl_embed>\n   void unordered_remove (unsigned);\n   void block_remove (unsigned, unsigned);\n   void qsort (int (*) (const void *, const void *));\n+  void sort (int (*) (const void *, const void *, void *), void *);\n   T *bsearch (const void *key, int (*compar)(const void *, const void *));\n+  T *bsearch (const void *key,\n+\t      int (*compar)(const void *, const void *, void *), void *);\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n   bool contains (const T &search) const;\n   static size_t embedded_size (unsigned);\n@@ -1111,7 +1114,19 @@ inline void\n vec<T, A, vl_embed>::qsort (int (*cmp) (const void *, const void *))\n {\n   if (length () > 1)\n-    ::qsort (address (), length (), sizeof (T), cmp);\n+    gcc_qsort (address (), length (), sizeof (T), cmp);\n+}\n+\n+/* Sort the contents of this vector with qsort.  CMP is the comparison\n+   function to pass to qsort.  */\n+\n+template<typename T, typename A>\n+inline void\n+vec<T, A, vl_embed>::sort (int (*cmp) (const void *, const void *, void *),\n+\t\t\t   void *data)\n+{\n+  if (length () > 1)\n+    gcc_sort_r (address (), length (), sizeof (T), cmp, data);\n }\n \n \n@@ -1149,6 +1164,41 @@ vec<T, A, vl_embed>::bsearch (const void *key,\n   return NULL;\n }\n \n+/* Search the contents of the sorted vector with a binary search.\n+   CMP is the comparison function to pass to bsearch.  */\n+\n+template<typename T, typename A>\n+inline T *\n+vec<T, A, vl_embed>::bsearch (const void *key,\n+\t\t\t      int (*compar) (const void *, const void *,\n+\t\t\t\t\t     void *), void *data)\n+{\n+  const void *base = this->address ();\n+  size_t nmemb = this->length ();\n+  size_t size = sizeof (T);\n+  /* The following is a copy of glibc stdlib-bsearch.h.  */\n+  size_t l, u, idx;\n+  const void *p;\n+  int comparison;\n+\n+  l = 0;\n+  u = nmemb;\n+  while (l < u)\n+    {\n+      idx = (l + u) / 2;\n+      p = (const void *) (((const char *) base) + (idx * size));\n+      comparison = (*compar) (key, p, data);\n+      if (comparison < 0)\n+\tu = idx;\n+      else if (comparison > 0)\n+\tl = idx + 1;\n+      else\n+\treturn (T *)const_cast<void *>(p);\n+    }\n+\n+  return NULL;\n+}\n+\n /* Return true if SEARCH is an element of V.  Note that this is O(N) in the\n    size of the vector and so should be used with care.  */\n \n@@ -1401,7 +1451,10 @@ struct vec<T, va_heap, vl_ptr>\n   void unordered_remove (unsigned);\n   void block_remove (unsigned, unsigned);\n   void qsort (int (*) (const void *, const void *));\n+  void sort (int (*) (const void *, const void *, void *), void *);\n   T *bsearch (const void *key, int (*compar)(const void *, const void *));\n+  T *bsearch (const void *key,\n+\t      int (*compar)(const void *, const void *, void *), void *);\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n   bool contains (const T &search) const;\n   void reverse (void);\n@@ -1898,6 +1951,18 @@ vec<T, va_heap, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n     m_vec->qsort (cmp);\n }\n \n+/* Sort the contents of this vector with qsort.  CMP is the comparison\n+   function to pass to qsort.  */\n+\n+template<typename T>\n+inline void\n+vec<T, va_heap, vl_ptr>::sort (int (*cmp) (const void *, const void *,\n+\t\t\t\t\t   void *), void *data)\n+{\n+  if (m_vec)\n+    m_vec->sort (cmp, data);\n+}\n+\n \n /* Search the contents of the sorted vector with a binary search.\n    CMP is the comparison function to pass to bsearch.  */\n@@ -1912,6 +1977,20 @@ vec<T, va_heap, vl_ptr>::bsearch (const void *key,\n   return NULL;\n }\n \n+/* Search the contents of the sorted vector with a binary search.\n+   CMP is the comparison function to pass to bsearch.  */\n+\n+template<typename T>\n+inline T *\n+vec<T, va_heap, vl_ptr>::bsearch (const void *key,\n+\t\t\t\t  int (*cmp) (const void *, const void *,\n+\t\t\t\t\t      void *), void *data)\n+{\n+  if (m_vec)\n+    return m_vec->bsearch (key, cmp, data);\n+  return NULL;\n+}\n+\n \n /* Find and return the first position in which OBJ could be inserted\n    without changing the ordering of this vector.  LESSTHAN is a"}]}