{"sha": "96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "node_id": "C_kwDOANBUbNoAKDk2YzhiYWE4YTdhOGFhNzk2NDUwNTg1YzFiYTJjMWZlMjQyOGI2ZjQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-09-27T10:35:21Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-09-27T11:24:37Z"}, "message": "Refactor TypeResolution to be a simple query based system\n\nThis patch refactors the type resolution system to introduce a new\ninterface\n\n  bool query_type (HirId, TyTy::BaseType** result)\n\nThis is needed in order to properly support forward declared items. Our\nname resolution system has two parts:\n\n  1. Toplevel scan\n  2. Item resolution\n\nThe toplevel scan gathers all the nesseacry 'names' into their respective\nnamespace by doing a full toplevel scan and generate canonical paths for\neach item. The second pass is responsible for drilling down into each\nstructure or function to resolve each field or variable etc. This means\nour name resolution system supports forward decalred items but our type\nresolution system did not.\n\nThis patch removes the toplevel scan from our type resolution pass which\nis not able to handle all cases such as a function with return type and\nthe type is decalred after the fact or a type alias to a type declared\nafter the fact. The name resolution mappings are resolved so when errors\noccured here we got errors such as unable to lookup HirId 1234, which meant\nyes we have 'resolved' this reference to this HirId but we are unable to\nfind any type information for it. This means we needed a new way to figure\nout the type in a query based way.\n\nThis is where the new query_type inferface comes in so when we have an\nHirId we want to resolve the mappings class allows us to figure out what\nitem this is such as:\n\n  1. HIR::Item (normal HIR::Function, Struct, TypeAlias, ...)\n  2. HIR::ImplItem (function, constant, ... within an impl-block)\n  3. HIR::ImplBlock (Self type on an impl-block)\n  4. HIR::ExternalItem (extern-block item)\n\nThe mappings class allows us to simply lookup these HIR nodes and then\ncall the relevant resolver class to compute the type. This patch does not\nadd support for self-referencial types but is the starting point to be able to support such types.\n\nFixes #1455", "tree": {"sha": "62c5a2edc7a80705984b4051a3fd7dbc27674262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c5a2edc7a80705984b4051a3fd7dbc27674262"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c"}], "stats": {"total": 2175, "additions": 952, "deletions": 1223}, "files": [{"sha": "5996696e425cf31b636266c9526e9799006656f8", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -111,7 +111,6 @@ GRS_OBJS = \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n-    rust/rust-hir-type-check-toplevel.o \\\n     rust/rust-hir-type-check-item.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n@@ -121,6 +120,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-enumitem.o \\\n     rust/rust-hir-type-check-implitem.o \\\n     rust/rust-hir-dot-operator.o \\\n+    rust/rust-hir-path-probe.o \\\n     rust/rust-coercion.o \\\n     rust/rust-casts.o \\\n     rust/rust-hir-type-check-base.o \\"}, {"sha": "1976a5f6a343b73abbddf19ac31151924eadb178", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -25,8 +25,7 @@ namespace Resolver {\n \n MethodResolver::MethodResolver (bool autoderef_flag,\n \t\t\t\tconst HIR::PathIdentSegment &segment_name)\n-  : AutoderefCycle (autoderef_flag), mappings (Analysis::Mappings::get ()),\n-    context (TypeCheckContext::get ()), segment_name (segment_name),\n+  : AutoderefCycle (autoderef_flag), segment_name (segment_name),\n     try_result (MethodCandidate::get_error ())\n {}\n \n@@ -80,8 +79,9 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \treturn true;\n \n       TyTy::BaseType *ty = nullptr;\n-      if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+      if (!query_type (func->get_mappings ().get_hirid (), &ty))\n \treturn true;\n+      rust_assert (ty != nullptr);\n       if (ty->get_kind () == TyTy::TypeKind::ERROR)\n \treturn true;\n \n@@ -127,7 +127,7 @@ MethodResolver::select (const TyTy::BaseType &receiver)\n \t  continue;\n \n \tTyTy::BaseType *ty = nullptr;\n-\tif (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\tif (!query_type (func->get_mappings ().get_hirid (), &ty))\n \t  continue;\n \tif (ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  continue;"}, {"sha": "054608dc931b18def268b8adac51fc323ae1116c", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -37,7 +37,7 @@ struct MethodCandidate\n   bool is_error () const { return candidate.is_error (); }\n };\n \n-class MethodResolver : protected AutoderefCycle\n+class MethodResolver : private TypeCheckBase, protected AutoderefCycle\n {\n public:\n   struct predicate_candidate\n@@ -63,10 +63,6 @@ class MethodResolver : protected AutoderefCycle\n   bool select (const TyTy::BaseType &receiver) override;\n \n private:\n-  // context info\n-  Analysis::Mappings *mappings;\n-  TypeCheckContext *context;\n-\n   // search\n   const HIR::PathIdentSegment &segment_name;\n   std::vector<MethodResolver::predicate_candidate> predicate_items;"}, {"sha": "cb3270d3623d03fc390e3385a97c23dc13683a6b", "filename": "gcc/rust/typecheck/rust-hir-path-probe.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-check-item.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+PathProbeType::process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n+\t\t\t\t\t    HIR::ImplBlock *impl)\n+{\n+  current_impl = impl;\n+  HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n+  TyTy::BaseType *impl_block_ty = nullptr;\n+  if (!query_type (impl_ty_id, &impl_block_ty))\n+    return;\n+\n+  if (!receiver->can_eq (impl_block_ty, false))\n+    {\n+      if (!impl_block_ty->can_eq (receiver, false))\n+\treturn;\n+    }\n+\n+  // lets visit the impl_item\n+  item->accept_vis (*this);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "b1d7f4b26acc29a37d30e226f49697d6d973033b", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -195,7 +195,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n       {\n \tHirId tyid = alias.get_mappings ().get_hirid ();\n \tTyTy::BaseType *ty = nullptr;\n-\tbool ok = context->lookup_type (tyid, &ty);\n+\tbool ok = query_type (tyid, &ty);\n \trust_assert (ok);\n \n \tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n@@ -214,7 +214,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n       {\n \tHirId tyid = constant.get_mappings ().get_hirid ();\n \tTyTy::BaseType *ty = nullptr;\n-\tbool ok = context->lookup_type (tyid, &ty);\n+\tbool ok = query_type (tyid, &ty);\n \trust_assert (ok);\n \n \tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n@@ -233,7 +233,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n       {\n \tHirId tyid = function.get_mappings ().get_hirid ();\n \tTyTy::BaseType *ty = nullptr;\n-\tbool ok = context->lookup_type (tyid, &ty);\n+\tbool ok = query_type (tyid, &ty);\n \trust_assert (ok);\n \n \tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n@@ -272,23 +272,7 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n   }\n \n   void process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n-\t\t\t\t    HIR::ImplBlock *impl)\n-  {\n-    current_impl = impl;\n-    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n-    TyTy::BaseType *impl_block_ty = nullptr;\n-    if (!context->lookup_type (impl_ty_id, &impl_block_ty))\n-      return;\n-\n-    if (!receiver->can_eq (impl_block_ty, false))\n-      {\n-\tif (!impl_block_ty->can_eq (receiver, false))\n-\t  return;\n-      }\n-\n-    // lets visit the impl_item\n-    item->accept_vis (*this);\n-  }\n+\t\t\t\t    HIR::ImplBlock *impl);\n \n   void\n   process_associated_trait_for_candidates (const TraitReference *trait_ref,"}, {"sha": "bd6a2fb3e738d7e1bf4d35a84bbb89d1dcfebb83", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.cc", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -17,8 +17,10 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-implitem.h\"\n #include \"rust-coercion.h\"\n #include \"rust-casts.h\"\n \n@@ -37,6 +39,13 @@ TypeCheckBase::check_for_unconstrained (\n   const TyTy::SubstitutionArgumentMappings &constraint_b,\n   const TyTy::BaseType *reference)\n {\n+  bool check_result = false;\n+  bool check_completed\n+    = context->have_checked_for_unconstrained (reference->get_ref (),\n+\t\t\t\t\t       &check_result);\n+  if (check_completed)\n+    return check_result;\n+\n   std::set<HirId> symbols_to_constrain;\n   std::map<HirId, Location> symbol_to_location;\n   for (const auto &p : params_to_constrain)\n@@ -86,6 +95,10 @@ TypeCheckBase::check_for_unconstrained (\n \t  unconstrained = true;\n \t}\n     }\n+\n+  context->insert_unconstrained_check_marker (reference->get_ref (),\n+\t\t\t\t\t      unconstrained);\n+\n   return unconstrained;\n }\n \n@@ -479,5 +492,68 @@ TypeCheckBase::resolve_generic_params (\n     }\n }\n \n+bool\n+TypeCheckBase::query_type (HirId reference, TyTy::BaseType **result)\n+{\n+  if (context->lookup_type (reference, result))\n+    return true;\n+\n+  HIR::Item *item = mappings->lookup_hir_item (reference);\n+  if (item != nullptr)\n+    {\n+      rust_debug_loc (item->get_locus (), \"resolved item {%u} to\", reference);\n+      *result = TypeCheckItem::Resolve (*item);\n+      return true;\n+    }\n+\n+  HirId parent_impl_id = UNKNOWN_HIRID;\n+  HIR::ImplItem *impl_item\n+    = mappings->lookup_hir_implitem (reference, &parent_impl_id);\n+  if (impl_item != nullptr)\n+    {\n+      HIR::ImplBlock *impl_block\n+\t= mappings->lookup_hir_impl_block (parent_impl_id);\n+      rust_assert (impl_block != nullptr);\n+\n+      // found an impl item\n+      rust_debug_loc (impl_item->get_locus (), \"resolved impl-item {%u} to\",\n+\t\t      reference);\n+\n+      *result = TypeCheckItem::ResolveImplItem (*impl_block, *impl_item);\n+      return true;\n+    }\n+\n+  // is it an impl_type?\n+  HIR::ImplBlock *impl_block_by_type = nullptr;\n+  bool found_impl_block_type\n+    = mappings->lookup_impl_block_type (reference, &impl_block_by_type);\n+  if (found_impl_block_type)\n+    {\n+      *result = TypeCheckItem::ResolveImplBlockSelf (*impl_block_by_type);\n+      return true;\n+    }\n+\n+  // is it an extern item?\n+  HirId parent_extern_block_id = UNKNOWN_HIRID;\n+  HIR::ExternalItem *extern_item\n+    = mappings->lookup_hir_extern_item (reference, &parent_extern_block_id);\n+  if (extern_item != nullptr)\n+    {\n+      HIR::ExternBlock *block\n+\t= mappings->lookup_hir_extern_block (parent_extern_block_id);\n+      rust_assert (block != nullptr);\n+\n+      *result = TypeCheckTopLevelExternItem::Resolve (extern_item, *block);\n+      return true;\n+    }\n+\n+  // more?\n+  Location possible_locus = mappings->lookup_location (reference);\n+  rust_debug_loc (possible_locus, \"query system failed to resolve: [%u]\",\n+\t\t  reference);\n+\n+  return false;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "743cf4f94bd48e3c5dc3b4a5b7231fc136a3be08", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -69,6 +69,8 @@ class TypeCheckBase\n     const std::vector<std::unique_ptr<HIR::GenericParam>> &generic_params,\n     std::vector<TyTy::SubstitutionParamMapping> &substitutions);\n \n+  bool query_type (HirId reference, TyTy::BaseType **result);\n+\n   Analysis::Mappings *mappings;\n   Resolver *resolver;\n   TypeCheckContext *context;"}, {"sha": "9a5785f71b7807f8570f5e96358d03565dc4470e", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -188,6 +188,9 @@ TypeCheckExpr::visit (HIR::CallExpr &expr)\n       return;\n     }\n \n+  rust_debug_loc (expr.get_locus (), \"resolved_call_expr to: {%s}\",\n+\t\t  function_tyty->get_name ().c_str ());\n+\n   TyTy::VariantDef &variant = TyTy::VariantDef::get_error_node ();\n   if (function_tyty->get_kind () == TyTy::TypeKind::ADT)\n     {"}, {"sha": "9643bb473bb23bf29de0f28cba425026c68dccf2", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.cc", "status": "modified", "additions": 68, "deletions": 113, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -32,12 +32,21 @@ TypeCheckTopLevelExternItem::TypeCheckTopLevelExternItem (\n   : TypeCheckBase (), parent (parent)\n {}\n \n-void\n+TyTy::BaseType *\n TypeCheckTopLevelExternItem::Resolve (HIR::ExternalItem *item,\n \t\t\t\t      const HIR::ExternBlock &parent)\n {\n+  // is it already resolved?\n+  auto context = TypeCheckContext::get ();\n+  TyTy::BaseType *resolved = nullptr;\n+  bool already_resolved\n+    = context->lookup_type (item->get_mappings ().get_hirid (), &resolved);\n+  if (already_resolved)\n+    return resolved;\n+\n   TypeCheckTopLevelExternItem resolver (parent);\n   item->accept_vis (resolver);\n+  return resolver.resolved;\n }\n \n void\n@@ -47,6 +56,7 @@ TypeCheckTopLevelExternItem::visit (HIR::ExternalStaticItem &item)\n     = TypeCheckType::Resolve (item.get_item_type ().get ());\n \n   context->insert_type (item.get_mappings (), actual_type);\n+  resolved = actual_type;\n }\n \n void\n@@ -142,79 +152,40 @@ TypeCheckTopLevelExternItem::visit (HIR::ExternalFunctionItem &function)\n \t\t\t\t  ret_type, std::move (substitutions));\n \n   context->insert_type (function.get_mappings (), fnType);\n+  resolved = fnType;\n }\n \n-TypeCheckTopLevelImplItem::TypeCheckTopLevelImplItem (\n-  TyTy::BaseType *self,\n+TypeCheckImplItem::TypeCheckImplItem (\n+  HIR::ImplBlock *parent, TyTy::BaseType *self,\n   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-  : TypeCheckBase (), self (self), substitutions (substitutions)\n+  : TypeCheckBase (), parent (parent), self (self),\n+    substitutions (substitutions)\n {}\n \n-void\n-TypeCheckTopLevelImplItem::Resolve (\n-  HIR::ImplItem *item, TyTy::BaseType *self,\n+TyTy::BaseType *\n+TypeCheckImplItem::Resolve (\n+  HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n {\n-  TypeCheckTopLevelImplItem resolver (self, substitutions);\n+  // is it already resolved?\n+  auto context = TypeCheckContext::get ();\n+  TyTy::BaseType *resolved = nullptr;\n+  bool already_resolved\n+    = context->lookup_type (item->get_impl_mappings ().get_hirid (), &resolved);\n+  if (already_resolved)\n+    return resolved;\n+\n+  // resolve\n+  TypeCheckImplItem resolver (parent, self, substitutions);\n   item->accept_vis (resolver);\n+  return resolver.result;\n }\n \n void\n-TypeCheckTopLevelImplItem::visit (HIR::TypeAlias &alias)\n-{\n-  TyTy::BaseType *actual_type\n-    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n-\n-  context->insert_type (alias.get_mappings (), actual_type);\n-\n-  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-}\n-\n-void\n-TypeCheckTopLevelImplItem::visit (HIR::ConstantItem &constant)\n-{\n-  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n-\n-  TyTy::BaseType *unified = unify_site (\n-    constant.get_mappings ().get_hirid (),\n-    TyTy::TyWithLocation (type, constant.get_type ()->get_locus ()),\n-    TyTy::TyWithLocation (expr_type, constant.get_expr ()->get_locus ()),\n-    constant.get_locus ());\n-  context->insert_type (constant.get_mappings (), unified);\n-}\n-\n-void\n-TypeCheckTopLevelImplItem::visit (HIR::Function &function)\n+TypeCheckImplItem::visit (HIR::Function &function)\n {\n   if (function.has_generics ())\n-    {\n-      for (auto &generic_param : function.get_generic_params ())\n-\t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tauto param_type\n-\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\tcontext->insert_type (generic_param->get_mappings (),\n-\t\t\t\t      param_type);\n-\n-\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t      }\n-\t      break;\n-\t    }\n-\t}\n-    }\n+    resolve_generic_params (function.get_generic_params (), substitutions);\n \n   for (auto &where_clause_item : function.get_where_clause ().get_items ())\n     {\n@@ -328,41 +299,10 @@ TypeCheckTopLevelImplItem::visit (HIR::Function &function)\n \t\t\t\t  std::move (substitutions));\n \n   context->insert_type (function.get_mappings (), fnType);\n-}\n-\n-TypeCheckImplItem::TypeCheckImplItem (HIR::ImplBlock *parent,\n-\t\t\t\t      TyTy::BaseType *self)\n-  : TypeCheckBase (), parent (parent), self (self)\n-{}\n-\n-void\n-TypeCheckImplItem::Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n-\t\t\t    TyTy::BaseType *self)\n-{\n-  TypeCheckImplItem resolver (parent, self);\n-  item->accept_vis (resolver);\n-}\n-\n-void\n-TypeCheckImplItem::visit (HIR::Function &function)\n-{\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-    {\n-      rust_error_at (function.get_locus (), \"failed to lookup function type\");\n-      return;\n-    }\n-\n-  if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-    {\n-      rust_error_at (function.get_locus (),\n-\t\t     \"found invalid type for function [%s]\",\n-\t\t     lookup->as_string ().c_str ());\n-      return;\n-    }\n+  result = fnType;\n \n   // need to get the return type from this\n-  TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n+  TyTy::FnType *resolve_fn_type = fnType;\n   auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n   context->push_return_type (TypeCheckContextItem (parent, &function),\n \t\t\t     expected_ret_tyty);\n@@ -383,20 +323,41 @@ TypeCheckImplItem::visit (HIR::Function &function)\n }\n \n void\n-TypeCheckImplItem::visit (HIR::ConstantItem &const_item)\n-{}\n+TypeCheckImplItem::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  TyTy::BaseType *unified = unify_site (\n+    constant.get_mappings ().get_hirid (),\n+    TyTy::TyWithLocation (type, constant.get_type ()->get_locus ()),\n+    TyTy::TyWithLocation (expr_type, constant.get_expr ()->get_locus ()),\n+    constant.get_locus ());\n+  context->insert_type (constant.get_mappings (), unified);\n+  result = unified;\n+}\n \n void\n-TypeCheckImplItem::visit (HIR::TypeAlias &type_alias)\n-{}\n+TypeCheckImplItem::visit (HIR::TypeAlias &alias)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+  context->insert_type (alias.get_mappings (), actual_type);\n+  result = actual_type;\n+  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+}\n \n TypeCheckImplItemWithTrait::TypeCheckImplItemWithTrait (\n   HIR::ImplBlock *parent, TyTy::BaseType *self,\n   TyTy::TypeBoundPredicate &trait_reference,\n   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-  : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n+  : TypeCheckBase (), trait_reference (trait_reference),\n     resolved_trait_item (TyTy::TypeBoundPredicateItem::error ()),\n-    substitutions (substitutions)\n+    parent (parent), self (self), substitutions (substitutions)\n {\n   rust_assert (is_trait_impl_block ());\n }\n@@ -417,10 +378,8 @@ void\n TypeCheckImplItemWithTrait::visit (HIR::ConstantItem &constant)\n {\n   // normal resolution of the item\n-  TypeCheckImplItem::visit (constant);\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n-    return;\n+  TyTy::BaseType *lookup\n+    = TypeCheckImplItem::Resolve (parent, &constant, self, substitutions);\n \n   // map the impl item to the associated trait item\n   const auto tref = trait_reference.get ();\n@@ -468,10 +427,8 @@ void\n TypeCheckImplItemWithTrait::visit (HIR::TypeAlias &type)\n {\n   // normal resolution of the item\n-  TypeCheckImplItem::visit (type);\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n-    return;\n+  TyTy::BaseType *lookup\n+    = TypeCheckImplItem::Resolve (parent, &type, self, substitutions);\n \n   // map the impl item to the associated trait item\n   const auto tref = trait_reference.get ();\n@@ -528,11 +485,9 @@ TypeCheckImplItemWithTrait::visit (HIR::TypeAlias &type)\n void\n TypeCheckImplItemWithTrait::visit (HIR::Function &function)\n {\n-  // we get the error checking from the base method here\n-  TypeCheckImplItem::visit (function);\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-    return;\n+  // normal resolution of the item\n+  TyTy::BaseType *lookup\n+    = TypeCheckImplItem::Resolve (parent, &function, self, substitutions);\n \n   // map the impl item to the associated trait item\n   const auto tref = trait_reference.get ();"}, {"sha": "c4b27e50451fe0472edf1aaa99cafe9e8feedf9c", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -28,7 +28,8 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase,\n \t\t\t\t    public HIR::HIRExternalItemVisitor\n {\n public:\n-  static void Resolve (HIR::ExternalItem *item, const HIR::ExternBlock &parent);\n+  static TyTy::BaseType *Resolve (HIR::ExternalItem *item,\n+\t\t\t\t  const HIR::ExternBlock &parent);\n \n   void visit (HIR::ExternalStaticItem &item) override;\n   void visit (HIR::ExternalFunctionItem &function) override;\n@@ -37,47 +38,33 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase,\n   TypeCheckTopLevelExternItem (const HIR::ExternBlock &parent);\n \n   const HIR::ExternBlock &parent;\n-};\n-\n-class TypeCheckTopLevelImplItem : public TypeCheckBase,\n-\t\t\t\t  public HIR::HIRImplVisitor\n-{\n-public:\n-  static void\n-  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n-\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n-\n-  void visit (HIR::TypeAlias &alias) override;\n-  void visit (HIR::ConstantItem &constant) override;\n-  void visit (HIR::Function &function) override;\n-\n-private:\n-  TypeCheckTopLevelImplItem (\n-    TyTy::BaseType *self,\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions);\n-\n-  TyTy::BaseType *self;\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  TyTy::BaseType *resolved;\n };\n \n class TypeCheckImplItem : public TypeCheckBase, public HIR::HIRImplVisitor\n {\n public:\n-  static void Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n-\t\t       TyTy::BaseType *self);\n+  static TyTy::BaseType *\n+  Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n   void visit (HIR::Function &function) override;\n   void visit (HIR::ConstantItem &const_item) override;\n   void visit (HIR::TypeAlias &type_alias) override;\n \n protected:\n-  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self);\n+  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self,\n+\t\t     std::vector<TyTy::SubstitutionParamMapping> substitutions);\n \n   HIR::ImplBlock *parent;\n   TyTy::BaseType *self;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+\n+  TyTy::BaseType *result;\n };\n \n-class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n+class TypeCheckImplItemWithTrait : public TypeCheckBase,\n+\t\t\t\t   public HIR::HIRImplVisitor\n {\n public:\n   static TyTy::TypeBoundPredicateItem\n@@ -105,6 +92,9 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   TyTy::TypeBoundPredicate &trait_reference;\n   TyTy::TypeBoundPredicateItem resolved_trait_item;\n+\n+  HIR::ImplBlock *parent;\n+  TyTy::BaseType *self;\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n "}, {"sha": "ade6ab720536304678a768db2a347c0fa58c3e41", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "modified", "additions": 462, "deletions": 92, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -16,59 +16,466 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-type-check-enumitem.h\"\n #include \"rust-hir-type-check-implitem.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-stmt.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-pattern.h\"\n #include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-TypeCheckItem::TypeCheckItem () : TypeCheckBase () {}\n+TypeCheckItem::TypeCheckItem () : TypeCheckBase (), infered (nullptr) {}\n \n-void\n+TyTy::BaseType *\n TypeCheckItem::Resolve (HIR::Item &item)\n {\n+  // is it already resolved?\n+  auto context = TypeCheckContext::get ();\n+  TyTy::BaseType *resolved = nullptr;\n+  bool already_resolved\n+    = context->lookup_type (item.get_mappings ().get_hirid (), &resolved);\n+  if (already_resolved)\n+    return resolved;\n+\n   rust_assert (item.get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM);\n   HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (item);\n \n   TypeCheckItem resolver;\n   vis_item.accept_vis (resolver);\n+  return resolver.infered;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckItem::ResolveImplItem (HIR::ImplBlock &impl_block, HIR::ImplItem &item)\n+{\n+  TypeCheckItem resolver;\n+  return resolver.resolve_impl_item (impl_block, item);\n+}\n+\n+TyTy::BaseType *\n+TypeCheckItem::ResolveImplBlockSelf (HIR::ImplBlock &impl_block)\n+{\n+  TypeCheckItem resolver;\n+\n+  bool failed_flag = false;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions\n+    = resolver.resolve_impl_block_substitutions (impl_block, failed_flag);\n+  if (failed_flag)\n+    {\n+      return new TyTy::ErrorType (impl_block.get_mappings ().get_hirid ());\n+    }\n+\n+  return resolver.resolve_impl_block_self (impl_block);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::TypeAlias &alias)\n+{\n+  TyTy::BaseType *actual_type\n+    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n+\n+  context->insert_type (alias.get_mappings (), actual_type);\n+\n+  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+  infered = actual_type;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::TupleStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  size_t idx = 0;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     std::to_string (idx), field_type,\n+\t\t\t\t     field.get_locus ());\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+      idx++;\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // its a single variant ADT\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n+\n+  // Process #[repr(X)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::StructStruct &struct_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (struct_decl.has_generics ())\n+    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &field : struct_decl.get_fields ())\n+    {\n+      TyTy::BaseType *field_type\n+\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_field\n+\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t     field.get_field_name (), field_type,\n+\t\t\t\t     field.get_locus ());\n+      fields.push_back (ty_field);\n+      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok = mappings->lookup_canonical_path (\n+    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n+\n+  // its a single variant ADT\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  // Process #[repr(X)] attribute, if any\n+  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n+  TyTy::ADTType::ReprOptions repr\n+    = parse_repr_options (attrs, struct_decl.get_locus ());\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t struct_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n+\t\t\t std::move (variants), std::move (substitutions), repr);\n+\n+  context->insert_type (struct_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Enum &enum_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (enum_decl.has_generics ())\n+    resolve_generic_params (enum_decl.get_generic_params (), substitutions);\n+\n+  std::vector<TyTy::VariantDef *> variants;\n+  int64_t discriminant_value = 0;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      TyTy::VariantDef *field_type\n+\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n+\n+      discriminant_value++;\n+      variants.push_back (field_type);\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (enum_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n+\n+  // multi variant ADT\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t enum_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (enum_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Union &union_decl)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (union_decl.has_generics ())\n+    resolve_generic_params (union_decl.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  std::vector<TyTy::StructFieldType *> fields;\n+  for (auto &variant : union_decl.get_variants ())\n+    {\n+      TyTy::BaseType *variant_type\n+\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n+      TyTy::StructFieldType *ty_variant\n+\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t     variant.get_field_name (), variant_type,\n+\t\t\t\t     variant.get_locus ());\n+      fields.push_back (ty_variant);\n+      context->insert_type (variant.get_mappings (),\n+\t\t\t    ty_variant->get_field_type ());\n+    }\n+\n+  // get the path\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (union_decl.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n+\n+  // there is only a single variant\n+  std::vector<TyTy::VariantDef *> variants;\n+  variants.push_back (new TyTy::VariantDef (\n+    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n+    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n+\n+  TyTy::BaseType *type\n+    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n+\t\t\t mappings->get_next_hir_id (),\n+\t\t\t union_decl.get_identifier (), ident,\n+\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n+\t\t\t std::move (substitutions));\n+\n+  context->insert_type (union_decl.get_mappings (), type);\n+  infered = type;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::StaticItem &var)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n+\n+  TyTy::BaseType *unified\n+    = coercion_site (var.get_mappings ().get_hirid (),\n+\t\t     TyTy::TyWithLocation (type, var.get_type ()->get_locus ()),\n+\t\t     TyTy::TyWithLocation (expr_type,\n+\t\t\t\t\t   var.get_expr ()->get_locus ()),\n+\t\t     var.get_locus ());\n+  context->insert_type (var.get_mappings (), unified);\n+  infered = unified;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::ConstantItem &constant)\n+{\n+  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n+  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+\n+  TyTy::BaseType *unified = unify_site (\n+    constant.get_mappings ().get_hirid (),\n+    TyTy::TyWithLocation (type, constant.get_type ()->get_locus ()),\n+    TyTy::TyWithLocation (expr_type, constant.get_expr ()->get_locus ()),\n+    constant.get_locus ());\n+  context->insert_type (constant.get_mappings (), unified);\n+  infered = unified;\n }\n \n void\n TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n+{\n+  bool failed_flag = false;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions\n+    = resolve_impl_block_substitutions (impl_block, failed_flag);\n+  if (failed_flag)\n+    {\n+      infered = new TyTy::ErrorType (impl_block.get_mappings ().get_hirid ());\n+      return;\n+    }\n+\n+  TyTy::BaseType *self = resolve_impl_block_self (impl_block);\n+\n+  // resolve each impl_item\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      TypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self,\n+\t\t\t\t  substitutions);\n+    }\n+\n+  // validate the impl items\n+  validate_trait_impl_block (impl_block, self, substitutions);\n+}\n+\n+TyTy::BaseType *\n+TypeCheckItem::resolve_impl_item (HIR::ImplBlock &impl_block,\n+\t\t\t\t  HIR::ImplItem &item)\n+{\n+  bool failed_flag = false;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions\n+    = resolve_impl_block_substitutions (impl_block, failed_flag);\n+  if (failed_flag)\n+    {\n+      return new TyTy::ErrorType (impl_block.get_mappings ().get_hirid ());\n+    }\n+\n+  TyTy::BaseType *self = resolve_impl_block_self (impl_block);\n+\n+  return TypeCheckImplItem::Resolve (&impl_block, &item, self, substitutions);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Function &function)\n {\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (impl_block.has_generics ())\n+  if (function.has_generics ())\n+    resolve_generic_params (function.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+    }\n+\n+  TyTy::BaseType *ret_type = nullptr;\n+  if (!function.has_function_return_type ())\n+    ret_type\n+      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n+  else\n     {\n-      for (auto &generic_param : impl_block.get_generic_params ())\n+      auto resolved\n+\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n+      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tTyTy::BaseType *l = nullptr;\n-\t\tbool ok = context->lookup_type (\n-\t\t  generic_param->get_mappings ().get_hirid (), &l);\n-\t\tif (ok && l->get_kind () == TyTy::TypeKind::PARAM)\n-\t\t  {\n-\t\t    substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t      static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t      static_cast<TyTy::ParamType *> (l)));\n-\t\t  }\n-\t      }\n-\t      break;\n-\t    }\n+\t  rust_error_at (function.get_locus (),\n+\t\t\t \"failed to resolve return type\");\n+\t  return;\n \t}\n+\n+      ret_type = resolved->clone ();\n+      ret_type->set_ref (\n+\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n+    }\n+\n+  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *>> params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      // get the name as well required for later on\n+      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+      params.push_back (\n+\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+      context->insert_type (param.get_mappings (), param_tyty);\n+      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n+    }\n+\n+  const CanonicalPath *canonical_path = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n+\t\t\t\t       &canonical_path);\n+  rust_assert (ok);\n+\n+  RustIdent ident{*canonical_path, function.get_locus ()};\n+  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t\t  function.get_function_name (), ident,\n+\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n+\t\t\t\t  std::move (params), ret_type,\n+\t\t\t\t  std::move (substitutions));\n+\n+  context->insert_type (function.get_mappings (), fnType);\n+\n+  // need to get the return type from this\n+  TyTy::FnType *resolved_fn_type = fnType;\n+  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n+  context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t     expected_ret_tyty);\n+\n+  auto block_expr_ty\n+    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+\n+  Location fn_return_locus = function.has_function_return_type ()\n+\t\t\t       ? function.get_return_type ()->get_locus ()\n+\t\t\t       : function.get_locus ();\n+  coercion_site (function.get_definition ()->get_mappings ().get_hirid (),\n+\t\t TyTy::TyWithLocation (expected_ret_tyty, fn_return_locus),\n+\t\t TyTy::TyWithLocation (block_expr_ty),\n+\t\t function.get_definition ()->get_locus ());\n+\n+  context->pop_return_type ();\n+\n+  infered = fnType;\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    TypeCheckItem::Resolve (*item.get ());\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::Trait &trait)\n+{\n+  TraitResolver::Resolve (trait);\n+}\n+\n+void\n+TypeCheckItem::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      TypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n+    }\n+}\n+\n+std::vector<TyTy::SubstitutionParamMapping>\n+TypeCheckItem::resolve_impl_block_substitutions (HIR::ImplBlock &impl_block,\n+\t\t\t\t\t\t bool &failure_flag)\n+{\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  if (impl_block.has_generics ())\n+    resolve_generic_params (impl_block.get_generic_params (), substitutions);\n+\n+  for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n+    {\n+      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n     }\n \n   auto specified_bound = TyTy::TypeBoundPredicate::error ();\n@@ -84,14 +491,7 @@ TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n       specified_bound = get_predicate_from_bound (*ref.get ());\n     }\n \n-  TyTy::BaseType *self = nullptr;\n-  if (!context->lookup_type (\n-\timpl_block.get_type ()->get_mappings ().get_hirid (), &self))\n-    {\n-      rust_error_at (impl_block.get_locus (),\n-\t\t     \"failed to resolve Self for ImplBlock\");\n-      return;\n-    }\n+  TyTy::BaseType *self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n \n   // inherit the bounds\n   if (!specified_bound.is_error ())\n@@ -103,20 +503,35 @@ TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n   const TyTy::SubstitutionArgumentMappings impl_constraints\n     = GetUsedSubstArgs::From (self);\n \n-  bool impl_block_has_unconstrained_typarams\n-    = check_for_unconstrained (substitutions, trait_constraints,\n-\t\t\t       impl_constraints, self);\n-  if (impl_block_has_unconstrained_typarams)\n-    return;\n+  failure_flag = check_for_unconstrained (substitutions, trait_constraints,\n+\t\t\t\t\t  impl_constraints, self);\n+\n+  return substitutions;\n+}\n+\n+void\n+TypeCheckItem::validate_trait_impl_block (\n+  HIR::ImplBlock &impl_block, TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> &substitutions)\n+{\n+  auto specified_bound = TyTy::TypeBoundPredicate::error ();\n+  TraitReference *trait_reference = &TraitReference::error_node ();\n+  if (impl_block.has_trait_ref ())\n+    {\n+      std::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n+      trait_reference = TraitResolver::Resolve (*ref.get ());\n+      rust_assert (!trait_reference->is_error ());\n+\n+      // we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n+      // for example\n+      specified_bound = get_predicate_from_bound (*ref.get ());\n+    }\n \n-  // validate the impl items\n   bool is_trait_impl_block = !trait_reference->is_error ();\n   std::vector<const TraitItemReference *> trait_item_refs;\n   for (auto &impl_item : impl_block.get_impl_items ())\n     {\n-      if (!is_trait_impl_block)\n-\tTypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n-      else\n+      if (!specified_bound.is_error ())\n \t{\n \t  auto trait_item_ref\n \t    = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n@@ -128,7 +543,7 @@ TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n     }\n \n   bool impl_block_missing_trait_items\n-    = is_trait_impl_block\n+    = !specified_bound.is_error ()\n       && trait_reference->size () != trait_item_refs.size ();\n   if (impl_block_missing_trait_items)\n     {\n@@ -187,55 +602,10 @@ TypeCheckItem::visit (HIR::ImplBlock &impl_block)\n     }\n }\n \n-void\n-TypeCheckItem::visit (HIR::Function &function)\n+TyTy::BaseType *\n+TypeCheckItem::resolve_impl_block_self (HIR::ImplBlock &impl_block)\n {\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-    {\n-      rust_error_at (function.get_locus (), \"failed to lookup function type\");\n-      return;\n-    }\n-\n-  if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-    {\n-      rust_error_at (function.get_locus (),\n-\t\t     \"found invalid type for function [%s]\",\n-\t\t     lookup->as_string ().c_str ());\n-      return;\n-    }\n-\n-  // need to get the return type from this\n-  TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n-  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-  context->push_return_type (TypeCheckContextItem (&function),\n-\t\t\t     expected_ret_tyty);\n-\n-  auto block_expr_ty\n-    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n-\n-  Location fn_return_locus = function.has_function_return_type ()\n-\t\t\t       ? function.get_return_type ()->get_locus ()\n-\t\t\t       : function.get_locus ();\n-  coercion_site (function.get_definition ()->get_mappings ().get_hirid (),\n-\t\t TyTy::TyWithLocation (expected_ret_tyty, fn_return_locus),\n-\t\t TyTy::TyWithLocation (block_expr_ty),\n-\t\t function.get_definition ()->get_locus ());\n-\n-  context->pop_return_type ();\n-}\n-\n-void\n-TypeCheckItem::visit (HIR::Module &module)\n-{\n-  for (auto &item : module.get_items ())\n-    TypeCheckItem::Resolve (*item.get ());\n-}\n-\n-void\n-TypeCheckItem::visit (HIR::Trait &trait)\n-{\n-  TraitResolver::Resolve (trait);\n+  return TypeCheckType::Resolve (impl_block.get_type ().get ());\n }\n \n } // namespace Resolver"}, {"sha": "3b88157f5ae4d483246fe7e81b66f1b0a7435e31", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -27,29 +27,48 @@ namespace Resolver {\n class TypeCheckItem : private TypeCheckBase, private HIR::HIRVisItemVisitor\n {\n public:\n-  static void Resolve (HIR::Item &item);\n+  static TyTy::BaseType *Resolve (HIR::Item &item);\n+\n+  static TyTy::BaseType *ResolveImplItem (HIR::ImplBlock &impl_block,\n+\t\t\t\t\t  HIR::ImplItem &item);\n+\n+  static TyTy::BaseType *ResolveImplBlockSelf (HIR::ImplBlock &impl_block);\n \n-  void visit (HIR::ImplBlock &impl_block) override;\n-  void visit (HIR::Function &function) override;\n   void visit (HIR::Module &module) override;\n-  void visit (HIR::Trait &trait) override;\n-\n-  // FIXME - get rid of toplevel pass\n-  void visit (HIR::TypeAlias &alias) override{};\n-  void visit (HIR::TupleStruct &struct_decl) override{};\n-  void visit (HIR::StructStruct &struct_decl) override{};\n-  void visit (HIR::Enum &enum_decl) override{};\n-  void visit (HIR::Union &union_decl) override{};\n-  void visit (HIR::StaticItem &var) override{};\n-  void visit (HIR::ConstantItem &constant) override{};\n-  void visit (HIR::ExternBlock &extern_block) override{};\n+  void visit (HIR::Function &function) override;\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::TupleStruct &struct_decl) override;\n+  void visit (HIR::StructStruct &struct_decl) override;\n+  void visit (HIR::Enum &enum_decl) override;\n+  void visit (HIR::Union &union_decl) override;\n+  void visit (HIR::StaticItem &var) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::ImplBlock &impl_block) override;\n+  void visit (HIR::ExternBlock &extern_block) override;\n+  void visit (HIR::Trait &trait_block) override;\n \n   // nothing to do\n   void visit (HIR::ExternCrate &crate) override {}\n   void visit (HIR::UseDeclaration &use_decl) override {}\n \n+protected:\n+  std::vector<TyTy::SubstitutionParamMapping>\n+  resolve_impl_block_substitutions (HIR::ImplBlock &impl_block,\n+\t\t\t\t    bool &failure_flag);\n+\n+  void validate_trait_impl_block (\n+    HIR::ImplBlock &impl_block, TyTy::BaseType *self,\n+    std::vector<TyTy::SubstitutionParamMapping> &substitutions);\n+\n+  TyTy::BaseType *resolve_impl_item (HIR::ImplBlock &impl_block,\n+\t\t\t\t     HIR::ImplItem &item);\n+\n+  TyTy::BaseType *resolve_impl_block_self (HIR::ImplBlock &impl_block);\n+\n private:\n   TypeCheckItem ();\n+\n+  TyTy::BaseType *infered;\n };\n \n } // namespace Resolver"}, {"sha": "33be96b786750c46c1afbbceb1ef9bcc5c8e9a78", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -235,7 +235,7 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t}\n \n       TyTy::BaseType *lookup = nullptr;\n-      if (!context->lookup_type (ref, &lookup))\n+      if (!query_type (ref, &lookup))\n \t{\n \t  if (is_root)\n \t    {\n@@ -383,7 +383,7 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \t  HirId impl_ty_id\n \t    = associated_impl_block->get_type ()->get_mappings ().get_hirid ();\n \t  TyTy::BaseType *impl_block_ty = nullptr;\n-\t  bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n+\t  bool ok = query_type (impl_ty_id, &impl_block_ty);\n \t  rust_assert (ok);\n \n \t  if (impl_block_ty->needs_generic_substitutions ())"}, {"sha": "890901245eeba2468780be2fcd4e80be74c44ca7", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.cc", "status": "modified", "additions": 42, "deletions": 345, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-enumitem.h\"\n #include \"rust-hir-type-check-implitem.h\"\n+#include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-pattern.h\"\n \n namespace Rust {\n@@ -139,378 +140,74 @@ TypeCheckStmt::visit (HIR::LetStmt &stmt)\n }\n \n void\n-TypeCheckStmt::visit (HIR::TupleStruct &struct_decl)\n+TypeCheckStmt::visit (HIR::TypePath &path)\n {\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (struct_decl.has_generics ())\n-    {\n-      for (auto &generic_param : struct_decl.get_generic_params ())\n-\t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tauto param_type\n-\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\tcontext->insert_type (generic_param->get_mappings (),\n-\t\t\t\t      param_type);\n-\n-\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t      }\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> fields;\n-  size_t idx = 0;\n-  for (auto &field : struct_decl.get_fields ())\n-    {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     std::to_string (idx), field_type,\n-\t\t\t\t     field.get_locus ());\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-      idx++;\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok = mappings->lookup_canonical_path (\n-    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-  // there is only a single variant\n-  std::vector<TyTy::VariantDef *> variants;\n-  variants.push_back (new TyTy::VariantDef (\n-    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n-\n-  // Process #[repr(...)] attribute, if any\n-  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-  TyTy::ADTType::ReprOptions repr\n-    = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t struct_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t std::move (variants), std::move (substitutions), repr);\n+  infered = TypeCheckType::Resolve (&path);\n+}\n+void\n+TypeCheckStmt::visit (HIR::QualifiedPathInType &path)\n+{\n+  infered = TypeCheckType::Resolve (&path);\n+}\n \n-  context->insert_type (struct_decl.get_mappings (), type);\n-  infered = type;\n+void\n+TypeCheckStmt::visit (HIR::TupleStruct &struct_decl)\n+{\n+  infered = TypeCheckItem::Resolve (struct_decl);\n }\n \n void\n TypeCheckStmt::visit (HIR::Enum &enum_decl)\n {\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (enum_decl.has_generics ())\n-    {\n-      for (auto &generic_param : enum_decl.get_generic_params ())\n-\t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tauto param_type\n-\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\tcontext->insert_type (generic_param->get_mappings (),\n-\t\t\t\t      param_type);\n-\n-\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t      }\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  std::vector<TyTy::VariantDef *> variants;\n-  int64_t discriminant_value = 0;\n-  for (auto &variant : enum_decl.get_variants ())\n-    {\n-      TyTy::VariantDef *field_type\n-\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n-\n-      discriminant_value++;\n-      variants.push_back (field_type);\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (enum_decl.get_mappings ().get_nodeid (),\n-\t\t\t\t       &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t enum_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n-\t\t\t std::move (substitutions));\n-\n-  context->insert_type (enum_decl.get_mappings (), type);\n-  infered = type;\n+  infered = TypeCheckItem::Resolve (enum_decl);\n }\n \n void\n TypeCheckStmt::visit (HIR::StructStruct &struct_decl)\n {\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (struct_decl.has_generics ())\n-    {\n-      for (auto &generic_param : struct_decl.get_generic_params ())\n-\t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tauto param_type\n-\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\tcontext->insert_type (generic_param->get_mappings (),\n-\t\t\t\t      param_type);\n-\n-\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t      }\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> fields;\n-  for (auto &field : struct_decl.get_fields ())\n-    {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     field.get_field_name (), field_type,\n-\t\t\t\t     field.get_locus ());\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok = mappings->lookup_canonical_path (\n-    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-  // there is only a single variant\n-  std::vector<TyTy::VariantDef *> variants;\n-  variants.push_back (new TyTy::VariantDef (\n-    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n-\n-  // Process #[repr(...)] attribute, if any\n-  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-  TyTy::ADTType::ReprOptions repr\n-    = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t struct_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t std::move (variants), std::move (substitutions), repr);\n-\n-  context->insert_type (struct_decl.get_mappings (), type);\n-  infered = type;\n+  infered = TypeCheckItem::Resolve (struct_decl);\n }\n \n void\n TypeCheckStmt::visit (HIR::Union &union_decl)\n {\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (union_decl.has_generics ())\n-    {\n-      for (auto &generic_param : union_decl.get_generic_params ())\n-\t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tauto param_type\n-\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\tcontext->insert_type (generic_param->get_mappings (),\n-\t\t\t\t      param_type);\n-\n-\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t      }\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> fields;\n-  for (auto &variant : union_decl.get_variants ())\n-    {\n-      TyTy::BaseType *variant_type\n-\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_variant\n-\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t     variant.get_field_name (), variant_type,\n-\t\t\t\t     variant.get_locus ());\n-      fields.push_back (ty_variant);\n-      context->insert_type (variant.get_mappings (),\n-\t\t\t    ty_variant->get_field_type ());\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (union_decl.get_mappings ().get_nodeid (),\n-\t\t\t\t       &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n-\n-  // there is only a single variant\n-  std::vector<TyTy::VariantDef *> variants;\n-  variants.push_back (new TyTy::VariantDef (\n-    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n-    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t union_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n-\t\t\t std::move (substitutions));\n-\n-  context->insert_type (union_decl.get_mappings (), type);\n-  infered = type;\n+  infered = TypeCheckItem::Resolve (union_decl);\n }\n \n void\n TypeCheckStmt::visit (HIR::Function &function)\n {\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (function.has_generics ())\n-    {\n-      for (auto &generic_param : function.get_generic_params ())\n-\t{\n-\t  switch (generic_param.get ()->get_kind ())\n-\t    {\n-\t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    case HIR::GenericParam::GenericKind::CONST:\n-\t      // FIXME: Skipping Lifetime and Const completely until better\n-\t      // handling.\n-\t      break;\n-\n-\t      case HIR::GenericParam::GenericKind::TYPE: {\n-\t\tauto param_type\n-\t\t  = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\tcontext->insert_type (generic_param->get_mappings (),\n-\t\t\t\t      param_type);\n-\n-\t\tsubstitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t  static_cast<HIR::TypeParam &> (*generic_param), param_type));\n-\t      }\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  TyTy::BaseType *ret_type = nullptr;\n-  if (!function.has_function_return_type ())\n-    ret_type\n-      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n-  else\n-    {\n-      auto resolved\n-\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n-      if (resolved == nullptr)\n-\t{\n-\t  rust_error_at (function.get_locus (),\n-\t\t\t \"failed to resolve return type\");\n-\t  return;\n-\t}\n-\n-      ret_type = resolved->clone ();\n-      ret_type->set_ref (\n-\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n-    }\n-\n-  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-  for (auto &param : function.get_function_params ())\n-    {\n-      // get the name as well required for later on\n-      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-      params.push_back (\n-\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t     param_tyty));\n-\n-      context->insert_type (param.get_mappings (), param_tyty);\n-      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n-\t\t\t\t       &canonical_path);\n-  rust_assert (ok);\n-\n-  RustIdent ident{*canonical_path, function.get_locus ()};\n-  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t  function.get_mappings ().get_defid (),\n-\t\t\t\t  function.get_function_name (), ident,\n-\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n-\t\t\t\t  std::move (params), ret_type,\n-\t\t\t\t  std::move (substitutions));\n-  context->insert_type (function.get_mappings (), fnType);\n+  infered = TypeCheckItem::Resolve (function);\n+}\n \n-  TyTy::FnType *resolved_fn_type = fnType;\n-  auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-  context->push_return_type (TypeCheckContextItem (&function),\n-\t\t\t     expected_ret_tyty);\n+void\n+TypeCheckStmt::visit (HIR::Module &module)\n+{\n+  infered = TypeCheckItem::Resolve (module);\n+}\n \n-  auto block_expr_ty\n-    = TypeCheckExpr::Resolve (function.get_definition ().get ());\n+void\n+TypeCheckStmt::visit (HIR::TypeAlias &type_alias)\n+{\n+  infered = TypeCheckItem::Resolve (type_alias);\n+}\n \n-  context->pop_return_type ();\n+void\n+TypeCheckStmt::visit (HIR::StaticItem &static_item)\n+{\n+  infered = TypeCheckItem::Resolve (static_item);\n+}\n \n-  Location fn_return_locus = function.has_function_return_type ()\n-\t\t\t       ? function.get_return_type ()->get_locus ()\n-\t\t\t       : function.get_locus ();\n-  coercion_site (function.get_definition ()->get_mappings ().get_hirid (),\n-\t\t TyTy::TyWithLocation (expected_ret_tyty, fn_return_locus),\n-\t\t TyTy::TyWithLocation (block_expr_ty),\n-\t\t function.get_definition ()->get_locus ());\n+void\n+TypeCheckStmt::visit (HIR::Trait &trait)\n+{\n+  infered = TypeCheckItem::Resolve (trait);\n+}\n \n-  infered = fnType;\n+void\n+TypeCheckStmt::visit (HIR::ImplBlock &impl)\n+{\n+  infered = TypeCheckItem::Resolve (impl);\n }\n \n } // namespace Resolver"}, {"sha": "5d894a7e703278c0d481b16a55f5b8b42a18bdba", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 22, "deletions": 40, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -40,50 +40,32 @@ class TypeCheckStmt : private TypeCheckBase, private HIR::HIRStmtVisitor\n   void visit (HIR::StructStruct &struct_decl) override;\n   void visit (HIR::Union &union_decl) override;\n   void visit (HIR::Function &function) override;\n+  void visit (HIR::Module &module) override;\n+  void visit (HIR::TypeAlias &type_alias) override;\n+  void visit (HIR::StaticItem &static_item) override;\n+  void visit (HIR::Trait &trait) override;\n+  void visit (HIR::ImplBlock &impl) override;\n+  void visit (HIR::TypePath &path) override;\n+  void visit (HIR::QualifiedPathInType &path) override;\n \n-  void visit (HIR::EnumItemTuple &) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::EnumItemStruct &) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::EnumItem &item) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::EnumItemDiscriminant &) override\n-  { /* TODO? */\n-  }\n+  // FIXME\n+  // this seems like it should not be part of this visitor\n   void visit (HIR::TypePathSegmentFunction &segment) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::TypePath &path) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::QualifiedPathInType &path) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::Module &module) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::ExternCrate &crate) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::UseDeclaration &use_decl) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::TypeAlias &type_alias) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::StaticItem &static_item) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::Trait &trait) override\n-  { /* TODO? */\n-  }\n-  void visit (HIR::ImplBlock &impl) override\n-  { /* TODO? */\n+  {\n+    gcc_unreachable ();\n   }\n \n+  // nothing to do for these\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n+\n+  // nothing to do for these as they are taken care of by the\n+  // hir-type-check-enumitem.h\n+  void visit (HIR::EnumItemTuple &) override {}\n+  void visit (HIR::EnumItemStruct &) override {}\n+  void visit (HIR::EnumItem &) override {}\n+  void visit (HIR::EnumItemDiscriminant &) override {}\n+\n private:\n   TypeCheckStmt () : TypeCheckBase (), infered (nullptr) {}\n "}, {"sha": "a2113d00a975506eca98eca6cb4ee0e30134aa89", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.cc", "status": "removed", "additions": 0, "deletions": 378, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.cc?ref=770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c", "patch": "@@ -1,378 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include \"rust-hir-type-check-toplevel.h\"\n-#include \"rust-hir-type-check-enumitem.h\"\n-#include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-check-expr.h\"\n-#include \"rust-hir-type-check-pattern.h\"\n-#include \"rust-hir-type-check-implitem.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-TypeCheckTopLevel::TypeCheckTopLevel () : TypeCheckBase () {}\n-\n-void\n-TypeCheckTopLevel::Resolve (HIR::Item &item)\n-{\n-  rust_assert (item.get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM);\n-  HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (item);\n-\n-  TypeCheckTopLevel resolver;\n-  vis_item.accept_vis (resolver);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::TypeAlias &alias)\n-{\n-  TyTy::BaseType *actual_type\n-    = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n-\n-  context->insert_type (alias.get_mappings (), actual_type);\n-\n-  for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::TupleStruct &struct_decl)\n-{\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (struct_decl.has_generics ())\n-    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n-\n-  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> fields;\n-  size_t idx = 0;\n-  for (auto &field : struct_decl.get_fields ())\n-    {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     std::to_string (idx), field_type,\n-\t\t\t\t     field.get_locus ());\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-      idx++;\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok = mappings->lookup_canonical_path (\n-    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-  // its a single variant ADT\n-  std::vector<TyTy::VariantDef *> variants;\n-  variants.push_back (new TyTy::VariantDef (\n-    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-    ident, TyTy::VariantDef::VariantType::TUPLE, nullptr, std::move (fields)));\n-\n-  // Process #[repr(X)] attribute, if any\n-  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-  TyTy::ADTType::ReprOptions repr\n-    = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t struct_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t std::move (variants), std::move (substitutions), repr);\n-\n-  context->insert_type (struct_decl.get_mappings (), type);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::Module &module)\n-{\n-  for (auto &item : module.get_items ())\n-    TypeCheckTopLevel::Resolve (*item.get ());\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::StructStruct &struct_decl)\n-{\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (struct_decl.has_generics ())\n-    resolve_generic_params (struct_decl.get_generic_params (), substitutions);\n-\n-  for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> fields;\n-  for (auto &field : struct_decl.get_fields ())\n-    {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     field.get_field_name (), field_type,\n-\t\t\t\t     field.get_locus ());\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok = mappings->lookup_canonical_path (\n-    struct_decl.get_mappings ().get_nodeid (), &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, struct_decl.get_locus ()};\n-\n-  // its a single variant ADT\n-  std::vector<TyTy::VariantDef *> variants;\n-  variants.push_back (new TyTy::VariantDef (\n-    struct_decl.get_mappings ().get_hirid (), struct_decl.get_identifier (),\n-    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n-\n-  // Process #[repr(X)] attribute, if any\n-  const AST::AttrVec &attrs = struct_decl.get_outer_attrs ();\n-  TyTy::ADTType::ReprOptions repr\n-    = parse_repr_options (attrs, struct_decl.get_locus ());\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t struct_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t std::move (variants), std::move (substitutions), repr);\n-\n-  context->insert_type (struct_decl.get_mappings (), type);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::Enum &enum_decl)\n-{\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (enum_decl.has_generics ())\n-    resolve_generic_params (enum_decl.get_generic_params (), substitutions);\n-\n-  std::vector<TyTy::VariantDef *> variants;\n-  int64_t discriminant_value = 0;\n-  for (auto &variant : enum_decl.get_variants ())\n-    {\n-      TyTy::VariantDef *field_type\n-\t= TypeCheckEnumItem::Resolve (variant.get (), discriminant_value);\n-\n-      discriminant_value++;\n-      variants.push_back (field_type);\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (enum_decl.get_mappings ().get_nodeid (),\n-\t\t\t\t       &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, enum_decl.get_locus ()};\n-\n-  // multi variant ADT\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (enum_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t enum_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::ENUM, std::move (variants),\n-\t\t\t std::move (substitutions));\n-\n-  context->insert_type (enum_decl.get_mappings (), type);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::Union &union_decl)\n-{\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (union_decl.has_generics ())\n-    resolve_generic_params (union_decl.get_generic_params (), substitutions);\n-\n-  for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-\n-  std::vector<TyTy::StructFieldType *> fields;\n-  for (auto &variant : union_decl.get_variants ())\n-    {\n-      TyTy::BaseType *variant_type\n-\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_variant\n-\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t     variant.get_field_name (), variant_type,\n-\t\t\t\t     variant.get_locus ());\n-      fields.push_back (ty_variant);\n-      context->insert_type (variant.get_mappings (),\n-\t\t\t    ty_variant->get_field_type ());\n-    }\n-\n-  // get the path\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (union_decl.get_mappings ().get_nodeid (),\n-\t\t\t\t       &canonical_path);\n-  rust_assert (ok);\n-  RustIdent ident{*canonical_path, union_decl.get_locus ()};\n-\n-  // there is only a single variant\n-  std::vector<TyTy::VariantDef *> variants;\n-  variants.push_back (new TyTy::VariantDef (\n-    union_decl.get_mappings ().get_hirid (), union_decl.get_identifier (),\n-    ident, TyTy::VariantDef::VariantType::STRUCT, nullptr, std::move (fields)));\n-\n-  TyTy::BaseType *type\n-    = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),\n-\t\t\t mappings->get_next_hir_id (),\n-\t\t\t union_decl.get_identifier (), ident,\n-\t\t\t TyTy::ADTType::ADTKind::UNION, std::move (variants),\n-\t\t\t std::move (substitutions));\n-\n-  context->insert_type (union_decl.get_mappings (), type);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::StaticItem &var)\n-{\n-  TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());\n-  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n-\n-  TyTy::BaseType *unified\n-    = coercion_site (var.get_mappings ().get_hirid (),\n-\t\t     TyTy::TyWithLocation (type, var.get_type ()->get_locus ()),\n-\t\t     TyTy::TyWithLocation (expr_type,\n-\t\t\t\t\t   var.get_expr ()->get_locus ()),\n-\t\t     var.get_locus ());\n-  context->insert_type (var.get_mappings (), unified);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::ConstantItem &constant)\n-{\n-  TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-  TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n-\n-  TyTy::BaseType *unified = unify_site (\n-    constant.get_mappings ().get_hirid (),\n-    TyTy::TyWithLocation (type, constant.get_type ()->get_locus ()),\n-    TyTy::TyWithLocation (expr_type, constant.get_expr ()->get_locus ()),\n-    constant.get_locus ());\n-  context->insert_type (constant.get_mappings (), unified);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::Function &function)\n-{\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (function.has_generics ())\n-    resolve_generic_params (function.get_generic_params (), substitutions);\n-\n-  for (auto &where_clause_item : function.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-\n-  TyTy::BaseType *ret_type = nullptr;\n-  if (!function.has_function_return_type ())\n-    ret_type\n-      = TyTy::TupleType::get_unit_type (function.get_mappings ().get_hirid ());\n-  else\n-    {\n-      auto resolved\n-\t= TypeCheckType::Resolve (function.get_return_type ().get ());\n-      if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (function.get_locus (),\n-\t\t\t \"failed to resolve return type\");\n-\t  return;\n-\t}\n-\n-      ret_type = resolved->clone ();\n-      ret_type->set_ref (\n-\tfunction.get_return_type ()->get_mappings ().get_hirid ());\n-    }\n-\n-  std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *>> params;\n-  for (auto &param : function.get_function_params ())\n-    {\n-      // get the name as well required for later on\n-      auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n-      params.push_back (\n-\tstd::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t     param_tyty));\n-\n-      context->insert_type (param.get_mappings (), param_tyty);\n-      TypeCheckPattern::Resolve (param.get_param_name (), param_tyty);\n-    }\n-\n-  const CanonicalPath *canonical_path = nullptr;\n-  bool ok\n-    = mappings->lookup_canonical_path (function.get_mappings ().get_nodeid (),\n-\t\t\t\t       &canonical_path);\n-  rust_assert (ok);\n-\n-  RustIdent ident{*canonical_path, function.get_locus ()};\n-  auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t  function.get_mappings ().get_defid (),\n-\t\t\t\t  function.get_function_name (), ident,\n-\t\t\t\t  TyTy::FnType::FNTYPE_DEFAULT_FLAGS, ABI::RUST,\n-\t\t\t\t  std::move (params), ret_type,\n-\t\t\t\t  std::move (substitutions));\n-\n-  context->insert_type (function.get_mappings (), fnType);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::ImplBlock &impl_block)\n-{\n-  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-  if (impl_block.has_generics ())\n-    resolve_generic_params (impl_block.get_generic_params (), substitutions);\n-\n-  for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n-    {\n-      ResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n-    }\n-\n-  auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n-  if (self->get_kind () == TyTy::TypeKind::ERROR)\n-    return;\n-\n-  for (auto &impl_item : impl_block.get_impl_items ())\n-    TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self, substitutions);\n-}\n-\n-void\n-TypeCheckTopLevel::visit (HIR::ExternBlock &extern_block)\n-{\n-  for (auto &item : extern_block.get_extern_items ())\n-    {\n-      TypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n-    }\n-}\n-\n-} // namespace Resolver\n-} // namespace Rust"}, {"sha": "d0db07d7281749aada1c3697f29e48d6647a24a7", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=770a2449e8e3b7c9c8a9627ce5d57c3bcd99177c", "patch": "@@ -1,56 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_TYPE_CHECK_TOPLEVEL\n-#define RUST_HIR_TYPE_CHECK_TOPLEVEL\n-\n-#include \"rust-hir-type-check-base.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-class TypeCheckTopLevel : private TypeCheckBase, public HIR::HIRVisItemVisitor\n-{\n-public:\n-  static void Resolve (HIR::Item &item);\n-\n-  void visit (HIR::Module &module) override;\n-  void visit (HIR::Function &function) override;\n-  void visit (HIR::TypeAlias &alias) override;\n-  void visit (HIR::TupleStruct &struct_decl) override;\n-  void visit (HIR::StructStruct &struct_decl) override;\n-  void visit (HIR::Enum &enum_decl) override;\n-  void visit (HIR::Union &union_decl) override;\n-  void visit (HIR::StaticItem &var) override;\n-  void visit (HIR::ConstantItem &constant) override;\n-  void visit (HIR::ImplBlock &impl_block) override;\n-  void visit (HIR::ExternBlock &extern_block) override;\n-\n-  // nothing to do\n-  void visit (HIR::Trait &trait_block) override {}\n-  void visit (HIR::ExternCrate &crate) override {}\n-  void visit (HIR::UseDeclaration &use_decl) override {}\n-\n-private:\n-  TypeCheckTopLevel ();\n-};\n-\n-} // namespace Resolver\n-} // namespace Rust\n-\n-#endif // RUST_HIR_TYPE_CHECK_TOPLEVEL"}, {"sha": "a47d40e092f1713e4a4c9eabc69c1c11ad05a215", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 37, "deletions": 73, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -48,6 +48,14 @@ TypeCheckResolveGenericArguments::visit (HIR::TypePathSegmentGeneric &generic)\n TyTy::BaseType *\n TypeCheckType::Resolve (HIR::Type *type)\n {\n+  // is it already resolved?\n+  auto context = TypeCheckContext::get ();\n+  TyTy::BaseType *resolved = nullptr;\n+  bool already_resolved\n+    = context->lookup_type (type->get_mappings ().get_hirid (), &resolved);\n+  if (already_resolved)\n+    return resolved;\n+\n   TypeCheckType resolver (type->get_mappings ().get_hirid ());\n   type->accept_vis (resolver);\n   rust_assert (resolver.translated != nullptr);\n@@ -103,77 +111,29 @@ TypeCheckType::visit (HIR::TupleType &tuple)\n void\n TypeCheckType::visit (HIR::TypePath &path)\n {\n-  // lookup the Node this resolves to\n-  NodeId ref;\n-  auto nid = path.get_mappings ().get_nodeid ();\n-  bool is_fully_resolved = resolver->lookup_resolved_type (nid, &ref);\n-\n-  TyTy::BaseType *lookup = nullptr;\n-  if (!is_fully_resolved)\n-    {\n-      // this can happen so we need to look up the root then resolve the\n-      // remaining segments if possible\n-      size_t offset = 0;\n-      NodeId resolved_node_id = UNKNOWN_NODEID;\n-      TyTy::BaseType *root\n-\t= resolve_root_path (path, &offset, &resolved_node_id);\n-\n-      rust_assert (root != nullptr);\n-      if (root->get_kind () == TyTy::TypeKind::ERROR)\n-\treturn;\n-\n-      translated\n-\t= resolve_segments (resolved_node_id, path.get_mappings ().get_hirid (),\n-\t\t\t    path.get_segments (), offset, root,\n-\t\t\t    path.get_mappings (), path.get_locus ());\n-      return;\n-    }\n-\n-  HirId hir_lookup;\n-  if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n-    {\n-      rust_error_at (path.get_locus (), \"failed to lookup HIR %d for node '%s'\",\n-\t\t     ref, path.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (!context->lookup_type (hir_lookup, &lookup))\n-    {\n-      rust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n-      return;\n-    }\n+  // this can happen so we need to look up the root then resolve the\n+  // remaining segments if possible\n+  size_t offset = 0;\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  TyTy::BaseType *root = resolve_root_path (path, &offset, &resolved_node_id);\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n \n-  TyTy::BaseType *path_type = lookup->clone ();\n+  TyTy::BaseType *path_type = root->clone ();\n   path_type->set_ref (path.get_mappings ().get_hirid ());\n+  context->insert_implicit_type (path.get_mappings ().get_hirid (), path_type);\n \n-  HIR::TypePathSegment *final_seg = path.get_final_segment ().get ();\n-  HIR::GenericArgs args = TypeCheckResolveGenericArguments::resolve (final_seg);\n-\n-  bool is_big_self = final_seg->is_ident_only ()\n-\t\t     && (final_seg->as_string ().compare (\"Self\") == 0);\n-\n-  if (path_type->needs_generic_substitutions ())\n-    {\n-      if (is_big_self)\n-\t{\n-\t  translated = path_type;\n-\t  return;\n-\t}\n-\n-      translated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n-    }\n-  else if (!args.is_empty ())\n-    {\n-      rust_error_at (path.get_locus (),\n-\t\t     \"TypePath %s declares generic arguments but \"\n-\t\t     \"the type %s does not have any\",\n-\t\t     path.as_string ().c_str (),\n-\t\t     path_type->as_string ().c_str ());\n-    }\n-  else\n+  bool fully_resolved = offset >= path.get_segments ().size ();\n+  if (fully_resolved)\n     {\n       translated = path_type;\n+      return;\n     }\n+\n+  translated\n+    = resolve_segments (resolved_node_id, path.get_mappings ().get_hirid (),\n+\t\t\tpath.get_segments (), offset, path_type,\n+\t\t\tpath.get_mappings (), path.get_locus ());\n }\n \n void\n@@ -389,7 +349,7 @@ TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n \t}\n \n       TyTy::BaseType *lookup = nullptr;\n-      if (!context->lookup_type (ref, &lookup))\n+      if (!query_type (ref, &lookup))\n \t{\n \t  if (is_root)\n \t    {\n@@ -428,14 +388,22 @@ TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n \n \t  if (!lookup->can_substitute ())\n \t    {\n-\t      rust_error_at (seg->get_locus (),\n-\t\t\t     \"substitutions not supported for %s\",\n+\t      rust_error_at (path.get_locus (),\n+\t\t\t     \"TypePath %s declares generic arguments but the \"\n+\t\t\t     \"type %s does not have any\",\n+\t\t\t     path.as_string ().c_str (),\n \t\t\t     lookup->as_string ().c_str ());\n \t      return new TyTy::ErrorType (lookup->get_ref ());\n \t    }\n \t  lookup = SubstMapper::Resolve (lookup, path.get_locus (),\n \t\t\t\t\t &generic_segment->get_generic_args ());\n \t}\n+      else if (lookup->needs_generic_substitutions ())\n+\t{\n+\t  HIR::GenericArgs empty\n+\t    = HIR::GenericArgs::create_empty (path.get_locus ());\n+\t  lookup = SubstMapper::Resolve (lookup, path.get_locus (), &empty);\n+\t}\n \n       *root_resolved_node_id = ref_node_id;\n       *offset = *offset + 1;\n@@ -531,7 +499,7 @@ TypeCheckType::resolve_segments (\n   context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n   if (tyseg->needs_generic_substitutions ())\n     {\n-      Location locus = segments.back ()->get_locus ();\n+      // Location locus = segments.back ()->get_locus ();\n       if (!prev_segment->needs_generic_substitutions ())\n \t{\n \t  auto used_args_in_prev_segment\n@@ -540,10 +508,6 @@ TypeCheckType::resolve_segments (\n \t    tyseg\n \t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n \t}\n-      else\n-\t{\n-\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t}\n \n       if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n \treturn new TyTy::ErrorType (expr_id);"}, {"sha": "a85ea5c8491765159f3415d4be3a5846d43a7db5", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -18,7 +18,6 @@\n \n #include \"rust-hir-type-check.h\"\n #include \"rust-hir-full.h\"\n-#include \"rust-hir-type-check-toplevel.h\"\n #include \"rust-hir-type-check-item.h\"\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-pattern.h\"\n@@ -35,7 +34,7 @@ void\n TypeResolution::Resolve (HIR::Crate &crate)\n {\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    TypeCheckTopLevel::Resolve (*it->get ());\n+    TypeCheckItem::Resolve (*it->get ());\n \n   if (saw_errors ())\n     return;\n@@ -44,12 +43,6 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   if (saw_errors ())\n     return;\n \n-  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    TypeCheckItem::Resolve (*it->get ());\n-\n-  if (saw_errors ())\n-    return;\n-\n   auto mappings = Analysis::Mappings::get ();\n   auto context = TypeCheckContext::get ();\n "}, {"sha": "c17db71aec7f2a547bef9948df1f0497c8387039", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -337,6 +337,41 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_unconstrained_check_marker (HirId id, bool status)\n+  {\n+    unconstrained[id] = status;\n+  }\n+\n+  bool have_checked_for_unconstrained (HirId id, bool *result)\n+  {\n+    auto it = unconstrained.find (id);\n+    bool found = it != unconstrained.end ();\n+    if (!found)\n+      return false;\n+\n+    *result = it->second;\n+    return true;\n+  }\n+\n+  void insert_resolved_predicate (HirId id, TyTy::TypeBoundPredicate predicate)\n+  {\n+    auto it = predicates.find (id);\n+    rust_assert (it == predicates.end ());\n+\n+    predicates.insert ({id, predicate});\n+  }\n+\n+  bool lookup_predicate (HirId id, TyTy::TypeBoundPredicate *result)\n+  {\n+    auto it = predicates.find (id);\n+    bool found = it != predicates.end ();\n+    if (!found)\n+      return false;\n+\n+    *result = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -365,6 +400,12 @@ class TypeCheckContext\n \n   // variants\n   std::map<HirId, HirId> variants;\n+\n+  // unconstrained type-params check\n+  std::map<HirId, bool> unconstrained;\n+\n+  // predicates\n+  std::map<HirId, TyTy::TypeBoundPredicate> predicates;\n };\n \n class TypeResolution"}, {"sha": "e326bbd94d9bace033c86e588556cc0dbe4df086", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -102,7 +102,7 @@ class SubstMapper : public TyTy::TyVisitor\n     if (!have_generic_args ())\n       {\n \tTyTy::BaseType *substs = type.infer_substitions (locus);\n-\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::PROJECTION);\n \tconcrete = static_cast<TyTy::ProjectionType *> (substs);\n       }\n     else"}, {"sha": "ec4a11fb5924d7810fe9e58f844584a7a359b0d6", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-type-check-item.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -33,11 +34,8 @@ TypeBoundsProbe::scan ()\n       if (!impl->has_trait_ref ())\n \treturn true;\n \n-      TyTy::BaseType *impl_type = nullptr;\n-      bool ok\n-\t= context->lookup_type (impl->get_type ()->get_mappings ().get_hirid (),\n-\t\t\t\t&impl_type);\n-      if (!ok)\n+      TyTy::BaseType *impl_type = TypeCheckItem::ResolveImplBlockSelf (*impl);\n+      if (impl_type->get_kind () == TyTy::TypeKind::ERROR)\n \treturn true;\n \n       if (!receiver->can_eq (impl_type, false))\n@@ -69,6 +67,13 @@ TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n TyTy::TypeBoundPredicate\n TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n {\n+  TyTy::TypeBoundPredicate lookup = TyTy::TypeBoundPredicate::error ();\n+  bool already_resolved\n+    = context->lookup_predicate (type_path.get_mappings ().get_hirid (),\n+\t\t\t\t &lookup);\n+  if (already_resolved)\n+    return lookup;\n+\n   TraitReference *trait = resolve_trait_path (type_path);\n   if (trait->is_error ())\n     return TyTy::TypeBoundPredicate::error ();\n@@ -94,6 +99,8 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n       predicate.apply_generic_arguments (&args);\n     }\n \n+  context->insert_resolved_predicate (type_path.get_mappings ().get_hirid (),\n+\t\t\t\t      predicate);\n   return predicate;\n }\n \n@@ -470,6 +477,13 @@ TypeBoundsMappings::raw_bounds_as_name () const\n void\n TypeBoundsMappings::add_bound (TypeBoundPredicate predicate)\n {\n+  for (auto &bound : specified_bounds)\n+    {\n+      bool same_trait_ref_p = bound.get_id () == predicate.get_id ();\n+      if (same_trait_ref_p)\n+\treturn;\n+    }\n+\n   specified_bounds.push_back (predicate);\n }\n "}, {"sha": "1e5dcb5a2e31d866dfd0941bffc5bccbe7a572c4", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -1358,6 +1358,8 @@ class ParamCmp : public BaseCmp\n   // generic arguments\n   void visit (const ParamType &) override { ok = true; }\n \n+  void visit (const TupleType &) override { ok = true; }\n+\n   void visit (const InferType &) override { ok = true; }\n \n   void visit (const FnType &) override { ok = true; }"}, {"sha": "b9a93186208f27aa788206273a3d2319ab7bec39", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -208,9 +208,6 @@ void\n BaseType::inherit_bounds (\n   const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n {\n-  // FIXME\n-  // 1. This needs to union the bounds\n-  // 2. Do some checking for trait polarity to ensure compatibility\n   for (auto &bound : specified_bounds)\n     {\n       add_bound (bound);\n@@ -754,6 +751,40 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n   return SubstitutionArgumentMappings (mappings, args.get_locus ());\n }\n \n+BaseType *\n+SubstitutionRef::infer_substitions (Location locus)\n+{\n+  std::vector<SubstitutionArg> args;\n+  std::map<std::string, BaseType *> argument_mappings;\n+  for (auto &p : get_substs ())\n+    {\n+      if (p.needs_substitution ())\n+\t{\n+\t  const std::string &symbol = p.get_param_ty ()->get_symbol ();\n+\t  auto it = argument_mappings.find (symbol);\n+\t  bool have_mapping = it != argument_mappings.end ();\n+\n+\t  if (have_mapping)\n+\t    {\n+\t      args.push_back (SubstitutionArg (&p, it->second));\n+\t    }\n+\t  else\n+\t    {\n+\t      TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t      args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t      argument_mappings[symbol] = infer_var.get_tyty ();\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  args.push_back (SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t}\n+    }\n+\n+  SubstitutionArgumentMappings infer_arguments (std::move (args), locus);\n+  return handle_substitions (std::move (infer_arguments));\n+}\n+\n SubstitutionArgumentMappings\n SubstitutionRef::adjust_mappings_for_this (\n   SubstitutionArgumentMappings &mappings)\n@@ -2479,7 +2510,13 @@ ParamType::resolve () const\n \tbreak;\n \n       TyVar v (rr->get_ty_ref ());\n-      r = v.get_tyty ();\n+      BaseType *n = v.get_tyty ();\n+\n+      // fix infinite loop\n+      if (r == n)\n+\tbreak;\n+\n+      r = n;\n     }\n \n   if (r->get_kind () == TypeKind::PARAM && (r->get_ref () == r->get_ty_ref ()))"}, {"sha": "cad1a1d01de595ff131975181e55d423fc097efc", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -960,37 +960,7 @@ class SubstitutionRef\n   solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n \n   // TODO comment\n-  BaseType *infer_substitions (Location locus)\n-  {\n-    std::vector<SubstitutionArg> args;\n-    std::map<std::string, BaseType *> argument_mappings;\n-    for (auto &p : get_substs ())\n-      {\n-\tif (p.needs_substitution ())\n-\t  {\n-\t    const std::string &symbol = p.get_param_ty ()->get_symbol ();\n-\t    auto it = argument_mappings.find (symbol);\n-\t    if (it == argument_mappings.end ())\n-\t      {\n-\t\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n-\t\targs.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n-\t\targument_mappings[symbol] = infer_var.get_tyty ();\n-\t      }\n-\t    else\n-\t      {\n-\t\targs.push_back (SubstitutionArg (&p, it->second));\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    args.push_back (\n-\t      SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n-\t  }\n-      }\n-\n-    SubstitutionArgumentMappings infer_arguments (std::move (args), locus);\n-    return handle_substitions (std::move (infer_arguments));\n-  }\n+  BaseType *infer_substitions (Location locus);\n \n   // TODO comment\n   bool monomorphize ();\n@@ -1059,6 +1029,8 @@ class TypeBoundPredicate : public SubstitutionRef\n \n   bool contains_associated_types () const;\n \n+  DefId get_id () const { return reference; }\n+\n private:\n   DefId reference;\n   Location locus;"}, {"sha": "3761d5f01d34bf3ce2c0acdd674d91e4397c9ff5", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -419,7 +419,9 @@ Mappings::insert_hir_impl_block (HIR::ImplBlock *item)\n   auto id = item->get_mappings ().get_hirid ();\n   rust_assert (lookup_hir_impl_block (id) == nullptr);\n \n+  HirId impl_type_id = item->get_type ()->get_mappings ().get_hirid ();\n   hirImplBlockMappings[id] = item;\n+  hirImplBlockTypeMappings[impl_type_id] = item;\n   insert_node_to_hir (item->get_mappings ().get_nodeid (), id);\n }\n \n@@ -433,6 +435,17 @@ Mappings::lookup_hir_impl_block (HirId id)\n   return it->second;\n }\n \n+bool\n+Mappings::lookup_impl_block_type (HirId id, HIR::ImplBlock **impl_block)\n+{\n+  auto it = hirImplBlockTypeMappings.find (id);\n+  if (it == hirImplBlockTypeMappings.end ())\n+    return false;\n+\n+  *impl_block = it->second;\n+  return true;\n+}\n+\n void\n Mappings::insert_module (HIR::Module *module)\n {"}, {"sha": "44018489f454a703aa97d4c75b6d65786c10afd3", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -123,6 +123,7 @@ class Mappings\n \n   void insert_hir_impl_block (HIR::ImplBlock *item);\n   HIR::ImplBlock *lookup_hir_impl_block (HirId id);\n+  bool lookup_impl_block_type (HirId id, HIR::ImplBlock **impl_block);\n \n   void insert_module (HIR::Module *module);\n   HIR::Module *lookup_module (HirId id);\n@@ -314,6 +315,7 @@ class Mappings\n   std::map<HirId, HIR::SelfParam *> hirSelfParamMappings;\n   std::map<HirId, HIR::ImplBlock *> hirImplItemsToImplMappings;\n   std::map<HirId, HIR::ImplBlock *> hirImplBlockMappings;\n+  std::map<HirId, HIR::ImplBlock *> hirImplBlockTypeMappings;\n   std::map<HirId, HIR::TraitItem *> hirTraitItemMappings;\n   std::map<HirId, HIR::ExternBlock *> hirExternBlockMappings;\n   std::map<HirId, std::pair<HIR::ExternalItem *, HirId>> hirExternItemMappings;"}, {"sha": "46cf6c939687bf3d0d4e4d912ff6de6c335749ee", "filename": "gcc/testsuite/rust/compile/const_generics_5.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -1,12 +1,15 @@\n+// bogus errors but shows the type checking system needs to support const\n+// generics with defaults\n+\n struct Foo<const N: usize = { 14 }>;\n \n const M: usize = 15;\n-type N = Foo<3>;\n+type N = Foo<3>; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n \n fn main() {\n-    let _: Foo<15> = Foo;\n-    let _: Foo<{ M }> = Foo;\n-    let _: Foo<M> = Foo;\n-    // bogus error, but it means the above const generic gets disambiguated properly\n+    let _: Foo<15> = Foo; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+    let _: Foo<{ M }> = Foo; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+    let _: Foo<M> = Foo; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+\n     let _: Foo<N> = Foo; // { dg-error \"TypePath Foo<N> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n }"}, {"sha": "7fe74c2c7981e09878733d2a0a236d0f93b914a5", "filename": "gcc/testsuite/rust/compile/unconstrained_type_param.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Ftestsuite%2Frust%2Fcompile%2Funconstrained_type_param.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4/gcc%2Ftestsuite%2Frust%2Fcompile%2Funconstrained_type_param.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Funconstrained_type_param.rs?ref=96c8baa8a7a8aa796450585c1ba2c1fe2428b6f4", "patch": "@@ -9,4 +9,6 @@ impl<X, Y> Foo<X> {\n \n fn main() {\n     let a = Foo::test();\n+    // { dg-error \"Failed to resolve expression of function call\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n }"}]}