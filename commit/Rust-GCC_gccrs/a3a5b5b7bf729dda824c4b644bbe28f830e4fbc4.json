{"sha": "a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhNWI1YjdiZjcyOWRkYTgyNGM0YjY0NGJiZTI4ZjgzMGU0ZmJjNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1997-09-28T19:37:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-28T19:37:05Z"}, "message": "cplus-dem.c (demangle_template): Add new parameter.\n\nSun Sep 28 12:00:52 1997  Mark Mitchell  <mmitchell@usa.net>\n\n        * cplus-dem.c (demangle_template): Add new parameter.  Handle new\n        template-function mangling.\n        (consume_count_with_underscores): New function.\n        (demangle_signature): Handle new name-mangling scheme.\n\nFrom-SVN: r15778", "tree": {"sha": "b9d61a358f04c03ae2a7ce7d0273bd37a11ce793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9d61a358f04c03ae2a7ce7d0273bd37a11ce793"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4/comments", "author": null, "committer": null, "parents": [{"sha": "a98d45ff1f4d45241c521994bbf03c438ba0d91f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98d45ff1f4d45241c521994bbf03c438ba0d91f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a98d45ff1f4d45241c521994bbf03c438ba0d91f"}], "stats": {"total": 304, "additions": 252, "deletions": 52}, "files": [{"sha": "a2c2274c9381225ab4fa02ee76a70f879b0f6578", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4", "patch": "@@ -1,3 +1,10 @@\n+Sun Sep 28 12:00:52 1997  Mark Mitchell  <mmitchell@usa.net>\n+\n+        * cplus-dem.c (demangle_template): Add new parameter.  Handle new\n+        template-function mangling.\n+        (consume_count_with_underscores): New function.\n+        (demangle_signature): Handle new name-mangling scheme.\n+\n Tue Sep  9 19:39:12 1997  Jim Wilson  <wilson@cygnus.com>\n \n \t* Makefile.in (install_to_libdir, install_to_tooldir): Add MULTISUBDIR"}, {"sha": "055ab0818e5d9e0e0608e7c4e34b4ea2ff6df192", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 245, "deletions": 52, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=a3a5b5b7bf729dda824c4b644bbe28f830e4fbc4", "patch": "@@ -102,6 +102,8 @@ struct work_stuff\n   int destructor;\n   int static_type;\t/* A static member function */\n   int const_type;\t/* A const member function */\n+  char **tmpl_argvec;   /* Template function arguments. */\n+  int ntmpl_args;       /* The number of template function arguments. */\n };\n \n #define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)\n@@ -222,7 +224,7 @@ demangle_method_args PARAMS ((struct work_stuff *work, const char **, string *))\n \n static int\n demangle_template PARAMS ((struct work_stuff *work, const char **, string *,\n-\t\t\t   string *));\n+\t\t\t   string *, int));\n \n static int\n arm_pt PARAMS ((struct work_stuff *, const char *, int, const char **,\n@@ -294,6 +296,9 @@ get_count PARAMS ((const char **, int *));\n static int\n consume_count PARAMS ((const char **));\n \n+static int \n+consume_count_with_underscores PARAMS ((const char**));\n+\n static int\n demangle_args PARAMS ((struct work_stuff *, const char **, string *));\n \n@@ -336,6 +341,42 @@ consume_count (type)\n   return (count);\n }\n \n+\n+/* Like consume_count, but for counts that are preceeded and followed\n+   by '_' if they are greater than 10.  Also, -1 is returned for\n+   failure, since 0 can be a valid value.  */\n+\n+static int\n+consume_count_with_underscores (mangled)\n+     const char **mangled;\n+{\n+  int idx;\n+\n+  if (**mangled == '_')\n+    {\n+      (*mangled)++;\n+      if (!isdigit (**mangled))\n+\treturn -1;\n+\n+      idx = consume_count (mangled);\n+      if (**mangled != '_')\n+\t/* The trailing underscore was missing. */\n+\treturn -1;\n+\t    \n+      (*mangled)++;\n+    }\n+  else\n+    {\n+      if (**mangled < '0' || **mangled > '9')\n+\treturn -1;\n+\t    \n+      idx = **mangled - '0';\n+      (*mangled)++;\n+    }\n+\n+  return idx;\n+}\n+\n int\n cplus_demangle_opname (opname, result, options)\n      const char *opname;\n@@ -580,7 +621,17 @@ mop_up (work, declp, success)\n     {\n       free ((char *) work -> typevec);\n     }\n-  \n+  if (work->tmpl_argvec)\n+    {\n+      int i;\n+\n+      for (i = 0; i < work->ntmpl_args; i++)\n+\tif (work->tmpl_argvec[i])\n+\t  free ((char*) work->tmpl_argvec[i]);\n+      \n+      free ((char*) work->tmpl_argvec);\n+    }\n+\n   /* If demangling was successful, ensure that the demangled string is null\n      terminated and return it.  Otherwise, free the demangling decl.  */\n   \n@@ -635,6 +686,7 @@ demangle_signature (work, mangled, declp)\n   int success = 1;\n   int func_done = 0;\n   int expect_func = 0;\n+  int expect_return_type = 0;\n   const char *oldmangled = NULL;\n   string trawname;\n   string tname;\n@@ -726,7 +778,7 @@ demangle_signature (work, mangled, declp)\n \t    {\n \t      oldmangled = *mangled;\n \t    }\n-\t  success = demangle_template (work, mangled, &tname, &trawname);\n+\t  success = demangle_template (work, mangled, &tname, &trawname, 1);\n \t  if (success)\n \t    {\n \t      remember_type (work, oldmangled, *mangled - oldmangled);\n@@ -751,14 +803,42 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase '_':\n-\t  /* At the outermost level, we cannot have a return type specified,\n-\t     so if we run into another '_' at this point we are dealing with\n-\t     a mangled name that is either bogus, or has been mangled by\n-\t     some algorithm we don't know how to deal with.  So just\n-\t     reject the entire demangling.  */\n-\t  success = 0;\n+\t  if (GNU_DEMANGLING && expect_return_type) \n+\t    {\n+\t      /* Read the return type. */\n+\t      string return_type;\n+\t      string_init (&return_type);\n+\n+\t      (*mangled)++;\n+\t      success = do_type (work, mangled, &return_type);\n+\t      APPEND_BLANK (&return_type);\n+\n+\t      string_prepends (declp, &return_type);\n+\t      string_delete (&return_type);\n+\t      break;\n+\t    }\n+\t  else\n+\t    /* At the outermost level, we cannot have a return type specified,\n+\t       so if we run into another '_' at this point we are dealing with\n+\t       a mangled name that is either bogus, or has been mangled by\n+\t       some algorithm we don't know how to deal with.  So just\n+\t       reject the entire demangling.  */\n+\t    success = 0;\n \t  break;\n \n+\tcase 'H':\n+\t  if (GNU_DEMANGLING) \n+\t    {\n+\t      /* A G++ template function.  Read the template arguments. */\n+\t      success = demangle_template (work, mangled, declp, 0, 0);\n+\t      expect_return_type = 1;\n+\t      (*mangled)++;\n+\t      break;\n+\t    }\n+\t  else\n+\t    /* fall through */\n+\t    ;\n+\n \tdefault:\n \t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n \t    {\n@@ -785,6 +865,10 @@ demangle_signature (work, mangled, declp)\n \t  {\n \t    func_done = 1;\n \t    success = demangle_args (work, mangled, declp);\n+\t    /* Since template include the mangling of their return types,\n+\t       we must set expect_func to 0 so that we don't try do\n+\t       demangle more arguments the next time we get here.  */\n+\t    expect_func = 0;\n \t  }\n       }\n     }\n@@ -838,11 +922,12 @@ demangle_method_args (work, mangled, declp)\n #endif\n \n static int\n-demangle_template (work, mangled, tname, trawname)\n+demangle_template (work, mangled, tname, trawname, is_type)\n      struct work_stuff *work;\n      const char **mangled;\n      string *tname;\n      string *trawname;\n+     int is_type;\n {\n   int i;\n   int is_pointer;\n@@ -857,31 +942,43 @@ demangle_template (work, mangled, tname, trawname)\n   const char *old_p;\n   const char *start;\n   int symbol_len;\n-  int is_java_array;\n+  int is_java_array = 0;\n   string temp;\n \n   (*mangled)++;\n-  start = *mangled;\n-  /* get template name */\n-  if ((r = consume_count (mangled)) == 0 || strlen (*mangled) < r)\n+  if (is_type)\n     {\n-      return (0);\n-    }\n-  if (trawname)\n-    string_appendn (trawname, *mangled, r);\n-  is_java_array = (work -> options & DMGL_JAVA)\n-    && strncmp (*mangled, \"JArray1Z\", 8) == 0;\n-  if (! is_java_array)\n-    {\n-      string_appendn (tname, *mangled, r);\n-      string_append (tname, \"<\");\n+      start = *mangled;\n+      /* get template name */\n+      if ((r = consume_count (mangled)) == 0 || strlen (*mangled) < r)\n+\t{\n+\t  return (0);\n+\t}\n+      if (trawname)\n+\tstring_appendn (trawname, *mangled, r);\n+      is_java_array = (work -> options & DMGL_JAVA)\n+\t&& strncmp (*mangled, \"JArray1Z\", 8) == 0;\n+      if (! is_java_array)\n+\t{\n+\t  string_appendn (tname, *mangled, r);\n+\t}\n+      *mangled += r;\n     }\n-  *mangled += r;\n+  if (!is_java_array)\n+    string_append (tname, \"<\");\n   /* get size of template parameter list */\n   if (!get_count (mangled, &r))\n     {\n       return (0);\n     }\n+  if (!is_type)\n+    {\n+      /* Create an array for saving the template argument values. */\n+      work->tmpl_argvec = (char**) xmalloc (r * sizeof (char *));\n+      work->ntmpl_args = r;\n+      for (i = 0; i < r; i++)\n+\twork->tmpl_argvec[i] = 0;\n+    }\n   for (i = 0; i < r; i++)\n     {\n       if (need_comma)\n@@ -897,6 +994,15 @@ demangle_template (work, mangled, tname, trawname)\n \t  if (success)\n \t    {\n \t      string_appends (tname, &temp);\n+\n+\t      if (!is_type)\n+\t\t{\n+\t\t  /* Save the template argument. */\n+\t\t  int len = temp.p - temp.b;\n+\t\t  work->tmpl_argvec[i] = xmalloc (len + 1);\n+\t\t  memcpy (work->tmpl_argvec[i], temp.b, len);\n+\t\t  work->tmpl_argvec[i][len] = '\\0';\n+\t\t}\n \t    }\n \t  string_delete(&temp);\n \t  if (!success)\n@@ -906,6 +1012,9 @@ demangle_template (work, mangled, tname, trawname)\n \t}\n       else\n \t{\n+\t  string  param;\n+\t  string* s;\n+\n \t  /* otherwise, value parameter */\n \t  old_p  = *mangled;\n \t  is_pointer = 0;\n@@ -919,7 +1028,7 @@ demangle_template (work, mangled, tname, trawname)\n \t  /*\n \t    if (success)\n \t    {\n-\t    string_appends (tname, &temp);\n+\t    string_appends (s, &temp);\n \t    }\n \t    */\n \t  string_delete(&temp);\n@@ -928,8 +1037,17 @@ demangle_template (work, mangled, tname, trawname)\n \t      break;\n \t    }\n \t  /*\n-\t    string_append (tname, \"=\");\n+\t    string_append (s, \"=\");\n \t    */\n+\n+\t  if (!is_type)\n+\t    {\n+\t      s = &param;\n+\t      string_init (s);\n+\t    }\n+\t  else\n+\t    s = tname;\n+\n \t  while (*old_p && !done)\n \t    {\t\n \t      switch (*old_p)\n@@ -983,16 +1101,41 @@ demangle_template (work, mangled, tname, trawname)\n \t\t  done = is_integral = 1;\n \t\t}\n \t    }\n-\t  if (is_integral)\n+\t  if (**mangled == 'Y')\n+\t    {\n+\t      /* The next argument is a template parameter. */\n+\t      int idx;\n+\n+\t      (*mangled)++;\n+\t      idx = consume_count_with_underscores (mangled);\n+\t      if (idx == -1 \n+\t\t  || (work->tmpl_argvec && idx >= work->ntmpl_args)\n+\t\t  || consume_count_with_underscores (mangled) == -1)\n+\t\t{\n+\t\t  success = 0;\n+\t\t  if (!is_type)\n+\t\t    string_delete (s);\n+\t\t  break;\n+\t\t}\n+\t      if (work->tmpl_argvec)\n+\t\tstring_append (s, work->tmpl_argvec[idx]);\n+\t      else\n+\t\t{\n+\t\t  char buf[10];\n+\t\t  sprintf(buf, \"T%d\", idx);\n+\t\t  string_append (s, buf);\n+\t\t}\n+\t    }\n+\t  else if (is_integral)\n \t    {\n \t      if (**mangled == 'm')\n \t\t{\n-\t\t  string_appendn (tname, \"-\", 1);\n+\t\t  string_appendn (s, \"-\", 1);\n \t\t  (*mangled)++;\n \t\t}\n \t      while (isdigit (**mangled))\t\n \t\t{\n-\t\t  string_appendn (tname, *mangled, 1);\n+\t\t  string_appendn (s, *mangled, 1);\n \t\t  (*mangled)++;\n \t\t}\n \t    }\n@@ -1002,60 +1145,62 @@ demangle_template (work, mangled, tname, trawname)\n \t      int val;\n               if (**mangled == 'm')\n                 {\n-                  string_appendn (tname, \"-\", 1);\n+                  string_appendn (s, \"-\", 1);\n                   (*mangled)++;\n                 }\n-\t      string_appendn (tname, \"'\", 1);\n+\t      string_appendn (s, \"'\", 1);\n               val = consume_count(mangled);\n \t      if (val == 0)\n \t\t{\n \t\t  success = 0;\n+\t\t  if (!is_type)\n+\t\t    string_delete (s);\n \t\t  break;\n                 }\n               tmp[0] = (char)val;\n               tmp[1] = '\\0';\n-              string_appendn (tname, &tmp[0], 1);\n-\t      string_appendn (tname, \"'\", 1);\n+              string_appendn (s, &tmp[0], 1);\n+\t      string_appendn (s, \"'\", 1);\n \t    }\n \t  else if (is_bool)\n \t    {\n \t      int val = consume_count (mangled);\n \t      if (val == 0)\n-\t\tstring_appendn (tname, \"false\", 5);\n+\t\tstring_appendn (s, \"false\", 5);\n \t      else if (val == 1)\n-\t\tstring_appendn (tname, \"true\", 4);\n+\t\tstring_appendn (s, \"true\", 4);\n \t      else\n \t\tsuccess = 0;\n \t    }\n \t  else if (is_real)\n \t    {\n \t      if (**mangled == 'm')\n \t\t{\n-\t\t  string_appendn (tname, \"-\", 1);\n+\t\t  string_appendn (s, \"-\", 1);\n \t\t  (*mangled)++;\n \t\t}\n \t      while (isdigit (**mangled))\t\n \t\t{\n-\t\t  string_appendn (tname, *mangled, 1);\n+\t\t  string_appendn (s, *mangled, 1);\n \t\t  (*mangled)++;\n \t\t}\n \t      if (**mangled == '.') /* fraction */\n \t\t{\n-\t\t  string_appendn (tname, \".\", 1);\n+\t\t  string_appendn (s, \".\", 1);\n \t\t  (*mangled)++;\n \t\t  while (isdigit (**mangled))\t\n \t\t    {\n-\t\t      string_appendn (tname, *mangled, 1);\n+\t\t      string_appendn (s, *mangled, 1);\n \t\t      (*mangled)++;\n \t\t    }\n \t\t}\n \t      if (**mangled == 'e') /* exponent */\n \t\t{\n-\t\t  string_appendn (tname, \"e\", 1);\n+\t\t  string_appendn (s, \"e\", 1);\n \t\t  (*mangled)++;\n \t\t  while (isdigit (**mangled))\t\n \t\t    {\n-\t\t      string_appendn (tname, *mangled, 1);\n+\t\t      string_appendn (s, *mangled, 1);\n \t\t      (*mangled)++;\n \t\t    }\n \t\t}\n@@ -1066,28 +1211,40 @@ demangle_template (work, mangled, tname, trawname)\n \t      if (symbol_len == 0)\n \t\t{\n \t\t  success = 0;\n+\t\t  if (!is_type)\n+\t\t    string_delete (s);\n \t\t  break;\n \t\t}\n \t      if (symbol_len == 0)\n-\t\tstring_appendn (tname, \"0\", 1);\n+\t\tstring_appendn (s, \"0\", 1);\n \t      else\n \t\t{\n \t\t  char *p = xmalloc (symbol_len + 1), *q;\n \t\t  strncpy (p, *mangled, symbol_len);\n \t\t  p [symbol_len] = '\\0';\n \t\t  q = cplus_demangle (p, work->options);\n-\t\t  string_appendn (tname, \"&\", 1);\n+\t\t  string_appendn (s, \"&\", 1);\n \t\t  if (q)\n \t\t    {\n-\t\t      string_append (tname, q);\n+\t\t      string_append (s, q);\n \t\t      free (q);\n \t\t    }\n \t\t  else\n-\t\t    string_append (tname, p);\n+\t\t    string_append (s, p);\n \t\t  free (p);\n \t\t}\n \t      *mangled += symbol_len;\n \t    }\n+\t  if (!is_type)\n+\t    {\n+\t      int len = s->p - s->b;\n+\t      work->tmpl_argvec[i] = xmalloc (len + 1);\n+\t      memcpy (work->tmpl_argvec[i], s->b, len);\n+\t      work->tmpl_argvec[i][len] = '\\0';\n+\t      \n+\t      string_appends (tname, s);\n+\t      string_delete (s);\n+\t    }\n \t}\n       need_comma = 1;\n     }\n@@ -1526,7 +1683,7 @@ gnu_special (work, mangled, declp)\n \t      success = demangle_qualified (work, mangled, declp, 0, 1);\n \t      break;\n \t    case 't':\n-\t      success = demangle_template (work, mangled, declp, 0);\n+\t      success = demangle_template (work, mangled, declp, 0, 1);\n \t      break;\n \t    default:\n \t      if (isdigit(*mangled[0]))\n@@ -1571,7 +1728,7 @@ gnu_special (work, mangled, declp)\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n-\t  success = demangle_template (work, mangled, declp, 0);\n+\t  success = demangle_template (work, mangled, declp, 0, 1);\n \t  break;\n \tdefault:\n \t  n = consume_count (mangled);\n@@ -1623,7 +1780,7 @@ gnu_special (work, mangled, declp)\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n-\t  success = demangle_template (work, mangled, declp, 0);\n+\t  success = demangle_template (work, mangled, declp, 0, 1);\n \t  break;\n \tdefault:\n \t  success = demangle_fund_type (work, mangled, declp);\n@@ -1825,7 +1982,12 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \t*mangled = *mangled + 1;\n       if (*mangled[0] == 't')\n \t{\n-\t  success = demangle_template(work, mangled, &temp, 0);\n+\t  success = demangle_template(work, mangled, &temp, 0, 1);\n+\t  if (!success) break;\n+\t}\n+      else if (*mangled[0] == 'X')\n+\t{\n+\t  success = do_type (work, mangled, &temp);\n \t  if (!success) break;\n \t}\n       else\n@@ -2064,7 +2226,7 @@ do_type (work, mangled, result)\n \t      {\n \t\tstring temp;\n \t\tstring_init (&temp);\n-\t\tsuccess = demangle_template (work, mangled, &temp, NULL);\n+\t\tsuccess = demangle_template (work, mangled, &temp, NULL, 1);\n \t\tif (success)\n \t\t  {\n \t\t    string_prependn (&decl, temp.b, temp.p - temp.b);\n@@ -2152,6 +2314,37 @@ do_type (work, mangled, result)\n       success = demangle_qualified (work, mangled, result, 0, 1);\n       break;\n \n+    case 'X':\n+    case 'Y':\n+      /* A template parm.  We substitute the corresponding argument. */\n+      {\n+\tint idx;\n+\tint lvl;\n+\n+\t(*mangled)++;\n+\tidx = consume_count_with_underscores (mangled);\n+\n+\tif (idx == -1 \n+\t    || (work->tmpl_argvec && idx >= work->ntmpl_args)\n+\t    || consume_count_with_underscores (mangled) == -1)\n+\t  {\n+\t    success = 0;\n+\t    break;\n+\t  }\n+\n+\tif (work->tmpl_argvec)\n+\t  string_append (result, work->tmpl_argvec[idx]);\n+\telse\n+\t  {\n+\t    char buf[10];\n+\t    sprintf(buf, \"T%d\", idx);\n+\t    string_append (result, buf);\n+\t  }\n+\n+\tsuccess = 1;\n+      }\n+    break;\n+\n     default:\n       success = demangle_fund_type (work, mangled, result);\n       break;\n@@ -2326,7 +2519,7 @@ demangle_fund_type (work, mangled, result)\n       }\n       break;\n     case 't':\n-      success = demangle_template(work,mangled, result, 0);\n+      success = demangle_template(work,mangled, result, 0, 1);\n       break;\n     default:\n       success = 0;"}]}