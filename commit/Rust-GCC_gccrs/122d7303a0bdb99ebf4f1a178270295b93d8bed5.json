{"sha": "122d7303a0bdb99ebf4f1a178270295b93d8bed5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIyZDczMDNhMGJkYjk5ZWJmNGYxYTE3ODI3MDI5NWI5M2Q4YmVkNQ==", "commit": {"author": {"name": "Andrey Turetskiy", "email": "andrey.turetskiy@intel.com", "date": "2014-11-13T13:56:22Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:56:22Z"}, "message": "[PATCH 7/7] OpenMP 4.0 offloading infrastructure: testsuite.\n\nlibgomp/\n\t* testsuite/lib/libgomp.exp\n\t(check_effective_target_offload_device): New.\n\t* testsuite/libgomp.c++/c++.exp: Include tests from subdirectories.\n\t* testsuite/libgomp.c++/examples-4/e.51.5.C: New test.\n\t* testsuite/libgomp.c++/examples-4/e.53.2.C: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.50.1.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.50.2.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.50.3.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.50.4.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.50.5.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.51.1.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.51.2.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.51.3.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.51.4.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.51.6.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.51.7.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.52.1.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.52.2.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.53.1.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.53.3.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.53.4.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.53.5.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.54.2.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.54.3.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.54.4.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.54.5.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.54.6.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.55.1.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.55.2.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.56.3.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.56.4.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.57.1.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.57.2.c: Ditto.\n\t* testsuite/libgomp.c/examples-4/e.57.3.c: Ditto.\n\t* testsuite/libgomp.c/target-7.c: Fix test.\n\t* testsuite/libgomp.fortran/examples-4/e.50.1.f90: New test.\n\t* testsuite/libgomp.fortran/examples-4/e.50.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.50.3.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.50.4.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.50.5.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.1.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.3.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.4.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.5.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.6.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.51.7.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.52.1.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.52.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.53.1.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.53.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.53.3.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.53.4.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.53.5.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.54.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.54.3.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.54.4.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.54.5.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.54.6.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.55.1.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.55.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.56.3.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.56.4.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.57.1.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.57.2.f90: Ditto.\n\t* testsuite/libgomp.fortran/examples-4/e.57.3.f90: Ditto.\n\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\n\nFrom-SVN: r217494", "tree": {"sha": "d2c1d75d58f000bd59c8eac757bb91fc0f5c3b0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2c1d75d58f000bd59c8eac757bb91fc0f5c3b0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/122d7303a0bdb99ebf4f1a178270295b93d8bed5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122d7303a0bdb99ebf4f1a178270295b93d8bed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122d7303a0bdb99ebf4f1a178270295b93d8bed5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122d7303a0bdb99ebf4f1a178270295b93d8bed5/comments", "author": null, "committer": null, "parents": [{"sha": "c713ddc0314d680f961155610a723e7b882e2ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c713ddc0314d680f961155610a723e7b882e2ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c713ddc0314d680f961155610a723e7b882e2ae3"}], "stats": {"total": 3691, "additions": 3686, "deletions": 5}, "files": [{"sha": "e5522cf2ddce39d629d758a619f3d57a78ed45e5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -1,3 +1,75 @@\n+2014-11-13  Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\n+\t* testsuite/lib/libgomp.exp\n+\t(check_effective_target_offload_device): New.\n+\t* testsuite/libgomp.c++/c++.exp: Include tests from subdirectories.\n+\t* testsuite/libgomp.c++/examples-4/e.51.5.C: New test.\n+\t* testsuite/libgomp.c++/examples-4/e.53.2.C: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.50.1.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.50.2.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.50.3.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.50.4.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.50.5.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.51.1.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.51.2.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.51.3.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.51.4.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.51.6.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.51.7.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.52.1.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.52.2.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.53.1.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.53.3.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.53.4.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.53.5.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.54.2.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.54.3.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.54.4.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.54.5.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.54.6.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.55.1.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.55.2.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.56.3.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.56.4.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.57.1.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.57.2.c: Ditto.\n+\t* testsuite/libgomp.c/examples-4/e.57.3.c: Ditto.\n+\t* testsuite/libgomp.c/target-7.c: Fix test.\n+\t* testsuite/libgomp.fortran/examples-4/e.50.1.f90: New test.\n+\t* testsuite/libgomp.fortran/examples-4/e.50.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.50.3.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.50.4.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.50.5.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.1.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.3.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.4.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.5.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.6.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.51.7.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.52.1.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.52.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.53.1.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.53.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.53.3.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.53.4.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.53.5.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.54.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.54.3.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.54.4.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.54.5.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.54.6.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.55.1.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.55.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.56.3.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.56.4.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.57.1.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.57.2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/examples-4/e.57.3.f90: Ditto.\n+\n 2014-11-13  Jakub Jelinek  <jakub@redhat.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>"}, {"sha": "071e22fbf30f99711767bacb8ff1ae5f832c9c76", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -239,3 +239,17 @@ proc libgomp_option_proc { option } {\n \treturn 0\n     }\n }\n+\n+# Return 1 if offload device is available.\n+proc check_effective_target_offload_device { } {\n+    return [check_runtime_nocache offload_device_available_ {\n+      #include <omp.h>\n+      int main ()\n+\t{\n+\t  int a;\n+\t  #pragma omp target map(from: a)\n+\t    a = omp_is_initial_device ();\n+\t  return a;\n+\t}\n+    } ]\n+}"}, {"sha": "da42e6213b0a0c2d047fa3197dcce042d4d88ea5", "filename": "libgomp/testsuite/libgomp.c++/c++.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -42,7 +42,7 @@ if { $blddir != \"\" } {\n \n if { $lang_test_file_found } {\n     # Gather a list of all tests.\n-    set tests [lsort [glob -nocomplain $srcdir/$subdir/*.C]]\n+    set tests [lsort [find $srcdir/$subdir *.C]]\n \n     if { $blddir != \"\" } {\n         set ld_library_path \"$always_ld_library_path:${blddir}/${lang_library_path}\""}, {"sha": "4298e23421772dced138a5236028865e3c66f397", "filename": "libgomp/testsuite/libgomp.c++/examples-4/e.51.5.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fe.51.5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fe.51.5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fe.51.5.C?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,62 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+\n+#define EPS 0.000001\n+#define N 1000\n+\n+extern \"C\" void abort (void);\n+\n+void init (float *a1, float *a2, int n)\n+{\n+  int s = -1;\n+  for (int i = 0; i < n; i++)\n+    {\n+      a1[i] = s * 0.01;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check (float *a, float *b, int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    if (a[i] - b[i] > EPS || b[i] - a[i] > EPS)\n+      abort ();\n+}\n+\n+void vec_mult_ref (float *&p, float *&v1, float *&v2, int n)\n+{\n+  for (int i = 0; i < n; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (float *&p, float *&v1, float *&v2, int n)\n+{\n+  #pragma omp target map(to: v1[0:n], v2[:n]) map(from: p[0:n])\n+    #pragma omp parallel for\n+      for (int i = 0; i < n; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+int main ()\n+{\n+  float *p = new float [N];\n+  float *p1 = new float [N];\n+  float *v1 = new float [N];\n+  float *v2 = new float [N];\n+\n+  init (v1, v2, N);\n+\n+  vec_mult_ref (p, v1, v2, N);\n+  vec_mult (p1, v1, v2, N);\n+\n+  check (p, p1, N);\n+\n+  delete [] p;\n+  delete [] p1;\n+  delete [] v1;\n+  delete [] v2;\n+\n+  return 0;\n+}"}, {"sha": "75276e7c5c63dfeb3d7bc7a032836d2045727e97", "filename": "libgomp/testsuite/libgomp.c++/examples-4/e.53.2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fe.53.2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fe.53.2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fexamples-4%2Fe.53.2.C?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do run }\n+// { dg-require-effective-target offload_device }\n+\n+#include <stdlib.h>\n+\n+struct typeX\n+{\n+  int a;\n+};\n+\n+class typeY\n+{\n+public:\n+  int foo () { return a^0x01; }\n+  int a;\n+};\n+\n+#pragma omp declare target\n+struct typeX varX;\n+class typeY varY;\n+#pragma omp end declare target\n+\n+int main ()\n+{\n+  varX.a = 0;\n+  varY.a = 0;\n+\n+  #pragma omp target\n+    {\n+      varX.a = 100;\n+      varY.a = 100;\n+    }\n+\n+  if (varX.a != 0 || varY.a != 0)\n+    abort ();\n+\n+  #pragma omp target update from(varX, varY)\n+\n+  if (varX.a != 100 || varY.a != 100)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "45adbe00f3c6c99a275e44c3721603950249de2f", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.50.1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.1.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define N 100000\n+\n+void init (int *a1, int *a2)\n+{\n+  int i, s = -1;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check (int *a, int *b)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void vec_mult_ref (int *p)\n+{\n+  int i;\n+  int v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (int *p)\n+{\n+  int i;\n+  int v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  #pragma omp target map(p[0:N])\n+    #pragma omp parallel for\n+      for (i = 0; i < N; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+int main ()\n+{\n+  int p1[N], p2[N];\n+  int v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  vec_mult_ref (p1);\n+  vec_mult (p2);\n+\n+  check (p1, p2);\n+\n+  return 0;\n+}"}, {"sha": "55d667aa77591994f1d05517cd1c44a49e180373", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.50.2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.2.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define N 100000\n+\n+void init (char *a1, char *a2)\n+{\n+  char s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check (char *a, char *b)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void vec_mult_ref (char *p)\n+{\n+  int i;\n+  char v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (char *p)\n+{\n+  int i;\n+  char v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  #pragma omp target map(from: p[0:N])\n+    #pragma omp parallel for\n+      for (i = 0; i < N; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+int main ()\n+{\n+  char p1[N], p2[N];\n+  char v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  vec_mult_ref (p1);\n+  vec_mult (p2);\n+\n+  check (p1, p2);\n+\n+  return 0;\n+}"}, {"sha": "8d5125f07eed4c1c76aea97f369abeacbdcbdabb", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.50.3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.3.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define N 100000\n+\n+void init (long long *a1, long long *a2)\n+{\n+  long long s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check (long long *a, long long *b)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void vec_mult_ref (long long *p)\n+{\n+  int i;\n+  long long v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (long long *p)\n+{\n+  int i;\n+  long long v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  #pragma omp target map(v1, v2, p[0:N])\n+    #pragma omp parallel for\n+      for (i = 0; i < N; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+int main ()\n+{\n+  long long p1[N], p2[N];\n+  long long v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  vec_mult_ref (p1);\n+  vec_mult (p2);\n+\n+  check (p1, p2);\n+\n+  return 0;\n+}"}, {"sha": "545f02ae9e4af85c329de4131493349ba1868275", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.50.4.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.4.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.000001\n+#define N 100000\n+\n+void init (double *a1, double *a2)\n+{\n+  double s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check (double *a, double *b)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] - b[i] > EPS || b[i] - a[i] > EPS)\n+      abort ();\n+}\n+\n+void vec_mult_ref (double *p, double *v1, double *v2)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (double *p, double *v1, double *v2)\n+{\n+  int i;\n+  #pragma omp target map(to: v1[0:N], v2[:N]) map(from: p[0:N])\n+    #pragma omp parallel for\n+      for (i = 0; i < N; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+int main ()\n+{\n+  double p1[N], p2[N];\n+  double v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  vec_mult_ref (p1, v1, v2);\n+  vec_mult (p2, v1, v2);\n+\n+  check (p1, p2);\n+\n+  return 0;\n+}"}, {"sha": "1853fba684b48611601b64c625ede1a21bad682b", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.50.5.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.50.5.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+#define EPS 0.000001\n+#define N 100000\n+#define THRESHOLD1 10000\n+#define THRESHOLD2 1000\n+\n+void init (float *a1, float *a2)\n+{\n+  float s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check (float *a, float *b)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] - b[i] > EPS || b[i] - a[i] > EPS)\n+      abort ();\n+}\n+\n+void vec_mult_ref (float *p, float *v1, float *v2)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (float *p, float *v1, float *v2)\n+{\n+  int i;\n+  #pragma omp target if(N > THRESHOLD1) map(to: v1[0:N], v2[:N]) \\\n+\t\t     map(from: p[0:N])\n+    {\n+      if (omp_is_initial_device ())\n+\tabort ();\n+\n+      #pragma omp parallel for if(N > THRESHOLD2)\n+\tfor (i = 0; i < N; i++)\n+\t  p[i] = v1[i] * v2[i];\n+    }\n+}\n+\n+int main ()\n+{\n+  float p1[N], p2[N];\n+  float v1[N], v2[N];\n+\n+  init (v1, v2);\n+\n+  vec_mult_ref (p1, v1, v2);\n+  vec_mult (p2, v1, v2);\n+\n+  check (p1, p2);\n+\n+  return 0;\n+}"}, {"sha": "6b0331bf04cce488a6d34742ee510e9b02faa348", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.51.1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.1.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+const int MAX = 1800;\n+\n+void check (long long *a, long long *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void init (long long *a1, long long *a2, int N)\n+{\n+  long long s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void vec_mult_ref (long long *p, long long *v1, long long *v2, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (long long *p, long long *v1, long long *v2, int N)\n+{\n+  int i;\n+  #pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p[0:N])\n+    #pragma omp target\n+      #pragma omp parallel for\n+\tfor (i = 0; i < N; i++)\n+\t  p[i] = v1[i] * v2[i];\n+}\n+\n+int main ()\n+{\n+  long long *p1 = (long long *) malloc (MAX * sizeof (long long));\n+  long long *p2 = (long long *) malloc (MAX * sizeof (long long));\n+  long long *v1 = (long long *) malloc (MAX * sizeof (long long));\n+  long long *v2 = (long long *) malloc (MAX * sizeof (long long));\n+\n+  init (v1, v2, MAX);\n+\n+  vec_mult_ref (p1, v1, v2, MAX);\n+  vec_mult (p2, v1, v2, MAX);\n+\n+  check (p1, p2, MAX);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "ee8f150c1a05a5ff4db27d8a80bbd0582d023ed6", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.51.2.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.2.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+const int MAX = 1800;\n+\n+void check (char *a, char *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void init (char *a1, char *a2, int N)\n+{\n+  char s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void init_again (char *a1, char *a2, int N)\n+{\n+  char s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s * 10;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void vec_mult_ref (char *p, char *v1, char *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+\n+  init_again (v1, v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = p[i] + (v1[i] * v2[i]);\n+}\n+\n+void vec_mult (char *p, char *v1, char *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, N);\n+\n+  #pragma omp target data map(from: p[0:N])\n+    {\n+      #pragma omp target map(to: v1[:N], v2[:N])\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = v1[i] * v2[i];\n+\n+      init_again (v1, v2, N);\n+\n+      #pragma omp target map(to: v1[:N], v2[:N])\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = p[i] + (v1[i] * v2[i]);\n+    }\n+}\n+\n+int main ()\n+{\n+  char *p1 = (char *) malloc (MAX * sizeof (char));\n+  char *p2 = (char *) malloc (MAX * sizeof (char));\n+  char *v1 = (char *) malloc (MAX * sizeof (char));\n+  char *v2 = (char *) malloc (MAX * sizeof (char));\n+\n+  vec_mult_ref (p1, v1, v2, MAX);\n+  vec_mult (p2, v1, v2, MAX);\n+\n+  check (p1, p2, MAX);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "abb283801f8ad26e1c1ab7c0c7aed232014ba919", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.51.3.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.3.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+const int ROWS = 5;\n+const int COLS = 5;\n+\n+void init (int Q[][COLS], const int rows, const int cols)\n+{\n+  int i, j;\n+  for (i = 0; i < rows; i++)\n+    for (j = 0; j < cols; j++)\n+      Q[i][j] = (i + 1) * 100 + (j + 1);\n+}\n+\n+void check (int a[][COLS], int b[][COLS], const int rows, const int cols)\n+{\n+  int i, j;\n+  for (i = 0; i < rows; i++)\n+    for (j = 0; j < cols; j++)\n+      if (a[i][j] != b[i][j])\n+\tabort ();\n+}\n+\n+void gramSchmidt_ref (int Q[][COLS], const int rows, const int cols)\n+{\n+  int i, k;\n+\n+  for (k = 0; k < cols; k++)\n+    {\n+      int tmp = 0;\n+\n+      for (i = 0; i < rows; i++)\n+\ttmp += (Q[i][k] * Q[i][k]);\n+\n+      for (i = 0; i < rows; i++)\n+\tQ[i][k] *= tmp;\n+    }\n+}\n+\n+void gramSchmidt (int Q[][COLS], const int rows, const int cols)\n+{\n+  int i, k;\n+\n+  #pragma omp target data map(Q[0:rows][0:cols]) map(to:COLS)\n+    for (k = 0; k < cols; k++)\n+      {\n+\tint tmp = 0;\n+\n+\t#pragma omp target\n+\t  #pragma omp parallel for reduction(+:tmp)\n+\t    for (i = 0; i < rows; i++)\n+\t      tmp += (Q[i][k] * Q[i][k]);\n+\n+\t#pragma omp target\n+\t  #pragma omp parallel for\n+\t    for (i = 0; i < rows; i++)\n+\t      Q[i][k] *= tmp;\n+      }\n+}\n+\n+int main ()\n+{\n+  int (*Q1)[COLS] = (int(*)[COLS]) malloc (ROWS * COLS * sizeof (int));\n+  int (*Q2)[COLS] = (int(*)[COLS]) malloc (ROWS * COLS * sizeof (int));\n+\n+  init (Q1, ROWS, COLS);\n+  init (Q2, ROWS, COLS);\n+\n+  gramSchmidt_ref (Q1, ROWS, COLS);\n+  gramSchmidt (Q2, ROWS, COLS);\n+\n+  check (Q1, Q2, ROWS, COLS);\n+\n+  free (Q1);\n+  free (Q2);\n+\n+  return 0;\n+}"}, {"sha": "d2948ae1b54df00c3b4351249c7f813d8c964a4b", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.51.4.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.4.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.000001\n+\n+const int MAX = 1800;\n+\n+void check (double *a, double *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] - b[i] > EPS || b[i] - a[i] > EPS)\n+      abort ();\n+}\n+\n+void init (double *a1, double *a2, int N)\n+{\n+  double s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void vec_mult_ref (double *p1, double *v3, double *v4, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    p1[i] = v3[i] * v4[i];\n+}\n+\n+void foo_ref (double *p0, double *v1, double *v2, int N)\n+{\n+  init (v1, v2, N);\n+  vec_mult_ref (p0, v1, v2, N);\n+}\n+\n+void vec_mult (double *p1, double *v3, double *v4, int N)\n+{\n+  int i;\n+  #pragma omp target map(to: v3[0:N], v4[:N]) map(from: p1[0:N])\n+    #pragma omp parallel for\n+      for (i = 0; i < N; i++)\n+\tp1[i] = v3[i] * v4[i];\n+}\n+\n+void foo (double *p0, double *v1, double *v2, int N)\n+{\n+  init (v1, v2, N);\n+\n+  #pragma omp target data map(to: v1[0:N], v2[:N]) map(from: p0[0:N])\n+    vec_mult (p0, v1, v2, N);\n+}\n+\n+int main ()\n+{\n+  double *p1 = (double *) malloc (MAX * sizeof (double));\n+  double *p2 = (double *) malloc (MAX * sizeof (double));\n+  double *v1 = (double *) malloc (MAX * sizeof (double));\n+  double *v2 = (double *) malloc (MAX * sizeof (double));\n+\n+  foo_ref (p1, v1, v2, MAX);\n+  foo (p2, v1, v2, MAX);\n+\n+  check (p1, p2, MAX);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "affeb490021307e50682e17ec142d890ecaaa5c5", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.51.6.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.6.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <stdlib.h>\n+#include <omp.h>\n+\n+#define EPS 0.000001\n+#define THRESHOLD 1000\n+\n+const int MAX = 1800;\n+\n+void check (float *a, float *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] - b[i] > EPS || b[i] - a[i] > EPS)\n+      abort ();\n+}\n+\n+void init (float *a1, float *a2, int N)\n+{\n+  float s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void init_again (float *a1, float *a2, int N)\n+{\n+  float s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s * 10;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void vec_mult_ref (float *p, float *v1, float *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+\n+  init_again (v1, v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = p[i] + (v1[i] * v2[i]);\n+}\n+\n+void vec_mult (float *p, float *v1, float *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, N);\n+\n+  #pragma omp target data if(N > THRESHOLD) map(from: p[0:N])\n+    {\n+      #pragma omp target if (N > THRESHOLD) map(to: v1[:N], v2[:N])\n+\t{\n+\t  if (omp_is_initial_device ())\n+\t    abort;\n+\n+\t  #pragma omp parallel for\n+\t    for (i = 0; i < N; i++)\n+\t      p[i] = v1[i] * v2[i];\n+\t}\n+\n+      init_again (v1, v2, N);\n+\n+      #pragma omp target if (N > THRESHOLD) map(to: v1[:N], v2[:N])\n+\t{\n+\t  if (omp_is_initial_device ())\n+\t    abort ();\n+\n+\t  #pragma omp parallel for\n+\t    for (i = 0; i < N; i++)\n+\t      p[i] = p[i] + (v1[i] * v2[i]);\n+\t}\n+    }\n+}\n+\n+int main ()\n+{\n+  float *p1 = (float *) malloc (MAX * sizeof (float));\n+  float *p2 = (float *) malloc (MAX * sizeof (float));\n+  float *v1 = (float *) malloc (MAX * sizeof (float));\n+  float *v2 = (float *) malloc (MAX * sizeof (float));\n+\n+  vec_mult_ref (p1, v1, v2, MAX);\n+  vec_mult (p2, v1, v2, MAX);\n+\n+  check (p1, p2, MAX);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "c18d4803cf3057e8b8b90b4463a57d9ac8b214ab", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.51.7.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.51.7.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <stdlib.h>\n+#include <omp.h>\n+\n+#define THRESHOLD 1000\n+\n+const int MAX = 1800;\n+\n+void check (short *a, short *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void init (short *a1, short *a2, int N)\n+{\n+  short s = -1;\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void vec_mult_ref (short *p, short *v1, short *v2, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (short *p, short *v1, short *v2, int N)\n+{\n+  int i;\n+  #pragma omp target data map(from: p[0:N])\n+    #pragma omp target if (N > THRESHOLD) map(to: v1[:N], v2[:N])\n+      {\n+\tif (omp_is_initial_device ())\n+\t  abort ();\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = v1[i] * v2[i];\n+      }\n+}\n+\n+int main ()\n+{\n+  short *p1 = (short *) malloc (MAX * sizeof (short));\n+  short *p2 = (short *) malloc (MAX * sizeof (short));\n+  short *v1 = (short *) malloc (MAX * sizeof (short));\n+  short *v2 = (short *) malloc (MAX * sizeof (short));\n+\n+  init (v1, v2, MAX);\n+\n+  vec_mult_ref (p1, v1, v2, MAX);\n+  vec_mult (p2, v1, v2, MAX);\n+\n+  check (p1, p2, MAX);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "727d475f6c7a9f243d79c1f4391f0dd75723bc1c", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.52.1.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.52.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.52.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.52.1.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+const int MAX = 1800;\n+\n+void check (int *a, int *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void init (int *a1, int *a2, int N)\n+{\n+  int i, s = -1;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void init_again (int *a1, int *a2, int N)\n+{\n+  int i, s = -1;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s * 10;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void vec_mult_ref (int *p, int *v1, int *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, MAX);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+\n+  init_again (v1, v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = p[i] + (v1[i] * v2[i]);\n+}\n+\n+void vec_mult (int *p, int *v1, int *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, MAX);\n+\n+  #pragma omp target data map(to: v1[:N], v2[:N]) map(from: p[0:N])\n+    {\n+      #pragma omp target\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = v1[i] * v2[i];\n+\n+      init_again (v1, v2, N);\n+\n+      #pragma omp target update to(v1[:N], v2[:N])\n+\n+      #pragma omp target\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = p[i] + (v1[i] * v2[i]);\n+    }\n+}\n+\n+int main ()\n+{\n+  int *p1 = (int *) malloc (MAX * sizeof (int));\n+  int *p2 = (int *) malloc (MAX * sizeof (int));\n+  int *v1 = (int *) malloc (MAX * sizeof (int));\n+  int *v2 = (int *) malloc (MAX * sizeof (int));\n+\n+  vec_mult_ref (p1, v1, v2, MAX);\n+  vec_mult (p2, v1, v2, MAX);\n+\n+  check (p1, p2, MAX);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "51262bb24a9f2925747db34af02e72f7b1ee5b2b", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.52.2.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.52.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.52.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.52.2.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+const int MAX = 1800;\n+\n+void check (int *a, int *b, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (a[i] != b[i])\n+      abort ();\n+}\n+\n+void init (int *a1, int *a2, int N)\n+{\n+  int i, s = -1;\n+  for (i = 0; i < N; i++)\n+    {\n+      a1[i] = s;\n+      a2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+int maybe_init_again (int *a, int N)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    a[i] = i;\n+  return 1;\n+}\n+\n+void vec_mult_ref (int *p, int *v1, int *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = v1[i] * v2[i];\n+\n+  maybe_init_again (v1, N);\n+  maybe_init_again (v2, N);\n+\n+  for (i = 0; i < N; i++)\n+    p[i] = p[i] + (v1[i] * v2[i]);\n+}\n+\n+void vec_mult (int *p, int *v1, int *v2, int N)\n+{\n+  int i;\n+\n+  init (v1, v2, N);\n+\n+  #pragma omp target data map(to: v1[:N], v2[:N]) map(from: p[0:N])\n+    {\n+      int changed;\n+\n+      #pragma omp target\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = v1[i] * v2[i];\n+\n+      changed = maybe_init_again (v1, N);\n+      #pragma omp target update if (changed) to(v1[:N])\n+\n+      changed = maybe_init_again (v2, N);\n+      #pragma omp target update if (changed) to(v2[:N])\n+\n+      #pragma omp target\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < N; i++)\n+\t    p[i] = p[i] + (v1[i] * v2[i]);\n+    }\n+}\n+\n+int main ()\n+{\n+  int *p = (int *) malloc (MAX * sizeof (int));\n+  int *p1 = (int *) malloc (MAX * sizeof (int));\n+  int *v1 = (int *) malloc (MAX * sizeof (int));\n+  int *v2 = (int *) malloc (MAX * sizeof (int));\n+\n+  vec_mult_ref (p, v1, v2, MAX);\n+  vec_mult (p1, v1, v2, MAX);\n+\n+  check (p, p1, MAX);\n+\n+  free (p);\n+  free (p1);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "beca85557809e3190bf581637a360af8e0ec71ac", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.53.1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.1.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define THRESHOLD 20\n+\n+#pragma omp declare target\n+int fib (int n)\n+{\n+  if (n <= 0)\n+    return 0;\n+  else if (n == 1)\n+    return 1;\n+  else\n+    return fib (n - 1) + fib (n - 2);\n+}\n+#pragma omp end declare target\n+\n+int fib_wrapper (int n)\n+{\n+  int x = 0;\n+\n+  #pragma omp target if(n > THRESHOLD)\n+    x = fib (n);\n+\n+  return x;\n+}\n+\n+int main ()\n+{\n+  if (fib (15) != fib_wrapper (15))\n+    abort ();\n+  if (fib (25) != fib_wrapper (25))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "8025335722a22e7c78ad54b77c203661f3a8c8d9", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.53.3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.3.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.000001\n+#define N 100000\n+\n+#pragma omp declare target\n+float p1[N], p2[N], v1[N], v2[N];\n+#pragma omp end declare target\n+\n+void init ()\n+{\n+  int i, s = -1;\n+  for (i = 0; i < N; i++)\n+    {\n+      v1[i] = s * 0.01;\n+      v2[i] = i;\n+      s = -s;\n+    }\n+}\n+\n+void check ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    if (p1[i] - p2[i] > EPS || p2[i] - p1[i] > EPS)\n+      abort ();\n+}\n+\n+void vec_mult_ref ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    p1[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult ()\n+{\n+  int i;\n+\n+  #pragma omp target update to(v1, v2)\n+\n+  #pragma omp target\n+    #pragma omp parallel for\n+      for (i = 0; i < N; i++)\n+\tp2[i] = v1[i] * v2[i];\n+\n+  #pragma omp target update from(p2)\n+}\n+\n+int main ()\n+{\n+  init ();\n+\n+  vec_mult_ref ();\n+  vec_mult ();\n+\n+  check ();\n+\n+  return 0;\n+}"}, {"sha": "278e1a4170794c44310b0ef0c3d83714e392d95e", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.53.4.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.4.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.00001\n+#define N 1000\n+\n+#pragma omp declare target\n+float Q[N][N];\n+float Pfun (const int i, const int k)\n+{\n+  return Q[i][k] * Q[k][i];\n+}\n+#pragma omp end declare target\n+\n+void init ()\n+{\n+  int i, j;\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      Q[i][j] = 0.001 * i * j;\n+}\n+\n+float accum_ref (int k)\n+{\n+  int i;\n+  float tmp = 0.0;\n+\n+  for (i = 0; i < N; i++)\n+    tmp += Pfun (i, k);\n+\n+  return tmp;\n+}\n+\n+float accum (int k)\n+{\n+  int i;\n+  float tmp = 0.0;\n+\n+  #pragma omp target\n+    #pragma omp parallel for reduction(+:tmp)\n+      for (i = 0; i < N; i++)\n+\ttmp += Pfun (i, k);\n+\n+  return tmp;\n+}\n+\n+void check (float a, float b)\n+{\n+  float err = (b == 0.0) ? a : (a - b) / b;\n+  if (((err > 0) ? err : -err) > EPS)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  int i;\n+\n+  init ();\n+\n+  #pragma omp target update to(Q)\n+\n+  for (i = 0; i < N; i++)\n+    check (accum (i), accum_ref (i));\n+\n+  return 0;\n+}"}, {"sha": "3bcd753dbbb15ee48954d6de798026a50c714b35", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.53.5.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.53.5.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-msse2\" { target sse2_runtime } } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.00001\n+#define N 10000\n+#define M 1024\n+\n+#pragma omp declare target\n+float Q[N][N];\n+#pragma omp declare simd uniform(i) linear(k) notinbranch\n+float Pfun (const int i, const int k)\n+{\n+  return Q[i][k] * Q[k][i];\n+}\n+#pragma omp end declare target\n+\n+void init ()\n+{\n+  int i, j;\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      Q[i][j] = 0.001 * i * j;\n+}\n+\n+float accum_ref ()\n+{\n+  int i, k;\n+  float tmp = 0.0;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      float tmp1 = 0.0;\n+\n+      for (k = 0; k < M; k++)\n+\ttmp1 += Pfun(i,k);\n+\n+      tmp += tmp1;\n+    }\n+\n+  return tmp;\n+}\n+\n+float accum ()\n+{\n+  int i, k;\n+  float tmp = 0.0;\n+\n+  #pragma omp target\n+    #pragma omp parallel for reduction(+:tmp)\n+      for (i = 0; i < N; i++)\n+\t{\n+\t  float tmp1 = 0.0;\n+\n+\t  #pragma omp simd reduction(+:tmp1)\n+\t    for (k = 0; k < M; k++)\n+\t      tmp1 += Pfun(i,k);\n+\n+\t  tmp += tmp1;\n+\t}\n+\n+  return tmp;\n+}\n+\n+void check (float a, float b)\n+{\n+  float err = (b == 0.0) ? a : (a - b) / b;\n+  if (((err > 0) ? err : -err) > EPS)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  init ();\n+\n+  #pragma omp target update to(Q)\n+\n+  check (accum (), accum_ref ());\n+\n+  return 0;\n+}"}, {"sha": "a4fdca6ed60c88c1932f029306dfe6453f779de7", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.54.2.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.2.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.0001\n+#define N 1024*1024\n+\n+void init (float B[], float C[], int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      B[i] = 0.1 * i;\n+      C[i] = 0.01 * i * i;\n+    }\n+}\n+\n+float dotprod_ref (float B[], float C[], int n)\n+{\n+  int i;\n+  float sum = 0.0;\n+\n+  for (i = 0; i < n; i++)\n+    sum += B[i] * C[i];\n+\n+  return sum;\n+}\n+\n+float dotprod (float B[], float C[], int n, int block_size,\n+\t       int num_teams, int block_threads)\n+{\n+  int i, i0;\n+  float sum = 0;\n+\n+  #pragma omp target map(to: B[0:n], C[0:n])\n+    #pragma omp teams num_teams(num_teams) thread_limit(block_threads) \\\n+\t\t      reduction(+:sum)\n+      #pragma omp distribute\n+\tfor (i0 = 0; i0 < n; i0 += block_size)\n+\t  #pragma omp parallel for reduction(+:sum)\n+\t    for (i = i0; i < ((i0 + block_size > n) ? n : i0 + block_size); i++)\n+\t      sum += B[i] * C[i];\n+\n+  return sum;\n+}\n+\n+void check (float a, float b)\n+{\n+  float err = (b == 0.0) ? a : (a - b) / b;\n+  if (((err > 0) ? err : -err) > EPS)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  float *v1 = (float *) malloc (N * sizeof (float));\n+  float *v2 = (float *) malloc (N * sizeof (float));\n+\n+  float p1, p2;\n+\n+  init (v1, v2, N);\n+\n+  p1 = dotprod_ref (v1, v2, N);\n+  p2 = dotprod (v1, v2, N, 32, 2, 8);\n+\n+  check (p1, p2);\n+\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "b670878588429599200aab631ff362aab7934107", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.54.3.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.3.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.0001\n+#define N 1024*1024\n+\n+void init (float B[], float C[], int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      B[i] = 0.1 * i;\n+      C[i] = 0.01 * i * i;\n+    }\n+}\n+\n+float dotprod_ref (float B[], float C[], int n)\n+{\n+  int i;\n+  float sum = 0.0;\n+\n+  for (i = 0; i < n; i++)\n+    sum += B[i] * C[i];\n+\n+  return sum;\n+}\n+\n+float dotprod (float B[], float C[], int n)\n+{\n+  int i;\n+  float sum = 0;\n+\n+  #pragma omp target teams map(to: B[0:n], C[0:n])\n+    #pragma omp distribute parallel for reduction(+:sum)\n+      for (i = 0; i < n; i++)\n+\tsum += B[i] * C[i];\n+\n+  return sum;\n+}\n+\n+void check (float a, float b)\n+{\n+  float err = (b == 0.0) ? a : (a - b) / b;\n+  if (((err > 0) ? err : -err) > EPS)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  float *v1 = (float *) malloc (N * sizeof (float));\n+  float *v2 = (float *) malloc (N * sizeof (float));\n+\n+  float p1, p2;\n+\n+  init (v1, v2, N);\n+\n+  p1 = dotprod_ref (v1, v2, N);\n+  p2 = dotprod (v1, v2, N);\n+\n+  check (p1, p2);\n+\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "9aef78ecfba45752ff3c7825fccb2fce8331f6dd", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.54.4.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.4.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.0001\n+#define N 1024*1024\n+\n+void init (float B[], float C[], int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      B[i] = 0.1 * i;\n+      C[i] = 0.01 * i * i;\n+    }\n+}\n+\n+float dotprod_ref (float B[], float C[], int n)\n+{\n+  int i;\n+  float sum = 0.0;\n+\n+  for (i = 0; i < n; i++)\n+    sum += B[i] * C[i];\n+\n+  return sum;\n+}\n+\n+float dotprod (float B[], float C[], int n)\n+{\n+  int i;\n+  float sum = 0;\n+\n+  #pragma omp target map(to: B[0:n], C[0:n])\n+    #pragma omp teams num_teams(8) thread_limit(16)\n+      #pragma omp distribute parallel for reduction(+:sum) \\\n+\t\t\t\t\t  dist_schedule(static, 1024) \\\n+\t\t\t\t\t  schedule(static, 64)\n+\tfor (i = 0; i < n; i++)\n+\t  sum += B[i] * C[i];\n+\n+  return sum;\n+}\n+\n+void check (float a, float b)\n+{\n+  float err = (b == 0.0) ? a : (a - b) / b;\n+  if (((err > 0) ? err : -err) > EPS)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  float *v1 = (float *) malloc (N * sizeof (float));\n+  float *v2 = (float *) malloc (N * sizeof (float));\n+\n+  float p1, p2;\n+\n+  init (v1, v2, N);\n+\n+  p1 = dotprod_ref (v1, v2, N);\n+  p2 = dotprod (v1, v2, N);\n+\n+  check (p1, p2);\n+\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "ac99744ebe37c7cc22a7358bc0e61f7383131d8c", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.54.5.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.5.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.00001\n+#define N 10000\n+\n+void init (float *a, float *b, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] = 0.1 * i;\n+      b[i] = 0.01 * i * i;\n+    }\n+}\n+\n+void vec_mult_ref (float *p, float *v1, float *v2, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (float *p, float *v1, float *v2, int n)\n+{\n+  int i;\n+  #pragma omp target teams map(to: v1[0:n], v2[:n]) map(from: p[0:n])\n+    #pragma omp distribute simd\n+      for (i = 0; i < n; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+void check (float *a, float *b, int n)\n+{\n+  int i;\n+  for (i = 0 ; i < n ; i++)\n+    {\n+      float err = (a[i] == 0.0) ? b[i] : (b[i] - a[i]) / a[i];\n+      if (((err > 0) ? err : -err) > EPS)\n+\tabort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  float *p1 = (float *) malloc (N * sizeof (float));\n+  float *p2 = (float *) malloc (N * sizeof (float));\n+  float *v1 = (float *) malloc (N * sizeof (float));\n+  float *v2 = (float *) malloc (N * sizeof (float));\n+\n+  init (v1, v2, N);\n+\n+  vec_mult_ref (p1, v1, v2, N);\n+  vec_mult (p2, v1, v2, N);\n+\n+  check (p1, p2, N);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "388582b51cdc8d2d1d2b6266a541d57d34c535e9", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.54.6.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.54.6.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.00001\n+#define N 10000\n+\n+void init (float *a, float *b, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] = 0.1 * i;\n+      b[i] = 0.01 * i * i;\n+    }\n+}\n+\n+void vec_mult_ref (float *p, float *v1, float *v2, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    p[i] = v1[i] * v2[i];\n+}\n+\n+void vec_mult (float *p, float *v1, float *v2, int n)\n+{\n+  int i;\n+  #pragma omp target teams map(to: v1[0:n], v2[:n]) map(from: p[0:n])\n+    #pragma omp distribute parallel for simd\n+      for (i = 0; i < n; i++)\n+\tp[i] = v1[i] * v2[i];\n+}\n+\n+void check (float *a, float *b, int n)\n+{\n+  int i;\n+  for (i = 0 ; i < n ; i++)\n+    {\n+      float err = (a[i] == 0.0) ? b[i] : (b[i] - a[i]) / a[i];\n+      if (((err > 0) ? err : -err) > EPS)\n+\tabort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  float *p1 = (float *) malloc (N * sizeof (float));\n+  float *p2 = (float *) malloc (N * sizeof (float));\n+  float *v1 = (float *) malloc (N * sizeof (float));\n+  float *v2 = (float *) malloc (N * sizeof (float));\n+\n+  init (v1, v2, N);\n+\n+  vec_mult_ref (p1, v1, v2, N);\n+  vec_mult (p2, v1, v2, N);\n+\n+  check (p1, p2, N);\n+\n+  free (p1);\n+  free (p2);\n+  free (v1);\n+  free (v2);\n+\n+  return 0;\n+}"}, {"sha": "082e78a7ddb022f5782e42ff626dd954be3e0f99", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.55.1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.55.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.55.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.55.1.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+#define EPS 0.00001\n+#define N 100000\n+#define CHUNKSZ 1000\n+\n+float Y[N];\n+float Z[N];\n+\n+#pragma omp declare target\n+float F (float a)\n+{\n+  return -a;\n+}\n+#pragma omp end declare target\n+\n+void pipedF_ref ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    Y[i] = F (Y[i]);\n+}\n+\n+void pipedF ()\n+{\n+  int i, C;\n+  for (C = 0; C < N; C += CHUNKSZ)\n+    {\n+      #pragma omp task\n+\t#pragma omp target map(Z[C:CHUNKSZ])\n+\t  #pragma omp parallel for\n+\t    for (i = C; i < C + CHUNKSZ; i++)\n+\t      Z[i] = F (Z[i]);\n+    }\n+  #pragma omp taskwait\n+}\n+\n+void init ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    Y[i] = Z[i] = 0.1 * i;\n+}\n+\n+void check ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      float err = (Z[i] == 0.0) ? Y[i] : (Y[i] - Z[i]) / Z[i];\n+      if (((err > 0) ? err : -err) > EPS)\n+\tabort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  init ();\n+\n+  pipedF_ref ();\n+  pipedF ();\n+\n+  check ();\n+\n+  return 0;\n+}"}, {"sha": "f03cae372fffaca7818f5c13b341fc1898fa019a", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.55.2.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.55.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.55.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.55.2.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+#define EPS 0.00001\n+#define N 10000\n+\n+#pragma omp declare target\n+void init (float *a, float *b, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] = 0.1 * i;\n+      b[i] = 0.01 * i * i;\n+    }\n+}\n+#pragma omp end declare target\n+\n+void vec_mult_ref (float *p, float *v1, float *v2, int n)\n+{\n+  int i;\n+\n+  v1 = (float *) malloc (n * sizeof (float));\n+  v2 = (float *) malloc (n * sizeof (float));\n+\n+  init (v1, v2, n);\n+\n+  for (i = 0; i < n; i++)\n+    p[i] = v1[i] * v2[i];\n+\n+  free (v1);\n+  free (v2);\n+}\n+\n+void vec_mult (float *p, float *v1, float *v2, int n)\n+{\n+  int i;\n+\n+  #pragma omp task shared(v1, v2) depend(out: v1, v2)\n+    #pragma omp target map(v1, v2)\n+      {\n+\tif (omp_is_initial_device ())\n+\t  abort ();\n+\n+\tv1 = (float *) malloc (n * sizeof (float));\n+\tv2 = (float *) malloc (n * sizeof (float));\n+\n+\tinit (v1, v2, n);\n+      }\n+\n+  #pragma omp task shared(v1, v2) depend(in: v1, v2)\n+    #pragma omp target map(to: v1, v2) map(from: p[0:n])\n+      {\n+\tif (omp_is_initial_device ())\n+\t  abort ();\n+\n+\t#pragma omp parallel for\n+\t  for (i = 0; i < n; i++)\n+\t    p[i] = v1[i] * v2[i];\n+\n+\t  free (v1);\n+\t  free (v2);\n+      }\n+}\n+\n+void check (float *a, float *b, int n)\n+{\n+  int i;\n+  for (i = 0 ; i < n ; i++)\n+    {\n+      float err = (a[i] == 0.0) ? b[i] : (b[i] - a[i]) / a[i];\n+      if (((err > 0) ? err : -err) > EPS)\n+\tabort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  float *p1 = (float *) malloc (N * sizeof (float));\n+  float *p2 = (float *) malloc (N * sizeof (float));\n+  float *v1, *v2;\n+\n+  vec_mult_ref (p1, v1, v2, N);\n+  vec_mult (p2, v1, v2, N);\n+\n+  check (p1, p2, N);\n+\n+  free (p1);\n+  free (p2);\n+\n+  return 0;\n+}"}, {"sha": "4f4649ae24484b6f4f703b10d57ce456293b02bc", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.56.3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.56.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.56.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.56.3.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+void foo ()\n+{\n+  int A[30], *p;\n+  #pragma omp target data map(A[0:4])\n+    {\n+      p = &A[0];\n+      #pragma omp target map(p[7:20]) map(A[0:4])\n+\t{\n+\t  A[2] = 777;\n+\t  p[8] = 777;\n+\t}\n+    }\n+\n+  if (A[2] != 777 || A[8] != 777)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  foo ();\n+  return 0;\n+}"}, {"sha": "66234d76f7b8c39f1c3fadbdc5af5fbe43c9b626", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.56.4.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.56.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.56.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.56.4.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+void foo ()\n+{\n+  int A[30], *p;\n+  #pragma omp target data map(A[0:10])\n+    {\n+      p = &A[0];\n+      #pragma omp target map(p[3:7]) map(A[0:10])\n+\t{\n+\t  A[2] = 777;\n+\t  A[8] = 777;\n+\t  p[8] = 999;\n+\t}\n+    }\n+\n+  if (A[2] != 777 || A[8] != 999)\n+    abort ();\n+}\n+\n+int main ()\n+{\n+  foo ();\n+  return 0;\n+}"}, {"sha": "f7c84fb4c1416fe360ab17c45ee777826a0c8e5a", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.57.1.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.1.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int main ()\n+{\n+  int a = 100;\n+  int b = 0;\n+  int c, d;\n+\n+  #pragma omp target if(a > 200 && a < 400)\n+    c = omp_is_initial_device ();\n+\n+  #pragma omp target data map(to: b) if(a > 200 && a < 400)\n+    #pragma omp target\n+      {\n+\tb = 100;\n+\td = omp_is_initial_device ();\n+      }\n+\n+  if (b != 100 || !c || d)\n+    abort ();\n+\n+  a += 200;\n+  b = 0;\n+\n+  #pragma omp target if(a > 200 && a < 400)\n+    c = omp_is_initial_device ();\n+\n+  #pragma omp target data map(to: b) if(a > 200 && a < 400)\n+    #pragma omp target\n+      {\n+\tb = 100;\n+\td = omp_is_initial_device ();\n+      }\n+\n+  if (b != 0 || c || d)\n+    abort ();\n+\n+  a += 200;\n+  b = 0;\n+\n+  #pragma omp target if(a > 200 && a < 400)\n+    c = omp_is_initial_device ();\n+\n+  #pragma omp target data map(to: b) if(a > 200 && a < 400)\n+    #pragma omp target\n+      {\n+\tb = 100;\n+\td = omp_is_initial_device ();\n+      }\n+\n+  if (b != 100 || !c || d)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "be204bd76f526045834c4fc2e00f2c2b660a5519", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.57.2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.2.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+#define N 10\n+\n+int main ()\n+{\n+  int i;\n+  int offload[N];\n+  int num = omp_get_num_devices();\n+\n+  #pragma omp parallel for\n+    for (i = 0; i < N; i++)\n+      #pragma omp target device(i) map(from: offload[i:1])\n+\toffload[i] = omp_is_initial_device ();\n+\n+  for (i = 0; i < num; i++)\n+    if (offload[i])\n+      abort ();\n+\n+  for (i = num; i < N; i++)\n+    if (!offload[i])\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "8a0cf7c200d20f8022d60c70c7b96e1f2f142505", "filename": "libgomp/testsuite/libgomp.c/examples-4/e.57.3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fexamples-4%2Fe.57.3.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target offload_device } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int main ()\n+{\n+  int res;\n+  int default_device = omp_get_default_device ();\n+\n+  #pragma omp target\n+    res = omp_is_initial_device ();\n+\n+  if (res)\n+    abort ();\n+\n+  omp_set_default_device (omp_get_num_devices ());\n+\n+  #pragma omp target\n+    res = omp_is_initial_device ();\n+\n+  if (!res)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "0fe6150283db5362f8a63d0c2c01cc21703dc063", "filename": "libgomp/testsuite/libgomp.c/target-7.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-7.c?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -18,7 +18,7 @@ foo (int f)\n   if (omp_get_level () != 0 || !omp_is_initial_device ())\n     abort ();\n   #pragma omp target if (v <= 1)\n-  if (omp_get_level () != 0 || (f && !omp_is_initial_device ()))\n+  if (omp_get_level () != 0)\n     abort ();\n   #pragma omp target device (d) if (v <= 1)\n   if (omp_get_level () != 0 || (f && !omp_is_initial_device ()))\n@@ -30,7 +30,7 @@ foo (int f)\n   if (omp_get_level () != 0 || !omp_is_initial_device ())\n     abort ();\n   #pragma omp target if (1)\n-  if (omp_get_level () != 0 || (f && !omp_is_initial_device ()))\n+  if (omp_get_level () != 0)\n     abort ();\n   #pragma omp target device (d) if (1)\n   if (omp_get_level () != 0 || (f && !omp_is_initial_device ()))\n@@ -59,7 +59,7 @@ foo (int f)\n   #pragma omp target data if (v <= 1) map (to: h)\n   {\n     #pragma omp target if (v <= 1)\n-    if (omp_get_level () != 0 || (f && !omp_is_initial_device ()) || h++ != 8)\n+    if (omp_get_level () != 0 || h++ != 8)\n       abort ();\n     #pragma omp target update if (v <= 1) from (h)\n   }\n@@ -87,7 +87,7 @@ foo (int f)\n   #pragma omp target data if (1) map (to: h)\n   {\n     #pragma omp target if (1)\n-    if (omp_get_level () != 0 || (f && !omp_is_initial_device ()) || h++ != 12)\n+    if (omp_get_level () != 0 || h++ != 12)\n       abort ();\n     #pragma omp target update if (1) from (h)\n   }"}, {"sha": "76e9068e30f38ce5b41644b9b0afb6054a3b823b", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.50.1.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.1.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+\n+module e_50_1_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    integer :: i, N\n+    real :: p(N), v1(N), v2(N)\n+    call init (v1, v2, N)\n+    !$omp target\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+    call check (p, N)\n+  end subroutine\n+\n+end module\n+\n+program e_50_1\n+  use e_50_1_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "af469f4d6872f2a9ecdc34c32ba95e701dba5752", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.50.2.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+\n+module e_50_2_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    integer :: i, N\n+    real :: p(N), v1(N), v2(N)\n+    call init (v1, v2, N)\n+    !$omp target map(v1,v2,p)\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+  call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_50_2\n+  use e_50_2_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "975470411cb43535be86d571188aa104efac1572", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.50.3.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.3.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+\n+module e_50_3_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    integer :: i, N\n+    real :: p(N), v1(N), v2(N)\n+    call init (v1, v2, N)\n+    !$omp target map(to: v1,v2) map(from: p)\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_50_3\n+  use e_50_3_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "f94794e16aa67dc423292aa33453185fcc51cbe6", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.50.4.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.4.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+\n+module e_50_4_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real, pointer, dimension(:) :: v1, v2\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real, pointer, dimension(:) :: p\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult_1 (p, v1, v2, N)\n+    integer :: i, N\n+    real, pointer, dimension(:) :: p, v1, v2\n+    !$omp target map(to: v1(1:N), v2(:N)) map(from: p(1:N))\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+  end subroutine\n+\n+  subroutine vec_mult_2 (p, v1, v2, N)\n+    real, dimension(*) :: p, v1, v2\n+    integer :: i, N\n+    !$omp target map(to: v1(1:N), v2(:N)) map(from: p(1:N))\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+  end subroutine\n+end module\n+\n+program e_50_4\n+  use e_50_4_mod, only : init, check, vec_mult_1, vec_mult_2\n+  real, pointer, dimension(:) :: p1, p2, v1, v2\n+  integer :: n\n+  n = 1000\n+  allocate (p1(n), p2(n), v1(n), v2(n))\n+  call init (v1, v2, n)\n+  call vec_mult_1 (p1, v1, v2, n)\n+  call vec_mult_2 (p2, v1, v2, n)\n+  call check (p1, N)\n+  call check (p2, N)\n+  deallocate (p1, p2, v1, v2)\n+end program"}, {"sha": "3f454d7d55e16485f2d966023848ec007b8a71d4", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.50.5.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.50.5.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+module e_50_5_mod\n+integer, parameter :: THRESHOLD1 = 500, THRESHOLD2 = 100\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    use omp_lib, only: omp_is_initial_device\n+    integer :: i, N\n+    real :: p(N), v1(N), v2(N)\n+    call init (v1, v2, N)\n+    !$omp target if(N > THRESHOLD1) map(to: v1,v2) map(from: p)\n+      if (omp_is_initial_device ()) call abort\n+      !$omp parallel do if(N > THRESHOLD2)\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_50_5\n+  use e_50_5_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "98e5c0b8f77752a04676760c9549f89f3bc51dc8", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.1.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.1.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+\n+module e_51_1_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    call init (v1, v2, N)\n+    !$omp target data map(to: v1, v2) map(from: p)\n+      !$omp target\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_51_1\n+  use e_51_1_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "360cdeda7e170c1a49f8952da248257171af583e", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.2.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+\n+module e_51_2_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine init_again (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i - 3.0\n+      v2(i) = i + 2.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - 2 * (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    call init (v1, v2, N)\n+    !$omp target data map(from: p)\n+      !$omp target map(to: v1, v2 )\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+      call init_again (v1, v2, N)\n+      !$omp target map(to: v1, v2 )\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = p(i) + v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_51_2\n+  use e_51_2_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "a3d9c188f93de1efad7d0001fae232723ea40bac", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.3.f90", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.3.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,79 @@\n+! { dg-do run }\n+\n+module e_51_3_mod\n+contains\n+  subroutine init (Q, rows, cols)\n+    integer :: i, k, rows, cols\n+    double precision :: Q(rows,cols)\n+    do k = 1, cols\n+      do i = 1, rows\n+        Q(i,k) = 10 * i + k\n+      end do\n+    end do\n+  end subroutine\n+\n+  subroutine check (P, Q, rows, cols)\n+    integer :: i, k, rows, cols\n+    double precision, parameter :: EPS = 0.00001\n+    double precision :: P(rows,cols), Q(rows,cols), diff\n+    do k = 1, cols\n+      do i = 1, rows\n+        diff = P(i,k) - Q(i,k)\n+        if (diff > EPS .or. -diff > EPS) call abort\n+      end do\n+    end do\n+  end subroutine\n+\n+  subroutine gramSchmidt_ref (Q, rows, cols)\n+    integer :: i, k, rows, cols\n+    double precision :: Q(rows,cols), tmp\n+    do k = 1, cols\n+      tmp = 0.0d0\n+      do i = 1, rows\n+        tmp = tmp + (Q(i,k) * Q(i,k))\n+      end do\n+      tmp = 1.0d0 / sqrt (tmp)\n+      do i = 1, rows\n+        Q(i,k) = Q(i,k) * tmp\n+      end do\n+    end do\n+  end subroutine\n+\n+  subroutine gramSchmidt (Q, rows, cols)\n+    integer :: i, k, rows, cols\n+    double precision :: Q(rows,cols), tmp\n+    !$omp target data map(Q)\n+      do k = 1, cols\n+        tmp = 0.0d0\n+        !$omp target\n+          !$omp parallel do reduction(+:tmp)\n+          do i = 1, rows\n+            tmp = tmp + (Q(i,k) * Q(i,k))\n+          end do\n+        !$omp end target\n+        tmp = 1.0d0 / sqrt (tmp)\n+        !$omp target\n+          !$omp parallel do\n+          do i = 1, rows\n+            Q(i,k) = Q(i,k) * tmp\n+          end do\n+        !$omp end target\n+      end do\n+    !$omp end target data\n+  end subroutine\n+end module\n+\n+program e_51_3\n+  use e_51_3_mod, only : init, check, gramSchmidt, gramSchmidt_ref\n+  integer :: cols, rows\n+  double precision, pointer :: P(:,:), Q(:,:)\n+  cols = 5\n+  rows = 5\n+  allocate (P(rows,cols), Q(rows,cols))\n+  call init (P, rows, cols)\n+  call init (Q, rows, cols)\n+  call gramSchmidt_ref (P, rows, cols)\n+  call gramSchmidt (Q, rows, cols)\n+  call check (P, Q, rows, cols)\n+  deallocate (P, Q)\n+end program"}, {"sha": "e9de6ae0015fba6242fc3e79ff2f3c31cc442e3d", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.4.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.4.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+\n+module e_51_4_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine foo (p, v1, v2, N)\n+    real, pointer, dimension(:) :: p, v1, v2\n+    integer :: N\n+    call init (v1, v2, N)\n+    !$omp target data map(to: v1, v2) map(from: p)\n+      call vec_mult (p, v1, v2, N)\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+\n+  subroutine vec_mult (p, v1, v2, N)\n+    real, pointer, dimension(:) :: p, v1, v2\n+    integer :: i, N\n+    !$omp target map(to: v1, v2) map(from: p)\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+  end subroutine\n+end module\n+\n+program e_51_4\n+  use e_51_4_mod, only : foo\n+  integer :: n\n+  real, pointer, dimension(:) :: p, v1, v2\n+  n = 1000\n+  allocate (p(n), v1(n), v2(n))\n+  call foo (p, v1, v2, n)\n+  deallocate (p, v1, v2)\n+end program"}, {"sha": "01a41adb0f41a2502aadcb7248c5aa7bfbdae75d", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.5.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.5.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+\n+module e_51_5_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine foo (p, v1, v2, N)\n+    real, dimension(:) :: p, v1, v2\n+    integer :: N\n+    call init (v1, v2, N)\n+    !$omp target data map(to: v1, v2, N) map(from: p)\n+      call vec_mult (p, v1, v2, N)\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+\n+  subroutine vec_mult (p, v1, v2, N)\n+    real, dimension(:) :: p, v1, v2\n+    integer :: i, N\n+    !$omp target map(to: v1, v2, N) map(from: p)\n+      !$omp parallel do\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target\n+  end subroutine\n+end module\n+\n+program e_51_5\n+  use e_51_5_mod, only : foo\n+  integer, parameter :: N = 1024\n+  real, allocatable, dimension(:) :: p, v1, v2\n+  allocate(p(N), v1(N), v2(N))\n+  call foo (p, v1, v2, N)\n+  deallocate (p, v1, v2)\n+end program"}, {"sha": "258da21e8f4858cb12bbb6e624190d262c60b52d", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.6.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.6.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+module e_51_6_mod\n+integer, parameter :: THRESHOLD = 500\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine init_again (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i - 3.0\n+      v2(i) = i + 2.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - 2 * (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    use omp_lib, only: omp_is_initial_device\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    call init (v1, v2, N)\n+    !$omp target data if(N > THRESHOLD) map(from: p)\n+      !$omp target if(N > THRESHOLD) map(to: v1, v2)\n+        if (omp_is_initial_device ()) call abort\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+      call init_again (v1, v2, N)\n+      !$omp target if(N > THRESHOLD) map(to: v1, v2)\n+        if (omp_is_initial_device ()) call abort\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = p(i) + v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_51_6\n+  use e_51_6_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "2ddac9e4665e60064f4f2b9efb6e2e3105be2cc4", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.51.7.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.51.7.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+module e_51_7_mod\n+integer, parameter :: THRESHOLD = 500\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (N)\n+    use omp_lib, only: omp_is_initial_device\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    call init (v1, v2, N)\n+    !$omp target data if(N > THRESHOLD) map(to: v1, v2) map(from: p)\n+      !$omp target\n+        if (omp_is_initial_device ()) call abort\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_51_7\n+  use e_51_7_mod, only : vec_mult\n+  integer :: n\n+  n = 1000\n+  call vec_mult (n)\n+end program"}, {"sha": "e23c0bb7bca5e6c6f3d47704fbcc389916fb6f73", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.52.1.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.52.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.52.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.52.1.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+\n+module e_52_1_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine init_again (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i - 3.0\n+      v2(i) = i + 2.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - 2 * (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (p, v1, v2, N)\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    call init (v1, v2, N)\n+    !$omp target data map(to: v1, v2) map(from: p)\n+      !$omp target\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+      call init_again (v1, v2, N)\n+      !$omp target update to(v1, v2)\n+      !$omp target\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = p(i) + v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_52_1\n+  use e_52_1_mod, only : vec_mult\n+  integer :: n\n+  real, pointer :: p(:), v1(:), v2(:)\n+  n = 1000\n+  allocate (p(n), v1(n), v2(n))\n+  call vec_mult (p, v1, v2, n)\n+  deallocate (p, v1, v2)\n+end program"}, {"sha": "3735e5342e465458e95bc43a6cdd36e7433b82d4", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.52.2.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.52.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.52.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.52.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do run }\n+\n+module e_52_2_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine init_again (v1, v2, N)\n+    integer :: i, N\n+    real :: v1(N), v2(N)\n+    do i = 1, N\n+      v1(i) = i - 3.0\n+      v2(i) = i + 2.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real :: diff, p(N)\n+    do i = 1, N\n+      diff = p(i) - (i * i + (i + 2.0) * (i - 3.0))\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  logical function maybe_init_again (v, N)\n+    real :: v(N)\n+    integer :: i, N\n+    do i = 1, N\n+      v(i) = i\n+    end do\n+    maybe_init_again = .true.\n+  end function\n+\n+  subroutine vec_mult (p, v1, v2, N)\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    logical :: changed\n+    call init (v1, v2, N)\n+    !$omp target data map(to: v1, v2) map(from: p)\n+      !$omp target\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+      changed = maybe_init_again (v1, N)\n+      !$omp target update if(changed) to(v1(:N))\n+      changed = maybe_init_again (v2, N)\n+      !$omp target update if(changed) to(v2(:N))\n+      !$omp target\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = p(i) + v1(i) * v2(i)\n+        end do\n+      !$omp end target\n+    !$omp end target data\n+    call check (p, N)\n+  end subroutine\n+end module\n+\n+program e_52_2\n+  use e_52_2_mod, only : vec_mult\n+  integer :: n\n+  real, pointer :: p(:), v1(:), v2(:)\n+  n = 1000\n+  allocate (p(n), v1(n), v2(n))\n+  call vec_mult (p, v1, v2, n)\n+  deallocate (p, v1, v2)\n+end program"}, {"sha": "a1885afa1b5e1074d86a4e40048fd7f08e03b783", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.53.1.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.1.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+\n+module e_53_1_mod\n+  integer :: THRESHOLD = 20\n+contains\n+  integer recursive function fib (n) result (f)\n+    !$omp declare target\n+    integer :: n\n+    if (n <= 0) then\n+      f = 0\n+    else if (n == 1) then\n+      f = 1\n+    else\n+      f = fib (n - 1) + fib (n - 2)\n+    end if\n+  end function\n+\n+  integer function fib_wrapper (n)\n+    integer :: x\n+    !$omp target map(to: n) if(n > THRESHOLD)\n+      x = fib (n)\n+    !$omp end target\n+    fib_wrapper = x\n+  end function\n+end module\n+\n+program e_53_1\n+  use e_53_1_mod, only : fib, fib_wrapper\n+  if (fib (15) /= fib_wrapper (15)) call abort\n+  if (fib (25) /= fib_wrapper (25)) call abort\n+end program"}, {"sha": "5bc900cac80f03f9e4af73e50a6c86656d0e8c42", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.53.2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+\n+program e_53_2\n+  !$omp declare target (fib)\n+  integer :: x, fib\n+  !$omp target\n+    x = fib (25)\n+  !$omp end target\n+  if (x /= fib (25)) call abort\n+end program\n+\n+integer recursive function fib (n) result (f)\n+  !$omp declare target\n+  integer :: n\n+  if (n <= 0) then\n+    f = 0\n+  else if (n == 1) then\n+    f = 1\n+  else\n+    f = fib (n - 1) + fib (n - 2)\n+  end if\n+end function"}, {"sha": "fffbb7ff17b179db33f1a97d11b5db58486058a7", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.53.3.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.3.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+\n+module e_53_3_mod\n+  !$omp declare target (N, p, v1, v2)\n+  integer, parameter :: N = 1000\n+  real :: p(N), v1(N), v2(N)\n+end module\n+\n+subroutine init (v1, v2, N)\n+  integer :: i, N\n+  real :: v1(N), v2(N)\n+  do i = 1, N\n+    v1(i) = i + 2.0\n+    v2(i) = i - 3.0\n+  end do\n+end subroutine\n+\n+subroutine check (p, N)\n+  integer :: i, N\n+  real, parameter :: EPS = 0.00001\n+  real :: diff, p(N)\n+  do i = 1, N\n+    diff = p(i) - (i + 2.0) * (i - 3.0)\n+    if (diff > EPS .or. -diff > EPS) call abort\n+  end do\n+end subroutine\n+\n+subroutine vec_mult ()\n+  use e_53_3_mod\n+  integer :: i\n+  call init (v1, v2, N);\n+  !$omp target update to(v1, v2)\n+  !$omp target\n+    !$omp parallel do\n+    do i = 1,N\n+      p(i) = v1(i) * v2(i)\n+    end do\n+  !$omp end target\n+  !$omp target update from (p)\n+  call check (p, N)\n+end subroutine\n+\n+program e_53_3\n+  call vec_mult ()\n+end program"}, {"sha": "41d251aae37b7e4ec40c0534109c72cd6d6df81a", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.53.4.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.4.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do run }\n+\n+module e_53_4_mod\n+  !$omp declare target (N, Q)\n+  integer, parameter :: N = 10\n+  real :: Q(N,N)\n+contains\n+  real function Pfun (i, k)\n+    !$omp declare target\n+    integer, intent(in) :: i, k\n+    Pfun = (Q(i,k) * Q(k,i))\n+  end function\n+end module\n+\n+real function accum (k) result (tmp)\n+  use e_53_4_mod\n+  integer :: i, k\n+  tmp = 0.0e0\n+  !$omp target\n+    !$omp parallel do reduction(+:tmp)\n+    do i = 1, N\n+      tmp = tmp + Pfun (k, i)\n+    end do\n+  !$omp end target\n+end function\n+\n+real function accum_ref (k) result (tmp)\n+  use e_53_4_mod\n+  integer :: i, k\n+  tmp = 0.0e0\n+  do i = 1, N\n+    tmp = tmp + Pfun (k, i)\n+  end do\n+end function\n+\n+subroutine init ()\n+  use e_53_4_mod\n+  integer :: i, j\n+  do i = 1, N\n+    do j = 1, N\n+      Q(i,j) = 0.001 * i * j\n+    end do\n+  end do\n+end subroutine\n+\n+subroutine check (a, b)\n+  real :: a, b, err\n+  real, parameter :: EPS = 0.00001\n+  if (b == 0.0) then\n+    err = a\n+  else if (a == 0.0) then\n+    err = b\n+  else\n+    err = (a - b) / b\n+  end if\n+  if (err > EPS .or. err < -EPS) call abort\n+end subroutine\n+\n+program e_53_4\n+  use e_53_4_mod\n+  integer :: i\n+  real :: accum, accum_ref\n+  call init ()\n+  !$omp target update to(Q)\n+  do i = 1, N\n+    call check (accum (i), accum_ref (i))\n+  end do\n+end program"}, {"sha": "304c9fb2ada1a82fbf4128439e416022bfa0138f", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.53.5.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.53.5.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+module e_53_5_mod\n+  !$omp declare target (N, Q)\n+  integer, parameter :: N = 10000, M = 1024\n+  real :: Q(N,N)\n+contains\n+  real function Pfun (k, i)\n+    !$omp declare simd(Pfun) uniform(i) linear(k) notinbranch\n+    !$omp declare target\n+    integer, value, intent(in) :: i, k\n+    Pfun = (Q(k,i) * Q(i,k))\n+  end function\n+end module\n+\n+real function accum () result (tmp)\n+  use e_53_5_mod\n+  real :: tmp1\n+  integer :: i\n+  tmp = 0.0e0\n+  !$omp target\n+    !$omp parallel do private(tmp1) reduction(+:tmp)\n+    do i = 1, N\n+      tmp1 = 0.0e0\n+      !$omp simd reduction(+:tmp1)\n+      do k = 1, M\n+        tmp1 = tmp1 + Pfun (k, i)\n+      end do\n+      tmp = tmp + tmp1\n+    end do\n+  !$omp end target\n+end function\n+\n+real function accum_ref () result (tmp)\n+  use e_53_5_mod\n+  real :: tmp1\n+  integer :: i\n+  tmp = 0.0e0\n+  do i = 1, N\n+    tmp1 = 0.0e0\n+    do k = 1, M\n+      tmp1 = tmp1 + Pfun (k, i)\n+    end do\n+    tmp = tmp + tmp1\n+  end do\n+end function\n+\n+subroutine init ()\n+  use e_53_5_mod\n+  integer :: i, j\n+  do i = 1, N\n+    do j = 1, N\n+      Q(i,j) = 0.001 * i * j\n+    end do\n+  end do\n+end subroutine\n+\n+subroutine check (a, b)\n+  real :: a, b, err\n+  real, parameter :: EPS = 0.00001\n+  if (b == 0.0) then\n+    err = a\n+  else if (a == 0.0) then\n+    err = b\n+  else\n+    err = (a - b) / b\n+  end if\n+  if (err > EPS .or. err < -EPS) call abort\n+end subroutine\n+\n+program e_53_5\n+  use e_53_5_mod\n+  real :: accum, accum_ref, d\n+  call init ()\n+  !$omp target update to(Q)\n+  call check (accum (), accum_ref ())\n+end program"}, {"sha": "7daed69481ee9564a8fc3febfe788669ce991b4b", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.54.2.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+\n+function dotprod_ref (B, C, N) result (sum)\n+  implicit none\n+  real :: B(N), C(N), sum\n+  integer :: N, i\n+  sum = 0.0e0\n+  do i = 1, N\n+    sum = sum + B(i) * C(i)\n+  end do\n+end function\n+\n+function dotprod (B, C, N, block_size, num_teams, block_threads) result (sum)\n+  implicit none\n+  real :: B(N), C(N), sum\n+  integer :: N, block_size, num_teams, block_threads, i, i0\n+  sum = 0.0e0\n+  !$omp target map(to: B, C, block_size, num_teams, block_threads)\n+    !$omp teams num_teams(num_teams) thread_limit(block_threads) &\n+    !$omp& reduction(+:sum)\n+      !$omp distribute\n+      do i0 = 1, N, block_size\n+        !$omp parallel do reduction(+:sum)\n+        do i = i0, min (i0 + block_size - 1, N)\n+          sum = sum + B(i) * C(i)\n+        end do\n+      end do\n+    !$omp end teams\n+  !$omp end target\n+end function\n+\n+subroutine init (B, C, N)\n+  real :: B(N), C(N)\n+  integer :: N, i\n+  do i = 1, N\n+    B(i) = 0.0001 * i\n+    C(i) = 0.000001 * i * i\n+  end do\n+end subroutine\n+\n+subroutine check (a, b)\n+  real :: a, b, err\n+  real, parameter :: EPS = 0.0001\n+  if (b == 0.0) then\n+    err = a\n+  else if (a == 0.0) then\n+    err = b\n+  else\n+    err = (a - b) / b\n+  end if\n+  if (err > EPS .or. err < -EPS) call abort\n+end subroutine\n+\n+program e_54_1\n+  integer :: n\n+  real :: ref, d\n+  real, pointer, dimension(:) :: B, C\n+  n = 1024 * 1024\n+  allocate (B(n), C(n))\n+  call init (B, C, n)\n+  ref = dotprod_ref (B, C, n)\n+  d = dotprod (B, C, n, 32, 2, 8)\n+  call check (ref, d)\n+  deallocate (B, C)\n+end program"}, {"sha": "2588d8bb6842446ece95cf6409c8381762fd4fc0", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.54.3.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.3.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+\n+function dotprod_ref (B, C, N) result (sum)\n+  implicit none\n+  real :: B(N), C(N), sum\n+  integer :: N, i\n+  sum = 0.0e0\n+  do i = 1, N\n+    sum = sum + B(i) * C(i)\n+  end do\n+end function\n+\n+function dotprod (B, C, N) result(sum)\n+  real :: B(N), C(N), sum\n+  integer :: N, i\n+  sum = 0.0e0\n+  !$omp target teams map(to: B, C)\n+    !$omp distribute parallel do reduction(+:sum)\n+    do i = 1, N\n+      sum = sum + B(i) * C(i)\n+    end do\n+  !$omp end target teams\n+end function\n+\n+subroutine init (B, C, N)\n+  real :: B(N), C(N)\n+  integer :: N, i\n+  do i = 1, N\n+    B(i) = 0.0001 * i\n+    C(i) = 0.000001 * i * i\n+  end do\n+end subroutine\n+\n+subroutine check (a, b)\n+  real :: a, b, err\n+  real, parameter :: EPS = 0.0001\n+  if (b == 0.0) then\n+    err = a\n+  else if (a == 0.0) then\n+    err = b\n+  else\n+    err = (a - b) / b\n+  end if\n+  if (err > EPS .or. err < -EPS) call abort\n+end subroutine\n+\n+program e_54_3\n+  integer :: n\n+  real :: ref, d\n+  real, pointer, dimension(:) :: B, C\n+  n = 1024 * 1024\n+  allocate (B(n), C(n))\n+  call init (B, C, n)\n+  ref = dotprod_ref (B, C, n)\n+  d = dotprod (B, C, n)\n+  call check (ref, d)\n+  deallocate (B, C)\n+end program"}, {"sha": "efae3c3cc2067dbe2a4098091066ba1797d7d9a0", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.54.4.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.4.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+\n+function dotprod_ref (B, C, N) result (sum)\n+  implicit none\n+  real :: B(N), C(N), sum\n+  integer :: N, i\n+  sum = 0.0e0\n+  do i = 1, N\n+    sum = sum + B(i) * C(i)\n+  end do\n+end function\n+\n+function dotprod (B, C, n) result(sum)\n+  real :: B(N), C(N), sum\n+  integer :: N, i\n+  sum = 0.0e0\n+  !$omp target map(to: B, C)\n+    !$omp teams num_teams(8) thread_limit(16)\n+      !$omp distribute parallel do reduction(+:sum) &\n+      !$omp& dist_schedule(static, 1024) schedule(static, 64)\n+      do i = 1, N\n+        sum = sum + B(i) * C(i)\n+      end do\n+    !$omp end teams\n+  !$omp end target\n+end function\n+\n+subroutine init (B, C, N)\n+  real :: B(N), C(N)\n+  integer :: N, i\n+  do i = 1, N\n+    B(i) = 0.0001 * i\n+    C(i) = 0.000001 * i * i\n+  end do\n+end subroutine\n+\n+subroutine check (a, b)\n+  real :: a, b, err\n+  real, parameter :: EPS = 0.0001\n+  if (b == 0.0) then\n+    err = a\n+  else if (a == 0.0) then\n+    err = b\n+  else\n+    err = (a - b) / b\n+  end if\n+  if (err > EPS .or. err < -EPS) call abort\n+end subroutine\n+\n+program e_54_4\n+  integer :: n\n+  real :: ref, d\n+  real, pointer, dimension(:) :: B, C\n+  n = 1024 * 1024\n+  allocate (B(n), C(n))\n+  call init (B, C, n)\n+  ref = dotprod_ref (B, C, n)\n+  d = dotprod (B, C, n)\n+  call check (ref, d)\n+  deallocate (B, C)\n+end program"}, {"sha": "9608d9a2c4e366245157b4890b69654ee675a420", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.54.5.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.5.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+\n+module e_54_5_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real, pointer, dimension(:) :: v1, v2\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real, pointer, dimension(:) :: p\n+    real :: diff\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (p, v1, v2, N)\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    !$omp target teams map(to: v1, v2) map(from: p)\n+      !$omp distribute simd\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target teams\n+  end subroutine\n+end module\n+\n+program e_54_5\n+  use e_54_5_mod, only : init, check, vec_mult\n+  real, pointer, dimension(:) :: p, v1, v2\n+  integer :: n\n+  n = 1000\n+  allocate (p(n), v1(n), v2(n))\n+  call init (v1, v2, n)\n+  call vec_mult (p, v1, v2, n)\n+  call check (p, N)\n+  deallocate (p, v1, v2)\n+end program"}, {"sha": "f79118816f28e9286f0c905287253a5055d8c4e9", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.54.6.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.54.6.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+\n+module e_54_6_mod\n+contains\n+  subroutine init (v1, v2, N)\n+    integer :: i, N\n+    real, pointer, dimension(:) :: v1, v2\n+    do i = 1, N\n+      v1(i) = i + 2.0\n+      v2(i) = i - 3.0\n+    end do\n+  end subroutine\n+\n+  subroutine check (p, N)\n+    integer :: i, N\n+    real, parameter :: EPS = 0.00001\n+    real, pointer, dimension(:) :: p\n+    real :: diff\n+    do i = 1, N\n+      diff = p(i) - (i + 2.0) * (i - 3.0)\n+      if (diff > EPS .or. -diff > EPS) call abort\n+    end do\n+  end subroutine\n+\n+  subroutine vec_mult (p, v1, v2, N)\n+    real :: p(N), v1(N), v2(N)\n+    integer :: i, N\n+    !$omp target teams map(to: v1, v2) map(from: p)\n+      !$omp distribute parallel do simd\n+      do i = 1, N\n+        p(i) = v1(i) * v2(i)\n+      end do\n+    !$omp end target teams\n+  end subroutine\n+end module\n+\n+program e_54_6\n+  use e_54_6_mod, only : init, check, vec_mult\n+  real, pointer, dimension(:) :: p, v1, v2\n+  integer :: n\n+  n = 1000\n+  allocate (p(n), v1(n), v2(n))\n+  call init (v1, v2, n)\n+  call vec_mult (p, v1, v2, n)\n+  call check (p, N)\n+  deallocate (p, v1, v2)\n+end program"}, {"sha": "0dd00b4ba8c69af1d4d802cedfcb808aad4363e4", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.55.1.f90", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.55.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.55.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.55.1.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+\n+module e_55_1_mod\n+  integer, parameter :: N = 10000000, CHUNKSZ = 100000\n+  real :: Y(N), Z(N)\n+end module\n+\n+subroutine init ()\n+  use e_55_1_mod, only : Y, Z, N\n+  integer :: i\n+  do i = 1, N\n+    Y(i) = 0.1 * i\n+    Z(i) = Y(i)\n+  end do\n+end subroutine\n+\n+subroutine check ()\n+  use e_55_1_mod, only : Y, Z, N\n+  real :: err\n+  real, parameter :: EPS = 0.00001\n+  integer :: i\n+  do i = 1, N\n+    if (Y(i) == 0.0) then\n+      err = Z(i)\n+    else if (Z(i) == 0.0) then\n+      err = Y(i)\n+    else\n+      err = (Y(i) - Z(i)) / Z(i)\n+    end if\n+    if (err > EPS .or. err < -EPS) call abort\n+  end do\n+end subroutine\n+\n+real function F (z)\n+  !$omp declare target\n+  real, intent(in) :: z\n+  F = -z\n+end function\n+\n+subroutine pipedF ()\n+  use e_55_1_mod, only: Z, N, CHUNKSZ\n+  integer :: C, i\n+  real :: F\n+  do C = 1, N, CHUNKSZ\n+    !$omp task\n+      !$omp target map(Z(C:C+CHUNKSZ-1))\n+        !$omp parallel do\n+        do i = C, C+CHUNKSZ-1\n+          Z(i) = F (Z(i))\n+        end do\n+      !$omp end target\n+    !$omp end task\n+  end do\n+end subroutine\n+\n+subroutine pipedF_ref ()\n+  use e_55_1_mod, only: Y, N\n+  integer :: i\n+  real :: F\n+  do i = 1, N\n+    Y(i) = F (Y(i))\n+  end do\n+end subroutine\n+\n+program e_55_1\n+  call init ()\n+  call pipedF ()\n+  call pipedF_ref ()\n+  call check ()\n+end program"}, {"sha": "dfcb5f40ca90b80127843823b90e1de428fb6e61", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.55.2.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.55.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.55.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.55.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+subroutine init (v1, v2, N)\n+  !$omp declare target\n+  integer :: i, N\n+  real :: v1(N), v2(N)\n+  do i = 1, N\n+    v1(i) = i + 2.0\n+    v2(i) = i - 3.0\n+  end do\n+end subroutine\n+\n+subroutine check (p, N)\n+  integer :: i, N\n+  real, parameter :: EPS = 0.00001\n+  real :: diff, p(N)\n+  do i = 1, N\n+    diff = p(i) - (i + 2.0) * (i - 3.0)\n+    if (diff > EPS .or. -diff > EPS) call abort\n+  end do\n+end subroutine\n+\n+subroutine vec_mult (p, N)\n+  use omp_lib, only: omp_is_initial_device\n+  real :: p(N)\n+  real, allocatable :: v1(:), v2(:)\n+  integer :: i\n+  !$omp declare target (init)\n+  !$omp target data map(to: v1, v2, N) map(from: p)\n+    !$omp task shared(v1, v2, p) depend(out: v1, v2)\n+      !$omp target map(to: v1, v2, N)\n+        if (omp_is_initial_device ()) call abort\n+        allocate (v1(N), v2(N))\n+        call init (v1, v2, N)\n+      !$omp end target\n+    !$omp end task\n+    !$omp task shared(v1, v2, p) depend(in: v1, v2)\n+      !$omp target map(to: v1, v2, N) map(from: p)\n+        if (omp_is_initial_device ()) call abort\n+        !$omp parallel do\n+        do i = 1, N\n+          p(i) = v1(i) * v2(i)\n+        end do\n+        deallocate (v1, v2)\n+      !$omp end target\n+    !$omp end task\n+  !$omp end target data\n+  call check (p, N)\n+end subroutine\n+\n+program e_55_2\n+  integer, parameter :: N = 1000\n+  real :: p(N)\n+  call vec_mult (p, N)\n+end program"}, {"sha": "94da51e4fc3437e7420d4494fc9ffa6312232fa0", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.56.3.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.56.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.56.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.56.3.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+\n+  call foo ()\n+contains\n+  subroutine foo ()\n+    integer, target :: A(30)\n+    integer, pointer :: p(:)\n+    !$omp target data map(A(1:4))\n+      p => A\n+      !$omp target map(p(8:27)) map(A(1:4))\n+        A(3) = 777\n+        p(9) = 777\n+      !$omp end target\n+    !$omp end target data\n+    if (A(3) /= 777 .or. A(9) /= 777) call abort\n+  end subroutine\n+end"}, {"sha": "6eb9bc1e5c33a4f57ae704efabeff153507c20b9", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.56.4.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.56.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.56.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.56.4.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+\n+  call foo ()\n+contains\n+  subroutine foo ()\n+    integer, target :: A(30)\n+    integer, pointer :: p(:)\n+    !$omp target data map(A(1:10))\n+      p => A\n+      !$omp target map(p(4:10)) map(A(1:10))\n+        A(3) = 777\n+        p(9) = 777\n+        A(9) = 999\n+      !$omp end target\n+    !$omp end target data\n+    if (A(3) /= 777 .or. A(9) /= 999) call abort\n+  end subroutine\n+end"}, {"sha": "291604bee7a44c9785ca41aabb79d9736c782aac", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.57.1.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.1.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+program e_57_1\n+  use omp_lib, only: omp_is_initial_device\n+  integer :: a, b\n+  logical :: c, d\n+\n+  a = 100\n+  b = 0\n+\n+  !$omp target if(a > 200 .and. a < 400)\n+    c = omp_is_initial_device ()\n+  !$omp end target\n+\n+  !$omp target data map(to: b) if(a > 200 .and. a < 400)\n+    !$omp target\n+      b = 100\n+      d = omp_is_initial_device ()\n+    !$omp end target\n+  !$omp end target data\n+\n+  if (b /= 100 .or. .not. c .or. d) call abort\n+\n+  a = a + 200\n+  b = 0\n+\n+  !$omp target if(a > 200 .and. a < 400)\n+    c = omp_is_initial_device ()\n+  !$omp end target\n+\n+  !$omp target data map(to: b) if(a > 200 .and. a < 400)\n+    !$omp target\n+      b = 100\n+      d = omp_is_initial_device ()\n+    !$omp end target\n+  !$omp end target data\n+\n+  if (b /= 0 .or. c .or. d) call abort\n+\n+  a = a + 200\n+  b = 0\n+\n+  !$omp target if(a > 200 .and. a < 400)\n+    c = omp_is_initial_device ()\n+  !$omp end target\n+\n+  !$omp target data map(to: b) if(a > 200 .and. a < 400)\n+    !$omp target\n+      b = 100\n+      d = omp_is_initial_device ()\n+    !$omp end target\n+  !$omp end target data\n+\n+  if (b /= 100 .or. .not. c .or. d) call abort\n+end program"}, {"sha": "4a304b5c799cfd71f3ad73b11c19e0f6c1d040d0", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.57.2.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.2.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+program e_57_2\n+  use omp_lib, only: omp_is_initial_device, omp_get_num_devices\n+  integer, parameter :: N = 10\n+  integer :: i, num\n+  logical :: offload(N)\n+  num = omp_get_num_devices ()\n+  !$omp parallel do\n+  do i = 1, N\n+    !$omp target device(i-1) map(from: offload(i:i))\n+      offload(i) = omp_is_initial_device ()\n+    !$omp end target\n+  end do\n+\n+  do i = 1, num\n+    if (offload(i)) call abort\n+  end do\n+\n+  do i = num+1, N\n+    if (.not. offload(i)) call abort\n+  end do\n+end program"}, {"sha": "a29f1b59a265db3c7142d23ca41677c17c07d95a", "filename": "libgomp/testsuite/libgomp.fortran/examples-4/e.57.3.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/122d7303a0bdb99ebf4f1a178270295b93d8bed5/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fexamples-4%2Fe.57.3.f90?ref=122d7303a0bdb99ebf4f1a178270295b93d8bed5", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-require-effective-target offload_device }\n+\n+program e_57_3\n+  use omp_lib, only: omp_is_initial_device, omp_get_num_devices,&\n+  omp_get_default_device, omp_set_default_device\n+  logical :: res\n+  integer :: default_device\n+\n+  default_device = omp_get_default_device ()\n+  !$omp target\n+    res = omp_is_initial_device ()\n+  !$omp end target\n+  if (res) call abort\n+\n+  call omp_set_default_device (omp_get_num_devices ())\n+  !$omp target\n+    res = omp_is_initial_device ()\n+  !$omp end target\n+  if (.not. res) call abort\n+end program"}]}