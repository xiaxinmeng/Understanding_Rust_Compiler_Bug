{"sha": "8981d7127bf3caffdb760897def90c8f0e052931", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk4MWQ3MTI3YmYzY2FmZmRiNzYwODk3ZGVmOTBjOGYwZTA1MjkzMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-02-05T23:49:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-02-05T23:49:08Z"}, "message": "re PR tree-optimization/68541 (Path splitting causes if-conversion miss)\n\n\tPR tree-optimization/68541\n\t* gimple-ssa-split-paths.c: Include tree-cfg.h and params.h.\n\t(count_stmts_in_block): New function.\n\t(poor_ifcvt_candidate_code): Likewise.\n\t(is_feasible_trace): Add some heuristics to determine when path\n\tsplitting is profitable.\n\t(find_block_to_duplicate_for_splitting_paths): Make sure the graph\n\tis a diamond with a single exit.\n\n        PR tree-optimization/68541\n\t* gcc.dg/tree-ssa/split-path-2.c: New test.\n\t* gcc.dg/tree-ssa/split-path-3.c: New test.\n\t* gcc.dg/tree-ssa/split-path-4.c: New test.\n\t* gcc.dg/tree-ssa/split-path-5.c: New test.\n\t* gcc.dg/tree-ssa/split-path-6.c: New test.\n\t* gcc.dg/tree-ssa/split-path-7.c: New test.\n\nFrom-SVN: r233191", "tree": {"sha": "5be1fac9c9d036bd4399cd0e8b410fe02c9c7c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5be1fac9c9d036bd4399cd0e8b410fe02c9c7c73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8981d7127bf3caffdb760897def90c8f0e052931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8981d7127bf3caffdb760897def90c8f0e052931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8981d7127bf3caffdb760897def90c8f0e052931", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8981d7127bf3caffdb760897def90c8f0e052931/comments", "author": null, "committer": null, "parents": [{"sha": "46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46cb933227a0c1cd1e8fca1c3c7179c3bee41be3"}], "stats": {"total": 495, "additions": 483, "deletions": 12}, "files": [{"sha": "a465156ac96dddd4f2a8d120cce4d1708e50157d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -1,3 +1,14 @@\n+2016-02-05  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/68541\n+\t* gimple-ssa-split-paths.c: Include tree-cfg.h and params.h.\n+\t(count_stmts_in_block): New function.\n+\t(poor_ifcvt_candidate_code): Likewise.\n+\t(is_feasible_trace): Add some heuristics to determine when path\n+\tsplitting is profitable.\n+\t(find_block_to_duplicate_for_splitting_paths): Make sure the graph\n+\tis a diamond with a single exit.\n+\n 2016-02-05  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/69662"}, {"sha": "ac6de8147df0fe0ef8e822abff0a3e1b4648338a", "filename": "gcc/gimple-ssa-split-paths.c", "status": "modified", "additions": 101, "deletions": 12, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Fgimple-ssa-split-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Fgimple-ssa-split-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-split-paths.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -25,11 +25,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n+#include \"tree-cfg.h\"\n #include \"cfganal.h\"\n #include \"cfgloop.h\"\n #include \"gimple-iterator.h\"\n #include \"tracer.h\"\n #include \"predict.h\"\n+#include \"params.h\"\n \n /* Given LATCH, the latch block in a loop, see if the shape of the\n    path reaching LATCH is suitable for being split by duplication.\n@@ -79,6 +81,11 @@ find_block_to_duplicate_for_splitting_paths (basic_block latch)\n \t      || !find_edge (bb_idom, EDGE_PRED (bb, 1)->src))\n \t    return NULL;\n \n+\t  /* And that the predecessors of BB each have a single successor.  */\n+\t  if (!single_succ_p (EDGE_PRED (bb, 0)->src)\n+\t      || !single_succ_p (EDGE_PRED (bb, 1)->src))\n+\t    return NULL;\n+\n \t  /* So at this point we have a simple diamond for an IF-THEN-ELSE\n \t     construct starting at BB_IDOM, with a join point at BB.  BB\n \t     pass control outside the loop or to the loop latch.\n@@ -91,29 +98,111 @@ find_block_to_duplicate_for_splitting_paths (basic_block latch)\n   return NULL;\n }\n \n+/* Return the number of non-debug statements in a block.  */\n+static unsigned int\n+count_stmts_in_block (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  unsigned int num_stmts = 0;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (!is_gimple_debug (stmt))\n+\tnum_stmts++;\n+    }\n+  return num_stmts;\n+}\n+\n+/* Return TRUE if CODE represents a tree code that is not likely to\n+   be easily if-convertable because it likely expands into multiple\n+   insns, FALSE otherwise.  */\n+static bool\n+poor_ifcvt_candidate_code (enum tree_code code)\n+{\n+  return (code == MIN_EXPR\n+\t  || code == MAX_EXPR\n+\t  || code == ABS_EXPR\n+\t  || code == COND_EXPR\n+\t  || code == CALL_EXPR);\n+}\n+\n /* Return TRUE if BB is a reasonable block to duplicate by examining\n    its size, false otherwise.  BB will always be a loop latch block.\n \n-   Should this use the same tests as we do for jump threading?  */\n+   Things to consider:\n+\n+     We do not want to spoil if-conversion if at all possible.\n+\n+     Most of the benefit seems to be from eliminating the unconditional\n+     jump rather than CSE/DCE opportunities.  So favor duplicating\n+     small latches.  A latch with just a conditional branch is ideal.\n+\n+     CSE/DCE opportunties crop up when statements from the predecessors\n+     feed statements in the latch and allow statements in the latch to\n+     simplify.  */\n \n static bool\n is_feasible_trace (basic_block bb)\n {\n-  int num_stmt = 0;\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  basic_block pred1 = EDGE_PRED (bb, 0)->src;\n+  basic_block pred2 = EDGE_PRED (bb, 1)->src;\n+  int num_stmts_in_join = count_stmts_in_block (bb);\n+  int num_stmts_in_pred1 = count_stmts_in_block (pred1);\n+  int num_stmts_in_pred2 = count_stmts_in_block (pred2);\n+\n+  /* This is meant to catch cases that are likely opportunities for\n+     if-conversion.  Essentially we look for the case where\n+     BB's predecessors are both single statement blocks where\n+     the output of that statement feed the same PHI in BB.  */\n+  if (num_stmts_in_pred1 == 1 && num_stmts_in_pred2 == 1)\n     {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (!is_gimple_debug (stmt))\n-\tnum_stmt++;\n+      gimple *stmt1 = last_and_only_stmt (pred1);\n+      gimple *stmt2 = last_and_only_stmt (pred2);\n+\n+      if (stmt1 && stmt2\n+\t  && gimple_code (stmt1) == GIMPLE_ASSIGN\n+\t  && gimple_code (stmt2) == GIMPLE_ASSIGN)\n+\t{\n+\t  enum tree_code code1 = gimple_assign_rhs_code (stmt1);\n+\t  enum tree_code code2 = gimple_assign_rhs_code (stmt2);\n+\n+\t  if (!poor_ifcvt_candidate_code (code1)\n+\t      && !poor_ifcvt_candidate_code (code2))\n+\t    {\n+\t      tree lhs1 = gimple_assign_lhs (stmt1);\n+\t      tree lhs2 = gimple_assign_lhs (stmt2);\n+\t      gimple_stmt_iterator gsi;\n+\t      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\t{\n+\t\t  gimple *phi = gsi_stmt (gsi);\n+\t\t  if ((gimple_phi_arg_def (phi, 0) == lhs1\n+\t\t       && gimple_phi_arg_def (phi, 1) == lhs2)\n+\t\t      || (gimple_phi_arg_def (phi, 1) == lhs1\n+\t\t\t  && gimple_phi_arg_def (phi, 0) == lhs2))\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Block %d appears to be a join point for \"\n+\t\t\t\t \"if-convertable diamond.\\n\",\n+\t\t\t\t bb->index);\n+\t\t      return false;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n \n-  /* We may want to limit how many statements we copy.  */\n-  if (num_stmt > 1)\n-    return true;\n+  /* We may want something here which looks at dataflow and tries\n+     to guess if duplication of BB is likely to result in simplification\n+     of instructions in BB in either the original or the duplicate.  */\n+\n+  /* Upper Hard limit on the number statements to copy.  */\n+  if (num_stmts_in_join\n+      >= PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS))\n+    return false;\n \n-  return false;\n+  return true;\n }\n \n /* If the immediate dominator of the latch of the loop is"}, {"sha": "388b2b981856c5af3c7ca147d71a53b6e84e9ff6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -1,3 +1,13 @@\n+2016-02-05  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/68541\n+\t* gcc.dg/tree-ssa/split-path-2.c: New test.\n+\t* gcc.dg/tree-ssa/split-path-3.c: New test.\n+\t* gcc.dg/tree-ssa/split-path-4.c: New test.\n+\t* gcc.dg/tree-ssa/split-path-5.c: New test.\n+\t* gcc.dg/tree-ssa/split-path-6.c: New test.\n+\t* gcc.dg/tree-ssa/split-path-7.c: New test.\n+\n 2016-02-05  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/69662"}, {"sha": "aeb926ef0edfaa7117c380cfa3d303117ef280d5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-2.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details \" } */\n+\n+int\n+foo(char *p, int n)\n+{\n+  int s = 0;\n+  int i;\n+\n+  for (i = 0; i < n; i++) {\n+    if (p[i] >= 0)\n+      s++;\n+    else\n+      s--;\n+  }\n+\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump \"appears to be a join point for if-convertable diamond\" \"split-paths\" } } */\n+"}, {"sha": "814504af97f132d7ad43acc640d8257b7345eb3d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-3.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-3.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details -w\" } */\n+\n+typedef struct bitmap_head_def *bitmap;\n+extern void vec_assert_fail (const char *, const char *, const char *file_,\n+\t\t\t     unsigned line_, const char *function_)\n+  __attribute__ ((__noreturn__));\n+typedef struct VEC_int_base\n+{\n+  unsigned num;\n+  unsigned alloc;\n+  int vec[1];\n+}\n+VEC_int_base;\n+static __inline__ int\n+VEC_int_base_space (VEC_int_base * vec_, int alloc_, const char *file_,\n+\t\t    unsigned line_, const char *function_)\n+{\n+  return vec_ ? vec_->alloc - vec_->num >= (unsigned) alloc_ : !alloc_;\n+}\n+\n+static __inline__ int *\n+VEC_int_base_quick_push (VEC_int_base * vec_, int obj_, const char *file_,\n+\t\t\t unsigned line_, const char *function_)\n+{\n+  (void) ((vec_->num <\n+\t   vec_->alloc) ? 0 : (vec_assert_fail (\"push\", \"VEC(int,base)\",\n+\t\t\t\t\t\tfile_, line_, function_), 0));\n+}\n+\n+typedef struct VEC_int_heap\n+{\n+  VEC_int_base base;\n+}\n+VEC_int_heap;\n+static __inline__ int\n+VEC_int_heap_reserve (VEC_int_heap ** vec_, int alloc_, const char *file_,\n+\t\t      unsigned line_, const char *function_)\n+{\n+  int extend =\n+    !VEC_int_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_, file_, line_,\n+\t\t\t function_);\n+  if (extend)\n+    *vec_ =\n+      (VEC_int_heap *) vec_heap_o_reserve (*vec_, alloc_,\n+\t\t\t\t\t   __builtin_offsetof (VEC_int_heap,\n+\t\t\t\t\t\t\t       base.vec),\n+\t\t\t\t\t   sizeof (int));\n+}\n+\n+static __inline__ int *\n+VEC_int_heap_safe_push (VEC_int_heap ** vec_, const int obj_,\n+\t\t\tconst char *file_, unsigned line_,\n+\t\t\tconst char *function_)\n+{\n+  VEC_int_heap_reserve (vec_, 1, file_, line_, function_);\n+  return VEC_int_base_quick_push (((*vec_) ? &(*vec_)->base : 0), obj_, file_,\n+\t\t\t\t  line_, function_);\n+};\n+\n+typedef struct bitmap_head_def\n+{\n+}\n+bitmap_head;\n+typedef struct\n+{\n+}\n+bitmap_iterator;\n+bitmap\n+compute_idf (bitmap_head * dfs)\n+{\n+  bitmap_iterator bi;\n+  unsigned bb_index, i;\n+  VEC_int_heap *work_stack;\n+  bitmap phi_insertion_points;\n+  while ((VEC_int_base_length (((work_stack) ? &(work_stack)->base : 0))) > 0)\n+    {\n+      for (bmp_iter_and_compl_init\n+\t   (&(bi), (&dfs[bb_index]), (phi_insertion_points), (0), &(i));\n+\t   bmp_iter_and_compl (&(bi), &(i)); bmp_iter_next (&(bi), &(i)))\n+\t{\n+\t  (VEC_int_heap_safe_push\n+\t   (&(work_stack), i, \"/home/gcc/virgin-gcc/gcc/cfganal.c\", 1349,\n+\t    __FUNCTION__));\n+\t}\n+    }\n+  (VEC_int_heap_free (&work_stack));\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Duplicating join block\" \"split-paths\" } } */"}, {"sha": "dac931c18d0009a142e5c8a10aecc3a8660afc60", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-4.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details -w\" } */\n+\n+powi_cost (long n)\n+{\n+  unsigned char cache[256];\n+  unsigned long digit;\n+  unsigned long val;\n+  int result;\n+  while (val >= 256)\n+    {\n+      if (val & 1)\n+\t{\n+\t  result += powi_lookup_cost (digit, cache) + 3 + 1;\n+\t}\n+      else\n+\t{\n+\t  val >>= 1;\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Duplicating join block\" 1 \"split-paths\" } } */\n+"}, {"sha": "5044c7301a1c2d3a35c98fdac65113feae51807f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-5.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-5.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details -w\" } */\n+\n+const extern char *__ctype_ptr__;\n+typedef unsigned char uchar;\n+static int patlen;\n+static int skip[(0x7f * 2 + 1) + 1];\n+static uchar *pat = ((void *) 0);\n+void\n+bmhi_init (const char *pattern)\n+{\n+  int i, lastpatchar;\n+  patlen = strlen (pattern);\n+  for (i = 0; i < patlen; i++)\n+    pat[i] = (\n+\t       {\n+\t       __typeof__ (pattern[i]) __x = (pattern[i]);\n+\t       ((((__ctype_ptr__ +\n+\t\t   sizeof (\"\"[__x]))[(int) (__x)]) & (01 | 02))\n+\t\t== 02) ? (int) __x - 'a' + 'A' : (int) __x;\n+\t       });\n+  for (i = 0; i < patlen - 1; ++i)\n+    {\n+      skip[(\n+\t     {\n+\t     __typeof__ (pat[i]) __x = (pat[i]);\n+\t     ((((__ctype_ptr__ +\n+\t\t sizeof (\"\"[__x]))[(int) (__x)]) & (01 | 02)) ==\n+\t      01) ? (int) __x - 'A' + 'a' : (int) __x;\n+\t     })] = patlen - i - 1;\n+    }\n+  skip[(\n+\t {\n+\t __typeof__ (lastpatchar) __x = (lastpatchar);\n+\t ((((__ctype_ptr__ +\n+\t     sizeof (\"\"[__x]))[(int) (__x)]) & (01 | 02)) ==\n+\t  01) ? (int) __x - 'A' + 'a' : (int) __x;\n+\t })] = 32767;\n+  for (i = 0; i < patlen - 1; ++i)\n+    {\n+    }\n+}\n+\n+char *\n+bmhi_search (const char *string, const int stringlen)\n+{\n+  int i, j;\n+  char *s;\n+  for (;;)\n+    {\n+      while (--j >= 0 && (\n+\t\t\t   {\n+\t\t\t   __typeof__ (s[j]) __x = (s[j]);\n+\t\t\t   ((((__ctype_ptr__ +\n+\t\t\t       sizeof (\"\"[__x]))[(int) (__x)]) &\n+\t\t\t     (01 | 02)) ==\n+\t\t\t    02) ? (int) __x - 'a' +\n+\t\t\t   'A' : (int) __x;}) == pat[j]);\n+}}\n+/* { dg-final { scan-tree-dump-times \"Duplicating join block\" 2 \"split-paths\" } } */"}, {"sha": "682166f195cb94c3fb00e20f02af54331c78dd5d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-6.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-6.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details -w\" } */\n+\n+struct __sFILE\n+{\n+  unsigned char *_p;\n+  int _r;\n+};\n+typedef struct __sFILE __FILE;\n+struct _reent\n+{\n+  __FILE *_stdin, *_stdout, *_stderr;\n+};\n+extern struct _reent *_impure_ptr;\n+extern char contextbufs[10][1024];\n+extern int contextoffset;\n+extern int sflag;\n+void\n+givehelp (interactive)\n+     int interactive;\n+{\n+  if (interactive)\n+    {\n+      while ((--((_impure_ptr->_stdin))->_r <\n+\t      0 ? __srget_r (_impure_ptr,\n+\t\t\t     (_impure_ptr->\n+\t\t\t      _stdin)) : (int) (*((_impure_ptr->_stdin))->\n+\t\t\t\t\t\t_p++)) != ' ');\n+    }\n+}\n+\n+oof ()\n+{\n+  int bufsize;\n+  int hadnl;\n+  while (1)\n+    {\n+      if (bufsize == (sizeof contextbufs[0]) / 2 - 1)\n+\t{\n+\t  if (contextbufs[0][0] == '*' || contextbufs[0][0] == '@')\n+\t    treeinsert (ichartosstr (strtosichar (contextbufs[0] + 1, 0), 1),\n+\t\t\t(100 + 4 * 20 + 4), contextbufs[0][0] == '*');\n+\t}\n+      if (hadnl)\n+\tcontextoffset = 0;\n+      else\n+\tcontextoffset += bufsize;\n+      if (sflag)\n+\t{\n+\t  stop ();\n+\t}\n+    }\n+}\n+\n+void\n+lookharder (string)\n+     char *string;\n+{\n+  register char *g;\n+  register char *s;\n+  for (s = string; *s != '\\0'; s++)\n+    {\n+      if (*s == '*')\n+\t{\n+\t  *g++ = '.';\n+\t}\n+      else\n+\t*g++ = *s;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Duplicating join block\" 3 \"split-paths\" } } */"}, {"sha": "f14ab7929bdeeeeb0c82b722ef44727e5262363c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-7.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8981d7127bf3caffdb760897def90c8f0e052931/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-7.c?ref=8981d7127bf3caffdb760897def90c8f0e052931", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsplit-paths -fdump-tree-split-paths-details -w\" } */\n+\n+\n+struct _reent\n+{\n+};\n+typedef unsigned char ichar_t;\n+struct dent\n+{\n+  char *word;\n+};\n+struct flagent\n+{\n+  ichar_t *strip;\n+  ichar_t *affix;\n+  short stripl;\n+  short affl;\n+};\n+union ptr_union\n+{\n+  struct flagptr *fp;\n+  struct flagent *ent;\n+};\n+struct flagptr\n+{\n+  union ptr_union pu;\n+  int numents;\n+};\n+struct hashheader\n+{\n+};\n+extern struct dent *hashtbl;\n+extern char *hashstrings;\n+extern int hashsize;\n+extern int nodictflag;\n+extern int numsflags;\n+extern int numpflags;\n+extern struct flagent *pflaglist;\n+extern struct flagent *sflaglist;\n+int\n+linit ()\n+{\n+  register int i;\n+  register struct dent *dp;\n+  struct flagent *entry;\n+  struct flagptr *ind;\n+  int viazero;\n+  register ichar_t *cp;\n+  if (!nodictflag)\n+    {\n+      for (i = hashsize, dp = hashtbl; --i >= 0; dp++)\n+\t{\n+\t  if (dp->word == (char *) -1)\n+\t    dp->word = ((void *) 0);\n+\t  else\n+\t    dp->word = &hashstrings[(int) (dp->word)];\n+\t}\n+    }\n+  for (i = numsflags + numpflags, entry = sflaglist; --i >= 0; entry++)\n+    {\n+      if (entry->stripl)\n+\tentry->strip = (ichar_t *) & hashstrings[(int) entry->strip];\n+      else\n+\tentry->affix = ((void *) 0);\n+    }\n+  for (i = numsflags, entry = sflaglist; i > 0; i--, entry++)\n+    {\n+      if (entry->affl == 0)\n+\t{\n+\t  if (ind->pu.fp == ((void *) 0))\n+\t    {\n+\t    }\n+\t}\n+    }\n+  for (i = numpflags, entry = pflaglist; i > 0; i--, entry++)\n+    {\n+      if (entry->affl == 0)\n+\t{\n+\t  while (ind->numents == 0 && ind->pu.fp != ((void *) 0))\n+\t    {\n+\t      if (*cp == 0)\n+\t\t{\n+\t\t}\n+\t    }\n+\t}\n+      if (!viazero && ind->numents >= 4\n+\t  && strcmp ((char *) (entry->affix),\n+\t\t     (char *) (ind->pu.ent->affix)) != 0)\n+\t{\n+\t}\n+    }\n+}\n+/* { dg-final { scan-tree-dump-times \"Duplicating join block\" 2 \"split-paths\" } } */"}]}