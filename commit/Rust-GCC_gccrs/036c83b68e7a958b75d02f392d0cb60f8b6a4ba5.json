{"sha": "036c83b68e7a958b75d02f392d0cb60f8b6a4ba5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2YzgzYjY4ZTdhOTU4Yjc1ZDAyZjM5MmQwY2I2MGY4YjZhNGJhNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T08:15:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T08:15:12Z"}, "message": "Fix missing back-annotation for derived types\n\nGigi fails to back-annotate the Present_Expr field of variants present\nin a type derived from a discriminated untagged record type, which is\nfor example visible in the output -gnatRj.\n\ngcc/ada/ChangeLog\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Tidy up.\n\t(build_variant_list): Add GNAT_VARIANT_PART parameter and annotate\n\tits variants if it is present.  Adjust the recursive call by passing\n\tthe variant subpart of variants, if any.\n\t(copy_and_substitute_in_layout): Rename GNU_SUBST_LIST to SUBST_LIST\n\tand adjust throughout.  For a type, pass the variant part in the\n\tcall to build_variant_list.", "tree": {"sha": "9eef30c422b0ab26840696223a1adc1197fd4204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9eef30c422b0ab26840696223a1adc1197fd4204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5/comments", "author": null, "committer": null, "parents": [{"sha": "15c55b96a721721e944f8617ae59bdcb273477e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c55b96a721721e944f8617ae59bdcb273477e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c55b96a721721e944f8617ae59bdcb273477e6"}], "stats": {"total": 80, "additions": 53, "deletions": 27}, "files": [{"sha": "769728af854260b41f33bdcf9aa6de2420c67f76", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=036c83b68e7a958b75d02f392d0cb60f8b6a4ba5", "patch": "@@ -1,3 +1,13 @@\n+2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: Tidy up.\n+\t(build_variant_list): Add GNAT_VARIANT_PART parameter and annotate its\n+\tvariants if it is present.  Adjust the recursive call by passing the\n+\tvariant subpart of variants, if any.\n+\t(copy_and_substitute_in_layout): Rename GNU_SUBST_LIST to SUBST_LIST\n+\tand adjust throughout.  For a type, pass the variant part in the\n+\tcall to build_variant_list.\n+\n 2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_component_type): Cap the alignment"}, {"sha": "bd69c3ab3062451a8a6d038ee29169c3bb8e4eef", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/036c83b68e7a958b75d02f392d0cb60f8b6a4ba5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=036c83b68e7a958b75d02f392d0cb60f8b6a4ba5", "patch": "@@ -230,7 +230,7 @@ static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n static vec<subst_pair> build_subst_list (Entity_Id, Entity_Id, bool);\n-static vec<variant_desc> build_variant_list (tree, vec<subst_pair>,\n+static vec<variant_desc> build_variant_list (tree, Node_Id, vec<subst_pair>,\n \t\t\t\t\t     vec<variant_desc>);\n static tree maybe_saturate_size (tree);\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool,\n@@ -2992,15 +2992,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n     /* Record Types and Subtypes\n \n-       The following fields are defined on record types:\n-\n-\t\tHas_Discriminants\tTrue if the record has discriminants\n-\t\tFirst_Discriminant      Points to head of list of discriminants\n-\t\tFirst_Entity\t\tPoints to head of list of fields\n-\t\tIs_Tagged_Type\t\tTrue if the record is tagged\n-\n-       Implementation of Ada records and discriminated records:\n-\n        A record type definition is transformed into the equivalent of a C\n        struct definition.  The fields that are the discriminants which are\n        found in the Full_Type_Declaration node and the elements of the\n@@ -8886,20 +8877,29 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n   return gnu_list;\n }\n \n-/* Scan all fields in QUAL_UNION_TYPE and return a list describing the\n-   variants of QUAL_UNION_TYPE that are still relevant after applying\n-   the substitutions described in SUBST_LIST.  GNU_LIST is a pre-existing\n+/* Scan all fields in {GNU_QUAL_UNION_TYPE,GNAT_VARIANT_PART} and return a list\n+   describing the variants of GNU_QUAL_UNION_TYPE that are still relevant after\n+   applying the substitutions described in SUBST_LIST.  GNU_LIST is an existing\n    list to be prepended to the newly created entries.  */\n \n static vec<variant_desc>\n-build_variant_list (tree qual_union_type, vec<subst_pair> subst_list,\n-\t\t    vec<variant_desc> gnu_list)\n+build_variant_list (tree gnu_qual_union_type, Node_Id gnat_variant_part,\n+\t\t    vec<subst_pair> subst_list, vec<variant_desc> gnu_list)\n {\n+  Node_Id gnat_variant;\n   tree gnu_field;\n \n-  for (gnu_field = TYPE_FIELDS (qual_union_type);\n+  for (gnu_field = TYPE_FIELDS (gnu_qual_union_type),\n+       gnat_variant\n+\t= Present (gnat_variant_part)\n+\t  ? First_Non_Pragma (Variants (gnat_variant_part))\n+\t  : Empty;\n        gnu_field;\n-       gnu_field = DECL_CHAIN (gnu_field))\n+       gnu_field = DECL_CHAIN (gnu_field),\n+       gnat_variant\n+\t= Present (gnat_variant_part)\n+\t  ? Next_Non_Pragma (gnat_variant)\n+\t  : Empty)\n     {\n       tree qual = DECL_QUALIFIER (gnu_field);\n       unsigned int i;\n@@ -8918,11 +8918,21 @@ build_variant_list (tree qual_union_type, vec<subst_pair> subst_list,\n \n \t  gnu_list.safe_push (v);\n \n+\t  /* Annotate the GNAT node if present.  */\n+\t  if (Present (gnat_variant))\n+\t    Set_Present_Expr (gnat_variant, annotate_value (qual));\n+\n \t  /* Recurse on the variant subpart of the variant, if any.  */\n \t  variant_subpart = get_variant_part (variant_type);\n \t  if (variant_subpart)\n-\t    gnu_list = build_variant_list (TREE_TYPE (variant_subpart),\n-\t\t\t\t\t   subst_list, gnu_list);\n+\t    gnu_list\n+\t      = build_variant_list (TREE_TYPE (variant_subpart),\n+\t\t\t\t    Present (gnat_variant)\n+\t\t\t\t    ? Variant_Part\n+\t\t\t\t      (Component_List (gnat_variant))\n+\t\t\t\t    : Empty,\n+\t\t\t\t    subst_list,\n+\t\t\t\t    gnu_list);\n \n \t  /* If the new qualifier is unconditionally true, the subsequent\n \t     variants cannot be accessed.  */\n@@ -9806,7 +9816,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t\t\t       Entity_Id gnat_old_type,\n \t\t\t       tree gnu_new_type,\n \t\t\t       tree gnu_old_type,\n-\t\t\t       vec<subst_pair> gnu_subst_list,\n+\t\t\t       vec<subst_pair> subst_list,\n \t\t\t       bool debug_info_p)\n {\n   const bool is_subtype = (Ekind (gnat_new_type) == E_Record_Subtype);\n@@ -9825,11 +9835,18 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n      build a new qualified union for the variants that are still relevant.  */\n   if (gnu_variant_part)\n     {\n+      const Node_Id gnat_decl = Declaration_Node (gnat_new_type);\n       variant_desc *v;\n       unsigned int i;\n \n-      gnu_variant_list = build_variant_list (TREE_TYPE (gnu_variant_part),\n-\t\t\t\t\t     gnu_subst_list, vNULL);\n+      gnu_variant_list\n+\t= build_variant_list (TREE_TYPE (gnu_variant_part),\n+\t\t\t      is_subtype\n+\t\t\t      ? Empty\n+\t\t\t      : Variant_Part\n+\t\t\t\t(Component_List (Type_Definition (gnat_decl))),\n+\t\t\t      subst_list,\n+\t\t\t      vNULL);\n \n       /* If all the qualifiers are unconditionally true, the innermost variant\n \t is statically selected.  */\n@@ -9855,8 +9872,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t\t\t     IDENTIFIER_POINTER (suffix));\n \t    TYPE_REVERSE_STORAGE_ORDER (new_variant)\n \t      = TYPE_REVERSE_STORAGE_ORDER (gnu_new_type);\n-\t    copy_and_substitute_in_size (new_variant, old_variant,\n-\t\t\t\t\t gnu_subst_list);\n+\t    copy_and_substitute_in_size (new_variant, old_variant, subst_list);\n \t    v->new_type = new_variant;\n \t  }\n     }\n@@ -9967,7 +9983,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \tgnu_field\n \t  = create_field_decl_from (gnu_old_field, gnu_field_type,\n \t\t\t\t    gnu_cont_type, gnu_size,\n-\t\t\t\t    gnu_pos_list, gnu_subst_list);\n+\t\t\t\t    gnu_pos_list, subst_list);\n \tgnu_pos = DECL_FIELD_OFFSET (gnu_field);\n \n \t/* If the context is a variant, put it in the new variant directly.  */\n@@ -10054,13 +10070,13 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n       tree new_variant_part\n \t= create_variant_part_from (gnu_variant_part, gnu_variant_list,\n \t\t\t\t    gnu_new_type, gnu_pos_list,\n-\t\t\t\t    gnu_subst_list, debug_info_p);\n+\t\t\t\t    subst_list, debug_info_p);\n       DECL_CHAIN (new_variant_part) = gnu_field_list;\n       gnu_field_list = new_variant_part;\n     }\n \n   gnu_variant_list.release ();\n-  gnu_subst_list.release ();\n+  subst_list.release ();\n \n   /* If NEW_TYPE is a subtype, it inherits all the attributes from OLD_TYPE.\n      Otherwise sizes and alignment must be computed independently.  */"}]}