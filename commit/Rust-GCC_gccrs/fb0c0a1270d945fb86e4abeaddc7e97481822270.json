{"sha": "fb0c0a1270d945fb86e4abeaddc7e97481822270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwYzBhMTI3MGQ5NDVmYjg2ZTRhYmVhZGRjN2U5NzQ4MTgyMjI3MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-18T23:56:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-18T23:56:34Z"}, "message": "Makefile.in (gcse.o): Now includes ggc.h.\n\n\t* Makefile.in (gcse.o): Now includes ggc.h.\n\t* gcse.c: Include ggc.h.\n\t(want_to_gcse_p): Verify expression can be in SET as valid insn.\n\t(try_replace_reg): Remove warning of uninitialize variable.\n\t(process_insert_insn): Call invalid_insn_p to validate insn.\n\t* recog.c (insn_invalid_p): Now global.\n\tSee if can make valid by adding CLOBBERs of SCRATCH only and do if so.\n\t* recog.h (insn_invalid_p): New declaration.\n\nFrom-SVN: r39857", "tree": {"sha": "e6a5316cb8b24a370d243ef6570ecc30bce2c4ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6a5316cb8b24a370d243ef6570ecc30bce2c4ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb0c0a1270d945fb86e4abeaddc7e97481822270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0c0a1270d945fb86e4abeaddc7e97481822270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0c0a1270d945fb86e4abeaddc7e97481822270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0c0a1270d945fb86e4abeaddc7e97481822270/comments", "author": null, "committer": null, "parents": [{"sha": "d659de97e72b033dfef264bd3f8d6dfdd8212252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d659de97e72b033dfef264bd3f8d6dfdd8212252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d659de97e72b033dfef264bd3f8d6dfdd8212252"}], "stats": {"total": 121, "additions": 98, "deletions": 23}, "files": [{"sha": "d159770e9464dcb9c009d666240b01279af630be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb0c0a1270d945fb86e4abeaddc7e97481822270", "patch": "@@ -1,5 +1,14 @@\n Sun Feb 18 15:45:17 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* Makefile.in (gcse.o): Now includes ggc.h.\n+\t* gcse.c: Include ggc.h.\n+\t(want_to_gcse_p): Verify expression can be in SET as valid insn.\n+\t(try_replace_reg): Remove warning of uninitialize variable.\n+\t(process_insert_insn): Call invalid_insn_p to validate insn.\n+\t* recog.c (insn_invalid_p): Now global.\n+\tSee if can make valid by adding CLOBBERs of SCRATCH only and do if so.\n+\t* recog.h (insn_invalid_p): New declaration.\n+\n \t* jump.c (jump_optimize_1): Only define reversed_code #ifdef HAVE_trap.\n \n \t* config/sparc/sparc.c (eligible_for_epilogue_delay): Don't put"}, {"sha": "671107bc912c4fb01d603f89a515a72c9d3cb6d6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fb0c0a1270d945fb86e4abeaddc7e97481822270", "patch": "@@ -1423,7 +1423,7 @@ cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h \\\n    $(BASIC_BLOCK_H) $(GGC_H)\n gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n-   flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n+   flags.h real.h insn-config.h ggc.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n    function.h output.h toplev.h\n sibcall.o : sibcall.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) function.h \\\n    hard-reg-set.h flags.h insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)"}, {"sha": "a5c552c376e60e619e790c17b29b4286988dae14", "filename": "gcc/gcse.c", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=fb0c0a1270d945fb86e4abeaddc7e97481822270", "patch": "@@ -159,6 +159,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"function.h\"\n #include \"expr.h\" \n+#include \"ggc.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc gmalloc\n@@ -1187,13 +1188,17 @@ static int *reg_last_set;\n static int mem_first_set;\n static int mem_last_set;\n \n-/* Perform a quick check whether X, the source of a set, is something\n-   we want to consider for GCSE.  */\n+/* See whether X, the source of a set, is something we want to consider for\n+   GCSE.  */\n \n static int\n want_to_gcse_p (x)\n      rtx x;\n {\n+  static rtx test_insn = 0;\n+  int num_clobbers = 0;\n+  int icode;\n+\n   switch (GET_CODE (x))\n     {\n     case REG:\n@@ -1207,7 +1212,31 @@ want_to_gcse_p (x)\n       break;\n     }\n \n-  return 1;\n+  /* If this is a valid operand, we are OK.  If it's VOIDmode, we aren't.  */\n+  if (general_operand (x, GET_MODE (x)))\n+    return 1;\n+  else if (GET_MODE (x) == VOIDmode)\n+    return 0;\n+\n+  /* Otherwise, check if we can make a valid insn from it.  First initialize\n+     our test insn if we haven't already.  */\n+  if (test_insn == 0)\n+    {\n+      test_insn\n+\t= make_insn_raw (gen_rtx_SET (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (word_mode,\n+\t\t\t\t\t\t   FIRST_PSEUDO_REGISTER * 2),\n+\t\t\t\t      const0_rtx));\n+      NEXT_INSN (test_insn) = PREV_INSN (test_insn) = 0;\n+      ggc_add_rtx_root (&test_insn, 1);\n+    }\n+\n+  /* Now make an insn like the one we would make when GCSE'ing and see if\n+     valid.  */\n+  PUT_MODE (SET_DEST (PATTERN (test_insn)), GET_MODE (x));\n+  SET_SRC (PATTERN (test_insn)) = x;\n+  return ((icode = recog (PATTERN (test_insn), test_insn, &num_clobbers)) >= 0\n+\t  && (num_clobbers == 0 || ! added_clobbers_hard_reg_p (icode)));\n }\n \n /* Return non-zero if the operands of expression X are unchanged from the\n@@ -3612,7 +3641,7 @@ try_replace_reg (from, to, insn)\n      rtx from, to, insn;\n {\n   rtx note = find_reg_equal_equiv_note (insn);\n-  rtx src;\n+  rtx src = 0;\n   int success = 0;\n   rtx set = single_set (insn);\n \n@@ -3640,10 +3669,10 @@ try_replace_reg (from, to, insn)\n   if (!success)\n     success = validate_replace_src (from, to, insn);\n \n-  /* We've failed to do replacement, have a single SET, and don't already\n-     have a note, two to add a REG_EQUAL note to not lose information.  */\n+  /* If we've failed to do replacement, have a single SET, and don't already\n+     have a note, add a REG_EQUAL note to not lose information.  */\n   if (!success && note == 0 && set != 0)\n-    note= REG_NOTES (insn)\n+    note = REG_NOTES (insn)\n       = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n \n   /* If there is already a NOTE, update the expression in it with our\n@@ -4265,13 +4294,22 @@ process_insert_insn (expr)\n      struct expr *expr;\n {\n   rtx reg = expr->reaching_reg;\n-  rtx pat, copied_expr;\n-  rtx first_new_insn;\n+  rtx exp = copy_rtx (expr->expr);\n+  rtx pat;\n \n   start_sequence ();\n-  copied_expr = copy_rtx (expr->expr);\n-  emit_move_insn (reg, copied_expr);\n-  first_new_insn = get_insns ();\n+\n+  /* If the expression is something that's an operand, like a constant,\n+     just copy it to a register.  */\n+  if (general_operand (exp, GET_MODE (reg)))\n+    emit_move_insn (reg, exp);\n+\n+  /* Otherwise, make a new insn to compute this expression and make sure the\n+     insn will be recognized (this also adds any needed CLOBBERs).  Copy the\n+     expression to make sure we don't have any sharing issues.  */\n+  if (insn_invalid_p (emit_insn (gen_rtx_SET (VOIDmode, reg, exp))))\n+    abort ();\n+  \n   pat = gen_sequence ();\n   end_sequence ();\n "}, {"sha": "bf8a3e370879e0b2d95d240f64684a74fc6f3152", "filename": "gcc/recog.c", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=fb0c0a1270d945fb86e4abeaddc7e97481822270", "patch": "@@ -58,7 +58,6 @@ Boston, MA 02111-1307, USA.  */\n static void validate_replace_rtx_1\tPARAMS ((rtx *, rtx, rtx, rtx));\n static rtx *find_single_use_1\t\tPARAMS ((rtx, rtx *));\n static rtx *find_constant_term_loc\tPARAMS ((rtx *));\n-static int insn_invalid_p\t\tPARAMS ((rtx));\n static void validate_replace_src_1 \tPARAMS ((rtx *, void *));\n \n /* Nonzero means allow operands to be volatile.\n@@ -217,7 +216,7 @@ validate_change (object, loc, new, in_group)\n   if (in_group == 0 && num_changes != 0)\n     abort ();\n \n-  *loc = new;\n+   *loc = new;\n \n   /* Save the information describing this change.  */\n   if (num_changes >= changes_allocated)\n@@ -260,18 +259,43 @@ validate_change (object, loc, new, in_group)\n /* This subroutine of apply_change_group verifies whether the changes to INSN\n    were valid; i.e. whether INSN can still be recognized.  */\n \n-static int\n+int\n insn_invalid_p (insn)\n      rtx insn;\n {\n-  int icode = recog_memoized (insn);\n+  rtx pat = PATTERN (insn);\n+  int num_clobbers = 0;\n+  /* If we are before reload and the pattern is a SET, see if we can add\n+     clobbers.  */\n+  int icode = recog (pat, insn,\n+\t\t     (GET_CODE (pat) == SET\n+\t\t      && ! reload_completed && ! reload_in_progress)\n+\t\t     ? &num_clobbers : NULL_PTR);\n   int is_asm = icode < 0 && asm_noperands (PATTERN (insn)) >= 0;\n \n-  if (is_asm && ! check_asm_operands (PATTERN (insn)))\n-    return 1;\n-  if (! is_asm && icode < 0)\n+  \n+  /* If this is an asm and the operand aren't legal, then fail.  Likewise if\n+     this is not an asm and the insn wasn't recognized.  */\n+  if ((is_asm && ! check_asm_operands (PATTERN (insn)))\n+      || (!is_asm && icode < 0))\n     return 1;\n \n+  /* If we have to add CLOBBERs, fail if we have to add ones that reference\n+     hard registers since our callers can't know if they are live or not.\n+     Otherwise, add them.  */\n+  if (num_clobbers > 0)\n+    {\n+      rtx newpat;\n+\n+      if (added_clobbers_hard_reg_p (icode))\n+\treturn 1;\n+\n+      newpat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_clobbers + 1));\n+      XVECEXP (newpat, 0, 0) = pat;\n+      add_clobbers (newpat, icode);\n+      PATTERN (insn) = pat = newpat;\n+    }\n+\n   /* After reload, verify that all constraints are satisfied.  */\n   if (reload_completed)\n     {\n@@ -281,6 +305,7 @@ insn_invalid_p (insn)\n \treturn 1;\n     }\n \n+  INSN_CODE (insn) = icode;\n   return 0;\n }\n \n@@ -744,9 +769,11 @@ validate_replace_rtx_group (from, to, insn)\n \n /* Function called by note_uses to replace used subexpressions.  */\n struct validate_replace_src_data\n-  {\n-    rtx from, to, insn;\n-  };\n+{\n+  rtx from;\t\t\t/* Old RTX */\n+  rtx to;\t\t\t/* New RTX */\n+  rtx insn;\t\t\t/* Insn in which substitution is occurring.  */\n+};\n \n static void\n validate_replace_src_1 (x, data)"}, {"sha": "e15a423d4ddaf3dbc81f75cdc710377e9361eb26", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0c0a1270d945fb86e4abeaddc7e97481822270/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=fb0c0a1270d945fb86e4abeaddc7e97481822270", "patch": "@@ -77,6 +77,7 @@ extern int recog_memoized_1\t\tPARAMS ((rtx));\n extern int check_asm_operands\t\tPARAMS ((rtx));\n extern int asm_operand_ok\t\tPARAMS ((rtx, const char *));\n extern int validate_change\t\tPARAMS ((rtx, rtx *, rtx, int));\n+extern int insn_invalid_p\t\tPARAMS ((rtx));\n extern int apply_change_group\t\tPARAMS ((void));\n extern int num_validated_changes\tPARAMS ((void));\n extern void cancel_changes\t\tPARAMS ((int));"}]}