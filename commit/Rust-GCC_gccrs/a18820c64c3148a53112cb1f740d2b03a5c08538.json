{"sha": "a18820c64c3148a53112cb1f740d2b03a5c08538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4ODIwYzY0YzMxNDhhNTMxMTJjYjFmNzQwZDJiMDNhNWMwODUzOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-07T09:23:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-07T09:23:29Z"}, "message": "gcse.c (gcse_main): Don't rebuild the CFG here.\n\n        * gcse.c (gcse_main): Don't rebuild the CFG here.\n        (delete_null_pointer_checks): Likewise.\n        * ssa.c (convert_to_ssa): Likewise.\n        * toplev.c (rest_of_compilation): Do it here instead.  Combine\n        sequential calls to TIMEVAR.  Consistently use `insns' instead of\n        `get_insns()'.  Always split insns after reload when optimizing.\n\nFrom-SVN: r32995", "tree": {"sha": "11b24e45dc8d9d1e3c4634bb9728e6215d582c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11b24e45dc8d9d1e3c4634bb9728e6215d582c0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a18820c64c3148a53112cb1f740d2b03a5c08538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a18820c64c3148a53112cb1f740d2b03a5c08538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a18820c64c3148a53112cb1f740d2b03a5c08538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a18820c64c3148a53112cb1f740d2b03a5c08538/comments", "author": null, "committer": null, "parents": [{"sha": "dc108b7a752864a4d586d5c30325030b42d6c395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc108b7a752864a4d586d5c30325030b42d6c395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc108b7a752864a4d586d5c30325030b42d6c395"}], "stats": {"total": 216, "additions": 113, "deletions": 103}, "files": [{"sha": "3c39485c2021feb9a41204cb3e49c80e812bbce5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a18820c64c3148a53112cb1f740d2b03a5c08538", "patch": "@@ -1,5 +1,12 @@\n 2000-04-07  Richard Henderson  <rth@cygnus.com>\n \n+\t* gcse.c (gcse_main): Don't rebuild the CFG here.\n+\t(delete_null_pointer_checks): Likewise.\n+\t* ssa.c (convert_to_ssa): Likewise.\n+\t* toplev.c (rest_of_compilation): Do it here instead.  Combine\n+\tsequential calls to TIMEVAR.  Consistently use `insns' instead of\n+\t`get_insns()'.  Always split insns after reload when optimizing.\n+\n \t* basic-block.h (merge_blocks_nomove): Declare.\n \t(tidy_fallthru_edge): Declare.\n \t* flow.c (merge_blocks_nomove): Document as merging into previous"}, {"sha": "996cde95e72c3321f8edab3abaea913cccbfe492", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a18820c64c3148a53112cb1f740d2b03a5c08538", "patch": "@@ -669,18 +669,13 @@ gcse_main (f, file)\n   /* Identify the basic block information for this function, including\n      successors and predecessors.  */\n   max_gcse_regno = max_reg_num ();\n-  find_basic_blocks (f, max_gcse_regno, file);\n-  cleanup_cfg (f);\n \n   if (file)\n     dump_flow_info (file);\n \n   /* Return if there's nothing to do.  */\n   if (n_basic_blocks <= 1)\n-    {\n-      free_basic_block_vars (0);\n-      return 0;\n-    }\n+    return 0;\n \n   /* Trying to perform global optimizations on flow graphs which have\n      a high connectivity will take a long time and is unlikely to be\n@@ -691,10 +686,7 @@ gcse_main (f, file)\n      a couple switch statements.  So we require a relatively large number\n      of basic blocks and the ratio of edges to blocks to be high.  */\n   if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n-    {\n-      free_basic_block_vars (0);\n-      return 0;\n-    }\n+    return 0;\n \n   /* See what modes support reg/reg copy operations.  */\n   if (! can_copy_init_p)\n@@ -807,7 +799,6 @@ gcse_main (f, file)\n \n   obstack_free (&gcse_obstack, NULL_PTR);\n   free_reg_set_mem ();\n-  free_basic_block_vars (0);\n   return run_jump_opt_after_gcse;\n }\n \f\n@@ -5070,17 +5061,9 @@ delete_null_pointer_checks (f)\n   int max_reg;\n   struct null_pointer_info npi;\n \n-  /* First break the program into basic blocks.  */\n-  find_basic_blocks (f, max_reg_num (), NULL);\n-  cleanup_cfg (f);\n-\n   /* If we have only a single block, then there's nothing to do.  */\n   if (n_basic_blocks <= 1)\n-    {\n-      /* Free storage allocated by find_basic_blocks.  */\n-      free_basic_block_vars (0);\n-      return;\n-    }\n+    return;\n \n   /* Trying to perform global optimizations on flow graphs which have\n      a high connectivity will take a long time and is unlikely to be\n@@ -5091,11 +5074,7 @@ delete_null_pointer_checks (f)\n      a couple switch statements.  So we require a relatively large number\n      of basic blocks and the ratio of edges to blocks to be high.  */\n   if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n-    {\n-      /* Free storage allocated by find_basic_blocks.  */\n-      free_basic_block_vars (0);\n-      return;\n-    }\n+    return;\n \n   /* We need four bitmaps, each with a bit for each register in each\n      basic block.  */\n@@ -5152,9 +5131,6 @@ delete_null_pointer_checks (f)\n \t\t\t\t    nonnull_avout, &npi);\n     }\n \n-  /* Free storage allocated by find_basic_blocks.  */\n-  free_basic_block_vars (0);\n-\n   /* Free the table of registers compared at the end of every block.  */\n   free (block_reg);\n "}, {"sha": "af7b6ad6eb1b49b034198361737d0dd4790a7583", "filename": "gcc/ssa.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=a18820c64c3148a53112cb1f740d2b03a5c08538", "patch": "@@ -855,10 +855,6 @@ convert_to_ssa()\n   if (in_ssa_form)\n     abort ();\n \n-  find_basic_blocks (get_insns (), max_reg_num(), NULL);\n-  /* The dominator algorithms assume all blocks are reachable; clean\n-     up first.  */\n-  cleanup_cfg (get_insns ());\n   /* Don't eliminate dead code here.  The CFG we computed above must\n      remain unchanged until we are finished emerging from SSA form --\n      the phi node representation depends on it.  */\n@@ -930,8 +926,6 @@ convert_to_ssa()\n   in_ssa_form = 1;\n \n   reg_scan (get_insns (), max_reg_num (), 1);\n-  find_basic_blocks (get_insns (), max_reg_num (), NULL);\n-  life_analysis (get_insns (), max_reg_num (), NULL, 0);\n }\n \n \n@@ -1818,7 +1812,6 @@ convert_from_ssa()\n   rtx insns = get_insns ();\n     \n   /* We need up-to-date life information.  */\n-  find_basic_blocks (insns, max_reg_num (), NULL);\n   life_analysis (insns, max_reg_num (), NULL, 0);\n \n   /* Figure out which regs in copies and phi nodes don't conflict and"}, {"sha": "00721b31248d2d18519e9c6c43b0054200e9a8b6", "filename": "gcc/toplev.c", "status": "modified", "additions": 102, "deletions": 68, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a18820c64c3148a53112cb1f740d2b03a5c08538/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a18820c64c3148a53112cb1f740d2b03a5c08538", "patch": "@@ -2861,7 +2861,7 @@ rest_of_compilation (decl)\n \t      int saved_optimize = optimize;\n \t      optimize = 0;\n \t      find_exception_handler_labels ();\n-\t      jump_optimize (get_insns(), !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t      jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n \t\t\t     !JUMP_AFTER_REGSCAN);\n \t      optimize = saved_optimize;\n \t    }\n@@ -2907,9 +2907,7 @@ rest_of_compilation (decl)\n \n   /* Don't return yet if -Wreturn-type; we need to do jump_optimize.  */\n   if ((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n-    {\n-      goto exit_rest_of_compilation;\n-    }\n+    goto exit_rest_of_compilation;\n \n   /* Emit code to get eh context, if needed. */\n   emit_eh_context ();\n@@ -2935,7 +2933,6 @@ rest_of_compilation (decl)\n   insns = get_insns ();\n \n   /* Copy any shared structure that should not be shared.  */\n-\n   unshare_all_rtl (current_function_decl, insns);\n \n #ifdef SETJMP_VIA_SAVE_AREA\n@@ -2945,13 +2942,7 @@ rest_of_compilation (decl)\n #endif\n \n   /* Instantiate all virtual registers.  */\n-\n-  instantiate_virtual_regs (current_function_decl, get_insns ());\n-\n-  /* See if we have allocated stack slots that are not directly addressable.\n-     If so, scan all the insns and create explicit address computation\n-     for all references to such slots.  */\n-  /* fixup_stack_slots (); */\n+  instantiate_virtual_regs (current_function_decl, insns);\n \n   /* Find all the EH handlers.  */\n   find_exception_handler_labels ();\n@@ -2961,26 +2952,39 @@ rest_of_compilation (decl)\n   /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n      are initialized and to compute whether control can drop off the end\n      of the function.  */\n-  TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n-  TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n-\t\t\t\t     JUMP_AFTER_REGSCAN));\n-\n-  /* Jump optimization, and the removal of NULL pointer checks, may\n-     have reduced the number of instructions substantially.  CSE, and\n-     future passes, allocate arrays whose dimensions involve the maximum\n-     instruction UID, so if we can reduce the maximum UID we'll save big on\n-     memory.  */\n-  renumber_insns (rtl_dump_file);\n-\n-  close_dump_file (DFI_jump, print_rtl, insns);\n+  TIMEVAR (jump_time,\n+\t   {\n+\t     reg_scan (insns, max_reg_num (), 0);\n+\t     jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n+\t\t\t    JUMP_AFTER_REGSCAN);\n+\t   });\n \n   /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n   if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n-    goto exit_rest_of_compilation;\n+    {\n+      close_dump_file (DFI_jump, print_rtl, insns);\n+      goto exit_rest_of_compilation;\n+    }\n+\n+  TIMEVAR (jump_time,\n+\t   {\n+\t     /* Try to identify useless null pointer tests and delete them.  */\n+\t     if (flag_delete_null_pointer_checks)\n+\t       {\n+\t\t find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t\t cleanup_cfg (insns);\n+\t\t delete_null_pointer_checks (insns);\n+\t       }\n \n-  /* Try to identify useless null pointer tests and delete them.  */\n-  if (flag_delete_null_pointer_checks)\n-    TIMEVAR (jump_time, delete_null_pointer_checks (get_insns ()));\n+\t     /* Jump optimization, and the removal of NULL pointer checks,\n+\t\tmay have reduced the number of instructions substantially. \n+\t\tCSE, and future passes, allocate arrays whose dimensions\n+\t\tinvolve the maximum instruction UID, so if we can reduce\n+\t\tthe maximum UID we'll save big on memory.  */\n+\t     renumber_insns (rtl_dump_file);\n+\t   });\n+\n+  close_dump_file (DFI_jump, print_rtl, insns);\n \n   if (ggc_p)\n     ggc_collect ();\n@@ -3001,6 +3005,7 @@ rest_of_compilation (decl)\n \n       TIMEVAR (cse_time, tem = cse_main (insns, max_reg_num (),\n \t\t\t\t\t 0, rtl_dump_file));\n+\n       /* If we are not running the second CSE pass, then we are no longer\n \t expecting CSE to be run.  */\n       cse_not_expected = !flag_rerun_cse_after_loop;\n@@ -3016,7 +3021,12 @@ rest_of_compilation (decl)\n \n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks)\n-\tTIMEVAR (jump_time, delete_null_pointer_checks (get_insns ()));\n+\tTIMEVAR (jump_time,\n+\t\t {\n+\t\t   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t\t   cleanup_cfg (insns);\n+\t\t   delete_null_pointer_checks (insns);\n+\t\t });\n \n       /* The second pass of jump optimization is likely to have\n          removed a bunch more instructions.  */\n@@ -3035,21 +3045,35 @@ rest_of_compilation (decl)\n   if (ggc_p)\n     ggc_collect ();\n \n-  if (flag_ssa)\n+  if (optimize > 0 && flag_ssa)\n     {\n       open_dump_file (DFI_ssa, decl);\n-      TIMEVAR (to_ssa_time, convert_to_ssa ());\n+\n+      TIMEVAR (to_ssa_time,\n+\t       {\n+\t\t find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n+\t\t cleanup_cfg (insns);\n+\t\t convert_to_ssa ();\n+\t       });\n+\n       close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n \n       open_dump_file (DFI_ussa, decl);\n-      TIMEVAR (from_ssa_time, convert_from_ssa ());\n-      /* New registers have been created.  Rescan their usage.  */\n-      reg_scan (insns, max_reg_num (), 1);\n-      close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n \n-      /* Life analysis used in SSA adds log_links but these shouldn't\n-\t be there until the flow stage, so clear them away.  */\n-      clear_log_links (insns);\n+      TIMEVAR (from_ssa_time,\n+\t       {\n+\t\t convert_from_ssa ();\n+\n+\t\t /* New registers have been created.  Rescan their usage.  */\n+\t\t reg_scan (insns, max_reg_num (), 1);\n+\n+\t\t /* Life analysis used in SSA adds log_links but these\n+\t\t    shouldn't be there until the flow stage, so clear\n+\t\t    them away.  */\n+\t\t clear_log_links (insns);\n+\t       });\n+\n+      close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n \n       if (ggc_p)\n \tggc_collect ();\n@@ -3061,7 +3085,12 @@ rest_of_compilation (decl)\n     {\n       open_dump_file (DFI_gcse, decl);\n \n-      TIMEVAR (gcse_time, tem = gcse_main (insns, rtl_dump_file));\n+      TIMEVAR (gcse_time,\n+\t       {\n+\t\t find_basic_blocks (insns, max_reg_num(), rtl_dump_file);\n+\t\t cleanup_cfg (insns);\n+\t\t tem = gcse_main (insns, rtl_dump_file);\n+\t       });\n \n       /* If gcse altered any jumps, rerun jump optimizations to clean\n \t things up.  */\n@@ -3077,6 +3106,7 @@ rest_of_compilation (decl)\n       if (ggc_p)\n \tggc_collect ();\n     }\n+\n   /* Move constant computations out of loops.  */\n \n   if (optimize > 0)\n@@ -3091,8 +3121,7 @@ rest_of_compilation (decl)\n \t       /* We only want to perform unrolling once.  */\n \t       \n \t       loop_optimize (insns, rtl_dump_file, 0, 0);\n-\t       \n-\t\n+\n \t       /* The first call to loop_optimize makes some instructions\n \t\t  trivially dead.  We delete those instructions now in the\n \t\t  hope that doing so will make the heuristics in loop work\n@@ -3128,14 +3157,20 @@ rest_of_compilation (decl)\n \t     the second CSE pass to do a better job.  Jump_optimize can change\n \t     max_reg_num so we must rerun reg_scan afterwards.\n \t     ??? Rework to not call reg_scan so often.  */\n-\t  TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n-\t  TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t\t\t     !JUMP_NOOP_MOVES,\n-\t\t\t\t\t     JUMP_AFTER_REGSCAN));\n+\t  TIMEVAR (jump_time,\n+\t\t   {\n+\t\t     reg_scan (insns, max_reg_num (), 0);\n+\t\t     jump_optimize (insns, !JUMP_CROSS_JUMP,\n+\t\t\t\t    !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+\t\t   });\n \t  \n-\t  TIMEVAR (cse2_time, reg_scan (insns, max_reg_num (), 0));\n-\t  TIMEVAR (cse2_time, tem = cse_main (insns, max_reg_num (),\n-\t\t\t\t\t      1, rtl_dump_file));\n+\t  TIMEVAR (cse2_time,\n+\t\t   {\n+\t\t     reg_scan (insns, max_reg_num (), 0);\n+\t\t     tem = cse_main (insns, max_reg_num (),\n+\t\t\t\t     1, rtl_dump_file);\n+\t\t   });\n+\n \t  if (tem)\n \t    TIMEVAR (jump_time, jump_optimize (insns, !JUMP_CROSS_JUMP,\n \t\t\t\t\t       !JUMP_NOOP_MOVES,\n@@ -3146,8 +3181,11 @@ rest_of_compilation (decl)\n \t{\n \t  /* This pass of jump threading straightens out code\n \t     that was kinked by loop optimization.  */\n-\t  TIMEVAR (jump_time, reg_scan (insns, max_reg_num (), 0));\n-\t  TIMEVAR (jump_time, thread_jumps (insns, max_reg_num (), 0));\n+\t  TIMEVAR (jump_time,\n+\t\t   {\n+\t\t     reg_scan (insns, max_reg_num (), 0);\n+\t\t     thread_jumps (insns, max_reg_num (), 0);\n+\t\t   });\n \t}\n \n       close_dump_file (DFI_cse2, print_rtl, insns);\n@@ -3160,11 +3198,10 @@ rest_of_compilation (decl)\n     {\n       open_dump_file (DFI_bp, decl);\n \n-      TIMEVAR\n-\t(branch_prob_time,\n-\t {\n-\t   branch_prob (insns, rtl_dump_file);\n-\t });\n+      TIMEVAR (branch_prob_time,\n+\t       {\n+\t\t branch_prob (insns, rtl_dump_file);\n+\t       });\n \n       close_dump_file (DFI_bp, print_rtl, insns);\n \n@@ -3301,8 +3338,11 @@ rest_of_compilation (decl)\n \n   if (dump_file[DFI_lreg].enabled)\n     {\n-      TIMEVAR (dump_time, dump_flow_info (rtl_dump_file));\n-      TIMEVAR (dump_time, dump_local_alloc (rtl_dump_file));\n+      TIMEVAR (dump_time,\n+\t       {\n+\t\t dump_flow_info (rtl_dump_file);\n+\t\t dump_local_alloc (rtl_dump_file);\n+\t       });\n \n       close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n     }\n@@ -3336,13 +3376,9 @@ rest_of_compilation (decl)\n   if (optimize > 0)\n     reload_cse_regs (insns);\n \n-  /* If optimizing and we are performing instruction scheduling after\n-     reload, then go ahead and split insns now since we are about to\n-     recompute flow information anyway.\n-\n-     reload_cse_regs may expose more splitting opportunities, expecially\n-     for double-word operations.  */\n-  if (optimize > 0 && flag_schedule_insns_after_reload)\n+  /* If optimizing, then go ahead and split insns now since we are about\n+     to recompute flow information anyway.  */\n+  if (optimize > 0)\n     split_all_insns (0);\n \n   /* Register allocation and reloading may have turned an indirect jump into\n@@ -3362,6 +3398,7 @@ rest_of_compilation (decl)\n   \n   TIMEVAR (flow2_time,\n \t   {\n+\t     jump_optimize_minimal (insns);\n \t     find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t   });\n \n@@ -3498,10 +3535,7 @@ rest_of_compilation (decl)\n \n      Note this must run before reg-stack because of death note (ab)use\n      in the ia32 backend.  */\n-  TIMEVAR (shorten_branch_time,\n-\t   {\n-\t     shorten_branches (get_insns ());\n-\t   });\n+  TIMEVAR (shorten_branch_time, shorten_branches (get_insns ()));\n \n #ifdef STACK_REGS\n   open_dump_file (DFI_stack, decl);"}]}