{"sha": "f46d33637c71165622aa4c55008798cbd91a8696", "node_id": "C_kwDOANBUbNoAKGY0NmQzMzYzN2M3MTE2NTYyMmFhNGM1NTAwODc5OGNiZDkxYTg2OTY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T07:04:20Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T16:55:14Z"}, "message": "path solver: Add relation support.\n\nThis patch adds relational support to the path solver.  It uses a\npath_oracle that keeps track of relations within a path which are\naugmented by relations on entry to the path.  With it, range_of_stmt,\nrange_of_expr, and friends can give relation aware answers.\n\ngcc/ChangeLog:\n\n\t* gimple-range-fold.h (class fur_source): Make oracle protected.\n\t* gimple-range-path.cc (path_range_query::path_range_query): Add\n\tresolve argument.  Initialize oracle.\n\t(path_range_query::~path_range_query): Delete oracle.\n\t(path_range_query::range_of_stmt): Adapt to use relations.\n\t(path_range_query::precompute_ranges): Pre-compute relations.\n\t(class jt_fur_source): New\n\t(jt_fur_source::jt_fur_source): New.\n\t(jt_fur_source::register_relation): New.\n\t(jt_fur_source::query_relation): New.\n\t(path_range_query::precompute_relations): New.\n\t(path_range_query::precompute_phi_relations): New.\n\t* gimple-range-path.h (path_range_query): Add resolve argument.\n\tAdd oracle, precompute_relations, precompute_phi_relations.\n\t* tree-ssa-threadbackward.c (back_threader::back_threader): Pass\n\tresolve argument to solver.", "tree": {"sha": "b623530c77549d9c837cfa8bfaf267019e2dc570", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b623530c77549d9c837cfa8bfaf267019e2dc570"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f46d33637c71165622aa4c55008798cbd91a8696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46d33637c71165622aa4c55008798cbd91a8696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46d33637c71165622aa4c55008798cbd91a8696", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46d33637c71165622aa4c55008798cbd91a8696/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "198bc5ece960557044483b1c72417759b4630f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198bc5ece960557044483b1c72417759b4630f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198bc5ece960557044483b1c72417759b4630f04"}], "stats": {"total": 223, "additions": 200, "deletions": 23}, "files": [{"sha": "bc0874b5f311af39cefce40fe40f6da0990e3008", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=f46d33637c71165622aa4c55008798cbd91a8696", "patch": "@@ -160,7 +160,7 @@ class fur_depend : public fur_stmt\n \t\t\t\t  tree op2) OVERRIDE;\n   virtual void register_relation (edge e, relation_kind k, tree op1,\n \t\t\t\t  tree op2) OVERRIDE;\n-private:\n+protected:\n   relation_oracle *m_oracle;\n };\n "}, {"sha": "b3040c9bc00367ce507bc723ebc44089626ae5c4", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 187, "deletions": 17, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=f46d33637c71165622aa4c55008798cbd91a8696", "patch": "@@ -30,11 +30,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"gimple-range-path.h\"\n #include \"ssa.h\"\n+#include \"tree-cfg.h\"\n+#include \"gimple-iterator.h\"\n \n // Internal construct to help facilitate debugging of solver.\n #define DEBUG_SOLVER (0 && dump_file)\n \n-path_range_query::path_range_query (gimple_ranger &ranger)\n+path_range_query::path_range_query (gimple_ranger &ranger, bool resolve)\n   : m_ranger (ranger)\n {\n   if (DEBUG_SOLVER)\n@@ -43,12 +45,15 @@ path_range_query::path_range_query (gimple_ranger &ranger)\n   m_cache = new ssa_global_cache;\n   m_has_cache_entry = BITMAP_ALLOC (NULL);\n   m_path = NULL;\n+  m_resolve = resolve;\n+  m_oracle = new path_oracle (ranger.oracle ());\n }\n \n path_range_query::~path_range_query ()\n {\n   BITMAP_FREE (m_has_cache_entry);\n   delete m_cache;\n+  delete m_oracle;\n }\n \n // Mark cache entry for NAME as unused.\n@@ -161,22 +166,6 @@ path_range_query::unreachable_path_p ()\n   return m_undefined_path;\n }\n \n-// Return the range of STMT at the end of the path being analyzed.\n-\n-bool\n-path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n-{\n-  tree type = gimple_range_type (stmt);\n-\n-  if (!irange::supports_type_p (type))\n-    return false;\n-\n-  if (!fold_range (r, stmt, this))\n-    r.set_varying (type);\n-\n-  return true;\n-}\n-\n // Initialize the current path to PATH.  The current block is set to\n // the entry block to the path.\n //\n@@ -371,6 +360,12 @@ path_range_query::precompute_ranges (const vec<basic_block> &path,\n   m_imports = imports;\n   m_undefined_path = false;\n \n+  if (m_resolve)\n+    {\n+      m_oracle->reset_path ();\n+      precompute_relations (path);\n+    }\n+\n   if (DEBUG_SOLVER)\n     {\n       fprintf (dump_file, \"\\npath_range_query: precompute_ranges for path: \");\n@@ -400,3 +395,178 @@ path_range_query::precompute_ranges (const vec<basic_block> &path,\n   if (DEBUG_SOLVER)\n     dump (dump_file);\n }\n+\n+// A folding aid used to register and query relations along a path.\n+// When queried, it returns relations as they would appear on exit to\n+// the path.\n+//\n+// Relations are registered on entry so the path_oracle knows which\n+// block to query the root oracle at when a relation lies outside the\n+// path.  However, when queried we return the relation on exit to the\n+// path, since the root_oracle ignores the registered.\n+\n+class jt_fur_source : public fur_depend\n+{\n+public:\n+  jt_fur_source (gimple *s, path_range_query *, gori_compute *,\n+\t\t const vec<basic_block> &);\n+  relation_kind query_relation (tree op1, tree op2) override;\n+  void register_relation (gimple *, relation_kind, tree op1, tree op2) override;\n+  void register_relation (edge, relation_kind, tree op1, tree op2) override;\n+private:\n+  basic_block m_entry;\n+};\n+\n+jt_fur_source::jt_fur_source (gimple *s,\n+\t\t\t      path_range_query *query,\n+\t\t\t      gori_compute *gori,\n+\t\t\t      const vec<basic_block> &path)\n+  : fur_depend (s, gori, query)\n+{\n+  gcc_checking_assert (!path.is_empty ());\n+\n+  m_entry = path[path.length () - 1];\n+\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    m_oracle = query->oracle ();\n+  else\n+    m_oracle = NULL;\n+}\n+\n+// Ignore statement and register relation on entry to path.\n+\n+void\n+jt_fur_source::register_relation (gimple *, relation_kind k, tree op1, tree op2)\n+{\n+  if (m_oracle)\n+    m_oracle->register_relation (m_entry, k, op1, op2);\n+}\n+\n+// Ignore edge and register relation on entry to path.\n+\n+void\n+jt_fur_source::register_relation (edge, relation_kind k, tree op1, tree op2)\n+{\n+  if (m_oracle)\n+    m_oracle->register_relation (m_entry, k, op1, op2);\n+}\n+\n+relation_kind\n+jt_fur_source::query_relation (tree op1, tree op2)\n+{\n+  if (!m_oracle)\n+    return VREL_NONE;\n+\n+  if (TREE_CODE (op1) != SSA_NAME || TREE_CODE (op2) != SSA_NAME)\n+    return VREL_NONE;\n+\n+  return m_oracle->query_relation (m_entry, op1, op2);\n+}\n+\n+// Return the range of STMT at the end of the path being analyzed.\n+\n+bool\n+path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n+{\n+  tree type = gimple_range_type (stmt);\n+\n+  if (!irange::supports_type_p (type))\n+    return false;\n+\n+  // If resolving unknowns, fold the statement as it would have\n+  // appeared at the end of the path.\n+  if (m_resolve)\n+    {\n+      fold_using_range f;\n+      jt_fur_source src (stmt, this, &m_ranger.gori (), *m_path);\n+      if (!f.fold_stmt (r, stmt, src))\n+\tr.set_varying (type);\n+    }\n+  // Otherwise, use the global ranger to fold it as it would appear in\n+  // the original IL.  This is more conservative, but faster.\n+  else if (!fold_range (r, stmt, this))\n+    r.set_varying (type);\n+\n+  return true;\n+}\n+\n+// Precompute relations on a path.  This involves two parts: relations\n+// along the conditionals joining a path, and relations determined by\n+// examining PHIs.\n+\n+void\n+path_range_query::precompute_relations (const vec<basic_block> &path)\n+{\n+  if (!dom_info_available_p (CDI_DOMINATORS))\n+    return;\n+\n+  jt_fur_source src (NULL, this, &m_ranger.gori (), path);\n+  basic_block prev = NULL;\n+  for (unsigned i = path.length (); i > 0; --i)\n+    {\n+      basic_block bb = path[i - 1];\n+      gimple *stmt = last_stmt (bb);\n+\n+      precompute_phi_relations (bb, prev);\n+\n+      // Compute relations in outgoing edges along the path.  Skip the\n+      // final conditional which we don't know yet.\n+      if (i > 1\n+\t  && stmt\n+\t  && gimple_code (stmt) == GIMPLE_COND\n+\t  && irange::supports_type_p (TREE_TYPE (gimple_cond_lhs (stmt))))\n+\t{\n+\t  basic_block next = path[i - 2];\n+\t  int_range<2> r;\n+\t  gcond *cond = as_a<gcond *> (stmt);\n+\n+\t  if (EDGE_SUCC (bb, 0)->dest == next)\n+\t    gcond_edge_range (r, EDGE_SUCC (bb, 0));\n+\t  else if (EDGE_SUCC (bb, 1)->dest == next)\n+\t    gcond_edge_range (r, EDGE_SUCC (bb, 1));\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  edge e0 = EDGE_SUCC (bb, 0);\n+\t  edge e1 = EDGE_SUCC (bb, 1);\n+\t  src.register_outgoing_edges (cond, r, e0, e1);\n+\t}\n+      prev = bb;\n+    }\n+}\n+\n+// Precompute relations for each PHI in BB.  For example:\n+//\n+//   x_5 = PHI<y_9(5),...>\n+//\n+// If the path flows through BB5, we can register that x_5 == y_9.\n+\n+void\n+path_range_query::precompute_phi_relations (basic_block bb, basic_block prev)\n+{\n+  if (prev == NULL)\n+    return;\n+\n+  basic_block entry = entry_bb ();\n+  edge e_in = find_edge (prev, bb);\n+  gcc_checking_assert (e_in);\n+\n+  for (gphi_iterator iter = gsi_start_phis (bb); !gsi_end_p (iter);\n+       gsi_next (&iter))\n+    {\n+      gphi *phi = iter.phi ();\n+      tree result = gimple_phi_result (phi);\n+      unsigned nargs = gimple_phi_num_args (phi);\n+\n+      for (size_t i = 0; i < nargs; ++i)\n+\tif (e_in == gimple_phi_arg_edge (phi, i))\n+\t  {\n+\t    tree arg = gimple_phi_arg_def (phi, i);\n+\n+\t    if (gimple_range_ssa_p (arg))\n+\t      m_oracle->register_relation (entry, EQ_EXPR, arg, result);\n+\n+\t    break;\n+\t  }\n+    }\n+}"}, {"sha": "d12fd7743ca47d7dee48b302b9a17614f401ead6", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=f46d33637c71165622aa4c55008798cbd91a8696", "patch": "@@ -35,13 +35,14 @@ along with GCC; see the file COPYING3.  If not see\n class path_range_query : public range_query\n {\n public:\n-  path_range_query (class gimple_ranger &ranger);\n+  path_range_query (class gimple_ranger &ranger, bool resolve);\n   virtual ~path_range_query ();\n   void precompute_ranges (const vec<basic_block> &path,\n \t\t\t  const bitmap_head *imports);\n   bool range_of_expr (irange &r, tree name, gimple * = NULL) override;\n   bool range_of_stmt (irange &r, gimple *, tree name = NULL) override;\n   bool unreachable_path_p ();\n+  path_oracle *oracle () { return m_oracle; }\n   void dump (FILE *) override;\n   void debug ();\n \n@@ -58,6 +59,8 @@ class path_range_query : public range_query\n   void precompute_ranges_in_block (basic_block bb);\n   void adjust_for_non_null_uses (basic_block bb);\n   void ssa_range_in_phi (irange &r, gphi *phi);\n+  void precompute_relations (const vec<basic_block> &);\n+  void precompute_phi_relations (basic_block bb, basic_block prev);\n \n   // Path navigation.\n   void set_path (const vec<basic_block> &);\n@@ -79,12 +82,16 @@ class path_range_query : public range_query\n   // Path being analyzed.\n   const vec<basic_block> *m_path;\n \n-  // Current path position.\n-  unsigned m_pos;\n-\n   const bitmap_head *m_imports;\n   gimple_ranger &m_ranger;\n   non_null_ref m_non_null;\n+  path_oracle *m_oracle;\n+\n+  // Current path position.\n+  unsigned m_pos;\n+\n+  // Use ranger to resolve anything not known on entry.\n+  bool m_resolve;\n \n   // Set if there were any undefined expressions while pre-calculating path.\n   bool m_undefined_path;"}, {"sha": "95542079faf7660e3ac9cba0d736b5f75e24146c", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f46d33637c71165622aa4c55008798cbd91a8696/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=f46d33637c71165622aa4c55008798cbd91a8696", "patch": "@@ -122,7 +122,7 @@ const edge back_threader::UNREACHABLE_EDGE = (edge) -1;\n back_threader::back_threader (bool speed_p)\n   : m_registry (param_max_fsm_thread_paths),\n     m_profit (speed_p),\n-    m_solver (m_ranger)\n+    m_solver (m_ranger, /*resolve=*/false)\n {\n   m_last_stmt = NULL;\n   m_imports = BITMAP_ALLOC (NULL);"}]}