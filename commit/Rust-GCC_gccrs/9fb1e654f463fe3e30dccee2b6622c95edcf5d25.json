{"sha": "9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiMWU2NTRmNDYzZmUzZTMwZGNjZWUyYjY2MjJjOTVlZGNmNWQyNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:01:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:01:58Z"}, "message": "[multiple changes]\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* treepr.adb (Print_Entity_Info): Do not print empty Elist.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Do not consider calls\n\tto subprograms in other units as possibly inlined.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): For a derived type that has no\n\texplicit delayed aspects but may inherit delayed aspects from its\n\tparent type, analyze aspect at freeze point for proper capture\n\tof an inherited aspect.\n\n2017-09-06  Arnaud Charlet  <charlet@adacore.com>\n\n\t* lib-xref.adb (Get_Through_Renamings): Get through subprogram\n\trenamings; also, avoid repeated calls to Renamed_Object when getting\n\tthrough object renamings.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Array_Type_Declaration): Handle properly an\n\tarray type declaration in a private part, when an index is a\n\tsubtype indication of a discrete type with a private partial view.\n\n2017-09-06  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_Modular_Op): Force generating\n\ttemporary to improve the generated code.\n\n2017-09-06  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-fatgen.adb: Minor typo fix in comment.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Make_Field_Assign): If the type\n\tof the right-hand side has stored constraint, use its values\n\t(except for those that are renamings of parent discriminants)\n\tto produce additional assignments for the discriminants of the\n\tleft-hand side, which are invisible in the righ-hand side and\n\tnot retrievable as selected components.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Needs_One_Formal): The first formal of such a\n\tfunction must be a controlling formal, so that Obj.F (X, Y)\n\tcan have the interpretation F(Obj)(X, Y).\n\t* sem_util.ads: Clarify documentation.\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* table.ads, table.adb: Restore original implementation.\n\t* namet.h (Names_Ptr): Adjust back.\n\t(Name_Chars_Ptr): Likewise.\n\t* uintp.h (Uints_Ptr): Likewise.\n\t(Udigits_Ptr): Likewise.\n\t* g-table.ads: Remove pragma Compiler_Unit_Warning.\n\t* par_sco.adb: Do not with GNAT.Table and use Table consistently.\n\t* scos.ads: Replace GNAT.Table with Table and adjust instantiations.\n\t* spark_xrefs.ads: Likewise.\n\t* scos.h: Undo latest changes.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Propagate\n\tNo_Return flag to instance if pragma applies to generic unit. This\n\tmust be done explicitly because the pragma does not appear\n\tdirectly in the generic declaration (unlike the corresponding\n\taspect specification).\n\nFrom-SVN: r251765", "tree": {"sha": "d3b790355af00b0aa6795455db68661ca27241ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3b790355af00b0aa6795455db68661ca27241ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/comments", "author": null, "committer": null, "parents": [{"sha": "68ec1a494cc8c24b59a99294f86991523cd9832c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ec1a494cc8c24b59a99294f86991523cd9832c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ec1a494cc8c24b59a99294f86991523cd9832c"}], "stats": {"total": 960, "additions": 827, "deletions": 133}, "files": [{"sha": "5c0b3d7a25af27d9dc069ac6c51449472b31d449", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -1,3 +1,77 @@\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* treepr.adb (Print_Entity_Info): Do not print empty Elist.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Do not consider calls\n+\tto subprograms in other units as possibly inlined.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): For a derived type that has no\n+\texplicit delayed aspects but may inherit delayed aspects from its\n+\tparent type, analyze aspect at freeze point for proper capture\n+\tof an inherited aspect.\n+\n+2017-09-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* lib-xref.adb (Get_Through_Renamings): Get through subprogram\n+\trenamings; also, avoid repeated calls to Renamed_Object when getting\n+\tthrough object renamings.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Array_Type_Declaration): Handle properly an\n+\tarray type declaration in a private part, when an index is a\n+\tsubtype indication of a discrete type with a private partial view.\n+\n+2017-09-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Modular_Op): Force generating\n+\ttemporary to improve the generated code.\n+\n+2017-09-06  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-fatgen.adb: Minor typo fix in comment.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Make_Field_Assign): If the type\n+\tof the right-hand side has stored constraint, use its values\n+\t(except for those that are renamings of parent discriminants)\n+\tto produce additional assignments for the discriminants of the\n+\tleft-hand side, which are invisible in the righ-hand side and\n+\tnot retrievable as selected components.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Needs_One_Formal): The first formal of such a\n+\tfunction must be a controlling formal, so that Obj.F (X, Y)\n+\tcan have the interpretation F(Obj)(X, Y).\n+\t* sem_util.ads: Clarify documentation.\n+\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* table.ads, table.adb: Restore original implementation.\n+\t* namet.h (Names_Ptr): Adjust back.\n+\t(Name_Chars_Ptr): Likewise.\n+\t* uintp.h (Uints_Ptr): Likewise.\n+\t(Udigits_Ptr): Likewise.\n+\t* g-table.ads: Remove pragma Compiler_Unit_Warning.\n+\t* par_sco.adb: Do not with GNAT.Table and use Table consistently.\n+\t* scos.ads: Replace GNAT.Table with Table and adjust instantiations.\n+\t* spark_xrefs.ads: Likewise.\n+\t* scos.h: Undo latest changes.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Propagate\n+\tNo_Return flag to instance if pragma applies to generic unit. This\n+\tmust be done explicitly because the pragma does not appear\n+\tdirectly in the generic declaration (unlike the corresponding\n+\taspect specification).\n+\n 2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_ch7.adb (Has_Referencer): Move up and expand comment"}, {"sha": "9e18ec78e3df8bae088a6561fd5b0e98ffdfe34a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -4069,6 +4069,31 @@ package body Exp_Ch4 is\n             Set_Right_Opnd (Op_Expr,\n               Unchecked_Convert_To (Standard_Integer,\n                 New_Copy_Tree (Right_Opnd (N))));\n+\n+            --  Link this node to the tree to analyze it\n+\n+            --  If the parent node is an expression with actions we link it\n+            --  to N since otherwise Force_Evaluation cannot identify if this\n+            --  node comes from the Expression and rejects generating the\n+            --  temporary.\n+\n+            if Nkind (Parent (N)) = N_Expression_With_Actions then\n+               Set_Parent (Op_Expr, N);\n+\n+            --  Common case\n+\n+            else\n+               Set_Parent (Op_Expr, Parent (N));\n+            end if;\n+\n+            Analyze (Op_Expr);\n+\n+            --  Force generating a temporary because in the expansion of this\n+            --  expression we may generate code that performs this computation\n+            --  several times.\n+\n+            Force_Evaluation (Op_Expr, Mode => Strict);\n+\n             Set_Left_Opnd (Mod_Expr, Op_Expr);\n          end if;\n "}, {"sha": "4a892556356579edbdb4361e0185674e177dec15", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -1590,6 +1590,48 @@ package body Exp_Ch5 is\n                   Next_Discriminant (F);\n                end;\n             end loop;\n+\n+            --  If the derived type has a stored constraint, assign the value\n+            --  of the corresponding discriminants explicitly, skipping those\n+            --  that are renamed discriminants. We cannot just retrieve them\n+            --  from the Rhs by selected component because they are invisible\n+            --  in the type of the right-hand side.\n+\n+            if Stored_Constraint (R_Typ) /= No_Elist then\n+               declare\n+                  Discr_Val : Elmt_Id;\n+                  Assign    : Node_Id;\n+\n+               begin\n+                  Discr_Val := First_Elmt (Stored_Constraint (R_Typ));\n+                  F := First_Entity (R_Typ);\n+                  while Present (F) loop\n+                     if Ekind (F) = E_Discriminant\n+                       and then Is_Completely_Hidden (F)\n+                       and then Present (Corresponding_Record_Component (F))\n+                       and then (not Is_Entity_Name (Node (Discr_Val))\n+                         or else Ekind (Entity (Node (Discr_Val)))\n+                           /= E_Discriminant)\n+                     then\n+                        Assign :=\n+                          Make_Assignment_Statement (Loc,\n+                            Name =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix        => Duplicate_Subexpr (Lhs),\n+                                Selector_Name =>\n+                                  New_Occurrence_Of\n+                                    (Corresponding_Record_Component (F), Loc)),\n+                            Expression => New_Copy (Node ((Discr_Val))));\n+\n+                        Set_Assignment_OK (Name (Assign));\n+                        Insert_Action (N, Assign);\n+                        Next_Elmt (Discr_Val);\n+                     end if;\n+\n+                     Next_Entity (F);\n+                  end loop;\n+               end;\n+            end if;\n          end if;\n \n          --  We know the underlying type is a record, but its current view"}, {"sha": "4d8aa656a57a43e16d781968c51d0c7a97637cbd", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -5266,8 +5266,12 @@ package body Freeze is\n       --  pragma or attribute definition clause in the tree at this point. We\n       --  also analyze the aspect specification node at the freeze point when\n       --  the aspect doesn't correspond to pragma/attribute definition clause.\n+      --  In addition, a derived type may have inherited aspects that were\n+      --  delayed in the parent, so these must also be captured now.\n \n-      if Has_Delayed_Aspects (E) then\n+      if Has_Delayed_Aspects (E)\n+         or else May_Inherit_Delayed_Rep_Aspects (E)\n+      then\n          Analyze_Aspects_At_Freeze_Point (E);\n       end if;\n "}, {"sha": "ccda39bd91af09cd93bf8d7fa0b6e4c482cccbaf", "filename": "gcc/ada/g-table.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fg-table.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fg-table.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.ads?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -41,8 +41,6 @@\n --     GNAT.Table\n --     Table (the compiler unit)\n \n-pragma Compiler_Unit_Warning;\n-\n with GNAT.Dynamic_Tables;\n \n generic"}, {"sha": "007d59c9fdae3afb03b18b8f6708b3d4ef8d6b15", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -1349,6 +1349,15 @@ package body Inline is\n       elsif In_Package_Visible_Spec (Id) then\n          return False;\n \n+      --  Do not inline subprograms declared in other units. This is important\n+      --  in particular for subprograms defined in the private part of a\n+      --  package spec, when analyzing one of its child packages, as otherwise\n+      --  we issue spurious messages about the impossibility to inline such\n+      --  calls.\n+\n+      elsif not In_Extended_Main_Code_Unit (Id) then\n+         return False;\n+\n       --  Do not inline subprograms marked No_Return, possibly used for\n       --  signaling errors, which GNATprove handles specially.\n "}, {"sha": "d40f0d42fbd29dae992efda83bfcae7d8004d3d9", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -413,17 +413,57 @@ package body Lib.Xref is\n       ---------------------------\n \n       function Get_Through_Renamings (E : Entity_Id) return Entity_Id is\n-         Result : Entity_Id := E;\n-\n       begin\n-         while Present (Result)\n-           and then Is_Object (Result)\n-           and then Present (Renamed_Object (Result))\n-         loop\n-            Result := Get_Enclosing_Object (Renamed_Object (Result));\n-         end loop;\n+         case Ekind (E) is\n+            --  For subprograms we just need to check once if they are have a\n+            --  Renamed_Entity, because Renamed_Entity is set transitively.\n+\n+            when Subprogram_Kind =>\n+               declare\n+                  Renamed : constant Entity_Id := Renamed_Entity (E);\n+\n+               begin\n+                  if Present (Renamed) then\n+                     return Renamed;\n+                  else\n+                     return E;\n+                  end if;\n+               end;\n+\n+            --  For objects we need to repeatedly call Renamed_Object, because\n+            --  it is not transitive.\n+\n+            when Object_Kind =>\n+               declare\n+                  Obj : Entity_Id := E;\n+\n+               begin\n+                  loop\n+                     pragma Assert (Present (Obj));\n+\n+                     declare\n+                        Renamed : constant Entity_Id := Renamed_Object (Obj);\n+                     begin\n+                        if Present (Renamed) then\n+                           Obj := Get_Enclosing_Object (Renamed);\n+\n+                           --  The renamed expression denotes a non-object,\n+                           --  e.g. function call, slicing of a function call,\n+                           --  pointer dereference, etc.\n+                           if No (Obj) then\n+                              return Empty;\n+                           end if;\n+                        else\n+                           return Obj;\n+                        end if;\n+                     end;\n+                  end loop;\n+               end;\n+\n+            when others =>\n+               return E;\n \n-         return Result;\n+         end case;\n       end Get_Through_Renamings;\n \n       ---------------"}, {"sha": "35068d388fcb418bab08795549fd6871c6ecfd6e", "filename": "gcc/ada/namet.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fnamet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fnamet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.h?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -45,11 +45,11 @@ struct Name_Entry\n };\n \n /* Pointer to names table vector. */\n-#define Names_Ptr namet__name_entries__tab__the_instance\n+#define Names_Ptr namet__name_entries__table\n extern struct Name_Entry *Names_Ptr;\n \n /* Pointer to name characters table. */\n-#define Name_Chars_Ptr namet__name_chars__tab__the_instance\n+#define Name_Chars_Ptr namet__name_chars__table\n extern char *Name_Chars_Ptr;\n \n /* This is Hostparm.Max_Line_Length.  */"}, {"sha": "d44b656530d98b2df4aa46451393980c648ecc56", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -44,7 +44,6 @@ with Table;\n \n with GNAT.HTable;      use GNAT.HTable;\n with GNAT.Heap_Sort_G;\n-with GNAT.Table;\n \n package body Par_SCO is\n \n@@ -76,12 +75,13 @@ package body Par_SCO is\n    --  running some steps multiple times (the second pass has to be started\n    --  from multiple places).\n \n-   package SCO_Raw_Table is new GNAT.Table\n+   package SCO_Raw_Table is new Table.Table\n      (Table_Component_Type => SCO_Table_Entry,\n       Table_Index_Type     => Nat,\n       Table_Low_Bound      => 1,\n       Table_Initial        => 500,\n-      Table_Increment      => 300);\n+      Table_Increment      => 300,\n+      Table_Name           => \"Raw_Table\");\n \n    -----------------------\n    -- Unit Number Table --"}, {"sha": "fdb34f2e885b265f0e87abcf07197c2fa298fe96", "filename": "gcc/ada/s-fatgen.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -726,11 +726,11 @@ package body System.Fat_Gen is\n    --  This works provided that the intermediate result (RM1 + N) does not\n    --  have extra precision (which is why we call Machine). When we compute\n    --  RM1 + N, the exponent of N will be normalized and the mantissa shifted\n-   --  shifted appropriately so the lower order bits, which cannot contribute\n-   --  to the integer part of N, fall off on the right. When we subtract RM1\n-   --  again, the significant bits of N are shifted to the left, and what we\n-   --  have is an integer, because only the first e bits are different from\n-   --  zero (assuming binary radix here).\n+   --  appropriately so the lower order bits, which cannot contribute to the\n+   --  integer part of N, fall off on the right. When we subtract RM1 again,\n+   --  the significant bits of N are shifted to the left, and what we have is\n+   --  an integer, because only the first e bits are different from zero\n+   --  (assuming binary radix here).\n \n    function Truncation (X : T) return T is\n       Result : T;"}, {"sha": "e99ace680a9cacf10a93b2f004d287b0c4258d03", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2009-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,10 +29,9 @@\n --  is used in the ALI file.\n \n with Namet; use Namet;\n+with Table;\n with Types; use Types;\n \n-with GNAT.Table;\n-\n package SCOs is\n \n    --  SCO information can exist in one of two forms. In the ALI file, it is\n@@ -383,12 +382,13 @@ package SCOs is\n       --  For the SCO for a pragma/aspect, gives the pragma/apsect name\n    end record;\n \n-   package SCO_Table is new GNAT.Table (\n+   package SCO_Table is new Table.Table (\n      Table_Component_Type => SCO_Table_Entry,\n      Table_Index_Type     => Nat,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 500,\n-     Table_Increment      => 300);\n+     Table_Increment      => 300,\n+     Table_Name           => \"Table\");\n \n    Is_Decision : constant array (Character) of Boolean :=\n      ('E' | 'G' | 'I' | 'P' | 'a' | 'A' | 'W' | 'X' => True,\n@@ -530,12 +530,13 @@ package SCOs is\n \n    end record;\n \n-   package SCO_Unit_Table is new GNAT.Table (\n+   package SCO_Unit_Table is new Table.Table (\n      Table_Component_Type => SCO_Unit_Table_Entry,\n      Table_Index_Type     => SCO_Unit_Index,\n      Table_Low_Bound      => 0, -- see note above on sorting\n      Table_Initial        => 20,\n-     Table_Increment      => 200);\n+     Table_Increment      => 200,\n+     Table_Name           => \"Unit_Table\");\n \n    -----------------------\n    -- Generic instances --\n@@ -551,12 +552,13 @@ package SCOs is\n       Enclosing_Instance : SCO_Instance_Index;\n    end record;\n \n-   package SCO_Instance_Table is new GNAT.Table (\n+   package SCO_Instance_Table is new Table.Table (\n      Table_Component_Type => SCO_Instance_Table_Entry,\n      Table_Index_Type     => SCO_Instance_Index,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 20,\n-     Table_Increment      => 200);\n+     Table_Increment      => 200,\n+     Table_Name           => \"Instance_Table\");\n \n    -----------------\n    -- Subprograms --"}, {"sha": "bda373b60a59608b9c75688fe36513b68eb9ce40", "filename": "gcc/ada/scos.h", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fscos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fscos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.h?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -45,16 +45,14 @@ struct SCO_Unit_Table_Entry\n \n typedef struct SCO_Unit_Table_Entry *SCO_Unit_Table_Type;\n \n-/* The following depends on the fact that The_Instance.Table\n-   is the first component. */\n-extern SCO_Unit_Table_Type scos__sco_unit_table__the_instance;\n-#define SCO_Unit_Table scos__sco_unit_table__the_instance\n+extern SCO_Unit_Table_Type scos__sco_unit_table__table;\n+#define SCO_Unit_Table scos__sco_unit_table__table\n \n-extern Int scos__sco_unit_table__first(void);\n-#define SCO_Unit_Table_First scos__sco_unit_table__first\n+extern Int scos__sco_unit_table__min;\n+#define SCO_Unit_Table_Min scos__sco_unit_table__min\n \n-extern Int scos__sco_unit_table__last(void);\n-#define SCO_Unit_Table_Last scos__sco_unit_table__last\n+extern Int scos__sco_unit_table__last_val;\n+#define SCO_Unit_Table_Last_Val scos__sco_unit_table__last_val\n \n \n /* SCOs table:  */\n@@ -76,16 +74,14 @@ struct SCO_Table_Entry\n \n typedef struct SCO_Table_Entry *SCO_Table_Type;\n \n-/* The following depends on the fact that The_Instance.Table\n-   is the first component. */\n-extern SCO_Table_Type scos__sco_table__the_instance;\n-#define SCO_Table scos__sco_table__the_instance\n+extern SCO_Table_Type scos__sco_table__table;\n+#define SCO_Table scos__sco_table__table\n \n-extern Int scos__sco_table__first(void);\n-#define SCO_Table_First scos__sco_table__first\n+extern Int scos__sco_table__min;\n+#define SCO_Table_Min scos__sco_table__min\n \n-extern Int scos__sco_table__last(void);\n-#define SCO_Table_Last scos__sco_table__last\n+extern Int scos__sco_table__last_val;\n+#define SCO_Table_Last_Val scos__sco_table__last_val\n \n #ifdef __cplusplus\n }"}, {"sha": "acc293d5ef0c02654fdf4f406cbb06d0bfc0fdbb", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -5382,6 +5382,15 @@ package body Sem_Ch12 is\n          Set_Has_Pragma_Inline (Act_Decl_Id, Has_Pragma_Inline (Gen_Unit));\n          Set_Has_Pragma_Inline (Anon_Id,     Has_Pragma_Inline (Gen_Unit));\n \n+         --  Propagate No_Return if pragma applied to generic unit. This must\n+         --  be done explicitly because pragma does not appear in generic\n+         --  declaration (unlike the aspect case).\n+\n+         if No_Return (Gen_Unit) then\n+            Set_No_Return (Act_Decl_Id);\n+            Set_No_Return (Anon_Id);\n+         end if;\n+\n          Set_Has_Pragma_Inline_Always\n            (Act_Decl_Id, Has_Pragma_Inline_Always (Gen_Unit));\n          Set_Has_Pragma_Inline_Always"}, {"sha": "b5fb5f954bbec8b77ed408b8934c13b7f890a08e", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -6000,8 +6000,8 @@ package body Sem_Ch3 is\n                Analyze (Decl);\n                Set_Etype (Index, New_E);\n \n-               --  If the index is a range the Entity attribute is not\n-               --  available. Example:\n+               --  If the index is a range or a subtype indication it carries\n+               --  no entity. Example:\n \n                --     package Pkg is\n                --        type T is private;\n@@ -6010,7 +6010,9 @@ package body Sem_Ch3 is\n                --        Table : array (T(1) .. T(10)) of Boolean;\n                --     end Pkg;\n \n-               if Nkind (Index) /= N_Range then\n+               --  Otherwise the type of the reference is its entity.\n+\n+               if Is_Entity_Name (Index) then\n                   Set_Entity (Index, New_E);\n                end if;\n             end;"}, {"sha": "dde75ce39e8501878f64ca334ce5e10168e39e07", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -17050,6 +17050,7 @@ package body Sem_Util is\n       if Ada_Version >= Ada_2005\n         and then Present (First_Formal (E))\n         and then No (Default_Value (First_Formal (E)))\n+        and then Is_Controlling_Formal (First_Formal (E))\n       then\n          Formal := Next_Formal (First_Formal (E));\n          while Present (Formal) loop"}, {"sha": "8eb71d0db74e8ce12cba842e04d9f45725c1f592", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -2012,9 +2012,10 @@ package Sem_Util is\n    --  entity E. If no such instance exits, return Empty.\n \n    function Needs_One_Actual (E : Entity_Id) return Boolean;\n-   --  Returns True if a function has defaults for all but its first\n-   --  formal. Used in Ada 2005 mode to solve the syntactic ambiguity that\n-   --  results from an indexing of a function call written in prefix form.\n+   --  Returns True if a function has defaults for all but its first formal,\n+   --  which is a controlling formal. Used in Ada 2005 mode to solve the\n+   --  syntactic ambiguity that results from an indexing of a function call\n+   --  that returns an array, so that Obj.F (X, Y) may mean F (Ob) (X, Y).\n \n    function New_Copy_List_Tree (List : List_Id) return List_Id;\n    --  Copy recursively an analyzed list of nodes. Uses New_Copy_Tree defined"}, {"sha": "fd5b76d4a66ea87439ef9e417daa796a5c0dd106", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,8 @@\n --  file, and by Get_SPARK_Xrefs/Put_SPARK_Xrefs to read/write the textual\n --  representation that is stored in the ALI file.\n \n+with Table;\n with Types;      use Types;\n-with GNAT.Table;\n \n package SPARK_Xrefs is\n \n@@ -258,12 +258,13 @@ package SPARK_Xrefs is\n       --  Column number for the reference\n    end record;\n \n-   package SPARK_Xref_Table is new GNAT.Table (\n+   package SPARK_Xref_Table is new Table.Table (\n      Table_Component_Type => SPARK_Xref_Record,\n      Table_Index_Type     => Xref_Index,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 2000,\n-     Table_Increment      => 300);\n+     Table_Increment      => 300,\n+     Table_Name           => \"Xref_Table\");\n \n    -----------------\n    -- Scope Table --\n@@ -323,12 +324,13 @@ package SPARK_Xrefs is\n       --  Entity (subprogram or package) for the scope\n    end record;\n \n-   package SPARK_Scope_Table is new GNAT.Table (\n+   package SPARK_Scope_Table is new Table.Table (\n      Table_Component_Type => SPARK_Scope_Record,\n      Table_Index_Type     => Scope_Index,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 200,\n-     Table_Increment      => 300);\n+     Table_Increment      => 300,\n+     Table_Name           => \"Scope_Table\");\n \n    ----------------\n    -- File Table --\n@@ -360,12 +362,13 @@ package SPARK_Xrefs is\n       --  Ending index in Scope table for this unit\n    end record;\n \n-   package SPARK_File_Table is new GNAT.Table (\n+   package SPARK_File_Table is new Table.Table (\n      Table_Component_Type => SPARK_File_Record,\n      Table_Index_Type     => File_Index,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 20,\n-     Table_Increment      => 200);\n+     Table_Increment      => 200,\n+     Table_Name           => \"File_Table\");\n \n    ---------------\n    -- Constants --"}, {"sha": "ed6f1f7972800a84bd2ee2087b8668b49e2b464d", "filename": "gcc/ada/table.adb", "status": "modified", "additions": 362, "deletions": 7, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ftable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ftable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -29,27 +29,380 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Debug;   use Debug;\n+with Opt;     use Opt;\n+with Output;  use Output;\n with System;  use System;\n with Tree_IO; use Tree_IO;\n \n with System.Memory; use System.Memory;\n \n with Unchecked_Conversion;\n \n+pragma Elaborate_All (Output);\n+\n package body Table is\n    package body Table is\n \n+      Min : constant Int := Int (Table_Low_Bound);\n+      --  Subscript of the minimum entry in the currently allocated table\n+\n+      Length : Int := 0;\n+      --  Number of entries in currently allocated table. The value of zero\n+      --  ensures that we initially allocate the table.\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      procedure Reallocate;\n+      --  Reallocate the existing table according to the current value stored\n+      --  in Max. Works correctly to do an initial allocation if the table\n+      --  is currently null.\n+\n       function Tree_Get_Table_Address return Address;\n       --  Return Null_Address if the table length is zero,\n       --  Table (First)'Address if not.\n \n+      pragma Warnings (Off);\n+      --  Turn off warnings. The following unchecked conversions are only used\n+      --  internally in this package, and cannot never result in any instances\n+      --  of improperly aliased pointers for the client of the package.\n+\n+      function To_Address is new Unchecked_Conversion (Table_Ptr, Address);\n+      function To_Pointer is new Unchecked_Conversion (Address, Table_Ptr);\n+\n+      pragma Warnings (On);\n+\n+      ------------\n+      -- Append --\n+      ------------\n+\n+      procedure Append (New_Val : Table_Component_Type) is\n+      begin\n+         Set_Item (Table_Index_Type (Last_Val + 1), New_Val);\n+      end Append;\n+\n+      ----------------\n+      -- Append_All --\n+      ----------------\n+\n+      procedure Append_All (New_Vals : Table_Type) is\n+      begin\n+         for J in New_Vals'Range loop\n+            Append (New_Vals (J));\n+         end loop;\n+      end Append_All;\n+\n+      --------------------\n+      -- Decrement_Last --\n+      --------------------\n+\n+      procedure Decrement_Last is\n+      begin\n+         Last_Val := Last_Val - 1;\n+      end Decrement_Last;\n+\n+      ----------\n+      -- Free --\n+      ----------\n+\n+      procedure Free is\n+      begin\n+         Free (To_Address (Table));\n+         Table := null;\n+         Length := 0;\n+      end Free;\n+\n+      --------------------\n+      -- Increment_Last --\n+      --------------------\n+\n+      procedure Increment_Last is\n+      begin\n+         Last_Val := Last_Val + 1;\n+\n+         if Last_Val > Max then\n+            Reallocate;\n+         end if;\n+      end Increment_Last;\n+\n+      ----------\n+      -- Init --\n+      ----------\n+\n+      procedure Init is\n+         Old_Length : constant Int := Length;\n+\n+      begin\n+         Locked   := False;\n+         Last_Val := Min - 1;\n+         Max      := Min + (Table_Initial * Table_Factor) - 1;\n+         Length   := Max - Min + 1;\n+\n+         --  If table is same size as before (happens when table is never\n+         --  expanded which is a common case), then simply reuse it. Note\n+         --  that this also means that an explicit Init call right after\n+         --  the implicit one in the package body is harmless.\n+\n+         if Old_Length = Length then\n+            return;\n+\n+         --  Otherwise we can use Reallocate to get a table of the right size.\n+         --  Note that Reallocate works fine to allocate a table of the right\n+         --  initial size when it is first allocated.\n+\n+         else\n+            Reallocate;\n+         end if;\n+      end Init;\n+\n+      ----------\n+      -- Last --\n+      ----------\n+\n+      function Last return Table_Index_Type is\n+      begin\n+         return Table_Index_Type (Last_Val);\n+      end Last;\n+\n+      ----------------\n+      -- Reallocate --\n+      ----------------\n+\n+      procedure Reallocate is\n+         New_Size   : Memory.size_t;\n+         New_Length : Long_Long_Integer;\n+\n+      begin\n+         if Max < Last_Val then\n+            pragma Assert (not Locked);\n+\n+            --  Make sure that we have at least the initial allocation. This\n+            --  is needed in cases where a zero length table is written out.\n+\n+            Length := Int'Max (Length, Table_Initial);\n+\n+            --  Now increment table length until it is sufficiently large. Use\n+            --  the increment value or 10, which ever is larger (the reason\n+            --  for the use of 10 here is to ensure that the table does really\n+            --  increase in size (which would not be the case for a table of\n+            --  length 10 increased by 3% for instance). Do the intermediate\n+            --  calculation in Long_Long_Integer to avoid overflow.\n+\n+            while Max < Last_Val loop\n+               New_Length :=\n+                 Long_Long_Integer (Length) *\n+                    (100 + Long_Long_Integer (Table_Increment)) / 100;\n+               Length := Int'Max (Int (New_Length), Length + 10);\n+               Max := Min + Length - 1;\n+            end loop;\n+\n+            if Debug_Flag_D then\n+               Write_Str (\"--> Allocating new \");\n+               Write_Str (Table_Name);\n+               Write_Str (\" table, size = \");\n+               Write_Int (Max - Min + 1);\n+               Write_Eol;\n+            end if;\n+         end if;\n+\n+         --  Do the intermediate calculation in size_t to avoid signed overflow\n+\n+         New_Size :=\n+           Memory.size_t (Max - Min + 1) *\n+                                    (Table_Type'Component_Size / Storage_Unit);\n+\n+         if Table = null then\n+            Table := To_Pointer (Alloc (New_Size));\n+\n+         elsif New_Size > 0 then\n+            Table :=\n+              To_Pointer (Realloc (Ptr  => To_Address (Table),\n+                                   Size => New_Size));\n+         end if;\n+\n+         if Length /= 0 and then Table = null then\n+            Set_Standard_Error;\n+            Write_Str (\"available memory exhausted\");\n+            Write_Eol;\n+            Set_Standard_Output;\n+            raise Unrecoverable_Error;\n+         end if;\n+      end Reallocate;\n+\n+      -------------\n+      -- Release --\n+      -------------\n+\n+      procedure Release is\n+         Extra_Length : Int;\n+         Size         : Memory.size_t;\n+\n+      begin\n+         Length := Last_Val - Int (Table_Low_Bound) + 1;\n+         Size   := Memory.size_t (Length) *\n+                     (Table_Type'Component_Size / Storage_Unit);\n+\n+         --  If the size of the table exceeds the release threshold then leave\n+         --  space to store as many extra elements as 0.1% of the table length.\n+\n+         if Release_Threshold > 0\n+           and then Size > Memory.size_t (Release_Threshold)\n+         then\n+            Extra_Length := Length / 1000;\n+            Length := Length + Extra_Length;\n+            Max    := Int (Table_Low_Bound) + Length - 1;\n+\n+            if Debug_Flag_D then\n+               Write_Str (\"--> Release_Threshold reached (length=\");\n+               Write_Int (Int (Size));\n+               Write_Str (\"): leaving room space for \");\n+               Write_Int (Extra_Length);\n+               Write_Str (\" components\");\n+               Write_Eol;\n+            end if;\n+         else\n+            Max := Last_Val;\n+         end if;\n+\n+         Reallocate;\n+      end Release;\n+\n+      -------------\n+      -- Restore --\n+      -------------\n+\n+      procedure Restore (T : Saved_Table) is\n+      begin\n+         Free (To_Address (Table));\n+         Last_Val := T.Last_Val;\n+         Max      := T.Max;\n+         Table    := T.Table;\n+         Length   := Max - Min + 1;\n+      end Restore;\n+\n+      ----------\n+      -- Save --\n+      ----------\n+\n+      function Save return Saved_Table is\n+         Res : Saved_Table;\n+\n+      begin\n+         Res.Last_Val := Last_Val;\n+         Res.Max      := Max;\n+         Res.Table    := Table;\n+\n+         Table  := null;\n+         Length := 0;\n+         Init;\n+         return Res;\n+      end Save;\n+\n+      --------------\n+      -- Set_Item --\n+      --------------\n+\n+      procedure Set_Item\n+         (Index : Table_Index_Type;\n+          Item  : Table_Component_Type)\n+      is\n+         --  If Item is a value within the current allocation, and we are going\n+         --  to reallocate, then we must preserve an intermediate copy here\n+         --  before calling Increment_Last. Otherwise, if Table_Component_Type\n+         --  is passed by reference, we are going to end up copying from\n+         --  storage that might have been deallocated from Increment_Last\n+         --  calling Reallocate.\n+\n+         subtype Allocated_Table_T is\n+           Table_Type (Table'First .. Table_Index_Type (Max + 1));\n+         --  A constrained table subtype one element larger than the currently\n+         --  allocated table.\n+\n+         Allocated_Table_Address : constant System.Address :=\n+                                     Table.all'Address;\n+         --  Used for address clause below (we can't use non-static expression\n+         --  Table.all'Address directly in the clause because some older\n+         --  versions of the compiler do not allow it).\n+\n+         Allocated_Table : Allocated_Table_T;\n+         pragma Import (Ada, Allocated_Table);\n+         pragma Suppress (Range_Check, On => Allocated_Table);\n+         for Allocated_Table'Address use Allocated_Table_Address;\n+         --  Allocated_Table represents the currently allocated array, plus one\n+         --  element (the supplementary element is used to have a convenient\n+         --  way of computing the address just past the end of the current\n+         --  allocation). Range checks are suppressed because this unit\n+         --  uses direct calls to System.Memory for allocation, and this can\n+         --  yield misaligned storage (and we cannot rely on the bootstrap\n+         --  compiler supporting specifically disabling alignment checks, so we\n+         --  need to suppress all range checks). It is safe to suppress this\n+         --  check here because we know that a (possibly misaligned) object\n+         --  of that type does actually exist at that address.\n+         --  ??? We should really improve the allocation circuitry here to\n+         --  guarantee proper alignment.\n+\n+         Need_Realloc : constant Boolean := Int (Index) > Max;\n+         --  True if this operation requires storage reallocation (which may\n+         --  involve moving table contents around).\n+\n+      begin\n+         --  If we're going to reallocate, check whether Item references an\n+         --  element of the currently allocated table.\n+\n+         if Need_Realloc\n+           and then Allocated_Table'Address <= Item'Address\n+           and then Item'Address <\n+                      Allocated_Table (Table_Index_Type (Max + 1))'Address\n+         then\n+            --  If so, save a copy on the stack because Increment_Last will\n+            --  reallocate storage and might deallocate the current table.\n+\n+            declare\n+               Item_Copy : constant Table_Component_Type := Item;\n+            begin\n+               Set_Last (Index);\n+               Table (Index) := Item_Copy;\n+            end;\n+\n+         else\n+            --  Here we know that either we won't reallocate (case of Index <\n+            --  Max) or that Item is not in the currently allocated table.\n+\n+            if Int (Index) > Last_Val then\n+               Set_Last (Index);\n+            end if;\n+\n+            Table (Index) := Item;\n+         end if;\n+      end Set_Item;\n+\n+      --------------\n+      -- Set_Last --\n+      --------------\n+\n+      procedure Set_Last (New_Val : Table_Index_Type) is\n+      begin\n+         if Int (New_Val) < Last_Val then\n+            Last_Val := Int (New_Val);\n+\n+         else\n+            Last_Val := Int (New_Val);\n+\n+            if Last_Val > Max then\n+               Reallocate;\n+            end if;\n+         end if;\n+      end Set_Last;\n+\n       ----------------------------\n       -- Tree_Get_Table_Address --\n       ----------------------------\n \n       function Tree_Get_Table_Address return Address is\n       begin\n-         if Is_Empty then\n+         if Length = 0 then\n             return Null_Address;\n          else\n             return Table (First)'Address;\n@@ -65,15 +418,15 @@ package body Table is\n       --  does an implicit Release.\n \n       procedure Tree_Read is\n-         Last : Int;\n       begin\n-         Init;\n-         Tree_Read_Int (Last);\n-         Set_Last (Table_Last_Type (Last));\n+         Tree_Read_Int (Max);\n+         Last_Val := Max;\n+         Length := Max - Min + 1;\n+         Reallocate;\n \n          Tree_Read_Data\n            (Tree_Get_Table_Address,\n-             (Last - Int (First) + 1) *\n+             (Last_Val - Int (First) + 1) *\n \n                --  Note the importance of parenthesizing the following division\n                --  to avoid the possibility of intermediate overflow.\n@@ -93,9 +446,11 @@ package body Table is\n          Tree_Write_Int (Int (Last));\n          Tree_Write_Data\n            (Tree_Get_Table_Address,\n-            (Int (Last - First) + 1) *\n+            (Last_Val - Int (First) + 1) *\n               (Table_Type'Component_Size / Storage_Unit));\n       end Tree_Write;\n \n+   begin\n+      Init;\n    end Table;\n end Table;"}, {"sha": "dcfc6fb692085ed2026c83b3cd47c32a74de01b8", "filename": "gcc/ada/table.ads", "status": "modified", "additions": 190, "deletions": 58, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ftable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ftable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.ads?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -29,20 +29,19 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package is a wrapper for GNAT.Table, for use in the compiler front\n---  end. It adds the Tree_Write/Tree_Read functionality; everything else is\n---  just a renaming of GNAT.Table. See GNAT.Table (g-table.ads) and\n---  GNAT.Dynamic_Tables (g-dyntab.ads) for documentation.\n-\n---  Note that these three interfaces should remain synchronized to keep as much\n---  coherency as possible among these related units:\n---\n---     GNAT.Dynamic_Tables\n---     GNAT.Table\n---     Table (the compiler unit)\n+--  This package provides an implementation of dynamically resizable one\n+--  dimensional arrays. The idea is to mimic the normal Ada semantics for\n+--  arrays as closely as possible with the one additional capability of\n+--  dynamically modifying the value of the Last attribute.\n+\n+--  This package uses a very efficient memory management scheme and any\n+--  change must be carefully evaluated on compilation of real software.\n+\n+--  Note that this interface should remain synchronized with those in\n+--  GNAT.Table and GNAT.Dynamic_Tables to keep coherency between these\n+--  three related units.\n \n with Types; use Types;\n-with GNAT.Table;\n \n package Table is\n    pragma Elaborate_Body;\n@@ -51,66 +50,199 @@ package Table is\n       type Table_Component_Type is private;\n       type Table_Index_Type     is range <>;\n \n-      Table_Low_Bound   : Table_Index_Type := Table_Index_Type'First;\n-      Table_Initial     : Pos := 8;\n-      Table_Increment   : Nat := 100;\n-      Table_Name        : String; -- for debugging printouts\n+      Table_Low_Bound   : Table_Index_Type;\n+      Table_Initial     : Pos;\n+      Table_Increment   : Nat;\n+      Table_Name        : String;\n       Release_Threshold : Nat := 0;\n \n    package Table is\n \n-      package Tab is new GNAT.Table\n-        (Table_Component_Type,\n-         Table_Index_Type,\n-         Table_Low_Bound,\n-         Positive (Table_Initial),\n-         Natural (Table_Increment),\n-         Table_Name,\n-         Natural (Release_Threshold));\n-\n-      subtype Valid_Table_Index_Type is Tab.Valid_Table_Index_Type;\n-      subtype Table_Last_Type is Tab.Table_Last_Type;\n-      subtype Table_Type is Tab.Table_Type;\n-\n-      subtype Table_Ptr is Tab.Table_Ptr;\n-\n-      Table : Table_Ptr renames Tab.Table;\n-\n-      Locked : Boolean renames Tab.Locked;\n-\n-      function Is_Empty return Boolean renames Tab.Is_Empty;\n-\n-      procedure Init renames Tab.Init;\n-\n-      function First return Table_Index_Type renames Tab.First;\n-      function Last return Table_Last_Type renames Tab.Last;\n+      --  Table_Component_Type and Table_Index_Type specify the type of the\n+      --  array, Table_Low_Bound is the lower bound. Table_Index_Type must be\n+      --  an integer type. The effect is roughly to declare:\n+\n+      --    Table : array (Table_Index_Type range Table_Low_Bound .. <>)\n+      --                       of Table_Component_Type;\n+\n+      --    Note: since the upper bound can be one less than the lower\n+      --    bound for an empty array, the table index type must be able\n+      --    to cover this range, e.g. if the lower bound is 1, then the\n+      --    Table_Index_Type should be Natural rather than Positive.\n+\n+      --  Table_Component_Type may be any Ada type, except that controlled\n+      --  types are not supported. Note however that default initialization\n+      --  will NOT occur for array components.\n+\n+      --  The Table_Initial values controls the allocation of the table when\n+      --  it is first allocated, either by default, or by an explicit Init\n+      --  call. The value used is Opt.Table_Factor * Table_Initial.\n+\n+      --  The Table_Increment value controls the amount of increase, if the\n+      --  table has to be increased in size. The value given is a percentage\n+      --  value (e.g. 100 = increase table size by 100%, i.e. double it).\n+\n+      --  The Table_Name parameter is simply use in debug output messages it\n+      --  has no other usage, and is not referenced in non-debugging mode.\n+\n+      --  The Last and Set_Last subprograms provide control over the current\n+      --  logical allocation. They are quite efficient, so they can be used\n+      --  freely (expensive reallocation occurs only at major granularity\n+      --  chunks controlled by the allocation parameters).\n+\n+      --  Note: We do not make the table components aliased, since this would\n+      --  restrict the use of table for discriminated types. If it is necessary\n+      --  to take the access of a table element, use Unrestricted_Access.\n+\n+      --  WARNING: On HPPA, the virtual addressing approach used in this unit\n+      --  is incompatible with the indexing instructions on the HPPA. So when\n+      --  using this unit, compile your application with -mdisable-indexing.\n+\n+      --  WARNING: If the table is reallocated, then the address of all its\n+      --  components will change. So do not capture the address of an element\n+      --  and then use the address later after the table may be reallocated.\n+      --  One tricky case of this is passing an element of the table to a\n+      --  subprogram by reference where the table gets reallocated during\n+      --  the execution of the subprogram. The best rule to follow is never\n+      --  to pass a table element as a parameter except for the case of IN\n+      --  mode parameters with scalar values.\n+\n+      type Table_Type is\n+        array (Table_Index_Type range <>) of Table_Component_Type;\n+\n+      subtype Big_Table_Type is\n+        Table_Type (Table_Low_Bound .. Table_Index_Type'Last);\n+      --  We work with pointers to a bogus array type that is constrained\n+      --  with the maximum possible range bound. This means that the pointer\n+      --  is a thin pointer, which is more efficient. Since subscript checks\n+      --  in any case must be on the logical, rather than physical bounds,\n+      --  safety is not compromised by this approach.\n+\n+      type Table_Ptr is access all Big_Table_Type;\n+      for Table_Ptr'Storage_Size use 0;\n+      --  The table is actually represented as a pointer to allow reallocation\n+\n+      Table : aliased Table_Ptr := null;\n+      --  The table itself. The lower bound is the value of Low_Bound.\n+      --  Logically the upper bound is the current value of Last (although\n+      --  the actual size of the allocated table may be larger than this).\n+      --  The program may only access and modify Table entries in the range\n+      --  First .. Last.\n+\n+      Locked : Boolean := False;\n+      --  Table expansion is permitted only if this switch is set to False. A\n+      --  client may set Locked to True, in which case any attempt to expand\n+      --  the table will cause an assertion failure. Note that while a table\n+      --  is locked, its address in memory remains fixed and unchanging. This\n+      --  feature is used to control table expansion during Gigi processing.\n+      --  Gigi assumes that tables other than the Uint and Ureal tables do\n+      --  not move during processing, which means that they cannot be expanded.\n+      --  The Locked flag is used to enforce this restriction.\n+\n+      procedure Init;\n+      --  This procedure allocates a new table of size Initial (freeing any\n+      --  previously allocated larger table). It is not necessary to call\n+      --  Init when a table is first instantiated (since the instantiation does\n+      --  the same initialization steps). However, it is harmless to do so, and\n+      --  Init is convenient in reestablishing a table for new use.\n+\n+      function Last return Table_Index_Type;\n+      pragma Inline (Last);\n+      --  Returns the current value of the last used entry in the table, which\n+      --  can then be used as a subscript for Table. Note that the only way to\n+      --  modify Last is to call the Set_Last procedure. Last must always be\n+      --  used to determine the logically last entry.\n+\n+      procedure Release;\n+      --  Storage is allocated in chunks according to the values given in the\n+      --  Initial and Increment parameters. If Release_Threshold is 0 or the\n+      --  length of the table does not exceed this threshold then a call to\n+      --  Release releases all storage that is allocated, but is not logically\n+      --  part of the current array value; otherwise the call to Release leaves\n+      --  the current array value plus 0.1% of the current table length free\n+      --  elements located at the end of the table (this parameter facilitates\n+      --  reopening large tables and adding a few elements without allocating a\n+      --  chunk of memory). In both cases current array values are not affected\n+      --  by this call.\n+\n+      procedure Free;\n+      --  Free all allocated memory for the table. A call to init is required\n+      --  before any use of this table after calling Free.\n+\n+      First : constant Table_Index_Type := Table_Low_Bound;\n+      --  Export First as synonym for Low_Bound (parallel with use of Last)\n+\n+      procedure Set_Last (New_Val : Table_Index_Type);\n+      pragma Inline (Set_Last);\n+      --  This procedure sets Last to the indicated value. If necessary the\n+      --  table is reallocated to accommodate the new value (i.e. on return\n+      --  the allocated table has an upper bound of at least Last). If Set_Last\n+      --  reduces the size of the table, then logically entries are removed\n+      --  from the table. If Set_Last increases the size of the table, then\n+      --  new entries are logically added to the table.\n+\n+      procedure Increment_Last;\n+      pragma Inline (Increment_Last);\n+      --  Adds 1 to Last (same as Set_Last (Last + 1)\n+\n+      procedure Decrement_Last;\n+      pragma Inline (Decrement_Last);\n+      --  Subtracts 1 from Last (same as Set_Last (Last - 1)\n+\n+      procedure Append (New_Val : Table_Component_Type);\n+      pragma Inline (Append);\n+      --  Equivalent to:\n+      --    x.Increment_Last;\n+      --    x.Table (x.Last) := New_Val;\n+      --  i.e. the table size is increased by one, and the given new item\n+      --  stored in the newly created table element.\n+\n+      procedure Append_All (New_Vals : Table_Type);\n+      --  Appends all components of New_Vals\n \n-      procedure Release renames Tab.Release;\n-\n-      procedure Free renames Tab.Free;\n-\n-      procedure Set_Last (New_Val : Table_Last_Type) renames Tab.Set_Last;\n-\n-      procedure Increment_Last renames Tab.Increment_Last;\n-      procedure Decrement_Last renames Tab.Decrement_Last;\n+      procedure Set_Item\n+        (Index : Table_Index_Type;\n+         Item  : Table_Component_Type);\n+      pragma Inline (Set_Item);\n+      --  Put Item in the table at position Index. The table is expanded if\n+      --  current table length is less than Index and in that case Last is set\n+      --  to Index. Item will replace any value already present in the table\n+      --  at this position.\n \n-      procedure Append (New_Val : Table_Component_Type) renames Tab.Append;\n-      procedure Append_All (New_Vals : Table_Type) renames Tab.Append_All;\n+      type Saved_Table is private;\n+      --  Type used for Save/Restore subprograms\n \n-      procedure Set_Item\n-        (Index : Valid_Table_Index_Type;\n-         Item  : Table_Component_Type) renames Tab.Set_Item;\n+      function Save return Saved_Table;\n+      --  Resets table to empty, but saves old contents of table in returned\n+      --  value, for possible later restoration by a call to Restore.\n \n-      subtype Saved_Table is Tab.Saved_Table;\n-      function Save return Saved_Table renames Tab.Save;\n-      procedure Restore (T : in out Saved_Table) renames Tab.Restore;\n+      procedure Restore (T : Saved_Table);\n+      --  Given a Saved_Table value returned by a prior call to Save, restores\n+      --  the table to the state it was in at the time of the Save call.\n \n       procedure Tree_Write;\n       --  Writes out contents of table using Tree_IO\n \n       procedure Tree_Read;\n       --  Initializes table by reading contents previously written with the\n-      --  Tree_Write call, also using Tree_IO.\n+      --  Tree_Write call (also using Tree_IO).\n+\n+   private\n+\n+      Last_Val : Int;\n+      --  Current value of Last. Note that we declare this in the private part\n+      --  because we don't want the client to modify Last except through one of\n+      --  the official interfaces (since a modification to Last may require a\n+      --  reallocation of the table).\n+\n+      Max : Int;\n+      --  Subscript of the maximum entry in the currently allocated table\n+\n+      type Saved_Table is record\n+         Last_Val : Int;\n+         Max      : Int;\n+         Table    : Table_Ptr;\n+      end record;\n \n    end Table;\n end Table;"}, {"sha": "6f25a7bd96a1799e61b534e67c5ecc25b5581ef4", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -423,12 +423,13 @@ package body Treepr is\n    procedure Print_Entity_Info (Ent : Entity_Id; Prefix : String) is\n       function Field_Present (U : Union_Id) return Boolean;\n       --  Returns False unless the value U represents a missing value\n-      --  (Empty, No_Uint, No_Ureal or No_String)\n+      --  (Empty, No_Elist, No_Uint, No_Ureal or No_String)\n \n       function Field_Present (U : Union_Id) return Boolean is\n       begin\n          return\n             U /= Union_Id (Empty)    and then\n+            U /= Union_Id (No_Elist) and then\n             U /= To_Union (No_Uint)  and then\n             U /= To_Union (No_Ureal) and then\n             U /= Union_Id (No_String);"}, {"sha": "ec374b3c8f9ff0e274e9fb6b27959616e7faaf9e", "filename": "gcc/ada/uintp.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fuintp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb1e654f463fe3e30dccee2b6622c95edcf5d25/gcc%2Fada%2Fuintp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.h?ref=9fb1e654f463fe3e30dccee2b6622c95edcf5d25", "patch": "@@ -101,11 +101,11 @@ extern Boolean UI_Lt\t\t\t(Uint, Uint);\n    the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n    that a Uint value of Uint_Bias indexes the first element.  */\n \n-#define Uints_Ptr (uintp__uints__tab__the_instance - Uint_Table_Start)\n-extern struct Uint_Entry *uintp__uints__tab__the_instance;\n+#define Uints_Ptr (uintp__uints__table - Uint_Table_Start)\n+extern struct Uint_Entry *uintp__uints__table;\n \n-#define Udigits_Ptr uintp__udigits__tab__the_instance\n-extern int *uintp__udigits__tab__the_instance;\n+#define Udigits_Ptr uintp__udigits__table\n+extern int *uintp__udigits__table;\n \n #ifdef __cplusplus\n }"}]}