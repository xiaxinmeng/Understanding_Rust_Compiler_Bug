{"sha": "d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjZGYxMTM4ZTRjN2YzNWY0NjZjYTUyYTAwYzU1Y2Y0ZWE5OWZiNQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-02-24T19:06:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-24T19:06:17Z"}, "message": "calls.c (initialize_argument_information): New function extracted from expand_call.\n\n        * calls.c (initialize_argument_information): New function extracted\n        from expand_call.\n        (expand_call): Use initialize_argument_information.  Remove variables\n        which are no longer used due to cleanups.\n\nFrom-SVN: r25416", "tree": {"sha": "f118bf5a5afcf7a63b8a156e3f96310bc8d42f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f118bf5a5afcf7a63b8a156e3f96310bc8d42f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5/comments", "author": null, "committer": null, "parents": [{"sha": "c55310ab51bdcbe0391979b04b675c7a887f4c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c55310ab51bdcbe0391979b04b675c7a887f4c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c55310ab51bdcbe0391979b04b675c7a887f4c85"}], "stats": {"total": 535, "additions": 300, "deletions": 235}, "files": [{"sha": "fedb88438cbe720d2dc35143d589c58f9ae6bf44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5", "patch": "@@ -5,6 +5,11 @@ Wed Feb 24 17:47:28 1999  Jim Wilson  <wilson@cygnus.com>\n \n Wed Feb 24 14:03:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (initialize_argument_information): New function extracted\n+\tfrom expand_call.\n+\t(expand_call): Use initialize_argument_information.  Remove variables\n+\twhich are no longer used due to cleanups.\n+\n \t* calls.c (compute_argument_block_size): New function, extracted from\n \texpand_calls.\n \t(expand_calls): Use compute_argument_block_size.  Delete"}, {"sha": "b7c4aa1dc1e26d714ddb2f1a715713392146a9c4", "filename": "gcc/calls.c", "status": "modified", "additions": 295, "deletions": 235, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d7cdf1138e4c7f35f466ca52a00c55cf4ea99fb5", "patch": "@@ -145,6 +145,13 @@ static void precompute_arguments \t\tPROTO ((int, int, int,\n \t\t\t\t\t\t\tstruct args_size *));\n static int compute_argument_block_size\t\tPROTO ((int, \n \t\t\t\t\t\t\tstruct args_size *));\n+static void initialize_argument_information\tPROTO ((int,\n+\t\t\t\t\t\t\tstruct arg_data *,\n+\t\t\t\t\t\t\tstruct args_size *,\n+\t\t\t\t\t\t\tint, tree, tree,\n+\t\t\t\t\t\t\tCUMULATIVE_ARGS,\n+\t\t\t\t\t\t\tint, rtx *, int *,\n+\t\t\t\t\t\t\tint *, int *));\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n static rtx save_fixed_argument_area\tPROTO ((int, rtx, int *, int *));\n@@ -830,6 +837,287 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n       }\n }\n \n+/* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n+   ACTPARMS. \n+\n+   NUM_ACTUALS is the total number of parameters.\n+\n+   N_NAMED_ARGS is the total number of named arguments.\n+\n+   FNDECL is the tree code for the target of this call (if known)\n+\n+   ARGS_SO_FAR holds state needed by the target to know where to place\n+   the next argument.\n+\n+   REG_PARM_STACK_SPACE is the number of bytes of stack space reserved\n+   for arguments which are passed in registers.\n+\n+   OLD_STACK_LEVEL is a pointer to an rtx which olds the old stack level\n+   and may be modified by this routine.\n+\n+   OLD_PENDING_ADJ, MUST_PREALLOCATE and IS_CONST are pointers to integer\n+   flags which may may be modified by this routine.  */\n+\n+static void\n+initialize_argument_information (num_actuals, args, args_size, n_named_args,\n+\t\t\t\t actparms, fndecl, args_so_far,\n+\t\t\t\t reg_parm_stack_space, old_stack_level,\n+\t\t\t\t old_pending_adj, must_preallocate, is_const)\n+     int num_actuals;\n+     struct arg_data *args;\n+     struct args_size *args_size;\n+     int n_named_args;\n+     tree actparms;\n+     tree fndecl;\n+     CUMULATIVE_ARGS args_so_far;\n+     int reg_parm_stack_space;\n+     rtx *old_stack_level;\n+     int *old_pending_adj;\n+     int *must_preallocate;\n+     int *is_const;\n+{\n+  /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n+  int inc;\n+\n+  /* Count arg position in order args appear.  */\n+  int argpos;\n+\n+  int i;\n+  tree p;\n+  \n+  args_size->constant = 0;\n+  args_size->var = 0;\n+\n+  /* In this loop, we consider args in the order they are written.\n+     We fill up ARGS from the front or from the back if necessary\n+     so that in any case the first arg to be pushed ends up at the front.  */\n+\n+#ifdef PUSH_ARGS_REVERSED\n+  i = num_actuals - 1, inc = -1;\n+  /* In this case, must reverse order of args\n+     so that we compute and push the last arg first.  */\n+#else\n+  i = 0, inc = 1;\n+#endif\n+\n+  /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n+  for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), i += inc, argpos++)\n+    {\n+      tree type = TREE_TYPE (TREE_VALUE (p));\n+      int unsignedp;\n+      enum machine_mode mode;\n+\n+      args[i].tree_value = TREE_VALUE (p);\n+\n+      /* Replace erroneous argument with constant zero.  */\n+      if (type == error_mark_node || TYPE_SIZE (type) == 0)\n+\targs[i].tree_value = integer_zero_node, type = integer_type_node;\n+\n+      /* If TYPE is a transparent union, pass things the way we would\n+\t pass the first field of the union.  We have already verified that\n+\t the modes are the same.  */\n+      if (TYPE_TRANSPARENT_UNION (type))\n+\ttype = TREE_TYPE (TYPE_FIELDS (type));\n+\n+      /* Decide where to pass this arg.\n+\n+\t args[i].reg is nonzero if all or part is passed in registers.\n+\n+\t args[i].partial is nonzero if part but not all is passed in registers,\n+\t and the exact value says how many words are passed in registers.\n+\n+\t args[i].pass_on_stack is nonzero if the argument must at least be\n+\t computed on the stack.  It may then be loaded back into registers\n+\t if args[i].reg is nonzero.\n+\n+\t These decisions are driven by the FUNCTION_... macros and must agree\n+\t with those made by function.c.  */\n+\n+      /* See if this argument should be passed by invisible reference.  */\n+      if ((TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+\t   && contains_placeholder_p (TYPE_SIZE (type)))\n+\t  || TREE_ADDRESSABLE (type)\n+#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n+\t  || FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, TYPE_MODE (type),\n+\t\t\t\t\t     type, argpos < n_named_args)\n+#endif\n+\t  )\n+\t{\n+\t  /* If we're compiling a thunk, pass through invisible\n+             references instead of making a copy.  */\n+\t  if (current_function_is_thunk\n+#ifdef FUNCTION_ARG_CALLEE_COPIES\n+\t      || (FUNCTION_ARG_CALLEE_COPIES (args_so_far, TYPE_MODE (type),\n+\t\t\t\t\t     type, argpos < n_named_args)\n+\t\t  /* If it's in a register, we must make a copy of it too.  */\n+\t\t  /* ??? Is this a sufficient test?  Is there a better one? */\n+\t\t  && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n+\t\t       && REG_P (DECL_RTL (args[i].tree_value)))\n+\t\t  && ! TREE_ADDRESSABLE (type))\n+#endif\n+\t      )\n+\t    {\n+\t      /* C++ uses a TARGET_EXPR to indicate that we want to make a\n+\t         new object from the argument.  If we are passing by\n+\t         invisible reference, the callee will do that for us, so we\n+\t         can strip off the TARGET_EXPR.  This is not always safe,\n+\t         but it is safe in the only case where this is a useful\n+\t         optimization; namely, when the argument is a plain object.\n+\t         In that case, the frontend is just asking the backend to\n+\t         make a bitwise copy of the argument. */\n+\t\t \n+\t      if (TREE_CODE (args[i].tree_value) == TARGET_EXPR\n+\t\t  && (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND\n+\t\t\t\t\t\t  (args[i].tree_value, 1)))\n+\t\t      == 'd')\n+\t\t  && ! REG_P (DECL_RTL (TREE_OPERAND (args[i].tree_value, 1))))\n+\t\targs[i].tree_value = TREE_OPERAND (args[i].tree_value, 1);\n+\n+\t      args[i].tree_value = build1 (ADDR_EXPR,\n+\t\t\t\t\t   build_pointer_type (type),\n+\t\t\t\t\t   args[i].tree_value);\n+\t      type = build_pointer_type (type);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We make a copy of the object and pass the address to the\n+\t\t function being called.  */\n+\t      rtx copy;\n+\n+\t      if (TYPE_SIZE (type) == 0\n+\t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+\t\t  || (flag_stack_check && ! STACK_CHECK_BUILTIN\n+\t\t      && (TREE_INT_CST_HIGH (TYPE_SIZE (type)) != 0\n+\t\t\t  || (TREE_INT_CST_LOW (TYPE_SIZE (type))\n+\t\t\t      > STACK_CHECK_MAX_VAR_SIZE * BITS_PER_UNIT))))\n+\t\t{\n+\t\t  /* This is a variable-sized object.  Make space on the stack\n+\t\t     for it.  */\n+\t\t  rtx size_rtx = expr_size (TREE_VALUE (p));\n+\n+\t\t  if (*old_stack_level == 0)\n+\t\t    {\n+\t\t      emit_stack_save (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\t\t      *old_pending_adj = pending_stack_adjust;\n+\t\t      pending_stack_adjust = 0;\n+\t\t    }\n+\n+\t\t  copy = gen_rtx_MEM (BLKmode,\n+\t\t\t\t      allocate_dynamic_stack_space (size_rtx,\n+\t\t\t\t\t\t\t\t    NULL_RTX,\n+\t\t\t\t\t\t\t\t    TYPE_ALIGN (type)));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int size = int_size_in_bytes (type);\n+\t\t  copy = assign_stack_temp (TYPE_MODE (type), size, 0);\n+\t\t}\n+\n+\t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n+\n+\t      store_expr (args[i].tree_value, copy, 0);\n+\t      *is_const = 0;\n+\n+\t      args[i].tree_value = build1 (ADDR_EXPR,\n+\t\t\t\t\t   build_pointer_type (type),\n+\t\t\t\t\t   make_tree (type, copy));\n+\t      type = build_pointer_type (type);\n+\t    }\n+\t}\n+\n+      mode = TYPE_MODE (type);\n+      unsignedp = TREE_UNSIGNED (type);\n+\n+#ifdef PROMOTE_FUNCTION_ARGS\n+      mode = promote_mode (type, mode, &unsignedp, 1);\n+#endif\n+\n+      args[i].unsignedp = unsignedp;\n+      args[i].mode = mode;\n+      args[i].reg = FUNCTION_ARG (args_so_far, mode, type,\n+\t\t\t\t  argpos < n_named_args);\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+      if (args[i].reg)\n+\targs[i].partial\n+\t  = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, type,\n+\t\t\t\t\targpos < n_named_args);\n+#endif\n+\n+      args[i].pass_on_stack = MUST_PASS_IN_STACK (mode, type);\n+\n+      /* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]),\n+\t it means that we are to pass this arg in the register(s) designated\n+\t by the PARALLEL, but also to pass it in the stack.  */\n+      if (args[i].reg && GET_CODE (args[i].reg) == PARALLEL\n+\t  && XEXP (XVECEXP (args[i].reg, 0, 0), 0) == 0)\n+\targs[i].pass_on_stack = 1;\n+\n+      /* If this is an addressable type, we must preallocate the stack\n+\t since we must evaluate the object into its final location.\n+\n+\t If this is to be passed in both registers and the stack, it is simpler\n+\t to preallocate.  */\n+      if (TREE_ADDRESSABLE (type)\n+\t  || (args[i].pass_on_stack && args[i].reg != 0))\n+\t*must_preallocate = 1;\n+\n+      /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n+\t we cannot consider this function call constant.  */\n+      if (TREE_ADDRESSABLE (type))\n+\t*is_const = 0;\n+\n+      /* Compute the stack-size of this argument.  */\n+      if (args[i].reg == 0 || args[i].partial != 0\n+\t  || reg_parm_stack_space > 0\n+\t  || args[i].pass_on_stack)\n+\tlocate_and_pad_parm (mode, type,\n+#ifdef STACK_PARMS_IN_REG_PARM_AREA\n+\t\t\t     1,\n+#else\n+\t\t\t     args[i].reg != 0,\n+#endif\n+\t\t\t     fndecl, args_size, &args[i].offset,\n+\t\t\t     &args[i].size);\n+\n+#ifndef ARGS_GROW_DOWNWARD\n+      args[i].slot_offset = *args_size;\n+#endif\n+\n+      /* If a part of the arg was put into registers,\n+\t don't include that part in the amount pushed.  */\n+      if (reg_parm_stack_space == 0 && ! args[i].pass_on_stack)\n+\targs[i].size.constant -= ((args[i].partial * UNITS_PER_WORD)\n+\t\t\t\t  / (PARM_BOUNDARY / BITS_PER_UNIT)\n+\t\t\t\t  * (PARM_BOUNDARY / BITS_PER_UNIT));\n+      \n+      /* Update ARGS_SIZE, the total stack space for args so far.  */\n+\n+      args_size->constant += args[i].size.constant;\n+      if (args[i].size.var)\n+\t{\n+\t  ADD_PARM_SIZE (*args_size, args[i].size.var);\n+\t}\n+\n+      /* Since the slot offset points to the bottom of the slot,\n+\t we must record it after incrementing if the args grow down.  */\n+#ifdef ARGS_GROW_DOWNWARD\n+      args[i].slot_offset = *args_size;\n+\n+      args[i].slot_offset.constant = -args_size->constant;\n+      if (args_size->var)\n+\t{\n+\t  SUB_PARM_SIZE (args[i].slot_offset, args_size->var);\n+\t}\n+#endif\n+\n+      /* Increment ARGS_SO_FAR, which has info about which arg-registers\n+\t have been used, etc.  */\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far, TYPE_MODE (type), type,\n+\t\t\t    argpos < n_named_args);\n+    }\n+}\n+\n /* Update ARGS_SIZE to contain the total size for the argument block.\n    Return the original constant component of the argument block's size.\n \n@@ -1071,8 +1359,6 @@ expand_call (exp, target, ignore)\n   /* Number of named args.  Args after this are anonymous ones\n      and they must all go on the stack.  */\n   int n_named_args;\n-  /* Count arg position in order args appear.  */\n-  int argpos;\n \n   /* Vector of information about each argument.\n      Arguments are numbered in the order they will be pushed,\n@@ -1104,8 +1390,6 @@ expand_call (exp, target, ignore)\n   /* Size of the stack reserved for parameter registers.  */\n   int reg_parm_stack_space = 0;\n \n-  /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n-  int inc;\n   /* Address of space preallocated for stack parms\n      (on machines that lack push insns), or 0 if space not preallocated.  */\n   rtx argblock = 0;\n@@ -1477,237 +1761,13 @@ expand_call (exp, target, ignore)\n   args = (struct arg_data *) alloca (num_actuals * sizeof (struct arg_data));\n   bzero ((char *) args, num_actuals * sizeof (struct arg_data));\n \n-  args_size.constant = 0;\n-  args_size.var = 0;\n-\n-  /* In this loop, we consider args in the order they are written.\n-     We fill up ARGS from the front or from the back if necessary\n-     so that in any case the first arg to be pushed ends up at the front.  */\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  i = num_actuals - 1, inc = -1;\n-  /* In this case, must reverse order of args\n-     so that we compute and push the last arg first.  */\n-#else\n-  i = 0, inc = 1;\n-#endif\n-\n-  /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n-  for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), i += inc, argpos++)\n-    {\n-      tree type = TREE_TYPE (TREE_VALUE (p));\n-      int unsignedp;\n-      enum machine_mode mode;\n-\n-      args[i].tree_value = TREE_VALUE (p);\n-\n-      /* Replace erroneous argument with constant zero.  */\n-      if (type == error_mark_node || TYPE_SIZE (type) == 0)\n-\targs[i].tree_value = integer_zero_node, type = integer_type_node;\n-\n-      /* If TYPE is a transparent union, pass things the way we would\n-\t pass the first field of the union.  We have already verified that\n-\t the modes are the same.  */\n-      if (TYPE_TRANSPARENT_UNION (type))\n-\ttype = TREE_TYPE (TYPE_FIELDS (type));\n-\n-      /* Decide where to pass this arg.\n-\n-\t args[i].reg is nonzero if all or part is passed in registers.\n-\n-\t args[i].partial is nonzero if part but not all is passed in registers,\n-\t and the exact value says how many words are passed in registers.\n-\n-\t args[i].pass_on_stack is nonzero if the argument must at least be\n-\t computed on the stack.  It may then be loaded back into registers\n-\t if args[i].reg is nonzero.\n-\n-\t These decisions are driven by the FUNCTION_... macros and must agree\n-\t with those made by function.c.  */\n-\n-      /* See if this argument should be passed by invisible reference.  */\n-      if ((TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t   && contains_placeholder_p (TYPE_SIZE (type)))\n-\t  || TREE_ADDRESSABLE (type)\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-\t  || FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, TYPE_MODE (type),\n-\t\t\t\t\t     type, argpos < n_named_args)\n-#endif\n-\t  )\n-\t{\n-\t  /* If we're compiling a thunk, pass through invisible\n-             references instead of making a copy.  */\n-\t  if (current_function_is_thunk\n-#ifdef FUNCTION_ARG_CALLEE_COPIES\n-\t      || (FUNCTION_ARG_CALLEE_COPIES (args_so_far, TYPE_MODE (type),\n-\t\t\t\t\t     type, argpos < n_named_args)\n-\t\t  /* If it's in a register, we must make a copy of it too.  */\n-\t\t  /* ??? Is this a sufficient test?  Is there a better one? */\n-\t\t  && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n-\t\t       && REG_P (DECL_RTL (args[i].tree_value)))\n-\t\t  && ! TREE_ADDRESSABLE (type))\n-#endif\n-\t      )\n-\t    {\n-\t      /* C++ uses a TARGET_EXPR to indicate that we want to make a\n-\t         new object from the argument.  If we are passing by\n-\t         invisible reference, the callee will do that for us, so we\n-\t         can strip off the TARGET_EXPR.  This is not always safe,\n-\t         but it is safe in the only case where this is a useful\n-\t         optimization; namely, when the argument is a plain object.\n-\t         In that case, the frontend is just asking the backend to\n-\t         make a bitwise copy of the argument. */\n-\t\t \n-\t      if (TREE_CODE (args[i].tree_value) == TARGET_EXPR\n-\t\t  && (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND\n-\t\t\t\t\t\t  (args[i].tree_value, 1)))\n-\t\t      == 'd')\n-\t\t  && ! REG_P (DECL_RTL (TREE_OPERAND (args[i].tree_value, 1))))\n-\t\targs[i].tree_value = TREE_OPERAND (args[i].tree_value, 1);\n-\n-\t      args[i].tree_value = build1 (ADDR_EXPR,\n-\t\t\t\t\t   build_pointer_type (type),\n-\t\t\t\t\t   args[i].tree_value);\n-\t      type = build_pointer_type (type);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We make a copy of the object and pass the address to the\n-\t\t function being called.  */\n-\t      rtx copy;\n-\n-\t      if (TYPE_SIZE (type) == 0\n-\t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t\t  || (flag_stack_check && ! STACK_CHECK_BUILTIN\n-\t\t      && (TREE_INT_CST_HIGH (TYPE_SIZE (type)) != 0\n-\t\t\t  || (TREE_INT_CST_LOW (TYPE_SIZE (type))\n-\t\t\t      > STACK_CHECK_MAX_VAR_SIZE * BITS_PER_UNIT))))\n-\t\t{\n-\t\t  /* This is a variable-sized object.  Make space on the stack\n-\t\t     for it.  */\n-\t\t  rtx size_rtx = expr_size (TREE_VALUE (p));\n-\n-\t\t  if (old_stack_level == 0)\n-\t\t    {\n-\t\t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t\t      old_pending_adj = pending_stack_adjust;\n-\t\t      pending_stack_adjust = 0;\n-\t\t    }\n-\n-\t\t  copy = gen_rtx_MEM (BLKmode,\n-\t\t\t\t      allocate_dynamic_stack_space (size_rtx,\n-\t\t\t\t\t\t\t\t    NULL_RTX,\n-\t\t\t\t\t\t\t\t    TYPE_ALIGN (type)));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int size = int_size_in_bytes (type);\n-\t\t  copy = assign_stack_temp (TYPE_MODE (type), size, 0);\n-\t\t}\n-\n-\t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n-\n-\t      store_expr (args[i].tree_value, copy, 0);\n-\t      is_const = 0;\n-\n-\t      args[i].tree_value = build1 (ADDR_EXPR,\n-\t\t\t\t\t   build_pointer_type (type),\n-\t\t\t\t\t   make_tree (type, copy));\n-\t      type = build_pointer_type (type);\n-\t    }\n-\t}\n-\n-      mode = TYPE_MODE (type);\n-      unsignedp = TREE_UNSIGNED (type);\n-\n-#ifdef PROMOTE_FUNCTION_ARGS\n-      mode = promote_mode (type, mode, &unsignedp, 1);\n-#endif\n-\n-      args[i].unsignedp = unsignedp;\n-      args[i].mode = mode;\n-      args[i].reg = FUNCTION_ARG (args_so_far, mode, type,\n-\t\t\t\t  argpos < n_named_args);\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-      if (args[i].reg)\n-\targs[i].partial\n-\t  = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, type,\n-\t\t\t\t\targpos < n_named_args);\n-#endif\n-\n-      args[i].pass_on_stack = MUST_PASS_IN_STACK (mode, type);\n-\n-      /* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]),\n-\t it means that we are to pass this arg in the register(s) designated\n-\t by the PARALLEL, but also to pass it in the stack.  */\n-      if (args[i].reg && GET_CODE (args[i].reg) == PARALLEL\n-\t  && XEXP (XVECEXP (args[i].reg, 0, 0), 0) == 0)\n-\targs[i].pass_on_stack = 1;\n-\n-      /* If this is an addressable type, we must preallocate the stack\n-\t since we must evaluate the object into its final location.\n-\n-\t If this is to be passed in both registers and the stack, it is simpler\n-\t to preallocate.  */\n-      if (TREE_ADDRESSABLE (type)\n-\t  || (args[i].pass_on_stack && args[i].reg != 0))\n-\tmust_preallocate = 1;\n-\n-      /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n-\t we cannot consider this function call constant.  */\n-      if (TREE_ADDRESSABLE (type))\n-\tis_const = 0;\n-\n-      /* Compute the stack-size of this argument.  */\n-      if (args[i].reg == 0 || args[i].partial != 0\n-\t  || reg_parm_stack_space > 0\n-\t  || args[i].pass_on_stack)\n-\tlocate_and_pad_parm (mode, type,\n-#ifdef STACK_PARMS_IN_REG_PARM_AREA\n-\t\t\t     1,\n-#else\n-\t\t\t     args[i].reg != 0,\n-#endif\n-\t\t\t     fndecl, &args_size, &args[i].offset,\n-\t\t\t     &args[i].size);\n-\n-#ifndef ARGS_GROW_DOWNWARD\n-      args[i].slot_offset = args_size;\n-#endif\n-\n-      /* If a part of the arg was put into registers,\n-\t don't include that part in the amount pushed.  */\n-      if (reg_parm_stack_space == 0 && ! args[i].pass_on_stack)\n-\targs[i].size.constant -= ((args[i].partial * UNITS_PER_WORD)\n-\t\t\t\t  / (PARM_BOUNDARY / BITS_PER_UNIT)\n-\t\t\t\t  * (PARM_BOUNDARY / BITS_PER_UNIT));\n-      \n-      /* Update ARGS_SIZE, the total stack space for args so far.  */\n-\n-      args_size.constant += args[i].size.constant;\n-      if (args[i].size.var)\n-\t{\n-\t  ADD_PARM_SIZE (args_size, args[i].size.var);\n-\t}\n-\n-      /* Since the slot offset points to the bottom of the slot,\n-\t we must record it after incrementing if the args grow down.  */\n-#ifdef ARGS_GROW_DOWNWARD\n-      args[i].slot_offset = args_size;\n-\n-      args[i].slot_offset.constant = -args_size.constant;\n-      if (args_size.var)\n-\t{\n-\t  SUB_PARM_SIZE (args[i].slot_offset, args_size.var);\n-\t}\n-#endif\n-\n-      /* Increment ARGS_SO_FAR, which has info about which arg-registers\n-\t have been used, etc.  */\n-\n-      FUNCTION_ARG_ADVANCE (args_so_far, TYPE_MODE (type), type,\n-\t\t\t    argpos < n_named_args);\n-    }\n+  /* Build up entries inthe ARGS array, compute the size of the arguments\n+     into ARGS_SIZE, etc.  */\n+  initialize_argument_information (num_actuals, args, &args_size, n_named_args,\n+\t\t\t\t   actparms, fndecl, args_so_far,\n+\t\t\t\t   reg_parm_stack_space, &old_stack_level,\n+\t\t\t\t   &old_pending_adj, &must_preallocate,\n+\t\t\t\t   &is_const);\n \n #ifdef FINAL_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,"}]}