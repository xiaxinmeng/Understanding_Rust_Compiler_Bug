{"sha": "8636f52f7b50176948646cc151bfd514b8b71c03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYzNmY1MmY3YjUwMTc2OTQ4NjQ2Y2MxNTFiZmQ1MTRiOGI3MWMwMw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-01-07T08:41:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-07T08:41:47Z"}, "message": "2015-01-07  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* alloc.ads Alphabetize several declarations. Add constants\n\tIgnored_Ghost_Units_Initial and Ignored_Ghost_Units_Increment.\n\t* atree.adb Add with and use clauses for Opt.\n\t(Allocate_Initialize_Node): Mark a node as ignored Ghost\n\tif it is created in an ignored Ghost region.\n\t(Ekind_In): New variant.\n\t(Is_Ignored_Ghost_Node): New routine.\n\t(Set_Is_Ignored_Ghost_Node): New routine.\n\t* atree.adb Aplhabetize several subprograms declarations. Flag\n\tSpare0 is now known as Is_Ignored_Ghost_Node.\n\t(Ekind_In): New variant.\n\t(Is_Ignored_Ghost_Node): New routine.\n\t(Set_Is_Ignored_Ghost_Node): New routine.\n\t* einfo.adb: Flag 279 is now known as Contains_Ignored_Ghost_Code.\n\t(Contains_Ignored_Ghost_Code): New routine.\n\t(Set_Contains_Ignored_Ghost_Code): New routine.\n\t(Set_Is_Checked_Ghost_Entity, Set_Is_Ignored_Ghost_Entity):\n\tIt is now possible to set this property on an unanalyzed entity.\n\t(Write_Entity_Flags): Output the status of flag\n\tContains_Ignored_Ghost_Code.\n\t* einfo.ads New attribute Contains_Ignored_Ghost_Code along with\n\tusage in nodes.\n\t(Contains_Ignored_Ghost_Code): New routine\n\talong with pragma Inline.\n\t(Set_Contains_Ignored_Ghost_Code): New routine along with pragma Inline.\n\t* exp_ch3.adb Add with and use clauses for Ghost.\n\t(Freeze_Type): Capture/restore the value of Ghost_Mode on entry/exit.\n\tSet the Ghost_Mode in effect.\n\t(Restore_Globals): New routine.\n\t* exp_ch7.adb (Process_Declarations): Do not process a context\n\tthat invoves an ignored Ghost entity.\n\t* exp_dbug.adb (Qualify_All_Entity_Names): Skip an ignored Ghost\n\tconstruct that has been rewritten as a null statement.\n\t* exp_disp.adb Add with and use clauses for Ghost.\n\t(Make_DT): Capture/restore the value of Ghost_Mode on entry/exit. Set\n\tthe Ghost_Mode in effect.\n\t(Restore_Globals): New routine.\n\t* exp_util.adb (Requires_Cleanup_Actions): An ignored Ghost entity\n\tdoes not require any clean up. Add two missing cases that deal\n\twith block statements.\n\t* freeze.adb Add with and use clauses for Ghost.\n\t(Freeze_Entity): Capture/restore the value of Ghost_Mode on entry/exit.\n\tSet the Ghost_Mode in effect.\n\t(Restore_Globals): New routine.\n\t* frontend.adb Add with and use clauses for Ghost. Remove any\n\tignored Ghost code from all units that qualify.\n\t* ghost.adb New unit.\n\t* ghost.ads New unit.\n\t* gnat1drv.adb Add with clause for Ghost. Initialize and lock\n\tthe table in package Ghost.\n\t* lib.ads: Alphabetize several subprogram declarations.\n\t* lib-xref.adb (Output_References): Do not generate reference\n\tinformation for ignored Ghost entities.\n\t* opt.ads Add new type Ghost_Mode_Type and new global variable\n\tGhost_Mode.\n\t* rtsfind.adb (Load_RTU): Provide a clean environment when\n\tloading a runtime unit.\n\t* sem.adb (Analyze): Capture/restore the value of Ghost_Mode on\n\tentry/exit as the node may set a different mode.\n\t(Do_Analyze):\n\tCapture/restore the value of Ghost_Mode on entry/exit as the\n\tunit may be withed from a unit with a different Ghost mode.\n\t* sem_ch3.adb Add with and use clauses for Ghost.\n\t(Analyze_Full_Type_Declaration, Analyze_Incomplete_Type_Decl,\n\tAnalyze_Number_Declaration, Analyze_Private_Extension_Declaration,\n\tAnalyze_Subtype_Declaration): Set the Ghost_Mode in effect. Mark\n\tthe entity as Ghost when there is a Ghost_Mode in effect.\n\t(Array_Type_Declaration): The implicit base type inherits the\n\t\"ghostness\" from the array type.\n\t(Derive_Subprogram): The\n\talias inherits the \"ghostness\" from the parent subprogram.\n\t(Make_Implicit_Base): The implicit base type inherits the\n\t\"ghostness\" from the parent type.\n\t* sem_ch5.adb Add with and use clauses for Ghost.\n\t(Analyze_Assignment): Set the Ghost_Mode in effect.\n\t* sem_ch6.adb Add with and use clauses for Ghost.\n\t(Analyze_Abstract_Subprogram_Declaration, Analyze_Procedure_Call,\n\tAnalyze_Subprogram_Body_Helper, Analyze_Subprogram_Declaration):\n\tSet the Ghost_Mode in effect. Mark the entity as Ghost when\n\tthere is a Ghost_Mode in effect.\n\t* sem_ch7.adb Add with and use clauses for Ghost.\n\t(Analyze_Package_Body_Helper, Analyze_Package_Declaration,\n\tAnalyze_Private_Type_Declaration): Set the Ghost_Mode in\n\teffect. Mark the entity as Ghost when there is a Ghost_Mode\n\tin effect.\n\t* sem_ch8.adb Add with and use clauses for Ghost.\n\t(Analyze_Exception_Renaming, Analyze_Generic_Renaming,\n\tAnalyze_Object_Renaming, Analyze_Package_Renaming,\n\tAnalyze_Subprogram_Renaming): Set the Ghost_Mode in effect. Mark\n\tthe entity as Ghost when there is a Ghost_Mode in effect.\n\t(Find_Type): Check the Ghost context of a type.\n\t* sem_ch11.adb Add with and use clauses for Ghost.\n\t(Analyze_Exception_Declaration): Set the Ghost_Mode in\n\teffect. Mark the entity as Ghost when there is a Ghost_Mode\n\tin effect.\n\t* sem_ch12.adb Add with and use clauses for Ghost.\n\t(Analyze_Generic_Package_Declaration,\n\tAnalyze_Generic_Subprogram_Declaration): Set the Ghost_Mode in effect.\n\tMark the entity as Ghost when there is a Ghost_Mode in effect.\n\t* sem_prag.adb Add with and use clauses for Ghost.\n\t(Analyze_Pragma): Ghost-related checks are triggered when there\n\tis a Ghost mode in effect.\n\t(Create_Abstract_State): Mark the\n\tentity as Ghost when there is a Ghost_Mode in effect.\n\t* sem_res.adb Add with and use clauses for Ghost.\n\t(Check_Ghost_Context): Removed.\n\t* sem_util.adb (Check_Ghost_Completion): Removed.\n\t(Check_Ghost_Derivation): Removed.\n\t(Incomplete_Or_Partial_View):\n\tAdd a guard in case the entity has not been analyzed yet\n\tand does carry a scope.\n\t(Is_Declaration): New routine.\n\t(Is_Ghost_Entity): Removed.\n\t(Is_Ghost_Statement_Or_Pragma):\n\tRemoved.\n\t(Is_Subject_To_Ghost): Removed.\n\t(Set_Is_Ghost_Entity):\n\tRemoved.\n\t(Within_Ghost_Scope): Removed.\n\t* sem_util.adb (Check_Ghost_Completion): Removed.\n\t(Check_Ghost_Derivation): Removed.\n\t(Is_Declaration): New routine.\n\t(Is_Ghost_Entity): Removed.\n\t(Is_Ghost_Statement_Or_Pragma): Removed.\n\t(Is_Subject_To_Ghost): Removed.\n\t(Set_Is_Ghost_Entity): Removed.\n\t(Within_Ghost_Scope): Removed.\n\t* sinfo.ads Add a section on Ghost mode.\n\t* treepr.adb (Print_Header_Flag): New routine.\n\t(Print_Node_Header): Factor out code. Output flag\n\tIs_Ignored_Ghost_Node.\n\t* gcc-interface/Make-lang.in: Add dependency for unit Ghost.\n\nFrom-SVN: r219280", "tree": {"sha": "39cc0e2d60bd238be63e41b7c58c3559dddab13f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39cc0e2d60bd238be63e41b7c58c3559dddab13f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8636f52f7b50176948646cc151bfd514b8b71c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8636f52f7b50176948646cc151bfd514b8b71c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8636f52f7b50176948646cc151bfd514b8b71c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8636f52f7b50176948646cc151bfd514b8b71c03/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a9a42abc4f30bd63ef666e972dcbce0f05f0d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a9a42abc4f30bd63ef666e972dcbce0f05f0d0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a9a42abc4f30bd63ef666e972dcbce0f05f0d0d"}], "stats": {"total": 3280, "additions": 2281, "deletions": 999}, "files": [{"sha": "39b20091d498a2ab79a6be38ec1d959e711130b9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -1,3 +1,138 @@\n+2015-01-07  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* alloc.ads Alphabetize several declarations. Add constants\n+\tIgnored_Ghost_Units_Initial and Ignored_Ghost_Units_Increment.\n+\t* atree.adb Add with and use clauses for Opt.\n+\t(Allocate_Initialize_Node): Mark a node as ignored Ghost\n+\tif it is created in an ignored Ghost region.\n+\t(Ekind_In): New variant.\n+\t(Is_Ignored_Ghost_Node): New routine.\n+\t(Set_Is_Ignored_Ghost_Node): New routine.\n+\t* atree.adb Aplhabetize several subprograms declarations. Flag\n+\tSpare0 is now known as Is_Ignored_Ghost_Node.\n+\t(Ekind_In): New variant.\n+\t(Is_Ignored_Ghost_Node): New routine.\n+\t(Set_Is_Ignored_Ghost_Node): New routine.\n+\t* einfo.adb: Flag 279 is now known as Contains_Ignored_Ghost_Code.\n+\t(Contains_Ignored_Ghost_Code): New routine.\n+\t(Set_Contains_Ignored_Ghost_Code): New routine.\n+\t(Set_Is_Checked_Ghost_Entity, Set_Is_Ignored_Ghost_Entity):\n+\tIt is now possible to set this property on an unanalyzed entity.\n+\t(Write_Entity_Flags): Output the status of flag\n+\tContains_Ignored_Ghost_Code.\n+\t* einfo.ads New attribute Contains_Ignored_Ghost_Code along with\n+\tusage in nodes.\n+\t(Contains_Ignored_Ghost_Code): New routine\n+\talong with pragma Inline.\n+\t(Set_Contains_Ignored_Ghost_Code): New routine along with pragma Inline.\n+\t* exp_ch3.adb Add with and use clauses for Ghost.\n+\t(Freeze_Type): Capture/restore the value of Ghost_Mode on entry/exit.\n+\tSet the Ghost_Mode in effect.\n+\t(Restore_Globals): New routine.\n+\t* exp_ch7.adb (Process_Declarations): Do not process a context\n+\tthat invoves an ignored Ghost entity.\n+\t* exp_dbug.adb (Qualify_All_Entity_Names): Skip an ignored Ghost\n+\tconstruct that has been rewritten as a null statement.\n+\t* exp_disp.adb Add with and use clauses for Ghost.\n+\t(Make_DT): Capture/restore the value of Ghost_Mode on entry/exit. Set\n+\tthe Ghost_Mode in effect.\n+\t(Restore_Globals): New routine.\n+\t* exp_util.adb (Requires_Cleanup_Actions): An ignored Ghost entity\n+\tdoes not require any clean up. Add two missing cases that deal\n+\twith block statements.\n+\t* freeze.adb Add with and use clauses for Ghost.\n+\t(Freeze_Entity): Capture/restore the value of Ghost_Mode on entry/exit.\n+\tSet the Ghost_Mode in effect.\n+\t(Restore_Globals): New routine.\n+\t* frontend.adb Add with and use clauses for Ghost. Remove any\n+\tignored Ghost code from all units that qualify.\n+\t* ghost.adb New unit.\n+\t* ghost.ads New unit.\n+\t* gnat1drv.adb Add with clause for Ghost. Initialize and lock\n+\tthe table in package Ghost.\n+\t* lib.ads: Alphabetize several subprogram declarations.\n+\t* lib-xref.adb (Output_References): Do not generate reference\n+\tinformation for ignored Ghost entities.\n+\t* opt.ads Add new type Ghost_Mode_Type and new global variable\n+\tGhost_Mode.\n+\t* rtsfind.adb (Load_RTU): Provide a clean environment when\n+\tloading a runtime unit.\n+\t* sem.adb (Analyze): Capture/restore the value of Ghost_Mode on\n+\tentry/exit as the node may set a different mode.\n+\t(Do_Analyze):\n+\tCapture/restore the value of Ghost_Mode on entry/exit as the\n+\tunit may be withed from a unit with a different Ghost mode.\n+\t* sem_ch3.adb Add with and use clauses for Ghost.\n+\t(Analyze_Full_Type_Declaration, Analyze_Incomplete_Type_Decl,\n+\tAnalyze_Number_Declaration, Analyze_Private_Extension_Declaration,\n+\tAnalyze_Subtype_Declaration): Set the Ghost_Mode in effect. Mark\n+\tthe entity as Ghost when there is a Ghost_Mode in effect.\n+\t(Array_Type_Declaration): The implicit base type inherits the\n+\t\"ghostness\" from the array type.\n+\t(Derive_Subprogram): The\n+\talias inherits the \"ghostness\" from the parent subprogram.\n+\t(Make_Implicit_Base): The implicit base type inherits the\n+\t\"ghostness\" from the parent type.\n+\t* sem_ch5.adb Add with and use clauses for Ghost.\n+\t(Analyze_Assignment): Set the Ghost_Mode in effect.\n+\t* sem_ch6.adb Add with and use clauses for Ghost.\n+\t(Analyze_Abstract_Subprogram_Declaration, Analyze_Procedure_Call,\n+\tAnalyze_Subprogram_Body_Helper, Analyze_Subprogram_Declaration):\n+\tSet the Ghost_Mode in effect. Mark the entity as Ghost when\n+\tthere is a Ghost_Mode in effect.\n+\t* sem_ch7.adb Add with and use clauses for Ghost.\n+\t(Analyze_Package_Body_Helper, Analyze_Package_Declaration,\n+\tAnalyze_Private_Type_Declaration): Set the Ghost_Mode in\n+\teffect. Mark the entity as Ghost when there is a Ghost_Mode\n+\tin effect.\n+\t* sem_ch8.adb Add with and use clauses for Ghost.\n+\t(Analyze_Exception_Renaming, Analyze_Generic_Renaming,\n+\tAnalyze_Object_Renaming, Analyze_Package_Renaming,\n+\tAnalyze_Subprogram_Renaming): Set the Ghost_Mode in effect. Mark\n+\tthe entity as Ghost when there is a Ghost_Mode in effect.\n+\t(Find_Type): Check the Ghost context of a type.\n+\t* sem_ch11.adb Add with and use clauses for Ghost.\n+\t(Analyze_Exception_Declaration): Set the Ghost_Mode in\n+\teffect. Mark the entity as Ghost when there is a Ghost_Mode\n+\tin effect.\n+\t* sem_ch12.adb Add with and use clauses for Ghost.\n+\t(Analyze_Generic_Package_Declaration,\n+\tAnalyze_Generic_Subprogram_Declaration): Set the Ghost_Mode in effect.\n+\tMark the entity as Ghost when there is a Ghost_Mode in effect.\n+\t* sem_prag.adb Add with and use clauses for Ghost.\n+\t(Analyze_Pragma): Ghost-related checks are triggered when there\n+\tis a Ghost mode in effect.\n+\t(Create_Abstract_State): Mark the\n+\tentity as Ghost when there is a Ghost_Mode in effect.\n+\t* sem_res.adb Add with and use clauses for Ghost.\n+\t(Check_Ghost_Context): Removed.\n+\t* sem_util.adb (Check_Ghost_Completion): Removed.\n+\t(Check_Ghost_Derivation): Removed.\n+\t(Incomplete_Or_Partial_View):\n+\tAdd a guard in case the entity has not been analyzed yet\n+\tand does carry a scope.\n+\t(Is_Declaration): New routine.\n+\t(Is_Ghost_Entity): Removed.\n+\t(Is_Ghost_Statement_Or_Pragma):\n+\tRemoved.\n+\t(Is_Subject_To_Ghost): Removed.\n+\t(Set_Is_Ghost_Entity):\n+\tRemoved.\n+\t(Within_Ghost_Scope): Removed.\n+\t* sem_util.adb (Check_Ghost_Completion): Removed.\n+\t(Check_Ghost_Derivation): Removed.\n+\t(Is_Declaration): New routine.\n+\t(Is_Ghost_Entity): Removed.\n+\t(Is_Ghost_Statement_Or_Pragma): Removed.\n+\t(Is_Subject_To_Ghost): Removed.\n+\t(Set_Is_Ghost_Entity): Removed.\n+\t(Within_Ghost_Scope): Removed.\n+\t* sinfo.ads Add a section on Ghost mode.\n+\t* treepr.adb (Print_Header_Flag): New routine.\n+\t(Print_Node_Header): Factor out code. Output flag\n+\tIs_Ignored_Ghost_Node.\n+\t* gcc-interface/Make-lang.in: Add dependency for unit Ghost.\n+\n 2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* freeze.adb (Freeze_Array_Type) <Complain_CS>: Remove always"}, {"sha": "e175f8b433d7f13383c46b18ef965b80664dc47a", "filename": "gcc/ada/alloc.ads", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,14 +64,17 @@ package Alloc is\n    File_Name_Chars_Initial          : constant := 10_000;  -- Osint\n    File_Name_Chars_Increment        : constant := 100;\n \n-   Inlined_Bodies_Initial           : constant := 50;      -- Inline\n-   Inlined_Bodies_Increment         : constant := 200;\n+   In_Out_Warnings_Initial          : constant := 100;     -- Sem_Warn\n+   In_Out_Warnings_Increment        : constant := 100;\n+\n+   Ignored_Ghost_Units_Initial      : constant := 20;      -- Sem_Util\n+   Ignored_Ghost_Units_Increment    : constant := 50;\n \n    Inlined_Initial                  : constant := 100;     -- Inline\n    Inlined_Increment                : constant := 100;\n \n-   In_Out_Warnings_Initial          : constant := 100;     -- Sem_Warn\n-   In_Out_Warnings_Increment        : constant := 100;\n+   Inlined_Bodies_Initial           : constant := 50;      -- Inline\n+   Inlined_Bodies_Increment         : constant := 200;\n \n    Interp_Map_Initial               : constant := 200;     -- Sem_Type\n    Interp_Map_Increment             : constant := 100;"}, {"sha": "3264ac37867f92db0fe39da27170dedce49af9ad", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -39,6 +39,7 @@ pragma Style_Checks (All_Checks);\n with Aspects; use Aspects;\n with Debug;   use Debug;\n with Nlists;  use Nlists;\n+with Opt;     use Opt;\n with Output;  use Output;\n with Sinput;  use Sinput;\n with Tree_IO; use Tree_IO;\n@@ -569,10 +570,10 @@ package body Atree is\n       then\n          New_Id := Src;\n \n-      else\n-         --  We are allocating a new node, or extending a node\n-         --  other than Nodes.Last.\n+      --  We are allocating a new node, or extending a node other than\n+      --  Nodes.Last.\n \n+      else\n          if Present (Src) then\n             Nodes.Append (Nodes.Table (Src));\n             Flags.Append (Flags.Table (Src));\n@@ -586,6 +587,13 @@ package body Atree is\n          Node_Count := Node_Count + 1;\n       end if;\n \n+      --  Mark the node as ignored Ghost if it is created in an ignored Ghost\n+      --  region.\n+\n+      if Ghost_Mode = Ignore then\n+         Set_Is_Ignored_Ghost_Node (New_Id);\n+      end if;\n+\n       --  Specifically copy Paren_Count to deal with creating new table entry\n       --  if the parentheses count is at the maximum possible value already.\n \n@@ -1079,6 +1087,30 @@ package body Atree is\n              T = V8;\n    end Ekind_In;\n \n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind;\n+      V9 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6 or else\n+             T = V7 or else\n+             T = V8 or else\n+             T = V9;\n+   end Ekind_In;\n+\n    function Ekind_In\n      (E  : Entity_Id;\n       V1 : Entity_Kind;\n@@ -1163,6 +1195,22 @@ package body Atree is\n       return Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6, V7, V8);\n    end Ekind_In;\n \n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind;\n+      V9 : Entity_Kind) return Boolean\n+   is\n+   begin\n+      return Ekind_In (Ekind (E), V1, V2, V3, V4, V5, V6, V7, V8, V9);\n+   end Ekind_In;\n+\n    ------------------------\n    -- Set_Reporting_Proc --\n    ------------------------\n@@ -1382,6 +1430,15 @@ package body Atree is\n       Set_Error_Posted (Error, True);\n    end Initialize;\n \n+   ---------------------------\n+   -- Is_Ignored_Ghost_Node --\n+   ---------------------------\n+\n+   function Is_Ignored_Ghost_Node (N : Node_Id) return Boolean is\n+   begin\n+      return Flags.Table (N).Is_Ignored_Ghost_Node;\n+   end Is_Ignored_Ghost_Node;\n+\n    --------------------------\n    -- Is_Rewrite_Insertion --\n    --------------------------\n@@ -2031,6 +2088,15 @@ package body Atree is\n       Nodes.Table (N).Has_Aspects := Val;\n    end Set_Has_Aspects;\n \n+   -------------------------------\n+   -- Set_Is_Ignored_Ghost_Node --\n+   -------------------------------\n+\n+   procedure Set_Is_Ignored_Ghost_Node (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      Flags.Table (N).Is_Ignored_Ghost_Node := Val;\n+   end Set_Is_Ignored_Ghost_Node;\n+\n    -----------------------\n    -- Set_Original_Node --\n    -----------------------"}, {"sha": "7d2e64f4f88f4d9b2b5351517fdd3e5b02c539d4", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 70, "deletions": 34, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -605,42 +605,46 @@ package Atree is\n    --  The following functions return the contents of the indicated field of\n    --  the node referenced by the argument, which is a Node_Id.\n \n-   function Nkind             (N : Node_Id) return Node_Kind;\n-   pragma Inline (Nkind);\n-\n    function Analyzed          (N : Node_Id) return Boolean;\n    pragma Inline (Analyzed);\n \n-   function Has_Aspects       (N : Node_Id) return Boolean;\n-   pragma Inline (Has_Aspects);\n-\n    function Comes_From_Source (N : Node_Id) return Boolean;\n    pragma Inline (Comes_From_Source);\n \n    function Error_Posted      (N : Node_Id) return Boolean;\n    pragma Inline (Error_Posted);\n \n-   function Sloc              (N : Node_Id) return Source_Ptr;\n-   pragma Inline (Sloc);\n+   function Has_Aspects       (N : Node_Id) return Boolean;\n+   pragma Inline (Has_Aspects);\n \n-   function Paren_Count       (N : Node_Id) return Nat;\n-   pragma Inline (Paren_Count);\n+   function Is_Ignored_Ghost_Node\n+                              (N : Node_Id) return Boolean;\n+   pragma Inline (Is_Ignored_Ghost_Node);\n \n-   function Parent            (N : Node_Id) return Node_Id;\n-   pragma Inline (Parent);\n-   --  Returns the parent of a node if the node is not a list member, or else\n-   --  the parent of the list containing the node if the node is a list member.\n+   function Nkind             (N : Node_Id) return Node_Kind;\n+   pragma Inline (Nkind);\n \n    function No                (N : Node_Id) return Boolean;\n    pragma Inline (No);\n    --  Tests given Id for equality with the Empty node. This allows notations\n    --  like \"if No (Variant_Part)\" as opposed to \"if Variant_Part = Empty\".\n \n+   function Parent            (N : Node_Id) return Node_Id;\n+   pragma Inline (Parent);\n+   --  Returns the parent of a node if the node is not a list member, or else\n+   --  the parent of the list containing the node if the node is a list member.\n+\n+   function Paren_Count       (N : Node_Id) return Nat;\n+   pragma Inline (Paren_Count);\n+\n    function Present           (N : Node_Id) return Boolean;\n    pragma Inline (Present);\n    --  Tests given Id for inequality with the Empty node. This allows notations\n    --  like \"if Present (Statement)\" as opposed to \"if Statement /= Empty\".\n \n+   function Sloc              (N : Node_Id) return Source_Ptr;\n+   pragma Inline (Sloc);\n+\n    ---------------------\n    -- Node_Kind Tests --\n    ---------------------\n@@ -784,6 +788,18 @@ package Atree is\n       V7 : Entity_Kind;\n       V8 : Entity_Kind) return Boolean;\n \n+   function Ekind_In\n+     (E  : Entity_Id;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind;\n+      V9 : Entity_Kind) return Boolean;\n+\n    function Ekind_In\n      (T  : Entity_Kind;\n       V1 : Entity_Kind;\n@@ -840,6 +856,18 @@ package Atree is\n       V7 : Entity_Kind;\n       V8 : Entity_Kind) return Boolean;\n \n+   function Ekind_In\n+     (T  : Entity_Kind;\n+      V1 : Entity_Kind;\n+      V2 : Entity_Kind;\n+      V3 : Entity_Kind;\n+      V4 : Entity_Kind;\n+      V5 : Entity_Kind;\n+      V6 : Entity_Kind;\n+      V7 : Entity_Kind;\n+      V8 : Entity_Kind;\n+      V9 : Entity_Kind) return Boolean;\n+\n    pragma Inline (Ekind_In);\n    --  Inline all above functions\n \n@@ -865,39 +893,42 @@ package Atree is\n    --  to be set in the specified field. Note that Set_Nkind is in the next\n    --  section, since its use is restricted.\n \n-   procedure Set_Sloc         (N : Node_Id; Val : Source_Ptr);\n-   pragma Inline (Set_Sloc);\n-\n-   procedure Set_Paren_Count  (N : Node_Id; Val : Nat);\n-   pragma Inline (Set_Paren_Count);\n-\n-   procedure Set_Parent       (N : Node_Id; Val : Node_Id);\n-   pragma Inline (Set_Parent);\n-\n-   procedure Set_Analyzed     (N : Node_Id; Val : Boolean := True);\n+   procedure Set_Analyzed (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Analyzed);\n \n-   procedure Set_Error_Posted (N : Node_Id; Val : Boolean := True);\n-   pragma Inline (Set_Error_Posted);\n-\n    procedure Set_Comes_From_Source (N : Node_Id; Val : Boolean);\n    pragma Inline (Set_Comes_From_Source);\n-   --  Note that this routine is very rarely used, since usually the\n-   --  default mechanism provided sets the right value, but in some\n-   --  unusual cases, the value needs to be reset (e.g. when a source\n-   --  node is copied, and the copy must not have Comes_From_Source set).\n+   --  Note that this routine is very rarely used, since usually the default\n+   --  mechanism provided sets the right value, but in some unusual cases, the\n+   --  value needs to be reset (e.g. when a source node is copied, and the copy\n+   --  must not have Comes_From_Source set).\n+\n+   procedure Set_Error_Posted (N : Node_Id; Val : Boolean := True);\n+   pragma Inline (Set_Error_Posted);\n \n    procedure Set_Has_Aspects (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Has_Aspects);\n \n+   procedure Set_Is_Ignored_Ghost_Node (N : Node_Id; Val : Boolean := True);\n+   pragma Inline (Set_Is_Ignored_Ghost_Node);\n+\n    procedure Set_Original_Node (N : Node_Id; Val : Node_Id);\n    pragma Inline (Set_Original_Node);\n    --  Note that this routine is used only in very peculiar cases. In normal\n    --  cases, the Original_Node link is set by calls to Rewrite. We currently\n-   --  use it in ASIS mode to manually set the link from pragma expressions\n-   --  to their aspect original source expressions, so that the original source\n+   --  use it in ASIS mode to manually set the link from pragma expressions to\n+   --  their aspect original source expressions, so that the original source\n    --  expressions accessed by ASIS are also semantically analyzed.\n \n+   procedure Set_Parent (N : Node_Id; Val : Node_Id);\n+   pragma Inline (Set_Parent);\n+\n+   procedure Set_Paren_Count (N : Node_Id; Val : Nat);\n+   pragma Inline (Set_Paren_Count);\n+\n+   procedure Set_Sloc (N : Node_Id; Val : Source_Ptr);\n+   pragma Inline (Set_Sloc);\n+\n    ------------------------------\n    -- Entity Update Procedures --\n    ------------------------------\n@@ -4007,7 +4038,12 @@ package Atree is\n          Flag1  : Boolean;\n          Flag2  : Boolean;\n          Flag3  : Boolean;\n-         Spare0 : Boolean;\n+\n+         Is_Ignored_Ghost_Node : Boolean;\n+         --  Flag denothing whether the node is subject to pragma Ghost with\n+         --  policy Ignore. The name of the flag should be Flag4, however this\n+         --  requires changing the names of all remaining 300+ flags.\n+\n          Spare1 : Boolean;\n          Spare2 : Boolean;\n          Spare3 : Boolean;"}, {"sha": "de4e1ef540a67a7f21c80c571fa0e566e801ec2f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -574,8 +574,8 @@ package body Einfo is\n    --    No_Dynamic_Predicate_On_Actual  Flag276\n    --    Is_Checked_Ghost_Entity         Flag277\n    --    Is_Ignored_Ghost_Entity         Flag278\n+   --    Contains_Ignored_Ghost_Code     Flag279\n \n-   --    (unused)                        Flag279\n    --    (unused)                        Flag280\n \n    --    (unused)                        Flag281\n@@ -1117,6 +1117,21 @@ package body Einfo is\n       return Node18 (Id);\n    end Entry_Index_Constant;\n \n+   function Contains_Ignored_Ghost_Code (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Block,\n+                       E_Function,\n+                       E_Generic_Function,\n+                       E_Generic_Package,\n+                       E_Generic_Procedure,\n+                       E_Package,\n+                       E_Package_Body,\n+                       E_Procedure,\n+                       E_Subprogram_Body));\n+      return Flag279 (Id);\n+   end Contains_Ignored_Ghost_Code;\n+\n    function Contract (Id : E) return N is\n    begin\n       pragma Assert\n@@ -3609,6 +3624,21 @@ package body Einfo is\n       Set_Node20 (Id, V);\n    end Set_Component_Type;\n \n+   procedure Set_Contains_Ignored_Ghost_Code (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Block,\n+                       E_Function,\n+                       E_Generic_Function,\n+                       E_Generic_Package,\n+                       E_Generic_Procedure,\n+                       E_Package,\n+                       E_Package_Body,\n+                       E_Procedure,\n+                       E_Subprogram_Body));\n+      Set_Flag279 (Id, V);\n+   end Set_Contains_Ignored_Ghost_Code;\n+\n    procedure Set_Contract (Id : E; V : N) is\n    begin\n       pragma Assert\n@@ -4747,7 +4777,11 @@ package body Einfo is\n         or else Ekind (Id) = E_Discriminant\n         or else Ekind (Id) = E_Exception\n         or else Ekind (Id) = E_Package_Body\n-        or else Ekind (Id) = E_Subprogram_Body);\n+        or else Ekind (Id) = E_Subprogram_Body\n+\n+        --  Allow this attribute to appear on non-analyzed entities\n+\n+        or else Ekind (Id) = E_Void);\n       Set_Flag277 (Id, V);\n    end Set_Is_Checked_Ghost_Entity;\n \n@@ -4942,7 +4976,11 @@ package body Einfo is\n         or else Ekind (Id) = E_Discriminant\n         or else Ekind (Id) = E_Exception\n         or else Ekind (Id) = E_Package_Body\n-        or else Ekind (Id) = E_Subprogram_Body);\n+        or else Ekind (Id) = E_Subprogram_Body\n+\n+        --  Allow this attribute to appear on non-analyzed entities\n+\n+        or else Ekind (Id) = E_Void);\n       Set_Flag278 (Id, V);\n    end Set_Is_Ignored_Ghost_Entity;\n \n@@ -8371,6 +8409,7 @@ package body Einfo is\n       W (\"C_Pass_By_Copy\",                  Flag125 (Id));\n       W (\"Can_Never_Be_Null\",               Flag38  (Id));\n       W (\"Checks_May_Be_Suppressed\",        Flag31  (Id));\n+      W (\"Contains_Ignored_Ghost_Code\",     Flag279 (Id));\n       W (\"Debug_Info_Off\",                  Flag166 (Id));\n       W (\"Default_Expressions_Processed\",   Flag108 (Id));\n       W (\"Delay_Cleanups\",                  Flag114 (Id));"}, {"sha": "938559a0fcde85d8e8594c9692d451edb2141468", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -661,6 +661,11 @@ package Einfo is\n --    Component_Type (Node20) [implementation base type only]\n --       Defined in array types and string types. References component type.\n \n+--    Contains_Ignored_Ghost_Code (Flag279)\n+--       Defined in blocks, packages and their bodies, subprograms and their\n+--       bodies. Set if the entity contains any ignored Ghost code in the form\n+--       of declaration, procedure call, assignment statement or pragma.\n+\n --    Corresponding_Concurrent_Type (Node18)\n --       Defined in record types that are constructed by the expander to\n --       represent task and protected types (Is_Concurrent_Record_Type flag\n@@ -5458,6 +5463,7 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Entry_Cancel_Parameter              (Node23)\n+   --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Cleanups                      (Flag114)\n    --    Discard_Names                       (Flag88)\n    --    Has_Master_Entity                   (Flag21)\n@@ -5531,8 +5537,8 @@ package Einfo is\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Completion                      (Flag26)   (constants only)\n    --    Has_Independent_Components          (Flag34)\n-   --    Has_Thunks                          (Flag228)  (constants only)\n    --    Has_Size_Clause                     (Flag29)\n+   --    Has_Thunks                          (Flag228)  (constants only)\n    --    Has_Up_Level_Access                 (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n@@ -5709,11 +5715,12 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Body_Needed_For_SAL                 (Flag40)\n-   --    Elaboration_Entity_Required         (Flag174)\n+   --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Delay_Cleanups                      (Flag114)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Discard_Names                       (Flag88)\n+   --    Elaboration_Entity_Required         (Flag174)\n    --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n    --    Has_Controlling_Result              (Flag98)\n@@ -5921,6 +5928,7 @@ package Einfo is\n    --    Contract                            (Node34)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n+   --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Discard_Names                       (Flag88)\n    --    Elaboration_Entity_Required         (Flag174)\n    --    Elaborate_Body_Desirable            (Flag210)  (non-generic case only)\n@@ -5955,6 +5963,7 @@ package Einfo is\n    --    SPARK_Aux_Pragma                    (Node33)\n    --    SPARK_Pragma                        (Node32)\n    --    Contract                            (Node34)\n+   --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Has_Anonymous_Master                (Flag253)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)\n@@ -6005,6 +6014,7 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Body_Needed_For_SAL                 (Flag40)\n+   --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Cleanups                      (Flag114)\n    --    Discard_Names                       (Flag88)\n    --    Elaboration_Entity_Required         (Flag174)\n@@ -6174,8 +6184,9 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Extra_Formals                       (Node28)\n    --    SPARK_Pragma                        (Node32)\n-   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Contract                            (Node34)\n+   --    Contains_Ignored_Ghost_Code         (Flag279)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Scope_Depth                         (synth)\n \n    --  E_Subprogram_Type\n@@ -6527,6 +6538,7 @@ package Einfo is\n    function Component_Clause                    (Id : E) return N;\n    function Component_Size                      (Id : E) return U;\n    function Component_Type                      (Id : E) return E;\n+   function Contains_Ignored_Ghost_Code         (Id : E) return B;\n    function Contract                            (Id : E) return N;\n    function Corresponding_Concurrent_Type       (Id : E) return E;\n    function Corresponding_Discriminant          (Id : E) return E;\n@@ -7168,6 +7180,7 @@ package Einfo is\n    procedure Set_Component_Clause                (Id : E; V : N);\n    procedure Set_Component_Size                  (Id : E; V : U);\n    procedure Set_Component_Type                  (Id : E; V : E);\n+   procedure Set_Contains_Ignored_Ghost_Code     (Id : E; V : B := True);\n    procedure Set_Contract                        (Id : E; V : N);\n    procedure Set_Corresponding_Concurrent_Type   (Id : E; V : E);\n    procedure Set_Corresponding_Discriminant      (Id : E; V : E);\n@@ -7924,6 +7937,7 @@ package Einfo is\n    pragma Inline (Component_Clause);\n    pragma Inline (Component_Size);\n    pragma Inline (Component_Type);\n+   pragma Inline (Contains_Ignored_Ghost_Code);\n    pragma Inline (Contract);\n    pragma Inline (Corresponding_Concurrent_Type);\n    pragma Inline (Corresponding_Discriminant);\n@@ -8413,6 +8427,7 @@ package Einfo is\n    pragma Inline (Set_Component_Clause);\n    pragma Inline (Set_Component_Size);\n    pragma Inline (Set_Component_Type);\n+   pragma Inline (Set_Contains_Ignored_Ghost_Code);\n    pragma Inline (Set_Contract);\n    pragma Inline (Set_Corresponding_Concurrent_Type);\n    pragma Inline (Set_Corresponding_Discriminant);"}, {"sha": "d45dbddc41bb1925c483afe2e16d44c20b5e896e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -43,6 +43,7 @@ with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -7427,11 +7428,37 @@ package body Exp_Ch3 is\n    --  node using Append_Freeze_Actions.\n \n    function Freeze_Type (N : Node_Id) return Boolean is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+      --  Save the current Ghost mode in effect in case the type being frozen\n+      --  sets a different mode.\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n       Def_Id    : constant Entity_Id := Entity (N);\n       RACW_Seen : Boolean := False;\n       Result    : Boolean := False;\n \n+   --  Start of processing for Freeze_Type\n+\n    begin\n+      --  The type being frozen may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  freezing are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode_For_Freeze (Def_Id, N);\n+\n       --  Process associated access types needing special processing\n \n       if Present (Access_Types_To_Process (N)) then\n@@ -7750,10 +7777,13 @@ package body Exp_Ch3 is\n       end if;\n \n       Freeze_Stream_Operations (N, Def_Id);\n+\n+      Restore_Globals;\n       return Result;\n \n    exception\n       when RE_Not_Available =>\n+         Restore_Globals;\n          return False;\n    end Freeze_Type;\n "}, {"sha": "f611fada6d438e6eb68a1908f278bf091a421088", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -1741,13 +1741,19 @@ package body Exp_Ch7 is\n             if Nkind (Decl) = N_Full_Type_Declaration then\n                Typ := Defining_Identifier (Decl);\n \n-               if Is_Tagged_Type (Typ)\n+               --  Ignored Ghost types do not need any cleanup actions because\n+               --  they will not appear in the final tree.\n+\n+               if Is_Ignored_Ghost_Entity (Typ) then\n+                  null;\n+\n+               elsif Is_Tagged_Type (Typ)\n                  and then Is_Library_Level_Entity (Typ)\n                  and then Convention (Typ) = Convention_Ada\n                  and then Present (Access_Disp_Table (Typ))\n                  and then RTE_Available (RE_Register_Tag)\n-                 and then not No_Run_Time_Mode\n                  and then not Is_Abstract_Type (Typ)\n+                 and then not No_Run_Time_Mode\n                then\n                   Processing_Actions;\n                end if;\n@@ -1773,6 +1779,12 @@ package body Exp_Ch7 is\n                elsif Is_Processed_Transient (Obj_Id) then\n                   null;\n \n+               --  Ignored Ghost objects do not need any cleanup actions\n+               --  because they will not appear in the final tree.\n+\n+               elsif Is_Ignored_Ghost_Entity (Obj_Id) then\n+                  null;\n+\n                --  The object is of the form:\n                --    Obj : Typ [:= Expr];\n \n@@ -1880,6 +1892,12 @@ package body Exp_Ch7 is\n                if For_Package and then Finalize_Storage_Only (Obj_Typ) then\n                   null;\n \n+               --  Ignored Ghost object renamings do not need any cleanup\n+               --  actions because they will not appear in the final tree.\n+\n+               elsif Is_Ignored_Ghost_Entity (Obj_Id) then\n+                  null;\n+\n                --  Return object of a build-in-place function. This case is\n                --  recognized and marked by the expansion of an extended return\n                --  statement (see Expand_N_Extended_Return_Statement).\n@@ -1921,11 +1939,17 @@ package body Exp_Ch7 is\n             then\n                Typ := Entity (Decl);\n \n-               if (Is_Access_Type (Typ)\n-                    and then not Is_Access_Subprogram_Type (Typ)\n-                    and then Needs_Finalization\n-                               (Available_View (Designated_Type (Typ))))\n-                 or else (Is_Type (Typ) and then Needs_Finalization (Typ))\n+               --  Freeze nodes for ignored Ghost types do not need cleanup\n+               --  actions because they will never appear in the final tree.\n+\n+               if Is_Ignored_Ghost_Entity (Typ) then\n+                  null;\n+\n+               elsif (Is_Access_Type (Typ)\n+                        and then not Is_Access_Subprogram_Type (Typ)\n+                        and then Needs_Finalization\n+                                   (Available_View (Designated_Type (Typ))))\n+                      or else (Is_Type (Typ) and then Needs_Finalization (Typ))\n                then\n                   Old_Counter_Val := Counter_Val;\n \n@@ -1950,14 +1974,16 @@ package body Exp_Ch7 is\n             --  Nested package declarations, avoid generics\n \n             elsif Nkind (Decl) = N_Package_Declaration then\n-               Spec    := Specification (Decl);\n-               Pack_Id := Defining_Unit_Name (Spec);\n+               Pack_Id := Defining_Entity (Decl);\n+               Spec    := Specification   (Decl);\n \n-               if Nkind (Pack_Id) = N_Defining_Program_Unit_Name then\n-                  Pack_Id := Defining_Identifier (Pack_Id);\n-               end if;\n+               --  Do not inspect an ignored Ghost package because all code\n+               --  found within will not appear in the final tree.\n+\n+               if Is_Ignored_Ghost_Entity (Pack_Id) then\n+                  null;\n \n-               if Ekind (Pack_Id) /= E_Generic_Package then\n+               elsif Ekind (Pack_Id) /= E_Generic_Package then\n                   Old_Counter_Val := Counter_Val;\n                   Process_Declarations\n                     (Private_Declarations (Spec), Preprocess);\n@@ -1980,9 +2006,16 @@ package body Exp_Ch7 is\n             --  Nested package bodies, avoid generics\n \n             elsif Nkind (Decl) = N_Package_Body then\n-               Spec := Corresponding_Spec (Decl);\n \n-               if Ekind (Spec) /= E_Generic_Package then\n+               --  Do not inspect an ignored Ghost package body because all\n+               --  code found within will not appear in the final tree.\n+\n+               if Is_Ignored_Ghost_Entity (Defining_Entity (Decl)) then\n+                  null;\n+\n+               elsif Ekind (Corresponding_Spec (Decl)) /=\n+                       E_Generic_Package\n+               then\n                   Old_Counter_Val := Counter_Val;\n                   Process_Declarations (Declarations (Decl), Preprocess);\n "}, {"sha": "3ed470a4d9161f414e59b86f09ccb0b1e6d53633", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -1101,10 +1101,21 @@ package body Exp_Dbug is\n    procedure Qualify_All_Entity_Names is\n       E   : Entity_Id;\n       Ent : Entity_Id;\n+      Nod : Node_Id;\n \n    begin\n       for J in Name_Qualify_Units.First .. Name_Qualify_Units.Last loop\n-         E := Defining_Entity (Name_Qualify_Units.Table (J));\n+         Nod := Name_Qualify_Units.Table (J);\n+\n+         --  When a scoping construct is ignored Ghost, it is rewritten as\n+         --  a null statement. Skip such constructs as they no longer carry\n+         --  names.\n+\n+         if Nkind (Nod) = N_Null_Statement then\n+            goto Continue;\n+         end if;\n+\n+         E := Defining_Entity (Nod);\n          Reset_Buffers;\n          Qualify_Entity_Name (E);\n \n@@ -1128,6 +1139,9 @@ package body Exp_Dbug is\n                exit when Ent = E;\n             end loop;\n          end if;\n+\n+         <<Continue>>\n+         null;\n       end loop;\n    end Qualify_All_Entity_Names;\n "}, {"sha": "3f999647413c7e1a22b7d863a6b85bede47b32b2", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -36,6 +36,7 @@ with Exp_Dbug; use Exp_Dbug;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Itypes;   use Itypes;\n with Layout;   use Layout;\n with Nlists;   use Nlists;\n@@ -3663,6 +3664,10 @@ package body Exp_Disp is\n    --     end;\n \n    function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+      --  Save the current Ghost mode in effect in case the tagged type sets a\n+      --  different mode.\n+\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n       Max_Predef_Prims : constant Int :=\n@@ -3725,6 +3730,9 @@ package body Exp_Disp is\n       --  this secondary dispatch table by Make_Tags when its unique external\n       --  name was generated.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       ------------------------------\n       -- Check_Premature_Freezing --\n       ------------------------------\n@@ -4409,6 +4417,15 @@ package body Exp_Disp is\n          Append_Elmt (Iface_DT, DT_Decl);\n       end Make_Secondary_DT;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n       --  Local variables\n \n       Elab_Code          : constant List_Id := New_List;\n@@ -4479,6 +4496,13 @@ package body Exp_Disp is\n    begin\n       pragma Assert (Is_Frozen (Typ));\n \n+      --  The tagged type for which the dispatch table is being build may be\n+      --  subject to pragma Ghost with policy Ignore. Set the mode now to\n+      --  ensure that any nodes generated during freezing are properly flagged\n+      --  as ignored Ghost.\n+\n+      Set_Ghost_Mode_For_Freeze (Typ, Typ);\n+\n       --  Handle cases in which there is no need to build the dispatch table\n \n       if Has_Dispatch_Table (Typ)\n@@ -4487,10 +4511,12 @@ package body Exp_Disp is\n         or else Convention (Typ) = Convention_CIL\n         or else Convention (Typ) = Convention_Java\n       then\n+         Restore_Globals;\n          return Result;\n \n       elsif No_Run_Time_Mode then\n          Error_Msg_CRT (\"tagged types\", Typ);\n+         Restore_Globals;\n          return Result;\n \n       elsif not RTE_Available (RE_Tag) then\n@@ -4506,6 +4532,7 @@ package body Exp_Disp is\n \n          Analyze_List (Result, Suppress => All_Checks);\n          Error_Msg_CRT (\"tagged types\", Typ);\n+         Restore_Globals;\n          return Result;\n       end if;\n \n@@ -4516,12 +4543,14 @@ package body Exp_Disp is\n       if RTE_Available (RE_Interface_Data) then\n          if Max_Predef_Prims /= 15 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n+            Restore_Globals;\n             return Result;\n          end if;\n       else\n          if Max_Predef_Prims /= 9 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n             Error_Msg_CRT (\"tagged types\", Typ);\n+            Restore_Globals;\n             return Result;\n          end if;\n       end if;\n@@ -6242,6 +6271,7 @@ package body Exp_Disp is\n \n       Register_CG_Node (Typ);\n \n+      Restore_Globals;\n       return Result;\n    end Make_DT;\n "}, {"sha": "7bc6bc3f135f2ac53210fc1ee592ca486b34069c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -7830,13 +7830,19 @@ package body Exp_Util is\n          if Nkind (Decl) = N_Full_Type_Declaration then\n             Typ := Defining_Identifier (Decl);\n \n-            if Is_Tagged_Type (Typ)\n+            --  Ignored Ghost types do not need any cleanup actions because\n+            --  they will not appear in the final tree.\n+\n+            if Is_Ignored_Ghost_Entity (Typ) then\n+               null;\n+\n+            elsif Is_Tagged_Type (Typ)\n               and then Is_Library_Level_Entity (Typ)\n               and then Convention (Typ) = Convention_Ada\n               and then Present (Access_Disp_Table (Typ))\n               and then RTE_Available (RE_Unregister_Tag)\n-              and then not No_Run_Time_Mode\n               and then not Is_Abstract_Type (Typ)\n+              and then not No_Run_Time_Mode\n             then\n                return True;\n             end if;\n@@ -7862,6 +7868,12 @@ package body Exp_Util is\n             elsif Is_Processed_Transient (Obj_Id) then\n                null;\n \n+            --  Ignored Ghost objects do not need any cleanup actions because\n+            --  they will not appear in the final tree.\n+\n+            elsif Is_Ignored_Ghost_Entity (Obj_Id) then\n+               null;\n+\n             --  The object is of the form:\n             --    Obj : Typ [:= Expr];\n             --\n@@ -7940,6 +7952,12 @@ package body Exp_Util is\n             if Lib_Level and then Finalize_Storage_Only (Obj_Typ) then\n                null;\n \n+            --  Ignored Ghost object renamings do not need any cleanup actions\n+            --  because they will not appear in the final tree.\n+\n+            elsif Is_Ignored_Ghost_Entity (Obj_Id) then\n+               null;\n+\n             --  Return object of a build-in-place function. This case is\n             --  recognized and marked by the expansion of an extended return\n             --  statement (see Expand_N_Extended_Return_Statement).\n@@ -7981,11 +7999,17 @@ package body Exp_Util is\n          then\n             Typ := Entity (Decl);\n \n-            if ((Is_Access_Type (Typ)\n-                  and then not Is_Access_Subprogram_Type (Typ)\n-                  and then Needs_Finalization\n-                             (Available_View (Designated_Type (Typ))))\n-                or else (Is_Type (Typ) and then Needs_Finalization (Typ)))\n+            --  Freeze nodes for ignored Ghost types do not need cleanup\n+            --  actions because they will never appear in the final tree.\n+\n+            if Is_Ignored_Ghost_Entity (Typ) then\n+               null;\n+\n+            elsif ((Is_Access_Type (Typ)\n+                      and then not Is_Access_Subprogram_Type (Typ)\n+                      and then Needs_Finalization\n+                                 (Available_View (Designated_Type (Typ))))\n+                    or else (Is_Type (Typ) and then Needs_Finalization (Typ)))\n               and then Requires_Cleanup_Actions\n                          (Actions (Decl), Lib_Level, Nested_Constructs)\n             then\n@@ -7997,29 +8021,57 @@ package body Exp_Util is\n          elsif Nested_Constructs\n            and then Nkind (Decl) = N_Package_Declaration\n          then\n-            Pack_Id := Defining_Unit_Name (Specification (Decl));\n+            Pack_Id := Defining_Entity (Decl);\n \n-            if Nkind (Pack_Id) = N_Defining_Program_Unit_Name then\n-               Pack_Id := Defining_Identifier (Pack_Id);\n-            end if;\n+            --  Do not inspect an ignored Ghost package because all code found\n+            --  within will not appear in the final tree.\n \n-            if Ekind (Pack_Id) /= E_Generic_Package\n-              and then\n-                Requires_Cleanup_Actions (Specification (Decl), Lib_Level)\n+            if Is_Ignored_Ghost_Entity (Pack_Id) then\n+               null;\n+\n+            elsif Ekind (Pack_Id) /= E_Generic_Package\n+              and then Requires_Cleanup_Actions\n+                         (Specification (Decl), Lib_Level)\n             then\n                return True;\n             end if;\n \n          --  Nested package bodies\n \n          elsif Nested_Constructs and then Nkind (Decl) = N_Package_Body then\n-            Pack_Id := Corresponding_Spec (Decl);\n \n-            if Ekind (Pack_Id) /= E_Generic_Package\n+            --  Do not inspect an ignored Ghost package body because all code\n+            --  found within will not appear in the final tree.\n+\n+            if Is_Ignored_Ghost_Entity (Defining_Entity (Decl)) then\n+               null;\n+\n+            elsif Ekind (Corresponding_Spec (Decl)) /= E_Generic_Package\n               and then Requires_Cleanup_Actions (Decl, Lib_Level)\n             then\n                return True;\n             end if;\n+\n+         elsif Nkind (Decl) = N_Block_Statement\n+           and then\n+\n+           --  Handle a rare case caused by a controlled transient variable\n+           --  created as part of a record init proc. The variable is wrapped\n+           --  in a block, but the block is not associated with a transient\n+           --  scope.\n+\n+           (Inside_Init_Proc\n+\n+           --  Handle the case where the original context has been wrapped in\n+           --  a block to avoid interference between exception handlers and\n+           --  At_End handlers. Treat the block as transparent and process its\n+           --  contents.\n+\n+             or else Is_Finalization_Wrapper (Decl))\n+         then\n+            if Requires_Cleanup_Actions (Decl, Lib_Level) then\n+               return True;\n+            end if;\n          end if;\n \n          Next (Decl);"}, {"sha": "52d1118afa27e98cc275edabbb8b0de543f24381", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -36,6 +36,7 @@ with Exp_Disp; use Exp_Disp;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Util; use Exp_Util;\n with Exp_Tss;  use Exp_Tss;\n+with Ghost;    use Ghost;\n with Layout;   use Layout;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -1862,12 +1863,16 @@ package body Freeze is\n    -------------------\n \n    function Freeze_Entity (E : Entity_Id; N : Node_Id) return List_Id is\n-      Loc           : constant Source_Ptr := Sloc (N);\n-      Comp          : Entity_Id;\n-      F_Node        : Node_Id;\n-      Indx          : Node_Id;\n-      Formal        : Entity_Id;\n-      Atype         : Entity_Id;\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+      --  Save the current Ghost mode in effect in case the entity being frozen\n+      --  sets a different mode.\n+\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Atype  : Entity_Id;\n+      Comp   : Entity_Id;\n+      F_Node : Node_Id;\n+      Formal : Entity_Id;\n+      Indx   : Node_Id;\n \n       Test_E : Entity_Id := E;\n       --  This could use a comment ???\n@@ -1929,6 +1934,9 @@ package body Freeze is\n       --  call, but rather must go in the package holding the function, so that\n       --  the backend can process it in the proper context.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       procedure Wrap_Imported_Subprogram (E : Entity_Id);\n       --  If E is an entity for an imported subprogram with pre/post-conditions\n       --  then this procedure will create a wrapper to ensure that proper run-\n@@ -4125,6 +4133,15 @@ package body Freeze is\n          Append_List (Result, Decls);\n       end Late_Freeze_Subprogram;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n       ------------------------------\n       -- Wrap_Imported_Subprogram --\n       ------------------------------\n@@ -4271,6 +4288,12 @@ package body Freeze is\n    --  Start of processing for Freeze_Entity\n \n    begin\n+      --  The entity being frozen may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  freezing are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode_For_Freeze (E, N);\n+\n       --  We are going to test for various reasons why this entity need not be\n       --  frozen here, but in the case of an Itype that's defined within a\n       --  record, that test actually applies to the record.\n@@ -4286,6 +4309,7 @@ package body Freeze is\n       --  Do not freeze if already frozen since we only need one freeze node\n \n       if Is_Frozen (E) then\n+         Restore_Globals;\n          return No_List;\n \n       --  It is improper to freeze an external entity within a generic because\n@@ -4300,6 +4324,7 @@ package body Freeze is\n             Analyze_Aspects_At_Freeze_Point (E);\n          end if;\n \n+         Restore_Globals;\n          return No_List;\n \n       --  AI05-0213: A formal incomplete type does not freeze the actual. In\n@@ -4310,16 +4335,19 @@ package body Freeze is\n         and then No (Full_View (Base_Type (E)))\n         and then Ada_Version >= Ada_2012\n       then\n+         Restore_Globals;\n          return No_List;\n \n       --  Formal subprograms are never frozen\n \n       elsif Is_Formal_Subprogram (E) then\n+         Restore_Globals;\n          return No_List;\n \n       --  Generic types are never frozen as they lack delayed semantic checks\n \n       elsif Is_Generic_Type (E) then\n+         Restore_Globals;\n          return No_List;\n \n       --  Do not freeze a global entity within an inner scope created during\n@@ -4353,6 +4381,7 @@ package body Freeze is\n                   then\n                      exit;\n                   else\n+                     Restore_Globals;\n                      return No_List;\n                   end if;\n                end if;\n@@ -4388,12 +4417,16 @@ package body Freeze is\n             end loop;\n \n             if No (S) then\n+               Restore_Globals;\n                return No_List;\n             end if;\n          end;\n \n       elsif Ekind (E) = E_Generic_Package then\n-         return Freeze_Generic_Entities (E);\n+         Result := Freeze_Generic_Entities (E);\n+\n+         Restore_Globals;\n+         return Result;\n       end if;\n \n       --  Add checks to detect proper initialization of scalars that may appear\n@@ -4475,6 +4508,7 @@ package body Freeze is\n \n             if not Is_Internal (E) then\n                if not Freeze_Profile (E) then\n+                  Restore_Globals;\n                   return Result;\n                end if;\n             end if;\n@@ -4499,6 +4533,7 @@ package body Freeze is\n \n             if Late_Freezing then\n                Late_Freeze_Subprogram (E);\n+               Restore_Globals;\n                return No_List;\n             end if;\n \n@@ -4830,6 +4865,7 @@ package body Freeze is\n                and then not Has_Delayed_Freeze (E))\n          then\n             Check_Compile_Time_Size (E);\n+            Restore_Globals;\n             return No_List;\n          end if;\n \n@@ -5102,6 +5138,7 @@ package body Freeze is\n \n             if not Is_Frozen (Root_Type (E)) then\n                Set_Is_Frozen (E, False);\n+               Restore_Globals;\n                return Result;\n             end if;\n \n@@ -5237,6 +5274,7 @@ package body Freeze is\n               and then not Present (Full_View (E))\n             then\n                Set_Is_Frozen (E, False);\n+               Restore_Globals;\n                return Result;\n \n             --  Case of full view present\n@@ -5328,6 +5366,7 @@ package body Freeze is\n                   Set_RM_Size   (E, RM_Size (Full_View (E)));\n                end if;\n \n+               Restore_Globals;\n                return Result;\n \n             --  Case of underlying full view present\n@@ -5357,6 +5396,7 @@ package body Freeze is\n \n                Check_Debug_Info_Needed (E);\n \n+               Restore_Globals;\n                return Result;\n \n             --  Case of no full view present. If entity is derived or subtype,\n@@ -5370,6 +5410,7 @@ package body Freeze is\n \n             else\n                Set_Is_Frozen (E, False);\n+               Restore_Globals;\n                return No_List;\n             end if;\n \n@@ -5418,6 +5459,7 @@ package body Freeze is\n          --  generic processing), so we never need freeze nodes for them.\n \n          if Is_Generic_Type (E) then\n+            Restore_Globals;\n             return Result;\n          end if;\n \n@@ -6033,6 +6075,7 @@ package body Freeze is\n          end if;\n       end if;\n \n+      Restore_Globals;\n       return Result;\n    end Freeze_Entity;\n "}, {"sha": "51ea9e89a1811689ec1c6a00c849d5f91f104f39", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -33,6 +33,7 @@ with Elists;\n with Exp_Dbug;\n with Fmap;\n with Fname.UF;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n@@ -421,14 +422,19 @@ begin\n                Analyze_Inlined_Bodies;\n             end if;\n \n-            --  Remove entities from program that do not have any\n-            --  execution time references.\n+            --  Remove entities from program that do not have any execution\n+            --  time references.\n \n             if Debug_Flag_UU then\n                Collect_Garbage_Entities;\n             end if;\n \n             Check_Elab_Calls;\n+\n+            --  Remove any ignored Ghost code as it must not appear in the\n+            --  executable.\n+\n+            Remove_Ignored_Ghost_Code;\n          end if;\n \n          --  List library units if requested"}, {"sha": "c24c22a0e010f33545905572784af08c134f0c0a", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -297,6 +297,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/g-u3spch.o\t\\\n  ada/get_spark_xrefs.o\t\\\n  ada/get_targ.o\t\\\n+ ada/ghost.o\t\\\n  ada/gnat.o\t\\\n  ada/gnatvsn.o\t\\\n  ada/hostparm.o\t\\"}, {"sha": "b69c74ee68f81dcdcfde0eb42c14b95739a46bad", "filename": "gcc/ada/ghost.adb", "status": "added", "additions": 949, "deletions": 0, "changes": 949, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -0,0 +1,949 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                G H O S T                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2014-2015, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Alloc;    use Alloc;\n+with Aspects;  use Aspects;\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Errout;   use Errout;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Res;  use Sem_Res;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Table;\n+\n+package body Ghost is\n+\n+   --  The following table contains the N_Compilation_Unit node for a unit that\n+   --  is either subject to pragma Ghost with policy Ignore or contains ignored\n+   --  Ghost code. The table is used in the removal of ignored Ghost code from\n+   --  units.\n+\n+   package Ignored_Ghost_Units is new Table.Table (\n+     Table_Component_Type => Node_Id,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Ignored_Ghost_Units_Initial,\n+     Table_Increment      => Alloc.Ignored_Ghost_Units_Increment,\n+     Table_Name           => \"Ignored_Ghost_Units\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Propagate_Ignored_Ghost_Code (N : Node_Id);\n+   --  Subsidiary to Set_Ghost_Mode_xxx. Signal all enclosing scopes that they\n+   --  now contain ignored Ghost code. Add the compilation unit containing N to\n+   --  table Ignored_Ghost_Units for post processing.\n+\n+   ----------------------------\n+   -- Add_Ignored_Ghost_Unit --\n+   ----------------------------\n+\n+   procedure Add_Ignored_Ghost_Unit (Unit : Node_Id) is\n+   begin\n+      pragma Assert (Nkind (Unit) = N_Compilation_Unit);\n+\n+      --  Avoid duplicates in the table as pruning the same unit more than once\n+      --  is wasteful. Since ignored Ghost code tends to be grouped up, check\n+      --  the contents of the table in reverse.\n+\n+      for Index in reverse Ignored_Ghost_Units.First ..\n+                           Ignored_Ghost_Units.Last\n+      loop\n+         --  The unit is already present in the table, do not add it again\n+\n+         if Unit = Ignored_Ghost_Units.Table (Index) then\n+            return;\n+         end if;\n+      end loop;\n+\n+      --  If we get here, then this is the first time the unit is being added\n+\n+      Ignored_Ghost_Units.Append (Unit);\n+   end Add_Ignored_Ghost_Unit;\n+\n+   ----------------------------\n+   -- Check_Ghost_Completion --\n+   ----------------------------\n+\n+   procedure Check_Ghost_Completion\n+     (Partial_View : Entity_Id;\n+      Full_View    : Entity_Id)\n+   is\n+      Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+   begin\n+      --  The Ghost policy in effect at the point of declaration and at the\n+      --  point of completion must match (SPARK RM 6.9(15)).\n+\n+      if Is_Checked_Ghost_Entity (Partial_View)\n+        and then Policy = Name_Ignore\n+      then\n+         Error_Msg_Sloc := Sloc (Full_View);\n+\n+         Error_Msg_N (\"incompatible ghost policies in effect\",   Partial_View);\n+         Error_Msg_N (\"\\& declared with ghost policy Check\",     Partial_View);\n+         Error_Msg_N (\"\\& completed # with ghost policy Ignore\", Partial_View);\n+\n+      elsif Is_Ignored_Ghost_Entity (Partial_View)\n+        and then Policy = Name_Check\n+      then\n+         Error_Msg_Sloc := Sloc (Full_View);\n+\n+         Error_Msg_N (\"incompatible ghost policies in effect\",  Partial_View);\n+         Error_Msg_N (\"\\& declared with ghost policy Ignore\",   Partial_View);\n+         Error_Msg_N (\"\\& completed # with ghost policy Check\", Partial_View);\n+      end if;\n+   end Check_Ghost_Completion;\n+\n+   -------------------------\n+   -- Check_Ghost_Context --\n+   -------------------------\n+\n+   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id) is\n+      procedure Check_Ghost_Policy (Id : Entity_Id; Err_N : Node_Id);\n+      --  Verify that the Ghost policy at the point of declaration of entity Id\n+      --  matches the policy at the point of reference. If this is not the case\n+      --  emit an error at Err_N.\n+\n+      function Is_OK_Ghost_Context (Context : Node_Id) return Boolean;\n+      --  Determine whether node Context denotes a Ghost-friendly context where\n+      --  a Ghost entity can safely reside.\n+\n+      -------------------------\n+      -- Is_OK_Ghost_Context --\n+      -------------------------\n+\n+      function Is_OK_Ghost_Context (Context : Node_Id) return Boolean is\n+         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean;\n+         --  Determine whether node Decl is a Ghost declaration or appears\n+         --  within a Ghost declaration.\n+\n+         function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean;\n+         --  Determine whether statement or pragma N is Ghost or appears within\n+         --  a Ghost statement or pragma. To qualify as such, N must either\n+         --    1) Occur within a ghost subprogram or package\n+         --    2) Denote a call to a ghost procedure\n+         --    3) Denote an assignment statement whose target is a ghost\n+         --       variable.\n+         --    4) Denote a pragma that mentions a ghost entity\n+\n+         --------------------------\n+         -- Is_Ghost_Declaration --\n+         --------------------------\n+\n+         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean is\n+            Par       : Node_Id;\n+            Subp_Decl : Node_Id;\n+            Subp_Id   : Entity_Id;\n+\n+         begin\n+            --  Climb the parent chain looking for an object declaration\n+\n+            Par := Decl;\n+            while Present (Par) loop\n+               if Is_Declaration (Par) then\n+\n+                  --  A declaration is Ghost when it appears within a Ghost\n+                  --  package or subprogram.\n+\n+                  if Ghost_Mode > None then\n+                     return True;\n+\n+                  --  Otherwise the declaration may not have been analyzed yet,\n+                  --  determine whether it is subject to aspect/pragma Ghost.\n+\n+                  else\n+                     return Is_Subject_To_Ghost (Par);\n+                  end if;\n+\n+               --  Special cases\n+\n+               --  A reference to a Ghost entity may appear as the default\n+               --  expression of a formal parameter of a subprogram body. This\n+               --  context must be treated as suitable because the relation\n+               --  between the spec and the body has not been established and\n+               --  the body is not marked as Ghost yet. The real check was\n+               --  performed on the spec.\n+\n+               elsif Nkind (Par) = N_Parameter_Specification\n+                 and then Nkind (Parent (Parent (Par))) = N_Subprogram_Body\n+               then\n+                  return True;\n+\n+               --  References to Ghost entities may be relocated in internally\n+               --  generated bodies.\n+\n+               elsif Nkind (Par) = N_Subprogram_Body\n+                 and then not Comes_From_Source (Par)\n+               then\n+                  Subp_Id := Corresponding_Spec (Par);\n+\n+                  --  The original context is an expression function that has\n+                  --  been split into a spec and a body. The context is OK as\n+                  --  long as the the initial declaration is Ghost.\n+\n+                  if Present (Subp_Id) then\n+                     Subp_Decl :=\n+                       Original_Node (Unit_Declaration_Node (Subp_Id));\n+\n+                     if Nkind (Subp_Decl) = N_Expression_Function then\n+                        return Is_Subject_To_Ghost (Subp_Decl);\n+                     end if;\n+                  end if;\n+\n+                  --  Otherwise this is either an internal body or an internal\n+                  --  completion. Both are OK because the real check was done\n+                  --  before expansion activities.\n+\n+                  return True;\n+               end if;\n+\n+               --  Prevent the search from going too far\n+\n+               if Is_Body_Or_Package_Declaration (Par) then\n+                  return False;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n+            return False;\n+         end Is_Ghost_Declaration;\n+\n+         ----------------------------------\n+         -- Is_Ghost_Statement_Or_Pragma --\n+         ----------------------------------\n+\n+         function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean is\n+            function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean;\n+            --  Determine whether an arbitrary node denotes a reference to a\n+            --  Ghost entity.\n+\n+            -------------------------------\n+            -- Is_Ghost_Entity_Reference --\n+            -------------------------------\n+\n+            function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean is\n+               Ref : Node_Id;\n+\n+            begin\n+               Ref := N;\n+\n+               --  When the reference extracts a subcomponent, recover the\n+               --  related object (SPARK RM 6.9(1)).\n+\n+               while Nkind_In (Ref, N_Explicit_Dereference,\n+                                    N_Indexed_Component,\n+                                    N_Selected_Component,\n+                                    N_Slice)\n+               loop\n+                  Ref := Prefix (Ref);\n+               end loop;\n+\n+               return\n+                 Is_Entity_Name (Ref)\n+                   and then Present (Entity (Ref))\n+                   and then Is_Ghost_Entity (Entity (Ref));\n+            end Is_Ghost_Entity_Reference;\n+\n+            --  Local variables\n+\n+            Arg  : Node_Id;\n+            Stmt : Node_Id;\n+\n+         --  Start of processing for Is_Ghost_Statement_Or_Pragma\n+\n+         begin\n+            if Nkind (N) = N_Pragma then\n+\n+               --  A pragma is Ghost when it appears within a Ghost package or\n+               --  subprogram.\n+\n+               if Ghost_Mode > None then\n+                  return True;\n+               end if;\n+\n+               --  A pragma is Ghost when it mentions a Ghost entity\n+\n+               Arg := First (Pragma_Argument_Associations (N));\n+               while Present (Arg) loop\n+                  if Is_Ghost_Entity_Reference (Get_Pragma_Arg (Arg)) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Arg);\n+               end loop;\n+            end if;\n+\n+            Stmt := N;\n+            while Present (Stmt) loop\n+               if Is_Statement (Stmt) then\n+\n+                  --  A statement is Ghost when it appears within a Ghost\n+                  --  package or subprogram.\n+\n+                  if Ghost_Mode > None then\n+                     return True;\n+\n+                  --  An assignment statement or a procedure call is Ghost when\n+                  --  the name denotes a Ghost entity.\n+\n+                  elsif Nkind_In (Stmt, N_Assignment_Statement,\n+                                        N_Procedure_Call_Statement)\n+                  then\n+                     return Is_Ghost_Entity_Reference (Name (Stmt));\n+                  end if;\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Stmt) then\n+                  return False;\n+               end if;\n+\n+               Stmt := Parent (Stmt);\n+            end loop;\n+\n+            return False;\n+         end Is_Ghost_Statement_Or_Pragma;\n+\n+      --  Start of processing for Is_OK_Ghost_Context\n+\n+      begin\n+         --  The Ghost entity appears within an assertion expression\n+\n+         if In_Assertion_Expr > 0 then\n+            return True;\n+\n+         --  The Ghost entity is part of a declaration or its completion\n+\n+         elsif Is_Ghost_Declaration (Context) then\n+            return True;\n+\n+         --  The Ghost entity is referenced within a Ghost statement\n+\n+         elsif Is_Ghost_Statement_Or_Pragma (Context) then\n+            return True;\n+\n+         --  Routine Expand_Record_Extension creates a parent subtype without\n+         --  inserting it into the tree. There is no good way of recognizing\n+         --  this special case as there is no parent. Try to approximate the\n+         --  context.\n+\n+         elsif No (Parent (Context)) and then Is_Tagged_Type (Ghost_Id) then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Is_OK_Ghost_Context;\n+\n+      ------------------------\n+      -- Check_Ghost_Policy --\n+      ------------------------\n+\n+      procedure Check_Ghost_Policy (Id : Entity_Id; Err_N : Node_Id) is\n+         Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+      begin\n+         --  The Ghost policy in effect a the point of declaration and at the\n+         --  point of use must match (SPARK RM 6.9(14)).\n+\n+         if Is_Checked_Ghost_Entity (Id) and then Policy = Name_Ignore then\n+            Error_Msg_Sloc := Sloc (Err_N);\n+\n+            Error_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n+            Error_Msg_NE (\"\\& declared with ghost policy Check\", Err_N, Id);\n+            Error_Msg_NE (\"\\& used # with ghost policy Ignore\", Err_N, Id);\n+\n+         elsif Is_Ignored_Ghost_Entity (Id) and then Policy = Name_Check then\n+            Error_Msg_Sloc := Sloc (Err_N);\n+\n+            Error_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n+            Error_Msg_NE (\"\\& declared with ghost policy Ignore\", Err_N, Id);\n+            Error_Msg_NE (\"\\& used # with ghost policy Check\", Err_N, Id);\n+         end if;\n+      end Check_Ghost_Policy;\n+\n+   --  Start of processing for Check_Ghost_Context\n+\n+   begin\n+      --  Once it has been established that the reference to the Ghost entity\n+      --  is within a suitable context, ensure that the policy at the point of\n+      --  declaration and at the point of use match.\n+\n+      if Is_OK_Ghost_Context (Ghost_Ref) then\n+         Check_Ghost_Policy (Ghost_Id, Ghost_Ref);\n+\n+      --  Otherwise the Ghost entity appears in a non-Ghost context and affects\n+      --  its behavior or value.\n+\n+      else\n+         Error_Msg_N\n+           (\"ghost entity cannot appear in this context (SPARK RM 6.9(12))\",\n+            Ghost_Ref);\n+      end if;\n+   end Check_Ghost_Context;\n+\n+   ----------------------------\n+   -- Check_Ghost_Derivation --\n+   ----------------------------\n+\n+   procedure Check_Ghost_Derivation (Typ : Entity_Id) is\n+      Parent_Typ : constant Entity_Id := Etype (Typ);\n+      Iface      : Entity_Id;\n+      Iface_Elmt : Elmt_Id;\n+\n+   begin\n+      --  Allow untagged derivations from predefined types such as Integer as\n+      --  those are not Ghost by definition.\n+\n+      if Is_Scalar_Type (Typ) and then Parent_Typ = Base_Type (Typ) then\n+         null;\n+\n+      --  The parent type of a Ghost type extension must be Ghost\n+\n+      elsif not Is_Ghost_Entity (Parent_Typ) then\n+         Error_Msg_N  (\"type extension & cannot be ghost\", Typ);\n+         Error_Msg_NE (\"\\parent type & is not ghost\", Typ, Parent_Typ);\n+         return;\n+      end if;\n+\n+      --  All progenitors (if any) must be Ghost as well\n+\n+      if Is_Tagged_Type (Typ) and then Present (Interfaces (Typ)) then\n+         Iface_Elmt := First_Elmt (Interfaces (Typ));\n+         while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n+\n+            if not Is_Ghost_Entity (Iface) then\n+               Error_Msg_N  (\"type extension & cannot be ghost\", Typ);\n+               Error_Msg_NE (\"\\interface type & is not ghost\", Typ, Iface);\n+               return;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end if;\n+   end Check_Ghost_Derivation;\n+\n+   --------------------------------\n+   -- Implements_Ghost_Interface --\n+   --------------------------------\n+\n+   function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean is\n+      Iface_Elmt : Elmt_Id;\n+\n+   begin\n+      --  Traverse the list of interfaces looking for a Ghost interface\n+\n+      if Is_Tagged_Type (Typ) and then Present (Interfaces (Typ)) then\n+         Iface_Elmt := First_Elmt (Interfaces (Typ));\n+         while Present (Iface_Elmt) loop\n+            if Is_Ghost_Entity (Node (Iface_Elmt)) then\n+               return True;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Implements_Ghost_Interface;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Ignored_Ghost_Units.Init;\n+   end Initialize;\n+\n+   ---------------------\n+   -- Is_Ghost_Entity --\n+   ---------------------\n+\n+   function Is_Ghost_Entity (Id : Entity_Id) return Boolean is\n+   begin\n+      return Is_Checked_Ghost_Entity (Id) or else Is_Ignored_Ghost_Entity (Id);\n+   end Is_Ghost_Entity;\n+\n+   -------------------------\n+   -- Is_Subject_To_Ghost --\n+   -------------------------\n+\n+   function Is_Subject_To_Ghost (N : Node_Id) return Boolean is\n+      function Enables_Ghostness (Arg : Node_Id) return Boolean;\n+      --  Determine whether aspect or pragma argument Arg enables \"ghostness\"\n+\n+      -----------------------\n+      -- Enables_Ghostness --\n+      -----------------------\n+\n+      function Enables_Ghostness (Arg : Node_Id) return Boolean is\n+         Expr : Node_Id;\n+\n+      begin\n+         Expr := Arg;\n+\n+         if Nkind (Expr) = N_Pragma_Argument_Association then\n+            Expr := Get_Pragma_Arg (Expr);\n+         end if;\n+\n+         --  Determine whether the expression of the aspect is static and\n+         --  denotes True.\n+\n+         if Present (Expr) then\n+            Preanalyze_And_Resolve (Expr);\n+\n+            return\n+              Is_OK_Static_Expression (Expr)\n+                and then Is_True (Expr_Value (Expr));\n+\n+         --  Otherwise Ghost defaults to True\n+\n+         else\n+            return True;\n+         end if;\n+      end Enables_Ghostness;\n+\n+      --  Local variables\n+\n+      Id      : constant Entity_Id := Defining_Entity (N);\n+      Asp     : Node_Id;\n+      Decl    : Node_Id;\n+      Prev_Id : Entity_Id;\n+\n+   --  Start of processing for Is_Subject_To_Ghost\n+\n+   begin\n+      --  The related entity of the declaration has not been analyzed yet, do\n+      --  not inspect its attributes.\n+\n+      if Ekind (Id) = E_Void then\n+         null;\n+\n+      elsif Is_Ghost_Entity (Id) then\n+         return True;\n+\n+      --  The completion of a type or a constant is not fully analyzed when the\n+      --  reference to the Ghost entity is resolved. Because the completion is\n+      --  not marked as Ghost yet, inspect the partial view.\n+\n+      elsif Is_Record_Type (Id)\n+        or else Ekind (Id) = E_Constant\n+        or else (Nkind (N) = N_Object_Declaration\n+                  and then Constant_Present (N))\n+      then\n+         Prev_Id := Incomplete_Or_Partial_View (Id);\n+\n+         if Present (Prev_Id) and then Is_Ghost_Entity (Prev_Id) then\n+            return True;\n+         end if;\n+      end if;\n+\n+      --  Examine the aspect specifications (if any) looking for aspect Ghost\n+\n+      if Permits_Aspect_Specifications (N) then\n+         Asp := First (Aspect_Specifications (N));\n+         while Present (Asp) loop\n+            if Chars (Identifier (Asp)) = Name_Ghost then\n+               return Enables_Ghostness (Expression (Asp));\n+            end if;\n+\n+            Next (Asp);\n+         end loop;\n+      end if;\n+\n+      Decl := Empty;\n+\n+      --  When the context is a [generic] package declaration, pragma Ghost\n+      --  resides in the visible declarations.\n+\n+      if Nkind_In (N, N_Generic_Package_Declaration,\n+                      N_Package_Declaration)\n+      then\n+         Decl := First (Visible_Declarations (Specification (N)));\n+\n+      --  When the context is a package or a subprogram body, pragma Ghost\n+      --  resides in the declarative part.\n+\n+      elsif Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n+         Decl := First (Declarations (N));\n+\n+      --  Otherwise pragma Ghost appears in the declarations following N\n+\n+      elsif Is_List_Member (N) then\n+         Decl := Next (N);\n+      end if;\n+\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Pragma\n+           and then Pragma_Name (Decl) = Name_Ghost\n+         then\n+            return\n+              Enables_Ghostness (First (Pragma_Argument_Associations (Decl)));\n+\n+         --  A source construct ends the region where pragma Ghost may appear,\n+         --  stop the traversal.\n+\n+         elsif Comes_From_Source (Decl) then\n+            exit;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      return False;\n+   end Is_Subject_To_Ghost;\n+\n+   ----------\n+   -- Lock --\n+   ----------\n+\n+   procedure Lock is\n+   begin\n+      Ignored_Ghost_Units.Locked := True;\n+      Ignored_Ghost_Units.Release;\n+   end Lock;\n+\n+   ----------------------------------\n+   -- Propagate_Ignored_Ghost_Code --\n+   ----------------------------------\n+\n+   procedure Propagate_Ignored_Ghost_Code (N : Node_Id) is\n+      Nod  : Node_Id;\n+      Scop : Entity_Id;\n+\n+   begin\n+      --  Traverse the parent chain looking for blocks, packages and\n+      --  subprograms or their respective bodies.\n+\n+      Nod := Parent (N);\n+      while Present (Nod) loop\n+         Scop := Empty;\n+\n+         if Nkind (Nod) = N_Block_Statement then\n+            Scop := Entity (Identifier (Nod));\n+\n+         elsif Nkind_In (Nod, N_Package_Body,\n+                              N_Package_Declaration,\n+                              N_Subprogram_Body,\n+                              N_Subprogram_Declaration)\n+         then\n+            Scop := Defining_Entity (Nod);\n+         end if;\n+\n+         --  The current node denotes a scoping construct\n+\n+         if Present (Scop) then\n+\n+            --  Stop the traversal when the scope already contains ignored\n+            --  Ghost code as all enclosing scopes have already been marked.\n+\n+            if Contains_Ignored_Ghost_Code (Scop) then\n+               exit;\n+\n+            --  Otherwise mark this scope and keep climbing\n+\n+            else\n+               Set_Contains_Ignored_Ghost_Code (Scop);\n+            end if;\n+         end if;\n+\n+         Nod := Parent (Nod);\n+      end loop;\n+\n+      --  The unit containing the ignored Ghost code must be post processed\n+      --  before invoking the back end.\n+\n+      Add_Ignored_Ghost_Unit (Cunit (Get_Code_Unit (N)));\n+   end Propagate_Ignored_Ghost_Code;\n+\n+   -------------------------------\n+   -- Remove_Ignored_Ghost_Code --\n+   -------------------------------\n+\n+   procedure Remove_Ignored_Ghost_Code is\n+      procedure Prune_Tree (Root : Node_Id);\n+      --  Remove all code marked as ignored Ghost from the tree of denoted by\n+      --  Root.\n+\n+      ----------------\n+      -- Prune_Tree --\n+      ----------------\n+\n+      procedure Prune_Tree (Root : Node_Id) is\n+         procedure Prune (N : Node_Id);\n+         --  Remove a given node from the tree by rewriting it into null\n+\n+         function Prune_Node (N : Node_Id) return Traverse_Result;\n+         --  Determine whether node N denotes an ignored Ghost construct. If\n+         --  this is the case, rewrite N as a null statement. See the body for\n+         --  special cases.\n+\n+         -----------\n+         -- Prune --\n+         -----------\n+\n+         procedure Prune (N : Node_Id) is\n+         begin\n+            --  Destroy any aspects that may be associated with the node\n+\n+            if Permits_Aspect_Specifications (N) and then Has_Aspects (N) then\n+               Remove_Aspects (N);\n+            end if;\n+\n+            Rewrite (N, Make_Null_Statement (Sloc (N)));\n+         end Prune;\n+\n+         ----------------\n+         -- Prune_Node --\n+         ----------------\n+\n+         function Prune_Node (N : Node_Id) return Traverse_Result is\n+            Id : Entity_Id;\n+\n+         begin\n+            --  The node is either declared as ignored Ghost or is a byproduct\n+            --  of expansion. Destroy it and stop the traversal on this branch.\n+\n+            if Is_Ignored_Ghost_Node (N) then\n+               Prune (N);\n+               return Skip;\n+\n+            --  Scoping constructs such as blocks, packages, subprograms and\n+            --  bodies offer some flexibility with respect to pruning.\n+\n+            elsif Nkind_In (N, N_Block_Statement,\n+                               N_Package_Body,\n+                               N_Package_Declaration,\n+                               N_Subprogram_Body,\n+                               N_Subprogram_Declaration)\n+            then\n+               if Nkind (N) = N_Block_Statement then\n+                  Id := Entity (Identifier (N));\n+               else\n+                  Id := Defining_Entity (N);\n+               end if;\n+\n+               --  The scoping construct contains both living and ignored Ghost\n+               --  code, let the traversal prune all relevant nodes.\n+\n+               if Contains_Ignored_Ghost_Code (Id) then\n+                  return OK;\n+\n+               --  Otherwise the construct contains only living code and should\n+               --  not be pruned.\n+\n+               else\n+                  return Skip;\n+               end if;\n+\n+            --  Otherwise keep searching for ignored Ghost nodes\n+\n+            else\n+               return OK;\n+            end if;\n+         end Prune_Node;\n+\n+         procedure Prune_Nodes is new Traverse_Proc (Prune_Node);\n+\n+      --  Start of processing for Prune_Tree\n+\n+      begin\n+         Prune_Nodes (Root);\n+      end Prune_Tree;\n+\n+   --  Start of processing for Remove_Ignored_Ghost_Code\n+\n+   begin\n+      for Index in Ignored_Ghost_Units.First .. Ignored_Ghost_Units.Last loop\n+         Prune_Tree (Unit (Ignored_Ghost_Units.Table (Index)));\n+      end loop;\n+   end Remove_Ignored_Ghost_Code;\n+\n+   --------------------\n+   -- Set_Ghost_Mode --\n+   --------------------\n+\n+   procedure Set_Ghost_Mode (N : Node_Id; Prev_Id : Entity_Id := Empty) is\n+      procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id);\n+      --  Set the value of global variable Ghost_Mode depending on the mode of\n+      --  entity Id.\n+\n+      procedure Set_Ghost_Mode_From_Policy;\n+      --  Set the value of global variable Ghost_Mode depending on the current\n+      --  Ghost policy in effect.\n+\n+      --------------------------------\n+      -- Set_Ghost_Mode_From_Entity --\n+      --------------------------------\n+\n+      procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id) is\n+      begin\n+         if Is_Checked_Ghost_Entity (Id) then\n+            Ghost_Mode := Check;\n+\n+         elsif Is_Ignored_Ghost_Entity (Id) then\n+            Ghost_Mode := Ignore;\n+\n+            Set_Is_Ignored_Ghost_Node (N);\n+            Propagate_Ignored_Ghost_Code (N);\n+         end if;\n+      end Set_Ghost_Mode_From_Entity;\n+\n+      --------------------------------\n+      -- Set_Ghost_Mode_From_Policy --\n+      --------------------------------\n+\n+      procedure Set_Ghost_Mode_From_Policy is\n+         Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+      begin\n+         if Policy = Name_Check then\n+            Ghost_Mode := Check;\n+\n+         elsif Policy = Name_Ignore then\n+            Ghost_Mode := Ignore;\n+\n+            Set_Is_Ignored_Ghost_Node (N);\n+            Propagate_Ignored_Ghost_Code (N);\n+         end if;\n+      end Set_Ghost_Mode_From_Policy;\n+\n+      --  Local variables\n+\n+      Nam : Node_Id;\n+\n+   --  Start of processing for Set_Ghost_Mode\n+\n+   begin\n+      --  The input node denotes one of the many declaration kinds that may be\n+      --  subject to pragma Ghost.\n+\n+      if Is_Declaration (N) then\n+         if Is_Subject_To_Ghost (N) then\n+            Set_Ghost_Mode_From_Policy;\n+\n+         --  The declaration denotes the completion of a deferred constant,\n+         --  pragma Ghost appears on the partial declaration.\n+\n+         elsif Nkind (N) = N_Object_Declaration\n+           and then Constant_Present (N)\n+           and then Present (Prev_Id)\n+         then\n+            Set_Ghost_Mode_From_Entity (Prev_Id);\n+\n+         --  The declaration denotes the full view of a private type, pragma\n+         --  Ghost appears on the partial declaration.\n+\n+         elsif Nkind (N) = N_Full_Type_Declaration\n+           and then Is_Private_Type (Defining_Entity (N))\n+           and then Present (Prev_Id)\n+         then\n+            Set_Ghost_Mode_From_Entity (Prev_Id);\n+         end if;\n+\n+      --  The input denotes an assignment or a procedure call. In this case\n+      --  the Ghost mode is dictated by the name of the construct.\n+\n+      elsif Nkind_In (N, N_Assignment_Statement,\n+                         N_Procedure_Call_Statement)\n+      then\n+         Nam := Name (N);\n+\n+         --  When the reference extracts a subcomponent, recover the related\n+         --  object (SPARK RM 6.9(1)).\n+\n+         while Nkind_In (Nam, N_Explicit_Dereference,\n+                              N_Indexed_Component,\n+                              N_Selected_Component,\n+                              N_Slice)\n+         loop\n+            Nam := Prefix (Nam);\n+         end loop;\n+\n+         if Is_Entity_Name (Nam)\n+           and then Present (Entity (Nam))\n+         then\n+            Set_Ghost_Mode_From_Entity (Entity (Nam));\n+         end if;\n+\n+      --  The input denotes a package or subprogram body\n+\n+      elsif Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n+         if (Present (Prev_Id) and then Is_Ghost_Entity (Prev_Id))\n+           or else Is_Subject_To_Ghost (N)\n+         then\n+            Set_Ghost_Mode_From_Policy;\n+         end if;\n+      end if;\n+   end Set_Ghost_Mode;\n+\n+   -------------------------------\n+   -- Set_Ghost_Mode_For_Freeze --\n+   -------------------------------\n+\n+   procedure Set_Ghost_Mode_For_Freeze (Id : Entity_Id; N : Node_Id) is\n+   begin\n+      if Is_Checked_Ghost_Entity (Id) then\n+         Ghost_Mode := Check;\n+\n+      elsif Is_Ignored_Ghost_Entity (Id) then\n+         Ghost_Mode := Ignore;\n+\n+         Propagate_Ignored_Ghost_Code (N);\n+      end if;\n+   end Set_Ghost_Mode_For_Freeze;\n+\n+   -------------------------\n+   -- Set_Is_Ghost_Entity --\n+   -------------------------\n+\n+   procedure Set_Is_Ghost_Entity (Id : Entity_Id) is\n+      Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n+\n+   begin\n+      if Policy = Name_Check then\n+         Set_Is_Checked_Ghost_Entity (Id);\n+\n+      elsif Policy = Name_Ignore then\n+         Set_Is_Ignored_Ghost_Entity (Id);\n+      end if;\n+   end Set_Is_Ghost_Entity;\n+\n+end Ghost;"}, {"sha": "436e84fe6167cf16ee31273b5cf9ba5f82268db6", "filename": "gcc/ada/ghost.ads", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fghost.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fghost.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -0,0 +1,115 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                G H O S T                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2014-2015, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines that deal with the static and runtime\n+--  semantics of Ghost entities.\n+\n+with Types; use Types;\n+\n+package Ghost is\n+\n+   procedure Add_Ignored_Ghost_Unit (Unit : Node_Id);\n+   --  Add a single ignored Ghost compilation unit to the internal table for\n+   --  post processing.\n+\n+   procedure Check_Ghost_Completion\n+     (Partial_View : Entity_Id;\n+      Full_View    : Entity_Id);\n+   --  Verify that the Ghost policy of a full view or a completion is the same\n+   --  as the Ghost policy of the partial view. Emit an error if this is not\n+   --  the case.\n+\n+   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id);\n+   --  Determine whether node Ghost_Ref appears within a Ghost-friendly context\n+   --  where Ghost entity Ghost_Id can safely reside.\n+\n+   procedure Check_Ghost_Derivation (Typ : Entity_Id);\n+   --  Verify that the parent type and all progenitors of derived type or type\n+   --  extension Typ are Ghost. If this is not the case, issue an error.\n+\n+   function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean;\n+   --  Determine whether type Typ implements at least one Ghost interface\n+\n+   procedure Initialize;\n+   --  Initialize internal tables\n+\n+   function Is_Ghost_Entity (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id is Ghost. To qualify as such, the entity\n+   --  must be subject to pragma Ghost.\n+\n+   function Is_Subject_To_Ghost (N : Node_Id) return Boolean;\n+   --  Determine whether declarative node N is subject to aspect or pragma\n+   --  Ghost. Use this routine in cases where [source] pragma Ghost has not\n+   --  been analyzed yet, but the context needs to establish the \"ghostness\"\n+   --  of N.\n+\n+   procedure Lock;\n+   --  Lock internal tables before calling backend\n+\n+   procedure Remove_Ignored_Ghost_Code;\n+   --  Remove all code marked as ignored Ghost from the trees of all qualifying\n+   --  units.\n+   --\n+   --  WARNING: this is a separate front end pass, care should be taken to keep\n+   --  it optimized.\n+\n+   procedure Set_Ghost_Mode (N : Node_Id; Prev_Id : Entity_Id := Empty);\n+   --  Set the value of global variable Ghost_Mode depending on the following\n+   --  scenarios:\n+   --\n+   --    If N is a declaration, determine whether N is subject to pragma Ghost.\n+   --    If this is the case, the Ghost_Mode is set based on the current Ghost\n+   --    policy in effect. Special cases:\n+   --\n+   --      N is the completion of a deferred constant, Prev_Id denotes the\n+   --      entity of the partial declaration.\n+   --\n+   --      N is the full view of a private type, Prev_Id denotes the entity\n+   --      of the partial declaration.\n+   --\n+   --    If N is an assignment statement or a procedure call, determine whether\n+   --    the name of N denotes a reference to a Ghost entity. If this is the\n+   --    case, the Global_Mode is set based on the mode of the name.\n+   --\n+   --    If N denotes a package or a subprogram body, determine whether the\n+   --    corresponding spec Prev_Id is a Ghost entity or the body is subject\n+   --    to pragma Ghost. If this is the case, the Global_Mode is set based on\n+   --    the current Ghost policy in effect.\n+   --\n+   --  WARNING: the caller must save and restore the value of Ghost_Mode in a\n+   --  a stack-like fasion as this routine may override the existing value.\n+\n+   procedure Set_Ghost_Mode_For_Freeze (Id : Entity_Id; N : Node_Id);\n+   --  Set the value of global variable Ghost_Mode depending on the mode of\n+   --  entity Id. N denotes the context of the freeze.\n+   --\n+   --  WARNING: the caller must save and restore the value of Ghost_Mode in a\n+   --  a stack-like fasion as this routine may override the existing value.\n+\n+   procedure Set_Is_Ghost_Entity (Id : Entity_Id);\n+   --  Set the relevant ghost attribute of entity Id depending on the current\n+   --  Ghost assertion policy in effect.\n+\n+end Ghost;"}, {"sha": "983c120c09ca864aaf635184e166619ab1c3b31a", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -36,6 +36,7 @@ with Fmap;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Frontend;\n+with Ghost;\n with Gnatvsn;  use Gnatvsn;\n with Inline;\n with Lib;      use Lib;\n@@ -863,7 +864,6 @@ begin\n       Lib.Xref.Initialize;\n       Scan_Compiler_Arguments;\n       Osint.Add_Default_Search_Dirs;\n-\n       Atree.Initialize;\n       Nlists.Initialize;\n       Sinput.Initialize;\n@@ -876,6 +876,7 @@ begin\n       SCOs.Initialize;\n       Snames.Initialize;\n       Stringt.Initialize;\n+      Ghost.Initialize;\n       Inline.Initialize;\n       Par_SCO.Initialize;\n       Sem_Ch8.Initialize;\n@@ -1291,12 +1292,13 @@ begin\n       Atree.Lock;\n       Elists.Lock;\n       Fname.UF.Lock;\n+      Ghost.Lock;\n       Inline.Lock;\n       Lib.Lock;\n+      Namet.Lock;\n       Nlists.Lock;\n       Sem.Lock;\n       Sinput.Lock;\n-      Namet.Lock;\n       Stringt.Lock;\n \n       --  Here we call the back end to generate the output code"}, {"sha": "11c2d06dabf3cf07be82e6cb5416cd5afe3acc75", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -1662,6 +1662,15 @@ package body Lib.Xref is\n          J := 1;\n          while J <= Xrefs.Last loop\n             Ent := Xrefs.Table (J).Key.Ent;\n+\n+            --  Do not generate reference information for an ignored Ghost\n+            --  entity because neither the entity nor its references will\n+            --  appear in the final tree.\n+\n+            if Is_Ignored_Ghost_Entity (Ent) then\n+               goto Orphan_Continue;\n+            end if;\n+\n             Get_Type_Reference (Ent, Tref, L, R);\n \n             if Present (Tref)\n@@ -1744,6 +1753,7 @@ package body Lib.Xref is\n                end;\n             end if;\n \n+            <<Orphan_Continue>>\n             J := J + 1;\n          end loop;\n       end Handle_Orphan_Type_References;\n@@ -1752,7 +1762,6 @@ package body Lib.Xref is\n       --  references, so we can sort them, and output them.\n \n       Output_Refs : declare\n-\n          Nrefs : constant Nat := Xrefs.Last;\n          --  Number of references in table\n \n@@ -2114,6 +2123,15 @@ package body Lib.Xref is\n \n             begin\n                Ent := XE.Key.Ent;\n+\n+               --  Do not generate reference information for an ignored Ghost\n+               --  entity because neither the entity nor its references will\n+               --  appear in the final tree.\n+\n+               if Is_Ignored_Ghost_Entity (Ent) then\n+                  goto Continue;\n+               end if;\n+\n                Ctyp := Xref_Entity_Letters (Ekind (Ent));\n \n                --  Skip reference if it is the only reference to an entity,"}, {"sha": "8cac209ffd2e49dd8c213617fa6aa2c7309056bc", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 120, "deletions": 120, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -440,25 +440,71 @@ package Lib is\n    --  do not have an entry for each possible field, since some of the fields\n    --  can only be set by specialized interfaces (defined below).\n \n-   function Version_Get (U : Unit_Number_Type) return Word_Hex_String;\n-   --  Returns the version as a string with 8 hex digits (upper case letters)\n+   function Compilation_Switches_Last return Nat;\n+   --  Return the count of stored compilation switches\n \n-   function Last_Unit return Unit_Number_Type;\n-   --  Unit number of last allocated unit\n+   procedure Disable_Switch_Storing;\n+   --  Disable registration of switches by Store_Compilation_Switch. Used to\n+   --  avoid registering switches added automatically by the gcc driver at the\n+   --  end of the command line.\n \n-   function Num_Units return Nat;\n-   --  Number of units currently in unit table\n+   function Earlier_In_Extended_Unit (S1, S2 : Source_Ptr) return Boolean;\n+   --  Given two Sloc values for which In_Same_Extended_Unit is true, determine\n+   --  if S1 appears before S2. Returns True if S1 appears before S2, and False\n+   --  otherwise. The result is undefined if S1 and S2 are not in the same\n+   --  extended unit. Note: this routine will not give reliable results if\n+   --  called after Sprint has been called with -gnatD set.\n \n-   procedure Remove_Unit (U : Unit_Number_Type);\n-   --  Remove unit U from unit table. Currently this is effective only\n-   --  if U is the last unit currently stored in the unit table.\n+   procedure Enable_Switch_Storing;\n+   --  Enable registration of switches by Store_Compilation_Switch. Used to\n+   --  avoid registering switches added automatically by the gcc driver at the\n+   --  beginning of the command line.\n \n    function Entity_Is_In_Main_Unit (E : Entity_Id) return Boolean;\n    --  Returns True if the entity E is declared in the main unit, or, in\n    --  its corresponding spec, or one of its subunits. Entities declared\n    --  within generic instantiations return True if the instantiation is\n    --  itself \"in the main unit\" by this definition. Otherwise False.\n \n+   function Exact_Source_Name (Loc : Source_Ptr) return String;\n+   --  Return name of entity at location Loc exactly as written in the source.\n+   --  this includes copying the wide character encodings exactly as they were\n+   --  used in the source, so the caller must be aware of the possibility of\n+   --  such encodings.\n+\n+   function Get_Compilation_Switch (N : Pos) return String_Ptr;\n+   --  Return the Nth stored compilation switch, or null if less than N\n+   --  switches have been stored. Used by ASIS and back ends written in Ada.\n+\n+   function Generic_May_Lack_ALI (Sfile : File_Name_Type) return Boolean;\n+   --  Generic units must be separately compiled. Since we always use\n+   --  macro substitution for generics, the resulting object file is a dummy\n+   --  one with no code, but the ALI file has the normal form, and we need\n+   --  this ALI file so that the binder can work out a correct order of\n+   --  elaboration.\n+   --\n+   --  However, ancient versions of GNAT used to not generate code or ALI\n+   --  files for generic units, and this would yield complex order of\n+   --  elaboration issues. These were fixed in GNAT 3.10. The support for not\n+   --  compiling language-defined library generics was retained nonetheless\n+   --  to facilitate bootstrap. Specifically, it is convenient to have\n+   --  the same list of files to be compiled for all stages. So, if the\n+   --  bootstrap compiler does not generate code for a given file, then\n+   --  the stage1 compiler (and binder) also must deal with the case of\n+   --  that file not being compiled. The predicate Generic_May_Lack_ALI is\n+   --  True for those generic units for which missing ALI files are allowed.\n+\n+   function Get_Cunit_Unit_Number (N : Node_Id) return Unit_Number_Type;\n+   --  Return unit number of the unit whose N_Compilation_Unit node is the\n+   --  one passed as an argument. This must always succeed since the node\n+   --  could not have been built without making a unit table entry.\n+\n+   function Get_Cunit_Entity_Unit_Number\n+     (E : Entity_Id) return Unit_Number_Type;\n+   --  Return unit number of the unit whose compilation unit spec entity is\n+   --  the one passed as an argument. This must always succeed since the\n+   --  entity could not have been built without making a unit table entry.\n+\n    function Get_Source_Unit (N : Node_Or_Entity_Id) return Unit_Number_Type;\n    pragma Inline (Get_Source_Unit);\n    function Get_Source_Unit (S : Source_Ptr) return Unit_Number_Type;\n@@ -478,34 +524,6 @@ package Lib is\n    --  template, so it returns the unit number containing the code that\n    --  corresponds to the node N, or the source location S.\n \n-   function In_Same_Source_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n-   pragma Inline (In_Same_Source_Unit);\n-   --  Determines if the two nodes or entities N1 and N2 are in the same\n-   --  source unit, the criterion being that Get_Source_Unit yields the\n-   --  same value for each argument.\n-\n-   function In_Same_Code_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n-   pragma Inline (In_Same_Code_Unit);\n-   --  Determines if the two nodes or entities N1 and N2 are in the same\n-   --  code unit, the criterion being that Get_Code_Unit yields the same\n-   --  value for each argument.\n-\n-   function In_Same_Extended_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n-   pragma Inline (In_Same_Extended_Unit);\n-   --  Determines if two nodes or entities N1 and N2 are in the same\n-   --  extended unit, where an extended unit is defined as a unit and all\n-   --  its subunits (considered recursively, i.e. subunits of subunits are\n-   --  included). Returns true if S1 and S2 are in the same extended unit\n-   --  and False otherwise.\n-\n-   function In_Same_Extended_Unit (S1, S2 : Source_Ptr) return Boolean;\n-   pragma Inline (In_Same_Extended_Unit);\n-   --  Determines if the two source locations S1 and S2 are in the same\n-   --  extended unit, where an extended unit is defined as a unit and all\n-   --  its subunits (considered recursively, i.e. subunits of subunits are\n-   --  included). Returns true if S1 and S2 are in the same extended unit\n-   --  and False otherwise.\n-\n    function In_Extended_Main_Code_Unit\n      (N : Node_Or_Entity_Id) return Boolean;\n    --  Return True if the node is in the generated code of the extended main\n@@ -550,48 +568,67 @@ package Lib is\n    function In_Predefined_Unit (S : Source_Ptr) return Boolean;\n    --  Same function as above but argument is a source pointer\n \n-   function Earlier_In_Extended_Unit (S1, S2 : Source_Ptr) return Boolean;\n-   --  Given two Sloc values for which In_Same_Extended_Unit is true, determine\n-   --  if S1 appears before S2. Returns True if S1 appears before S2, and False\n-   --  otherwise. The result is undefined if S1 and S2 are not in the same\n-   --  extended unit. Note: this routine will not give reliable results if\n-   --  called after Sprint has been called with -gnatD set.\n-\n-   function Exact_Source_Name (Loc : Source_Ptr) return String;\n-   --  Return name of entity at location Loc exactly as written in the source.\n-   --  this includes copying the wide character encodings exactly as they were\n-   --  used in the source, so the caller must be aware of the possibility of\n-   --  such encodings.\n-\n-   function Compilation_Switches_Last return Nat;\n-   --  Return the count of stored compilation switches\n+   function In_Same_Code_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n+   pragma Inline (In_Same_Code_Unit);\n+   --  Determines if the two nodes or entities N1 and N2 are in the same\n+   --  code unit, the criterion being that Get_Code_Unit yields the same\n+   --  value for each argument.\n \n-   function Get_Compilation_Switch (N : Pos) return String_Ptr;\n-   --  Return the Nth stored compilation switch, or null if less than N\n-   --  switches have been stored. Used by ASIS and back ends written in Ada.\n+   function In_Same_Extended_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n+   pragma Inline (In_Same_Extended_Unit);\n+   --  Determines if two nodes or entities N1 and N2 are in the same\n+   --  extended unit, where an extended unit is defined as a unit and all\n+   --  its subunits (considered recursively, i.e. subunits of subunits are\n+   --  included). Returns true if S1 and S2 are in the same extended unit\n+   --  and False otherwise.\n \n-   function Get_Cunit_Unit_Number (N : Node_Id) return Unit_Number_Type;\n-   --  Return unit number of the unit whose N_Compilation_Unit node is the\n-   --  one passed as an argument. This must always succeed since the node\n-   --  could not have been built without making a unit table entry.\n+   function In_Same_Extended_Unit (S1, S2 : Source_Ptr) return Boolean;\n+   pragma Inline (In_Same_Extended_Unit);\n+   --  Determines if the two source locations S1 and S2 are in the same\n+   --  extended unit, where an extended unit is defined as a unit and all\n+   --  its subunits (considered recursively, i.e. subunits of subunits are\n+   --  included). Returns true if S1 and S2 are in the same extended unit\n+   --  and False otherwise.\n \n-   function Get_Cunit_Entity_Unit_Number\n-     (E : Entity_Id) return Unit_Number_Type;\n-   --  Return unit number of the unit whose compilation unit spec entity is\n-   --  the one passed as an argument. This must always succeed since the\n-   --  entity could not have been built without making a unit table entry.\n+   function In_Same_Source_Unit (N1, N2 : Node_Or_Entity_Id) return Boolean;\n+   pragma Inline (In_Same_Source_Unit);\n+   --  Determines if the two nodes or entities N1 and N2 are in the same\n+   --  source unit, the criterion being that Get_Source_Unit yields the\n+   --  same value for each argument.\n \n    function Increment_Serial_Number return Nat;\n    --  Increment Serial_Number field for current unit, and return the\n    --  incremented value.\n \n-   procedure Synchronize_Serial_Number;\n-   --  This function increments the Serial_Number field for the current unit\n-   --  but does not return the incremented value. This is used when there\n-   --  is a situation where one path of control increments a serial number\n-   --  (using Increment_Serial_Number), and the other path does not and it is\n-   --  important to keep the serial numbers synchronized in the two cases (e.g.\n-   --  when the references in a package and a client must be kept consistent).\n+   procedure Initialize;\n+   --  Initialize internal tables\n+\n+   function Is_Loaded (Uname : Unit_Name_Type) return Boolean;\n+   --  Determines if unit with given name is already loaded, i.e. there is\n+   --  already an entry in the file table with this unit name for which the\n+   --  corresponding file was found and parsed. Note that the Fatal_Error flag\n+   --  of this entry must be checked before proceeding with further processing.\n+\n+   function Last_Unit return Unit_Number_Type;\n+   --  Unit number of last allocated unit\n+\n+   procedure List (File_Names_Only : Boolean := False);\n+   --  Lists units in active library (i.e. generates output consisting of a\n+   --  sorted listing of the units represented in File table, except for the\n+   --  main unit). If File_Names_Only is set to True, then the list includes\n+   --  only file names, and no other information. Otherwise the unit name and\n+   --  time stamp are also output. File_Names_Only also restricts the list to\n+   --  exclude any predefined files.\n+\n+   procedure Lock;\n+   --  Lock internal tables before calling back end\n+\n+   function Num_Units return Nat;\n+   --  Number of units currently in unit table\n+\n+   procedure Remove_Unit (U : Unit_Number_Type);\n+   --  Remove unit U from unit table. Currently this is effective only if U is\n+   --  the last unit currently stored in the unit table.\n \n    procedure Replace_Linker_Option_String\n      (S            : String_Id;\n@@ -604,16 +641,6 @@ package Lib is\n    --  which may influence the generated output file(s). Switch is the text of\n    --  the switch to store (except that -fRTS gets changed back to --RTS).\n \n-   procedure Enable_Switch_Storing;\n-   --  Enable registration of switches by Store_Compilation_Switch. Used to\n-   --  avoid registering switches added automatically by the gcc driver at the\n-   --  beginning of the command line.\n-\n-   procedure Disable_Switch_Storing;\n-   --  Disable registration of switches by Store_Compilation_Switch. Used to\n-   --  avoid registering switches added automatically by the gcc driver at the\n-   --  end of the command line.\n-\n    procedure Store_Linker_Option_String (S : String_Id);\n    --  This procedure is called to register the string from a pragma\n    --  Linker_Option. The argument is the Id of the string to register.\n@@ -622,14 +649,13 @@ package Lib is\n    --  This procedure is called to register a pragma N for which a notes\n    --  entry is required.\n \n-   procedure Initialize;\n-   --  Initialize internal tables\n-\n-   procedure Lock;\n-   --  Lock internal tables before calling back end\n-\n-   procedure Unlock;\n-   --  Unlock internal tables, in cases where the back end needs to modify them\n+   procedure Synchronize_Serial_Number;\n+   --  This function increments the Serial_Number field for the current unit\n+   --  but does not return the incremented value. This is used when there\n+   --  is a situation where one path of control increments a serial number\n+   --  (using Increment_Serial_Number), and the other path does not and it is\n+   --  important to keep the serial numbers synchronized in the two cases (e.g.\n+   --  when the references in a package and a client must be kept consistent).\n \n    procedure Tree_Read;\n    --  Initializes internal tables from current tree file using the relevant\n@@ -639,43 +665,17 @@ package Lib is\n    --  Writes out internal tables to current tree file using the relevant\n    --  Table.Tree_Write routines.\n \n-   function Is_Loaded (Uname : Unit_Name_Type) return Boolean;\n-   --  Determines if unit with given name is already loaded, i.e. there is\n-   --  already an entry in the file table with this unit name for which the\n-   --  corresponding file was found and parsed. Note that the Fatal_Error flag\n-   --  of this entry must be checked before proceeding with further processing.\n+   procedure Unlock;\n+   --  Unlock internal tables, in cases where the back end needs to modify them\n+\n+   function Version_Get (U : Unit_Number_Type) return Word_Hex_String;\n+   --  Returns the version as a string with 8 hex digits (upper case letters)\n \n    procedure Version_Referenced (S : String_Id);\n    --  This routine is called from Exp_Attr to register the use of a Version\n    --  or Body_Version attribute. The argument is the external name used to\n    --  access the version string.\n \n-   procedure List (File_Names_Only : Boolean := False);\n-   --  Lists units in active library (i.e. generates output consisting of a\n-   --  sorted listing of the units represented in File table, except for the\n-   --  main unit). If File_Names_Only is set to True, then the list includes\n-   --  only file names, and no other information. Otherwise the unit name and\n-   --  time stamp are also output. File_Names_Only also restricts the list to\n-   --  exclude any predefined files.\n-\n-   function Generic_May_Lack_ALI (Sfile : File_Name_Type) return Boolean;\n-   --  Generic units must be separately compiled. Since we always use\n-   --  macro substitution for generics, the resulting object file is a dummy\n-   --  one with no code, but the ALI file has the normal form, and we need\n-   --  this ALI file so that the binder can work out a correct order of\n-   --  elaboration.\n-   --\n-   --  However, ancient versions of GNAT used to not generate code or ALI\n-   --  files for generic units, and this would yield complex order of\n-   --  elaboration issues. These were fixed in GNAT 3.10. The support for not\n-   --  compiling language-defined library generics was retained nonetheless\n-   --  to facilitate bootstrap. Specifically, it is convenient to have\n-   --  the same list of files to be compiled for all stages. So, if the\n-   --  bootstrap compiler does not generate code for a given file, then\n-   --  the stage1 compiler (and binder) also must deal with the case of\n-   --  that file not being compiled. The predicate Generic_May_Lack_ALI is\n-   --  True for those generic units for which missing ALI files are allowed.\n-\n    procedure Write_Unit_Info\n      (Unit_Num : Unit_Number_Type;\n       Item     : Node_Id;"}, {"sha": "a1ce246bb81608dc141dc7433f0fef5ce4279d58", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -724,6 +724,14 @@ package Opt is\n    --  True if the frontend finished its work and has called the backend to\n    --  process the tree and generate the object file.\n \n+   type Ghost_Mode_Type is (None, Check, Ignore);\n+   --  Possible legal modes that can be set by aspect/pragma Ghost as well as\n+   --  value None, which indicates that no such aspect/pragma applies.\n+\n+   Ghost_Mode : Ghost_Mode_Type := None;\n+   --  GNAT\n+   --  Current Ghost mode setting\n+\n    Global_Discard_Names : Boolean := False;\n    --  GNAT, GNATBIND\n    --  True if a pragma Discard_Names appeared as a configuration pragma for"}, {"sha": "29ca1fa68d4de4ebb694d0bb551c521841df6f90", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -923,6 +923,12 @@ package body Rtsfind is\n          end loop;\n       end Save_Private_Visibility;\n \n+      --  Local variables\n+\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+      --  Save the current Ghost mode in effect to ensure a clean environment\n+      --  when analyzing the unit.\n+\n    --  Start of processing for Load_RTU\n \n    begin\n@@ -932,6 +938,10 @@ package body Rtsfind is\n          return;\n       end if;\n \n+      --  Provide a clean environment for the unit\n+\n+      Ghost_Mode := None;\n+\n       --  Note if secondary stack is used\n \n       if U_Id = System_Secondary_Stack then\n@@ -1032,6 +1042,10 @@ package body Rtsfind is\n       if Use_Setting then\n          Set_Is_Potentially_Use_Visible (U.Entity, True);\n       end if;\n+\n+      --  Restore the original Ghost mode now that analysis has taken place\n+\n+      Ghost_Mode := GM;\n    end Load_RTU;\n \n    --------------------"}, {"sha": "4451addbf3929ceecb14b5ab1b4a620d131cd0b1", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 116, "deletions": 101, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -95,6 +95,10 @@ package body Sem is\n    -------------\n \n    procedure Analyze (N : Node_Id) is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+      --  Save the current Ghost mode in effect in case the construct sets a\n+      --  different mode.\n+\n    begin\n       Debug_A_Entry (\"analyzing  \", N);\n \n@@ -108,7 +112,6 @@ package body Sem is\n       --  Otherwise processing depends on the node kind\n \n       case Nkind (N) is\n-\n          when N_Abort_Statement =>\n             Analyze_Abort_Statement (N);\n \n@@ -622,10 +625,9 @@ package body Sem is\n          --  the call to analyze them is generated when the full list is\n          --  analyzed.\n \n-         when\n-           N_SCIL_Dispatch_Table_Tag_Init |\n-           N_SCIL_Dispatching_Call        |\n-           N_SCIL_Membership_Test         =>\n+         when N_SCIL_Dispatch_Table_Tag_Init |\n+              N_SCIL_Dispatching_Call        |\n+              N_SCIL_Membership_Test         =>\n             null;\n \n          --  For the remaining node types, we generate compiler abort, because\n@@ -635,65 +637,63 @@ package body Sem is\n          --  node appears only in the context of a type declaration, and is\n          --  processed by the analyze routine for type declarations.\n \n-         when\n-           N_Abortable_Part                         |\n-           N_Access_Definition                      |\n-           N_Access_Function_Definition             |\n-           N_Access_Procedure_Definition            |\n-           N_Access_To_Object_Definition            |\n-           N_Aspect_Specification                   |\n-           N_Case_Expression_Alternative            |\n-           N_Case_Statement_Alternative             |\n-           N_Compilation_Unit_Aux                   |\n-           N_Component_Association                  |\n-           N_Component_Clause                       |\n-           N_Component_Definition                   |\n-           N_Component_List                         |\n-           N_Constrained_Array_Definition           |\n-           N_Contract                               |\n-           N_Decimal_Fixed_Point_Definition         |\n-           N_Defining_Character_Literal             |\n-           N_Defining_Identifier                    |\n-           N_Defining_Operator_Symbol               |\n-           N_Defining_Program_Unit_Name             |\n-           N_Delta_Constraint                       |\n-           N_Derived_Type_Definition                |\n-           N_Designator                             |\n-           N_Digits_Constraint                      |\n-           N_Discriminant_Association               |\n-           N_Discriminant_Specification             |\n-           N_Elsif_Part                             |\n-           N_Entry_Call_Statement                   |\n-           N_Enumeration_Type_Definition            |\n-           N_Exception_Handler                      |\n-           N_Floating_Point_Definition              |\n-           N_Formal_Decimal_Fixed_Point_Definition  |\n-           N_Formal_Derived_Type_Definition         |\n-           N_Formal_Discrete_Type_Definition        |\n-           N_Formal_Floating_Point_Definition       |\n-           N_Formal_Modular_Type_Definition         |\n-           N_Formal_Ordinary_Fixed_Point_Definition |\n-           N_Formal_Private_Type_Definition         |\n-           N_Formal_Incomplete_Type_Definition      |\n-           N_Formal_Signed_Integer_Type_Definition  |\n-           N_Function_Specification                 |\n-           N_Generic_Association                    |\n-           N_Index_Or_Discriminant_Constraint       |\n-           N_Iteration_Scheme                       |\n-           N_Mod_Clause                             |\n-           N_Modular_Type_Definition                |\n-           N_Ordinary_Fixed_Point_Definition        |\n-           N_Parameter_Specification                |\n-           N_Pragma_Argument_Association            |\n-           N_Procedure_Specification                |\n-           N_Real_Range_Specification               |\n-           N_Record_Definition                      |\n-           N_Signed_Integer_Type_Definition         |\n-           N_Unconstrained_Array_Definition         |\n-           N_Unused_At_Start                        |\n-           N_Unused_At_End                          |\n-           N_Variant                                =>\n-\n+         when N_Abortable_Part                         |\n+              N_Access_Definition                      |\n+              N_Access_Function_Definition             |\n+              N_Access_Procedure_Definition            |\n+              N_Access_To_Object_Definition            |\n+              N_Aspect_Specification                   |\n+              N_Case_Expression_Alternative            |\n+              N_Case_Statement_Alternative             |\n+              N_Compilation_Unit_Aux                   |\n+              N_Component_Association                  |\n+              N_Component_Clause                       |\n+              N_Component_Definition                   |\n+              N_Component_List                         |\n+              N_Constrained_Array_Definition           |\n+              N_Contract                               |\n+              N_Decimal_Fixed_Point_Definition         |\n+              N_Defining_Character_Literal             |\n+              N_Defining_Identifier                    |\n+              N_Defining_Operator_Symbol               |\n+              N_Defining_Program_Unit_Name             |\n+              N_Delta_Constraint                       |\n+              N_Derived_Type_Definition                |\n+              N_Designator                             |\n+              N_Digits_Constraint                      |\n+              N_Discriminant_Association               |\n+              N_Discriminant_Specification             |\n+              N_Elsif_Part                             |\n+              N_Entry_Call_Statement                   |\n+              N_Enumeration_Type_Definition            |\n+              N_Exception_Handler                      |\n+              N_Floating_Point_Definition              |\n+              N_Formal_Decimal_Fixed_Point_Definition  |\n+              N_Formal_Derived_Type_Definition         |\n+              N_Formal_Discrete_Type_Definition        |\n+              N_Formal_Floating_Point_Definition       |\n+              N_Formal_Modular_Type_Definition         |\n+              N_Formal_Ordinary_Fixed_Point_Definition |\n+              N_Formal_Private_Type_Definition         |\n+              N_Formal_Incomplete_Type_Definition      |\n+              N_Formal_Signed_Integer_Type_Definition  |\n+              N_Function_Specification                 |\n+              N_Generic_Association                    |\n+              N_Index_Or_Discriminant_Constraint       |\n+              N_Iteration_Scheme                       |\n+              N_Mod_Clause                             |\n+              N_Modular_Type_Definition                |\n+              N_Ordinary_Fixed_Point_Definition        |\n+              N_Parameter_Specification                |\n+              N_Pragma_Argument_Association            |\n+              N_Procedure_Specification                |\n+              N_Real_Range_Specification               |\n+              N_Record_Definition                      |\n+              N_Signed_Integer_Type_Definition         |\n+              N_Unconstrained_Array_Definition         |\n+              N_Unused_At_Start                        |\n+              N_Unused_At_End                          |\n+              N_Variant                                =>\n             raise Program_Error;\n       end case;\n \n@@ -719,6 +719,11 @@ package body Sem is\n       then\n          Expand (N);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze;\n \n    --  Version with check(s) suppressed\n@@ -1297,6 +1302,51 @@ package body Sem is\n    ---------------\n \n    procedure Semantics (Comp_Unit : Node_Id) is\n+      procedure Do_Analyze;\n+      --  Perform the analysis of the compilation unit\n+\n+      ----------------\n+      -- Do_Analyze --\n+      ----------------\n+\n+      procedure Do_Analyze is\n+         GM : constant Ghost_Mode_Type := Ghost_Mode;\n+         --  Save the current Ghost mode in effect in case the compilation unit\n+         --  is withed from a unit with a different Ghost mode.\n+\n+         List : Elist_Id;\n+\n+      begin\n+         List := Save_Scope_Stack;\n+         Push_Scope (Standard_Standard);\n+\n+         --  Set up a clean environment before analyzing\n+\n+         Ghost_Mode          := None;\n+         Outer_Generic_Scope := Empty;\n+         Scope_Suppress      := Suppress_Options;\n+         Scope_Stack.Table\n+           (Scope_Stack.Last).Component_Alignment_Default := Calign_Default;\n+         Scope_Stack.Table\n+           (Scope_Stack.Last).Is_Active_Stack_Base := True;\n+\n+         --  Now analyze the top level compilation unit node\n+\n+         Analyze (Comp_Unit);\n+\n+         --  Check for scope mismatch on exit from compilation\n+\n+         pragma Assert (Current_Scope = Standard_Standard\n+                          or else Comp_Unit = Cunit (Main_Unit));\n+\n+         --  Then pop entry for Standard, and pop implicit types\n+\n+         Pop_Scope;\n+         Restore_Scope_Stack (List);\n+         Ghost_Mode := GM;\n+      end Do_Analyze;\n+\n+      --  Local variables\n \n       --  The following locations save the corresponding global flags and\n       --  variables so that they can be restored on completion. This is needed\n@@ -1315,6 +1365,8 @@ package body Sem is\n       S_Outer_Gen_Scope   : constant Entity_Id        := Outer_Generic_Scope;\n       S_Style_Check       : constant Boolean          := Style_Check;\n \n+      Already_Analyzed : constant Boolean := Analyzed (Comp_Unit);\n+\n       Curunit : constant Unit_Number_Type := Get_Cunit_Unit_Number (Comp_Unit);\n       --  New value of Current_Sem_Unit\n \n@@ -1344,43 +1396,6 @@ package body Sem is\n       --  unit. All with'ed units are analyzed with config restrictions reset\n       --  and we need to restore these saved values at the end.\n \n-      procedure Do_Analyze;\n-      --  Procedure to analyze the compilation unit\n-\n-      ----------------\n-      -- Do_Analyze --\n-      ----------------\n-\n-      procedure Do_Analyze is\n-         List : Elist_Id;\n-\n-      begin\n-         List := Save_Scope_Stack;\n-         Push_Scope (Standard_Standard);\n-         Scope_Suppress := Suppress_Options;\n-         Scope_Stack.Table\n-           (Scope_Stack.Last).Component_Alignment_Default := Calign_Default;\n-         Scope_Stack.Table\n-           (Scope_Stack.Last).Is_Active_Stack_Base := True;\n-         Outer_Generic_Scope := Empty;\n-\n-         --  Now analyze the top level compilation unit node\n-\n-         Analyze (Comp_Unit);\n-\n-         --  Check for scope mismatch on exit from compilation\n-\n-         pragma Assert (Current_Scope = Standard_Standard\n-                          or else Comp_Unit = Cunit (Main_Unit));\n-\n-         --  Then pop entry for Standard, and pop implicit types\n-\n-         Pop_Scope;\n-         Restore_Scope_Stack (List);\n-      end Do_Analyze;\n-\n-      Already_Analyzed : constant Boolean := Analyzed (Comp_Unit);\n-\n    --  Start of processing for Semantics\n \n    begin"}, {"sha": "ca6c9639188dc2203783f504baab345185d1e337", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -27,6 +27,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -56,18 +57,25 @@ package body Sem_Ch11 is\n    procedure Analyze_Exception_Declaration (N : Node_Id) is\n       Id : constant Entity_Id := Defining_Identifier (N);\n       PF : constant Boolean   := Is_Pure (Current_Scope);\n+\n    begin\n+      --  The exception declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       Generate_Definition         (Id);\n       Enter_Name                  (Id);\n       Set_Ekind                   (Id, E_Exception);\n       Set_Etype                   (Id, Standard_Exception_Type);\n       Set_Is_Statically_Allocated (Id);\n       Set_Is_Pure                 (Id, PF);\n \n-      --  An exception declared within a Ghost scope is automatically Ghost\n+      --  An exception declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Within_Ghost_Scope then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n "}, {"sha": "4b88e1d607a63640656ffa1e9332fa04fc1e0971", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -33,6 +33,7 @@ with Exp_Disp; use Exp_Disp;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n@@ -2991,6 +2992,11 @@ package body Sem_Ch12 is\n       Decl        : Node_Id;\n \n    begin\n+      --  The generic package declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n       --  We introduce a renaming of the enclosing package, to have a usable\n@@ -3050,10 +3056,10 @@ package body Sem_Ch12 is\n       Set_Etype    (Id, Standard_Void_Type);\n       Set_Contract (Id, Make_Contract (Sloc (Id)));\n \n-      --  A generic package declared within a Ghost scope is rendered Ghost\n+      --  A generic package declared within a Ghost region is rendered Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Within_Ghost_Scope then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n \n@@ -3152,6 +3158,12 @@ package body Sem_Ch12 is\n       Typ         : Entity_Id;\n \n    begin\n+      --  The generic subprogram declaration may be subject to pragma Ghost\n+      --  with policy Ignore. Set the mode now to ensure that any nodes\n+      --  generated during analysis and expansion are properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n \n       --  Create copy of generic unit, and save for instantiation. If the unit\n@@ -3259,10 +3271,10 @@ package body Sem_Ch12 is\n          Set_Etype (Id, Standard_Void_Type);\n       end if;\n \n-      --  A generic subprogram declared within a Ghost scope is rendered Ghost\n+      --  A generic subprogram declared within a Ghost region is rendered Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Within_Ghost_Scope then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n "}, {"sha": "61be2f9b6022f2df07b79667cd0d05033858415b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 78, "deletions": 63, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -39,6 +39,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Itypes;   use Itypes;\n with Layout;   use Layout;\n with Lib;      use Lib;\n@@ -532,8 +533,8 @@ package body Sem_Ch3 is\n    function Find_Type_Of_Object\n      (Obj_Def     : Node_Id;\n       Related_Nod : Node_Id) return Entity_Id;\n-   --  Get type entity for object referenced by Obj_Def, attaching the\n-   --  implicit types generated to Related_Nod\n+   --  Get type entity for object referenced by Obj_Def, attaching the implicit\n+   --  types generated to Related_Nod.\n \n    procedure Floating_Point_Type_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Create a new float and apply the constraint to obtain subtype of it\n@@ -2552,9 +2553,15 @@ package body Sem_Ch3 is\n    begin\n       Prev := Find_Type_Name (N);\n \n-      --  The full view, if present, now points to the current type\n-      --  If there is an incomplete partial view, set a link to it, to\n-      --  simplify the retrieval of primitive operations of the type.\n+      --  The type declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N, Prev);\n+\n+      --  The full view, if present, now points to the current type. If there\n+      --  is an incomplete partial view, set a link to it, to simplify the\n+      --  retrieval of primitive operations of the type.\n \n       --  Ada 2005 (AI-50217): If the type was previously decorated when\n       --  imported through a LIMITED WITH clause, it appears as incomplete\n@@ -2704,10 +2711,10 @@ package body Sem_Ch3 is\n          Check_SPARK_05_Restriction (\"controlled type is not allowed\", N);\n       end if;\n \n-      --  A type declared within a Ghost scope is automatically Ghost\n+      --  A type declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Comes_From_Source (T) and then Within_Ghost_Scope then\n+      if Comes_From_Source (T) and then Ghost_Mode > None then\n          Set_Is_Ghost_Entity (T);\n       end if;\n \n@@ -2856,10 +2863,10 @@ package body Sem_Ch3 is\n       Set_Is_First_Subtype (T, True);\n       Set_Etype (T, T);\n \n-      --  An incomplete type declared within a Ghost scope is automatically\n+      --  An incomplete type declared within a Ghost region is automatically\n       --  Ghost (SPARK RM 6.9(2)).\n \n-      if Within_Ghost_Scope then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (T);\n       end if;\n \n@@ -2970,13 +2977,19 @@ package body Sem_Ch3 is\n       It    : Interp;\n \n    begin\n+      --  The number declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       Generate_Definition (Id);\n       Enter_Name (Id);\n \n-      --  A number declared within a Ghost scope is automatically Ghost\n+      --  A number declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Within_Ghost_Scope then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n \n@@ -3393,6 +3406,12 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  The object declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N, Prev_Entity);\n+\n       if Present (Prev_Entity) then\n          Constant_Redeclaration (Id, N, T);\n \n@@ -3917,10 +3936,10 @@ package body Sem_Ch3 is\n                   Set_Ekind (Id, E_Variable);\n                end if;\n \n-               --  An object declared within a Ghost scope is automatically\n+               --  An object declared within a Ghost region is automatically\n                --  Ghost (SPARK RM 6.9(2)).\n \n-               if Comes_From_Source (Id) and then Within_Ghost_Scope then\n+               if Comes_From_Source (Id) and then Ghost_Mode > None then\n                   Set_Is_Ghost_Entity (Id);\n \n                   --  The Ghost policy in effect at the point of declaration\n@@ -4098,16 +4117,13 @@ package body Sem_Ch3 is\n       Init_Esize                   (Id);\n       Set_Optimize_Alignment_Flags (Id);\n \n-      --  An object declared within a Ghost scope is automatically Ghost\n-      --  (SPARK RM 6.9(2)). This property is also inherited when its type\n-      --  is Ghost or the previous declaration of the deferred constant is\n-      --  Ghost.\n+      --  An object declared within a Ghost region is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n \n       if Comes_From_Source (Id)\n-        and then (Is_Ghost_Entity (T)\n+        and then (Ghost_Mode > None\n                    or else (Present (Prev_Entity)\n-                             and then Is_Ghost_Entity (Prev_Entity))\n-                   or else Within_Ghost_Scope)\n+                             and then Is_Ghost_Entity (Prev_Entity)))\n       then\n          Set_Is_Ghost_Entity (Id);\n \n@@ -4353,6 +4369,12 @@ package body Sem_Ch3 is\n       Parent_Base : Entity_Id;\n \n    begin\n+      --  The private extension declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Ada 2005 (AI-251): Decorate all names in list of ancestor interfaces\n \n       if Is_Non_Empty_List (Interface_List (N)) then\n@@ -4581,6 +4603,12 @@ package body Sem_Ch3 is\n       R_Checks : Check_Result;\n \n    begin\n+      --  The subtype declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       Generate_Definition (Id);\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n       Init_Size_Align (Id);\n@@ -5456,12 +5484,13 @@ package body Sem_Ch3 is\n \n          --  The constrained array type is a subtype of the unconstrained one\n \n-         Set_Ekind          (T, E_Array_Subtype);\n-         Init_Size_Align    (T);\n-         Set_Etype          (T, Implicit_Base);\n-         Set_Scope          (T, Current_Scope);\n-         Set_Is_Constrained (T, True);\n-         Set_First_Index    (T, First (Discrete_Subtype_Definitions (Def)));\n+         Set_Ekind              (T, E_Array_Subtype);\n+         Init_Size_Align        (T);\n+         Set_Etype              (T, Implicit_Base);\n+         Set_Scope              (T, Current_Scope);\n+         Set_Is_Constrained     (T);\n+         Set_First_Index        (T,\n+           First (Discrete_Subtype_Definitions (Def)));\n          Set_Has_Delayed_Freeze (T);\n \n          --  Complete setup of implicit base type\n@@ -5472,13 +5501,17 @@ package body Sem_Ch3 is\n          Set_Has_Protected     (Implicit_Base, Has_Protected (Element_Type));\n          Set_Component_Size    (Implicit_Base, Uint_0);\n          Set_Packed_Array_Impl_Type (Implicit_Base, Empty);\n-         Set_Has_Controlled_Component\n-                               (Implicit_Base,\n-                                  Has_Controlled_Component (Element_Type)\n-                                    or else Is_Controlled  (Element_Type));\n-         Set_Finalize_Storage_Only\n-                               (Implicit_Base, Finalize_Storage_Only\n-                                                        (Element_Type));\n+         Set_Has_Controlled_Component (Implicit_Base,\n+           Has_Controlled_Component (Element_Type)\n+             or else Is_Controlled  (Element_Type));\n+         Set_Finalize_Storage_Only (Implicit_Base,\n+           Finalize_Storage_Only (Element_Type));\n+\n+         --  Inherit the \"ghostness\" from the constrained array type\n+\n+         if Is_Ghost_Entity (T) or else Ghost_Mode > None then\n+            Set_Is_Ghost_Entity (Implicit_Base);\n+         end if;\n \n       --  Unconstrained array case\n \n@@ -5945,6 +5978,12 @@ package body Sem_Ch3 is\n          Copy_Array_Base_Type_Attributes (Implicit_Base, Parent_Base);\n \n          Set_Has_Delayed_Freeze (Implicit_Base, True);\n+\n+         --  Inherit the \"ghostness\" from the parent base type\n+\n+         if Is_Ghost_Entity (Parent_Base) or else Ghost_Mode > None then\n+            Set_Is_Ghost_Entity (Implicit_Base);\n+         end if;\n       end Make_Implicit_Base;\n \n    --  Start of processing for Build_Derived_Array_Type\n@@ -7720,34 +7759,6 @@ package body Sem_Ch3 is\n       Derived_Type : Entity_Id;\n       Derive_Subps : Boolean := True)\n    is\n-      function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean;\n-      --  Determine whether type Typ implements at least one Ghost interface\n-\n-      --------------------------------\n-      -- Implements_Ghost_Interface --\n-      --------------------------------\n-\n-      function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean is\n-         Iface_Elmt : Elmt_Id;\n-      begin\n-         --  Traverse the list of interfaces looking for a Ghost interface\n-\n-         if Is_Tagged_Type (Typ) and then Present (Interfaces (Typ)) then\n-            Iface_Elmt := First_Elmt (Interfaces (Typ));\n-            while Present (Iface_Elmt) loop\n-               if Is_Ghost_Entity (Node (Iface_Elmt)) then\n-                  return True;\n-               end if;\n-\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-         end if;\n-\n-         return False;\n-      end Implements_Ghost_Interface;\n-\n-      --  Local variables\n-\n       Discriminant_Specs : constant Boolean :=\n                              Present (Discriminant_Specifications (N));\n       Is_Tagged          : constant Boolean := Is_Tagged_Type (Parent_Type);\n@@ -7775,8 +7786,6 @@ package body Sem_Ch3 is\n       --  An empty Discs list means that there were no constraints in the\n       --  subtype indication or that there was an error processing it.\n \n-   --  Start of processing for Build_Derived_Record_Type\n-\n    begin\n       if Ekind (Parent_Type) = E_Record_Type_With_Private\n         and then Present (Full_View (Parent_Type))\n@@ -14630,6 +14639,12 @@ package body Sem_Ch3 is\n          Set_Alias (New_Subp, Actual_Subp);\n       end if;\n \n+      --  Inherit the \"ghostness\" from the parent subprogram\n+\n+      if Is_Ghost_Entity (Alias (New_Subp)) then\n+         Set_Is_Ghost_Entity (New_Subp);\n+      end if;\n+\n       --  Derived subprograms of a tagged type must inherit the convention\n       --  of the parent subprogram (a requirement of AI-117). Derived\n       --  subprograms of untagged types simply get convention Ada by default."}, {"sha": "5cd60dd71806874128c0d9ca83843bdb761e7f01", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -32,6 +32,7 @@ with Expander; use Expander;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -278,6 +279,13 @@ package body Sem_Ch5 is\n       --  proper use of a Ghost entity need to know the enclosing context.\n \n       Analyze (Lhs);\n+\n+      --  The left hand side of an assignment may reference an entity subject\n+      --  to pragma Ghost with policy Ignore. Set the mode now to ensure that\n+      --  any nodes generated during analysis and expansion are properly\n+      --  flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Analyze (Rhs);\n \n       --  Ensure that we never do an assignment on a variable marked as"}, {"sha": "5e987bcb16a7c4918a7e2380cab5b729edc5a316", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -40,6 +40,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Itypes;   use Itypes;\n with Lib.Xref; use Lib.Xref;\n@@ -213,6 +214,12 @@ package body Sem_Ch6 is\n       Scop       : constant Entity_Id := Current_Scope;\n \n    begin\n+      --  The abstract subprogram declaration may be subject to pragma Ghost\n+      --  with policy Ignore. Set the mode now to ensure that any nodes\n+      --  generated during analysis and expansion are properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"abstract subprogram is not allowed\", N);\n \n       Generate_Definition (Designator);\n@@ -223,10 +230,10 @@ package body Sem_Ch6 is\n \n       Set_Categorization_From_Scope (Designator, Scop);\n \n-      --  An abstract subprogram declared within a Ghost scope is automatically\n+      --  An abstract subprogram declared within a Ghost region is rendered\n       --  Ghost (SPARK RM 6.9(2)).\n \n-      if Comes_From_Source (Designator) and then Within_Ghost_Scope then\n+      if Comes_From_Source (Designator) and then Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Designator);\n       end if;\n \n@@ -1257,7 +1264,7 @@ package body Sem_Ch6 is\n          --  property is not directly inherited as the body may be subject\n          --  to a different Ghost assertion policy.\n \n-         if Is_Ghost_Entity (Gen_Id) or else Within_Ghost_Scope then\n+         if Is_Ghost_Entity (Gen_Id) or else Ghost_Mode > None then\n             Set_Is_Ghost_Entity (Body_Id);\n \n             --  The Ghost policy in effect at the point of declaration and at\n@@ -1606,6 +1613,13 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  The name of the procedure call may reference an entity subject to\n+      --  pragma Ghost with policy Ignore. Set the mode now to ensure that any\n+      --  nodes generated during analysis and expansion are properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Otherwise analyze the parameters\n \n       if Present (Actuals) then\n@@ -3113,6 +3127,13 @@ package body Sem_Ch6 is\n       then\n          if Is_Generic_Subprogram (Prev_Id) then\n             Spec_Id := Prev_Id;\n+\n+            --  The corresponding spec may be subject to pragma Ghost with\n+            --  policy Ignore. Set the mode now to ensure that any nodes\n+            --  generated during analysis and expansion are properly flagged\n+            --  as ignored Ghost.\n+\n+            Set_Ghost_Mode          (N, Spec_Id);\n             Set_Is_Compilation_Unit (Body_Id, Is_Compilation_Unit (Spec_Id));\n             Set_Is_Child_Unit       (Body_Id, Is_Child_Unit       (Spec_Id));\n \n@@ -3150,9 +3171,24 @@ package body Sem_Ch6 is\n          then\n             if Is_Private_Concurrent_Primitive (Body_Id) then\n                Spec_Id := Disambiguate_Spec;\n+\n+               --  The corresponding spec may be subject to pragma Ghost with\n+               --  policy Ignore. Set the mode now to ensure that any nodes\n+               --  generated during analysis and expansion are properly flagged\n+               --  as ignored Ghost.\n+\n+               Set_Ghost_Mode (N, Spec_Id);\n+\n             else\n                Spec_Id := Find_Corresponding_Spec (N);\n \n+               --  The corresponding spec may be subject to pragma Ghost with\n+               --  policy Ignore. Set the mode now to ensure that any nodes\n+               --  generated during analysis and expansion are properly flagged\n+               --  as ignored Ghost.\n+\n+               Set_Ghost_Mode (N, Spec_Id);\n+\n                --  In GNATprove mode, if the body has no previous spec, create\n                --  one so that the inlining machinery can operate properly.\n                --  Transfer aspects, if any, to the new spec, so that they\n@@ -3294,6 +3330,13 @@ package body Sem_Ch6 is\n \n          else\n             Spec_Id := Corresponding_Spec (N);\n+\n+            --  The corresponding spec may be subject to pragma Ghost with\n+            --  policy Ignore. Set the mode now to ensure that any nodes\n+            --  generated during analysis and expansion are properly flagged\n+            --  as ignored Ghost.\n+\n+            Set_Ghost_Mode (N, Spec_Id);\n          end if;\n       end if;\n \n@@ -3387,7 +3430,7 @@ package body Sem_Ch6 is\n             --  property is not directly inherited as the body may be subject\n             --  to a different Ghost assertion policy.\n \n-            if Is_Ghost_Entity (Spec_Id) or else Within_Ghost_Scope then\n+            if Is_Ghost_Entity (Spec_Id) or else Ghost_Mode > None then\n                Set_Is_Ghost_Entity (Body_Id);\n \n                --  The Ghost policy in effect at the point of declaration and\n@@ -4261,6 +4304,12 @@ package body Sem_Ch6 is\n       --  Indicates whether a null procedure declaration is a completion\n \n    begin\n+      --  The subprogram declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Null procedures are not allowed in SPARK\n \n       if Nkind (Specification (N)) = N_Procedure_Specification\n@@ -4294,12 +4343,12 @@ package body Sem_Ch6 is\n       --  explicit pragma).\n \n       Set_SPARK_Pragma (Designator, SPARK_Mode_Pragma);\n-      Set_SPARK_Pragma_Inherited (Designator, True);\n+      Set_SPARK_Pragma_Inherited (Designator);\n \n-      --  A subprogram declared within a Ghost scope is automatically Ghost\n+      --  A subprogram declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Comes_From_Source (Designator) and then Within_Ghost_Scope then\n+      if Comes_From_Source (Designator) and then Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Designator);\n       end if;\n "}, {"sha": "0a80db82653895c84c831c2de2df407eeb47c667", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -37,6 +37,7 @@ with Errout;   use Errout;\n with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n with Exp_Dbug; use Exp_Dbug;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -634,6 +635,13 @@ package body Sem_Ch7 is\n          end if;\n       end if;\n \n+      --  The corresponding spec of the package body may be subject to pragma\n+      --  Ghost with policy Ignore. Set the mode now to ensure that any nodes\n+      --  generated during analysis and expansion are properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode (N, Spec_Id);\n+\n       Set_Is_Compilation_Unit (Body_Id, Is_Compilation_Unit (Spec_Id));\n       Style.Check_Identifier (Body_Id, Spec_Id);\n \n@@ -731,7 +739,7 @@ package body Sem_Ch7 is\n       --  property is not directly inherited as the body may be subject to a\n       --  different Ghost assertion policy.\n \n-      if Is_Ghost_Entity (Spec_Id) or else Within_Ghost_Scope then\n+      if Is_Ghost_Entity (Spec_Id) or else Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Body_Id);\n \n          --  The Ghost policy in effect at the point of declaration and at the\n@@ -1001,6 +1009,12 @@ package body Sem_Ch7 is\n          Indent;\n       end if;\n \n+      --  The package declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       Generate_Definition (Id);\n       Enter_Name (Id);\n       Set_Ekind    (Id, E_Package);\n@@ -1762,6 +1776,12 @@ package body Sem_Ch7 is\n       Id : constant Entity_Id := Defining_Identifier (N);\n \n    begin\n+      --  The private type declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       Generate_Definition (Id);\n       Set_Is_Pure         (Id, PF);\n       Init_Size_Align     (Id);\n@@ -1775,10 +1795,10 @@ package body Sem_Ch7 is\n       New_Private_Type (N, Id, N);\n       Set_Depends_On_Private (Id);\n \n-      --  A type declared within a Ghost scope is automatically Ghost\n+      --  A type declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Within_Ghost_Scope then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n "}, {"sha": "8c7731488a09d539bf17196ae35e273a5ebe0b84", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -32,6 +32,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Impunit;  use Impunit;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n@@ -552,6 +553,12 @@ package body Sem_Ch8 is\n       Nam : constant Node_Id := Name (N);\n \n    begin\n+      --  The exception renaming declaration may be subject to pragma Ghost\n+      --  with policy Ignore. Set the mode now to ensure that any nodes\n+      --  generated during analysis and expansion are properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"exception renaming is not allowed\", N);\n \n       Enter_Name (Id);\n@@ -575,7 +582,7 @@ package body Sem_Ch8 is\n          --  An exception renaming is Ghost if the renamed entity is Ghost or\n          --  the construct appears within a Ghost scope.\n \n-         if Is_Ghost_Entity (Entity (Nam)) or else Within_Ghost_Scope then\n+         if Is_Ghost_Entity (Entity (Nam)) or else Ghost_Mode > None then\n             Set_Is_Ghost_Entity (Id);\n          end if;\n       end if;\n@@ -665,6 +672,11 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n+      --  The generic renaming declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"generic renaming is not allowed\", N);\n \n       Generate_Definition (New_P);\n@@ -711,7 +723,7 @@ package body Sem_Ch8 is\n          --  An generic renaming is Ghost if the renamed entity is Ghost or the\n          --  construct appears within a Ghost scope.\n \n-         if Is_Ghost_Entity (Old_P) or else Within_Ghost_Scope then\n+         if Is_Ghost_Entity (Old_P) or else Ghost_Mode > None then\n             Set_Is_Ghost_Entity (New_P);\n          end if;\n \n@@ -850,6 +862,11 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n+      --  The object renaming declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"object renaming is not allowed\", N);\n \n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n@@ -1315,7 +1332,7 @@ package body Sem_Ch8 is\n \n       if (Is_Entity_Name (Nam)\n            and then Is_Ghost_Entity (Entity (Nam)))\n-        or else Within_Ghost_Scope\n+        or else Ghost_Mode > None\n       then\n          Set_Is_Ghost_Entity (Id);\n       end if;\n@@ -1371,6 +1388,12 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n+      --  The package renaming declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Check for Text_IO special unit (we may be renaming a Text_IO child)\n \n       Check_Text_IO_Special_Unit (Name (N));\n@@ -1437,7 +1460,7 @@ package body Sem_Ch8 is\n          --  A package renaming is Ghost if the renamed entity is Ghost or\n          --  the construct appears within a Ghost scope.\n \n-         if Is_Ghost_Entity (Old_P) or else Within_Ghost_Scope then\n+         if Is_Ghost_Entity (Old_P) or else Ghost_Mode > None then\n             Set_Is_Ghost_Entity (New_P);\n          end if;\n \n@@ -2559,6 +2582,13 @@ package body Sem_Ch8 is\n    --  Start of processing for Analyze_Subprogram_Renaming\n \n    begin\n+      --  The subprogram renaming declaration may be subject to pragma Ghost\n+      --  with policy Ignore. Set the mode now to ensure that any nodes\n+      --  generated during analysis and expansion are properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  We must test for the attribute renaming case before the Analyze\n       --  call because otherwise Sem_Attr will complain that the attribute\n       --  is missing an argument when it is analyzed.\n@@ -3027,7 +3057,7 @@ package body Sem_Ch8 is\n          --  A subprogram renaming is Ghost if the renamed entity is Ghost or\n          --  the construct appears within a Ghost scope.\n \n-         if Is_Ghost_Entity (Entity (Nam)) or else Within_Ghost_Scope then\n+         if Is_Ghost_Entity (Entity (Nam)) or else Ghost_Mode > None then\n             Set_Is_Ghost_Entity (New_S);\n          end if;\n \n@@ -7184,6 +7214,12 @@ package body Sem_Ch8 is\n          elsif Is_Floating_Point_Type (Etype (N)) then\n             Check_Restriction (No_Floating_Point, N);\n          end if;\n+\n+         --  A Ghost type must appear in a specific context\n+\n+         if Is_Ghost_Entity (Etype (N)) then\n+            Check_Ghost_Context (Etype (N), N);\n+         end if;\n       end if;\n    end Find_Type;\n "}, {"sha": "dd2bc1be43ec233c29c54c3b2063c8ecd35fad9b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -41,6 +41,7 @@ with Errout;   use Errout;\n with Exp_Dist; use Exp_Dist;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Writ; use Lib.Writ;\n with Lib.Xref; use Lib.Xref;\n@@ -8412,7 +8413,7 @@ package body Sem_Prag is\n                   --  If previous error, avoid cascaded errors\n \n                   Check_Error_Detected;\n-                  Applies   := True;\n+                  Applies := True;\n \n                else\n                   Make_Inline (Subp);\n@@ -8434,8 +8435,7 @@ package body Sem_Prag is\n             end if;\n \n             if not Applies then\n-               Error_Pragma_Arg\n-                 (\"inappropriate argument for pragma%\", Assoc);\n+               Error_Pragma_Arg (\"inappropriate argument for pragma%\", Assoc);\n             end if;\n \n             Next (Assoc);\n@@ -10212,10 +10212,10 @@ package body Sem_Prag is\n                   Set_Refinement_Constituents (State_Id, New_Elmt_List);\n                   Set_Part_Of_Constituents    (State_Id, New_Elmt_List);\n \n-                  --  An abstract state declared within a Ghost scope becomes\n+                  --  An abstract state declared within a Ghost region becomes\n                   --  Ghost (SPARK RM 6.9(2)).\n \n-                  if Within_Ghost_Scope then\n+                  if Ghost_Mode > None then\n                      Set_Is_Ghost_Entity (State_Id);\n                   end if;\n \n@@ -11907,7 +11907,7 @@ package body Sem_Prag is\n                   --  Pragma Check_Policy specifying a Ghost policy cannot\n                   --  occur within a ghost subprogram or package.\n \n-                  if Within_Ghost_Scope then\n+                  if Ghost_Mode > None then\n                      Error_Pragma\n                        (\"pragma % cannot appear within ghost subprogram or \"\n                         & \"package\");\n@@ -14377,7 +14377,7 @@ package body Sem_Prag is\n                   --  region (SPARK RM 6.9(7)).\n \n                   if Is_False (Expr_Value (Expr))\n-                    and then Within_Ghost_Scope\n+                    and then Ghost_Mode > None\n                   then\n                      Error_Pragma\n                        (\"pragma % with value False cannot appear in enabled \"\n@@ -14941,7 +14941,7 @@ package body Sem_Prag is\n          -- Independent_Components --\n          ----------------------------\n \n-         --  pragma Independent_Components (array_or_record_LOCAL_NAME);\n+         --  pragma Atomic_Components (array_or_record_LOCAL_NAME);\n \n          when Pragma_Independent_Components => Independent_Components : declare\n             E_Id : Node_Id;"}, {"sha": "8f762d44b958fac50c08c826e5b172e058791602", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 191, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -37,6 +37,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n@@ -110,10 +111,6 @@ package body Sem_Res is\n       Pref : Node_Id);\n    --  Check that the type of the prefix of a dereference is not incomplete\n \n-   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id);\n-   --  Determine whether node Ghost_Ref appears within a Ghost-friendly context\n-   --  where Ghost entity Ghost_Id can safely reside.\n-\n    function Check_Infinite_Recursion (N : Node_Id) return Boolean;\n    --  Given a call node, N, which is known to occur immediately within the\n    --  subprogram being called, determines whether it is a detectable case of\n@@ -694,193 +691,6 @@ package body Sem_Res is\n       end if;\n    end Check_Fully_Declared_Prefix;\n \n-   -------------------------\n-   -- Check_Ghost_Context --\n-   -------------------------\n-\n-   procedure Check_Ghost_Context (Ghost_Id : Entity_Id; Ghost_Ref : Node_Id) is\n-      procedure Check_Ghost_Policy (Id : Entity_Id; Err_N : Node_Id);\n-      --  Verify that the Ghost policy at the point of declaration of entity Id\n-      --  matches the policy at the point of reference. If this is not the case\n-      --  emit an error at Err_N.\n-\n-      function Is_OK_Ghost_Context (Context : Node_Id) return Boolean;\n-      --  Determine whether node Context denotes a Ghost-friendly context where\n-      --  a Ghost entity can safely reside.\n-\n-      -------------------------\n-      -- Is_OK_Ghost_Context --\n-      -------------------------\n-\n-      function Is_OK_Ghost_Context (Context : Node_Id) return Boolean is\n-         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean;\n-         --  Determine whether node Decl is a Ghost declaration or appears\n-         --  within a Ghost declaration.\n-\n-         --------------------------\n-         -- Is_Ghost_Declaration --\n-         --------------------------\n-\n-         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean is\n-            Par       : Node_Id;\n-            Subp_Decl : Node_Id;\n-            Subp_Id   : Entity_Id;\n-\n-         begin\n-            --  Climb the parent chain looking for an object declaration\n-\n-            Par := Decl;\n-            while Present (Par) loop\n-               case Nkind (Par) is\n-                  when N_Abstract_Subprogram_Declaration        |\n-                       N_Exception_Declaration                  |\n-                       N_Exception_Renaming_Declaration         |\n-                       N_Full_Type_Declaration                  |\n-                       N_Generic_Function_Renaming_Declaration  |\n-                       N_Generic_Package_Declaration            |\n-                       N_Generic_Package_Renaming_Declaration   |\n-                       N_Generic_Procedure_Renaming_Declaration |\n-                       N_Generic_Subprogram_Declaration         |\n-                       N_Number_Declaration                     |\n-                       N_Object_Declaration                     |\n-                       N_Object_Renaming_Declaration            |\n-                       N_Package_Declaration                    |\n-                       N_Package_Renaming_Declaration           |\n-                       N_Private_Extension_Declaration          |\n-                       N_Private_Type_Declaration               |\n-                       N_Subprogram_Declaration                 |\n-                       N_Subprogram_Renaming_Declaration        |\n-                       N_Subtype_Declaration                    =>\n-                     return Is_Subject_To_Ghost (Par);\n-\n-                  when others                                   =>\n-                     null;\n-               end case;\n-\n-               --  Special cases\n-\n-               --  A reference to a Ghost entity may appear as the default\n-               --  expression of a formal parameter of a subprogram body. This\n-               --  context must be treated as suitable because the relation\n-               --  between the spec and the body has not been established and\n-               --  the body is not marked as Ghost yet. The real check was\n-               --  performed on the spec.\n-\n-               if Nkind (Par) = N_Parameter_Specification\n-                 and then Nkind (Parent (Parent (Par))) = N_Subprogram_Body\n-               then\n-                  return True;\n-\n-               --  References to Ghost entities may be relocated in internally\n-               --  generated bodies.\n-\n-               elsif Nkind (Par) = N_Subprogram_Body\n-                 and then not Comes_From_Source (Par)\n-               then\n-                  Subp_Id := Corresponding_Spec (Par);\n-\n-                  --  The original context is an expression function that has\n-                  --  been split into a spec and a body. The context is OK as\n-                  --  long as the the initial declaration is Ghost.\n-\n-                  if Present (Subp_Id) then\n-                     Subp_Decl :=\n-                       Original_Node (Unit_Declaration_Node (Subp_Id));\n-\n-                     if Nkind (Subp_Decl) = N_Expression_Function then\n-                        return Is_Subject_To_Ghost (Subp_Decl);\n-                     end if;\n-                  end if;\n-\n-                  --  Otherwise this is either an internal body or an internal\n-                  --  completion. Both are OK because the real check was done\n-                  --  before expansion activities.\n-\n-                  return True;\n-               end if;\n-\n-               --  Prevent the search from going too far\n-\n-               if Is_Body_Or_Package_Declaration (Par) then\n-                  return False;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            return False;\n-         end Is_Ghost_Declaration;\n-\n-      --  Start of processing for Is_OK_Ghost_Context\n-\n-      begin\n-         --  The Ghost entity appears within an assertion expression\n-\n-         if In_Assertion_Expr > 0 then\n-            return True;\n-\n-         --  The Ghost entity is part of a declaration or its completion\n-\n-         elsif Is_Ghost_Declaration (Context) then\n-            return True;\n-\n-         --  The Ghost entity is referenced within a Ghost statement\n-\n-         elsif Is_Ghost_Statement_Or_Pragma (Context) then\n-            return True;\n-\n-         else\n-            return False;\n-         end if;\n-      end Is_OK_Ghost_Context;\n-\n-      ------------------------\n-      -- Check_Ghost_Policy --\n-      ------------------------\n-\n-      procedure Check_Ghost_Policy (Id : Entity_Id; Err_N : Node_Id) is\n-         Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n-\n-      begin\n-         --  The Ghost policy in effect a the point of declaration and at the\n-         --  point of use must match (SPARK RM 6.9(14)).\n-\n-         if Is_Checked_Ghost_Entity (Id) and then Policy = Name_Ignore then\n-            Error_Msg_Sloc := Sloc (Err_N);\n-\n-            Error_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n-            Error_Msg_NE (\"\\& declared with ghost policy Check\", Err_N, Id);\n-            Error_Msg_NE (\"\\& used # with ghost policy Ignore\", Err_N, Id);\n-\n-         elsif Is_Ignored_Ghost_Entity (Id) and then Policy = Name_Check then\n-            Error_Msg_Sloc := Sloc (Err_N);\n-\n-            Error_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n-            Error_Msg_NE (\"\\& declared with ghost policy Ignore\", Err_N, Id);\n-            Error_Msg_NE (\"\\& used # with ghost policy Check\", Err_N, Id);\n-         end if;\n-      end Check_Ghost_Policy;\n-\n-   --  Start of processing for Check_Ghost_Context\n-\n-   begin\n-      --  Once it has been established that the reference to the Ghost entity\n-      --  is within a suitable context, ensure that the policy at the point of\n-      --  declaration and at the point of use match.\n-\n-      if Is_OK_Ghost_Context (Ghost_Ref) then\n-         Check_Ghost_Policy (Ghost_Id, Ghost_Ref);\n-\n-      --  Otherwise the Ghost entity appears in a non-Ghost context and affects\n-      --  its behavior or value.\n-\n-      else\n-         Error_Msg_N\n-           (\"ghost entity cannot appear in this context (SPARK RM 6.9(12))\",\n-            Ghost_Ref);\n-      end if;\n-   end Check_Ghost_Context;\n-\n    ------------------------------\n    -- Check_Infinite_Recursion --\n    ------------------------------"}, {"sha": "51a673874160cbea0f1aa6afc16ee375649dd0fc", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 41, "deletions": 345, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -70,7 +70,7 @@ with GNAT.HTable; use GNAT.HTable;\n package body Sem_Util is\n \n    ----------------------------------------\n-   -- Global_Variables for New_Copy_Tree --\n+   -- Global Variables for New_Copy_Tree --\n    ----------------------------------------\n \n    --  These global variables are used by New_Copy_Tree. See description of the\n@@ -110,12 +110,6 @@ package body Sem_Util is\n    --  and Build_Discriminal_Subtype_Of_Component. C is a list of constraints,\n    --  Loc is the source location, T is the original subtype.\n \n-   function Is_Fully_Initialized_Variant (Typ : Entity_Id) return Boolean;\n-   --  Subsidiary to Is_Fully_Initialized_Type. For an unconstrained type\n-   --  with discriminants whose default values are static, examine only the\n-   --  components in the selected variant to determine whether all of them\n-   --  have a default.\n-\n    function Has_Enabled_Property\n      (Item_Id  : Entity_Id;\n       Property : Name_Id) return Boolean;\n@@ -127,6 +121,12 @@ package body Sem_Util is\n    --  T is a derived tagged type. Check whether the type extension is null.\n    --  If the parent type is fully initialized, T can be treated as such.\n \n+   function Is_Fully_Initialized_Variant (Typ : Entity_Id) return Boolean;\n+   --  Subsidiary to Is_Fully_Initialized_Type. For an unconstrained type\n+   --  with discriminants whose default values are static, examine only the\n+   --  components in the selected variant to determine whether all of them\n+   --  have a default.\n+\n    ------------------------------\n    --  Abstract_Interface_List --\n    ------------------------------\n@@ -2676,82 +2676,6 @@ package body Sem_Util is\n       end if;\n    end Check_Function_Writable_Actuals;\n \n-   ----------------------------\n-   -- Check_Ghost_Completion --\n-   ----------------------------\n-\n-   procedure Check_Ghost_Completion\n-     (Partial_View : Entity_Id;\n-      Full_View    : Entity_Id)\n-   is\n-      Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n-\n-   begin\n-      --  The Ghost policy in effect at the point of declaration and at the\n-      --  point of completion must match (SPARK RM 6.9(15)).\n-\n-      if Is_Checked_Ghost_Entity (Partial_View)\n-        and then Policy = Name_Ignore\n-      then\n-         Error_Msg_Sloc := Sloc (Full_View);\n-\n-         Error_Msg_N (\"incompatible ghost policies in effect\",   Partial_View);\n-         Error_Msg_N (\"\\& declared with ghost policy Check\",     Partial_View);\n-         Error_Msg_N (\"\\& completed # with ghost policy Ignore\", Partial_View);\n-\n-      elsif Is_Ignored_Ghost_Entity (Partial_View)\n-        and then Policy = Name_Check\n-      then\n-         Error_Msg_Sloc := Sloc (Full_View);\n-\n-         Error_Msg_N (\"incompatible ghost policies in effect\",  Partial_View);\n-         Error_Msg_N (\"\\& declared with ghost policy Ignore\",   Partial_View);\n-         Error_Msg_N (\"\\& completed # with ghost policy Check\", Partial_View);\n-      end if;\n-   end Check_Ghost_Completion;\n-\n-   ----------------------------\n-   -- Check_Ghost_Derivation --\n-   ----------------------------\n-\n-   procedure Check_Ghost_Derivation (Typ : Entity_Id) is\n-      Parent_Typ : constant Entity_Id := Etype (Typ);\n-      Iface      : Entity_Id;\n-      Iface_Elmt : Elmt_Id;\n-\n-   begin\n-      --  Allow untagged derivations from predefined types such as Integer as\n-      --  those are not Ghost by definition.\n-\n-      if Is_Scalar_Type (Typ) and then Parent_Typ = Base_Type (Typ) then\n-         null;\n-\n-      --  The parent type of a Ghost type extension must be Ghost\n-\n-      elsif not Is_Ghost_Entity (Parent_Typ) then\n-         Error_Msg_N  (\"type extension & cannot be ghost\", Typ);\n-         Error_Msg_NE (\"\\parent type & is not ghost\", Typ, Parent_Typ);\n-         return;\n-      end if;\n-\n-      --  All progenitors (if any) must be Ghost as well\n-\n-      if Is_Tagged_Type (Typ) and then Present (Interfaces (Typ)) then\n-         Iface_Elmt := First_Elmt (Interfaces (Typ));\n-         while Present (Iface_Elmt) loop\n-            Iface := Node (Iface_Elmt);\n-\n-            if not Is_Ghost_Entity (Iface) then\n-               Error_Msg_N  (\"type extension & cannot be ghost\", Typ);\n-               Error_Msg_NE (\"\\interface type & is not ghost\", Typ, Iface);\n-               return;\n-            end if;\n-\n-            Next_Elmt (Iface_Elmt);\n-         end loop;\n-      end if;\n-   end Check_Ghost_Derivation;\n-\n    --------------------------------\n    -- Check_Implicit_Dereference --\n    --------------------------------\n@@ -9498,7 +9422,7 @@ package body Sem_Util is\n          Pkg_Decl : Node_Id := Pkg;\n \n       begin\n-         if Ekind (Pkg) = E_Package then\n+         if Present (Pkg) and then Ekind (Pkg) = E_Package then\n             while Nkind (Pkg_Decl) /= N_Package_Specification loop\n                Pkg_Decl := Parent (Pkg_Decl);\n             end loop;\n@@ -10437,6 +10361,39 @@ package body Sem_Util is\n         and then Is_Imported (Entity (Name (N)));\n    end Is_CPP_Constructor_Call;\n \n+   --------------------\n+   -- Is_Declaration --\n+   --------------------\n+\n+   function Is_Declaration (N : Node_Id) return Boolean is\n+   begin\n+      case Nkind (N) is\n+         when N_Abstract_Subprogram_Declaration        |\n+              N_Exception_Declaration                  |\n+              N_Exception_Renaming_Declaration         |\n+              N_Full_Type_Declaration                  |\n+              N_Generic_Function_Renaming_Declaration  |\n+              N_Generic_Package_Declaration            |\n+              N_Generic_Package_Renaming_Declaration   |\n+              N_Generic_Procedure_Renaming_Declaration |\n+              N_Generic_Subprogram_Declaration         |\n+              N_Number_Declaration                     |\n+              N_Object_Declaration                     |\n+              N_Object_Renaming_Declaration            |\n+              N_Package_Declaration                    |\n+              N_Package_Renaming_Declaration           |\n+              N_Private_Extension_Declaration          |\n+              N_Private_Type_Declaration               |\n+              N_Subprogram_Declaration                 |\n+              N_Subprogram_Renaming_Declaration        |\n+              N_Subtype_Declaration                    =>\n+            return True;\n+\n+         when others                                   =>\n+            return False;\n+      end case;\n+   end Is_Declaration;\n+\n    -----------------\n    -- Is_Delegate --\n    -----------------\n@@ -11209,110 +11166,6 @@ package body Sem_Util is\n       end if;\n    end Is_Fully_Initialized_Variant;\n \n-   ---------------------\n-   -- Is_Ghost_Entity --\n-   ---------------------\n-\n-   function Is_Ghost_Entity (Id : Entity_Id) return Boolean is\n-   begin\n-      return Is_Checked_Ghost_Entity (Id) or else Is_Ignored_Ghost_Entity (Id);\n-   end Is_Ghost_Entity;\n-\n-   ----------------------------------\n-   -- Is_Ghost_Statement_Or_Pragma --\n-   ----------------------------------\n-\n-   function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean is\n-      function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean;\n-      --  Determine whether an arbitrary node denotes a reference to a Ghost\n-      --  entity.\n-\n-      -------------------------------\n-      -- Is_Ghost_Entity_Reference --\n-      -------------------------------\n-\n-      function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean is\n-         Ref : Node_Id;\n-\n-      begin\n-         Ref := N;\n-\n-         --  When the reference extracts a subcomponent, recover the related\n-         --  object (SPARK RM 6.9(1)).\n-\n-         while Nkind_In (Ref, N_Explicit_Dereference,\n-                              N_Indexed_Component,\n-                              N_Selected_Component,\n-                              N_Slice)\n-         loop\n-            Ref := Prefix (Ref);\n-         end loop;\n-\n-         return\n-           Is_Entity_Name (Ref)\n-             and then Present (Entity (Ref))\n-             and then Is_Ghost_Entity (Entity (Ref));\n-      end Is_Ghost_Entity_Reference;\n-\n-      --  Local variables\n-\n-      Arg  : Node_Id;\n-      Stmt : Node_Id;\n-\n-   --  Start of processing for Is_Ghost_Statement_Or_Pragma\n-\n-   begin\n-      if Nkind (N) = N_Pragma then\n-\n-         --  A pragma is Ghost when it appears within a Ghost package or\n-         --  subprogram.\n-\n-         if Within_Ghost_Scope then\n-            return True;\n-         end if;\n-\n-         --  A pragma is Ghost when it mentions a Ghost entity\n-\n-         Arg := First (Pragma_Argument_Associations (N));\n-         while Present (Arg) loop\n-            if Is_Ghost_Entity_Reference (Get_Pragma_Arg (Arg)) then\n-               return True;\n-            end if;\n-\n-            Next (Arg);\n-         end loop;\n-      end if;\n-\n-      Stmt := N;\n-      while Present (Stmt) loop\n-\n-         --  A statement is Ghost when it appears within a Ghost package or\n-         --  subprogram.\n-\n-         if Is_Statement (Stmt) and then Within_Ghost_Scope then\n-            return True;\n-\n-         --  An assignment statement is Ghost when the target is a Ghost\n-         --  variable. A procedure call is Ghost when the invoked procedure\n-         --  is Ghost.\n-\n-         elsif Nkind_In (Stmt, N_Assignment_Statement,\n-                               N_Procedure_Call_Statement)\n-         then\n-            return Is_Ghost_Entity_Reference (Name (Stmt));\n-\n-         --  Prevent the search from going too far\n-\n-         elsif Is_Body_Or_Package_Declaration (Stmt) then\n-            return False;\n-         end if;\n-\n-         Stmt := Parent (Stmt);\n-      end loop;\n-\n-      return False;\n-   end Is_Ghost_Statement_Or_Pragma;\n-\n    ----------------------------\n    -- Is_Inherited_Operation --\n    ----------------------------\n@@ -12417,123 +12270,6 @@ package body Sem_Util is\n           or else Nkind (N) = N_Procedure_Call_Statement;\n    end Is_Statement;\n \n-   -------------------------\n-   -- Is_Subject_To_Ghost --\n-   -------------------------\n-\n-   function Is_Subject_To_Ghost (N : Node_Id) return Boolean is\n-      function Enables_Ghostness (Arg : Node_Id) return Boolean;\n-      --  Determine whether aspect or pragma argument Arg enables \"ghostness\"\n-\n-      -----------------------\n-      -- Enables_Ghostness --\n-      -----------------------\n-\n-      function Enables_Ghostness (Arg : Node_Id) return Boolean is\n-         Expr : Node_Id;\n-\n-      begin\n-         Expr := Arg;\n-\n-         if Nkind (Expr) = N_Pragma_Argument_Association then\n-            Expr := Get_Pragma_Arg (Expr);\n-         end if;\n-\n-         --  Determine whether the expression of the aspect is static and\n-         --  denotes True.\n-\n-         if Present (Expr) then\n-            Preanalyze_And_Resolve (Expr);\n-\n-            return\n-              Is_OK_Static_Expression (Expr)\n-                and then Is_True (Expr_Value (Expr));\n-\n-         --  Otherwise Ghost defaults to True\n-\n-         else\n-            return True;\n-         end if;\n-      end Enables_Ghostness;\n-\n-      --  Local variables\n-\n-      Id      : constant Entity_Id := Defining_Entity (N);\n-      Asp     : Node_Id;\n-      Decl    : Node_Id;\n-      Prev_Id : Entity_Id;\n-\n-   --  Start of processing for Is_Subject_To_Ghost\n-\n-   begin\n-      if Is_Ghost_Entity (Id) then\n-         return True;\n-\n-      --  The completion of a type or a constant is not fully analyzed when the\n-      --  reference to the Ghost entity is resolved. Because the completion is\n-      --  not marked as Ghost yet, inspect the partial view.\n-\n-      elsif Is_Record_Type (Id)\n-        or else Ekind (Id) = E_Constant\n-        or else (Nkind (N) = N_Object_Declaration\n-                  and then Constant_Present (N))\n-      then\n-         Prev_Id := Incomplete_Or_Partial_View (Id);\n-\n-         if Present (Prev_Id) and then Is_Ghost_Entity (Prev_Id) then\n-            return True;\n-         end if;\n-      end if;\n-\n-      --  Examine the aspect specifications (if any) looking for aspect Ghost\n-\n-      if Permits_Aspect_Specifications (N) then\n-         Asp := First (Aspect_Specifications (N));\n-         while Present (Asp) loop\n-            if Chars (Identifier (Asp)) = Name_Ghost then\n-               return Enables_Ghostness (Expression (Asp));\n-            end if;\n-\n-            Next (Asp);\n-         end loop;\n-      end if;\n-\n-      Decl := Empty;\n-\n-      --  When the context is a [generic] package declaration, pragma Ghost\n-      --  resides in the visible declarations.\n-\n-      if Nkind_In (N, N_Generic_Package_Declaration,\n-                      N_Package_Declaration)\n-      then\n-         Decl := First (Visible_Declarations (Specification (N)));\n-\n-      --  Otherwise pragma Ghost appears in the declarations following N\n-\n-      elsif Is_List_Member (N) then\n-         Decl := Next (N);\n-      end if;\n-\n-      while Present (Decl) loop\n-         if Nkind (Decl) = N_Pragma\n-           and then Pragma_Name (Decl) = Name_Ghost\n-         then\n-            return\n-              Enables_Ghostness (First (Pragma_Argument_Associations (Decl)));\n-\n-         --  A source construct ends the region where pragma Ghost may appear,\n-         --  stop the traversal.\n-\n-         elsif Comes_From_Source (Decl) then\n-            exit;\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return False;\n-   end Is_Subject_To_Ghost;\n-\n    --------------------------------------------------\n    -- Is_Subprogram_Stub_Without_Prior_Declaration --\n    --------------------------------------------------\n@@ -17265,22 +17001,6 @@ package body Sem_Util is\n       Set_Entity (N, Val);\n    end Set_Entity_With_Checks;\n \n-   -------------------------\n-   -- Set_Is_Ghost_Entity --\n-   -------------------------\n-\n-   procedure Set_Is_Ghost_Entity (Id : Entity_Id) is\n-      Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n-\n-   begin\n-      if Policy = Name_Check then\n-         Set_Is_Checked_Ghost_Entity (Id);\n-\n-      elsif Policy = Name_Ignore then\n-         Set_Is_Ignored_Ghost_Entity (Id);\n-      end if;\n-   end Set_Is_Ghost_Entity;\n-\n    ------------------------\n    -- Set_Name_Entity_Id --\n    ------------------------\n@@ -18213,30 +17933,6 @@ package body Sem_Util is\n       return List_1;\n    end Visible_Ancestors;\n \n-   ------------------------\n-   -- Within_Ghost_Scope --\n-   ------------------------\n-\n-   function Within_Ghost_Scope\n-     (Id : Entity_Id := Current_Scope) return Boolean\n-   is\n-      S : Entity_Id;\n-\n-   begin\n-      --  Climb the scope stack looking for a Ghost scope\n-\n-      S := Id;\n-      while Present (S) and then S /= Standard_Standard loop\n-         if Is_Ghost_Entity (S) then\n-            return True;\n-         end if;\n-\n-         S := Scope (S);\n-      end loop;\n-\n-      return False;\n-   end Within_Ghost_Scope;\n-\n    ----------------------\n    -- Within_Init_Proc --\n    ----------------------"}, {"sha": "43f1089dca71d957d77986dce3c9c842925ed1bf", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -285,17 +285,6 @@ package Sem_Util is\n    --  the one containing C2, that is known to refer to the same object (RM\n    --  6.4.1(6.17/3)).\n \n-   procedure Check_Ghost_Completion\n-     (Partial_View : Entity_Id;\n-      Full_View    : Entity_Id);\n-   --  Verify that the Ghost policy of a full view or a completion is the same\n-   --  as the Ghost policy of the partial view. Emit an error if this is not\n-   --  the case.\n-\n-   procedure Check_Ghost_Derivation (Typ : Entity_Id);\n-   --  Verify that the parent type and all progenitors of derived type or type\n-   --  extension Typ are Ghost. If this is not the case, issue an error.\n-\n    procedure Check_Implicit_Dereference (N : Node_Id; Typ : Entity_Id);\n    --  AI05-139-2: Accessors and iterators for containers. This procedure\n    --  checks whether T is a reference type, and if so it adds an interprettion\n@@ -1213,6 +1202,9 @@ package Sem_Util is\n    --  First determine whether type T is an interface and then check whether\n    --  it is of protected, synchronized or task kind.\n \n+   function Is_Declaration (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a declaration\n+\n    function Is_Delegate (T : Entity_Id) return Boolean;\n    --  Returns true if type T represents a delegate. A Delegate is the CIL\n    --  object used to represent access-to-subprogram types. This is only\n@@ -1279,18 +1271,6 @@ package Sem_Util is\n    --  means that the result returned is not crucial, but should err on the\n    --  side of thinking things are fully initialized if it does not know.\n \n-   function Is_Ghost_Entity (Id : Entity_Id) return Boolean;\n-   --  Determine whether entity Id is Ghost. To qualify as such, the entity\n-   --  must be subject to Convention Ghost.\n-\n-   function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean;\n-   --  Determine whether statement or pragma N is ghost. To qualify as such, N\n-   --  must either\n-   --    1) Occur within a ghost subprogram or package\n-   --    2) Denote a call to a ghost procedure\n-   --    3) Denote an assignment statement whose target is a ghost variable\n-   --    4) Denote a pragma that mentions a ghost entity\n-\n    function Is_Inherited_Operation (E : Entity_Id) return Boolean;\n    --  E is a subprogram. Return True is E is an implicit operation inherited\n    --  by a derived type declaration.\n@@ -1419,12 +1399,6 @@ package Sem_Util is\n    --  the N_Statement_Other_Than_Procedure_Call subtype from Sinfo).\n    --  Note that a label is *not* a statement, and will return False.\n \n-   function Is_Subject_To_Ghost (N : Node_Id) return Boolean;\n-   --  Determine whether declarative node N is subject to aspect or pragma\n-   --  Ghost. Use this routine in cases where [source] pragma Ghost has not\n-   --  been analyzed yet, but the context needs to establish the \"ghostness\"\n-   --  of N.\n-\n    function Is_Subprogram_Stub_Without_Prior_Declaration\n      (N : Node_Id) return Boolean;\n    --  Return True if N is a subprogram stub with no prior subprogram\n@@ -1914,10 +1888,6 @@ package Sem_Util is\n    --    If restriction No_Implementation_Identifiers is set, then it checks\n    --    that the entity is not implementation defined.\n \n-   procedure Set_Is_Ghost_Entity (Id : Entity_Id);\n-   --  Set the relevant ghost attribute of entity Id depending on the current\n-   --  Ghost assertion policy in effect.\n-\n    procedure Set_Name_Entity_Id (Id : Name_Id; Val : Entity_Id);\n    pragma Inline (Set_Name_Entity_Id);\n    --  Sets the Entity_Id value associated with the given name, which is the\n@@ -2045,12 +2015,6 @@ package Sem_Util is\n    --  generate the list of visible ancestors; otherwise their partial\n    --  view is added to the resulting list.\n \n-   function Within_Ghost_Scope\n-     (Id : Entity_Id := Current_Scope) return Boolean;\n-   --  Determine whether an arbitrary entity is either a scope or within a\n-   --  scope subject to convention Ghost or one that inherits \"ghostness\" from\n-   --  an enclosing construct.\n-\n    function Within_Init_Proc return Boolean;\n    --  Determines if Current_Scope is within an init proc\n "}, {"sha": "7c4bbf9a98aa4fc6919598fe5b401fb20b9899a1", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -521,6 +521,32 @@ package Sinfo is\n    --      simply ignore these nodes, since they are not relevant to the task\n    --      of back annotating representation information.\n \n+   ----------------\n+   -- Ghost Mode --\n+   ----------------\n+\n+   --  When a declaration is subject to pragma Ghost, it establishes a Ghost\n+   --  region depending on the Ghost assertion policy in effect at the point\n+   --  of declaration. This region is temporal and starts right before the\n+   --  analysis of the Ghost declaration and ends after its expansion. The\n+   --  values of global variable Opt.Ghost_Mode are as follows:\n+\n+   --    1. Check - All static semantics as defined in SPARK RM 6.9 are in\n+   --       effect.\n+\n+   --    2. Ignore - Same as Check, ignored Ghost code is not present in ALI\n+   --       files, object files as well as the final executable.\n+\n+   --  To achieve the runtime semantics of \"Ignore\", the compiler marks each\n+   --  node created during an ignored Ghost region and signals all enclosing\n+   --  scopes that such a node resides within. The compilation unit where the\n+   --  node resides is also added to an auxiliary table for post processing.\n+\n+   --  After the analysis and expansion of all compilation units takes place\n+   --  as well as the instantiation of all inlined [generic] bodies, the GNAT\n+   --  driver initiates a separate pass which removes all ignored Ghost code\n+   --  from all units stored in the auxiliary table.\n+\n    --------------------\n    -- GNATprove Mode --\n    --------------------"}, {"sha": "9d09a57ddfe221f6e31eab3d2930141854fda96b", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8636f52f7b50176948646cc151bfd514b8b71c03/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=8636f52f7b50176948646cc151bfd514b8b71c03", "patch": "@@ -1282,7 +1282,30 @@ package body Treepr is\n    -----------------------\n \n    procedure Print_Node_Header (N : Node_Id) is\n-      Notes : Boolean := False;\n+      Enumerate : Boolean := False;\n+      --  Flag set when enumerating multiple header flags\n+\n+      procedure Print_Header_Flag (Flag : String);\n+      --  Output one of the flags that appears in a node header. The routine\n+      --  automatically handles enumeration of multiple flags.\n+\n+      -----------------------\n+      -- Print_Header_Flag --\n+      -----------------------\n+\n+      procedure Print_Header_Flag (Flag : String) is\n+      begin\n+         if Enumerate then\n+            Print_Char (',');\n+         else\n+            Enumerate := True;\n+            Print_Char ('(');\n+         end if;\n+\n+         Print_Str (Flag);\n+      end Print_Header_Flag;\n+\n+   --  Start of processing for Print_Node_Header\n \n    begin\n       Print_Node_Ref (N);\n@@ -1293,34 +1316,25 @@ package body Treepr is\n          return;\n       end if;\n \n+      Print_Char (' ');\n+\n       if Comes_From_Source (N) then\n-         Notes := True;\n-         Print_Str (\" (source\");\n+         Print_Header_Flag (\"source\");\n       end if;\n \n       if Analyzed (N) then\n-         if not Notes then\n-            Notes := True;\n-            Print_Str (\" (\");\n-         else\n-            Print_Str (\",\");\n-         end if;\n-\n-         Print_Str (\"analyzed\");\n+         Print_Header_Flag (\"analyzed\");\n       end if;\n \n       if Error_Posted (N) then\n-         if not Notes then\n-            Notes := True;\n-            Print_Str (\" (\");\n-         else\n-            Print_Str (\",\");\n-         end if;\n+         Print_Header_Flag (\"posted\");\n+      end if;\n \n-         Print_Str (\"posted\");\n+      if Is_Ignored_Ghost_Node (N) then\n+         Print_Header_Flag (\"ignored ghost\");\n       end if;\n \n-      if Notes then\n+      if Enumerate then\n          Print_Char (')');\n       end if;\n "}]}