{"sha": "01d32b2b8b860db7cf58b88aa1880d93dc37c450", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkMzJiMmI4Yjg2MGRiN2NmNThiODhhYTE4ODBkOTNkYzM3YzQ1MA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-07-29T15:48:25Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-07-29T15:48:25Z"}, "message": "re PR tree-optimization/57558 (Loop not vectorized if iteration count could be infinite)\n\n\tPR tree-optimization/57558\n\t* tree-vect-loop-manip.c (vect_create_cond_for_niters_checks): New\n\tfunction.\n\t(vect_loop_versioning): Support versioning with niter assumptions.\n\t* tree-vect-loop.c (tree-ssa-loop.h): Include header file.\n\t(vect_get_loop_niters): New parameter.  Reimplement to support\n\tassumptions in loop niter info.\n\t(vect_analyze_loop_form_1, vect_analyze_loop_form): Ditto.\n\t(new_loop_vec_info): Init LOOP_VINFO_NITERS_ASSUMPTIONS.\n\t(vect_estimate_min_profitable_iters): Use LOOP_REQUIRES_VERSIONING.\n\tSupport loop versioning for niters.\n\t* tree-vectorizer.c (tree-ssa-loop-niter.h): Include header file.\n\t(vect_free_loop_info_assumptions): New function.\n\t(vectorize_loops): Free loop niter info for loops with flag\n\tLOOP_F_ASSUMPTIONS set if vectorization failed.\n\t* tree-vectorizer.h (struct _loop_vec_info): New field\n\tnum_iters_assumptions.\n\t(LOOP_VINFO_NITERS_ASSUMPTIONS): New macro.\n\t(LOOP_REQUIRES_VERSIONING_FOR_NITERS): New macro.\n\t(LOOP_REQUIRES_VERSIONING): New macro.\n\t(vect_free_loop_info_assumptions): New decl.\n\n\tgcc/testsuite\n\tPR tree-optimization/57558\n\t* gcc.dg/vect/pr57558-1.c: New test.\n\t* gcc.dg/vect/pr57558-2.c: New test.\n\nFrom-SVN: r238877", "tree": {"sha": "17c5a12a18cff4922671091f3bf2f74b62ff94d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17c5a12a18cff4922671091f3bf2f74b62ff94d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d32b2b8b860db7cf58b88aa1880d93dc37c450", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d32b2b8b860db7cf58b88aa1880d93dc37c450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d32b2b8b860db7cf58b88aa1880d93dc37c450", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d32b2b8b860db7cf58b88aa1880d93dc37c450/comments", "author": null, "committer": null, "parents": [{"sha": "18767ebc32eaed40760aab394fe77d0815454efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18767ebc32eaed40760aab394fe77d0815454efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18767ebc32eaed40760aab394fe77d0815454efd"}], "stats": {"total": 308, "additions": 262, "deletions": 46}, "files": [{"sha": "a8c527ad1ac09da9f232d977738457fba5a6999b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -1,3 +1,27 @@\n+2016-07-29  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/57558\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_niters_checks): New\n+\tfunction.\n+\t(vect_loop_versioning): Support versioning with niter assumptions.\n+\t* tree-vect-loop.c (tree-ssa-loop.h): Include header file.\n+\t(vect_get_loop_niters): New parameter.  Reimplement to support\n+\tassumptions in loop niter info.\n+\t(vect_analyze_loop_form_1, vect_analyze_loop_form): Ditto.\n+\t(new_loop_vec_info): Init LOOP_VINFO_NITERS_ASSUMPTIONS.\n+\t(vect_estimate_min_profitable_iters): Use LOOP_REQUIRES_VERSIONING.\n+\tSupport loop versioning for niters.\n+\t* tree-vectorizer.c (tree-ssa-loop-niter.h): Include header file.\n+\t(vect_free_loop_info_assumptions): New function.\n+\t(vectorize_loops): Free loop niter info for loops with flag\n+\tLOOP_F_ASSUMPTIONS set if vectorization failed.\n+\t* tree-vectorizer.h (struct _loop_vec_info): New field\n+\tnum_iters_assumptions.\n+\t(LOOP_VINFO_NITERS_ASSUMPTIONS): New macro.\n+\t(LOOP_REQUIRES_VERSIONING_FOR_NITERS): New macro.\n+\t(LOOP_REQUIRES_VERSIONING): New macro.\n+\t(vect_free_loop_info_assumptions): New decl.\n+\n 2016-07-29  Bin Cheng  <bin.cheng@arm.com>\n \n \t* cfgloop.h (struct loop): New field constraints."}, {"sha": "73b2d478358e4ba611f823317b9ec2cf8d60a8bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -1,3 +1,9 @@\n+2016-07-29  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/57558\n+\t* gcc.dg/vect/pr57558-1.c: New test.\n+\t* gcc.dg/vect/pr57558-2.c: New test.\n+\n 2016-07-29  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tgcc.dg/pr70920-4.c: Restrict to lp64 targets and make scan-tree-dump"}, {"sha": "1b36b75d2b598a621a501acc5e0e57d1d4be9f6b", "filename": "gcc/testsuite/gcc.dg/vect/pr57558-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr57558-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr57558-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr57558-1.c?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+typedef unsigned long ul;\n+void foo (ul* __restrict x, ul* __restrict y, ul n)\n+{\n+  ul i;\n+  for (i=1; i<=n; i++, x++, y++)\n+    *x += *y;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "ba8600351c010ba56379a4ca868ecada359d9fc5", "filename": "gcc/testsuite/gcc.dg/vect/pr57558-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr57558-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr57558-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr57558-2.c?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+void foo (int *a, int len)\n+{\n+  unsigned short i;\n+\n+  for (i = 1; i < (len - 1); i++)\n+    a[i] = a[i+1];\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "c1381b366cf969e08dc84ebcec4f7934b1c90cfe", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -2082,6 +2082,37 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n   free_original_copy_tables ();\n }\n \n+/* Function vect_create_cond_for_niters_checks.\n+\n+   Create a conditional expression that represents the run-time checks for\n+   loop's niter.  The loop is guaranteed to to terminate if the run-time\n+   checks hold.\n+\n+   Input:\n+   COND_EXPR  - input conditional expression.  New conditions will be chained\n+\t\twith logical AND operation.  If it is NULL, then the function\n+\t\tis used to return the number of alias checks.\n+   LOOP_VINFO - field LOOP_VINFO_MAY_ALIAS_STMTS contains the list of ddrs\n+\t\tto be checked.\n+\n+   Output:\n+   COND_EXPR - conditional expression.\n+\n+   The returned COND_EXPR is the conditional expression to be used in the\n+   if statement that controls which version of the loop gets executed at\n+   runtime.  */\n+\n+static void\n+vect_create_cond_for_niters_checks (loop_vec_info loop_vinfo, tree *cond_expr)\n+{\n+  tree part_cond_expr = LOOP_VINFO_NITERS_ASSUMPTIONS (loop_vinfo);\n+\n+  if (*cond_expr)\n+    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t      *cond_expr, part_cond_expr);\n+  else\n+    *cond_expr = part_cond_expr;\n+}\n \n /* Function vect_create_cond_for_align_checks.\n \n@@ -2330,7 +2361,7 @@ void\n vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t      unsigned int th, bool check_profitability)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo), *nloop;\n   struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n   basic_block condition_bb;\n   gphi_iterator gsi;\n@@ -2347,14 +2378,19 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n   tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n   bool version_align = LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo);\n   bool version_alias = LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo);\n+  bool version_niter = LOOP_REQUIRES_VERSIONING_FOR_NITERS (loop_vinfo);\n \n   if (check_profitability)\n-    {\n-      cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n-\t\t\t       build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n-      cond_expr = force_gimple_operand_1 (cond_expr, &cond_expr_stmt_list,\n-\t\t\t\t\t  is_gimple_condexpr, NULL_TREE);\n-    }\n+    cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n+\t\t\t     build_int_cst (TREE_TYPE (scalar_loop_iters),\n+\t\t\t\t\t\t       th));\n+\n+  if (version_niter)\n+    vect_create_cond_for_niters_checks (loop_vinfo, &cond_expr);\n+\n+  if (cond_expr)\n+    cond_expr = force_gimple_operand_1 (cond_expr, &cond_expr_stmt_list,\n+\t\t\t\t\tis_gimple_condexpr, NULL_TREE);\n \n   if (version_align)\n     vect_create_cond_for_align_checks (loop_vinfo, &cond_expr,\n@@ -2375,8 +2411,8 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \n       /* We don't want to scale SCALAR_LOOP's frequencies, we need to\n \t scale LOOP's frequencies instead.  */\n-      loop_version (scalar_loop, cond_expr, &condition_bb,\n-\t\t    prob, REG_BR_PROB_BASE, REG_BR_PROB_BASE - prob, true);\n+      nloop = loop_version (scalar_loop, cond_expr, &condition_bb, prob,\n+\t\t\t    REG_BR_PROB_BASE, REG_BR_PROB_BASE - prob, true);\n       scale_loop_frequencies (loop, prob, REG_BR_PROB_BASE);\n       /* CONDITION_BB was created above SCALAR_LOOP's preheader,\n \t while we need to move it above LOOP's preheader.  */\n@@ -2403,8 +2439,18 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t       condition_bb);\n     }\n   else\n-    loop_version (loop, cond_expr, &condition_bb,\n-\t\t  prob, prob, REG_BR_PROB_BASE - prob, true);\n+    nloop = loop_version (loop, cond_expr, &condition_bb,\n+\t\t\t  prob, prob, REG_BR_PROB_BASE - prob, true);\n+\n+  if (version_niter)\n+    {\n+      /* The versioned loop could be infinite, we need to clear existing\n+\t niter information which is copied from the original loop.  */\n+      gcc_assert (loop_constraint_set_p (loop, LOOP_C_FINITE));\n+      vect_free_loop_info_assumptions (nloop);\n+      /* And set constraint LOOP_C_INFINITE for niter analyzer.  */\n+      loop_constraint_set (loop, LOOP_C_INFINITE);\n+    }\n \n   if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n       && dump_enabled_p ())"}, {"sha": "41c4c29f6d36703b1fc1d84dd8c4ae30ac76ac5a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 111, "deletions": 32, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop-ivopts.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"tree-ssa-loop-niter.h\"\n+#include \"tree-ssa-loop.h\"\n #include \"cfgloop.h\"\n #include \"params.h\"\n #include \"tree-scalar-evolution.h\"\n@@ -1002,37 +1003,88 @@ vect_fixup_scalar_cycles_with_patterns (loop_vec_info loop_vinfo)\n \n    Determine how many iterations the loop is executed and place it\n    in NUMBER_OF_ITERATIONS.  Place the number of latch iterations\n-   in NUMBER_OF_ITERATIONSM1.\n+   in NUMBER_OF_ITERATIONSM1.  Place the condition under which the\n+   niter information holds in ASSUMPTIONS.\n \n    Return the loop exit condition.  */\n \n \n static gcond *\n-vect_get_loop_niters (struct loop *loop, tree *number_of_iterations,\n-\t\t      tree *number_of_iterationsm1)\n+vect_get_loop_niters (struct loop *loop, tree *assumptions,\n+\t\t      tree *number_of_iterations, tree *number_of_iterationsm1)\n {\n-  tree niters;\n-\n+  edge exit = single_exit (loop);\n+  struct tree_niter_desc niter_desc;\n+  tree niter_assumptions, niter, may_be_zero;\n+  gcond *cond = get_loop_exit_condition (loop);\n+\n+  *assumptions = boolean_true_node;\n+  *number_of_iterationsm1 = chrec_dont_know;\n+  *number_of_iterations = chrec_dont_know;\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== get_loop_niters ===\\n\");\n \n-  niters = number_of_latch_executions (loop);\n-  *number_of_iterationsm1 = niters;\n+  if (!exit)\n+    return cond;\n+\n+  niter = chrec_dont_know;\n+  may_be_zero = NULL_TREE;\n+  niter_assumptions = boolean_true_node;\n+  if (!number_of_iterations_exit_assumptions (loop, exit, &niter_desc, NULL)\n+      || chrec_contains_undetermined (niter_desc.niter))\n+    return cond;\n+\n+  niter_assumptions = niter_desc.assumptions;\n+  may_be_zero = niter_desc.may_be_zero;\n+  niter = niter_desc.niter;\n+\n+  if (may_be_zero && integer_zerop (may_be_zero))\n+    may_be_zero = NULL_TREE;\n+\n+  if (may_be_zero)\n+    {\n+      if (COMPARISON_CLASS_P (may_be_zero))\n+\t{\n+\t  /* Try to combine may_be_zero with assumptions, this can simplify\n+\t     computation of niter expression.  */\n+\t  if (niter_assumptions && !integer_nonzerop (niter_assumptions))\n+\t    niter_assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t     niter_assumptions,\n+\t\t\t\t\t     fold_build1 (TRUTH_NOT_EXPR,\n+\t\t\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t\t\t  may_be_zero));\n+\t  else\n+\t    niter = fold_build3 (COND_EXPR, TREE_TYPE (niter), may_be_zero,\n+\t\t\t\t build_int_cst (TREE_TYPE (niter), 0), niter);\n+\n+\t  may_be_zero = NULL_TREE;\n+\t}\n+      else if (integer_nonzerop (may_be_zero))\n+\t{\n+\t  *number_of_iterationsm1 = build_int_cst (TREE_TYPE (niter), 0);\n+\t  *number_of_iterations = build_int_cst (TREE_TYPE (niter), 1);\n+\t  return cond;\n+\t}\n+      else\n+\treturn cond;\n+    }\n+\n+  *assumptions = niter_assumptions;\n+  *number_of_iterationsm1 = niter;\n \n   /* We want the number of loop header executions which is the number\n      of latch executions plus one.\n      ???  For UINT_MAX latch executions this number overflows to zero\n      for loops like do { n++; } while (n != 0);  */\n-  if (niters && !chrec_contains_undetermined (niters))\n-    niters = fold_build2 (PLUS_EXPR, TREE_TYPE (niters), unshare_expr (niters),\n-\t\t\t  build_int_cst (TREE_TYPE (niters), 1));\n-  *number_of_iterations = niters;\n+  if (niter && !chrec_contains_undetermined (niter))\n+    niter = fold_build2 (PLUS_EXPR, TREE_TYPE (niter), unshare_expr (niter),\n+\t\t\t  build_int_cst (TREE_TYPE (niter), 1));\n+  *number_of_iterations = niter;\n \n-  return get_loop_exit_condition (loop);\n+  return cond;\n }\n \n-\n /* Function bb_in_loop_p\n \n    Used as predicate for dfs order traversal of the loop bbs.  */\n@@ -1101,6 +1153,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_NITERSM1 (res) = NULL;\n   LOOP_VINFO_NITERS (res) = NULL;\n   LOOP_VINFO_NITERS_UNCHANGED (res) = NULL;\n+  LOOP_VINFO_NITERS_ASSUMPTIONS (res) = NULL;\n   LOOP_VINFO_COST_MODEL_THRESHOLD (res) = 0;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_VINFO_PEELING_FOR_ALIGNMENT (res) = 0;\n@@ -1280,12 +1333,13 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n    Verify that certain CFG restrictions hold, including:\n    - the loop has a pre-header\n    - the loop has a single entry and exit\n-   - the loop exit condition is simple enough, and the number of iterations\n-     can be analyzed (a countable loop).  */\n+   - the loop exit condition is simple enough\n+   - the number of iterations can be analyzed, i.e, a countable loop.  The\n+     niter could be analyzed under some assumptions.  */\n \n bool\n vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n-\t\t\t  tree *number_of_iterationsm1,\n+\t\t\t  tree *assumptions, tree *number_of_iterationsm1,\n \t\t\t  tree *number_of_iterations, gcond **inner_loop_cond)\n {\n   if (dump_enabled_p ())\n@@ -1376,9 +1430,13 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n \t}\n \n       /* Analyze the inner-loop.  */\n-      tree inner_niterm1, inner_niter;\n+      tree inner_niterm1, inner_niter, inner_assumptions;\n       if (! vect_analyze_loop_form_1 (loop->inner, inner_loop_cond,\n-\t\t\t\t      &inner_niterm1, &inner_niter, NULL))\n+\t\t\t\t      &inner_assumptions, &inner_niterm1,\n+\t\t\t\t      &inner_niter, NULL)\n+\t  /* Don't support analyzing niter under assumptions for inner\n+\t     loop.  */\n+\t  || !integer_onep (inner_assumptions))\n \t{\n \t  if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1447,7 +1505,7 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n \t}\n     }\n \n-  *loop_cond = vect_get_loop_niters (loop, number_of_iterations,\n+  *loop_cond = vect_get_loop_niters (loop, assumptions, number_of_iterations,\n \t\t\t\t     number_of_iterationsm1);\n   if (!*loop_cond)\n     {\n@@ -1457,7 +1515,8 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n       return false;\n     }\n \n-  if (!*number_of_iterations\n+  if (integer_zerop (*assumptions)\n+      || !*number_of_iterations\n       || chrec_contains_undetermined (*number_of_iterations))\n     {\n       if (dump_enabled_p ())\n@@ -1483,17 +1542,31 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n loop_vec_info\n vect_analyze_loop_form (struct loop *loop)\n {\n-  tree number_of_iterations, number_of_iterationsm1;\n+  tree assumptions, number_of_iterations, number_of_iterationsm1;\n   gcond *loop_cond, *inner_loop_cond = NULL;\n \n-  if (! vect_analyze_loop_form_1 (loop, &loop_cond, &number_of_iterationsm1,\n+  if (! vect_analyze_loop_form_1 (loop, &loop_cond,\n+\t\t\t\t  &assumptions, &number_of_iterationsm1,\n \t\t\t\t  &number_of_iterations, &inner_loop_cond))\n     return NULL;\n \n   loop_vec_info loop_vinfo = new_loop_vec_info (loop);\n   LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n+  if (!integer_onep (assumptions))\n+    {\n+      /* We consider to vectorize this loop by versioning it under\n+\t some assumptions.  In order to do this, we need to clear\n+\t existing information computed by scev and niter analyzer.  */\n+      scev_reset_htab ();\n+      free_numbers_of_iterations_estimates_loop (loop);\n+      /* Also set flag for this loop so that following scev and niter\n+\t analysis are done under the assumptions.  */\n+      loop_constraint_set (loop, LOOP_C_FINITE);\n+      /* Also record the assumptions for versioning.  */\n+      LOOP_VINFO_NITERS_ASSUMPTIONS (loop_vinfo) = assumptions;\n+    }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n@@ -2082,8 +2155,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n                /* In case of versioning, check if the maximum number of\n                   iterations is greater than th.  If they are identical,\n                   the epilogue is unnecessary.  */\n-\t       && ((!LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo)\n-\t            && !LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo))\n+\t       && (!LOOP_REQUIRES_VERSIONING (loop_vinfo)\n                    || (unsigned HOST_WIDE_INT) max_niter > th)))\n     LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n \n@@ -3127,8 +3199,18 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n                    \"versioning aliasing.\\n\");\n     }\n \n-  if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n-      || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n+  /* Requires loop versioning with niter checks.  */\n+  if (LOOP_REQUIRES_VERSIONING_FOR_NITERS (loop_vinfo))\n+    {\n+      /*  FIXME: Make cost depend on complexity of individual check.  */\n+      (void) add_stmt_cost (target_cost_data, 1, vector_stmt, NULL, 0,\n+\t\t\t    vect_prologue);\n+      dump_printf (MSG_NOTE,\n+\t\t   \"cost model: Adding cost of checks for loop \"\n+\t\t   \"versioning niters.\\n\");\n+    }\n+\n+  if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n     (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken, NULL, 0,\n \t\t\t  vect_prologue);\n \n@@ -3285,12 +3367,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n      decide whether to vectorize at compile time.  Hence the scalar version\n      do not carry cost model guard costs.  */\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n-      || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n+      || LOOP_REQUIRES_VERSIONING (loop_vinfo))\n     {\n       /* Cost model check occurs at versioning.  */\n-      if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n-          || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n+      if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n \tscalar_outside_cost += vect_get_stmt_cost (cond_branch_not_taken);\n       else\n \t{\n@@ -6629,8 +6709,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   /* Version the loop first, if required, so the profitability check\n      comes first.  */\n \n-  if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n-      || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n+  if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n     {\n       vect_loop_versioning (loop_vinfo, th, check_profitability);\n       check_profitability = false;"}, {"sha": "1d55041fb223981fd3562777eaea36ab3ca57563", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -69,6 +69,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"gimple-walk.h\"\n #include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop-niter.h\"\n #include \"tree-cfg.h\"\n #include \"cfgloop.h\"\n #include \"tree-vectorizer.h\"\n@@ -368,6 +369,20 @@ vect_destroy_datarefs (vec_info *vinfo)\n   free_data_refs (vinfo->datarefs);\n }\n \n+/* A helper function to free scev and LOOP niter information, as well as\n+   clear loop constraint LOOP_C_FINITE.  */\n+\n+void\n+vect_free_loop_info_assumptions (struct loop *loop)\n+{\n+  scev_reset_htab ();\n+  /* We need to explicitly reset upper bound information since they are\n+     used even after free_numbers_of_iterations_estimates_loop.  */\n+  loop->any_upper_bound = false;\n+  loop->any_likely_upper_bound = false;\n+  free_numbers_of_iterations_estimates_loop (loop);\n+  loop_constraint_clear (loop, LOOP_C_FINITE);\n+}\n \n /* Return whether STMT is inside the region we try to vectorize.  */\n \n@@ -537,14 +552,26 @@ vectorize_loops (void)\n \tloop->aux = loop_vinfo;\n \n \tif (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n-\t  continue;\n+\t  {\n+\t    /* Free existing information if loop is analyzed with some\n+\t       assumptions.  */\n+\t    if (loop_constraint_set_p (loop, LOOP_C_FINITE))\n+\t      vect_free_loop_info_assumptions (loop);\n+\n+\t    continue;\n+\t  }\n \n         if (!dbg_cnt (vect_loop))\n \t  {\n \t    /* We may miss some if-converted loops due to\n \t       debug counter.  Set any_ifcvt_loops to visit\n \t       them at finalization.  */\n \t    any_ifcvt_loops = true;\n+\t    /* Free existing information if loop is analyzed with some\n+\t       assumptions.  */\n+\t    if (loop_constraint_set_p (loop, LOOP_C_FINITE))\n+\t      vect_free_loop_info_assumptions (loop);\n+\n \t    break;\n \t  }\n "}, {"sha": "31570d8ed1fb816125e09d11e4b8f65ddae2b608", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d32b2b8b860db7cf58b88aa1880d93dc37c450/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=01d32b2b8b860db7cf58b88aa1880d93dc37c450", "patch": "@@ -231,6 +231,8 @@ typedef struct _loop_vec_info : public vec_info {\n   tree num_iters;\n   /* Number of iterations of the original loop.  */\n   tree num_iters_unchanged;\n+  /* Condition under which this loop is analyzed and versioned.  */\n+  tree num_iters_assumptions;\n \n   /* Threshold of number of iterations below which vectorzation will not be\n      performed. It is calculated from MIN_PROFITABLE_ITERS and\n@@ -343,6 +345,7 @@ typedef struct _loop_vec_info : public vec_info {\n    prologue peeling retain total unchanged scalar loop iterations for\n    cost model.  */\n #define LOOP_VINFO_NITERS_UNCHANGED(L)     (L)->num_iters_unchanged\n+#define LOOP_VINFO_NITERS_ASSUMPTIONS(L)   (L)->num_iters_assumptions\n #define LOOP_VINFO_COST_MODEL_THRESHOLD(L) (L)->th\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n@@ -371,10 +374,16 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_SCALAR_ITERATION_COST(L) (L)->scalar_cost_vec\n #define LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST(L) (L)->single_scalar_iteration_cost\n \n-#define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\\n+#define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n-#define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)     \\\n+#define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)\t\t\\\n   ((L)->may_alias_ddrs.length () > 0)\n+#define LOOP_REQUIRES_VERSIONING_FOR_NITERS(L)\t\t\\\n+  (LOOP_VINFO_NITERS_ASSUMPTIONS (L))\n+#define LOOP_REQUIRES_VERSIONING(L)\t\t\t\\\n+  (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (L)\t\t\\\n+   || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (L)\t\t\\\n+   || LOOP_REQUIRES_VERSIONING_FOR_NITERS (L))\n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)          \\\n   (tree_fits_shwi_p ((L)->num_iters) && tree_to_shwi ((L)->num_iters) > 0)\n@@ -1177,5 +1186,6 @@ void vect_pattern_recog (vec_info *);\n unsigned vectorize_loops (void);\n void vect_destroy_datarefs (vec_info *);\n bool vect_stmt_in_region_p (vec_info *, gimple *);\n+void vect_free_loop_info_assumptions (struct loop *);\n \n #endif  /* GCC_TREE_VECTORIZER_H  */"}]}