{"sha": "2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI5YzYzYTJkODM2ODI1MmVkZWQ2ZmJkYmFmYjQ3ODZlMmZkZjQxMg==", "commit": {"author": {"name": "Felix Yang", "email": "felix.yang@huawei.com", "date": "2014-09-19T16:28:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-09-19T16:28:42Z"}, "message": "cfgrtl.c [...]: Update comments and fix spacing to conform to coding style.\n\n        * cfgrtl.c ira.c ira-color.c ira-conflicts ira-lives.c: Update\n        comments and fix spacing to conform to coding style.\n\nFrom-SVN: r215398", "tree": {"sha": "10c36055a7c6ea6cee8a6c2988bfc09a457d417a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10c36055a7c6ea6cee8a6c2988bfc09a457d417a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/comments", "author": null, "committer": null, "parents": [{"sha": "bcd0e41fdad9fcf1b0ef5e176ecf9a39315ace20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcd0e41fdad9fcf1b0ef5e176ecf9a39315ace20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcd0e41fdad9fcf1b0ef5e176ecf9a39315ace20"}], "stats": {"total": 37, "additions": 21, "deletions": 16}, "files": [{"sha": "261eda3bc95ce7657fd9bf3d502952521c413f37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "patch": "@@ -1,3 +1,8 @@\n+2014-09-19  Felix Yang  <felix.yang@huawei.com>\n+\n+\t* cfgrtl.c ira.c ira-color.c ira-conflicts ira-lives.c: Update\n+\tcomments and fix spacing to conform to coding style.\n+\n 2014-09-19  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* genrecog.c (validate_pattern): Allow empty constraints in"}, {"sha": "07c82681c1f00435efb2a2bba1adcf8e773df783", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "patch": "@@ -696,8 +696,8 @@ first_insn_after_basic_block_note (basic_block block)\n   return NEXT_INSN (insn);\n }\n \n-/* Creates a new basic block just after basic block B by splitting\n-   everything after specified instruction I.  */\n+/* Creates a new basic block just after basic block BB by splitting\n+   everything after specified instruction INSNP.  */\n \n static basic_block\n rtl_split_block (basic_block bb, void *insnp)\n@@ -4928,7 +4928,7 @@ rtl_lv_add_condition_to_bb (basic_block first_head ,\n   seq = get_insns ();\n   end_sequence ();\n \n-  /* Add the new cond , in the new head.  */\n+  /* Add the new cond, in the new head.  */\n   emit_insn_after (seq, BB_END (cond_bb));\n }\n "}, {"sha": "1042eaab48fd5936212383dbf2ff326cab75bccc", "filename": "gcc/ira-color.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "patch": "@@ -135,7 +135,7 @@ struct allocno_color_data\n      and all its subnodes in the tree (forest) of allocno hard\n      register nodes (see comments above).  */\n   int hard_regs_subnodes_start;\n-  /* The length of the previous array. */\n+  /* The length of the previous array.  */\n   int hard_regs_subnodes_num;\n   /* Records about updating allocno hard reg costs from copies.  If\n      the allocno did not get expected hard register, these records are\n@@ -1864,7 +1864,7 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n   if (best_hard_regno >= 0)\n     update_costs_from_copies (a, true, ! retry_p);\n   ira_assert (ALLOCNO_CLASS (a) == aclass);\n-  /* We don't need updated costs anymore: */\n+  /* We don't need updated costs anymore.  */\n   ira_free_allocno_updated_costs (a);\n   return best_hard_regno >= 0;\n }\n@@ -3069,7 +3069,7 @@ color_allocnos (void)\n \n \f\n \n-/* Output information about the loop given by its LOOP_TREE_NODE. */\n+/* Output information about the loop given by its LOOP_TREE_NODE.  */\n static void\n print_loop_title (ira_loop_tree_node_t loop_tree_node)\n {\n@@ -3205,7 +3205,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t    ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n \t    if (hard_regno >= 0)\n \t      update_costs_from_copies (subloop_allocno, true, true);\n-\t    /* We don't need updated costs anymore: */\n+\t    /* We don't need updated costs anymore.  */\n \t    ira_free_allocno_updated_costs (subloop_allocno);\n \t  }\n       }\n@@ -3249,7 +3249,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t  ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n \t\t  if (hard_regno >= 0)\n \t\t    update_costs_from_copies (subloop_allocno, true, true);\n-\t\t  /* We don't need updated costs anymore: */\n+\t\t  /* We don't need updated costs anymore.  */\n \t\t  ira_free_allocno_updated_costs (subloop_allocno);\n \t\t}\n \t      continue;\n@@ -3265,7 +3265,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t  ALLOCNO_ASSIGNED_P (subloop_allocno) = true;\n \t\t  if (hard_regno >= 0)\n \t\t    update_costs_from_copies (subloop_allocno, true, true);\n-\t\t  /* We don't need updated costs anymore: */\n+\t\t  /* We don't need updated costs anymore.  */\n \t\t  ira_free_allocno_updated_costs (subloop_allocno);\n \t\t}\n \t    }"}, {"sha": "6b1bfade83e5f0efdbc764c5415349871c80155e", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "patch": "@@ -60,7 +60,7 @@ static IRA_INT_TYPE **conflicts;\n \f\n /* Record a conflict between objects OBJ1 and OBJ2.  If necessary,\n    canonicalize the conflict by recording it for lower-order subobjects\n-   of the corresponding allocnos. */\n+   of the corresponding allocnos.  */\n static void\n record_object_conflict (ira_object_t obj1, ira_object_t obj2)\n {"}, {"sha": "bb6f235c8ec158e678e3bce85641014e5cf03892", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "patch": "@@ -1323,7 +1323,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n       curr_point++;\n \n     }\n-  /* Propagate register pressure to upper loop tree nodes: */\n+  /* Propagate register pressure to upper loop tree nodes.  */\n   if (loop_tree_node != ira_loop_tree_root)\n     for (i = 0; i < ira_pressure_classes_num; i++)\n       {"}, {"sha": "ad0e463e4cddba2eddeb096f70528864577d28ba", "filename": "gcc/ira.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b9c63a2d8368252eded6fbdbafb4786e2fdf412/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=2b9c63a2d8368252eded6fbdbafb4786e2fdf412", "patch": "@@ -1078,7 +1078,7 @@ setup_allocno_and_important_classes (void)\n    containing a given class.  If allocatable hard register set of a\n    given class is not a subset of any corresponding set of a class\n    from CLASSES, we use the cheapest (with load/store point of view)\n-   class from CLASSES whose set intersects with given class set */\n+   class from CLASSES whose set intersects with given class set.  */\n static void\n setup_class_translate_array (enum reg_class *class_translate,\n \t\t\t     int classes_num, enum reg_class *classes)\n@@ -1774,7 +1774,7 @@ void\n ira_setup_alts (rtx_insn *insn, HARD_REG_SET &alts)\n {\n   /* MAP nalt * nop -> start of constraints for given operand and\n-     alternative */\n+     alternative.  */\n   static vec<const char *> insn_constraints;\n   int nop, nalt;\n   bool curr_swapped;\n@@ -2728,7 +2728,7 @@ print_redundant_copies (void)\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       if (ALLOCNO_CAP_MEMBER (a) != NULL)\n-\t/* It is a cap. */\n+\t/* It is a cap.  */\n \tcontinue;\n       hard_regno = ALLOCNO_HARD_REGNO (a);\n       if (hard_regno >= 0)\n@@ -3463,7 +3463,7 @@ update_equiv_regs (void)\n \t    note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n \n \t  /* Don't bother considering a REG_EQUAL note containing an EXPR_LIST\n-\t     since it represents a function call */\n+\t     since it represents a function call.  */\n \t  if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n \t    note = NULL_RTX;\n \n@@ -4137,7 +4137,7 @@ build_insn_chain (void)\n \t\t       to a multiword reg.  Here, we only model the\n \t\t       subreg case that is not wrapped in ZERO_EXTRACT\n \t\t       precisely so we do not need to look at the\n-\t\t       fabricated use. */\n+\t\t       fabricated use.  */\n \t\t    if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE)\n \t\t\t&& !DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT)\n \t\t\t&& DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))"}]}