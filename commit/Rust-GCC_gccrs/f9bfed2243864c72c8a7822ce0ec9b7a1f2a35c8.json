{"sha": "f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjliZmVkMjI0Mzg2NGM3MmM4YTc4MjJjZTBlYzliN2ExZjJhMzVjOA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2009-04-08T16:48:07Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2009-04-08T16:48:07Z"}, "message": "string.c (compare0): Use gfc_charlen_type.\n\n2009-04-08  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        * runtime/string.c (compare0): Use gfc_charlen_type.\n        * runtime/error.c (gfc_itoa): Move to io/write.c\n        (xtoa): Rename to gfc_xtoa.\n        * runtime/backtrace.c (show_backtrace): Call gfc_xtoa.\n        * intrinsics/cshift0.c (cshift0): Use index_type for shift arg.\n        * intrinsics/date_and_time.c (date_and_time): Use index_type.\n        (itime_i4): Likewise.\n        (itime_i8): Likewise.\n        (idate_i4): Likewise.\n        (idate_i8): Likewise.\n        (gmtime_i4): Likewise.\n        (gmtime_i8): Likewise.\n        (ltime_i4): Likewise.\n        (ltime_i8): Likewise.\n        * libgfortran.h (gfc_itoa): Remove prototype.\n        (xtoa): Rename prototype to gfc_xtoa.\n        * io/list_read.c (nml_read_obj): Use size_t for string length.\n        * io/transfer.c (read_block_direct): Change nbytes arg from\n        pointer to value.\n        (unformatted_read): Minor cleanup, call read_block_directly properly.\n        (skip_record): Use ssize_t.\n        (next_record_w_unf): Avoid stell() call by calling sseek with SEEK_CUR.\n        (iolength_transfer): Make sure to multiply before cast.\n        * io/intrinsics.c (fgetc): Remove unnecessary variable.\n        * io/format.c (format_hash): Use gfc_charlen_type.\n        * io/write.c (itoa): Move from runtime/error.c:gfc_itoa, rename,\n        make static.\n        (write_i): Call with pointer to itoa.\n        (write_z): Call with pointer to gfc_xtoa.\n        (write_integer): Pointer to itoa.\n        (nml_write_obj): Type cleanup, don't call strlen in loop.\n\nFrom-SVN: r145758", "tree": {"sha": "a970504f9831850f9b5d3dc40d4ebab2b7bec39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a970504f9831850f9b5d3dc40d4ebab2b7bec39a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/comments", "author": null, "committer": null, "parents": [{"sha": "75ccc1e7fa591f7a6c88ddd04b97169bcf04e5ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ccc1e7fa591f7a6c88ddd04b97169bcf04e5ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75ccc1e7fa591f7a6c88ddd04b97169bcf04e5ff"}], "stats": {"total": 274, "additions": 147, "deletions": 127}, "files": [{"sha": "8bc904acba6c74b5c2bd357477c197bb243aa742", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,3 +1,37 @@\n+2009-04-08  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        * runtime/string.c (compare0): Use gfc_charlen_type.\n+        * runtime/error.c (gfc_itoa): Move to io/write.c\n+        (xtoa): Rename to gfc_xtoa.\n+        * runtime/backtrace.c (show_backtrace): Call gfc_xtoa.\n+        * intrinsics/cshift0.c (cshift0): Use index_type for shift arg.\n+        * intrinsics/date_and_time.c (date_and_time): Use index_type.\n+        (itime_i4): Likewise.\n+        (itime_i8): Likewise.\n+        (idate_i4): Likewise.\n+        (idate_i8): Likewise.\n+        (gmtime_i4): Likewise.\n+        (gmtime_i8): Likewise.\n+        (ltime_i4): Likewise.\n+        (ltime_i8): Likewise.\n+        * libgfortran.h (gfc_itoa): Remove prototype.\n+        (xtoa): Rename prototype to gfc_xtoa.\n+        * io/list_read.c (nml_read_obj): Use size_t for string length.\n+        * io/transfer.c (read_block_direct): Change nbytes arg from\n+        pointer to value.\n+        (unformatted_read): Minor cleanup, call read_block_directly properly.\n+        (skip_record): Use ssize_t.\n+        (next_record_w_unf): Avoid stell() call by calling sseek with SEEK_CUR.\n+        (iolength_transfer): Make sure to multiply before cast.\n+        * io/intrinsics.c (fgetc): Remove unnecessary variable.\n+        * io/format.c (format_hash): Use gfc_charlen_type.\n+        * io/write.c (itoa): Move from runtime/error.c:gfc_itoa, rename,\n+        make static.\n+        (write_i): Call with pointer to itoa.\n+        (write_z): Call with pointer to gfc_xtoa.\n+        (write_integer): Pointer to itoa.\n+        (nml_write_obj): Type cleanup, don't call strlen in loop.\n+\t\n 2009-04-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR libgfortran/39664"}, {"sha": "fa63cdcacf23a95121d132c9d552279c2d8d26d5", "filename": "libgfortran/intrinsics/cshift0.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fintrinsics%2Fcshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fintrinsics%2Fcshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcshift0.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,5 +1,5 @@\n /* Generic implementation of the CSHIFT intrinsic\n-   Copyright 2003, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright 2003, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Feng Wang <wf_cs@yahoo.com>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -35,7 +35,7 @@ Boston, MA 02110-1301, USA.  */\n \n static void\n cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n-\t ssize_t shift, int which, index_type size)\n+\t index_type shift, int which, index_type size)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride[GFC_MAX_DIMENSIONS];\n@@ -311,7 +311,7 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   rptr = ret->data;\n   sptr = array->data;\n \n-  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  shift = len == 0 ? 0 : shift % len;\n   if (shift < 0)\n     shift += len;\n "}, {"sha": "3faeca9458ce78ea1c57134331cf97d2272c924d", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the DATE_AND_TIME intrinsic.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Steven Bosscher.\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -242,7 +242,7 @@ date_and_time (char *__date, char *__time, char *__zone,\n   /* Copy the values into the arguments.  */\n   if (__values)\n     {\n-      size_t len, delta, elt_size;\n+      index_type len, delta, elt_size;\n \n       elt_size = GFC_DESCRIPTOR_SIZE (__values);\n       len = __values->dim[0].ubound + 1 - __values->dim[0].lbound;\n@@ -384,7 +384,7 @@ void\n itime_i4 (gfc_array_i4 *__values)\n {\n   int x[3], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_4 *vptr;\n   \n   /* Call helper function.  */\n@@ -410,7 +410,7 @@ void\n itime_i8 (gfc_array_i8 *__values)\n {\n   int x[3], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_8 *vptr;\n   \n   /* Call helper function.  */\n@@ -466,7 +466,7 @@ void\n idate_i4 (gfc_array_i4 *__values)\n {\n   int x[3], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_4 *vptr;\n   \n   /* Call helper function.  */\n@@ -492,7 +492,7 @@ void\n idate_i8 (gfc_array_i8 *__values)\n {\n   int x[3], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_8 *vptr;\n   \n   /* Call helper function.  */\n@@ -554,7 +554,7 @@ void\n gmtime_i4 (GFC_INTEGER_4 * t, gfc_array_i4 * tarray)\n {\n   int x[9], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_4 *vptr;\n   time_t tt;\n   \n@@ -581,7 +581,7 @@ void\n gmtime_i8 (GFC_INTEGER_8 * t, gfc_array_i8 * tarray)\n {\n   int x[9], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_8 *vptr;\n   time_t tt;\n   \n@@ -646,7 +646,7 @@ void\n ltime_i4 (GFC_INTEGER_4 * t, gfc_array_i4 * tarray)\n {\n   int x[9], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_4 *vptr;\n   time_t tt;\n   \n@@ -673,7 +673,7 @@ void\n ltime_i8 (GFC_INTEGER_8 * t, gfc_array_i8 * tarray)\n {\n   int x[9], i;\n-  size_t len, delta;\n+  index_type len, delta;\n   GFC_INTEGER_8 *vptr;\n   time_t tt;\n   "}, {"sha": "7778311c2215ca6e52dbb772cba8f8683f515d1b", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    F2003 I/O support contributed by Jerry DeLisle\n@@ -140,9 +140,9 @@ static inline\n uint32_t format_hash (st_parameter_dt *dtp)\n {\n   char *key;\n-  size_t key_len;\n+  gfc_charlen_type key_len;\n   uint32_t hash = 0;\n-  size_t i;\n+  gfc_charlen_type i;\n \n   /* Hash the format string. Super simple, but what the heck!  */\n   key = dtp->format;"}, {"sha": "f704ee578343eb9a4bcabea0a72967bec43219dc", "filename": "libgfortran/io/intrinsics.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Fintrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Fintrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fintrinsics.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,6 +1,6 @@\n /* Implementation of the FGET, FGETC, FPUT, FPUTC, FLUSH \n    FTELL, TTYNAM and ISATTY intrinsics.\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -46,15 +46,13 @@ int\n PREFIX(fgetc) (const int * unit, char * c, gfc_charlen_type c_len)\n {\n   int ret;\n-  size_t s;\n   gfc_unit * u = find_unit (*unit);\n \n   if (u == NULL)\n     return -1;\n \n-  s = 1;\n   memset (c, ' ', c_len);\n-  ret = sread (u->s, c, s);\n+  ret = sread (u->s, c, 1);\n   unlock_unit (u);\n \n   if (ret < 0)"}, {"sha": "52e85597ea7bb2ae6c997868abe5cee10d2ae333", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -2305,7 +2305,7 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n   int dim;\n   index_type dlen;\n   index_type m;\n-  index_type obj_name_len;\n+  size_t obj_name_len;\n   void * pdata;\n \n   /* This object not touched in name parsing.  */"}, {"sha": "e2bf5dae2d9c45a511ef8c75ea55ba6d73206463", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist transfer functions contributed by Paul Thomas\n@@ -397,7 +397,7 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n    unformatted files.  */\n \n static void\n-read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n+read_block_direct (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n   ssize_t to_read_record;\n   ssize_t have_read_record;\n@@ -407,9 +407,8 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n   if (is_stream_io (dtp))\n     {\n-      to_read_record = *nbytes;\n       have_read_record = sread (dtp->u.p.current_unit->s, buf, \n-\t\t\t\tto_read_record);\n+\t\t\t\tnbytes);\n       if (unlikely (have_read_record < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n@@ -418,29 +417,27 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->strm_pos += (gfc_offset) have_read_record; \n \n-      if (unlikely (to_read_record != have_read_record))\n+      if (unlikely ((ssize_t) nbytes != have_read_record))\n \t{\n \t  /* Short read,  e.g. if we hit EOF.  For stream files,\n \t   we have to set the end-of-file condition.  */\n           hit_eof (dtp);\n-\t  return;\n \t}\n       return;\n     }\n \n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n     {\n-      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes)\n \t{\n \t  short_record = 1;\n-\t  to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;\n-\t  *nbytes = to_read_record;\n+\t  to_read_record = dtp->u.p.current_unit->bytes_left;\n+\t  nbytes = to_read_record;\n \t}\n-\n       else\n \t{\n \t  short_record = 0;\n-\t  to_read_record = *nbytes;\n+\t  to_read_record = nbytes;\n \t}\n \n       dtp->u.p.current_unit->bytes_left -= to_read_record;\n@@ -452,18 +449,16 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t  return;\n \t}\n \n-      if (to_read_record != (ssize_t) *nbytes)  \n+      if (to_read_record != (ssize_t) nbytes)  \n \t{\n \t  /* Short read, e.g. if we hit EOF.  Apparently, we read\n \t   more than was written to the last record.  */\n-\t  *nbytes = to_read_record;\n \t  return;\n \t}\n \n       if (unlikely (short_record))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);\n-\t  return;\n \t}\n       return;\n     }\n@@ -475,14 +470,14 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n   /* Check whether we exceed the total record length.  */\n \n   if (dtp->u.p.current_unit->flags.has_recl\n-      && (*nbytes > (size_t) dtp->u.p.current_unit->bytes_left))\n+      && (nbytes > dtp->u.p.current_unit->bytes_left))\n     {\n-      to_read_record = (ssize_t) dtp->u.p.current_unit->bytes_left;\n+      to_read_record = dtp->u.p.current_unit->bytes_left;\n       short_record = 1;\n     }\n   else\n     {\n-      to_read_record = *nbytes;\n+      to_read_record = nbytes;\n       short_record = 0;\n     }\n   have_read_record = 0;\n@@ -492,7 +487,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       if (dtp->u.p.current_unit->bytes_left_subrecord\n \t  < (gfc_offset) to_read_record)\n \t{\n-\t  to_read_subrecord = (ssize_t) dtp->u.p.current_unit->bytes_left_subrecord;\n+\t  to_read_subrecord = dtp->u.p.current_unit->bytes_left_subrecord;\n \t  to_read_record -= to_read_subrecord;\n \t}\n       else\n@@ -520,7 +515,6 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t     structure has been corrupted, or the trailing record\n \t     marker would still be present.  */\n \n-\t  *nbytes = have_read_record;\n \t  generate_error (&dtp->common, LIBERROR_CORRUPT_FILE, NULL);\n \t  return;\n \t}\n@@ -737,20 +731,18 @@ static void\n unformatted_read (st_parameter_dt *dtp, bt type,\n \t\t  void *dest, int kind, size_t size, size_t nelems)\n {\n-  size_t i, sz;\n-\n   if (likely (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE)\n       || kind == 1)\n     {\n-      sz = size * nelems;\n       if (type == BT_CHARACTER)\n-\tsz *= GFC_SIZE_OF_CHAR_KIND(kind);\n-      read_block_direct (dtp, dest, &sz);\n+\tsize *= GFC_SIZE_OF_CHAR_KIND(kind);\n+      read_block_direct (dtp, dest, size * nelems);\n     }\n   else\n     {\n       char buffer[16];\n       char *p;\n+      size_t i;\n \n       p = dest;\n \n@@ -773,7 +765,7 @@ unformatted_read (st_parameter_dt *dtp, bt type,\n       \n       for (i = 0; i < nelems; i++)\n \t{\n- \t  read_block_direct (dtp, buffer, &size);\n+ \t  read_block_direct (dtp, buffer, size);\n  \t  reverse_memcpy (p, buffer, size);\n  \t  p += size;\n  \t}\n@@ -2571,11 +2563,10 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n    position.  */\n \n static void\n-skip_record (st_parameter_dt *dtp, size_t bytes)\n+skip_record (st_parameter_dt *dtp, ssize_t bytes)\n {\n-  size_t rlength;\n-  ssize_t readb;\n-  static const size_t MAX_READ = 4096;\n+  ssize_t rlength, readb;\n+  static const ssize_t MAX_READ = 4096;\n   char p[MAX_READ];\n \n   dtp->u.p.current_unit->bytes_left_subrecord += bytes;\n@@ -2595,8 +2586,8 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n \t{\n \t  rlength = \n-\t    (MAX_READ < (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n-\t    MAX_READ : (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n+\t    (MAX_READ < dtp->u.p.current_unit->bytes_left_subrecord) ?\n+\t    MAX_READ : dtp->u.p.current_unit->bytes_left_subrecord;\n \n \t  readb = sread (dtp->u.p.current_unit->s, p, rlength);\n \t  if (readb < 0)\n@@ -2811,13 +2802,11 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n static void\n next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n {\n-  gfc_offset c, m, m_write;\n-  size_t record_marker;\n+  gfc_offset m, m_write, record_marker;\n \n   /* Bytes written.  */\n   m = dtp->u.p.current_unit->recl_subrecord\n     - dtp->u.p.current_unit->bytes_left_subrecord;\n-  c = stell (dtp->u.p.current_unit->s);\n \n   /* Write the length tail.  If we finish a record containing\n      subrecords, we write out the negative length.  */\n@@ -2838,8 +2827,8 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Seek to the head and overwrite the bogus length with the real\n      length.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker, \n-\t\t       SEEK_SET) < 0))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, - m - 2 * record_marker, \n+\t\t       SEEK_CUR) < 0))\n     goto io_error;\n \n   if (next_subrecord)\n@@ -2852,8 +2841,8 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n \n   /* Seek past the end of the current record.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker, \n-\t\t       SEEK_SET) < 0))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, m + record_marker, \n+\t\t       SEEK_CUR) < 0))\n     goto io_error;\n \n   return;\n@@ -3207,7 +3196,7 @@ iolength_transfer (st_parameter_dt *dtp, bt type __attribute__((unused)),\n \t\t   size_t size, size_t nelems)\n {\n   if ((dtp->common.flags & IOPARM_DT_HAS_IOLENGTH) != 0)\n-    *dtp->iolength += (GFC_IO_INT) size * nelems;\n+    *dtp->iolength += (GFC_IO_INT) (size * nelems);\n }\n \n "}, {"sha": "95076d67f8a8ed241db4d1b77e9a7e1550adcc41", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 56, "deletions": 17, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist output contributed by Paul Thomas\n@@ -602,7 +602,7 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n     n = -n;\n   nsign = sign == S_NONE ? 0 : 1;\n   \n-  /* conv calls gfc_itoa which sets the negative sign needed\n+  /* conv calls itoa which sets the negative sign needed\n      by write_integer. The sign '+' or '-' is set below based on sign\n      calculated above, so we just point past the sign in the string\n      before proceeding to avoid double signs in corner cases.\n@@ -712,10 +712,47 @@ btoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n }\n \n \n+/* itoa()-- Integer to decimal conversion. */\n+\n+static const char *\n+itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)\n+{\n+  int negative;\n+  char *p;\n+  GFC_UINTEGER_LARGEST t;\n+\n+  assert (len >= GFC_ITOA_BUF_SIZE);\n+\n+  if (n == 0)\n+    return \"0\";\n+\n+  negative = 0;\n+  t = n;\n+  if (n < 0)\n+    {\n+      negative = 1;\n+      t = -n; /*must use unsigned to protect from overflow*/\n+    }\n+\n+  p = buffer + GFC_ITOA_BUF_SIZE - 1;\n+  *p = '\\0';\n+\n+  while (t != 0)\n+    {\n+      *--p = '0' + (t % 10);\n+      t /= 10;\n+    }\n+\n+  if (negative)\n+    *--p = '-';\n+  return p;\n+}\n+\n+\n void\n write_i (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_decimal (dtp, f, p, len, (void *) gfc_itoa);\n+  write_decimal (dtp, f, p, len, (void *) itoa);\n }\n \n \n@@ -735,7 +772,7 @@ write_o (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n void\n write_z (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_int (dtp, f, p, len, xtoa);\n+  write_int (dtp, f, p, len, gfc_xtoa);\n }\n \n \n@@ -830,7 +867,7 @@ write_integer (st_parameter_dt *dtp, const char *source, int length)\n   int width;\n   char itoa_buf[GFC_ITOA_BUF_SIZE];\n \n-  q = gfc_itoa (extract_int (source, length), itoa_buf, sizeof (itoa_buf));\n+  q = itoa (extract_int (source, length), itoa_buf, sizeof (itoa_buf));\n \n   switch (length)\n     {\n@@ -1193,13 +1230,13 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   int rep_ctr;\n   int num;\n   int nml_carry;\n-  index_type len;\n+  int len;\n   index_type obj_size;\n   index_type nelem;\n-  index_type dim_i;\n-  index_type clen;\n+  size_t dim_i;\n+  size_t clen;\n   index_type elem_ctr;\n-  index_type obj_name_len;\n+  size_t obj_name_len;\n   void * p ;\n   char cup;\n   char * obj_name;\n@@ -1229,14 +1266,16 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n       len = 0;\n       if (base)\n \t{\n-\t  len =strlen (base->var_name);\n-\t  for (dim_i = 0; dim_i < (index_type) strlen (base_name); dim_i++)\n+\t  len = strlen (base->var_name);\n+\t  base_name_len = strlen (base_name);\n+\t  for (dim_i = 0; dim_i < base_name_len; dim_i++)\n             {\n \t      cup = toupper (base_name[dim_i]);\n \t      write_character (dtp, &cup, 1, 1);\n             }\n \t}\n-      for (dim_i =len; dim_i < (index_type) strlen (obj->var_name); dim_i++)\n+      clen = strlen (obj->var_name);\n+      for (dim_i = len; dim_i < clen; dim_i++)\n \t{\n \t  cup = toupper (obj->var_name[dim_i]);\n \t  write_character (dtp, &cup, 1, 1);\n@@ -1275,7 +1314,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   /* Set the index vector and count the number of elements.  */\n \n   nelem = 1;\n-  for (dim_i=0; dim_i < obj->var_rank; dim_i++)\n+  for (dim_i = 0; dim_i < (size_t) obj->var_rank; dim_i++)\n     {\n       obj->ls[dim_i].idx = obj->dim[dim_i].lbound;\n       nelem = nelem * (obj->dim[dim_i].ubound + 1 - obj->dim[dim_i].lbound);\n@@ -1378,7 +1417,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t      /* Append the qualifier.  */\n \n \t      tot_len = base_name_len + clen;\n-\t      for (dim_i = 0; dim_i < obj->var_rank; dim_i++)\n+\t      for (dim_i = 0; dim_i < (size_t) obj->var_rank; dim_i++)\n \t\t{\n \t\t  if (!dim_i)\n \t\t    {\n@@ -1387,7 +1426,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t\t    }\n \t\t  sprintf (ext_name + tot_len, \"%d\", (int) obj->ls[dim_i].idx);\n \t\t  tot_len += strlen (ext_name + tot_len);\n-\t\t  ext_name[tot_len] = (dim_i == obj->var_rank - 1) ? ')' : ',';\n+\t\t  ext_name[tot_len] = ((int) dim_i == obj->var_rank - 1) ? ')' : ',';\n \t\t  tot_len++;\n \t\t}\n \n@@ -1441,11 +1480,11 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n obj_loop:\n \n     nml_carry = 1;\n-    for (dim_i = 0; nml_carry && (dim_i < obj->var_rank); dim_i++)\n+    for (dim_i = 0; nml_carry && (dim_i < (size_t) obj->var_rank); dim_i++)\n       {\n \tobj->ls[dim_i].idx += nml_carry ;\n \tnml_carry = 0;\n-\tif (obj->ls[dim_i].idx  > (ssize_t)obj->dim[dim_i].ubound)\n+\tif (obj->ls[dim_i].idx  > (index_type) obj->dim[dim_i].ubound)\n \t  {\n \t    obj->ls[dim_i].idx = obj->dim[dim_i].lbound;\n \t    nml_carry = 1;"}, {"sha": "9e976db737f021ba6641010d76160ffb83c12939", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,5 +1,5 @@\n /* Common declarations for all of libgfortran.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>, and\n    Andy Vaught <andy@xena.eas.asu.edu>\n@@ -635,11 +635,8 @@ internal_proto(show_backtrace);\n extern void sys_exit (int) __attribute__ ((noreturn));\n internal_proto(sys_exit);\n \n-extern const char *gfc_itoa (GFC_INTEGER_LARGEST, char *, size_t);\n-internal_proto(gfc_itoa);\n-\n-extern const char *xtoa (GFC_UINTEGER_LARGEST, char *, size_t);\n-internal_proto(xtoa);\n+extern const char *gfc_xtoa (GFC_UINTEGER_LARGEST, char *, size_t);\n+internal_proto(gfc_xtoa);\n \n extern void os_error (const char *) __attribute__ ((noreturn));\n iexport_proto(os_error);"}, {"sha": "0dd207466efebb6bd3daf57d7769a90121da64cd", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -152,7 +152,7 @@ show_backtrace (void)\n \n     /* Write the list of addresses in hexadecimal format.  */\n     for (i = 0; i < depth; i++)\n-      addr[i] = xtoa ((GFC_UINTEGER_LARGEST) (intptr_t) trace[i], addr_buf[i],\n+      addr[i] = gfc_xtoa ((GFC_UINTEGER_LARGEST) (intptr_t) trace[i], addr_buf[i],\n \t\t      sizeof (addr_buf[i]));\n \n     /* Don't output an error message if something goes wrong, we'll simply"}, {"sha": "2dede7215c49b4d3e88647c98c974c95be9c1ffb", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 3, "deletions": 40, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2005, 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -116,47 +116,10 @@ sys_exit (int code)\n  * Other error returns are reserved for the STOP statement with a numeric code.\n  */\n \n-/* gfc_itoa()-- Integer to decimal conversion. */\n+/* gfc_xtoa()-- Integer to hexadecimal conversion.  */\n \n const char *\n-gfc_itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)\n-{\n-  int negative;\n-  char *p;\n-  GFC_UINTEGER_LARGEST t;\n-\n-  assert (len >= GFC_ITOA_BUF_SIZE);\n-\n-  if (n == 0)\n-    return \"0\";\n-\n-  negative = 0;\n-  t = n;\n-  if (n < 0)\n-    {\n-      negative = 1;\n-      t = -n; /*must use unsigned to protect from overflow*/\n-    }\n-\n-  p = buffer + GFC_ITOA_BUF_SIZE - 1;\n-  *p = '\\0';\n-\n-  while (t != 0)\n-    {\n-      *--p = '0' + (t % 10);\n-      t /= 10;\n-    }\n-\n-  if (negative)\n-    *--p = '-';\n-  return p;\n-}\n-\n-\n-/* xtoa()-- Integer to hexadecimal conversion.  */\n-\n-const char *\n-xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n+gfc_xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n {\n   int digit;\n   char *p;"}, {"sha": "a14f82c502fdc26395b38ecbd711b5b154328c00", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=f9bfed2243864c72c8a7822ce0ec9b7a1f2a35c8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003, 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -37,7 +37,7 @@ Boston, MA 02110-1301, USA.  */\n static int\n compare0 (const char *s1, gfc_charlen_type s1_len, const char *s2)\n {\n-  size_t len;\n+  gfc_charlen_type len;\n \n   /* Strip trailing blanks from the Fortran string.  */\n   len = fstrlen (s1, s1_len);"}]}