{"sha": "3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IzN2NjZDRmZjk0ZmIxZWE2Y2YzM2I3NWU1ODNjNjY4NzRhYjg2Mg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-06-29T14:14:16Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2014-06-29T14:14:16Z"}, "message": "re PR fortran/36275 ([F03] Binding label can be any scalar char initialisation expression)\n\n\tPR fortran/36275\n\tPR fortran/38839\n\n\t* decl.c (check_bind_name_identifier): New function.\n\t(gfc_match_bind_c): Match any constant expression as binding\n\tlabel.\n\t* match.c (gfc_match_name_C): Remove.\n\n\t* gfortran.dg/binding_label_tests_2.f03: Adjust error messages.\n\t* gfortran.dg/binding_label_tests_27.f90: New file.\n\nFrom-SVN: r212123", "tree": {"sha": "412eee3cabd54ee810c7b511d6db1d6f6df41d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/412eee3cabd54ee810c7b511d6db1d6f6df41d5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "516a84f7c0fef97317781cab65213ceef7d696df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516a84f7c0fef97317781cab65213ceef7d696df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516a84f7c0fef97317781cab65213ceef7d696df"}], "stats": {"total": 270, "additions": 131, "deletions": 139}, "files": [{"sha": "5ebf40b3b2e66873ff7ab6d9b0a0c2228d759b1a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "patch": "@@ -1,3 +1,12 @@\n+2014-06-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/36275\n+\tPR fortran/38839\n+\t* decl.c (check_bind_name_identifier): New function.\n+\t(gfc_match_bind_c): Match any constant expression as binding\n+\tlabel.\n+\t* match.c (gfc_match_name_C): Remove.\n+\n 2014-06-28  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/29383"}, {"sha": "7f7428156e3ed246d00f212ece38f8b038189477", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 76, "deletions": 37, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "patch": "@@ -5779,6 +5779,54 @@ gfc_match_subroutine (void)\n }\n \n \n+/* Check that the NAME identifier in a BIND attribute or statement\n+   is conform to C identifier rules.  */\n+\n+match\n+check_bind_name_identifier (char **name)\n+{\n+  char *n = *name, *p;\n+\n+  /* Remove leading spaces.  */\n+  while (*n == ' ')\n+    n++;\n+\n+  /* On an empty string, free memory and set name to NULL.  */\n+  if (*n == '\\0')\n+    {\n+      free (*name);\n+      *name = NULL;\n+      return MATCH_YES;\n+    }\n+\n+  /* Remove trailing spaces.  */\n+  p = n + strlen(n) - 1;\n+  while (*p == ' ')\n+    *(p--) = '\\0';\n+\n+  /* Insert the identifier into the symbol table.  */\n+  p = xstrdup (n);\n+  free (*name);\n+  *name = p;\n+\n+  /* Now check that identifier is valid under C rules.  */\n+  if (ISDIGIT (*p))\n+    {\n+      gfc_error (\"Invalid C identifier in NAME= specifier at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  for (; *p; p++)\n+    if (!(ISALNUM (*p) || *p == '_' || *p == '$'))\n+      {\n+        gfc_error (\"Invalid C identifier in NAME= specifier at %C\");\n+\treturn MATCH_ERROR;\n+      }\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a BIND(C) specifier, with the optional 'name=' specifier if\n    given, and set the binding label in either the given symbol (if not\n    NULL), or in the current_ts.  The symbol may be NULL because we may\n@@ -5793,10 +5841,8 @@ gfc_match_subroutine (void)\n match\n gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n {\n-  /* binding label, if exists */\n-  const char* binding_label = NULL;\n-  match double_quote;\n-  match single_quote;\n+  char *binding_label = NULL;\n+  gfc_expr *e = NULL;\n \n   /* Initialize the flag that specifies whether we encountered a NAME=\n      specifier or not.  */\n@@ -5821,44 +5867,37 @@ gfc_match_bind_c (gfc_symbol *sym, bool allow_binding_name)\n \n       has_name_equals = 1;\n \n-      /* Get the opening quote.  */\n-      double_quote = MATCH_YES;\n-      single_quote = MATCH_YES;\n-      double_quote = gfc_match_char ('\"');\n-      if (double_quote != MATCH_YES)\n-\tsingle_quote = gfc_match_char ('\\'');\n-      if (double_quote != MATCH_YES && single_quote != MATCH_YES)\n-        {\n-          gfc_error (\"Syntax error in NAME= specifier for binding label \"\n-                     \"at %C\");\n-          return MATCH_ERROR;\n-        }\n-\n-      /* Grab the binding label, using functions that will not lower\n-\t case the names automatically.\t*/\n-      if (gfc_match_name_C (&binding_label) != MATCH_YES)\n-\t return MATCH_ERROR;\n+      if (gfc_match_init_expr (&e) != MATCH_YES)\n+\t{\n+\t  gfc_free_expr (e);\n+\t  return MATCH_ERROR;\n+\t}\n \n-      /* Get the closing quotation.  */\n-      if (double_quote == MATCH_YES)\n+      if (!gfc_simplify_expr(e, 0))\n \t{\n-\t  if (gfc_match_char ('\"') != MATCH_YES)\n-            {\n-              gfc_error (\"Missing closing quote '\\\"' for binding label at %C\");\n-              /* User started string with '\"' so looked to match it.  */\n-              return MATCH_ERROR;\n-            }\n+\t  gfc_error (\"NAME= specifier at %C should be a constant expression\");\n+\t  gfc_free_expr (e);\n+\t  return MATCH_ERROR;\n \t}\n-      else\n+\n+      if (e->expr_type != EXPR_CONSTANT || e->ts.type != BT_CHARACTER\n+\t  || e->ts.kind != gfc_default_character_kind || e->rank != 0)\n \t{\n-\t  if (gfc_match_char ('\\'') != MATCH_YES)\n-            {\n-              gfc_error (\"Missing closing quote '\\'' for binding label at %C\");\n-              /* User started string with \"'\" char.  */\n-              return MATCH_ERROR;\n-            }\n+\t  gfc_error (\"NAME= specifier at %C should be a scalar of \"\n+\t             \"default character kind\");\n+\t  gfc_free_expr(e);\n+\t  return MATCH_ERROR;\n \t}\n-   }\n+\n+      // Get a C string from the Fortran string constant\n+      binding_label = gfc_widechar_to_char (e->value.character.string,\n+\t\t\t\t\t    e->value.character.length);\n+      gfc_free_expr(e);\n+\n+      // Check that it is valid (old gfc_match_name_C)\n+      if (check_bind_name_identifier (&binding_label) != MATCH_YES)\n+\treturn MATCH_ERROR;\n+    }\n \n   /* Get the required right paren.  */\n   if (gfc_match_char (')') != MATCH_YES)"}, {"sha": "84e2764e1312897aba85049bcd7ccf2a015f5bf6", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "patch": "@@ -569,99 +569,6 @@ gfc_match_name (char *buffer)\n }\n \n \n-/* Match a valid name for C, which is almost the same as for Fortran,\n-   except that you can start with an underscore, etc..  It could have\n-   been done by modifying the gfc_match_name, but this way other\n-   things C allows can be done, such as no limits on the length.\n-   Also, by rewriting it, we use the gfc_next_char_C() to prevent the\n-   input characters from being automatically lower cased, since C is\n-   case sensitive.  The parameter, buffer, is used to return the name\n-   that is matched.  Return MATCH_ERROR if the name is not a valid C\n-   name, MATCH_NO if what we're seeing isn't a name, and MATCH_YES if\n-   we successfully match a C name.  */\n-\n-match\n-gfc_match_name_C (const char **buffer)\n-{\n-  locus old_loc;\n-  size_t i = 0;\n-  gfc_char_t c;\n-  char* buf;\n-  size_t cursz = 16;\n-\n-  old_loc = gfc_current_locus;\n-  gfc_gobble_whitespace ();\n-\n-  /* Get the next char (first possible char of name) and see if\n-     it's valid for C (either a letter or an underscore).  */\n-  c = gfc_next_char_literal (INSTRING_WARN);\n-\n-  /* If the user put nothing expect spaces between the quotes, it is valid\n-     and simply means there is no name= specifier and the name is the Fortran\n-     symbol name, all lowercase.  */\n-  if (c == '\"' || c == '\\'')\n-    {\n-      gfc_current_locus = old_loc;\n-      return MATCH_YES;\n-    }\n-\n-  if (!ISALPHA (c) && c != '_')\n-    {\n-      gfc_error (\"Invalid C name in NAME= specifier at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  buf = XNEWVEC (char, cursz);\n-  /* Continue to read valid variable name characters.  */\n-  do\n-    {\n-      gcc_assert (gfc_wide_fits_in_byte (c));\n-\n-      buf[i++] = (unsigned char) c;\n-\n-      if (i >= cursz)\n-\t{\n-\t  cursz *= 2;\n-\t  buf = XRESIZEVEC (char, buf, cursz);\n-\t}\n-\n-      old_loc = gfc_current_locus;\n-\n-      /* Get next char; param means we're in a string.  */\n-      c = gfc_next_char_literal (INSTRING_WARN);\n-    } while (ISALNUM (c) || c == '_');\n-\n-  /* The binding label will be needed later anyway, so just insert it\n-     into the symbol table.  */\n-  buf[i] = '\\0';\n-  *buffer = IDENTIFIER_POINTER (get_identifier (buf));\n-  XDELETEVEC (buf);\n-  gfc_current_locus = old_loc;\n-\n-  /* See if we stopped because of whitespace.  */\n-  if (c == ' ')\n-    {\n-      gfc_gobble_whitespace ();\n-      c = gfc_peek_ascii_char ();\n-      if (c != '\"' && c != '\\'')\n-        {\n-          gfc_error (\"Embedded space in NAME= specifier at %C\");\n-          return MATCH_ERROR;\n-        }\n-    }\n-\n-  /* If we stopped because we had an invalid character for a C name, report\n-     that to the user by returning MATCH_NO.  */\n-  if (c != '\"' && c != '\\'')\n-    {\n-      gfc_error (\"Invalid C name in NAME= specifier at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  return MATCH_YES;\n-}\n-\n-\n /* Match a symbol on the input.  Modifies the pointer to the symbol\n    pointer if successful.  */\n "}, {"sha": "86276d9bd3819dd04b3aeaa3580f56191437578b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "patch": "@@ -1,3 +1,10 @@\n+2014-06-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/36275\n+\tPR fortran/38839\n+\t* gfortran.dg/binding_label_tests_2.f03: Adjust error messages.\n+\t* gfortran.dg/binding_label_tests_27.f90: New file.\n+\n 2014-06-29  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* gfortran.dg/ieee/ieee_6.f90: Allow inexact together with"}, {"sha": "c2ec632d10d4b1d0fe40b7230bf2ca8ed76741cd", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_2.f03", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_2.f03?ref=3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "patch": "@@ -7,25 +7,28 @@ module binding_label_tests_2\n   subroutine ok() \n   end subroutine ok\n \n-  subroutine sub0() bind(c, name=\"   1\") ! { dg-error \"Invalid C name\" }\n+  subroutine sub0() bind(c, name=\"   1\") ! { dg-error \"Invalid C identifier\" }\n   end subroutine sub0 ! { dg-error \"Expecting END MODULE\" }\n \n-  subroutine sub1() bind(c, name=\"$\") ! { dg-error \"Invalid C name\" }\n-  end subroutine sub1 ! { dg-error \"Expecting END MODULE\" }\n+  subroutine sub1() bind(c, name=\"$\")\n+  end subroutine sub1\n \n-  subroutine sub2() bind(c, name=\"abc$\") ! { dg-error \"Invalid C name\" }\n-  end subroutine sub2 ! { dg-error \"Expecting END MODULE\" }\n+  subroutine sub2() bind(c, name=\"abc$\")\n+  end subroutine sub2\n \n-  subroutine sub3() bind(c, name=\"abc d\") ! { dg-error \"Embedded space\" }\n+  subroutine sub3() bind(c, name=\"abc d\") ! { dg-error \"Invalid C identifier\" }\n   end subroutine sub3 ! { dg-error \"Expecting END MODULE\" }\n \n-  subroutine sub5() BIND(C, name=\" myvar 2 \") ! { dg-error \"Embedded space\" }\n+  subroutine sub4() bind(c, name=\"2foo\") ! { dg-error \"Invalid C identifier\" }\n+  end subroutine sub4 ! { dg-error \"Expecting END MODULE\" }\n+\n+  subroutine sub5() BIND(C, name=\" myvar 2 \") ! { dg-error \"Invalid C identifier\" }\n   end subroutine sub5 ! { dg-error \"Expecting END MODULE\" }\n \n-  subroutine sub6() bind(c, name=\"         ) ! { dg-error \"Invalid C name\" }\n+  subroutine sub6() bind(c, name=\"         ) ! { dg-error \"Invalid C identifier\" }\n   end subroutine sub6 ! { dg-error \"Expecting END MODULE\" }\n \n-  subroutine sub7() bind(c, name=) ! { dg-error \"Syntax error\" }\n+  subroutine sub7() bind(c, name=) ! { dg-error \"Invalid character\" }\n   end subroutine sub7 ! { dg-error \"Expecting END MODULE\" }\n \n   subroutine sub8() bind(c, name) ! { dg-error \"Syntax error\" }"}, {"sha": "b0cd74e5cd0582d9fc8e247110e17d728f77a40e", "filename": "gcc/testsuite/gfortran.dg/binding_label_tests_27.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_27.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b37ccd4ff94fb1ea6cf33b75e583c66874ab862/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_27.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbinding_label_tests_27.f90?ref=3b37ccd4ff94fb1ea6cf33b75e583c66874ab862", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+\n+module p\n+\n+  implicit none\n+  integer i1, i2, i3, i4, i5, i6, i7, i8, i9, i10\n+\n+  character(len=*), parameter :: s = \"toto\"\n+  character(len=*), parameter :: t(2) = [\"x\", \"y\"]\n+\n+  bind(c,name=\"   foo    \") :: i1\n+  bind(c, name=trim(\"Hello   \") // \"There\") :: i2\n+  bind(c, name=1_\"name\") :: i3\n+  bind(c, name=4_\"\") :: i4 ! { dg-error \"scalar of default character kind\" }\n+  bind(c, name=1) :: i5 ! { dg-error \"scalar of default character kind\" }\n+  bind(c, name=1.0) :: i6 ! { dg-error \"scalar of default character kind\" }\n+  bind(c, name=[\"\",\"\",\"\"]) :: i7 ! { dg-error \"scalar of default character kind\" }\n+  bind(c, name=s) :: i8\n+  bind(c, name=t(2)) :: i9\n+\n+end module\n+\n+subroutine foobar(s)\n+  character(len=*) :: s\n+  integer :: i\n+  bind(c, name=s) :: i ! { dg-error \"constant expression\" }\n+end subroutine"}]}