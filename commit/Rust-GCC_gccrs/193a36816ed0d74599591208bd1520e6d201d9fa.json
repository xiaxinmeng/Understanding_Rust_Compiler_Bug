{"sha": "193a36816ed0d74599591208bd1520e6d201d9fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzYTM2ODE2ZWQwZDc0NTk5NTkxMjA4YmQxNTIwZTZkMjAxZDlmYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-12-01T14:34:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-12-01T14:34:51Z"}, "message": "re PR rtl-optimization/38245 (stack corruption when a call is removed but not the outgoing argument pushes)\n\n\tPR rtl-optimization/38245\n\t* tree-vrp.c (abs_extent_range): New function.\n\t(extract_range_from_binary_expr): Compute range\n\tfor *_DIV_EXPR even if vr1 is VR_VARYING, VR_ANTI_RANGE\n\tor includes zero or if vr1 is VR_RANGE and op0 has some\n\tother range.\n\n\t* gcc.dg/pr38245-1.c: New test.\n\t* gcc.dg/pr38245-2.c: New test.\n\nFrom-SVN: r142317", "tree": {"sha": "94654a380e73859bd598639a67717b56b13ace7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94654a380e73859bd598639a67717b56b13ace7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/193a36816ed0d74599591208bd1520e6d201d9fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193a36816ed0d74599591208bd1520e6d201d9fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/193a36816ed0d74599591208bd1520e6d201d9fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/193a36816ed0d74599591208bd1520e6d201d9fa/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d04dceb5ff1668e6e4bb5177f9f619f5e5fffa82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d04dceb5ff1668e6e4bb5177f9f619f5e5fffa82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d04dceb5ff1668e6e4bb5177f9f619f5e5fffa82"}], "stats": {"total": 417, "additions": 349, "deletions": 68}, "files": [{"sha": "05b970b7f46858e271c39af5cf0ba0c0225ed3ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=193a36816ed0d74599591208bd1520e6d201d9fa", "patch": "@@ -1,3 +1,12 @@\n+2008-12-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/38245\n+\t* tree-vrp.c (abs_extent_range): New function.\n+\t(extract_range_from_binary_expr): Compute range\n+\tfor *_DIV_EXPR even if vr1 is VR_VARYING, VR_ANTI_RANGE\n+\tor includes zero or if vr1 is VR_RANGE and op0 has some\n+\tother range.\n+\n 2008-12-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR middle-end/37908"}, {"sha": "88adf43bda1cb74497c704a1e1966b9418362f7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=193a36816ed0d74599591208bd1520e6d201d9fa", "patch": "@@ -1,3 +1,9 @@\n+2008-12-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/38245\n+\t* gcc.dg/pr38245-1.c: New test.\n+\t* gcc.dg/pr38245-2.c: New test.\n+\n 2008-11-30  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37779"}, {"sha": "17b969c7de00fc3b4c4aec3335453fbe69b51914", "filename": "gcc/testsuite/gcc.dg/pr38245-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-1.c?ref=193a36816ed0d74599591208bd1520e6d201d9fa", "patch": "@@ -0,0 +1,36 @@\n+/* PR rtl-optimization/38245 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+static inline int\n+f1 (int si1, int si2)\n+{\n+  return si2 == 0 ? si1 : si1 / si2;\n+}\n+\n+static inline unsigned long long\n+f2 (unsigned long long ui1, unsigned long long ui2)\n+{\n+  return ui1 % ui2;\n+}\n+\n+unsigned char g;\n+volatile unsigned int h;\n+\n+void\n+f3 (void)\n+{\n+  if (!((signed char) f1 (0, f2 (g, 2123)) - 1))\n+    h;\n+}\n+\n+int\n+main (void)\n+{\n+  f3 ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"% 2123\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"0 / \" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "2998299375d72ec95b46a5cdf8cdb281b370f640", "filename": "gcc/testsuite/gcc.dg/pr38245-2.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38245-2.c?ref=193a36816ed0d74599591208bd1520e6d201d9fa", "patch": "@@ -0,0 +1,110 @@\n+/* PR rtl-optimization/38245 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+extern void link_error (void);\n+\n+void\n+f1 (unsigned int a)\n+{\n+  if (a != 28)\n+    {\n+      if (4 / a == 5)\n+\tlink_error ();\n+    }\n+}\n+\n+void\n+f2 (unsigned int a)\n+{\n+  if (4 / a == 5)\n+    link_error ();\n+}\n+\n+void\n+f3 (unsigned int a)\n+{\n+  if (4 / (a & 0xff) == 5)\n+    link_error ();\n+}\n+\n+void\n+f4 (unsigned int a, unsigned int b)\n+{\n+  if ((b & 3) / ((a & 0xff) + 1) == 5)\n+    link_error ();\n+}\n+\n+void\n+f5 (int a)\n+{\n+  if (a != 28)\n+    {\n+      if (4 / a == 5)\n+\tlink_error ();\n+    }\n+}\n+\n+void\n+f6 (int a)\n+{\n+  if (4 / a == 5)\n+    link_error ();\n+}\n+\n+void\n+f7 (int a)\n+{\n+  if (4 / (a & 0xff) == 5)\n+    link_error ();\n+}\n+\n+void\n+f8 (int a, int b)\n+{\n+  if ((b & 3) / ((a & 0xff) + 1) == 5)\n+    link_error ();\n+}\n+\n+void\n+f9 (int a, int b)\n+{\n+  if (b >= 4)\n+    if ((a / b) == __INT_MAX__ / 2)\n+      link_error ();\n+}\n+\n+void\n+f10 (unsigned int a, unsigned int b)\n+{\n+  if (b >= 16)\n+    if ((a / b) == __INT_MAX__ / 4)\n+      link_error ();\n+}\n+\n+void\n+f11 (int a, int b)\n+{\n+  if (b <= -32)\n+    if ((a / b) == -__INT_MAX__ / 16)\n+      link_error ();\n+}\n+\n+void\n+f12 (int a, int b)\n+{\n+  if (a >= -6 && a <= 4)\n+    if ((a / b) == -7 || (a / b) == 7)\n+      link_error ();\n+}\n+\n+void\n+f13 (unsigned int a, unsigned int b)\n+{\n+  if (a <= 4)\n+    if ((a / b) == 5)\n+      link_error ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"link_error\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1289c49ef1daa9be9e51b4905f0a52be1e1a329a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 188, "deletions": 68, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/193a36816ed0d74599591208bd1520e6d201d9fa/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=193a36816ed0d74599591208bd1520e6d201d9fa", "patch": "@@ -599,6 +599,42 @@ set_value_range_to_undefined (value_range_t *vr)\n }\n \n \n+/* If abs (min) < abs (max), set VR to [-max, max], if\n+   abs (min) >= abs (max), set VR to [-min, min].  */\n+\n+static void\n+abs_extent_range (value_range_t *vr, tree min, tree max)\n+{\n+  int cmp;\n+\n+  gcc_assert (TREE_CODE (min) == INTEGER_CST);\n+  gcc_assert (TREE_CODE (max) == INTEGER_CST);\n+  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (min)));\n+  gcc_assert (!TYPE_UNSIGNED (TREE_TYPE (min)));\n+  min = fold_unary (ABS_EXPR, TREE_TYPE (min), min);\n+  max = fold_unary (ABS_EXPR, TREE_TYPE (max), max);\n+  if (TREE_OVERFLOW (min) || TREE_OVERFLOW (max))\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+  cmp = compare_values (min, max);\n+  if (cmp == -1)\n+    min = fold_unary (NEGATE_EXPR, TREE_TYPE (min), max);\n+  else if (cmp == 0 || cmp == 1)\n+    {\n+      max = min;\n+      min = fold_unary (NEGATE_EXPR, TREE_TYPE (min), min);\n+    }\n+  else\n+    {\n+      set_value_range_to_varying (vr);\n+      return;\n+    }\n+  set_and_canonicalize_value_range (vr, VR_RANGE, min, max, NULL);\n+}\n+\n+\n /* Return value range information for VAR.  \n \n    If we have no values ranges recorded (ie, VRP is not running), then\n@@ -2108,11 +2144,17 @@ extract_range_from_binary_expr (value_range_t *vr,\n   /* Refuse to operate on VARYING ranges, ranges of different kinds\n      and symbolic ranges.  As an exception, we allow BIT_AND_EXPR\n      because we may be able to derive a useful range even if one of\n-     the operands is VR_VARYING or symbolic range.  TODO, we may be\n-     able to derive anti-ranges in some cases.  */\n+     the operands is VR_VARYING or symbolic range.  Similarly for\n+     divisions.  TODO, we may be able to derive anti-ranges in\n+     some cases.  */\n   if (code != BIT_AND_EXPR\n       && code != TRUTH_AND_EXPR\n       && code != TRUTH_OR_EXPR\n+      && code != TRUNC_DIV_EXPR\n+      && code != FLOOR_DIV_EXPR\n+      && code != CEIL_DIV_EXPR\n+      && code != EXACT_DIV_EXPR\n+      && code != ROUND_DIV_EXPR\n       && (vr0.type == VR_VARYING\n \t  || vr1.type == VR_VARYING\n \t  || vr0.type != vr1.type\n@@ -2276,6 +2318,86 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t    }\n \t}\n \n+      else if ((code == TRUNC_DIV_EXPR\n+\t\t|| code == FLOOR_DIV_EXPR\n+\t\t|| code == CEIL_DIV_EXPR\n+\t\t|| code == EXACT_DIV_EXPR\n+\t\t|| code == ROUND_DIV_EXPR)\n+\t       && (vr0.type != VR_RANGE || symbolic_range_p (&vr0)))\n+\t{\n+\t  /* For division, if op1 has VR_RANGE but op0 does not, something\n+\t     can be deduced just from that range.  Say [min, max] / [4, max]\n+\t     gives [min / 4, max / 4] range.  */\n+\t  if (vr1.type == VR_RANGE\n+\t      && !symbolic_range_p (&vr1)\n+\t      && !range_includes_zero_p (&vr1))\n+\t    {\n+\t      vr0.type = type = VR_RANGE;\n+\t      vr0.min = vrp_val_min (TREE_TYPE (op0));\n+\t      vr0.max = vrp_val_max (TREE_TYPE (op1));\n+\t    }\n+\t  else\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* For divisions, if op0 is VR_RANGE, we can deduce a range\n+\t even if op1 is VR_VARYING, VR_ANTI_RANGE, symbolic or can\n+\t include 0.  */\n+      if ((code == TRUNC_DIV_EXPR\n+\t   || code == FLOOR_DIV_EXPR\n+\t   || code == CEIL_DIV_EXPR\n+\t   || code == EXACT_DIV_EXPR\n+\t   || code == ROUND_DIV_EXPR)\n+\t  && vr0.type == VR_RANGE\n+\t  && (vr1.type != VR_RANGE\n+\t      || symbolic_range_p (&vr1)\n+\t      || range_includes_zero_p (&vr1)))\n+\t{\n+\t  tree zero = build_int_cst (TREE_TYPE (vr0.min), 0);\n+\t  int cmp;\n+\n+\t  sop = false;\n+\t  min = NULL_TREE;\n+\t  max = NULL_TREE;\n+\t  if (vrp_expr_computes_nonnegative (op1, &sop) && !sop)\n+\t    {\n+\t      /* For unsigned division or when divisor is known\n+\t\t to be non-negative, the range has to cover\n+\t\t all numbers from 0 to max for positive max\n+\t\t and all numbers from min to 0 for negative min.  */\n+\t      cmp = compare_values (vr0.max, zero);\n+\t      if (cmp == -1)\n+\t\tmax = zero;\n+\t      else if (cmp == 0 || cmp == 1)\n+\t\tmax = vr0.max;\n+\t      else\n+\t\ttype = VR_VARYING;\n+\t      cmp = compare_values (vr0.min, zero);\n+\t      if (cmp == 1)\n+\t\tmin = zero;\n+\t      else if (cmp == 0 || cmp == -1)\n+\t\tmin = vr0.min;\n+\t      else\n+\t\ttype = VR_VARYING;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise the range is -max .. max or min .. -min\n+\t\t depending on which bound is bigger in absolute value,\n+\t\t as the division can change the sign.  */\n+\t      abs_extent_range (vr, vr0.min, vr0.max);\n+\t      return;\n+\t    }\n+\t  if (type == VR_VARYING)\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\t}\n+\n       /* Multiplications and divisions are a bit tricky to handle,\n \t depending on the mix of signs we have in the two ranges, we\n \t need to operate on different values to get the minimum and\n@@ -2288,84 +2410,82 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n \t MAX1) and then figure the smallest and largest values to form\n \t the new range.  */\n-\n-      /* Divisions by zero result in a VARYING value.  */\n-      else if (code != MULT_EXPR\n-\t       && (vr0.type == VR_ANTI_RANGE || range_includes_zero_p (&vr1)))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n-      /* Compute the 4 cross operations.  */\n-      sop = false;\n-      val[0] = vrp_int_const_binop (code, vr0.min, vr1.min);\n-      if (val[0] == NULL_TREE)\n-\tsop = true;\n-\n-      if (vr1.max == vr1.min)\n-\tval[1] = NULL_TREE;\n       else\n \t{\n-\t  val[1] = vrp_int_const_binop (code, vr0.min, vr1.max);\n-\t  if (val[1] == NULL_TREE)\n-\t    sop = true;\n-\t}\n+\t  gcc_assert ((vr0.type == VR_RANGE\n+\t\t       || (code == MULT_EXPR && vr0.type == VR_ANTI_RANGE))\n+\t\t      && vr0.type == vr1.type);\n \n-      if (vr0.max == vr0.min)\n-\tval[2] = NULL_TREE;\n-      else\n-\t{\n-\t  val[2] = vrp_int_const_binop (code, vr0.max, vr1.min);\n-\t  if (val[2] == NULL_TREE)\n+\t  /* Compute the 4 cross operations.  */\n+\t  sop = false;\n+\t  val[0] = vrp_int_const_binop (code, vr0.min, vr1.min);\n+\t  if (val[0] == NULL_TREE)\n \t    sop = true;\n-\t}\n \n-      if (vr0.min == vr0.max || vr1.min == vr1.max)\n-\tval[3] = NULL_TREE;\n-      else\n-\t{\n-\t  val[3] = vrp_int_const_binop (code, vr0.max, vr1.max);\n-\t  if (val[3] == NULL_TREE)\n-\t    sop = true;\n-\t}\n+\t  if (vr1.max == vr1.min)\n+\t    val[1] = NULL_TREE;\n+\t  else\n+\t    {\n+\t      val[1] = vrp_int_const_binop (code, vr0.min, vr1.max);\n+\t      if (val[1] == NULL_TREE)\n+\t\tsop = true;\n+\t    }\n \n-      if (sop)\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n+\t  if (vr0.max == vr0.min)\n+\t    val[2] = NULL_TREE;\n+\t  else\n+\t    {\n+\t      val[2] = vrp_int_const_binop (code, vr0.max, vr1.min);\n+\t      if (val[2] == NULL_TREE)\n+\t\tsop = true;\n+\t    }\n \n-      /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n-\t of VAL[i].  */\n-      min = val[0];\n-      max = val[0];\n-      for (i = 1; i < 4; i++)\n-\t{\n-\t  if (!is_gimple_min_invariant (min)\n-\t      || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n-\t      || !is_gimple_min_invariant (max)\n-\t      || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n-\t    break;\n+\t  if (vr0.min == vr0.max || vr1.min == vr1.max)\n+\t    val[3] = NULL_TREE;\n+\t  else\n+\t    {\n+\t      val[3] = vrp_int_const_binop (code, vr0.max, vr1.max);\n+\t      if (val[3] == NULL_TREE)\n+\t\tsop = true;\n+\t    }\n+\n+\t  if (sop)\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n \n-\t  if (val[i])\n+\t  /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n+\t     of VAL[i].  */\n+\t  min = val[0];\n+\t  max = val[0];\n+\t  for (i = 1; i < 4; i++)\n \t    {\n-\t      if (!is_gimple_min_invariant (val[i])\n-\t\t  || (TREE_OVERFLOW (val[i])\n-\t\t      && !is_overflow_infinity (val[i])))\n+\t      if (!is_gimple_min_invariant (min)\n+\t\t  || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+\t\t  || !is_gimple_min_invariant (max)\n+\t\t  || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+\t\tbreak;\n+\n+\t      if (val[i])\n \t\t{\n-\t\t  /* If we found an overflowed value, set MIN and MAX\n-\t\t     to it so that we set the resulting range to\n-\t\t     VARYING.  */\n-\t\t  min = max = val[i];\n-\t\t  break;\n-\t\t}\n+\t\t  if (!is_gimple_min_invariant (val[i])\n+\t\t      || (TREE_OVERFLOW (val[i])\n+\t\t\t  && !is_overflow_infinity (val[i])))\n+\t\t    {\n+\t\t      /* If we found an overflowed value, set MIN and MAX\n+\t\t\t to it so that we set the resulting range to\n+\t\t\t VARYING.  */\n+\t\t      min = max = val[i];\n+\t\t      break;\n+\t\t    }\n \n-\t      if (compare_values (val[i], min) == -1)\n-\t\tmin = val[i];\n+\t\t  if (compare_values (val[i], min) == -1)\n+\t\t    min = val[i];\n \n-\t      if (compare_values (val[i], max) == 1)\n-\t\tmax = val[i];\n+\t\t  if (compare_values (val[i], max) == 1)\n+\t\t    max = val[i];\n+\t\t}\n \t    }\n \t}\n     }"}]}