{"sha": "669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY5YTZmZGNiNDM2YWU4MWY3NjIxYzM1ZDkwZjdjNDFlZDIxMTdhNw==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2019-03-06T12:56:05Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2019-03-06T12:56:05Z"}, "message": "Rewrite variant, also PR libstdc++/85517\n\n* include/std/variant (__do_visit): New.\n(__variant_cast): Likewise.\n(__variant_cookie): Likewise.\n(__erased_*): Remove.\n(_Variant_storage::_S_vtable): Likewise.\n(_Variant_storage::__M_reset_impl): Adjust to use __do_visit.\n(_Variant_storage::__M_reset): Adjust.\n(__variant_construct): New.\n(_Copy_ctor_base(const _Copy_ctor_base&)): Adjust to use\n__variant_construct.\n(_Move_ctor_base(_Move_ctor_base&&)): Likewise.\n(_Move_ctor_base::__M_destructive_copy): New.\n(_Move_ctor_base::__M_destructive_move): Adjust to use\n__variant_construct.\n(_Copy_assign_base::operator=): Adjust to use __do_visit.\n(_Copy_assign_alias): Adjust to check both copy assignment\nand copy construction for triviality.\n(_Move_assign_base::operator=): Adjust to use __do_visit.\n(_Multi_array): Add support for visitors that accept and return\na __variant_cookie.\n(__gen_vtable_impl::_S_apply_all_alts): Likewise.\n(__gen_vtable_impl::_S_apply_single_alt): Likewise.\n(__gen_vtable_impl::__element_by_index_or_cookie): New. Generate\na __variant_cookie temporary for a variant that is valueless and..\n(__gen_vtable_impl::__visit_invoke): ..adjust here.\n(__gen_vtable::_Array_type): Conditionally make space for\nthe __variant_cookie visitor case.\n(__variant_construct_by_index): New.\n(get_if): Adjust to use std::addressof.\n(relops): Adjust to use __do_visit.\n(variant): Add __variant_cast and __variant_construct_by_index\nas friends.\n(variant::emplace): Use _M_reset() and __variant_construct_by_index\ninstead of self-destruction.\n(variant::swap): Adjust to use __do_visit.\n(visit): Reimplement in terms of __do_visit.\n(__variant_hash_call_base_impl::operator()): Adjust to use __do_visit.\n* testsuite/20_util/variant/compile.cc: Adjust.\n* testsuite/20_util/variant/run.cc: Likewise.\n\nFrom-SVN: r269422", "tree": {"sha": "b25fdd4abd5da8fa208491e8d36b74e2751f0ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b25fdd4abd5da8fa208491e8d36b74e2751f0ea3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99447f700d170f7d15d84e246706c92635f11248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99447f700d170f7d15d84e246706c92635f11248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99447f700d170f7d15d84e246706c92635f11248"}], "stats": {"total": 573, "additions": 374, "deletions": 199}, "files": [{"sha": "7a199f8fc191ae50bbfdcce3c7b6c3ee597ff3b6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "patch": "@@ -1,3 +1,47 @@\n+2019-03-06  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tRewrite variant.\n+\tAlso PR libstdc++/85517\n+\t* include/std/variant (__do_visit): New.\n+\t(__variant_cast): Likewise.\n+\t(__variant_cookie): Likewise.\n+\t(__erased_*): Remove.\n+\t(_Variant_storage::_S_vtable): Likewise.\n+\t(_Variant_storage::__M_reset_impl): Adjust to use __do_visit.\n+\t(_Variant_storage::__M_reset): Adjust.\n+\t(__variant_construct): New.\n+\t(_Copy_ctor_base(const _Copy_ctor_base&)): Adjust to use\n+\t__variant_construct.\n+\t(_Move_ctor_base(_Move_ctor_base&&)): Likewise.\n+\t(_Move_ctor_base::__M_destructive_copy): New.\n+\t(_Move_ctor_base::__M_destructive_move): Adjust to use\n+\t__variant_construct.\n+\t(_Copy_assign_base::operator=): Adjust to use __do_visit.\n+\t(_Copy_assign_alias): Adjust to check both copy assignment\n+\tand copy construction for triviality.\n+\t(_Move_assign_base::operator=): Adjust to use __do_visit.\n+\t(_Multi_array): Add support for visitors that accept and return\n+\ta __variant_cookie.\n+\t(__gen_vtable_impl::_S_apply_all_alts): Likewise.\n+\t(__gen_vtable_impl::_S_apply_single_alt): Likewise.\n+\t(__gen_vtable_impl::__element_by_index_or_cookie): New. Generate\n+\ta __variant_cookie temporary for a variant that is valueless and..\n+\t(__gen_vtable_impl::__visit_invoke): ..adjust here.\n+\t(__gen_vtable::_Array_type): Conditionally make space for\n+\tthe __variant_cookie visitor case.\n+\t(__variant_construct_by_index): New.\n+\t(get_if): Adjust to use std::addressof.\n+\t(relops): Adjust to use __do_visit.\n+\t(variant): Add __variant_cast and __variant_construct_by_index\n+\tas friends.\n+\t(variant::emplace): Use _M_reset() and __variant_construct_by_index\n+\tinstead of self-destruction.\n+\t(variant::swap): Adjust to use __do_visit.\n+\t(visit): Reimplement in terms of __do_visit.\n+\t(__variant_hash_call_base_impl::operator()): Adjust to use __do_visit.\n+\t* testsuite/20_util/variant/compile.cc: Adjust.\n+\t* testsuite/20_util/variant/run.cc: Likewise.\n+\n 2019-03-06  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/c++config.h (_cpp_lib_char8_t): Add L suffix to"}, {"sha": "a5b8fa83217b33018c4019e2984134088919b079", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 292, "deletions": 195, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "patch": "@@ -138,6 +138,24 @@ namespace __variant\n     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&\n     get(const variant<_Types...>&&);\n \n+  template<typename _Visitor, typename... _Variants>\n+    constexpr decltype(auto)\n+    __do_visit(_Visitor&& __visitor, _Variants&&... __variants);\n+\n+  template <typename... _Types, typename _Tp>\n+    decltype(auto) __variant_cast(_Tp&& __rhs)\n+    {\n+      if constexpr (is_lvalue_reference_v<_Tp>)\n+\t{\n+\t  if constexpr (is_const_v<remove_reference_t<_Tp>>)\n+\t    return static_cast<const variant<_Types...>&>(__rhs);\n+\t  else\n+\t    return static_cast<variant<_Types...>&>(__rhs);\n+\t}\n+      else\n+        return static_cast<variant<_Types...>&&>(__rhs);\n+    }\n+\n namespace __detail\n {\n namespace __variant\n@@ -155,6 +173,9 @@ namespace __variant\n       std::integral_constant<size_t, is_same_v<_Tp, _First>\n \t? 0 : __index_of_v<_Tp, _Rest...> + 1> {};\n \n+  // used for raw visitation\n+  struct __variant_cookie {};\n+\n   // _Uninitialized<T> is guaranteed to be a literal type, even if T is not.\n   // We have to do this, because [basic.types]p10.5.3 (n4606) is not implemented\n   // yet. When it's implemented, _Uninitialized<T> can be changed to the alias\n@@ -194,7 +215,10 @@ namespace __variant\n     {\n       template<typename... _Args>\n       constexpr _Uninitialized(in_place_index_t<0>, _Args&&... __args)\n-      { ::new (&_M_storage) _Type(std::forward<_Args>(__args)...); }\n+      {\n+\t::new ((void*)std::addressof(_M_storage))\n+\t  _Type(std::forward<_Args>(__args)...);\n+      }\n \n       const _Type& _M_get() const &\n       { return *_M_storage._M_ptr(); }\n@@ -236,63 +260,6 @@ namespace __variant\n \t\t\t      std::forward<_Variant>(__v)._M_u);\n     }\n \n-  // Various functions as \"vtable\" entries, where those vtables are used by\n-  // polymorphic operations.\n-  template<typename _Lhs, typename _Rhs>\n-    void\n-    __erased_ctor(void* __lhs, void* __rhs)\n-    {\n-      using _Type = remove_reference_t<_Lhs>;\n-      ::new (__lhs) _Type(__variant::__ref_cast<_Rhs>(__rhs));\n-    }\n-\n-  template<typename _Variant, size_t _Np>\n-    void\n-    __erased_dtor(_Variant&& __v)\n-    { std::_Destroy(std::__addressof(__variant::__get<_Np>(__v))); }\n-\n-  template<typename _Lhs, typename _Rhs>\n-    void\n-    __erased_assign(void* __lhs, void* __rhs)\n-    {\n-      __variant::__ref_cast<_Lhs>(__lhs) = __variant::__ref_cast<_Rhs>(__rhs);\n-    }\n-\n-  template<typename _Lhs, typename _Rhs>\n-    void\n-    __erased_swap(void* __lhs, void* __rhs)\n-    {\n-      using std::swap;\n-      swap(__variant::__ref_cast<_Lhs>(__lhs),\n-\t   __variant::__ref_cast<_Rhs>(__rhs));\n-    }\n-\n-#define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \\\n-  template<typename _Variant, size_t _Np> \\\n-    constexpr bool \\\n-    __erased_##__NAME(const _Variant& __lhs, const _Variant& __rhs) \\\n-    { \\\n-      return __variant::__get<_Np>(std::forward<_Variant>(__lhs)) \\\n-\t  __OP __variant::__get<_Np>(std::forward<_Variant>(__rhs)); \\\n-    }\n-\n-  _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)\n-  _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)\n-  _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)\n-  _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)\n-  _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)\n-  _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)\n-\n-#undef _VARIANT_RELATION_FUNCTION_TEMPLATE\n-\n-  template<typename _Tp>\n-    size_t\n-    __erased_hash(void* __t)\n-    {\n-      return std::hash<__remove_cvref_t<_Tp>>{}(\n-\t  __variant::__ref_cast<_Tp>(__t));\n-    }\n-\n   template<typename... _Types>\n     struct _Traits\n     {\n@@ -369,9 +336,6 @@ namespace __variant\n   template<typename... _Types>\n     struct _Variant_storage<false, _Types...>\n     {\n-      template<size_t... __indices>\n-\tstatic constexpr void (*_S_vtable[])(const _Variant_storage&) =\n-\t    { &__erased_dtor<const _Variant_storage&, __indices>... };\n \n       constexpr _Variant_storage() : _M_index(variant_npos) { }\n \n@@ -381,16 +345,21 @@ namespace __variant\n \t_M_index(_Np)\n \t{ }\n \n-      template<size_t... __indices>\n-\tconstexpr void _M_reset_impl(std::index_sequence<__indices...>)\n-\t{\n-\t  if (_M_index != __index_type(variant_npos))\n-\t    _S_vtable<__indices...>[_M_index](*this);\n+      constexpr void _M_reset_impl()\n+      {\n+\t__do_visit([](auto&& __this_mem) mutable\n+\t\t   -> __detail::__variant::__variant_cookie\n+\t  {\n+\t    if constexpr (!is_same_v<remove_reference_t<decltype(__this_mem)>,\n+\t\t\t  __variant_cookie>)\n+\t      std::_Destroy(std::__addressof(__this_mem));\n+\t    return {};\n+\t  }, __variant_cast<_Types...>(*this));\n \t}\n \n       void _M_reset()\n       {\n-\t_M_reset_impl(std::index_sequence_for<_Types...>{});\n+\t_M_reset_impl();\n \t_M_index = variant_npos;\n       }\n \n@@ -453,6 +422,24 @@ namespace __variant\n     using _Variant_storage_alias =\n \t_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;\n \n+  template<typename... _Types, typename _Tp, typename _Up>\n+    void __variant_construct(_Tp&& __lhs, _Up&& __rhs)\n+    {\n+      __lhs._M_index = __rhs._M_index;\n+      __do_visit([](auto&& __this_mem, auto&& __rhs_mem) mutable\n+\t\t -> __detail::__variant::__variant_cookie\n+        {\n+\t  using _Type = remove_reference_t<decltype(__this_mem)>;\n+\t  if constexpr (is_same_v<__remove_cvref_t<decltype(__rhs_mem)>,\n+\t\t\t          remove_cv_t<_Type>>\n+\t\t\t&& !is_same_v<_Type, __variant_cookie>)\n+\t    ::new ((void*)std::addressof(__this_mem))\n+\t      _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));\n+\t  return {};\n+\t}, __variant_cast<_Types...>(__lhs),\n+\t   __variant_cast<_Types...>(std::forward<decltype(__rhs)>(__rhs)));\n+    }\n+\n   // The following are (Copy|Move) (ctor|assign) layers for forwarding\n   // triviality and handling non-trivial SMF behaviors.\n \n@@ -465,13 +452,7 @@ namespace __variant\n       _Copy_ctor_base(const _Copy_ctor_base& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)\n       {\n-\tif (__rhs._M_valid())\n-\t  {\n-\t    static constexpr void (*_S_vtable[])(void*, void*) =\n-\t      { &__erased_ctor<_Types&, const _Types&>... };\n-\t    _S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());\n-\t    this->_M_index = __rhs._M_index;\n-\t  }\n+\t__variant_construct<_Types...>(*this, __rhs);\n       }\n \n       _Copy_ctor_base(_Copy_ctor_base&&) = default;\n@@ -499,21 +480,31 @@ namespace __variant\n       _Move_ctor_base(_Move_ctor_base&& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)\n       {\n-\tif (__rhs._M_valid())\n+\t__variant_construct<_Types...>(*this,\n+\t  std::forward<_Move_ctor_base>(__rhs));\n+      }\n+\n+      void _M_destructive_move(_Move_ctor_base&& __rhs)\n+      {\n+\tthis->_M_reset();\n+\t__try\n \t  {\n-\t    static constexpr void (*_S_vtable[])(void*, void*) =\n-\t      { &__erased_ctor<_Types&, _Types&&>... };\n-\t    _S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());\n-\t    this->_M_index = __rhs._M_index;\n+\t    __variant_construct<_Types...>(*this,\n+\t      std::forward<_Move_ctor_base>(__rhs));\n+\t  }\n+\t__catch (...)\n+\t  {\n+\t    this->_M_index = variant_npos;\n+\t    __throw_exception_again;\n \t  }\n       }\n \n-      void _M_destructive_move(_Move_ctor_base&& __rhs)\n+      void _M_destructive_copy(const _Move_ctor_base& __rhs)\n       {\n-\tthis->~_Move_ctor_base();\n+\tthis->_M_reset();\n \t__try\n \t  {\n-\t    ::new (this) _Move_ctor_base(std::move(__rhs));\n+\t    __variant_construct<_Types...>(*this, __rhs);\n \t  }\n \t__catch (...)\n \t  {\n@@ -535,8 +526,14 @@ namespace __variant\n \n       void _M_destructive_move(_Move_ctor_base&& __rhs)\n       {\n-\tthis->~_Move_ctor_base();\n-\t::new (this) _Move_ctor_base(std::move(__rhs));\n+\tthis->_M_reset();\n+\t__variant_construct<_Types...>(*this,\n+          std::forward<_Move_ctor_base>(__rhs));\n+      }\n+      void _M_destructive_copy(const _Move_ctor_base& __rhs)\n+      {\n+\tthis->_M_reset();\n+\t__variant_construct<_Types...>(*this, __rhs);\n       }\n     };\n \n@@ -554,21 +551,44 @@ namespace __variant\n       operator=(const _Copy_assign_base& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)\n       {\n-\tif (this->_M_index == __rhs._M_index)\n+\t__do_visit([this, &__rhs](auto&& __this_mem, auto&& __rhs_mem) mutable\n+\t\t   -> __detail::__variant::__variant_cookie\n \t  {\n-\t    if (__rhs._M_valid())\n+\t    if constexpr (is_same_v<\n+\t\t\t    remove_reference_t<decltype(__this_mem)>,\n+\t\t\t    remove_reference_t<decltype(__rhs_mem)>>)\n \t      {\n-\t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__erased_assign<_Types&, const _Types&>... };\n-\t\t_S_vtable[__rhs._M_index](this->_M_storage(),\n-\t\t\t\t\t  __rhs._M_storage());\n+\t\tif constexpr (!is_same_v<\n+\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n+\t\t\t        __variant_cookie>)\n+\t\t  __this_mem = __rhs_mem;\n \t      }\n-\t  }\n-\telse\n-\t  {\n-\t    _Copy_assign_base __tmp(__rhs);\n-\t    this->_M_destructive_move(std::move(__tmp));\n-\t  }\n+\t    else\n+\t      {\n+\t\tif constexpr (!is_same_v<\n+\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n+\t\t\t        __variant_cookie>)\n+\t\t  {\n+\t\t    using __rhs_type =\n+\t\t      remove_reference_t<decltype(__rhs_mem)>;\n+\t\t    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>\n+\t\t      || !is_nothrow_move_constructible_v<__rhs_type>)\n+\t\t      {\n+\t\t\tthis->_M_destructive_copy(__rhs);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t_Copy_assign_base __tmp(__rhs);\n+\t\t\tthis->_M_destructive_move(std::move(__tmp));\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    this->_M_reset();\n+\t\t  }\n+\t      }\n+\t  return {};\n+\t}, __variant_cast<_Types...>(*this), __variant_cast<_Types...>(__rhs));\n \t__glibcxx_assert(this->_M_index == __rhs._M_index);\n \treturn *this;\n       }\n@@ -587,7 +607,8 @@ namespace __variant\n \n   template<typename... _Types>\n     using _Copy_assign_alias =\n-\t_Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign,\n+\t_Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign\n+\t\t\t  && _Traits<_Types...>::_S_trivial_copy_ctor,\n \t\t\t  _Types...>;\n \n   template<bool, typename... _Types>\n@@ -600,21 +621,25 @@ namespace __variant\n       operator=(_Move_assign_base&& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)\n       {\n-\tif (this->_M_index == __rhs._M_index)\n+\t__do_visit([this, &__rhs](auto&& __this_mem, auto&& __rhs_mem) mutable\n+\t\t   -> __detail::__variant::__variant_cookie\n \t  {\n-\t    if (__rhs._M_valid())\n+\t    if constexpr (is_same_v<\n+\t\t\t    remove_reference_t<decltype(__this_mem)>,\n+\t\t\t    remove_reference_t<decltype(__rhs_mem)>>)\n \t      {\n-\t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__erased_assign<_Types&, _Types&&>... };\n-\t\t_S_vtable[__rhs._M_index]\n-\t\t  (this->_M_storage(), __rhs._M_storage());\n+\t\tif constexpr (!is_same_v<\n+\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n+\t\t\t        __variant_cookie>)\n+\t\t  __this_mem = std::move(__rhs_mem);\n \t      }\n-\t  }\n-\telse\n-\t  {\n-\t    _Move_assign_base __tmp(std::move(__rhs));\n-\t    this->_M_destructive_move(std::move(__tmp));\n-\t  }\n+\t    else\n+\t      {\n+\t\t_Move_assign_base __tmp(std::move(__rhs));\n+\t\tthis->_M_destructive_move(std::move(__tmp));\n+\t      }\n+\t  return {};\n+\t}, __variant_cast<_Types...>(*this), __variant_cast<_Types...>(__rhs));\n \t__glibcxx_assert(this->_M_index == __rhs._M_index);\n \treturn *this;\n       }\n@@ -733,15 +758,21 @@ namespace __variant\n       _Tp _M_data;\n     };\n \n-  template<typename _Tp, size_t __first, size_t... __rest>\n-    struct _Multi_array<_Tp, __first, __rest...>\n+  template<typename _Ret,\n+\t   typename _Visitor,\n+\t   typename... _Variants,\n+\t   size_t __first, size_t... __rest>\n+    struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>\n     {\n+      static constexpr int __do_cookie =\n+\tis_same_v<_Ret, __variant_cookie> ? 1 : 0;\n+      using _Tp = _Ret(*)(_Visitor, _Variants...);\n       template<typename... _Args>\n \tconstexpr const _Tp&\n \t_M_access(size_t __first_index, _Args... __rest_indices) const\n-\t{ return _M_arr[__first_index]._M_access(__rest_indices...); }\n+        { return _M_arr[__first_index + __do_cookie]._M_access(__rest_indices...); }\n \n-      _Multi_array<_Tp, __rest...> _M_arr[__first];\n+      _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];\n     };\n \n   // Creates a multi-dimensional vtable recursively.\n@@ -801,18 +832,37 @@ namespace __variant\n \t_S_apply_all_alts(_Array_type& __vtable,\n \t\t\t  std::index_sequence<__var_indices...>)\n \t{\n-\t  (_S_apply_single_alt<__var_indices>(\n-\t     __vtable._M_arr[__var_indices]), ...);\n+\t  if constexpr (is_same_v<_Result_type, __variant_cookie>)\n+\t    (_S_apply_single_alt<true, __var_indices>(\n+\t      __vtable._M_arr[__var_indices + 1],\n+\t      &(__vtable._M_arr[0])), ...);\n+\t  else\n+\t    (_S_apply_single_alt<false, __var_indices>(\n+\t      __vtable._M_arr[__var_indices]), ...);\n \t}\n \n-      template<size_t __index, typename _Tp>\n+      template<bool __do_cookie, size_t __index, typename _Tp>\n \tstatic constexpr void\n-\t_S_apply_single_alt(_Tp& __element)\n+\t_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)\n \t{\n \t  using _Alternative = variant_alternative_t<__index, _Next>;\n-\t  __element = __gen_vtable_impl<\n-\t    remove_reference_t<decltype(__element)>, tuple<_Variants...>,\n-\t    std::index_sequence<__indices..., __index>>::_S_apply();\n+\t  if constexpr (__do_cookie)\n+\t    {\n+\t      __element = __gen_vtable_impl<\n+\t\t_Tp,\n+\t\ttuple<_Variants...>,\n+\t\tstd::index_sequence<__indices..., __index>>::_S_apply();\n+\t      *__cookie_element = __gen_vtable_impl<\n+\t\t_Tp,\n+\t\ttuple<_Variants...>,\n+\t\tstd::index_sequence<__indices..., variant_npos>>::_S_apply();\n+\t    }\n+\t  else\n+\t    {\n+\t      __element = __gen_vtable_impl<\n+\t\tremove_reference_t<decltype(__element)>, tuple<_Variants...>,\n+\t\tstd::index_sequence<__indices..., __index>>::_S_apply();\n+\t    }\n \t}\n     };\n \n@@ -825,11 +875,22 @@ namespace __variant\n       using _Array_type =\n \t  _Multi_array<_Result_type (*)(_Visitor&&, _Variants...)>;\n \n+      template<size_t __index, typename _Variant>\n+\tstatic constexpr decltype(auto)\n+\t__element_by_index_or_cookie(_Variant&& __var)\n+        {\n+\t  if constexpr (__index != variant_npos)\n+\t    return __variant::__get<__index>(std::forward<_Variant>(__var));\n+\t  else\n+\t    return __variant_cookie{};\n+\t}\n+\n       static constexpr decltype(auto)\n       __visit_invoke(_Visitor&& __visitor, _Variants... __vars)\n       {\n \treturn std::__invoke(std::forward<_Visitor>(__visitor),\n-\t    __variant::__get<__indices>(std::forward<_Variants>(__vars))...);\n+\t    __element_by_index_or_cookie<__indices>(\n+\t      std::forward<_Variants>(__vars))...);\n       }\n \n       static constexpr auto\n@@ -843,7 +904,9 @@ namespace __variant\n       using _Func_ptr = _Result_type (*)(_Visitor&&, _Variants...);\n       using _Array_type =\n \t  _Multi_array<_Func_ptr,\n-\t\t       variant_size_v<remove_reference_t<_Variants>>...>;\n+\t\t       (variant_size_v<remove_reference_t<_Variants>>\n+\t\t\t+ (is_same_v<_Result_type, __variant_cookie> ? 1 : 0))\n+\t               ...>;\n \n       static constexpr _Array_type\n       _S_apply()\n@@ -869,6 +932,16 @@ namespace __variant\n } // namespace __variant\n } // namespace __detail\n \n+  template<size_t _Np, typename _Variant, typename... _Args>\n+    void __variant_construct_by_index(_Variant& __v, _Args&&... __args)\n+    {\n+      __v._M_index = _Np;\n+      auto&& __storage = __detail::__variant::__get<_Np>(__v);\n+      ::new ((void*)std::addressof(__storage))\n+        remove_reference_t<decltype(__storage)>\n+\t  (std::forward<_Args>(__args)...);\n+    }\n+\n   template<typename _Tp, typename... _Types>\n     constexpr bool\n     holds_alternative(const variant<_Types...>& __v) noexcept\n@@ -925,7 +998,7 @@ namespace __variant\n \t\t    \"The index should be in [0, number of alternatives)\");\n       static_assert(!is_void_v<_Alternative_type>, \"_Tp should not be void\");\n       if (__ptr && __ptr->index() == _Np)\n-\treturn &__detail::__variant::__get<_Np>(*__ptr);\n+\treturn std::addressof(__detail::__variant::__get<_Np>(*__ptr));\n       return nullptr;\n     }\n \n@@ -939,7 +1012,7 @@ namespace __variant\n \t\t    \"The index should be in [0, number of alternatives)\");\n       static_assert(!is_void_v<_Alternative_type>, \"_Tp should not be void\");\n       if (__ptr && __ptr->index() == _Np)\n-\treturn &__detail::__variant::__get<_Np>(*__ptr);\n+\treturn std::addressof(__detail::__variant::__get<_Np>(*__ptr));\n       return nullptr;\n     }\n \n@@ -973,7 +1046,27 @@ namespace __variant\n     constexpr bool operator __OP(const variant<_Types...>& __lhs, \\\n \t\t\t\t const variant<_Types...>& __rhs) \\\n     { \\\n-      return __lhs._M_##__NAME(__rhs, std::index_sequence_for<_Types...>{}); \\\n+      bool __ret = true; \\\n+      __do_visit([&__ret, &__lhs, __rhs] \\\n+\t\t (auto&& __this_mem, auto&& __rhs_mem) mutable\t\\\n+\t\t   -> __detail::__variant::__variant_cookie \\\n+        { \\\n+\t  if constexpr (!is_same_v< \\\n+\t\t\t  remove_reference_t<decltype(__this_mem)>, \\\n+\t\t\t  remove_reference_t<decltype(__rhs_mem)>> \\\n+\t\t\t|| is_same_v<decltype(__this_mem), \\\n+\t\t\t             __detail::__variant::__variant_cookie>) \\\n+\t    __ret = (__lhs.index() + 1) __OP (__rhs.index() + 1); \\\n+\t  else if constexpr (is_same_v< \\\n+\t\t\t       remove_reference_t<decltype(__this_mem)>, \\\n+\t\t\t       remove_reference_t<decltype(__rhs_mem)>> \\\n+                             && !is_same_v< \\\n+\t                          remove_reference_t<decltype(__this_mem)>, \\\n+\t\t\t\t  __detail::__variant::__variant_cookie>) \\\n+\t    __ret = __this_mem __OP __rhs_mem; \\\n+\t  return {}; \\\n+\t}, __lhs, __rhs); \\\n+      return __ret; \\\n     } \\\n \\\n   constexpr bool operator __OP(monostate, monostate) noexcept \\\n@@ -1036,6 +1129,12 @@ namespace __variant\n \tvariant<_Types...>>\n     {\n     private:\n+      template <typename... _UTypes, typename _Tp>\n+\tfriend decltype(auto) __variant_cast(_Tp&&);\n+      template<size_t _Np, typename _Variant, typename... _Args>\n+\tfriend void __variant_construct_by_index(_Variant& __v,\n+\t\t\t\t\t\t _Args&&... __args);\n+\n       static_assert(sizeof...(_Types) > 0,\n \t\t    \"variant must have at least one alternative\");\n       static_assert(!(std::is_reference_v<_Types> || ...),\n@@ -1185,7 +1284,6 @@ namespace __variant\n \t{\n \t  static_assert(_Np < sizeof...(_Types),\n \t\t\t\"The index should be in [0, number of alternatives)\");\n-\n \t  using type = variant_alternative_t<_Np, variant>;\n \t  // If constructing the value can throw but move assigning it can't,\n \t  // construct in a temporary and then move assign from it. This gives\n@@ -1202,11 +1300,11 @@ namespace __variant\n \t      return std::get<_Np>(*this);\n \t    }\n \n-\t  this->~variant();\n+\t  this->_M_reset();\n \t  __try\n \t    {\n-\t      ::new (this) variant(in_place_index<_Np>,\n-\t\t\t\t   std::forward<_Args>(__args)...);\n+\t      __variant_construct_by_index<_Np>(*this,\n+\t        std::forward<_Args>(__args)...);\n \t    }\n \t  __catch (...)\n \t    {\n@@ -1225,7 +1323,6 @@ namespace __variant\n \t{\n \t  static_assert(_Np < sizeof...(_Types),\n \t\t\t\"The index should be in [0, number of alternatives)\");\n-\n \t  using type = variant_alternative_t<_Np, variant>;\n \t  if constexpr (is_trivially_copyable_v<type>\n \t      && !is_nothrow_constructible_v<type, initializer_list<_Up>,\n@@ -1239,11 +1336,11 @@ namespace __variant\n \t      return std::get<_Np>(*this);\n \t    }\n \n-\t  this->~variant();\n+\t  this->_M_reset();\n \t  __try\n \t    {\n-\t      ::new (this) variant(in_place_index<_Np>, __il,\n-\t\t\t\t   std::forward<_Args>(__args)...);\n+\t      __variant_construct_by_index<_Np>(*this, __il,\n+\t\tstd::forward<_Args>(__args)...);\n \t    }\n \t  __catch (...)\n \t    {\n@@ -1270,62 +1367,49 @@ namespace __variant\n       noexcept((__is_nothrow_swappable<_Types>::value && ...)\n \t       && is_nothrow_move_constructible_v<variant>)\n       {\n-\tif (this->index() == __rhs.index())\n+\t__do_visit([this, &__rhs](auto&& __this_mem, auto&& __rhs_mem) mutable\n+\t\t   -> __detail::__variant::__variant_cookie\n \t  {\n-\t    if (this->_M_valid())\n+\t    if constexpr (is_same_v<\n+\t\t\t    remove_reference_t<decltype(__this_mem)>,\n+\t\t\t    remove_reference_t<decltype(__rhs_mem)>>)\n \t      {\n-\t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__detail::__variant::__erased_swap<_Types&, _Types&>... };\n-\t\t_S_vtable[__rhs._M_index](this->_M_storage(),\n-\t\t\t\t\t  __rhs._M_storage());\n+\t\tif constexpr (!is_same_v<\n+\t\t\t        remove_reference_t<decltype(__rhs_mem)>,\n+\t\t\t        __detail::__variant::__variant_cookie>)\n+\t\t  {\n+\t\t    using std::swap;\n+\t\t    swap(__this_mem, __rhs_mem);\n+\t\t  }\n \t      }\n-\t  }\n-\telse if (!this->_M_valid())\n-\t  {\n-\t    this->_M_destructive_move(std::move(__rhs));\n-\t    __rhs._M_reset();\n-\t  }\n-\telse if (!__rhs._M_valid())\n-\t  {\n-\t    __rhs._M_destructive_move(std::move(*this));\n-\t    this->_M_reset();\n-\t  }\n-\telse\n-\t  {\n-\t    auto __tmp = std::move(__rhs);\n-\t    __rhs._M_destructive_move(std::move(*this));\n-\t    this->_M_destructive_move(std::move(__tmp));\n-\t  }\n+\t    else\n+\t      {\n+\t\tif constexpr (is_same_v<\n+\t\t\t        remove_reference_t<decltype(__this_mem)>,\n+\t\t\t        __detail::__variant::__variant_cookie>)\n+\t\t  {\n+\t\t    this->_M_destructive_move(std::move(__rhs));\n+\t\t    __rhs._M_reset();\n+\t\t  }\n+\t\telse if constexpr (is_same_v<\n+\t\t\t             remove_reference_t<decltype(__rhs_mem)>,\n+\t\t\t             __detail::__variant::__variant_cookie>)\n+\t\t  {\n+\t\t    __rhs._M_destructive_move(std::move(*this));\n+\t\t    this->_M_reset();\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    auto __tmp = std::move(__rhs);\n+\t\t    __rhs._M_destructive_move(std::move(*this));\n+\t\t    this->_M_destructive_move(std::move(__tmp));\n+\t\t  }\n+\t      }\n+\t  return {};\n+\t}, *this, __rhs);\n       }\n \n     private:\n-#define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \\\n-      template<size_t... __indices> \\\n-\tstatic constexpr bool \\\n-\t(*_S_erased_##__NAME[])(const variant&, const variant&) = \\\n-\t  { &__detail::__variant::__erased_##__NAME< \\\n-\t\tconst variant&, __indices>... }; \\\n-      template<size_t... __indices> \\\n-\tconstexpr bool \\\n-\t_M_##__NAME(const variant& __rhs, \\\n-\t\t    std::index_sequence<__indices...>) const \\\n-\t{ \\\n-\t  auto __lhs_index = this->index(); \\\n-\t  auto __rhs_index = __rhs.index(); \\\n-\t  if (__lhs_index != __rhs_index || valueless_by_exception()) \\\n-\t    /* Modulo addition. */ \\\n-\t    return __lhs_index + 1 __OP __rhs_index + 1; \\\n-\t  return _S_erased_##__NAME<__indices...>[__lhs_index](*this, __rhs); \\\n-\t}\n-\n-      _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)\n-      _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)\n-      _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)\n-      _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)\n-      _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)\n-      _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)\n-\n-#undef _VARIANT_RELATION_FUNCTION_TEMPLATE\n \n #if defined(__clang__) && __clang_major__ <= 7\n     public:\n@@ -1401,11 +1485,8 @@ namespace __variant\n \n   template<typename _Visitor, typename... _Variants>\n     constexpr decltype(auto)\n-    visit(_Visitor&& __visitor, _Variants&&... __variants)\n+    __do_visit(_Visitor&& __visitor, _Variants&&... __variants)\n     {\n-      if ((__variants.valueless_by_exception() || ...))\n-\t__throw_bad_variant_access(\"Unexpected index\");\n-\n       using _Result_type =\n \tdecltype(std::forward<_Visitor>(__visitor)(\n \t    std::get<0>(std::forward<_Variants>(__variants))...));\n@@ -1418,22 +1499,38 @@ namespace __variant\n \t\t\t   std::forward<_Variants>(__variants)...);\n     }\n \n+  template<typename _Visitor, typename... _Variants>\n+    constexpr decltype(auto)\n+    visit(_Visitor&& __visitor, _Variants&&... __variants)\n+    {\n+      if ((__variants.valueless_by_exception() || ...))\n+\t__throw_bad_variant_access(\"Unexpected index\");\n+\n+      return __do_visit(std::forward<_Visitor>(__visitor),\n+\t\t\tstd::forward<_Variants>(__variants)...);\n+    }\n+\n   template<bool, typename... _Types>\n     struct __variant_hash_call_base_impl\n     {\n       size_t\n       operator()(const variant<_Types...>& __t) const\n       noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> && ...))\n       {\n-\tif (!__t.valueless_by_exception())\n+\tsize_t __ret;\n+\t__do_visit([&__t, &__ret](auto&& __t_mem) mutable\n+\t\t   -> __detail::__variant::__variant_cookie\n \t  {\n-\t    namespace __edv = __detail::__variant;\n-\t    static constexpr size_t (*_S_vtable[])(void*) =\n-\t      { &__edv::__erased_hash<const _Types&>... };\n-\t    return hash<size_t>{}(__t.index())\n-\t      + _S_vtable[__t.index()](__edv::__get_storage(__t));\n-\t  }\n-\treturn hash<size_t>{}(__t.index());\n+\t    using _Type = __remove_cvref_t<decltype(__t_mem)>;\n+\t    if constexpr (!is_same_v<_Type,\n+\t\t\t             __detail::__variant::__variant_cookie>)\n+\t      __ret = std::hash<size_t>{}(__t.index())\n+\t\t      + std::hash<_Type>{}(__t_mem);\n+\t    else\n+\t      __ret = std::hash<size_t>{}(__t.index());\n+\t    return {};\n+\t  }, __t);\n+\treturn __ret;\n       }\n     };\n "}, {"sha": "04fef0be13fdbf5772474edb572c9bd1f70deb62", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "patch": "@@ -488,12 +488,12 @@ void test_triviality()\n   TEST_TEMPLATE(=default, =default,         , =default,         ,  true, false,  true, false)\n   TEST_TEMPLATE(=default, =default,         ,         , =default,  true, false, false,  true)\n   TEST_TEMPLATE(=default, =default,         ,         ,         ,  true, false, false, false)\n-  TEST_TEMPLATE(=default,         , =default, =default, =default, false,  true,  true,  true)\n-  TEST_TEMPLATE(=default,         , =default, =default,         , false,  true,  true, false)\n+  TEST_TEMPLATE(=default,         , =default, =default, =default, false,  true,  false,  true)\n+  TEST_TEMPLATE(=default,         , =default, =default,         , false,  true,  false, false)\n   TEST_TEMPLATE(=default,         , =default,         , =default, false,  true, false,  true)\n   TEST_TEMPLATE(=default,         , =default,         ,         , false,  true, false, false)\n-  TEST_TEMPLATE(=default,         ,         , =default, =default, false, false,  true,  true)\n-  TEST_TEMPLATE(=default,         ,         , =default,         , false, false,  true, false)\n+  TEST_TEMPLATE(=default,         ,         , =default, =default, false, false,  false,  true)\n+  TEST_TEMPLATE(=default,         ,         , =default,         , false, false,  false, false)\n   TEST_TEMPLATE(=default,         ,         ,         , =default, false, false, false,  true)\n   TEST_TEMPLATE(=default,         ,         ,         ,         , false, false, false, false)\n   TEST_TEMPLATE(        , =default, =default, =default, =default, false, false, false, false)"}, {"sha": "7ee9b08c2ce8b40423d19e57ab1a5251d3b393d7", "filename": "libstdc++-v3/testsuite/20_util/variant/run.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/669a6fdcb436ae81f7621c35d90f7c41ed2117a7/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Frun.cc?ref=669a6fdcb436ae81f7621c35d90f7c41ed2117a7", "patch": "@@ -88,6 +88,21 @@ void arbitrary_ctor()\n   VERIFY(get<1>(v) == \"a\");\n }\n \n+struct ThrowingMoveCtorThrowsCopyCtor\n+{\n+  ThrowingMoveCtorThrowsCopyCtor() noexcept = default;\n+  ThrowingMoveCtorThrowsCopyCtor(ThrowingMoveCtorThrowsCopyCtor&&) {}\n+  ThrowingMoveCtorThrowsCopyCtor(ThrowingMoveCtorThrowsCopyCtor const&)\n+  {\n+    throw 0;\n+  }\n+\n+  ThrowingMoveCtorThrowsCopyCtor& operator=(ThrowingMoveCtorThrowsCopyCtor&&) noexcept\n+    = default;\n+  ThrowingMoveCtorThrowsCopyCtor& operator=(ThrowingMoveCtorThrowsCopyCtor const&) noexcept\n+    = default;\n+};\n+\n void copy_assign()\n {\n   variant<monostate, string> v(\"a\");\n@@ -96,6 +111,20 @@ void copy_assign()\n   u = v;\n   VERIFY(holds_alternative<string>(u));\n   VERIFY(get<string>(u) == \"a\");\n+  {\n+    std::variant<int, ThrowingMoveCtorThrowsCopyCtor> v1,\n+      v2 = ThrowingMoveCtorThrowsCopyCtor();\n+    bool should_throw = false;\n+    try\n+      {\n+\tv1 = v2;\n+      }\n+    catch(int)\n+      {\n+\tshould_throw = true;\n+      }\n+    VERIFY(should_throw);\n+  }\n }\n \n void move_assign()\n@@ -183,11 +212,15 @@ void emplace()\n     AlwaysThrow a;\n     try { v.emplace<1>(a); } catch (nullptr_t) { }\n     VERIFY(v.valueless_by_exception());\n+    v.emplace<0>(42);\n+    VERIFY(!v.valueless_by_exception());\n   }\n   {\n     variant<int, AlwaysThrow> v;\n     try { v.emplace<1>(AlwaysThrow{}); } catch (nullptr_t) { }\n     VERIFY(v.valueless_by_exception());\n+    v.emplace<0>(42);\n+    VERIFY(!v.valueless_by_exception());\n   }\n   VERIFY(&v.emplace<0>(1) == &std::get<0>(v));\n   VERIFY(&v.emplace<int>(1) == &std::get<int>(v));\n@@ -258,6 +291,7 @@ void test_relational()\n     VERIFY(v < w);\n     VERIFY(v <= w);\n     VERIFY(!(v == w));\n+    VERIFY(v == v);\n     VERIFY(v != w);\n     VERIFY(w > v);\n     VERIFY(w >= v);"}]}