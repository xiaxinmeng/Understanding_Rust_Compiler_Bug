{"sha": "41700fc33bd80f9bac8565ca78a9a5fe3c896337", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3MDBmYzMzYmQ4MGY5YmFjODU2NWNhNzhhOWE1ZmUzYzg5NjMzNw==", "commit": {"author": {"name": "Hariharan Sandanagobalane", "email": "hariharan@picochip.com", "date": "2010-04-30T09:40:21Z"}, "committer": {"name": "Hariharan Sandanagobalane", "email": "hariharans@gcc.gnu.org", "date": "2010-04-30T09:40:21Z"}, "message": "picochip.c (picochip_legitimize_address): Define.\n\n        * config/picochip/picochip.c (picochip_legitimize_address): Define.\n        Use this function to do machine-specific conversion.\n        (picochip_legitimize_reload_address): Likewise.\n        (picochip_legitimate_address_p): Check valid base register only if\n        strict.\n        (picochip_check_conditional_copy): Check for modw only if opnd is\n        register.\n        * config/picochip/picochip.h (LEGITIMIZE_RELOAD_ADDRESS): Use this\n        to call the function in c.\n        * config/picochip/picochip-protos.h\n        (picochip_legitimize_reload_address): Define.\n        * config/picochip/picochip.md (supported_compare1): Define.\n\nFrom-SVN: r158927", "tree": {"sha": "4d431d1801fd8cfcc9e1bf12e77b84f78e83e81a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d431d1801fd8cfcc9e1bf12e77b84f78e83e81a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41700fc33bd80f9bac8565ca78a9a5fe3c896337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41700fc33bd80f9bac8565ca78a9a5fe3c896337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41700fc33bd80f9bac8565ca78a9a5fe3c896337", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41700fc33bd80f9bac8565ca78a9a5fe3c896337/comments", "author": null, "committer": null, "parents": [{"sha": "8b4765bf42585ab649517308c69d4df7e570636d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b4765bf42585ab649517308c69d4df7e570636d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b4765bf42585ab649517308c69d4df7e570636d"}], "stats": {"total": 200, "additions": 194, "deletions": 6}, "files": [{"sha": "1a428b9417af3e564abfc7468e851ed9fe23e7be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41700fc33bd80f9bac8565ca78a9a5fe3c896337", "patch": "@@ -1,3 +1,18 @@\n+2010-04-30  Hariharan Sandanagobalane  <hariharan@picochip.com>\n+\n+\t* config/picochip/picochip.c (picochip_legitimize_address): Define.\n+\tUse this function to do machine-specific conversion.\n+\t(picochip_legitimize_reload_address): Likewise.\n+\t(picochip_legitimate_address_p): Check valid base register only if\n+\tstrict.\n+\t(picochip_check_conditional_copy): Check for modw only if opnd is\n+\tregister.\n+\t* config/picochip/picochip.h (LEGITIMIZE_RELOAD_ADDRESS): Use this\n+\tto call the function in c.\n+\t* config/picochip/picochip-protos.h\n+\t(picochip_legitimize_reload_address): Define.\n+\t* config/picochip/picochip.md (supported_compare1): Define.\n+\n 2010-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (cgraph_local_info): Remove for_functions_valid."}, {"sha": "875bb1d2a31ea65f7ca7e6a71743a3a4790da1b1", "filename": "gcc/config/picochip/picochip-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip-protos.h?ref=41700fc33bd80f9bac8565ca78a9a5fe3c896337", "patch": "@@ -99,6 +99,10 @@ extern rtx picochip_struct_value_rtx(tree fntype ATTRIBUTE_UNUSED,\n \n #endif /* RTX_CODE inside TREE_CODE */\n \n+extern int picochip_legitimize_reload_address (rtx *x, enum machine_mode mode,\n+                                        int opnum, int type, int ind_levels);\n+\n+\n void picochip_output_ascii (FILE * file, const char *str, int length);\n \n extern int picochip_hard_regno_mode_ok (int regno, enum machine_mode mode);"}, {"sha": "0d6db586b38b364dce916cccce8b99db3fd717f6", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 154, "deletions": 5, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=41700fc33bd80f9bac8565ca78a9a5fe3c896337", "patch": "@@ -96,6 +96,10 @@ bool picochip_rtx_costs (rtx x, int code, int outer_code, int* total, bool speed\n bool picochip_return_in_memory(const_tree type,\n                               const_tree fntype ATTRIBUTE_UNUSED);\n bool picochip_legitimate_address_p (enum machine_mode, rtx, bool);\n+rtx picochip_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+                             enum machine_mode mode);\n+int picochip_legitimize_reload_address (rtx *x, enum machine_mode mode,\n+                                        int opnum, int type, int ind_levels);\n \n rtx picochip_struct_value_rtx(tree fntype ATTRIBUTE_UNUSED, int incoming ATTRIBUTE_UNUSED);\n rtx picochip_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n@@ -279,6 +283,9 @@ static char picochip_get_vliw_alu_id (void);\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P picochip_legitimate_address_p\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS picochip_legitimize_address\n+\n /* Loading and storing QImode values to and from memory\n    usually requires a scratch register. */\n #undef TARGET_SECONDARY_RELOAD\n@@ -1268,9 +1275,13 @@ picochip_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n       {\n \trtx base = XEXP (x, 0);\n \trtx offset = XEXP (x, 1);\n+        if (strict && !REGNO_OK_FOR_BASE_P (REGNO(base)))\n+        {\n+          valid = 0;\n+          break;\n+        }\n \n \tvalid = (REG == GET_CODE (base) &&\n-\t\t REGNO_OK_FOR_BASE_P (REGNO(base)) &&\n \t\t picochip_legitimate_address_register (base, strict) &&\n \t\t CONST_INT == GET_CODE (offset) &&\n \t\t picochip_const_ok_for_base (mode, REGNO (base),\n@@ -1311,6 +1322,144 @@ picochip_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \n }\n \n+/* For all memory operations, picochip allows a uconst4 offset value. It\n+   is hence beneficial to turn an\n+   addr = <reg + long_const>\n+   ld/st addr\n+\n+   into\n+\n+   X = reg + long_const & FFF0\n+   diff = long_const - (long_const & FFF0)\n+   ld/st <X + diff>\n+\n+   X can be reused in subsequent memory operations.\n+   */\n+rtx\n+picochip_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+                             enum machine_mode mode)\n+{\n+  if (!optimize)\n+    return x;\n+\n+  unsigned mask_val;\n+  // Depending on mode, the offsets allowed are either 16/32/64.\n+  switch (mode)\n+    {\n+      case QImode:\n+        mask_val = 0xFFF0;\n+        break;\n+      case HImode:\n+        mask_val = 0xFFE0;\n+        break;\n+      case SImode:\n+        mask_val = 0xFFC0;\n+        break;\n+      default:\n+        return x;\n+    }\n+\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      int offset = INTVAL (XEXP (x, 1));\n+      // Ignore cases with negative offsets.\n+      if (offset < 0)\n+        return x;\n+      int high_val = offset & mask_val;\n+      int low_val = offset - high_val;\n+      if (high_val != 0)\n+        {\n+          rtx temp_reg = force_reg (Pmode, gen_rtx_PLUS (Pmode, XEXP (x, 0), GEN_INT(high_val)));\n+          x = gen_rtx_PLUS (Pmode, temp_reg, GEN_INT(low_val));\n+          return x;\n+        }\n+    }\n+  return x;\n+}\n+\n+/* For all memory operations, picochip allows a uconst4 offset value. It\n+   is hence beneficial to turn an\n+   addr = <reg + long_const>\n+   ld/st addr\n+\n+   into\n+\n+   X = reg + long_const & FFF0\n+   diff = long_const - (long_const & FFF0)\n+   ld/st <X + diff>\n+\n+   X can be reused in subsequent memory operations.\n+   */\n+int\n+picochip_legitimize_reload_address (rtx *x,\n+                                    enum machine_mode mode,\n+                                    int opnum, int type,\n+                                    int ind_levels ATTRIBUTE_UNUSED)\n+{\n+  if (picochip_symbol_offset(*x))\n+    {\n+      *x = gen_rtx_CONST(mode, *x);\n+      return 0;\n+    }\n+  if (!optimize)\n+    return 0;\n+\n+  /* We should recognise addresses that we created.*/\n+  if (GET_CODE (*x) == PLUS\n+      && GET_CODE (XEXP (*x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (*x, 0), 0)) == REG\n+      && GET_CODE (XEXP (XEXP (*x, 0), 1)) == CONST_INT\n+      && GET_CODE (XEXP (*x, 1)) == CONST_INT)\n+    {\n+      push_reload (XEXP (*x, 0), NULL_RTX, &XEXP (*x, 0), NULL,\n+                   BASE_REG_CLASS, GET_MODE (*x), VOIDmode, 0, 0,\n+                   opnum, (enum reload_type)type);\n+      return 1;\n+    }\n+\n+  unsigned mask_val;\n+  // Depending on mode, the offsets allowed are either 16/32/64.\n+  switch (mode)\n+    {\n+      case QImode:\n+        mask_val = 0xFFF0;\n+        break;\n+      case HImode:\n+        mask_val = 0xFFE0;\n+        break;\n+      case SImode:\n+        mask_val = 0xFFC0;\n+        break;\n+      default:\n+        return 0;\n+    }\n+\n+  if (GET_CODE (*x) == PLUS\n+      && GET_CODE (XEXP (*x, 0)) == REG\n+      && GET_CODE (XEXP (*x, 1)) == CONST_INT)\n+    {\n+      int offset = INTVAL (XEXP (*x, 1));\n+      // Ignore cases with negative offsets.\n+      if (offset < 0)\n+        return 0;\n+      int high_val = offset & mask_val;\n+      int low_val = offset - high_val;\n+      if (high_val != 0)\n+        {\n+          rtx temp_reg = gen_rtx_PLUS (Pmode, XEXP (*x, 0), GEN_INT(high_val));\n+          *x = gen_rtx_PLUS (Pmode, temp_reg, GEN_INT(low_val));\n+          push_reload (XEXP (*x, 0), NULL_RTX, &XEXP (*x, 0), NULL,\n+                       BASE_REG_CLASS, GET_MODE (*x), VOIDmode, 0, 0,\n+                       opnum, (enum reload_type)type);\n+          return 1;\n+        }\n+    }\n+\n+  return 0;\n+}\n+\n /* Detect an rtx which matches (plus (symbol_ref) (const_int)). */\n int\n picochip_symbol_offset (rtx operand)\n@@ -4395,11 +4544,11 @@ picochip_check_conditional_copy (rtx * operands)\n      handled using logical operations (e.g., SIreg != 0 when low ||\n      high). Need to find test cases to provoke this though (fixunssfdi\n      in libgcc does, but is complicated). */\n-  if (GET_MODE (branch_op_0) != HImode ||\n-       !(register_operand (branch_op_0, GET_MODE (branch_op_0))))\n+  if (register_operand(branch_op_0, GET_MODE(branch_op_0)) &&\n+      GET_MODE(branch_op_0) != HImode)\n     return 0;\n-  if (GET_MODE (branch_op_1) != HImode ||\n-       !(picochip_comparison_operand (branch_op_1, GET_MODE (branch_op_1))))\n+  if (register_operand(branch_op_1, GET_MODE(branch_op_1)) &&\n+      GET_MODE(branch_op_1) != HImode)\n     return 0;\n \n   return 1;"}, {"sha": "7269fa062ad057a165760f292d92774a2b28fca8", "filename": "gcc/config/picochip/picochip.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.h?ref=41700fc33bd80f9bac8565ca78a9a5fe3c896337", "patch": "@@ -495,7 +495,10 @@ extern const enum reg_class picochip_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    correct code is generated. */\n \n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n-if (picochip_symbol_offset(X)) { X = gen_rtx_CONST(MODE, X); }\n+do {                                                                         \\\n+  if (picochip_legitimize_reload_address(&X,MODE,OPNUM,TYPE,IND_LEVELS))     \\\n+    goto WIN;                                                                \\\n+  } while(0);                                                                \\\n \n /* Nonzero if the constant rtx X is a legitimate general operand.  X\n    satisfies CONSTANT_P.  */"}, {"sha": "62103506123cdfbee7da040b7bb570d77d4e3320", "filename": "gcc/config/picochip/picochip.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41700fc33bd80f9bac8565ca78a9a5fe3c896337/gcc%2Fconfig%2Fpicochip%2Fpicochip.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.md?ref=41700fc33bd80f9bac8565ca78a9a5fe3c896337", "patch": "@@ -590,6 +590,23 @@\n    (set_attr \"length\" \"2,2,4\")\n    ])\n \n+;; This pattern was added to match the previous pattern. When doing if-convert\n+;; the pattern generated using movhicc does not have a eq:CC but only a eq for\n+;; operator. If this pattern were not to be there, Gcc decides not to use\n+;; movhicc at all. Whereas, in Gcc 4.4, it seems to be cleverer.\n+(define_insn \"*supported_compare1\"\n+  [(set (reg:CC CC_REGNUM)\n+        (match_operator 0 \"picochip_supported_comparison_operator\"\n+                        [(match_operand:HI 1 \"register_operand\" \"r,r,r\")\n+                         (match_operand:HI 2 \"picochip_comparison_operand\" \"r,J,i\")]))]\n+  \"\"\n+  \"* return picochip_output_compare(operands);\"\n+  [; Must be picoAlu because it sets the condition flags.\n+   (set_attr \"type\" \"picoAlu,picoAlu,picoAlu\")\n+   (set_attr \"longConstant\" \"false,false,true\")\n+   (set_attr \"length\" \"2,2,4\")\n+   ])\n+\n (define_insn \"*compare\"\n   [(set (reg:CC CC_REGNUM)\n         (match_operator:CC 0 \"comparison_operator\""}]}