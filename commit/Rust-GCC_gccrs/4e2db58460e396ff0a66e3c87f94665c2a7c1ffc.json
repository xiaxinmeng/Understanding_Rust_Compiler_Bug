{"sha": "4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUyZGI1ODQ2MGUzOTZmZjBhNjZlM2M4N2Y5NDY2NWMyYTdjMWZmYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-16T17:54:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-16T17:54:34Z"}, "message": "hard-reg-set.h (regs_invalidated_by_call): Declare.\n\n        * hard-reg-set.h (regs_invalidated_by_call): Declare.\n        * regclass.c (regs_invalidated_by_call): Move from cse.c.\n        (init_reg_sets_1): Move initialization from cse_main.\n        * cse.c (regs_invalidated_by_call): Move to regclass.c.\n        (cse_main): Move its initialization also.\n        * df.c (df_insn_refs_record): Use regs_invalidated_by_call.\n        * flow.c (propagate_one_insn): Likewise.\n        * gcse.c (compute_hash_table): Likewise.\n        (compute_kill_rd, compute_store_table): Likewise.\n        * sched-deps.c (sched_analyze_1): Likewise.\n\nFrom-SVN: r44053", "tree": {"sha": "91f60d01900241bcf2cec0a70c51d3cdca1a9403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91f60d01900241bcf2cec0a70c51d3cdca1a9403"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/comments", "author": null, "committer": null, "parents": [{"sha": "fb124b992c3235992f5fc7f781266d5708d3a215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb124b992c3235992f5fc7f781266d5708d3a215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb124b992c3235992f5fc7f781266d5708d3a215"}], "stats": {"total": 184, "additions": 81, "deletions": 103}, "files": [{"sha": "8fea87e4b8796d321a7da4829aeea3ad372cfa41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -1,3 +1,16 @@\n+2001-07-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* hard-reg-set.h (regs_invalidated_by_call): Declare.\n+\t* regclass.c (regs_invalidated_by_call): Move from cse.c.\n+\t(init_reg_sets_1): Move initialization from cse_main.\n+\t* cse.c (regs_invalidated_by_call): Move to regclass.c.\n+\t(cse_main): Move its initialization also.\n+\t* df.c (df_insn_refs_record): Use regs_invalidated_by_call.\n+\t* flow.c (propagate_one_insn): Likewise.\n+\t* gcse.c (compute_hash_table): Likewise.\n+\t(compute_kill_rd, compute_store_table): Likewise.\n+\t* sched-deps.c (sched_analyze_1): Likewise.\n+\n Mon Jul 16 18:07:07 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* gcse.c (pre_insert_copy_insn): Use gen_move_insn instead of\n@@ -385,12 +398,12 @@ Thu Jul 12 16:48:54 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n 2001-07-11  Timothy Wall  <twall@redhat.com>\n \n-        * config.gcc: Add configuration for AIX5/IA64.\n-        * config/ia64/aix.h: New.  AIX5/IA64-specific configuration.\n-        * config/ia64/crt[in].asm: New.  Generic static ctor/dtor\n+\t* config.gcc: Add configuration for AIX5/IA64.\n+\t* config/ia64/aix.h: New.  AIX5/IA64-specific configuration.\n+\t* config/ia64/crt[in].asm: New.  Generic static ctor/dtor\n \tsupport prefix/suffix code.\n-        * config/ia64/t-aix: New.  Makefile fragment.\n-        * config/ia64/unwind-aix.c: New.  Unwind table entry lookup.\n+\t* config/ia64/t-aix: New.  Makefile fragment.\n+\t* config/ia64/unwind-aix.c: New.  Unwind table entry lookup.\n \n 2001-07-11  Kazu Hirata  <kazu@hxi.com>\n \n@@ -1395,8 +1408,8 @@ Fri Jul  6 11:47:59 2001  Jeffrey A Law  (law@cygnus.com)\n \n 2001-07-05  H.J. Lu  (hjl@gnu.org)\n \n-        * config/mips/mips.c (mips_parse_cpu): New function to parse\n-        -march=*/-mcpu=*.\n+\t* config/mips/mips.c (mips_parse_cpu): New function to parse\n+\t-march=*/-mcpu=*.\n \n 2001-07-05  Jim Wilson  <wilson@redhat.com>\n \n@@ -1482,7 +1495,7 @@ Fri Jul  6 11:47:59 2001  Jeffrey A Law  (law@cygnus.com)\n 2001-07-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cppinit.c (remove_dup_dirs): Inform if a system include\n-        directory is being reordered.\n+\tdirectory is being reordered.\n \t* doc/invoke.texi (Directory Options): GCC warns if you hide a\n \tsystem include.\n \t* doc/cpp.texi (Search Paths): Likewise.\n@@ -1756,8 +1769,8 @@ Mon Jul  2 15:33:31 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-07-02  Steve Ellcey  <sje@cup.hp.com>\n \n-        * config/ia64/t-ia64: Change LIB1ASMFUNCS to use single underscore.\n-        * config/ia64/lib1funcs.asm: Change macro names to match t-ia64.\n+\t* config/ia64/t-ia64: Change LIB1ASMFUNCS to use single underscore.\n+\t* config/ia64/lib1funcs.asm: Change macro names to match t-ia64.\n \n 2001-07-02  Zack Weinberg  <zackw@stanford.edu>\n "}, {"sha": "266f258d7580ffe9eb1674346a5cb0b7b2f760fb", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -346,11 +346,6 @@ static struct cse_reg_info *cached_cse_reg_info;\n \n static HARD_REG_SET hard_regs_in_table;\n \n-/* A HARD_REG_SET containing all the hard registers that are invalidated\n-   by a CALL_INSN.  */\n-\n-static HARD_REG_SET regs_invalidated_by_call;\n-\n /* CUID of insn that starts the basic block currently being cse-processed.  */\n \n static int cse_basic_block_start;\n@@ -7072,37 +7067,6 @@ cse_main (f, nregs, after_loop, file)\n \tINSN_CUID (insn) = i;\n     }\n \n-  /* Initialize which registers are clobbered by calls.  */\n-\n-  CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if ((call_used_regs[i]\n-\t /* Used to check !fixed_regs[i] here, but that isn't safe;\n-\t    fixed regs are still call-clobbered, and sched can get\n-\t    confused if they can \"live across calls\".\n-\n-\t    The frame pointer is always preserved across calls.  The arg\n-\t    pointer is if it is fixed.  The stack pointer usually is, unless\n-\t    RETURN_POPS_ARGS, in which case an explicit CLOBBER\n-\t    will be present.  If we are generating PIC code, the PIC offset\n-\t    table register is preserved across calls.  */\n-\n-\t && i != STACK_POINTER_REGNUM\n-\t && i != FRAME_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t && i != HARD_FRAME_POINTER_REGNUM\n-#endif\n-#if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t && ! (i == ARG_POINTER_REGNUM && fixed_regs[i])\n-#endif\n-#if !defined (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED)\n-\t && ! (i == PIC_OFFSET_TABLE_REGNUM && flag_pic)\n-#endif\n-\t )\n-\t|| global_regs[i])\n-      SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n-\n   ggc_push_context ();\n \n   /* Loop over basic blocks."}, {"sha": "4548a313ceb7f663da5c812ccbbfb305a1de7fa4", "filename": "gcc/df.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -1268,14 +1268,9 @@ df_insn_refs_record (df, bb, insn)\n \n \t  if (df->flags & DF_HARD_REGS)\n \t    {\n-\t      /* Each call clobbers all call-clobbered regs that are not\n-\t\t global or fixed and have not been explicitly defined\n-\t\t in the call pattern.  */\n+\t      /* Kill all registers invalidated by a call.  */\n \t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\tif (call_used_regs[i] \n-\t\t    && ! global_regs[i]\n-\t\t    && ! fixed_regs[i]\n-\t\t    && ! df_insn_regno_def_p (df, bb, insn, i))\n+\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t\t  {\n \t\t    rtx reg_clob = df_reg_clobber_gen (i);\n \t\t    df_defs_record (df, reg_clob, bb, insn);"}, {"sha": "6d25582cebc646f0cac5660fa9de85516337e83b", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -4948,8 +4948,7 @@ propagate_one_insn (pbi, insn)\n \n \t  /* Calls change all call-used and global registers.  */\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (call_used_regs[i] && ! global_regs[i]\n-\t\t&& ! fixed_regs[i])\n+\t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t      {\n \t\t/* We do not want REG_UNUSED notes for these registers.  */\n \t\tmark_set_1 (pbi, CLOBBER, gen_rtx_REG (reg_raw_mode[i], i),"}, {"sha": "9834a6b6aa6405c9a208e05b58bddcc1c9858a90", "filename": "gcc/gcse.c", "status": "modified", "additions": 5, "deletions": 46, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -2548,20 +2548,7 @@ compute_hash_table (set_p)\n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif ((call_used_regs[regno]\n-\t\t     && regno != STACK_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t     && regno != HARD_FRAME_POINTER_REGNUM\n-#endif\n-#if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t     && ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n-#endif\n-#if !defined (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED)\n-\t\t     && ! (regno == PIC_OFFSET_TABLE_REGNUM && flag_pic)\n-#endif\n-\n-\t\t     && regno != FRAME_POINTER_REGNUM)\n-\t\t    || global_regs[regno])\n+\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n \t\t  record_last_reg_set_info (insn, regno);\n \n \t      if (! CONST_CALL_P (insn))\n@@ -3007,23 +2994,8 @@ compute_kill_rd ()\n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\t{\n-\t\t  if ((call_used_regs[regno]\n-\t\t       && regno != STACK_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t       && regno != HARD_FRAME_POINTER_REGNUM\n-#endif\n-#if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t       && ! (regno == ARG_POINTER_REGNUM\n-\t\t\t     && fixed_regs[regno])\n-#endif\n-#if !defined (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED)\n-\t\t       && ! (regno == PIC_OFFSET_TABLE_REGNUM && flag_pic)\n-#endif\n-\t\t       && regno != FRAME_POINTER_REGNUM)\n-\t\t      || global_regs[regno])\n-\t\t    handle_rd_kill_set (insn, regno, BASIC_BLOCK (bb));\n-\t\t}\n+\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n+\t\t  handle_rd_kill_set (insn, regno, BASIC_BLOCK (bb));\n \t    }\n \n \t  if (GET_CODE (pat) == PARALLEL)\n@@ -6553,21 +6525,8 @@ compute_store_table ()\n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    {\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif ((call_used_regs[regno]\n-\t\t     && regno != STACK_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t     && regno != HARD_FRAME_POINTER_REGNUM\n-#endif\n-#if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t     && ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n-#endif\n-#if defined (PIC_OFFSET_TABLE_REGNUM) && !defined (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED)\n-\t\t     && ! (regno == PIC_OFFSET_TABLE_REGNUM && flag_pic)\n-#endif\n-\n-\t\t     && regno != FRAME_POINTER_REGNUM)\n-\t\t    || global_regs[regno])\n-\t\tSET_BIT (reg_set_in_block[bb], regno);\n+\t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n+\t\t  SET_BIT (reg_set_in_block[bb], regno);\n \t    }\n \t  \n \t  pat = PATTERN (insn);"}, {"sha": "c3a2305711f87a2c6cb6efa58a7b6220b95d97ec", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -431,6 +431,15 @@ extern HARD_REG_SET call_fixed_reg_set;\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n+/* Contains 1 for registers that are set or clobbered by calls.  */\n+/* ??? Ideally, this would be just call_used_regs plus global_regs, but\n+   for someone's bright idea to have call_used_regs strictly include\n+   fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n+   that are actually preserved.  We know for sure that those associated\n+   with the local stack frame are safe, but scant others.  */\n+\n+extern HARD_REG_SET regs_invalidated_by_call;\n+\n #ifdef REG_ALLOC_ORDER\n /* Table of register numbers in the order in which to try to use them.  */\n "}, {"sha": "e3eca7f35d1985c119e7c2ed6e98e27fc718a574", "filename": "gcc/regclass.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -116,7 +116,16 @@ int n_non_fixed_regs;\n    and are also considered fixed.  */\n \n char global_regs[FIRST_PSEUDO_REGISTER];\n-  \n+\n+/* Contains 1 for registers that are set or clobbered by calls.  */\n+/* ??? Ideally, this would be just call_used_regs plus global_regs, but\n+   for someone's bright idea to have call_used_regs strictly include\n+   fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n+   that are actually preserved.  We know for sure that those associated\n+   with the local stack frame are safe, but scant others.  */\n+\n+HARD_REG_SET regs_invalidated_by_call;\n+\n /* Table of register numbers in the order in which to try to use them.  */\n #ifdef REG_ALLOC_ORDER\n int reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n@@ -410,6 +419,7 @@ init_reg_sets_1 ()\n   CLEAR_HARD_REG_SET (fixed_reg_set);\n   CLEAR_HARD_REG_SET (call_used_reg_set);\n   CLEAR_HARD_REG_SET (call_fixed_reg_set);\n+  CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n \n   memcpy (call_fixed_regs, fixed_regs, sizeof call_fixed_regs);\n \n@@ -428,7 +438,34 @@ init_reg_sets_1 ()\n \tSET_HARD_REG_BIT (call_fixed_reg_set, i);\n       if (CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (i)))\n \tSET_HARD_REG_BIT (losing_caller_save_reg_set, i);\n+\n+      /* There are a couple of fixed registers that we know are safe to\n+\t exclude from being clobbered by calls:\n+\n+\t The frame pointer is always preserved across calls.  The arg pointer\n+\t is if it is fixed.  The stack pointer usually is, unless\n+\t RETURN_POPS_ARGS, in which case an explicit CLOBBER will be present.\n+\t If we are generating PIC code, the PIC offset table register is\n+\t preserved across calls, though the target can override that.  */\n+\t \n+      if (i == STACK_POINTER_REGNUM || i == FRAME_POINTER_REGNUM)\n+\t;\n+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n+      else if (i == HARD_FRAME_POINTER_REGNUM)\n+\t;\n+#endif\n+#if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n+      else if (i == ARG_POINTER_REGNUM && fixed_regs[i])\n+\t;\n+#endif\n+#ifndef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n+      else if (i == PIC_OFFSET_TABLE_REGNUM && flag_pic)\n+\t;\n+#endif\n+      else if (call_used_regs[i] || global_regs[i])\n+\tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n     }\n+\n   memset (contains_reg_of_mode, 0, sizeof (contains_reg_of_mode));\n   memset (allocatable_regs_of_mode, 0, sizeof (allocatable_regs_of_mode));\n   for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)"}, {"sha": "422b39485d36f8bbe65e70eed9de9850a5983146", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e2db58460e396ff0a66e3c87f94665c2a7c1ffc/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4e2db58460e396ff0a66e3c87f94665c2a7c1ffc", "patch": "@@ -618,7 +618,9 @@ sched_analyze_1 (deps, x, insn)\n \t\tSET_REGNO_REG_SET (reg_pending_clobbers, r);\n \n \t      /* Function calls clobber all call_used regs.  */\n-\t      if (global_regs[r] || (code == SET && call_used_regs[r]))\n+\t      if (global_regs[r]\n+\t\t  || (code == SET\n+\t\t      && TEST_HARD_REG_BIT (regs_invalidated_by_call, r)))\n \t\tfor (u = deps->last_function_call; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \t    }"}]}