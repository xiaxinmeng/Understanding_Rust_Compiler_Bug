{"sha": "bd8d4d191780e0b944d5187129b8210d71c565ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4ZDRkMTkxNzgwZTBiOTQ0ZDUxODcxMjliODIxMGQ3MWM1NjVlYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-02-25T17:37:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-02-25T17:37:37Z"}, "message": "re PR target/30778 (invalid code generation for memset() with -mtune=k8)\n\n\tPR target/30778\n\t* i386.c (counter_mode): New function.\n\t(expand_set_or_movmem_via_loop): Use it.\n\t(expand_movmem_epilogue): Likewise; fix pasto.\n\t(ix86_expand_movmem): Do emit guard even for constant counts.\n\t(ix86_expand_setmem): Likewise.\n\nFrom-SVN: r122313", "tree": {"sha": "702fa38991981e1fd08b6c26850d0a110e9b3917", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/702fa38991981e1fd08b6c26850d0a110e9b3917"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8d4d191780e0b944d5187129b8210d71c565ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8d4d191780e0b944d5187129b8210d71c565ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8d4d191780e0b944d5187129b8210d71c565ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8d4d191780e0b944d5187129b8210d71c565ec/comments", "author": null, "committer": null, "parents": [{"sha": "710c45f6a43652d2199a01ef44ffd2652dff90ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710c45f6a43652d2199a01ef44ffd2652dff90ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710c45f6a43652d2199a01ef44ffd2652dff90ce"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "6aa21b5c158df614bfe3779bf87ff74a09d0db17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd8d4d191780e0b944d5187129b8210d71c565ec", "patch": "@@ -1,3 +1,13 @@\n+2007-02-24  Uros Bizjak  <ubizjak@gmail.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\tPR target/30778\n+\t* i386.c (counter_mode): New function.\n+\t(expand_set_or_movmem_via_loop): Use it.\n+\t(expand_movmem_epilogue): Likewise; fix pasto.\n+\t(ix86_expand_movmem): Do emit guard even for constant counts.\n+\t(ix86_expand_setmem): Likewise.\n+\n 2007-02-25  Nick Clifton  <nickc@redhat.com>\n \n \t* config/frv/frv.h (ASM_OUTPUT_CASE_LABEL): Delete."}, {"sha": "5a4e1d5e4c6c68449e46d75f63058a6511b9177e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bd8d4d191780e0b944d5187129b8210d71c565ec", "patch": "@@ -13314,6 +13314,21 @@ scale_counter (rtx countreg, int scale)\n   return sc;\n }\n \n+/* Return mode for the memcpy/memset loop counter.  Preffer SImode over DImode\n+   for constant loop counts.  */\n+\n+static enum machine_mode\n+counter_mode (rtx count_exp)\n+{\n+  if (GET_MODE (count_exp) != VOIDmode)\n+    return GET_MODE (count_exp);\n+  if (GET_CODE (count_exp) != CONST_INT)\n+    return Pmode;\n+  if (TARGET_64BIT && (INTVAL (count_exp) & ~0xffffffff))\n+    return DImode;\n+  return SImode;\n+}\n+\n /* When SRCPTR is non-NULL, output simple loop to move memory\n    pointer to SRCPTR to DESTPTR via chunks of MODE unrolled UNROLL times,\n    overall size is COUNT specified in bytes.  When SRCPTR is NULL, output the\n@@ -13330,18 +13345,14 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t\t\t       int expected_size)\n {\n   rtx out_label, top_label, iter, tmp;\n-  enum machine_mode iter_mode;\n+  enum machine_mode iter_mode = counter_mode (count);\n   rtx piece_size = GEN_INT (GET_MODE_SIZE (mode) * unroll);\n   rtx piece_size_mask = GEN_INT (~((GET_MODE_SIZE (mode) * unroll) - 1));\n   rtx size;\n   rtx x_addr;\n   rtx y_addr;\n   int i;\n \n-  iter_mode = GET_MODE (count);\n-  if (iter_mode == VOIDmode)\n-    iter_mode = word_mode;\n-\n   top_label = gen_label_rtx ();\n   out_label = gen_label_rtx ();\n   iter = gen_reg_rtx (iter_mode);\n@@ -13555,8 +13566,8 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n \t    emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset);\n \t  else\n \t    {\n-\t      emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset);\n-\t      emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset + 4);\n+\t      emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n+\t      emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset + 4);\n \t    }\n \t  offset += 8;\n \t}\n@@ -13673,8 +13684,8 @@ expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n \t\t\t\t rtx count, int max_size)\n {\n   count =\n-    expand_simple_binop (GET_MODE (count), AND, count, GEN_INT (max_size - 1),\n-\t\t\t count, 1, OPTAB_DIRECT);\n+    expand_simple_binop (counter_mode (count), AND, count,\n+\t\t\t GEN_INT (max_size - 1), count, 1, OPTAB_DIRECT);\n   expand_set_or_movmem_via_loop (destmem, NULL, destptr, NULL,\n \t\t\t\t gen_lowpart (QImode, value), count, QImode,\n \t\t\t\t 1, max_size / 2);\n@@ -14134,20 +14145,20 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   gcc_assert (desired_align >= 1 && align >= 1);\n \n   /* Ensure that alignment prologue won't copy past end of block.  */\n-  if ((size_needed > 1 || (desired_align > 1 && desired_align > align))\n-      && !count)\n+  if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n     {\n       epilogue_size_needed = MAX (size_needed - 1, desired_align - align);\n-\n       /* Epilogue always copies COUNT_EXP & EPILOGUE_SIZE_NEEDED bytes.\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = smallest_pow2_greater_than (epilogue_size_needed);\n \n       label = gen_label_rtx ();\n       emit_cmp_and_jump_insns (count_exp,\n \t\t\t       GEN_INT (epilogue_size_needed),\n-\t\t\t       LTU, 0, GET_MODE (count_exp), 1, label);\n-      if (expected_size == -1 || expected_size < epilogue_size_needed)\n+\t\t\t       LTU, 0, counter_mode (count_exp), 1, label);\n+      if (GET_CODE (count_exp) == CONST_INT)\n+\t;\n+      else if (expected_size == -1 || expected_size < epilogue_size_needed)\n \tpredict_jump (REG_BR_PROB_BASE * 60 / 100);\n       else\n \tpredict_jump (REG_BR_PROB_BASE * 20 / 100);\n@@ -14247,7 +14258,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       if (size_needed < epilogue_size_needed)\n \t{\n \t  tmp =\n-\t    expand_simple_binop (GET_MODE (count_exp), AND, count_exp,\n+\t    expand_simple_binop (counter_mode (count_exp), AND, count_exp,\n \t\t\t\t GEN_INT (size_needed - 1), count_exp, 1,\n \t\t\t\t OPTAB_DIRECT);\n \t  if (tmp != count_exp)\n@@ -14403,7 +14414,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n     return 0;\n   gcc_assert (alg != no_stringop);\n   if (!count)\n-    count_exp = copy_to_mode_reg (GET_MODE (count_exp), count_exp);\n+    count_exp = copy_to_mode_reg (counter_mode (count_exp), count_exp);\n   destreg = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   switch (alg)\n     {\n@@ -14446,11 +14457,9 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n     promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n \t\t\t\t\t\t   desired_align, align);\n   /* Ensure that alignment prologue won't copy past end of block.  */\n-  if ((size_needed > 1 || (desired_align > 1 && desired_align > align))\n-      && !count)\n+  if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n     {\n       epilogue_size_needed = MAX (size_needed - 1, desired_align - align);\n-\n       /* Epilogue always copies COUNT_EXP & EPILOGUE_SIZE_NEEDED bytes.\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = smallest_pow2_greater_than (epilogue_size_needed);\n@@ -14464,8 +14473,10 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       label = gen_label_rtx ();\n       emit_cmp_and_jump_insns (count_exp,\n \t\t\t       GEN_INT (epilogue_size_needed),\n-\t\t\t       LTU, 0, GET_MODE (count_exp), 1, label);\n-      if (expected_size == -1 || expected_size <= epilogue_size_needed)\n+\t\t\t       LTU, 0, counter_mode (count_exp), 1, label);\n+      if (GET_CODE (count_exp) == CONST_INT)\n+\t;\n+      else if (expected_size == -1 || expected_size <= epilogue_size_needed)\n \tpredict_jump (REG_BR_PROB_BASE * 60 / 100);\n       else\n \tpredict_jump (REG_BR_PROB_BASE * 20 / 100);\n@@ -14475,7 +14486,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       rtx hot_label = gen_label_rtx ();\n       jump_around_label = gen_label_rtx ();\n       emit_cmp_and_jump_insns (count_exp, GEN_INT (dynamic_check - 1),\n-\t\t\t       LEU, 0, GET_MODE (count_exp), 1, hot_label);\n+\t\t\t       LEU, 0, counter_mode (count_exp), 1, hot_label);\n       predict_jump (REG_BR_PROB_BASE * 90 / 100);\n       set_storage_via_libcall (dst, count_exp, val_exp, false);\n       emit_jump (jump_around_label);\n@@ -14558,7 +14569,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       if (size_needed < desired_align - align)\n \t{\n \t  tmp =\n-\t    expand_simple_binop (GET_MODE (count_exp), AND, count_exp,\n+\t    expand_simple_binop (counter_mode (count_exp), AND, count_exp,\n \t\t\t\t GEN_INT (size_needed - 1), count_exp, 1,\n \t\t\t\t OPTAB_DIRECT);\n \t  size_needed = desired_align - align + 1;"}, {"sha": "c2e1df80a567c0e243ff41afa973237910491b89", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd8d4d191780e0b944d5187129b8210d71c565ec", "patch": "@@ -1,3 +1,7 @@\n+2007-02-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.c-torture/execute/pr30778.c: New testcase.\n+\n 2007-02-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/30918"}, {"sha": "1b05189f4995ade32efbbe1de4d85f0dd42a5759", "filename": "gcc/testsuite/gcc.c-torture/execute/pr30778.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr30778.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8d4d191780e0b944d5187129b8210d71c565ec/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr30778.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr30778.c?ref=bd8d4d191780e0b944d5187129b8210d71c565ec", "patch": "@@ -0,0 +1,34 @@\n+extern void *memset (void *, int, unsigned long);\n+extern void abort (void);\n+\n+struct reg_stat {\n+  void *last_death;\n+  void *last_set;\n+  void *last_set_value;\n+  int   last_set_label;\n+  char  last_set_sign_bit_copies;\n+  int   last_set_mode : 8;\n+  char  last_set_invalid;\n+  char sign_bit_copies;\n+  long nonzero_bits;\n+};\n+\n+static struct reg_stat *reg_stat;\n+\n+void __attribute__((noinline))\n+init_reg_last (void)\n+{\n+  memset (reg_stat, 0, __builtin_offsetof (struct reg_stat, sign_bit_copies));\n+}\n+\n+int main (void)\n+{\n+  struct reg_stat r;\n+\n+  reg_stat = &r;\n+  r.nonzero_bits = -1;\n+  init_reg_last ();\n+  if (r.nonzero_bits != -1)\n+    abort ();\n+  return 0;\n+}"}]}