{"sha": "849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5YTc2YTVhMjBkYjM4MzBiM2E2MjdhYWUxYjhjN2ViMGYxNjIzZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-06-28T08:27:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-06-28T08:27:18Z"}, "message": "re PR middle-end/66867 (Suboptimal code generation for atomic_compare_exchange)\n\n\tPR middle-end/66867\n\t* builtins.c (expand_ifn_atomic_compare_exchange_into_call,\n\texpand_ifn_atomic_compare_exchange): New functions.\n\t* internal-fn.c (expand_ATOMIC_COMPARE_EXCHANGE): New function.\n\t* tree.h (build_call_expr_internal_loc): Rename to ...\n\t(build_call_expr_internal_loc_array): ... this.  Fix up type of\n\tlast argument.\n\t* internal-fn.def (ATOMIC_COMPARE_EXCHANGE): New internal fn.\n\t* predict.c (expr_expected_value_1): Handle IMAGPART_EXPR of\n\tATOMIC_COMPARE_EXCHANGE result.\n\t* builtins.h (expand_ifn_atomic_compare_exchange): New prototype.\n\t* gimple-fold.h (optimize_atomic_compare_exchange_p,\n\tfold_builtin_atomic_compare_exchange): New prototypes.\n\t* gimple-fold.c (optimize_atomic_compare_exchange_p,\n\tfold_builtin_atomic_compare_exchange): New functions..\n\t* tree-ssa.c (execute_update_addresses_taken): If\n\toptimize_atomic_compare_exchange_p, ignore &var in 2nd argument\n\tof call when finding addressable vars, and if such var becomes\n\tnon-addressable, call fold_builtin_atomic_compare_exchange.\n\nFrom-SVN: r237814", "tree": {"sha": "532f4d56f6e6da5f9c6f2a7cf4ae65a7b9a8342d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/532f4d56f6e6da5f9c6f2a7cf4ae65a7b9a8342d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a826405801ce4e28d534e3f693f236405d886caf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a826405801ce4e28d534e3f693f236405d886caf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a826405801ce4e28d534e3f693f236405d886caf"}], "stats": {"total": 328, "additions": 324, "deletions": 4}, "files": [{"sha": "ad247ce0f20436885b455df40857bb04d75b68ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -1,3 +1,25 @@\n+2016-06-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/66867\n+\t* builtins.c (expand_ifn_atomic_compare_exchange_into_call,\n+\texpand_ifn_atomic_compare_exchange): New functions.\n+\t* internal-fn.c (expand_ATOMIC_COMPARE_EXCHANGE): New function.\n+\t* tree.h (build_call_expr_internal_loc): Rename to ...\n+\t(build_call_expr_internal_loc_array): ... this.  Fix up type of\n+\tlast argument.\n+\t* internal-fn.def (ATOMIC_COMPARE_EXCHANGE): New internal fn.\n+\t* predict.c (expr_expected_value_1): Handle IMAGPART_EXPR of\n+\tATOMIC_COMPARE_EXCHANGE result.\n+\t* builtins.h (expand_ifn_atomic_compare_exchange): New prototype.\n+\t* gimple-fold.h (optimize_atomic_compare_exchange_p,\n+\tfold_builtin_atomic_compare_exchange): New prototypes.\n+\t* gimple-fold.c (optimize_atomic_compare_exchange_p,\n+\tfold_builtin_atomic_compare_exchange): New functions..\n+\t* tree-ssa.c (execute_update_addresses_taken): If\n+\toptimize_atomic_compare_exchange_p, ignore &var in 2nd argument\n+\tof call when finding addressable vars, and if such var becomes\n+\tnon-addressable, call fold_builtin_atomic_compare_exchange.\n+\n 2016-06-27  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/71670"}, {"sha": "1465c60c98fada5b134593dcd41f2952dda966e2", "filename": "gcc/builtins.c", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -5158,6 +5158,123 @@ expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp,\n   return target;\n }\n \n+/* Helper function for expand_ifn_atomic_compare_exchange - expand\n+   internal ATOMIC_COMPARE_EXCHANGE call into __atomic_compare_exchange_N\n+   call.  The weak parameter must be dropped to match the expected parameter\n+   list and the expected argument changed from value to pointer to memory\n+   slot.  */\n+\n+static void\n+expand_ifn_atomic_compare_exchange_into_call (gcall *call, machine_mode mode)\n+{\n+  unsigned int z;\n+  vec<tree, va_gc> *vec;\n+\n+  vec_alloc (vec, 5);\n+  vec->quick_push (gimple_call_arg (call, 0));\n+  tree expected = gimple_call_arg (call, 1);\n+  rtx x = assign_stack_temp_for_type (mode, GET_MODE_SIZE (mode),\n+\t\t\t\t      TREE_TYPE (expected));\n+  rtx expd = expand_expr (expected, x, mode, EXPAND_NORMAL);\n+  if (expd != x)\n+    emit_move_insn (x, expd);\n+  tree v = make_tree (TREE_TYPE (expected), x);\n+  vec->quick_push (build1 (ADDR_EXPR,\n+\t\t\t   build_pointer_type (TREE_TYPE (expected)), v));\n+  vec->quick_push (gimple_call_arg (call, 2));\n+  /* Skip the boolean weak parameter.  */\n+  for (z = 4; z < 6; z++)\n+    vec->quick_push (gimple_call_arg (call, z));\n+  built_in_function fncode\n+    = (built_in_function) ((int) BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1\n+\t\t\t   + exact_log2 (GET_MODE_SIZE (mode)));\n+  tree fndecl = builtin_decl_explicit (fncode);\n+  tree fn = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fndecl)),\n+\t\t    fndecl);\n+  tree exp = build_call_vec (boolean_type_node, fn, vec);\n+  tree lhs = gimple_call_lhs (call);\n+  rtx boolret = expand_call (exp, NULL_RTX, lhs == NULL_TREE);\n+  if (lhs)\n+    {\n+      rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (GET_MODE (boolret) != mode)\n+\tboolret = convert_modes (mode, GET_MODE (boolret), boolret, 1);\n+      x = force_reg (mode, x);\n+      write_complex_part (target, boolret, true);\n+      write_complex_part (target, x, false);\n+    }\n+}\n+\n+/* Expand IFN_ATOMIC_COMPARE_EXCHANGE internal function.  */\n+\n+void\n+expand_ifn_atomic_compare_exchange (gcall *call)\n+{\n+  int size = tree_to_shwi (gimple_call_arg (call, 3)) & 255;\n+  gcc_assert (size == 1 || size == 2 || size == 4 || size == 8 || size == 16);\n+  machine_mode mode = mode_for_size (BITS_PER_UNIT * size, MODE_INT, 0);\n+  rtx expect, desired, mem, oldval, boolret;\n+  enum memmodel success, failure;\n+  tree lhs;\n+  bool is_weak;\n+  source_location loc\n+    = expansion_point_location_if_in_system_header (gimple_location (call));\n+\n+  success = get_memmodel (gimple_call_arg (call, 4));\n+  failure = get_memmodel (gimple_call_arg (call, 5));\n+\n+  if (failure > success)\n+    {\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"failure memory model cannot be stronger than success \"\n+\t\t  \"memory model for %<__atomic_compare_exchange%>\");\n+      success = MEMMODEL_SEQ_CST;\n+    }\n+\n+  if (is_mm_release (failure) || is_mm_acq_rel (failure))\n+    {\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"invalid failure memory model for \"\n+\t\t  \"%<__atomic_compare_exchange%>\");\n+      failure = MEMMODEL_SEQ_CST;\n+      success = MEMMODEL_SEQ_CST;\n+    }\n+\n+  if (!flag_inline_atomics)\n+    {\n+      expand_ifn_atomic_compare_exchange_into_call (call, mode);\n+      return;\n+    }\n+\n+  /* Expand the operands.  */\n+  mem = get_builtin_sync_mem (gimple_call_arg (call, 0), mode);\n+\n+  expect = expand_expr_force_mode (gimple_call_arg (call, 1), mode);\n+  desired = expand_expr_force_mode (gimple_call_arg (call, 2), mode);\n+\n+  is_weak = (tree_to_shwi (gimple_call_arg (call, 3)) & 256) != 0;\n+\n+  boolret = NULL;\n+  oldval = NULL;\n+\n+  if (!expand_atomic_compare_and_swap (&boolret, &oldval, mem, expect, desired,\n+\t\t\t\t       is_weak, success, failure))\n+    {\n+      expand_ifn_atomic_compare_exchange_into_call (call, mode);\n+      return;\n+    }\n+\n+  lhs = gimple_call_lhs (call);\n+  if (lhs)\n+    {\n+      rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+      if (GET_MODE (boolret) != mode)\n+\tboolret = convert_modes (mode, GET_MODE (boolret), boolret, 1);\n+      write_complex_part (target, boolret, true);\n+      write_complex_part (target, oldval, false);\n+    }\n+}\n+\n /* Expand the __atomic_load intrinsic:\n    \tTYPE __atomic_load (TYPE *object, enum memmodel)\n    EXP is the CALL_EXPR."}, {"sha": "8d0acd0bef2f9ab496a2b50eb398e7fd6fe2b313", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -72,6 +72,7 @@ extern tree std_canonical_va_list_type (tree);\n extern void std_expand_builtin_va_start (tree, rtx);\n extern void expand_builtin_trap (void);\n extern void expand_ifn_atomic_bit_test_and (gcall *);\n+extern void expand_ifn_atomic_compare_exchange (gcall *);\n extern rtx expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern rtx expand_builtin_with_bounds (tree, rtx, rtx, machine_mode, int);\n extern enum built_in_function builtin_mathfn_code (const_tree);"}, {"sha": "36c105fc141cb8d48ba7d5679057331214ede91e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -2953,6 +2953,133 @@ fold_internal_goacc_dim (const gimple *call)\n   return result;\n }\n \n+/* Return true if stmt is __atomic_compare_exchange_N call which is suitable\n+   for conversion into ATOMIC_COMPARE_EXCHANGE if the second argument is\n+   &var where var is only addressable because of such calls.  */\n+\n+bool\n+optimize_atomic_compare_exchange_p (gimple *stmt)\n+{\n+  if (gimple_call_num_args (stmt) != 6\n+      || !flag_inline_atomics\n+      || !optimize\n+      || (flag_sanitize & (SANITIZE_THREAD | SANITIZE_ADDRESS)) != 0\n+      || !gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+      || !gimple_vdef (stmt)\n+      || !gimple_vuse (stmt))\n+    return false;\n+\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_2:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8:\n+    case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  tree expected = gimple_call_arg (stmt, 1);\n+  if (TREE_CODE (expected) != ADDR_EXPR\n+      || !SSA_VAR_P (TREE_OPERAND (expected, 0))\n+      || !is_gimple_reg_type (TREE_TYPE (TREE_OPERAND (expected, 0)))\n+      || !auto_var_in_fn_p (TREE_OPERAND (expected, 0), current_function_decl)\n+      || TREE_THIS_VOLATILE (TREE_TYPE (TREE_OPERAND (expected, 0)))\n+      || TREE_CODE (TREE_TYPE (TREE_OPERAND (expected, 0))) == VECTOR_TYPE\n+      || TREE_CODE (TREE_TYPE (TREE_OPERAND (expected, 0))) == COMPLEX_TYPE)\n+    return false;\n+\n+  tree weak = gimple_call_arg (stmt, 3);\n+  if (!integer_zerop (weak) && !integer_onep (weak))\n+    return false;\n+\n+  tree parmt = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  tree itype = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (parmt)));\n+  machine_mode mode = TYPE_MODE (itype);\n+\n+  if (direct_optab_handler (atomic_compare_and_swap_optab, mode)\n+      == CODE_FOR_nothing\n+      && optab_handler (sync_compare_and_swap_optab, mode) == CODE_FOR_nothing)\n+    return false;\n+\n+  if (int_size_in_bytes (TREE_TYPE (TREE_OPERAND (expected, 0)))\n+      != GET_MODE_SIZE (mode))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Fold\n+     r = __atomic_compare_exchange_N (p, &e, d, w, s, f);\n+   into\n+     _Complex uintN_t t = ATOMIC_COMPARE_EXCHANGE (p, e, d, w * 256 + N, s, f);\n+     i = IMAGPART_EXPR <t>;\n+     r = (_Bool) i;\n+     e = REALPART_EXPR <t>;  */\n+\n+void\n+fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  tree parmt = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  tree itype = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (parmt)));\n+  tree ctype = build_complex_type (itype);\n+  tree expected = TREE_OPERAND (gimple_call_arg (stmt, 1), 0);\n+  gimple *g = gimple_build_assign (make_ssa_name (TREE_TYPE (expected)),\n+\t\t\t\t   expected);\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+  gimple_stmt_iterator gsiret = gsi_for_stmt (g);\n+  if (!useless_type_conversion_p (itype, TREE_TYPE (expected)))\n+    {\n+      g = gimple_build_assign (make_ssa_name (itype), VIEW_CONVERT_EXPR,\n+\t\t\t       build1 (VIEW_CONVERT_EXPR, itype,\n+\t\t\t\t       gimple_assign_lhs (g)));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+    }\n+  int flag = (integer_onep (gimple_call_arg (stmt, 3)) ? 256 : 0)\n+\t     + int_size_in_bytes (itype);\n+  g = gimple_build_call_internal (IFN_ATOMIC_COMPARE_EXCHANGE, 6,\n+\t\t\t\t  gimple_call_arg (stmt, 0),\n+\t\t\t\t  gimple_assign_lhs (g),\n+\t\t\t\t  gimple_call_arg (stmt, 2),\n+\t\t\t\t  build_int_cst (integer_type_node, flag),\n+\t\t\t\t  gimple_call_arg (stmt, 4),\n+\t\t\t\t  gimple_call_arg (stmt, 5));\n+  tree lhs = make_ssa_name (ctype);\n+  gimple_call_set_lhs (g, lhs);\n+  gimple_set_vdef (g, gimple_vdef (stmt));\n+  gimple_set_vuse (g, gimple_vuse (stmt));\n+  SSA_NAME_DEF_STMT (gimple_vdef (g)) = g;\n+  if (gimple_call_lhs (stmt))\n+    {\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (make_ssa_name (itype), IMAGPART_EXPR,\n+\t\t\t       build1 (IMAGPART_EXPR, itype, lhs));\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      g = gimple_build_assign (gimple_call_lhs (stmt), NOP_EXPR,\n+\t\t\t       gimple_assign_lhs (g));\n+    }\n+  gsi_replace (gsi, g, true);\n+  g = gimple_build_assign (make_ssa_name (itype), REALPART_EXPR,\n+\t\t\t   build1 (REALPART_EXPR, itype, lhs));\n+  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+  if (!useless_type_conversion_p (TREE_TYPE (expected), itype))\n+    {\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (expected)),\n+\t\t\t       VIEW_CONVERT_EXPR,\n+\t\t\t       build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expected),\n+\t\t\t\t       gimple_assign_lhs (g)));\n+      gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+    }\n+  g = gimple_build_assign (expected, SSA_NAME, gimple_assign_lhs (g));\n+  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n+  *gsi = gsiret;\n+}\n+\n /* Return true if ARG0 CODE ARG1 in infinite signed precision operation\n    doesn't fit into TYPE.  The test for overflow should be regardless of\n    -fwrapv, and even for unsigned types.  */"}, {"sha": "f3147144029db1948be940394f9694c721ad6fe1", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -32,6 +32,8 @@ extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree,\n \t\t\t\t\tenum tree_code, tree, tree);\n extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n+extern bool optimize_atomic_compare_exchange_p (gimple *);\n+extern void fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *);\n extern bool arith_overflowed_p (enum tree_code, const_tree, const_tree,\n \t\t\t\tconst_tree);\n extern tree no_follow_ssa_edges (tree);"}, {"sha": "5dd813f707ae22dc6c92adc87899781c90c27a53", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -2185,6 +2185,14 @@ expand_ATOMIC_BIT_TEST_AND_RESET (internal_fn, gcall *call)\n   expand_ifn_atomic_bit_test_and (call);\n }\n \n+/* Expand atomic bit test and set.  */\n+\n+static void\n+expand_ATOMIC_COMPARE_EXCHANGE (internal_fn, gcall *call)\n+{\n+  expand_ifn_atomic_compare_exchange (call);\n+}\n+\n /* Expand a call to FN using the operands in STMT.  FN has a single\n    output operand and NARGS input operands.  */\n "}, {"sha": "6701cd95afbe70597ccc1b975e8dd0587e70f0a1", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -193,6 +193,7 @@ DEF_INTERNAL_FN (SET_EDOM, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_SET, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_COMPLEMENT, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_RESET, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (ATOMIC_COMPARE_EXCHANGE, ECF_LEAF | ECF_NOTHROW, NULL)\n \n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN"}, {"sha": "66a88ab70bf0801a869b3b7ad7d8ad13bfacb781", "filename": "gcc/predict.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -2134,6 +2134,25 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n       if (TREE_CONSTANT (op0))\n \treturn op0;\n \n+      if (code == IMAGPART_EXPR)\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (op0, 0)) == SSA_NAME)\n+\t    {\n+\t      def = SSA_NAME_DEF_STMT (TREE_OPERAND (op0, 0));\n+\t      if (is_gimple_call (def)\n+\t\t  && gimple_call_internal_p (def)\n+\t\t  && (gimple_call_internal_fn (def)\n+\t\t      == IFN_ATOMIC_COMPARE_EXCHANGE))\n+\t\t{\n+\t\t  /* Assume that any given atomic operation has low contention,\n+\t\t     and thus the compare-and-swap operation succeeds.  */\n+\t\t  if (predictor)\n+\t\t    *predictor = PRED_COMPARE_AND_SWAP;\n+\t\t  return build_one_cst (TREE_TYPE (op0));\n+\t\t}\n+\t    }\n+\t}\n+\n       if (code != SSA_NAME)\n \treturn NULL_TREE;\n "}, {"sha": "fd742f2e8b9b5fae8f25ae092d14a31ac092ae54", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -1414,8 +1414,21 @@ execute_update_addresses_taken (void)\n \t  enum gimple_code code = gimple_code (stmt);\n \t  tree decl;\n \n-\t  /* Note all addresses taken by the stmt.  */\n-\t  gimple_ior_addresses_taken (addresses_taken, stmt);\n+\t  if (code == GIMPLE_CALL\n+\t      && optimize_atomic_compare_exchange_p (stmt))\n+\t    {\n+\t      /* For __atomic_compare_exchange_N if the second argument\n+\t\t is &var, don't mark var addressable;\n+\t\t if it becomes non-addressable, we'll rewrite it into\n+\t\t ATOMIC_COMPARE_EXCHANGE call.  */\n+\t      tree arg = gimple_call_arg (stmt, 1);\n+\t      gimple_call_set_arg (stmt, 1, null_pointer_node);\n+\t      gimple_ior_addresses_taken (addresses_taken, stmt);\n+\t      gimple_call_set_arg (stmt, 1, arg);\n+\t    }\n+\t  else\n+\t    /* Note all addresses taken by the stmt.  */\n+\t    gimple_ior_addresses_taken (addresses_taken, stmt);\n \n \t  /* If we have a call or an assignment, see if the lhs contains\n \t     a local decl that requires not to be a gimple register.  */\n@@ -1657,6 +1670,16 @@ execute_update_addresses_taken (void)\n \t    else if (gimple_code (stmt) == GIMPLE_CALL)\n \t      {\n \t\tunsigned i;\n+\t\tif (optimize_atomic_compare_exchange_p (stmt))\n+\t\t  {\n+\t\t    tree expected = gimple_call_arg (stmt, 1);\n+\t\t    if (bitmap_bit_p (suitable_for_renaming,\n+\t\t\t\t      DECL_UID (TREE_OPERAND (expected, 0))))\n+\t\t      {\n+\t\t\tfold_builtin_atomic_compare_exchange (&gsi);\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t  }\n \t\tfor (i = 0; i < gimple_call_num_args (stmt); ++i)\n \t\t  {\n \t\t    tree *argp = gimple_call_arg_ptr (stmt, i);"}, {"sha": "99ed8ffc554b8ba39658ad5b304a92ab30f2ee76", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849a76a5a20db3830b3a627aae1b8c7eb0f1623d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=849a76a5a20db3830b3a627aae1b8c7eb0f1623d", "patch": "@@ -3985,8 +3985,8 @@ extern tree build_call_expr_loc (location_t, tree, int, ...);\n extern tree build_call_expr (tree, int, ...);\n extern tree build_call_expr_internal_loc (location_t, enum internal_fn,\n \t\t\t\t\t  tree, int, ...);\n-extern tree build_call_expr_internal_loc (location_t, enum internal_fn,\n-\t\t\t\t\t  tree, int, tree *);\n+extern tree build_call_expr_internal_loc_array (location_t, enum internal_fn,\n+\t\t\t\t\t\ttree, int, const tree *);\n extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,\n \t\t\t\t       int, ...);\n extern tree build_string_literal (int, const char *);"}]}