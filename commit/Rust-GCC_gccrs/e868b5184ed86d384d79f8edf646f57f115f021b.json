{"sha": "e868b5184ed86d384d79f8edf646f57f115f021b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2OGI1MTg0ZWQ4NmQzODRkNzlmOGVkZjY0NmY1N2YxMTVmMDIxYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-18T21:59:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-18T21:59:49Z"}, "message": "(SECONDARY_{INPUT,OUTPUT}_RELOAD_CLASS): Need GENERAL_REGS for paradoxical SUBREG and FLOAT_REGS.\n\n(SECONDARY_{INPUT,OUTPUT}_RELOAD_CLASS): Need GENERAL_REGS for\nparadoxical SUBREG and FLOAT_REGS.\n(SECONDARY_NEEDED_MODE): Use actual mode for 4 bytes or wider.\n\nFrom-SVN: r9209", "tree": {"sha": "02ba8b09364e39a85736014813cc9ee1151ecded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02ba8b09364e39a85736014813cc9ee1151ecded"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e868b5184ed86d384d79f8edf646f57f115f021b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e868b5184ed86d384d79f8edf646f57f115f021b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e868b5184ed86d384d79f8edf646f57f115f021b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e868b5184ed86d384d79f8edf646f57f115f021b/comments", "author": null, "committer": null, "parents": [{"sha": "7a5b18b055a2e2bcf43fa8f75612ca1a21af9e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a5b18b055a2e2bcf43fa8f75612ca1a21af9e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a5b18b055a2e2bcf43fa8f75612ca1a21af9e1d"}], "stats": {"total": 12, "additions": 10, "deletions": 2}, "files": [{"sha": "0526d6935ed22d5e90b56ffa53abe89c5bdf422a", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e868b5184ed86d384d79f8edf646f57f115f021b/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e868b5184ed86d384d79f8edf646f57f115f021b/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e868b5184ed86d384d79f8edf646f57f115f021b", "patch": "@@ -545,7 +545,8 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n    QImode and HImode from an aligned address to a general register. \n-   We also cannot load an unaligned address into an FP register.  */\n+   We also cannot load an unaligned address or a paradodixal SUBREG into an\n+   FP register.   */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN)\t\t\t\\\n (((GET_CODE (IN) == MEM \t\t\t\t\t\t\\\n@@ -561,6 +562,9 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n  ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n  : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == MEM\t\t\t\\\n     && GET_CODE (XEXP (IN, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n+ : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == SUBREG\t\t\t\\\n+    && (GET_MODE_SIZE (GET_MODE (IN))\t\t\t\t\t\\\n+\t> GET_MODE_SIZE (GET_MODE (SUBREG_REG (IN))))) ? GENERAL_REGS\t\\\n  : NO_REGS)\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT)\t\t\t\\\n@@ -575,7 +579,10 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n  ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n  : ((CLASS) == FLOAT_REGS && GET_CODE (OUT) == MEM\t\t\t\\\n     && GET_CODE (XEXP (OUT, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n-  : NO_REGS)\n+ : ((CLASS) == FLOAT_REGS && GET_CODE (OUT) == SUBREG\t\t\t\\\n+    && (GET_MODE_SIZE (GET_MODE (OUT))\t\t\t\t\t\\\n+\t> GET_MODE_SIZE (GET_MODE (SUBREG_REG (OUT))))) ? GENERAL_REGS\t\\\n+ : NO_REGS)\n \n /* If we are copying between general and FP registers, we need a memory\n    location.  */\n@@ -589,6 +596,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    area is very tricky! */\n #define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT ? (MODE)\t\t\\\n+   : GET_MODE_SIZE (MODE) >= 4 ? (MODE)\t\t\t\\\n    : mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0))\n \n /* Return the maximum number of consecutive registers"}]}