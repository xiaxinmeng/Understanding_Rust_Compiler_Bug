{"sha": "a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE1NTJmYzNlYzBlYTRhNmIzNDRiZjVhNmM3NzkxNjFhNGMxZGUzOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-30T22:36:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-30T22:36:44Z"}, "message": "libgo: Update to weekly.2012-03-27 aka go1 release.\n\nFrom-SVN: r186029", "tree": {"sha": "3bed00c24e1b50f3d7703c633098fa654a112d46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bed00c24e1b50f3d7703c633098fa654a112d46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/comments", "author": null, "committer": null, "parents": [{"sha": "99002f83667c7c55c035fcae9c802b5608efeb30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99002f83667c7c55c035fcae9c802b5608efeb30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99002f83667c7c55c035fcae9c802b5608efeb30"}], "stats": {"total": 347, "additions": 225, "deletions": 122}, "files": [{"sha": "46a35888aa71fd283976148f27d35375b74da57c", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -1,4 +1,4 @@\n-bce220d03774\n+dc5e410f0b4c\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "77e56a754560a4ded5be2d13b9984969fd2afc1e", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -60,21 +60,23 @@ FindCipherSuite:\n \tfor _, id := range clientHello.cipherSuites {\n \t\tfor _, supported := range config.cipherSuites() {\n \t\t\tif id == supported {\n-\t\t\t\tsuite = nil\n+\t\t\t\tvar candidate *cipherSuite\n+\n \t\t\t\tfor _, s := range cipherSuites {\n \t\t\t\t\tif s.id == id {\n-\t\t\t\t\t\tsuite = s\n+\t\t\t\t\t\tcandidate = s\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif suite == nil {\n+\t\t\t\tif candidate == nil {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\t// Don't select a ciphersuite which we can't\n \t\t\t\t// support for this client.\n-\t\t\t\tif suite.elliptic && !ellipticOk {\n+\t\t\t\tif candidate.elliptic && !ellipticOk {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n+\t\t\t\tsuite = candidate\n \t\t\t\tbreak FindCipherSuite\n \t\t\t}\n \t\t}"}, {"sha": "a931d8fb555e784383eea48cb661c615ac80b3c2", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -130,6 +130,10 @@ Curve:\n \t\t}\n \t}\n \n+\tif curveid == 0 {\n+\t\treturn nil, errors.New(\"tls: no supported elliptic curves offered\")\n+\t}\n+\n \tvar x, y *big.Int\n \tvar err error\n \tka.privateKey, x, y, err = elliptic.GenerateKey(ka.curve, config.rand())"}, {"sha": "3aca40e8e74d0ee98301fb118e9ffe87ee8291c6", "filename": "libgo/go/exp/gotype/gotype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -171,7 +171,7 @@ func processFiles(filenames []string, allFiles bool) {\n \n func processPackage(fset *token.FileSet, files map[string]*ast.File) {\n \t// make a package (resolve all identifiers)\n-\tpkg, err := ast.NewPackage(fset, files, types.GcImporter, types.Universe)\n+\tpkg, err := ast.NewPackage(fset, files, types.GcImport, types.Universe)\n \tif err != nil {\n \t\treport(err)\n \t\treturn"}, {"sha": "34c26c9908cff68c55735009192f9a9a5dd0d0e1", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -184,7 +184,7 @@ func check(t *testing.T, testname string, testfiles []string) {\n \teliminate(t, errors, err)\n \n \t// verify errors returned after resolving identifiers\n-\tpkg, err := ast.NewPackage(fset, files, GcImporter, Universe)\n+\tpkg, err := ast.NewPackage(fset, files, GcImport, Universe)\n \teliminate(t, errors, err)\n \n \t// verify errors returned by the typechecker"}, {"sha": "bca2038804e0c23b7780842db45cd2849156efaf", "filename": "libgo/go/exp/types/exportdata.go", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file implements ExportData.\n+// This file implements FindGcExportData.\n \n package types\n \n@@ -11,15 +11,14 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n \t\"strconv\"\n \t\"strings\"\n )\n \n-func readGopackHeader(buf *bufio.Reader) (name string, size int, err error) {\n+func readGopackHeader(r *bufio.Reader) (name string, size int, err error) {\n \t// See $GOROOT/include/ar.h.\n \thdr := make([]byte, 16+12+6+6+8+10+2)\n-\t_, err = io.ReadFull(buf, hdr)\n+\t_, err = io.ReadFull(r, hdr)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -36,33 +35,14 @@ func readGopackHeader(buf *bufio.Reader) (name string, size int, err error) {\n \treturn\n }\n \n-type dataReader struct {\n-\t*bufio.Reader\n-\tio.Closer\n-}\n-\n-// ExportData returns a readCloser positioned at the beginning of the\n-// export data section of the given object/archive file, or an error.\n-// It is the caller's responsibility to close the readCloser.\n+// FindGcExportData positions the reader r at the beginning of the\n+// export data section of an underlying GC-created object/archive\n+// file by reading from it. The reader must be positioned at the\n+// start of the file before calling this function.\n //\n-func ExportData(filename string) (rc io.ReadCloser, err error) {\n-\tfile, err := os.Open(filename)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\tdefer func() {\n-\t\tif err != nil {\n-\t\t\tfile.Close()\n-\t\t\t// Add file name to error.\n-\t\t\terr = fmt.Errorf(\"reading export data: %s: %v\", filename, err)\n-\t\t}\n-\t}()\n-\n-\tbuf := bufio.NewReader(file)\n-\n+func FindGcExportData(r *bufio.Reader) (err error) {\n \t// Read first line to make sure this is an object file.\n-\tline, err := buf.ReadSlice('\\n')\n+\tline, err := r.ReadSlice('\\n')\n \tif err != nil {\n \t\treturn\n \t}\n@@ -74,7 +54,7 @@ func ExportData(filename string) (rc io.ReadCloser, err error) {\n \n \t\t// First entry should be __.SYMDEF.\n \t\t// Read and discard.\n-\t\tif name, size, err = readGopackHeader(buf); err != nil {\n+\t\tif name, size, err = readGopackHeader(r); err != nil {\n \t\t\treturn\n \t\t}\n \t\tif name != \"__.SYMDEF\" {\n@@ -88,15 +68,14 @@ func ExportData(filename string) (rc io.ReadCloser, err error) {\n \t\t\tif n > block {\n \t\t\t\tn = block\n \t\t\t}\n-\t\t\t_, err = io.ReadFull(buf, tmp[:n])\n-\t\t\tif err != nil {\n+\t\t\tif _, err = io.ReadFull(r, tmp[:n]); err != nil {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tsize -= n\n \t\t}\n \n \t\t// Second entry should be __.PKGDEF.\n-\t\tif name, size, err = readGopackHeader(buf); err != nil {\n+\t\tif name, size, err = readGopackHeader(r); err != nil {\n \t\t\treturn\n \t\t}\n \t\tif name != \"__.PKGDEF\" {\n@@ -106,8 +85,7 @@ func ExportData(filename string) (rc io.ReadCloser, err error) {\n \n \t\t// Read first line of __.PKGDEF data, so that line\n \t\t// is once again the first line of the input.\n-\t\tline, err = buf.ReadSlice('\\n')\n-\t\tif err != nil {\n+\t\tif line, err = r.ReadSlice('\\n'); err != nil {\n \t\t\treturn\n \t\t}\n \t}\n@@ -122,12 +100,10 @@ func ExportData(filename string) (rc io.ReadCloser, err error) {\n \t// Skip over object header to export data.\n \t// Begins after first line with $$.\n \tfor line[0] != '$' {\n-\t\tline, err = buf.ReadSlice('\\n')\n-\t\tif err != nil {\n+\t\tif line, err = r.ReadSlice('\\n'); err != nil {\n \t\t\treturn\n \t\t}\n \t}\n \n-\trc = &dataReader{buf, file}\n \treturn\n }"}, {"sha": "07ab087abf8b3fa096e8e0a30df36b9587456d7a", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 99, "deletions": 58, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -2,12 +2,13 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file implements an ast.Importer for gc generated object files.\n+// This file implements an ast.Importer for gc-generated object files.\n // TODO(gri) Eventually move this into a separate package outside types.\n \n package types\n \n import (\n+\t\"bufio\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n@@ -24,41 +25,40 @@ import (\n \n const trace = false // set to true for debugging\n \n-var (\n-\tpkgExts = [...]string{\".a\", \".5\", \".6\", \".8\"}\n-)\n+var pkgExts = [...]string{\".a\", \".5\", \".6\", \".8\"}\n \n-// findPkg returns the filename and package id for an import path.\n+// FindPkg returns the filename and unique package id for an import\n+// path based on package information provided by build.Import (using\n+// the build.Default build.Context).\n // If no file was found, an empty filename is returned.\n-func findPkg(path string) (filename, id string) {\n+//\n+func FindPkg(path, srcDir string) (filename, id string) {\n \tif len(path) == 0 {\n \t\treturn\n \t}\n \n \tid = path\n \tvar noext string\n-\tswitch path[0] {\n+\tswitch {\n \tdefault:\n \t\t// \"x\" -> \"$GOPATH/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n-\t\tbp, _ := build.Import(path, \"\", build.FindOnly)\n+\t\tbp, _ := build.Import(path, srcDir, build.FindOnly)\n \t\tif bp.PkgObj == \"\" {\n \t\t\treturn\n \t\t}\n \t\tnoext = bp.PkgObj\n \t\tif strings.HasSuffix(noext, \".a\") {\n-\t\t\tnoext = noext[:len(noext)-2]\n+\t\t\tnoext = noext[:len(noext)-len(\".a\")]\n \t\t}\n \n-\tcase '.':\n+\tcase build.IsLocalImport(path):\n \t\t// \"./x\" -> \"/this/directory/x.ext\", \"/this/directory/x\"\n-\t\tcwd, err := os.Getwd()\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tnoext = filepath.Join(cwd, path)\n+\t\tnoext = filepath.Join(srcDir, path)\n \t\tid = noext\n \n-\tcase '/':\n+\tcase filepath.IsAbs(path):\n+\t\t// for completeness only - go/build.Import\n+\t\t// does not support absolute imports\n \t\t// \"/x\" -> \"/x.ext\", \"/x\"\n \t\tnoext = path\n \t}\n@@ -75,6 +75,89 @@ func findPkg(path string) (filename, id string) {\n \treturn\n }\n \n+// GcImportData imports a package by reading the gc-generated export data,\n+// adds the corresponding package object to the imports map indexed by id,\n+// and returns the object.\n+//\n+// The imports map must contains all packages already imported, and no map\n+// entry with id as the key must be present. The data reader position must\n+// be the beginning of the export data section. The filename is only used\n+// in error messages.\n+//\n+func GcImportData(imports map[string]*ast.Object, filename, id string, data *bufio.Reader) (pkg *ast.Object, err error) {\n+\tif trace {\n+\t\tfmt.Printf(\"importing %s (%s)\\n\", id, filename)\n+\t}\n+\n+\tif imports[id] != nil {\n+\t\tpanic(fmt.Sprintf(\"package %s already imported\", id))\n+\t}\n+\n+\t// support for gcParser error handling\n+\tdefer func() {\n+\t\tif r := recover(); r != nil {\n+\t\t\terr = r.(importError) // will re-panic if r is not an importError\n+\t\t}\n+\t}()\n+\n+\tvar p gcParser\n+\tp.init(filename, id, data, imports)\n+\tpkg = p.parseExport()\n+\n+\treturn\n+}\n+\n+// GcImport imports a gc-generated package given its import path, adds the\n+// corresponding package object to the imports map, and returns the object.\n+// Local import paths are interpreted relative to the current working directory.\n+// The imports map must contains all packages already imported.\n+// GcImport satisfies the ast.Importer signature.\n+//\n+func GcImport(imports map[string]*ast.Object, path string) (pkg *ast.Object, err error) {\n+\tif path == \"unsafe\" {\n+\t\treturn Unsafe, nil\n+\t}\n+\n+\tsrcDir, err := os.Getwd()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfilename, id := FindPkg(path, srcDir)\n+\tif filename == \"\" {\n+\t\terr = errors.New(\"can't find import: \" + id)\n+\t\treturn\n+\t}\n+\n+\tif pkg = imports[id]; pkg != nil {\n+\t\treturn // package was imported before\n+\t}\n+\n+\t// open file\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tf.Close()\n+\t\tif err != nil {\n+\t\t\t// Add file name to error.\n+\t\t\terr = fmt.Errorf(\"reading export data: %s: %v\", filename, err)\n+\t\t}\n+\t}()\n+\n+\tbuf := bufio.NewReader(f)\n+\tif err = FindGcExportData(buf); err != nil {\n+\t\treturn\n+\t}\n+\n+\tpkg, err = GcImportData(imports, filename, id, buf)\n+\n+\treturn\n+}\n+\n+// ----------------------------------------------------------------------------\n+// gcParser\n+\n // gcParser parses the exports inside a gc compiler-produced\n // object/archive file and populates its scope with the results.\n type gcParser struct {\n@@ -109,47 +192,6 @@ func (p *gcParser) next() {\n \t}\n }\n \n-// GcImporter implements the ast.Importer signature.\n-func GcImporter(imports map[string]*ast.Object, path string) (pkg *ast.Object, err error) {\n-\tif path == \"unsafe\" {\n-\t\treturn Unsafe, nil\n-\t}\n-\n-\tdefer func() {\n-\t\tif r := recover(); r != nil {\n-\t\t\terr = r.(importError) // will re-panic if r is not an importError\n-\t\t\tif trace {\n-\t\t\t\tpanic(err) // force a stack trace\n-\t\t\t}\n-\t\t}\n-\t}()\n-\n-\tfilename, id := findPkg(path)\n-\tif filename == \"\" {\n-\t\terr = errors.New(\"can't find import: \" + id)\n-\t\treturn\n-\t}\n-\n-\tif pkg = imports[id]; pkg != nil {\n-\t\treturn // package was imported before\n-\t}\n-\n-\tbuf, err := ExportData(filename)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer buf.Close()\n-\n-\tif trace {\n-\t\tfmt.Printf(\"importing %s (%s)\\n\", id, filename)\n-\t}\n-\n-\tvar p gcParser\n-\tp.init(filename, id, buf, imports)\n-\tpkg = p.parseExport()\n-\treturn\n-}\n-\n // Declare inserts a named object of the given kind in scope.\n func (p *gcParser) declare(scope *ast.Scope, kind ast.ObjKind, name string) *ast.Object {\n \t// the object may have been imported before - if it exists\n@@ -707,7 +749,6 @@ func (p *gcParser) parseConstDecl() {\n \t\tp.next()\n \t\ttyp = String.Underlying\n \tdefault:\n-\t\tprintln(p.tok)\n \t\tp.errorf(\"expected literal got %s\", scanner.TokenString(p.tok))\n \t}\n \tif obj.Type == nil {"}, {"sha": "20247b0dc44c9dfceda55e8f9dba308461d65e3e", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -17,31 +17,31 @@ import (\n \t\"time\"\n )\n \n-var gcName, gcPath string // compiler name and path\n+var gcPath string // Go compiler path\n \n func init() {\n \t// determine compiler\n+\tvar gc string\n \tswitch runtime.GOARCH {\n \tcase \"386\":\n-\t\tgcName = \"8g\"\n+\t\tgc = \"8g\"\n \tcase \"amd64\":\n-\t\tgcName = \"6g\"\n+\t\tgc = \"6g\"\n \tcase \"arm\":\n-\t\tgcName = \"5g\"\n+\t\tgc = \"5g\"\n \tdefault:\n-\t\tgcName = \"unknown-GOARCH-compiler\"\n-\t\tgcPath = gcName\n+\t\tgcPath = \"unknown-GOARCH-compiler\"\n \t\treturn\n \t}\n-\tgcPath = filepath.Join(build.ToolDir, gcName)\n+\tgcPath = filepath.Join(build.ToolDir, gc)\n }\n \n func compile(t *testing.T, dirname, filename string) {\n \tcmd := exec.Command(gcPath, filename)\n \tcmd.Dir = dirname\n \tout, err := cmd.CombinedOutput()\n \tif err != nil {\n-\t\tt.Errorf(\"%s %s failed: %s\", gcName, filename, err)\n+\t\tt.Errorf(\"%s %s failed: %s\", gcPath, filename, err)\n \t\treturn\n \t}\n \tt.Logf(\"%s\", string(out))\n@@ -52,7 +52,7 @@ func compile(t *testing.T, dirname, filename string) {\n var imports = make(map[string]*ast.Object)\n \n func testPath(t *testing.T, path string) bool {\n-\t_, err := GcImporter(imports, path)\n+\t_, err := GcImport(imports, path)\n \tif err != nil {\n \t\tt.Errorf(\"testPath(%s): %s\", path, err)\n \t\treturn false"}, {"sha": "d749aef15130d776a84e9ff5fd6bc57cc2575001", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -210,7 +210,6 @@ func (ctxt *Context) SrcDirs() []string {\n // if set, or else the compiled code's GOARCH, GOOS, and GOROOT.\n var Default Context = defaultContext()\n \n-// This list is also known to ../../../cmd/dist/build.c.\n var cgoEnabled = map[string]bool{\n \t\"darwin/386\":    true,\n \t\"darwin/amd64\":  true,\n@@ -388,7 +387,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t\t\t// but check that using it wouldn't find something\n \t\t\t\t// else first.\n \t\t\t\tif ctxt.GOROOT != \"\" {\n-\t\t\t\t\tif dir := ctxt.joinPath(ctxt.GOROOT, \"src\", sub); ctxt.isDir(dir) {\n+\t\t\t\t\tif dir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\", sub); ctxt.isDir(dir) {\n \t\t\t\t\t\tgoto Found\n \t\t\t\t\t}\n \t\t\t\t}"}, {"sha": "03ac60606718ad23982f619a739a2079e1d936d2", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -18,7 +18,7 @@\n // initialization side effects.\n //\n // See \"The Go image package\" for more details:\n-// http://blog.golang.org/2011/09/go-image-package.html\n+// http://golang.org/doc/articles/image_package.html\n package image\n \n import ("}, {"sha": "76c953b9b4e006cfed589e178cb861ee29d73aaf", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -623,6 +623,10 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err e\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t} else if err == syscall.ECONNABORTED {\n+\t\t\t\t// This means that a socket on the listen queue was closed\n+\t\t\t\t// before we Accept()ed it; it's a silly error, so try again.\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t\treturn nil, &OpError{\"accept\", fd.net, fd.laddr, err}\n \t\t}"}, {"sha": "0c95c9cece08ceced8438fe0a7d8781f9f2b8e18", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -58,7 +58,7 @@ const (\n \n func (m FileMode) String() string {\n \tconst str = \"dalTLDpSugct\"\n-\tvar buf [20]byte\n+\tvar buf [32]byte // Mode is uint32.\n \tw := 0\n \tfor i, c := range str {\n \t\tif m&(1<<uint(32-1-i)) != 0 {"}, {"sha": "b8766588cf5937d091b6facc8ebd656442e8a156", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -814,6 +814,7 @@ type VolumeNameTest struct {\n var volumenametests = []VolumeNameTest{\n \t{`c:/foo/bar`, `c:`},\n \t{`c:`, `c:`},\n+\t{`2:`, ``},\n \t{``, ``},\n \t{`\\\\\\host`, ``},\n \t{`\\\\\\host\\`, ``},\n@@ -845,3 +846,26 @@ func TestVolumeName(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestDriveLetterInEvalSymlinks(t *testing.T) {\n+\tif runtime.GOOS != \"windows\" {\n+\t\treturn\n+\t}\n+\twd, _ := os.Getwd()\n+\tif len(wd) < 3 {\n+\t\tt.Errorf(\"Current directory path %q is too short\", wd)\n+\t}\n+\tlp := strings.ToLower(wd)\n+\tup := strings.ToUpper(wd)\n+\tflp, err := filepath.EvalSymlinks(lp)\n+\tif err != nil {\n+\t\tt.Fatalf(\"EvalSymlinks(%q) failed: %q\", lp, err)\n+\t}\n+\tfup, err := filepath.EvalSymlinks(up)\n+\tif err != nil {\n+\t\tt.Fatalf(\"EvalSymlinks(%q) failed: %q\", up, err)\n+\t}\n+\tif flp != fup {\n+\t\tt.Errorf(\"Results of EvalSymlinks do not match: %q and %q\", flp, fup)\n+\t}\n+}"}, {"sha": "3dcd0302195d6bd58ba1c2a08d6b878dfa21d76e", "filename": "libgo/go/path/filepath/path_windows.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -35,9 +35,7 @@ func VolumeName(path string) (v string) {\n \t}\n \t// with drive letter\n \tc := path[0]\n-\tif path[1] == ':' &&\n-\t\t('0' <= c && c <= '9' || 'a' <= c && c <= 'z' ||\n-\t\t\t'A' <= c && c <= 'Z') {\n+\tif path[1] == ':' && ('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z') {\n \t\treturn path[:2]\n \t}\n \t// is it UNC"}, {"sha": "1ee939928e9ed0f4e81121f9c55f23927b661a49", "filename": "libgo/go/path/filepath/symlink_windows.go", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fsymlink_windows.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -8,7 +8,24 @@ import (\n \t\"syscall\"\n )\n \n-func evalSymlinks(path string) (string, error) {\n+func toShort(path string) (string, error) {\n+\tp := syscall.StringToUTF16(path)\n+\tb := p // GetShortPathName says we can reuse buffer\n+\tn, err := syscall.GetShortPathName(&p[0], &b[0], uint32(len(b)))\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif n > uint32(len(b)) {\n+\t\tb = make([]uint16, n)\n+\t\tn, err = syscall.GetShortPathName(&p[0], &b[0], uint32(len(b)))\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\treturn syscall.UTF16ToString(b), nil\n+}\n+\n+func toLong(path string) (string, error) {\n \tp := syscall.StringToUTF16(path)\n \tb := p // GetLongPathName says we can reuse buffer\n \tn, err := syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))\n@@ -23,5 +40,24 @@ func evalSymlinks(path string) (string, error) {\n \t\t}\n \t}\n \tb = b[:n]\n-\treturn Clean(syscall.UTF16ToString(b)), nil\n+\treturn syscall.UTF16ToString(b), nil\n+}\n+\n+func evalSymlinks(path string) (string, error) {\n+\tp, err := toShort(path)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tp, err = toLong(p)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t// syscall.GetLongPathName does not change the case of the drive letter,\n+\t// but the result of EvalSymlinks must be unique, so we have\n+\t// EvalSymlinks(`c:\\a`) == EvalSymlinks(`C:\\a`).\n+\t// Make drive letter upper case.\n+\tif len(p) >= 2 && p[1] == ':' && 'a' <= p[0] && p[0] <= 'z' {\n+\t\tp = string(p[0]+'A'-'a') + p[1:]\n+\t}\n+\treturn Clean(p), nil\n }"}, {"sha": "aa50ab97f6f2d47f49490ed74a24383cbb85e788", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -244,7 +244,7 @@ Functions\n \n During execution functions are found in two function maps: first in the\n template, then in the global function map. By default, no functions are defined\n-in the template but the Funcs methods can be used to add them.\n+in the template but the Funcs method can be used to add them.\n \n Predefined global functions are named as follows.\n "}, {"sha": "9ad9f9659b9d0b70bdd940c4f5728091c857e4ed", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=a1552fc3ec0ea4a6b344bf5a6c779161a4c1de39", "patch": "@@ -448,6 +448,11 @@ runtime_main(void)\n \t// roots.\n \tmstats.enablegc = 1;\n \n+\t// The deadlock detection has false negatives.\n+\t// Let scvg start up, to eliminate the false negative\n+\t// for the trivial program func main() { select{} }.\n+\truntime_gosched();\n+\n \tmain_main();\n \truntime_exit(0);\n \tfor(;;)\n@@ -795,6 +800,20 @@ nextgandunlock(void)\n \t}\n \n \t// Look for deadlock situation.\n+\t// There is a race with the scavenger that causes false negatives:\n+\t// if the scavenger is just starting, then we have\n+\t//\tscvg != nil && grunning == 0 && gwait == 0\n+\t// and we do not detect a deadlock.  It is possible that we should\n+\t// add that case to the if statement here, but it is too close to Go 1\n+\t// to make such a subtle change.  Instead, we work around the\n+\t// false negative in trivial programs by calling runtime.gosched\n+\t// from the main goroutine just before main.main.\n+\t// See runtime_main above.\n+\t//\n+\t// On a related note, it is also possible that the scvg == nil case is\n+\t// wrong and should include gwait, but that does not happen in\n+\t// standard Go programs, which all start the scavenger.\n+\t//\n \tif((scvg == nil && runtime_sched.grunning == 0) ||\n \t   (scvg != nil && runtime_sched.grunning == 1 && runtime_sched.gwait == 0 &&\n \t    (scvg->status == Grunning || scvg->status == Gsyscall))) {"}]}