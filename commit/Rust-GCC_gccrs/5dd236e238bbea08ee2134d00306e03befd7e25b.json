{"sha": "5dd236e238bbea08ee2134d00306e03befd7e25b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRkMjM2ZTIzOGJiZWEwOGVlMjEzNGQwMDMwNmUwM2JlZmQ3ZTI1Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-03-16T18:30:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-03-16T18:30:16Z"}, "message": "re PR c++/4361 (bogus ambiguity taking the address of a member template)\n\ncp:\n\tPR c++/4361\n\t* cp-tree.h (CLASSTYPE_METHOD_VEC): Document where templated\n\tconversion operators go.\n\t(struct lang_decl_flags): Add template_conv_p and unused\n\tbitfields.\n\t(DECL_TEMPLATE_CONV_FN_P): New macro.\n\t* call.c (build_user_type_conversion_1): Don't check second type\n\tconversion of overload set first.\n\t* class.c (add_method): Make sure templated conversion operators\n\tall end up on slot 2.\n\t* lex.c (do_identifier): A conversion operator token might be\n\tsatisfied by a templated conversion operator.\n\t* mangle.c (struct globals) Add internal_mangling_p member.\n\t(write_template_param): Do internal mangling, if needed.\n\t(mangle_conv_op_name_for_type): Request internal mangling.\n\t* pt.c (check_explicit_specialization): Use\n\tCLASSTYPE_FIRST_CONVERSION_SLOT.\n\t(template_parm_this_level_p): New function.\n\t(push_template_decl_real): Determine DECL_TEMPLATE_CONV_FN_P.\n\t* search.c (lookup_fn_fields_1): Template conversions will be on\n\tthe first slot.\n\t* typeck.c (build_component_ref): Preserve the type of an\n\tconversion operator name on the overload type.\n\t(build_x_function_call): Retrieve the conversion operator name.\ntestsuite:\n\t* g++.dg/template/conv1.C: New test.\n\t* g++.dg/template/conv2.C: New test.\n\t* g++.dg/template/conv3.C: New test.\n\t* g++.dg/template/conv4.C: New test.\n\nFrom-SVN: r50889", "tree": {"sha": "fe6bb32d28da75dc1021968451c83d5aba03ffe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6bb32d28da75dc1021968451c83d5aba03ffe7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dd236e238bbea08ee2134d00306e03befd7e25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd236e238bbea08ee2134d00306e03befd7e25b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd236e238bbea08ee2134d00306e03befd7e25b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd236e238bbea08ee2134d00306e03befd7e25b/comments", "author": null, "committer": null, "parents": [{"sha": "28eca9e87b9e4b0f6f30fda48d2b550299b1cc4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28eca9e87b9e4b0f6f30fda48d2b550299b1cc4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28eca9e87b9e4b0f6f30fda48d2b550299b1cc4b"}], "stats": {"total": 434, "additions": 343, "deletions": 91}, "files": [{"sha": "b5d947a2e666f774ac5aa533fe9de057a867aa80", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -1,3 +1,30 @@\n+2002-03-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/4361\n+\t* cp-tree.h (CLASSTYPE_METHOD_VEC): Document where templated\n+\tconversion operators go.\n+\t(struct lang_decl_flags): Add template_conv_p and unused\n+\tbitfields.\n+\t(DECL_TEMPLATE_CONV_FN_P): New macro.\n+\t* call.c (build_user_type_conversion_1): Don't check second type\n+\tconversion of overload set first.\n+\t* class.c (add_method): Make sure templated conversion operators\n+\tall end up on slot 2.\n+\t* lex.c (do_identifier): A conversion operator token might be\n+\tsatisfied by a templated conversion operator.\n+\t* mangle.c (struct globals) Add internal_mangling_p member.\n+\t(write_template_param): Do internal mangling, if needed.\n+\t(mangle_conv_op_name_for_type): Request internal mangling.\n+\t* pt.c (check_explicit_specialization): Use\n+\tCLASSTYPE_FIRST_CONVERSION_SLOT.\n+\t(template_parm_this_level_p): New function.\n+\t(push_template_decl_real): Determine DECL_TEMPLATE_CONV_FN_P.\n+\t* search.c (lookup_fn_fields_1): Template conversions will be on\n+\tthe first slot.\n+\t* typeck.c (build_component_ref): Preserve the type of an\n+\tconversion operator name on the overload type.\n+\t(build_x_function_call): Retrieve the conversion operator name.\n+\n 2002-03-15  Richard Henderson  <rth@redhat.com>\n \n \t* init.c (build_new_1): Use size_binop instead of cp_build_binary_op."}, {"sha": "357c0683e0b93a2b1134054e5ea63a6dc42a17c2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 48, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -2444,65 +2444,53 @@ build_user_type_conversion_1 (totype, expr, flags)\n     {\n       tree fns = TREE_VALUE (convs);\n       int convflags = LOOKUP_NO_CONVERSION;\n-      tree ics;\n \n       /* If we are called to convert to a reference type, we are trying to\n \t find an lvalue binding, so don't even consider temporaries.  If\n \t we don't find an lvalue binding, the caller will try again to\n \t look for a temporary binding.  */\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n+      \n+      for (; fns; fns = OVL_NEXT (fns))\n+\t{\n+\t  tree fn = OVL_CURRENT (fns);\n+\t  struct z_candidate *old_candidates = candidates;\n+\t  \n+\t  /* [over.match.funcs] For conversion functions, the function\n+\t     is considered to be a member of the class of the implicit\n+\t     object argument for the purpose of defining the type of\n+\t     the implicit object parameter.\n \n-      if (TREE_CODE (OVL_CURRENT (fns)) != TEMPLATE_DECL)\n-\tics = implicit_conversion\n-\t  (totype, TREE_TYPE (TREE_TYPE (OVL_CURRENT (fns))), 0, convflags);\n-      else\n-\t/* We can't compute this yet.  */\n-\tics = error_mark_node;\n-\n-      if (TREE_CODE (totype) == REFERENCE_TYPE && ics && ICS_BAD_FLAG (ics))\n-\t/* ignore the near match.  */;\n-      else if (ics)\n-\tfor (; fns; fns = OVL_NEXT (fns))\n-\t  {\n-\t    tree fn = OVL_CURRENT (fns);\n-\t    struct z_candidate *old_candidates = candidates;\n-\n-\t    /* [over.match.funcs] For conversion functions, the function is\n-\t       considered to be a member of the class of the implicit object\n-\t       argument for the purpose of defining the type of the implicit\n-\t       object parameter.\n+\t     So we pass fromtype as CTYPE to add_*_candidate.  */\n \n-\t       So we pass fromtype as CTYPE to add_*_candidate.  */\n+\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t    {\n+\t      templates = tree_cons (NULL_TREE, fn, templates);\n+\t      candidates = \n+\t\tadd_template_candidate (candidates, fn, fromtype, NULL_TREE,\n+\t\t\t\t\targs, totype, flags,\n+\t\t\t\t\tDEDUCE_CONV);\n+\t    } \n+\t  else \n+\t    candidates = add_function_candidate (candidates, fn, fromtype,\n+\t\t\t\t\t\t args, flags); \n \n-\t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t      {\n-\t\ttemplates = tree_cons (NULL_TREE, fn, templates);\n-\t\tcandidates = \n-\t\t  add_template_candidate (candidates, fn, fromtype, NULL_TREE,\n-\t\t\t\t\t  args, totype, flags,\n-\t\t\t\t\t  DEDUCE_CONV);\n-\t      } \n-\t    else \n-\t      candidates = add_function_candidate (candidates, fn, fromtype,\n-\t\t\t\t\t\t   args, flags); \n+\t  if (candidates != old_candidates)\n+\t    {\n+\t      tree ics = implicit_conversion\n+\t\t(totype, TREE_TYPE (TREE_TYPE (candidates->fn)),\n+\t\t 0, convflags);\n \n-\t    if (candidates != old_candidates)\n-\t      {\n-\t\tif (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t\t  ics = implicit_conversion\n-\t\t    (totype, TREE_TYPE (TREE_TYPE (candidates->fn)),\n-\t\t     0, convflags);\n-\n-\t\tcandidates->second_conv = ics;\n-\t\tcandidates->basetype_path = TYPE_BINFO (fromtype);\n-\n-\t\tif (ics == NULL_TREE)\n-\t\t  candidates->viable = 0;\n-\t\telse if (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n-\t\t  candidates->viable = -1;\n-\t      }\n-\t  }\n+\t      candidates->second_conv = ics;\n+\t      candidates->basetype_path = TYPE_BINFO (fromtype);\n+\t      \n+\t      if (ics == NULL_TREE)\n+\t\tcandidates->viable = 0;\n+\t      else if (candidates->viable == 1 && ICS_BAD_FLAG (ics))\n+\t\tcandidates->viable = -1;\n+\t    }\n+\t}\n     }\n \n   if (! any_viable (candidates))"}, {"sha": "ae8b34e159254eeb40e5ba1d429e6f84ee87ccd3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -856,6 +856,8 @@ add_method (type, method, error_p)\n   int len;\n   int slot;\n   tree method_vec;\n+  int template_conv_p = (TREE_CODE (method) == TEMPLATE_DECL\n+\t\t\t && DECL_TEMPLATE_CONV_FN_P (method));\n \n   if (!CLASSTYPE_METHOD_VEC (type))\n     /* Make a new method vector.  We start with 8 entries.  We must\n@@ -880,14 +882,36 @@ add_method (type, method, error_p)\n     slot = CLASSTYPE_DESTRUCTOR_SLOT;\n   else\n     {\n+      int have_template_convs_p = 0;\n+      \n       /* See if we already have an entry with this name.  */\n       for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n-\tif (!TREE_VEC_ELT (method_vec, slot)\n-\t    || (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, \n-\t\t\t\t\t\t      slot))) \n-\t\t== DECL_NAME (method)))\n-\t  break;\n-\t\t\n+\t{\n+\t  tree m = TREE_VEC_ELT (method_vec, slot);\n+\n+\t  if (!m)\n+\t    break;\n+\t  m = OVL_CURRENT (m);\n+\t  \n+\t  if (template_conv_p)\n+\t    {\n+\t      have_template_convs_p = (TREE_CODE (m) == TEMPLATE_DECL\n+\t\t\t\t       && DECL_TEMPLATE_CONV_FN_P (m));\n+\t      \n+\t      /* If we need to move things up, see if there's\n+\t\t space. */\n+\t      if (!have_template_convs_p)\n+\t\t{\n+\t\t  slot = len - 1;\n+\t\t  if (TREE_VEC_ELT (method_vec, slot))\n+\t\t    slot++;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  if (DECL_NAME (m) == DECL_NAME (method))\n+\t    break;\n+\t}\n+      \n       if (slot == len)\n \t{\n \t  /* We need a bigger method vector.  */\n@@ -920,22 +944,27 @@ add_method (type, method, error_p)\n \t     slide some of the vector elements up.  In theory, this\n \t     makes this algorithm O(N^2) but we don't expect many\n \t     conversion operators.  */\n-\t  for (slot = 2; slot < len; ++slot)\n-\t    {\n-\t      tree fn = TREE_VEC_ELT (method_vec, slot);\n+\t  if (template_conv_p)\n+\t    slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t  else\n+\t    for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n+\t      {\n+\t\ttree fn = TREE_VEC_ELT (method_vec, slot);\n   \n-\t      if (!fn)\n-\t\t/* There are no more entries in the vector, so we\n-\t\t   can insert the new conversion operator here.  */\n-\t\tbreak;\n+\t\tif (!fn)\n+\t\t  /* There are no more entries in the vector, so we\n+\t\t     can insert the new conversion operator here.  */\n+\t\t  break;\n   \t\t  \n-\t      if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n-\t\t/* We can insert the new function right at the\n-\t\t   SLOTth position.  */\n-\t\tbreak;\n-\t    }\n-  \n-\t  if (!TREE_VEC_ELT (method_vec, slot))\n+\t\tif (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+\t\t  /* We can insert the new function right at the\n+\t\t     SLOTth position.  */\n+\t\t  break;\n+\t      }\n+\n+\t  if (template_conv_p && have_template_convs_p)\n+\t    /*OK*/;\n+\t  else if (!TREE_VEC_ELT (method_vec, slot))\n \t    /* There is nothing in the Ith slot, so we can avoid\n \t       moving anything.  */\n \t\t; \n@@ -1036,7 +1065,7 @@ add_method (type, method, error_p)\n   TREE_VEC_ELT (method_vec, slot) \n     = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n \n-      /* Add the new binding.  */ \n+  /* Add the new binding.  */ \n   if (!DECL_CONSTRUCTOR_P (method)\n       && !DECL_DESTRUCTOR_P (method))\n     push_class_level_binding (DECL_NAME (method),"}, {"sha": "fac6a9d3ccbc2cf21f2e932dce4fece481e8f278", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -1358,8 +1358,14 @@ struct lang_type\n    either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  All\n    functions with the same name end up in the same slot.  The first\n    two elements are for constructors, and destructors, respectively.\n-   Any conversion operators are next, followed by ordinary member\n-   functions.  There may be empty entries at the end of the vector.  */\n+   All template conversion operators to innermost template dependent\n+   types are overloaded on the next slot, if they exist.  Note, the\n+   names for these functions will not all be the same.  The\n+   non-template conversion operators & templated conversions to\n+   non-innermost template types are next, followed by ordinary member\n+   functions.  There may be empty entries at the end of the vector.\n+   The conversion operators are unsorted. The ordinary member\n+   functions are sorted, once the class is complete.  */\n #define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC (NODE)->methods)\n \n /* The slot in the CLASSTYPE_METHOD_VEC where constructors go.  */\n@@ -1761,7 +1767,9 @@ struct lang_decl_flags\n   unsigned global_dtor_p : 1;\n   unsigned assignment_operator_p : 1;\n   unsigned anticipated_p : 1;\n-  /* Four unused bits.  */\n+  unsigned template_conv_p : 1;\n+  \n+  unsigned unused : 3; /* Three unused bits.  */\n \n   union {\n     /* In a FUNCTION_DECL, VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this\n@@ -1949,6 +1957,12 @@ struct lang_decl\n #define DECL_CONV_FN_P(NODE) \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)))\n \n+/* Non-zero if NODE, which is a TEMPLATE_DECL, is a template\n+   conversion operator to a type dependent on the innermost template\n+   args.  */\n+#define DECL_TEMPLATE_CONV_FN_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.template_conv_p)\n+\n /* Set the overloaded operator code for NODE to CODE.  */\n #define SET_OVERLOADED_OPERATOR_CODE(NODE, CODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->u2.operator_code = (CODE))"}, {"sha": "7290a360db6b09f77cf48ff211cdaf5a3cd81f61", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -1199,6 +1199,9 @@ do_identifier (token, parsing, args)\n     {\n       if (current_template_parms)\n \treturn build_min_nt (LOOKUP_EXPR, token);\n+      else if (IDENTIFIER_TYPENAME_P (token))\n+\t/* A templated conversion operator might exist.  */\n+\treturn token;\n       else if (IDENTIFIER_OPNAME_P (token))\n \t{\n \t  if (token != ansi_opname (ERROR_MARK))"}, {"sha": "7e82b44cd613808b8040eeccdf6b46d1946d82ff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -132,6 +132,7 @@ static int unregister_specialization PARAMS ((tree, tree));\n static tree reduce_template_parm_level PARAMS ((tree, tree, int));\n static tree build_template_decl PARAMS ((tree, tree));\n static int mark_template_parm PARAMS ((tree, void *));\n+static int template_parm_this_level_p PARAMS ((tree, void *));\n static tree tsubst_friend_function PARAMS ((tree, tree));\n static tree tsubst_friend_class PARAMS ((tree, tree));\n static tree get_bindings_real PARAMS ((tree, tree, tree, int, int, int));\n@@ -1579,7 +1580,8 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t      methods = CLASSTYPE_METHOD_VEC (ctype);\n \t      if (methods)\n-\t\tfor (idx = 2; idx < TREE_VEC_LENGTH (methods); ++idx) \n+\t\tfor (idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t\t     idx < TREE_VEC_LENGTH (methods); ++idx) \n \t\t  {\n \t\t    tree ovl = TREE_VEC_ELT (methods, idx);\n \n@@ -2496,6 +2498,26 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n     }\n }\n \n+/* Worker for push_template_decl_real, called via\n+   for_each_template_parm.  DATA is really an int, indicating the\n+   level of the parameters we are interested in.  If T is a template\n+   parameter of that level, return non-zero.  */\n+\n+static int\n+template_parm_this_level_p (t, data)\n+     tree t;\n+     void *data;\n+{\n+  int this_level = (int)data;\n+  int level;\n+\n+  if (TREE_CODE (t) == TEMPLATE_PARM_INDEX)\n+    level = TEMPLATE_PARM_LEVEL (t);\n+  else\n+    level = TEMPLATE_TYPE_LEVEL (t);\n+  return level == this_level;\n+}\n+\n /* Creates a TEMPLATE_DECL for the indicated DECL using the template\n    parameters given by current_template_args, or reuses a\n    previously existing one, if appropriate.  Returns the DECL, or an\n@@ -2718,7 +2740,20 @@ push_template_decl_real (decl, is_friend)\n     tmpl = pushdecl_namespace_level (tmpl);\n \n   if (primary)\n-    DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n+    {\n+      DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n+      if (DECL_CONV_FN_P (tmpl))\n+\t{\n+\t  /* It is a conversion operator. See if the type converted to\n+\t     depends on innermost template operands.  */\n+\t  \n+\t  if (for_each_template_parm\n+\t      (TREE_TYPE (TREE_TYPE (tmpl)),\n+\t       template_parm_this_level_p,\n+\t       (void *)TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl))))\n+\t    DECL_TEMPLATE_CONV_FN_P (tmpl) = 1;\n+\t}\n+    }\n \n   info = tree_cons (tmpl, args, NULL_TREE);\n "}, {"sha": "adcb07642f37de71ecbf363b7963a8b1ad9a603c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -1522,8 +1522,9 @@ int\n lookup_fnfields_1 (type, name)\n      tree type, name;\n {\n-  tree method_vec \n-    = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n+  tree method_vec = (CLASS_TYPE_P (type)\n+\t\t     ? CLASSTYPE_METHOD_VEC (type)\n+\t\t     : NULL_TREE);\n \n   if (method_vec != 0)\n     {\n@@ -1586,22 +1587,19 @@ lookup_fnfields_1 (type, name)\n \t}\n \n       /* If we didn't find it, it might have been a template\n-\t conversion operator.  (Note that we don't look for this case\n-\t above so that we will always find specializations first.)  */\n+\t conversion operator to a templated type.  If there are any,\n+\t such template conversion operators will all be overloaded on\n+\t the first conversion slot.  (Note that we don't look for this\n+\t case above so that we will always find specializations\n+\t first.)  */\n       if (IDENTIFIER_TYPENAME_P (name)) \n \t{\n-\t  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-\t       i < len && methods[i]; \n-\t       ++i)\n+\t  i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t  if (i < len && methods[i])\n \t    {\n \t      tmp = OVL_CURRENT (methods[i]);\n-\t      if (! DECL_CONV_FN_P (tmp))\n-\t\t{\n-\t\t  /* Since all conversion operators come first, we know\n-\t\t     there is no such operator.  */\n-\t\t  break;\n-\t\t}\n-\t      else if (TREE_CODE (tmp) == TEMPLATE_DECL)\n+\t      if (TREE_CODE (tmp) == TEMPLATE_DECL\n+\t\t  && DECL_TEMPLATE_CONV_FN_P (tmp))\n \t\treturn i;\n \t    }\n \t}"}, {"sha": "f0c9255e9784fdb710b4490ad74f667dc7ed7a77", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -2095,7 +2095,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t now.  Otherwise, we have to wait and see what context it is\n \t\t used in; a component_ref involving a non-static member\n \t\t function can only be used in a call (expr.ref).  */\n-\n+\t      \n \t      if (TREE_CHAIN (fndecls) == NULL_TREE\n \t\t  && TREE_CODE (TREE_VALUE (fndecls)) == FUNCTION_DECL)\n \t\t{\n@@ -2119,7 +2119,16 @@ build_component_ref (datum, component, basetype_path, protect)\n \n \t      fndecls = TREE_VALUE (fndecls);\n \t      \n-\t      if (TREE_CODE (component) == TEMPLATE_ID_EXPR)\n+ \t      if (IDENTIFIER_TYPENAME_P (name))\n+ \t\t{\n+ \t\t  /* We want for a conversion op. We need to remember\n+ \t\t     the actual type we wanted, in case we got a set of\n+ \t\t     templated conversion operators back.  */\n+ \t\t  fndecls = ovl_cons (OVL_CURRENT (fndecls),\n+ \t\t\t\t      OVL_NEXT (fndecls));\n+ \t\t  TREE_TYPE (fndecls) = TREE_TYPE (name);\n+ \t\t}\n+\t      else if (TREE_CODE (component) == TEMPLATE_ID_EXPR)\n \t\tfndecls = build_nt (TEMPLATE_ID_EXPR,\n \t\t\t\t    fndecls, TREE_OPERAND (component, 1));\n \t      \n@@ -2684,7 +2693,12 @@ build_x_function_call (function, params, decl)\n       decl = TREE_OPERAND (function, 0);\n       function = TREE_OPERAND (function, 1);\n \n-      if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n+      if (TREE_CODE (function) == OVERLOAD\n+ \t  && TREE_TYPE (function) != unknown_type_node)\n+ \t/* It was a conversion operator. We can't use DECL_NAME, as\n+ \t   that might refer to a templated function.  */\n+\tfunction = mangle_conv_op_name_for_type (TREE_TYPE (function));\n+      else if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n \t{\n \t  my_friendly_assert (!template_id, 20011228);\n "}, {"sha": "13772f100970893fdef8b74437b2055d90673349", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -1,3 +1,10 @@\n+2002-03-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/template/conv1.C: New test.\n+\t* g++.dg/template/conv2.C: New test.\n+\t* g++.dg/template/conv3.C: New test.\n+\t* g++.dg/template/conv4.C: New test.\n+\n 2002-03-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/template/qualttp20.C: Remove unnecessary error tags."}, {"sha": "e0c7492034ca421f31380c9eab572033ff0f8f98", "filename": "gcc/testsuite/g++.dg/template/conv1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv1.C?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 4361. Template conversion operators were not overloaded.\n+\n+template <class T> struct Second;\n+\n+template<class T> struct First\n+{\n+  int Foo ();\n+  \n+  template <class U> operator Second<U>();\n+  template <class U> operator First<U>();\n+};\n+\n+template <class T> int First<T>::Foo ()\n+{} // This is here to make sure we didn't smash Foo's decl in the\n+   // method vector\n+\n+struct B { };\n+struct D { };\n+\n+void Foo ()\n+{\n+  First<B> (First<D>::*pf)() = &First<D>::operator First<B>;\n+}"}, {"sha": "a0d08df55835be2f0c0547dc80f9c08d7d03cae5", "filename": "gcc/testsuite/g++.dg/template/conv2.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv2.C?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 4361. Template conversion operators were not overloaded.\n+\n+class C\n+{\n+public:\n+\n+  operator float () {return 2;}\n+  \n+  operator int () \n+  {\n+    return 0;\n+  }\n+  \n+  template<typename T>\n+  operator int ()\n+  { return 1;\n+  }\n+};\n+\n+int main ()\n+{\n+  C p;\n+  int r;\n+\n+  r = p.operator int ();\n+  if (r)\n+    return r;\n+  r = static_cast <int> (p);\n+\n+  if (r)\n+    return r + 2;\n+  \n+  return 0;\n+}"}, {"sha": "a6b0f639bccb64333d4ab6dcbe2b8299e8711dad", "filename": "gcc/testsuite/g++.dg/template/conv3.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv3.C?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 4361. Template conversion operators were not overloaded.\n+\n+template <typename T> struct C\n+{\n+  operator T () \n+  {\n+    return 0;\n+  }\n+  template <typename T2> operator T2 ()\n+  {\n+    return 1;\n+  }\n+  int Foo ()\n+  {\n+    return operator T ();\n+  }\n+  template <typename T2> int Baz ()\n+  {\n+    return static_cast <int> (operator T2 ());\n+  }\n+};\n+\n+int main ()\n+{\n+  int r;\n+  C<int> c;\n+\n+  r = c.Foo ();\n+  if (r)\n+    return 1;\n+  r = c.Baz<int> ();\n+  if (r)\n+    return 2;\n+  r = c.Baz<float> ();\n+  if (!r)\n+    return 3;\n+  return 0;\n+}"}, {"sha": "4db3dca603b72d71c54919b9cd39fd2daf93b5a7", "filename": "gcc/testsuite/g++.dg/template/conv4.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dd236e238bbea08ee2134d00306e03befd7e25b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv4.C?ref=5dd236e238bbea08ee2134d00306e03befd7e25b", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 4361. Template conversion operators were not overloaded.\n+\n+struct C\n+{\n+  template <typename T2> operator T2 ()\n+  {\n+    return 1;\n+  }\n+  int Foo ()\n+  {\n+    return operator int ();\n+  }\n+};\n+\n+struct D\n+{\n+  int Foo ()\n+  {\n+    return operator int (); // { dg-error \"no matching function\" \"\" }\n+  }\n+};\n+"}]}