{"sha": "df1346b423f1c8849b6090b47023ee29f6dddf7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYxMzQ2YjQyM2YxYzg4NDliNjA5MGI0NzAyM2VlMjlmNmRkZGY3YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-10-01T18:46:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-10-01T18:46:51Z"}, "message": "[libiberty] Use pipe inside pex_run\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-10/msg00039.html\n\t* configure.ac (checkfuncs): Add pipe2.\n\t* config.in, configure: Rebuilt.\n\t* pex-unix.c (pex_unix_exec_child): Comminicate errors from child\n\tto parent with a pipe, when possible.\n\nFrom-SVN: r264769", "tree": {"sha": "47f2a70f8994f6f0209d48b71f4aa64f67122557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f2a70f8994f6f0209d48b71f4aa64f67122557"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df1346b423f1c8849b6090b47023ee29f6dddf7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1346b423f1c8849b6090b47023ee29f6dddf7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1346b423f1c8849b6090b47023ee29f6dddf7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1346b423f1c8849b6090b47023ee29f6dddf7a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2649038cea4670fb51ad82751126661ac9e86c8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2649038cea4670fb51ad82751126661ac9e86c8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2649038cea4670fb51ad82751126661ac9e86c8a"}], "stats": {"total": 154, "additions": 109, "deletions": 45}, "files": [{"sha": "b2e833cf7ea56462b98a17ff3b79c7b987687111", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=df1346b423f1c8849b6090b47023ee29f6dddf7a", "patch": "@@ -1,3 +1,10 @@\n+2018-10-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* configure.ac (checkfuncs): Add pipe2.\n+\t* config.in, configure: Rebuilt.\n+\t* pex-unix.c (pex_unix_exec_child): Comminicate errors from child\n+\tto parent with a pipe, when possible.\n+\n 2018-08-23  Nathan Sidwell  <nathan@acm.org>\n \t    Martin Liska  <mliska@suse.cz>\n "}, {"sha": "c7b472543cf8e339d5d50a907c41d352d7ee9001", "filename": "libiberty/config.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.in?ref=df1346b423f1c8849b6090b47023ee29f6dddf7a", "patch": "@@ -195,6 +195,9 @@\n /* Define to 1 if you have the `on_exit' function. */\n #undef HAVE_ON_EXIT\n \n+/* Define to 1 if you have the `pipe2' function. */\n+#undef HAVE_PIPE2\n+\n /* Define to 1 if you have the <process.h> header file. */\n #undef HAVE_PROCESS_H\n "}, {"sha": "03ff39491152a6b5fd476e9e2f477c7ebc9decf2", "filename": "libiberty/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=df1346b423f1c8849b6090b47023ee29f6dddf7a", "patch": "@@ -5727,7 +5727,7 @@ funcs=\"$funcs setproctitle\"\n vars=\"sys_errlist sys_nerr sys_siglist\"\n \n checkfuncs=\"__fsetlocking canonicalize_file_name dup3 getrlimit getrusage \\\n- getsysinfo gettimeofday on_exit psignal pstat_getdynamic pstat_getstatic \\\n+ getsysinfo gettimeofday on_exit pipe2 psignal pstat_getdynamic pstat_getstatic \\\n  realpath setrlimit sbrk spawnve spawnvpe strerror strsignal sysconf sysctl \\\n  sysmp table times wait3 wait4\"\n \n@@ -5743,7 +5743,7 @@ if test \"x\" = \"y\"; then\n     index insque \\\n     memchr memcmp memcpy memmem memmove memset mkstemps \\\n     on_exit \\\n-    psignal pstat_getdynamic pstat_getstatic putenv \\\n+    pipe2 psignal pstat_getdynamic pstat_getstatic putenv \\\n     random realpath rename rindex \\\n     sbrk setenv setproctitle setrlimit sigsetmask snprintf spawnve spawnvpe \\\n      stpcpy stpncpy strcasecmp strchr strdup \\"}, {"sha": "59c45c973ab05bcef966b8417c7683fa18b28f40", "filename": "libiberty/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.ac?ref=df1346b423f1c8849b6090b47023ee29f6dddf7a", "patch": "@@ -391,7 +391,7 @@ funcs=\"$funcs setproctitle\"\n vars=\"sys_errlist sys_nerr sys_siglist\"\n \n checkfuncs=\"__fsetlocking canonicalize_file_name dup3 getrlimit getrusage \\\n- getsysinfo gettimeofday on_exit psignal pstat_getdynamic pstat_getstatic \\\n+ getsysinfo gettimeofday on_exit pipe2 psignal pstat_getdynamic pstat_getstatic \\\n  realpath setrlimit sbrk spawnve spawnvpe strerror strsignal sysconf sysctl \\\n  sysmp table times wait3 wait4\"\n \n@@ -407,7 +407,7 @@ if test \"x\" = \"y\"; then\n     index insque \\\n     memchr memcmp memcpy memmem memmove memset mkstemps \\\n     on_exit \\\n-    psignal pstat_getdynamic pstat_getstatic putenv \\\n+    pipe2 psignal pstat_getdynamic pstat_getstatic putenv \\\n     random realpath rename rindex \\\n     sbrk setenv setproctitle setrlimit sigsetmask snprintf spawnve spawnvpe \\\n      stpcpy stpncpy strcasecmp strchr strdup \\"}, {"sha": "0f283e6b03767952fec2a3c6300c417c5ae68047", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 95, "deletions": 41, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1346b423f1c8849b6090b47023ee29f6dddf7a/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=df1346b423f1c8849b6090b47023ee29f6dddf7a", "patch": "@@ -569,6 +569,38 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t\t     int toclose, const char **errmsg, int *err)\n {\n   pid_t pid = -1;\n+  /* Tuple to communicate error from child to parent.  We can safely\n+     transfer string literal pointers as both run with identical\n+     address mappings.  */\n+  struct fn_err \n+  {\n+    const char *fn;\n+    int err;\n+  };\n+  volatile int do_pipe = 0;\n+  volatile int pipes[2]; /* [0]:reader,[1]:writer.  */\n+#ifdef O_CLOEXEC\n+  do_pipe = 1;\n+#endif\n+  if (do_pipe)\n+    {\n+#ifdef HAVE_PIPE2\n+      if (pipe2 ((int *)pipes, O_CLOEXEC))\n+\tdo_pipe = 0;\n+#else\n+      if (pipe ((int *)pipes))\n+\tdo_pipe = 0;\n+      else\n+\t{\n+\t  if (fcntl (pipes[1], F_SETFD, FD_CLOEXEC) == -1)\n+\t    {\n+\t      close (pipes[0]);\n+\t      close (pipes[1]);\n+\t      do_pipe = 0;\n+\t    }\n+\t}\n+#endif\n+    }\n \n   /* We declare these to be volatile to avoid warnings from gcc about\n      them being clobbered by vfork.  */\n@@ -579,8 +611,9 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n      This clobbers the parent's environ so we need to restore it.\n      It would be nice to use one of the exec* functions that takes an\n      environment as a parameter, but that may have portability\n-     issues.   */\n-  char **save_environ = environ;\n+     issues.  It is marked volatile so the child doesn't consider it a\n+     dead variable and therefore clobber where ever it is stored.  */\n+  char **volatile save_environ = environ;\n \n   for (retries = 0; retries < 4; ++retries)\n     {\n@@ -594,47 +627,55 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n   switch (pid)\n     {\n     case -1:\n+      if (do_pipe)\n+\t{\n+\t  close (pipes[0]);\n+\t  close (pipes[1]);\n+\t}\n       *err = errno;\n       *errmsg = VFORK_STRING;\n       return (pid_t) -1;\n \n     case 0:\n       /* Child process.  */\n       {\n-\tconst char *bad_fn = NULL;\n+\tstruct fn_err failed;\n+\tfailed.fn = NULL;\n \n-\tif (!bad_fn && in != STDIN_FILE_NO)\n+\tif (do_pipe)\n+\t  close (pipes[0]);\n+\tif (!failed.fn && in != STDIN_FILE_NO)\n \t  {\n \t    if (dup2 (in, STDIN_FILE_NO) < 0)\n-\t      bad_fn = \"dup2\";\n+\t      failed.fn = \"dup2\", failed.err = errno;\n \t    else if (close (in) < 0)\n-\t      bad_fn = \"close\";\n+\t      failed.fn = \"close\", failed.err = errno;\n \t  }\n-\tif (!bad_fn && out != STDOUT_FILE_NO)\n+\tif (!failed.fn && out != STDOUT_FILE_NO)\n \t  {\n \t    if (dup2 (out, STDOUT_FILE_NO) < 0)\n-\t      bad_fn = \"dup2\";\n+\t      failed.fn = \"dup2\", failed.err = errno;\n \t    else if (close (out) < 0)\n-\t      bad_fn = \"close\";\n+\t      failed.fn = \"close\", failed.err = errno;\n \t  }\n-\tif (!bad_fn && errdes != STDERR_FILE_NO)\n+\tif (!failed.fn && errdes != STDERR_FILE_NO)\n \t  {\n \t    if (dup2 (errdes, STDERR_FILE_NO) < 0)\n-\t      bad_fn = \"dup2\";\n+\t      failed.fn = \"dup2\", failed.err = errno;\n \t    else if (close (errdes) < 0)\n-\t      bad_fn = \"close\";\n+\t      failed.fn = \"close\", failed.err = errno;\n \t  }\n-\tif (!bad_fn && toclose >= 0)\n+\tif (!failed.fn && toclose >= 0)\n \t  {\n \t    if (close (toclose) < 0)\n-\t      bad_fn = \"close\";\n+\t      failed.fn = \"close\", failed.err = errno;\n \t  }\n-\tif (!bad_fn && (flags & PEX_STDERR_TO_STDOUT) != 0)\n+\tif (!failed.fn && (flags & PEX_STDERR_TO_STDOUT) != 0)\n \t  {\n \t    if (dup2 (STDOUT_FILE_NO, STDERR_FILE_NO) < 0)\n-\t      bad_fn = \"dup2\";\n+\t      failed.fn = \"dup2\", failed.err = errno;\n \t  }\n-\tif (!bad_fn)\n+\tif (!failed.fn)\n \t  {\n \t    if (env)\n \t      /* NOTE: In a standard vfork implementation this clobbers\n@@ -644,30 +685,35 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t    if ((flags & PEX_SEARCH) != 0)\n \t      {\n \t\texecvp (executable, to_ptr32 (argv));\n-\t\tbad_fn = \"execvp\";\n+\t\tfailed.fn = \"execvp\", failed.err = errno;\n \t      }\n \t    else\n \t      {\n \t\texecv (executable, to_ptr32 (argv));\n-\t\tbad_fn = \"execv\";\n+\t\tfailed.fn = \"execv\", failed.err = errno;\n \t      }\n \t  }\n \n \t/* Something failed, report an error.  We don't use stdio\n \t   routines, because we might be here due to a vfork call.  */\n \tssize_t retval = 0;\n-\tint eno = errno;\n-\t\n+\n+\tif (!do_pipe\n+\t    || write (pipes[1], &failed, sizeof (failed)) != sizeof (failed))\n+\t  {\n+\t    /* The parent will not see our scream above, so write to\n+\t       stdout.  */\n #define writeerr(s) (retval |= write (STDERR_FILE_NO, s, strlen (s)))\n-\twriteerr (obj->pname);\n-\twriteerr (\": error trying to exec '\");\n-\twriteerr (executable);\n-\twriteerr (\"': \");\n-\twriteerr (bad_fn);\n-\twriteerr (\": \");\n-\twriteerr (xstrerror (eno));\n-\twriteerr (\"\\n\");\n+\t    writeerr (obj->pname);\n+\t    writeerr (\": error trying to exec '\");\n+\t    writeerr (executable);\n+\t    writeerr (\"': \");\n+\t    writeerr (failed.fn);\n+\t    writeerr (\": \");\n+\t    writeerr (xstrerror (failed.err));\n+\t    writeerr (\"\\n\");\n #undef writeerr\n+\t  }\n \n \t/* Exit with -2 if the error output failed, too.  */\n \t_exit (retval < 0 ? -2 : -1);\n@@ -678,33 +724,41 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n     default:\n       /* Parent process.  */\n       {\n-\tconst char *bad_fn = NULL;\n-\t\n \t/* Restore environ.  Note that the parent either doesn't run\n \t   until the child execs/exits (standard vfork behaviour), or\n \t   if it does run then vfork is behaving more like fork.  In\n \t   either case we needn't worry about clobbering the child's\n \t   copy of environ.  */\n \tenviron = save_environ;\n \n-\tif (!bad_fn && in != STDIN_FILE_NO)\n+\tstruct fn_err failed;\n+\tfailed.fn = NULL;\n+\tif (do_pipe)\n+\t  {\n+\t    close (pipes[1]);\n+\t    ssize_t len = read (pipes[0], &failed, sizeof (failed));\n+\t    if (len < 0)\n+\t      failed.fn = NULL;\n+\t    close (pipes[0]);\n+\t  }\n+\n+\tif (!failed.fn && in != STDIN_FILE_NO)\n \t  if (close (in) < 0)\n-\t    bad_fn = \"close\";\n-\tif (!bad_fn && out != STDOUT_FILE_NO)\n+\t    failed.fn = \"close\", failed.err = errno;\n+\tif (!failed.fn && out != STDOUT_FILE_NO)\n \t  if (close (out) < 0)\n-\t    bad_fn = \"close\";\n-\tif (!bad_fn && errdes != STDERR_FILE_NO)\n+\t    failed.fn = \"close\", failed.err = errno;\n+\tif (!failed.fn && errdes != STDERR_FILE_NO)\n \t  if (close (errdes) < 0)\n-\t    bad_fn = \"close\";\n+\t    failed.fn = \"close\", failed.err = errno;\n \n-\tif (bad_fn)\n+\tif (failed.fn)\n \t  {\n-\t    *err = errno;\n-\t    *errmsg = bad_fn;\n+\t    *err = failed.err;\n+\t    *errmsg = failed.fn;\n \t    return (pid_t) -1;\n \t  }\n       }\n-\n       return pid;\n     }\n }"}]}