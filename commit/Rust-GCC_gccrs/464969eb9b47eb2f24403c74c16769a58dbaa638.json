{"sha": "464969eb9b47eb2f24403c74c16769a58dbaa638", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0OTY5ZWI5YjQ3ZWIyZjI0NDAzYzc0YzE2NzY5YTU4ZGJhYTYzOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-08-28T16:43:56Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-08-28T16:43:56Z"}, "message": "PR tree-optimization/91457 - inconsistent warning for writing past the end of an array member\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/91457\n\t* builtins.c (component_size): New function.\n\t(compute_objsize): Add argument. Handle ARRAY_REF and COMPONENT_REF.\n\t* builtins.h (compute_objsize): Add argument.\n\t* tree-ssa-strlen.c (handle_store): Handle no-warning bit.\n\t* tree-vrp.c (vrp_prop::check_array_ref): Return warning result.\n\t(vrp_prop::check_mem_ref): Same.\n\t(vrp_prop::search_for_addr_array): Set no-warning bit.\n\t(check_array_bounds): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/91457\n\t* c-c++-common/Wstringop-overflow-2.c: New test.\n\t* g++.dg/warn/Warray-bounds-8.C: New test.\n\t* g++.dg/warn/Wstringop-overflow-3.C: New test.\n\t* gcc.dg/Wstringop-overflow-15.c: New test.\n\nFrom-SVN: r274997", "tree": {"sha": "821481a2cfc3a3c99c5d25b19c08cd56afef8e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/821481a2cfc3a3c99c5d25b19c08cd56afef8e58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/464969eb9b47eb2f24403c74c16769a58dbaa638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464969eb9b47eb2f24403c74c16769a58dbaa638", "html_url": "https://github.com/Rust-GCC/gccrs/commit/464969eb9b47eb2f24403c74c16769a58dbaa638", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464969eb9b47eb2f24403c74c16769a58dbaa638/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2eee239811d4335f28ccdf7c2d9c490fcf6612d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2eee239811d4335f28ccdf7c2d9c490fcf6612d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2eee239811d4335f28ccdf7c2d9c490fcf6612d"}], "stats": {"total": 1410, "additions": 1365, "deletions": 45}, "files": [{"sha": "77dbf876a3a5d0c16fbbcce9f8d127a6d7baa280", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -1,3 +1,15 @@\n+2019-08-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91457\n+\t* builtins.c (component_size): New function.\n+\t(compute_objsize): Add argument. Handle ARRAY_REF and COMPONENT_REF.\n+\t* builtins.h (compute_objsize): Add argument.\n+\t* tree-ssa-strlen.c (handle_store): Handle no-warning bit.\n+\t* tree-vrp.c (vrp_prop::check_array_ref): Return warning result.\n+\t(vrp_prop::check_mem_ref): Same.\n+\t(vrp_prop::search_for_addr_array): Set no-warning bit.\n+\t(check_array_bounds): Same.\n+\n 2019-08-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR driver/80545"}, {"sha": "f8063c138a340a06d45b01c9bb7f43caf75e78b2", "filename": "gcc/builtins.c", "status": "modified", "additions": 98, "deletions": 15, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"file-prefix-map.h\" /* remap_macro_filename()  */\n #include \"gomp-constants.h\"\n #include \"omp-general.h\"\n+#include \"tree-dfa.h\"\n \n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n@@ -3561,19 +3562,73 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   return true;\n }\n \n+/* Determines the size of the member referenced by the COMPONENT_REF\n+   REF, using its initializer expression if necessary in order to\n+   determine the size of an initialized flexible array member.\n+   Returns the size (which might be zero for an object with\n+   an uninitialized flexible array member) or null if the size\n+   cannot be determined.  */\n+\n+static tree\n+component_size (tree ref)\n+{\n+  gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n+\n+  tree member = TREE_OPERAND (ref, 1);\n+\n+  /* If the member is not last or has a size greater than one, return\n+     it.  Otherwise it's either a flexible array member or a zero-length\n+     array member, or an array of length one treated as such.  */\n+  tree size = DECL_SIZE_UNIT (member);\n+  if (size\n+      && (!array_at_struct_end_p (ref)\n+\t  || (!integer_zerop (size)\n+\t      && !integer_onep (size))))\n+    return size;\n+\n+  /* If the reference is to a declared object and the member a true\n+     flexible array, try to determine its size from its initializer.  */\n+  poly_int64 off = 0;\n+  tree base = get_addr_base_and_unit_offset (ref, &off);\n+  if (!base || !VAR_P (base))\n+    return NULL_TREE;\n+\n+  /* The size of any member of a declared object other than a flexible\n+     array member is that obtained above.  */\n+  if (size)\n+    return size;\n+\n+  if (tree init = DECL_INITIAL (base))\n+    if (TREE_CODE (init) == CONSTRUCTOR)\n+      {\n+\toff <<= LOG2_BITS_PER_UNIT;\n+\tinit = fold_ctor_reference (NULL_TREE, init, off, 0, base);\n+\tif (init)\n+\t  return TYPE_SIZE_UNIT (TREE_TYPE (init));\n+      }\n+\n+  return DECL_EXTERNAL (base) ? NULL_TREE : integer_zero_node;\n+}\n+\n /* Helper to compute the size of the object referenced by the DEST\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).  Return\n    an estimate of the size of the object if successful or NULL when\n    the size cannot be determined.  When the referenced object involves\n    a non-constant offset in some range the returned value represents\n    the largest size given the smallest non-negative offset in the\n-   range.  The function is intended for diagnostics and should not\n-   be used to influence code generation or optimization.  */\n+   range.  If nonnull, set *PDECL to the decl of the referenced\n+   subobject if it can be determined, or to null otherwise.\n+   The function is intended for diagnostics and should not be used\n+   to influence code generation or optimization.  */\n \n tree\n-compute_objsize (tree dest, int ostype)\n+compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n {\n+  tree dummy = NULL_TREE;\n+  if (!pdecl)\n+    pdecl = &dummy;\n+\n   unsigned HOST_WIDE_INT size;\n \n   /* Only the two least significant bits are meaningful.  */\n@@ -3600,7 +3655,7 @@ compute_objsize (tree dest, int ostype)\n \t  tree off = gimple_assign_rhs2 (stmt);\n \t  if (TREE_CODE (off) == INTEGER_CST)\n \t    {\n-\t      if (tree size = compute_objsize (dest, ostype))\n+\t      if (tree size = compute_objsize (dest, ostype, pdecl))\n \t\t{\n \t\t  wide_int wioff = wi::to_wide (off);\n \t\t  wide_int wisiz = wi::to_wide (size);\n@@ -3625,7 +3680,7 @@ compute_objsize (tree dest, int ostype)\n \n \t      if (rng == VR_RANGE)\n \t\t{\n-\t\t  if (tree size = compute_objsize (dest, ostype))\n+\t\t  if (tree size = compute_objsize (dest, ostype, pdecl))\n \t\t    {\n \t\t      wide_int wisiz = wi::to_wide (size);\n \n@@ -3653,12 +3708,31 @@ compute_objsize (tree dest, int ostype)\n   if (!ostype)\n     return NULL_TREE;\n \n-  if (TREE_CODE (dest) == MEM_REF)\n+  if (TREE_CODE (dest) == ARRAY_REF\n+      || TREE_CODE (dest) == MEM_REF)\n     {\n       tree ref = TREE_OPERAND (dest, 0);\n       tree off = TREE_OPERAND (dest, 1);\n-      if (tree size = compute_objsize (ref, ostype))\n+      if (tree size = compute_objsize (ref, ostype, pdecl))\n \t{\n+\t  /* If the declaration of the destination object is known\n+\t     to have zero size, return zero.  */\n+\t  if (integer_zerop (size))\n+\t    return integer_zero_node;\n+\n+\t  if (TREE_CODE (off) != INTEGER_CST\n+\t      || TREE_CODE (size) != INTEGER_CST)\n+\t    return NULL_TREE;\n+\n+\t  if (TREE_CODE (dest) == ARRAY_REF)\n+\t    {\n+\t      tree eltype = TREE_TYPE (dest);\n+\t      if (tree tpsize = TYPE_SIZE_UNIT (eltype))\n+\t\toff = fold_build2 (MULT_EXPR, size_type_node, off, tpsize);\n+\t      else\n+\t\treturn NULL_TREE;\n+\t    }\n+\n \t  if (tree_int_cst_lt (off, size))\n \t    return fold_build2 (MINUS_EXPR, size_type_node, size, off);\n \t  return integer_zero_node;\n@@ -3667,24 +3741,33 @@ compute_objsize (tree dest, int ostype)\n       return NULL_TREE;\n     }\n \n+  if (TREE_CODE (dest) == COMPONENT_REF)\n+    {\n+      *pdecl = TREE_OPERAND (dest, 1);\n+      return component_size (dest);\n+    }\n+\n   if (TREE_CODE (dest) != ADDR_EXPR)\n     return NULL_TREE;\n \n+  tree ref = TREE_OPERAND (dest, 0);\n+  if (DECL_P (ref))\n+    {\n+      *pdecl = ref;\n+      return DECL_SIZE_UNIT (ref);\n+    }\n+\n   tree type = TREE_TYPE (dest);\n   if (TREE_CODE (type) == POINTER_TYPE)\n     type = TREE_TYPE (type);\n \n   type = TYPE_MAIN_VARIANT (type);\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n-      && !array_at_struct_end_p (TREE_OPERAND (dest, 0)))\n-    {\n-      /* Return the constant size unless it's zero (that's a zero-length\n-\t array likely at the end of a struct).  */\n-      tree size = TYPE_SIZE_UNIT (type);\n-      if (size && TREE_CODE (size) == INTEGER_CST\n-\t  && !integer_zerop (size))\n-\treturn size;\n+      && !array_at_struct_end_p (ref))\n+    {\n+      if (tree size = TYPE_SIZE_UNIT (type))\n+\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n     }\n \n   return NULL_TREE;"}, {"sha": "1ad82e869634e737b3a70771c59a595c4eeb6d2a", "filename": "gcc/builtins.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -134,7 +134,7 @@ extern tree fold_call_stmt (gcall *, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n-extern tree compute_objsize (tree, int);\n+extern tree compute_objsize (tree, int, tree * = NULL);\n \n extern bool readonly_data_expr (tree exp);\n extern bool init_target_chars (void);"}, {"sha": "0e7c31b1ab70441e1f65dea47c8321adee05a87a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -1,3 +1,11 @@\n+2019-08-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91457\n+\t* c-c++-common/Wstringop-overflow-2.c: New test.\n+\t* g++.dg/warn/Warray-bounds-8.C: New test.\n+\t* g++.dg/warn/Wstringop-overflow-3.C: New test.\n+\t* gcc.dg/Wstringop-overflow-15.c: New test.\n+\n 2019-08-16  Martin Liska  <mliska@suse.cz>\n \n \tPR c++/90613"}, {"sha": "d1aab4805e9f4acb6797e2186294524716b4d383", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2.c", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -0,0 +1,348 @@\n+/* PR middle-end/91458 - inconsistent warning for writing past the end\n+   of an array member\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+void sink (void*);\n+\n+// Exercise flexible array members.\n+\n+struct Ax\n+{\n+  char n;\n+  char a[];                     // { dg-message \"destination object declared here\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+struct Ax ax_;\n+\n+void gax_ (void)\n+{\n+  ax_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax_.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax_.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the flexible array member.\n+struct Ax ax0 = { 0 };\n+\n+void gax0 (void)\n+{\n+  ax0.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the flexible array member to empty.\n+struct Ax ax0_ = { 0, { } };\n+\n+void gax0_ (void)\n+{\n+  ax0_.a[0] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0_.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0_.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for out-of-bounds accesses to a definition with\n+// an initializer.\n+struct Ax ax1 = { 1, { 0 } };\n+\n+void gax1 (void)\n+{\n+  ax1.a[0] = 0;\n+  ax1.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax1.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+struct Ax ax2 = { 2, { 1, 0 } };\n+\n+void gax2 (void)\n+{\n+  ax2.a[0] = 0;\n+  ax2.a[1] = 1;\n+  ax2.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void gaxp (struct Ax *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 3;\n+  p->a[9] = 9;\n+}\n+\n+\n+// Verify no warning for an extern struct object whose array may be\n+// initialized to any number of elements.\n+extern struct Ax axx;\n+\n+void gaxx (void)\n+{\n+  axx.a[0] = 0;\n+  axx.a[3] = 3;\n+  axx.a[9] = 9;\n+}\n+\n+// Exercise zero-length array members.\n+\n+struct A0\n+{\n+  char n;\n+  char a[0];                    // { dg-message \"destination object declared here\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+struct A0 a0_;\n+\n+void ga0_ (void)\n+{\n+  a0_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0_.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0_.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the flexible array member.\n+struct A0 a00 = { 0 };\n+\n+void ga00 (void)\n+{\n+  a00.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the flexible array member to empty.\n+struct A0 a00_ = { 0, { } };\n+\n+void ga00_ (void)\n+{\n+  a00_.a[0] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00_.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00_.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// The following are rejected with\n+//   error: too many initializers for 'char [0]'\n+// A0 a01 = { 1, { 0 } };\n+// A0 a02 = { 2, { 1, 0 } };\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga0p (struct A0 *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 3;\n+  p->a[9] = 9;\n+}\n+\n+\n+// Verify warning for an extern struct object which (unlike a true\n+// flexible array member) may not be initialized.\n+extern struct A0 a0x;\n+\n+void ga0x (void)\n+{\n+  a0x.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0x.a[9] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Exercise trailing one-element array members.\n+\n+struct A1\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object declared here\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+struct A1 a1_;\n+\n+void ga1_ (void)\n+{\n+  a1_.a[0] = 0;\n+  a1_.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a;\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+struct A1 a1__ = { 0 };\n+\n+void ga1__ (void)\n+{\n+  a1__.a[0] = 0;\n+  a1__.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1__.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 1 };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+struct A1 a1_0 = { 0, { } };\n+\n+void ga1_0_ (void)\n+{\n+  a1_0.a[0] = 0;\n+  a1_0.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_0.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 1, { } };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+struct A1 a1_1 = { 0, { 1 } };\n+\n+void ga1_1 (void)\n+{\n+  a1_1.a[0] = 0;\n+  a1_1.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_1.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 0, { 1 } };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga1p (struct A1 *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 3;\n+  p->a[9] = 9;\n+}\n+\n+\n+// Verify warning for an extern struct object.  Similar to the zero-length\n+// array case, a one-element trailing array can be initialized to at most\n+// a single element.\n+extern struct A1 a1x;\n+\n+void ga1x (void)\n+{\n+  a1x.a[0] = 0;\n+  a1x.a[3] = 3;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1x.a[9] = 9;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Exercise interior one-element array members (verify they're not\n+// treated as trailing.\n+\n+struct A1i\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char x;\n+};\n+\n+// Verify warning for a definition with no initializer.\n+struct A1i a1i_;\n+\n+void ga1i_ (void)\n+{\n+  a1i_.a[0] = 0;\n+  a1i_.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1i a;\n+  a.a[0] = 1;\n+  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+struct A1i a1i__ = { 0 };\n+\n+void ga1i__ (void)\n+{\n+  a1i__.a[0] = 0;\n+  a1i__.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i__.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1i a = { 0 };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+struct A1 a1i_0 = { 0, { } };\n+\n+void ga1i_0_ (void)\n+{\n+  a1i_0.a[0] = 0;\n+  a1i_0.a[1] = 1;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_0.a[2] = 2;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 0, { } };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+struct A1 a1i_1 = { 0, { 1 } };\n+\n+void ga1i_1 (void)\n+{\n+  a1i_1.a[0] = 0;\n+  a1i_1.a[1] = 1;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_1.a[2] = 2;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 0, { 1 } };\n+  a.a[0] = 1;\n+  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga1ip (struct A1i *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 3;                  // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  p->a[9] = 9;                  // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify no warning for an extern struct object.\n+extern struct A1i a1ix;\n+\n+void ga1ix (void)\n+{\n+  a1ix.a[0] = 0;\n+  a1ix.a[3] = 3;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1ix.a[9] = 9;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}"}, {"sha": "850414ede4b515b7e4b285ab3cc7fa7351c82431", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-8.C", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -0,0 +1,388 @@\n+/* PR middle-end/91458 - inconsistent warning for writing past the end\n+   of an array member\n+   See Wstringop-overflow-3.C for the same test that exercises the other\n+   warning.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-stringop-overflow\" } */\n+\n+void sink (void*);\n+\n+// Exercise flexible array members.\n+\n+struct Ax\n+{\n+  char n;\n+  char a[];                     // { dg-message \"while referencing .Ax::a.\" \"pr91463\" { xfail *-*-* } }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+Ax ax_;\n+\n+void gax_ ()\n+{\n+  ax_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the flexible array member.\n+Ax ax0 = { 0 };\n+\n+void gax0 ()\n+{\n+  ax0.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax0.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax0.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the flexible array member to empty.\n+Ax ax0_ = { 0, { } };\n+\n+void gax0_ ()\n+{\n+  ax0_.a[0] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax0_.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax0_.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+}\n+\n+// Verify warning for out-of-bounds accesses to a definition with\n+// an initializer.\n+Ax ax1 = { 1, { 0 } };\n+\n+void gax1 ()\n+{\n+  ax1.a[0] = 0;\n+  ax1.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax1.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+}\n+\n+Ax ax2 = { 2, { 1, 0 } };\n+\n+void gax2 ()\n+{\n+  ax2.a[0] = 0;\n+  ax2.a[1] = 0;\n+  ax2.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void gaxp (Ax *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;\n+  p->a[9] = 0;\n+}\n+\n+\n+// Verify no warning for an extern struct object whose array may be\n+// initialized to any number of elements.\n+extern Ax axx;\n+\n+void gaxx ()\n+{\n+  axx.a[0] = 0;\n+  axx.a[3] = 0;\n+  axx.a[9] = 0;\n+}\n+\n+// Exercise zero-length array members.\n+\n+struct A0\n+{\n+  char n;\n+  char a[0];                    // { dg-message \"while referencing .A0::a.\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+A0 a0_;\n+\n+void ga0_ ()\n+{\n+  a0_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a0_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a0_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the flexible array member.\n+A0 a00 = { 0 };\n+\n+void ga00 ()\n+{\n+  a00.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a00.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a00.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the flexible array member to empty.\n+A0 a00_ = { 0, { } };\n+\n+void ga00_ ()\n+{\n+  a00_.a[0] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a00_.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a00_.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// The following are rejected with\n+//   error: too many initializers for 'char [0]'\n+// A0 a01 = { 1, { 0 } };\n+// A0 a02 = { 2, { 1, 0 } };\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga0p (A0 *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;\n+  p->a[9] = 0;\n+}\n+\n+\n+// Verify warning for an extern struct object which (unlike a true\n+// flexible array member) may not be initialized.\n+extern A0 a0x;\n+\n+void ga0x ()\n+{\n+  a0x.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a0x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a0x.a[9] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+// Exercise trailing one-element array members.\n+\n+struct A1\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"while referencing .A1::a.\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+A1 a1_;\n+\n+void ga1_ ()\n+{\n+  a1_.a[0] = 0;\n+  a1_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+A1 a1__ = { 0 };\n+\n+void ga1__ ()\n+{\n+  a1__.a[0] = 0;\n+  a1__.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1__.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+A1 a1_0 = { 0, { } };\n+\n+void ga1_0_ ()\n+{\n+  a1_0.a[0] = 0;\n+  a1_0.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1_0.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+A1 a1_1 = { 0, { 1 } };\n+\n+void ga1_1 ()\n+{\n+  a1_1.a[0] = 0;\n+  a1_1.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1_1.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga1p (A1 *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;\n+  p->a[9] = 0;\n+}\n+\n+\n+// Verify warning for an extern struct object.  Similar to the zero-length\n+// array case, a one-element trailing array can be initialized to at most\n+// a single element.\n+extern A1 a1x;\n+\n+void ga1x ()\n+{\n+  a1x.a[0] = 0;\n+  a1x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1x.a[9] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Exercise interior one-element array members (verify they're not\n+// treated as trailing.\n+\n+struct A1i\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"while referencing .A1i::a.\" }\n+  char x;\n+};\n+\n+// Verify warning for a definition with no initializer.\n+A1i a1i_;\n+\n+void ga1i_ ()\n+{\n+  a1i_.a[0] = 0;\n+  a1i_.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1i_.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+A1i a1i__ = { 0 };\n+\n+void ga1i__ ()\n+{\n+  a1i__.a[0] = 0;\n+  a1i__.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1i__.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+A1 a1i_0 = { 0, { } };\n+\n+void ga1i_0_ ()\n+{\n+  a1i_0.a[0] = 0;\n+  a1i_0.a[1] = 0;               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1i_0.a[2] = 0;               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+A1 a1i_1 = { 0, { 1 } };\n+\n+void ga1i_1 ()\n+{\n+  a1i_1.a[0] = 0;\n+  a1i_1.a[1] = 0;               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1i_1.a[2] = 0;               // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga1ip (A1i *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;                  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a[9] = 0;                  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+// Verify no warning for an extern struct object.\n+extern A1i a1ix;\n+\n+void ga1ix ()\n+{\n+  a1ix.a[0] = 0;\n+  a1ix.a[3] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  a1ix.a[9] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+// Verify non-POD classes with flexible array members.\n+\n+struct Bx\n+{\n+  char n;\n+  char a[];                     // { dg-message \"while referencing .Bx::a.\" \"pr91463\" { xfail *-*-* } }\n+\n+  // Verify the warning for a constant.\n+  Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+\n+  // And also for a non-constant.  Regardless of the subscript, the array\n+  // of the object in function gxi() below has a zero size.\n+  Bx (int i) { a[i] = 0; }      // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+};\n+\n+void gbx (void)\n+{\n+  struct Bx bx;\n+  sink (&bx);\n+}\n+\n+void gbxi (int i)\n+{\n+  struct Bx bxi (i);\n+  sink (&bxi);\n+}\n+\n+struct B0\n+{\n+  char n;\n+  char a[0];                    // { dg-message \"while referencing .B0::a.\" }\n+\n+  B0 () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+};\n+\n+\n+void gb0 (void)\n+{\n+  struct B0 b0;\n+  sink (&b0);\n+}\n+\n+\n+struct B1\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"while referencing .B1::a.\" }\n+\n+  B1 () { a[1] = 0; }           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+};\n+\n+void gb1 (void)\n+{\n+  struct B1 b1;\n+  sink (&b1);\n+}\n+\n+\n+struct B123\n+{\n+  char a[123];                  // { dg-message \"while referencing .B123::a.\" }\n+\n+  B123 () { a[123] = 0; }       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+};\n+\n+void gb123 (void)\n+{\n+  struct B123 b123;\n+  sink (&b123);\n+}\n+\n+\n+struct B234\n+{\n+  char a[234];                  // { dg-message \"while referencing .B234::a.\" }\n+\n+  B234 (int i) { a[i] = 0; }    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+};\n+\n+void g234 (void)\n+{\n+  struct B234 b234 (234);\n+  sink (&b234);\n+}"}, {"sha": "99ce427c1b57ffee01fa58db05badecb522d8172", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-3.C", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -0,0 +1,386 @@\n+/* PR middle-end/91458 - inconsistent warning for writing past the end\n+   of an array member\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+void sink (void*);\n+\n+// Exercise flexible array members.\n+\n+struct Ax\n+{\n+  char n;\n+  char a[];                     // { dg-message \"destination object declared here\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+Ax ax_;\n+\n+void gax_ ()\n+{\n+  ax_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the flexible array member.\n+Ax ax0 = { 0 };\n+\n+void gax0 ()\n+{\n+  ax0.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the flexible array member to empty.\n+Ax ax0_ = { 0, { } };\n+\n+void gax0_ ()\n+{\n+  ax0_.a[0] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0_.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax0_.a[2] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for out-of-bounds accesses to a definition with\n+// an initializer.\n+Ax ax1 = { 1, { 0 } };\n+\n+void gax1 ()\n+{\n+  ax1.a[0] = 0;\n+  ax1.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  ax1.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+Ax ax2 = { 2, { 1, 0 } };\n+\n+void gax2 ()\n+{\n+  ax2.a[0] = 0;\n+  ax2.a[1] = 0;\n+  ax2.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void gaxp (Ax *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;\n+  p->a[9] = 0;\n+}\n+\n+\n+// Verify no warning for an extern struct object whose array may be\n+// initialized to any number of elements.\n+extern Ax axx;\n+\n+void gaxx ()\n+{\n+  axx.a[0] = 0;\n+  axx.a[3] = 0;\n+  axx.a[9] = 0;\n+}\n+\n+// Exercise zero-length array members.\n+\n+struct A0\n+{\n+  char n;\n+  char a[0];                    // { dg-message \"destination object declared here\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+A0 a0_;\n+\n+void ga0_ ()\n+{\n+  a0_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the flexible array member.\n+A0 a00 = { 0 };\n+\n+void ga00 ()\n+{\n+  a00.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the flexible array member to empty.\n+A0 a00_ = { 0, { } };\n+\n+void ga00_ ()\n+{\n+  a00_.a[0] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00_.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a00_.a[2] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// The following are rejected with\n+//   error: too many initializers for 'char [0]'\n+// A0 a01 = { 1, { 0 } };\n+// A0 a02 = { 2, { 1, 0 } };\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga0p (A0 *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;\n+  p->a[9] = 0;\n+}\n+\n+\n+// Verify warning for an extern struct object which (unlike a true\n+// flexible array member) may not be initialized.\n+extern A0 a0x;\n+\n+void ga0x ()\n+{\n+  a0x.a[0] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a0x.a[9] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Exercise trailing one-element array members.\n+\n+struct A1\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object declared here\" }\n+};\n+\n+// Verify warning for a definition with no initializer.\n+A1 a1_;\n+\n+void ga1_ ()\n+{\n+  a1_.a[0] = 0;\n+  a1_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+A1 a1__ = { 0 };\n+\n+void ga1__ ()\n+{\n+  a1__.a[0] = 0;\n+  a1__.a[1] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1__.a[2] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+A1 a1_0 = { 0, { } };\n+\n+void ga1_0_ ()\n+{\n+  a1_0.a[0] = 0;\n+  a1_0.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_0.a[2] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+A1 a1_1 = { 0, { 1 } };\n+\n+void ga1_1 ()\n+{\n+  a1_1.a[0] = 0;\n+  a1_1.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_1.a[2] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga1p (A1 *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;\n+  p->a[9] = 0;\n+}\n+\n+\n+// Verify warning for an extern struct object.  Similar to the zero-length\n+// array case, a one-element trailing array can be initialized to at most\n+// a single element.\n+extern A1 a1x;\n+\n+void ga1x ()\n+{\n+  a1x.a[0] = 0;\n+  a1x.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1x.a[9] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Exercise interior one-element array members (verify they're not\n+// treated as trailing.\n+\n+struct A1i\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object declared here\" }\n+  char x;\n+};\n+\n+// Verify warning for a definition with no initializer.\n+A1i a1i_;\n+\n+void ga1i_ ()\n+{\n+  a1i_.a[0] = 0;\n+  a1i_.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_.a[2] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+A1i a1i__ = { 0 };\n+\n+void ga1i__ ()\n+{\n+  a1i__.a[0] = 0;\n+  a1i__.a[1] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i__.a[2] = 0;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+A1 a1i_0 = { 0, { } };\n+\n+void ga1i_0_ ()\n+{\n+  a1i_0.a[0] = 0;\n+  a1i_0.a[1] = 0;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_0.a[2] = 0;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+A1 a1i_1 = { 0, { 1 } };\n+\n+void ga1i_1 ()\n+{\n+  a1i_1.a[0] = 0;\n+  a1i_1.a[1] = 0;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_1.a[2] = 0;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify no warning for an unknown struct object.\n+void ga1ip (A1i *p)\n+{\n+  p->a[0] = 0;\n+  p->a[3] = 0;                  // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  p->a[9] = 0;                  // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify no warning for an extern struct object.\n+extern A1i a1ix;\n+\n+void ga1ix ()\n+{\n+  a1ix.a[0] = 0;\n+  a1ix.a[3] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1ix.a[9] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+// Verify non-POD classes with flexible array members.\n+\n+struct Bx\n+{\n+  char n;\n+  char a[];                     // { dg-message \"destination object declared here\" }\n+\n+  // Verify the warning for a constant.\n+  Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  // And also for a non-constant.  Regardless of the subscript, the array\n+  // of the object in function gxi() below has a zero size.\n+  Bx (int i) { a[i] = 0; }      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+};\n+\n+void gbx (void)\n+{\n+  struct Bx bx;\n+  sink (&bx);\n+}\n+\n+void gbxi (int i)\n+{\n+  struct Bx bxi (i);\n+  sink (&bxi);\n+}\n+\n+struct B0\n+{\n+  char n;\n+  char a[0];                    // { dg-message \"destination object declared here\" }\n+\n+  B0 () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+};\n+\n+\n+void gb0 (void)\n+{\n+  struct B0 b0;\n+  sink (&b0);\n+}\n+\n+\n+struct B1\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object declared here\" }\n+\n+  B1 () { a[1] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+};\n+\n+void gb1 (void)\n+{\n+  struct B1 b1;\n+  sink (&b1);\n+}\n+\n+\n+struct B123\n+{\n+  char a[123];                  // { dg-message \"destination object declared here\" }\n+\n+  B123 () { a[123] = 0; }       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+};\n+\n+void gb123 (void)\n+{\n+  struct B123 b123;\n+  sink (&b123);\n+}\n+\n+\n+struct B234\n+{\n+  char a[234];                  // { dg-message \"destination object declared here\" }\n+\n+  B234 (int i) { a[i] = 0; }    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+};\n+\n+void g234 (void)\n+{\n+  struct B234 b234 (234);\n+  sink (&b234);\n+}"}, {"sha": "12f8f9d353b3b38d838be82cd16d22e59ae8443c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-15.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-15.c?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -0,0 +1,62 @@\n+/* PR middle-end/91458 - inconsistent warning for writing past the end\n+   of an array member\n+   Verify that the -Wstringop-overflow detection doesn't cause an ICE\n+   for either kind of VLAs (member and non-member).\n+   Diagnosing the accesses is the subject of pr82608.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+void sink (void*);\n+\n+void vla_unbounded (int n)\n+{\n+  char a[n];\n+\n+  a[0] = 0;\n+  a[1] = 1;\n+  a[n] = n;         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+\n+  sink (&a);\n+}\n+\n+void vla_bounded (int n)\n+{\n+  if (n > 32)\n+    n = 32;\n+\n+  char a[n];\n+\n+  a[0] = 0;\n+  a[1] = 1;\n+  a[n] = n;         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+  a[69] = n;        // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+\n+  sink (&a);\n+}\n+\n+\n+void member_vla_unbounded (int n)\n+{\n+  struct S { char i, a[n]; } s;\n+\n+  s.a[0] = 0;\n+  s.a[1] = 1;\n+  s.a[n] = n;       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+\n+  sink (&s);\n+}\n+\n+void member_vla_bounded (int n)\n+{\n+  if (n > 32)\n+    n = 32;\n+\n+  struct S { char i, a[n]; } s;\n+\n+  s.a[0] = 0;\n+  s.a[1] = 1;\n+  s.a[n] = n;       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+  s.a[69] = n;      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr82608\" { xfail *-*-* } }\n+\n+  sink (&s);\n+}"}, {"sha": "7bb5f52c1e5dded6a3e81a4086e4e3e79cef469d", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -4026,16 +4026,30 @@ handle_store (gimple_stmt_iterator *gsi)\n       rhs_minlen = lenrange[0];\n       storing_nonzero_p = lenrange[1] > 0;\n \n-      if (tree dstsize = compute_objsize (lhs, 1))\n-\tif (compare_tree_int (dstsize, lenrange[2]) < 0)\n-\t  {\n-\t    location_t loc = gimple_nonartificial_location (stmt);\n-\t    warning_n (loc, OPT_Wstringop_overflow_,\n-\t\t       lenrange[2],\n-\t\t       \"%Gwriting %u byte into a region of size %E\",\n-\t\t       \"%Gwriting %u bytes into a region of size %E\",\n-\t\t       stmt, lenrange[2], dstsize);\n-\t  }\n+      /* Avoid issuing multiple warnings for the same LHS or statement.\n+\t For example, -Warray-bounds may have already been issued for\n+\t an out-of-bounds subscript.  */\n+      if (!TREE_NO_WARNING (lhs) && !gimple_no_warning_p (stmt))\n+\t{\n+\t  /* Set to the declaration referenced by LHS (if known).  */\n+\t  tree decl = NULL_TREE;\n+\t  if (tree dstsize = compute_objsize (lhs, 1, &decl))\n+\t    if (compare_tree_int (dstsize, lenrange[2]) < 0)\n+\t      {\n+\t\tlocation_t loc = gimple_nonartificial_location (stmt);\n+\t\tif (warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t\t       lenrange[2],\n+\t\t\t       \"%Gwriting %u byte into a region of size %E\",\n+\t\t\t       \"%Gwriting %u bytes into a region of size %E\",\n+\t\t\t       stmt, lenrange[2], dstsize))\n+\t\t  {\n+\t\t    if (decl)\n+\t\t      inform (DECL_SOURCE_LOCATION (decl),\n+\t\t\t      \"destination object declared here\");\n+\t\t    gimple_set_no_warning (stmt, true);\n+\t\t  }\n+\t      }\n+\t}\n     }\n   else\n     {"}, {"sha": "c95b5ade781e6c512a8f3e9621a5fa857306eede", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464969eb9b47eb2f24403c74c16769a58dbaa638/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=464969eb9b47eb2f24403c74c16769a58dbaa638", "patch": "@@ -4388,8 +4388,8 @@ class vrp_prop : public ssa_propagation_engine\n   void vrp_initialize (void);\n   void vrp_finalize (bool);\n   void check_all_array_refs (void);\n-  void check_array_ref (location_t, tree, bool);\n-  void check_mem_ref (location_t, tree, bool);\n+  bool check_array_ref (location_t, tree, bool);\n+  bool check_mem_ref (location_t, tree, bool);\n   void search_for_addr_array (tree, location_t);\n \n   class vr_values vr_values;\n@@ -4415,9 +4415,10 @@ class vrp_prop : public ssa_propagation_engine\n    array subscript is a constant, check if it is outside valid\n    range. If the array subscript is a RANGE, warn if it is\n    non-overlapping with valid range.\n-   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n+   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.\n+   Returns true if a warning has been issued.  */\n \n-void\n+bool\n vrp_prop::check_array_ref (location_t location, tree ref,\n \t\t\t   bool ignore_off_by_one)\n {\n@@ -4426,7 +4427,7 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n   tree low_bound, up_bound, up_bound_p1;\n \n   if (TREE_NO_WARNING (ref))\n-    return;\n+    return false;\n \n   low_sub = up_sub = TREE_OPERAND (ref, 1);\n   up_bound = array_ref_up_bound (ref);\n@@ -4541,12 +4542,16 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n   if (warned)\n     {\n       ref = TREE_OPERAND (ref, 0);\n+      if (TREE_CODE (ref) == COMPONENT_REF)\n+\tref = TREE_OPERAND (ref, 1);\n \n       if (DECL_P (ref))\n \tinform (DECL_SOURCE_LOCATION (ref), \"while referencing %qD\", ref);\n \n       TREE_NO_WARNING (ref) = 1;\n     }\n+\n+  return warned;\n }\n \n /* Checks one MEM_REF in REF, located at LOCATION, for out-of-bounds\n@@ -4556,14 +4561,15 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n    with valid range.\n    IGNORE_OFF_BY_ONE is true if the MEM_REF is inside an ADDR_EXPR\n    (used to allow one-past-the-end indices for code that takes\n-   the address of the just-past-the-end element of an array).  */\n+   the address of the just-past-the-end element of an array).\n+   Returns true if a warning has been issued.  */\n \n-void\n+bool\n vrp_prop::check_mem_ref (location_t location, tree ref,\n \t\t\t bool ignore_off_by_one)\n {\n   if (TREE_NO_WARNING (ref))\n-    return;\n+    return false;\n \n   tree arg = TREE_OPERAND (ref, 0);\n   /* The constant and variable offset of the reference.  */\n@@ -4615,7 +4621,7 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n \t  continue;\n \t}\n       else\n-\treturn;\n+\treturn false;\n \n       /* VAROFF should always be a SSA_NAME here (and not even\n \t INTEGER_CST) but there's no point in taking chances.  */\n@@ -4677,10 +4683,10 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n       arg = TREE_OPERAND (arg, 0);\n       if (TREE_CODE (arg) != STRING_CST\n \t  && TREE_CODE (arg) != VAR_DECL)\n-\treturn;\n+\treturn false;\n     }\n   else\n-    return;\n+    return false;\n \n   /* The type of the object being referred to.  It can be an array,\n      string literal, or a non-array type when the MEM_REF represents\n@@ -4695,7 +4701,7 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n       || !COMPLETE_TYPE_P (reftype)\n       || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST\n       || RECORD_OR_UNION_TYPE_P (reftype))\n-    return;\n+    return false;\n \n   offset_int eltsize;\n   if (TREE_CODE (reftype) == ARRAY_TYPE)\n@@ -4797,11 +4803,11 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n \n       if (warned)\n \tTREE_NO_WARNING (ref) = 1;\n-      return;\n+      return warned;\n     }\n \n   if (warn_array_bounds < 2)\n-    return;\n+    return false;\n \n   /* At level 2 check also intermediate offsets.  */\n   int i = 0;\n@@ -4812,8 +4818,13 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n       if (warning_at (location, OPT_Warray_bounds,\n \t\t      \"intermediate array offset %wi is outside array bounds \"\n \t\t      \"of %qT\", tmpidx, reftype))\n-\tTREE_NO_WARNING (ref) = 1;\n+\t{\n+\t  TREE_NO_WARNING (ref) = 1;\n+\t  return true;\n+\t}\n     }\n+\n+  return false;\n }\n \n /* Searches if the expr T, located at LOCATION computes\n@@ -4825,10 +4836,14 @@ vrp_prop::search_for_addr_array (tree t, location_t location)\n   /* Check each ARRAY_REF and MEM_REF in the reference chain. */\n   do\n     {\n+      bool warned = false;\n       if (TREE_CODE (t) == ARRAY_REF)\n-\tcheck_array_ref (location, t, true /*ignore_off_by_one*/);\n+\twarned = check_array_ref (location, t, true /*ignore_off_by_one*/);\n       else if (TREE_CODE (t) == MEM_REF)\n-\tcheck_mem_ref (location, t, true /*ignore_off_by_one*/);\n+\twarned = check_mem_ref (location, t, true /*ignore_off_by_one*/);\n+\n+      if (warned)\n+\tTREE_NO_WARNING (t) = true;\n \n       t = TREE_OPERAND (t, 0);\n     }\n@@ -4920,16 +4935,20 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n \n   *walk_subtree = TRUE;\n \n+  bool warned = false;\n   vrp_prop *vrp_prop = (class vrp_prop *)wi->info;\n   if (TREE_CODE (t) == ARRAY_REF)\n-    vrp_prop->check_array_ref (location, t, false /*ignore_off_by_one*/);\n+    warned = vrp_prop->check_array_ref (location, t, false/*ignore_off_by_one*/);\n   else if (TREE_CODE (t) == MEM_REF)\n-    vrp_prop->check_mem_ref (location, t, false /*ignore_off_by_one*/);\n+    warned = vrp_prop->check_mem_ref (location, t, false /*ignore_off_by_one*/);\n   else if (TREE_CODE (t) == ADDR_EXPR)\n     {\n       vrp_prop->search_for_addr_array (t, location);\n       *walk_subtree = FALSE;\n     }\n+  /* Propagate the no-warning bit to the outer expression.  */\n+  if (warned)\n+    TREE_NO_WARNING (t) = true;\n \n   return NULL_TREE;\n }"}]}