{"sha": "870ca331280a56f4dc9499d0046594b9bd63e7c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwY2EzMzEyODBhNTZmNGRjOTQ5OWQwMDQ2NTk0YjliZDYzZTdjNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-01-09T15:10:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-01-09T15:10:43Z"}, "message": "re PR tree-optimization/55875 (IVopts caused miscompilation)\n\n\tPR tree-optimiation/55875\n\t* gcc.c-torture/execute/pr55875.c: New testcase.\n\t* g++.dg/torture/pr55875.C: New testcase.\n\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Add\n\tEVERY_ITERATION parameter.\n\t(number_of_iterations_exit): Check if exit is executed every\n\titeration.\n\t(idx_infer_loop_bounds): Similarly here.\n\t(n_of_executions_at_most): Simplify\n\tto only test for cases where statement is dominated by the\n\tparticular bound; handle correctly the \"postdominance\"\n\ttest.\n\t(scev_probably_wraps_p): Use max loop iterations info\n\tas a global bound first.\n\nFrom-SVN: r195054", "tree": {"sha": "fa91e2ed4dc3c3cbb1c733cf42692146e63b1edd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa91e2ed4dc3c3cbb1c733cf42692146e63b1edd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/870ca331280a56f4dc9499d0046594b9bd63e7c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870ca331280a56f4dc9499d0046594b9bd63e7c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870ca331280a56f4dc9499d0046594b9bd63e7c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870ca331280a56f4dc9499d0046594b9bd63e7c4/comments", "author": null, "committer": null, "parents": [{"sha": "3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cd232b5aafa8b8563d3bbe4b4e240eea6b93036"}], "stats": {"total": 209, "additions": 178, "deletions": 31}, "files": [{"sha": "01fb93c5cb5ad971e8563435a199f68022d47bd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=870ca331280a56f4dc9499d0046594b9bd63e7c4", "patch": "@@ -1,3 +1,18 @@\n+2013-01-09  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimiation/55875\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Add\n+\tEVERY_ITERATION parameter.\n+\t(number_of_iterations_exit): Check if exit is executed every\n+\titeration.\n+\t(idx_infer_loop_bounds): Similarly here.\n+\t(n_of_executions_at_most): Simplify\n+\tto only test for cases where statement is dominated by the\n+\tparticular bound; handle correctly the \"postdominance\"\n+\ttest.\n+\t(scev_probably_wraps_p): Use max loop iterations info\n+\tas a global bound first.\n+\n 2013-01-09  Nguyen Duy Dat\n \t    Nick Clifton  <nickc@redhat.com>\n "}, {"sha": "74d7ea46d404d78b78d177fbb7a38f7894412bcf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=870ca331280a56f4dc9499d0046594b9bd63e7c4", "patch": "@@ -1,3 +1,9 @@\n+2013-01-09  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimiation/55875\n+\t* gcc.c-torture/execute/pr55875.c: New testcase.\n+\t* g++.dg/torture/pr55875.C: New testcase.\n+\n 2013-01-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/48418"}, {"sha": "faadf88f49545b8e26ea6ba5159b63d61c5aae13", "filename": "gcc/testsuite/g++.dg/torture/pr55875.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr55875.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr55875.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr55875.C?ref=870ca331280a56f4dc9499d0046594b9bd63e7c4", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run }\n+\n+struct A\n+{\n+  short int a1;\n+  unsigned char a2;\n+  unsigned int a3;\n+};\n+\n+struct B\n+{\n+  unsigned short b1;\n+  const A *b2;\n+};\n+\n+B b;\n+\n+__attribute__((noinline, noclone))\n+int foo (unsigned x)\n+{\n+  __asm volatile (\"\" : \"+r\" (x) : : \"memory\");\n+  return x;\n+}\n+\n+inline void\n+bar (const int &)\n+{\n+}\n+\n+__attribute__((noinline)) void\n+baz ()\n+{\n+  const A *a = b.b2;\n+  unsigned int i;\n+  unsigned short n = b.b1;\n+  for (i = 0; i < n; ++i)\n+    if (a[i].a1 == 11)\n+      {\n+    if (i > 0 && (a[i - 1].a2 & 1))\n+      continue;\n+    bar (foo (2));\n+    return;\n+      }\n+}\n+\n+int\n+main ()\n+{\n+  A a[4] = { { 10, 0, 0 }, { 11, 1, 0 }, { 11, 1, 0 }, { 11, 1, 0 } };\n+  b.b1 = 4;\n+  b.b2 = a;\n+  baz ();\n+  return 0;\n+}\n+"}, {"sha": "4a0ce1b1bc1a8c76214f929d059ee0b8ddb3ef10", "filename": "gcc/testsuite/gcc.c-torture/execute/pr55875.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr55875.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr55875.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr55875.c?ref=870ca331280a56f4dc9499d0046594b9bd63e7c4", "patch": "@@ -0,0 +1,17 @@\n+int a[250];\n+__attribute__ ((noinline))\n+t(int i)\n+{\n+  if (i==0)\n+    exit(0);\n+  if (i>255)\n+    abort ();\n+}\n+main()\n+{\n+  unsigned int i;\n+  for (i=0;;i++)\n+    {\n+      a[i]=t((unsigned char)(i+5));\n+    }\n+}"}, {"sha": "fe2bbc1b057da8ad2b9494c5fa40b82d8d8fa31f", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 85, "deletions": 31, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/870ca331280a56f4dc9499d0046594b9bd63e7c4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=870ca331280a56f4dc9499d0046594b9bd63e7c4", "patch": "@@ -1208,6 +1208,8 @@ dump_affine_iv (FILE *file, affine_iv *iv)\n    -- in this case we can use the information whether the control induction\n    variables can overflow or not in a more efficient way.\n \n+   if EVERY_ITERATION is true, we know the test is executed on every iteration.\n+\n    The results (number of iterations and assumptions as described in\n    comments at struct tree_niter_desc in tree-flow.h) are stored to NITER.\n    Returns false if it fails to determine number of iterations, true if it\n@@ -1217,11 +1219,21 @@ static bool\n number_of_iterations_cond (struct loop *loop,\n \t\t\t   tree type, affine_iv *iv0, enum tree_code code,\n \t\t\t   affine_iv *iv1, struct tree_niter_desc *niter,\n-\t\t\t   bool only_exit)\n+\t\t\t   bool only_exit, bool every_iteration)\n {\n   bool exit_must_be_taken = false, ret;\n   bounds bnds;\n \n+  /* If the test is not executed every iteration, wrapping may make the test\n+     to pass again. \n+     TODO: the overflow case can be still used as unreliable estimate of upper\n+     bound.  But we have no API to pass it down to number of iterations code\n+     and, at present, it will not use it anyway.  */\n+  if (!every_iteration\n+      && (!iv0->no_overflow || !iv1->no_overflow\n+\t  || code == NE_EXPR || code == EQ_EXPR))\n+    return false;\n+\n   /* The meaning of these assumptions is this:\n      if !assumptions\n        then the rest of information does not have to be valid\n@@ -1807,9 +1819,11 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   tree op0, op1;\n   enum tree_code code;\n   affine_iv iv0, iv1;\n+  bool safe;\n \n-  if (every_iteration\n-      && !dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src))\n+  safe = dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src);\n+\n+  if (every_iteration && !safe)\n     return false;\n \n   niter->assumptions = boolean_false_node;\n@@ -1826,9 +1840,9 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n     {\n     case GT_EXPR:\n     case GE_EXPR:\n-    case NE_EXPR:\n     case LT_EXPR:\n     case LE_EXPR:\n+    case NE_EXPR:\n       break;\n \n     default:\n@@ -1855,7 +1869,7 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   iv0.base = expand_simple_operations (iv0.base);\n   iv1.base = expand_simple_operations (iv1.base);\n   if (!number_of_iterations_cond (loop, type, &iv0, code, &iv1, niter,\n-\t\t\t\t  loop_only_exit_p (loop, exit)))\n+\t\t\t\t  loop_only_exit_p (loop, exit), safe))\n     {\n       fold_undefer_and_ignore_overflow_warnings ();\n       return false;\n@@ -2657,6 +2671,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   tree low, high, type, next;\n   bool sign, upper = true, at_end = false;\n   struct loop *loop = data->loop;\n+  bool reliable = true;\n \n   if (TREE_CODE (base) != ARRAY_REF)\n     return true;\n@@ -2728,7 +2743,14 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n       && tree_int_cst_compare (next, high) <= 0)\n     return true;\n \n-  record_nonwrapping_iv (loop, init, step, data->stmt, low, high, true, upper);\n+  /* If access is not executed on every iteration, we must ensure that overlow may\n+     not make the access valid later.  */\n+  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, gimple_bb (data->stmt))\n+      && scev_probably_wraps_p (initial_condition_in_loop_num (ev, loop->num),\n+\t\t\t\tstep, data->stmt, loop, true))\n+    reliable = false;\n+\n+  record_nonwrapping_iv (loop, init, step, data->stmt, low, high, reliable, upper);\n   return true;\n }\n \n@@ -3549,8 +3571,15 @@ stmt_dominates_stmt_p (gimple s1, gimple s2)\n /* Returns true when we can prove that the number of executions of\n    STMT in the loop is at most NITER, according to the bound on\n    the number of executions of the statement NITER_BOUND->stmt recorded in\n-   NITER_BOUND.  If STMT is NULL, we must prove this bound for all\n-   statements in the loop.  */\n+   NITER_BOUND and fact that NITER_BOUND->stmt dominate STMT.\n+\n+   ??? This code can become quite a CPU hog - we can have many bounds,\n+   and large basic block forcing stmt_dominates_stmt_p to be queried\n+   many times on a large basic blocks, so the whole thing is O(n^2)\n+   for scev_probably_wraps_p invocation (that can be done n times).\n+\n+   It would make more sense (and give better answers) to remember BB\n+   bounds computed by discover_iteration_bound_by_body_walk.  */\n \n static bool\n n_of_executions_at_most (gimple stmt,\n@@ -3571,32 +3600,43 @@ n_of_executions_at_most (gimple stmt,\n   /* We know that NITER_BOUND->stmt is executed at most NITER_BOUND->bound + 1\n      times.  This means that:\n \n-     -- if NITER_BOUND->is_exit is true, then everything before\n-        NITER_BOUND->stmt is executed at most NITER_BOUND->bound + 1\n-\ttimes, and everything after it at most NITER_BOUND->bound times.\n+     -- if NITER_BOUND->is_exit is true, then everything after\n+\tit at most NITER_BOUND->bound times.\n \n      -- If NITER_BOUND->is_exit is false, then if we can prove that when STMT\n \tis executed, then NITER_BOUND->stmt is executed as well in the same\n-\titeration (we conclude that if both statements belong to the same\n-\tbasic block, or if STMT is after NITER_BOUND->stmt), then STMT\n-\tis executed at most NITER_BOUND->bound + 1 times.  Otherwise STMT is\n-\texecuted at most NITER_BOUND->bound + 2 times.  */\n+\titeration then STMT is executed at most NITER_BOUND->bound + 1 times. \n+\n+\tIf we can determine that NITER_BOUND->stmt is always executed\n+\tafter STMT, then STMT is executed at most NITER_BOUND->bound + 2 times.\n+\tWe conclude that if both statements belong to the same\n+\tbasic block and STMT is before NITER_BOUND->stmt and there are no\n+\tstatements with side effects in between.  */\n \n   if (niter_bound->is_exit)\n     {\n-      if (stmt\n-\t  && stmt != niter_bound->stmt\n-\t  && stmt_dominates_stmt_p (niter_bound->stmt, stmt))\n-\tcmp = GE_EXPR;\n-      else\n-\tcmp = GT_EXPR;\n+      if (stmt == niter_bound->stmt\n+\t  || !stmt_dominates_stmt_p (niter_bound->stmt, stmt))\n+\treturn false;\n+      cmp = GE_EXPR;\n     }\n   else\n     {\n-      if (!stmt\n-\t  || (gimple_bb (stmt) != gimple_bb (niter_bound->stmt)\n-\t      && !stmt_dominates_stmt_p (niter_bound->stmt, stmt)))\n+      if (!stmt_dominates_stmt_p (niter_bound->stmt, stmt))\n \t{\n+          gimple_stmt_iterator bsi;\n+\t  if (gimple_bb (stmt) != gimple_bb (niter_bound->stmt)\n+\t      || gimple_code (stmt) == GIMPLE_PHI\n+\t      || gimple_code (niter_bound->stmt) == GIMPLE_PHI)\n+\t    return false;\n+\n+\t  /* By stmt_dominates_stmt_p we already know that STMT appears\n+\t     before NITER_BOUND->STMT.  Still need to test that the loop\n+\t     can not be terinated by a side effect in between.  */\n+\t  for (bsi = gsi_for_stmt (stmt); gsi_stmt (bsi) != niter_bound->stmt;\n+\t       gsi_next (&bsi))\n+\t    if (gimple_has_side_effects (gsi_stmt (bsi)))\n+\t       return false;\n \t  bound += double_int_one;\n \t  if (bound.is_zero ()\n \t      || !double_int_fits_to_tree_p (nit_type, bound))\n@@ -3640,10 +3680,12 @@ scev_probably_wraps_p (tree base, tree step,\n \t\t       gimple at_stmt, struct loop *loop,\n \t\t       bool use_overflow_semantics)\n {\n-  struct nb_iter_bound *bound;\n   tree delta, step_abs;\n   tree unsigned_type, valid_niter;\n   tree type = TREE_TYPE (step);\n+  tree e;\n+  double_int niter;\n+  struct nb_iter_bound *bound;\n \n   /* FIXME: We really need something like\n      http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html.\n@@ -3706,14 +3748,26 @@ scev_probably_wraps_p (tree base, tree step,\n   valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);\n \n   estimate_numbers_of_iterations_loop (loop);\n-  for (bound = loop->bounds; bound; bound = bound->next)\n+\n+  if (max_loop_iterations (loop, &niter)\n+      && double_int_fits_to_tree_p (TREE_TYPE (valid_niter), niter)\n+      && (e = fold_binary (GT_EXPR, boolean_type_node, valid_niter,\n+\t\t\t   double_int_to_tree (TREE_TYPE (valid_niter),\n+\t\t\t\t\t       niter))) != NULL\n+      && integer_nonzerop (e))\n     {\n-      if (n_of_executions_at_most (at_stmt, bound, valid_niter))\n-\t{\n-\t  fold_undefer_and_ignore_overflow_warnings ();\n-\t  return false;\n-\t}\n+      fold_undefer_and_ignore_overflow_warnings ();\n+      return false;\n     }\n+  if (at_stmt)\n+    for (bound = loop->bounds; bound; bound = bound->next)\n+      {\n+\tif (n_of_executions_at_most (at_stmt, bound, valid_niter))\n+\t  {\n+\t    fold_undefer_and_ignore_overflow_warnings ();\n+\t    return false;\n+\t  }\n+      }\n \n   fold_undefer_and_ignore_overflow_warnings ();\n "}]}