{"sha": "a3a4f6be0c7ac1536c4d1def14217840b04dd488", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhNGY2YmUwYzdhYzE1MzZjNGQxZGVmMTQyMTc4NDBiMDRkZDQ4OA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-20T22:34:00Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-20T22:34:00Z"}, "message": "c++: Recursive unification with packs and explicit targs [PR94628]\n\nThis PR seems to be similar to PR c++/43382, except that the recursive call to\nthe variadic function with trailing return type in this testcase is additionally\ngiven some explicit template arguments.\n\nIn the first testcase below, when resolving the recursive call to 'select',\nfn_type_unification first substitutes in the call's explicit template arguments\nbefore doing unification, and so during this substitution the template argument\npack for Args is incomplete.\n\nSince the pack is incomplete, the substitution of 'args...' in the trailing\nreturn type decltype(f(args...)) is handled by the unsubstituted_packs case of\ntsubst_pack_expansion.  But the handling of this case happens _before_ we reset\nlocal_specializations, and so the substitution ends up reusing the old binding\nfor 'args' from local_specializations rather than building a new one.\n\nThis patch fixes this issue by setting up local_specializations sooner in\ntsubst_pack_expansion, before the handling of the unsubstituted_packs case.\nIt also adds a new policy to local_specialization_stack so that we could use the\nclass here to conditionally replace local_specializations.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94628\n\t* cp-tree.h (lss_policy::lss_nop): New enumerator.\n\t* pt.c (local_specialization_stack::local_specialization_stack): Handle\n\tan lss_nop policy.\n\t(local_specialization_stack::~local_specialization_stack): Likewise.\n\t(tsubst_pack_expansion): Use a local_specialization_stack instead of\n\tmanually saving and restoring local_specializations.  Conditionally\n\treplace local_specializations sooner, before the handling of the\n\tunsubstituted_packs case.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94628\n\t* g++.dg/cpp0x/variadic179.C: New test.\n\t* g++.dg/cpp0x/variadic180.C: New test.", "tree": {"sha": "37f4719987f10bc9a7e8eb93b53b3b75a09f18d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37f4719987f10bc9a7e8eb93b53b3b75a09f18d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a4f6be0c7ac1536c4d1def14217840b04dd488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a4f6be0c7ac1536c4d1def14217840b04dd488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a4f6be0c7ac1536c4d1def14217840b04dd488", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a4f6be0c7ac1536c4d1def14217840b04dd488/comments", "author": null, "committer": null, "parents": [{"sha": "58d4cf217dab69f64e6cf779fc6be8ef2837afe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d4cf217dab69f64e6cf779fc6be8ef2837afe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58d4cf217dab69f64e6cf779fc6be8ef2837afe6"}], "stats": {"total": 99, "additions": 77, "deletions": 22}, "files": [{"sha": "797984bcaa2922bd08921091409de9c33f40ef8a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a3a4f6be0c7ac1536c4d1def14217840b04dd488", "patch": "@@ -1,3 +1,15 @@\n+2020-04-20  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94628\n+\t* cp-tree.h (lss_policy::lss_nop): New enumerator.\n+\t* pt.c (local_specialization_stack::local_specialization_stack): Handle\n+\tan lss_nop policy.\n+\t(local_specialization_stack::~local_specialization_stack): Likewise.\n+\t(tsubst_pack_expansion): Use a local_specialization_stack instead of\n+\tmanually saving and restoring local_specializations.  Conditionally\n+\treplace local_specializations sooner, before the handling of the\n+\tunsubstituted_packs case.\n+\n 2020-04-20  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94505 - bogus -Wparentheses warning with fold-expression."}, {"sha": "0b62a775c1bf0dfc524b2682f5642a43f1cf772e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a3a4f6be0c7ac1536c4d1def14217840b04dd488", "patch": "@@ -5421,7 +5421,7 @@ enum unification_kind_t {\n // An RAII class used to create a new pointer map for local\n // specializations. When the stack goes out of scope, the\n // previous pointer map is restored.\n-enum lss_policy { lss_blank, lss_copy };\n+enum lss_policy { lss_blank, lss_copy, lss_nop };\n class local_specialization_stack\n {\n public:"}, {"sha": "cd6392aca222a2f8c065933598faca87a04e431f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a3a4f6be0c7ac1536c4d1def14217840b04dd488", "patch": "@@ -83,16 +83,21 @@ static tree cur_stmt_expr;\n local_specialization_stack::local_specialization_stack (lss_policy policy)\n   : saved (local_specializations)\n {\n-  if (policy == lss_blank || !saved)\n+  if (policy == lss_nop)\n+    ;\n+  else if (policy == lss_blank || !saved)\n     local_specializations = new hash_map<tree, tree>;\n   else\n     local_specializations = new hash_map<tree, tree>(*saved);\n }\n \n local_specialization_stack::~local_specialization_stack ()\n {\n-  delete local_specializations;\n-  local_specializations = saved;\n+  if (local_specializations != saved)\n+    {\n+      delete local_specializations;\n+      local_specializations = saved;\n+    }\n }\n \n /* True if we've recursed into fn_type_unification too many times.  */\n@@ -12718,7 +12723,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n   bool unsubstituted_fn_pack = false;\n   int i, len = -1;\n   tree result;\n-  hash_map<tree, tree> *saved_local_specializations = NULL;\n   bool need_local_specializations = false;\n   int levels;\n \n@@ -12917,7 +12921,15 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t= build_extra_args (pattern, args, complain);\n       return t;\n     }\n-  else if (unsubstituted_packs)\n+\n+  /* If NEED_LOCAL_SPECIALIZATIONS then we're in a late-specified return\n+     type, so create our own local specializations map; the current map is\n+     either NULL or (in the case of recursive unification) might have\n+     bindings that we don't want to use or alter.  */\n+  local_specialization_stack lss (need_local_specializations\n+\t\t\t\t  ? lss_blank : lss_nop);\n+\n+  if (unsubstituted_packs)\n     {\n       /* There were no real arguments, we're just replacing a parameter\n \t pack with another version of itself. Substitute into the\n@@ -12934,16 +12946,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \n   gcc_assert (len >= 0);\n \n-  if (need_local_specializations)\n-    {\n-      /* We're in a late-specified return type, so create our own local\n-\t specializations map; the current map is either NULL or (in the\n-\t case of recursive unification) might have bindings that we don't\n-\t want to use or alter.  */\n-      saved_local_specializations = local_specializations;\n-      local_specializations = new hash_map<tree, tree>;\n-    }\n-\n   /* For each argument in each argument pack, substitute into the\n      pattern.  */\n   result = make_tree_vec (len);\n@@ -12990,12 +12992,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n         }\n     }\n \n-  if (need_local_specializations)\n-    {\n-      delete local_specializations;\n-      local_specializations = saved_local_specializations;\n-    }\n-\n   /* If the dependent pack arguments were such that we end up with only a\n      single pack expansion again, there's no need to keep it in a TREE_VEC.  */\n   if (len == 1 && TREE_CODE (result) == TREE_VEC"}, {"sha": "813f94c7de0b8b35c5cb2c92b03d5b3fe4ea1bbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3a4f6be0c7ac1536c4d1def14217840b04dd488", "patch": "@@ -1,3 +1,9 @@\n+2020-04-20  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94628\n+\t* g++.dg/cpp0x/variadic179.C: New test.\n+\t* g++.dg/cpp0x/variadic180.C: New test.\n+\n 2020-04-20  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94505 - bogus -Wparentheses warning with fold-expression."}, {"sha": "f04d3f753ca3f34e2c43793734349c2da31aad28", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic179.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic179.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic179.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic179.C?ref=a3a4f6be0c7ac1536c4d1def14217840b04dd488", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/94628\n+// { dg-do compile { target c++11 } }\n+\n+int f(int, int);\n+int f(int);\n+\n+template<class...Args>\n+auto select(Args... args) -> decltype(f(args...))\n+{\n+  if (sizeof...(Args) > 1)\n+    return select<char>(7);\n+  else\n+    return 0;\n+}\n+\n+int a = select(0, 1);"}, {"sha": "0dd0f88d6ecc64c40bb5e06928402b8fbd6ffdd3", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic180.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic180.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a4f6be0c7ac1536c4d1def14217840b04dd488/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic180.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic180.C?ref=a3a4f6be0c7ac1536c4d1def14217840b04dd488", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/94628\n+// A variant of variadic101.C where the recursive call to deref\n+// has its first template argument explicitly provided.\n+// { dg-do compile { target c++11 } }\n+\n+template<class T>\n+struct Container\n+{ T f() const; };\n+\n+template<class T>\n+T deref(const T& t)\n+{ return t; }\n+\n+\n+template <class T, class... Args>\n+auto\n+deref(const T& u, int r, Args... args)\n+-> decltype(deref(u.f(), args...))\n+{ return deref<decltype(u.f())>(u.f(), args...); }\n+\n+int main(void)\n+{\n+    Container<Container<int>> v;\n+    deref(v,1,2);\n+}"}]}