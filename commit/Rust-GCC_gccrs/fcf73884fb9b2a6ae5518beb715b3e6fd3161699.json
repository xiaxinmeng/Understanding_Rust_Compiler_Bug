{"sha": "fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNmNzM4ODRmYjliMmE2YWU1NTE4YmViNzE1YjNlNmZkMzE2MTY5OQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-07-23T15:57:49Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-07-23T15:57:49Z"}, "message": "re PR c/35058 (-Werror= works only with some warnings)\n\n2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\tPR 35058\n\t* diagnostic.c (pedwarn): Add opt parameter.\n\t(pedwarn0): New.\n\t* c-tree.h (pedwarn_init): Add opt parameter.\n\t(pedwarn_c90): Likewise.\n\t(pedwarn_c99): Likewise.\n\t* c-errors.c (pedwarn_c99): Likewise.\n\t(pedwarn_c90): Likewise.\n\t* toplev.h (pedwarn): Update declaration.\n\t(pedwarn0): Declare.\n\t* c-lex.c: All calls to pedwarn changed.\n\t* builtins.c: All calls to pedwarn changed.\n\t* toplev.c: All calls to pedwarn changed.\n\t* c-decl.c: All calls to pedwarn changed.\n\t* c-typeck.c: All calls to pedwarn changed.\n\t* c-common.c: All calls to pedwarn changed.\n\t* c-parser.c: All calls to pedwarn changed.\ncp/\n\t* typeck.c: All calls to pedwarn changed.\n\t* decl.c: All calls to pedwarn changed.\n\t* call.c: All calls to pedwarn changed.\n\t* error.c: All calls to pedwarn changed.\n\t* typeck2.c: All calls to pedwarn changed.\n\t* pt.c: All calls to pedwarn changed.\n\t* name-lookup.c: All calls to pedwarn changed.\n\t* parser.c: All calls to pedwarn changed.\nfortran/\n\t* f95-lang.c (gfc_mark_addressable): All calls to pedwarn changed.\ntestsuite/\n\t* gcc.dg/Wdeclaration-after-statement-3.c: New.\n\t* gcc/testsuite/gcc.dg/Wpointer-arith.c: New.\n\nFrom-SVN: r138089", "tree": {"sha": "f00173dd9740a4ee5b51d4737ab407c93e441bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f00173dd9740a4ee5b51d4737ab407c93e441bcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/comments", "author": null, "committer": null, "parents": [{"sha": "554cd17b8d4df5ad1f58a68fdce3e9d8c5d56566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554cd17b8d4df5ad1f58a68fdce3e9d8c5d56566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554cd17b8d4df5ad1f58a68fdce3e9d8c5d56566"}], "stats": {"total": 887, "additions": 501, "deletions": 386}, "files": [{"sha": "3b93a7c36699c6a65c2e4caf81d3ef2eb15719cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -1,3 +1,23 @@\n+2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 35058\n+\t* diagnostic.c (pedwarn): Add opt parameter.\n+\t(pedwarn0): New.\n+\t* c-tree.h (pedwarn_init): Add opt parameter.\n+\t(pedwarn_c90): Likewise.\n+\t(pedwarn_c99): Likewise.\n+\t* c-errors.c (pedwarn_c99): Likewise.\n+\t(pedwarn_c90): Likewise.\n+\t* toplev.h (pedwarn): Update declaration.\n+\t(pedwarn0): Declare.\n+\t* c-lex.c: All calls to pedwarn changed.\n+\t* builtins.c: All calls to pedwarn changed.\n+\t* toplev.c: All calls to pedwarn changed.\n+\t* c-decl.c: All calls to pedwarn changed.\n+\t* c-typeck.c: All calls to pedwarn changed.\n+\t* c-common.c: All calls to pedwarn changed.\n+\t* c-parser.c: All calls to pedwarn changed.\n+\t\n 2008-07-23  Michael Meissner  <gnu@the-meissners.org>\n \t    Karthik Kumar  <karthikkumar@gmail.com>\n "}, {"sha": "b46cd266b39d27fdea07796364764d88e5be3294", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -7248,7 +7248,7 @@ fold_builtin_inf (tree type, int warn)\n      Thus we pedwarn to ensure this constraint violation is\n      diagnosed.  */\n   if (!MODE_HAS_INFINITIES (TYPE_MODE (type)) && warn)\n-    pedwarn (\"target format does not support infinity\");\n+    pedwarn (0, \"target format does not support infinity\");\n \n   real_inf (&real);\n   return build_real (type, real);"}, {"sha": "fbb5f88fac821cba7a72e641c11bb886cda82a32", "filename": "gcc/c-common.c", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -1047,7 +1047,7 @@ fname_decl (unsigned int rid, tree id)\n       input_location = saved_location;\n     }\n   if (!ix && !current_function_decl)\n-    pedwarn (\"%qD is not defined outside of function scope\", decl);\n+    pedwarn (0, \"%qD is not defined outside of function scope\", decl);\n \n   return decl;\n }\n@@ -1096,7 +1096,8 @@ fix_string_type (tree value)\n \t   separate the %d from the 'C'.  'ISO' should not be\n \t   translated, but it may be moved after 'C%d' in languages\n \t   where modifiers follow nouns.  */\n-\tpedwarn (\"string length %qd is greater than the length %qd \"\n+\tpedwarn (OPT_Woverlength_strings,\n+\t\t \"string length %qd is greater than the length %qd \"\n \t\t \"ISO C%d compilers are required to support\",\n \t\t nchars - 1, nchars_max, relevant_std);\n     }\n@@ -1143,7 +1144,7 @@ constant_expression_warning (tree value)\n \t  || TREE_CODE (value) == VECTOR_CST\n \t  || TREE_CODE (value) == COMPLEX_CST)\n       && TREE_OVERFLOW (value))\n-    pedwarn (\"overflow in constant expression\");\n+    pedwarn (OPT_Woverflow, \"overflow in constant expression\");\n }\n \n /* The same as above but print an unconditional error.  */\n@@ -1361,25 +1362,25 @@ check_main_parameter_types (tree decl)\n        {\n        case 1:\n          if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-           pedwarn (\"first argument of %q+D should be %<int%>\", decl);\n+           pedwarn (0, \"first argument of %q+D should be %<int%>\", decl);\n          break;\n \n        case 2:\n          if (TREE_CODE (type) != POINTER_TYPE\n              || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n              || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n                  != char_type_node))\n-           pedwarn (\"second argument of %q+D should be %<char **%>\",\n-                    decl);\n+           pedwarn (0, \"second argument of %q+D should be %<char **%>\",\n+\t\t     decl);\n          break;\n \n        case 3:\n          if (TREE_CODE (type) != POINTER_TYPE\n              || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n              || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n                  != char_type_node))\n-           pedwarn (\"third argument of %q+D should probably be \"\n-                    \"%<char **%>\", decl);\n+           pedwarn (0, \"third argument of %q+D should probably be \"\n+\t\t     \"%<char **%>\", decl);\n          break;\n        }\n    }\n@@ -1388,7 +1389,7 @@ check_main_parameter_types (tree decl)\n     argument because it's only mentioned in an appendix of the\n     standard.  */\n   if (argct > 0 && (argct < 2 || argct > 3))\n-   pedwarn (\"%q+D takes only zero or two arguments\", decl);\n+   pedwarn (0, \"%q+D takes only zero or two arguments\", decl);\n }\n \n /* True if pointers to distinct types T1 and T2 can be converted to\n@@ -3079,20 +3080,20 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"pointer of type %<void *%> used in arithmetic\");\n+      pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t       \"pointer of type %<void *%> used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n     {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"pointer to a function used in arithmetic\");\n+      pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t       \"pointer to a function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n     {\n-      if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"pointer to member function used in arithmetic\");\n+      pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t       \"pointer to member function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else\n@@ -3600,7 +3601,8 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n       if (is_sizeof)\n \t{\n \t  if (complain && (pedantic || warn_pointer_arith))\n-\t    pedwarn (\"invalid application of %<sizeof%> to a function type\");\n+\t    pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t     \"invalid application of %<sizeof%> to a function type\");\n           else if (!complain)\n             return error_mark_node;\n \t  value = size_one_node;\n@@ -3612,7 +3614,8 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n     {\n       if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (\"invalid application of %qs to a void type\", op_name);\n+\tpedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t \"invalid application of %qs to a void type\", op_name);\n       else if (!complain)\n         return error_mark_node;\n       value = size_one_node;\n@@ -4478,8 +4481,9 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n     }\n \n   /* Case ranges are a GNU extension.  */\n-  if (high_value && pedantic)\n-    pedwarn (\"range expressions in switch statements are non-standard\");\n+  if (high_value)\n+    pedwarn (OPT_pedantic, \n+\t     \"range expressions in switch statements are non-standard\");\n \n   type = TREE_TYPE (cond);\n   if (low_value)\n@@ -4792,8 +4796,7 @@ finish_label_address_expr (tree label)\n {\n   tree result;\n \n-  if (pedantic)\n-    pedwarn (\"taking the address of a label is non-standard\");\n+  pedwarn (OPT_pedantic, \"taking the address of a label is non-standard\");\n \n   if (label == error_mark_node)\n     return error_mark_node;"}, {"sha": "3c47c171a9e21ddc443507daee96de0485f6f740", "filename": "gcc/c-decl.c", "status": "modified", "additions": 103, "deletions": 107, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -786,7 +786,7 @@ pop_scope (void)\n \t\t   && TREE_PUBLIC (p)\n \t\t   && !DECL_INITIAL (p)\n \t\t   && !flag_gnu89_inline)\n-\t    pedwarn (\"inline function %q+D declared but never defined\", p);\n+\t    pedwarn (0, \"inline function %q+D declared but never defined\", p);\n \n \t  goto common_symbol;\n \n@@ -1223,7 +1223,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n \t       && C_FUNCTION_IMPLICIT_INT (newdecl) && !DECL_INITIAL (olddecl))\n \t{\n-\t  pedwarn (\"conflicting types for %q+D\", newdecl);\n+\t  pedwarn (0, \"conflicting types for %q+D\", newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (newdecl) = *newtypep = newtype = oldtype;\n \t  C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n@@ -1236,7 +1236,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (oldtype)) == integer_type_node\n \t       && C_DECL_IMPLICIT (olddecl) && !DECL_INITIAL (olddecl))\n \t{\n-\t  pedwarn (\"conflicting types for %q+D\", newdecl);\n+\t  pedwarn (0, \"conflicting types for %q+D\", newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (olddecl) = *oldtypep = oldtype = newtype;\n \t  pedwarned = true;\n@@ -1588,7 +1588,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \n   /* Report location of previous decl/defn in a consistent manner.  */\n   if (warned || pedwarned)\n-    locate_old_decl (olddecl, pedwarned ? pedwarn : warning0);\n+    locate_old_decl (olddecl, pedwarned ? pedwarn0 : warning0);\n \n #undef DECL_EXTERN_INLINE\n \n@@ -2356,7 +2356,8 @@ implicit_decl_warning (tree id, tree olddecl)\n   if (warn_implicit_function_declaration)\n     {\n       if (flag_isoc99)\n-\tpedwarn (G_(\"implicit declaration of function %qE\"), id);\n+\tpedwarn (OPT_Wimplicit_function_declaration, \n+\t\t G_(\"implicit declaration of function %qE\"), id);\n       else \n \twarning (OPT_Wimplicit_function_declaration, \n \t\t G_(\"implicit declaration of function %qE\"), id);\n@@ -2908,16 +2909,16 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t      if (warned != 1 && code != ENUMERAL_TYPE)\n \t\t/* Empty unnamed enum OK */\n \t\t{\n-\t\t  pedwarn (\"unnamed struct/union that defines no instances\");\n+\t\t  pedwarn (0, \"unnamed struct/union that defines no instances\");\n \t\t  warned = 1;\n \t\t}\n \t    }\n \t  else if (!declspecs->tag_defined_p\n \t\t   && declspecs->storage_class != csc_none)\n \t    {\n \t      if (warned != 1)\n-\t\tpedwarn (\"empty declaration with storage class specifier \"\n-\t\t\t \"does not redeclare tag\");\n+\t\tpedwarn (0, \"empty declaration with storage class specifier \"\n+\t\t\t  \"does not redeclare tag\");\n \t      warned = 1;\n \t      pending_xref_error ();\n \t    }\n@@ -2927,8 +2928,8 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t\t       || declspecs->restrict_p))\n \t    {\n \t      if (warned != 1)\n-\t\tpedwarn (\"empty declaration with type qualifier \"\n-\t\t\t \"does not redeclare tag\");\n+\t\tpedwarn (0, \"empty declaration with type qualifier \"\n+\t\t\t  \"does not redeclare tag\");\n \t      warned = 1;\n \t      pending_xref_error ();\n \t    }\n@@ -2948,14 +2949,14 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t{\n \t  if (warned != 1 && !in_system_header)\n \t    {\n-\t      pedwarn (\"useless type name in empty declaration\");\n+\t      pedwarn (0, \"useless type name in empty declaration\");\n \t      warned = 1;\n \t    }\n \t}\n     }\n   else if (warned != 1 && !in_system_header && declspecs->typedef_p)\n     {\n-      pedwarn (\"useless type name in empty declaration\");\n+      pedwarn (0, \"useless type name in empty declaration\");\n       warned = 1;\n     }\n \n@@ -3002,7 +3003,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n   if (warned != 1)\n     {\n       if (!found_tag)\n-\tpedwarn (\"empty declaration\");\n+\tpedwarn (0, \"empty declaration\");\n     }\n }\n \f\n@@ -3065,13 +3066,13 @@ build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n     }\n   declarator->u.array.static_p = static_p;\n   declarator->u.array.vla_unspec_p = vla_unspec_p;\n-  if (pedantic && !flag_isoc99)\n+  if (!flag_isoc99)\n     {\n       if (static_p || quals != NULL)\n-\tpedwarn (\"ISO C90 does not support %<static%> or type \"\n+\tpedwarn (OPT_pedantic, \"ISO C90 does not support %<static%> or type \"\n \t\t \"qualifiers in parameter array declarators\");\n       if (vla_unspec_p)\n-\tpedwarn (\"ISO C90 does not support %<[*]%> array declarators\");\n+\tpedwarn (OPT_pedantic, \"ISO C90 does not support %<[*]%> array declarators\");\n     }\n   if (vla_unspec_p)\n     {\n@@ -3327,8 +3328,8 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n       && !TREE_READONLY (decl)\n       && DECL_DECLARED_INLINE_P (current_function_decl)\n       && DECL_EXTERNAL (current_function_decl))\n-    pedwarn (\"%q+D is static but declared in inline function %qD \"\n-\t     \"which is not static\", decl, current_function_decl);\n+    pedwarn (0, \"%q+D is static but declared in inline function %qD \"\n+\t      \"which is not static\", decl, current_function_decl);\n \n   /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -3705,7 +3706,7 @@ mark_forward_parm_decls (void)\n \n   if (pedantic && !current_scope->warned_forward_parm_decls)\n     {\n-      pedwarn (\"ISO C forbids forward parameter declarations\");\n+      pedwarn (OPT_pedantic, \"ISO C forbids forward parameter declarations\");\n       current_scope->warned_forward_parm_decls = true;\n     }\n \n@@ -3852,12 +3853,11 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n     }\n \n   type_mv = TYPE_MAIN_VARIANT (*type);\n-  if (pedantic\n-      && !in_system_header\n+  if (!in_system_header\n       && type_mv != integer_type_node\n       && type_mv != unsigned_type_node\n       && type_mv != boolean_type_node)\n-    pedwarn (\"type of bit-field %qs is a GCC extension\", name);\n+    pedwarn (OPT_pedantic, \"type of bit-field %qs is a GCC extension\", name);\n \n   max_width = TYPE_PRECISION (*type);\n \n@@ -3887,28 +3887,27 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n static void\n warn_variable_length_array (const char *name, tree size)\n {\n-  int ped = !flag_isoc99 && pedantic && warn_vla != 0;\n   int const_size = TREE_CONSTANT (size);\n \n-  if (ped)\n+  if (!flag_isoc99 && pedantic && warn_vla != 0)\n     {\n       if (const_size)\n \t{\n \t  if (name)\n-\t    pedwarn (\"ISO C90 forbids array %qs whose size \"\n+\t    pedwarn (OPT_Wvla, \"ISO C90 forbids array %qs whose size \"\n \t\t     \"can%'t be evaluated\",\n \t\t     name);\n \t  else\n-\t    pedwarn (\"ISO C90 forbids array whose size \"\n+\t    pedwarn (OPT_Wvla, \"ISO C90 forbids array whose size \"\n \t\t     \"can%'t be evaluated\");\n \t}\n       else\n \t{\n \t  if (name) \n-\t    pedwarn (\"ISO C90 forbids variable length array %qs\",\n+\t    pedwarn (OPT_Wvla, \"ISO C90 forbids variable length array %qs\",\n \t\t     name);\n \t  else\n-\t    pedwarn (\"ISO C90 forbids variable length array\");\n+\t    pedwarn (OPT_Wvla, \"ISO C90 forbids variable length array\");\n \t}\n     }\n   else if (warn_vla > 0)\n@@ -4069,8 +4068,9 @@ grokdeclarator (const struct c_declarator *declarator,\n       if ((warn_implicit_int || warn_return_type || flag_isoc99)\n \t  && funcdef_flag)\n \twarn_about_return_type = 1;\n-      else if (warn_implicit_int || flag_isoc99)\n-\tpedwarn_c99 (\"type defaults to %<int%> in declaration of %qs\", name);\n+      else \n+\tpedwarn_c99 (flag_isoc99 ? 0 : OPT_Wimplicit_int, \n+\t\t     \"type defaults to %<int%> in declaration of %qs\", name);\n     }\n \n   /* Adjust the type if a bit-field is being declared,\n@@ -4098,11 +4098,11 @@ grokdeclarator (const struct c_declarator *declarator,\n   if (pedantic && !flag_isoc99)\n     {\n       if (constp > 1)\n-\tpedwarn (\"duplicate %<const%>\");\n+\tpedwarn (OPT_pedantic, \"duplicate %<const%>\");\n       if (restrictp > 1)\n-\tpedwarn (\"duplicate %<restrict%>\");\n+\tpedwarn (OPT_pedantic, \"duplicate %<restrict%>\");\n       if (volatilep > 1)\n-\tpedwarn (\"duplicate %<volatile%>\");\n+\tpedwarn (OPT_pedantic, \"duplicate %<volatile%>\");\n     }\n   if (!flag_gen_aux_info && (TYPE_QUALS (element_type)))\n     type = TYPE_MAIN_VARIANT (type);\n@@ -4119,9 +4119,9 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  || storage_class == csc_register\n \t  || storage_class == csc_typedef))\n     {\n-      if (storage_class == csc_auto\n-\t  && (pedantic || current_scope == file_scope))\n-\tpedwarn (\"function definition declared %<auto%>\");\n+      if (storage_class == csc_auto)\n+\tpedwarn ((current_scope == file_scope) ? 0 : OPT_pedantic, \n+\t\t \"function definition declared %<auto%>\");\n       if (storage_class == csc_register)\n \terror (\"function definition declared %<register%>\");\n       if (storage_class == csc_typedef)\n@@ -4177,7 +4177,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       if (storage_class == csc_auto)\n \terror (\"file-scope declaration of %qs specifies %<auto%>\", name);\n       if (pedantic && storage_class == csc_register)\n-\tpedwarn (\"file-scope declaration of %qs specifies %<register%>\", name);\n+\tpedwarn (OPT_pedantic, \"file-scope declaration of %qs specifies %<register%>\", name);\n     }\n   else\n     {\n@@ -4290,7 +4290,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t      }\n \n \t    if (pedantic && !in_system_header && flexible_array_type_p (type))\n-\t      pedwarn (\"invalid use of structure with flexible array member\");\n+\t      pedwarn (OPT_pedantic, \"invalid use of structure with flexible array member\");\n \n \t    if (size == error_mark_node)\n \t      type = error_mark_node;\n@@ -4315,7 +4315,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  }\n \n \t\tif (pedantic && integer_zerop (size))\n-\t\t  pedwarn (\"ISO C forbids zero-size array %qs\", name);\n+\t\t  pedwarn (OPT_pedantic, \"ISO C forbids zero-size array %qs\", name);\n \n \t\tif (TREE_CODE (size) == INTEGER_CST)\n \t\t  {\n@@ -4387,7 +4387,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    else if (decl_context == FIELD)\n \t      {\n \t\tif (pedantic && !flag_isoc99 && !in_system_header)\n-\t\t  pedwarn (\"ISO C90 does not support flexible array members\");\n+\t\t  pedwarn (OPT_pedantic, \"ISO C90 does not support flexible array members\");\n \n \t\t/* ISO C99 Flexible array members are effectively\n \t\t   identical to GCC's zero-length array extension.  */\n@@ -4532,7 +4532,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t   function definitions in ISO C; GCC used to used\n \t\t   them for noreturn functions.  */\n \t\tif (VOID_TYPE_P (type) && really_funcdef)\n-\t\t  pedwarn (\"function definition has qualified void return type\");\n+\t\t  pedwarn (0, \"function definition has qualified void return type\");\n \t\telse\n \t\t  warning (OPT_Wignored_qualifiers,\n \t\t\t   \"type qualifiers ignored on function return type\");\n@@ -4564,7 +4564,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t    if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t\t&& type_quals)\n-\t      pedwarn (\"ISO C forbids qualified function types\");\n+\t      pedwarn (OPT_pedantic, \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n \t    size_varies = 0;\n@@ -4645,15 +4645,15 @@ grokdeclarator (const struct c_declarator *declarator,\n       tree decl;\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (\"ISO C forbids qualified function types\");\n+\tpedwarn (OPT_pedantic, \"ISO C forbids qualified function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       decl = build_decl (TYPE_DECL, declarator->u.id, type);\n       DECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n       if (declspecs->explicit_signed_p)\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n       if (declspecs->inline_p)\n-\tpedwarn (\"typedef %q+D declared %<inline%>\", decl);\n+\tpedwarn (0, \"typedef %q+D declared %<inline%>\", decl);\n       return decl;\n     }\n \n@@ -4668,7 +4668,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  && !declspecs->inline_p);\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (\"ISO C forbids const or volatile function types\");\n+\tpedwarn (OPT_pedantic, \"ISO C forbids const or volatile function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n       return type;\n@@ -4678,7 +4678,8 @@ grokdeclarator (const struct c_declarator *declarator,\n       && variably_modified_type_p (type, NULL_TREE))\n     {\n       /* C99 6.7.2.1p8 */\n-      pedwarn (\"a member of a structure or union cannot have a variably modified type\");\n+      pedwarn (OPT_pedantic, \n+\t       \"a member of a structure or union cannot have a variably modified type\");\n     }\n \n   /* Aside from typedefs and type names (handle above),\n@@ -4731,8 +4732,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-\t    if (pedantic && type_quals)\n-\t      pedwarn (\"ISO C forbids qualified function types\");\n+\t    if (type_quals)\n+\t      pedwarn (OPT_pedantic, \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n \t    type = build_pointer_type (type);\n@@ -4758,7 +4759,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \tDECL_ARG_TYPE (decl) = promoted_type;\n \tif (declspecs->inline_p)\n-\t  pedwarn (\"parameter %q+D declared %<inline%>\", decl);\n+\t  pedwarn (0, \"parameter %q+D declared %<inline%>\", decl);\n       }\n     else if (decl_context == FIELD)\n       {\n@@ -4804,10 +4805,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       GCC allows 'auto', perhaps with 'inline', to support\n \t       nested functions.  */\n \t    if (storage_class == csc_auto)\n-\t      {\n-\t\tif (pedantic)\n-\t\t  pedwarn (\"invalid storage class for function %qs\", name);\n-\t      }\n+\t\tpedwarn (OPT_pedantic, \"invalid storage class for function %qs\", name);\n \t    else if (storage_class == csc_static)\n \t      {\n \t\terror (\"invalid storage class for function %qs\", name);\n@@ -4823,7 +4821,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n \tif (pedantic && type_quals && !DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (\"ISO C forbids qualified function types\");\n+\t  pedwarn (OPT_pedantic,\n+\t\t   \"ISO C forbids qualified function types\");\n \n \t/* GNU C interprets a volatile-qualified function type to indicate\n \t   that the function does not return.  */\n@@ -4865,7 +4864,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tif (flag_hosted && MAIN_NAME_P (declarator->u.id))\n \t  {\n \t    if (declspecs->inline_p)\n-\t      pedwarn (\"cannot inline function %<main%>\");\n+\t      pedwarn (0, \"cannot inline function %<main%>\");\n \t  }\n \telse if (declspecs->inline_p)\n \t  {\n@@ -4918,7 +4917,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (declspecs->inline_p)\n-\t  pedwarn (\"variable %q+D declared %<inline%>\", decl);\n+\t  pedwarn (0, \"variable %q+D declared %<inline%>\", decl);\n \n \t/* At file scope, an initialized extern declaration may follow\n \t   a static declaration.  In that case, DECL_EXTERNAL will be\n@@ -5026,7 +5025,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n   else if (arg_types && TREE_CODE (TREE_VALUE (arg_types)) == IDENTIFIER_NODE)\n     {\n       if (!funcdef_flag)\n-\tpedwarn (\"parameter names (without types) in function declaration\");\n+\tpedwarn (0, \"parameter names (without types) in function declaration\");\n \n       arg_info->parms = arg_info->types;\n       arg_info->types = 0;\n@@ -5440,11 +5439,10 @@ grokfield (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \t}\n       if (!ok)\n \t{\n-\t  pedwarn (\"declaration does not declare anything\");\n+\t  pedwarn (0, \"declaration does not declare anything\");\n \t  return NULL_TREE;\n \t}\n-      if (pedantic)\n-\tpedwarn (\"ISO C doesn%'t support unnamed structs/unions\");\n+      pedwarn (OPT_pedantic, \"ISO C doesn%'t support unnamed structs/unions\");\n     }\n \n   value = grokdeclarator (declarator, declspecs, FIELD, false,\n@@ -5543,16 +5541,16 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n \t      if (fieldlist)\n-\t\tpedwarn (\"union has no named members\");\n+\t\tpedwarn (OPT_pedantic, \"union has no named members\");\n \t      else\n-\t\tpedwarn (\"union has no members\");\n+\t\tpedwarn (OPT_pedantic, \"union has no members\");\n \t    }\n \t  else\n \t    {\n \t      if (fieldlist)\n-\t\tpedwarn (\"struct has no named members\");\n+\t\tpedwarn (OPT_pedantic, \"struct has no named members\");\n \t      else\n-\t\tpedwarn (\"struct has no members\");\n+\t\tpedwarn (OPT_pedantic, \"struct has no members\");\n \t    }\n \t}\n     }\n@@ -5631,7 +5629,8 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \n       if (pedantic && !in_system_header && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn (\"%Jinvalid use of structure with flexible array member\", x);\n+\tpedwarn (OPT_pedantic, \n+\t\t \"%Jinvalid use of structure with flexible array member\", x);\n \n       if (DECL_NAME (x))\n \tsaw_named_field = 1;\n@@ -6016,7 +6015,7 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value)\n \n   if (pedantic && !int_fits_type_p (value, integer_type_node))\n     {\n-      pedwarn (\"ISO C restricts enumerator values to range of %<int%>\");\n+      pedwarn (OPT_pedantic, \"ISO C restricts enumerator values to range of %<int%>\");\n       /* XXX This causes -pedantic to change the meaning of the program.\n \t Remove?  -zw 2004-03-15  */\n       value = convert (integer_type_node, value);\n@@ -6132,7 +6131,9 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     }\n \n   if (warn_about_return_type)\n-    pedwarn_c99 (\"return type defaults to %<int%>\");\n+    pedwarn_c99 (flag_isoc99 ? 0 \n+\t\t : (warn_return_type ? OPT_Wreturn_type : OPT_Wimplicit_int),\n+\t\t \"return type defaults to %<int%>\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in pop_scope) with the BLOCK.  */\n@@ -6253,12 +6254,12 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     {\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn (\"return type of %q+D is not %<int%>\", decl1);\n+\tpedwarn (OPT_Wmain, \"return type of %q+D is not %<int%>\", decl1);\n \n       check_main_parameter_types(decl1);\n \n       if (!TREE_PUBLIC (decl1))\n-\tpedwarn (\"%q+D is normally a non-static function\", decl1);\n+\tpedwarn (OPT_Wmain, \"%q+D is normally a non-static function\", decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -6406,7 +6407,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  warn_if_shadowing (decl);\n \n \t  if (flag_isoc99)\n-\t    pedwarn (\"type of %q+D defaults to %<int%>\", decl);\n+\t    pedwarn (0, \"type of %q+D defaults to %<int%>\", decl);\n \t  else \n \t    warning (OPT_Wmissing_parameter_type, \"type of %q+D defaults to %<int%>\", decl);\n \t}\n@@ -6517,22 +6518,19 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t\t      < TYPE_PRECISION (integer_type_node))\n \t\t    DECL_ARG_TYPE (parm) = integer_type_node;\n \n-\t\t  if (pedantic)\n+\t\t  /* ??? Is it possible to get here with a\n+\t\t     built-in prototype or will it always have\n+\t\t     been diagnosed as conflicting with an\n+\t\t     old-style definition and discarded?  */\n+\t\t  if (current_function_prototype_built_in)\n+\t\t    warning (OPT_pedantic, \"promoted argument %qD \"\n+\t\t\t     \"doesn%'t match built-in prototype\", parm);\n+\t\t  else\n \t\t    {\n-\t\t      /* ??? Is it possible to get here with a\n-\t\t\t built-in prototype or will it always have\n-\t\t\t been diagnosed as conflicting with an\n-\t\t\t old-style definition and discarded?  */\n-\t\t      if (current_function_prototype_built_in)\n-\t\t\twarning (0, \"promoted argument %qD \"\n-\t\t\t\t \"doesn%'t match built-in prototype\", parm);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  pedwarn (\"promoted argument %qD \"\n-\t\t\t\t   \"doesn%'t match prototype\", parm);\n-\t\t\t  pedwarn (\"%Hprototype declaration\",\n-\t\t\t\t   &current_function_prototype_locus);\n-\t\t\t}\n+\t\t      pedwarn (OPT_pedantic, \"promoted argument %qD \"\n+\t\t\t       \"doesn%'t match prototype\", parm);\n+\t\t      pedwarn (OPT_pedantic, \"%Hprototype declaration\",\n+\t\t\t       &current_function_prototype_locus);\n \t\t    }\n \t\t}\n \t      else\n@@ -6724,7 +6722,7 @@ finish_function (void)\n \t  /* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned.\n \t     If warn_main is -1 (-Wno-main) we don't want to be warned.  */\n \t  if (!warn_main)\n-\t    pedwarn (\"return type of %q+D is not %<int%>\", fndecl);\n+\t    pedwarn (0, \"return type of %q+D is not %<int%>\", fndecl);\n \t}\n       else\n \t{\n@@ -7175,8 +7173,8 @@ declspecs_add_qual (struct c_declspecs *specs, tree qual)\n     default:\n       gcc_unreachable ();\n     }\n-  if (dupe && pedantic && !flag_isoc99)\n-    pedwarn (\"duplicate %qE\", qual);\n+  if (dupe && !flag_isoc99)\n+    pedwarn (OPT_pedantic, \"duplicate %qE\", qual);\n   return specs;\n }\n \n@@ -7224,9 +7222,8 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t\t\t     \"declaration specifiers\");\n \t\t      break;\n \t\t    }\n-\t\t  if (pedantic && !flag_isoc99 && !in_system_header\n-\t\t      && warn_long_long)\n-\t\t    pedwarn (\"ISO C90 does not support %<long long%>\");\n+\t\t  if (pedantic && !flag_isoc99 && !in_system_header)\n+\t\t    pedwarn (OPT_Wlong_long, \"ISO C90 does not support %<long long%>\");\n \t\t  specs->long_long_p = 1;\n \t\t  break;\n \t\t}\n@@ -7349,8 +7346,8 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      break;\n \t    case RID_COMPLEX:\n \t      dupe = specs->complex_p;\n-\t      if (pedantic && !flag_isoc99 && !in_system_header)\n-\t\tpedwarn (\"ISO C90 does not support complex types\");\n+\t      if (!flag_isoc99 && !in_system_header)\n+\t\tpedwarn (OPT_pedantic, \"ISO C90 does not support complex types\");\n \t      if (specs->typespec_word == cts_void)\n \t\terror (\"both %<complex%> and %<void%> in \"\n \t\t       \"declaration specifiers\");\n@@ -7380,8 +7377,7 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      break;\n \t    case RID_SAT:\n \t      dupe = specs->saturating_p;\n-\t      if (pedantic)\n-\t\tpedwarn (\"ISO C does not support saturating types\");\n+\t      pedwarn (OPT_pedantic, \"ISO C does not support saturating types\");\n \t      if (specs->typespec_word == cts_void)\n \t\terror (\"both %<_Sat%> and %<void%> in \"\n \t\t       \"declaration specifiers\");\n@@ -7578,8 +7574,8 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      }\n \t      if (!targetm.decimal_float_supported_p ())\n \t\terror (\"decimal floating point not supported for this target\");\n-\t      if (pedantic)\n-\t\tpedwarn (\"ISO C does not support decimal floating point\");\n+\t      pedwarn (OPT_pedantic, \n+\t\t       \"ISO C does not support decimal floating point\");\n \t      return specs;\n \t    case RID_FRACT:\n \t    case RID_ACCUM:\n@@ -7599,8 +7595,8 @@ declspecs_add_type (struct c_declspecs *specs, struct c_typespec spec)\n \t      }\n \t      if (!targetm.fixed_point_supported_p ())\n \t\terror (\"fixed-point types not supported for this target\");\n-\t      if (pedantic)\n-\t\tpedwarn (\"ISO C does not support fixed-point types\");\n+\t      pedwarn (OPT_pedantic, \n+\t\t       \"ISO C does not support fixed-point types\");\n \t      return specs;\n \t    default:\n \t      /* ObjC reserved word \"id\", handled below.  */\n@@ -7786,9 +7782,9 @@ finish_declspecs (struct c_declspecs *specs)\n       else if (specs->complex_p)\n \t{\n \t  specs->typespec_word = cts_double;\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support plain %<complex%> meaning \"\n-\t\t     \"%<double complex%>\");\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ISO C does not support plain %<complex%> meaning \"\n+\t\t   \"%<double complex%>\");\n \t}\n       else\n \t{\n@@ -7831,8 +7827,8 @@ finish_declspecs (struct c_declspecs *specs)\n \tspecs->type = char_type_node;\n       if (specs->complex_p)\n \t{\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support complex integer types\");\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n       break;\n@@ -7857,8 +7853,8 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t       : integer_type_node);\n       if (specs->complex_p)\n \t{\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support complex integer types\");\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n       break;\n@@ -8008,7 +8004,7 @@ c_write_global_declarations_1 (tree globals)\n \t  && !TREE_PUBLIC (decl)\n \t  && C_DECL_USED (decl))\n \t{\n-\t  pedwarn (\"%q+F used but never defined\", decl);\n+\t  pedwarn (0, \"%q+F used but never defined\", decl);\n \t  TREE_NO_WARNING (decl) = 1;\n \t}\n "}, {"sha": "8adeeeb3538a3a94e3958a5e99c86f3ef430ca77", "filename": "gcc/c-errors.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-errors.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -31,14 +31,15 @@ along with GCC; see the file COPYING3.  If not see\n /* Issue an ISO C99 pedantic warning MSGID.  */\n \n void\n-pedwarn_c99 (const char *gmsgid, ...)\n+pedwarn_c99 (int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n \t\t       flag_isoc99 ? pedantic_warning_kind () : DK_WARNING);\n+  diagnostic.option_index = opt;\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -49,14 +50,15 @@ pedwarn_c99 (const char *gmsgid, ...)\n    (There is no flag_c90.)  */\n \n void\n-pedwarn_c90 (const char *gmsgid, ...)\n+pedwarn_c90 (int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n \t\t       flag_isoc99 ? DK_WARNING : pedantic_warning_kind ());\n+  diagnostic.option_index = opt;\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }"}, {"sha": "e49e3319c3f3d1c2011c817baae9281b263196f0", "filename": "gcc/c-lex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -587,8 +587,8 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n   if (itk > itk_unsigned_long\n       && (flags & CPP_N_WIDTH) != CPP_N_LARGE\n       && !in_system_header && !flag_isoc99)\n-    pedwarn (\"integer constant is too large for %qs type\",\n-\t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n+    pedwarn (0, \"integer constant is too large for %qs type\",\n+\t      (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n   value = build_int_cst_wide (type, integer.low, integer.high);\n \n@@ -641,8 +641,8 @@ interpret_float (const cpp_token *token, unsigned int flags)\n \n \t    return error_mark_node;\n \t  }\n-\telse if (pedantic)\n-\t  pedwarn (\"non-standard suffix on floating constant\");\n+\telse\n+\t  pedwarn (OPT_pedantic, \"non-standard suffix on floating constant\");\n \n \ttype = c_common_type_for_mode (mode, 0);\n \tgcc_assert (type);\n@@ -684,7 +684,7 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   if (REAL_VALUE_ISINF (real)) \n     {\n       if (!MODE_HAS_INFINITIES (TYPE_MODE (type)))\n-\tpedwarn (\"floating constant exceeds range of %qT\", type);\n+\tpedwarn (0, \"floating constant exceeds range of %qT\", type);\n       else\n \twarning (OPT_Woverflow, \"floating constant exceeds range of %qT\", type);\n     }"}, {"sha": "a2ea45f6a786d5b365c1dfe6fc7f39e51daf6f39", "filename": "gcc/c-parser.c", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -960,9 +960,8 @@ c_parser_translation_unit (c_parser *parser)\n {\n   if (c_parser_next_token_is (parser, CPP_EOF))\n     {\n-      if (pedantic)\n-\tpedwarn (\"%HISO C forbids an empty translation unit\",\n-\t\t &c_parser_peek_token (parser)->location);\n+      pedwarn (OPT_pedantic, \"%HISO C forbids an empty translation unit\",\n+\t       &c_parser_peek_token (parser)->location);\n     }\n   else\n     {\n@@ -1046,9 +1045,9 @@ c_parser_external_declaration (c_parser *parser)\n \t}\n       break;\n     case CPP_SEMICOLON:\n-      if (pedantic)\n-\tpedwarn (\"%HISO C does not allow extra %<;%> outside of a function\",\n-\t\t &c_parser_peek_token (parser)->location);\n+      pedwarn (OPT_pedantic, \n+\t       \"%HISO C does not allow extra %<;%> outside of a function\",\n+\t       &c_parser_peek_token (parser)->location);\n       c_parser_consume_token (parser);\n       break;\n     case CPP_PRAGMA:\n@@ -1162,7 +1161,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n       else\n \t{\n \t  shadow_tag_warned (specs, 1);\n-\t  pedwarn (\"%Hempty declaration\", &here);\n+\t  pedwarn (0, \"%Hempty declaration\", &here);\n \t}\n       c_parser_consume_token (parser);\n       return;\n@@ -1198,8 +1197,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t  if (!diagnosed_no_specs && !specs->declspecs_seen_p)\n \t    {\n \t      diagnosed_no_specs = true;\n-\t      pedwarn (\"%Hdata definition has no type or storage class\",\n-\t\t       &here);\n+\t      pedwarn (0, \"%Hdata definition has no type or storage class\",\n+\t\t\t&here);\n \t    }\n \t  /* Having seen a data definition, there cannot now be a\n \t     function definition.  */\n@@ -1268,8 +1267,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n       /* Function definition (nested or otherwise).  */\n       if (nested)\n \t{\n-\t  if (pedantic)\n-\t    pedwarn (\"%HISO C forbids nested functions\", &here);\n+\t  pedwarn (OPT_pedantic, \"%HISO C forbids nested functions\", &here);\n \t  c_push_function_context ();\n \t}\n       if (!start_function (specs, declarator, all_prefix_attrs))\n@@ -1663,8 +1661,9 @@ c_parser_enum_specifier (c_parser *parser)\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n \t    {\n-\t      if (seen_comma && pedantic && !flag_isoc99)\n-\t\tpedwarn (\"%Hcomma at end of enumerator list\", &comma_loc);\n+\t      if (seen_comma && !flag_isoc99)\n+\t\tpedwarn (OPT_pedantic, \"%Hcomma at end of enumerator list\", \n+\t\t\t &comma_loc);\n \t      c_parser_consume_token (parser);\n \t      break;\n \t    }\n@@ -1695,7 +1694,8 @@ c_parser_enum_specifier (c_parser *parser)\n   if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n     {\n       gcc_assert (ident);\n-      pedwarn (\"%HISO C forbids forward references to %<enum%> types\",\n+      pedwarn (OPT_pedantic,\n+\t       \"%HISO C forbids forward references to %<enum%> types\",\n \t       &ident_loc);\n     }\n   return ret;\n@@ -1820,9 +1820,9 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  /* Parse any stray semicolon.  */\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n-\t      if (pedantic)\n-\t\tpedwarn (\"%Hextra semicolon in struct or union specified\",\n-\t\t\t &c_parser_peek_token (parser)->location);\n+\t      pedwarn (OPT_pedantic, \n+\t\t       \"%Hextra semicolon in struct or union specified\",\n+\t\t       &c_parser_peek_token (parser)->location);\n \t      c_parser_consume_token (parser);\n \t      continue;\n \t    }\n@@ -1850,8 +1850,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n-\t\tpedwarn (\"%Hno semicolon at end of struct or union\",\n-\t\t\t &c_parser_peek_token (parser)->location);\n+\t\tpedwarn (0, \"%Hno semicolon at end of struct or union\",\n+\t\t\t  &c_parser_peek_token (parser)->location);\n \t      else\n \t\t{\n \t\t  c_parser_error (parser, \"expected %<;%>\");\n@@ -1942,9 +1942,9 @@ c_parser_struct_declaration (c_parser *parser)\n       tree ret;\n       if (!specs->type_seen_p)\n \t{\n-\t  if (pedantic)\n-\t    pedwarn (\"%HISO C forbids member declarations with no members\",\n-\t\t     &decl_loc);\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"%HISO C forbids member declarations with no members\",\n+\t\t   &decl_loc);\n \t  shadow_tag_warned (specs, pedantic);\n \t  ret = NULL_TREE;\n \t}\n@@ -2997,8 +2997,8 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n     really_start_incremental_init (type);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n     {\n-      if (pedantic)\n-\tpedwarn (\"%HISO C forbids empty initializer braces\", &brace_loc);\n+      pedwarn (OPT_pedantic, \"%HISO C forbids empty initializer braces\",\n+\t       &brace_loc);\n     }\n   else\n     {\n@@ -3042,12 +3042,10 @@ c_parser_initelt (c_parser *parser)\n     {\n       /* Old-style structure member designator.  */\n       set_init_label (c_parser_peek_token (parser)->value);\n-      if (pedantic)\n-\t{\n-\t  /* Use the colon as the error location.  */\n-\t  pedwarn (\"%Hobsolete use of designated initializer with %<:%>\",\n-\t\t   &c_parser_peek_2nd_token (parser)->location);\n-\t}\n+      /* Use the colon as the error location.  */\n+      pedwarn (OPT_pedantic, \n+\t       \"%Hobsolete use of designated initializer with %<:%>\",\n+\t       &c_parser_peek_2nd_token (parser)->location);\n       c_parser_consume_token (parser);\n       c_parser_consume_token (parser);\n     }\n@@ -3175,8 +3173,9 @@ c_parser_initelt (c_parser *parser)\n \t\t{\n \t\t  c_parser_consume_token (parser);\n \t\t  set_init_index (first, second);\n-\t\t  if (pedantic && second)\n-\t\t    pedwarn (\"%HISO C forbids specifying range of \"\n+\t\t  if (second)\n+\t\t    pedwarn (OPT_pedantic, \n+\t\t\t     \"%HISO C forbids specifying range of \"\n \t\t\t     \"elements to initialize\", &ellipsis_loc);\n \t\t}\n \t      else\n@@ -3188,19 +3187,20 @@ c_parser_initelt (c_parser *parser)\n \t{\n \t  if (c_parser_next_token_is (parser, CPP_EQ))\n \t    {\n-\t      if (pedantic && !flag_isoc99)\n-\t\tpedwarn (\"%HISO C90 forbids specifying subobject \"\n+\t      if (!flag_isoc99)\n+\t\tpedwarn (OPT_pedantic, \n+\t\t\t \"%HISO C90 forbids specifying subobject \"\n \t\t\t \"to initialize\", &des_loc);\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n \t      if (des_seen == 1)\n \t\t{\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"%Hobsolete use of designated initializer \"\n-\t\t\t     \"without %<=%>\",\n-\t\t\t     &c_parser_peek_token (parser)->location);\n+\t\t  pedwarn (OPT_pedantic, \n+\t\t\t   \"%Hobsolete use of designated initializer \"\n+\t\t\t   \"without %<=%>\",\n+\t\t\t   &c_parser_peek_token (parser)->location);\n \t\t}\n \t      else\n \t\t{\n@@ -3351,8 +3351,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t    }\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n-      if (pedantic)\n-\tpedwarn (\"%HISO C forbids label declarations\", &err_loc);\n+      pedwarn (OPT_pedantic, \"%HISO C forbids label declarations\", &err_loc);\n     }\n   /* We must now have at least one statement, label or declaration.  */\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -3382,10 +3381,11 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t{\n \t  last_label = false;\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true);\n-\t  if (last_stmt\n-\t      && ((pedantic && !flag_isoc99)\n-\t\t  || warn_declaration_after_statement))\n-\t    pedwarn_c90 (\"%HISO C90 forbids mixed declarations and code\",\n+\t  if (last_stmt)\n+\t    pedwarn_c90 ((pedantic && !flag_isoc99)\n+\t\t\t ? OPT_pedantic\n+\t\t\t : OPT_Wdeclaration_after_statement,\n+\t\t\t \"%HISO C90 forbids mixed declarations and code\",\n \t\t\t &loc);\n \t  last_stmt = false;\n \t}\n@@ -3410,10 +3410,11 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t      /* Following the old parser, __extension__ does not\n \t\t disable this diagnostic.  */\n \t      restore_extension_diagnostics (ext);\n-\t      if (last_stmt\n-\t\t  && ((pedantic && !flag_isoc99)\n-\t\t      || warn_declaration_after_statement))\n-\t\tpedwarn_c90 (\"%HISO C90 forbids mixed declarations and code\",\n+\t      if (last_stmt)\n+\t\tpedwarn_c90 ((pedantic && !flag_isoc99)\n+\t\t\t     ? OPT_pedantic\n+\t\t\t     : OPT_Wdeclaration_after_statement,\n+\t\t\t     \"%HISO C90 forbids mixed declarations and code\",\n \t\t\t     &loc);\n \t      last_stmt = false;\n \t    }\n@@ -4420,9 +4421,9 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n-      if (pedantic)\n-\tpedwarn (\"%HISO C forbids omitting the middle term of a ?: expression\",\n-\t\t &c_parser_peek_token (parser)->location);\n+      pedwarn (OPT_pedantic, \n+\t       \"%HISO C forbids omitting the middle term of a ?: expression\",\n+\t       &c_parser_peek_token (parser)->location);\n       /* Make sure first operand is calculated only once.  */\n       exp1.value = save_expr (default_conversion (cond.value));\n       cond.value = c_objc_common_truthvalue_conversion (exp1.value);\n@@ -5124,9 +5125,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  c_parser_compound_statement_nostart (parser);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n-\t  if (pedantic)\n-\t    pedwarn (\"%HISO C forbids braced-groups within expressions\",\n-\t\t     &here);\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"%HISO C forbids braced-groups within expressions\", &here);\n \t  expr.value = c_finish_stmt_expr (stmt);\n \t  expr.original_code = ERROR_MARK;\n \t}\n@@ -5486,8 +5486,9 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   finish_init ();\n   maybe_warn_string_init (type, init);\n \n-  if (pedantic && !flag_isoc99)\n-    pedwarn (\"%HISO C90 forbids compound literals\", &start_loc);\n+  if (!flag_isoc99)\n+    pedwarn (OPT_pedantic, \"%HISO C90 forbids compound literals\", \n+\t     &start_loc);\n   expr.value = build_compound_literal (type, init.value);\n   expr.original_code = ERROR_MARK;\n   return c_parser_postfix_expression_after_primary (parser, expr);\n@@ -5788,9 +5789,9 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n       /* Parse any stray semicolon.  */\n       if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t{\n-\t  if (pedantic)\n-\t    pedwarn (\"%Hextra semicolon in struct or union specified\",\n-\t\t     &c_parser_peek_token (parser)->location);\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"%Hextra semicolon in struct or union specified\",\n+\t\t   &c_parser_peek_token (parser)->location);\n \t  c_parser_consume_token (parser);\n \t  continue;\n \t}\n@@ -6006,9 +6007,9 @@ c_parser_objc_method_definition (c_parser *parser)\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       c_parser_consume_token (parser);\n-      if (pedantic)\n-\tpedwarn (\"%Hextra semicolon in method definition specified\",\n-\t\t &c_parser_peek_token (parser)->location);\n+      pedwarn (OPT_pedantic, \n+\t       \"%Hextra semicolon in method definition specified\",\n+\t       &c_parser_peek_token (parser)->location);\n     }\n   if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n@@ -6044,10 +6045,9 @@ c_parser_objc_methodprotolist (c_parser *parser)\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_SEMICOLON:\n-\t  if (pedantic)\n-\t    pedwarn (\"%HISO C does not allow extra %<;%> \"\n-\t\t     \"outside of a function\",\n-\t\t     &c_parser_peek_token (parser)->location);\n+\t  pedwarn (OPT_pedantic, \"%HISO C does not allow extra %<;%> \"\n+\t\t   \"outside of a function\",\n+\t\t   &c_parser_peek_token (parser)->location);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase CPP_PLUS:"}, {"sha": "d3e3695341cca9f10b70772c380dceaae8481d53", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -563,7 +563,7 @@ extern tree c_cast_expr (struct c_type_name *, tree);\n extern tree build_c_cast (tree, tree);\n extern void store_init_value (tree, tree);\n extern void error_init (const char *);\n-extern void pedwarn_init (const char *);\n+extern void pedwarn_init (int opt, const char *);\n extern void maybe_warn_string_init (tree, struct c_expr);\n extern void start_init (tree, tree, int);\n extern void finish_init (void);\n@@ -640,7 +640,7 @@ extern void c_write_global_declarations (void);\n #define ATTRIBUTE_GCC_CDIAG(m, n) ATTRIBUTE_NONNULL(m)\n #endif\n \n-extern void pedwarn_c90 (const char *, ...) ATTRIBUTE_GCC_CDIAG(1,2);\n-extern void pedwarn_c99 (const char *, ...) ATTRIBUTE_GCC_CDIAG(1,2);\n+extern void pedwarn_c90 (int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(2,3);\n+extern void pedwarn_c99 (int opt, const char *, ...) ATTRIBUTE_GCC_CDIAG(2,3);\n \n #endif /* ! GCC_C_TREE_H */"}, {"sha": "5d7036a43677adeaa2d3d5254992581d59ed3bb9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 106, "deletions": 97, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -470,8 +470,8 @@ composite_type (tree t1, tree t2)\n \t\t      {\n \t\t\tTREE_VALUE (n) = composite_type (TREE_TYPE (memb),\n \t\t\t\t\t\t\t TREE_VALUE (p2));\n-\t\t\tif (pedantic)\n-\t\t\t  pedwarn (\"function types not truly compatible in ISO C\");\n+\t\t\tpedwarn (OPT_pedantic, \n+\t\t\t\t \"function types not truly compatible in ISO C\");\n \t\t\tgoto parm_done;\n \t\t      }\n \t\t  }\n@@ -495,8 +495,8 @@ composite_type (tree t1, tree t2)\n \t\t      {\n \t\t\tTREE_VALUE (n) = composite_type (TREE_TYPE (memb),\n \t\t\t\t\t\t\t TREE_VALUE (p1));\n-\t\t\tif (pedantic)\n-\t\t\t  pedwarn (\"function types not truly compatible in ISO C\");\n+\t\t\tpedwarn (OPT_pedantic, \n+\t\t\t\t \"function types not truly compatible in ISO C\");\n \t\t\tgoto parm_done;\n \t\t      }\n \t\t  }\n@@ -1039,8 +1039,8 @@ comp_target_types (tree ttl, tree ttr)\n     mvr = TYPE_MAIN_VARIANT (mvr);\n   val = comptypes (mvl, mvr);\n \n-  if (val == 2 && pedantic)\n-    pedwarn (\"types are not quite compatible\");\n+  if (val == 2)\n+    pedwarn (OPT_pedantic, \"types are not quite compatible\");\n   return val;\n }\n \f\n@@ -1363,7 +1363,7 @@ function_types_compatible_p (const_tree f1, const_tree f2)\n   /* 'volatile' qualifiers on a function's return type used to mean\n      the function is noreturn.  */\n   if (TYPE_VOLATILE (ret1) != TYPE_VOLATILE (ret2))\n-    pedwarn (\"function return types not compatible due to %<volatile%>\");\n+    pedwarn (0, \"function return types not compatible due to %<volatile%>\");\n   if (TYPE_VOLATILE (ret1))\n     ret1 = build_qualified_type (TYPE_MAIN_VARIANT (ret1),\n \t\t\t\t TYPE_QUALS (ret1) & ~TYPE_QUAL_VOLATILE);\n@@ -2115,9 +2115,11 @@ build_array_ref (tree array, tree index)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && C_DECL_REGISTER (foo))\n-\t    pedwarn (\"ISO C forbids subscripting %<register%> array\");\n+\t    pedwarn (OPT_pedantic, \n+\t\t     \"ISO C forbids subscripting %<register%> array\");\n \t  else if (!flag_isoc99 && !lvalue_p (foo))\n-\t    pedwarn (\"ISO C90 forbids subscripting non-lvalue array\");\n+\t    pedwarn (OPT_pedantic, \n+\t\t     \"ISO C90 forbids subscripting non-lvalue array\");\n \t}\n \n       type = TREE_TYPE (TREE_TYPE (array));\n@@ -2231,8 +2233,8 @@ build_external_ref (tree id, int fun, location_t loc)\n \t   && (TREE_CODE (ref) != VAR_DECL || TREE_STATIC (ref))\n \t   && ! TREE_PUBLIC (ref)\n \t   && DECL_CONTEXT (ref) != current_function_decl)\n-    pedwarn (\"%H%qD is static but used in inline function %qD \"\n-\t     \"which is not static\", &loc, ref, current_function_decl);\n+    pedwarn (0, \"%H%qD is static but used in inline function %qD \"\n+\t      \"which is not static\", &loc, ref, current_function_decl);\n \n   return ref;\n }\n@@ -2456,7 +2458,7 @@ build_function_call (tree function, tree params)\n       if (TREE_CONSTANT (result)\n \t  && (name == NULL_TREE\n \t      || strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10) != 0))\n-\tpedwarn_init (\"initializer element is not constant\");\n+\tpedwarn_init (0, \"initializer element is not constant\");\n     }\n   else\n     result = fold_build_call_array (TREE_TYPE (fntype),\n@@ -2800,13 +2802,12 @@ pointer_diff (tree op0, tree op1)\n   tree con0, con1, lit0, lit1;\n   tree orig_op1 = op1;\n \n-  if (pedantic || warn_pointer_arith)\n-    {\n-      if (TREE_CODE (target_type) == VOID_TYPE)\n-\tpedwarn (\"pointer of type %<void *%> used in subtraction\");\n-      if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-\tpedwarn (\"pointer to a function used in subtraction\");\n-    }\n+  if (TREE_CODE (target_type) == VOID_TYPE)\n+    pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t     \"pointer of type %<void *%> used in subtraction\");\n+  if (TREE_CODE (target_type) == FUNCTION_TYPE)\n+    pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t     \"pointer to a function used in subtraction\");\n \n   /* If the conversion to ptrdiff_type does anything like widening or\n      converting a partial to an integral mode, we get a convert_expression\n@@ -2948,8 +2949,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       else if (typecode == COMPLEX_TYPE)\n \t{\n \t  code = CONJ_EXPR;\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support %<~%> for complex conjugation\");\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ISO C does not support %<~%> for complex conjugation\");\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n \t}\n@@ -3020,9 +3021,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t{\n \t  tree real, imag;\n \n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support %<++%> and %<--%>\"\n-\t\t     \" on complex types\");\n+\t  pedwarn (OPT_pedantic, \"ISO C does not support %<++%> and %<--%>\"\n+\t\t   \" on complex types\");\n \n \t  arg = stabilize_reference (arg);\n \t  real = build_unary_op (REALPART_EXPR, arg, 1);\n@@ -3067,14 +3067,15 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t\telse\n \t\t  error (\"decrement of pointer to unknown structure\");\n \t      }\n-\t    else if ((pedantic || warn_pointer_arith)\n-\t\t     && (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE\n-\t\t\t || TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE))\n+\t    else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE\n+\t\t     || TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n \t      {\n \t\tif (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t\t  pedwarn (\"wrong type argument to increment\");\n+\t\t  pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t\t   \"wrong type argument to increment\");\n \t\telse\n-\t\t  pedwarn (\"wrong type argument to decrement\");\n+\t\t  pedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t\t   \"wrong type argument to decrement\");\n \t      }\n \n \t    inc = c_size_in_bytes (TREE_TYPE (result_type));\n@@ -3349,7 +3350,7 @@ c_mark_addressable (tree exp)\n \t\t  (\"global register variable %qD used in nested function\", x);\n \t\treturn false;\n \t      }\n-\t    pedwarn (\"register variable %qD used in nested function\", x);\n+\t    pedwarn (0, \"register variable %qD used in nested function\", x);\n \t  }\n \telse if (C_DECL_REGISTER (x))\n \t  {\n@@ -3456,8 +3457,9 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     }\n   else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n     {\n-      if (pedantic && (code1 != VOID_TYPE || code2 != VOID_TYPE))\n-\tpedwarn (\"ISO C forbids conditional expr with only one void side\");\n+      if (code1 != VOID_TYPE || code2 != VOID_TYPE)\n+\tpedwarn (OPT_pedantic, \n+\t\t \"ISO C forbids conditional expr with only one void side\");\n       result_type = void_type_node;\n     }\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n@@ -3470,30 +3472,30 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \tresult_type = qualify_type (type1, type2);\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n-\t  if (pedantic && TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ISO C forbids conditional expr between \"\n+\t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n+\t    pedwarn (OPT_pedantic, \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type1),\n \t\t\t\t\t\t\t  TREE_TYPE (type2)));\n \t}\n       else if (VOID_TYPE_P (TREE_TYPE (type2)))\n \t{\n-\t  if (pedantic && TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ISO C forbids conditional expr between \"\n+\t  if (TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n+\t    pedwarn (OPT_pedantic, \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type2),\n \t\t\t\t\t\t\t  TREE_TYPE (type1)));\n \t}\n       else\n \t{\n-\t  pedwarn (\"pointer type mismatch in conditional expression\");\n+\t  pedwarn (0, \"pointer type mismatch in conditional expression\");\n \t  result_type = build_pointer_type (void_type_node);\n \t}\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n       if (!null_pointer_constant_p (orig_op2))\n-\tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n+\tpedwarn (0, \"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n \t  op2 = null_pointer_node;\n@@ -3503,7 +3505,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n       if (!null_pointer_constant_p (orig_op1))\n-\tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n+\tpedwarn (0, \"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n \t  op1 = null_pointer_node;\n@@ -3614,12 +3616,10 @@ build_c_cast (tree type, tree expr)\n \n   if (type == TYPE_MAIN_VARIANT (TREE_TYPE (value)))\n     {\n-      if (pedantic)\n-\t{\n-\t  if (TREE_CODE (type) == RECORD_TYPE\n-\t      || TREE_CODE (type) == UNION_TYPE)\n-\t    pedwarn (\"ISO C forbids casting nonscalar to the same type\");\n-\t}\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  || TREE_CODE (type) == UNION_TYPE)\n+\tpedwarn (OPT_pedantic, \n+\t\t \"ISO C forbids casting nonscalar to the same type\");\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n     {\n@@ -3635,8 +3635,7 @@ build_c_cast (tree type, tree expr)\n \t{\n \t  tree t;\n \n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C forbids casts to union type\");\n+\t  pedwarn (OPT_pedantic, \"ISO C forbids casts to union type\");\n \t  t = digest_init (type,\n \t\t\t   build_constructor_single (type, field, value),\n \t\t\t   true, 0);\n@@ -3747,15 +3746,17 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE)\n-\tpedwarn (\"ISO C forbids conversion of function pointer to object pointer type\");\n+\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\t \"conversion of function pointer to object pointer type\");\n \n       if (pedantic\n \t  && TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n \t  && !null_pointer_constant_p (value))\n-\tpedwarn (\"ISO C forbids conversion of object pointer to function pointer type\");\n+\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\t \"conversion of object pointer to function pointer type\");\n \n       ovalue = value;\n       value = convert (type, value);\n@@ -3951,19 +3952,19 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n     switch (errtype)\t\t\t\t\\\n       {\t\t\t\t\t\t\\\n       case ic_argpass:\t\t\t\t\\\n-\tpedwarn (AR, parmnum, rname);\t\t\\\n+\tpedwarn (0, AR, parmnum, rname);\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_argpass_nonproto:\t\t\t\\\n-\twarning (0, AR, parmnum, rname);\t\t\\\n+\twarning (0, AR, parmnum, rname);\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_assign:\t\t\t\t\\\n-\tpedwarn (AS);\t\t\t\t\\\n+\tpedwarn (0, AS);\t\t\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_init:\t\t\t\t\\\n-\tpedwarn (IN);\t\t\t\t\\\n+\tpedwarn (0, IN);\t\t\t\\\n \tbreak;\t\t\t\t\t\\\n       case ic_return:\t\t\t\t\\\n-\tpedwarn (RE);\t\t\t\t\\\n+\tpedwarn (0, RE);\t\t\t\\\n \tbreak;\t\t\t\t\t\\\n       default:\t\t\t\t\t\\\n \tgcc_unreachable ();\t\t\t\\\n@@ -4170,8 +4171,9 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t      memb = marginal_memb;\n \t    }\n \n-\t  if (pedantic && (!fundecl || !DECL_IN_SYSTEM_HEADER (fundecl)))\n-\t    pedwarn (\"ISO C prohibits argument conversion to union type\");\n+\t  if (!fundecl || !DECL_IN_SYSTEM_HEADER (fundecl))\n+\t    pedwarn (OPT_pedantic, \n+\t\t     \"ISO C prohibits argument conversion to union type\");\n \n \t  rhs = fold_convert (TREE_TYPE (memb), rhs);\n \t  return build_constructor_single (type, memb, rhs);\n@@ -4616,19 +4618,20 @@ error_init (const char *msgid)\n     error (\"(near initialization for %qs)\", ofwhat);\n }\n \n-/* Issue a pedantic warning for a bad initializer component.\n-   MSGID identifies the message.\n-   The component name is taken from the spelling stack.  */\n+/* Issue a pedantic warning for a bad initializer component.  OPT is\n+   the option OPT_* (from options.h) controlling this warning or 0 if\n+   it is unconditionally given.  MSGID identifies the message.  The\n+   component name is taken from the spelling stack.  */\n \n void\n-pedwarn_init (const char *msgid)\n+pedwarn_init (int opt, const char *msgid)\n {\n   char *ofwhat;\n \n-  pedwarn (\"%s\", _(msgid));\n+  pedwarn (opt, \"%s\", _(msgid));\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    pedwarn (\"(near initialization for %qs)\", ofwhat);\n+    pedwarn (opt, \"(near initialization for %qs)\", ofwhat);\n }\n \n /* Issue a warning for a bad initializer component.  \n@@ -4659,7 +4662,8 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n       && TREE_CODE (type) == ARRAY_TYPE\n       && TREE_CODE (expr.value) == STRING_CST\n       && expr.original_code != STRING_CST)\n-    pedwarn_init (\"array initialized from parenthesized string constant\");\n+    pedwarn_init (OPT_pedantic, \n+\t\t  \"array initialized from parenthesized string constant\");\n }\n \n /* Digest the parser output INIT as an initializer for type TYPE.\n@@ -4752,7 +4756,7 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t\t\t\t       TREE_STRING_LENGTH (inside_init)\n \t\t\t\t       - (TYPE_PRECISION (typ1)\n \t\t\t\t\t  / BITS_PER_UNIT)))\n-\t    pedwarn_init (\"initializer-string for array of chars is too long\");\n+\t    pedwarn_init (0, \"initializer-string for array of chars is too long\");\n \n \t  return inside_init;\n \t}\n@@ -4867,7 +4871,7 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t  if (inside_init == error_mark_node)\n \t    error_init (\"initializer element is not constant\");\n \t  else\n-\t    pedwarn_init (\"initializer element is not constant\");\n+\t    pedwarn_init (OPT_pedantic, \"initializer element is not constant\");\n \t  if (flag_pedantic_errors)\n \t    inside_init = error_mark_node;\n \t}\n@@ -5540,8 +5544,8 @@ pop_init_level (int implicit)\n \n \t  if (constructor_depth > 2)\n \t    error_init (\"initialization of flexible array member in a nested context\");\n-\t  else if (pedantic)\n-\t    pedwarn_init (\"initialization of a flexible array member\");\n+\t  else\n+\t    pedwarn_init (OPT_pedantic, \"initialization of a flexible array member\");\n \n \t  /* We have already issued an error message for the existence\n \t     of a flexible array member not at the end of the structure.\n@@ -6278,7 +6282,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t  value = error_mark_node;\n \t}\n       else if (require_constant_elements)\n-\tpedwarn (\"initializer element is not computable at load time\");\n+\tpedwarn (0, \"initializer element is not computable at load time\");\n     }\n \n   /* If this field is empty (and not at the end of structure),\n@@ -6605,7 +6609,7 @@ process_init_element (struct c_expr value)\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (\"excess elements in struct initializer\");\n+\t      pedwarn_init (0, \"excess elements in struct initializer\");\n \t      break;\n \t    }\n \n@@ -6688,7 +6692,7 @@ process_init_element (struct c_expr value)\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (\"excess elements in union initializer\");\n+\t      pedwarn_init (0, \"excess elements in union initializer\");\n \t      break;\n \t    }\n \n@@ -6775,7 +6779,7 @@ process_init_element (struct c_expr value)\n \t      && (tree_int_cst_lt (constructor_max_index, constructor_index)\n \t\t  || integer_all_onesp (constructor_max_index)))\n \t    {\n-\t      pedwarn_init (\"excess elements in array initializer\");\n+\t      pedwarn_init (0, \"excess elements in array initializer\");\n \t      break;\n \t    }\n \n@@ -6805,7 +6809,7 @@ process_init_element (struct c_expr value)\n \t    always have a fixed size derived from their type.  */\n \t  if (tree_int_cst_lt (constructor_max_index, constructor_index))\n \t    {\n-\t      pedwarn_init (\"excess elements in vector initializer\");\n+\t      pedwarn_init (0, \"excess elements in vector initializer\");\n \t      break;\n \t    }\n \n@@ -6829,7 +6833,7 @@ process_init_element (struct c_expr value)\n       else if (constructor_type != error_mark_node\n \t       && constructor_fields == 0)\n \t{\n-\t  pedwarn_init (\"excess elements in scalar initializer\");\n+\t  pedwarn_init (0, \"excess elements in scalar initializer\");\n \t  break;\n \t}\n       else\n@@ -7060,8 +7064,7 @@ c_finish_goto_label (tree label)\n tree\n c_finish_goto_ptr (tree expr)\n {\n-  if (pedantic)\n-    pedwarn (\"ISO C forbids %<goto *expr;%>\");\n+  pedwarn (OPT_pedantic, \"ISO C forbids %<goto *expr;%>\");\n   expr = convert (ptr_type_node, expr);\n   return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));\n }\n@@ -7084,7 +7087,8 @@ c_finish_return (tree retval)\n       if ((warn_return_type || flag_isoc99)\n \t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n \t{\n-\t  pedwarn_c99 (\"%<return%> with no value, in \"\n+\t  pedwarn_c99 (flag_isoc99 ? 0 : OPT_Wreturn_type, \n+\t\t       \"%<return%> with no value, in \"\n \t\t       \"function returning non-void\");\n \t  no_warning = true;\n \t}\n@@ -7093,9 +7097,10 @@ c_finish_return (tree retval)\n     {\n       current_function_returns_null = 1;\n       if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tpedwarn (\"%<return%> with a value, in function returning void\");\n-      else if (pedantic)\n-\tpedwarn (\"ISO C forbids %<return%> with expression, in function returning void\");\n+\tpedwarn (0, \"%<return%> with a value, in function returning void\");\n+      else \n+\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\t \"%<return%> with expression, in function returning void\");\n     }\n   else\n     {\n@@ -8165,20 +8170,20 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t whose value is 0 but which isn't a valid null ptr const.  */\n \t      if (pedantic && !null_pointer_constant_p (orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ISO C forbids comparison of %<void *%>\"\n-\t\t\t \" with function pointer\");\n+\t\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n \t      if (pedantic && !null_pointer_constant_p (orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ISO C forbids comparison of %<void *%>\"\n-\t\t\t \" with function pointer\");\n+\t\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else\n \t    /* Avoid warning about the volatile ObjC EH puts on decls.  */\n \t    if (!objc_ok)\n-\t      pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t      pedwarn (0, \"comparison of distinct pointer types lacks a cast\");\n \n \t  if (result_type == NULL_TREE)\n \t    result_type = ptr_type_node;\n@@ -8202,12 +8207,12 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (\"comparison between pointer and integer\");\n+\t  pedwarn (0, \"comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (\"comparison between pointer and integer\");\n+\t  pedwarn (0, \"comparison between pointer and integer\");\n \t}\n       break;\n \n@@ -8228,38 +8233,42 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n \t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n-\t\tpedwarn (\"comparison of complete and incomplete pointers\");\n-\t      else if (pedantic\n-\t\t       && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ISO C forbids ordered comparisons of pointers to functions\");\n+\t\tpedwarn (0, \"comparison of complete and incomplete pointers\");\n+\t      else if (TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n+\t\tpedwarn (OPT_pedantic, \"ISO C forbids \"\n+\t\t\t \"ordered comparisons of pointers to functions\");\n \t    }\n \t  else\n \t    {\n \t      result_type = ptr_type_node;\n-\t      pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t      pedwarn (0, \"comparison of distinct pointer types lacks a cast\");\n \t    }\n \t}\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n \t  result_type = type0;\n-\t  if (pedantic || extra_warnings)\n-\t    pedwarn (\"ordered comparison of pointer with integer zero\");\n+\t  if (pedantic)\n+\t    pedwarn (OPT_pedantic, \n+\t\t     \"ordered comparison of pointer with integer zero\");\n+\t  else if (extra_warnings)\n+\t    warning (OPT_Wextra,\n+\t\t     \"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  result_type = type1;\n-\t  if (pedantic)\n-\t    pedwarn (\"ordered comparison of pointer with integer zero\");\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (\"comparison between pointer and integer\");\n+\t  pedwarn (0, \"comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (\"comparison between pointer and integer\");\n+\t  pedwarn (0, \"comparison between pointer and integer\");\n \t}\n       break;\n "}, {"sha": "3757dcfe9052ee8fe07e0568c0942db56e4724ee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -1,3 +1,15 @@\n+2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 35058\n+\t* typeck.c: All calls to pedwarn changed.\n+\t* decl.c: All calls to pedwarn changed.\n+\t* call.c: All calls to pedwarn changed.\n+\t* error.c: All calls to pedwarn changed.\n+\t* typeck2.c: All calls to pedwarn changed.\n+\t* pt.c: All calls to pedwarn changed.\n+\t* name-lookup.c: All calls to pedwarn changed.\n+\t* parser.c: All calls to pedwarn changed.\n+\n 2008-07-21  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* call.c: Fix comment typos."}, {"sha": "7cff6adb3a9ae11eb40152f062c74f93bd5bda88", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -3404,8 +3404,9 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n      calculated only once.  */\n   if (!arg2)\n     {\n-      if (pedantic && (complain & tf_error))\n-\tpedwarn (\"ISO C++ forbids omitting the middle term of a ?: expression\");\n+      if (complain & tf_error)\n+\tpedwarn (OPT_pedantic, \n+\t\t \"ISO C++ forbids omitting the middle term of a ?: expression\");\n \n       /* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */\n       if (real_lvalue_p (arg1))\n@@ -6760,7 +6761,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t{\n \t  if (warn)\n \t    {\n-\t      warning (0,\n+\t      pedwarn (0,\n \t      \"ISO C++ says that these are ambiguous, even \"\n \t      \"though the worst conversion for the first is better than \"\n \t      \"the worst conversion for the second:\");"}, {"sha": "cc9e8c8bbc0d833530d26d3a0d06d764350d68a7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -3813,9 +3813,8 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n       /* Anonymous unions are objects, so they can have specifiers.  */;\n       SET_ANON_AGGR_TYPE_P (declared_type);\n \n-      if (TREE_CODE (declared_type) != UNION_TYPE && pedantic\n-\t  && !in_system_header)\n-\tpedwarn (\"ISO C++ prohibits anonymous structs\");\n+      if (TREE_CODE (declared_type) != UNION_TYPE && !in_system_header)\n+\tpedwarn (OPT_pedantic, \"ISO C++ prohibits anonymous structs\");\n     }\n \n   else\n@@ -7004,8 +7003,8 @@ check_static_variable_definition (tree decl, tree type)\n     error (\"ISO C++ forbids in-class initialization of non-const \"\n \t   \"static member %qD\",\n \t   decl);\n-  else if (pedantic && !INTEGRAL_TYPE_P (type))\n-    pedwarn (\"ISO C++ forbids initialization of member constant \"\n+  else if (!INTEGRAL_TYPE_P (type))\n+    pedwarn (OPT_pedantic, \"ISO C++ forbids initialization of member constant \"\n \t     \"%qD of non-integral type %qT\", decl, type);\n \n   return 0;\n@@ -7082,12 +7081,12 @@ compute_array_index_type (tree name, tree size)\n \t}\n       /* As an extension we allow zero-sized arrays.  We always allow\n \t them in system headers because glibc uses them.  */\n-      else if (integer_zerop (size) && pedantic && !in_system_header)\n+      else if (integer_zerop (size) && !in_system_header)\n \t{\n \t  if (name)\n-\t    pedwarn (\"ISO C++ forbids zero-size array %qD\", name);\n+\t    pedwarn (OPT_pedantic, \"ISO C++ forbids zero-size array %qD\", name);\n \t  else\n-\t    pedwarn (\"ISO C++ forbids zero-size array\");\n+\t    pedwarn (OPT_pedantic, \"ISO C++ forbids zero-size array\");\n \t}\n     }\n   else if (TREE_CONSTANT (size))\n@@ -7103,9 +7102,9 @@ compute_array_index_type (tree name, tree size)\n   else if (pedantic && warn_vla != 0)\n     {\n       if (name)\n-\tpedwarn (\"ISO C++ forbids variable length array %qD\", name);\n+\tpedwarn (OPT_Wvla, \"ISO C++ forbids variable length array %qD\", name);\n       else\n-\tpedwarn (\"ISO C++ forbids variable length array\");\n+\tpedwarn (OPT_Wvla, \"ISO C++ forbids variable length array\");\n     }\n   else if (warn_vla > 0)\n     {\n@@ -7736,7 +7735,8 @@ grokdeclarator (const cp_declarator *declarator,\n       else if (! is_main)\n \tpermerror (\"ISO C++ forbids declaration of %qs with no type\", name);\n       else if (pedantic)\n-\tpedwarn (\"ISO C++ forbids declaration of %qs with no type\", name);\n+\tpedwarn (OPT_pedantic,\n+\t\t \"ISO C++ forbids declaration of %qs with no type\", name);\n       else\n \twarning (OPT_Wreturn_type,\n                  \"ISO C++ forbids declaration of %qs with no type\", name);\n@@ -7791,7 +7791,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t  ok = 1;\n \t  if (!explicit_int && !defaulted_int && !explicit_char && pedantic)\n \t    {\n-\t      pedwarn (\"long, short, signed or unsigned used invalidly for %qs\",\n+\t      pedwarn (OPT_pedantic, \n+\t\t       \"long, short, signed or unsigned used invalidly for %qs\",\n \t\t       name);\n \t      if (flag_pedantic_errors)\n \t\tok = 0;\n@@ -7896,7 +7897,8 @@ grokdeclarator (const cp_declarator *declarator,\n       if (pedantic)\n \t{\n \t  tree bad_type = build_qualified_type (type, type_quals);\n-\t  pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ignoring %qV qualifiers added to function type %qT\",\n \t\t   bad_type, type);\n \t}\n       type_quals = TYPE_UNQUALIFIED;\n@@ -9124,10 +9126,12 @@ grokdeclarator (const cp_declarator *declarator,\n \t    && pedantic)\n \t  {\n \t    if (storage_class == sc_static)\n-\t      pedwarn (\"%<static%> specified invalid for function %qs \"\n+\t      pedwarn (OPT_pedantic, \n+\t\t       \"%<static%> specified invalid for function %qs \"\n \t\t       \"declared out of global scope\", name);\n \t    else\n-\t      pedwarn (\"%<inline%> specifier invalid for function %qs \"\n+\t      pedwarn (OPT_pedantic, \n+\t\t       \"%<inline%> specifier invalid for function %qs \"\n \t\t       \"declared out of global scope\", name);\n \t  }\n \n@@ -9215,9 +9219,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \t    if (storage_class == sc_extern && pedantic)\n \t      {\n-\t\tpedwarn (\"cannot explicitly declare member %q#D to have \"\n-\t\t\t \"extern linkage\",\n-\t\t\t decl);\n+\t\tpedwarn (OPT_pedantic, \n+\t\t\t \"cannot explicitly declare member %q#D to have \"\n+\t\t\t \"extern linkage\", decl);\n \t\tstorage_class = sc_none;\n \t      }\n \t  }\n@@ -10104,8 +10108,8 @@ grok_op_properties (tree decl, bool complain)\n \t    if (operator_code == POSTINCREMENT_EXPR\n \t\t|| operator_code == POSTDECREMENT_EXPR)\n \t      {\n-\t\tif (pedantic)\n-\t\t  pedwarn (\"%qD cannot have default arguments\", decl);\n+\t\tpedwarn (OPT_pedantic, \"%qD cannot have default arguments\", \n+\t\t\t decl);\n \t      }\n \t    else\n \t      {"}, {"sha": "d3ec82aaaefb319d184734a8f2134a249c221c0f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -2685,7 +2685,7 @@ maybe_warn_cpp0x (const char* str)\n     /* We really want to suppress this warning in system headers,\n        because libstdc++ uses variadic templates even when we aren't\n        in C++0x mode. */\n-    pedwarn (\"%s only available with -std=c++0x\", str);\n+    pedwarn (0, \"%s only available with -std=c++0x\", str);\n }\n \n /* Warn about the use of variadic templates when appropriate.  */"}, {"sha": "9b456d54c575fb841a0cb676a51dd699b41b853b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -724,10 +724,10 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t    /* Don't do anything just yet.  */;\n \t  else if (t == wchar_decl_node)\n \t    {\n-\t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n-\t\tpedwarn (\"redeclaration of %<wchar_t%> as %qT\",\n+\t      if (! DECL_IN_SYSTEM_HEADER (x))\n+\t\tpedwarn (OPT_pedantic, \"redeclaration of %<wchar_t%> as %qT\",\n \t\t\t TREE_TYPE (x));\n-\n+\t      \n \t      /* Throw away the redeclaration.  */\n \t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n@@ -796,10 +796,11 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t\t\t\t\t  x_exception_spec,\n \t\t\t\t\t  true))\n \t\t    {\n-\t\t      pedwarn (\"declaration of %q#D with C language linkage\", x);\n-\t\t      pedwarn (\"conflicts with previous declaration %q+#D\",\n-\t\t\t        previous);\n-\t\t      pedwarn (\"due to different exception specifications\");\n+\t\t      pedwarn (0, \"declaration of %q#D with C language linkage\",\n+\t\t\t       x);\n+\t\t      pedwarn (0, \"conflicts with previous declaration %q+#D\",\n+\t\t\t       previous);\n+\t\t      pedwarn (0, \"due to different exception specifications\");\n \t\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t\t    }\n \t\t}"}, {"sha": "420b92cea10c7a790cb49a819d51cc67973cc45a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -2162,7 +2162,8 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n \t    error (\"%H%<long long long%> is too long for GCC\", &location);\n \t  else if (pedantic && !in_system_header && warn_long_long\n                    && cxx_dialect == cxx98)\n-\t    pedwarn (\"%HISO C++ 1998 does not support %<long long%>\",\n+\t    pedwarn (OPT_Wlong_long, \n+\t\t     \"%HISO C++ 1998 does not support %<long long%>\",\n \t\t     &location);\n \t}\n       else if (count > 1)\n@@ -3214,9 +3215,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \t  {\n \t    /* Statement-expressions are not allowed by the standard.  */\n-\t    if (pedantic)\n-\t      pedwarn (\"%HISO C++ forbids braced-groups within expressions\",\n-\t\t       &token->location);\n+\t    pedwarn (OPT_pedantic, \n+\t\t     \"%HISO C++ forbids braced-groups within expressions\",\n+\t\t     &token->location);\n \n \t    /* And they're not allowed outside of a function-body; you\n \t       cannot, for example, write:\n@@ -4545,8 +4546,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t      {\n \t\t/* Warn the user that a compound literal is not\n \t\t   allowed in standard C++.  */\n-\t\tif (pedantic)\n-\t\t  pedwarn (\"ISO C++ forbids compound-literals\");\n+\t\tpedwarn (OPT_pedantic, \"ISO C++ forbids compound-literals\");\n \t\t/* For simplicity, we disallow compound literals in\n \t\t   constant-expressions.  We could\n \t\t   allow compound literals of integer type, whose\n@@ -7610,8 +7610,7 @@ cp_parser_jump_statement (cp_parser* parser)\n       if (cp_lexer_next_token_is (parser->lexer, CPP_MULT))\n \t{\n \t  /* Issue a warning about this use of a GNU extension.  */\n-\t  if (pedantic)\n-\t    pedwarn (\"%HISO C++ forbids computed gotos\", &token->location);\n+\t  pedwarn (OPT_pedantic, \"%HISO C++ forbids computed gotos\", &token->location);\n \t  /* Consume the '*' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the dependent expression.  */\n@@ -7750,8 +7749,8 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t  /* A declaration consisting of a single semicolon is\n \t     invalid.  Allow it unless we're being pedantic.  */\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  if (pedantic && !in_system_header)\n-\t    pedwarn (\"extra %<;%>\");\n+\t  if (!in_system_header)\n+\t    pedwarn (OPT_pedantic, \"extra %<;%>\");\n \t  continue;\n \t}\n \n@@ -11734,8 +11733,8 @@ cp_parser_enumerator_list (cp_parser* parser, tree type)\n       /* If the next token is a `}', there is a trailing comma.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n \t{\n-\t  if (pedantic && !in_system_header)\n-\t    pedwarn (\"comma at end of enumerator list\");\n+\t  if (!in_system_header)\n+\t    pedwarn (OPT_pedantic, \"comma at end of enumerator list\");\n \t  break;\n \t}\n     }\n@@ -14369,8 +14368,8 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)\n \t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_COLON)\n \t{\n \t  /* Warn the user that they are using an extension.  */\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C++ does not allow designated initializers\");\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ISO C++ does not allow designated initializers\");\n \t  /* Consume the identifier.  */\n \t  identifier = cp_lexer_consume_token (parser->lexer)->u.value;\n \t  /* Consume the `:'.  */\n@@ -15386,8 +15385,8 @@ cp_parser_member_declaration (cp_parser* parser)\n       if (!decl_specifiers.any_specifiers_p)\n \t{\n \t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t  if (pedantic && !in_system_header_at (token->location))\n-\t    pedwarn (\"%Hextra %<;%>\", &token->location);\n+\t  if (!in_system_header_at (token->location))\n+\t    pedwarn (OPT_pedantic, \"%Hextra %<;%>\", &token->location);\n \t}\n       else\n \t{"}, {"sha": "60e75286e4664b56cd097a0e6d60da55025db25e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -14610,8 +14610,9 @@ do_decl_instantiation (tree decl, tree storage)\n     ;\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n-      if (pedantic && !in_system_header && (cxx_dialect == cxx98))\n-\tpedwarn (\"ISO C++ 1998 forbids the use of %<extern%> on explicit \"\n+      if (!in_system_header && (cxx_dialect == cxx98))\n+\tpedwarn (OPT_pedantic, \n+\t\t \"ISO C++ 1998 forbids the use of %<extern%> on explicit \"\n \t\t \"instantiations\");\n       extern_p = 1;\n     }\n@@ -14697,16 +14698,17 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n   if (storage != NULL_TREE)\n     {\n-      if (pedantic && !in_system_header)\n+      if (!in_system_header)\n \t{\n \t  if (storage == ridpointers[(int) RID_EXTERN])\n \t    {\n \t      if (cxx_dialect == cxx98)\n-\t\tpedwarn(\"ISO C++ 1998 forbids the use of %<extern%> on \"\n+\t\tpedwarn(OPT_pedantic, \n+\t\t\t\"ISO C++ 1998 forbids the use of %<extern%> on \"\n \t\t\t\"explicit instantiations\");\n \t    }\n \t  else\n-\t    pedwarn(\"ISO C++ forbids the use of %qE on explicit \"\n+\t    pedwarn(OPT_pedantic, \"ISO C++ forbids the use of %qE on explicit \"\n \t\t    \"instantiations\", storage);\n \t}\n "}, {"sha": "67511f948774ea26eaa26b24320b88c458f6f0a3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -511,9 +511,10 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       tree attributes;\n       tree result_type;\n \n-      if (pedantic && TYPE_PTRFN_P (t2) && (complain & tf_error))\n-\tpedwarn (\"ISO C++ forbids %s between pointer of type %<void *%> \"\n-\t\t \"and pointer-to-function\", location);\n+      if (TYPE_PTRFN_P (t2) && (complain & tf_error))\n+\tpedwarn (OPT_pedantic, \"ISO C++ forbids %s \"\n+\t\t \"between pointer of type %<void *%> and pointer-to-function\",\n+\t\t location);\n       result_type\n \t= cp_build_qualified_type (void_type_node,\n \t\t\t\t   (cp_type_quals (TREE_TYPE (t1))\n@@ -1278,8 +1279,9 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n   type = non_reference (type);\n   if (TREE_CODE (type) == METHOD_TYPE)\n     {\n-      if (complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (\"invalid application of %qs to a member function\", \n+      if (complain)\n+\tpedwarn (pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t \"invalid application of %qs to a member function\", \n \t\t operator_name_info[(int) op].name);\n       value = size_one_node;\n     }\n@@ -2596,8 +2598,8 @@ build_array_ref (tree array, tree idx)\n \t    return error_mark_node;\n \t}\n \n-      if (pedantic && !lvalue_p (array))\n-\tpedwarn (\"ISO C++ forbids subscripting non-lvalue array\");\n+      if (!lvalue_p (array))\n+\tpedwarn (OPT_pedantic, \"ISO C++ forbids subscripting non-lvalue array\");\n \n       /* Note in C++ it is valid to subscript a `register' array, since\n \t it is valid to take the address of something with that\n@@ -2822,8 +2824,9 @@ cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n       fndecl = function;\n \n       /* Convert anything with function type to a pointer-to-function.  */\n-      if (pedantic && DECL_MAIN_P (function) && (complain & tf_error))\n-\tpedwarn (\"ISO C++ forbids calling %<::main%> from within program\");\n+      if (DECL_MAIN_P (function) && (complain & tf_error))\n+\tpedwarn (OPT_pedantic, \n+\t\t \"ISO C++ forbids calling %<::main%> from within program\");\n \n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n@@ -4101,15 +4104,12 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n   if (!complete_type_or_else (target_type, NULL_TREE))\n     return error_mark_node;\n \n-  if (pedantic || warn_pointer_arith)\n-    {\n-      if (TREE_CODE (target_type) == VOID_TYPE)\n-\tpermerror (\"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n-      if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-\tpermerror (\"ISO C++ forbids using pointer to a function in subtraction\");\n-      if (TREE_CODE (target_type) == METHOD_TYPE)\n-\tpermerror (\"ISO C++ forbids using pointer to a method in subtraction\");\n-    }\n+  if (TREE_CODE (target_type) == VOID_TYPE)\n+    permerror (\"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n+  if (TREE_CODE (target_type) == FUNCTION_TYPE)\n+    permerror (\"ISO C++ forbids using pointer to a function in subtraction\");\n+  if (TREE_CODE (target_type) == METHOD_TYPE)\n+    permerror (\"ISO C++ forbids using pointer to a method in subtraction\");\n \n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n@@ -4559,7 +4559,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t  arg = build1 (CONVERT_EXPR, type, arg);\n \t  return arg;\n \t}\n-      else if (pedantic && DECL_MAIN_P (arg))\n+      else if (DECL_MAIN_P (arg))\n         {\n           /* ARM $3.4 */\n           if (complain & tf_error)\n@@ -4655,7 +4655,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n           /* Even if we're not being pedantic, we cannot allow this\n              extension when we're instantiating in a SFINAE\n              context.  */\n-\t  if (! lvalue_p (arg) && (pedantic || complain == tf_none))\n+\t  if (! lvalue_p (arg) && complain == tf_none)\n             {\n               if (complain & tf_error)\n                 permerror (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n@@ -5443,7 +5443,8 @@ convert_member_func_to_ptr (tree type, tree expr)\n \t      || TREE_CODE (intype) == METHOD_TYPE);\n \n   if (pedantic || warn_pmf2ptr)\n-    pedwarn (\"converting from %qT to %qT\", intype, type);\n+    pedwarn (pedantic ? OPT_pedantic : OPT_Wpmf_conversions,\n+\t     \"converting from %qT to %qT\", intype, type);\n \n   if (TREE_CODE (intype) == METHOD_TYPE)\n     expr = build_addr_func (expr);\n@@ -6980,7 +6981,6 @@ check_return_expr (tree retval, bool *no_warning)\n       else\n \tpermerror (\"return-statement with a value, in function \"\n \t\t   \"returning 'void'\");\n-\n       current_function_returns_null = 1;\n \n       /* There's really no value to return, after all.  */\n@@ -7347,7 +7347,8 @@ cp_apply_type_quals_to_decl (int type_quals, tree decl)\n       if (pedantic)\n \t{\n \t  tree bad_type = build_qualified_type (type, type_quals);\n-\t  pedwarn (\"ignoring %qV qualifiers added to function type %qT\",\n+\t  pedwarn (OPT_pedantic, \n+\t\t   \"ignoring %qV qualifiers added to function type %qT\",\n \t\t   bad_type, type);\n \t}\n "}, {"sha": "ee686fecf33d558236ef1e76730b742c13bd1f9f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -345,7 +345,7 @@ cxx_incomplete_type_diagnostic (const_tree value, const_tree type, int diag_type\n   if (diag_type == 1)\n     p_msg = warning0;\n   else if (diag_type == 2)\n-    p_msg = pedwarn;\n+    p_msg = pedwarn0;\n   else\n     p_msg = error;\n "}, {"sha": "49b3f9a058ff5c4a2fb8d2071360a21dc183b142", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -522,16 +522,34 @@ warning_at (location_t location, int opt, const char *gmsgid, ...)\n \n    Note that these diagnostics are issued independent of the setting\n    of the -pedantic command-line switch.  To get a warning enabled\n-   only with that switch, write \"if (pedantic) pedwarn (...);\"  */\n+   only with that switch, use either \"if (pedantic) pedwarn\n+   (OPT_pedantic,...)\" or just \"pedwarn (OPT_pedantic,..)\".  To get a\n+   pedwarn independently of the -pedantic switch use \"pedwarn (0,...)\".  */\n+\n+void\n+pedwarn (int opt, const char *gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n+                      pedantic_warning_kind ());\n+  diagnostic.option_index = opt;\n+\n+  report_diagnostic (&diagnostic);\n+  va_end (ap);\n+}\n+\n void\n-pedwarn (const char *gmsgid, ...)\n+pedwarn0 (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n-\t\t       pedantic_warning_kind ());\n+                      pedantic_warning_kind ());\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }"}, {"sha": "7e3ffd65c930bb4a02c8b3acc818d15eff543d80", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -1,3 +1,8 @@\n+2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 35058\n+\t* f95-lang.c (gfc_mark_addressable): All calls to pedwarn changed.\n+\n 2008-07-22  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/29835"}, {"sha": "941f7cd47d2f6146e587cbfaa4ce521ad509a12d", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -604,8 +604,8 @@ gfc_mark_addressable (tree exp)\n \t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n \t\treturn false;\n \t      }\n-\t    pedwarn (\"register variable %qs used in nested function\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n+\t    pedwarn0 (\"register variable %qs used in nested function\",\n+\t\t      IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n \telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n \t  {\n@@ -629,7 +629,7 @@ gfc_mark_addressable (tree exp)\n \t      }\n #endif\n \n-\t    pedwarn (\"address of register variable %qs requested\",\n+\t    pedwarn0 (\"address of register variable %qs requested\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n "}, {"sha": "20eb6666f6d256a4658212bc5eb682c5d6aa1c75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -1,3 +1,9 @@\n+2008-07-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 35058\n+\t* gcc.dg/Wdeclaration-after-statement-3.c: New.\n+\t* gcc/testsuite/gcc.dg/Wpointer-arith.c: New.\n+\t\n 2008-07-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/36852"}, {"sha": "63b2bac5de8272734e4bcdeeb812b4c272d9025e", "filename": "gcc/testsuite/gcc.dg/Wdeclaration-after-statement-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftestsuite%2Fgcc.dg%2FWdeclaration-after-statement-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftestsuite%2Fgcc.dg%2FWdeclaration-after-statement-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWdeclaration-after-statement-3.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -0,0 +1,24 @@\n+/* PR 35058: -Werror= works only with some warnings. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic -Werror=declaration-after-statement\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+int\n+main (void)\n+{\n+  int i = 0;\n+  if (i != 0)\n+    abort ();\n+  i++;\n+  if (i != 1)\n+    abort ();\n+  int j = i;\t\t\t\t/* { dg-error \"\" \"declaration-after-statement\" } */\n+  if (j != 1)\n+    abort ();\n+  struct foo { int i0; } k = { 4 };\t/* { dg-error \"\" \"declaration-after-statement\" } */\n+  if (k.i0 != 4)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "d7a19079cc43db8fdc0bddb22508454fd03f904d", "filename": "gcc/testsuite/gcc.dg/Wpointer-arith.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftestsuite%2Fgcc.dg%2FWpointer-arith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftestsuite%2Fgcc.dg%2FWpointer-arith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWpointer-arith.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -0,0 +1,10 @@\n+/* PR 35058: -Werror= works only with some warnings. */\n+/* { dg-do compile } */\n+/* { dg-options \"-Werror=pointer-arith\" } */\n+void *a;\n+\n+void *test(){\n+  int x=5;\n+  if(a) a++; /* { dg-error \"wrong type argument to increment\" } */\n+  return a+x; /* { dg-error \"pointer of type\" } */\n+}"}, {"sha": "ea24a96c20ef300a63b23eb47316d66847ecfacd", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -825,7 +825,7 @@ check_global_declaration_1 (tree decl)\n \t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n     {\n       if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\tpedwarn (\"%q+F used but never defined\", decl);\n+\tpedwarn (0, \"%q+F used but never defined\", decl);\n       else\n \twarning (OPT_Wunused_function, \"%q+F declared %<static%> but never defined\", decl);\n       /* This symbol is effectively an \"extern\" declaration now.  */"}, {"sha": "f1e4fe500f6330725b30fdec3e2203fb4ef18512", "filename": "gcc/toplev.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf73884fb9b2a6ae5518beb715b3e6fd3161699/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=fcf73884fb9b2a6ae5518beb715b3e6fd3161699", "patch": "@@ -64,7 +64,9 @@ extern void warning_at (location_t, int, const char *, ...)\n extern void error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void fatal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n      ATTRIBUTE_NORETURN;\n-extern void pedwarn (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n+extern void pedwarn0 (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n+/* Pass one of the OPT_W* from options.h as the first parameter.  */\n+extern void pedwarn (int, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void permerror (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void sorry (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void inform (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);"}]}