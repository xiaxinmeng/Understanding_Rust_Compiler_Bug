{"sha": "a00b61e6bfc4a79af55236db0e602e09cd8fda72", "node_id": "C_kwDOANBUbNoAKGEwMGI2MWU2YmZjNGE3OWFmNTUyMzZkYjBlNjAyZTA5Y2Q4ZmRhNzI", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-18T15:07:22Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - find_heap_var_refs\n - find_immediate_fndecl\n - instantiation_dependent_expression_p\n - cp_get_callee\n - build_nop\n - scalarish_type_p\n - type_has_nontrivial_copy_init\n - build_local_temp\n - is_normal_capture_proxy\n - reject_gcc_builtin\n - is_bitfield_expr_with_lowered_type\n - maybe_undo_parenthesized_ref\n - fold_offsetof\n - char_type_p\n - resolve_nondeduced_context\n - null_node_p\n\nFollowing structs, classes and enums are ported in this changeset:\n - c_tree_index\n - warning_sentinel\n - uid_sensitive_constexpr_evaluation_checker\n - iloc_sentinel\n - ptrmem_cst\n\nThis changeset puts c_global_trees and cp_global_trees outside Rust and Compile\nnamespaces because keeping them inside is causing build issues.\nThis is possibly because rust-tree.cc contains only Rust namespace while\nrust-constexpr.cc is Rust+Compile namespace. This causes issues when trying to use\nthem inside both files.\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "372b21fad7406485934f78a8d48c682901a9d832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/372b21fad7406485934f78a8d48c682901a9d832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a00b61e6bfc4a79af55236db0e602e09cd8fda72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00b61e6bfc4a79af55236db0e602e09cd8fda72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a00b61e6bfc4a79af55236db0e602e09cd8fda72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00b61e6bfc4a79af55236db0e602e09cd8fda72/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c13a2e5873f5919c00b5f37b6db52af8d0f7300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c13a2e5873f5919c00b5f37b6db52af8d0f7300"}], "stats": {"total": 910, "additions": 899, "deletions": 11}, "files": [{"sha": "189badabf94dc517d31303a3bb7e76a41de80ace", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 97, "deletions": 8, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b61e6bfc4a79af55236db0e602e09cd8fda72/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b61e6bfc4a79af55236db0e602e09cd8fda72/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=a00b61e6bfc4a79af55236db0e602e09cd8fda72", "patch": "@@ -25,7 +25,9 @@\n #include \"print-tree.h\"\n #include \"gimplify.h\"\n #include \"tree-iterator.h\"\n+#include \"timevar.h\"\n #include \"varasm.h\"\n+#include \"cgraph.h\"\n \n #define VERIFY_CONSTANT(X)                                                     \\\n   do                                                                           \\\n@@ -50,6 +52,11 @@ struct constexpr_global_ctx\n {\n   HOST_WIDE_INT constexpr_ops_count;\n \n+  /* Cleanups that need to be evaluated at the end of CLEANUP_POINT_EXPR.  */\n+  vec<tree> *cleanups;\n+  /* Heap VAR_DECLs created during the evaluation of the outermost constant\n+     expression.  */\n+  auto_vec<tree, 16> heap_vars;\n   constexpr_global_ctx () : constexpr_ops_count (0) {}\n };\n \n@@ -481,6 +488,60 @@ var_in_maybe_constexpr_fn (tree t)\n \n // forked from gcc/cp/constexpr.cc array_index_cmp\n \n+/* Some of the expressions fed to the constexpr mechanism are calls to\n+   constructors, which have type void.  In that case, return the type being\n+   initialized by the constructor.  */\n+\n+static tree\n+initialized_type (tree t)\n+{\n+  if (TYPE_P (t))\n+    return t;\n+  tree type = TREE_TYPE (t);\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    {\n+      /* A constructor call has void type, so we need to look deeper.  */\n+      tree fn = get_function_named_in_call (t);\n+      if (fn && TREE_CODE (fn) == FUNCTION_DECL && DECL_CXX_CONSTRUCTOR_P (fn))\n+\ttype = DECL_CONTEXT (fn);\n+    }\n+  else if (TREE_CODE (t) == COMPOUND_EXPR)\n+    return initialized_type (TREE_OPERAND (t, 1));\n+\n+  return cv_unqualified (type);\n+}\n+\n+/* P0859: A function is needed for constant evaluation if it is a constexpr\n+   function that is named by an expression ([basic.def.odr]) that is\n+   potentially constant evaluated.\n+\n+   So we need to instantiate any constexpr functions mentioned by the\n+   expression even if the definition isn't needed for evaluating the\n+   expression.  */\n+\n+static tree\n+instantiate_cx_fn_r (tree *tp, int *walk_subtrees, void * /*data*/)\n+{\n+  if (TREE_CODE (*tp) == CALL_EXPR)\n+    {\n+      if (EXPR_HAS_LOCATION (*tp))\n+\tinput_location = EXPR_LOCATION (*tp);\n+    }\n+\n+  if (!EXPR_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+static void\n+instantiate_constexpr_fns (tree t)\n+{\n+  location_t loc = input_location;\n+  rs_walk_tree_without_duplicates (&t, instantiate_cx_fn_r, NULL);\n+  input_location = loc;\n+}\n+\n /* Returns less than, equal to, or greater than zero if KEY is found to be\n    less than, to match, or to be greater than the constructor_elt's INDEX.  */\n \n@@ -508,8 +569,6 @@ array_index_cmp (tree key, tree index)\n     }\n }\n \n-// forked from gcc/cp/constexpr.cc unshare_constructor\n-\n /* If T is a CONSTRUCTOR, return an unshared copy of T and any\n    sub-CONSTRUCTORs.  Otherwise return T.\n \n@@ -540,8 +599,6 @@ unshare_constructor (tree t MEM_STAT_DECL)\n   return t;\n }\n \n-// forked from gcc/cp/constexpr.cc find_array_ctor_elt\n-\n /* Returns the index of the constructor_elt of ARY which matches DINDEX, or -1\n    if none.  If INSERT is true, insert a matching element rather than fail.  */\n \n@@ -666,8 +723,6 @@ find_array_ctor_elt (tree ary, tree dindex, bool insert)\n   return -1;\n }\n \n-// forked from gcc/cp/constexpr.cc reduced_constant_expression_p\n-\n /* Return true if T is a valid constant initializer.  If a CONSTRUCTOR\n    initializes all the members, the CONSTRUCTOR_NO_CLEARING flag will be\n    cleared.\n@@ -758,8 +813,6 @@ reduced_constant_expression_p (tree t)\n     }\n }\n \n-// forked from gcc/cp/constexpr.cc verify_constant\n-\n /* Some expressions may have constant operands but are not constant\n    themselves, such as 1/0.  Call this function to check for that\n    condition.\n@@ -794,6 +847,42 @@ verify_constant (tree t, bool allow_non_constant, bool *non_constant_p,\n   return *non_constant_p;\n }\n \n+// forked from gcc/cp/constexpr.cc find_heap_var_refs\n+\n+/* Look for heap variables in the expression *TP.  */\n+\n+static tree\n+find_heap_var_refs (tree *tp, int *walk_subtrees, void * /*data*/)\n+{\n+  if (VAR_P (*tp)\n+      && (DECL_NAME (*tp) == heap_uninit_identifier\n+\t  || DECL_NAME (*tp) == heap_identifier\n+\t  || DECL_NAME (*tp) == heap_vec_uninit_identifier\n+\t  || DECL_NAME (*tp) == heap_vec_identifier\n+\t  || DECL_NAME (*tp) == heap_deleted_identifier))\n+    return *tp;\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/constexpr.cc find_immediate_fndecl\n+\n+/* Find immediate function decls in *TP if any.  */\n+\n+static tree\n+find_immediate_fndecl (tree *tp, int * /*walk_subtrees*/, void * /*data*/)\n+{\n+  if (TREE_CODE (*tp) == FUNCTION_DECL && DECL_IMMEDIATE_FUNCTION_P (*tp))\n+    return *tp;\n+  if (TREE_CODE (*tp) == PTRMEM_CST\n+      && TREE_CODE (PTRMEM_CST_MEMBER (*tp)) == FUNCTION_DECL\n+      && DECL_IMMEDIATE_FUNCTION_P (PTRMEM_CST_MEMBER (*tp)))\n+    return PTRMEM_CST_MEMBER (*tp);\n+  return NULL_TREE;\n+}\n+\n // forked in gcc/cp/constexpr.cc diag_array_subscript\n \n /* Under the control of CTX, issue a detailed diagnostic for"}, {"sha": "22e91f4d828ef07be9edd295b4d9218153dacfcb", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 500, "deletions": 1, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b61e6bfc4a79af55236db0e602e09cd8fda72/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b61e6bfc4a79af55236db0e602e09cd8fda72/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=a00b61e6bfc4a79af55236db0e602e09cd8fda72", "patch": "@@ -26,6 +26,13 @@\n #include \"hash-map.h\"\n #include \"diagnostic.h\"\n #include \"timevar.h\"\n+#include \"convert.h\"\n+#include \"gimple-expr.h\"\n+\n+// forked from gcc/c-family/c-common.cc c_global_trees\n+tree c_global_trees[CTI_MAX];\n+// forked from gcc/cp/decl.cc cp_global_trees\n+tree cp_global_trees[CPTI_MAX];\n \n namespace Rust {\n \n@@ -995,7 +1002,115 @@ rs_type_quals (const_tree type)\n \ttree type_info_type_node, tinfo_decl_id, tinfo_decl_type;\n \ttree tinfo_var_id;  */\n \n-tree cp_global_trees[CPTI_MAX];\n+/* The following symbols are subsumed in the c_global_trees array, and\n+   listed here individually for documentation purposes.\n+\n+   INTEGER_TYPE and REAL_TYPE nodes for the standard data types.\n+\n+\ttree short_integer_type_node;\n+\ttree long_integer_type_node;\n+\ttree long_long_integer_type_node;\n+\n+\ttree short_unsigned_type_node;\n+\ttree long_unsigned_type_node;\n+\ttree long_long_unsigned_type_node;\n+\n+\ttree truthvalue_type_node;\n+\ttree truthvalue_false_node;\n+\ttree truthvalue_true_node;\n+\n+\ttree ptrdiff_type_node;\n+\n+\ttree unsigned_char_type_node;\n+\ttree signed_char_type_node;\n+\ttree wchar_type_node;\n+\n+\ttree char8_type_node;\n+\ttree char16_type_node;\n+\ttree char32_type_node;\n+\n+\ttree float_type_node;\n+\ttree double_type_node;\n+\ttree long_double_type_node;\n+\n+\ttree complex_integer_type_node;\n+\ttree complex_float_type_node;\n+\ttree complex_double_type_node;\n+\ttree complex_long_double_type_node;\n+\n+\ttree dfloat32_type_node;\n+\ttree dfloat64_type_node;\n+\ttree_dfloat128_type_node;\n+\n+\ttree intQI_type_node;\n+\ttree intHI_type_node;\n+\ttree intSI_type_node;\n+\ttree intDI_type_node;\n+\ttree intTI_type_node;\n+\n+\ttree unsigned_intQI_type_node;\n+\ttree unsigned_intHI_type_node;\n+\ttree unsigned_intSI_type_node;\n+\ttree unsigned_intDI_type_node;\n+\ttree unsigned_intTI_type_node;\n+\n+\ttree widest_integer_literal_type_node;\n+\ttree widest_unsigned_literal_type_node;\n+\n+   Nodes for types `void *' and `const void *'.\n+\n+\ttree ptr_type_node, const_ptr_type_node;\n+\n+   Nodes for types `char *' and `const char *'.\n+\n+\ttree string_type_node, const_string_type_node;\n+\n+   Type `char[SOMENUMBER]'.\n+   Used when an array of char is needed and the size is irrelevant.\n+\n+\ttree char_array_type_node;\n+\n+   Type `wchar_t[SOMENUMBER]' or something like it.\n+   Used when a wide string literal is created.\n+\n+\ttree wchar_array_type_node;\n+\n+   Type `char8_t[SOMENUMBER]' or something like it.\n+   Used when a UTF-8 string literal is created.\n+\n+\ttree char8_array_type_node;\n+\n+   Type `char16_t[SOMENUMBER]' or something like it.\n+   Used when a UTF-16 string literal is created.\n+\n+\ttree char16_array_type_node;\n+\n+   Type `char32_t[SOMENUMBER]' or something like it.\n+   Used when a UTF-32 string literal is created.\n+\n+\ttree char32_array_type_node;\n+\n+   Type `int ()' -- used for implicit declaration of functions.\n+\n+\ttree default_function_type;\n+\n+   A VOID_TYPE node, packaged in a TREE_LIST.\n+\n+\ttree void_list_node;\n+\n+  The lazily created VAR_DECLs for __FUNCTION__, __PRETTY_FUNCTION__,\n+  and __func__. (C doesn't generate __FUNCTION__ and__PRETTY_FUNCTION__\n+  VAR_DECLS, but C++ does.)\n+\n+\ttree function_name_decl_node;\n+\ttree pretty_function_name_decl_node;\n+\ttree c99_function_name_decl_node;\n+\n+  Stack of nested function name VAR_DECLs.\n+\n+\ttree saved_function_name_decls;\n+\n+*/\n \n // forked from gcc/cp/module.cc fixed_trees\n \n@@ -1035,6 +1150,7 @@ maybe_add_global (tree val, unsigned &crc)\n /* Global trees.  */\n static const std::pair<tree *, unsigned> global_tree_arys[] = {\n   std::pair<tree *, unsigned> (cp_global_trees, CPTI_MODULE_HWM),\n+  std::pair<tree *, unsigned> (c_global_trees, CTI_MODULE_HWM),\n };\n \n // forked from gcc/cp/module.cc init_modules\n@@ -1051,6 +1167,13 @@ init_modules ()\n     {\n       maybe_add_global (*ptr, crc);\n     }\n+\n+  ptr = global_tree_arys[1].first;\n+  limit = global_tree_arys[1].second;\n+  for (unsigned ix = 0; ix != limit; ix++, ptr++)\n+    {\n+      maybe_add_global (*ptr, crc);\n+    }\n }\n \n // forked from gcc/cp/constexpr.cc var_in_constexpr_fn\n@@ -3222,4 +3345,380 @@ release_tree_vector (vec<tree, va_gc> *vec)\n \t}\n     }\n }\n+\n+// forked from gcc/cp/cvt.cc instantiation_dependent_expression_p\n+\n+/* As above, but also check value-dependence of the expression as a whole.  */\n+\n+bool\n+instantiation_dependent_expression_p (tree expression)\n+{\n+  return false;\n+}\n+\n+// forked from gcc/cp/cvt.cc cp_get_callee\n+\n+/* If CALL is a call, return the callee; otherwise null.  */\n+\n+tree\n+cp_get_callee (tree call)\n+{\n+  if (call == NULL_TREE)\n+    return call;\n+  else if (TREE_CODE (call) == CALL_EXPR)\n+    return CALL_EXPR_FN (call);\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/typeck.cc build_nop\n+\n+/* Return a NOP_EXPR converting EXPR to TYPE.  */\n+\n+tree\n+build_nop (tree type, tree expr)\n+{\n+  if (type == error_mark_node || error_operand_p (expr))\n+    return expr;\n+  return build1_loc (EXPR_LOCATION (expr), NOP_EXPR, type, expr);\n+}\n+\n+// forked from gcc/cp/tree.cc scalarish_type_p\n+\n+/* Returns 1 iff type T is something we want to treat as a scalar type for\n+   the purpose of deciding whether it is trivial/POD/standard-layout.  */\n+\n+bool\n+scalarish_type_p (const_tree t)\n+{\n+  if (t == error_mark_node)\n+    return 1;\n+\n+  return (SCALAR_TYPE_P (t) || VECTOR_TYPE_P (t));\n+}\n+\n+// forked from gcc/cp/tree.cc type_has_nontrivial_copy_init\n+\n+/* Returns true iff copying an object of type T (including via move\n+   constructor) is non-trivial.  That is, T has no non-trivial copy\n+   constructors and no non-trivial move constructors, and not all copy/move\n+   constructors are deleted.  This function implements the ABI notion of\n+   non-trivial copy, which has diverged from the one in the standard.  */\n+\n+bool\n+type_has_nontrivial_copy_init (const_tree type)\n+{\n+  return false;\n+}\n+\n+// forked from gcc/cp/tree.cc build_local_temp\n+\n+/* Return an undeclared local temporary of type TYPE for use in building a\n+   TARGET_EXPR.  */\n+\n+tree\n+build_local_temp (tree type)\n+{\n+  tree slot = build_decl (input_location, VAR_DECL, NULL_TREE, type);\n+  DECL_ARTIFICIAL (slot) = 1;\n+  DECL_IGNORED_P (slot) = 1;\n+  DECL_CONTEXT (slot) = current_function_decl;\n+  layout_decl (slot, 0);\n+  return slot;\n+}\n+\n+// forked from gcc/cp/lambda.cc is_normal_capture_proxy\n+\n+/* Returns true iff DECL is a capture proxy for a normal capture\n+   (i.e. without explicit initializer).  */\n+\n+bool\n+is_normal_capture_proxy (tree decl)\n+{\n+  return false;\n+}\n+\n+// forked from gcc/cp/c-common.cc reject_gcc_builtin\n+\n+/* For an EXPR of a FUNCTION_TYPE that references a GCC built-in function\n+   with no library fallback or for an ADDR_EXPR whose operand is such type\n+   issues an error pointing to the location LOC.\n+   Returns true when the expression has been diagnosed and false\n+   otherwise.  */\n+\n+bool\n+reject_gcc_builtin (const_tree expr, location_t loc /* = UNKNOWN_LOCATION */)\n+{\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n+  if (TREE_TYPE (expr) && TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE\n+      && TREE_CODE (expr) == FUNCTION_DECL\n+      /* The intersection of DECL_BUILT_IN and DECL_IS_UNDECLARED_BUILTIN avoids\n+\t false positives for user-declared built-ins such as abs or\n+\t strlen, and for C++ operators new and delete.\n+\t The c_decl_implicit() test avoids false positives for implicitly\n+\t declared built-ins with library fallbacks (such as abs).  */\n+      && fndecl_built_in_p (expr) && DECL_IS_UNDECLARED_BUILTIN (expr)\n+      && !DECL_ASSEMBLER_NAME_SET_P (expr))\n+    {\n+      if (loc == UNKNOWN_LOCATION)\n+\tloc = EXPR_LOC_OR_LOC (expr, input_location);\n+\n+      /* Reject arguments that are built-in functions with\n+\t no library fallback.  */\n+      error_at (loc, \"built-in function %qE must be directly called\", expr);\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+// forked from gcc/cp/typeck.cc is_bitfield_expr_with_lowered_type\n+\n+/* If EXP is a reference to a bit-field, and the type of EXP does not\n+   match the declared type of the bit-field, return the declared type\n+   of the bit-field.  Otherwise, return NULL_TREE.  */\n+\n+tree\n+is_bitfield_expr_with_lowered_type (const_tree exp)\n+{\n+  switch (TREE_CODE (exp))\n+    {\n+    case COND_EXPR:\n+      if (!is_bitfield_expr_with_lowered_type (TREE_OPERAND (exp, 1)\n+\t\t\t\t\t\t ? TREE_OPERAND (exp, 1)\n+\t\t\t\t\t\t : TREE_OPERAND (exp, 0)))\n+\treturn NULL_TREE;\n+      return is_bitfield_expr_with_lowered_type (TREE_OPERAND (exp, 2));\n+\n+    case COMPOUND_EXPR:\n+      return is_bitfield_expr_with_lowered_type (TREE_OPERAND (exp, 1));\n+\n+    case MODIFY_EXPR:\n+    case SAVE_EXPR:\n+    case UNARY_PLUS_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case NEGATE_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case BIT_NOT_EXPR:\n+      return is_bitfield_expr_with_lowered_type (TREE_OPERAND (exp, 0));\n+\n+      case COMPONENT_REF: {\n+\ttree field;\n+\n+\tfield = TREE_OPERAND (exp, 1);\n+\tif (TREE_CODE (field) != FIELD_DECL || !DECL_BIT_FIELD_TYPE (field))\n+\t  return NULL_TREE;\n+\tif (same_type_ignoring_top_level_qualifiers_p (\n+\t      TREE_TYPE (exp), DECL_BIT_FIELD_TYPE (field)))\n+\t  return NULL_TREE;\n+\treturn DECL_BIT_FIELD_TYPE (field);\n+      }\n+\n+    case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (exp))\n+\treturn is_bitfield_expr_with_lowered_type (\n+\t  DECL_VALUE_EXPR (CONST_CAST_TREE (exp)));\n+      return NULL_TREE;\n+\n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (exp))\n+\treturn is_bitfield_expr_with_lowered_type (TREE_OPERAND (exp, 0));\n+      else\n+\treturn NULL_TREE;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+// forked from gcc/cp/semantics.cc maybe_undo_parenthesized_ref\n+\n+/* If T is an id-expression obfuscated by force_paren_expr, undo the\n+   obfuscation and return the underlying id-expression.  Otherwise\n+   return T.  */\n+\n+tree\n+maybe_undo_parenthesized_ref (tree t)\n+{\n+  if ((TREE_CODE (t) == PAREN_EXPR || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n+      && REF_PARENTHESIZED_P (t))\n+    t = TREE_OPERAND (t, 0);\n+\n+  return t;\n+}\n+\n+// forked from gcc/c-family/c-common.cc fold_offsetof\n+\n+/* Fold an offsetof-like expression.  EXPR is a nested sequence of component\n+   references with an INDIRECT_REF of a constant at the bottom; much like the\n+   traditional rendering of offsetof as a macro.  TYPE is the desired type of\n+   the whole expression.  Return the folded result.  */\n+\n+tree\n+fold_offsetof (tree expr, tree type, enum tree_code ctx)\n+{\n+  tree base, off, t;\n+  tree_code code = TREE_CODE (expr);\n+  switch (code)\n+    {\n+    case ERROR_MARK:\n+      return expr;\n+\n+    case VAR_DECL:\n+      error (\"cannot apply %<offsetof%> to static data member %qD\", expr);\n+      return error_mark_node;\n+\n+    case CALL_EXPR:\n+    case TARGET_EXPR:\n+      error (\"cannot apply %<offsetof%> when %<operator[]%> is overloaded\");\n+      return error_mark_node;\n+\n+    case NOP_EXPR:\n+    case INDIRECT_REF:\n+      if (!TREE_CONSTANT (TREE_OPERAND (expr, 0)))\n+\t{\n+\t  error (\"cannot apply %<offsetof%> to a non constant address\");\n+\t  return error_mark_node;\n+\t}\n+      return convert (type, TREE_OPERAND (expr, 0));\n+\n+    case COMPONENT_REF:\n+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);\n+      if (base == error_mark_node)\n+\treturn base;\n+\n+      t = TREE_OPERAND (expr, 1);\n+      if (DECL_C_BIT_FIELD (t))\n+\t{\n+\t  error (\"attempt to take address of bit-field structure \"\n+\t\t \"member %qD\",\n+\t\t t);\n+\t  return error_mark_node;\n+\t}\n+      off = size_binop_loc (input_location, PLUS_EXPR, DECL_FIELD_OFFSET (t),\n+\t\t\t    size_int (tree_to_uhwi (DECL_FIELD_BIT_OFFSET (t))\n+\t\t\t\t      / BITS_PER_UNIT));\n+      break;\n+\n+    case ARRAY_REF:\n+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);\n+      if (base == error_mark_node)\n+\treturn base;\n+\n+      t = TREE_OPERAND (expr, 1);\n+      STRIP_ANY_LOCATION_WRAPPER (t);\n+\n+      /* Check if the offset goes beyond the upper bound of the array.  */\n+      if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) >= 0)\n+\t{\n+\t  tree upbound = array_ref_up_bound (expr);\n+\t  if (upbound != NULL_TREE && TREE_CODE (upbound) == INTEGER_CST\n+\t      && !tree_int_cst_equal (upbound,\n+\t\t\t\t      TYPE_MAX_VALUE (TREE_TYPE (upbound))))\n+\t    {\n+\t      if (ctx != ARRAY_REF && ctx != COMPONENT_REF)\n+\t\tupbound = size_binop (PLUS_EXPR, upbound,\n+\t\t\t\t      build_int_cst (TREE_TYPE (upbound), 1));\n+\t      if (tree_int_cst_lt (upbound, t))\n+\t\t{\n+\t\t  tree v;\n+\n+\t\t  for (v = TREE_OPERAND (expr, 0);\n+\t\t       TREE_CODE (v) == COMPONENT_REF; v = TREE_OPERAND (v, 0))\n+\t\t    if (TREE_CODE (TREE_TYPE (TREE_OPERAND (v, 0)))\n+\t\t\t== RECORD_TYPE)\n+\t\t      {\n+\t\t\ttree fld_chain = DECL_CHAIN (TREE_OPERAND (v, 1));\n+\t\t\tfor (; fld_chain; fld_chain = DECL_CHAIN (fld_chain))\n+\t\t\t  if (TREE_CODE (fld_chain) == FIELD_DECL)\n+\t\t\t    break;\n+\n+\t\t\tif (fld_chain)\n+\t\t\t  break;\n+\t\t      }\n+\t\t  /* Don't warn if the array might be considered a poor\n+\t\t     man's flexible array member with a very permissive\n+\t\t     definition thereof.  */\n+\t\t  if (TREE_CODE (v) == ARRAY_REF\n+\t\t      || TREE_CODE (v) == COMPONENT_REF)\n+\t\t    warning (OPT_Warray_bounds,\n+\t\t\t     \"index %E denotes an offset \"\n+\t\t\t     \"greater than size of %qT\",\n+\t\t\t     t, TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\t\t}\n+\t    }\n+\t}\n+\n+      t = convert (sizetype, t);\n+      off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);\n+      break;\n+\n+    case COMPOUND_EXPR:\n+      /* Handle static members of volatile structs.  */\n+      t = TREE_OPERAND (expr, 1);\n+      gcc_checking_assert (VAR_P (get_base_address (t)));\n+      return fold_offsetof (t, type);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!POINTER_TYPE_P (type))\n+    return size_binop (PLUS_EXPR, base, convert (type, off));\n+  return fold_build_pointer_plus (base, off);\n+}\n+\n+// forked from gcc/cp/tree.cc char_type_p\n+\n+/* Returns nonzero if TYPE is a character type, including wchar_t.  */\n+\n+int\n+char_type_p (tree type)\n+{\n+  return (same_type_p (type, char_type_node)\n+\t  || same_type_p (type, unsigned_char_type_node)\n+\t  || same_type_p (type, signed_char_type_node)\n+\t  || same_type_p (type, char8_type_node)\n+\t  || same_type_p (type, char16_type_node)\n+\t  || same_type_p (type, char32_type_node)\n+\t  || same_type_p (type, wchar_type_node));\n+}\n+\n+// forked from gcc/cp/pt.cc resolve_nondeduced_context\n+\n+/* Core DR 115: In contexts where deduction is done and fails, or in\n+   contexts where deduction is not done, if a template argument list is\n+   specified and it, along with any default template arguments, identifies\n+   a single function template specialization, then the template-id is an\n+   lvalue for the function template specialization.  */\n+\n+tree\n+resolve_nondeduced_context (tree orig_expr, tsubst_flags_t complain)\n+{\n+  tree expr, offset, baselink;\n+  bool addr;\n+\n+  if (!type_unknown_p (orig_expr))\n+    return orig_expr;\n+\n+  expr = orig_expr;\n+  addr = false;\n+  offset = NULL_TREE;\n+  baselink = NULL_TREE;\n+\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      addr = true;\n+    }\n+\n+  return orig_expr;\n+}\n } // namespace Rust"}, {"sha": "9e8de7cf833f2f51ed4ca7e9f3825c94695b2316", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 302, "deletions": 2, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a00b61e6bfc4a79af55236db0e602e09cd8fda72/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a00b61e6bfc4a79af55236db0e602e09cd8fda72/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=a00b61e6bfc4a79af55236db0e602e09cd8fda72", "patch": "@@ -158,6 +158,89 @@\n #define VAR_OR_FUNCTION_DECL_CHECK(NODE)                                       \\\n   TREE_CHECK2 (NODE, VAR_DECL, FUNCTION_DECL)\n \n+// forked from gcc/cp/c-common.h c_tree_index\n+\n+/* Standard named or nameless data types of the C compiler.  */\n+\n+enum c_tree_index\n+{\n+  CTI_CHAR8_TYPE,\n+  CTI_CHAR16_TYPE,\n+  CTI_CHAR32_TYPE,\n+  CTI_WCHAR_TYPE,\n+  CTI_UNDERLYING_WCHAR_TYPE,\n+  CTI_WINT_TYPE,\n+  CTI_SIGNED_SIZE_TYPE,\t     /* For format checking only.  */\n+  CTI_UNSIGNED_PTRDIFF_TYPE, /* For format checking only.  */\n+  CTI_INTMAX_TYPE,\n+  CTI_UINTMAX_TYPE,\n+  CTI_WIDEST_INT_LIT_TYPE,\n+  CTI_WIDEST_UINT_LIT_TYPE,\n+\n+  /* Types for <stdint.h>, that may not be defined on all\n+     targets.  */\n+  CTI_SIG_ATOMIC_TYPE,\n+  CTI_INT8_TYPE,\n+  CTI_INT16_TYPE,\n+  CTI_INT32_TYPE,\n+  CTI_INT64_TYPE,\n+  CTI_UINT8_TYPE,\n+  CTI_UINT16_TYPE,\n+  CTI_UINT32_TYPE,\n+  CTI_UINT64_TYPE,\n+  CTI_INT_LEAST8_TYPE,\n+  CTI_INT_LEAST16_TYPE,\n+  CTI_INT_LEAST32_TYPE,\n+  CTI_INT_LEAST64_TYPE,\n+  CTI_UINT_LEAST8_TYPE,\n+  CTI_UINT_LEAST16_TYPE,\n+  CTI_UINT_LEAST32_TYPE,\n+  CTI_UINT_LEAST64_TYPE,\n+  CTI_INT_FAST8_TYPE,\n+  CTI_INT_FAST16_TYPE,\n+  CTI_INT_FAST32_TYPE,\n+  CTI_INT_FAST64_TYPE,\n+  CTI_UINT_FAST8_TYPE,\n+  CTI_UINT_FAST16_TYPE,\n+  CTI_UINT_FAST32_TYPE,\n+  CTI_UINT_FAST64_TYPE,\n+  CTI_INTPTR_TYPE,\n+  CTI_UINTPTR_TYPE,\n+\n+  CTI_CHAR_ARRAY_TYPE,\n+  CTI_CHAR8_ARRAY_TYPE,\n+  CTI_CHAR16_ARRAY_TYPE,\n+  CTI_CHAR32_ARRAY_TYPE,\n+  CTI_WCHAR_ARRAY_TYPE,\n+  CTI_STRING_TYPE,\n+  CTI_CONST_STRING_TYPE,\n+\n+  /* Type for boolean expressions (bool in C++, int in C).  */\n+  CTI_TRUTHVALUE_TYPE,\n+  CTI_TRUTHVALUE_TRUE,\n+  CTI_TRUTHVALUE_FALSE,\n+\n+  CTI_DEFAULT_FUNCTION_TYPE,\n+\n+  CTI_NULL,\n+\n+  /* These are not types, but we have to look them up all the time.  */\n+  CTI_FUNCTION_NAME_DECL,\n+  CTI_PRETTY_FUNCTION_NAME_DECL,\n+  CTI_C99_FUNCTION_NAME_DECL,\n+\n+  CTI_MODULE_HWM,\n+  /* Below here entities change during compilation.  */\n+\n+  CTI_SAVED_FUNCTION_NAME_DECLS,\n+\n+  CTI_MAX\n+};\n+\n+// forked from gcc/c-family/c-common.h c_tree_index\n+\n+extern GTY (()) tree c_global_trees[CTI_MAX];\n+\n // forked from gcc/cp/cp-tree.h cp_tree_index\n \n enum cp_tree_index\n@@ -307,6 +390,71 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n /* std::align_val_t */\n #define align_type_node cp_global_trees[CPTI_ALIGN_TYPE]\n \n+#define char8_type_node c_global_trees[CTI_CHAR8_TYPE]\n+#define char16_type_node c_global_trees[CTI_CHAR16_TYPE]\n+#define char32_type_node c_global_trees[CTI_CHAR32_TYPE]\n+#define wchar_type_node c_global_trees[CTI_WCHAR_TYPE]\n+#define underlying_wchar_type_node c_global_trees[CTI_UNDERLYING_WCHAR_TYPE]\n+#define wint_type_node c_global_trees[CTI_WINT_TYPE]\n+#define signed_size_type_node c_global_trees[CTI_SIGNED_SIZE_TYPE]\n+#define unsigned_ptrdiff_type_node c_global_trees[CTI_UNSIGNED_PTRDIFF_TYPE]\n+#define intmax_type_node c_global_trees[CTI_INTMAX_TYPE]\n+#define uintmax_type_node c_global_trees[CTI_UINTMAX_TYPE]\n+#define widest_integer_literal_type_node c_global_trees[CTI_WIDEST_INT_LIT_TYPE]\n+#define widest_unsigned_literal_type_node                                      \\\n+  c_global_trees[CTI_WIDEST_UINT_LIT_TYPE]\n+\n+#define sig_atomic_type_node c_global_trees[CTI_SIG_ATOMIC_TYPE]\n+#define int8_type_node c_global_trees[CTI_INT8_TYPE]\n+#define int16_type_node c_global_trees[CTI_INT16_TYPE]\n+#define int32_type_node c_global_trees[CTI_INT32_TYPE]\n+#define int64_type_node c_global_trees[CTI_INT64_TYPE]\n+#define uint8_type_node c_global_trees[CTI_UINT8_TYPE]\n+#define c_uint16_type_node c_global_trees[CTI_UINT16_TYPE]\n+#define c_uint32_type_node c_global_trees[CTI_UINT32_TYPE]\n+#define c_uint64_type_node c_global_trees[CTI_UINT64_TYPE]\n+#define int_least8_type_node c_global_trees[CTI_INT_LEAST8_TYPE]\n+#define int_least16_type_node c_global_trees[CTI_INT_LEAST16_TYPE]\n+#define int_least32_type_node c_global_trees[CTI_INT_LEAST32_TYPE]\n+#define int_least64_type_node c_global_trees[CTI_INT_LEAST64_TYPE]\n+#define uint_least8_type_node c_global_trees[CTI_UINT_LEAST8_TYPE]\n+#define uint_least16_type_node c_global_trees[CTI_UINT_LEAST16_TYPE]\n+#define uint_least32_type_node c_global_trees[CTI_UINT_LEAST32_TYPE]\n+#define uint_least64_type_node c_global_trees[CTI_UINT_LEAST64_TYPE]\n+#define int_fast8_type_node c_global_trees[CTI_INT_FAST8_TYPE]\n+#define int_fast16_type_node c_global_trees[CTI_INT_FAST16_TYPE]\n+#define int_fast32_type_node c_global_trees[CTI_INT_FAST32_TYPE]\n+#define int_fast64_type_node c_global_trees[CTI_INT_FAST64_TYPE]\n+#define uint_fast8_type_node c_global_trees[CTI_UINT_FAST8_TYPE]\n+#define uint_fast16_type_node c_global_trees[CTI_UINT_FAST16_TYPE]\n+#define uint_fast32_type_node c_global_trees[CTI_UINT_FAST32_TYPE]\n+#define uint_fast64_type_node c_global_trees[CTI_UINT_FAST64_TYPE]\n+#define intptr_type_node c_global_trees[CTI_INTPTR_TYPE]\n+#define uintptr_type_node c_global_trees[CTI_UINTPTR_TYPE]\n+\n+#define truthvalue_type_node c_global_trees[CTI_TRUTHVALUE_TYPE]\n+#define truthvalue_true_node c_global_trees[CTI_TRUTHVALUE_TRUE]\n+#define truthvalue_false_node c_global_trees[CTI_TRUTHVALUE_FALSE]\n+\n+#define char_array_type_node c_global_trees[CTI_CHAR_ARRAY_TYPE]\n+#define char8_array_type_node c_global_trees[CTI_CHAR8_ARRAY_TYPE]\n+#define char16_array_type_node c_global_trees[CTI_CHAR16_ARRAY_TYPE]\n+#define char32_array_type_node c_global_trees[CTI_CHAR32_ARRAY_TYPE]\n+#define wchar_array_type_node c_global_trees[CTI_WCHAR_ARRAY_TYPE]\n+#define string_type_node c_global_trees[CTI_STRING_TYPE]\n+#define const_string_type_node c_global_trees[CTI_CONST_STRING_TYPE]\n+\n+#define default_function_type c_global_trees[CTI_DEFAULT_FUNCTION_TYPE]\n+\n+#define function_name_decl_node c_global_trees[CTI_FUNCTION_NAME_DECL]\n+#define pretty_function_name_decl_node                                         \\\n+  c_global_trees[CTI_PRETTY_FUNCTION_NAME_DECL]\n+#define c99_function_name_decl_node c_global_trees[CTI_C99_FUNCTION_NAME_DECL]\n+#define saved_function_name_decls c_global_trees[CTI_SAVED_FUNCTION_NAME_DECLS]\n+\n+/* The node for C++ `__null'.  */\n+#define null_node c_global_trees[CTI_NULL]\n+\n /* We cache these tree nodes so as to call get_identifier less frequently.\n    For identifiers for functions, including special member functions such\n    as ctors and assignment operators, the nodes can be used (among other\n@@ -911,6 +1059,45 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n /* Nonzero if DECL was declared with '= default' (maybe implicitly).  */\n #define DECL_DEFAULTED_FN(DECL) (LANG_DECL_FN_CHECK (DECL)->defaulted_p)\n \n+/* True if NODE is a brace-enclosed initializer.  */\n+#define BRACE_ENCLOSED_INITIALIZER_P(NODE)                                     \\\n+  (TREE_CODE (NODE) == CONSTRUCTOR && TREE_TYPE (NODE) == init_list_type_node)\n+\n+/* True if FNDECL is an immediate function.  */\n+#define DECL_IMMEDIATE_FUNCTION_P(NODE)                                        \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))                             \\\n+     ? LANG_DECL_FN_CHECK (NODE)->immediate_fn_p                               \\\n+     : false)\n+#define SET_DECL_IMMEDIATE_FUNCTION_P(NODE)                                    \\\n+  (retrofit_lang_decl (FUNCTION_DECL_CHECK (NODE)),                            \\\n+   LANG_DECL_FN_CHECK (NODE)->immediate_fn_p = true)\n+\n+/* True if this CONSTRUCTOR should not be used as a variable initializer\n+   because it was loaded from a constexpr variable with mutable fields.  */\n+#define CONSTRUCTOR_MUTABLE_POISON(NODE)                                       \\\n+  (TREE_LANG_FLAG_2 (CONSTRUCTOR_CHECK (NODE)))\n+\n+/* For a pointer-to-member constant `X::Y' this is the _DECL for\n+   `Y'.  */\n+#define PTRMEM_CST_MEMBER(NODE)                                                \\\n+  (((ptrmem_cst_t) PTRMEM_CST_CHECK (NODE))->member)\n+\n+/* Indicates whether a COMPONENT_REF or a SCOPE_REF has been parenthesized, an\n+   INDIRECT_REF comes from parenthesizing a _DECL, or a PAREN_EXPR identifies a\n+   parenthesized initializer relevant for decltype(auto).  Currently only set\n+   some of the time in C++14 mode.  */\n+\n+#define REF_PARENTHESIZED_P(NODE)                                              \\\n+  TREE_LANG_FLAG_2 (TREE_CHECK5 ((NODE), COMPONENT_REF, INDIRECT_REF,          \\\n+\t\t\t\t SCOPE_REF, VIEW_CONVERT_EXPR, PAREN_EXPR))\n+\n+/* Returns true if NODE is a pointer-to-member.  */\n+#define TYPE_PTRMEM_P(NODE)                                                    \\\n+  (TYPE_PTRDATAMEM_P (NODE) || TYPE_PTRMEMFUNC_P (NODE))\n+\n+/* Returns true if NODE is a pointer or a pointer-to-member.  */\n+#define TYPE_PTR_OR_PTRMEM_P(NODE) (TYPE_PTR_P (NODE) || TYPE_PTRMEM_P (NODE))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -1035,6 +1222,68 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+// forked from gcc/cp/cp-tree.h warning_sentinel\n+\n+/* RAII sentinel to disable certain warnings during template substitution\n+   and elsewhere.  */\n+\n+class warning_sentinel\n+{\n+public:\n+  int &flag;\n+  int val;\n+  warning_sentinel (int &flag, bool suppress = true) : flag (flag), val (flag)\n+  {\n+    if (suppress)\n+      flag = 0;\n+  }\n+  ~warning_sentinel () { flag = val; }\n+};\n+\n+// forked from gcc/cp/cp-tree.h uid_sensitive_constexpr_evaluation_checker\n+\n+/* Used to determine whether uid_sensitive_constexpr_evaluation_p was\n+   called and returned true, indicating that we've restricted constexpr\n+   evaluation in order to avoid UID generation.  We use this to control\n+   updates to the fold_cache and cv_cache.  */\n+\n+struct uid_sensitive_constexpr_evaluation_checker\n+{\n+  const unsigned saved_counter;\n+  uid_sensitive_constexpr_evaluation_checker ();\n+  bool evaluation_restricted_p () const;\n+};\n+\n+// forked from gcc/cp/cp-tree.h iloc_sentinel\n+\n+/* RAII sentinel to temporarily override input_location.  This will not set\n+   input_location to UNKNOWN_LOCATION or BUILTINS_LOCATION.  */\n+\n+class iloc_sentinel\n+{\n+  location_t saved_loc;\n+\n+public:\n+  iloc_sentinel (location_t loc) : saved_loc (input_location)\n+  {\n+    if (loc >= RESERVED_LOCATION_COUNT)\n+      input_location = loc;\n+  }\n+  ~iloc_sentinel () { input_location = saved_loc; }\n+};\n+\n+// forked from gcc/cp/cp-tree.h ptrmem_cst\n+\n+struct GTY (()) ptrmem_cst\n+{\n+  struct tree_common common;\n+  tree member;\n+  location_t locus;\n+};\n+typedef struct ptrmem_cst *ptrmem_cst_t;\n+\n+// forked from gcc/cp/cp-tree.h named_decl_hash\n+\n /* hash traits for declarations.  Hashes potential overload sets via\n    DECL_NAME.  */\n \n@@ -1736,8 +1985,8 @@ mark_use (tree expr, bool rvalue_p, bool read_p, location_t loc,\n // function with no library fallback (or any of its bits, such as in\n // a conversion to bool).\n extern tree\n-mark_rvalue_use (tree e, location_t loc /* = UNKNOWN_LOCATION */,\n-\t\t bool reject_builtin /* = true */);\n+mark_rvalue_use (tree, location_t = UNKNOWN_LOCATION,\n+\t\t bool reject_builtin = true);\n \n // Called whenever an expression is used in an lvalue context.\n extern tree\n@@ -1901,6 +2150,50 @@ extern bool reduced_constant_expression_p (tree);\n \n extern tree cv_unqualified (tree);\n \n+extern tree cp_get_callee (tree);\n+extern tree cp_get_callee_fndecl_nofold (tree);\n+\n+extern bool is_nondependent_static_init_expression (tree);\n+\n+extern tree\n+maybe_constant_init (tree, tree = NULL_TREE, bool = false);\n+\n+extern tree build_nop (tree, tree);\n+\n+extern bool scalarish_type_p (const_tree);\n+\n+extern tree is_bitfield_expr_with_lowered_type (const_tree);\n+\n+extern tree convert_bitfield_to_declared_type (tree);\n+\n+extern tree\n+cp_fold_maybe_rvalue (tree, bool);\n+\n+extern tree maybe_undo_parenthesized_ref (tree);\n+\n+extern tree\n+fold_offsetof (tree, tree = size_type_node, tree_code ctx = ERROR_MARK);\n+\n+extern tree cp_truthvalue_conversion (tree, tsubst_flags_t);\n+\n+extern tree\n+fold_non_dependent_expr (tree, tsubst_flags_t = tf_warning_or_error,\n+\t\t\t bool = false, tree = NULL_TREE);\n+\n+extern int char_type_p (tree);\n+\n+extern bool instantiation_dependent_expression_p (tree);\n+\n+extern bool type_has_nontrivial_copy_init (const_tree);\n+\n+extern tree build_local_temp (tree);\n+\n+extern bool is_normal_capture_proxy (tree);\n+\n+extern bool reject_gcc_builtin (const_tree, location_t = UNKNOWN_LOCATION);\n+\n+extern tree resolve_nondeduced_context (tree, tsubst_flags_t);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -2062,6 +2355,13 @@ vec_safe_push (releasing_vec &r, const tree &t CXX_MEM_STAT_INFO)\n   return vec_safe_push (*&r, t PASS_MEM_STAT);\n }\n \n+inline bool\n+null_node_p (const_tree expr)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+  return expr == null_node;\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}