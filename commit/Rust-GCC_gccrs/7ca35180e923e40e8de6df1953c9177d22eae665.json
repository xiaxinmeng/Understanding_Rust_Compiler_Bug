{"sha": "7ca35180e923e40e8de6df1953c9177d22eae665", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhMzUxODBlOTIzZTQwZThkZTZkZjE5NTNjOTE3N2QyMmVhZTY2NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-05-11T23:33:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-05-11T23:33:23Z"}, "message": "Convert to md_asm_adjust\n\nUsing proper vectors instead of lists of trees.\n\nFrom-SVN: r223025", "tree": {"sha": "caa8a966e2b428095382916220510834997b1c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caa8a966e2b428095382916220510834997b1c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ca35180e923e40e8de6df1953c9177d22eae665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca35180e923e40e8de6df1953c9177d22eae665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca35180e923e40e8de6df1953c9177d22eae665", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca35180e923e40e8de6df1953c9177d22eae665/comments", "author": null, "committer": null, "parents": [{"sha": "15a85b055d38e8f0000da08d80e143a89ecb827e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a85b055d38e8f0000da08d80e143a89ecb827e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15a85b055d38e8f0000da08d80e143a89ecb827e"}], "stats": {"total": 894, "additions": 445, "deletions": 449}, "files": [{"sha": "a4690b78399ca9c535ce9239be02fae9a3f35f6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -1,3 +1,47 @@\n+2015-05-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* target.def (md_asm_clobbers): Replace with...\n+\t(md_asm_adjust): this.\n+\t* tm.texi.in (TARGET_MD_ASM_CLOBBERS): Remove.\n+\t(TARGET_MD_ASM_ADJUST): New.\n+\t* tm.texi: Rebuild.\n+\t* hooks.c (hook_tree_tree_tree_tree_3rd_identity): Remove.\n+\t* hooks.h (hook_tree_tree_tree_tree_3rd_identity): Remove.\n+\t* system.h (TARGET_MD_ASM_CLOBBERS): Poison.\n+\n+\t* cfgexpand.c (check_operand_nalternatives): Accept vector of\n+\tconstraints instead of lists of outputs and inputs.\n+\t(expand_asm_stmt): Save and restore input_location around the\n+\tbody of the function.  Move asm data into vectors instead of\n+\tbuilding tree lists.  Generate cleanup sequences as needed,\n+\trather than waiting til the end.  Use new md_asm_adjust hook.\n+\n+\t* config/vxworks.c: Include vec.h before target.h.\n+\t* gimple.c: Likewise.\n+\t* incpath.c: Likewise.\n+\t* mode-switching.c: Likewise.\n+\n+\t* config/cris/cris.c (cris_md_asm_clobbers): Convert to...\n+\t(cris_md_asm_adjust): this.\n+\t(TARGET_MD_ASM_CLOBBERS): Remove.\n+\t(TARGET_MD_ASM_ADJUST): New.\n+\t* config/i386/i386.c (ix86_md_asm_clobbers): Convert to...\n+\t(ix86_md_asm_adjust): this.\n+\t(TARGET_MD_ASM_CLOBBERS): Remove.\n+\t(TARGET_MD_ASM_ADJUST): New.\n+\t* config/mn10300/mn10300.c (mn10300_md_asm_clobbers): Convert to...\n+\t(mn10300_md_asm_adjust): this.\n+\t(TARGET_MD_ASM_CLOBBERS): Remove.\n+\t(TARGET_MD_ASM_ADJUST): New.\n+\t* config/rs6000/rs6000.c (rs6000_md_asm_clobbers): Convert to...\n+\t(rs6000_md_asm_adjust): this.\n+\t(TARGET_MD_ASM_CLOBBERS): Remove.\n+\t(TARGET_MD_ASM_ADJUST): New.\n+\t* config/visium/visium.c (visium_md_asm_clobbers): Convert to...\n+\t(visium_md_asm_adjust): this.\n+\t(TARGET_MD_ASM_CLOBBERS): Remove.\n+\t(TARGET_MD_ASM_ADJUST): New.\n+\n 2015-05-11  Richard Henderson  <rth@redhat.com>\n \n \t* gimplify.c (gimplify_asm_expr): Set gimple_asm_volatile_p"}, {"sha": "09e668acb7cda84a278fe31fcffc664fad02c9b4", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 286, "deletions": 327, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -2438,41 +2438,27 @@ n_occurrences (int c, const char *s)\n    the same number of alternatives.  Return true if so.  */\n \n static bool\n-check_operand_nalternatives (tree outputs, tree inputs)\n+check_operand_nalternatives (const vec<const char *> &constraints)\n {\n-  if (outputs || inputs)\n+  unsigned len = constraints.length();\n+  if (len > 0)\n     {\n-      tree tmp = TREE_PURPOSE (outputs ? outputs : inputs);\n-      int nalternatives\n-\t= n_occurrences (',', TREE_STRING_POINTER (TREE_VALUE (tmp)));\n-      tree next = inputs;\n+      int nalternatives = n_occurrences (',', constraints[0]);\n \n       if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n \t{\n \t  error (\"too many alternatives in %<asm%>\");\n \t  return false;\n \t}\n \n-      tmp = outputs;\n-      while (tmp)\n-\t{\n-\t  const char *constraint\n-\t    = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tmp)));\n-\n-\t  if (n_occurrences (',', constraint) != nalternatives)\n-\t    {\n-\t      error (\"operand constraints for %<asm%> differ \"\n-\t\t     \"in number of alternatives\");\n-\t      return false;\n-\t    }\n-\n-\t  if (TREE_CHAIN (tmp))\n-\t    tmp = TREE_CHAIN (tmp);\n-\t  else\n-\t    tmp = next, next = 0;\n-\t}\n+      for (unsigned i = 1; i < len; ++i)\n+\tif (n_occurrences (',', constraints[i]) != nalternatives)\n+\t  {\n+\t    error (\"operand constraints for %<asm%> differ \"\n+\t\t   \"in number of alternatives\");\n+\t    return false;\n+\t  }\n     }\n-\n   return true;\n }\n \n@@ -2524,156 +2510,145 @@ tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n static void\n expand_asm_stmt (gasm *stmt)\n {\n-  int noutputs, ninputs, nclobbers, nlabels, i;\n-  tree string, outputs, inputs, clobbers, labels, tail, t;\n-  location_t locus = gimple_location (stmt);\n-  basic_block fallthru_bb = NULL;\n-\n-  /* Meh... convert the gimple asm operands into real tree lists.\n-     Eventually we should make all routines work on the vectors instead\n-     of relying on TREE_CHAIN.  */\n-  outputs = NULL_TREE;\n-  noutputs = gimple_asm_noutputs (stmt);\n-  if (noutputs > 0)\n-    {\n-      t = outputs = gimple_asm_output_op (stmt, 0);\n-      for (i = 1; i < noutputs; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n-    }\n+  class save_input_location\n+  {\n+    location_t old;\n \n-  inputs = NULL_TREE;\n-  ninputs = gimple_asm_ninputs (stmt);\n-  if (ninputs > 0)\n+  public:\n+    explicit save_input_location(location_t where)\n     {\n-      t = inputs = gimple_asm_input_op (stmt, 0);\n-      for (i = 1; i < ninputs; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n+      old = input_location;\n+      input_location = where;\n     }\n \n-  clobbers = NULL_TREE;\n-  nclobbers = gimple_asm_nclobbers (stmt);\n-  if (nclobbers > 0)\n+    ~save_input_location()\n     {\n-      t = clobbers = gimple_asm_clobber_op (stmt, 0);\n-      for (i = 1; i < nclobbers; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n+      input_location = old;\n     }\n+  };\n \n-  labels = NULL_TREE;\n-  nlabels = gimple_asm_nlabels (stmt);\n-  if (nlabels > 0)\n+  location_t locus = gimple_location (stmt);\n+\n+  if (gimple_asm_input_p (stmt))\n     {\n-      edge fallthru = find_fallthru_edge (gimple_bb (stmt)->succs);\n-      if (fallthru)\n-\tfallthru_bb = fallthru->dest;\n-      t = labels = gimple_asm_label_op (stmt, 0);\n-      for (i = 1; i < nlabels; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_label_op (stmt, i);\n+      const char *s = gimple_asm_string (stmt);\n+      tree string = build_string (strlen (s), s);\n+      expand_asm_loc (string, gimple_asm_volatile_p (stmt), locus);\n+      return;\n     }\n \n-  {\n-    const char *s = gimple_asm_string (stmt);\n-    string = build_string (strlen (s), s);\n-  }\n+  /* There are some legacy diagnostics in here, and also avoids a\n+     sixth parameger to targetm.md_asm_adjust.  */\n+  save_input_location s_i_l(locus);\n \n-  if (gimple_asm_input_p (stmt))\n+  unsigned noutputs = gimple_asm_noutputs (stmt);\n+  unsigned ninputs = gimple_asm_ninputs (stmt);\n+  unsigned nlabels = gimple_asm_nlabels (stmt);\n+  unsigned i;\n+\n+  /* ??? Diagnose during gimplification?  */\n+  if (ninputs + noutputs + nlabels > MAX_RECOG_OPERANDS)\n     {\n-      expand_asm_loc (string, gimple_asm_volatile_p (stmt), locus);\n+      error (\"more than %d operands in %<asm%>\", MAX_RECOG_OPERANDS);\n       return;\n     }\n \n-  /* Record the contents of OUTPUTS before it is modified.  */\n-  tree *orig_outputs = XALLOCAVEC (tree, noutputs);\n-  for (i = 0; i < noutputs; ++i)\n-    orig_outputs[i] = TREE_VALUE (gimple_asm_output_op (stmt, i));\n+  auto_vec<tree, MAX_RECOG_OPERANDS> output_tvec;\n+  auto_vec<tree, MAX_RECOG_OPERANDS> input_tvec;\n+  auto_vec<const char *, MAX_RECOG_OPERANDS> constraints;\n \n-  rtvec argvec, constraintvec, labelvec;\n-  rtx body;\n-  int ninout;\n-  HARD_REG_SET clobbered_regs;\n-  int clobber_conflict_found = 0;\n-  /* Vector of RTX's of evaluated output operands.  */\n-  rtx *output_rtx = XALLOCAVEC (rtx, noutputs);\n-  int *inout_opnum = XALLOCAVEC (int, noutputs);\n-  rtx *real_output_rtx = XALLOCAVEC (rtx, noutputs);\n-  machine_mode *inout_mode = XALLOCAVEC (machine_mode, noutputs);\n-  const char **constraints = XALLOCAVEC (const char *, noutputs + ninputs);\n-  int old_generating_concat_p = generating_concat_p;\n-  rtx_code_label *fallthru_label = NULL;\n+  /* Copy the gimple vectors into new vectors that we can manipulate.  */\n \n-  if (! check_operand_nalternatives (outputs, inputs))\n-    return;\n+  output_tvec.safe_grow (noutputs);\n+  input_tvec.safe_grow (ninputs);\n+  constraints.safe_grow (noutputs + ninputs);\n \n-  /* Collect constraints.  */\n-  i = 0;\n-  for (t = outputs; t ; t = TREE_CHAIN (t), i++)\n-    constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n-  for (t = inputs; t ; t = TREE_CHAIN (t), i++)\n-    constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+  for (i = 0; i < noutputs; ++i)\n+    {\n+      tree t = gimple_asm_output_op (stmt, i);\n+      output_tvec[i] = TREE_VALUE (t);\n+      constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+    }\n+  for (i = 0; i < ninputs; i++)\n+    {\n+      tree t = gimple_asm_input_op (stmt, i);\n+      input_tvec[i] = TREE_VALUE (t);\n+      constraints[i + noutputs]\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+    }\n \n-  /* Sometimes we wish to automatically clobber registers across an asm.\n-     Case in point is when the i386 backend moved from cc0 to a hard reg --\n-     maintaining source-level compatibility means automatically clobbering\n-     the flags register.  */\n-  clobbers = targetm.md_asm_clobbers (outputs, inputs, clobbers);\n+  /* ??? Diagnose during gimplification?  */\n+  if (! check_operand_nalternatives (constraints))\n+    return;\n \n   /* Count the number of meaningful clobbered registers, ignoring what\n      we would ignore later.  */\n-  nclobbers = 0;\n+  auto_vec<rtx> clobber_rvec;\n+  HARD_REG_SET clobbered_regs;\n   CLEAR_HARD_REG_SET (clobbered_regs);\n-  for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n-    {\n-      const char *regname;\n-      int nregs;\n-\n-      if (TREE_VALUE (tail) == error_mark_node)\n-\treturn;\n-      regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n-\n-      i = decode_reg_name_and_count (regname, &nregs);\n-      if (i == -4)\n-\t++nclobbers;\n-      else if (i == -2)\n-\terror (\"unknown register name %qs in %<asm%>\", regname);\n \n-      /* Mark clobbered registers.  */\n-      if (i >= 0)\n-        {\n-\t  int reg;\n+  if (unsigned n = gimple_asm_nclobbers (stmt))\n+    {\n+      clobber_rvec.reserve (n);\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  tree t = gimple_asm_clobber_op (stmt, i);\n+          const char *regname = TREE_STRING_POINTER (TREE_VALUE (t));\n+\t  int nregs, j;\n \n-\t  for (reg = i; reg < i + nregs; reg++)\n+\t  j = decode_reg_name_and_count (regname, &nregs);\n+\t  if (j < 0)\n \t    {\n-\t      ++nclobbers;\n-\n-\t      /* Clobbering the PIC register is an error.  */\n-\t      if (reg == (int) PIC_OFFSET_TABLE_REGNUM)\n+\t      if (j == -2)\n \t\t{\n-\t\t  error (\"PIC register clobbered by %qs in %<asm%>\", regname);\n-\t\t  return;\n+\t\t  /* ??? Diagnose during gimplification?  */\n+\t\t  error (\"unknown register name %qs in %<asm%>\", regname);\n+\t\t}\n+\t      else if (j == -4)\n+\t\t{\n+\t\t  rtx x = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode));\n+\t\t  clobber_rvec.safe_push (x);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Otherwise we should have -1 == empty string\n+\t\t     or -3 == cc, which is not a register.  */\n+\t\t  gcc_assert (j == -1 || j == -3);\n \t\t}\n-\n-\t      SET_HARD_REG_BIT (clobbered_regs, reg);\n \t    }\n+\t  else\n+\t    for (int reg = j; reg < j + nregs; reg++)\n+\t      {\n+\t\t/* Clobbering the PIC register is an error.  */\n+\t\tif (reg == (int) PIC_OFFSET_TABLE_REGNUM)\n+\t\t  {\n+\t\t    /* ??? Diagnose during gimplification?  */\n+\t\t    error (\"PIC register clobbered by %qs in %<asm%>\",\n+\t\t\t   regname);\n+\t\t    return;\n+\t\t  }\n+\n+\t        SET_HARD_REG_BIT (clobbered_regs, reg);\n+\t        rtx x = gen_rtx_REG (reg_raw_mode[reg], reg);\n+\t\tclobber_rvec.safe_push (x);\n+\t      }\n \t}\n     }\n+  unsigned nclobbers = clobber_rvec.length();\n \n   /* First pass over inputs and outputs checks validity and sets\n      mark_addressable if needed.  */\n+  /* ??? Diagnose during gimplification?  */\n \n-  ninout = 0;\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+  for (i = 0; i < noutputs; ++i)\n     {\n-      tree val = TREE_VALUE (tail);\n+      tree val = output_tvec[i];\n       tree type = TREE_TYPE (val);\n       const char *constraint;\n       bool is_inout;\n       bool allows_reg;\n       bool allows_mem;\n \n-      /* If there's an erroneous arg, emit no insn.  */\n-      if (type == error_mark_node)\n-\treturn;\n-\n       /* Try to parse the output constraint.  If that fails, there's\n \t no point in going further.  */\n       constraint = constraints[i];\n@@ -2688,53 +2663,43 @@ expand_asm_stmt (gasm *stmt)\n \t\t  && REG_P (DECL_RTL (val))\n \t\t  && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n \tmark_addressable (val);\n-\n-      if (is_inout)\n-\tninout++;\n-    }\n-\n-  ninputs += ninout;\n-  if (ninputs + noutputs + nlabels > MAX_RECOG_OPERANDS)\n-    {\n-      error (\"more than %d operands in %<asm%>\", MAX_RECOG_OPERANDS);\n-      return;\n     }\n \n-  for (i = 0, tail = inputs; tail; i++, tail = TREE_CHAIN (tail))\n+  for (i = 0; i < ninputs; ++i)\n     {\n       bool allows_reg, allows_mem;\n       const char *constraint;\n \n-      /* If there's an erroneous arg, emit no insn, because the ASM_INPUT\n-\t would get VOIDmode and that could cause a crash in reload.  */\n-      if (TREE_TYPE (TREE_VALUE (tail)) == error_mark_node)\n-\treturn;\n-\n       constraint = constraints[i + noutputs];\n-      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n-\t\t\t\t    constraints, &allows_mem, &allows_reg))\n+      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n+\t\t\t\t    constraints.address (),\n+\t\t\t\t    &allows_mem, &allows_reg))\n \treturn;\n \n       if (! allows_reg && allows_mem)\n-\tmark_addressable (TREE_VALUE (tail));\n+\tmark_addressable (input_tvec[i]);\n     }\n \n   /* Second pass evaluates arguments.  */\n \n   /* Make sure stack is consistent for asm goto.  */\n   if (nlabels > 0)\n     do_pending_stack_adjust ();\n+  int old_generating_concat_p = generating_concat_p;\n+\n+  /* Vector of RTX's of evaluated output operands.  */\n+  auto_vec<rtx, MAX_RECOG_OPERANDS> output_rvec;\n+  auto_vec<int, MAX_RECOG_OPERANDS> inout_opnum;\n+  rtx_insn *after_rtl_seq = NULL, *after_rtl_end = NULL;\n+\n+  output_rvec.safe_grow (noutputs);\n \n-  ninout = 0;\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+  for (i = 0; i < noutputs; ++i)\n     {\n-      tree val = TREE_VALUE (tail);\n+      tree val = output_tvec[i];\n       tree type = TREE_TYPE (val);\n-      bool is_inout;\n-      bool allows_reg;\n-      bool allows_mem;\n+      bool is_inout, allows_reg, allows_mem, ok;\n       rtx op;\n-      bool ok;\n \n       ok = parse_output_constraint (&constraints[i], i, ninputs,\n \t\t\t\t    noutputs, &allows_mem, &allows_reg,\n@@ -2743,12 +2708,11 @@ expand_asm_stmt (gasm *stmt)\n \n       /* If an output operand is not a decl or indirect ref and our constraint\n \t allows a register, make a temporary to act as an intermediate.\n-\t Make the asm insn write into that, then our caller will copy it to\n+\t Make the asm insn write into that, then we will copy it to\n \t the real output operand.  Likewise for promoted variables.  */\n \n       generating_concat_p = 0;\n \n-      real_output_rtx[i] = NULL_RTX;\n       if ((TREE_CODE (val) == INDIRECT_REF\n \t   && allows_mem)\n \t  || (DECL_P (val)\n@@ -2768,69 +2732,64 @@ expand_asm_stmt (gasm *stmt)\n \t  if ((! allows_mem && MEM_P (op))\n \t      || GET_CODE (op) == CONCAT)\n \t    {\n-\t      real_output_rtx[i] = op;\n+\t      rtx old_op = op;\n \t      op = gen_reg_rtx (GET_MODE (op));\n+\n+\t      generating_concat_p = old_generating_concat_p;\n+\n \t      if (is_inout)\n-\t\temit_move_insn (op, real_output_rtx[i]);\n+\t\temit_move_insn (op, old_op);\n+\n+\t      push_to_sequence2 (after_rtl_seq, after_rtl_end);\n+\t      emit_move_insn (old_op, op);\n+\t      after_rtl_seq = get_insns ();\n+\t      after_rtl_end = get_last_insn ();\n+\t      end_sequence ();\n \t    }\n \t}\n       else\n \t{\n \t  op = assign_temp (type, 0, 1);\n \t  op = validize_mem (op);\n-\t  if (!MEM_P (op) && TREE_CODE (TREE_VALUE (tail)) == SSA_NAME)\n-\t    set_reg_attrs_for_decl_rtl (SSA_NAME_VAR (TREE_VALUE (tail)), op);\n-\t  TREE_VALUE (tail) = make_tree (type, op);\n-\t}\n-      output_rtx[i] = op;\n+\t  if (!MEM_P (op) && TREE_CODE (val) == SSA_NAME)\n+\t    set_reg_attrs_for_decl_rtl (SSA_NAME_VAR (val), op);\n \n-      generating_concat_p = old_generating_concat_p;\n+\t  generating_concat_p = old_generating_concat_p;\n \n-      if (is_inout)\n-\t{\n-\t  inout_mode[ninout] = TYPE_MODE (type);\n-\t  inout_opnum[ninout++] = i;\n+\t  push_to_sequence2 (after_rtl_seq, after_rtl_end);\n+\t  expand_assignment (val, make_tree (type, op), false);\n+\t  after_rtl_seq = get_insns ();\n+\t  after_rtl_end = get_last_insn ();\n+\t  end_sequence ();\n \t}\n+      output_rvec[i] = op;\n \n-      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n-\tclobber_conflict_found = 1;\n+      if (is_inout)\n+\tinout_opnum.safe_push (i);\n     }\n \n-  /* Make vectors for the expression-rtx, constraint strings,\n-     and named operands.  */\n-\n-  argvec = rtvec_alloc (ninputs);\n-  constraintvec = rtvec_alloc (ninputs);\n-  labelvec = rtvec_alloc (nlabels);\n+  auto_vec<rtx, MAX_RECOG_OPERANDS> input_rvec;\n+  auto_vec<machine_mode, MAX_RECOG_OPERANDS> input_mode;\n \n-  body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n-\t\t\t\t: GET_MODE (output_rtx[0])),\n-\t\t\t       ggc_strdup (TREE_STRING_POINTER (string)),\n-\t\t\t       empty_string, 0, argvec, constraintvec,\n-\t\t\t       labelvec, locus);\n+  input_rvec.safe_grow (ninputs);\n+  input_mode.safe_grow (ninputs);\n \n-  MEM_VOLATILE_P (body) = gimple_asm_volatile_p (stmt);\n-\n-  /* Eval the inputs and put them into ARGVEC.\n-     Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */\n+  generating_concat_p = 0;\n \n-  for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), ++i)\n+  for (i = 0; i < ninputs; ++i)\n     {\n-      bool allows_reg, allows_mem;\n+      tree val = input_tvec[i];\n+      tree type = TREE_TYPE (val);\n+      bool allows_reg, allows_mem, ok;\n       const char *constraint;\n-      tree val, type;\n       rtx op;\n-      bool ok;\n \n       constraint = constraints[i + noutputs];\n-      ok = parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n-\t\t\t\t   constraints, &allows_mem, &allows_reg);\n+      ok = parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n+\t\t\t\t   constraints.address (),\n+\t\t\t\t   &allows_mem, &allows_reg);\n       gcc_assert (ok);\n \n-      generating_concat_p = 0;\n-\n-      val = TREE_VALUE (tail);\n-      type = TREE_TYPE (val);\n       /* EXPAND_INITIALIZER will not generate code for valid initializer\n \t constants, but will still generate code for other types of operand.\n \t This is the behavior we want for constant constraints.  */\n@@ -2861,61 +2820,109 @@ expand_asm_stmt (gasm *stmt)\n \t  else\n \t    gcc_unreachable ();\n \t}\n-\n-      generating_concat_p = old_generating_concat_p;\n-      ASM_OPERANDS_INPUT (body, i) = op;\n-\n-      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n-\t= gen_rtx_ASM_INPUT_loc (TYPE_MODE (type),\n-\t\t\t\t ggc_strdup (constraints[i + noutputs]),\n-\t\t\t\t locus);\n-\n-      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n-\tclobber_conflict_found = 1;\n+      input_rvec[i] = op;\n+      input_mode[i] = TYPE_MODE (type);\n     }\n \n-  /* Protect all the operands from the queue now that they have all been\n-     evaluated.  */\n-\n-  generating_concat_p = 0;\n-\n   /* For in-out operands, copy output rtx to input rtx.  */\n+  unsigned ninout = inout_opnum.length();\n   for (i = 0; i < ninout; i++)\n     {\n       int j = inout_opnum[i];\n-      char buffer[16];\n+      rtx o = output_rvec[j];\n \n-      ASM_OPERANDS_INPUT (body, ninputs - ninout + i)\n-\t= output_rtx[j];\n+      input_rvec.safe_push (o);\n+      input_mode.safe_push (GET_MODE (o));\n \n+      char buffer[16];\n       sprintf (buffer, \"%d\", j);\n-      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, ninputs - ninout + i)\n-\t= gen_rtx_ASM_INPUT_loc (inout_mode[i], ggc_strdup (buffer), locus);\n+      constraints.safe_push (ggc_strdup (buffer));\n+    }\n+  ninputs += ninout;\n+\n+  /* Sometimes we wish to automatically clobber registers across an asm.\n+     Case in point is when the i386 backend moved from cc0 to a hard reg --\n+     maintaining source-level compatibility means automatically clobbering\n+     the flags register.  */\n+  rtx_insn *after_md_seq = NULL;\n+  if (targetm.md_asm_adjust)\n+    after_md_seq = targetm.md_asm_adjust (output_rvec, input_rvec,\n+\t\t\t\t\t  constraints, clobber_rvec,\n+\t\t\t\t\t  clobbered_regs);\n+\n+  /* Do not allow the hook to change the output and input count,\n+     lest it mess up the operand numbering.  */\n+  gcc_assert (output_rvec.length() == noutputs);\n+  gcc_assert (input_rvec.length() == ninputs);\n+  gcc_assert (constraints.length() == noutputs + ninputs);\n+\n+  /* But it certainly can adjust the clobbers.  */\n+  nclobbers = clobber_rvec.length();\n+\n+  /* Third pass checks for easy conflicts.  */\n+  /* ??? Why are we doing this on trees instead of rtx.  */\n+\n+  bool clobber_conflict_found = 0;\n+  for (i = 0; i < noutputs; ++i)\n+    if (tree_conflicts_with_clobbers_p (output_tvec[i], &clobbered_regs))\n+\tclobber_conflict_found = 1;\n+  for (i = 0; i < ninputs - ninout; ++i)\n+    if (tree_conflicts_with_clobbers_p (input_tvec[i], &clobbered_regs))\n+\tclobber_conflict_found = 1;\n+\n+  /* Make vectors for the expression-rtx, constraint strings,\n+     and named operands.  */\n+\n+  rtvec argvec = rtvec_alloc (ninputs);\n+  rtvec constraintvec = rtvec_alloc (ninputs);\n+  rtvec labelvec = rtvec_alloc (nlabels);\n+\n+  rtx body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n+\t\t\t\t    : GET_MODE (output_rvec[0])),\n+\t\t\t\t   ggc_strdup (gimple_asm_string (stmt)),\n+\t\t\t\t   empty_string, 0, argvec, constraintvec,\n+\t\t\t\t   labelvec, locus);\n+  MEM_VOLATILE_P (body) = gimple_asm_volatile_p (stmt);\n+\n+  for (i = 0; i < ninputs; ++i)\n+    {\n+      ASM_OPERANDS_INPUT (body, i) = input_rvec[i];\n+      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n+\t= gen_rtx_ASM_INPUT_loc (input_mode[i],\n+\t\t\t\t constraints[i + noutputs],\n+\t\t\t\t locus);\n     }\n \n   /* Copy labels to the vector.  */\n-  for (i = 0, tail = labels; i < nlabels; ++i, tail = TREE_CHAIN (tail))\n+  rtx_code_label *fallthru_label = NULL;\n+  if (nlabels > 0)\n     {\n-      rtx r;\n-      /* If asm goto has any labels in the fallthru basic block, use\n-\t a label that we emit immediately after the asm goto.  Expansion\n-\t may insert further instructions into the same basic block after\n-\t asm goto and if we don't do this, insertion of instructions on\n-\t the fallthru edge might misbehave.  See PR58670.  */\n-      if (fallthru_bb\n-\t  && label_to_block_fn (cfun, TREE_VALUE (tail)) == fallthru_bb)\n+      basic_block fallthru_bb = NULL;\n+      edge fallthru = find_fallthru_edge (gimple_bb (stmt)->succs);\n+      if (fallthru)\n+\tfallthru_bb = fallthru->dest;\n+\n+      for (i = 0; i < nlabels; ++i)\n \t{\n-\t  if (fallthru_label == NULL_RTX)\n-\t    fallthru_label = gen_label_rtx ();\n-\t  r = fallthru_label;\n+\t  tree label = TREE_VALUE (gimple_asm_label_op (stmt, i));\n+\t  rtx r;\n+\t  /* If asm goto has any labels in the fallthru basic block, use\n+\t     a label that we emit immediately after the asm goto.  Expansion\n+\t     may insert further instructions into the same basic block after\n+\t     asm goto and if we don't do this, insertion of instructions on\n+\t     the fallthru edge might misbehave.  See PR58670.  */\n+\t  if (fallthru_bb && label_to_block_fn (cfun, label) == fallthru_bb)\n+\t    {\n+\t      if (fallthru_label == NULL_RTX)\n+\t        fallthru_label = gen_label_rtx ();\n+\t      r = fallthru_label;\n+\t    }\n+\t  else\n+\t    r = label_rtx (label);\n+\t  ASM_OPERANDS_LABEL (body, i) = gen_rtx_LABEL_REF (Pmode, r);\n \t}\n-      else\n-\tr = label_rtx (TREE_VALUE (tail));\n-      ASM_OPERANDS_LABEL (body, i) = gen_rtx_LABEL_REF (Pmode, r);\n     }\n \n-  generating_concat_p = old_generating_concat_p;\n-\n   /* Now, for each output, construct an rtx\n      (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER\n \t\t\t       ARGVEC CONSTRAINTS OPNAMES))\n@@ -2933,8 +2940,8 @@ expand_asm_stmt (gasm *stmt)\n     }\n   else if (noutputs == 1 && nclobbers == 0)\n     {\n-      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = ggc_strdup (constraints[0]);\n-      emit_insn (gen_rtx_SET (output_rtx[0], body));\n+      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = constraints[0];\n+      emit_insn (gen_rtx_SET (output_rvec[0], body));\n     }\n   else\n     {\n@@ -2947,87 +2954,52 @@ expand_asm_stmt (gasm *stmt)\n       body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num + nclobbers));\n \n       /* For each output operand, store a SET.  */\n-      for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+      for (i = 0; i < noutputs; ++i)\n \t{\n-\t  XVECEXP (body, 0, i)\n-\t    = gen_rtx_SET (output_rtx[i],\n-\t\t\t   gen_rtx_ASM_OPERANDS\n-\t\t\t   (GET_MODE (output_rtx[i]),\n-\t\t\t    ggc_strdup (TREE_STRING_POINTER (string)),\n-\t\t\t    ggc_strdup (constraints[i]),\n-\t\t\t    i, argvec, constraintvec, labelvec, locus));\n-\n-\t  MEM_VOLATILE_P (SET_SRC (XVECEXP (body, 0, i)))\n-\t    = gimple_asm_volatile_p (stmt);\n+\t  rtx src, o = output_rvec[i];\n+\t  if (i == 0)\n+\t    {\n+\t      ASM_OPERANDS_OUTPUT_CONSTRAINT (obody) = constraints[0];\n+\t      src = obody;\n+\t    }\n+\t  else\n+\t    {\n+\t      src = gen_rtx_ASM_OPERANDS (GET_MODE (o),\n+\t\t\t\t\t  ASM_OPERANDS_TEMPLATE (obody),\n+\t\t\t\t\t  constraints[i], i, argvec,\n+\t\t\t\t\t  constraintvec, labelvec, locus);\n+\t      MEM_VOLATILE_P (src) = gimple_asm_volatile_p (stmt);\n+\t    }\n+\t  XVECEXP (body, 0, i) = gen_rtx_SET (o, src);\n \t}\n \n       /* If there are no outputs (but there are some clobbers)\n \t store the bare ASM_OPERANDS into the PARALLEL.  */\n-\n       if (i == 0)\n \tXVECEXP (body, 0, i++) = obody;\n \n       /* Store (clobber REG) for each clobbered register specified.  */\n-\n-      for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n+      for (unsigned j = 0; j < nclobbers; ++j)\n \t{\n-\t  const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n-\t  int reg, nregs;\n-\t  int j = decode_reg_name_and_count (regname, &nregs);\n-\t  rtx clobbered_reg;\n+\t  rtx clobbered_reg = clobber_rvec[j];\n \n-\t  if (j < 0)\n+\t  /* Do sanity check for overlap between clobbers and respectively\n+\t     input and outputs that hasn't been handled.  Such overlap\n+\t     should have been detected and reported above.  */\n+\t  if (!clobber_conflict_found && REG_P (clobbered_reg))\n \t    {\n-\t      if (j == -3)\t/* `cc', which is not a register */\n-\t\tcontinue;\n-\n-\t      if (j == -4)\t/* `memory', don't cache memory across asm */\n-\t\t{\n-\t\t  XVECEXP (body, 0, i++)\n-\t\t    = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t       gen_rtx_MEM\n-\t\t\t\t       (BLKmode,\n-\t\t\t\t\tgen_rtx_SCRATCH (VOIDmode)));\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Ignore unknown register, error already signaled.  */\n-\t      continue;\n+\t      /* We test the old body (obody) contents to avoid\n+\t\t tripping over the under-construction body.  */\n+\t      for (unsigned k = 0; k < noutputs; ++k)\n+\t\tif (reg_overlap_mentioned_p (clobbered_reg, output_rvec[k]))\n+\t\t  internal_error (\"asm clobber conflict with output operand\");\n+\n+\t      for (unsigned k = 0; k < ninputs - ninout; ++k)\n+\t\tif (reg_overlap_mentioned_p (clobbered_reg, input_rvec[k]))\n+\t\t  internal_error (\"asm clobber conflict with input operand\");\n \t    }\n \n-\t  for (reg = j; reg < j + nregs; reg++)\n-\t    {\n-\t      /* Use QImode since that's guaranteed to clobber just\n-\t       * one reg.  */\n-\t      clobbered_reg = gen_rtx_REG (QImode, reg);\n-\n-\t      /* Do sanity check for overlap between clobbers and\n-\t\t respectively input and outputs that hasn't been\n-\t\t handled.  Such overlap should have been detected and\n-\t\t reported above.  */\n-\t      if (!clobber_conflict_found)\n-\t\t{\n-\t\t  int opno;\n-\n-\t\t  /* We test the old body (obody) contents to avoid\n-\t\t     tripping over the under-construction body.  */\n-\t\t  for (opno = 0; opno < noutputs; opno++)\n-\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n-\t\t\t\t\t\t output_rtx[opno]))\n-\t\t      internal_error\n-\t\t\t(\"asm clobber conflict with output operand\");\n-\n-\t\t  for (opno = 0; opno < ninputs - ninout; opno++)\n-\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n-\t\t\t\t\t\t ASM_OPERANDS_INPUT (obody,\n-\t\t\t\t\t\t\t\t     opno)))\n-\t\t      internal_error\n-\t\t\t(\"asm clobber conflict with input operand\");\n-\t\t}\n-\n-\t      XVECEXP (body, 0, i++)\n-\t\t= gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n-\t    }\n+\t  XVECEXP (body, 0, i++) = gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n \t}\n \n       if (nlabels > 0)\n@@ -3036,31 +3008,18 @@ expand_asm_stmt (gasm *stmt)\n \temit_insn (body);\n     }\n \n+  generating_concat_p = old_generating_concat_p;\n+\n   if (fallthru_label)\n     emit_label (fallthru_label);\n \n-  /* For any outputs that needed reloading into registers, spill them\n-     back to where they belong.  */\n-  for (i = 0; i < noutputs; ++i)\n-    if (real_output_rtx[i])\n-      emit_move_insn (real_output_rtx[i], output_rtx[i]);\n-\n-  /* Copy all the intermediate outputs into the specified outputs.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      if (orig_outputs[i] != TREE_VALUE (tail))\n-\t{\n-\t  expand_assignment (orig_outputs[i], TREE_VALUE (tail), false);\n-\t  free_temp_slots ();\n+  if (after_md_seq)\n+    emit_insn (after_md_seq);\n+  if (after_rtl_seq)\n+    emit_insn (after_rtl_seq);\n \n-\t  /* Restore the original value so that it's correct the next\n-\t     time we expand this function.  */\n-\t  TREE_VALUE (tail) = orig_outputs[i];\n-\t}\n-    }\n-\n-  crtl->has_asm_statement = 1;\n   free_temp_slots ();\n+  crtl->has_asm_statement = 1;\n }\n \n /* Emit code to jump to the address"}, {"sha": "fc79e3e89108c474c023acd5f19539fff0f01298", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -179,7 +179,9 @@ static rtx cris_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       machine_mode, const_tree, bool);\n static void cris_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static tree cris_md_asm_clobbers (tree, tree, tree);\n+static rtx_insn *cris_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n+\t\t\t\t     vec<const char *> &,\n+\t\t\t\t     vec<rtx> &, HARD_REG_SET &);\n static bool cris_cannot_force_const_mem (machine_mode, rtx);\n \n static void cris_option_override (void);\n@@ -283,8 +285,8 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #define TARGET_FUNCTION_INCOMING_ARG cris_function_incoming_arg\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE cris_function_arg_advance\n-#undef TARGET_MD_ASM_CLOBBERS\n-#define TARGET_MD_ASM_CLOBBERS cris_md_asm_clobbers\n+#undef TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST cris_md_asm_adjust\n \n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM cris_cannot_force_const_mem\n@@ -4189,55 +4191,41 @@ cris_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n   ca->regs += (3 + CRIS_FUNCTION_ARG_SIZE (mode, type)) / 4;\n }\n \n-/* Worker function for TARGET_MD_ASM_CLOBBERS.  */\n+/* Worker function for TARGET_MD_ASM_ADJUST.  */\n \n-static tree\n-cris_md_asm_clobbers (tree outputs, tree inputs, tree in_clobbers)\n+static rtx_insn *\n+cris_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &inputs,\n+\t\t    vec<const char *> &constraints,\n+\t\t    vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n {\n-  HARD_REG_SET mof_set;\n-  tree clobbers;\n-  tree t;\n-\n-  CLEAR_HARD_REG_SET (mof_set);\n-  SET_HARD_REG_BIT (mof_set, CRIS_MOF_REGNUM);\n-\n-  /* For the time being, all asms clobber condition codes.  Revisit when\n-     there's a reasonable use for inputs/outputs that mention condition\n-     codes.  */\n-  clobbers\n-    = tree_cons (NULL_TREE,\n-\t\t build_string (strlen (reg_names[CRIS_CC0_REGNUM]),\n-\t\t\t       reg_names[CRIS_CC0_REGNUM]),\n-\t\t in_clobbers);\n-\n-  for (t = outputs; t != NULL; t = TREE_CHAIN (t))\n-    {\n-      tree val = TREE_VALUE (t);\n-\n-      /* The constraint letter for the singleton register class of MOF\n-\t is 'h'.  If it's mentioned in the constraints, the asm is\n-\t MOF-aware and adding it to the clobbers would cause it to have\n-\t impossible constraints.  */\n-      if (strchr (TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t))),\n-\t\t  'h') != NULL\n-\t  || tree_overlaps_hard_reg_set (val, &mof_set) != NULL_TREE)\n-\treturn clobbers;\n-    }\n-\n-  for (t = inputs; t != NULL; t = TREE_CHAIN (t))\n-    {\n-      tree val = TREE_VALUE (t);\n-\n-      if (strchr (TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t))),\n-\t\t  'h') != NULL\n-\t  || tree_overlaps_hard_reg_set (val, &mof_set) != NULL_TREE)\n-\treturn clobbers;\n-    }\n-\n-  return tree_cons (NULL_TREE,\n-\t\t    build_string (strlen (reg_names[CRIS_MOF_REGNUM]),\n-\t\t\t\t  reg_names[CRIS_MOF_REGNUM]),\n-\t\t    clobbers);\n+  /* For the time being, all asms clobber condition codes.\n+     Revisit when there's a reasonable use for inputs/outputs\n+     that mention condition codes.  */\n+  clobbers.safe_push (gen_rtx_REG (CCmode, CRIS_CC0_REGNUM));\n+  SET_HARD_REG_BIT (clobbered_regs, CRIS_CC0_REGNUM);\n+\n+  /* Determine if the source using MOF.  If it is, automatically\n+     clobbering MOF would cause it to have impossible constraints.  */\n+\n+  /* Look for a use of the MOF constraint letter: h.  */\n+  for (unsigned i = 0, n = constraints.length(); i < n; ++i)\n+    if (strchr (constraints[i], 'h') != NULL)\n+      return NULL;\n+\n+  /* Look for an output or an input that touches MOF.  */\n+  rtx mof_reg = gen_rtx_REG (SImode, CRIS_MOF_REGNUM);\n+  for (unsigned i = 0, n = outputs.length(); i < n; ++i)\n+    if (reg_overlap_mentioned_p (mof_reg, outputs[i]))\n+      return NULL;\n+  for (unsigned i = 0, n = inputs.length(); i < n; ++i)\n+    if (reg_overlap_mentioned_p (mof_reg, inputs[i]))\n+      return NULL;\n+\n+  /* No direct reference to MOF or its constraint.\n+     Clobber it for backward compatibility.  */\n+  clobbers.safe_push (mof_reg);\n+  SET_HARD_REG_BIT (clobbered_regs, CRIS_MOF_REGNUM);\n+  return NULL;\n }\n \n /* Implement TARGET_FRAME_POINTER_REQUIRED."}, {"sha": "70becc0e737315a42debec499afb72be738e5fe1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -45403,19 +45403,23 @@ ix86_c_mode_for_suffix (char suffix)\n   return VOIDmode;\n }\n \n-/* Worker function for TARGET_MD_ASM_CLOBBERS.\n+/* Worker function for TARGET_MD_ASM_ADJUST.\n \n    We do this in the new i386 backend to maintain source compatibility\n    with the old cc0-based compiler.  */\n \n-static tree\n-ix86_md_asm_clobbers (tree, tree, tree clobbers)\n+static rtx_insn *\n+ix86_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n+\t\t    vec<const char *> &/*constraints*/,\n+\t\t    vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n {\n-  clobbers = tree_cons (NULL_TREE, build_string (5, \"flags\"),\n-\t\t\tclobbers);\n-  clobbers = tree_cons (NULL_TREE, build_string (4, \"fpsr\"),\n-\t\t\tclobbers);\n-  return clobbers;\n+  clobbers.safe_push (gen_rtx_REG (CCmode, FLAGS_REG));\n+  clobbers.safe_push (gen_rtx_REG (CCFPmode, FPSR_REG));\n+\n+  SET_HARD_REG_BIT (clobbered_regs, FLAGS_REG);\n+  SET_HARD_REG_BIT (clobbered_regs, FPSR_REG);\n+\n+  return NULL;\n }\n \n /* Implements target vector targetm.asm.encode_section_info.  */\n@@ -51943,8 +51947,8 @@ ix86_operands_ok_for_move_multiple (rtx *operands, bool load,\n #undef TARGET_EXPAND_BUILTIN_VA_START\n #define TARGET_EXPAND_BUILTIN_VA_START ix86_va_start\n \n-#undef TARGET_MD_ASM_CLOBBERS\n-#define TARGET_MD_ASM_CLOBBERS ix86_md_asm_clobbers\n+#undef TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST ix86_md_asm_adjust\n \n #undef TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true"}, {"sha": "5bf2c03684af73b4424c2604e09e4307cfcf5b44", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -2881,18 +2881,18 @@ mn10300_conditional_register_usage (void)\n     call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n }\n \n-/* Worker function for TARGET_MD_ASM_CLOBBERS.\n+/* Worker function for TARGET_MD_ASM_ADJUST.\n    We do this in the mn10300 backend to maintain source compatibility\n    with the old cc0-based compiler.  */\n \n-static tree\n-mn10300_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n-                         tree inputs ATTRIBUTE_UNUSED,\n-                         tree clobbers)\n+static rtx_insn *\n+mn10300_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n+\t\t       vec<const char *> &/*constraints*/,\n+\t\t       vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n {\n-  clobbers = tree_cons (NULL_TREE, build_string (5, \"EPSW\"),\n-                        clobbers);\n-  return clobbers;\n+  clobbers.safe_push (gen_rtx_REG (CCmode, CC_REG));\n+  SET_HARD_REG_BIT (clobbered_regs, CC_REG);\n+  return NULL;\n }\n \f\n /* A helper function for splitting cbranch patterns after reload.  */\n@@ -3442,8 +3442,8 @@ mn10300_reorg (void)\n #undef  TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE mn10300_conditional_register_usage\n \n-#undef TARGET_MD_ASM_CLOBBERS\n-#define TARGET_MD_ASM_CLOBBERS  mn10300_md_asm_clobbers\n+#undef TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST mn10300_md_asm_adjust\n \n #undef  TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM  CC_REG"}, {"sha": "7971cbadd0a974291f99ae69225d83499196c930", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -1597,8 +1597,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_ASM_LOOP_ALIGN_MAX_SKIP\n #define TARGET_ASM_LOOP_ALIGN_MAX_SKIP rs6000_loop_align_max_skip\n \n-#undef TARGET_MD_ASM_CLOBBERS\n-#define TARGET_MD_ASM_CLOBBERS rs6000_md_asm_clobbers\n+#undef TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST rs6000_md_asm_adjust\n \n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE rs6000_option_override\n@@ -3209,17 +3209,20 @@ rs6000_builtin_mask_calculate (void)\n \t  | ((TARGET_LONG_DOUBLE_128)\t    ? RS6000_BTM_LDBL128 : 0));\n }\n \n-/* Implement TARGET_MD_ASM_CLOBBERS.  All asm statements are considered\n+/* Implement TARGET_MD_ASM_ADJUST.  All asm statements are considered\n    to clobber the XER[CA] bit because clobbering that bit without telling\n    the compiler worked just fine with versions of GCC before GCC 5, and\n    breaking a lot of older code in ways that are hard to track down is\n    not such a great idea.  */\n \n-static tree\n-rs6000_md_asm_clobbers (tree, tree, tree clobbers)\n+static rtx_insn *\n+rs6000_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n+\t\t      vec<const char *> &/*constraints*/,\n+\t\t      vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n {\n-  tree s = build_string (strlen (reg_names[CA_REGNO]), reg_names[CA_REGNO]);\n-  return tree_cons (NULL_TREE, s, clobbers);\n+  clobbers.safe_push (gen_rtx_REG (SImode, CA_REGNO));\n+  SET_HARD_REG_BIT (clobbered_regs, CA_REGNO);\n+  return NULL;\n }\n \n /* Override command line options.  Mostly we process the processor type and"}, {"sha": "313f06e61bc4ba094e21799f74669fd00a4203f1", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -172,7 +172,9 @@ static bool visium_frame_pointer_required (void);\n \n static tree visium_build_builtin_va_list (void);\n \n-static tree visium_md_asm_clobbers (tree, tree, tree);\n+static rtx_insn *visium_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n+\t\t\t\t       vec<const char *> &,\n+\t\t\t\t       vec<rtx> &, HARD_REG_SET &);\n \n static bool visium_legitimate_constant_p (enum machine_mode, rtx);\n \n@@ -299,8 +301,8 @@ static unsigned int visium_reorg (void);\n #undef  TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT visium_trampoline_init\n \n-#undef TARGET_MD_ASM_CLOBBERS\n-#define TARGET_MD_ASM_CLOBBERS visium_md_asm_clobbers\n+#undef TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST visium_md_asm_adjust\n \n #undef TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM FLAGS_REGNUM\n@@ -720,13 +722,14 @@ visium_conditional_register_usage (void)\n    an asm   We do this for the FLAGS to maintain source compatibility with\n    the original cc0-based compiler.  */\n \n-static tree\n-visium_md_asm_clobbers (tree outputs ATTRIBUTE_UNUSED,\n-\t\t\ttree inputs ATTRIBUTE_UNUSED,\n-\t\t\ttree clobbers)\n+static rtx_insn *\n+visium_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n+\t\t      vec<const char *> &/*constraints*/,\n+\t\t      vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n {\n-  const char *flags = reg_names[FLAGS_REGNUM];\n-  return tree_cons (NULL_TREE, build_string (strlen (flags), flags), clobbers);\n+  clobbers.safe_push (gen_rtx_REG (CCmode, FLAGS_REGNUM));\n+  SET_HARD_REG_BIT (clobbered_regs, FLAGS_REGNUM);\n+  return NULL;\n }\n \n /* Return true if X is a legitimate constant for a MODE immediate operand."}, {"sha": "e29dc69376db0bc15fecb2faa5a44b32dfad5c2a", "filename": "gcc/config/vxworks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fvxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fconfig%2Fvxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -21,13 +21,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"vec.h\"\n #include \"target.h\"\n #include \"diagnostic-core.h\"\n #include \"output.h\"\n #include \"tm.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\"\n-#include \"vec.h\"\n #include \"double-int.h\"\n #include \"input.h\"\n #include \"alias.h\""}, {"sha": "9886f4ad2a98bf14bb1c9a99b98869ee73af2793", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -10835,15 +10835,15 @@ from shared libraries (DLLs).\n You need not define this macro if it would always evaluate to zero.\n @end defmac\n \n-@deftypefn {Target Hook} tree TARGET_MD_ASM_CLOBBERS (tree @var{outputs}, tree @var{inputs}, tree @var{clobbers})\n-This target hook should add to @var{clobbers} @code{STRING_CST} trees for\n-any hard regs the port wishes to automatically clobber for an asm.\n-It should return the result of the last @code{tree_cons} used to add a\n-clobber.  The @var{outputs}, @var{inputs} and @var{clobber} lists are the\n-corresponding parameters to the asm and may be inspected to avoid\n-clobbering a register that is an input or output of the asm.  You can use\n-@code{tree_overlaps_hard_reg_set}, declared in @file{tree.h}, to test\n-for overlap with regards to asm-declared registers.\n+@deftypefn {Target Hook} {rtx_insn *} TARGET_MD_ASM_ADJUST (vec<rtx>& @var{outputs}, vec<rtx>& @var{inputs}, vec<const char *>& @var{constraints}, vec<rtx>& @var{clobbers}, HARD_REG_SET& @var{clobbered_regs})\n+This target hook may add @dfn{clobbers} to @var{clobbers} and\n+@var{clobbered_regs} for any hard regs the port wishes to automatically\n+clobber for an asm.  The @var{outputs} and @var{inputs} may be inspected\n+to avoid clobbering a register that is already used by the asm.\n+\n+It may modify the @var{outputs}, @var{inputs}, and @var{constraints}\n+as necessary for other pre-processing.  In this case the return value is\n+a sequence of insns to emit after the asm.\n @end deftypefn\n \n @defmac MATH_LIBRARY"}, {"sha": "707d61042848ca88d57c6c8f0b80f2c7985d642b", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -7903,7 +7903,7 @@ from shared libraries (DLLs).\n You need not define this macro if it would always evaluate to zero.\n @end defmac\n \n-@hook TARGET_MD_ASM_CLOBBERS\n+@hook TARGET_MD_ASM_ADJUST\n \n @defmac MATH_LIBRARY\n Define this macro as a C string constant for the linker argument to link"}, {"sha": "8b3b3229c3f022f77cf3f5f6e273fa927311fb5d", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -23,10 +23,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"target.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\"\n #include \"vec.h\"\n+#include \"target.h\"\n #include \"double-int.h\"\n #include \"input.h\"\n #include \"alias.h\""}, {"sha": "92a21411a3f7efe28e03b93ff65eddfce04996aa", "filename": "gcc/hooks.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -378,14 +378,6 @@ hook_uint_mode_0 (machine_mode m ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-/* Generic hook that takes three trees and returns the last one as is.  */\n-tree\n-hook_tree_tree_tree_tree_3rd_identity (tree a ATTRIBUTE_UNUSED,\n-\t\t\t\t       tree b ATTRIBUTE_UNUSED, tree c)\n-{\n-  return c;\n-}\n-\n /* Generic hook that takes no arguments and returns a NULL const string.  */\n const char *\n hook_constcharptr_void_null (void)"}, {"sha": "02c24ce9da68d57031be4f1d043a2f73c4e17ba8", "filename": "gcc/hooks.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -93,7 +93,6 @@ extern tree hook_tree_const_tree_null (const_tree);\n \n extern tree hook_tree_tree_tree_null (tree, tree);\n extern tree hook_tree_tree_tree_tree_null (tree, tree, tree);\n-extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);\n extern tree hook_tree_tree_int_treep_bool_null (tree, int, tree *, bool);\n \n extern unsigned hook_uint_void_0 (void);"}, {"sha": "c4e0574cbf6ca784b57cb833a3810ceefff8244d", "filename": "gcc/incpath.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fincpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fincpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fincpath.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -21,6 +21,7 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"machmode.h\"\n+#include \"vec.h\"\n #include \"target.h\"\n #include \"tm.h\"\n #include \"cpplib.h\""}, {"sha": "7ac09523450984947dec8fb6f3f400341c5118b6", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"vec.h\"\n #include \"target.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -29,7 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"predict.h\"\n-#include \"vec.h\"\n #include \"hashtab.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\""}, {"sha": "448a7fed78b662d70bca6d47dfac5fbfa6645944", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -964,6 +964,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tTARGET_HANDLE_PRAGMA_EXTERN_PREFIX \\\n \tTARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN \\\n \tTARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD \\\n+\tTARGET_MD_ASM_CLOBBERS\n \n /* Arrays that were deleted in favor of a functional interface.  */\n  #pragma GCC poison built_in_decls implicit_built_in_decls"}, {"sha": "eba992102aa730ba3903e4f7aa2838e76c1b563e", "filename": "gcc/target.def", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca35180e923e40e8de6df1953c9177d22eae665/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=7ca35180e923e40e8de6df1953c9177d22eae665", "patch": "@@ -3742,20 +3742,22 @@ machines.  One reason you may need to define this target hook is if\\n\\\n  rtx, (void),\n  default_builtin_setjmp_frame_value)\n \n-/* This target hook should add STRING_CST trees for any hard regs\n-   the port wishes to automatically clobber for an asm.  */\n-DEFHOOK\n-(md_asm_clobbers,\n- \"This target hook should add to @var{clobbers} @code{STRING_CST} trees for\\n\\\n-any hard regs the port wishes to automatically clobber for an asm.\\n\\\n-It should return the result of the last @code{tree_cons} used to add a\\n\\\n-clobber.  The @var{outputs}, @var{inputs} and @var{clobber} lists are the\\n\\\n-corresponding parameters to the asm and may be inspected to avoid\\n\\\n-clobbering a register that is an input or output of the asm.  You can use\\n\\\n-@code{tree_overlaps_hard_reg_set}, declared in @file{tree.h}, to test\\n\\\n-for overlap with regards to asm-declared registers.\",\n- tree, (tree outputs, tree inputs, tree clobbers),\n- hook_tree_tree_tree_tree_3rd_identity)\n+/* This target hook should manipulate the outputs, inputs, constraints,\n+   and clobbers the port wishes for pre-processing the asm.  */\n+DEFHOOK\n+(md_asm_adjust,\n+ \"This target hook may add @dfn{clobbers} to @var{clobbers} and\\n\\\n+@var{clobbered_regs} for any hard regs the port wishes to automatically\\n\\\n+clobber for an asm.  The @var{outputs} and @var{inputs} may be inspected\\n\\\n+to avoid clobbering a register that is already used by the asm.\\n\\\n+\\n\\\n+It may modify the @var{outputs}, @var{inputs}, and @var{constraints}\\n\\\n+as necessary for other pre-processing.  In this case the return value is\\n\\\n+a sequence of insns to emit after the asm.\",\n+ rtx_insn *,\n+ (vec<rtx>& outputs, vec<rtx>& inputs, vec<const char *>& constraints,\n+  vec<rtx>& clobbers, HARD_REG_SET& clobbered_regs),\n+ NULL)\n \n /* This target hook allows the backend to specify a calling convention\n    in the debug information.  This function actually returns an"}]}