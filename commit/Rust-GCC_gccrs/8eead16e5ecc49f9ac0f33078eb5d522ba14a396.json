{"sha": "8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVlYWQxNmU1ZWNjNDlmOWFjMGYzMzA3OGViNWQ1MjJiYTE0YTM5Ng==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2009-11-09T22:09:30Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-11-09T22:09:30Z"}, "message": "user.cfg.in: Regenerate, add files.\n\n2009-11-09  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* doc/doxygen/user.cfg.in: Regenerate, add files.\n\t* libsupc++/eh_ptr.cc: Format.\n\t* libsupc++/exception_ptr.h: Same.\n\t* libsupc++/cxxabi.h(recursive_init_error): Move declaration here.\n\t* libsupc++/guard.cc: From here.\n\t* libsupc++/nested_exception.h: Add markup.\n\nFrom-SVN: r154054", "tree": {"sha": "b880310f7477dda5c4226c7dfe5db4ebeb4095eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b880310f7477dda5c4226c7dfe5db4ebeb4095eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/comments", "author": null, "committer": null, "parents": [{"sha": "3f08607cac2b08e547f0b6fae316c4b24cf70b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f08607cac2b08e547f0b6fae316c4b24cf70b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f08607cac2b08e547f0b6fae316c4b24cf70b70"}], "stats": {"total": 1601, "additions": 787, "deletions": 814}, "files": [{"sha": "154d4d5030df7a67833a7e4744a4f10d83c53d2d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "patch": "@@ -1,3 +1,12 @@\n+2009-11-09  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* doc/doxygen/user.cfg.in: Regenerate, add files.\n+\t* libsupc++/eh_ptr.cc: Format.\n+\t* libsupc++/exception_ptr.h: Same.\n+\t* libsupc++/cxxabi.h(recursive_init_error): Move declaration here.\n+\t* libsupc++/guard.cc: From here.\n+\t* libsupc++/nested_exception.h: Add markup.\n+\n 2009-11-09  Johannes Singler  <singler@kit.edu>\n \n \t* include/parallel/multiway_merge.h (multiway_merge_*,"}, {"sha": "be32ecbb3216a6887be758abf0c8d4bed07eb848", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 706, "deletions": 711, "changes": 1417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396"}, {"sha": "e49b0f4e6dbf1a5994c9470e7eda0e80e62c9ea5", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "patch": "@@ -100,7 +100,7 @@ namespace __cxxabiv1\n   \n   void \n   __cxa_vec_cleanup(void* __array_address, size_t __element_count,\n-\t\t    size_t __element_size, __cxa_cdtor_type destructor) _GLIBCXX_NOTHROW;\n+\t\t    size_t __s, __cxa_cdtor_type destructor) _GLIBCXX_NOTHROW;\n   \n   // Destruct and release array.\n   void \n@@ -601,6 +601,27 @@ namespace __cxxabiv1\n */\n namespace abi = __cxxabiv1;\n \n+namespace __gnu_cxx\n+{\n+  /**\n+   *  @brief Exception thrown by __cxa_guard_acquire.\n+   *  @ingroup exceptions\n+   *\n+   *  6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)\n+   *  while the object is being initialized, the behavior is undefined.\n+   *\n+   *  Since we already have a library function to handle locking, we might\n+   *  as well check for this situation and throw an exception.\n+   *  We use the second byte of the guard variable to remember that we're\n+   *  in the middle of an initialization.\n+   */\n+  class recursive_init_error: public std::exception\n+  {\n+  public:\n+    recursive_init_error() throw() { }\n+    virtual ~recursive_init_error() throw ();\n+  };\n+}\n #endif // __cplusplus\n \n #pragma GCC visibility pop"}, {"sha": "8a0167d75103e0bd1bc6eaca3cc29c247b9bc0c0", "filename": "libstdc++-v3/libsupc++/eh_ptr.cc", "status": "modified", "additions": 20, "deletions": 41, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_ptr.cc?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "patch": "@@ -35,41 +35,30 @@\n using namespace __cxxabiv1;\n \n std::__exception_ptr::exception_ptr::exception_ptr() throw()\n-  : _M_exception_object(0)\n-{\n-}\n+: _M_exception_object(0) { }\n \n \n std::__exception_ptr::exception_ptr::exception_ptr(void* obj) throw()\n-  : _M_exception_object(obj)\n-{\n-  _M_addref();\n-}\n+: _M_exception_object(obj)  { _M_addref(); }\n \n \n std::__exception_ptr::exception_ptr::exception_ptr(__safe_bool) throw()\n-  : _M_exception_object(0)\n-{\n-}\n+: _M_exception_object(0) { }\n \n \n-std::__exception_ptr::exception_ptr::exception_ptr(\n-                        const exception_ptr& other) throw()\n-  : _M_exception_object(other._M_exception_object)\n-{\n-  _M_addref();\n-}\n+std::__exception_ptr::\n+exception_ptr::exception_ptr(const exception_ptr& other) throw()\n+: _M_exception_object(other._M_exception_object)\n+{ _M_addref(); }\n \n \n std::__exception_ptr::exception_ptr::~exception_ptr() throw()\n-{\n-  _M_release();\n-}\n+{ _M_release(); }\n \n \n std::__exception_ptr::exception_ptr&\n-std::__exception_ptr::exception_ptr::operator=(\n-                    const exception_ptr& other) throw()\n+std::__exception_ptr::\n+exception_ptr::operator=(const exception_ptr& other) throw()\n {\n   exception_ptr(other).swap(*this);\n   return *this;\n@@ -109,15 +98,11 @@ std::__exception_ptr::exception_ptr::_M_release() throw()\n \n void*\n std::__exception_ptr::exception_ptr::_M_get() const throw()\n-{\n-  return _M_exception_object;\n-}\n+{ return _M_exception_object; }\n \n \n void\n-std::__exception_ptr::exception_ptr::_M_safe_bool_dummy() throw ()\n-{\n-}\n+std::__exception_ptr::exception_ptr::_M_safe_bool_dummy() throw () { }\n \n \n void\n@@ -132,9 +117,7 @@ std::__exception_ptr::exception_ptr::swap(exception_ptr &other) throw()\n // Retained for compatibility with CXXABI_1.3.\n bool\n std::__exception_ptr::exception_ptr::operator!() const throw()\n-{\n-  return _M_exception_object == 0;\n-}\n+{ return _M_exception_object == 0; }\n \n \n // Retained for compatibility with CXXABI_1.3.\n@@ -153,17 +136,13 @@ std::__exception_ptr::exception_ptr::__cxa_exception_type() const throw()\n \n \n bool std::__exception_ptr::operator==(const exception_ptr& lhs,\n-                                      const exception_ptr& rhs) throw()\n-{\n-  return lhs._M_exception_object == rhs._M_exception_object;\n-}\n+\t\t\t\t      const exception_ptr& rhs) throw()\n+{ return lhs._M_exception_object == rhs._M_exception_object; }\n \n \n bool std::__exception_ptr::operator!=(const exception_ptr& lhs,\n-                                      const exception_ptr& rhs) throw()\n-{\n-  return !(lhs == rhs);\n-}\n+\t\t\t\t      const exception_ptr& rhs) throw()\n+{ return !(lhs == rhs);}\n \n \n std::exception_ptr\n@@ -185,8 +164,8 @@ std::current_exception() throw()\n \n \n static void\n-__gxx_dependent_exception_cleanup (_Unwind_Reason_Code code,\n-                                   _Unwind_Exception *exc)\n+__gxx_dependent_exception_cleanup(_Unwind_Reason_Code code,\n+\t\t\t\t  _Unwind_Exception *exc)\n {\n   // This cleanup is set only for dependents.\n   __cxa_dependent_exception *dep = __get_dependent_exception_from_ue (exc);\n@@ -236,7 +215,7 @@ std::rethrow_exception(std::exception_ptr ep)\n \n   // Some sort of unwinding error.  Note that terminate is a handler.\n   __cxa_begin_catch (&dep->unwindHeader);\n-  std::terminate ();\n+  std::terminate();\n }\n \n #undef _GLIBCXX_EH_PTR_COMPAT"}, {"sha": "3ee4d8d327d49cba5a40f189ac6520645addd891", "filename": "libstdc++-v3/libsupc++/exception_ptr.h", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_ptr.h?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "patch": "@@ -48,42 +48,28 @@ namespace std\n    * @addtogroup exceptions\n    * @{\n    */\n-\n-  // Hide the free operators from other types\n   namespace __exception_ptr\n   {\n-    /**\n-     * @brief An opaque pointer to an arbitrary exception.\n-     */\n     class exception_ptr;\n   }\n \n   using __exception_ptr::exception_ptr;\n \n-  /** Obtain an %exception_ptr to the currently handled exception. If there\n+  /** Obtain an exception_ptr to the currently handled exception. If there\n    *  is none, or the currently handled exception is foreign, return the null\n    *  value.\n    */\n   exception_ptr current_exception() throw();\n \n-  /// Throw the object pointed to by the %exception_ptr.\n+  /// Throw the object pointed to by the exception_ptr.\n   void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));\n \n-  /// Obtain an %exception_ptr pointing to a copy of the supplied object.\n-  template<typename _Ex>\n-    exception_ptr \n-    copy_exception(_Ex __ex) throw();\n-\n   namespace __exception_ptr\n   {\n-    bool \n-    operator==(const exception_ptr&, const exception_ptr&)\n-      throw() __attribute__ ((__pure__));\n-\n-    bool \n-    operator!=(const exception_ptr&, const exception_ptr&)\n-      throw() __attribute__ ((__pure__));\n-\n+    /**\n+     *  @brief An opaque pointer to an arbitrary exception.\n+     *  @ingroup exceptions\n+     */\n     class exception_ptr\n     {\n       void* _M_exception_object;\n@@ -140,16 +126,24 @@ namespace std\n #endif\n \n       friend bool \n-      operator==(const exception_ptr&, const exception_ptr&)\n-\tthrow() __attribute__ ((__pure__));\n+      operator==(const exception_ptr&, const exception_ptr&) throw() \n+      __attribute__ ((__pure__));\n \n       const type_info*\n       __cxa_exception_type() const throw() __attribute__ ((__pure__));\n     };\n \n+    bool \n+    operator==(const exception_ptr&, const exception_ptr&) throw() \n+    __attribute__ ((__pure__));\n+\n+    bool \n+    operator!=(const exception_ptr&, const exception_ptr&) throw() \n+    __attribute__ ((__pure__));\n   } // namespace __exception_ptr\n \n \n+  /// Obtain an exception_ptr pointing to a copy of the supplied object.\n   template<typename _Ex>\n     exception_ptr \n     copy_exception(_Ex __ex) throw()"}, {"sha": "222e5ec422764cb760cc5fbe37bd477ccb17b474", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "patch": "@@ -136,20 +136,6 @@ __set_and_release (__cxxabiv1::__guard *g)\n \n namespace __gnu_cxx\n {\n-  // 6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)\n-  // while the object is being initialized, the behavior is undefined.\n-\n-  // Since we already have a library function to handle locking, we might\n-  // as well check for this situation and throw an exception.\n-  // We use the second byte of the guard variable to remember that we're\n-  // in the middle of an initialization.\n-  class recursive_init_error: public std::exception\n-  {\n-  public:\n-    recursive_init_error() throw() { }\n-    virtual ~recursive_init_error() throw ();\n-  };\n-\n   recursive_init_error::~recursive_init_error() throw() { }\n }\n "}, {"sha": "9b054840effca900ea5213231a8b1dcb83703275", "filename": "libstdc++-v3/libsupc++/nested_exception.h", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eead16e5ecc49f9ac0f33078eb5d522ba14a396/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h?ref=8eead16e5ecc49f9ac0f33078eb5d522ba14a396", "patch": "@@ -51,9 +51,11 @@ namespace std\n    * @{\n    */\n \n-  /// nested_exception\n+  /// Exception class with exception_ptr data member.\n   class nested_exception\n   {\n+    exception_ptr _M_ptr;\n+\n   public:\n     nested_exception() throw() : _M_ptr(current_exception()) { }\n \n@@ -70,16 +72,12 @@ namespace std\n     exception_ptr\n     nested_ptr() const\n     { return _M_ptr; }\n-\n-  private:\n-    exception_ptr _M_ptr;\n   };\n \n   template<typename _Except>\n     struct _Nested_exception : public _Except, public nested_exception\n     {\n-      explicit\n-      _Nested_exception(_Except&& __ex)\n+      explicit _Nested_exception(_Except&& __ex)\n       : _Except(static_cast<_Except&&>(__ex))\n       { }\n     };\n@@ -89,27 +87,21 @@ namespace std\n     {\n       static const nested_exception*\n       _S_get(const _Ex& __ex)\n-      {\n-        return dynamic_cast<const nested_exception*>(&__ex);\n-      }\n+      { return dynamic_cast<const nested_exception*>(&__ex); }\n     };\n \n   template<typename _Ex>\n     struct __get_nested_helper<_Ex*>\n     {\n       static const nested_exception*\n       _S_get(const _Ex* __ex)\n-      {\n-        return dynamic_cast<const nested_exception*>(__ex);\n-      }\n+      { return dynamic_cast<const nested_exception*>(__ex); }\n     };\n \n   template<typename _Ex>\n     inline const nested_exception*\n     __get_nested_exception(const _Ex& __ex)\n-    {\n-      return __get_nested_helper<_Ex>::_S_get(__ex);\n-    }\n+    { return __get_nested_helper<_Ex>::_S_get(__ex); }\n \n   template<typename _Ex>\n     void\n@@ -126,21 +118,19 @@ namespace std\n   template<typename _Ex>\n     inline void\n     __throw_with_nested(_Ex&& __ex, const nested_exception* = 0)\n-    {\n-      throw __ex;\n-    }\n+    { throw __ex; }\n \n   template<typename _Ex>\n     inline void\n     __throw_with_nested(_Ex&& __ex, ...)\n-    {\n-      throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex));\n-    }\n+    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }\n   \n   template<typename _Ex>\n     void\n     throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));\n \n+  /// If @p __ex is derived from nested_exception, @p __ex. \n+  /// Else, an implementation-defined object derived from both.\n   template<typename _Ex>\n     inline void\n     throw_with_nested(_Ex __ex)\n@@ -150,6 +140,7 @@ namespace std\n       __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);\n     }\n \n+  /// If @p __ex is derived from nested_exception, @p __ex.rethrow_nested().\n   template<typename _Ex>\n     inline void\n     rethrow_if_nested(const _Ex& __ex)\n@@ -158,12 +149,10 @@ namespace std\n         __nested->rethrow_nested();\n     }\n \n-  // see n2619\n+  /// Overload, See N2619\n   inline void\n   rethrow_if_nested(const nested_exception& __ex)\n-  {\n-    __ex.rethrow_nested();\n-  }\n+  { __ex.rethrow_nested(); }\n \n   // @} group exceptions\n } // namespace std"}]}