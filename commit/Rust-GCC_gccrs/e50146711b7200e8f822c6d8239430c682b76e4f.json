{"sha": "e50146711b7200e8f822c6d8239430c682b76e4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUwMTQ2NzExYjcyMDBlOGY4MjJjNmQ4MjM5NDMwYzY4MmI3NmU0Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-04T16:57:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-04T16:57:36Z"}, "message": "internal-fn.def (GOACC_REDUCTION): New.\n\n\t* internal-fn.def (GOACC_REDUCTION): New.\n\t* internal-fn.h (enum ifn_goacc_reduction_kind): New.\n\t* internal-fn.c (expand_GOACC_REDUCTION): New.\n\t* target.def (goacc.reduction): New OpenACC hook.\n\t* targhooks.h (default_goacc_reduction): Declare.\n\t* doc/tm.texi.in: Add TARGET_GOACC_REDUCTION.\n\t* doc/tm.texi: Rebuilt.\n\t* omp-low.c (oacc_get_reduction_array_id, oacc_max_threads,\n\tscan_sharing_clauses): Remove oacc reduction handling here.\n\t(lower_rec_input_clauses): Don't handle OpenACC reductions here.\n\t(oacc_lower_reduction_var_helper): Delete.\n\t(lower_oacc_reductions): New.\n\t(lower_reduction_clauses): Don't handle OpenACC reductions here.\n\t(lower_oacc_head_tail): Call lower_oacc_reductions.\n\t(oacc_gimple_assign, oacc_init_reduction_array,\n\toacc_initialize_reduction_data, oacc_finalize_reduction_data,\n\toacc_process_reduction_data): Delete.\n\t(lower_omp_target): Remove old OpenACC reduction handling.  Insert\n\tdummy OpenACC gang reduction for reductions at outer level.\n\t(oacc_loop_xform_head_tail): Transform IFN_GOACC_REDUCTION.\n\t(default_goacc_reduction): New.\n\t(execute_oacc_device_lower): Handle IFN_GOACC_REDUCTION.\n\nFrom-SVN: r229767", "tree": {"sha": "8cefa28e0fa59d6ad4a8704a956624dba45f3552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cefa28e0fa59d6ad4a8704a956624dba45f3552"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e50146711b7200e8f822c6d8239430c682b76e4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50146711b7200e8f822c6d8239430c682b76e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e50146711b7200e8f822c6d8239430c682b76e4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50146711b7200e8f822c6d8239430c682b76e4f/comments", "author": null, "committer": null, "parents": [{"sha": "be373510f80fc6fc1e7b227056a69b703ce1c7a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be373510f80fc6fc1e7b227056a69b703ce1c7a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be373510f80fc6fc1e7b227056a69b703ce1c7a4"}], "stats": {"total": 902, "additions": 330, "deletions": 572}, "files": [{"sha": "e332df32c90594185ff3d70d26ea979bbf8a1a0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -1,3 +1,29 @@\n+2015-11-04  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* internal-fn.def (GOACC_REDUCTION): New.\n+\t* internal-fn.h (enum ifn_goacc_reduction_kind): New.\n+\t* internal-fn.c (expand_GOACC_REDUCTION): New.\n+\t* target.def (goacc.reduction): New OpenACC hook.\n+\t* targhooks.h (default_goacc_reduction): Declare.\n+\t* doc/tm.texi.in: Add TARGET_GOACC_REDUCTION.\n+\t* doc/tm.texi: Rebuilt.\n+\t* omp-low.c (oacc_get_reduction_array_id, oacc_max_threads,\n+\tscan_sharing_clauses): Remove oacc reduction handling here.\n+\t(lower_rec_input_clauses): Don't handle OpenACC reductions here.\n+\t(oacc_lower_reduction_var_helper): Delete.\n+\t(lower_oacc_reductions): New.\n+\t(lower_reduction_clauses): Don't handle OpenACC reductions here.\n+\t(lower_oacc_head_tail): Call lower_oacc_reductions.\n+\t(oacc_gimple_assign, oacc_init_reduction_array,\n+\toacc_initialize_reduction_data, oacc_finalize_reduction_data,\n+\toacc_process_reduction_data): Delete.\n+\t(lower_omp_target): Remove old OpenACC reduction handling.  Insert\n+\tdummy OpenACC gang reduction for reductions at outer level.\n+\t(oacc_loop_xform_head_tail): Transform IFN_GOACC_REDUCTION.\n+\t(default_goacc_reduction): New.\n+\t(execute_oacc_device_lower): Handle IFN_GOACC_REDUCTION.\n+\n 2015-11-04  Martin Liska  <mliska@suse.cz>\n \n \t* cgraphunit.c (cgraph_node::expand_thunk): Call\n@@ -41,7 +67,7 @@\n \tvi->only_restrict_pointers.\n \t(intra_create_variable_infos): Call create_variable_info_for_1 with\n \textra arg.  Remove restrict handling.  Call make_param_constraints with\n-\tone less arg.\n+\tone fewer arg.\n \n 2015-11-04  Tom de Vries  <tom@codesourcery.com>\n "}, {"sha": "1e6baa0a0804db8d6593a073a12212c87343afeb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -5787,6 +5787,15 @@ gimple has been inserted before it, or there is no need for it).\n The default hook returns false, if there are no RTL expanders for them.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_GOACC_REDUCTION (gcall *@var{call})\n+This hook is used by the oacc_transform pass to expand calls to the\n+@var{GOACC_REDUCTION} internal function, into a sequence of gimple\n+instructions.  @var{call} is gimple statement containing the call to\n+the function.  This hook removes statement @var{call} after the\n+expanded sequence has been inserted.  This hook is also responsible\n+for allocating any storage for reductions when necessary.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "0529011cb610c683235e87d5bc476dd4af661097", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -4264,6 +4264,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_GOACC_FORK_JOIN\n \n+@hook TARGET_GOACC_REDUCTION\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "6fac752af618ad44b2c376dc220fb7b66b13c3b2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -2045,6 +2045,14 @@ expand_GOACC_LOOP (gcall *stmt ATTRIBUTE_UNUSED)\n   gcc_unreachable ();\n }\n \n+/* This is expanded by oacc_device_lower pass.  */\n+\n+static void\n+expand_GOACC_REDUCTION (gcall *stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "ca06b10d83126eff84b402eb9cabc22f634d4a0d", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -83,3 +83,6 @@ DEF_INTERNAL_FN (GOACC_DIM_POS, ECF_PURE | ECF_NOTHROW | ECF_LEAF, \".\")\n \n /* OpenACC looping abstraction.  See internal-fn.h for usage.  */\n DEF_INTERNAL_FN (GOACC_LOOP, ECF_PURE | ECF_NOTHROW, NULL)\n+\n+/* OpenACC reduction abstraction.  See internal-fn.h  for usage.  */\n+DEF_INTERNAL_FN (GOACC_REDUCTION, ECF_NOTHROW | ECF_LEAF, NULL)"}, {"sha": "20cbd13e4b669eab835d6e2a312aa2169fd56330", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -66,6 +66,28 @@ enum ifn_goacc_loop_kind {\n   IFN_GOACC_LOOP_BOUND    /* Limit of iteration value.  */\n };\n \n+/* The GOACC_REDUCTION function defines a generic interface to support\n+   gang, worker and vector reductions.  All calls are of the following\n+   form:\n+\n+     V = REDUCTION (CODE, REF_TO_RES, LOCAL_VAR, LEVEL, OP, OFFSET)\n+\n+   REF_TO_RES - is a reference to the original reduction varl, may be NULL\n+   LOCAL_VAR is the intermediate reduction variable\n+   LEVEL corresponds to the GOMP_DIM of the reduction\n+   OP is the tree code of the reduction operation\n+   OFFSET may be used as an offset into a reduction array for the\n+          reductions occuring at this level.\n+   In general the return value is LOCAL_VAR, which creates a data\n+   dependency between calls operating on the same reduction.  */\n+\n+enum ifn_goacc_reduction_kind {\n+  IFN_GOACC_REDUCTION_SETUP,\n+  IFN_GOACC_REDUCTION_INIT,\n+  IFN_GOACC_REDUCTION_FINI,\n+  IFN_GOACC_REDUCTION_TEARDOWN\n+};\n+\n /* Initialize internal function tables.  */\n \n extern void init_internal_fns ();"}, {"sha": "6a0915b3c384c1c8706d058c03acba4a798a7ef5", "filename": "gcc/omp-low.c", "status": "modified", "additions": 247, "deletions": 571, "changes": 818, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -305,66 +305,6 @@ is_oacc_kernels (omp_context *ctx)\n \t      == GF_OMP_TARGET_KIND_OACC_KERNELS));\n }\n \n-/* Helper function to get the name of the array containing the partial\n-   reductions for OpenACC reductions.  */\n-static const char *\n-oacc_get_reduction_array_id (tree node)\n-{\n-  const char *id = IDENTIFIER_POINTER (DECL_NAME (node));\n-  int len = strlen (\"OACC\") + strlen (id);\n-  char *temp_name = XALLOCAVEC (char, len + 1);\n-  snprintf (temp_name, len + 1, \"OACC%s\", id);\n-  return IDENTIFIER_POINTER (get_identifier (temp_name));\n-}\n-\n-/* Determine the number of threads OpenACC threads used to determine the\n-   size of the array of partial reductions.  Currently, this is num_gangs\n-   * vector_length.  This value may be different than GOACC_GET_NUM_THREADS,\n-   because it is independed of the device used.  */\n-\n-static tree\n-oacc_max_threads (omp_context *ctx)\n-{\n-  tree nthreads, vector_length, gangs, clauses;\n-\n-  gangs = fold_convert (sizetype, integer_one_node);\n-  vector_length = gangs;\n-\n-  /* The reduction clause may be nested inside a loop directive.\n-     Scan for the innermost vector_length clause.  */\n-  for (omp_context *oc = ctx; oc; oc = oc->outer)\n-    {\n-      if (gimple_code (oc->stmt) != GIMPLE_OMP_TARGET\n-\t  || (gimple_omp_target_kind (oc->stmt)\n-\t      != GF_OMP_TARGET_KIND_OACC_PARALLEL))\n-\tcontinue;\n-\n-      clauses = gimple_omp_target_clauses (oc->stmt);\n-\n-      vector_length = find_omp_clause (clauses, OMP_CLAUSE_VECTOR_LENGTH);\n-      if (vector_length)\n-\tvector_length = fold_convert_loc (OMP_CLAUSE_LOCATION (vector_length),\n-\t\t\t\t\t  sizetype,\n-\t\t\t\t\t  OMP_CLAUSE_VECTOR_LENGTH_EXPR\n-\t\t\t\t\t  (vector_length));\n-      else\n-\tvector_length = fold_convert (sizetype, integer_one_node);\n-\n-      gangs = find_omp_clause (clauses, OMP_CLAUSE_NUM_GANGS);\n-      if (gangs)\n-        gangs = fold_convert_loc (OMP_CLAUSE_LOCATION (gangs), sizetype,\n-\t\t\t\t  OMP_CLAUSE_NUM_GANGS_EXPR (gangs));\n-      else\n-\tgangs = fold_convert (sizetype, integer_one_node);\n-\n-      break;\n-    }\n-\n-  nthreads = fold_build2 (MULT_EXPR, sizetype, gangs, vector_length);\n-\n-  return nthreads;\n-}\n-\n /* If DECL is the artificial dummy VAR_DECL created for non-static\n    data member privatization, return the underlying \"this\" parameter,\n    otherwise return NULL.  */\n@@ -2016,27 +1956,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\tinstall_var_field (decl, by_ref, 3, ctx);\n \t    }\n \t  install_var_local (decl, ctx);\n-\t  if (is_gimple_omp_oacc (ctx->stmt)\n-\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n-\t    {\n-\t      /* Create a decl for the reduction array.  */\n-\t      tree var = OMP_CLAUSE_DECL (c);\n-\t      tree type = get_base_type (var);\n-\t      tree ptype = build_pointer_type (type);\n-\t      tree array = create_tmp_var (ptype,\n-\t\t\t\t\t   oacc_get_reduction_array_id (var));\n-\t      omp_context *octx = (ctx->field_map ? ctx : ctx->outer);\n-\t      install_var_field (array, true, 3, octx);\n-\t      install_var_local (array, octx);\n-\n-\t      /* Insert it into the current context.  */\n-\t      splay_tree_insert (ctx->reduction_map, (splay_tree_key)\n-\t\t\t\t oacc_get_reduction_array_id (var),\n-\t\t\t\t (splay_tree_value) array);\n-\t      splay_tree_insert (ctx->reduction_map,\n-\t\t\t\t (splay_tree_key) array,\n-\t\t\t\t (splay_tree_value) array);\n-\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n@@ -4938,6 +4857,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      break;\n \n \t    case OMP_CLAUSE_REDUCTION:\n+\t      /* OpenACC reductions are initialized using the\n+\t\t GOACC_REDUCTION internal function.  */\n+\t      if (is_gimple_omp_oacc (ctx->stmt))\n+\t\tbreak;\n \t      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t\t{\n \t\t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n@@ -5351,56 +5274,170 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n     gimple_seq_add_stmt (stmt_list, gimple_build_label (label));\n }\n \n+/* Lower the OpenACC reductions of CLAUSES for compute axis LEVEL\n+   (which might be a placeholder).  INNER is true if this is an inner\n+   axis of a multi-axis loop.  FORK and JOIN are (optional) fork and\n+   join markers.  Generate the before-loop forking sequence in\n+   FORK_SEQ and the after-loop joining sequence to JOIN_SEQ.  The\n+   general form of these sequences is\n+\n+     GOACC_REDUCTION_SETUP\n+     GOACC_FORK\n+     GOACC_REDUCTION_INIT\n+     ...\n+     GOACC_REDUCTION_FINI\n+     GOACC_JOIN\n+     GOACC_REDUCTION_TEARDOWN.  */\n+\n static void\n-oacc_lower_reduction_var_helper (gimple_seq *stmt_seqp, omp_context *ctx,\n-\t\t\t\t tree tid, tree var, tree new_var)\n+lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n+\t\t       gcall *fork, gcall *join, gimple_seq *fork_seq,\n+\t\t       gimple_seq *join_seq, omp_context *ctx)\n {\n-  /* The atomic add at the end of the sum creates unnecessary\n-     write contention on accelerators.  To work around this,\n-     create an array to store the partial reductions. Later, in\n-     lower_omp_for (for openacc), the values of array will be\n-     combined.  */\n-\n-  tree t = NULL_TREE, array, x;\n-  tree type = get_base_type (var);\n-  gimple *stmt;\n+  gimple_seq before_fork = NULL;\n+  gimple_seq after_fork = NULL;\n+  gimple_seq before_join = NULL;\n+  gimple_seq after_join = NULL;\n+  tree init_code = NULL_TREE, fini_code = NULL_TREE,\n+    setup_code = NULL_TREE, teardown_code = NULL_TREE;\n+  unsigned offset = 0;\n+\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+      {\n+\ttree orig = OMP_CLAUSE_DECL (c);\n+\ttree var = maybe_lookup_decl (orig, ctx);\n+\ttree ref_to_res = NULL_TREE;\n+\ttree incoming, outgoing;\n+\n+\tenum tree_code rcode = OMP_CLAUSE_REDUCTION_CODE (c);\n+\tif (rcode == MINUS_EXPR)\n+\t  rcode = PLUS_EXPR;\n+\telse if (rcode == TRUTH_ANDIF_EXPR)\n+\t  rcode = BIT_AND_EXPR;\n+\telse if (rcode == TRUTH_ORIF_EXPR)\n+\t  rcode = BIT_IOR_EXPR;\n+\ttree op = build_int_cst (unsigned_type_node, rcode);\n+\n+\tif (!var)\n+\t  var = orig;\n+\tgcc_assert (!is_reference (var));\n+\n+\tincoming = outgoing = var;\n+\t\n+\tif (!inner)\n+\t  {\n+\t    /* See if an outer construct also reduces this variable.  */\n+\t    omp_context *outer = ctx;\n \n-  /* Now insert the partial reductions into the array.  */\n+\t    while (omp_context *probe = outer->outer)\n+\t      {\n+\t\tenum gimple_code type = gimple_code (probe->stmt);\n+\t\ttree cls;\n \n-  /* Find the reduction array.  */\n+\t\tswitch (type)\n+\t\t  {\n+\t\t  case GIMPLE_OMP_FOR:\n+\t\t    cls = gimple_omp_for_clauses (probe->stmt);\n+\t\t    break;\n \n-  tree ptype = build_pointer_type (type);\n+\t\t  case GIMPLE_OMP_TARGET:\n+\t\t    if (gimple_omp_target_kind (probe->stmt)\n+\t\t\t!= GF_OMP_TARGET_KIND_OACC_PARALLEL)\n+\t\t      goto do_lookup;\n \n-  t = lookup_oacc_reduction (oacc_get_reduction_array_id (var), ctx);\n-  t = build_receiver_ref (t, false, ctx->outer);\n+\t\t    cls = gimple_omp_target_clauses (probe->stmt);\n+\t\t    break;\n \n-  array = create_tmp_var (ptype);\n-  gimplify_assign (array, t, stmt_seqp);\n+\t\t  default:\n+\t\t    goto do_lookup;\n+\t\t  }\n+\t\t\n+\t\touter = probe;\n+\t\tfor (; cls;  cls = OMP_CLAUSE_CHAIN (cls))\n+\t\t  if (OMP_CLAUSE_CODE (cls) == OMP_CLAUSE_REDUCTION\n+\t\t      && orig == OMP_CLAUSE_DECL (cls))\n+\t\t    goto has_outer_reduction;\n+\t      }\n \n-  tree ptr = create_tmp_var (TREE_TYPE (array));\n+\t  do_lookup:\n+\t    /* This is the outermost construct with this reduction,\n+\t       see if there's a mapping for it.  */\n+\t    if (gimple_code (outer->stmt) == GIMPLE_OMP_TARGET\n+\t\t&& maybe_lookup_field (orig, outer))\n+\t      {\n+\t\tref_to_res = build_receiver_ref (orig, false, outer);\n+\t\tif (is_reference (orig))\n+\t\t  ref_to_res = build_simple_mem_ref (ref_to_res);\n \n-  /* Find the reduction array.  */\n+\t\toutgoing = var;\n+\t\tincoming = omp_reduction_init_op (loc, rcode, TREE_TYPE (var));\n+\t      }\n+\t    else\n+\t      incoming = outgoing = orig;\n+\t      \n+\t  has_outer_reduction:;\n+\t  }\n \n-  /* testing a unary conversion.  */\n-  tree offset = create_tmp_var (sizetype);\n-  gimplify_assign (offset, TYPE_SIZE_UNIT (type),\n-\t\t   stmt_seqp);\n-  t = create_tmp_var (sizetype);\n-  gimplify_assign (t, unshare_expr (fold_build1 (NOP_EXPR, sizetype, tid)),\n-\t\t   stmt_seqp);\n-  stmt = gimple_build_assign (offset, MULT_EXPR, offset, t);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n+\tif (!ref_to_res)\n+\t  ref_to_res = integer_zero_node;\n \n-  /* Offset expression.  Does the POINTER_PLUS_EXPR take care\n-     of adding sizeof(var) to the array?  */\n-  ptr = create_tmp_var (ptype);\n-  stmt = gimple_build_assign (unshare_expr (ptr), POINTER_PLUS_EXPR, array,\n-\t\t\t      offset);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n+\t/* Determine position in reduction buffer, which may be used\n+\t   by target.  */\n+\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (var));\n+\tunsigned align = GET_MODE_ALIGNMENT (mode) /  BITS_PER_UNIT;\n+\toffset = (offset + align - 1) & ~(align - 1);\n+\ttree off = build_int_cst (sizetype, offset);\n+\toffset += GET_MODE_SIZE (mode);\n \n-  /* Move the local sum to gfc$sum[i].  */\n-  x = unshare_expr (build_simple_mem_ref (ptr));\n-  stmt = gimplify_assign (x, new_var, stmt_seqp);\n+\tif (!init_code)\n+\t  {\n+\t    init_code = build_int_cst (integer_type_node,\n+\t\t\t\t       IFN_GOACC_REDUCTION_INIT);\n+\t    fini_code = build_int_cst (integer_type_node,\n+\t\t\t\t       IFN_GOACC_REDUCTION_FINI);\n+\t    setup_code = build_int_cst (integer_type_node,\n+\t\t\t\t\tIFN_GOACC_REDUCTION_SETUP);\n+\t    teardown_code = build_int_cst (integer_type_node,\n+\t\t\t\t\t   IFN_GOACC_REDUCTION_TEARDOWN);\n+\t  }\n+\n+\ttree setup_call\n+\t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n+\t\t\t\t\t  TREE_TYPE (var), 6, setup_code,\n+\t\t\t\t\t  unshare_expr (ref_to_res),\n+\t\t\t\t\t  incoming, level, op, off);\n+\ttree init_call\n+\t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n+\t\t\t\t\t  TREE_TYPE (var), 6, init_code,\n+\t\t\t\t\t  unshare_expr (ref_to_res),\n+\t\t\t\t\t  var, level, op, off);\n+\ttree fini_call\n+\t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n+\t\t\t\t\t  TREE_TYPE (var), 6, fini_code,\n+\t\t\t\t\t  unshare_expr (ref_to_res),\n+\t\t\t\t\t  var, level, op, off);\n+\ttree teardown_call\n+\t  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,\n+\t\t\t\t\t  TREE_TYPE (var), 6, teardown_code,\n+\t\t\t\t\t  ref_to_res, var, level, op, off);\n+\n+\tgimplify_assign (var, setup_call, &before_fork);\n+\tgimplify_assign (var, init_call, &after_fork);\n+\tgimplify_assign (var, fini_call, &before_join);\n+\tgimplify_assign (outgoing, teardown_call, &after_join);\n+      }\n+\n+  /* Now stitch things together.  */\n+  gimple_seq_add_seq (fork_seq, before_fork);\n+  if (fork)\n+    gimple_seq_add_stmt (fork_seq, fork);\n+  gimple_seq_add_seq (fork_seq, after_fork);\n+\n+  gimple_seq_add_seq (join_seq, before_join);\n+  if (join)\n+    gimple_seq_add_stmt (join_seq, join);\n+  gimple_seq_add_seq (join_seq, after_join);\n }\n \n /* Generate code to implement the REDUCTION clauses.  */\n@@ -5413,6 +5450,10 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n   tree x, c, tid = NULL_TREE;\n   int count = 0;\n \n+  /* OpenACC loop reductions are handled elsewhere.  */\n+  if (is_gimple_omp_oacc (ctx->stmt))\n+    return;\n+\n   /* SIMD reductions are handled in lower_rec_input_clauses.  */\n   if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n       && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n@@ -5484,13 +5525,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n       if (code == MINUS_EXPR)\n         code = PLUS_EXPR;\n \n-      if (is_gimple_omp_oacc (ctx->stmt))\n-\t{\n-\t  gcc_checking_assert (!OMP_CLAUSE_REDUCTION_PLACEHOLDER (c));\n-\n-\t  oacc_lower_reduction_var_helper (stmt_seqp, ctx, tid, var, new_var);\n-\t}\n-      else if (count == 1)\n+      if (count == 1)\n \t{\n \t  tree addr = build_fold_addr_expr_loc (clause_loc, ref);\n \n@@ -6055,8 +6090,8 @@ lower_oacc_head_tail (location_t loc, tree clauses,\n \t\t\t      build_int_cst (integer_type_node, done),\n \t\t\t      &join_seq);\n \n-      gimple_seq_add_stmt (&fork_seq, fork);\n-      gimple_seq_add_stmt (&join_seq, join);\n+      lower_oacc_reductions (loc, clauses, place, inner,\n+\t\t\t     fork, join, &fork_seq, &join_seq,  ctx);\n \n       /* Append this level to head. */\n       gimple_seq_add_seq (head, fork_seq);\n@@ -12948,446 +12983,6 @@ make_pass_expand_omp_ssa (gcc::context *ctxt)\n \f\n /* Routines to lower OMP directives into OMP-GIMPLE.  */\n \n-/* Helper function to preform, potentially COMPLEX_TYPE, operation and\n-   convert it to gimple.  */\n-static void\n-oacc_gimple_assign (tree dest, tree_code op, tree src, gimple_seq *seq)\n-{\n-  gimple *stmt;\n-\n-  if (TREE_CODE (TREE_TYPE (dest)) != COMPLEX_TYPE)\n-    {\n-      stmt = gimple_build_assign (dest, op, dest, src);\n-      gimple_seq_add_stmt (seq, stmt);\n-      return;\n-    }\n-\n-  tree t = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-  tree rdest = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (dest)), dest);\n-  gimplify_assign (t, rdest, seq);\n-  rdest = t;\n-\n-  t = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-  tree idest = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (dest)), dest);\n-  gimplify_assign (t, idest, seq);\n-  idest = t;\n-\n-  t = create_tmp_var (TREE_TYPE (TREE_TYPE (src)));\n-  tree rsrc = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (src)), src);\n-  gimplify_assign (t, rsrc, seq);\n-  rsrc = t;\n-\n-  t = create_tmp_var (TREE_TYPE (TREE_TYPE (src)));\n-  tree isrc = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (src)), src);\n-  gimplify_assign (t, isrc, seq);\n-  isrc = t;\n-\n-  tree r = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-  tree i = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-  tree result;\n-\n-  if (op == PLUS_EXPR)\n-    {\n-      stmt = gimple_build_assign (r, op, rdest, rsrc);\n-      gimple_seq_add_stmt (seq, stmt);\n-\n-      stmt = gimple_build_assign (i, op, idest, isrc);\n-      gimple_seq_add_stmt (seq, stmt);\n-    }\n-  else if (op == MULT_EXPR)\n-    {\n-      /* Let x = a + ib = dest, y = c + id = src.\n-\t x * y = (ac - bd) + i(ad + bc)  */\n-      tree ac = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-      tree bd = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-      tree ad = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-      tree bc = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n-\n-      stmt = gimple_build_assign (ac, MULT_EXPR, rdest, rsrc);\n-      gimple_seq_add_stmt (seq, stmt);\n-\n-      stmt = gimple_build_assign (bd, MULT_EXPR, idest, isrc);\n-      gimple_seq_add_stmt (seq, stmt);\n-\n-      stmt = gimple_build_assign (r, MINUS_EXPR, ac, bd);\n-      gimple_seq_add_stmt (seq, stmt);\n-\n-      stmt = gimple_build_assign (ad, MULT_EXPR, rdest, isrc);\n-      gimple_seq_add_stmt (seq, stmt);\n-\n-      stmt = gimple_build_assign (bd, MULT_EXPR, idest, rsrc);\n-      gimple_seq_add_stmt (seq, stmt);\n-\n-      stmt = gimple_build_assign (i, PLUS_EXPR, ad, bc);\n-      gimple_seq_add_stmt (seq, stmt);\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  result = build2 (COMPLEX_EXPR, TREE_TYPE (dest), r, i);\n-  gimplify_assign (dest, result, seq);\n-}\n-\n-/* Initialize the reduction array with default values.  */\n-\n-static void\n-oacc_init_reduction_array (tree array, tree init, tree nthreads,\n-\t\t\t   gimple_seq *stmt_seqp)\n-{\n-  tree type = TREE_TYPE (TREE_TYPE (array));\n-  tree x, loop_header, loop_body, loop_exit;\n-  gimple *stmt;\n-\n-  /* Create for loop.\n-\n-     let var = the original reduction variable\n-     let array = reduction variable array\n-\n-     for (i = 0; i < nthreads; i++)\n-       var op= array[i]\n- */\n-\n-  loop_header = create_artificial_label (UNKNOWN_LOCATION);\n-  loop_body = create_artificial_label (UNKNOWN_LOCATION);\n-  loop_exit = create_artificial_label (UNKNOWN_LOCATION);\n-\n-  /* Create and initialize an index variable.  */\n-  tree ix = create_tmp_var (sizetype);\n-  gimplify_assign (ix, fold_build1 (NOP_EXPR, sizetype, integer_zero_node),\n-\t\t   stmt_seqp);\n-\n-  /* Insert the loop header label here.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_header));\n-\n-  /* Exit loop if ix >= nthreads.  */\n-  x = create_tmp_var (sizetype);\n-  gimplify_assign (x, fold_build1 (NOP_EXPR, sizetype, nthreads), stmt_seqp);\n-  stmt = gimple_build_cond (GE_EXPR, ix, x, loop_exit, loop_body);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-  /* Insert the loop body label here.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_body));\n-\n-  /* Calculate the array offset.  */\n-  tree offset = create_tmp_var (sizetype);\n-  gimplify_assign (offset, TYPE_SIZE_UNIT (type), stmt_seqp);\n-  stmt = gimple_build_assign (offset, MULT_EXPR, offset, ix);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-  tree ptr = create_tmp_var (TREE_TYPE (array));\n-  stmt = gimple_build_assign (ptr, POINTER_PLUS_EXPR, array, offset);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-  /* Assign init.  */\n-  gimplify_assign (build_simple_mem_ref (ptr), init, stmt_seqp);\n-\n-  /* Increment the induction variable.  */\n-  tree one = fold_build1 (NOP_EXPR, sizetype, integer_one_node);\n-  stmt = gimple_build_assign (ix, PLUS_EXPR, ix, one);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-  /* Go back to the top of the loop.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_goto (loop_header));\n-\n-  /* Place the loop exit label here.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_exit));\n-}\n-\n-/* Helper function to initialize local data for the reduction arrays.\n-   The reduction arrays need to be placed inside the calling function\n-   for accelerators, or else the host won't be able to preform the final\n-   reduction.  */\n-\n-static void\n-oacc_initialize_reduction_data (tree clauses, tree nthreads,\n-\t\t\t\tgimple_seq *stmt_seqp, omp_context *ctx)\n-{\n-  tree c, t, oc;\n-  gimple *stmt;\n-  omp_context *octx;\n-\n-  /* Find the innermost OpenACC parallel context.  */\n-  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n-      && (gimple_omp_target_kind (ctx->stmt)\n-\t  == GF_OMP_TARGET_KIND_OACC_PARALLEL))\n-    octx = ctx;\n-  else\n-    octx = ctx->outer;\n-  gcc_checking_assert (gimple_code (octx->stmt) == GIMPLE_OMP_TARGET\n-\t\t       && (gimple_omp_target_kind (octx->stmt)\n-\t\t\t   == GF_OMP_TARGET_KIND_OACC_PARALLEL));\n-\n-  /* Extract the clauses.  */\n-  oc = gimple_omp_target_clauses (octx->stmt);\n-\n-  /* Find the last outer clause.  */\n-  for (; oc && OMP_CLAUSE_CHAIN (oc); oc = OMP_CLAUSE_CHAIN (oc))\n-    ;\n-\n-  /* Allocate arrays for each reduction variable.  */\n-  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n-    {\n-      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n-\tcontinue;\n-\n-      tree var = OMP_CLAUSE_DECL (c);\n-      tree type = get_base_type (var);\n-      tree array = lookup_oacc_reduction (oacc_get_reduction_array_id (var),\n-\t\t\t\t\t  ctx);\n-      tree size, call;\n-\n-      /* Calculate size of the reduction array.  */\n-      t = create_tmp_var (TREE_TYPE (nthreads));\n-      stmt = gimple_build_assign (t, MULT_EXPR, nthreads,\n-\t\t\t\t  fold_convert (TREE_TYPE (nthreads),\n-\t\t\t\t\t\tTYPE_SIZE_UNIT (type)));\n-      gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-      size = create_tmp_var (sizetype);\n-      gimplify_assign (size, fold_build1 (NOP_EXPR, sizetype, t), stmt_seqp);\n-\n-      /* Now allocate memory for it.  */\n-      call = unshare_expr (builtin_decl_explicit (BUILT_IN_ALLOCA));\n-      stmt = gimple_build_call (call, 1, size);\n-      gimple_call_set_lhs (stmt, array);\n-      gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-      /* Initialize array. */\n-      tree init = omp_reduction_init_op (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t OMP_CLAUSE_REDUCTION_CODE (c),\n-\t\t\t\t\t type);\n-      oacc_init_reduction_array (array, init, nthreads, stmt_seqp);\n-\n-      /* Map this array into the accelerator.  */\n-\n-      /* Add the reduction array to the list of clauses.  */\n-      tree x = array;\n-      t = build_omp_clause (gimple_location (ctx->stmt), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_SET_MAP_KIND (t, GOMP_MAP_FORCE_TOFROM);\n-      OMP_CLAUSE_DECL (t) = x;\n-      OMP_CLAUSE_CHAIN (t) = NULL;\n-      if (oc)\n-\tOMP_CLAUSE_CHAIN (oc) = t;\n-      else\n-\tgimple_omp_target_set_clauses (as_a <gomp_target *> (octx->stmt), t);\n-      OMP_CLAUSE_SIZE (t) = size;\n-      oc = t;\n-    }\n-}\n-\n-/* Helper function to process the array of partial reductions.  Nthreads\n-   indicates the number of threads.  Unfortunately, GOACC_GET_NUM_THREADS\n-   cannot be used here, because nthreads on the host may be different than\n-   on the accelerator. */\n-\n-static void\n-oacc_finalize_reduction_data (tree clauses, tree nthreads,\n-\t\t\t      gimple_seq *stmt_seqp, omp_context *ctx)\n-{\n-  tree c, x, var, array, loop_header, loop_body, loop_exit, type;\n-  gimple *stmt;\n-\n-  /* Create for loop.\n-\n-     let var = the original reduction variable\n-     let array = reduction variable array\n-\n-     for (i = 0; i < nthreads; i++)\n-       var op= array[i]\n- */\n-\n-  loop_header = create_artificial_label (UNKNOWN_LOCATION);\n-  loop_body = create_artificial_label (UNKNOWN_LOCATION);\n-  loop_exit = create_artificial_label (UNKNOWN_LOCATION);\n-\n-  /* Create and initialize an index variable.  */\n-  tree ix = create_tmp_var (sizetype);\n-  gimplify_assign (ix, fold_build1 (NOP_EXPR, sizetype, integer_zero_node),\n-\t\t   stmt_seqp);\n-\n-  /* Insert the loop header label here.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_header));\n-\n-  /* Exit loop if ix >= nthreads.  */\n-  x = create_tmp_var (sizetype);\n-  gimplify_assign (x, fold_build1 (NOP_EXPR, sizetype, nthreads), stmt_seqp);\n-  stmt = gimple_build_cond (GE_EXPR, ix, x, loop_exit, loop_body);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-  /* Insert the loop body label here.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_body));\n-\n-  /* Collapse each reduction array, one element at a time.  */\n-  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n-    {\n-      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n-\tcontinue;\n-\n-      tree_code reduction_code = OMP_CLAUSE_REDUCTION_CODE (c);\n-\n-      /* reduction(-:var) sums up the partial results, so it acts\n-\t identically to reduction(+:var).  */\n-      if (reduction_code == MINUS_EXPR)\n-        reduction_code = PLUS_EXPR;\n-\n-      /* Set up reduction variable var.  */\n-      var = OMP_CLAUSE_DECL (c);\n-      type = get_base_type (var);\n-      array = lookup_oacc_reduction (oacc_get_reduction_array_id\n-\t\t\t\t     (OMP_CLAUSE_DECL (c)), ctx);\n-\n-      /* Calculate the array offset.  */\n-      tree offset = create_tmp_var (sizetype);\n-      gimplify_assign (offset, TYPE_SIZE_UNIT (type), stmt_seqp);\n-      stmt = gimple_build_assign (offset, MULT_EXPR, offset, ix);\n-      gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-      tree ptr = create_tmp_var (TREE_TYPE (array));\n-      stmt = gimple_build_assign (ptr, POINTER_PLUS_EXPR, array, offset);\n-      gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-      /* Extract array[ix] into mem.  */\n-      tree mem = create_tmp_var (type);\n-      gimplify_assign (mem, build_simple_mem_ref (ptr), stmt_seqp);\n-\n-      /* Find the original reduction variable.  */\n-      if (is_reference (var))\n-\tvar = build_simple_mem_ref (var);\n-\n-      tree t = create_tmp_var (type);\n-\n-      x = lang_hooks.decls.omp_clause_assign_op (c, t, var);\n-      gimplify_and_add (unshare_expr(x), stmt_seqp);\n-\n-      /* var = var op mem */\n-      switch (OMP_CLAUSE_REDUCTION_CODE (c))\n-\t{\n-\tcase TRUTH_ANDIF_EXPR:\n-\tcase TRUTH_ORIF_EXPR:\n-\t  t = fold_build2 (OMP_CLAUSE_REDUCTION_CODE (c), integer_type_node,\n-\t\t\t   t, mem);\n-\t  gimplify_and_add (t, stmt_seqp);\n-\t  break;\n-\tdefault:\n-\t  /* The lhs isn't a gimple_reg when var is COMPLEX_TYPE.  */\n-\t  oacc_gimple_assign (t, OMP_CLAUSE_REDUCTION_CODE (c), mem,\n-\t\t\t      stmt_seqp);\n-\t}\n-\n-      t = fold_build1 (NOP_EXPR, TREE_TYPE (var), t);\n-      x = lang_hooks.decls.omp_clause_assign_op (c, var, t);\n-      gimplify_and_add (unshare_expr(x), stmt_seqp);\n-    }\n-\n-  /* Increment the induction variable.  */\n-  tree one = fold_build1 (NOP_EXPR, sizetype, integer_one_node);\n-  stmt = gimple_build_assign (ix, PLUS_EXPR, ix, one);\n-  gimple_seq_add_stmt (stmt_seqp, stmt);\n-\n-  /* Go back to the top of the loop.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_goto (loop_header));\n-\n-  /* Place the loop exit label here.  */\n-  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_exit));\n-}\n-\n-/* Scan through all of the gimple stmts searching for an OMP_FOR_EXPR, and\n-   scan that for reductions.  */\n-\n-static void\n-oacc_process_reduction_data (gimple_seq *body, gimple_seq *in_stmt_seqp,\n-\t\t\tgimple_seq *out_stmt_seqp, omp_context *ctx)\n-{\n-  gimple_stmt_iterator gsi;\n-  gimple_seq inner = NULL;\n-\n-  /* A collapse clause may have inserted a new bind block.  */\n-  gsi = gsi_start (*body);\n-  while (!gsi_end_p (gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (gbind *bind_stmt = dyn_cast <gbind *> (stmt))\n-\t{\n-\t  inner = gimple_bind_body (bind_stmt);\n-\t  body = &inner;\n-\t  gsi = gsi_start (*body);\n-\t}\n-      else if (dyn_cast <gomp_for *> (stmt))\n-\tbreak;\n-      else\n-\tgsi_next (&gsi);\n-    }\n-\n-  for (gsi = gsi_start (*body); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      tree clauses, nthreads, t, c, acc_device, acc_device_host, call,\n-\tenter, exit;\n-      bool reduction_found = false;\n-\n-      gimple *stmt = gsi_stmt (gsi);\n-\n-      switch (gimple_code (stmt))\n-\t{\n-\tcase GIMPLE_OMP_FOR:\n-\t  clauses = gimple_omp_for_clauses (stmt);\n-\n-\t  /* Search for a reduction clause.  */\n-\t  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n-\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n-\t      {\n-\t\treduction_found = true;\n-\t\tbreak;\n-\t      }\n-\n-\t  if (!reduction_found)\n-\t    break;\n-\n-\t  ctx = maybe_lookup_ctx (stmt);\n-\t  t = NULL_TREE;\n-\n-\t  /* Extract the number of threads.  */\n-\t  nthreads = create_tmp_var (sizetype);\n-\t  t = oacc_max_threads (ctx);\n-\t  gimplify_assign (nthreads, t, in_stmt_seqp);\n-\n-\t  /* Determine if this is kernel will be executed on the host.  */\n-\t  call = builtin_decl_explicit (BUILT_IN_ACC_GET_DEVICE_TYPE);\n-\t  acc_device = create_tmp_var (integer_type_node, \".acc_device_type\");\n-\t  stmt = gimple_build_call (call, 0);\n-\t  gimple_call_set_lhs (stmt, acc_device);\n-\t  gimple_seq_add_stmt (in_stmt_seqp, stmt);\n-\n-\t  /* Set nthreads = 1 for ACC_DEVICE_TYPE=host.  */\n-\t  acc_device_host = create_tmp_var (integer_type_node,\n-\t\t\t\t\t    \".acc_device_host\");\n-\t  gimplify_assign (acc_device_host,\n-\t\t\t   build_int_cst (integer_type_node,\n-\t\t\t\t\t  GOMP_DEVICE_HOST),\n-\t\t\t   in_stmt_seqp);\n-\n-\t  enter = create_artificial_label (UNKNOWN_LOCATION);\n-\t  exit = create_artificial_label (UNKNOWN_LOCATION);\n-\n-\t  stmt = gimple_build_cond (EQ_EXPR, acc_device, acc_device_host,\n-\t\t\t\t    enter, exit);\n-\t  gimple_seq_add_stmt (in_stmt_seqp, stmt);\n-\t  gimple_seq_add_stmt (in_stmt_seqp, gimple_build_label (enter));\n-\t  gimplify_assign (nthreads, fold_build1 (NOP_EXPR, sizetype,\n-\t\t\t\t\t\t  integer_one_node),\n-\t\t\t   in_stmt_seqp);\n-\t  gimple_seq_add_stmt (in_stmt_seqp, gimple_build_label (exit));\n-\n-\t  oacc_initialize_reduction_data (clauses, nthreads, in_stmt_seqp,\n-\t\t\t\t\t  ctx);\n-\t  oacc_finalize_reduction_data (clauses, nthreads, out_stmt_seqp, ctx);\n-\t  break;\n-\tdefault:\n-\t  // Scan for other directives which support reduction here.\n-\t  break;\n-\t}\n-    }\n-}\n-\n /* If ctx is a worksharing context inside of a cancellable parallel\n    region and it isn't nowait, add lhs to its GIMPLE_OMP_RETURN\n    and conditional branch to parallel's cancel_label to handle\n@@ -15009,9 +14604,6 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   irlist = NULL;\n   orlist = NULL;\n-  if (offloaded\n-      && is_gimple_omp_oacc (stmt))\n-    oacc_process_reduction_data (&tgt_body, &irlist, &orlist, ctx);\n \n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     switch (OMP_CLAUSE_CODE (c))\n@@ -15933,7 +15525,22 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    break;\n \t  }\n \n+      gimple_seq fork_seq = NULL;\n+      gimple_seq join_seq = NULL;\n+\n+      if (is_oacc_parallel (ctx))\n+\t{\n+\t  /* If there are reductions on the offloaded region itself, treat\n+\t     them as a dummy GANG loop.  */\n+\t  tree level = build_int_cst (integer_type_node, GOMP_DIM_GANG);\n+\n+\t  lower_oacc_reductions (gimple_location (ctx->stmt), clauses, level,\n+\t\t\t\t false, NULL, NULL, &fork_seq, &join_seq, ctx);\n+\t}\n+\n+      gimple_seq_add_seq (&new_body, fork_seq);\n       gimple_seq_add_seq (&new_body, tgt_body);\n+      gimple_seq_add_seq (&new_body, join_seq);\n \n       if (offloaded)\n \tnew_body = maybe_catch_exception (new_body);\n@@ -19022,6 +18629,11 @@ oacc_loop_xform_head_tail (gcall *from, int level)\n \t  else if (k == kind && stmt != from)\n \t    break;\n \t}\n+      else if (is_gimple_call (stmt)\n+\t       && gimple_call_internal_p (stmt)\n+\t       && gimple_call_internal_fn (stmt) == IFN_GOACC_REDUCTION)\n+\t*gimple_call_arg_ptr (stmt, 3) = replacement;\n+\n       gsi_next (&gsi);\n       while (gsi_end_p (gsi))\n \tgsi = gsi_start_bb (single_succ (gsi_bb (gsi)));\n@@ -19240,6 +18852,53 @@ default_goacc_fork_join (gcall *ARG_UNUSED (call),\n     return targetm.have_oacc_join ();\n }\n \n+/* Default goacc.reduction early expander.\n+\n+   LHS-opt = IFN_REDUCTION (KIND, RES_PTR, VAR, LEVEL, OP, OFFSET)\n+   If RES_PTR is not integer-zerop:\n+       SETUP - emit 'LHS = *RES_PTR', LHS = NULL\n+       TEARDOWN - emit '*RES_PTR = VAR'\n+   If LHS is not NULL\n+       emit 'LHS = VAR'   */\n+\n+void\n+default_goacc_reduction (gcall *call)\n+{\n+  unsigned code = (unsigned)TREE_INT_CST_LOW (gimple_call_arg (call, 0));\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  gimple_seq seq = NULL;\n+\n+  if (code == IFN_GOACC_REDUCTION_SETUP\n+      || code == IFN_GOACC_REDUCTION_TEARDOWN)\n+    {\n+      /* Setup and Teardown need to copy from/to the receiver object,\n+\t if there is one.  */\n+      tree ref_to_res = gimple_call_arg (call, 1);\n+      \n+      if (!integer_zerop (ref_to_res))\n+\t{\n+\t  tree dst = build_simple_mem_ref (ref_to_res);\n+\t  tree src = var;\n+\t  \n+\t  if (code == IFN_GOACC_REDUCTION_SETUP)\n+\t    {\n+\t      src = dst;\n+\t      dst = lhs;\n+\t      lhs = NULL;\n+\t    }\n+\t  gimple_seq_add_stmt (&seq, gimple_build_assign (dst, src));\n+\t}\n+    }\n+\n+  /* Copy VAR to LHS, if there is an LHS.  */\n+  if (lhs)\n+    gimple_seq_add_stmt (&seq, gimple_build_assign (lhs, var));\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n /* Main entry point for oacc transformations which run on the device\n    compiler after LTO, so we know what the target device is at this\n    point (including the host fallback).  */\n@@ -19267,6 +18926,10 @@ execute_oacc_device_lower ()\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  /* Offloaded targets may introduce new basic blocks, which require\n+     dominance information to update SSA.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n   /* Now lower internal loop functions to target-specific code\n      sequences.  */\n   basic_block bb;\n@@ -19301,6 +18964,19 @@ execute_oacc_device_lower ()\n \t    rescan = true;\n \t    break;\n \n+\t  case IFN_GOACC_REDUCTION:\n+\t    /* Mark the function for SSA renaming.  */\n+\t    mark_virtual_operands_for_renaming (cfun);\n+\n+\t    /* If the level is -1, this ended up being an unused\n+\t       axis.  Handle as a default.  */\n+\t    if (integer_minus_onep (gimple_call_arg (call, 3)))\n+\t      default_goacc_reduction (call);\n+\t    else\n+\t      targetm.goacc.reduction (call);\n+\t    rescan = true;\n+\t    break;\n+\n \t  case IFN_UNIQUE:\n \t    {\n \t      enum ifn_unique_kind kind"}, {"sha": "461af6b14d80e07109f246b842787a4451193e3f", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -1670,6 +1670,17 @@ The default hook returns false, if there are no RTL expanders for them.\",\n bool, (gcall *call, const int *dims, bool is_fork),\n default_goacc_fork_join)\n \n+DEFHOOK\n+(reduction,\n+\"This hook is used by the oacc_transform pass to expand calls to the\\n\\\n+@var{GOACC_REDUCTION} internal function, into a sequence of gimple\\n\\\n+instructions.  @var{call} is gimple statement containing the call to\\n\\\n+the function.  This hook removes statement @var{call} after the\\n\\\n+expanded sequence has been inserted.  This hook is also responsible\\n\\\n+for allocating any storage for reductions when necessary.\",\n+void, (gcall *call),\n+default_goacc_reduction)\n+\n HOOK_VECTOR_END (goacc)\n \n /* Functions relating to vectorization.  */"}, {"sha": "c34e4ae052cf6307bc47ae941a5e41bd86a92207", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e50146711b7200e8f822c6d8239430c682b76e4f/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=e50146711b7200e8f822c6d8239430c682b76e4f", "patch": "@@ -111,6 +111,7 @@ extern void default_destroy_cost_data (void *);\n /* OpenACC hooks.  */\n extern bool default_goacc_validate_dims (tree, int [], int);\n extern bool default_goacc_fork_join (gcall *, const int [], bool);\n+extern void default_goacc_reduction (gcall *);\n \n /* These are here, and not in hooks.[ch], because not all users of\n    hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */"}]}