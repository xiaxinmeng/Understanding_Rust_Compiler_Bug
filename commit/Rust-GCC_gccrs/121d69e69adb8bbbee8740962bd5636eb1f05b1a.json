{"sha": "121d69e69adb8bbbee8740962bd5636eb1f05b1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxZDY5ZTY5YWRiOGJiYmVlODc0MDk2MmJkNTYzNmViMWYwNWIxYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-07-14T20:41:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-07-14T20:41:27Z"}, "message": "mips.c (mips_expand_prologue): Use a single insn to allocate 32768 bytes of stack.\n\n\t* config/mips/mips.c (mips_expand_prologue): Use a single insn to\n\tallocate 32768 bytes of stack.  Use addition rather than subtraction\n\twhen a single insn is enough.\n\t* config/mips/mips.md: Remove insns and splitters for subtracting\n\tconstants.\n\t(subsi3): Only accept register operands.\n\t(subsi3_internal): Likewise.  Use for TARGET_MIPS16 as well.\n\t(subdi3_internal_3, subsi3_internal_2): Likewise.\n\t(casesi): Use expand_binop to subtract the lower bound.\n\nFrom-SVN: r69357", "tree": {"sha": "3801fa6d61d4e57a638684647f4a49efc45dc929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3801fa6d61d4e57a638684647f4a49efc45dc929"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/121d69e69adb8bbbee8740962bd5636eb1f05b1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121d69e69adb8bbbee8740962bd5636eb1f05b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121d69e69adb8bbbee8740962bd5636eb1f05b1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121d69e69adb8bbbee8740962bd5636eb1f05b1a/comments", "author": null, "committer": null, "parents": [{"sha": "3485245e16bc7d4052b488e6971ff024d3e5413b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3485245e16bc7d4052b488e6971ff024d3e5413b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3485245e16bc7d4052b488e6971ff024d3e5413b"}], "stats": {"total": 454, "additions": 52, "deletions": 402}, "files": [{"sha": "accf42b863035a687f7bfdd3005288c3b2ea8caf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121d69e69adb8bbbee8740962bd5636eb1f05b1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121d69e69adb8bbbee8740962bd5636eb1f05b1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=121d69e69adb8bbbee8740962bd5636eb1f05b1a", "patch": "@@ -1,3 +1,15 @@\n+2003-07-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_expand_prologue): Use a single insn to\n+\tallocate 32768 bytes of stack.  Use addition rather than subtraction\n+\twhen a single insn is enough.\n+\t* config/mips/mips.md: Remove insns and splitters for subtracting\n+\tconstants.\n+\t(subsi3): Only accept register operands.\n+\t(subsi3_internal): Likewise.  Use for TARGET_MIPS16 as well.\n+\t(subdi3_internal_3, subsi3_internal_2): Likewise.\n+\t(casesi): Use expand_binop to subtract the lower bound.\n+\n 2003-07-14  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_in_small_data_p): Don't handle"}, {"sha": "5e069b789a10f59ee19c7f42ffa1ebbd3f9e13f7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121d69e69adb8bbbee8740962bd5636eb1f05b1a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121d69e69adb8bbbee8740962bd5636eb1f05b1a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=121d69e69adb8bbbee8740962bd5636eb1f05b1a", "patch": "@@ -7424,27 +7424,24 @@ mips_expand_prologue ()\n     {\n       rtx tsize_rtx = GEN_INT (tsize);\n \n-      /* If we are doing svr4-abi, sp move is done by\n-         function_prologue.  In mips16 mode with a large frame, we\n-         save the registers before adjusting the stack.  */\n-      if (!TARGET_MIPS16 || tsize <= 32767)\n+      /* In mips16 mode with a large frame, we save the registers before\n+         adjusting the stack.  */\n+      if (!TARGET_MIPS16 || tsize <= 32768)\n \t{\n-\t  rtx adjustment_rtx;\n-\n-\t  if (tsize > 32767)\n+\t  if (tsize > 32768)\n \t    {\n+\t      rtx adjustment_rtx;\n+\n \t      adjustment_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n \t      emit_move_insn (adjustment_rtx, tsize_rtx);\n+\t      emit_insn (gen_sub3_insn (stack_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tadjustment_rtx));\n \t    }\n \t  else\n-\t    adjustment_rtx = tsize_rtx;\n-\n-\t  if (Pmode == DImode)\n-\t    emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   adjustment_rtx));\n-\t  else\n-\t    emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   adjustment_rtx));\n+\t    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (-tsize)));\n \n \t  mips_set_frame_expr\n \t    (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n@@ -7460,7 +7457,7 @@ mips_expand_prologue ()\n \temit_insn (gen_cprestore\n \t\t   (GEN_INT (current_function_outgoing_args_size)));\n \n-      if (TARGET_MIPS16 && tsize > 32767)\n+      if (TARGET_MIPS16 && tsize > 32768)\n \t{\n \t  rtx reg_rtx;\n \n@@ -7470,14 +7467,9 @@ mips_expand_prologue ()\n \t  reg_rtx = gen_rtx (REG, Pmode, 3);\n   \t  emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n   \t  emit_move_insn (reg_rtx, tsize_rtx);\n-  \t  if (Pmode == DImode)\n-\t    emit_insn (gen_subdi3 (hard_frame_pointer_rtx,\n-\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t   reg_rtx));\n-\t  else\n-\t    emit_insn (gen_subsi3 (hard_frame_pointer_rtx,\n-\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t   reg_rtx));\n+\t  emit_insn (gen_sub3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t    hard_frame_pointer_rtx,\n+\t\t\t\t    reg_rtx));\n \t  emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n \t}\n "}, {"sha": "d30f4690e2f4e922e89423e2e9f2639c0ea8e1bd", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 24, "deletions": 378, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121d69e69adb8bbbee8740962bd5636eb1f05b1a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121d69e69adb8bbbee8740962bd5636eb1f05b1a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=121d69e69adb8bbbee8740962bd5636eb1f05b1a", "patch": "@@ -1250,153 +1250,21 @@\n    (set_attr \"mode\"\t\"SF\")])\n \n (define_expand \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"\")))]\n   \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) == -32768\n-\t  || (TARGET_MIPS16\n-\t      && INTVAL (operands[2]) == -0x4000)))\n-    operands[2] = force_reg (SImode, operands[2]);\n-}\")\n+  \"\")\n \n (define_insn \"subsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"!TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n   \"subu\\\\t%0,%z1,%2\"\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-;; For the mips16, we need to recognize stack pointer subtractions\n-;; explicitly, since we don't have a constraint for $sp.  These insns\n-;; will be generated by the save_restore_insns functions.\n-\n-(define_insn \"\"\n-  [(set (reg:SI 29)\n-\t(minus:SI (reg:SI 29)\n-\t\t  (match_operand:SI 0 \"small_int\" \"I\")))]\n-  \"TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n-  \"addu\\\\t%$,%$,%n0\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 0 \"m16_nsimm8_8\" \"\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 8)))])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (reg:SI 29)\n-\t\t  (match_operand:SI 1 \"small_int\" \"I\")))]\n-  \"TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n-  \"addu\\\\t%0,%$,%n1\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 1 \"m16_nuimm8_4\" \"\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 8)))])\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"I,O,d\")))]\n-  \"TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || (INTVAL (operands[2]) != -32768 && INTVAL (operands[2]) != -0x4000))\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \\\"subu\\\\t%0,%2\\\";\n-  return \\\"subu\\\\t%0,%1,%2\\\";\n-}\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(if_then_else (match_operand:VOID 2 \"m16_nsimm8_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_nsimm4_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (const_int 4)])])\n-\n-;; On the mips16, we can sometimes split a subtract of a constant\n-;; which is a 4 byte instruction into two adds which are both 2 byte\n-;; instructions.  There are two cases: one where we are setting a\n-;; register to a register minus a constant, and one where we are\n-;; simply subtracting a constant from a register.\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(minus:SI (match_dup 0)\n-\t\t  (match_operand:SI 1 \"const_int_operand\" \"\")))]\n-  \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[0]) == REG\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && ((INTVAL (operands[1]) > 0x80\n-\t&& INTVAL (operands[1]) <= 0x80 + 0x80)\n-       || (INTVAL (operands[1]) < - 0x7f\n-\t   && INTVAL (operands[1]) >= - 0x7f - 0x7f))\"\n-  [(set (match_dup 0) (minus:SI (match_dup 0) (match_dup 1)))\n-   (set (match_dup 0) (minus:SI (match_dup 0) (match_dup 2)))]\n-  \"\n-{\n-  HOST_WIDE_INT val = INTVAL (operands[1]);\n-\n-  if (val >= 0)\n-    {\n-      operands[1] = GEN_INT (0x80);\n-      operands[2] = GEN_INT (val - 0x80);\n-    }\n-  else\n-    {\n-      operands[1] = GEN_INT (- 0x7f);\n-      operands[2] = GEN_INT (val + 0x7f);\n-    }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[0]) == REG\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG\n-   && M16_REG_P (REGNO (operands[1]))\n-   && REGNO (operands[0]) != REGNO (operands[1])\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && ((INTVAL (operands[2]) > 0x8\n-\t&& INTVAL (operands[2]) <= 0x8 + 0x80)\n-       || (INTVAL (operands[2]) < - 0x7\n-\t   && INTVAL (operands[2]) >= - 0x7 - 0x7f))\"\n-  [(set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (minus:SI (match_dup 0) (match_dup 3)))]\n-  \"\n-{\n-  HOST_WIDE_INT val = INTVAL (operands[2]);\n-\n-  if (val >= 0)\n-    {\n-      operands[2] = GEN_INT (0x8);\n-      operands[3] = GEN_INT (val - 0x8);\n-    }\n-  else\n-    {\n-      operands[2] = GEN_INT (- 0x7);\n-      operands[3] = GEN_INT (val + 0x7);\n-    }\n-}\")\n-\n (define_expand \"subdi3\"\n   [(parallel [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t\t   (minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n@@ -1482,247 +1350,24 @@\n \t\t  (match_dup 3)))]\n   \"\")\n \n-(define_insn \"subdi3_internal_2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"d,d,d\")\n-\t\t  (match_operand:DI 2 \"small_int\" \"P,J,N\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d\"))]\n-  \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && INTVAL (operands[2]) != -32768\"\n-  \"@\n-   sltu\\\\t%3,%L1,%2\\;subu\\\\t%L0,%L1,%2\\;subu\\\\t%M0,%M1,%3\n-   move\\\\t%L0,%L1\\;move\\\\t%M0,%M1\n-   sltu\\\\t%3,%L1,%2\\;subu\\\\t%L0,%L1,%2\\;subu\\\\t%M0,%M1,1\\;subu\\\\t%M0,%M0,%3\"\n-  [(set_attr \"type\"\t\"darith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"12,8,16\")])\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"small_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && INTVAL (operands[2]) > 0\"\n-\n-  [(set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 1) 0)\n-\t\t(match_dup 2)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(minus:SI (subreg:SI (match_dup 1) 0)\n-\t\t  (match_dup 2)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(minus:SI (subreg:SI (match_dup 1) 4)\n-\t\t  (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"small_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && WORDS_BIG_ENDIAN && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE && !TARGET_MIPS16\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n-   && INTVAL (operands[2]) > 0\"\n-\n-  [(set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 1) 4)\n-\t\t(match_dup 2)))\n-\n-   (set (subreg:SI (match_dup 0) 4)\n-\t(minus:SI (subreg:SI (match_dup 1) 4)\n-\t\t  (match_dup 2)))\n-\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(minus:SI (subreg:SI (match_dup 1) 0)\n-\t\t  (match_dup 3)))]\n-  \"\")\n-\n (define_insn \"subdi3_internal_3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(minus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"dJ\")\n-\t\t  (match_operand:DI 2 \"arith_operand\" \"dI\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n-  \"*\n-{\n-  return (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    ? \\\"daddu\\\\t%0,%z1,%n2\\\"\n-    : \\\"dsubu\\\\t%0,%z1,%2\\\";\n-}\"\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"TARGET_64BIT\"\n+  \"dsubu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"darith\")\n    (set_attr \"mode\"\t\"DI\")])\n \n-;; For the mips16, we need to recognize stack pointer subtractions\n-;; explicitly, since we don't have a constraint for $sp.  These insns\n-;; will be generated by the save_restore_insns functions.\n-\n-(define_insn \"\"\n-  [(set (reg:DI 29)\n-\t(minus:DI (reg:DI 29)\n-\t\t  (match_operand:DI 0 \"small_int\" \"I\")))]\n-  \"TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n-  \"daddu\\\\t%$,%$,%n0\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 0 \"m16_nsimm8_8\" \"\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 8)))])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(minus:DI (reg:DI 29)\n-\t\t  (match_operand:DI 1 \"small_int\" \"I\")))]\n-  \"TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n-  \"daddu\\\\t%0,%$,%n1\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 0 \"m16_nuimm5_4\" \"\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 8)))])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,d,d\")\n-\t\t  (match_operand:DI 2 \"arith_operand\" \"I,O,d\")))]\n-  \"TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || (INTVAL (operands[2]) != -32768 && INTVAL (operands[2]) != -0x4000))\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \\\"dsubu\\\\t%0,%2\\\";\n-  return \\\"dsubu\\\\t%0,%1,%2\\\";\n-}\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(if_then_else (match_operand:VOID 2 \"m16_nsimm5_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_nsimm4_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (const_int 4)])])\n-\n-;; On the mips16, we can sometimes split an add of a constant which is\n-;; a 4 byte instruction into two adds which are both 2 byte\n-;; instructions.  There are two cases: one where we are adding a\n-;; constant plus a register to another register, and one where we are\n-;; simply adding a constant to a register.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(minus:DI (match_dup 0)\n-\t\t  (match_operand:DI 1 \"const_int_operand\" \"\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[0]) == REG\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && ((INTVAL (operands[1]) > 0x10\n-\t&& INTVAL (operands[1]) <= 0x10 + 0x10)\n-       || (INTVAL (operands[1]) < - 0xf\n-\t   && INTVAL (operands[1]) >= - 0xf - 0xf))\"\n-  [(set (match_dup 0) (minus:DI (match_dup 0) (match_dup 1)))\n-   (set (match_dup 0) (minus:DI (match_dup 0) (match_dup 2)))]\n-  \"\n-{\n-  HOST_WIDE_INT val = INTVAL (operands[1]);\n-\n-  if (val >= 0)\n-    {\n-      operands[1] = GEN_INT (0xf);\n-      operands[2] = GEN_INT (val - 0xf);\n-    }\n-  else\n-    {\n-      operands[1] = GEN_INT (- 0x10);\n-      operands[2] = GEN_INT (val + 0x10);\n-    }\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[0]) == REG\n-   && M16_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG\n-   && M16_REG_P (REGNO (operands[1]))\n-   && REGNO (operands[0]) != REGNO (operands[1])\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && ((INTVAL (operands[2]) > 0x8\n-\t&& INTVAL (operands[2]) <= 0x8 + 0x10)\n-       || (INTVAL (operands[2]) < - 0x7\n-\t   && INTVAL (operands[2]) >= - 0x7 - 0xf))\"\n-  [(set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (minus:DI (match_dup 0) (match_dup 3)))]\n-  \"\n-{\n-  HOST_WIDE_INT val = INTVAL (operands[2]);\n-\n-  if (val >= 0)\n-    {\n-      operands[2] = GEN_INT (0x8);\n-      operands[3] = GEN_INT (val - 0x8);\n-    }\n-  else\n-    {\n-      operands[2] = GEN_INT (- 0x7);\n-      operands[3] = GEN_INT (val + 0x7);\n-    }\n-}\")\n-\n (define_insn \"subsi3_internal_2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:DI (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ\")\n-\t\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n-  \"TARGET_64BIT && !TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -32768)\"\n-  \"*\n-{\n-  return (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    ? \\\"addu\\\\t%0,%z1,%n2\\\"\n-    : \\\"subu\\\\t%0,%z1,%2\\\";\n-}\"\n+\t(sign_extend:DI\n+\t    (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"TARGET_64BIT\"\n+  \"subu\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"DI\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-\t(sign_extend:DI (minus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n-\t\t\t\t  (match_operand:SI 2 \"arith_operand\" \"I,O,d\"))))]\n-  \"TARGET_64BIT && TARGET_MIPS16\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || (INTVAL (operands[2]) != -32768 && INTVAL (operands[2]) != -0x4000))\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \\\"subu\\\\t%0,%2\\\";\n-  return \\\"subu\\\\t%0,%1,%2\\\";\n-}\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(if_then_else (match_operand:VOID 2 \"m16_nsimm8_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_nsimm4_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (const_int 4)])])\n-\n-\n \f\n ;;\n ;;  ....................\n@@ -8540,8 +8185,8 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"casesi\"\n   [(set (match_dup 5)\n-\t(minus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"dI\")))\n+\t(minus:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 1 \"const_int_operand\" \"\")))\n    (set (cc0)\n \t(compare:CC (match_dup 5)\n \t\t    (match_operand:SI 2 \"arith_operand\" \"\")))\n@@ -8562,19 +8207,20 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   if (operands[0])\n     {\n-      rtx reg = gen_reg_rtx (SImode);\n+      rtx index;\n \n       /* If the index is too large, go to the default label.  */\n-      emit_insn (gen_subsi3 (reg, operands[0], operands[1]));\n-      emit_insn (gen_cmpsi (reg, operands[2]));\n+      index = expand_binop (SImode, sub_optab, operands[0],\n+\t\t\t    operands[1], 0, 0, OPTAB_WIDEN);\n+      emit_insn (gen_cmpsi (index, operands[2]));\n       emit_insn (gen_bgtu (operands[4]));\n \n       /* Do the PIC jump.  */\n       if (Pmode != DImode)\n-        emit_jump_insn (gen_casesi_internal (reg, operands[3],\n+        emit_jump_insn (gen_casesi_internal (index, operands[3],\n \t\t\t\t\t     gen_reg_rtx (SImode)));\n       else\n-        emit_jump_insn (gen_casesi_internal_di (reg, operands[3],\n+        emit_jump_insn (gen_casesi_internal_di (index, operands[3],\n \t\t\t\t\t\tgen_reg_rtx (DImode)));\n \n       DONE;"}]}