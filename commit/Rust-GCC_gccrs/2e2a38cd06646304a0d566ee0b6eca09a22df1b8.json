{"sha": "2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUyYTM4Y2QwNjY0NjMwNGEwZDU2NmVlMGI2ZWNhMDlhMjJkZjFiOA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-02-06T05:58:10Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-02-06T05:58:10Z"}, "message": "[multiple changes]\n\n\n2003-02-05  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/locale_facets.tcc (time_put::do_put): Use __write.\n\t(money_put::do_put): Same.\n\n2003-02-05  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* include/bits/ios_base.h (ios_base): Document reserved storage.\n\n\t* include/bits/locale_facets.h:\t(struct __pad): Comment on\n\timplementation.\n\t(__verify_grouping): Same.\n\t(__add_grouping): Same.\n\t* include/bits/locale_facets.tcc (__verify_grouping): Move\n\tcomments to declaration.\n\t(__add_grouping): Same.\n\n\t* include/bits/locale_facets.tcc:\n\t(__write<_CharT, _OutIter>): New function.\n\t(__write<_CharT>): New function specialization.\n\t(num_put::_M_insert): Remove explicit loop over iterator.  Use\n\t__write.\n\t(num_put::_M_widen_float): Remove __basefield.\n\t(num_put::_M_widen_int): Move __basefield to within grouping block.\n\n\t* include/bits/streambuf_iterator.h: Include <streambuf>.\n\t(ostreambuf_iterator::_M_put): Add.\n\nFrom-SVN: r62473", "tree": {"sha": "a5992ed0d713382e1bf0580bdae524a2878fb8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5992ed0d713382e1bf0580bdae524a2878fb8ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/comments", "author": null, "committer": null, "parents": [{"sha": "476d909872696454142e588683a9937a3ef98f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476d909872696454142e588683a9937a3ef98f5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476d909872696454142e588683a9937a3ef98f5e"}], "stats": {"total": 156, "additions": 105, "deletions": 51}, "files": [{"sha": "93707882ee97b21c9f0fb732246c176fb00a62d5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "patch": "@@ -1,3 +1,31 @@\n+2003-02-05  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/locale_facets.tcc (time_put::do_put): Use __write.\n+\t(money_put::do_put): Same.\n+\n+2003-02-05  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* include/bits/ios_base.h (ios_base): Document reserved storage.\n+\n+\t* include/bits/locale_facets.h:\t(struct __pad): Comment on\n+\timplementation.\n+\t(__verify_grouping): Same.\n+\t(__add_grouping): Same.\t\t\n+\t* include/bits/locale_facets.tcc (__verify_grouping): Move\n+\tcomments to declaration.\n+\t(__add_grouping): Same.\n+\t\n+\t* include/bits/locale_facets.tcc: \n+\t(__write<_CharT, _OutIter>): New function.\n+\t(__write<_CharT>): New function specialization.\n+\t(num_put::_M_insert): Remove explicit loop over iterator.  Use\n+\t__write.\n+\t(num_put::_M_widen_float): Remove __basefield. \n+\t(num_put::_M_widen_int): Move __basefield to within grouping block.\n+\t\n+\t* include/bits/streambuf_iterator.h: Include <streambuf>.\n+\t(ostreambuf_iterator::_M_put): Add.\n+\n 2003-02-05  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* testsuite/26_numerics/valarray_name_lookup.cc: Fix typo."}, {"sha": "a7d4bf614c41f72347bd0c6b363aca264210577e", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "patch": "@@ -1,6 +1,6 @@\n // Iostreams base classes -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -416,6 +416,7 @@ namespace std\n     _Words  \t\t_M_word_zero;    \n \n     // Guaranteed storage.\n+    // The first 5 iword and pword slots are reserved for internal use.\n     static const int \t_S_local_word_size = 8;\n     _Words  \t\t_M_local_word[_S_local_word_size];  \n "}, {"sha": "a2a043c3a8d7209fe9d706595e5e3c0375d6e962", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "patch": "@@ -103,7 +103,8 @@ namespace std\n     __convert_to_v(const char*, long double&, ios_base::iostate&, \n \t\t   const __c_locale&, int);\n \n-\n+  // NB: __pad is a struct, rather than a function, so it can be\n+  // partially-specialized.\n   template<typename _CharT, typename _Traits>\n     struct __pad\n     {\n@@ -113,17 +114,53 @@ namespace std\n \t     const streamsize __oldlen, const bool __num);\n     };\n \n+  // Used by both numeric and monetary facets.\n+  // Check to make sure that the __grouping_tmp string constructed in\n+  // money_get or num_get matches the canonical grouping for a given\n+  // locale.\n+  // __grouping_tmp is parsed L to R\n+  // 1,222,444 == __grouping_tmp of \"\\1\\3\\3\"\n+  // __grouping is parsed R to L\n+  // 1,222,444 == __grouping of \"\\3\" == \"\\3\\3\\3\"\n   template<typename _CharT>\n     bool\n     __verify_grouping(const basic_string<_CharT>& __grouping, \n \t\t      basic_string<_CharT>& __grouping_tmp);\n \n+  // Used by both numeric and monetary facets.\n+  // Inserts \"group separator\" characters into an array of characters.\n+  // It's recursive, one iteration per group.  It moves the characters\n+  // in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".  Call this\n+  // only with __gbeg != __gend.\n   template<typename _CharT>\n     _CharT*\n     __add_grouping(_CharT* __s, _CharT __sep,  \n \t\t   const char* __gbeg, const char* __gend, \n \t\t   const _CharT* __first, const _CharT* __last);\n \n+  // This template permits specializing facet output code for\n+  // ostreambuf_iterator.  For ostreambuf_iterator, sputn is\n+  // significantly more efficient than incrementing iterators.\n+  template<typename _CharT>\n+    inline\n+    ostreambuf_iterator<_CharT>\n+    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)\n+    {\n+      __s._M_put(__ws, __len);\n+      return __s;\n+    }\n+\n+  // This is the unspecialized form of the template.\n+  template<typename _CharT, typename _OutIter>\n+    inline\n+    _OutIter\n+    __write(_OutIter __s, const _CharT* __ws, int __len)\n+    {\n+      for (int __j = 0; __j < __len; __j++, ++__s)\n+\t*__s = __ws[__j];\n+      return __s;\n+    }\n+\n   // 22.2.1.1  Template class ctype\n   // Include host and configuration specific ctype enums for ctype_base.\n   #include <bits/ctype_base.h>"}, {"sha": "e6e9fbe86973a6c78a380648a79505413638f819", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "patch": "@@ -750,7 +750,6 @@ namespace std\n //282. What types does numpunct grouping refer to?\n       // Add grouping, if necessary. \n       const string __grouping = __np.grouping();\n-      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n       if (__grouping.size())\n \t{\n \t  _CharT* __p2;\n@@ -797,7 +796,6 @@ namespace std\n       // Add grouping, if necessary. \n       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n       const string __grouping = __np.grouping();\n-      const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n       if (__grouping.size())\n \t{\n \t  // By itself __add_grouping cannot deal correctly with __ws when\n@@ -806,6 +804,8 @@ namespace std\n \t  // However, remember that the latter do not occur if the number\n \t  // printed is '0' (__len == 1).\n \t  streamsize __off = 0;\n+\t  const ios_base::fmtflags __basefield = __io.flags() \n+\t    \t\t\t\t\t & ios_base::basefield;\n \t  if ((__io.flags() & ios_base::showbase) && __len > 1)\n \t    if (__basefield == ios_base::oct)\n \t      {\n@@ -840,6 +840,7 @@ namespace std\n     {\n       typedef char_traits<_CharT> \t\t__traits_type;\n       // [22.2.2.2.2] Stage 3.\n+      // If necessary, pad.\n       streamsize __w = __io.width();\n       _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n \t\t\t\t\t\t\t    * __w));\n@@ -855,9 +856,7 @@ namespace std\n \n       // [22.2.2.2.2] Stage 4.\n       // Write resulting, fully-formatted string to output iterator.\n-      for (int __j = 0; __j < __len; ++__j, ++__s)\n-\t*__s = __ws[__j];\n-      return __s;\n+      return __write(__s, __ws, __len);\n     }\n \n   template<typename _CharT, typename _OutIter>\n@@ -1196,7 +1195,8 @@ namespace std\n       char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n       int __len = __convert_from_v(__cs, 0, \"%.01Lf\", __units, _S_c_locale);\n #endif\n-      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __cs_size));\n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t   * __cs_size));\n       __ctype.widen(__cs, __cs + __len, __ws);\n       string_type __digits(__ws);\n       return this->do_put(__s, __intl, __io, __fill, __digits); \n@@ -1290,7 +1290,7 @@ namespace std\n \t\t  const char* __gend = __gbeg + __grouping.size();\n \t\t  const int __n = (__end - __beg) * 2;\n \t\t  _CharT* __ws2 =\n-\t\t    static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n+       \t          static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n \t\t  _CharT* __ws_end = __add_grouping(__ws2, __sep, __gbeg, \n \t\t\t\t\t\t    __gend, __beg, __end);\n \t\t  __value.insert(0, __ws2, __ws_end - __ws2);\n@@ -1359,8 +1359,7 @@ namespace std\n \t    }\n \n \t  // Write resulting, fully-formatted string to output iterator.\n-\t  for (size_type __j = 0; __j < __len; ++__j, ++__s)\n-\t    *__s = __res[__j];\n+\t  __s = __write(__s, __res.c_str(), __len);\n \t}\n       __io.width(0);\n       return __s; \n@@ -1616,7 +1615,8 @@ namespace std\n \t\t    ios_base::iostate& __err) const\n     {\n       typedef char_traits<_CharT> \t\t__traits_type;\n-      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int) * __indexlen));\n+      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int) \n+\t\t\t\t\t\t\t  * __indexlen));\n       size_t __nmatches = 0;\n       size_t __pos = 0;\n       bool __testvalid = true;\n@@ -1633,8 +1633,8 @@ namespace std\n \t  // Find smallest matching string.\n \t  size_t __minlen = 10;\n \t  for (size_t __i2 = 0; __i2 < __nmatches; ++__i2)\n-\t    __minlen = std::min(__minlen, \n-\t\t\t\t__traits_type::length(__names[__matches[__i2]]));\n+\t    __minlen = min(__minlen, \n+\t\t\t   __traits_type::length(__names[__matches[__i2]]));\n \t  \n \t  if (__pos < __minlen && __beg != __end)\n \t    {\n@@ -1878,8 +1878,7 @@ namespace std\n       // NB: This size is arbitrary. Should this be a data member,\n       // initialized at construction?\n       const size_t __maxlen = 64;\n-      char_type* __res =\n-\tstatic_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));\n+      char_type* __res = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));\n \n       // NB: In IEE 1003.1-200x, and perhaps other locale models, it\n       // is possible that the format character will be longer than one\n@@ -1903,10 +1902,7 @@ namespace std\n       __tp._M_put(__res, __maxlen, __fmt, __tm);\n \n       // Write resulting, fully-formatted string to output iterator.\n-      size_t __len = char_traits<char_type>::length(__res);\n-      for (size_t __i = 0; __i < __len; ++__i, ++__s)\n-\t*__s = __res[__i];\n-      return __s;\n+      return __write(__s, __res, char_traits<char_type>::length(__res));\n     }\n \n \n@@ -1946,8 +1942,8 @@ namespace std\n       // If the buffer was not large enough, try again with the correct size.\n       if (__res >= __len)\n \t{\n-\t  __c =\n-\t    static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__res + 1)));\n+\t  __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t      * (__res + 1)));\n \t  _M_transform(__c, __lo, __res + 1);\n \t}\n       return string_type(__c);\n@@ -1984,7 +1980,8 @@ namespace std\n \t\t\t\t   const streamsize __oldlen, const bool __num)\n     {\n       size_t __plen = static_cast<size_t>(__newlen - __oldlen);\n-      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __plen));\n+      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t\t\t\t\t\t\t     * __plen));\n       _Traits::assign(__pads, __plen, __fill); \n \n       _CharT* __beg;\n@@ -2054,14 +2051,6 @@ namespace std\n \t\t\t  __newlen - __beglen - __mod);\n     }\n \n-  // Used by both numeric and monetary facets.\n-  // Check to make sure that the __grouping_tmp string constructed in\n-  // money_get or num_get matches the canonical grouping for a given\n-  // locale.\n-  // __grouping_tmp is parsed L to R\n-  // 1,222,444 == __grouping_tmp of \"/1/3/3\"\n-  // __grouping is parsed R to L\n-  // 1,222,444 == __grouping of \"/3\" == \"/3/3/3\"\n   template<typename _CharT>\n     bool\n     __verify_grouping(const basic_string<_CharT>& __grouping, \n@@ -2086,11 +2075,6 @@ namespace std\n       return __test;\n     }\n \n-  // Used by both numeric and monetary facets.\n-  // Inserts \"group separator\" characters into an array of characters.\n-  // It's recursive, one iteration per group.  It moves the characters\n-  // in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".  Call this\n-  // only with __gbeg != __gend.\n   template<typename _CharT>\n     _CharT*\n     __add_grouping(_CharT* __s, _CharT __sep,  "}, {"sha": "c2dee887c4b8b1fdb2dd8d95b3300c413c4a9e9b", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2a38cd06646304a0d566ee0b6eca09a22df1b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=2e2a38cd06646304a0d566ee0b6eca09a22df1b8", "patch": "@@ -1,6 +1,6 @@\n // Streambuf iterators\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -28,8 +28,6 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-// XXX Should specialize copy, find algorithms for streambuf iterators.\n-\n /** @file streambuf_iterator.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n@@ -40,6 +38,10 @@\n \n #pragma GCC system_header\n \n+#include <streambuf>\n+\n+// NB: Should specialize copy, find algorithms for streambuf iterators.\n+\n namespace std\n {\n   // 24.5.3 Template class istreambuf_iterator\n@@ -166,15 +168,20 @@ namespace std\n       bool \t\t_M_failed;\n \n     public:\n-      inline \n       ostreambuf_iterator(ostream_type& __s) throw ()\n       : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n       \n       ostreambuf_iterator(streambuf_type* __s) throw ()\n       : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n \n       ostreambuf_iterator& \n-      operator=(_CharT __c);\n+      operator=(_CharT __c)\n+      {\n+\tif (!_M_failed && \n+\t    _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))\n+\t  _M_failed = true;\n+\treturn *this;\n+      }\n \n       ostreambuf_iterator& \n       operator*() throw()\n@@ -191,16 +198,13 @@ namespace std\n       bool \n       failed() const throw()\n       { return _M_failed; }\n-    };\n \n-  template<typename _CharT, typename _Traits>\n-    inline ostreambuf_iterator<_CharT, _Traits>&\n-    ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)\n-    {\n-      if (!_M_failed && \n-          _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))\n-\t_M_failed = true;\n-      return *this;\n-    }\n+      ostreambuf_iterator& \n+      _M_put(const _CharT* __ws, streamsize __len)\n+      {\n+\tthis->_M_sbuf->sputn(__ws, __len);\n+\treturn *this;\n+      }\n+    };\n } // namespace std\n #endif"}]}