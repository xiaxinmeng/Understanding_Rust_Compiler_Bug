{"sha": "7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U5YTNhYmJiOGM5N2JiMWJkYzc5Zjk0ZjY2NTQ1OTk3ODAyYWM1ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-05-16T16:24:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-05-16T16:24:19Z"}, "message": "tree-vectorizer.h (NUM_PATTERNS): Increment.\n\n\t* tree-vectorizer.h (NUM_PATTERNS): Increment.\n\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add\n\tvect_recog_rotate_pattern.\n\t(vect_recog_rotate_pattern): New function.\n\n\t* gcc.target/i386/rotate-3.c: New test.\n\t* gcc.target/i386/rotate-3a.c: New test.\n\t* gcc.target/i386/rotate-4.c: New test.\n\t* gcc.target/i386/rotate-4a.c: New test.\n\t* gcc.target/i386/rotate-5.c: New test.\n\t* gcc.target/i386/rotate-5a.c: New test.\n\nFrom-SVN: r198978", "tree": {"sha": "b1fe6ac169ec1ebdb3dacc7df3fa7d05b76def60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1fe6ac169ec1ebdb3dacc7df3fa7d05b76def60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "427b248dd0460725a3d6b266fde176420da3103b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/427b248dd0460725a3d6b266fde176420da3103b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/427b248dd0460725a3d6b266fde176420da3103b"}], "stats": {"total": 361, "additions": 360, "deletions": 1}, "files": [{"sha": "1c70cb1c6c7a27337a79daedaa538d25a6ee95f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -1,3 +1,10 @@\n+2013-05-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-vectorizer.h (NUM_PATTERNS): Increment.\n+\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add\n+\tvect_recog_rotate_pattern.\n+\t(vect_recog_rotate_pattern): New function.\n+\n 2013-05-16  Jason Merrill  <jason@redhat.com>\n \n \t* Makefile.in (LLINKER): New variable."}, {"sha": "4e7a01f6dd4b0b86bdfe940ca6406dfb9c2d3bb8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -1,3 +1,12 @@\n+2013-05-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.target/i386/rotate-3.c: New test.\n+\t* gcc.target/i386/rotate-3a.c: New test.\n+\t* gcc.target/i386/rotate-4.c: New test.\n+\t* gcc.target/i386/rotate-4a.c: New test.\n+\t* gcc.target/i386/rotate-5.c: New test.\n+\t* gcc.target/i386/rotate-5a.c: New test.\n+\n 2013-05-16  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/visibility-21.c: Require section_anchors."}, {"sha": "7f255732b5018203f1d67afc80cb5cd815a99cda", "filename": "gcc/testsuite/gcc.target/i386/rotate-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-3.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-O3 -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+unsigned int a[1024] __attribute__((aligned (32)));\n+\n+__attribute__((noinline, noclone)) void\n+foo (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int j = i & 31;\n+      a[i] = (a[i] << j) | (a[i] >> ((-j) & 31));\n+    }\n+}"}, {"sha": "0685efbd0a5c15888156b1d33971c13faf9ac7f5", "filename": "gcc/testsuite/gcc.target/i386/rotate-3a.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-3a.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-O3 -mavx2\" } */\n+\n+#include \"avx2-check.h\"\n+\n+#include \"rotate-3.c\"\n+\n+static void\n+__attribute__((noinline))\n+avx2_test (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = i * 1073741789U;\n+  foo ();\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int j = i & 31;\n+      unsigned int x = i * 1073741789U;\n+      if (a[i] != ((x << j) | (x >> ((-j) & 31))))\n+\tabort ();\n+    }\n+}"}, {"sha": "0f8fdee07d736abb76ae30d082ce38a6f2599a7d", "filename": "gcc/testsuite/gcc.target/i386/rotate-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-4.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-O3 -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+unsigned int a[1024] __attribute__((aligned (32)));\n+\n+__attribute__((noinline, noclone)) void\n+foo (int j)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (a[i] << j) | (a[i] >> ((-j) & 31));\n+}"}, {"sha": "bc69d206aa5ea2375010820f0b2368f14c65ce0f", "filename": "gcc/testsuite/gcc.target/i386/rotate-4a.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-4a.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-O3 -mavx2\" } */\n+\n+#include \"avx2-check.h\"\n+\n+#include \"rotate-4.c\"\n+\n+static void\n+__attribute__((noinline))\n+avx2_test (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = i * 1073741789U;\n+  foo (3);\n+  for (i = 0; i < 1024; i++)\n+    {\n+      unsigned int x = i * 1073741789U;\n+      if (a[i] != ((x << 3) | (x >> ((-3) & 31))))\n+\tabort ();\n+    }\n+  foo (0);\n+  for (i = 0; i < 1024; i++)\n+    {\n+      unsigned int x = i * 1073741789U;\n+      if (a[i] != ((x << 3) | (x >> ((-3) & 31))))\n+\tabort ();\n+    }\n+  foo (29);\n+  for (i = 0; i < 1024; i++)\n+    if (a[i] != i * 1073741789U)\n+      abort ();\n+}"}, {"sha": "7d5888db2c4b75163693106a63a48acd511f1617", "filename": "gcc/testsuite/gcc.target/i386/rotate-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-5.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -mavx -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+\n+unsigned int a[1024] __attribute__((aligned (32)));\n+\n+__attribute__((noinline, noclone)) void\n+foo (void)\n+{\n+  int i, j = 3;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (a[i] << j) | (a[i] >> ((-j) & 31));\n+}"}, {"sha": "5813654014ef366db7639ded378dc4d3a5142eef", "filename": "gcc/testsuite/gcc.target/i386/rotate-5a.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-5a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-5a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-5a.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O3 -mavx\" } */\n+\n+#include \"avx-check.h\"\n+\n+#include \"rotate-5.c\"\n+\n+static void\n+__attribute__((noinline))\n+avx_test (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    a[i] = i * 1073741789U;\n+  foo ();\n+  for (i = 0; i < 1024; i++)\n+    {\n+      unsigned int x = i * 1073741789U;\n+      if (a[i] != ((x << 3) | (x >> ((-3) & 31))))\n+\tabort ();\n+    }\n+}"}, {"sha": "dacfb87998efc57016ee9f1becd4be295b35d5c4", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -50,6 +50,7 @@ static gimple vect_recog_over_widening_pattern (vec<gimple> *, tree *,\n                                                  tree *);\n static gimple vect_recog_widen_shift_pattern (vec<gimple> *,\n \t                                tree *, tree *);\n+static gimple vect_recog_rotate_pattern (vec<gimple> *, tree *, tree *);\n static gimple vect_recog_vector_vector_shift_pattern (vec<gimple> *,\n \t\t\t\t\t\t      tree *, tree *);\n static gimple vect_recog_divmod_pattern (vec<gimple> *,\n@@ -64,6 +65,7 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_pow_pattern,\n \tvect_recog_widen_shift_pattern,\n \tvect_recog_over_widening_pattern,\n+\tvect_recog_rotate_pattern,\n \tvect_recog_vector_vector_shift_pattern,\n \tvect_recog_divmod_pattern,\n \tvect_recog_mixed_size_cond_pattern,\n@@ -1451,6 +1453,218 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,\n   return pattern_stmt;\n }\n \n+/* Detect a rotate pattern wouldn't be otherwise vectorized:\n+\n+   type a_t, b_t, c_t;\n+\n+   S0 a_t = b_t r<< c_t;\n+\n+  Input/Output:\n+\n+  * STMTS: Contains a stmt from which the pattern search begins,\n+    i.e. the shift/rotate stmt.  The original stmt (S0) is replaced\n+    with a sequence:\n+\n+   S1 d_t = -c_t;\n+   S2 e_t = d_t & (B - 1);\n+   S3 f_t = b_t << c_t;\n+   S4 g_t = b_t >> e_t;\n+   S0 a_t = f_t | g_t;\n+\n+    where B is element bitsize of type.\n+\n+  Output:\n+\n+  * TYPE_IN: The type of the input arguments to the pattern.\n+\n+  * TYPE_OUT: The type of the output of this pattern.\n+\n+  * Return value: A new stmt that will be used to replace the rotate\n+    S0 stmt.  */\n+\n+static gimple\n+vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n+{\n+  gimple last_stmt = stmts->pop ();\n+  tree oprnd0, oprnd1, lhs, var, var1, var2, vectype, type, stype, def, def2;\n+  gimple pattern_stmt, def_stmt;\n+  enum tree_code rhs_code;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+  enum vect_def_type dt;\n+  optab optab1, optab2;\n+\n+  if (!is_gimple_assign (last_stmt))\n+    return NULL;\n+\n+  rhs_code = gimple_assign_rhs_code (last_stmt);\n+  switch (rhs_code)\n+    {\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      break;\n+    default:\n+      return NULL;\n+    }\n+\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+    return NULL;\n+\n+  lhs = gimple_assign_lhs (last_stmt);\n+  oprnd0 = gimple_assign_rhs1 (last_stmt);\n+  type = TREE_TYPE (oprnd0);\n+  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  if (TREE_CODE (oprnd0) != SSA_NAME\n+      || TYPE_PRECISION (TREE_TYPE (lhs)) != TYPE_PRECISION (type)\n+      || !INTEGRAL_TYPE_P (type)\n+      || !TYPE_UNSIGNED (type))\n+    return NULL;\n+\n+  if (!vect_is_simple_use (oprnd1, last_stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t   &def, &dt))\n+    return NULL;\n+\n+  if (dt != vect_internal_def\n+      && dt != vect_constant_def\n+      && dt != vect_external_def)\n+    return NULL;\n+\n+  vectype = get_vectype_for_scalar_type (type);\n+  if (vectype == NULL_TREE)\n+    return NULL;\n+\n+  /* If vector/vector or vector/scalar rotate is supported by the target,\n+     don't do anything here.  */\n+  optab1 = optab_for_tree_code (rhs_code, vectype, optab_vector);\n+  if (optab1\n+      && optab_handler (optab1, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n+    return NULL;\n+\n+  if (bb_vinfo != NULL || dt != vect_internal_def)\n+    {\n+      optab2 = optab_for_tree_code (rhs_code, vectype, optab_scalar);\n+      if (optab2\n+\t  && optab_handler (optab2, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n+\treturn NULL;\n+    }\n+\n+  /* If vector/vector or vector/scalar shifts aren't supported by the target,\n+     don't do anything here either.  */\n+  optab1 = optab_for_tree_code (LSHIFT_EXPR, vectype, optab_vector);\n+  optab2 = optab_for_tree_code (RSHIFT_EXPR, vectype, optab_vector);\n+  if (!optab1\n+      || optab_handler (optab1, TYPE_MODE (vectype)) == CODE_FOR_nothing\n+      || !optab2\n+      || optab_handler (optab2, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n+    {\n+      if (bb_vinfo == NULL && dt == vect_internal_def)\n+\treturn NULL;\n+      optab1 = optab_for_tree_code (LSHIFT_EXPR, vectype, optab_scalar);\n+      optab2 = optab_for_tree_code (RSHIFT_EXPR, vectype, optab_scalar);\n+      if (!optab1\n+\t  || optab_handler (optab1, TYPE_MODE (vectype)) == CODE_FOR_nothing\n+\t  || !optab2\n+\t  || optab_handler (optab2, TYPE_MODE (vectype)) == CODE_FOR_nothing)\n+\treturn NULL;\n+    }\n+\n+  *type_in = vectype;\n+  *type_out = vectype;\n+  if (*type_in == NULL_TREE)\n+    return NULL;\n+\n+  def = NULL_TREE;\n+  if (TREE_CODE (oprnd1) == INTEGER_CST\n+      || TYPE_MODE (TREE_TYPE (oprnd1)) == TYPE_MODE (type))\n+    def = oprnd1;\n+  else if (def_stmt && gimple_assign_cast_p (def_stmt))\n+    {\n+      tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+      if (TYPE_MODE (TREE_TYPE (rhs1)) == TYPE_MODE (type)\n+\t  && TYPE_PRECISION (TREE_TYPE (rhs1))\n+\t     == TYPE_PRECISION (type))\n+\tdef = rhs1;\n+    }\n+\n+  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n+  if (def == NULL_TREE)\n+    {\n+      def = vect_recog_temp_ssa_var (type, NULL);\n+      def_stmt = gimple_build_assign_with_ops (NOP_EXPR, def, oprnd1,\n+\t\t\t\t\t       NULL_TREE);\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+    }\n+  stype = TREE_TYPE (def);\n+\n+  if (TREE_CODE (def) == INTEGER_CST)\n+    {\n+      if (!host_integerp (def, 1)\n+\t  || (unsigned HOST_WIDE_INT) tree_low_cst (def, 1)\n+\t     >= GET_MODE_PRECISION (TYPE_MODE (type))\n+\t  || integer_zerop (def))\n+\treturn NULL;\n+      def2 = build_int_cst (stype,\n+\t\t\t    GET_MODE_PRECISION (TYPE_MODE (type))\n+\t\t\t    - tree_low_cst (def, 1));\n+    }\n+  else\n+    {\n+      tree vecstype = get_vectype_for_scalar_type (stype);\n+      stmt_vec_info def_stmt_vinfo;\n+\n+      if (vecstype == NULL_TREE)\n+\treturn NULL;\n+      def2 = vect_recog_temp_ssa_var (stype, NULL);\n+      def_stmt = gimple_build_assign_with_ops (NEGATE_EXPR, def2, def,\n+\t\t\t\t\t       NULL_TREE);\n+      def_stmt_vinfo\n+\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecstype;\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+      def2 = vect_recog_temp_ssa_var (stype, NULL);\n+      tree mask\n+\t= build_int_cst (stype, GET_MODE_PRECISION (TYPE_MODE (stype)) - 1);\n+      def_stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, def2,\n+\t\t\t\t\t       gimple_assign_lhs (def_stmt),\n+\t\t\t\t\t       mask);\n+      def_stmt_vinfo\n+\t= new_stmt_vec_info (def_stmt, loop_vinfo, bb_vinfo);\n+      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n+      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecstype;\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+    }\n+\n+  var1 = vect_recog_temp_ssa_var (type, NULL);\n+  def_stmt = gimple_build_assign_with_ops (rhs_code == LROTATE_EXPR\n+\t\t\t\t\t   ? LSHIFT_EXPR : RSHIFT_EXPR,\n+\t\t\t\t\t   var1, oprnd0, def);\n+  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+  var2 = vect_recog_temp_ssa_var (type, NULL);\n+  def_stmt = gimple_build_assign_with_ops (rhs_code == LROTATE_EXPR\n+\t\t\t\t\t   ? RSHIFT_EXPR : LSHIFT_EXPR,\n+\t\t\t\t\t   var2, oprnd0, def2);\n+  append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\n+  /* Pattern detected.  */\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"vect_recog_rotate_pattern: detected: \");\n+\n+  /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n+  var = vect_recog_temp_ssa_var (type, NULL);\n+  pattern_stmt = gimple_build_assign_with_ops (BIT_IOR_EXPR, var, var1, var2);\n+\n+  if (dump_enabled_p ())\n+    dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n+\n+  stmts->safe_push (last_stmt);\n+  return pattern_stmt;\n+}\n+\n /* Detect a vector by vector shift pattern that wouldn't be otherwise\n    vectorized:\n "}, {"sha": "7c5dfe884dfb67c668fb4b41b869e7d9cc26489d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e9a3abbb8c97bb1bdc79f94f66545997802ac5d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7e9a3abbb8c97bb1bdc79f94f66545997802ac5d", "patch": "@@ -1005,7 +1005,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (vec<gimple> *, tree *, tree *);\n-#define NUM_PATTERNS 10\n+#define NUM_PATTERNS 11\n void vect_pattern_recog (loop_vec_info, bb_vec_info);\n \n /* In tree-vectorizer.c.  */"}]}