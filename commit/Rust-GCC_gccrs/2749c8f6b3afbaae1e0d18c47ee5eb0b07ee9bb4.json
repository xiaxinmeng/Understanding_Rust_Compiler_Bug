{"sha": "2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc0OWM4ZjZiM2FmYmFhZTFlMGQxOGM0N2VlNWViMGIwN2VlOWJiNA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-08-01T13:02:38Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-08-01T13:02:38Z"}, "message": "re PR tree-optimization/46556 (Code size regression in struct access)\n\ngcc:\n\n\tPR tree-optimization/46556\n\t* gimple-ssa-strength-reduction.c (enum cand_kind): Add CAND_REF.\n\t(base_cand_map): Change to hash table.\n\t(base_cand_hash): New function.\n\t(base_cand_free): Likewise.\n\t(base_cand_eq): Likewise.\n\t(lookup_cand): Change base_cand_map to hash table.\n\t(find_basis_for_candidate): Likewise.\n\t(base_cand_from_table): Exclude CAND_REF.\n\t(restructure_reference): New function.\n\t(slsr_process_ref): Likewise.\n\t(find_candidates_in_block): Call slsr_process_ref.\n\t(dump_candidate): Handle CAND_REF.\n\t(base_cand_dump_callback): New function.\n\t(dump_cand_chains): Change base_cand_map to hash table.\n\t(replace_ref): New function.\n\t(replace_refs): Likewise.\n\t(analyze_candidates_and_replace): Call replace_refs.\n\t(execute_strength_reduction): Change base_cand_map to hash table.\n\ngcc/testsuite:\n\n\tPR tree-optimization/46556\n\t* testsuite/gcc.dg/tree-ssa/slsr-27.c: New.\n\t* testsuite/gcc.dg/tree-ssa/slsr-28.c: New.\n\t* testsuite/gcc.dg/tree-ssa/slsr-29.c: New.\n\nFrom-SVN: r190037", "tree": {"sha": "e01379151b097a379c693676f05e75d3280e2234", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e01379151b097a379c693676f05e75d3280e2234"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/comments", "author": null, "committer": null, "parents": [{"sha": "85add0cfd1e8712bb4d10d49fe2e37460c076a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85add0cfd1e8712bb4d10d49fe2e37460c076a70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85add0cfd1e8712bb4d10d49fe2e37460c076a70"}], "stats": {"total": 451, "additions": 404, "deletions": 47}, "files": [{"sha": "9549c83291827cbf8f70633705d16dcf5433cff4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "patch": "@@ -1,3 +1,25 @@\n+2012-08-01  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\tPR tree-optimization/46556\n+\t* gimple-ssa-strength-reduction.c (enum cand_kind): Add CAND_REF.\n+\t(base_cand_map): Change to hash table.\n+\t(base_cand_hash): New function.\n+\t(base_cand_free): Likewise.\n+\t(base_cand_eq): Likewise.\n+\t(lookup_cand): Change base_cand_map to hash table.\n+\t(find_basis_for_candidate): Likewise.\n+\t(base_cand_from_table): Exclude CAND_REF.\n+\t(restructure_reference): New function.\n+\t(slsr_process_ref): Likewise.\n+\t(find_candidates_in_block): Call slsr_process_ref.\n+\t(dump_candidate): Handle CAND_REF.\n+\t(base_cand_dump_callback): New function.\n+\t(dump_cand_chains): Change base_cand_map to hash table.\n+\t(replace_ref): New function.\n+\t(replace_refs): Likewise.\n+\t(analyze_candidates_and_replace): Call replace_refs.\n+\t(execute_strength_reduction): Change base_cand_map to hash table.\n+\n 2012-08-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_address_subreg_operand): Reject"}, {"sha": "5d79521722b446a72ed7d15c9cdf1586c02414a2", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 299, "deletions": 47, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "patch": "@@ -32,7 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n    2) Explicit multiplies, unknown constant multipliers,\n       no conditional increments. (data gathering complete,\n       replacements pending)\n-   3) Implicit multiplies in addressing expressions. (pending)\n+   3) Implicit multiplies in addressing expressions. (complete)\n    4) Explicit multiplies, conditional increments. (pending)\n \n    It would also be possible to apply strength reduction to divisions\n@@ -106,7 +106,47 @@ along with GCC; see the file COPYING3.  If not see\n \n    as a strength reduction opportunity, even though this S1 would\n    also be replaceable by the S1' above.  This can be added if it\n-   comes up in practice.  */\n+   comes up in practice.\n+\n+   Strength reduction in addressing\n+   --------------------------------\n+   There is another kind of candidate known as CAND_REF.  A CAND_REF\n+   describes a statement containing a memory reference having \n+   complex addressing that might benefit from strength reduction.\n+   Specifically, we are interested in references for which \n+   get_inner_reference returns a base address, offset, and bitpos as\n+   follows:\n+\n+     base:    MEM_REF (T1, C1)\n+     offset:  MULT_EXPR (PLUS_EXPR (T2, C2), C3)\n+     bitpos:  C4 * BITS_PER_UNIT\n+\n+   Here T1 and T2 are arbitrary trees, and C1, C2, C3, C4 are \n+   arbitrary integer constants.  Note that C2 may be zero, in which\n+   case the offset will be MULT_EXPR (T2, C3).\n+\n+   When this pattern is recognized, the original memory reference\n+   can be replaced with:\n+\n+     MEM_REF (POINTER_PLUS_EXPR (T1, MULT_EXPR (T2, C3)),\n+              C1 + (C2 * C3) + C4)\n+\n+   which distributes the multiply to allow constant folding.  When\n+   two or more addressing expressions can be represented by MEM_REFs\n+   of this form, differing only in the constants C1, C2, and C4,\n+   making this substitution produces more efficient addressing during\n+   the RTL phases.  When there are not at least two expressions with\n+   the same values of T1, T2, and C3, there is nothing to be gained\n+   by the replacement.\n+\n+   Strength reduction of CAND_REFs uses the same infrastructure as\n+   that used by CAND_MULTs and CAND_ADDs.  We record T1 in the base (B)\n+   field, MULT_EXPR (T2, C3) in the stride (S) field, and \n+   C1 + (C2 * C3) + C4 in the index (i) field.  A basis for a CAND_REF\n+   is thus another CAND_REF with the same B and S values.  When at \n+   least two CAND_REFs are chained together using the basis relation,\n+   each of them is replaced as above, resulting in improved code\n+   generation for addressing.  */\n \n \n /* Index into the candidate vector, offset by 1.  VECs are zero-based,\n@@ -117,7 +157,8 @@ typedef unsigned cand_idx;\n enum cand_kind\n {\n   CAND_MULT,\n-  CAND_ADD\n+  CAND_ADD,\n+  CAND_REF\n };\n \n struct slsr_cand_d\n@@ -136,7 +177,9 @@ struct slsr_cand_d\n \n   /* The type of the candidate.  This is normally the type of base_name,\n      but casts may have occurred when combining feeding instructions.\n-     A candidate can only be a basis for candidates of the same final type.  */\n+     A candidate can only be a basis for candidates of the same final type.\n+     (For CAND_REFs, this is the type to be used for operand 1 of the\n+     replacement MEM_REF.)  */\n   tree cand_type;\n \n   /* The kind of candidate (CAND_MULT, etc.).  */\n@@ -210,8 +253,8 @@ static struct pointer_map_t *stmt_cand_map;\n /* Obstack for candidates.  */\n static struct obstack cand_obstack;\n \n-/* Array mapping from base SSA names to chains of candidates.  */\n-static cand_chain_t *base_cand_map;\n+/* Hash table embodying a mapping from base names to chains of candidates.  */\n+static htab_t base_cand_map;\n \n /* Obstack for candidate chains.  */\n static struct obstack chain_obstack;\n@@ -224,6 +267,33 @@ lookup_cand (cand_idx idx)\n   return VEC_index (slsr_cand_t, cand_vec, idx - 1);\n }\n \n+/* Callback to produce a hash value for a candidate chain header.  */\n+\n+static hashval_t\n+base_cand_hash (const void *p)\n+{\n+  tree base_expr = ((const_cand_chain_t) p)->base_name;\n+  return iterative_hash_expr (base_expr, 0);\n+}\n+\n+/* Callback when an element is removed from the hash table.\n+   We never remove entries until the entire table is released.  */\n+\n+static void\n+base_cand_free (void *p ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+/* Callback to return true if two candidate chain headers are equal.  */\n+\n+static int\n+base_cand_eq (const void *p1, const void *p2)\n+{\n+  const_cand_chain_t const chain1 = (const_cand_chain_t) p1;\n+  const_cand_chain_t const chain2 = (const_cand_chain_t) p2;\n+  return operand_equal_p (chain1->base_name, chain2->base_name, 0);\n+}\n+\f\n /* Use the base name from candidate C to look for possible candidates\n    that can serve as a basis for C.  Each potential basis must also\n    appear in a block that dominates the candidate statement and have\n@@ -234,11 +304,12 @@ lookup_cand (cand_idx idx)\n static int\n find_basis_for_candidate (slsr_cand_t c)\n {\n+  cand_chain mapping_key;\n   cand_chain_t chain;\n   slsr_cand_t basis = NULL;\n \n-  gcc_assert (TREE_CODE (c->base_name) == SSA_NAME);\n-  chain = base_cand_map[SSA_NAME_VERSION (c->base_name)];\n+  mapping_key.base_name = c->base_name;\n+  chain = (cand_chain_t) htab_find (base_cand_map, &mapping_key);\n \n   for (; chain; chain = chain->next)\n     {\n@@ -272,23 +343,23 @@ find_basis_for_candidate (slsr_cand_t c)\n static void\n record_potential_basis (slsr_cand_t c)\n {\n-  cand_chain_t node, head;\n-  int index;\n+  cand_chain_t node;\n+  void **slot;\n \n   node = (cand_chain_t) obstack_alloc (&chain_obstack, sizeof (cand_chain));\n   node->base_name = c->base_name;\n   node->cand = c;\n   node->next = NULL;\n-  index = SSA_NAME_VERSION (c->base_name);\n-  head = base_cand_map[index];\n+  slot = htab_find_slot (base_cand_map, node, INSERT);\n \n-  if (head)\n+  if (*slot)\n     {\n+      cand_chain_t head = (cand_chain_t) (*slot);\n       node->next = head->next;\n       head->next = node;\n     }\n   else\n-    base_cand_map[index] = node;\n+    *slot = node;\n }\n \n /* Allocate storage for a new candidate and initialize its fields.\n@@ -382,10 +453,11 @@ base_cand_from_table (tree base_in)\n     return (slsr_cand_t) NULL;\n \n   result = (slsr_cand_t *) pointer_map_contains (stmt_cand_map, def);\n-  if (!result)\n-    return (slsr_cand_t) NULL;\n+  \n+  if (result && (*result)->kind != CAND_REF)\n+    return *result;\n \n-  return *result;\n+  return (slsr_cand_t) NULL;\n }\n \n /* Add an entry to the statement-to-candidate mapping.  */\n@@ -398,6 +470,127 @@ add_cand_for_stmt (gimple gs, slsr_cand_t c)\n   *slot = c;\n }\n \f\n+/* Look for the following pattern:\n+\n+    *PBASE:    MEM_REF (T1, C1)\n+\n+    *POFFSET:  MULT_EXPR (T2, C3)        [C2 is zero]\n+                     or\n+               MULT_EXPR (PLUS_EXPR (T2, C2), C3)\n+                     or\n+               MULT_EXPR (MINUS_EXPR (T2, -C2), C3)\n+\n+    *PINDEX:   C4 * BITS_PER_UNIT\n+\n+   If not present, leave the input values unchanged and return FALSE.\n+   Otherwise, modify the input values as follows and return TRUE:\n+\n+    *PBASE:    T1\n+    *POFFSET:  MULT_EXPR (T2, C3)\n+    *PINDEX:   C1 + (C2 * C3) + C4  */\n+\n+static bool\n+restructure_reference (tree *pbase, tree *poffset, double_int *pindex,\n+\t\t       tree *ptype)\n+{\n+  tree base = *pbase, offset = *poffset;\n+  double_int index = *pindex;\n+  double_int bpu = uhwi_to_double_int (BITS_PER_UNIT);\n+  tree mult_op0, mult_op1, t1, t2, type;\n+  double_int c1, c2, c3, c4;\n+\n+  if (!base\n+      || !offset\n+      || TREE_CODE (base) != MEM_REF\n+      || TREE_CODE (offset) != MULT_EXPR\n+      || TREE_CODE (TREE_OPERAND (offset, 1)) != INTEGER_CST\n+      || !double_int_zero_p (double_int_umod (index, bpu, FLOOR_MOD_EXPR)))\n+    return false;\n+\n+  t1 = TREE_OPERAND (base, 0);\n+  c1 = mem_ref_offset (base);\n+  type = TREE_TYPE (TREE_OPERAND (base, 1));\n+\n+  mult_op0 = TREE_OPERAND (offset, 0);\n+  mult_op1 = TREE_OPERAND (offset, 1);\n+\n+  c3 = tree_to_double_int (mult_op1);\n+\n+  if (TREE_CODE (mult_op0) == PLUS_EXPR)\n+\n+    if (TREE_CODE (TREE_OPERAND (mult_op0, 1)) == INTEGER_CST)\n+      {\n+\tt2 = TREE_OPERAND (mult_op0, 0);\n+\tc2 = tree_to_double_int (TREE_OPERAND (mult_op0, 1));\n+      }\n+    else\n+      return false;\n+\n+  else if (TREE_CODE (mult_op0) == MINUS_EXPR)\n+\n+    if (TREE_CODE (TREE_OPERAND (mult_op0, 1)) == INTEGER_CST)\n+      {\n+\tt2 = TREE_OPERAND (mult_op0, 0);\n+\tc2 = double_int_neg (tree_to_double_int (TREE_OPERAND (mult_op0, 1)));\n+      }\n+    else\n+      return false;\n+\n+  else\n+    {\n+      t2 = mult_op0;\n+      c2 = double_int_zero;\n+    }\n+\n+  c4 = double_int_udiv (index, bpu, FLOOR_DIV_EXPR);\n+\n+  *pbase = t1;\n+  *poffset = fold_build2 (MULT_EXPR, sizetype, t2,\n+\t\t\t  double_int_to_tree (sizetype, c3));\n+  *pindex = double_int_add (double_int_add (c1, double_int_mul (c2, c3)), c4);\n+  *ptype = type;\n+\n+  return true;\n+}\n+\n+/* Given GS which contains a data reference, create a CAND_REF entry in\n+   the candidate table and attempt to find a basis.  */\n+\n+static void\n+slsr_process_ref (gimple gs)\n+{\n+  tree ref_expr, base, offset, type;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  enum machine_mode mode;\n+  int unsignedp, volatilep;\n+  double_int index;\n+  slsr_cand_t c;\n+\n+  if (gimple_vdef (gs))\n+    ref_expr = gimple_assign_lhs (gs);\n+  else\n+    ref_expr = gimple_assign_rhs1 (gs);\n+\n+  if (!handled_component_p (ref_expr)\n+      || TREE_CODE (ref_expr) == BIT_FIELD_REF\n+      || (TREE_CODE (ref_expr) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD (TREE_OPERAND (ref_expr, 1))))\n+    return;\n+\n+  base = get_inner_reference (ref_expr, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t      &unsignedp, &volatilep, false);\n+  index = uhwi_to_double_int (bitpos);\n+\n+  if (!restructure_reference (&base, &offset, &index, &type))\n+    return;\n+\n+  c = alloc_cand_and_find_basis (CAND_REF, gs, base, index, offset,\n+\t\t\t\t type, 0);\n+\n+  /* Add the candidate to the statement-candidate mapping.  */\n+  add_cand_for_stmt (gs, c);\n+}\n+\n /* Create a candidate entry for a statement GS, where GS multiplies\n    two SSA names BASE_IN and STRIDE_IN.  Propagate any known information\n    about the two SSA names into the new candidate.  Return the new\n@@ -1048,8 +1241,12 @@ find_candidates_in_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     {\n       gimple gs = gsi_stmt (gsi);\n \n-      if (is_gimple_assign (gs)\n-\t  && SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (gimple_assign_lhs (gs)))))\n+      if (gimple_vuse (gs) && gimple_assign_single_p (gs))\n+\tslsr_process_ref (gs);\n+\n+      else if (is_gimple_assign (gs)\n+\t       && SCALAR_INT_MODE_P\n+\t            (TYPE_MODE (TREE_TYPE (gimple_assign_lhs (gs)))))\n \t{\n \t  tree rhs1 = NULL_TREE, rhs2 = NULL_TREE;\n \n@@ -1143,6 +1340,15 @@ dump_candidate (slsr_cand_t c)\n       print_generic_expr (dump_file, c->stride, 0);\n       fputs (\") : \", dump_file);\n       break;\n+    case CAND_REF:\n+      fputs (\"     REF  : \", dump_file);\n+      print_generic_expr (dump_file, c->base_name, 0);\n+      fputs (\" + (\", dump_file);\n+      print_generic_expr (dump_file, c->stride, 0);\n+      fputs (\") + \", dump_file);\n+      dump_double_int (dump_file, c->index, false);\n+      fputs (\" : \", dump_file);\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -1173,36 +1379,33 @@ dump_cand_vec (void)\n     dump_candidate (c);\n }\n \n-/* Dump the candidate chains.  */\n+/* Callback used to dump the candidate chains hash table.  */\n \n-static void\n-dump_cand_chains (void)\n+static int\n+base_cand_dump_callback (void **slot, void *ignored ATTRIBUTE_UNUSED)\n {\n-  unsigned i;\n+  const_cand_chain_t chain = *((const_cand_chain_t *) slot);\n+  cand_chain_t p;\n \n-  fprintf (dump_file, \"\\nStrength reduction candidate chains:\\n\\n\");\n+  print_generic_expr (dump_file, chain->base_name, 0);\n+  fprintf (dump_file, \" -> %d\", chain->cand->cand_num);\n \n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      const_cand_chain_t chain = base_cand_map[i];\n-\n-      if (chain)\n-\t{\n-\t  cand_chain_t p;\n+  for (p = chain->next; p; p = p->next)\n+    fprintf (dump_file, \" -> %d\", p->cand->cand_num);\n \n-\t  print_generic_expr (dump_file, chain->base_name, 0);\n-\t  fprintf (dump_file, \" -> %d\", chain->cand->cand_num);\n-\n-\t  for (p = chain->next; p; p = p->next)\n-\t    fprintf (dump_file, \" -> %d\", p->cand->cand_num);\n+  fputs (\"\\n\", dump_file);\n+  return 1;\n+}\n \n-\t  fputs (\"\\n\", dump_file);\n-\t}\n-    }\n+/* Dump the candidate chains.  */\n \n+static void\n+dump_cand_chains (void)\n+{\n+  fprintf (dump_file, \"\\nStrength reduction candidate chains:\\n\\n\");\n+  htab_traverse_noresize (base_cand_map, base_cand_dump_callback, NULL);\n   fputs (\"\\n\", dump_file);\n }\n-\n \f\n /* Recursive helper for unconditional_cands_with_known_stride_p.\n    Returns TRUE iff C, its siblings, and its dependents are all\n@@ -1238,6 +1441,53 @@ unconditional_cands_with_known_stride_p (slsr_cand_t root)\n   return unconditional_cands (lookup_cand (root->dependent));\n }\n \n+/* Replace *EXPR in candidate C with an equivalent strength-reduced\n+   data reference.  */\n+\n+static void\n+replace_ref (tree *expr, slsr_cand_t c)\n+{\n+  tree add_expr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (c->base_name),\n+\t\t\t       c->base_name, c->stride);\n+  tree mem_ref = fold_build2 (MEM_REF, TREE_TYPE (*expr), add_expr,\n+\t\t\t      double_int_to_tree (c->cand_type, c->index));\n+  \n+  /* Gimplify the base addressing expression for the new MEM_REF tree.  */\n+  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);\n+  TREE_OPERAND (mem_ref, 0)\n+    = force_gimple_operand_gsi (&gsi, TREE_OPERAND (mem_ref, 0),\n+\t\t\t\t/*simple_p=*/true, NULL,\n+\t\t\t\t/*before=*/true, GSI_SAME_STMT);\n+  copy_ref_info (mem_ref, *expr);\n+  *expr = mem_ref;\n+  update_stmt (c->cand_stmt);\n+}\n+\n+/* Replace CAND_REF candidate C, each sibling of candidate C, and each\n+   dependent of candidate C with an equivalent strength-reduced data\n+   reference.  */\n+\n+static void\n+replace_refs (slsr_cand_t c)\n+{\n+  if (gimple_vdef (c->cand_stmt))\n+    {\n+      tree *lhs = gimple_assign_lhs_ptr (c->cand_stmt);\n+      replace_ref (lhs, c);\n+    }\n+  else\n+    {\n+      tree *rhs = gimple_assign_rhs1_ptr (c->cand_stmt);\n+      replace_ref (rhs, c);\n+    }\n+\n+  if (c->sibling)\n+    replace_refs (lookup_cand (c->sibling));\n+\n+  if (c->dependent)\n+    replace_refs (lookup_cand (c->dependent));\n+}\n+\n /* Calculate the increment required for candidate C relative to \n    its basis.  */\n \n@@ -1405,13 +1655,18 @@ analyze_candidates_and_replace (void)\n \n       first_dep = lookup_cand (c->dependent);\n \n+      /* If this is a chain of CAND_REFs, unconditionally replace\n+\t each of them with a strength-reduced data reference.  */\n+      if (c->kind == CAND_REF)\n+\treplace_refs (c);\n+\n       /* If the common stride of all related candidates is a\n \t known constant, and none of these has a phi-dependence,\n \t then all replacements are considered profitable.\n \t Each replaces a multiply by a single add, with the\n \t possibility that a feeding add also goes dead as a\n \t result.  */\n-      if (unconditional_cands_with_known_stride_p (c))\n+      else if (unconditional_cands_with_known_stride_p (c))\n \treplace_dependents (first_dep);\n \n       /* TODO:  When the stride is an SSA name, it may still be\n@@ -1420,9 +1675,6 @@ analyze_candidates_and_replace (void)\n \t can be reused, or are less expensive to calculate than\n \t the replaced statements.  */\n \n-      /* TODO:  Strength-reduce data references with implicit\n-\t multiplication in their addressing expressions.  */\n-\n       /* TODO:  When conditional increments occur so that a \n \t candidate is dependent upon a phi-basis, the cost of\n \t introducing a temporary must be accounted for.  */\n@@ -1447,8 +1699,8 @@ execute_strength_reduction (void)\n   gcc_obstack_init (&chain_obstack);\n \n   /* Allocate the mapping from base names to candidate chains.  */\n-  base_cand_map = XNEWVEC (cand_chain_t, num_ssa_names);\n-  memset (base_cand_map, 0, num_ssa_names * sizeof (cand_chain_t));\n+  base_cand_map = htab_create (500, base_cand_hash,\n+\t\t\t       base_cand_eq, base_cand_free);\n \n   /* Initialize the loop optimizer.  We need to detect flow across\n      back edges, and this gives us dominator information as well.  */\n@@ -1479,7 +1731,7 @@ execute_strength_reduction (void)\n   /* Free resources.  */\n   fini_walk_dominator_tree (&walk_data);\n   loop_optimizer_finalize ();\n-  free (base_cand_map);\n+  htab_delete (base_cand_map);\n   obstack_free (&chain_obstack, NULL);\n   pointer_map_destroy (stmt_cand_map);\n   VEC_free (slsr_cand_t, heap, cand_vec);"}, {"sha": "330e64583958f2abbc6530a4798c260fb0f565ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "patch": "@@ -1,3 +1,10 @@\n+2012-08-01  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\tPR tree-optimization/46556\n+\t* testsuite/gcc.dg/tree-ssa/slsr-27.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/slsr-28.c: New.\n+\t* testsuite/gcc.dg/tree-ssa/slsr-29.c: New.\n+\n 2012-07-31  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/42418"}, {"sha": "b0defc7a8799bf3223a98d9c8ea7e2a2b3110b6f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-27.c?ref=2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom2\" } */\n+\n+struct x\n+{\n+  int a[16];\n+  int b[16];\n+  int c[16];\n+};\n+\n+extern void foo (int, int, int);\n+\n+void\n+f (struct x *p, unsigned int n)\n+{\n+  foo (p->a[n], p->c[n], p->b[n]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\* 4;\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ D\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)D\" 3 \"dom2\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom2\" } } */"}, {"sha": "fdf1596b80297e2fd88b5efdc2139c2f220bf21a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-28.c?ref=2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom2\" } */\n+\n+struct x\n+{\n+  int a[16];\n+  int b[16];\n+  int c[16];\n+};\n+\n+extern void foo (int, int, int);\n+\n+void\n+f (struct x *p, unsigned int n)\n+{\n+  foo (p->a[n], p->c[n], p->b[n]);\n+  if (n > 12)\n+    foo (p->a[n], p->c[n], p->b[n]);\n+  else if (n > 3)\n+    foo (p->b[n], p->a[n], p->c[n]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\* 4;\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ D\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)D\" 9 \"dom2\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom2\" } } */"}, {"sha": "2366a863137fcc93aa9ef5a42f13846949f9425f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-29.c?ref=2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom2\" } */\n+\n+struct x\n+{\n+  int a[16];\n+  int b[16];\n+  int c[16];\n+};\n+\n+extern void foo (int, int, int);\n+\n+void\n+f (struct x *p, unsigned int n)\n+{\n+  foo (p->a[n], p->c[n], p->b[n]);\n+  if (n > 3)\n+    {\n+      foo (p->a[n], p->c[n], p->b[n]);\n+      if (n > 12)\n+\tfoo (p->b[n], p->a[n], p->c[n]);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\* 4;\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ D\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)D\" 9 \"dom2\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom2\" } } */"}]}