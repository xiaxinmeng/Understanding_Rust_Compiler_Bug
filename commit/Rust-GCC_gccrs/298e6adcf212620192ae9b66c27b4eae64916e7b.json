{"sha": "298e6adcf212620192ae9b66c27b4eae64916e7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4ZTZhZGNmMjEyNjIwMTkyYWU5YjY2YzI3YjRlYWU2NDkxNmU3Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-30T19:13:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-30T19:13:03Z"}, "message": "alias.c (mems_in_disjoint_alias_sets_p, [...]): Use gcc_assert and gcc_unreachable instead of abort.\n\n\t* alias.c (mems_in_disjoint_alias_sets_p, record_alias_subset,\n\trecord_set, rtx_equal_for_memref_p, init_alias_analysis): Use\n\tgcc_assert and gcc_unreachable instead of abort.\n\t* alloc-pool.c (abort, fancy_abort): Remove.\n\t(create_alloc_pool, free_alloc_pool, pool_alloc, pool_free): Use\n\tgcc_assert or gcc_unreachable.\n\t* attribs.c (init_attributes, decl_attributes): Likewise.\n\t* bb-reorder.c (FREE, find_traces_1_round, copy_bb,\n\tmark_bb_for_unlikely_executed_section,\n\tadd_labels_and_missing_jumps, fix_crossing_conditional_branches,\n\tfix_crossing_unconditional_branches):  Likewise.\n\t* bitmap.c (bitmap_first_set_bit, bitmap_last_set_bit,\n\tbitmap_operation):  Likewise.\n\t* bt-load.c (insn_sets_btr_p, augment_live_range,\n\tmove_btr_def):  Likewise.\n\t* builtins.c (c_readstr, expand_builtin_longjmp, apply_args_size,\n\tapply_result_size, expand_builtin_apply, expand_builtin_mathfn,\n\texpand_builtin_mathfn_2, expand_builtin_mathfn_3,\n\tbuiltin_memcpy_read_str, expand_movstr, expand_builtin_stpcpy,\n\texpand_builtin_memcmp, expand_builtin_args_info,\n\tstd_gimplify_va_arg_expr, expand_builtin_unop,\n\texpand_builtin_fputs, expand_builtin_profile_func,\n\texpand_builtin_fork_or_exec, fold_builtin_bitop,\n\tfold_builtin_classify, fold_builtin_fputs): Likewise.\n\nFrom-SVN: r86797", "tree": {"sha": "fff62e6c69665ec9937365c779e5da53606f6d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff62e6c69665ec9937365c779e5da53606f6d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/298e6adcf212620192ae9b66c27b4eae64916e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298e6adcf212620192ae9b66c27b4eae64916e7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298e6adcf212620192ae9b66c27b4eae64916e7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298e6adcf212620192ae9b66c27b4eae64916e7b/comments", "author": null, "committer": null, "parents": [{"sha": "0de4325e0bc2e0601e49ac8e85ca9a7134e50198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de4325e0bc2e0601e49ac8e85ca9a7134e50198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de4325e0bc2e0601e49ac8e85ca9a7134e50198"}], "stats": {"total": 282, "additions": 115, "deletions": 167}, "files": [{"sha": "02ba2603baae04a796bcd2a8828cc15167bc822c", "filename": "gcc/alias.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -229,18 +229,15 @@ get_alias_set_entry (HOST_WIDE_INT alias_set)\n static inline int\n mems_in_disjoint_alias_sets_p (rtx mem1, rtx mem2)\n {\n-#ifdef ENABLE_CHECKING\n /* Perform a basic sanity check.  Namely, that there are no alias sets\n    if we're not using strict aliasing.  This helps to catch bugs\n    whereby someone uses PUT_CODE, but doesn't clear MEM_ALIAS_SET, or\n    where a MEM is allocated in some way other than by the use of\n    gen_rtx_MEM, and the MEM_ALIAS_SET is not cleared.  If we begin to\n    use alias sets to indicate that spilled registers cannot alias each\n    other, we might need to remove this check.  */\n-  if (! flag_strict_aliasing\n-      && (MEM_ALIAS_SET (mem1) != 0 || MEM_ALIAS_SET (mem2) != 0))\n-    abort ();\n-#endif\n+  gcc_assert (flag_strict_aliasing\n+\t      || (!MEM_ALIAS_SET (mem1) && !MEM_ALIAS_SET (mem2)));\n \n   return ! alias_sets_conflict_p (MEM_ALIAS_SET (mem1), MEM_ALIAS_SET (mem2));\n }\n@@ -624,8 +621,7 @@ record_alias_subset (HOST_WIDE_INT superset, HOST_WIDE_INT subset)\n   if (superset == subset)\n     return;\n \n-  if (superset == 0)\n-    abort ();\n+  gcc_assert (superset);\n \n   superset_entry = get_alias_set_entry (superset);\n   if (superset_entry == 0)\n@@ -930,8 +926,7 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n \n   regno = REGNO (dest);\n \n-  if (regno >= VARRAY_SIZE (reg_base_value))\n-    abort ();\n+  gcc_assert (regno < VARRAY_SIZE (reg_base_value));\n \n   /* If this spans multiple hard registers, then we must indicate that every\n      register has an unusable value.  */\n@@ -1307,7 +1302,7 @@ rtx_equal_for_memref_p (rtx x, rtx y)\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -2899,8 +2894,8 @@ init_alias_analysis (void)\n \t}\n \n       /* Now propagate values from new_reg_base_value to reg_base_value.  */\n-      if (maxreg != (unsigned int) max_reg_num())\n-\tabort ();\n+      gcc_assert (maxreg == (unsigned int) max_reg_num());\n+      \n       for (ui = 0; ui < maxreg; ui++)\n \t{\n \t  if (new_reg_base_value[ui]"}, {"sha": "14876536cdd1241dd8cfaac136edcaae8ad577ea", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -25,16 +25,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"alloc-pool.h\"\n #include \"hashtab.h\"\n \n-/* Redefine abort to report an internal error w/o coredump, and\n-   reporting the location of the error in the source file.  This logic\n-   is duplicated in rtl.h and tree.h because every file that needs the\n-   special abort includes one or both.  toplev.h gets too few files,\n-   system.h gets too many.  */\n-\n-extern void fancy_abort (const char *, int, const char *)\n-    ATTRIBUTE_NORETURN;\n-#define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n-\n #define align_eight(x) (((x+7) >> 3) << 3)\n \n /* The internal allocation object.  */\n@@ -135,8 +125,7 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n   struct alloc_pool_descriptor *desc;\n #endif\n \n-  if (!name)\n-    abort ();\n+  gcc_assert (name);\n \n   /* Make size large enough to store the list header.  */\n   if (size < sizeof (alloc_pool_list))\n@@ -151,8 +140,7 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n #endif\n \n   /* Um, we can't really allocate 0 elements per block.  */\n-  if (num == 0)\n-    abort ();\n+  gcc_assert (num);\n \n   /* Find the size of the pool structure, and the name.  */\n   pool_size = sizeof (struct alloc_pool_def);\n@@ -201,10 +189,7 @@ free_alloc_pool (alloc_pool pool)\n   struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n #endif\n \n-#ifdef ENABLE_CHECKING\n-  if (!pool)\n-    abort ();\n-#endif\n+  gcc_assert (pool);\n \n   /* Free each block allocated to the pool.  */\n   for (block = pool->block_list; block != NULL; block = next_block)\n@@ -234,10 +219,7 @@ pool_alloc (alloc_pool pool)\n   desc->allocated+=pool->elt_size;\n #endif\n \n-#ifdef ENABLE_CHECKING\n-  if (!pool)\n-    abort ();\n-#endif\n+  gcc_assert (pool);\n \n   /* If there are no more free elements, make some more!.  */\n   if (!pool->free_list)\n@@ -296,22 +278,19 @@ pool_free (alloc_pool pool, void *ptr)\n {\n   alloc_pool_list header;\n \n-#ifdef ENABLE_CHECKING\n-  if (!ptr)\n-    abort ();\n+  gcc_assert (ptr);\n \n+#ifdef ENABLE_CHECKING\n   memset (ptr, 0xaf, pool->elt_size - offsetof (allocation_object, u.data));\n \n   /* Check whether the PTR was allocated from POOL.  */\n-  if (pool->id != ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id)\n-    abort ();\n+  gcc_assert (pool->id == ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id);\n \n   /* Mark the element to be free.  */\n   ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id = 0;\n #else\n   /* Check if we free more than we allocated, which is Bad (TM).  */\n-  if (pool->elts_free + 1 > pool->elts_allocated)\n-    abort ();\n+  gcc_assert (pool->elts_free < pool->elts_allocated);\n #endif\n \n   header = (alloc_pool_list) ptr;"}, {"sha": "8174f39222c32461f248933088188d1385d1c550", "filename": "gcc/attribs.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -77,25 +77,25 @@ init_attributes (void)\n \t  /* The name must not begin and end with __.  */\n \t  const char *name = attribute_tables[i][j].name;\n \t  int len = strlen (name);\n-\t  if (name[0] == '_' && name[1] == '_'\n-\t      && name[len - 1] == '_' && name[len - 2] == '_')\n-\t    abort ();\n+\t  \n+\t  gcc_assert (!(name[0] == '_' && name[1] == '_'\n+\t\t\t&& name[len - 1] == '_' && name[len - 2] == '_'));\n+\t  \n \t  /* The minimum and maximum lengths must be consistent.  */\n-\t  if (attribute_tables[i][j].min_length < 0)\n-\t    abort ();\n-\t  if (attribute_tables[i][j].max_length != -1\n-\t      && (attribute_tables[i][j].max_length\n-\t\t  < attribute_tables[i][j].min_length))\n-\t    abort ();\n+\t  gcc_assert (attribute_tables[i][j].min_length >= 0);\n+\t  \n+\t  gcc_assert (attribute_tables[i][j].max_length == -1\n+\t\t      || (attribute_tables[i][j].max_length\n+\t\t\t  >= attribute_tables[i][j].min_length));\n+\t  \n \t  /* An attribute cannot require both a DECL and a TYPE.  */\n-\t  if (attribute_tables[i][j].decl_required\n-\t      && attribute_tables[i][j].type_required)\n-\t    abort ();\n+\t  gcc_assert (!attribute_tables[i][j].decl_required\n+\t\t      || !attribute_tables[i][j].type_required);\n+\t  \n \t  /* If an attribute requires a function type, in particular\n \t     it requires a type.  */\n-\t  if (attribute_tables[i][j].function_type_required\n-\t      && !attribute_tables[i][j].type_required)\n-\t    abort ();\n+\t  gcc_assert (!attribute_tables[i][j].function_type_required\n+\t\t      || attribute_tables[i][j].type_required);\n \t}\n     }\n \n@@ -105,9 +105,8 @@ init_attributes (void)\n       int j, k;\n       for (j = 0; attribute_tables[i][j].name != NULL; j++)\n \tfor (k = j + 1; attribute_tables[i][k].name != NULL; k++)\n-\t  if (!strcmp (attribute_tables[i][j].name,\n-\t\t       attribute_tables[i][k].name))\n-\t    abort ();\n+\t  gcc_assert (strcmp (attribute_tables[i][j].name,\n+\t\t\t      attribute_tables[i][k].name));\n     }\n   /* Check that no name occurs in more than one table.  */\n   for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n@@ -117,9 +116,8 @@ init_attributes (void)\n       for (j = i + 1; j < ARRAY_SIZE (attribute_tables); j++)\n \tfor (k = 0; attribute_tables[i][k].name != NULL; k++)\n \t  for (l = 0; attribute_tables[j][l].name != NULL; l++)\n-\t    if (!strcmp (attribute_tables[i][k].name,\n-\t\t\t attribute_tables[j][l].name))\n-\t      abort ();\n+\t    gcc_assert (strcmp (attribute_tables[i][k].name,\n+\t\t\t\tattribute_tables[j][l].name));\n     }\n #endif\n \n@@ -327,10 +325,11 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t  fn_ptr_tmp = build_pointer_type (fn_ptr_tmp);\n \t  if (DECL_P (*node))\n \t    TREE_TYPE (*node) = fn_ptr_tmp;\n-\t  else if (TREE_CODE (*node) == POINTER_TYPE)\n-\t    *node = fn_ptr_tmp;\n \t  else\n-\t    abort ();\n+\t    {\n+\t      gcc_assert (TREE_CODE (*node) == POINTER_TYPE);\n+\t      *node = fn_ptr_tmp;\n+\t    }\n \t}\n     }\n "}, {"sha": "9a52e6ca5900d23f26ba2d6c3b53d5de747764b8", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -137,8 +137,7 @@ static bbro_basic_block_data *bbd;\n #define GET_ARRAY_SIZE(X) ((((X) / 4) + 1) * 5)\n \n /* Free the memory and set the pointer to NULL.  */\n-#define FREE(P) \\\n-  do { if (P) { free (P); P = 0; } else { abort (); } } while (0)\n+#define FREE(P) (gcc_assert (P), free (P), P = 0)\n \n /* Structure for holding information about a trace.  */\n struct trace\n@@ -501,10 +500,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t  /* Select the successor that will be placed after BB.  */\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n-#ifdef ENABLE_CHECKING\n-\t      if (e->flags & EDGE_FAKE)\n-\t\tabort ();\n-#endif\n+\t      gcc_assert (!(e->flags & EDGE_FAKE));\n \n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n@@ -760,10 +756,9 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n   new_bb = duplicate_block (old_bb, e);\n   BB_COPY_PARTITION (new_bb, old_bb);\n \n-  if (e->dest != new_bb)\n-    abort ();\n-  if (e->dest->rbi->visited)\n-    abort ();\n+  gcc_assert (e->dest == new_bb);\n+  gcc_assert (!e->dest->rbi->visited);\n+\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Duplicated bb %d (created bb %d)\\n\",\n@@ -1345,9 +1340,7 @@ mark_bb_for_unlikely_executed_section (basic_block bb)\n     \n   /* If basic block does not contain a NOTE_INSN_BASIC_BLOCK, there is\n      a major problem.  */\n-\n-  if (!insert_insn)\n-    abort ();\n+  gcc_assert (insert_insn);\n \n   /* Insert note and assign basic block number to it.  */\n   \n@@ -1391,28 +1384,19 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n  \t\t    /* bb just falls through.  */\n  \t\t    {\n  \t\t      /* make sure there's only one successor */\n- \t\t      if (src->succ && (src->succ->succ_next == NULL))\n- \t\t\t{\n- \t\t\t  /* Find label in dest block.  */\n-\t\t\t  label = block_label (dest);\n-\n-\t\t\t  new_jump = emit_jump_insn_after (gen_jump (label), \n-\t\t\t\t\t\t\t   BB_END (src));\n-\t\t\t  barrier = emit_barrier_after (new_jump);\n-\t\t\t  JUMP_LABEL (new_jump) = label;\n-\t\t\t  LABEL_NUSES (label) += 1;\n-\t\t\t  src->rbi->footer = unlink_insn_chain (barrier,\n-\t\t\t\t\t\t\t\tbarrier);\n-\t\t\t  /* Mark edge as non-fallthru.  */\n-\t\t\t  crossing_edges[i]->flags &= ~EDGE_FALLTHRU;\n-\t\t\t}\n- \t\t      else\n- \t\t\t{ \n- \t\t\t  /* Basic block has two successors, but\n- \t\t\t     doesn't end in a jump; something is wrong\n- \t\t\t     here!  */\n- \t\t\t  abort();\n- \t\t\t}\n+\t\t      gcc_assert (src->succ && !src->succ->succ_next);\n+\t\t      \n+\t\t      /* Find label in dest block.  */\n+\t\t      label = block_label (dest);\n+\t\t      \n+\t\t      new_jump = emit_jump_insn_after (gen_jump (label), \n+\t\t\t\t\t\t       BB_END (src));\n+\t\t      barrier = emit_barrier_after (new_jump);\n+\t\t      JUMP_LABEL (new_jump) = label;\n+\t\t      LABEL_NUSES (label) += 1;\n+\t\t      src->rbi->footer = unlink_insn_chain (barrier, barrier);\n+\t\t      /* Mark edge as non-fallthru.  */\n+\t\t      crossing_edges[i]->flags &= ~EDGE_FALLTHRU;\n  \t\t    } /* end: 'if (GET_CODE ... '  */\n  \t\t} /* end: 'if (src && src->index...'  */\n   \t    } /* end: 'if (dest && dest->index...'  */\n@@ -1722,12 +1706,13 @@ fix_crossing_conditional_branches (void)\n \t\t\t\t\t\t       (old_label), \n \t\t\t\t\t\t       BB_END (new_bb));\n \t\t    }\n-\t\t  else if (HAVE_return\n-\t\t\t   && GET_CODE (old_label) == RETURN)\n-\t\t    new_jump = emit_jump_insn_after (gen_return (), \n-\t\t\t\t\t\t     BB_END (new_bb));\n \t\t  else\n-\t\t    abort ();\n+\t\t    {\n+\t\t      gcc_assert (HAVE_return\n+\t\t\t\t  && GET_CODE (old_label) == RETURN);\n+\t\t      new_jump = emit_jump_insn_after (gen_return (), \n+\t\t\t\t\t\t       BB_END (new_bb));\n+\t\t    }\n \t\t  \n \t\t  barrier = emit_barrier_after (new_jump);\n \t\t  JUMP_LABEL (new_jump) = old_label;\n@@ -1794,13 +1779,12 @@ fix_crossing_unconditional_branches (void)\n \t{\n \t  rtx label2, table;\n \n-\t  if (any_condjump_p (last_insn))\n-\t    abort ();\n+\t  gcc_assert (!any_condjump_p (last_insn));\n \n \t  /* Make sure the jump is not already an indirect or table jump.  */\n \n-\t  else if (!computed_jump_p (last_insn)\n-\t\t   && !tablejump_p (last_insn, &label2, &table))\n+\t  if (!computed_jump_p (last_insn)\n+\t      && !tablejump_p (last_insn, &label2, &table))\n \t    {\n \t      /* We have found a \"crossing\" unconditional branch.  Now\n \t\t we must convert it to an indirect jump.  First create"}, {"sha": "fada1729b12cbb5c025a189bf08353dc4285a5a4", "filename": "gcc/bitmap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -415,7 +415,7 @@ bitmap_first_set_bit (bitmap a)\n   for (word_num = 0; word_num < BITMAP_ELEMENT_WORDS; ++word_num)\n     if ((word = ptr->bits[word_num]) != 0)\n       goto word_found;\n-  abort ();\n+  gcc_unreachable ();\n  word_found:\n #endif\n \n@@ -472,7 +472,7 @@ bitmap_last_set_bit (bitmap a)\n   for (word_num = BITMAP_ELEMENT_WORDS; word_num-- > 0; )\n     if ((word = ptr->bits[word_num]) != 0)\n       goto word_found;\n-  abort ();\n+  gcc_unreachable ();\n  word_found:\n #endif\n \n@@ -608,7 +608,7 @@ bitmap_operation (bitmap to, bitmap from1, bitmap from2,\n       switch (operation)\n \t{\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tcase BITMAP_AND:\n \t  DOIT (&);"}, {"sha": "bbd6abd663fa0f92a983ca8dabe0b6c8cc4a858e", "filename": "gcc/bt-load.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -237,8 +237,8 @@ insn_sets_btr_p (rtx insn, int check_const, int *regno)\n       if (REG_P (dest)\n \t  && TEST_HARD_REG_BIT (all_btrs, REGNO (dest)))\n \t{\n-\t  if (btr_referenced_p (src, NULL))\n-\t    abort();\n+\t  gcc_assert (!btr_referenced_p (src, NULL));\n+\t  \n \t  if (!check_const || CONSTANT_P (src))\n \t    {\n \t      if (regno)\n@@ -875,11 +875,13 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n \n   if (dominated_by_p (CDI_DOMINATORS, new_bb, head_bb))\n     *tos++ = new_bb;\n-  else if (dominated_by_p (CDI_DOMINATORS, head_bb, new_bb))\n+  else\n     {\n       edge e;\n       int new_block = new_bb->index;\n \n+      gcc_assert (dominated_by_p (CDI_DOMINATORS, head_bb, new_bb));\n+  \n       bitmap_set_bit (live_range, new_block);\n       if (flag_btr_bb_exclusive)\n \tIOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[new_block]);\n@@ -900,8 +902,6 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n       for (e = head_bb->pred; e; e = e->pred_next)\n \t*tos++ = e->src;\n     }\n-  else\n-    abort();\n \n   while (tos != worklist)\n     {\n@@ -1146,8 +1146,8 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n     {\n       insp = BB_END (b);\n       for (insp = BB_END (b); ! INSN_P (insp); insp = PREV_INSN (insp))\n-\tif (insp == BB_HEAD (b))\n-\t  abort ();\n+\tgcc_assert (insp != BB_HEAD (b));\n+      \n       if (JUMP_P (insp) || can_throw_internal (insp))\n \tinsp = PREV_INSN (insp);\n     }"}, {"sha": "2e019d3bfbf12f3d10c915d6d3a72d893abeb597", "filename": "gcc/builtins.c", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298e6adcf212620192ae9b66c27b4eae64916e7b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=298e6adcf212620192ae9b66c27b4eae64916e7b", "patch": "@@ -376,8 +376,8 @@ c_readstr (const char *str, enum machine_mode mode)\n   HOST_WIDE_INT ch;\n   unsigned int i, j;\n \n-  if (GET_MODE_CLASS (mode) != MODE_INT)\n-    abort ();\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);\n+  \n   c[0] = 0;\n   c[1] = 0;\n   ch = 1;\n@@ -390,8 +390,8 @@ c_readstr (const char *str, enum machine_mode mode)\n \t  && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \tj = j + UNITS_PER_WORD - 2 * (j % UNITS_PER_WORD) - 1;\n       j *= BITS_PER_UNIT;\n-      if (j > 2 * HOST_BITS_PER_WIDE_INT)\n-\tabort ();\n+      gcc_assert (j <= 2 * HOST_BITS_PER_WIDE_INT);\n+      \n       if (ch)\n \tch = (unsigned char) str[i];\n       c[j / HOST_BITS_PER_WIDE_INT] |= ch << (j % HOST_BITS_PER_WIDE_INT);\n@@ -700,8 +700,7 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n      a second argument of 1, because that is what builtin_setjmp will\n      return.  This also makes EH slightly more efficient, since we are no\n      longer copying around a value that we don't care about.  */\n-  if (value != const1_rtx)\n-    abort ();\n+  gcc_assert (value == const1_rtx);\n \n   current_function_calls_longjmp = 1;\n \n@@ -758,8 +757,8 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n      internal exception handling use only.  */\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n     {\n-      if (insn == last)\n-\tabort ();\n+      gcc_assert (insn != last);\n+      \n       if (JUMP_P (insn))\n \t{\n \t  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO, const0_rtx,\n@@ -1048,8 +1047,7 @@ apply_args_size (void)\n \t  {\n \t    mode = reg_raw_mode[regno];\n \n-\t    if (mode == VOIDmode)\n-\t      abort ();\n+\t    gcc_assert (mode != VOIDmode);\n \n \t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n \t    if (size % align != 0)\n@@ -1087,8 +1085,7 @@ apply_result_size (void)\n \t  {\n \t    mode = reg_raw_mode[regno];\n \n-\t    if (mode == VOIDmode)\n-\t      abort ();\n+\t    gcc_assert (mode != VOIDmode);\n \n \t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n \t    if (size % align != 0)\n@@ -1360,8 +1357,8 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif ((mode = apply_result_mode[regno]) != VOIDmode)\n \t  {\n-\t    if (valreg)\n-\t      abort (); /* HAVE_untyped_call required.  */\n+\t    gcc_assert (!valreg); /* HAVE_untyped_call required.  */\n+\t    \n \t    valreg = gen_rtx_REG (mode, regno);\n \t  }\n \n@@ -1373,7 +1370,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n     }\n   else\n #endif\n-    abort ();\n+    gcc_unreachable ();\n \n   /* Find the CALL insn we just emitted, and attach the register usage\n      information.  */\n@@ -1742,7 +1739,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n     case BUILT_IN_NEARBYINTL:\n       builtin_optab = nearbyint_optab; break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Make a suitable register to place result in.  */\n@@ -1882,7 +1879,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n     case BUILT_IN_DREML:\n       builtin_optab = drem_optab; break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Make a suitable register to place result in.  */\n@@ -1982,7 +1979,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n     case BUILT_IN_COSL:\n       builtin_optab = sincos_optab; break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Make a suitable register to place result in.  */\n@@ -2005,7 +2002,7 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n       case BUILT_IN_COSL:\n \tbuiltin_optab = cos_optab; break;\n       default:\n-\tabort();\n+\tgcc_unreachable ();\n       }\n   }\n \n@@ -2032,23 +2029,24 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n \t Set TARGET to wherever the result comes back.  */\n       if (builtin_optab == sincos_optab)\n \t{\n+\t  int result;\n+\t  \n \t  switch (DECL_FUNCTION_CODE (fndecl))\n \t    {\n \t    case BUILT_IN_SIN:\n \t    case BUILT_IN_SINF:\n \t    case BUILT_IN_SINL:\n-\t      if (!expand_twoval_unop (builtin_optab, op0, 0, target, 0))\n-\t\tabort();\n+\t      result = expand_twoval_unop (builtin_optab, op0, 0, target, 0);\n \t      break;\n \t    case BUILT_IN_COS:\n \t    case BUILT_IN_COSF:\n \t    case BUILT_IN_COSL:\n-\t      if (!expand_twoval_unop (builtin_optab, op0, target, 0, 0))\n-\t\tabort();\n+\t      result = expand_twoval_unop (builtin_optab, op0, target, 0, 0);\n \t      break;\n \t    default:\n-\t      abort();\n+\t      gcc_unreachable ();\n \t    }\n+\t  gcc_assert (result);\n \t}\n       else\n \t{\n@@ -2665,10 +2663,9 @@ builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n {\n   const char *str = (const char *) data;\n \n-  if (offset < 0\n-      || ((unsigned HOST_WIDE_INT) offset + GET_MODE_SIZE (mode)\n-\t  > strlen (str) + 1))\n-    abort ();  /* Attempt to read past the end of constant string.  */\n+  gcc_assert (offset >= 0\n+\t      && ((unsigned HOST_WIDE_INT) offset + GET_MODE_SIZE (mode)\n+\t\t  <= strlen (str) + 1));\n \n   return c_readstr (str + offset, mode);\n }\n@@ -3015,8 +3012,7 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n \n   insn = data->genfun (end, dest_mem, src_mem);\n \n-  if (insn == 0)\n-    abort ();\n+  gcc_assert (insn);\n \n   emit_insn (insn);\n \n@@ -3138,8 +3134,7 @@ expand_builtin_stpcpy (tree arglist, rtx target, enum machine_mode mode)\n \t\t  ret = emit_move_insn (target,\n \t\t\t\t\tplus_constant (ret,\n \t\t\t\t\t\t       INTVAL (len_rtx)));\n-\t\t  if (! ret)\n-\t\t    abort ();\n+\t\t  gcc_assert (ret);\n \n \t\t  return target;\n \t\t}\n@@ -3532,7 +3527,7 @@ expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n \t\t\t   GEN_INT (MIN (arg1_align, arg2_align)));\n     else\n #endif\n-      abort ();\n+      gcc_unreachable ();\n \n     if (insn)\n       emit_insn (insn);\n@@ -4125,8 +4120,7 @@ expand_builtin_args_info (tree arglist)\n   int nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n   int *word_ptr = (int *) &current_function_args_info;\n \n-  if (sizeof (CUMULATIVE_ARGS) % sizeof (int) != 0)\n-    abort ();\n+  gcc_assert (sizeof (CUMULATIVE_ARGS) % sizeof (int) == 0);\n \n   if (arglist != 0)\n     {\n@@ -4296,7 +4290,7 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n   /* All of the alignment and movement below is for args-grow-up machines.\n      As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n      implement their own specialized gimplify_va_arg_expr routines.  */\n-  abort ();\n+  gcc_unreachable ();\n #endif\n \n   indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n@@ -4625,9 +4619,8 @@ expand_builtin_unop (enum machine_mode target_mode, tree arglist, rtx target,\n      Set TARGET to wherever the result comes back.  */\n   target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n \t\t\top_optab, op0, target, 1);\n-  if (target == 0)\n-    abort ();\n-\n+  gcc_assert (target);\n+  \n   return convert_to_mode (target_mode, target, 0);\n }\n \n@@ -4704,7 +4697,7 @@ expand_builtin_fputs (tree arglist, rtx target, bool unlocked)\n \tbreak;\n       }\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return expand_expr (build_function_call_expr (fn, arglist),\n@@ -5242,10 +5235,8 @@ expand_builtin_profile_func (bool exitp)\n   rtx this, which;\n \n   this = DECL_RTL (current_function_decl);\n-  if (MEM_P (this))\n-    this = XEXP (this, 0);\n-  else\n-    abort ();\n+  gcc_assert (MEM_P (this));\n+  this = XEXP (this, 0);\n \n   if (exitp)\n     which = profile_function_exit_libfunc;\n@@ -5480,7 +5471,7 @@ expand_builtin_fork_or_exec (tree fn, tree arglist, rtx target, int ignore)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   decl = build_decl (FUNCTION_DECL, id, TREE_TYPE (fn));\n@@ -6813,7 +6804,7 @@ fold_builtin_bitop (tree exp)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n \n       return build_int_cst (TREE_TYPE (exp), result);\n@@ -7740,7 +7731,7 @@ fold_builtin_classify (tree exp, int builtin_index)\n       return fold (build2 (UNORDERED_EXPR, type, arg, arg));\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -9158,7 +9149,7 @@ fold_builtin_fputs (tree arglist, bool ignore, bool unlocked, tree len)\n \tbreak;\n       }\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* These optimizations are only performed when the result is ignored,"}]}