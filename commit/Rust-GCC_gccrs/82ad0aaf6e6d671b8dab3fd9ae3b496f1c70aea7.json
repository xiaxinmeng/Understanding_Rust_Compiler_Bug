{"sha": "82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJhZDBhYWY2ZTZkNjcxYjhkYWIzZmQ5YWUzYjQ5NmYxYzcwYWVhNw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2012-08-09T13:18:05Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2012-08-09T13:18:05Z"}, "message": "reload.c (find_valid_class_1): New static function.\n\n\t* reload.c (find_valid_class_1): New static function.\n\t(push_reload): Use it when reloading a SYMBOL_REG as the inner\n\tof a subreg.  Keep better track of needed classes for the\n\tsecondary memory case.\n\t* config/i386/i386.h (LIMIT_RELOAD_CLASS): Limit INT_SSE_REGS to\n\tGENERAL_REGS.\n\t* reload1.c (replaced_subreg): New static function.\n\t(gen_reload): Use it when deciding whether to use secondary\n\tmemory.\n\n\t* gcc.c-torture/compile/20120727-1.c: New test.\n\nFrom-SVN: r190252", "tree": {"sha": "dc0e08837a77bf368d263bcde301c676189919de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0e08837a77bf368d263bcde301c676189919de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/comments", "author": null, "committer": null, "parents": [{"sha": "62d6a5bbc851e99b69cf6899e02ac46e66a3b50c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d6a5bbc851e99b69cf6899e02ac46e66a3b50c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d6a5bbc851e99b69cf6899e02ac46e66a3b50c"}], "stats": {"total": 131, "additions": 112, "deletions": 19}, "files": [{"sha": "2a00c31eb00dc56abd2bd9929cad86c5052cadb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "patch": "@@ -1,3 +1,15 @@\n+2012-08-09  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* reload.c (find_valid_class_1): New static function.\n+\t(push_reload): Use it when reloading a SYMBOL_REG as the inner\n+\tof a subreg.  Keep better track of needed classes for the\n+\tsecondary memory case.\n+\t* config/i386/i386.h (LIMIT_RELOAD_CLASS): Limit INT_SSE_REGS to\n+\tGENERAL_REGS.\n+\t* reload1.c (replaced_subreg): New static function.\n+\t(gen_reload): Use it when deciding whether to use secondary\n+\tmemory.\n+\n 2012-08-09  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.h (SSA_VAR_P): Simplify."}, {"sha": "de7b82a57e7b78560cea009b3b2b9c427b18178f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "patch": "@@ -1384,7 +1384,8 @@ enum reg_class\n   ((MODE) == QImode && !TARGET_64BIT\t\t\t\t\\\n    && ((CLASS) == ALL_REGS || (CLASS) == GENERAL_REGS\t\t\\\n        || (CLASS) == LEGACY_REGS || (CLASS) == INDEX_REGS)\t\\\n-   ? Q_REGS : (CLASS))\n+   ? Q_REGS\t\t\t\t\t\t\t\\\n+   : (CLASS) == INT_SSE_REGS ? GENERAL_REGS : (CLASS))\n \n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.  */"}, {"sha": "201f4759ad5f5868c83579526ac7041661f9d447", "filename": "gcc/reload.c", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "patch": "@@ -707,6 +707,55 @@ find_valid_class (enum machine_mode outer ATTRIBUTE_UNUSED,\n \n   return best_class;\n }\n+\n+/* We are trying to reload a subreg of something that is not a register.\n+   Find the largest class which has at least one register valid in\n+   mode MODE.  OUTER is the mode of the subreg, DEST_CLASS the class in\n+   which we would eventually like to obtain the object.  */\n+\n+static enum reg_class\n+find_valid_class_1 (enum machine_mode outer ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    enum reg_class dest_class ATTRIBUTE_UNUSED)\n+{\n+  int best_cost = -1;\n+  int rclass;\n+  int regno;\n+  enum reg_class best_class = NO_REGS;\n+  unsigned int best_size = 0;\n+  int cost;\n+\n+  for (rclass = 1; rclass < N_REG_CLASSES; rclass++)\n+    {\n+      int bad = 0;\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER && !bad; regno++)\n+\tif (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno)\n+\t    && !HARD_REGNO_MODE_OK (regno, mode))\n+\t  bad = 1;\n+\n+      if (bad)\n+\tcontinue;\n+\n+      cost = register_move_cost (outer, (enum reg_class) rclass, dest_class);\n+\n+      if ((reg_class_size[rclass] > best_size\n+\t   && (best_cost < 0 || best_cost >= cost))\n+\t  || best_cost > cost)\n+\t{\n+\t  best_class = (enum reg_class) rclass;\n+\t  best_size = reg_class_size[rclass];\n+\t  best_cost = register_move_cost (outer, (enum reg_class) rclass,\n+\t\t\t\t\t  dest_class);\n+\t}\n+    }\n+\n+  gcc_assert (best_size != 0);\n+\n+#ifdef LIMIT_RELOAD_CLASS\n+  best_class = LIMIT_RELOAD_CLASS (mode, best_class);\n+#endif\n+  return best_class;\n+}\n \f\n /* Return the number of a previously made reload that can be combined with\n    a new one, or n_reloads if none of the existing reloads can be used.\n@@ -925,6 +974,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   int secondary_in_reload = -1, secondary_out_reload = -1;\n   enum insn_code secondary_in_icode = CODE_FOR_nothing;\n   enum insn_code secondary_out_icode = CODE_FOR_nothing;\n+  enum reg_class subreg_in_class ATTRIBUTE_UNUSED;\n+  subreg_in_class = NO_REGS;\n \n   /* INMODE and/or OUTMODE could be VOIDmode if no mode\n      has been specified for the operand.  In that case,\n@@ -1091,24 +1142,26 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n   if (in != 0 && reload_inner_reg_of_subreg (in, inmode, false))\n     {\n-      enum reg_class in_class = rclass;\n-\n       if (REG_P (SUBREG_REG (in)))\n-\tin_class\n+\tsubreg_in_class\n \t  = find_valid_class (inmode, GET_MODE (SUBREG_REG (in)),\n \t\t\t      subreg_regno_offset (REGNO (SUBREG_REG (in)),\n \t\t\t\t\t\t   GET_MODE (SUBREG_REG (in)),\n \t\t\t\t\t\t   SUBREG_BYTE (in),\n \t\t\t\t\t\t   GET_MODE (in)),\n \t\t\t      REGNO (SUBREG_REG (in)));\n+      else if (GET_CODE (SUBREG_REG (in)) == SYMBOL_REF)\n+\tsubreg_in_class = find_valid_class_1 (inmode,\n+\t\t\t\t\t      GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t      rclass);\n \n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for input reloads of type RELOAD_OTHER in the same\n \t order as the reloads.  Thus if the outer reload is also of type\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output before the outer reload.  */\n       push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), (rtx *) 0,\n-\t\t   in_class, VOIDmode, VOIDmode, 0, 0, opnum, type);\n+\t\t   subreg_in_class, VOIDmode, VOIDmode, 0, 0, opnum, type);\n       dont_remove_subreg = 1;\n     }\n \n@@ -1327,13 +1380,15 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t So add an additional reload.  */\n \n #ifdef SECONDARY_MEMORY_NEEDED\n-      /* If a memory location is needed for the copy, make one.  */\n-      if (in != 0\n+      if (subreg_in_class == NO_REGS\n+\t  && in != 0\n \t  && (REG_P (in)\n \t      || (GET_CODE (in) == SUBREG && REG_P (SUBREG_REG (in))))\n-\t  && reg_or_subregno (in) < FIRST_PSEUDO_REGISTER\n-\t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (reg_or_subregno (in)),\n-\t\t\t\t      rclass, inmode))\n+\t  && reg_or_subregno (in) < FIRST_PSEUDO_REGISTER)\n+\tsubreg_in_class = REGNO_REG_CLASS (reg_or_subregno (in));\n+      /* If a memory location is needed for the copy, make one.  */\n+      if (subreg_in_class != NO_REGS\n+\t  && SECONDARY_MEMORY_NEEDED (subreg_in_class, rclass, inmode))\n \tget_secondary_mem (in, inmode, opnum, type);\n #endif\n "}, {"sha": "bf5d3d3bb083e3f42f0e2af21103f92fbf3bf6b4", "filename": "gcc/reload1.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "patch": "@@ -8469,6 +8469,18 @@ emit_insn_if_valid_for_reload (rtx insn)\n   return NULL;\n }\n \n+/* If X is not a subreg, return it unmodified.  If it is a subreg,\n+   look up whether we made a replacement for the SUBREG_REG.  Return\n+   either the replacement or the SUBREG_REG.  */\n+\n+static rtx\n+replaced_subreg (rtx x)\n+{\n+  if (GET_CODE (x) == SUBREG)\n+    return find_replacement (&SUBREG_REG (x));\n+  return x;\n+}\n+\n /* Emit code to perform a reload from IN (which may be a reload register) to\n    OUT (which may also be a reload register).  IN or OUT is from operand\n    OPNUM with reload type TYPE.\n@@ -8479,7 +8491,7 @@ static rtx\n gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n {\n   rtx last = get_last_insn ();\n-  rtx tem;\n+  rtx tem, tem1, tem2;\n \n   /* If IN is a paradoxical SUBREG, remove it and try to put the\n      opposite SUBREG on OUT.  Likewise for a paradoxical SUBREG on OUT.  */\n@@ -8616,14 +8628,12 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n \n #ifdef SECONDARY_MEMORY_NEEDED\n   /* If we need a memory location to do the move, do it that way.  */\n-  else if ((REG_P (in)\n-            || (GET_CODE (in) == SUBREG && REG_P (SUBREG_REG (in))))\n-\t   && reg_or_subregno (in) < FIRST_PSEUDO_REGISTER\n-\t   && (REG_P (out)\n-\t       || (GET_CODE (out) == SUBREG && REG_P (SUBREG_REG (out))))\n-\t   && reg_or_subregno (out) < FIRST_PSEUDO_REGISTER\n-\t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (reg_or_subregno (in)),\n-\t\t\t\t       REGNO_REG_CLASS (reg_or_subregno (out)),\n+  else if ((tem1 = replaced_subreg (in), tem2 = replaced_subreg (out),\n+\t    (REG_P (tem1) && REG_P (tem2)))\n+\t   && REGNO (tem1) < FIRST_PSEUDO_REGISTER\n+\t   && REGNO (tem2) < FIRST_PSEUDO_REGISTER\n+\t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (tem1)),\n+\t\t\t\t       REGNO_REG_CLASS (REGNO (tem2)),\n \t\t\t\t       GET_MODE (out)))\n     {\n       /* Get the memory to use and rewrite both registers to its mode.  */"}, {"sha": "7dcf7d760edc0954aa62012057d2db38c6c15411", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "patch": "@@ -1,3 +1,7 @@\n+2012-08-09  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* gcc.c-torture/compile/20120727-1.c: New test.\n+\n 2012-08-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/54199"}, {"sha": "d43472fa10f05251148b4c0eb15a258e4c45c6a8", "filename": "gcc/testsuite/gcc.c-torture/compile/20120727-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20120727-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20120727-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20120727-1.c?ref=82ad0aaf6e6d671b8dab3fd9ae3b496f1c70aea7", "patch": "@@ -0,0 +1,11 @@\n+union {\n+  char *p;\n+  float f;\n+} u;\n+\n+void\n+f (void)\n+{\n+  u.p = \"\";\n+  u.f += 1.1;\n+}"}]}