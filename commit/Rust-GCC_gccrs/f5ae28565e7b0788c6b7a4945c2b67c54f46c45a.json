{"sha": "f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVhZTI4NTY1ZTdiMDc4OGM2YjdhNDk0NWMyYjY3YzU0ZjQ2YzQ1YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:26:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:26:14Z"}, "message": "[40/46] Add vec_info::lookup_dr\n\nThis patch replaces DR_VECT_AUX and vect_dr_stmt with a new\nvec_info::lookup_dr function, so that the lookup is relative\nto a particular vec_info rather than to global state.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vec_info::lookup_dr): New member function.\n\t(vect_dr_stmt): Delete.\n\t* tree-vectorizer.c (vec_info::lookup_dr): New function.\n\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): Use it instead\n\tof DR_VECT_AUX.\n\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr)\n\t(vect_analyze_data_ref_dependence, vect_record_base_alignments)\n\t(vect_verify_datarefs_alignment, vect_peeling_supportable)\n\t(vect_analyze_data_ref_accesses, vect_prune_runtime_alias_test_list)\n\t(vect_analyze_data_refs): Likewise.\n\t(vect_slp_analyze_data_ref_dependence): Likewise.  Take a vec_info\n\targument.\n\t(vect_find_same_alignment_drs): Likewise.\n\t(vect_slp_analyze_node_dependences): Update calls accordingly.\n\t(vect_analyze_data_refs_alignment): Likewise.  Use vec_info::lookup_dr\n\tinstead of DR_VECT_AUX.\n\t(vect_get_peeling_costs_all_drs): Take a loop_vec_info instead\n\tof a vector data references.  Use vec_info::lookup_dr instead of\n\tDR_VECT_AUX.\n\t(vect_peeling_hash_get_lowest_cost): Update calls accordingly.\n\t(vect_enhance_data_refs_alignment): Likewise.  Use vec_info::lookup_dr\n\tinstead of DR_VECT_AUX.\n\nFrom-SVN: r263155", "tree": {"sha": "c29ad4a40e234aea9c03035c3645b2b51040eca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c29ad4a40e234aea9c03035c3645b2b51040eca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e5e6ff5e63127a7a6ae4ee64d08a22a41a021c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5e6ff5e63127a7a6ae4ee64d08a22a41a021c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e5e6ff5e63127a7a6ae4ee64d08a22a41a021c4"}], "stats": {"total": 145, "additions": 84, "deletions": 61}, "files": [{"sha": "d17ac3b22de175cdcba529d12579ce6a2467fcf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "patch": "@@ -1,3 +1,28 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vec_info::lookup_dr): New member function.\n+\t(vect_dr_stmt): Delete.\n+\t* tree-vectorizer.c (vec_info::lookup_dr): New function.\n+\t* tree-vect-loop-manip.c (vect_update_inits_of_drs): Use it instead\n+\tof DR_VECT_AUX.\n+\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr)\n+\t(vect_analyze_data_ref_dependence, vect_record_base_alignments)\n+\t(vect_verify_datarefs_alignment, vect_peeling_supportable)\n+\t(vect_analyze_data_ref_accesses, vect_prune_runtime_alias_test_list)\n+\t(vect_analyze_data_refs): Likewise.\n+\t(vect_slp_analyze_data_ref_dependence): Likewise.  Take a vec_info\n+\targument.\n+\t(vect_find_same_alignment_drs): Likewise.\n+\t(vect_slp_analyze_node_dependences): Update calls accordingly.\n+\t(vect_analyze_data_refs_alignment): Likewise.  Use vec_info::lookup_dr\n+\tinstead of DR_VECT_AUX.\n+\t(vect_get_peeling_costs_all_drs): Take a loop_vec_info instead\n+\tof a vector data references.  Use vec_info::lookup_dr instead of\n+\tDR_VECT_AUX.\n+\t(vect_peeling_hash_get_lowest_cost): Update calls accordingly.\n+\t(vect_enhance_data_refs_alignment): Likewise.  Use vec_info::lookup_dr\n+\tinstead of DR_VECT_AUX.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (_loop_vec_info::unaligned_dr): Change to"}, {"sha": "2158bf4e2f63dc272f552369f566dc9931d2772e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "patch": "@@ -269,10 +269,10 @@ vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \n \t     Note that the alias checks will be removed if the VF ends up\n \t     being small enough.  */\n-\t  return (!STMT_VINFO_GATHER_SCATTER_P\n-\t\t     (vinfo_for_stmt (DR_STMT (DDR_A (ddr))))\n-\t\t  && !STMT_VINFO_GATHER_SCATTER_P\n-\t\t        (vinfo_for_stmt (DR_STMT (DDR_B (ddr))))\n+\t  dr_vec_info *dr_info_a = loop_vinfo->lookup_dr (DDR_A (ddr));\n+\t  dr_vec_info *dr_info_b = loop_vinfo->lookup_dr (DDR_B (ddr));\n+\t  return (!STMT_VINFO_GATHER_SCATTER_P (dr_info_a->stmt)\n+\t\t  && !STMT_VINFO_GATHER_SCATTER_P (dr_info_b->stmt)\n \t\t  && vect_mark_for_runtime_alias_test (ddr, loop_vinfo));\n \t}\n     }\n@@ -296,8 +296,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n-  dr_vec_info *dr_info_a = DR_VECT_AUX (dra);\n-  dr_vec_info *dr_info_b = DR_VECT_AUX (drb);\n+  dr_vec_info *dr_info_a = loop_vinfo->lookup_dr (dra);\n+  dr_vec_info *dr_info_b = loop_vinfo->lookup_dr (drb);\n   stmt_vec_info stmtinfo_a = dr_info_a->stmt;\n   stmt_vec_info stmtinfo_b = dr_info_b->stmt;\n   lambda_vector dist_v;\n@@ -604,17 +604,18 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n /* Function vect_slp_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n-   DRA and a memory-reference DRB.  When versioning for alias may check a\n-   dependence at run-time, return FALSE.  Adjust *MAX_VF according to\n-   the data dependence.  */\n+   DRA and a memory-reference DRB for VINFO.  When versioning for alias\n+   may check a dependence at run-time, return FALSE.  Adjust *MAX_VF\n+   according to the data dependence.  */\n \n static bool\n-vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n+vect_slp_analyze_data_ref_dependence (vec_info *vinfo,\n+\t\t\t\t      struct data_dependence_relation *ddr)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n-  dr_vec_info *dr_info_a = DR_VECT_AUX (dra);\n-  dr_vec_info *dr_info_b = DR_VECT_AUX (drb);\n+  dr_vec_info *dr_info_a = vinfo->lookup_dr (dra);\n+  dr_vec_info *dr_info_b = vinfo->lookup_dr (drb);\n \n   /* We need to check dependences of statements marked as unvectorizable\n      as well, they still can prohibit vectorization.  */\n@@ -726,7 +727,8 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \t\t  data_reference *store_dr = STMT_VINFO_DATA_REF (store_info);\n \t\t  ddr_p ddr = initialize_data_dependence_relation\n \t\t\t\t(dr_a, store_dr, vNULL);\n-\t\t  dependent = vect_slp_analyze_data_ref_dependence (ddr);\n+\t\t  dependent\n+\t\t    = vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n \t\t  free_dependence_relation (ddr);\n \t\t  if (dependent)\n \t\t    break;\n@@ -736,7 +738,7 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \t    {\n \t      ddr_p ddr = initialize_data_dependence_relation (dr_a,\n \t\t\t\t\t\t\t       dr_b, vNULL);\n-\t      dependent = vect_slp_analyze_data_ref_dependence (ddr);\n+\t      dependent = vect_slp_analyze_data_ref_dependence (vinfo, ddr);\n \t      free_dependence_relation (ddr);\n \t    }\n \t  if (dependent)\n@@ -848,7 +850,7 @@ vect_record_base_alignments (vec_info *vinfo)\n   unsigned int i;\n   FOR_EACH_VEC_ELT (vinfo->shared->datarefs, i, dr)\n     {\n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = vinfo->lookup_dr (dr);\n       stmt_vec_info stmt_info = dr_info->stmt;\n       if (!DR_IS_CONDITIONAL_IN_STMT (dr)\n \t  && STMT_VINFO_VECTORIZABLE (stmt_info)\n@@ -1172,7 +1174,7 @@ vect_verify_datarefs_alignment (loop_vec_info vinfo)\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = vinfo->lookup_dr (dr);\n       stmt_vec_info stmt_info = dr_info->stmt;\n \n       if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1397,12 +1399,12 @@ vect_peeling_hash_get_most_frequent (_vect_peel_info **slot,\n   return 1;\n }\n \n-/* Get the costs of peeling NPEEL iterations checking data access costs\n-   for all data refs.  If UNKNOWN_MISALIGNMENT is true, we assume DR0_INFO's\n-   misalignment will be zero after peeling.  */\n+/* Get the costs of peeling NPEEL iterations for LOOP_VINFO, checking\n+   data access costs for all data refs.  If UNKNOWN_MISALIGNMENT is true,\n+   we assume DR0_INFO's misalignment will be zero after peeling.  */\n \n static void\n-vect_get_peeling_costs_all_drs (vec<data_reference_p> datarefs,\n+vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n \t\t\t\tdr_vec_info *dr0_info,\n \t\t\t\tunsigned int *inside_cost,\n \t\t\t\tunsigned int *outside_cost,\n@@ -1411,12 +1413,13 @@ vect_get_peeling_costs_all_drs (vec<data_reference_p> datarefs,\n \t\t\t\tunsigned int npeel,\n \t\t\t\tbool unknown_misalignment)\n {\n+  vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   unsigned i;\n   data_reference *dr;\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n       stmt_vec_info stmt_info = dr_info->stmt;\n       if (!STMT_VINFO_RELEVANT_P (stmt_info))\n \tcontinue;\n@@ -1466,10 +1469,9 @@ vect_peeling_hash_get_lowest_cost (_vect_peel_info **slot,\n   body_cost_vec.create (2);\n   epilogue_cost_vec.create (2);\n \n-  vect_get_peeling_costs_all_drs (LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t\t\t\t  elem->dr_info, &inside_cost, &outside_cost,\n-\t\t\t\t  &body_cost_vec, &prologue_cost_vec,\n-\t\t\t\t  elem->npeel, false);\n+  vect_get_peeling_costs_all_drs (loop_vinfo, elem->dr_info, &inside_cost,\n+\t\t\t\t  &outside_cost, &body_cost_vec,\n+\t\t\t\t  &prologue_cost_vec, elem->npeel, false);\n \n   body_cost_vec.release ();\n \n@@ -1550,7 +1552,7 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n       if (dr == dr0_info->dr)\n \tcontinue;\n \n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n       stmt_vec_info stmt_info = dr_info->stmt;\n       /* For interleaving, only the alignment of the first access\n \t matters.  */\n@@ -1732,7 +1734,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n       stmt_vec_info stmt_info = dr_info->stmt;\n \n       if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -1896,7 +1898,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       stmt_vector_for_cost dummy;\n       dummy.create (2);\n-      vect_get_peeling_costs_all_drs (datarefs, dr0_info,\n+      vect_get_peeling_costs_all_drs (loop_vinfo, dr0_info,\n \t\t\t\t      &load_inside_cost,\n \t\t\t\t      &load_outside_cost,\n \t\t\t\t      &dummy, &dummy, estimated_npeels, true);\n@@ -1905,7 +1907,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (first_store)\n \t{\n \t  dummy.create (2);\n-\t  vect_get_peeling_costs_all_drs (datarefs, first_store,\n+\t  vect_get_peeling_costs_all_drs (loop_vinfo, first_store,\n \t\t\t\t\t  &store_inside_cost,\n \t\t\t\t\t  &store_outside_cost,\n \t\t\t\t\t  &dummy, &dummy,\n@@ -1996,7 +1998,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       stmt_vector_for_cost dummy;\n       dummy.create (2);\n-      vect_get_peeling_costs_all_drs (datarefs, NULL, &nopeel_inside_cost,\n+      vect_get_peeling_costs_all_drs (loop_vinfo, NULL, &nopeel_inside_cost,\n \t\t\t\t      &nopeel_outside_cost, &dummy, &dummy,\n \t\t\t\t      0, false);\n       dummy.release ();\n@@ -2126,7 +2128,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      {\n \t\t/* Strided accesses perform only component accesses, alignment\n \t\t   is irrelevant for them.  */\n-\t\tdr_vec_info *dr_info = DR_VECT_AUX (dr);\n+\t\tdr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n \t\tstmt_info = dr_info->stmt;\n \t\tif (STMT_VINFO_STRIDED_P (stmt_info)\n \t\t    && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n@@ -2176,7 +2178,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n     {\n       FOR_EACH_VEC_ELT (datarefs, i, dr)\n         {\n-\t  dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+\t  dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n \t  stmt_vec_info stmt_info = dr_info->stmt;\n \n \t  /* For interleaving, only the alignment of the first access\n@@ -2291,16 +2293,16 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n /* Function vect_find_same_alignment_drs.\n \n-   Update group and alignment relations according to the chosen\n+   Update group and alignment relations in VINFO according to the chosen\n    vectorization factor.  */\n \n static void\n-vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n+vect_find_same_alignment_drs (vec_info *vinfo, data_dependence_relation *ddr)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n-  dr_vec_info *dr_info_a = DR_VECT_AUX (dra);\n-  dr_vec_info *dr_info_b = DR_VECT_AUX (drb);\n+  dr_vec_info *dr_info_a = vinfo->lookup_dr (dra);\n+  dr_vec_info *dr_info_b = vinfo->lookup_dr (drb);\n   stmt_vec_info stmtinfo_a = dr_info_a->stmt;\n   stmt_vec_info stmtinfo_b = dr_info_b->stmt;\n \n@@ -2367,15 +2369,15 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n   unsigned int i;\n \n   FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-    vect_find_same_alignment_drs (ddr);\n+    vect_find_same_alignment_drs (vinfo, ddr);\n \n   vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n   struct data_reference *dr;\n \n   vect_record_base_alignments (vinfo);\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = vinfo->lookup_dr (dr);\n       if (STMT_VINFO_VECTORIZABLE (dr_info->stmt))\n \tvect_compute_data_ref_alignment (dr_info);\n     }\n@@ -2941,7 +2943,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n   for (i = 0; i < datarefs_copy.length () - 1;)\n     {\n       data_reference_p dra = datarefs_copy[i];\n-      dr_vec_info *dr_info_a = DR_VECT_AUX (dra);\n+      dr_vec_info *dr_info_a = vinfo->lookup_dr (dra);\n       stmt_vec_info stmtinfo_a = dr_info_a->stmt;\n       stmt_vec_info lastinfo = NULL;\n       if (!STMT_VINFO_VECTORIZABLE (stmtinfo_a)\n@@ -2953,7 +2955,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n       for (i = i + 1; i < datarefs_copy.length (); ++i)\n \t{\n \t  data_reference_p drb = datarefs_copy[i];\n-\t  dr_vec_info *dr_info_b = DR_VECT_AUX (drb);\n+\t  dr_vec_info *dr_info_b = vinfo->lookup_dr (drb);\n \t  stmt_vec_info stmtinfo_b = dr_info_b->stmt;\n \t  if (!STMT_VINFO_VECTORIZABLE (stmtinfo_b)\n \t      || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n@@ -3078,7 +3080,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \n   FOR_EACH_VEC_ELT (datarefs_copy, i, dr)\n     {\n-      dr_vec_info *dr_info = DR_VECT_AUX (dr);\n+      dr_vec_info *dr_info = vinfo->lookup_dr (dr);\n       if (STMT_VINFO_VECTORIZABLE (dr_info->stmt)\n \t  && !vect_analyze_data_ref_access (dr_info))\n \t{\n@@ -3438,10 +3440,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  continue;\n \t}\n \n-      dr_vec_info *dr_info_a = DR_VECT_AUX (DDR_A (ddr));\n+      dr_vec_info *dr_info_a = loop_vinfo->lookup_dr (DDR_A (ddr));\n       stmt_vec_info stmt_info_a = dr_info_a->stmt;\n \n-      dr_vec_info *dr_info_b = DR_VECT_AUX (DDR_B (ddr));\n+      dr_vec_info *dr_info_b = loop_vinfo->lookup_dr (DDR_B (ddr));\n       stmt_vec_info stmt_info_b = dr_info_b->stmt;\n \n       /* Skip the pair if inter-iteration dependencies are irrelevant"}, {"sha": "504e4e30301be23af038e031de78f59b2aecad44", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "patch": "@@ -1754,8 +1754,8 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters,\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      gimple *stmt = DR_STMT (dr);\n-      if (!STMT_VINFO_GATHER_SCATTER_P (vinfo_for_stmt (stmt)))\n+      dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n+      if (!STMT_VINFO_GATHER_SCATTER_P (dr_info->stmt))\n \tvect_update_init_of_dr (dr, niters, code);\n     }\n }"}, {"sha": "cece9787b7c767bacd84d0b463e578dd512d13f7", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "patch": "@@ -562,6 +562,17 @@ vec_info::lookup_single_use (tree lhs)\n   return NULL;\n }\n \n+/* Return vectorization information about DR.  */\n+\n+dr_vec_info *\n+vec_info::lookup_dr (data_reference *dr)\n+{\n+  stmt_vec_info stmt_info = lookup_stmt (DR_STMT (dr));\n+  /* DR_STMT should never refer to a stmt in a pattern replacement.  */\n+  gcc_checking_assert (!is_pattern_stmt_p (stmt_info));\n+  return STMT_VINFO_DR_INFO (stmt_info->dr_aux.stmt);\n+}\n+\n /* Record that NEW_STMT_INFO now implements the same data reference\n    as OLD_STMT_INFO.  */\n "}, {"sha": "61d89ac97083cb893d017f9a2f2f8e851b03cef9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae28565e7b0788c6b7a4945c2b67c54f46c45a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f5ae28565e7b0788c6b7a4945c2b67c54f46c45a", "patch": "@@ -240,6 +240,7 @@ struct vec_info {\n   stmt_vec_info lookup_stmt (gimple *);\n   stmt_vec_info lookup_def (tree);\n   stmt_vec_info lookup_single_use (tree);\n+  struct dr_vec_info *lookup_dr (data_reference *);\n   void move_dr (stmt_vec_info, stmt_vec_info);\n \n   /* The type of vectorization.  */\n@@ -1062,8 +1063,6 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n-#define DR_VECT_AUX(dr) (STMT_VINFO_DR_INFO (vect_dr_stmt (dr)))\n-\n #define VECT_MAX_COST 1000\n \n /* The maximum number of intermediate steps required in multi-step type\n@@ -1273,20 +1272,6 @@ add_stmt_costs (void *data, stmt_vector_for_cost *cost_vec)\n \t\t   cost->misalign, cost->where);\n }\n \n-/* Return the stmt DR is in.  For DR_STMT that have been replaced by\n-   a pattern this returns the corresponding pattern stmt.  Otherwise\n-   DR_STMT is returned.  */\n-\n-inline stmt_vec_info\n-vect_dr_stmt (data_reference *dr)\n-{\n-  gimple *stmt = DR_STMT (dr);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  /* DR_STMT should never refer to a stmt in a pattern replacement.  */\n-  gcc_checking_assert (!is_pattern_stmt_p (stmt_info));\n-  return stmt_info->dr_aux.stmt;\n-}\n-\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/"}]}