{"sha": "f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkYWM2ZWIzZjcxZDU4MTBmZjljOGI0MTdkNTJlMGQwYTc2ZmUzZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-02-01T11:47:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-01T11:47:59Z"}, "message": "expr.c (get_inner_reference): Use sbitsizetype for type sizes.\n\n        * expr.c (get_inner_reference): Use sbitsizetype for type sizes.\n        * fold-const.c (size_int): Replace with\n        (size_int_wide).\n        (make_bit_field_ref): Use bitsize_int for bit position.\n        * stor-layout.c (sizetype): Delete.\n        (sizetype_tab, sbitsizetype, ubitsizetype): Declare.\n        (layout_record, layout_union, layout_type):\n        Use bitsize_int for bit size.\n        (set_sizetype): New function.\n        (make_signed_type, make_unsigned_type): Use it.\n        * c-decl.c (init_decl_processing): Likewise.\n        * tree.h (size_int): Don't delcare, #define.\n        (size_int_wide, sizetype_tab, sbitsize, ubitsize): Declare.\n        (set_sizetype): Declare.\n        (bitsize_int, size_int_2, BITS_PER_UNIT_LOG, sizetype, bitsizetype):\n        Define.\n        * c-typeck.c (c_sizeof, c_sizeof_nowarn, c_size_in_bytes):\n        Convert result to sizetype.\n        (really_start_incremental_init, push_init_level):\n        Set type of constructor_bit_index to sbitsizetype.\n        (push_init_level): Use unsigned arithmetic to determine padding.\n        (output_init_element): Likewise.\n\nFrom-SVN: r17577", "tree": {"sha": "e4c4d0cc8bf232b7a9de28f0621b20029848ddd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4c4d0cc8bf232b7a9de28f0621b20029848ddd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/comments", "author": null, "committer": null, "parents": [{"sha": "f5426d1e9b4208ebbdd9cdc4c613f7fda9bc98ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5426d1e9b4208ebbdd9cdc4c613f7fda9bc98ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5426d1e9b4208ebbdd9cdc4c613f7fda9bc98ed"}], "stats": {"total": 266, "additions": 193, "deletions": 73}, "files": [{"sha": "a9fa0c8d2289a9a8df51b04473aaf9f14859557e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -1,3 +1,28 @@\n+Sun Feb  1 12:39:53 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* expr.c (get_inner_reference): Use sbitsizetype for type sizes.\n+\t* fold-const.c (size_int): Replace with\n+\t(size_int_wide).\n+\t(make_bit_field_ref): Use bitsize_int for bit position.\n+\t* stor-layout.c (sizetype): Delete.\n+\t(sizetype_tab, sbitsizetype, ubitsizetype): Declare.\n+\t(layout_record, layout_union, layout_type):\n+\tUse bitsize_int for bit size.\n+\t(set_sizetype): New function.\n+\t(make_signed_type, make_unsigned_type): Use it.\n+\t* c-decl.c (init_decl_processing): Likewise.\n+\t* tree.h (size_int): Don't delcare, #define.\n+\t(size_int_wide, sizetype_tab, sbitsize, ubitsize): Declare.\n+\t(set_sizetype): Declare.\n+\t(bitsize_int, size_int_2, BITS_PER_UNIT_LOG, sizetype, bitsizetype):\n+\tDefine.\n+\t* c-typeck.c (c_sizeof, c_sizeof_nowarn, c_size_in_bytes):\n+\tConvert result to sizetype.\n+\t(really_start_incremental_init, push_init_level):\n+\tSet type of constructor_bit_index to sbitsizetype.\n+\t(push_init_level): Use unsigned arithmetic to determine padding.\n+\t(output_init_element): Likewise.\n+\n Sun Feb  1 03:32:07 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* combine.c (simplify_shift_const): Fix typo in last change."}, {"sha": "31bae9fd47797f58e4945cb03846721b5c218dcf", "filename": "gcc/LANGUAGES", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2FLANGUAGES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2FLANGUAGES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FLANGUAGES?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -0,0 +1,32 @@\n+Right now there is no documentation for the GCC tree -> rtl interfaces\n+(or more generally the interfaces for adding new languages).\n+\n+Such documentation would be of great benefit to the project.  Until such\n+time as we can formally start documenting the interface this file will\n+serve as a repository for information on these interface and any incompatable\n+changes we've made.\n+\n+\n+Feb 1, 1998:\n+\n+  GCC used to store structure sizes & offsets to elements as bitsize\n+  quantities.  This causes problems because a structure can only be\n+  (target memsize / 8) bytes long (this may effect arrays too).  This\n+  is particularly problematical on machines with small address spaces.\n+\n+  So:\n+\n+    All trees that represent sizes in bits should have a TREE_TYPE of\n+    bitsizetype (rather than sizetype).\n+\n+    Accordingly, when such values are computed / initialized, care has to\n+    be takes to use / compute the proper type.\n+\n+    When a size in bits is converted into a size in bytes, which is expressed\n+    in trees, care should be taken to change the tree's type again to sizetype.\n+\n+    We've updated C, C++, Fortran & Objective-C to work with the new\n+    scheme.  Other languages will need to be updated accordingly.\n+    Contact amylaar@cygnus.com for additional information.\n+\n+"}, {"sha": "95d7ed124567ae1823ea57c2a354f22972c8dc6b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -1,5 +1,5 @@\n /* Process declarations and variables for C compiler.\n-   Copyright (C) 1988, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -2946,25 +2946,15 @@ init_decl_processing ()\n   /* `unsigned long' is the standard type for sizeof.\n      Traditionally, use a signed type.\n      Note that stddef.h uses `unsigned long',\n-     and this must agree, even of long and int are the same size.  */\n-  sizetype\n-    = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE)));\n+     and this must agree, even if long and int are the same size.  */\n+  set_sizetype\n+    (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE))));\n   if (flag_traditional && TREE_UNSIGNED (sizetype))\n-    sizetype = signed_type (sizetype);\n+    set_sizetype (signed_type (sizetype));\n \n   ptrdiff_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n \n-  TREE_TYPE (TYPE_SIZE (integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (char_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (unsigned_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_unsigned_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_long_integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (long_long_unsigned_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (short_integer_type_node)) = sizetype;\n-  TREE_TYPE (TYPE_SIZE (short_unsigned_type_node)) = sizetype;\n-\n   error_mark_node = make_node (ERROR_MARK);\n   TREE_TYPE (error_mark_node) = error_mark_node;\n "}, {"sha": "edfc7fd448a7287067b7bead773259ba532d80d1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -852,6 +852,7 @@ c_sizeof (type)\n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n \t\t  size_int (TYPE_PRECISION (char_type_node)));\n+  t = convert (sizetype, t);\n   /* size_binop does not put the constant in range, so do it now.  */\n   if (TREE_CODE (t) == INTEGER_CST && force_fit_type (t, 0))\n     TREE_CONSTANT_OVERFLOW (t) = TREE_OVERFLOW (t) = 1;\n@@ -875,6 +876,7 @@ c_sizeof_nowarn (type)\n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n \t\t  size_int (TYPE_PRECISION (char_type_node)));\n+  t = convert (sizetype, t);\n   force_fit_type (t, 0);\n   return t;\n }\n@@ -903,6 +905,7 @@ c_size_in_bytes (type)\n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n \t\t     size_int (BITS_PER_UNIT));\n+  t = convert (sizetype, t);\n   force_fit_type (t, 0);\n   return t;\n }\n@@ -5347,6 +5350,7 @@ really_start_incremental_init (type)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n       constructor_unfilled_fields = constructor_fields;\n       constructor_bit_index = copy_node (integer_zero_node);\n+      TREE_TYPE (constructor_bit_index) = sbitsizetype;\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5426,13 +5430,17 @@ push_init_level (implicit)\n       if (! tree_int_cst_equal (constructor_bit_index,\n \t\t\t\tDECL_FIELD_BITPOS (constructor_fields)))\n \t{\n-\t  int next = (TREE_INT_CST_LOW\n-\t\t      (DECL_FIELD_BITPOS (constructor_fields))\n-\t\t      / BITS_PER_UNIT);\n-\t  int here = (TREE_INT_CST_LOW (constructor_bit_index)\n-\t\t      / BITS_PER_UNIT);\n-\n-\t  assemble_zeros (next - here);\n+\t  /* By using unsigned arithmetic, the result will be correct even\n+\t     in case of overflows, if BITS_PER_UNIT is a power of two.  */\n+\t  unsigned next = (TREE_INT_CST_LOW\n+\t\t\t   (DECL_FIELD_BITPOS (constructor_fields))\n+\t\t\t   / (unsigned)BITS_PER_UNIT);\n+\t  unsigned here = (TREE_INT_CST_LOW (constructor_bit_index)\n+\t\t\t   / (unsigned)BITS_PER_UNIT);\n+\n+\t  assemble_zeros ((next - here)\n+\t\t\t  * (unsigned)BITS_PER_UNIT\n+\t\t\t  / (unsigned)BITS_PER_UNIT);\n \t}\n       /* Indicate that we have now filled the structure up to the current\n \t field.  */\n@@ -5524,6 +5532,7 @@ push_init_level (implicit)\n \tconstructor_fields = TREE_CHAIN (constructor_fields);\n       constructor_unfilled_fields = constructor_fields;\n       constructor_bit_index = copy_node (integer_zero_node);\n+      TREE_TYPE (constructor_bit_index) = sbitsizetype;\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -6018,12 +6027,19 @@ output_init_element (value, type, field, pending)\n \t\t  if (! tree_int_cst_equal (constructor_bit_index,\n \t\t\t\t\t    DECL_FIELD_BITPOS (field)))\n \t\t    {\n-\t\t      int next = (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n-\t\t\t\t  / BITS_PER_UNIT);\n-\t\t      int here = (TREE_INT_CST_LOW (constructor_bit_index)\n-\t\t\t\t  / BITS_PER_UNIT);\n-\n-\t\t      assemble_zeros (next - here);\n+\t\t      /* By using unsigned arithmetic, the result will be\n+\t\t\t correct even in case of overflows, if BITS_PER_UNIT\n+\t\t\t is a power of two.  */\n+\t\t      unsigned next = (TREE_INT_CST_LOW\n+\t\t\t\t       (DECL_FIELD_BITPOS (field))\n+\t\t\t\t       / (unsigned)BITS_PER_UNIT);\n+\t\t      unsigned here = (TREE_INT_CST_LOW\n+\t\t\t\t       (constructor_bit_index)\n+\t\t\t\t       / (unsigned)BITS_PER_UNIT);\n+\n+\t\t      assemble_zeros ((next - here)\n+\t\t\t\t      * (unsigned)BITS_PER_UNIT\n+\t\t\t\t      / (unsigned)BITS_PER_UNIT);\n \t\t    }\n \t\t}\n \t      output_constant (digest_init (type, value,"}, {"sha": "0c107c0db76fb1111653799f6d72d20a53d52092", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -4358,8 +4358,14 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  if (! integer_zerop (low_bound))\n \t    index = fold (build (MINUS_EXPR, index_type, index, low_bound));\n \n-\t  index = fold (build (MULT_EXPR, index_type, index,\n-\t\t\t       convert (index_type,\n+\t  if (TREE_CODE (index) == INTEGER_CST)\n+\t    {\n+\t      index = convert (sbitsizetype, index);\n+\t      index_type = TREE_TYPE (index);\n+\t    }\n+\n+\t  index = fold (build (MULT_EXPR, sbitsizetype, index,\n+\t\t\t       convert (sbitsizetype,\n \t\t\t\t\tTYPE_SIZE (TREE_TYPE (exp)))));\n \n \t  if (TREE_CODE (index) == INTEGER_CST\n@@ -4368,9 +4374,9 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  else\n \t    {\n \t      offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t   size_binop (FLOOR_DIV_EXPR, index,\n-\t\t\t\t\t       size_int (BITS_PER_UNIT)));\n-\n+\t\t\t\t   convert (sizetype,\n+\t\t\t\t\t    size_binop (FLOOR_DIV_EXPR, index,\n+\t\t\t\t\t\t\tsize_int (BITS_PER_UNIT))));\n \t      if (contains_placeholder_p (offset))\n \t\toffset = build (WITH_RECORD_EXPR, sizetype, offset, exp);\n \t    }"}, {"sha": "f4d5c8054b905b8b448f670a30e4b68a59d46cda", "filename": "gcc/fold-const.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -1,5 +1,5 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 88, 92-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */\n   @@ for cross-compilers.  */\n \n \n-/* The entry points in this file are fold, size_int, size_binop\n+/* The entry points in this file are fold, size_int_wide, size_binop\n    and force_fit_type.\n \n    fold takes a tree as argument and returns a simplified tree.\n@@ -1422,33 +1422,35 @@ const_binop (code, arg1, arg2, notrunc)\n   return 0;\n }\n \f\n-/* Return an INTEGER_CST with value V and type from `sizetype'.  */\n+/* Return an INTEGER_CST with value V .  The type is determined by bit_p:\n+   if it is zero, the type is taken from sizetype; if it is one, the type\n+   is taken from bitsizetype.  */\n \n tree\n-size_int (number)\n-     unsigned HOST_WIDE_INT number;\n+size_int_wide (number, high, bit_p)\n+     unsigned HOST_WIDE_INT number, high;\n {\n   register tree t;\n   /* Type-size nodes already made for small sizes.  */\n-  static tree size_table[2*HOST_BITS_PER_WIDE_INT + 1];\n+  static tree size_table[2*HOST_BITS_PER_WIDE_INT + 1][2];\n \n-  if (number < 2*HOST_BITS_PER_WIDE_INT + 1\n-      && size_table[number] != 0)\n-    return size_table[number];\n-  if (number < 2*HOST_BITS_PER_WIDE_INT + 1)\n+  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high\n+      && size_table[number][bit_p] != 0)\n+    return size_table[number][bit_p];\n+  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high)\n     {\n       push_obstacks_nochange ();\n       /* Make this a permanent node.  */\n       end_temporary_allocation ();\n       t = build_int_2 (number, 0);\n-      TREE_TYPE (t) = sizetype;\n-      size_table[number] = t;\n+      TREE_TYPE (t) = sizetype_tab[bit_p];\n+      size_table[number][bit_p] = t;\n       pop_obstacks ();\n     }\n   else\n     {\n-      t = build_int_2 (number, 0);\n-      TREE_TYPE (t) = sizetype;\n+      t = build_int_2 (number, high);\n+      TREE_TYPE (t) = sizetype_tab[bit_p];\n       TREE_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (t) = force_fit_type (t, 0);\n     }\n   return t;\n@@ -2343,7 +2345,7 @@ make_bit_field_ref (inner, type, bitsize, bitpos, unsignedp)\n      int unsignedp;\n {\n   tree result = build (BIT_FIELD_REF, type, inner,\n-\t\t       size_int (bitsize), size_int (bitpos));\n+\t\t       size_int (bitsize), bitsize_int (bitpos, 0L));\n \n   TREE_UNSIGNED (result) = unsignedp;\n "}, {"sha": "0e4e5087c21c3b7098286d34742ea2b86640691d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -1,5 +1,5 @@\n /* C-compiler utilities for types and variables storage layout\n-   Copyright (C) 1987, 88, 92-96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -33,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n    It is the first integer type laid out.\n    In C, this is int.  */\n \n-tree sizetype;\n+tree sizetype_tab[2], sbitsizetype, ubitsizetype;\n \n /* An integer constant with value 0 whose type is sizetype.  */\n \n@@ -419,7 +419,7 @@ layout_record (rec)\n \t    {\n \t      if (const_size > 0)\n \t\tvar_size = size_binop (PLUS_EXPR, var_size,\n-\t\t\t\t       size_int (const_size));\n+\t\t\t\t       bitsize_int (const_size, 0L));\n \t      const_size = 0;\n \t      var_size = round_up (var_size, desired_align);\n \t      var_align = MIN (var_align, desired_align);\n@@ -483,7 +483,7 @@ layout_record (rec)\n \n       if (var_size && const_size)\n \tDECL_FIELD_BITPOS (field)\n-\t  = size_binop (PLUS_EXPR, var_size, size_int (const_size));\n+\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size, 0L));\n       else if (var_size)\n \tDECL_FIELD_BITPOS (field) = var_size;\n       else\n@@ -536,7 +536,7 @@ layout_record (rec)\n     {\n       if (const_size)\n \tvar_size\n-\t  = size_binop (PLUS_EXPR, var_size, size_int (const_size));\n+\t  = size_binop (PLUS_EXPR, var_size, bitsize_int (const_size, 0L));\n       TYPE_SIZE (rec) = var_size;\n     }\n \n@@ -595,7 +595,7 @@ layout_union (rec)\n \tcontinue;\n \n       layout_decl (field, 0);\n-      DECL_FIELD_BITPOS (field) = size_int (0);\n+      DECL_FIELD_BITPOS (field) = bitsize_int (0L, 0L);\n \n       /* Union must be at least as aligned as any field requires.  */\n \n@@ -625,21 +625,21 @@ layout_union (rec)\n       else if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n \tvar_size = fold (build (COND_EXPR, sizetype, DECL_QUALIFIER (field),\n \t\t\t\tDECL_SIZE (field),\n-\t\t\t\tvar_size ? var_size : integer_zero_node));\n+\t\t\t\tvar_size ? var_size : bitsize_int (0L, 0L)));\n       }\n \n   if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n     TYPE_FIELDS (rec) = nreverse (TYPE_FIELDS (rec));\n \n   /* Determine the ultimate size of the union (in bytes).  */\n   if (NULL == var_size)\n-    TYPE_SIZE (rec) = size_int (CEIL (const_size, BITS_PER_UNIT)\n-\t\t\t\t* BITS_PER_UNIT);\n+    TYPE_SIZE (rec) = bitsize_int (CEIL (const_size, BITS_PER_UNIT)\n+\t\t\t\t   * BITS_PER_UNIT, 0L);\n   else if (const_size == 0)\n     TYPE_SIZE (rec) = var_size;\n   else\n     TYPE_SIZE (rec) = size_binop (MAX_EXPR, var_size,\n-\t\t\t\t  round_up (size_int (const_size),\n+\t\t\t\t  round_up (bitsize_int (const_size, 0L),\n \t\t\t\t\t    BITS_PER_UNIT));\n \n   /* Determine the desired alignment.  */\n@@ -712,12 +712,12 @@ layout_type (type)\n \n       TYPE_MODE (type) = smallest_mode_for_size (TYPE_PRECISION (type),\n \t\t\t\t\t\t MODE_INT);\n-      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n       break;\n \n     case REAL_TYPE:\n       TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_FLOAT, 0);\n-      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n       break;\n \n     case COMPLEX_TYPE:\n@@ -727,7 +727,7 @@ layout_type (type)\n \t\t\t (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n \t\t\t  ? MODE_COMPLEX_INT : MODE_COMPLEX_FLOAT),\n \t\t\t 0);\n-      TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n+      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n       break;\n \n     case VOID_TYPE:\n@@ -737,7 +737,7 @@ layout_type (type)\n       break;\n \n     case OFFSET_TYPE:\n-      TYPE_SIZE (type) = size_int (POINTER_SIZE);\n+      TYPE_SIZE (type) = bitsize_int (POINTER_SIZE, 0L);\n       TYPE_MODE (type) = ptr_mode;\n       break;\n \n@@ -750,7 +750,7 @@ layout_type (type)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       TYPE_MODE (type) = ptr_mode;\n-      TYPE_SIZE (type) = size_int (POINTER_SIZE);\n+      TYPE_SIZE (type) = bitsize_int (POINTER_SIZE, 0L);\n       TREE_UNSIGNED (type) = 1;\n       TYPE_PRECISION (type) = POINTER_SIZE;\n       break;\n@@ -798,8 +798,8 @@ layout_type (type)\n \t\t&& TREE_CODE (TYPE_MAX_VALUE (index)) != INTEGER_CST)\n \t      length = size_binop (MAX_EXPR, length, size_zero_node);\n \n-\t    TYPE_SIZE (type) = size_binop (MULT_EXPR, length,\n-\t\t\t\t\t   TYPE_SIZE (element));\n+\t    TYPE_SIZE (type) = size_binop (MULT_EXPR, TYPE_SIZE (element),\n+\t\t\t\t\t   length);\n \t  }\n \n \t/* Now round the alignment and size,\n@@ -972,7 +972,7 @@ layout_type (type)\n \t    TYPE_MODE (type) = BLKmode;\n \t  else\n \t    TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n-\t  TYPE_SIZE (type) = size_int (rounded_size);\n+\t  TYPE_SIZE (type) = bitsize_int (rounded_size, 0L);\n \t  TYPE_ALIGN (type) = alignment;\n \t  TYPE_PRECISION (type) = size_in_bits;\n \t}\n@@ -1066,9 +1066,7 @@ make_signed_type (precision)\n      is the type for size values.  */\n \n   if (sizetype == 0)\n-    {\n-      sizetype = type;\n-    }\n+    set_sizetype (type);\n \n   /* Lay out the type: set its alignment, size, etc.  */\n \n@@ -1092,13 +1090,49 @@ make_unsigned_type (precision)\n \n   if (sizetype == 0)\n     {\n-      sizetype = type;\n+      TREE_UNSIGNED (type) = 1;\n+      set_sizetype (type);\n     }\n \n   fixup_unsigned_type (type);\n   return type;\n }\n \n+/* Set sizetype to TYPE, and initialize *bitsizetype accordingly.\n+   Also update the type of any standard type's sizes made so far.  */\n+\n+void\n+set_sizetype (type)\n+     tree type;\n+{\n+  int precision = TYPE_PRECISION (type);\n+\n+  sizetype = type;\n+\n+  /* The *bitsizetype types use a precision that avoids overflows when\n+     calculating signed sizes / offsets in bits.\n+\n+     We are allocating bitsizetype once and change it in place when\n+     we decide later that we want to change it.  This way, we avoid the\n+     hassle of changing all the TYPE_SIZE (TREE_TYPE (sometype))\n+     individually in each front end.  */\n+  if (! bitsizetype)\n+    bitsizetype = make_node (INTEGER_TYPE);\n+\n+  precision += BITS_PER_UNIT_LOG + 1;\n+  /* However, when cross-compiling from a 32 bit to a 64 bit host,\n+     we are limited to 64 bit precision.  */\n+  if (precision > 2 * HOST_BITS_PER_WIDE_INT)\n+    precision = 2 * HOST_BITS_PER_WIDE_INT;\n+  TYPE_PRECISION (bitsizetype) = precision;\n+  (TREE_UNSIGNED (type) ? fixup_unsigned_type : fixup_signed_type)\n+    (bitsizetype);\n+  layout_type (bitsizetype);\n+\n+  sbitsizetype = make_signed_type (precision);\n+  ubitsizetype = make_unsigned_type (precision);\n+}\n+\n /* Set the extreme values of TYPE based on its precision in bits,\n    then lay it out.  Used when make_signed_type won't do\n    because the tree code is not INTEGER_TYPE."}, {"sha": "093304ab04e1a638cc8d417589315163872ce7a2", "filename": "gcc/tree.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f8dac6eb3f71d5810ff9c8b417d52e0d0a76fe3d", "patch": "@@ -1,5 +1,5 @@\n /* Front-end tree definitions for GNU compiler.\n-   Copyright (C) 1989, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93-97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1295,6 +1295,7 @@ extern tree build_block\t\t\tPROTO((tree, tree, tree, tree, tree));\n \n extern tree make_signed_type\t\tPROTO((int));\n extern tree make_unsigned_type\t\tPROTO((int));\n+extern void set_sizetype\t\tPROTO((tree));\n extern tree signed_or_unsigned_type \tPROTO((int, tree));\n extern void fixup_unsigned_type\t\tPROTO((tree));\n extern tree build_pointer_type\t\tPROTO((tree));\n@@ -1398,14 +1399,28 @@ extern tree convert\t\t\tPROTO((tree, tree));\n extern tree size_in_bytes\t\tPROTO((tree));\n extern int int_size_in_bytes\t\tPROTO((tree));\n extern tree size_binop\t\t\tPROTO((enum tree_code, tree, tree));\n-extern tree size_int\t\t\tPROTO((unsigned HOST_WIDE_INT));\n+extern tree size_int_wide\t\tPROTO((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t       unsigned HOST_WIDE_INT, int));\n+#define size_int(L) size_int_2 ((L), 0, 0)\n+#define bitsize_int(L, H) size_int_2 ((L), (H), 1)\n+#define size_int_2(L, H, T)\t\t\t\\\n+  size_int_wide ((unsigned HOST_WIDE_INT) (L),\t\\\n+\t\t (unsigned HOST_WIDE_INT) (H), (T))\n+\n extern tree round_up\t\t\tPROTO((tree, int));\n extern tree get_pending_sizes\t\tPROTO((void));\n extern void put_pending_sizes\t\tPROTO((tree));\n \n /* Type for sizes of data-type.  */\n \n-extern tree sizetype;\n+#define BITS_PER_UNIT_LOG \\\n+  ((BITS_PER_UNIT > 1) + (BITS_PER_UNIT > 2) + (BITS_PER_UNIT > 4) \\\n+   + (BITS_PER_UNIT > 8) + (BITS_PER_UNIT > 16) + (BITS_PER_UNIT > 32) \\\n+   + (BITS_PER_UNIT > 64) + (BITS_PER_UNIT > 128) + (BITS_PER_UNIT > 256))\n+\n+extern tree sizetype_tab[2], sbitsizetype, ubitsizetype;\n+#define sizetype sizetype_tab[0]\n+#define bitsizetype sizetype_tab[1]\n \n /* If nonzero, an upper limit on alignment of structure fields, in bits. */\n extern int maximum_field_alignment;"}]}