{"sha": "77381ee7de541021dccd0030a757fc38f369993b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzczODFlZTdkZTU0MTAyMWRjY2QwMDMwYTc1N2ZjMzhmMzY5OTkzYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-04T11:12:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-04T11:12:04Z"}, "message": "re PR target/59163 (program compiled with g++ -O3 segfaults)\n\n\tPR target/59163\n\t* config/i386/i386.c (ix86_legitimate_combined_insn): If for\n\t!TARGET_AVX there is misaligned MEM operand with vector mode\n\tand get_attr_ssememalign is 0, return false.\n\t(ix86_expand_special_args_builtin): Add get_pointer_alignment\n\tcomputed alignment and for non-temporal loads/stores also\n\tat least GET_MODE_ALIGNMENT as MEM_ALIGN.\n\t* config/i386/sse.md\n\t(<sse>_loadu<ssemodesuffix><avxsizesuffix><mask_name>,\n\t<sse>_storeu<ssemodesuffix><avxsizesuffix>,\n\t<sse2_avx_avx512f>_loaddqu<mode><mask_name>,\n\t<sse2_avx_avx512f>_storedqu<mode>, <sse3>_lddqu<avxsizesuffix>,\n\tsse_vmrcpv4sf2, sse_vmrsqrtv4sf2, sse2_cvtdq2pd, sse_movhlps,\n\tsse_movlhps, sse_storehps, sse_loadhps, sse_loadlps,\n\t*vec_interleave_highv2df, *vec_interleave_lowv2df,\n\t*vec_extractv2df_1_sse, sse2_movsd, sse4_1_<code>v8qiv8hi2,\n\tsse4_1_<code>v4qiv4si2, sse4_1_<code>v4hiv4si2,\n\tsse4_1_<code>v2qiv2di2, sse4_1_<code>v2hiv2di2,\n\tsse4_1_<code>v2siv2di2, sse4_2_pcmpestr, *sse4_2_pcmpestr_unaligned,\n\tsse4_2_pcmpestri, sse4_2_pcmpestrm, sse4_2_pcmpestr_cconly,\n\tsse4_2_pcmpistr, *sse4_2_pcmpistr_unaligned, sse4_2_pcmpistri,\n\tsse4_2_pcmpistrm, sse4_2_pcmpistr_cconly): Add ssememalign attribute.\n\t* config/i386/i386.md (ssememalign): New define_attr.\n\n\t* g++.dg/torture/pr59163.C: New test.\n\nFrom-SVN: r205663", "tree": {"sha": "1e7231a3d81ac22559f693a55d561f8ae7463d8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e7231a3d81ac22559f693a55d561f8ae7463d8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77381ee7de541021dccd0030a757fc38f369993b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77381ee7de541021dccd0030a757fc38f369993b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77381ee7de541021dccd0030a757fc38f369993b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77381ee7de541021dccd0030a757fc38f369993b/comments", "author": null, "committer": null, "parents": [{"sha": "a1d7a124b9f3940943890c6d1da2b0d2b5219f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d7a124b9f3940943890c6d1da2b0d2b5219f7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d7a124b9f3940943890c6d1da2b0d2b5219f7e"}], "stats": {"total": 4, "additions": 2, "deletions": 2}, "files": [{"sha": "7bf8c1ec0214aeb5a7f1f1a72fdd846d1d3939d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77381ee7de541021dccd0030a757fc38f369993b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77381ee7de541021dccd0030a757fc38f369993b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=77381ee7de541021dccd0030a757fc38f369993b", "patch": "@@ -32649,7 +32649,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n \t     on it.  Try to improve it using get_pointer_alignment,\n \t     and if the special builtin is one that requires strict\n \t     mode alignment, also from it's GET_MODE_ALIGNMENT.\n-\t     Failure to do so could leak to ix86_legitimate_combined_insn\n+\t     Failure to do so could lead to ix86_legitimate_combined_insn\n \t     rejecting all changes to such insns.  */\n \t  unsigned int align = get_pointer_alignment (arg);\n \t  if (aligned_mem && align < GET_MODE_ALIGNMENT (tmode))\n@@ -32705,7 +32705,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n \t\t on it.  Try to improve it using get_pointer_alignment,\n \t\t and if the special builtin is one that requires strict\n \t\t mode alignment, also from it's GET_MODE_ALIGNMENT.\n-\t\t Failure to do so could leak to ix86_legitimate_combined_insn\n+\t\t Failure to do so could lead to ix86_legitimate_combined_insn\n \t\t rejecting all changes to such insns.  */\n \t      unsigned int align = get_pointer_alignment (arg);\n \t      if (aligned_mem && align < GET_MODE_ALIGNMENT (mode))"}]}