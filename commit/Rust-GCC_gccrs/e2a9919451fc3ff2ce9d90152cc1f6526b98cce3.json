{"sha": "e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJhOTkxOTQ1MWZjM2ZmMmNlOWQ5MDE1MmNjMWY2NTI2Yjk4Y2NlMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-08-01T23:27:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-08-01T23:27:38Z"}, "message": "rs6000-c.c (altivec_resolve_overloaded_builtin): Add support for vec_extract on vector float...\n\n[gcc]\n2016-08-01  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tAdd support for vec_extract on vector float, vector int, vector\n\tshort, and vector char vector types.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add\n\tvector float, vector int, vector short, and vector char\n\toptimizations on 64-bit ISA 2.07 systems for both constant and\n\tvariable element numbers.\n\t(rs6000_split_vec_extract_var): Likewise.\n\t* config/rs6000/vsx.md (vsx_xscvspdp_scalar2): Allow SFmode to be\n\tAltivec registers on ISA 2.07 and above.\n\t(vsx_extract_v4sf): Delete alternative that hard coded element 0,\n\twhich never was matched due to the split occuring before register\n\tallocation (and the code would not have worked on little endian\n\tsystems if it did match).  Allow extracts to go to the Altivec\n\tregisters if ISA 2.07 (power8).  Change from using \"\" around the\n\tC++ code to using {}'s.\n\t(vsx_extract_v4sf_<mode>_load): New insn to optimize vector float\n\tvec_extracts when the vector is in memory.\n\t(vsx_extract_v4sf_var): New insn to optimize vector float\n\tvec_extracts when the element number is variable on 64-bit ISA\n\t2.07 systems.\n\t(vsx_extract_<mode>, VSX_EXTRACT_I iterator): Add optimizations\n\tfor 64-bit ISA 2.07 as well as ISA 3.0.\n\t(vsx_extract_<mode>_p9, VSX_EXTRACT_I iterator): Likewise.\n\t(vsx_extract_<mode>_p8, VSX_EXTRACT_I iterator): Likewise.\n\t(vsx_extract_<mode>_load, VSX_EXTRACT_I iterator): New insn to\n\toptimize vector int, vector short, and vector char vec_extracts\n\twhen the vector is in memory.\n\t(vsx_extract_<mode>_var, VSX_EXTRACT_I iterator): New insn to\n\toptimize vector int, vector short, and vector char vec_extracts\n\twhen the element number is variable.\n\n[gcc/testsuite]\n2016-08-01  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-extract-5.c: New tests to test\n\tvec_extract for vector float, vector int, vector short, and vector\n\tchar.\n\t* gcc.target/powerpc/vec-extract-6.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-7.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-8.c: Likewise.\n\t* gcc.target/powerpc/vec-extract-9.c: Likewise.\n\nFrom-SVN: r238971", "tree": {"sha": "be32d404c0080a73c0b9158ff5d20a1437865f28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be32d404c0080a73c0b9158ff5d20a1437865f28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/comments", "author": null, "committer": null, "parents": [{"sha": "72a30e45c5629a3f1cece39777b71a557eed3c57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a30e45c5629a3f1cece39777b71a557eed3c57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a30e45c5629a3f1cece39777b71a557eed3c57"}], "stats": {"total": 588, "additions": 571, "deletions": 17}, "files": [{"sha": "fa109062803b9b8bc2a5868084f55e3d7df9c28a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -1,3 +1,37 @@\n+2016-08-01  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tAdd support for vec_extract on vector float, vector int, vector\n+\tshort, and vector char vector types.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add\n+\tvector float, vector int, vector short, and vector char\n+\toptimizations on 64-bit ISA 2.07 systems for both constant and\n+\tvariable element numbers.\n+\t(rs6000_split_vec_extract_var): Likewise.\n+\t* config/rs6000/vsx.md (vsx_xscvspdp_scalar2): Allow SFmode to be\n+\tAltivec registers on ISA 2.07 and above.\n+\t(vsx_extract_v4sf): Delete alternative that hard coded element 0,\n+\twhich never was matched due to the split occuring before register\n+\tallocation (and the code would not have worked on little endian\n+\tsystems if it did match).  Allow extracts to go to the Altivec\n+\tregisters if ISA 2.07 (power8).  Change from using \"\" around the\n+\tC++ code to using {}'s.\n+\t(vsx_extract_v4sf_<mode>_load): New insn to optimize vector float\n+\tvec_extracts when the vector is in memory.\n+\t(vsx_extract_v4sf_var): New insn to optimize vector float\n+\tvec_extracts when the element number is variable on 64-bit ISA\n+\t2.07 systems.\n+\t(vsx_extract_<mode>, VSX_EXTRACT_I iterator): Add optimizations\n+\tfor 64-bit ISA 2.07 as well as ISA 3.0.\n+\t(vsx_extract_<mode>_p9, VSX_EXTRACT_I iterator): Likewise.\n+\t(vsx_extract_<mode>_p8, VSX_EXTRACT_I iterator): Likewise.\n+\t(vsx_extract_<mode>_load, VSX_EXTRACT_I iterator): New insn to\n+\toptimize vector int, vector short, and vector char vec_extracts\n+\twhen the vector is in memory.\n+\t(vsx_extract_<mode>_var, VSX_EXTRACT_I iterator): New insn to\n+\toptimize vector int, vector short, and vector char vec_extracts\n+\twhen the element number is variable.\n+\n 2016-08-01  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/71948"}, {"sha": "beca35552668077579096785429c74a896c62739", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -5135,6 +5135,25 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tcase V2DImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n \t\t  break;\n+\n+\t\tcase V4SFmode:\n+\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n+\t\t  break;\n+\n+\t\tcase V4SImode:\n+\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n+\t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n+\t\t  break;\n+\n+\t\tcase V8HImode:\n+\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n+\t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n+\t\t  break;\n+\n+\t\tcase V16QImode:\n+\t\t  if (TARGET_DIRECT_MOVE_64BIT)\n+\t\t    call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n+\t\t  break;\n \t\t}\n \t    }\n \n@@ -5154,6 +5173,22 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tcase V2DImode:\n \t\t  call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V2DI];\n \t\t  break;\n+\n+\t\tcase V4SFmode:\n+\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SF];\n+\t\t  break;\n+\n+\t\tcase V4SImode:\n+\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V4SI];\n+\t\t  break;\n+\n+\t\tcase V8HImode:\n+\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V8HI];\n+\t\t  break;\n+\n+\t\tcase V16QImode:\n+\t\t  call = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_EXT_V16QI];\n+\t\t  break;\n \t\t}\n \t    }\n "}, {"sha": "c16863d0ad63949d84857480f91bab5c1a6cb93e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -6938,23 +6938,23 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \t  emit_insn (gen_vsx_extract_v4sf (target, vec, elt));\n \t  return;\n \tcase V16QImode:\n-\t  if (TARGET_VEXTRACTUB)\n+\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v16qi (target, vec, elt));\n \t      return;\n \t    }\n \t  else\n \t    break;\n \tcase V8HImode:\n-\t  if (TARGET_VEXTRACTUB)\n+\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v8hi (target, vec, elt));\n \t      return;\n \t    }\n \t  else\n \t    break;\n \tcase V4SImode:\n-\t  if (TARGET_VEXTRACTUB)\n+\t  if (TARGET_DIRECT_MOVE_64BIT)\n \t    {\n \t      emit_insn (gen_vsx_extract_v4si (target, vec, elt));\n \t      return;\n@@ -6982,6 +6982,26 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \t  emit_insn (gen_vsx_extract_v2di_var (target, vec, elt));\n \t  return;\n \n+\tcase V4SFmode:\n+\t  if (TARGET_UPPER_REGS_SF)\n+\t    {\n+\t      emit_insn (gen_vsx_extract_v4sf_var (target, vec, elt));\n+\t      return;\n+\t    }\n+\t  break;\n+\n+\tcase V4SImode:\n+\t  emit_insn (gen_vsx_extract_v4si_var (target, vec, elt));\n+\t  return;\n+\n+\tcase V8HImode:\n+\t  emit_insn (gen_vsx_extract_v8hi_var (target, vec, elt));\n+\t  return;\n+\n+\tcase V16QImode:\n+\t  emit_insn (gen_vsx_extract_v16qi_var (target, vec, elt));\n+\t  return;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -7253,6 +7273,33 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \t  emit_insn (gen_vsx_vslo_v2di (dest, src, tmp_altivec));\n \t  return;\n \n+\tcase V4SFmode:\n+\t  {\n+\t    rtx tmp_altivec_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n+\t    rtx tmp_altivec_v4sf = gen_rtx_REG (V4SFmode, REGNO (tmp_altivec));\n+\t    rtx src_v2di = gen_rtx_REG (V2DImode, REGNO (src));\n+\t    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,\n+\t\t\t\t\t  tmp_altivec));\n+\n+\t    emit_insn (gen_vsx_xscvspdp_scalar2 (dest, tmp_altivec_v4sf));\n+\t    return;\n+\t  }\n+\n+\tcase V4SImode:\n+\tcase V8HImode:\n+\tcase V16QImode:\n+\t  {\n+\t    rtx tmp_altivec_di = gen_rtx_REG (DImode, REGNO (tmp_altivec));\n+\t    rtx src_v2di = gen_rtx_REG (V2DImode, REGNO (src));\n+\t    rtx tmp_gpr_di = gen_rtx_REG (DImode, REGNO (dest));\n+\t    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,\n+\t\t\t\t\t  tmp_altivec));\n+\t    emit_move_insn (tmp_gpr_di, tmp_altivec_di);\n+\t    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,\n+\t\t\t\t    GEN_INT (64 - (8 * scalar_size))));\n+\t    return;\n+\t  }\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "61fb282e4b7e3f276ad2e2804d0cc81e91015a9e", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 149, "deletions": 13, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -1663,7 +1663,7 @@\n \n ;; Same as vsx_xscvspdp, but use SF as the type\n (define_insn \"vsx_xscvspdp_scalar2\"\n-  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f\")\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=ww\")\n \t(unspec:SF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wa\")]\n \t\t   UNSPEC_VSX_CVSPDP))]\n   \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n@@ -2237,18 +2237,15 @@\n \n ;; Extract a SF element from V4SF\n (define_insn_and_split \"vsx_extract_v4sf\"\n-  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f,f\")\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=ww\")\n \t(vec_select:SF\n-\t (match_operand:V4SF 1 \"vsx_register_operand\" \"wa,wa\")\n-\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"O,i\")])))\n-   (clobber (match_scratch:V4SF 3 \"=X,0\"))]\n+\t (match_operand:V4SF 1 \"vsx_register_operand\" \"wa\")\n+\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"n\")])))\n+   (clobber (match_scratch:V4SF 3 \"=0\"))]\n   \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n-  \"@\n-   xscvspdp %x0,%x1\n-   #\"\n-  \"\"\n+  \"#\"\n+  \"&& 1\"\n   [(const_int 0)]\n-  \"\n {\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n@@ -2268,10 +2265,46 @@\n     }\n   emit_insn (gen_vsx_xscvspdp_scalar2 (op0, tmp));\n   DONE;\n-}\"\n-  [(set_attr \"length\" \"4,8\")\n+}\n+  [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"fp\")])\n \n+(define_insn_and_split \"*vsx_extract_v4sf_<mode>_load\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,wv,wb,?r\")\n+\t(vec_select:SF\n+\t (match_operand:V4SF 1 \"memory_operand\" \"m,Z,m,m\")\n+\t (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n,n,n,n\")])))\n+   (clobber (match_scratch:P 3 \"=&b,&b,&b,&b\"))]\n+  \"VECTOR_MEM_VSX_P (V4SFmode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 4))]\n+{\n+  operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n+\t\t\t\t\t   operands[3], SFmode);\n+}\n+  [(set_attr \"type\" \"fpload,fpload,fpload,load\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; Variable V4SF extract\n+(define_insn_and_split \"vsx_extract_v4sf_var\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=ww,ww,?r\")\n+\t(unspec:SF [(match_operand:V4SF 1 \"input_operand\" \"v,m,m\")\n+\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r,r,r\")]\n+\t\t   UNSPEC_VSX_EXTRACT))\n+   (clobber (match_scratch:DI 3 \"=r,&b,&b\"))\n+   (clobber (match_scratch:V2DI 4 \"=&v,X,X\"))]\n+  \"VECTOR_MEM_VSX_P (V4SFmode) && TARGET_DIRECT_MOVE_64BIT\n+   && TARGET_UPPER_REGS_SF\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_vec_extract_var (operands[0], operands[1], operands[2],\n+\t\t\t\toperands[3], operands[4]);\n+  DONE;\n+})\n+\n ;; Expand the builtin form of xxpermdi to canonical rtl.\n (define_expand \"vsx_xxpermdi_<mode>\"\n   [(match_operand:VSX_L 0 \"vsx_register_operand\" \"\")\n@@ -2370,7 +2403,21 @@\n ;; Extraction of a single element in a small integer vector.  None of the small\n ;; types are currently allowed in a vector register, so we extract to a DImode\n ;; and either do a direct move or store.\n-(define_insn_and_split  \"vsx_extract_<mode>\"\n+(define_expand  \"vsx_extract_<mode>\"\n+  [(parallel [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\")\n+\t\t   (vec_select:<VS_scalar>\n+\t\t    (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\")\n+\t\t    (parallel [(match_operand:QI 2 \"const_int_operand\")])))\n+\t      (clobber (match_dup 3))])]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+{\n+  operands[3] = gen_rtx_SCRATCH ((TARGET_VEXTRACTUB) ? DImode : <MODE>mode);\n+})\n+\n+;; Under ISA 3.0, we can use the byte/half-word/word integer stores if we are\n+;; extracting a vector element and storing it to memory, rather than using\n+;; direct move to a GPR and a GPR store.\n+(define_insn_and_split  \"*vsx_extract_<mode>_p9\"\n   [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r,Z\")\n \t(vec_select:<VS_scalar>\n \t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"<VSX_EX>,<VSX_EX>\")\n@@ -2438,6 +2485,95 @@\n }\n   [(set_attr \"type\" \"vecsimple\")])\n \n+(define_insn_and_split  \"*vsx_extract_<mode>_p8\"\n+  [(set (match_operand:<VS_scalar> 0 \"nonimmediate_operand\" \"=r\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_EXTRACT_I 1 \"gpc_reg_operand\" \"v\")\n+\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))\n+   (clobber (match_scratch:VSX_EXTRACT_I 3 \"=v\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx element = operands[2];\n+  rtx vec_tmp = operands[3];\n+  int value;\n+\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    element = GEN_INT (GET_MODE_NUNITS (<MODE>mode) - 1 - INTVAL (element));\n+\n+  /* If the value is in the correct position, we can avoid doing the VSPLT<x>\n+     instruction.  */\n+  value = INTVAL (element);\n+  if (<MODE>mode == V16QImode)\n+    {\n+      if (value != 7)\n+\temit_insn (gen_altivec_vspltb_direct (vec_tmp, src, element));\n+      else\n+\tvec_tmp = src;\n+    }\n+  else if (<MODE>mode == V8HImode)\n+    {\n+      if (value != 3)\n+\temit_insn (gen_altivec_vsplth_direct (vec_tmp, src, element));\n+      else\n+\tvec_tmp = src;\n+    }\n+  else if (<MODE>mode == V4SImode)\n+    {\n+      if (value != 1)\n+\temit_insn (gen_altivec_vspltw_direct (vec_tmp, src, element));\n+      else\n+\tvec_tmp = src;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  emit_move_insn (gen_rtx_REG (DImode, REGNO (dest)),\n+\t\t  gen_rtx_REG (DImode, REGNO (vec_tmp)));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"mftgpr\")])\n+\n+;; Optimize extracting a single scalar element from memory.\n+(define_insn_and_split \"*vsx_extract_<mode>_load\"\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=r\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_EXTRACT_I 1 \"memory_operand\" \"m\")\n+\t (parallel [(match_operand:QI 2 \"<VSX_EXTRACT_PREDICATE>\" \"n\")])))\n+   (clobber (match_scratch:DI 3 \"=&b\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 4))]\n+{\n+  operands[4] = rs6000_adjust_vec_address (operands[0], operands[1], operands[2],\n+\t\t\t\t\t   operands[3], <VS_scalar>mode);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; Variable V16QI/V8HI/V4SI extract\n+(define_insn_and_split \"vsx_extract_<mode>_var\"\n+  [(set (match_operand:<VS_scalar> 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(unspec:<VS_scalar>\n+\t [(match_operand:VSX_EXTRACT_I 1 \"input_operand\" \"v,m\")\n+\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")]\n+\t UNSPEC_VSX_EXTRACT))\n+   (clobber (match_scratch:DI 3 \"=r,&b\"))\n+   (clobber (match_scratch:V2DI 4 \"=&v,X\"))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_vec_extract_var (operands[0], operands[1], operands[2],\n+\t\t\t\toperands[3], operands[4]);\n+  DONE;\n+})\n \n ;; Expanders for builtins\n (define_expand \"vsx_mergel_<mode>\""}, {"sha": "3eb9df1a412d07d94cc0f5c2d56f47398a4c1de9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -1,7 +1,17 @@\n+2016-08-01  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-extract-5.c: New tests to test\n+\tvec_extract for vector float, vector int, vector short, and vector\n+\tchar.\n+\t* gcc.target/powerpc/vec-extract-6.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-7.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-8.c: Likewise.\n+\t* gcc.target/powerpc/vec-extract-9.c: Likewise.\n+\n 2016-08-01  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* gcc.target/aarch64/test_frame_10.c: Fix test to check for a\n-\tsingle stack adjustment, no writeback.\t\n+\tsingle stack adjustment, no writeback.\n \t* gcc.target/aarch64/test_frame_12.c: Likewise.\n \t* gcc.target/aarch64/test_frame_13.c: Likewise.\n \t* gcc.target/aarch64/test_frame_15.c: Likewise."}, {"sha": "95924f389714c31544dfe046b62063c61c148c30", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-5.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-5.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+signed char\n+add_signed_char_0 (vector signed char *p)\n+{\n+  return vec_extract (*p, 0) + 1;\n+}\n+\n+signed char\n+add_signed_char_1 (vector signed char *p)\n+{\n+  return vec_extract (*p, 1) + 1;\n+}\n+\n+signed char\n+add_signed_char_2 (vector signed char *p)\n+{\n+  return vec_extract (*p, 2) + 1;\n+}\n+\n+signed char\n+add_signed_char_3 (vector signed char *p)\n+{\n+  return vec_extract (*p, 3) + 1;\n+}\n+\n+signed char\n+add_signed_char_4 (vector signed char *p)\n+{\n+  return vec_extract (*p, 4) + 1;\n+}\n+\n+signed char\n+add_signed_char_5 (vector signed char *p)\n+{\n+  return vec_extract (*p, 5) + 1;\n+}\n+\n+signed char\n+add_signed_char_6 (vector signed char *p)\n+{\n+  return vec_extract (*p, 6) + 1;\n+}\n+\n+signed char\n+add_signed_char_7 (vector signed char *p)\n+{\n+  return vec_extract (*p, 7) + 1;\n+}\n+\n+signed char\n+add_signed_char_n (vector signed char *p, int n)\n+{\n+  return vec_extract (*p, n) + 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}, {"sha": "27b8105915f0463733670022d9029d541e1da61a", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-6.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-6.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+unsigned char\n+add_unsigned_char_0 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 0) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_1 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 1) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_2 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 2) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_3 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 3) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_4 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 4) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_5 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 5) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_6 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 6) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_7 (vector unsigned char *p)\n+{\n+  return vec_extract (*p, 7) + 1;\n+}\n+\n+unsigned char\n+add_unsigned_char_n (vector unsigned char *p, int n)\n+{\n+  return vec_extract (*p, n) + 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}, {"sha": "11b71b43b4d6920bcef824e330169e705e83e155", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-7.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-7.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+float\n+add_float_0 (vector float *p)\n+{\n+  return vec_extract (*p, 0) + 1.0f;\n+}\n+\n+float\n+add_float_1 (vector float *p)\n+{\n+  return vec_extract (*p, 1) + 1.0f;\n+}\n+\n+float\n+add_float_2 (vector float *p)\n+{\n+  return vec_extract (*p, 2) + 1.0f;\n+}\n+\n+float\n+add_float_3 (vector float *p)\n+{\n+  return vec_extract (*p, 3) + 1.0f;\n+}\n+\n+float\n+add_float_n (vector float *p, long n)\n+{\n+  return vec_extract (*p, n) + 1.0f;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}, {"sha": "f10b3b0f27184a885d135376ab0feabdaf1bb7fc", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-8.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-8.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+int\n+add_int_0 (vector int *p)\n+{\n+  return vec_extract (*p, 0) + 1;\n+}\n+\n+int\n+add_int_1 (vector int *p)\n+{\n+  return vec_extract (*p, 1) + 1;\n+}\n+\n+int\n+add_int_2 (vector int *p)\n+{\n+  return vec_extract (*p, 2) + 1;\n+}\n+\n+int\n+add_int_3 (vector int *p)\n+{\n+  return vec_extract (*p, 3) + 1;\n+}\n+\n+int\n+add_int_n (vector int *p, int n)\n+{\n+  return vec_extract (*p, n) + 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}, {"sha": "e355bce913d558ae3a6e0015aadbc82e8e412c33", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-9.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a9919451fc3ff2ce9d90152cc1f6526b98cce3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-9.c?ref=e2a9919451fc3ff2ce9d90152cc1f6526b98cce3", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+short\n+add_short_0 (vector short *p)\n+{\n+  return vec_extract (*p, 0) + 1;\n+}\n+\n+short\n+add_short_1 (vector short *p)\n+{\n+  return vec_extract (*p, 1) + 1;\n+}\n+\n+short\n+add_short_2 (vector short *p)\n+{\n+  return vec_extract (*p, 2) + 1;\n+}\n+\n+short\n+add_short_3 (vector short *p)\n+{\n+  return vec_extract (*p, 3) + 1;\n+}\n+\n+short\n+add_short_4 (vector short *p)\n+{\n+  return vec_extract (*p, 4) + 1;\n+}\n+\n+short\n+add_short_5 (vector short *p)\n+{\n+  return vec_extract (*p, 5) + 1;\n+}\n+\n+short\n+add_short_6 (vector short *p)\n+{\n+  return vec_extract (*p, 6) + 1;\n+}\n+\n+short\n+add_short_7 (vector short *p)\n+{\n+  return vec_extract (*p, 7) + 1;\n+}\n+\n+short\n+add_short_n (vector short *p, int n)\n+{\n+  return vec_extract (*p, n) + 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"lxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"   } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"     } } */\n+/* { dg-final { scan-assembler-not \"lxv\"      } } */\n+/* { dg-final { scan-assembler-not \"lvx\"      } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}]}