{"sha": "4de249d909c233761e01226009329a31197a8174", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRlMjQ5ZDkwOWMyMzM3NjFlMDEyMjYwMDkzMjlhMzExOTdhODE3NA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-01-31T09:21:18Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-01-31T09:21:18Z"}, "message": "combine.c (cse_main): Set gen_lowpart to gen_lowpart_for_combine and restore it to...\n\n2004-01-31  Paolo Bonzini  <bonzini@gnu.org>\n\n \t* combine.c (cse_main): Set gen_lowpart to gen_lowpart_for_combine\n\tand restore it to gen_lowpart_general on exit.\n\t(gen_lowpart_for_combine): Adjust all callers to go through\n\tgen_lowpart.\n\t* cse.c (cse_main): Set gen_lowpart to gen_lowpart_if_possible\n\tand restore it to gen_lowpart_general on exit.\n\t(gen_lowpart_if_possible): Adjust all callers to go through\n\tgen_lowpart.\n\t* emit-rtl.c (gen_lowpart_general): New name of gen_lowpart.\n\t(gen_lowpart): Declare as pointer to function, initialized to\n\tgen_lowpart_general.\n\t* rtl.h (gen_lowpart): Declare as pointer to function.\n\nFrom-SVN: r77026", "tree": {"sha": "4bdf7a42eabbdc21c283f25530f1e0938a9feae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bdf7a42eabbdc21c283f25530f1e0938a9feae2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4de249d909c233761e01226009329a31197a8174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4de249d909c233761e01226009329a31197a8174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4de249d909c233761e01226009329a31197a8174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4de249d909c233761e01226009329a31197a8174/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f84d109fc49f0e6f269c1e8a0c1bf48fb25c24b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84d109fc49f0e6f269c1e8a0c1bf48fb25c24b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84d109fc49f0e6f269c1e8a0c1bf48fb25c24b8"}], "stats": {"total": 225, "additions": 123, "deletions": 102}, "files": [{"sha": "5997244c0e63ea4e2c7fd0f95e1487533a69a5bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de249d909c233761e01226009329a31197a8174/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de249d909c233761e01226009329a31197a8174/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4de249d909c233761e01226009329a31197a8174", "patch": "@@ -1,3 +1,18 @@\n+2004-01-31  Paolo Bonzini  <bonzini@gnu.org>\n+\n+ \t* combine.c (cse_main): Set gen_lowpart to gen_lowpart_for_combine\n+\tand restore it to gen_lowpart_general on exit.\n+\t(gen_lowpart_for_combine): Adjust all callers to go through\n+\tgen_lowpart.\n+\t* cse.c (cse_main): Set gen_lowpart to gen_lowpart_if_possible\n+\tand restore it to gen_lowpart_general on exit.\n+\t(gen_lowpart_if_possible): Adjust all callers to go through\n+\tgen_lowpart.\n+\t* emit-rtl.c (gen_lowpart_general): New name of gen_lowpart.\n+\t(gen_lowpart): Declare as pointer to function, initialized to\n+\tgen_lowpart_general.\n+\t* rtl.h (gen_lowpart): Declare as pointer to function.\n+\n 2004-01-31  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* bt-load.c: Replace \"gen_rtx (FOO, \" with \"gen_rtx_FOO (\"."}, {"sha": "0db618e1ff147c4296e2c0c601b8fe03980ad009", "filename": "gcc/combine.c", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de249d909c233761e01226009329a31197a8174/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de249d909c233761e01226009329a31197a8174/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4de249d909c233761e01226009329a31197a8174", "patch": "@@ -95,10 +95,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define SHIFT_COUNT_TRUNCATED 0\n #endif\n \n-/* It is not safe to use ordinary gen_lowpart in combine.\n-   Use gen_lowpart_for_combine instead.  See comments there.  */\n-#define gen_lowpart dont_use_gen_lowpart_you_dummy\n-\n /* Number of attempts to combine instructions in this function.  */\n \n static int combine_attempts;\n@@ -525,6 +521,10 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   combine_max_regno = nregs;\n \n+  /* It is not safe to use ordinary gen_lowpart in combine.\n+     See comments in gen_lowpart_for_combine.  */\n+  gen_lowpart = gen_lowpart_for_combine;\n+\n   reg_nonzero_bits = xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT));\n   reg_sign_bit_copies = xcalloc (nregs, sizeof (unsigned char));\n \n@@ -774,6 +774,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   total_successes += combine_successes;\n \n   nonzero_sign_valid = 0;\n+  gen_lowpart = gen_lowpart_general;\n \n   /* Make recognizer allow volatile MEMs again.  */\n   init_recog ();\n@@ -2321,7 +2322,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       ni2dest = SET_DEST (XVECEXP (newpat, 0, 0));\n       newpat = XVECEXP (newpat, 0, 1);\n       SUBST (SET_SRC (newpat),\n-\t     gen_lowpart_for_combine (GET_MODE (SET_SRC (newpat)), ni2dest));\n+\t     gen_lowpart (GET_MODE (SET_SRC (newpat)), ni2dest));\n       i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n       if (i2_code_number >= 0)\n@@ -3131,7 +3132,7 @@ find_split_point (rtx *loc, rtx insn)\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_AND (mode,\n \t\t\t\t  gen_rtx_LSHIFTRT\n-\t\t\t\t  (mode, gen_lowpart_for_combine (mode, inner),\n+\t\t\t\t  (mode, gen_lowpart (mode, inner),\n \t\t\t\t   GEN_INT (pos)),\n \t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n \n@@ -3145,7 +3146,7 @@ find_split_point (rtx *loc, rtx insn)\n \t\t     gen_rtx_fmt_ee\n \t\t     (unsignedp ? LSHIFTRT : ASHIFTRT, mode,\n \t\t      gen_rtx_ASHIFT (mode,\n-\t\t\t\t      gen_lowpart_for_combine (mode, inner),\n+\t\t\t\t      gen_lowpart (mode, inner),\n \t\t\t\t      GEN_INT (GET_MODE_BITSIZE (mode)\n \t\t\t\t\t       - len - pos)),\n \t\t      GEN_INT (GET_MODE_BITSIZE (mode) - len)));\n@@ -3814,15 +3815,15 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n       if (op0_mode == VOIDmode)\n \top0_mode = GET_MODE (SUBREG_REG (x));\n \n-      /* simplify_subreg can't use gen_lowpart_for_combine.  */\n+      /* See if this can be moved to simplify_subreg.  */\n       if (CONSTANT_P (SUBREG_REG (x))\n \t  && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x)\n-\t     /* Don't call gen_lowpart_for_combine if the inner mode\n+\t     /* Don't call gen_lowpart if the inner mode\n \t\tis VOIDmode and we cannot simplify it, as SUBREG without\n \t\tinner mode is invalid.  */\n \t  && (GET_MODE (SUBREG_REG (x)) != VOIDmode\n \t      || gen_lowpart_common (mode, SUBREG_REG (x))))\n-\treturn gen_lowpart_for_combine (mode, SUBREG_REG (x));\n+\treturn gen_lowpart (mode, SUBREG_REG (x));\n \n       if (GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_CC)\n         break;\n@@ -3861,7 +3862,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t\t\t      simplify_gen_unary (NOT, inner_mode, const1_rtx,\n \t\t\t\t\t\t  inner_mode),\n \t\t\t      XEXP (SUBREG_REG (XEXP (x, 0)), 1));\n-\t  return gen_lowpart_for_combine (mode, x);\n+\t  return gen_lowpart (mode, x);\n \t}\n \n       /* Apply De Morgan's laws to reduce number of patterns for machines\n@@ -3988,7 +3989,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t     >= (unsigned int) (GET_MODE_BITSIZE (mode) + 1)\n \t  && ! (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t\t&& GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT))\n-\treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n+\treturn gen_lowpart (mode, XEXP (x, 0));\n \n       /* A truncate of a comparison can be replaced with a subreg if\n          STORE_FLAG_VALUE permits.  This is like the previous test,\n@@ -3997,7 +3998,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0)\n-\treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n+\treturn gen_lowpart (mode, XEXP (x, 0));\n \n       /* Similarly, a truncate of a register whose value is a\n          comparison can be replaced with a subreg if STORE_FLAG_VALUE\n@@ -4006,7 +4007,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0\n \t  && (temp = get_last_value (XEXP (x, 0)))\n \t  && GET_RTX_CLASS (GET_CODE (temp)) == '<')\n-\treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n+\treturn gen_lowpart (mode, XEXP (x, 0));\n \n       break;\n \n@@ -4354,8 +4355,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n \t      && nonzero_bits (op0, mode) == 1)\n-\t    return gen_lowpart_for_combine (mode,\n-\t\t\t\t\t    expand_compound_operation (op0));\n+\t    return gen_lowpart (mode,\n+\t\t\t\texpand_compound_operation (op0));\n \n \t  else if (STORE_FLAG_VALUE == 1\n \t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n@@ -4366,7 +4367,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      return simplify_gen_unary (NEG, mode,\n-\t\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t\t gen_lowpart (mode, op0),\n \t\t\t\t\t mode);\n \t    }\n \n@@ -4378,7 +4379,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      return gen_binary (XOR, mode,\n-\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t gen_lowpart (mode, op0),\n \t\t\t\t const1_rtx);\n \t    }\n \n@@ -4390,7 +4391,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return plus_constant (gen_lowpart_for_combine (mode, op0), 1);\n+\t      return plus_constant (gen_lowpart (mode, op0), 1);\n \t    }\n \n \t  /* If STORE_FLAG_VALUE is -1, we have cases similar to\n@@ -4400,8 +4401,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t      && op1 == const0_rtx\n \t      && (num_sign_bit_copies (op0, mode)\n \t\t  == GET_MODE_BITSIZE (mode)))\n-\t    return gen_lowpart_for_combine (mode,\n-\t\t\t\t\t    expand_compound_operation (op0));\n+\t    return gen_lowpart (mode,\n+\t\t\t\texpand_compound_operation (op0));\n \n \t  else if (STORE_FLAG_VALUE == -1\n \t\t   && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n@@ -4411,7 +4412,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      return simplify_gen_unary (NEG, mode,\n-\t\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t\t gen_lowpart (mode, op0),\n \t\t\t\t\t mode);\n \t    }\n \n@@ -4424,7 +4425,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t    {\n \t      op0 = expand_compound_operation (op0);\n \t      return simplify_gen_unary (NOT, mode,\n-\t\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t\t gen_lowpart (mode, op0),\n \t\t\t\t\t mode);\n \t    }\n \n@@ -4436,7 +4437,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return plus_constant (gen_lowpart_for_combine (mode, op0), -1);\n+\t      return plus_constant (gen_lowpart (mode, op0), -1);\n \t    }\n \n \t  /* If STORE_FLAG_VALUE says to just test the sign bit and X has just\n@@ -4901,7 +4902,7 @@ simplify_if_then_else (rtx x)\n \t  temp = gen_binary (MULT, m, temp,\n \t\t\t     gen_binary (MULT, m, c1, const_true_rtx));\n \t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n-\t  temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n+\t  temp = gen_binary (op, m, gen_lowpart (m, z), temp);\n \n \t  if (extend_op != NIL)\n \t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n@@ -4924,7 +4925,7 @@ simplify_if_then_else (rtx x)\n \t      && (i = exact_log2 (-INTVAL (true_rtx))) >= 0)))\n     return\n       simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t    gen_lowpart_for_combine (mode, XEXP (cond, 0)), i);\n+\t\t\t    gen_lowpart (mode, XEXP (cond, 0)), i);\n \n   /* (IF_THEN_ELSE (NE REG 0) (0) (8)) is REG for nonzero_bits (REG) == 8.  */\n   if (true_code == NE && XEXP (cond, 1) == const0_rtx\n@@ -5155,7 +5156,7 @@ simplify_set (rtx x)\n \t      && GET_CODE (SUBREG_REG (dest)) == REG)))\n     {\n       SUBST (SET_DEST (x),\n-\t     gen_lowpart_for_combine (GET_MODE (SUBREG_REG (src)),\n+\t     gen_lowpart (GET_MODE (SUBREG_REG (src)),\n \t\t\t\t      dest));\n       SUBST (SET_SRC (x), SUBREG_REG (src));\n \n@@ -5855,7 +5856,7 @@ expand_field_assignment (rtx x)\n \t\t\t+ (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n \t{\n \t  x = gen_rtx_SET (VOIDmode, SUBREG_REG (SET_DEST (x)),\n-\t\t\t   gen_lowpart_for_combine\n+\t\t\t   gen_lowpart\n \t\t\t   (GET_MODE (SUBREG_REG (SET_DEST (x))),\n \t\t\t    SET_SRC (x)));\n \t  continue;\n@@ -5883,7 +5884,7 @@ expand_field_assignment (rtx x)\n \t    break;\n \n \t  compute_mode = imode;\n-\t  inner = gen_lowpart_for_combine (imode, inner);\n+\t  inner = gen_lowpart (imode, inner);\n \t}\n \n       /* Compute a mask of LEN bits, if we can do this on the host machine.  */\n@@ -5907,7 +5908,7 @@ expand_field_assignment (rtx x)\n \t\t\t\t inner),\n \t\t     gen_binary (ASHIFT, compute_mode,\n \t\t\t\t gen_binary (AND, compute_mode,\n-\t\t\t\t\t     gen_lowpart_for_combine\n+\t\t\t\t\t     gen_lowpart\n \t\t\t\t\t     (compute_mode, SET_SRC (x)),\n \t\t\t\t\t     mask),\n \t\t\t\t pos)));\n@@ -6055,7 +6056,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t{\n \t  if (tmode != inner_mode)\n \t    {\n-\t      /* We can't call gen_lowpart_for_combine in a DEST since we\n+\t      /* We can't call gen_lowpart in a DEST since we\n \t\t always want a SUBREG (see below) and it would sometimes\n \t\t return a new hard register.  */\n \t      if (pos || in_dest)\n@@ -6082,7 +6083,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t  new = gen_rtx_SUBREG (tmode, inner, final_word);\n \t\t}\n \t      else\n-\t\tnew = gen_lowpart_for_combine (tmode, inner);\n+\t\tnew = gen_lowpart (tmode, inner);\n \t    }\n \t  else\n \t    new = inner;\n@@ -6312,7 +6313,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n     }\n   else if (pos_rtx != 0\n \t   && GET_MODE_SIZE (pos_mode) < GET_MODE_SIZE (GET_MODE (pos_rtx)))\n-    pos_rtx = gen_lowpart_for_combine (pos_mode, pos_rtx);\n+    pos_rtx = gen_lowpart (pos_mode, pos_rtx);\n \n   /* Make POS_RTX unless we already have it and it is correct.  If we don't\n      have a POS_RTX but we do have an ORIG_POS_RTX, the latter must\n@@ -6327,7 +6328,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   new = gen_rtx_fmt_eee (unsignedp ? ZERO_EXTRACT : SIGN_EXTRACT,\n \t\t\t extraction_mode, inner, GEN_INT (len), pos_rtx);\n   if (! in_dest)\n-    new = gen_lowpart_for_combine (mode, new);\n+    new = gen_lowpart (mode, new);\n \n   return new;\n }\n@@ -6630,7 +6631,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t      tem = gen_rtx_fmt_e (GET_CODE (tem), mode, XEXP (tem, 0));\n \t    }\n \t  else\n-\t    tem = gen_lowpart_for_combine (mode, XEXP (tem, 0));\n+\t    tem = gen_lowpart (mode, XEXP (tem, 0));\n \t  return tem;\n \t}\n       break;\n@@ -6641,7 +6642,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \n   if (new)\n     {\n-      x = gen_lowpart_for_combine (mode, new);\n+      x = gen_lowpart (mode, new);\n       code = GET_CODE (x);\n     }\n \n@@ -6716,7 +6717,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n      expression is VOIDmode.\n \n      Also do nothing if X is a CLOBBER; this can happen if X was\n-     the return value from a call to gen_lowpart_for_combine.  */\n+     the return value from a call to gen_lowpart.  */\n   if (code == CALL || code == ASM_OPERANDS || code == CLOBBER)\n     return x;\n \n@@ -6770,7 +6771,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n      get X in the proper mode.  */\n   if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode)\n       && (GET_MODE_MASK (GET_MODE (x)) & ~mask) == 0)\n-    return gen_lowpart_for_combine (mode, x);\n+    return gen_lowpart (mode, x);\n \n   /* If we aren't changing the mode, X is not a SUBREG, and all zero bits in\n      MASK are already known to be zero in X, we need not do anything.  */\n@@ -6963,12 +6964,12 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* For most binary operations, just propagate into the operation and\n \t change the mode if we have an operation of that mode.  */\n \n-      op0 = gen_lowpart_for_combine (op_mode,\n-\t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n-\t\t\t\t\t\t    reg, next_select));\n-      op1 = gen_lowpart_for_combine (op_mode,\n-\t\t\t\t     force_to_mode (XEXP (x, 1), mode, mask,\n-\t\t\t\t\t\t    reg, next_select));\n+      op0 = gen_lowpart (op_mode,\n+\t\t\t force_to_mode (XEXP (x, 0), mode, mask,\n+\t\t\t\t\treg, next_select));\n+      op1 = gen_lowpart (op_mode,\n+\t\t\t force_to_mode (XEXP (x, 1), mode, mask,\n+\t\t\t\t\treg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n \tx = gen_binary (code, op_mode, op0, op1);\n@@ -7000,9 +7001,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       else\n \tmask = fuller_mask;\n \n-      op0 = gen_lowpart_for_combine (op_mode,\n-\t\t\t\t     force_to_mode (XEXP (x, 0), op_mode,\n-\t\t\t\t\t\t    mask, reg, next_select));\n+      op0 = gen_lowpart (op_mode,\n+\t\t\t force_to_mode (XEXP (x, 0), op_mode,\n+\t\t\t\t\tmask, reg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = gen_binary (code, op_mode, op0, XEXP (x, 1));\n@@ -7198,9 +7199,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       mask = fuller_mask;\n \n     unop:\n-      op0 = gen_lowpart_for_combine (op_mode,\n-\t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n-\t\t\t\t\t\t    reg, next_select));\n+      op0 = gen_lowpart (op_mode,\n+\t\t\t force_to_mode (XEXP (x, 0), mode, mask,\n+\t\t\t\t\treg, next_select));\n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = simplify_gen_unary (code, op_mode, op0, op_mode);\n       break;\n@@ -7222,11 +7223,11 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t written in a narrower mode.  We play it safe and do not do so.  */\n \n       SUBST (XEXP (x, 1),\n-\t     gen_lowpart_for_combine (GET_MODE (x),\n+\t     gen_lowpart (GET_MODE (x),\n \t\t\t\t      force_to_mode (XEXP (x, 1), mode,\n \t\t\t\t\t\t     mask, reg, next_select)));\n       SUBST (XEXP (x, 2),\n-\t     gen_lowpart_for_combine (GET_MODE (x),\n+\t     gen_lowpart (GET_MODE (x),\n \t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n \t\t\t\t\t\t     mask, reg, next_select)));\n       break;\n@@ -7236,7 +7237,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n     }\n \n   /* Ensure we return a value of the proper mode.  */\n-  return gen_lowpart_for_combine (mode, x);\n+  return gen_lowpart (mode, x);\n }\n \f\n /* Return nonzero if X is an expression that has one of two values depending on\n@@ -7610,13 +7611,13 @@ rtx_equal_for_field_assignment_p (rtx x, rtx y)\n   if (GET_CODE (x) == MEM && GET_CODE (y) == SUBREG\n       && GET_CODE (SUBREG_REG (y)) == MEM\n       && rtx_equal_p (SUBREG_REG (y),\n-\t\t      gen_lowpart_for_combine (GET_MODE (SUBREG_REG (y)), x)))\n+\t\t      gen_lowpart (GET_MODE (SUBREG_REG (y)), x)))\n     return 1;\n \n   if (GET_CODE (y) == MEM && GET_CODE (x) == SUBREG\n       && GET_CODE (SUBREG_REG (x)) == MEM\n       && rtx_equal_p (SUBREG_REG (x),\n-\t\t      gen_lowpart_for_combine (GET_MODE (SUBREG_REG (x)), y)))\n+\t\t      gen_lowpart (GET_MODE (SUBREG_REG (x)), y)))\n     return 1;\n \n   /* We used to see if get_last_value of X and Y were the same but that's\n@@ -7839,7 +7840,7 @@ apply_distributive_law (rtx x)\n \n       tem = gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n \t\t\tSUBREG_REG (lhs), SUBREG_REG (rhs));\n-      return gen_lowpart_for_combine (GET_MODE (x), tem);\n+      return gen_lowpart (GET_MODE (x), tem);\n \n     default:\n       return x;\n@@ -7942,7 +7943,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n \n   if (GET_CODE (varop) == IOR || GET_CODE (varop) == XOR)\n     return\n-      gen_lowpart_for_combine\n+      gen_lowpart\n \t(mode,\n \t apply_distributive_law\n \t (gen_binary (GET_CODE (varop), GET_MODE (varop),\n@@ -7975,7 +7976,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       && SUBREG_REG (XEXP (x, 0)) == varop)\n     varop = XEXP (x, 0);\n   else\n-    varop = gen_lowpart_for_combine (mode, varop);\n+    varop = gen_lowpart (mode, varop);\n \n   /* If we can't make the SUBREG, try to return what we were given.  */\n   if (GET_CODE (varop) == CLOBBER)\n@@ -9801,7 +9802,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n       && SUBREG_REG (XEXP (x, 0)) == varop)\n     varop = XEXP (x, 0);\n   else if (GET_MODE (varop) != shift_mode)\n-    varop = gen_lowpart_for_combine (shift_mode, varop);\n+    varop = gen_lowpart (shift_mode, varop);\n \n   /* If we can't make the SUBREG, try to return what we were given.  */\n   if (GET_CODE (varop) == CLOBBER)\n@@ -9830,7 +9831,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t\t\t\tGET_MODE_MASK (result_mode) >> orig_count);\n \n   /* Do the remainder of the processing in RESULT_MODE.  */\n-  x = gen_lowpart_for_combine (result_mode, x);\n+  x = gen_lowpart (result_mode, x);\n \n   /* If COMPLEMENT_P is set, we have to complement X before doing the outer\n      operation.  */\n@@ -9965,17 +9966,16 @@ recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n   return insn_code_number;\n }\n \f\n-/* Like gen_lowpart but for use by combine.  In combine it is not possible\n-   to create any new pseudoregs.  However, it is safe to create\n-   invalid memory addresses, because combine will try to recognize\n-   them and all they will do is make the combine attempt fail.\n+/* Like gen_lowpart_general but for use by combine.  In combine it\n+   is not possible to create any new pseudoregs.  However, it is\n+   safe to create invalid memory addresses, because combine will\n+   try to recognize them and all they will do is make the combine\n+   attempt fail.\n \n    If for some reason this cannot do its job, an rtx\n    (clobber (const_int 0)) is returned.\n    An insn containing that will not be recognized.  */\n \n-#undef gen_lowpart\n-\n static rtx\n gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n {\n@@ -10273,8 +10273,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t tmode != GET_MODE (op0); tmode = GET_MODE_WIDER_MODE (tmode))\n \t      if ((unsigned HOST_WIDE_INT) c0 == GET_MODE_MASK (tmode))\n \t\t{\n-\t\t  op0 = gen_lowpart_for_combine (tmode, inner_op0);\n-\t\t  op1 = gen_lowpart_for_combine (tmode, inner_op1);\n+\t\t  op0 = gen_lowpart (tmode, inner_op0);\n+\t\t  op1 = gen_lowpart (tmode, inner_op1);\n \t\t  code = unsigned_condition (code);\n \t\t  changed = 1;\n \t\t  break;\n@@ -10939,7 +10939,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && const_op >> i == 0\n \t      && (tmode = mode_for_size (i, MODE_INT, 1)) != BLKmode)\n \t    {\n-\t      op0 = gen_lowpart_for_combine (tmode, XEXP (op0, 0));\n+\t      op0 = gen_lowpart (tmode, XEXP (op0, 0));\n \t      continue;\n \t    }\n \n@@ -10979,7 +10979,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t  op0 = gen_binary (AND, tmode,\n \t\t\t\t    SUBREG_REG (XEXP (op0, 0)),\n \t\t\t\t    gen_int_mode (c1, tmode));\n-\t\t  op0 = gen_lowpart_for_combine (mode, op0);\n+\t\t  op0 = gen_lowpart (mode, op0);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -11101,7 +11101,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t   + (GET_MODE_MASK (tmode) >> 1) + 1)\n \t\t  <= GET_MODE_MASK (tmode)))\n \t    {\n-\t      op0 = gen_lowpart_for_combine (tmode, XEXP (XEXP (op0, 0), 0));\n+\t      op0 = gen_lowpart (tmode, XEXP (XEXP (op0, 0), 0));\n \t      continue;\n \t    }\n \n@@ -11126,7 +11126,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t\t\t\t  XEXP (op0, 1));\n \n \t      op0 = gen_binary (PLUS, tmode,\n-\t\t\t\tgen_lowpart_for_combine (tmode, inner),\n+\t\t\t\tgen_lowpart (tmode, inner),\n \t\t\t\tnew_const);\n \t      continue;\n \t    }\n@@ -11220,7 +11220,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n           if (GET_CODE (SUBREG_REG (op0)) == REG)\n \t    {\n \t      op0 = SUBREG_REG (op0);\n-\t      op1 = gen_lowpart_for_combine (GET_MODE (op0), op1);\n+\t      op1 = gen_lowpart (GET_MODE (op0), op1);\n \t    }\n \t}\n       else if ((GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n@@ -11229,7 +11229,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t\t\t GET_MODE (SUBREG_REG (op0)))\n \t\t   & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n \t{\n-\t  tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)), op1);\n+\t  tem = gen_lowpart (GET_MODE (SUBREG_REG (op0)), op1);\n \n \t  if ((nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n \t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n@@ -11281,15 +11281,15 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      if (GET_CODE (op0) == AND\n \t\t  && !have_insn_for (AND, mode))\n \t\top0 = gen_binary (AND, tmode,\n-\t\t\t\t  gen_lowpart_for_combine (tmode,\n-\t\t\t\t\t\t\t   XEXP (op0, 0)),\n-\t\t\t\t  gen_lowpart_for_combine (tmode,\n-\t\t\t\t\t\t\t   XEXP (op0, 1)));\n+\t\t\t\t  gen_lowpart (tmode,\n+\t\t\t\t\t       XEXP (op0, 0)),\n+\t\t\t\t  gen_lowpart (tmode,\n+\t\t\t\t\t       XEXP (op0, 1)));\n \n-\t      op0 = gen_lowpart_for_combine (tmode, op0);\n+\t      op0 = gen_lowpart (tmode, op0);\n \t      if (zero_extended && GET_CODE (op1) == CONST_INT)\n \t\top1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (mode));\n-\t      op1 = gen_lowpart_for_combine (tmode, op1);\n+\t      op1 = gen_lowpart (tmode, op1);\n \t      break;\n \t    }\n \n@@ -11300,7 +11300,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = gen_binary (AND, tmode,\n-\t\t\t\tgen_lowpart_for_combine (tmode, op0),\n+\t\t\t\tgen_lowpart (tmode, op0),\n \t\t\t\tGEN_INT ((HOST_WIDE_INT) 1\n \t\t\t\t\t << (GET_MODE_BITSIZE (mode) - 1)));\n \t      code = (code == LT) ? NE : EQ;\n@@ -11555,7 +11555,7 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n \t       && GET_MODE_BITSIZE (GET_MODE (dest)) <= BITS_PER_WORD\n \t       && subreg_lowpart_p (SET_DEST (setter)))\n \trecord_value_for_reg (dest, record_dead_insn,\n-\t\t\t      gen_lowpart_for_combine (GET_MODE (dest),\n+\t\t\t      gen_lowpart (GET_MODE (dest),\n \t\t\t\t\t\t       SET_SRC (setter)));\n       else\n \trecord_value_for_reg (dest, record_dead_insn, NULL_RTX);\n@@ -11827,7 +11827,7 @@ get_last_value (rtx x)\n       && (GET_MODE_SIZE (GET_MODE (x))\n \t  <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n       && (value = get_last_value (SUBREG_REG (x))) != 0)\n-    return gen_lowpart_for_combine (GET_MODE (x), value);\n+    return gen_lowpart (GET_MODE (x), value);\n \n   if (GET_CODE (x) != REG)\n     return 0;"}, {"sha": "edc6ef3a8a02bba0feddc369bef713ab14594593", "filename": "gcc/cse.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de249d909c233761e01226009329a31197a8174/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de249d909c233761e01226009329a31197a8174/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4de249d909c233761e01226009329a31197a8174", "patch": "@@ -1628,7 +1628,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n       int exp_q = REG_QTY (REGNO (classp->exp));\n       struct qty_table_elem *exp_ent = &qty_table[exp_q];\n \n-      exp_ent->const_rtx = gen_lowpart_if_possible (exp_ent->mode, x);\n+      exp_ent->const_rtx = gen_lowpart (exp_ent->mode, x);\n       exp_ent->const_insn = this_insn;\n     }\n \n@@ -1647,7 +1647,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \t      struct qty_table_elem *x_ent = &qty_table[x_q];\n \n \t      x_ent->const_rtx\n-\t\t= gen_lowpart_if_possible (GET_MODE (x), p->exp);\n+\t\t= gen_lowpart (GET_MODE (x), p->exp);\n \t      x_ent->const_insn = this_insn;\n \t      break;\n \t    }\n@@ -3577,7 +3577,7 @@ fold_rtx (rtx x, rtx insn)\n \t    if (((BYTES_BIG_ENDIAN\n \t\t  && offset == GET_MODE_SIZE (GET_MODE (constant)) - 1)\n \t\t || (! BYTES_BIG_ENDIAN && offset == 0))\n-\t\t&& (new = gen_lowpart_if_possible (mode, constant)) != 0)\n+\t\t&& (new = gen_lowpart (mode, constant)) != 0)\n \t      return new;\n \t  }\n \n@@ -3683,7 +3683,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t    && GET_CODE (arg_ent->const_rtx) != REG\n \t\t    && GET_CODE (arg_ent->const_rtx) != PLUS)\n \t\t  const_arg\n-\t\t    = gen_lowpart_if_possible (GET_MODE (arg),\n+\t\t    = gen_lowpart (GET_MODE (arg),\n \t\t\t\t\t       arg_ent->const_rtx);\n \t      }\n \t    break;\n@@ -4289,7 +4289,7 @@ equiv_constant (rtx x)\n       struct qty_table_elem *x_ent = &qty_table[x_q];\n \n       if (x_ent->const_rtx)\n-\tx = gen_lowpart_if_possible (GET_MODE (x), x_ent->const_rtx);\n+\tx = gen_lowpart (GET_MODE (x), x_ent->const_rtx);\n     }\n \n   if (x == 0 || CONSTANT_P (x))\n@@ -4327,7 +4327,7 @@ equiv_constant (rtx x)\n \n    If the requested operation cannot be done, 0 is returned.\n \n-   This is similar to gen_lowpart in emit-rtl.c.  */\n+   This is similar to gen_lowpart_general in emit-rtl.c.  */\n \n rtx\n gen_lowpart_if_possible (enum machine_mode mode, rtx x)\n@@ -4442,7 +4442,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n-      rtx tem = gen_lowpart_if_possible (inner_mode, op1);\n+      rtx tem = gen_lowpart (inner_mode, op1);\n \n       record_jump_cond (code, mode, SUBREG_REG (op0),\n \t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op1, 0),\n@@ -4454,7 +4454,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op1));\n-      rtx tem = gen_lowpart_if_possible (inner_mode, op0);\n+      rtx tem = gen_lowpart (inner_mode, op0);\n \n       record_jump_cond (code, mode, SUBREG_REG (op1),\n \t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op0, 0),\n@@ -4474,7 +4474,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op0));\n-      rtx tem = gen_lowpart_if_possible (inner_mode, op1);\n+      rtx tem = gen_lowpart (inner_mode, op1);\n \n       record_jump_cond (code, mode, SUBREG_REG (op0),\n \t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op1, 0),\n@@ -4487,7 +4487,7 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n \t  < GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1)))))\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (op1));\n-      rtx tem = gen_lowpart_if_possible (inner_mode, op0);\n+      rtx tem = gen_lowpart (inner_mode, op0);\n \n       record_jump_cond (code, mode, SUBREG_REG (op1),\n \t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op0, 0),\n@@ -5176,7 +5176,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t   const_elt; const_elt = const_elt->next_same_value)\n \t\tif (GET_CODE (const_elt->exp) == REG)\n \t\t  {\n-\t\t    src_related = gen_lowpart_if_possible (mode,\n+\t\t    src_related = gen_lowpart (mode,\n \t\t\t\t\t\t\t   const_elt->exp);\n \t\t    break;\n \t\t  }\n@@ -5200,7 +5200,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n \t       tmode = GET_MODE_WIDER_MODE (tmode))\n \t    {\n-\t      rtx inner = gen_lowpart_if_possible (tmode, XEXP (src, 0));\n+\t      rtx inner = gen_lowpart (tmode, XEXP (src, 0));\n \t      struct table_elt *larger_elt;\n \n \t      if (inner)\n@@ -5216,7 +5216,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t    if (GET_CODE (larger_elt->exp) == REG)\n \t\t      {\n \t\t\tsrc_related\n-\t\t\t  = gen_lowpart_if_possible (mode, larger_elt->exp);\n+\t\t\t  = gen_lowpart (mode, larger_elt->exp);\n \t\t\tbreak;\n \t\t      }\n \n@@ -5261,7 +5261,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t   larger_elt; larger_elt = larger_elt->next_same_value)\n \t\tif (GET_CODE (larger_elt->exp) == REG)\n \t\t  {\n-\t\t    src_related = gen_lowpart_if_possible (mode,\n+\t\t    src_related = gen_lowpart (mode,\n \t\t\t\t\t\t\t   larger_elt->exp);\n \t\t    break;\n \t\t  }\n@@ -6087,8 +6087,8 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t   we are also doing (set (reg:m2 foo) (subreg:m2 (bar:m1) 0)) so\n \t   make that equivalence as well.\n \n-\t   However, BAR may have equivalences for which gen_lowpart_if_possible\n-\t   will produce a simpler value than gen_lowpart_if_possible applied to\n+\t   However, BAR may have equivalences for which gen_lowpart\n+\t   will produce a simpler value than gen_lowpart applied to\n \t   BAR (e.g., if BAR was ZERO_EXTENDed from M2), so we will scan all\n \t   BAR's equivalences.  If we don't get a simplified form, make\n \t   the SUBREG.  It will not be used in an equivalence, but will\n@@ -6433,7 +6433,7 @@ cse_process_notes (rtx x, rtx object)\n \t      && (CONSTANT_P (ent->const_rtx)\n \t\t  || GET_CODE (ent->const_rtx) == REG))\n \t    {\n-\t      rtx new = gen_lowpart_if_possible (GET_MODE (x), ent->const_rtx);\n+\t      rtx new = gen_lowpart (GET_MODE (x), ent->const_rtx);\n \t      if (new)\n \t\treturn new;\n \t    }\n@@ -6983,6 +6983,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n   constant_pool_entries_cost = 0;\n   constant_pool_entries_regcost = 0;\n   val.path_size = 0;\n+  gen_lowpart = gen_lowpart_if_possible;\n \n   init_recog ();\n   init_alias_analysis ();\n@@ -7102,6 +7103,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n   free (uid_cuid);\n   free (reg_eqv_table);\n   free (val.path);\n+  gen_lowpart = gen_lowpart_general;\n \n   return cse_jumps_altered || recorded_label_ref;\n }"}, {"sha": "df2a2369428ce3b09eb5119c539b7de7f8a8dc6f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de249d909c233761e01226009329a31197a8174/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de249d909c233761e01226009329a31197a8174/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4de249d909c233761e01226009329a31197a8174", "patch": "@@ -99,6 +99,8 @@ rtx global_rtl[GR_MAX];\n    at the beginning of each function.  */\n static GTY(()) rtx static_regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n \n+rtx (*gen_lowpart) (enum machine_mode mode, rtx x) = gen_lowpart_general;\n+\n /* We record floating-point CONST_DOUBLEs in each floating-point mode for\n    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we\n    record a copy of const[012]_rtx.  */\n@@ -1207,7 +1209,7 @@ subreg_realpart_p (rtx x)\n    If X is a MEM whose address is a QUEUED, the value may be so also.  */\n \n rtx\n-gen_lowpart (enum machine_mode mode, rtx x)\n+gen_lowpart_general (enum machine_mode mode, rtx x)\n {\n   rtx result = gen_lowpart_common (mode, x);\n "}, {"sha": "8cb4e1b2836052dc29b8704901f073a314f3a9ed", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de249d909c233761e01226009329a31197a8174/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de249d909c233761e01226009329a31197a8174/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4de249d909c233761e01226009329a31197a8174", "patch": "@@ -1476,7 +1476,9 @@ extern rtx gen_rtx_REG_offset (rtx, enum machine_mode, unsigned int, int);\n extern rtx gen_label_rtx (void);\n extern int subreg_hard_regno (rtx, int);\n extern rtx gen_lowpart_common (enum machine_mode, rtx);\n-extern rtx gen_lowpart (enum machine_mode, rtx);\n+extern rtx gen_lowpart_general (enum machine_mode, rtx);\n+extern rtx (*gen_lowpart) (enum machine_mode mode, rtx x);\n+\n \n /* In cse.c */\n extern rtx gen_lowpart_if_possible (enum machine_mode, rtx);"}]}