{"sha": "fb0703f704d02beb8d886b695fe335ebde4a2ea2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwNzAzZjcwNGQwMmJlYjhkODg2YjY5NWZlMzM1ZWJkZTRhMmVhMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-01-04T00:15:58Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-01-04T00:15:58Z"}, "message": "re PR middle-end/38586 (quadratic behaviour in find_temp_slot_from_address.)\n\n\tPR middle-end/38586\n\t* function.c (struct temp_slot): Move to the section of the file\n\tthat deals with temp slots.  Remove field 'address'.\n\t(temp_slot_address_table): New hash table of address -> temp slot.\n\t(struct temp_slot_address_entry): New struct, items for the table.\n\t(temp_slot_address_compute_hash, temp_slot_address_hash,\n\ttemp_slot_address_eq, insert_temp_slot_address): Support functions\n\tfor the new table.\n\t(find_temp_slot_from_address): Rewrite to use the new hash table.\n\t(remove_unused_temp_slot_addresses): Remove addresses of temp\n\tslots that have been made available.\n\t(remove_unused_temp_slot_addresses_1): Call-back for htab_traverse,\n\tworker function for remove_unused_temp_slot_addresses.\n\t(assign_stack_temp_for_type): Don't clear the temp slot address list.\n\tAdd the temp slot address to the address -> temp slot map.\n\t(update_temp_slot_address): Update via insert_temp_slot_address.\n\t(free_temp_slots): Call remove_unused_temp_slot_addresses.\n\t(pop_temp_slots): Likewise.\n\t(init_temp_slots): Allocate the address -> temp slot map, or empty\n\tthe map if it is already allocated.\n\t(prepare_function_start): Initialize temp slot processing.\n\nFrom-SVN: r143041", "tree": {"sha": "036cc581e08d7fcaf0a794b0ad2b240a2158cbc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/036cc581e08d7fcaf0a794b0ad2b240a2158cbc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb0703f704d02beb8d886b695fe335ebde4a2ea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0703f704d02beb8d886b695fe335ebde4a2ea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0703f704d02beb8d886b695fe335ebde4a2ea2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0703f704d02beb8d886b695fe335ebde4a2ea2/comments", "author": null, "committer": null, "parents": [{"sha": "b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a430f346093aba1cb1e28aa7f92405e68b0ccd"}], "stats": {"total": 315, "additions": 210, "deletions": 105}, "files": [{"sha": "627fcb4420a555e24459379f9e85b3d3c20746ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0703f704d02beb8d886b695fe335ebde4a2ea2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0703f704d02beb8d886b695fe335ebde4a2ea2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb0703f704d02beb8d886b695fe335ebde4a2ea2", "patch": "@@ -1,3 +1,27 @@\n+2009-01-04  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/38586\n+\t* function.c (struct temp_slot): Move to the section of the file\n+\tthat deals with temp slots.  Remove field 'address'.\n+\t(temp_slot_address_table): New hash table of address -> temp slot.\n+\t(struct temp_slot_address_entry): New struct, items for the table.\n+\t(temp_slot_address_compute_hash, temp_slot_address_hash,\n+\ttemp_slot_address_eq, insert_temp_slot_address): Support functions\n+\tfor the new table.\n+\t(find_temp_slot_from_address): Rewrite to use the new hash table.\n+\t(remove_unused_temp_slot_addresses): Remove addresses of temp\n+\tslots that have been made available.\n+\t(remove_unused_temp_slot_addresses_1): Call-back for htab_traverse,\n+\tworker function for remove_unused_temp_slot_addresses.\n+\t(assign_stack_temp_for_type): Don't clear the temp slot address list.\n+\tAdd the temp slot address to the address -> temp slot map.\n+\t(update_temp_slot_address): Update via insert_temp_slot_address.\n+\t(free_temp_slots): Call remove_unused_temp_slot_addresses.\n+\t(pop_temp_slots): Likewise.\n+\t(init_temp_slots): Allocate the address -> temp slot map, or empty\n+\tthe map if it is already allocated.\n+\t(prepare_function_start): Initialize temp slot processing.\n+\n 2009-01-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR middle-end/38584"}, {"sha": "7701042c77d286be238746fa9fba2bd5897150d5", "filename": "gcc/function.c", "status": "modified", "additions": 186, "deletions": 105, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0703f704d02beb8d886b695fe335ebde4a2ea2/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0703f704d02beb8d886b695fe335ebde4a2ea2/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=fb0703f704d02beb8d886b695fe335ebde4a2ea2", "patch": "@@ -132,61 +132,6 @@ static VEC(int,heap) *epilogue;\n    in this function.  */\n static VEC(int,heap) *sibcall_epilogue;\n \f\n-/* In order to evaluate some expressions, such as function calls returning\n-   structures in memory, we need to temporarily allocate stack locations.\n-   We record each allocated temporary in the following structure.\n-\n-   Associated with each temporary slot is a nesting level.  When we pop up\n-   one level, all temporaries associated with the previous level are freed.\n-   Normally, all temporaries are freed after the execution of the statement\n-   in which they were created.  However, if we are inside a ({...}) grouping,\n-   the result may be in a temporary and hence must be preserved.  If the\n-   result could be in a temporary, we preserve it if we can determine which\n-   one it is in.  If we cannot determine which temporary may contain the\n-   result, all temporaries are preserved.  A temporary is preserved by\n-   pretending it was allocated at the previous nesting level.\n-\n-   Automatic variables are also assigned temporary slots, at the nesting\n-   level where they are defined.  They are marked a \"kept\" so that\n-   free_temp_slots will not free them.  */\n-\n-struct temp_slot GTY(())\n-{\n-  /* Points to next temporary slot.  */\n-  struct temp_slot *next;\n-  /* Points to previous temporary slot.  */\n-  struct temp_slot *prev;\n-\n-  /* The rtx to used to reference the slot.  */\n-  rtx slot;\n-  /* The rtx used to represent the address if not the address of the\n-     slot above.  May be an EXPR_LIST if multiple addresses exist.  */\n-  rtx address;\n-  /* The alignment (in bits) of the slot.  */\n-  unsigned int align;\n-  /* The size, in units, of the slot.  */\n-  HOST_WIDE_INT size;\n-  /* The type of the object in the slot, or zero if it doesn't correspond\n-     to a type.  We use this to determine whether a slot can be reused.\n-     It can be reused if objects of the type of the new slot will always\n-     conflict with objects of the type of the old slot.  */\n-  tree type;\n-  /* Nonzero if this temporary is currently in use.  */\n-  char in_use;\n-  /* Nonzero if this temporary has its address taken.  */\n-  char addr_taken;\n-  /* Nesting level at which this slot is being used.  */\n-  int level;\n-  /* Nonzero if this should survive a call to free_temp_slots.  */\n-  int keep;\n-  /* The offset of the slot from the frame_pointer, including extra space\n-     for alignment.  This info is for combine_temp_slots.  */\n-  HOST_WIDE_INT base_offset;\n-  /* The size of the slot, including extra space for alignment.  This\n-     info is for combine_temp_slots.  */\n-  HOST_WIDE_INT full_size;\n-};\n-\f\n /* Forward declarations.  */\n \n static struct temp_slot *find_temp_slot_from_address (rtx);\n@@ -486,6 +431,70 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n   return assign_stack_local_1 (mode, size, align, false);\n }\n \f\n+\f\n+/* In order to evaluate some expressions, such as function calls returning\n+   structures in memory, we need to temporarily allocate stack locations.\n+   We record each allocated temporary in the following structure.\n+\n+   Associated with each temporary slot is a nesting level.  When we pop up\n+   one level, all temporaries associated with the previous level are freed.\n+   Normally, all temporaries are freed after the execution of the statement\n+   in which they were created.  However, if we are inside a ({...}) grouping,\n+   the result may be in a temporary and hence must be preserved.  If the\n+   result could be in a temporary, we preserve it if we can determine which\n+   one it is in.  If we cannot determine which temporary may contain the\n+   result, all temporaries are preserved.  A temporary is preserved by\n+   pretending it was allocated at the previous nesting level.\n+\n+   Automatic variables are also assigned temporary slots, at the nesting\n+   level where they are defined.  They are marked a \"kept\" so that\n+   free_temp_slots will not free them.  */\n+\n+struct temp_slot GTY(())\n+{\n+  /* Points to next temporary slot.  */\n+  struct temp_slot *next;\n+  /* Points to previous temporary slot.  */\n+  struct temp_slot *prev;\n+  /* The rtx to used to reference the slot.  */\n+  rtx slot;\n+  /* The alignment (in bits) of the slot.  */\n+  unsigned int align;\n+  /* The size, in units, of the slot.  */\n+  HOST_WIDE_INT size;\n+  /* The type of the object in the slot, or zero if it doesn't correspond\n+     to a type.  We use this to determine whether a slot can be reused.\n+     It can be reused if objects of the type of the new slot will always\n+     conflict with objects of the type of the old slot.  */\n+  tree type;\n+  /* Nonzero if this temporary is currently in use.  */\n+  char in_use;\n+  /* Nonzero if this temporary has its address taken.  */\n+  char addr_taken;\n+  /* Nesting level at which this slot is being used.  */\n+  int level;\n+  /* Nonzero if this should survive a call to free_temp_slots.  */\n+  int keep;\n+  /* The offset of the slot from the frame_pointer, including extra space\n+     for alignment.  This info is for combine_temp_slots.  */\n+  HOST_WIDE_INT base_offset;\n+  /* The size of the slot, including extra space for alignment.  This\n+     info is for combine_temp_slots.  */\n+  HOST_WIDE_INT full_size;\n+};\n+\n+/* A table of addresses that represent a stack slot.  The table is a mapping\n+   from address RTXen to a temp slot.  */\n+static GTY((param_is(struct temp_slot_address_entry))) htab_t temp_slot_address_table;\n+\n+/* Entry for the above hash table.  */\n+struct temp_slot_address_entry GTY(())\n+{\n+  hashval_t hash;\n+  rtx address;\n+  struct temp_slot *temp_slot;\n+};\n+\n /* Removes temporary slot TEMP from LIST.  */\n \n static void\n@@ -555,6 +564,114 @@ make_slot_available (struct temp_slot *temp)\n   temp->in_use = 0;\n   temp->level = -1;\n }\n+\n+/* Compute the hash value for an address -> temp slot mapping.\n+   The value is cached on the mapping entry.  */\n+static hashval_t\n+temp_slot_address_compute_hash (struct temp_slot_address_entry *t)\n+{\n+  int do_not_record = 0;\n+  return hash_rtx (t->address, GET_MODE (t->address),\n+\t\t   &do_not_record, NULL, false);\n+}\n+\n+/* Return the hash value for an address -> temp slot mapping.  */\n+static hashval_t\n+temp_slot_address_hash (const void *p)\n+{\n+  const struct temp_slot_address_entry *t;\n+  t = (const struct temp_slot_address_entry *) p;\n+  return t->hash;\n+}\n+\n+/* Compare two address -> temp slot mapping entries.  */\n+static int\n+temp_slot_address_eq (const void *p1, const void *p2)\n+{\n+  const struct temp_slot_address_entry *t1, *t2;\n+  t1 = (const struct temp_slot_address_entry *) p1;\n+  t2 = (const struct temp_slot_address_entry *) p2;\n+  return exp_equiv_p (t1->address, t2->address, 0, true);\n+}\n+\n+/* Add ADDRESS as an alias of TEMP_SLOT to the addess -> temp slot mapping.  */\n+static void\n+insert_temp_slot_address (rtx address, struct temp_slot *temp_slot)\n+{\n+  void **slot;\n+  struct temp_slot_address_entry *t = GGC_NEW (struct temp_slot_address_entry);\n+  t->address = address;\n+  t->temp_slot = temp_slot;\n+  t->hash = temp_slot_address_compute_hash (t);\n+  slot = htab_find_slot_with_hash (temp_slot_address_table, t, t->hash, INSERT);\n+  *slot = t;\n+}\n+\n+/* Remove an address -> temp slot mapping entry if the temp slot is\n+   not in use anymore.  Callback for remove_unused_temp_slot_addresses.  */\n+static int\n+remove_unused_temp_slot_addresses_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  const struct temp_slot_address_entry *t;\n+  t = (const struct temp_slot_address_entry *) *slot;\n+  if (! t->temp_slot->in_use)\n+    *slot = NULL;\n+  return 1;\n+}\n+\n+/* Remove all mappings of addresses to unused temp slots.  */\n+static void\n+remove_unused_temp_slot_addresses (void)\n+{\n+  htab_traverse (temp_slot_address_table,\n+\t\t remove_unused_temp_slot_addresses_1,\n+\t\t NULL);\n+}\n+\n+/* Find the temp slot corresponding to the object at address X.  */\n+\n+static struct temp_slot *\n+find_temp_slot_from_address (rtx x)\n+{\n+  struct temp_slot *p;\n+  struct temp_slot_address_entry tmp, *t;\n+\n+  /* First try the easy way:\n+     See if X exists in the address -> temp slot mapping.  */\n+  tmp.address = x;\n+  tmp.temp_slot = NULL;\n+  tmp.hash = temp_slot_address_compute_hash (&tmp);\n+  t = (struct temp_slot_address_entry *)\n+    htab_find_with_hash (temp_slot_address_table, &tmp, tmp.hash);\n+  if (t)\n+    return t->temp_slot;\n+\n+  /* If we have a sum involving a register, see if it points to a temp\n+     slot.  */\n+  if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 0))\n+      && (p = find_temp_slot_from_address (XEXP (x, 0))) != 0)\n+    return p;\n+  else if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 1))\n+\t   && (p = find_temp_slot_from_address (XEXP (x, 1))) != 0)\n+    return p;\n+\n+  /* Last resort: Address is a virtual stack var address.  */\n+  if (GET_CODE (x) == PLUS\n+      && XEXP (x, 0) == virtual_stack_vars_rtx\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      int i;\n+      for (i = max_slot_level (); i >= 0; i--)\n+\tfor (p = *temp_slots_at_level (i); p; p = p->next)\n+\t  {\n+\t    if (INTVAL (XEXP (x, 1)) >= p->base_offset\n+\t\t&& INTVAL (XEXP (x, 1)) < p->base_offset + p->full_size)\n+\t      return p;\n+\t  }\n+    }\n+\n+  return NULL;\n+}\n \f\n /* Allocate a temporary stack slot and record it for possible later\n    reuse.\n@@ -641,7 +758,6 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \t      p->full_size = best_p->full_size - rounded_size;\n \t      p->slot = adjust_address_nv (best_p->slot, BLKmode, rounded_size);\n \t      p->align = best_p->align;\n-\t      p->address = 0;\n \t      p->type = best_p->type;\n \t      insert_slot_to_list (p, &avail_temp_slots);\n \n@@ -700,7 +816,6 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \t  p->base_offset = frame_offset_old;\n \t  p->full_size = frame_offset - frame_offset_old;\n \t}\n-      p->address = 0;\n \n       selected = p;\n     }\n@@ -714,6 +829,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \n   pp = temp_slots_at_level (p->level);\n   insert_slot_to_list (p, pp);\n+  insert_temp_slot_address (XEXP (p->slot, 0), p);\n \n   /* Create a new MEM rtx to avoid clobbering MEM flags of old slots.  */\n   slot = gen_rtx_MEM (mode, XEXP (p->slot, 0));\n@@ -882,45 +998,6 @@ combine_temp_slots (void)\n     }\n }\n \f\n-/* Find the temp slot corresponding to the object at address X.  */\n-\n-static struct temp_slot *\n-find_temp_slot_from_address (rtx x)\n-{\n-  struct temp_slot *p;\n-  rtx next;\n-  int i;\n-\n-  for (i = max_slot_level (); i >= 0; i--)\n-    for (p = *temp_slots_at_level (i); p; p = p->next)\n-      {\n-\tif (XEXP (p->slot, 0) == x\n-\t    || p->address == x\n-\t    || (GET_CODE (x) == PLUS\n-\t\t&& XEXP (x, 0) == virtual_stack_vars_rtx\n-\t\t&& GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t\t&& INTVAL (XEXP (x, 1)) >= p->base_offset\n-\t\t&& INTVAL (XEXP (x, 1)) < p->base_offset + p->full_size))\n-\t  return p;\n-\n-\telse if (p->address != 0 && GET_CODE (p->address) == EXPR_LIST)\n-\t  for (next = p->address; next; next = XEXP (next, 1))\n-\t    if (XEXP (next, 0) == x)\n-\t      return p;\n-      }\n-\n-  /* If we have a sum involving a register, see if it points to a temp\n-     slot.  */\n-  if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 0))\n-      && (p = find_temp_slot_from_address (XEXP (x, 0))) != 0)\n-    return p;\n-  else if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 1))\n-\t   && (p = find_temp_slot_from_address (XEXP (x, 1))) != 0)\n-    return p;\n-\n-  return 0;\n-}\n-\n /* Indicate that NEW_RTX is an alternate way of referring to the temp\n    slot that previously was known by OLD_RTX.  */\n \n@@ -967,15 +1044,7 @@ update_temp_slot_address (rtx old_rtx, rtx new_rtx)\n     }\n \n   /* Otherwise add an alias for the temp's address.  */\n-  else if (p->address == 0)\n-    p->address = new_rtx;\n-  else\n-    {\n-      if (GET_CODE (p->address) != EXPR_LIST)\n-\tp->address = gen_rtx_EXPR_LIST (VOIDmode, p->address, NULL_RTX);\n-\n-      p->address = gen_rtx_EXPR_LIST (VOIDmode, new_rtx, p->address);\n-    }\n+  insert_temp_slot_address (new_rtx, p);\n }\n \n /* If X could be a reference to a temporary slot, mark the fact that its\n@@ -1103,6 +1172,7 @@ free_temp_slots (void)\n \tmake_slot_available (p);\n     }\n \n+  remove_unused_temp_slot_addresses ();\n   combine_temp_slots ();\n }\n \n@@ -1128,6 +1198,7 @@ pop_temp_slots (void)\n       make_slot_available (p);\n     }\n \n+  remove_unused_temp_slot_addresses ();\n   combine_temp_slots ();\n \n   temp_slot_level--;\n@@ -1142,6 +1213,15 @@ init_temp_slots (void)\n   avail_temp_slots = 0;\n   used_temp_slots = 0;\n   temp_slot_level = 0;\n+\n+  /* Set up the table to map addresses to temp slots.  */\n+  if (! temp_slot_address_table)\n+    temp_slot_address_table = htab_create_ggc (32,\n+\t\t\t\t\t       temp_slot_address_hash,\n+\t\t\t\t\t       temp_slot_address_eq,\n+\t\t\t\t\t       NULL);\n+  else\n+    htab_empty (temp_slot_address_table);\n }\n \f\n /* These routines are responsible for converting virtual register references\n@@ -4035,6 +4115,7 @@ static void\n prepare_function_start (void)\n {\n   gcc_assert (!crtl->emit.x_last_insn);\n+  init_temp_slots ();\n   init_emit ();\n   init_varasm_status ();\n   init_expr ();"}]}