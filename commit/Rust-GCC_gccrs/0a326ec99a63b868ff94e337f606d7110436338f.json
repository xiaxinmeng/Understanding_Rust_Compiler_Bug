{"sha": "0a326ec99a63b868ff94e337f606d7110436338f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEzMjZlYzk5YTYzYjg2OGZmOTRlMzM3ZjYwNmQ3MTEwNDM2MzM4Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-12-14T12:34:54Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-12-14T12:34:54Z"}, "message": "Run reg_scan_update to get information about regs created by loop.\n\nFrom-SVN: r30914", "tree": {"sha": "77120b099cd76a75c000ef63fcd14f109b761f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77120b099cd76a75c000ef63fcd14f109b761f20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a326ec99a63b868ff94e337f606d7110436338f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a326ec99a63b868ff94e337f606d7110436338f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a326ec99a63b868ff94e337f606d7110436338f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a326ec99a63b868ff94e337f606d7110436338f/comments", "author": null, "committer": null, "parents": [{"sha": "0dc0641b044cdb525118e4ca1358f95d9930e3d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc0641b044cdb525118e4ca1358f95d9930e3d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc0641b044cdb525118e4ca1358f95d9930e3d9"}], "stats": {"total": 28, "additions": 26, "deletions": 2}, "files": [{"sha": "91bb220223661c108001e3dab53fdc7b8e964372", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a326ec99a63b868ff94e337f606d7110436338f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a326ec99a63b868ff94e337f606d7110436338f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a326ec99a63b868ff94e337f606d7110436338f", "patch": "@@ -1,3 +1,11 @@\n+1999-12-14  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* loop.c (loop_max_reg): New static variable.\n+\t(loop_optimize): Initialize it.  Eliminate one unnecessary call to\n+\tmax_reg_num.\n+\t(scan_loop): Call reg_scan_update whenever we may have added new\n+\tregisters, and update loop_max_reg.\n+\n Tue Dec 14 12:07:29 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n \t* regclass.c  (record_reg_classes): Do not do the copying preferrencing"}, {"sha": "81b77ae8234162fb5682728b87b5252cbbbf9a06", "filename": "gcc/loop.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a326ec99a63b868ff94e337f606d7110436338f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a326ec99a63b868ff94e337f606d7110436338f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=0a326ec99a63b868ff94e337f606d7110436338f", "patch": "@@ -213,6 +213,9 @@ static int num_mem_sets;\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n int max_reg_before_loop;\n \n+/* The value to pass to the next call of reg_scan_update.  */\n+static int loop_max_reg;\n+\n /* This obstack is used in product_cheap_p to allocate its rtl.  It\n    may call gen_reg_rtx which, in turn, may reallocate regno_reg_rtx.\n    If we used the same obstack that it did, we would be deallocating\n@@ -467,6 +470,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   init_recog_no_volatile ();\n \n   max_reg_before_loop = max_reg_num ();\n+  loop_max_reg = max_reg_before_loop;\n \n   regs_may_share = 0;\n \n@@ -516,7 +520,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   /* Now find all register lifetimes.  This must be done after\n      find_and_verify_loops, because it might reorder the insns in the\n      function.  */\n-  reg_scan (f, max_reg_num (), 1);\n+  reg_scan (f, max_reg_before_loop, 1);\n \n   /* This must occur after reg_scan so that registers created by gcse\n      will have entries in the register tables.\n@@ -660,7 +664,7 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   int insn_count;\n   int in_libcall = 0;\n   int tem;\n-  rtx temp;\n+  rtx temp, update_start, update_end;\n   /* The SET from an insn, if it is the only SET in the insn.  */\n   rtx set, set1;\n   /* Chain describing insns movable in current loop.  */\n@@ -1178,12 +1182,24 @@ scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n   load_mems_and_recount_loop_regs_set (scan_start, end, loop_top,\n \t\t\t\t       loop_start, &insn_count);\n \n+  for (update_start = loop_start;\n+       PREV_INSN (update_start) && GET_CODE (PREV_INSN (update_start)) != CODE_LABEL;\n+       update_start = PREV_INSN (update_start))\n+    ;\n+  update_end = NEXT_INSN (end);\n+\n+  reg_scan_update (update_start, update_end, loop_max_reg);\n+  loop_max_reg = max_reg_num ();\n+\n   if (flag_strength_reduce)\n     {\n       the_movables = movables;\n       strength_reduce (scan_start, end, loop_top,\n \t\t       insn_count, loop_start, end,\n \t\t       loop_info, loop_cont, unroll_p, bct_p);\n+\n+      reg_scan_update (update_start, update_end, loop_max_reg);\n+      loop_max_reg = max_reg_num ();\n     }\n \n   VARRAY_FREE (reg_single_usage);"}]}