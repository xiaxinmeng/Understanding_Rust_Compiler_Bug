{"sha": "7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1NmZhM2U2M2YzZDBmN2U1N2RiMWFlYmNiYjFjODBjMTJhZDQ0YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-11-20T16:22:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-11-20T16:22:19Z"}, "message": "re PR ipa/87957 (ICE tree check: expected tree that contains \u2018decl minimal\u2019 structure, have \u2018identifier_node\u2019 in warn_odr, at ipa-devirt.c:1051 since r265519)\n\n\n\tPR lto/87957\n\t* ipa-devirt.c (odr_subtypes_equivalent_p): Report ODR violation\n\twhen sybtype already violates ODR.\n\t(get_odr_type): Do not ICE when insert is false and type duplicate\n\tis not registered yet.\n\t(register_odr_type): Be sure to register subtypes first.\n\nFrom-SVN: r266322", "tree": {"sha": "f42788f9966e44cdf0e9ca812e03b82c726f265a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f42788f9966e44cdf0e9ca812e03b82c726f265a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a/comments", "author": null, "committer": null, "parents": [{"sha": "33f3393ab5cc809f2636cc3ce86b3032177c91b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f3393ab5cc809f2636cc3ce86b3032177c91b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f3393ab5cc809f2636cc3ce86b3032177c91b8"}], "stats": {"total": 53, "additions": 47, "deletions": 6}, "files": [{"sha": "d0849d6e5c9524e9d7993da0f03eb28f5816c037", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a", "patch": "@@ -1,3 +1,12 @@\n+2018-11-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/87957\n+\t* ipa-devirt.c (odr_subtypes_equivalent_p): Report ODR violation\n+\twhen sybtype already violates ODR.\n+\t(get_odr_type): Do not ICE when insert is false and type duplicate\n+\tis not registered yet.\n+\t(register_odr_type): Be sure to register subtypes first.\n+\n 2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* config/s390/s390.md (\"clztidi2\"): Swap the RTX's written to the\n@@ -26,7 +35,8 @@\n \t(symbol_table::remove_unreachable_nodes): Likewise.\n \t* passes.c (pass_data_ipa_remove_symbols): New structure.\n \t(pass_ipa_remove_symbols): New pass.\n-\t(make_pass_ipa_remove_symbols): New functoin.\n+\t(make_pass_ipa_remove_symbols): New function.\n+\t* tree-pass.h (make_pass_ipa_remove_symbols): Declare.\n \t* passes.def (pass_ipa_remove_symbols): Schedule after early passes.\n \n 2018-11-20  Richard Biener  <rguenther@suse.de>"}, {"sha": "cbc0eec33fdac94373d35c739ba303d7abd7219c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=7656fa3e63f3d0f7e57db1aebcbb1c80c12ad44a", "patch": "@@ -692,14 +692,17 @@ odr_subtypes_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n      and other ODR even though it is a violation.  */\n   if (types_odr_comparable (t1, t2))\n     {\n+      if (t1 != t2\n+\t  && odr_type_p (TYPE_MAIN_VARIANT (t1))\n+\t  && get_odr_type (TYPE_MAIN_VARIANT (t1), true)->odr_violated)\n+\treturn false;\n       if (!types_same_for_odr (t1, t2))\n         return false;\n       if (!type_variants_equivalent_p (t1, t2, warn, warned))\n \treturn false;\n       /* Limit recursion: If subtypes are ODR types and we know\n \t that they are same, be happy.  */\n-      if (!odr_type_p (TYPE_MAIN_VARIANT (t1))\n-\t  || !get_odr_type (TYPE_MAIN_VARIANT (t1), true)->odr_violated)\n+      if (odr_type_p (TYPE_MAIN_VARIANT (t1)))\n         return true;\n     }\n \n@@ -2047,10 +2050,9 @@ get_odr_type (tree type, bool insert)\n       else if (*vtable_slot)\n \tval = *vtable_slot;\n \n-      if (val->type != type\n+      if (val->type != type && insert\n \t  && (!val->types_set || !val->types_set->add (type)))\n \t{\n-\t  gcc_assert (insert);\n \t  /* We have type duplicate, but it may introduce vtable name or\n  \t     mangled name; be sure to keep hashes in sync.  */\n \t  if (in_lto_p && can_be_vtable_hashed_p (type)\n@@ -2144,7 +2146,36 @@ register_odr_type (tree type)\n         odr_vtable_hash = new odr_vtable_hash_type (23);\n     }\n   if (type == TYPE_MAIN_VARIANT (type))\n-    get_odr_type (type, true);\n+    {\n+      /* To get ODR warings right, first register all sub-types.  */\n+      if (RECORD_OR_UNION_TYPE_P (type)\n+\t  && COMPLETE_TYPE_P (type))\n+\t{\n+\t  /* Limit recursion on types which are already registered.  */\n+\t  odr_type ot = get_odr_type (type, false);\n+\t  if (ot\n+\t      && (ot->type == type\n+\t\t  || (ot->types_set\n+\t\t      && ot->types_set->contains (type))))\n+\t    return;\n+\t  for (tree f = TYPE_FIELDS (type); f; f = TREE_CHAIN (f))\n+\t    if (TREE_CODE (f) == FIELD_DECL)\n+\t      {\n+\t\ttree subtype = TREE_TYPE (f);\n+\n+\t\twhile (TREE_CODE (subtype) == ARRAY_TYPE)\n+\t\t  subtype = TREE_TYPE (subtype);\n+\t\tif (type_with_linkage_p (TYPE_MAIN_VARIANT (subtype)))\n+\t\t  register_odr_type (TYPE_MAIN_VARIANT (subtype));\n+\t      }\n+\t   if (TYPE_BINFO (type))\n+\t     for (unsigned int i = 0;\n+\t          i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\t       register_odr_type (BINFO_TYPE (BINFO_BASE_BINFO\n+\t\t\t\t\t\t (TYPE_BINFO (type), i)));\n+\t}\n+      get_odr_type (type, true);\n+    }\n }\n \n /* Return true if type is known to have no derivations.  */"}]}