{"sha": "7551a9957437f20254be41d396962b9ccc46cee6", "node_id": "C_kwDOANBUbNoAKDc1NTFhOTk1NzQzN2YyMDI1NGJlNDFkMzk2OTYyYjljY2M0NmNlZTY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-03T13:51:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T09:36:09Z"}, "message": "libstdc++: Fix handling of const types in std::variant [PR102912]\n\nPrior to r12-4447 (implementing P2231R1 constexpr changes) we didn't\nconstruct the correct member of the union in __variant_construct_single,\nwe just plopped an object in the memory occupied by the union:\n\n  void* __storage = std::addressof(__lhs._M_u);\n  using _Type = remove_reference_t<decltype(__rhs_mem)>;\n  ::new (__storage) _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));\n\nWe didn't care whether we had variant<int, const int>, we would just\nplace an int (or const int) into the storage, and then set the _M_index\nto say which one it was.\n\nIn the new constexpr-friendly code we use std::construct_at to construct\nthe union object, which constructs the active member of the right type.\nBut now we need to know exactly the right type. We have to distinguish\nbetween alternatives of type int and const int, and we have to be able\nto find a const int (or const std::string, as in the OP) among the\nalternatives. So my change from remove_reference_t<decltype(__rhs_mem)>\nto remove_cvref_t<_Up> was wrong. It strips the const from const int,\nand then we can't find the index of the const int alternative.\n\nBut just using remove_reference_t doesn't work either. When the copy\nassignment operator of std::variant<int> uses __variant_construct_single\nit passes a const int& as __rhs_mem, but if we don't strip the const\nthen we try to find const int among the alternatives, and *that* fails.\nSimilarly for the copy constructor, which also uses a const int& as the\ninitializer for a non-const int alternative.\n\nThe root cause of the problem is that __variant_construct_single doesn't\nknow the index of the type it's supposed to construct, and the new\n_Variant_storage::__index_of<_Type> helper doesn't work if __rhs_mem and\nthe alternative being constructed have different const-qualification. We\nneed to replace __variant_construct_single with something that knows the\nindex of the alternative being constructed. All uses of that function do\nactually know the index, but that context is lost by the time we call\n__variant_construct_single. This patch replaces that function and\n__variant_construct, inlining their effects directly into the callers.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/102912\n\t* include/std/variant (_Variant_storage::__index_of): Remove.\n\t(__variant_construct_single): Remove.\n\t(__variant_construct): Remove.\n\t(_Copy_ctor_base::_Copy_ctor_base(const _Copy_ctor_base&)): Do\n\tconstruction directly instead of using __variant_construct.\n\t(_Move_ctor_base::_Move_ctor_base(_Move_ctor_base&&)): Likewise.\n\t(_Move_ctor_base::_M_destructive_move()): Remove.\n\t(_Move_ctor_base::_M_destructive_copy()): Remove.\n\t(_Copy_assign_base::operator=(const _Copy_assign_base&)): Do\n\tconstruction directly instead of using _M_destructive_copy.\n\t(variant::swap): Do construction directly instead of using\n\t_M_destructive_move.\n\t* testsuite/20_util/variant/102912.cc: New test.", "tree": {"sha": "05193da8c50149f1d6c44cb141a75e2c3c364532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05193da8c50149f1d6c44cb141a75e2c3c364532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7551a9957437f20254be41d396962b9ccc46cee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551a9957437f20254be41d396962b9ccc46cee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7551a9957437f20254be41d396962b9ccc46cee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551a9957437f20254be41d396962b9ccc46cee6/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa62db42b99e9eb1c067d2171bc437b3394e4d5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa62db42b99e9eb1c067d2171bc437b3394e4d5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa62db42b99e9eb1c067d2171bc437b3394e4d5d"}], "stats": {"total": 202, "additions": 114, "deletions": 88}, "files": [{"sha": "63468af7012fe84b65114f53f92e2f319a9af96c", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 43, "deletions": 88, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551a9957437f20254be41d396962b9ccc46cee6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551a9957437f20254be41d396962b9ccc46cee6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=7551a9957437f20254be41d396962b9ccc46cee6", "patch": "@@ -467,10 +467,6 @@ namespace __variant\n   template<typename... _Types>\n     struct _Variant_storage<false, _Types...>\n     {\n-      template<typename _Tp>\n-\tstatic constexpr size_t __index_of\n-\t  = __detail::__variant::__index_of_v<_Tp, _Types...>;\n-\n       constexpr\n       _Variant_storage()\n       : _M_index(static_cast<__index_type>(variant_npos))\n@@ -517,10 +513,6 @@ namespace __variant\n   template<typename... _Types>\n     struct _Variant_storage<true, _Types...>\n     {\n-      template<typename _Tp>\n-\tstatic constexpr size_t __index_of\n-\t  = __detail::__variant::__index_of_v<_Tp, _Types...>;\n-\n       constexpr\n       _Variant_storage()\n       : _M_index(static_cast<__index_type>(variant_npos))\n@@ -560,35 +552,6 @@ namespace __variant\n     using _Variant_storage_alias =\n \t_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;\n \n-  template<typename _Tp, typename _Up>\n-    _GLIBCXX20_CONSTEXPR\n-    void\n-    __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)\n-    {\n-      using _Type = __remove_cvref_t<_Up>;\n-\n-      if constexpr (!is_same_v<_Type, __variant_cookie>)\n-\t{\n-\t  using _Lhs = remove_reference_t<_Tp>;\n-\t  std::_Construct(std::__addressof(__lhs._M_u),\n-\t\t\t  in_place_index<_Lhs::template __index_of<_Type>>,\n-\t\t\t  std::forward<_Up>(__rhs_mem));\n-\t}\n-    }\n-\n-  template<typename... _Types, typename _Tp, typename _Up>\n-    _GLIBCXX20_CONSTEXPR\n-    void\n-    __variant_construct(_Tp&& __lhs, _Up&& __rhs)\n-    {\n-      __lhs._M_index = __rhs._M_index;\n-      __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable\n-        {\n-\t  __variant_construct_single(std::forward<_Tp>(__lhs),\n-\t      std::forward<decltype(__rhs_mem)>(__rhs_mem));\n-\t}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));\n-    }\n-\n   // The following are (Copy|Move) (ctor|assign) layers for forwarding\n   // triviality and handling non-trivial SMF behaviors.\n \n@@ -602,7 +565,15 @@ namespace __variant\n       _Copy_ctor_base(const _Copy_ctor_base& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)\n       {\n-\t__variant_construct<_Types...>(*this, __rhs);\n+\t__variant::__raw_idx_visit(\n+\t  [this](auto&& __rhs_mem, auto __rhs_index) mutable\n+\t  {\n+\t    constexpr size_t __j = __rhs_index;\n+\t    if constexpr (__j != variant_npos)\n+\t      std::_Construct(std::__addressof(this->_M_u),\n+\t\t\t      in_place_index<__j>, __rhs_mem);\n+\t  }, __variant_cast<_Types...>(__rhs));\n+\tthis->_M_index = __rhs._M_index;\n       }\n \n       _Copy_ctor_base(_Copy_ctor_base&&) = default;\n@@ -631,27 +602,17 @@ namespace __variant\n       _Move_ctor_base(_Move_ctor_base&& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)\n       {\n-\t__variant_construct<_Types...>(*this, std::move(__rhs));\n+\t__variant::__raw_idx_visit(\n+\t  [this](auto&& __rhs_mem, auto __rhs_index) mutable\n+\t  {\n+\t    constexpr size_t __j = __rhs_index;\n+\t    if constexpr (__j != variant_npos)\n+\t      std::_Construct(std::__addressof(this->_M_u),\n+\t\t\t      in_place_index<__j>,\n+\t\t\t      std::forward<decltype(__rhs_mem)>(__rhs_mem));\n+\t  }, __variant_cast<_Types...>(std::move(__rhs)));\n+\tthis->_M_index = __rhs._M_index;\n       }\n-\n-      template<typename _Up>\n-\t_GLIBCXX20_CONSTEXPR\n-        void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)\n-        {\n-\t  this->_M_reset();\n-\t  __variant_construct_single(*this, std::forward<_Up>(__rhs));\n-\t  this->_M_index = __rhs_index;\n-\t}\n-\n-      template<typename _Up>\n-\t_GLIBCXX20_CONSTEXPR\n-        void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)\n-        {\n-\t  this->_M_reset();\n-\t  __variant_construct_single(*this, __rhs);\n-\t  this->_M_index = __rhs_index;\n-\t}\n-\n       _Move_ctor_base(const _Move_ctor_base&) = default;\n       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;\n       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;\n@@ -662,24 +623,6 @@ namespace __variant\n     {\n       using _Base = _Copy_ctor_alias<_Types...>;\n       using _Base::_Base;\n-\n-      template<typename _Up>\n-\t_GLIBCXX20_CONSTEXPR\n-        void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)\n-        {\n-\t  this->_M_reset();\n-\t  __variant_construct_single(*this, std::forward<_Up>(__rhs));\n-\t  this->_M_index = __rhs_index;\n-\t}\n-\n-      template<typename _Up>\n-\t_GLIBCXX20_CONSTEXPR\n-        void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)\n-        {\n-\t  this->_M_reset();\n-\t  __variant_construct_single(*this, __rhs);\n-\t  this->_M_index = __rhs_index;\n-\t}\n     };\n \n   template<typename... _Types>\n@@ -709,14 +652,19 @@ namespace __variant\n \t\t    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;\n \t\t    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>\n \t\t\t|| !is_nothrow_move_constructible_v<__rhs_type>)\n-\t\t      // The standard says this->emplace<__rhs_type>(__rhs_mem)\n-\t\t      // should be used here, but _M_destructive_copy is\n-\t\t      // equivalent in this case. Either copy construction\n-\t\t      // doesn't throw, so _M_destructive_copy gives strong\n-\t\t      // exception safety guarantee, or both copy construction\n-\t\t      // and move construction can throw, so emplace only gives\n-\t\t      // basic exception safety anyway.\n-\t\t      this->_M_destructive_copy(__rhs_index, __rhs_mem);\n+\t\t      {\n+\t\t\t// The standard says emplace<__rhs_index>(__rhs_mem)\n+\t\t\t// should be used here, but this is equivalent. Either\n+\t\t\t// copy construction doesn't throw, so we have strong\n+\t\t\t// exception safety guarantee, or both copy construction\n+\t\t\t// and move construction can throw, so emplace only\n+\t\t\t// gives basic exception safety anyway.\n+\t\t\tthis->_M_reset();\n+\t\t\tstd::_Construct(std::__addressof(this->_M_u),\n+\t\t\t\t\tin_place_index<__rhs_index>,\n+\t\t\t\t\t__rhs_mem);\n+\t\t\tthis->_M_index = __rhs_index;\n+\t\t      }\n \t\t    else\n \t\t      __variant_cast<_Types...>(*this)\n \t\t\t= variant<_Types...>(std::in_place_index<__rhs_index>,\n@@ -1715,17 +1663,24 @@ namespace __variant\n \t\t  }\n \t\telse\n \t\t  {\n+\t\t    constexpr size_t __j = __rhs_index;\n \t\t    if (!this->valueless_by_exception()) [[__likely__]]\n \t\t      {\n \t\t\tauto __tmp(std::move(__rhs_mem));\n \t\t\t__rhs = std::move(*this);\n-\t\t\tthis->_M_destructive_move(__rhs_index,\n-\t\t\t\t\t\t  std::move(__tmp));\n+\t\t\tthis->_M_reset();\n+\t\t\tstd::_Construct(std::__addressof(this->_M_u),\n+\t\t\t\t\tin_place_index<__j>,\n+\t\t\t\t\tstd::move(__tmp));\n+\t\t\tthis->_M_index = __j;\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tthis->_M_destructive_move(__rhs_index,\n-\t\t\t\t\t\t  std::move(__rhs_mem));\n+\t\t\tthis->_M_reset();\n+\t\t\tstd::_Construct(std::__addressof(this->_M_u),\n+\t\t\t\t\tin_place_index<__j>,\n+\t\t\t\t\tstd::move(__rhs_mem));\n+\t\t\tthis->_M_index = __j;\n \t\t\t__rhs._M_reset();\n \t\t      }\n \t\t  }"}, {"sha": "0dea138c5ba153bcf8422270dda1aa8a57723e75", "filename": "libstdc++-v3/testsuite/20_util/variant/102912.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7551a9957437f20254be41d396962b9ccc46cee6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2F102912.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7551a9957437f20254be41d396962b9ccc46cee6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2F102912.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2F102912.cc?ref=7551a9957437f20254be41d396962b9ccc46cee6", "patch": "@@ -0,0 +1,71 @@\n+// { dg-do compile { target c++17 } }\n+#include <variant>\n+\n+void\n+test01()\n+{\n+  struct X {\n+    ~X() { } // non-trivial\n+  };\n+\n+  std::variant<const int, const X> v;\n+  auto vv = v;\n+}\n+\n+#if __cpp_lib_variant >= 202106L // P2231R1 constexpr destruction in variant\n+constexpr bool\n+test02()\n+{\n+  struct Y {\n+    constexpr ~Y() { } // non-trivial\n+  };\n+  using V = std::variant<int, const int, const Y, Y>;\n+\n+  V v1(std::in_place_index<1>, 1);\n+  V vv1 = v1;\n+  if (vv1.index() != v1.index())\n+    return false;\n+\n+  V v2(std::in_place_index<2>);\n+  V vv2 = v2;\n+  if (vv2.index() != v2.index())\n+    return false;\n+\n+  return true;\n+}\n+static_assert( test02() );\n+\n+constexpr bool\n+test03()\n+{\n+  struct Y {\n+    constexpr ~Y() { } // non-trivial\n+  };\n+  using V = std::variant<int, int, Y, Y>;\n+\n+  V v1(std::in_place_index<1>, 1);\n+  V vv1 = v1;\n+  if (vv1.index() != v1.index())\n+    return false;\n+  vv1 = v1;\n+  if (vv1.index() != v1.index())\n+    return false;\n+  vv1 = std::move(v1);\n+  if (vv1.index() != v1.index())\n+    return false;\n+\n+  V v2(std::in_place_index<2>);\n+  V vv2 = v2;\n+  if (vv2.index() != v2.index())\n+    return false;\n+  vv2 = v2;\n+  if (vv2.index() != v2.index())\n+    return false;\n+  vv2 = std::move(v2);\n+  if (vv2.index() != v2.index())\n+    return false;\n+\n+  return true;\n+}\n+static_assert( test03() );\n+#endif"}]}