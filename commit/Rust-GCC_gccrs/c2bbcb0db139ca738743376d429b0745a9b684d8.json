{"sha": "c2bbcb0db139ca738743376d429b0745a9b684d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiYmNiMGRiMTM5Y2E3Mzg3NDMzNzZkNDI5YjA3NDVhOWI2ODRkOA==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2011-06-08T03:54:05Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2011-06-08T03:54:05Z"}, "message": "sh.c (prepare_move_operands): Set pic register appropriately for global and local dynamic tls models even if...\n\n\t* config/sh/sh.c (prepare_move_operands): Set pic register\n\tappropriately for global and local dynamic tls models even\n\tif flag_pic is unset.\n\nFrom-SVN: r174792", "tree": {"sha": "4bb094ccc3fb252dd601d079e9430762d427cff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bb094ccc3fb252dd601d079e9430762d427cff3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2bbcb0db139ca738743376d429b0745a9b684d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bbcb0db139ca738743376d429b0745a9b684d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2bbcb0db139ca738743376d429b0745a9b684d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2bbcb0db139ca738743376d429b0745a9b684d8/comments", "author": null, "committer": null, "parents": [{"sha": "7c172073f5d26544486548d61aa1e8a48c073eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c172073f5d26544486548d61aa1e8a48c073eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c172073f5d26544486548d61aa1e8a48c073eed"}], "stats": {"total": 38, "additions": 25, "deletions": 13}, "files": [{"sha": "ff7cd0bbddfce7f45a4c68fd6e5e8a1d3af75fb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bbcb0db139ca738743376d429b0745a9b684d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bbcb0db139ca738743376d429b0745a9b684d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2bbcb0db139ca738743376d429b0745a9b684d8", "patch": "@@ -1,3 +1,9 @@\n+2011-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (prepare_move_operands): Set pic register\n+\tappropriately for global and local dynamic tls models even\n+\tif flag_pic is unset.\n+\n 2011-06-07  Jason Merrill  <jason@redhat.com>\n \n \t* pretty-print.h (ATTRIBUTE_GCC_PPDIAG): Use GCC_DIAG_STYLE if set."}, {"sha": "f81172545a4dd4c0cda911d6b4c70522c8c1a66d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2bbcb0db139ca738743376d429b0745a9b684d8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2bbcb0db139ca738743376d429b0745a9b684d8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c2bbcb0db139ca738743376d429b0745a9b684d8", "patch": "@@ -1844,12 +1844,30 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t{\n \t  rtx tga_op1, tga_ret, tmp, tmp2;\n \n+\t  if (! flag_pic\n+\t      && (tls_kind == TLS_MODEL_GLOBAL_DYNAMIC\n+\t\t  || tls_kind == TLS_MODEL_LOCAL_DYNAMIC\n+\t\t  || tls_kind == TLS_MODEL_INITIAL_EXEC))\n+\t    {\n+\t      /* Don't schedule insns for getting GOT address when\n+\t\t the first scheduling is enabled, to avoid spill\n+\t\t failures for R0.  */\n+\t      if (flag_schedule_insns)\n+\t\temit_insn (gen_blockage ());\n+\t      emit_insn (gen_GOTaddr2picreg ());\n+\t      emit_use (gen_rtx_REG (SImode, PIC_REG));\n+\t      if (flag_schedule_insns)\n+\t\temit_insn (gen_blockage ());\n+\t}\n+\n \t  switch (tls_kind)\n \t    {\n \t    case TLS_MODEL_GLOBAL_DYNAMIC:\n \t      tga_ret = gen_rtx_REG (Pmode, R0_REG);\n \t      emit_call_insn (gen_tls_global_dynamic (tga_ret, op1));\n-\t      op1 = tga_ret;\n+\t      tmp = gen_reg_rtx (Pmode);\n+\t      emit_move_insn (tmp, tga_ret);\n+\t      op1 = tmp;\n \t      break;\n \n \t    case TLS_MODEL_LOCAL_DYNAMIC:\n@@ -1869,18 +1887,6 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t      break;\n \n \t    case TLS_MODEL_INITIAL_EXEC:\n-\t      if (! flag_pic)\n-\t\t{\n-\t\t  /* Don't schedule insns for getting GOT address when\n-\t\t     the first scheduling is enabled, to avoid spill\n-\t\t     failures for R0.  */\n-\t\t  if (flag_schedule_insns)\n-\t\t    emit_insn (gen_blockage ());\n-\t\t  emit_insn (gen_GOTaddr2picreg ());\n-\t\t  emit_use (gen_rtx_REG (SImode, PIC_REG));\n-\t\t  if (flag_schedule_insns)\n-\t\t    emit_insn (gen_blockage ());\n-\t\t}\n \t      tga_op1 = !can_create_pseudo_p () ? op0 : gen_reg_rtx (Pmode);\n \t      tmp = gen_sym2GOTTPOFF (op1);\n \t      emit_insn (gen_tls_initial_exec (tga_op1, tmp));"}]}