{"sha": "71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFiN2JlMzhjM2YxZDUwY2EwMDRiM2FhMWMyMWUyMDZkNTk1YzY3Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@stanford.edu", "date": "2001-03-02T00:40:00Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-03-02T00:40:00Z"}, "message": "stringpool.c (set_identifier): New function.\n\n\t* stringpool.c (set_identifier): New function.\n\t* tree.h: Prototype it.\n\n\t* c-parse.in: Kill D_YES. If compiled for objc, call\n\tsave_and_forget_protocol_qualifiers from init_reswords.\n\t* objc/objc-act.c (remember_protocol_qualifiers,\n\tforget_protocol_qualifiers): Don't diddle C_IS_RESERVED_WORD.\n\tSwap out the non-keyword IDENTIFIER_NODEs for keyword ones, or\n\tvice versa.\n\t(save_and_forget_protocol_qualifiers): New function.\n\t* c-lex.h: Prototype save_and_forget_protocol_qualifiers.\n\nFrom-SVN: r40170", "tree": {"sha": "b9429823f84096cf8932b11e6e31c6dd708dab5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9429823f84096cf8932b11e6e31c6dd708dab5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/comments", "author": null, "committer": null, "parents": [{"sha": "5aa709ad7e1cb28ae54dea521a5ca6cbf1fe6016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa709ad7e1cb28ae54dea521a5ca6cbf1fe6016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa709ad7e1cb28ae54dea521a5ca6cbf1fe6016"}], "stats": {"total": 110, "additions": 84, "deletions": 26}, "files": [{"sha": "637efd3e5a17953c0edb5b22ae7cf1ea7be7d8ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "patch": "@@ -1,3 +1,17 @@\n+2001-03-01  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* stringpool.c (set_identifier): New function.\n+\t* tree.h: Prototype it.\n+\n+\t* c-parse.in: Kill D_YES. If compiled for objc, call\n+\tsave_and_forget_protocol_qualifiers from init_reswords.\n+\t* objc/objc-act.c (remember_protocol_qualifiers,\n+\tforget_protocol_qualifiers): Don't diddle C_IS_RESERVED_WORD.\n+\tSwap out the non-keyword IDENTIFIER_NODEs for keyword ones, or\n+\tvice versa.\n+\t(save_and_forget_protocol_qualifiers): New function.\n+\t* c-lex.h: Prototype save_and_forget_protocol_qualifiers.\n+\n 2001-03-01  Diego Novillo  <dnovillo@redhat.com>\n \n \t* c-semantics.c (prune_unused_decls): Return error_mark_node"}, {"sha": "bd25a16662a002097205247c62761a83a17f2f3b", "filename": "gcc/c-lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fc-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fc-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.h?ref=71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "patch": "@@ -27,6 +27,7 @@ extern void position_after_white_space PARAMS ((void));\n extern int c_lex PARAMS ((tree *));\n extern const char *init_c_lex PARAMS ((const char *));\n \n+extern void save_and_forget_protocol_qualifiers PARAMS ((void));\n extern void forget_protocol_qualifiers PARAMS ((void));\n extern void remember_protocol_qualifiers PARAMS ((void));\n extern tree is_class_name PARAMS ((tree));"}, {"sha": "ea59e739dd373aef259d965d9fd9feecd142b0a3", "filename": "gcc/c-parse.in", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "patch": "@@ -2878,7 +2878,6 @@ struct resword\n #define D_EXT\t0x04\t/* GCC extension */\n #define D_EXT89\t0x08\t/* GCC extension incorporated in C99 */\n #define D_OBJC\t0x10\t/* Objective C only */\n-#define D_YES\t0x20\t/* always starts disabled */\n \n static const struct resword reswords[] =\n {\n@@ -2971,12 +2970,12 @@ ifobjc\n   { \"@public\",\t\tRID_AT_PUBLIC,\t\tD_OBJC },\n   { \"@selector\",\tRID_AT_SELECTOR,\tD_OBJC },\n   { \"id\",\t\tRID_ID,\t\t\tD_OBJC },\n-  { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC|D_YES },\n-  { \"byref\",\t\tRID_BYREF,\t\tD_OBJC|D_YES },\n-  { \"in\",\t\tRID_IN,\t\t\tD_OBJC|D_YES },\n-  { \"inout\",\t\tRID_INOUT,\t\tD_OBJC|D_YES },\n-  { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC|D_YES },\n-  { \"out\",\t\tRID_OUT,\t\tD_OBJC|D_YES },\n+  { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC },\n+  { \"byref\",\t\tRID_BYREF,\t\tD_OBJC },\n+  { \"in\",\t\tRID_IN,\t\t\tD_OBJC },\n+  { \"inout\",\t\tRID_INOUT,\t\tD_OBJC },\n+  { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC },\n+  { \"out\",\t\tRID_OUT,\t\tD_OBJC },\n end ifobjc\n };\n #define N_reswords (sizeof reswords / sizeof (struct resword))\n@@ -3138,14 +3137,12 @@ init_reswords ()\n \n       id = get_identifier (reswords[i].word);\n       C_RID_CODE (id) = reswords[i].rid;\n+      C_IS_RESERVED_WORD (id) = 1;\n       ridpointers [(int) reswords[i].rid] = id;\n-\n-      /* Objective C does tricky things with enabling and disabling \n-\t keywords.  So these we must not elide in the test above, but\n-\t wait and not mark them reserved now.  */\n-      if (! (reswords[i].disable & D_YES))\n-\tC_IS_RESERVED_WORD (id) = 1;\n     }\n+ifobjc\n+  save_and_forget_protocol_qualifiers ();\n+end ifobjc\n }\n \n const char *"}, {"sha": "f5f27ad803866e5fe7198e130834f107ee2d9359", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "patch": "@@ -8590,25 +8590,45 @@ lookup_objc_ivar (id)\n     return 0;\n }\n \n-/* Parser callbacks.  */\n+/* Parser callbacks.\n+   Some ObjC keywords are reserved only in a particular context:\n+   in out inout bycopy byref oneway.\n+   We have to save and restore the IDENTIFIER_NODEs that describe\n+   them as keywords, when appropriate.  */\n+\n+#define N_PQ 6\n+static tree saved_pq[N_PQ];\n+static tree saved_not_pq[N_PQ];\n+static const char *const pq_strings[N_PQ] = {\n+  \"bycopy\", \"byref\", \"in\", \"inout\", \"oneway\", \"out\"\n+};\n+\n+void\n+save_and_forget_protocol_qualifiers ()\n+{\n+  int i;\n+  for (i = 0; i < N_PQ; i++)\n+    saved_pq[i] = set_identifier (pq_strings[i], NULL_TREE);\n+\n+  ggc_add_tree_root (saved_pq, N_PQ);\n+  ggc_add_tree_root (saved_not_pq, N_PQ);\n+}\n+\n void\n forget_protocol_qualifiers ()\n {\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_IN]) = 0;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_OUT]) = 0;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_INOUT]) = 0;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYCOPY]) = 0;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYREF]) = 0;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_ONEWAY]) = 0;\n+  int i;\n+  for (i = 0; i < N_PQ; i++)\n+    {\n+      set_identifier (pq_strings[i], saved_not_pq[i]);\n+      saved_not_pq[i] = NULL_TREE;\n+    }\n }\n \n void\n remember_protocol_qualifiers ()\n {\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_IN]) = 1;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_OUT]) = 1;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_INOUT]) = 1;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYCOPY]) = 1;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYREF]) = 1;\n-  C_IS_RESERVED_WORD (ridpointers[(int) RID_ONEWAY]) = 1;\n+  int i;\n+  for (i = 0; i < N_PQ; i++)\n+    saved_not_pq[i] = set_identifier (pq_strings[i], saved_pq[i]);\n }"}, {"sha": "f5e8968105a734feac39f6751b5bcdf4aa9fd052", "filename": "gcc/stringpool.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "patch": "@@ -340,6 +340,25 @@ maybe_get_identifier (text)\n   return NULL_TREE;\n }\n \n+/* Look up an identifier with the name TEXT, replace its identifier\n+   node with NODE, and return the old identifier node.  This is used\n+   by languages which need to enable and disable keywords based on\n+   context; e.g. see remember_protocol_qualifiers in objc/objc-act.c.  */\n+tree\n+set_identifier (text, node)\n+     const char *text;\n+     tree node;\n+{\n+  struct str_header *str;\n+  tree old;\n+  size_t length = strlen (text);\n+\n+  str = alloc_string (text, length, INSERT);\n+  old = str->data;\t/* might be null */\n+  str->data = node;\n+  return old;\n+}\n+\n /* Report some basic statistics about the string pool.  */\n \n void"}, {"sha": "cfcd7becb8a081e1c89d276316d4a855553eb9a0", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71b7be38c3f1d50ca004b3aa1c21e206d595c67f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=71b7be38c3f1d50ca004b3aa1c21e206d595c67f", "patch": "@@ -1922,6 +1922,13 @@ extern tree get_identifier\t\tPARAMS ((const char *));\n \n extern tree maybe_get_identifier\tPARAMS ((const char *));\n \n+/* Look up an identifier with the name TEXT, replace its identifier\n+   node with NODE, and return the old identifier node.  This is used\n+   by languages which need to enable and disable keywords based on\n+   context; e.g. see remember_protocol_qualifiers in objc/objc-act.c.  */\n+\n+extern tree set_identifier\t\tPARAMS ((const char *, tree));\n+\n /* Construct various types of nodes.  */\n \n #define build_int_2(LO,HI)  \\"}]}