{"sha": "0b176958df07659d96bf1ae3f42cf4607161bd1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIxNzY5NThkZjA3NjU5ZDk2YmYxYWUzZjQyY2Y0NjA3MTYxYmQxZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-18T08:31:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-18T08:31:32Z"}, "message": "re PR middle-end/67790 (verify_ssa failed: definition in block 20 follows the use)\n\n2015-11-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/67790\n\t* tree-vect-loop.c (vect_is_simple_reduction_1): Remove\n\tIL rewrite for MINUS_EXPR reductions, rename back to ...\n\t(vect_is_simple_reduction): ... this, removing the wrapper.\n\t(vect_force_simple_reduction): Adjust.\n\t(vectorizable_reduction): Adjust reduc_index for MINUS_EXPR\n\treductions and make use if reduc_index in all places.  For\n\tthe final reduction of MINUS_EXPR use PLUS_EXPR.\n\n\t* gcc.dg/vect/pr67790.c: New testcase.\n\nFrom-SVN: r230518", "tree": {"sha": "3dd101923b7b9075ba8cb94d8319a4457ff1823b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd101923b7b9075ba8cb94d8319a4457ff1823b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b176958df07659d96bf1ae3f42cf4607161bd1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b176958df07659d96bf1ae3f42cf4607161bd1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b176958df07659d96bf1ae3f42cf4607161bd1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b176958df07659d96bf1ae3f42cf4607161bd1d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae53cf85a0674d2dee066e6104defd9ec817f89e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae53cf85a0674d2dee066e6104defd9ec817f89e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae53cf85a0674d2dee066e6104defd9ec817f89e"}], "stats": {"total": 124, "additions": 77, "deletions": 47}, "files": [{"sha": "910a17863780c439253d045ef30fef19d636566a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b176958df07659d96bf1ae3f42cf4607161bd1d", "patch": "@@ -1,3 +1,14 @@\n+2015-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/67790\n+\t* tree-vect-loop.c (vect_is_simple_reduction_1): Remove\n+\tIL rewrite for MINUS_EXPR reductions, rename back to ...\n+\t(vect_is_simple_reduction): ... this, removing the wrapper.\n+\t(vect_force_simple_reduction): Adjust.\n+\t(vectorizable_reduction): Adjust reduc_index for MINUS_EXPR\n+\treductions and make use if reduc_index in all places.  For\n+\tthe final reduction of MINUS_EXPR use PLUS_EXPR.\n+\n 2015-11-18  Alan Modra  <amodra@gmail.com>\n \n \t* configure.ac (POWERPC64_TOC_POINTER_ALIGNMENT): Pass -z norelro"}, {"sha": "5be70e2f85b380222bb835a1f6684770856f210c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b176958df07659d96bf1ae3f42cf4607161bd1d", "patch": "@@ -1,3 +1,8 @@\n+2015-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/67790\n+\t* gcc.dg/vect/pr67790.c: New testcase.\n+\n 2015-11-17  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* g++.dg/cpp1y/pr58708.C: Define wfoo based on sizeof wchar_t."}, {"sha": "5e2d506a730b3d44e5153c08b9b6dca57c0f8402", "filename": "gcc/testsuite/gcc.dg/vect/pr67790.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c?ref=0b176958df07659d96bf1ae3f42cf4607161bd1d", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+struct {\n+    int x_advance;\n+    int y_advance;\n+} a[256];\n+\n+int b, c;\n+\n+void __attribute__((noinline,noclone)) fn1()\n+{\n+  for (int i = 0; i < 256; i++)\n+    {\n+      c -= a[i].x_advance;\n+      b -= a[i].y_advance;\n+    }\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < 256; ++i)\n+    {\n+      a[i].x_advance = i;\n+      a[i].y_advance = -i + 3;\n+      __asm__ volatile (\"\" : : : \"memory\");\n+    }\n+  \n+  fn1();\n+\n+  if (c != -32640 || b != 31872)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */"}, {"sha": "c3dbfd3fa760ada66921fb66ac61bb105a4413cd", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 21, "deletions": 47, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b176958df07659d96bf1ae3f42cf4607161bd1d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0b176958df07659d96bf1ae3f42cf4607161bd1d", "patch": "@@ -2468,16 +2468,13 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n        if (a[i] < val)\n \tret_val = a[i];\n \n-   If MODIFY is true it tries also to rework the code in-place to enable\n-   detection of more reduction patterns.  For the time being we rewrite\n-   \"res -= RHS\" into \"rhs += -RHS\" when it seems worthwhile.\n */\n \n static gimple *\n-vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n-\t\t\t    bool check_reduction, bool *double_reduc,\n-\t\t\t    bool modify, bool need_wrapping_integral_overflow,\n-\t\t\t    enum vect_reduction_type *v_reduc_type)\n+vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n+\t\t\t  bool check_reduction, bool *double_reduc,\n+\t\t\t  bool need_wrapping_integral_overflow,\n+\t\t\t  enum vect_reduction_type *v_reduc_type)\n {\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n@@ -2634,7 +2631,6 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n      gimple instruction for the first simple tests and only do this\n      if we're allowed to change code at all.  */\n   if (code == MINUS_EXPR\n-      && modify\n       && (op1 = gimple_assign_rhs1 (def_stmt))\n       && TREE_CODE (op1) == SSA_NAME\n       && SSA_NAME_DEF_STMT (op1) == phi)\n@@ -2791,23 +2787,6 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n \t}\n     }\n \n-  /* If we detected \"res -= x[i]\" earlier, rewrite it into\n-     \"res += -x[i]\" now.  If this turns out to be useless reassoc\n-     will clean it up again.  */\n-  if (orig_code == MINUS_EXPR)\n-    {\n-      tree rhs = gimple_assign_rhs2 (def_stmt);\n-      tree negrhs = make_ssa_name (TREE_TYPE (rhs));\n-      gimple *negate_stmt = gimple_build_assign (negrhs, NEGATE_EXPR, rhs);\n-      gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);\n-      set_vinfo_for_stmt (negate_stmt, new_stmt_vec_info (negate_stmt, \n-\t\t\t\t\t\t\t  loop_info));\n-      gsi_insert_before (&gsi, negate_stmt, GSI_NEW_STMT);\n-      gimple_assign_set_rhs2 (def_stmt, negrhs);\n-      gimple_assign_set_rhs_code (def_stmt, PLUS_EXPR);\n-      update_stmt (def_stmt);\n-    }\n-\n   /* Reduction is safe. We're dealing with one of the following:\n      1) integer arithmetic and no trapv\n      2) floating point arithmetic, and special flags permit this optimization\n@@ -2863,7 +2842,8 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n                           == vect_internal_def\n \t\t      && !is_loop_header_bb_p (gimple_bb (def2)))))))\n     {\n-      if (check_reduction)\n+      if (check_reduction\n+\t  && orig_code != MINUS_EXPR)\n         {\n \t  if (code == COND_EXPR)\n \t    {\n@@ -2915,21 +2895,6 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple *phi,\n   return NULL;\n }\n \n-/* Wrapper around vect_is_simple_reduction_1, that won't modify code\n-   in-place.  Arguments as there.  */\n-\n-static gimple *\n-vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n-\t\t\t  bool check_reduction, bool *double_reduc,\n-\t\t\t  bool need_wrapping_integral_overflow,\n-\t\t\t  enum vect_reduction_type *v_reduc_type)\n-{\n-  return vect_is_simple_reduction_1 (loop_info, phi, check_reduction,\n-\t\t\t\t     double_reduc, false,\n-\t\t\t\t     need_wrapping_integral_overflow,\n-\t\t\t\t     v_reduc_type);\n-}\n-\n /* Wrapper around vect_is_simple_reduction_1, which will modify code\n    in-place if it enables detection of more reductions.  Arguments\n    as there.  */\n@@ -2940,10 +2905,10 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple *phi,\n \t\t\t     bool need_wrapping_integral_overflow)\n {\n   enum vect_reduction_type v_reduc_type;\n-  return vect_is_simple_reduction_1 (loop_info, phi, check_reduction,\n-\t\t\t\t     double_reduc, true,\n-\t\t\t\t     need_wrapping_integral_overflow,\n-\t\t\t\t     &v_reduc_type);\n+  return vect_is_simple_reduction (loop_info, phi, check_reduction,\n+\t\t\t\t   double_reduc,\n+\t\t\t\t   need_wrapping_integral_overflow,\n+\t\t\t\t   &v_reduc_type);\n }\n \n /* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n@@ -5398,6 +5363,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n   /* The default is that the reduction variable is the last in statement.  */\n   int reduc_index = op_type - 1;\n+  if (code == MINUS_EXPR)\n+    reduc_index = 0;\n \n   if (code == COND_EXPR && slp_node)\n     return false;\n@@ -5417,8 +5384,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n      The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the\n      reduction variable.  */\n-  for (i = 0; i < op_type - 1; i++)\n+  for (i = 0; i < op_type; i++)\n     {\n+      if (i == reduc_index)\n+\tcontinue;\n+\n       /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n       if (i == 0 && code == COND_EXPR)\n         continue;\n@@ -5454,7 +5424,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt, &dt, &tem);\n+  is_simple_use = vect_is_simple_use (ops[reduc_index], loop_vinfo,\n+\t\t\t\t      &def_stmt, &dt, &tem);\n   if (!vectype_in)\n     vectype_in = tem;\n   gcc_assert (is_simple_use);\n@@ -5625,6 +5596,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n          the vector code inside the loop can be used for the epilog code. */\n       orig_code = code;\n \n+      if (code == MINUS_EXPR)\n+\torig_code = PLUS_EXPR;\n+\n       /* For simple condition reductions, replace with the actual expression\n \t we want to base our reduction around.  */\n       if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)"}]}