{"sha": "e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThhYzVhYzk2YTNkODViNTZhZGEyZDk1MzEwMGJkYmQ2ZWRhNzQ5Yg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-10-14T15:42:33Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-10-14T15:42:33Z"}, "message": "re PR target/46278 (avr-gcc 4.5.1 doing suboptimal reloads using X)\n\n\tPR target/46278\n\t* doc/invoke.texi (AVR Options): Document -mstrict-X.\n\t* config/avr/avr.opt (-mstrict-X): New option.\n\t(avr_strict_X): New variable reflecting -mstrict-X.\n\t* config/avr/avr.c (avr_reg_ok_for_addr_p): Add parameter\n\touter_code and pass it down to avr_regno_mode_code_ok_for_base_p.\n\t(avr_legitimate_address_p): Pass outer_code to\n\tavr_reg_ok_for_addr_p and use that function in case PLUS.\n\t(avr_mode_code_base_reg_class): Depend on avr_strict_X.\n\t(avr_regno_mode_code_ok_for_base_p): Ditto, and depend on outer_code.\n\t(avr_option_override): Disable -fcaller-saves if -mstrict-X is on.\n\nFrom-SVN: r179993", "tree": {"sha": "91b3c432bb96e3b99e5406a18369fc6373642fb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91b3c432bb96e3b99e5406a18369fc6373642fb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d7a0211604472c2d489d6304f8b56df4c619537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7a0211604472c2d489d6304f8b56df4c619537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d7a0211604472c2d489d6304f8b56df4c619537"}], "stats": {"total": 184, "additions": 127, "deletions": 57}, "files": [{"sha": "add57f01efb04752c012ee0777b3d064ee8e769f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "patch": "@@ -1,3 +1,18 @@\n+2011-10-14  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/46278\n+\t* doc/invoke.texi (AVR Options): Document -mstrict-X.\n+\n+\t* config/avr/avr.opt (-mstrict-X): New option.\n+\t(avr_strict_X): New variable reflecting -mstrict-X.\n+\t* config/avr/avr.c (avr_reg_ok_for_addr_p): Add parameter\n+\touter_code and pass it down to avr_regno_mode_code_ok_for_base_p.\n+\t(avr_legitimate_address_p): Pass outer_code to\n+\tavr_reg_ok_for_addr_p and use that function in case PLUS.\n+\t(avr_mode_code_base_reg_class): Depend on avr_strict_X.\n+\t(avr_regno_mode_code_ok_for_base_p): Ditto, and depend on outer_code.\n+\t(avr_option_override): Disable -fcaller-saves if -mstrict-X is on.\n+\t\n 2011-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/sse.md (neg<mode>2): Use VI_AVX2 iterator instead"}, {"sha": "d34ac6a81803c36153fdb50d10ab23d7d34bbd62", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 90, "deletions": 56, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "patch": "@@ -351,6 +351,17 @@ avr_option_override (void)\n {\n   flag_delete_null_pointer_checks = 0;\n \n+  /* caller-save.c looks for call-clobbered hard registers that are assigned\n+     to pseudos that cross calls and tries so save-restore them around calls\n+     in order to reduce the number of stack slots needed.\n+\n+     This might leads to situations where reload is no more able to cope\n+     with the challenge of AVR's very few address registers and fails to\n+     perform the requested spills.  */\n+  \n+  if (avr_strict_X)\n+    flag_caller_saves = 0;\n+\n   /* Unwind tables currently require a frame pointer for correctness,\n      see toplev.c:process_options().  */\n \n@@ -1205,11 +1216,12 @@ avr_cannot_modify_jumps_p (void)\n /* Helper function for `avr_legitimate_address_p'.  */\n \n static inline bool\n-avr_reg_ok_for_addr_p (rtx reg, addr_space_t as ATTRIBUTE_UNUSED, int strict)\n+avr_reg_ok_for_addr_p (rtx reg, addr_space_t as ATTRIBUTE_UNUSED,\n+                       RTX_CODE outer_code, bool strict)\n {\n   return (REG_P (reg)\n           && (avr_regno_mode_code_ok_for_base_p (REGNO (reg),\n-                                                 QImode, MEM, UNKNOWN)\n+                                                 QImode, outer_code, UNKNOWN)\n               || (!strict\n                   && REGNO (reg) >= FIRST_PSEUDO_REGISTER)));\n }\n@@ -1221,58 +1233,69 @@ avr_reg_ok_for_addr_p (rtx reg, addr_space_t as ATTRIBUTE_UNUSED, int strict)\n static bool\n avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n-  reg_class_t r = NO_REGS;\n+  bool ok = CONSTANT_ADDRESS_P (x);\n   \n-  if (REG_P (x)\n-      && avr_reg_ok_for_addr_p (x, ADDR_SPACE_GENERIC, strict))\n-    {\n-      r = POINTER_REGS;\n-    }\n-  else if (CONSTANT_ADDRESS_P (x))\n-    {\n-      r = ALL_REGS;\n-    }\n-  else if (GET_CODE (x) == PLUS\n-           && REG_P (XEXP (x, 0))\n-           && CONST_INT_P (XEXP (x, 1))\n-           && INTVAL (XEXP (x, 1)) >= 0)\n+  switch (GET_CODE (x))\n     {\n-      rtx reg = XEXP (x, 0);\n-      bool fit = INTVAL (XEXP (x, 1)) <= MAX_LD_OFFSET (mode);\n-      \n-      if (fit)\n-        {\n-          if (! strict\n-              || REGNO (reg) == REG_X\n-              || REGNO (reg) == REG_Y\n-              || REGNO (reg) == REG_Z)\n-            {\n-              r = BASE_POINTER_REGS;\n-            }\n-          \n-          if (reg == frame_pointer_rtx\n-              || reg == arg_pointer_rtx)\n-            {\n-              r = BASE_POINTER_REGS;\n-            }\n-        }\n-      else if (frame_pointer_needed && reg == frame_pointer_rtx)\n+    case REG:\n+      ok = avr_reg_ok_for_addr_p (x, ADDR_SPACE_GENERIC,\n+                                  MEM, strict);\n+\n+      if (strict\n+          && DImode == mode\n+          && REG_X == REGNO (x))\n         {\n-          r = POINTER_Y_REGS;\n+          ok = false;\n         }\n-    }\n-  else if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC)\n-           && REG_P (XEXP (x, 0))\n-           && avr_reg_ok_for_addr_p (XEXP (x, 0), ADDR_SPACE_GENERIC, strict))\n-    {\n-      r = POINTER_REGS;\n-    }\n+      break;\n+\n+    case POST_INC:\n+    case PRE_DEC:\n+      ok = avr_reg_ok_for_addr_p (XEXP (x, 0), ADDR_SPACE_GENERIC,\n+                                  GET_CODE (x), strict);\n+      break;\n \n+    case PLUS:\n+      {\n+        rtx reg = XEXP (x, 0);\n+        rtx op1 = XEXP (x, 1);\n+        \n+        if (REG_P (reg)\n+            && CONST_INT_P (op1)\n+            && INTVAL (op1) >= 0)\n+          {\n+            bool fit = IN_RANGE (INTVAL (op1), 0, MAX_LD_OFFSET (mode));\n+\n+            if (fit)\n+              {\n+                ok = (! strict\n+                      || avr_reg_ok_for_addr_p (reg, ADDR_SPACE_GENERIC,\n+                                                PLUS, strict));\n+          \n+                if (reg == frame_pointer_rtx\n+                    || reg == arg_pointer_rtx)\n+                  {\n+                    ok = true;\n+                  }\n+              }\n+            else if (frame_pointer_needed\n+                     && reg == frame_pointer_rtx)\n+              {\n+                ok = true;\n+              }\n+          }\n+      }\n+      break;\n+      \n+    default:\n+      break;\n+    }\n+  \n   if (avr_log.legitimate_address_p)\n     {\n-      avr_edump (\"\\n%?: ret=%d=%R, mode=%m strict=%d \"\n+      avr_edump (\"\\n%?: ret=%d, mode=%m strict=%d \"\n                  \"reload_completed=%d reload_in_progress=%d %s:\",\n-                 !!r, r, mode, strict, reload_completed, reload_in_progress,\n+                 ok, mode, strict, reload_completed, reload_in_progress,\n                  reg_renumber ? \"(reg_renumber)\" : \"\");\n       \n       if (GET_CODE (x) == PLUS\n@@ -1288,7 +1311,7 @@ avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n       avr_edump (\"\\n%r\\n\", x);\n     }\n   \n-  return r == NO_REGS ? 0 : (int)r;\n+  return ok;\n }\n \n /* Attempts to replace X with a valid\n@@ -7304,10 +7327,13 @@ avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n reg_class_t\n avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                              RTX_CODE outer_code ATTRIBUTE_UNUSED,\n+                              RTX_CODE outer_code,\n                               RTX_CODE index_code ATTRIBUTE_UNUSED)\n {\n-  return reload_completed ? BASE_POINTER_REGS : POINTER_REGS;\n+  if (!avr_strict_X)\n+    return reload_completed ? BASE_POINTER_REGS : POINTER_REGS;\n+\n+  return PLUS == outer_code ? BASE_POINTER_REGS : POINTER_REGS;\n }\n \n \n@@ -7316,19 +7342,20 @@ avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n bool\n avr_regno_mode_code_ok_for_base_p (int regno,\n                                    enum machine_mode mode ATTRIBUTE_UNUSED,\n-                                   RTX_CODE outer_code ATTRIBUTE_UNUSED,\n+                                   RTX_CODE outer_code,\n                                    RTX_CODE index_code ATTRIBUTE_UNUSED)\n {\n+  bool ok = false;\n+  \n   if (regno < FIRST_PSEUDO_REGISTER\n       && (regno == REG_X\n           || regno == REG_Y\n           || regno == REG_Z\n           || regno == ARG_POINTER_REGNUM))\n     {\n-      return true;\n+      ok = true;\n     }\n-\n-  if (reg_renumber)\n+  else if (reg_renumber)\n     {\n       regno = reg_renumber[regno];\n \n@@ -7337,11 +7364,18 @@ avr_regno_mode_code_ok_for_base_p (int regno,\n           || regno == REG_Z\n           || regno == ARG_POINTER_REGNUM)\n         {\n-          return true;\n+          ok = true;\n         }\n     }\n-  \n-  return false;\n+\n+  if (avr_strict_X\n+      && PLUS == outer_code\n+      && regno == REG_X)\n+    {\n+      ok = false;\n+    }\n+\n+  return ok;\n }\n \n "}, {"sha": "277b6007ee0afa44d8c66dbe8d0bc2fe95cc22f5", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "patch": "@@ -61,3 +61,7 @@ Relax branches\n mpmem-wrap-around\n Target Report\n Make the linker relaxation machine assume that a program counter wrap-around occurs.\n+\n+mstrict-X\n+Target Report Var(avr_strict_X) Init(0)\n+When accessing RAM, use X as imposed by the hardware, i.e. just use pre-decrement, post-increment and indirect addressing with the X register.  Without this option, the compiler may assume that there is an addressing mode X+const similar to Y+const and Z+const and emit instructions to emulate such an addressing mode for X."}, {"sha": "2501a8e3bce41029b2f72a0010a4949c6eef79ed", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ac5ac96a3d85b56ada2d953100bdbd6eda749b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e8ac5ac96a3d85b56ada2d953100bdbd6eda749b", "patch": "@@ -487,7 +487,7 @@ Objective-C and Objective-C++ Dialects}.\n \n @emph{AVR Options}\n @gccoptlist{-mmcu=@var{mcu}  -mno-interrupts @gol\n--mcall-prologues  -mtiny-stack  -mint8}\n+-mcall-prologues  -mtiny-stack  -mint8  -mstrict-X}\n \n @emph{Blackfin Options}\n @gccoptlist{-mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]} @gol\n@@ -10689,6 +10689,23 @@ char will be 1 byte, an int will be 1 byte, a long will be 2 bytes\n and long long will be 4 bytes.  Please note that this option does not\n comply to the C standards, but it will provide you with smaller code\n size.\n+\n+@item -mstrict-X\n+@opindex mstrict-X\n+Use register @code{X} in a way proposed by the hardware.  This means\n+that @code{X} will only be used in indirect, post-increment or\n+pre-decrement addressing.\n+\n+Without this option, the @code{X} register may be used in the same way\n+as @code{Y} or @code{Z} which then is emulated by additional\n+instructions.  \n+For example, loading a value with @code{X+const} addressing with a\n+small @code{const @leq{} 63} to a register @var{Rn} will be printed as\n+@example\n+adiw r26, const\n+ld   @var{Rn}, X\n+sbiw r26, const\n+@end example\n @end table\n \n @node Blackfin Options"}]}