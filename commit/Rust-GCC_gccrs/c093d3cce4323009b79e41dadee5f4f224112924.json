{"sha": "c093d3cce4323009b79e41dadee5f4f224112924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA5M2QzY2NlNDMyMzAwOWI3OWU0MWRhZGVlNWY0ZjIyNDExMjkyNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T13:54:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T13:54:43Z"}, "message": "[multiple changes]\n\n2014-01-20  Yannick Moy  <moy@adacore.com>\n\n\t* gnat1drv.adb (Gnat1drv): Call Write_ALI with Object=True in GNATprove\n\tmode.\n\n2014-01-20  Pascal Obry  <obry@adacore.com>\n\n\t* g-arrspl.ads (Slice_Set): New definition (will use a copy on\n\twrite scheme).\n\t* g-arrspl.adb: Adapt all routine to this new implementation.\n\t(Set): Copy the Slice_Set definition before reusing it.\n\nFrom-SVN: r206812", "tree": {"sha": "ec00a81f40c34c3dab63c2896a3fba89ff1c1322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec00a81f40c34c3dab63c2896a3fba89ff1c1322"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c093d3cce4323009b79e41dadee5f4f224112924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c093d3cce4323009b79e41dadee5f4f224112924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c093d3cce4323009b79e41dadee5f4f224112924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c093d3cce4323009b79e41dadee5f4f224112924/comments", "author": null, "committer": null, "parents": [{"sha": "0bd75e44cd11925fe09d7e9048bc14d9e976a92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd75e44cd11925fe09d7e9048bc14d9e976a92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd75e44cd11925fe09d7e9048bc14d9e976a92a"}], "stats": {"total": 166, "additions": 110, "deletions": 56}, "files": [{"sha": "1908f6568406dfd72205272bdf005fea043f9eec", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c093d3cce4323009b79e41dadee5f4f224112924", "patch": "@@ -1,3 +1,15 @@\n+2014-01-20  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat1drv.adb (Gnat1drv): Call Write_ALI with Object=True in GNATprove\n+\tmode.\n+\n+2014-01-20  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-arrspl.ads (Slice_Set): New definition (will use a copy on\n+\twrite scheme).\n+\t* g-arrspl.adb: Adapt all routine to this new implementation.\n+\t(Set): Copy the Slice_Set definition before reusing it.\n+\n 2014-01-20  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_prag.adb (Process_Import_Or_Interface): In"}, {"sha": "82b42b1eba238884f3e8f96b3362c803b0e38a46", "filename": "gcc/ada/g-arrspl.adb", "status": "modified", "additions": 83, "deletions": 50, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2Fg-arrspl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2Fg-arrspl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-arrspl.adb?ref=c093d3cce4323009b79e41dadee5f4f224112924", "patch": "@@ -39,9 +39,6 @@ package body GNAT.Array_Split is\n    procedure Free is\n       new Ada.Unchecked_Deallocation (Separators_Indexes, Indexes_Access);\n \n-   procedure Free is\n-      new Ada.Unchecked_Deallocation (Element_Sequence, Element_Access);\n-\n    function Count\n      (Source  : Element_Sequence;\n       Pattern : Element_Set) return Natural;\n@@ -54,7 +51,7 @@ package body GNAT.Array_Split is\n \n    procedure Adjust (S : in out Slice_Set) is\n    begin\n-      S.Ref_Counter.all := S.Ref_Counter.all + 1;\n+      S.D.Ref_Counter := S.D.Ref_Counter + 1;\n    end Adjust;\n \n    ------------\n@@ -81,10 +78,11 @@ package body GNAT.Array_Split is\n       Separators : Element_Set;\n       Mode       : Separator_Mode := Single)\n    is\n+      Result : Slice_Set;\n    begin\n-      Free (S.Source);\n-      S.Source := new Element_Sequence'(From);\n-      Set (S, Separators, Mode);\n+      Result.D.Source := new Element_Sequence'(From);\n+      Set (Result, Separators, Mode);\n+      S := Result;\n    end Create;\n \n    -----------\n@@ -116,23 +114,23 @@ package body GNAT.Array_Split is\n          new Ada.Unchecked_Deallocation (Element_Sequence, Element_Access);\n \n       procedure Free is\n-         new Ada.Unchecked_Deallocation (Natural, Counter);\n+         new Ada.Unchecked_Deallocation (Data, Data_Access);\n \n-      Ref_Counter : Counter := S.Ref_Counter;\n+      D : Data_Access := S.D;\n \n    begin\n       --  Ensure call is idempotent\n \n-      S.Ref_Counter := null;\n+      S.D := null;\n \n-      if Ref_Counter /= null then\n-         Ref_Counter.all := Ref_Counter.all - 1;\n+      if D /= null then\n+         D.Ref_Counter := D.Ref_Counter - 1;\n \n-         if Ref_Counter.all = 0 then\n-            Free (S.Source);\n-            Free (S.Indexes);\n-            Free (S.Slices);\n-            Free (Ref_Counter);\n+         if D.Ref_Counter = 0 then\n+            Free (D.Source);\n+            Free (D.Indexes);\n+            Free (D.Slices);\n+            Free (D);\n          end if;\n       end if;\n    end Finalize;\n@@ -143,7 +141,7 @@ package body GNAT.Array_Split is\n \n    procedure Initialize (S : in out Slice_Set) is\n    begin\n-      S.Ref_Counter := new Natural'(1);\n+      S.D := new Data'(1, null, 0, null, null);\n    end Initialize;\n \n    ----------------\n@@ -155,11 +153,11 @@ package body GNAT.Array_Split is\n       Index : Slice_Number) return Slice_Separators\n    is\n    begin\n-      if Index > S.N_Slice then\n+      if Index > S.D.N_Slice then\n          raise Index_Error;\n \n       elsif Index = 0\n-        or else (Index = 1 and then S.N_Slice = 1)\n+        or else (Index = 1 and then S.D.N_Slice = 1)\n       then\n          --  Whole string, or no separator used\n \n@@ -168,15 +166,15 @@ package body GNAT.Array_Split is\n \n       elsif Index = 1 then\n          return (Before => Array_End,\n-                 After  => S.Source (S.Slices (Index).Stop + 1));\n+                 After  => S.D.Source (S.D.Slices (Index).Stop + 1));\n \n-      elsif Index = S.N_Slice then\n-         return (Before => S.Source (S.Slices (Index).Start - 1),\n+      elsif Index = S.D.N_Slice then\n+         return (Before => S.D.Source (S.D.Slices (Index).Start - 1),\n                  After  => Array_End);\n \n       else\n-         return (Before => S.Source (S.Slices (Index).Start - 1),\n-                 After  => S.Source (S.Slices (Index).Stop + 1));\n+         return (Before => S.D.Source (S.D.Slices (Index).Start - 1),\n+                 After  => S.D.Source (S.D.Slices (Index).Stop + 1));\n       end if;\n    end Separators;\n \n@@ -186,7 +184,7 @@ package body GNAT.Array_Split is\n \n    function Separators (S : Slice_Set) return Separators_Indexes is\n    begin\n-      return S.Indexes.all;\n+      return S.D.Indexes.all;\n    end Separators;\n \n    ---------\n@@ -211,21 +209,55 @@ package body GNAT.Array_Split is\n       Separators : Element_Set;\n       Mode       : Separator_Mode := Single)\n    is\n-      Count_Sep : constant Natural := Count (S.Source.all, Separators);\n-      J : Positive;\n+\n+      procedure Copy_On_Write (S : in out Slice_Set);\n+      --  Make a copy of S if shared with another variable\n+\n+      -------------------\n+      -- Copy_On_Write --\n+      -------------------\n+\n+      procedure Copy_On_Write (S : in out Slice_Set) is\n+      begin\n+         if S.D.Ref_Counter > 1 then\n+            --  First let's remove our count from the current data\n+\n+            S.D.Ref_Counter := S.D.Ref_Counter - 1;\n+\n+            --  Then duplicate the data\n+\n+            S.D := new Data'(S.D.all);\n+            S.D.Ref_Counter := 1;\n+\n+            if S.D.Source /= null then\n+               S.D.Source := new Element_Sequence'(S.D.Source.all);\n+               S.D.Indexes := null;\n+               S.D.Slices := null;\n+            end if;\n+\n+         else\n+            --  If there is a single reference to this variable, free it now\n+            --  as it will be redefined below.\n+\n+            Free (S.D.Indexes);\n+            Free (S.D.Slices);\n+         end if;\n+      end Copy_On_Write;\n+\n+      Count_Sep : constant Natural := Count (S.D.Source.all, Separators);\n+      J         : Positive;\n+\n    begin\n-      --  Free old structure\n-      Free (S.Indexes);\n-      Free (S.Slices);\n+      Copy_On_Write (S);\n \n       --  Compute all separator's indexes\n \n-      S.Indexes := new Separators_Indexes (1 .. Count_Sep);\n-      J := S.Indexes'First;\n+      S.D.Indexes := new Separators_Indexes (1 .. Count_Sep);\n+      J := S.D.Indexes'First;\n \n-      for K in S.Source'Range loop\n-         if Is_In (S.Source (K), Separators) then\n-            S.Indexes (J) := K;\n+      for K in S.D.Source'Range loop\n+         if Is_In (S.D.Source (K), Separators) then\n+            S.D.Indexes (J) := K;\n             J := J + 1;\n          end if;\n       end loop;\n@@ -238,26 +270,26 @@ package body GNAT.Array_Split is\n          Start, Stop : Natural;\n \n       begin\n-         S.N_Slice := 0;\n+         S.D.N_Slice := 0;\n \n-         Start := S.Source'First;\n+         Start := S.D.Source'First;\n          Stop  := 0;\n \n          loop\n             if K > Count_Sep then\n \n                --  No more separators, last slice ends at end of source string\n \n-               Stop := S.Source'Last;\n+               Stop := S.D.Source'Last;\n \n             else\n-               Stop := S.Indexes (K) - 1;\n+               Stop := S.D.Indexes (K) - 1;\n             end if;\n \n             --  Add slice to the table\n \n-            S.N_Slice := S.N_Slice + 1;\n-            S_Info (S.N_Slice) := (Start, Stop);\n+            S.D.N_Slice := S.D.N_Slice + 1;\n+            S_Info (S.D.N_Slice) := (Start, Stop);\n \n             exit when K > Count_Sep;\n \n@@ -268,24 +300,24 @@ package body GNAT.Array_Split is\n                   --  In this mode just set start to character next to the\n                   --  current separator, advance the separator index.\n \n-                  Start := S.Indexes (K) + 1;\n+                  Start := S.D.Indexes (K) + 1;\n                   K := K + 1;\n \n                when Multiple =>\n \n                   --  In this mode skip separators following each other\n \n                   loop\n-                     Start := S.Indexes (K) + 1;\n+                     Start := S.D.Indexes (K) + 1;\n                      K := K + 1;\n                      exit when K > Count_Sep\n-                       or else S.Indexes (K) > S.Indexes (K - 1) + 1;\n+                       or else S.D.Indexes (K) > S.D.Indexes (K - 1) + 1;\n                   end loop;\n \n             end case;\n          end loop;\n \n-         S.Slices := new Slices_Indexes'(S_Info (1 .. S.N_Slice));\n+         S.D.Slices := new Slices_Indexes'(S_Info (1 .. S.D.N_Slice));\n       end;\n    end Set;\n \n@@ -299,13 +331,14 @@ package body GNAT.Array_Split is\n    is\n    begin\n       if Index = 0 then\n-         return S.Source.all;\n+         return S.D.Source.all;\n \n-      elsif Index > S.N_Slice then\n+      elsif Index > S.D.N_Slice then\n          raise Index_Error;\n \n       else\n-         return S.Source (S.Slices (Index).Start .. S.Slices (Index).Stop);\n+         return S.D.Source\n+           (S.D.Slices (Index).Start .. S.D.Slices (Index).Stop);\n       end if;\n    end Slice;\n \n@@ -315,7 +348,7 @@ package body GNAT.Array_Split is\n \n    function Slice_Count (S : Slice_Set) return Slice_Number is\n    begin\n-      return S.N_Slice;\n+      return S.D.N_Slice;\n    end Slice_Count;\n \n end GNAT.Array_Split;"}, {"sha": "fa7e6603c14e9e82302e3fe079c7c94e714cc027", "filename": "gcc/ada/g-arrspl.ads", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2Fg-arrspl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2Fg-arrspl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-arrspl.ads?ref=c093d3cce4323009b79e41dadee5f4f224112924", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2002-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -157,8 +157,6 @@ private\n \n    type Element_Access is access Element_Sequence;\n \n-   type Counter is access Natural;\n-\n    type Indexes_Access is access Separators_Indexes;\n \n    type Slice_Info is record\n@@ -172,13 +170,18 @@ private\n    --  All indexes for fast access to slices. In the Slice_Set we keep only\n    --  the original array and the indexes where each slice start and stop.\n \n-   type Slice_Set is new Ada.Finalization.Controlled with record\n-      Ref_Counter : Counter;            -- Reference counter, by-address sem\n+   type Data is record\n+      Ref_Counter : Natural;            -- Reference counter, by-address sem\n       Source      : Element_Access;\n       N_Slice     : Slice_Number := 0;  -- Number of slices found\n       Indexes     : Indexes_Access;\n       Slices      : Slices_Access;\n    end record;\n+   type Data_Access is access all Data;\n+\n+   type Slice_Set is new Ada.Finalization.Controlled with record\n+      D : Data_Access;\n+   end record;\n \n    procedure Initialize (S : in out Slice_Set);\n    procedure Adjust     (S : in out Slice_Set);"}, {"sha": "c0ebcfcb6ebc70c4b73fe43aff030ffd724145d3", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c093d3cce4323009b79e41dadee5f4f224112924/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=c093d3cce4323009b79e41dadee5f4f224112924", "patch": "@@ -1257,7 +1257,13 @@ begin\n          Exit_Program (E_Errors);\n       end if;\n \n-      Write_ALI (Object => (Back_End_Mode = Generate_Object));\n+      --  In GNATprove mode, an \"object\" file is always generated as the\n+      --  result of calling gnat1 or gnat2why, although this is not the\n+      --  same as the object file produced for compilation.\n+\n+      Write_ALI (Object => (Back_End_Mode = Generate_Object\n+                              or else\n+                            GNATprove_Mode));\n \n       if not Compilation_Errors then\n "}]}