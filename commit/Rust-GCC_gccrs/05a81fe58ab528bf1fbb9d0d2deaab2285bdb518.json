{"sha": "05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVhODFmZTU4YWI1MjhiZjFmYmI5ZDBkMmRlYWFiMjI4NWJkYjUxOA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-15T22:25:24Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-15T22:25:24Z"}, "message": "c-lex.c (check_newline): Pass character after `#pragma' to HANDLE_PRAGMA.\n\n\t* c-lex.c (check_newline): Pass character after `#pragma' to\n\tHANDLE_PRAGMA.  Don't call get_directive_line if at end of line.\n\t* c-common.c (get_directive_line): Watch for EOF.\n\t* h8300/h8300.h (HANDLE_PRAGMA): New argument `c'.\n\tMust issue `return' now.\n\t* i960/i960.h (HANDLE_PRAGMA): Likewise.\n\t* sh/sh.h (HANDLE_PRAGMA): Likewise.\n\t* nextstep.h (HANDLE_PRAGMA): Likewise.\n\t* h8300/h8300.c (handle_pragma): New argument `ch'.\n\tSimplify pragma processing.  Delete support for `#pragma section'.\n\t* i960/i960.c (process_pragma): New argument `c'.  Change result to\n\tterminating character.\n\t* nextstep.c (handle_pragma): Likewise.\n\t* sh/sh.c (handle_pragma): Likewise.  Also simplified.\n\nFrom-SVN: r10999", "tree": {"sha": "79c4f03f1d011640a7b270160132fb58e1333970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79c4f03f1d011640a7b270160132fb58e1333970"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/comments", "author": null, "committer": null, "parents": [{"sha": "9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9298a6b0eb75d3f025250cd3f626a7b74f470fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9298a6b0eb75d3f025250cd3f626a7b74f470fe9"}], "stats": {"total": 172, "additions": 89, "deletions": 83}, "files": [{"sha": "58e9df02cd908c133426392bdb05a1c9f3e2546d", "filename": "gcc/c-common.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -2163,7 +2163,10 @@ truthvalue_conversion (expr)\n    a part of the directive.\n \n    The value is a string in a reusable buffer.  It remains valid\n-   only until the next time this function is called.  */\n+   only until the next time this function is called.\n+\n+   The terminating character ('\\n' or EOF) is left in FINPUT for the\n+   caller to re-read.  */\n \n char *\n get_directive_line (finput)\n@@ -2207,7 +2210,8 @@ get_directive_line (finput)\n \tcontinue;\n \n       /* Detect the end of the directive.  */\n-      if (c == '\\n' && looking_for == 0)\n+      if (looking_for == 0\n+\t  && (c == '\\n' || c == EOF))\n \t{\n           ungetc (c, finput);\n \t  c = '\\0';"}, {"sha": "51479beb53f3b31ca7c1595376da7f7f8e89b4f3", "filename": "gcc/c-lex.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -1,5 +1,5 @@\n /* Lexical analyzer for C and Objective C.\n-   Copyright (C) 1987, 88, 89, 92, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 94, 95, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -402,7 +402,7 @@ check_newline ()\n \t      return handle_sysv_pragma (finput, c);\n #else /* !HANDLE_SYSV_PRAGMA */\n #ifdef HANDLE_PRAGMA\n-\t      HANDLE_PRAGMA (finput);\n+\t      HANDLE_PRAGMA (finput, c);\n #endif /* HANDLE_PRAGMA */\n \t      goto skipline;\n #endif /* !HANDLE_SYSV_PRAGMA */\n@@ -419,7 +419,8 @@ check_newline ()\n \t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n #ifdef DWARF_DEBUGGING_INFO\n-\t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t      if (c != '\\n'\n+\t\t  && (debug_info_level == DINFO_LEVEL_VERBOSE)\n \t\t  && (write_symbols == DWARF_DEBUG))\n \t        dwarfout_define (lineno, get_directive_line (finput));\n #endif /* DWARF_DEBUGGING_INFO */\n@@ -435,7 +436,8 @@ check_newline ()\n \t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n #ifdef DWARF_DEBUGGING_INFO\n-\t      if ((debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t      if (c != '\\n'\n+\t\t  && (debug_info_level == DINFO_LEVEL_VERBOSE)\n \t\t  && (write_symbols == DWARF_DEBUG))\n \t        dwarfout_undef (lineno, get_directive_line (finput));\n #endif /* DWARF_DEBUGGING_INFO */\n@@ -674,9 +676,8 @@ check_newline ()\n \n   /* skip the rest of this line.  */\n  skipline:\n-  if (c == '\\n')\n-    return c;\n-  while ((c = getc (finput)) != EOF && c != '\\n');\n+  while (c != '\\n' && c != EOF)\n+    c = getc (finput);\n   return c;\n }\n \f"}, {"sha": "f6a42ebdc2ba1afdc2d782dded27b27afb81987d", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -548,57 +548,35 @@ eq_operator (x, mode)\n    with this attribute may be safely used in an interrupt vector.  */\n \n int\n-handle_pragma (file)\n+handle_pragma (file, c)\n      FILE *file;\n+     int c;\n {\n-  int c;\n   char pbuf[20];\n   int psize = 0;\n \n-  c = getc (file);\n   while (c == ' ' || c == '\\t')\n     c = getc (file);\n \n-  if (c == '\\n' || c == EOF)\n-    return c;\n-\n-  /* The only pragmas we understand are interrupt and saveall.  */\n-  while (psize < sizeof (pbuf) - 1\n-\t && isalpha (c))\n+  if (c != '\\n' & c != EOF)\n     {\n-      pbuf[psize++] = c;\n-      c = getc (file);\n-    }\n-  pbuf[psize] = 0;\n-\n-  if (strcmp (pbuf, \"interrupt\") == 0)\n-    pragma_interrupt = 1;\n-\n-  if (strcmp (pbuf, \"saveall\") == 0)\n-    pragma_saveall = 1;\n-\n-  /* ??? This is deprecated.  Delete for gcc 2.8.  */\n-  if (strcmp (pbuf, \"section\") == 0)\n-    {\n-      static int printed_p = 0;\n-      if (!printed_p)\n-\t{\n-\t  warning (\"#pragma section is deprecated, use section attributes\");\n-\t  printed_p = 1;\n-\t}\n-      while (c && !isalpha (c))\n-\tc = getc (file);\n-      psize = 0;\n       while (psize < sizeof (pbuf) - 1\n-\t     && isalpha (c) || isdigit (c) || c == '_')\n+\t     && isalpha (c))\n \t{\n \t  pbuf[psize++] = c;\n \t  c = getc (file);\n \t}\n       pbuf[psize] = 0;\n-      named_section (NULL_TREE, pbuf);\n+\n+      if (strcmp (pbuf, \"interrupt\") == 0)\n+\tpragma_interrupt = 1;\n+      else if (strcmp (pbuf, \"saveall\") == 0)\n+\tpragma_saveall = 1;\n+\n+      while (c != '\\n' && c != EOF)\n+\tc = getc (file);\n     }\n-  ungetc (c, file);\n+\n   return c;\n }\n \f"}, {"sha": "b146ed907fcd1033b05358eff586a8c3aa7e8cb6", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -1272,7 +1272,13 @@ do { char dstr[30];\t\t\t\t\t\\\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n-#define HANDLE_PRAGMA(FILE) handle_pragma (FILE)\n+/* Define this macro if you want to implement any pragmas.  If defined, it\n+   should be a C statement to be executed when #pragma is seen.  The\n+   argument STREAM is the stdio input stream from which the source\n+   text can be read.  CH is the first character after the #pragma.  The\n+   statement should execute a `return' with the terminating character found\n+   (newline or EOF).  */\n+#define HANDLE_PRAGMA(FILE, CH) return handle_pragma (FILE, CH)\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n "}, {"sha": "72dabd2d7db1d0671986b4a68f4d78c7cf836cf8", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -89,14 +89,13 @@ static int ret_label = 0;\n /* ??? This is incomplete, since it does not handle all pragmas that the\n    intel compilers understand.  */\n \n-void\n-process_pragma (finput)\n+int\n+process_pragma (finput, c)\n      FILE *finput;\n+     int c;\n {\n-  int c;\n   int i;\n \n-  c = getc (finput);\n   while (c == ' ' || c == '\\t')\n     c = getc (finput);\n \n@@ -162,7 +161,9 @@ process_pragma (finput)\n \n   /* Should be pragma 'far' or equivalent for callx/balx here.  */\n \n-  ungetc (c, finput);\n+  while (c != '\\n' && c != EOF)\n+    c = getc (finput);\n+  return c;\n }\n \n /* Initialize variables before compiling any files.  */"}, {"sha": "331e212afda1b92ce07bce75f21263f0e56d4db2", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -119,7 +119,7 @@ Boston, MA 02111-1307, USA.  */\n   fprintf (asm_out_file, \"\\t.type\\t0x%x;\", (A & 0xf) + 2 * (A & ~0xf))\n \n /* Handle pragmas for compatibility with Intel's compilers.  */\n-#define HANDLE_PRAGMA(FILE) process_pragma (FILE)\n+#define HANDLE_PRAGMA(FILE, CH) return process_pragma (FILE, CH)\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n "}, {"sha": "65bf16e387ed5358fc1613a2d1e5759bbea06140", "filename": "gcc/config/nextstep.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fnextstep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fnextstep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.c?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -1,5 +1,5 @@\n /* Functions for generic NeXT as target machine for GNU C compiler.\n-   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 90-93, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -35,14 +35,17 @@ static int initial_optimize_flag;\n extern char *get_directive_line ();\n \n /* Called from check_newline via the macro HANDLE_PRAGMA.\n-   FINPUT is the source file input stream.  */\n+   FINPUT is the source file input stream.\n+   CH is the first character after `#pragma'.\n+   The result is the terminating character ('\\n' or EOF).  */\n \n-void\n-handle_pragma (finput, get_line_function)\n+int\n+handle_pragma (finput, ch, get_line_function)\n      FILE *finput;\n+     int ch;\n      char *(*get_line_function) ();\n {\n-  register char *p = (*get_line_function) (finput);\n+  register char *p;\n \n   /* Record initial setting of optimize flag, so we can restore it.  */\n   if (!pragma_initialized)\n@@ -51,6 +54,11 @@ handle_pragma (finput, get_line_function)\n       initial_optimize_flag = optimize;\n     }\n \n+  /* Nothing to do if #pragma is by itself.  */\n+  if (ch == '\\n' || ch == EOF)\n+    return ch;\n+\n+  p = (*get_line_function) (finput);\n   if (OPT_STRCMP (\"CC_OPT_ON\"))\n     {\n       optimize = 1, obey_regdecls = 0;\n@@ -81,4 +89,7 @@ handle_pragma (finput, get_line_function)\n     flag_writable_strings = 0;\n   else if (OPT_STRCMP (\"CC_NO_MACH_TEXT_SECTIONS\"))\n     flag_no_mach_text_sections = 1;\n+\n+  /* get_line_function must leave the last character read in FINPUT.  */\n+  return getc (finput);\n }"}, {"sha": "bfd039c22416b24ce44c4d4a82692a179ac6af53", "filename": "gcc/config/nextstep.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fnextstep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fnextstep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.h?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -1,6 +1,6 @@\n /* nextstep.h -- operating system specific defines to be used when\n    targeting GCC for NeXTSTEP.\n-   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 90-93, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -240,7 +240,8 @@ Boston, MA 02111-1307, USA.  */\n /* How to parse #pragma's */\n \n #undef\tHANDLE_PRAGMA\n-#define HANDLE_PRAGMA(finput) handle_pragma (finput, &get_directive_line)\n+#define HANDLE_PRAGMA(finput, ch) \\\n+  return handle_pragma (finput, ch, &get_directive_line)\n \n /* Give methods pretty symbol names on NeXT. */\n "}, {"sha": "81125b3e41c11a29cb023db6998538f56a86fa61", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for Hitachi Super-H.\n-   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -23,6 +23,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n \n+#include <ctype.h>\n #include <stdio.h>\n \n #include \"rtl.h\"\n@@ -2019,40 +2020,37 @@ initial_elimination_offset (from, to)\n    compiler.  */\n \n int\n-handle_pragma (file)\n+handle_pragma (file, c)\n      FILE *file;\n+     int c;\n {\n-  int c;\n   char pbuf[200];\n   int psize = 0;\n \n-  c = getc (file);\n   while (c == ' ' || c == '\\t')\n     c = getc (file);\n \n-  if (c == '\\n' || c == EOF)\n-    return c;\n-\n-  while (psize < sizeof (pbuf) - 1 && c != '\\n')\n+  if (c != '\\n' & c != EOF)\n     {\n-      pbuf[psize++] = c;\n-      if (psize == 9 && strncmp (pbuf, \"interrupt\", 9) == 0)\n-\t{\n-\t  pragma_interrupt = 1;\n-\t  return ' ';\n-\t}\n-      if (psize == 5 && strncmp (pbuf, \"trapa\", 5) == 0)\n-\t{\n-\t  pragma_interrupt = pragma_trapa = 1;\n-\t  return ' ';\n-\t}\n-      if (psize == 15 && strncmp (pbuf, \"nosave_low_regs\", 15) == 0)\n+      while (psize < sizeof (pbuf) - 1\n+\t     && (isalpha (c) || c == '_'))\n \t{\n-\t  pragma_nosave_low_regs = 1;\n-\t  return ' ';\n+\t  pbuf[psize++] = c;\n+\t  c = getc (file);\n \t}\n-      c = getc (file);\n+      pbuf[psize] = 0;\n+\n+      if (strcmp (pbuf, \"interrupt\") == 0)\n+\tpragma_interrupt = 1;\n+      else if (strcmp (pbuf, \"trapa\") == 0)\n+\tpragma_interrupt = pragma_trapa = 1;\n+      else if (strcmp (pbuf, \"nosave_low_regs\") == 0)\n+\tpragma_nosave_low_regs = 1;\n+\n+      while (c != '\\n' && c != EOF)\n+\tc = getc (file);\n     }\n+\n   return c;\n }\n \f"}, {"sha": "2c6f947c64bfef0a1552314211812fd27b462803", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a81fe58ab528bf1fbb9d0d2deaab2285bdb518/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=05a81fe58ab528bf1fbb9d0d2deaab2285bdb518", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for Hitachi Super-H.\n-   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -1388,7 +1388,13 @@ extern char *output_far_jump();\n \n #define TARGET_MEM_FUNCTIONS\n \n-#define HANDLE_PRAGMA(finput) return handle_pragma (finput)\n+/* Define this macro if you want to implement any pragmas.  If defined, it\n+   should be a C statement to be executed when #pragma is seen.  The\n+   argument STREAM is the stdio input stream from which the source\n+   text can be read.  CH is the first character after the #pragma.  The\n+   statement should execute a `return' with the terminating character found\n+   (newline or EOF).  */\n+#define HANDLE_PRAGMA(FILE, CH) return handle_pragma (FILE, CH)\n \n /* Set when processing a function with pragma interrupt turned on.  */\n "}]}