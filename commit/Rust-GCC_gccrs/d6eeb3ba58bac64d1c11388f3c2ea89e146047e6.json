{"sha": "d6eeb3ba58bac64d1c11388f3c2ea89e146047e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlZWIzYmE1OGJhYzY0ZDFjMTEzODhmM2MyZWE4OWUxNDYwNDdlNg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2006-04-22T08:50:36Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-04-22T08:50:36Z"}, "message": "dwarf2out.c (struct die_struct): Document that die_sib makes a circular linked list.\n\n\t* dwarf2out.c (struct die_struct): Document that die_sib makes\n\ta circular linked list.\n\t(FOR_EACH_CHILD): New.\n\t(reverse_die_lists): Delete.\n\t(reverse_all_dies): Delete.\n\t(add_dwarf_attr): Correct documentation.\n\t(remove_child_with_prev): New.\n\t(remove_child_TAG): Update for change to die_struct, use\n\tremove_child_with_prev.\n\t(add_child_die): Update for change to die_struct.\n\t(splice_child_die): Use remove_child_with_prev and add_child_die.\n\t(print_die): Use FOR_EACH_CHILD.\n\t(die_checksum): Likewise.\n\t(assign_symbol_names): Likewise.\n\t(output_location_lists): Likewise.\n\t(build_abbrev_table): Likewise.\n\t(calc_die_sizes): Likewise.\n\t(mark_dies): Likewise.\n\t(unmark_dies): Likewise.\n\t(unmark_all_dies): Likewise.\n\t(output_die): Likewise.\n\t(prune_unused_types_mark): Likewise.\n\t(prune_unused_types_walk): Likewise.\n\t(same_die_p): Update for change to die_struct.\n\t(break_out_includes): Likewise.\n\t(prune_unused_types_prune): Likewise.\n\t(add_sibling_attributes): Use FOR_EACH_CHILD, simplify logic.\n\t(prune_unmark_dies): Use FOR_EACH_CHILD, don't clear die_mark if\n\tit's already clear.\n\t(dwarf2out_finish): Don't call reverse_all_dies.\n\nFrom-SVN: r113171", "tree": {"sha": "8a4a80539b16c0b97f587f4ef835c15c159d40df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4a80539b16c0b97f587f4ef835c15c159d40df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d360fd8f2abfb37c7f2bc926678073948160ffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d360fd8f2abfb37c7f2bc926678073948160ffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d360fd8f2abfb37c7f2bc926678073948160ffd"}], "stats": {"total": 375, "additions": 200, "deletions": 175}, "files": [{"sha": "5a20827fcabaf0accde01fa48a74d8849cc96116", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6eeb3ba58bac64d1c11388f3c2ea89e146047e6", "patch": "@@ -1,3 +1,36 @@\n+2006-04-21  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* dwarf2out.c (struct die_struct): Document that die_sib makes\n+\ta circular linked list.\n+\t(FOR_EACH_CHILD): New.\n+\t(reverse_die_lists): Delete.\n+\t(reverse_all_dies): Delete.\n+\t(add_dwarf_attr): Correct documentation.\n+\t(remove_child_with_prev): New.\n+\t(remove_child_TAG): Update for change to die_struct, use\n+\tremove_child_with_prev.\n+\t(add_child_die): Update for change to die_struct.\n+\t(splice_child_die): Use remove_child_with_prev and add_child_die.\n+\t(print_die): Use FOR_EACH_CHILD.\n+\t(die_checksum): Likewise.\n+\t(assign_symbol_names): Likewise.\n+\t(output_location_lists): Likewise.\n+\t(build_abbrev_table): Likewise.\n+\t(calc_die_sizes): Likewise.\n+\t(mark_dies): Likewise.\n+\t(unmark_dies): Likewise.\n+\t(unmark_all_dies): Likewise.\n+\t(output_die): Likewise.\n+\t(prune_unused_types_mark): Likewise.\n+\t(prune_unused_types_walk): Likewise.\n+\t(same_die_p): Update for change to die_struct.\n+\t(break_out_includes): Likewise.\n+\t(prune_unused_types_prune): Likewise.\n+\t(add_sibling_attributes): Use FOR_EACH_CHILD, simplify logic.\n+\t(prune_unmark_dies): Use FOR_EACH_CHILD, don't clear die_mark if\n+\tit's already clear.\n+\t(dwarf2out_finish): Don't call reverse_all_dies.\n+\n 2006-04-21  Eric Christopher  <echristo@apple.com>\n \n \t* df-core.c, tree-outof-ssa.c, config/i386/i386.c: Fix typos"}, {"sha": "6c01596e1404ac74573d63cf70794fb8cb55cbc5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 167, "deletions": 175, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6eeb3ba58bac64d1c11388f3c2ea89e146047e6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d6eeb3ba58bac64d1c11388f3c2ea89e146047e6", "patch": "@@ -3688,7 +3688,9 @@ dw_attr_node;\n DEF_VEC_O(dw_attr_node);\n DEF_VEC_ALLOC_O(dw_attr_node,gc);\n \n-/* The Debugging Information Entry (DIE) structure */\n+/* The Debugging Information Entry (DIE) structure.  DIEs form a tree.\n+   The children of each node form a circular list linked by\n+   die_sib.  die_child points to the node *before* the \"first\" child node.  */\n \n typedef struct die_struct GTY(())\n {\n@@ -3708,6 +3710,15 @@ typedef struct die_struct GTY(())\n }\n die_node;\n \n+/* Evaluate 'expr' while 'c' is set to each child of DIE in order.  */\n+#define FOR_EACH_CHILD(die, c, expr) do {\t\\\n+  c = die->die_child;\t\t\t\t\\\n+  if (c) do {\t\t\t\t\t\\\n+    c = c->die_sib;\t\t\t\t\\\n+    expr;\t\t\t\t\t\\\n+  } while (c != die->die_child);\t\t\\\n+} while (0)\n+\n /* The pubname structure */\n \n typedef struct pubname_struct GTY(())\n@@ -4042,8 +4053,6 @@ static void add_var_loc_to_decl (tree, struct var_loc_node *);\n static void print_spaces (FILE *);\n static void print_die (dw_die_ref, FILE *);\n static void print_dwarf_line_table (FILE *);\n-static void reverse_die_lists (dw_die_ref);\n-static void reverse_all_dies (dw_die_ref);\n static dw_die_ref push_new_compile_unit (dw_die_ref, dw_die_ref);\n static dw_die_ref pop_compile_unit (dw_die_ref);\n static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);\n@@ -4838,8 +4847,7 @@ decl_class_context (tree decl)\n   return context;\n }\n \f\n-/* Add an attribute/value pair to a DIE.  We build the lists up in reverse\n-   addition order, and correct that in reverse_all_dies.  */\n+/* Add an attribute/value pair to a DIE.  */\n \n static inline void\n add_dwarf_attr (dw_die_ref die, dw_attr_ref attr)\n@@ -5406,56 +5414,77 @@ remove_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n       }\n }\n \n-/* Remove child die whose die_tag is specified tag.  */\n+/* Remove CHILD from its parent.  PREV must have the property that\n+   PREV->DIE_SIB == CHILD.  Does not alter CHILD.  */\n \n static void\n-remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)\n+remove_child_with_prev (dw_die_ref child, dw_die_ref prev)\n {\n-  dw_die_ref current, prev, next;\n-  current = die->die_child;\n-  prev = NULL;\n-  while (current != NULL)\n+  gcc_assert (child->die_parent == prev->die_parent);\n+  gcc_assert (prev->die_sib == child);\n+  if (prev == child)\n     {\n-      if (current->die_tag == tag)\n-\t{\n-\t  next = current->die_sib;\n-\t  if (prev == NULL)\n-\t    die->die_child = next;\n-\t  else\n-\t    prev->die_sib = next;\n-\t  current = next;\n-\t}\n-      else\n-\t{\n-\t  prev = current;\n-\t  current = current->die_sib;\n-\t}\n+      gcc_assert (child->die_parent->die_child == child);\n+      prev = NULL;\n     }\n+  else\n+    prev->die_sib = child->die_sib;\n+  if (child->die_parent->die_child == child)\n+    child->die_parent->die_child = prev;\n }\n \n-/* Add a child DIE below its parent.  We build the lists up in reverse\n-   addition order, and correct that in reverse_all_dies.  */\n+/* Remove child DIE whose die_tag is TAG.  Do nothing if no child\n+   matches TAG.  */\n \n-static inline void\n+static void\n+remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)\n+{\n+  dw_die_ref c;\n+  \n+  c = die->die_child;\n+  if (c) do {\n+    dw_die_ref prev = c;\n+    c = c->die_sib;\n+    while (c->die_tag == tag)\n+      {\n+\tremove_child_with_prev (c, prev);\n+\t/* Might have removed every child.  */\n+\tif (c == c->die_sib)\n+\t  return;\n+\tc = c->die_sib;\n+      }\n+  } while (c != die->die_child);\n+}\n+\n+/* Add a CHILD_DIE as the last child of DIE.  */\n+\n+static void\n add_child_die (dw_die_ref die, dw_die_ref child_die)\n {\n-  if (die != NULL && child_die != NULL)\n-    {\n-      gcc_assert (die != child_die);\n+  /* FIXME this should probably be an assert.  */\n+  if (! die || ! child_die)\n+    return;\n+  gcc_assert (die != child_die);\n \n-      child_die->die_parent = die;\n-      child_die->die_sib = die->die_child;\n-      die->die_child = child_die;\n+  child_die->die_parent = die;\n+  if (die->die_child)\n+    {\n+      child_die->die_sib = die->die_child->die_sib;\n+      die->die_child->die_sib = child_die;\n     }\n+  else\n+    child_die->die_sib = child_die;\n+  die->die_child = child_die;\n }\n \n /* Move CHILD, which must be a child of PARENT or the DIE for which PARENT\n-   is the specification, to the front of PARENT's list of children.  */\n+   is the specification, to the end of PARENT's list of children.  \n+   This is done by removing and re-adding it.  */\n \n static void\n splice_child_die (dw_die_ref parent, dw_die_ref child)\n {\n-  dw_die_ref *p;\n+  dw_die_ref p;\n \n   /* We want the declaration DIE from inside the class, not the\n      specification DIE at toplevel.  */\n@@ -5470,17 +5499,15 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n   gcc_assert (child->die_parent == parent\n \t      || (child->die_parent\n \t\t  == get_AT_ref (parent, DW_AT_specification)));\n-\n-  for (p = &(child->die_parent->die_child); *p; p = &((*p)->die_sib))\n-    if (*p == child)\n+  \n+  for (p = child->die_parent->die_child; ; p = p->die_sib)\n+    if (p->die_sib == child)\n       {\n-\t*p = child->die_sib;\n+\tremove_child_with_prev (child, p);\n \tbreak;\n       }\n \n-  child->die_parent = parent;\n-  child->die_sib = parent->die_child;\n-  parent->die_child = child;\n+  add_child_die (parent, child);\n }\n \n /* Return a pointer to a newly created DIE node.  */\n@@ -5727,9 +5754,7 @@ print_die (dw_die_ref die, FILE *outfile)\n   if (die->die_child != NULL)\n     {\n       print_indent += 4;\n-      for (c = die->die_child; c != NULL; c = c->die_sib)\n-\tprint_die (c, outfile);\n-\n+      FOR_EACH_CHILD (die, c, print_die (c, outfile));\n       print_indent -= 4;\n     }\n   if (print_indent == 0)\n@@ -5779,42 +5804,6 @@ debug_dwarf (void)\n     print_dwarf_line_table (stderr);\n }\n \f\n-/* We build up the lists of children and attributes by pushing new ones\n-   onto the beginning of the list.  Reverse the lists for DIE so that\n-   they are in order of addition.  */\n-\n-static void\n-reverse_die_lists (dw_die_ref die)\n-{\n-  dw_die_ref c, cp, cn;\n-\n-  for (c = die->die_child, cp = 0; c; c = cn)\n-    {\n-      cn = c->die_sib;\n-      c->die_sib = cp;\n-      cp = c;\n-    }\n-\n-  die->die_child = cp;\n-}\n-\n-/* reverse_die_lists only reverses the single die you pass it. Since we used to\n-   reverse all dies in add_sibling_attributes, which runs through all the dies,\n-   it would reverse all the dies.  Now, however, since we don't call\n-   reverse_die_lists in add_sibling_attributes, we need a routine to\n-   recursively reverse all the dies. This is that routine.  */\n-\n-static void\n-reverse_all_dies (dw_die_ref die)\n-{\n-  dw_die_ref c;\n-\n-  reverse_die_lists (die);\n-\n-  for (c = die->die_child; c; c = c->die_sib)\n-    reverse_all_dies (c);\n-}\n-\n /* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU\n    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL\n    DIE that marks the start of the DIEs for this include file.  */\n@@ -5943,8 +5932,7 @@ die_checksum (dw_die_ref die, struct md5_ctx *ctx, int *mark)\n   for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n     attr_checksum (a, ctx, mark);\n \n-  for (c = die->die_child; c; c = c->die_sib)\n-    die_checksum (c, ctx, mark);\n+  FOR_EACH_CHILD (die, c, die_checksum (c, ctx, mark));\n }\n \n #undef CHECKSUM\n@@ -6067,13 +6055,28 @@ same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n     if (!same_attr_p (a1, VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n       return 0;\n \n-  for (c1 = die1->die_child, c2 = die2->die_child;\n-       c1 && c2;\n-       c1 = c1->die_sib, c2 = c2->die_sib)\n-    if (!same_die_p (c1, c2, mark))\n-      return 0;\n-  if (c1 || c2)\n-    return 0;\n+  c1 = die1->die_child;\n+  c2 = die2->die_child;\n+  if (! c1)\n+    {\n+      if (c2)\n+\treturn 0;\n+    }\n+  else\n+    for (;;)\n+      {\n+\tif (!same_die_p (c1, c2, mark))\n+\t  return 0;\n+\tc1 = c1->die_sib;\n+\tc2 = c2->die_sib;\n+\tif (c1 == die1->die_child)\n+\t  {\n+\t    if (c2 == die2->die_child)\n+\t      break;\n+\t    else\n+\t      return 0;\n+\t  }\n+    }\n \n   return 1;\n }\n@@ -6238,8 +6241,7 @@ assign_symbol_names (dw_die_ref die)\n \tdie->die_symbol = gen_internal_sym (\"LDIE\");\n     }\n \n-  for (c = die->die_child; c != NULL; c = c->die_sib)\n-    assign_symbol_names (c);\n+  FOR_EACH_CHILD (die, c, assign_symbol_names (c));\n }\n \n struct cu_hash_table_entry\n@@ -6337,35 +6339,34 @@ record_comdat_symbol_number (dw_die_ref cu, htab_t htable, unsigned int sym_num)\n static void\n break_out_includes (dw_die_ref die)\n {\n-  dw_die_ref *ptr;\n+  dw_die_ref c;\n   dw_die_ref unit = NULL;\n   limbo_die_node *node, **pnode;\n   htab_t cu_hash_table;\n \n-  for (ptr = &(die->die_child); *ptr;)\n-    {\n-      dw_die_ref c = *ptr;\n-\n-      if (c->die_tag == DW_TAG_GNU_BINCL || c->die_tag == DW_TAG_GNU_EINCL\n-\t  || (unit && is_comdat_die (c)))\n-\t{\n-\t  /* This DIE is for a secondary CU; remove it from the main one.  */\n-\t  *ptr = c->die_sib;\n-\n-\t  if (c->die_tag == DW_TAG_GNU_BINCL)\n-\t    unit = push_new_compile_unit (unit, c);\n-\t  else if (c->die_tag == DW_TAG_GNU_EINCL)\n-\t    unit = pop_compile_unit (unit);\n-\t  else\n-\t    add_child_die (unit, c);\n-\t}\n-      else\n-\t{\n-\t  /* Leave this DIE in the main CU.  */\n-\t  ptr = &(c->die_sib);\n-\t  continue;\n-\t}\n-    }\n+  c = die->die_child;\n+  if (c) do {\n+    dw_die_ref prev = c;\n+    c = c->die_sib;\n+    while (c->die_tag == DW_TAG_GNU_BINCL || c->die_tag == DW_TAG_GNU_EINCL\n+\t   || (unit && is_comdat_die (c)))\n+      {\n+\tdw_die_ref next = c->die_sib;\n+\n+\t/* This DIE is for a secondary CU; remove it from the main one.  */\n+\tremove_child_with_prev (c, prev);\n+\t\n+\tif (c->die_tag == DW_TAG_GNU_BINCL)\n+\t  unit = push_new_compile_unit (unit, c);\n+\telse if (c->die_tag == DW_TAG_GNU_EINCL)\n+\t  unit = pop_compile_unit (unit);\n+\telse\n+\t  add_child_die (unit, c);\n+\tc = next;\n+\tif (c == die->die_child)\n+\t  break;\n+      }\n+  } while (c != die->die_child);\n \n #if 0\n   /* We can only use this in debugging, since the frontend doesn't check\n@@ -6406,13 +6407,13 @@ add_sibling_attributes (dw_die_ref die)\n {\n   dw_die_ref c;\n \n-  if (die->die_tag != DW_TAG_compile_unit\n-      && die->die_sib && die->die_child != NULL)\n-    /* Add the sibling link to the front of the attribute list.  */\n+  if (! die->die_child)\n+    return;\n+\n+  if (die->die_parent && die != die->die_parent->die_child)\n     add_AT_die_ref (die, DW_AT_sibling, die->die_sib);\n \n-  for (c = die->die_child; c != NULL; c = c->die_sib)\n-    add_sibling_attributes (c);\n+  FOR_EACH_CHILD (die, c, add_sibling_attributes (c));\n }\n \n /* Output all location lists for the DIE and its children.  */\n@@ -6428,9 +6429,7 @@ output_location_lists (dw_die_ref die)\n     if (AT_class (a) == dw_val_class_loc_list)\n       output_loc_list (AT_loc_list (a));\n \n-  for (c = die->die_child; c != NULL; c = c->die_sib)\n-    output_location_lists (c);\n-\n+  FOR_EACH_CHILD (die, c, output_location_lists (c));\n }\n \n /* The format of each DIE (and its attribute value pairs) is encoded in an\n@@ -6506,8 +6505,7 @@ build_abbrev_table (dw_die_ref die)\n     }\n \n   die->die_abbrev = abbrev_id;\n-  for (c = die->die_child; c != NULL; c = c->die_sib)\n-    build_abbrev_table (c);\n+  FOR_EACH_CHILD (die, c, build_abbrev_table (c));\n }\n \f\n /* Return the power-of-two number of bytes necessary to represent VALUE.  */\n@@ -6623,8 +6621,7 @@ calc_die_sizes (dw_die_ref die)\n   die->die_offset = next_die_offset;\n   next_die_offset += size_of_die (die);\n \n-  for (c = die->die_child; c != NULL; c = c->die_sib)\n-    calc_die_sizes (c);\n+  FOR_EACH_CHILD (die, c, calc_die_sizes (c));\n \n   if (die->die_child != NULL)\n     /* Count the null byte used to terminate sibling lists.  */\n@@ -6644,8 +6641,7 @@ mark_dies (dw_die_ref die)\n   gcc_assert (!die->die_mark);\n \n   die->die_mark = 1;\n-  for (c = die->die_child; c; c = c->die_sib)\n-    mark_dies (c);\n+  FOR_EACH_CHILD (die, c, mark_dies (c));\n }\n \n /* Clear the marks for a die and its children.  */\n@@ -6658,8 +6654,7 @@ unmark_dies (dw_die_ref die)\n   gcc_assert (die->die_mark);\n \n   die->die_mark = 0;\n-  for (c = die->die_child; c; c = c->die_sib)\n-    unmark_dies (c);\n+  FOR_EACH_CHILD (die, c, unmark_dies (c));\n }\n \n /* Clear the marks for a die, its children and referred dies.  */\n@@ -6675,8 +6670,7 @@ unmark_all_dies (dw_die_ref die)\n     return;\n   die->die_mark = 0;\n \n-  for (c = die->die_child; c; c = c->die_sib)\n-    unmark_all_dies (c);\n+  FOR_EACH_CHILD (die, c, unmark_all_dies (c));\n \n   for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n     if (AT_class (a) == dw_val_class_die_ref)\n@@ -7148,8 +7142,7 @@ output_die (dw_die_ref die)\n \t}\n     }\n \n-  for (c = die->die_child; c != NULL; c = c->die_sib)\n-    output_die (c);\n+  FOR_EACH_CHILD (die, c, output_die (c));\n \n   /* Add null byte to terminate sibling list.  */\n   if (die->die_child != NULL)\n@@ -13846,9 +13839,10 @@ static void\n prune_unmark_dies (dw_die_ref die)\n {\n   dw_die_ref c;\n-  die->die_mark = 0;\n-  for (c = die->die_child; c; c = c->die_sib)\n-    prune_unmark_dies (c);\n+  \n+  if (die->die_mark)\n+    die->die_mark = 0;\n+  FOR_EACH_CHILD (die, c, prune_unmark_dies (c));\n }\n \n \n@@ -13916,16 +13910,12 @@ prune_unused_types_mark (dw_die_ref die, int dokids)\n \t Remember that we've walked the kids.  */\n       die->die_mark = 2;\n \n-      /* Walk them.  */\n-      for (c = die->die_child; c; c = c->die_sib)\n-\t{\n-\t  /* If this is an array type, we need to make sure our\n-\t     kids get marked, even if they're types.  */\n-\t  if (die->die_tag == DW_TAG_array_type)\n-\t    prune_unused_types_mark (c, 1);\n-\t  else\n-\t    prune_unused_types_walk (c);\n-\t}\n+      /* If this is an array type, we need to make sure our\n+\t kids get marked, even if they're types.  */\n+      if (die->die_tag == DW_TAG_array_type)\n+\tFOR_EACH_CHILD (die, c, prune_unused_types_mark (c, 1));\n+      else\n+\tFOR_EACH_CHILD (die, c, prune_unused_types_walk (c));\n     }\n }\n \n@@ -13978,8 +13968,7 @@ prune_unused_types_walk (dw_die_ref die)\n   prune_unused_types_walk_attribs (die);\n \n   /* Mark children.  */\n-  for (c = die->die_child; c; c = c->die_sib)\n-    prune_unused_types_walk (c);\n+  FOR_EACH_CHILD (die, c, prune_unused_types_walk (c));\n }\n \n /* Increment the string counts on strings referred to from DIE's\n@@ -14016,29 +14005,36 @@ prune_unused_types_update_strings (dw_die_ref die)\n static void\n prune_unused_types_prune (dw_die_ref die)\n {\n-  dw_die_ref *p;\n+  dw_die_ref c;\n \n   gcc_assert (die->die_mark);\n \n-  p = &die->die_child;\n-  while (*p)\n-    {\n-      dw_die_ref c = *p;\n-      if (c && ! c->die_mark)\n-\t{\n-\t  do {\n-\t    c = c->die_sib;\n-\t  } while (c && ! c->die_mark);\n-\t  *p = c;\n-\t}\n-      \n-      if (c)\n+  if (! die->die_child)\n+    return;\n+  \n+  c = die->die_child;\n+  do {\n+    dw_die_ref prev = c;\n+    for (c = c->die_sib; ! c->die_mark; c = c->die_sib)\n+      if (c == die->die_child)\n \t{\n-\t  prune_unused_types_update_strings (c);\n-\t  prune_unused_types_prune (c);\n-\t  p = &c->die_sib;\n+\t  /* No marked children between 'prev' and the end of the list.  */\n+\t  if (prev == c)\n+\t    /* No marked children at all.  */\n+\t    die->die_child = NULL;\n+\t  else\n+\t    {\n+\t      prev->die_sib = c->die_sib;\n+\t      die->die_child = prev;\n+\t    }\n+\t  return;\n \t}\n-    }\n+\n+    if (c != prev->die_sib)\n+      prev->die_sib = c;\n+    prune_unused_types_update_strings (c);\n+    prune_unused_types_prune (c);\n+  } while (c != die->die_child);\n }\n \n \n@@ -14166,10 +14162,6 @@ dwarf2out_finish (const char *filename)\n      emit full debugging info for them.  */\n   retry_incomplete_types ();\n \n-  /* We need to reverse all the dies before break_out_includes, or\n-     we'll see the end of an include file before the beginning.  */\n-  reverse_all_dies (comp_unit_die);\n-\n   if (flag_eliminate_unused_debug_types)\n     prune_unused_types ();\n "}]}