{"sha": "bec922f0407cfb7f184581dc7b5cc10d91cc1063", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVjOTIyZjA0MDdjZmI3ZjE4NDU4MWRjN2I1Y2MxMGQ5MWNjMTA2Mw==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2010-07-10T18:43:29Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2010-07-10T18:43:29Z"}, "message": "re PR middle-end/42505 (loop canonicalization causes a lot of unnecessary temporary variables)\n\n2010-07-10  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR middle-end/42505\n\n\tgcc/\n\t* tree-inline.c (estimate_num_insns): Refactor builtin complexity\n\tlookup code into....\n\t* builtins.c (is_simple_builtin, is_inexpensive_builtin): ...these\n\tnew functions.\n\t* tree.h (is_simple_builtin, is_inexpensive_builtin): Declare.\n\t* cfgloopanal.c (target_clobbered_regs): Define.\n\t(init_set_costs): Initialize target_clobbered_regs.\n\t(estimate_reg_pressure_cost): Add call_p argument.  When true,\n\tadjust the number of available registers to exclude the\n\tcall-clobbered registers.\n\t* cfgloop.h (target_clobbered_regs): Declare.\n\t(estimate_reg_pressure_cost): Adjust declaration.\n\t* tree-ssa-loop-ivopts.c (struct ivopts_data): Add body_includes_call.\n\t(ivopts_global_cost_for_size): Pass it to estimate_reg_pressure_cost.\n\t(determine_set_costs): Dump target_clobbered_regs.\n\t(loop_body_includes_call): New function.\n\t(tree_ssa_iv_optimize_loop): Use it to initialize new field.\n\t* loop-invariant.c (gain_for_invariant): Adjust arguments to pass\n\tcall_p flag through.\n\t(best_gain_for_invariant): Likewise.\n\t(find_invariants_to_move): Likewise.\n\t(move_single_loop_invariants): Likewise, using already-computed\n\thas_call field.\n\nFrom-SVN: r162043", "tree": {"sha": "b3a38775af4396d2f1d30d5d0c41a80f2bf0e78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3a38775af4396d2f1d30d5d0c41a80f2bf0e78f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bec922f0407cfb7f184581dc7b5cc10d91cc1063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec922f0407cfb7f184581dc7b5cc10d91cc1063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec922f0407cfb7f184581dc7b5cc10d91cc1063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec922f0407cfb7f184581dc7b5cc10d91cc1063/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35151cd5f8b9f94eee7853a25ae65df04591651a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35151cd5f8b9f94eee7853a25ae65df04591651a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35151cd5f8b9f94eee7853a25ae65df04591651a"}], "stats": {"total": 326, "additions": 215, "deletions": 111}, "files": [{"sha": "201f56ddea6bbb81a12cb99eed10b3d46c3464b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -1,3 +1,30 @@\n+2010-07-10  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR middle-end/42505\n+\t* tree-inline.c (estimate_num_insns): Refactor builtin complexity\n+\tlookup code into....\n+\t* builtins.c (is_simple_builtin, is_inexpensive_builtin): ...these\n+\tnew functions.\n+\t* tree.h (is_simple_builtin, is_inexpensive_builtin): Declare.\n+\t* cfgloopanal.c (target_clobbered_regs): Define.\n+\t(init_set_costs): Initialize target_clobbered_regs.\n+\t(estimate_reg_pressure_cost): Add call_p argument.  When true,\n+\tadjust the number of available registers to exclude the\n+\tcall-clobbered registers.\n+\t* cfgloop.h (target_clobbered_regs): Declare.\n+\t(estimate_reg_pressure_cost): Adjust declaration.\n+\t* tree-ssa-loop-ivopts.c (struct ivopts_data): Add body_includes_call.\n+\t(ivopts_global_cost_for_size): Pass it to estimate_reg_pressure_cost.\n+\t(determine_set_costs): Dump target_clobbered_regs.\n+\t(loop_body_includes_call): New function.\n+\t(tree_ssa_iv_optimize_loop): Use it to initialize new field.\n+\t* loop-invariant.c (gain_for_invariant): Adjust arguments to pass\n+\tcall_p flag through.\n+\t(best_gain_for_invariant): Likewise.\n+\t(find_invariants_to_move): Likewise.\n+\t(move_single_loop_invariants): Likewise, using already-computed\n+\thas_call field.\n+\n 2010-07-10  Richard Guenther  <rguenther@suse.de>\n \t    Joern Rennecke  <joern.rennecke@embecosm.com>\n "}, {"sha": "8039f9b8b11522cf3953f7d3940786d540819d17", "filename": "gcc/builtins.c", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -13753,3 +13753,123 @@ set_builtin_user_assembler_name (tree decl, const char *asmspec)\n       break;\n     }\n }\n+\n+/* Return true if DECL is a builtin that expands to a constant or similarly\n+   simple code.  */\n+bool\n+is_simple_builtin (tree decl)\n+{\n+  if (decl && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (decl))\n+      {\n+\t/* Builtins that expand to constants.  */\n+      case BUILT_IN_CONSTANT_P:\n+      case BUILT_IN_EXPECT:\n+      case BUILT_IN_OBJECT_SIZE:\n+      case BUILT_IN_UNREACHABLE:\n+\t/* Simple register moves or loads from stack.  */\n+      case BUILT_IN_RETURN_ADDRESS:\n+      case BUILT_IN_EXTRACT_RETURN_ADDR:\n+      case BUILT_IN_FROB_RETURN_ADDR:\n+      case BUILT_IN_RETURN:\n+      case BUILT_IN_AGGREGATE_INCOMING_ADDRESS:\n+      case BUILT_IN_FRAME_ADDRESS:\n+      case BUILT_IN_VA_END:\n+      case BUILT_IN_STACK_SAVE:\n+      case BUILT_IN_STACK_RESTORE:\n+\t/* Exception state returns or moves registers around.  */\n+      case BUILT_IN_EH_FILTER:\n+      case BUILT_IN_EH_POINTER:\n+      case BUILT_IN_EH_COPY_VALUES:\n+\treturn true;\n+\n+      default:\n+\treturn false;\n+      }\n+\n+  return false;\n+}\n+\n+/* Return true if DECL is a builtin that is not expensive, i.e., they are\n+   most probably expanded inline into reasonably simple code.  This is a\n+   superset of is_simple_builtin.  */\n+bool\n+is_inexpensive_builtin (tree decl)\n+{\n+  if (!decl)\n+    return false;\n+  else if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_MD)\n+    return true;\n+  else if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (decl))\n+      {\n+      case BUILT_IN_ABS:\n+      case BUILT_IN_ALLOCA:\n+      case BUILT_IN_BSWAP32:\n+      case BUILT_IN_BSWAP64:\n+      case BUILT_IN_CLZ:\n+      case BUILT_IN_CLZIMAX:\n+      case BUILT_IN_CLZL:\n+      case BUILT_IN_CLZLL:\n+      case BUILT_IN_CTZ:\n+      case BUILT_IN_CTZIMAX:\n+      case BUILT_IN_CTZL:\n+      case BUILT_IN_CTZLL:\n+      case BUILT_IN_FFS:\n+      case BUILT_IN_FFSIMAX:\n+      case BUILT_IN_FFSL:\n+      case BUILT_IN_FFSLL:\n+      case BUILT_IN_IMAXABS:\n+      case BUILT_IN_FINITE:\n+      case BUILT_IN_FINITEF:\n+      case BUILT_IN_FINITEL:\n+      case BUILT_IN_FINITED32:\n+      case BUILT_IN_FINITED64:\n+      case BUILT_IN_FINITED128:\n+      case BUILT_IN_FPCLASSIFY:\n+      case BUILT_IN_ISFINITE:\n+      case BUILT_IN_ISINF_SIGN:\n+      case BUILT_IN_ISINF:\n+      case BUILT_IN_ISINFF:\n+      case BUILT_IN_ISINFL:\n+      case BUILT_IN_ISINFD32:\n+      case BUILT_IN_ISINFD64:\n+      case BUILT_IN_ISINFD128:\n+      case BUILT_IN_ISNAN:\n+      case BUILT_IN_ISNANF:\n+      case BUILT_IN_ISNANL:\n+      case BUILT_IN_ISNAND32:\n+      case BUILT_IN_ISNAND64:\n+      case BUILT_IN_ISNAND128:\n+      case BUILT_IN_ISNORMAL:\n+      case BUILT_IN_ISGREATER:\n+      case BUILT_IN_ISGREATEREQUAL:\n+      case BUILT_IN_ISLESS:\n+      case BUILT_IN_ISLESSEQUAL:\n+      case BUILT_IN_ISLESSGREATER:\n+      case BUILT_IN_ISUNORDERED:\n+      case BUILT_IN_VA_ARG_PACK:\n+      case BUILT_IN_VA_ARG_PACK_LEN:\n+      case BUILT_IN_VA_COPY:\n+      case BUILT_IN_TRAP:\n+      case BUILT_IN_SAVEREGS:\n+      case BUILT_IN_POPCOUNTL:\n+      case BUILT_IN_POPCOUNTLL:\n+      case BUILT_IN_POPCOUNTIMAX:\n+      case BUILT_IN_POPCOUNT:\n+      case BUILT_IN_PARITYL:\n+      case BUILT_IN_PARITYLL:\n+      case BUILT_IN_PARITYIMAX:\n+      case BUILT_IN_PARITY:\n+      case BUILT_IN_LABS:\n+      case BUILT_IN_LLABS:\n+      case BUILT_IN_PREFETCH:\n+\treturn true;\n+\n+      default:\n+\treturn is_simple_builtin (decl);\n+      }\n+\n+  return false;\n+}\n+"}, {"sha": "46cda11861e49fd65f1b650ef2eb82f2cc557852", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -627,13 +627,14 @@ fel_init (loop_iterator *li, loop_p *loop, unsigned flags)\n /* The properties of the target.  */\n \n extern unsigned target_avail_regs;\n+extern unsigned target_clobbered_regs;\n extern unsigned target_res_regs;\n extern unsigned target_reg_cost [2];\n extern unsigned target_spill_cost [2];\n \n /* Register pressure estimation for induction variable optimizations & loop\n    invariant motion.  */\n-extern unsigned estimate_reg_pressure_cost (unsigned, unsigned, bool);\n+extern unsigned estimate_reg_pressure_cost (unsigned, unsigned, bool, bool);\n extern void init_set_costs (void);\n \n /* Loop optimizer initialization.  */"}, {"sha": "853e6f22dd43b9c58d9427fa39fba317301c336c", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -320,6 +320,8 @@ seq_cost (const_rtx seq, bool speed)\n /* The properties of the target.  */\n \n unsigned target_avail_regs;\t/* Number of available registers.  */\n+unsigned target_clobbered_regs; /* Number of available registers that are\n+\t\t\t\t   call-clobbered.  */\n unsigned target_res_regs;\t/* Number of registers reserved for temporary\n \t\t\t\t   expressions.  */\n unsigned target_reg_cost[2];\t/* The cost for register when there still\n@@ -342,10 +344,15 @@ init_set_costs (void)\n   unsigned i;\n \n   target_avail_regs = 0;\n+  target_clobbered_regs = 0;\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i)\n \t&& !fixed_regs[i])\n-      target_avail_regs++;\n+      {\n+\ttarget_avail_regs++;\n+\tif (call_used_regs[i])\n+\t  target_clobbered_regs++;\n+      }\n \n   target_res_regs = 3;\n \n@@ -379,20 +386,29 @@ init_set_costs (void)\n \n /* Estimates cost of increased register pressure caused by making N_NEW new\n    registers live around the loop.  N_OLD is the number of registers live\n-   around the loop.  */\n+   around the loop.  If CALL_P is true, also take into account that\n+   call-used registers may be clobbered in the loop body, reducing the\n+   number of available registers before we spill.  */\n \n unsigned\n-estimate_reg_pressure_cost (unsigned n_new, unsigned n_old, bool speed)\n+estimate_reg_pressure_cost (unsigned n_new, unsigned n_old, bool speed,\n+\t\t\t    bool call_p)\n {\n   unsigned cost;\n   unsigned regs_needed = n_new + n_old;\n+  unsigned available_regs = target_avail_regs;\n+\n+  /* If there is a call in the loop body, the call-clobbered registers\n+     are not available for loop invariants.  */\n+  if (call_p)\n+    available_regs = available_regs - target_clobbered_regs;\n \n   /* If we have enough registers, we should use them and not restrict\n      the transformations unnecessarily.  */\n-  if (regs_needed + target_res_regs <= target_avail_regs)\n+  if (regs_needed + target_res_regs <= available_regs)\n     return 0;\n \n-  if (regs_needed <= target_avail_regs)\n+  if (regs_needed <= available_regs)\n     /* If we are close to running out of registers, try to preserve\n        them.  */\n     cost = target_reg_cost [speed] * n_new;"}, {"sha": "19da7dd6e6d10b0a55167c8c15883cfed8ba8ff7", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -1173,11 +1173,13 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n /* Calculates gain for eliminating invariant INV.  REGS_USED is the number\n    of registers used in the loop, NEW_REGS is the number of new variables\n    already added due to the invariant motion.  The number of registers needed\n-   for it is stored in *REGS_NEEDED.  */\n+   for it is stored in *REGS_NEEDED.  SPEED and CALL_P are flags passed\n+   through to estimate_reg_pressure_cost. */\n \n static int\n gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n-\t\t    unsigned *new_regs, unsigned regs_used, bool speed)\n+\t\t    unsigned *new_regs, unsigned regs_used,\n+\t\t    bool speed, bool call_p)\n {\n   int comp_cost, size_cost;\n \n@@ -1188,9 +1190,9 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n   if (! flag_ira_loop_pressure)\n     {\n       size_cost = (estimate_reg_pressure_cost (new_regs[0] + regs_needed[0],\n-\t\t\t\t\t       regs_used, speed)\n+\t\t\t\t\t       regs_used, speed, call_p)\n \t\t   - estimate_reg_pressure_cost (new_regs[0],\n-\t\t\t\t\t\t regs_used, speed));\n+\t\t\t\t\t\t regs_used, speed, call_p));\n     }\n   else\n     {\n@@ -1245,7 +1247,8 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \n static int\n best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n-\t\t\t unsigned *new_regs, unsigned regs_used, bool speed)\n+\t\t\t unsigned *new_regs, unsigned regs_used,\n+\t\t\t bool speed, bool call_p)\n {\n   struct invariant *inv;\n   int i, gain = 0, again;\n@@ -1261,7 +1264,7 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n \tcontinue;\n \n       again = gain_for_invariant (inv, aregs_needed, new_regs, regs_used,\n-      \t\t\t\t  speed);\n+      \t\t\t\t  speed, call_p);\n       if (again > gain)\n \t{\n \t  gain = again;\n@@ -1314,7 +1317,7 @@ set_move_mark (unsigned invno, int gain)\n /* Determines which invariants to move.  */\n \n static void\n-find_invariants_to_move (bool speed)\n+find_invariants_to_move (bool speed, bool call_p)\n {\n   int gain;\n   unsigned i, regs_used, regs_needed[N_REG_CLASSES], new_regs[N_REG_CLASSES];\n@@ -1353,7 +1356,8 @@ find_invariants_to_move (bool speed)\n \tnew_regs[ira_reg_class_cover[i]] = 0;\n     }\n   while ((gain = best_gain_for_invariant (&inv, regs_needed,\n-\t\t\t\t\t  new_regs, regs_used, speed)) > 0)\n+\t\t\t\t\t  new_regs, regs_used,\n+\t\t\t\t\t  speed, call_p)) > 0)\n     {\n       set_move_mark (inv->invno, gain);\n       if (! flag_ira_loop_pressure)\n@@ -1573,7 +1577,8 @@ move_single_loop_invariants (struct loop *loop)\n   init_inv_motion_data ();\n \n   find_invariants (loop);\n-  find_invariants_to_move (optimize_loop_for_speed_p (loop));\n+  find_invariants_to_move (optimize_loop_for_speed_p (loop),\n+\t\t\t   LOOP_DATA (loop)->has_call);\n   move_invariants (loop);\n \n   free_inv_motion_data ();"}, {"sha": "4298958fb51bbbcc0de7aa284a35f58dc86233da", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 95, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -3478,105 +3478,13 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \tif (POINTER_TYPE_P (funtype))\n \t  funtype = TREE_TYPE (funtype);\n \n-\tif (decl && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_MD)\n+\tif (is_simple_builtin (decl))\n+\t  return 0;\n+\telse if (is_inexpensive_builtin (decl))\n \t  cost = weights->target_builtin_call_cost;\n \telse\n \t  cost = weights->call_cost;\n \n-\tif (decl && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n-\t  switch (DECL_FUNCTION_CODE (decl))\n-\t    {\n-\t    /* Builtins that expand to constants.  */\n-\t    case BUILT_IN_CONSTANT_P:\n-\t    case BUILT_IN_EXPECT:\n-\t    case BUILT_IN_OBJECT_SIZE:\n-\t    case BUILT_IN_UNREACHABLE:\n-\t    /* Simple register moves or loads from stack.  */\n-\t    case BUILT_IN_RETURN_ADDRESS:\n-\t    case BUILT_IN_EXTRACT_RETURN_ADDR:\n-\t    case BUILT_IN_FROB_RETURN_ADDR:\n-\t    case BUILT_IN_RETURN:\n-\t    case BUILT_IN_AGGREGATE_INCOMING_ADDRESS:\n-\t    case BUILT_IN_FRAME_ADDRESS:\n-\t    case BUILT_IN_VA_END:\n-\t    case BUILT_IN_STACK_SAVE:\n-\t    case BUILT_IN_STACK_RESTORE:\n-\t    /* Exception state returns or moves registers around.  */\n-\t    case BUILT_IN_EH_FILTER:\n-\t    case BUILT_IN_EH_POINTER:\n-\t    case BUILT_IN_EH_COPY_VALUES:\n-\t      return 0;\n-\n-\t    /* builtins that are not expensive (that is they are most probably\n-\t       expanded inline into resonably simple code).  */\n-\t    case BUILT_IN_ABS:\n-\t    case BUILT_IN_ALLOCA:\n-\t    case BUILT_IN_BSWAP32:\n-\t    case BUILT_IN_BSWAP64:\n-\t    case BUILT_IN_CLZ:\n-\t    case BUILT_IN_CLZIMAX:\n-\t    case BUILT_IN_CLZL:\n-\t    case BUILT_IN_CLZLL:\n-\t    case BUILT_IN_CTZ:\n-\t    case BUILT_IN_CTZIMAX:\n-\t    case BUILT_IN_CTZL:\n-\t    case BUILT_IN_CTZLL:\n-\t    case BUILT_IN_FFS:\n-\t    case BUILT_IN_FFSIMAX:\n-\t    case BUILT_IN_FFSL:\n-\t    case BUILT_IN_FFSLL:\n-\t    case BUILT_IN_IMAXABS:\n-\t    case BUILT_IN_FINITE:\n-\t    case BUILT_IN_FINITEF:\n-\t    case BUILT_IN_FINITEL:\n-\t    case BUILT_IN_FINITED32:\n-\t    case BUILT_IN_FINITED64:\n-\t    case BUILT_IN_FINITED128:\n-\t    case BUILT_IN_FPCLASSIFY:\n-\t    case BUILT_IN_ISFINITE:\n-\t    case BUILT_IN_ISINF_SIGN:\n-\t    case BUILT_IN_ISINF:\n-\t    case BUILT_IN_ISINFF:\n-\t    case BUILT_IN_ISINFL:\n-\t    case BUILT_IN_ISINFD32:\n-\t    case BUILT_IN_ISINFD64:\n-\t    case BUILT_IN_ISINFD128:\n-\t    case BUILT_IN_ISNAN:\n-\t    case BUILT_IN_ISNANF:\n-\t    case BUILT_IN_ISNANL:\n-\t    case BUILT_IN_ISNAND32:\n-\t    case BUILT_IN_ISNAND64:\n-\t    case BUILT_IN_ISNAND128:\n-\t    case BUILT_IN_ISNORMAL:\n-\t    case BUILT_IN_ISGREATER:\n-\t    case BUILT_IN_ISGREATEREQUAL:\n-\t    case BUILT_IN_ISLESS:\n-\t    case BUILT_IN_ISLESSEQUAL:\n-\t    case BUILT_IN_ISLESSGREATER:\n-\t    case BUILT_IN_ISUNORDERED:\n-\t    case BUILT_IN_VA_ARG_PACK:\n-\t    case BUILT_IN_VA_ARG_PACK_LEN:\n-\t    case BUILT_IN_VA_COPY:\n-\t    case BUILT_IN_TRAP:\n-\t    case BUILT_IN_SAVEREGS:\n-\t    case BUILT_IN_POPCOUNTL:\n-\t    case BUILT_IN_POPCOUNTLL:\n-\t    case BUILT_IN_POPCOUNTIMAX:\n-\t    case BUILT_IN_POPCOUNT:\n-\t    case BUILT_IN_PARITYL:\n-\t    case BUILT_IN_PARITYLL:\n-\t    case BUILT_IN_PARITYIMAX:\n-\t    case BUILT_IN_PARITY:\n-\t    case BUILT_IN_LABS:\n-\t    case BUILT_IN_LLABS:\n-\t    case BUILT_IN_PREFETCH:\n-\t      cost = weights->target_builtin_call_cost;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\n \tif (decl)\n \t  funtype = TREE_TYPE (decl);\n "}, {"sha": "83ec13e4a76c6ca234b993bc833bf566a6765eda", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -260,6 +260,9 @@ struct ivopts_data\n \n   /* Are we optimizing for speed?  */\n   bool speed;\n+\n+  /* Whether the loop body includes any function calls.  */\n+  bool body_includes_call;\n };\n \n /* An assignment of iv candidates to uses.  */\n@@ -4431,7 +4434,8 @@ ivopts_global_cost_for_size (struct ivopts_data *data, unsigned size)\n {\n   /* We add size to the cost, so that we prefer eliminating ivs\n      if possible.  */\n-  return size + estimate_reg_pressure_cost (size, data->regs_used, data->speed);\n+  return size + estimate_reg_pressure_cost (size, data->regs_used, data->speed,\n+\t\t\t\t\t    data->body_includes_call);\n }\n \n /* For each size of the induction variable set determine the penalty.  */\n@@ -4450,6 +4454,7 @@ determine_set_costs (struct ivopts_data *data)\n     {\n       fprintf (dump_file, \"Global costs:\\n\");\n       fprintf (dump_file, \"  target_avail_regs %d\\n\", target_avail_regs);\n+      fprintf (dump_file, \"  target_clobbered_regs %d\\n\", target_clobbered_regs);\n       fprintf (dump_file, \"  target_reg_cost %d\\n\", target_reg_cost[data->speed]);\n       fprintf (dump_file, \"  target_spill_cost %d\\n\", target_spill_cost[data->speed]);\n     }\n@@ -5859,6 +5864,25 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   VEC_free (iv_cand_p, heap, data->iv_candidates);\n }\n \n+/* Returns true if the loop body BODY includes any function calls.  */\n+\n+static bool\n+loop_body_includes_call (basic_block *body, unsigned num_nodes)\n+{\n+  gimple_stmt_iterator gsi;\n+  unsigned i;\n+\n+  for (i = 0; i < num_nodes; i++)\n+    for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple stmt = gsi_stmt (gsi);\n+\tif (is_gimple_call (stmt)\n+\t    && !is_inexpensive_builtin (gimple_call_fndecl (stmt)))\n+\t  return true;\n+      }\n+  return false;\n+}\n+\n /* Optimizes the LOOP.  Returns true if anything changed.  */\n \n static bool\n@@ -5890,6 +5914,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n     }\n \n   body = get_loop_body (loop);\n+  data->body_includes_call = loop_body_includes_call (body, loop->num_nodes);\n   renumber_gimple_stmt_uids_in_blocks (body, loop->num_nodes);\n   free (body);\n "}, {"sha": "960ee7d8e762f9e67dca624eb65501ac96fba74a", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec922f0407cfb7f184581dc7b5cc10d91cc1063/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bec922f0407cfb7f184581dc7b5cc10d91cc1063", "patch": "@@ -5046,6 +5046,8 @@ extern tree build_range_check (location_t, tree, tree, int, tree, tree);\n extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n \t\t\t  tree, tree);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n+extern bool is_simple_builtin (tree);\n+extern bool is_inexpensive_builtin (tree);\n \n /* In convert.c */\n extern tree strip_float_extensions (tree);"}]}