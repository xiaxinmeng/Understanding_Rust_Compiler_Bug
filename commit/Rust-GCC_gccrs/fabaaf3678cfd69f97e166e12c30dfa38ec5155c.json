{"sha": "fabaaf3678cfd69f97e166e12c30dfa38ec5155c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiYWFmMzY3OGNmZDY5Zjk3ZTE2NmUxMmMzMGRmYTM4ZWM1MTU1Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-08-31T05:00:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-08-31T05:00:37Z"}, "message": "re PR target/23630 (built-ins MMX regression)\n\n        PR target/23630\n        * expr.c (expand_expr_real_1) <VIEW_CONVERT_EXPR>: Use gen_lowpart\n        whenever the mode sizes match.\n\nFrom-SVN: r103660", "tree": {"sha": "3dfaf2a75a7406dac3941db39d4799e4588a421d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dfaf2a75a7406dac3941db39d4799e4588a421d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabaaf3678cfd69f97e166e12c30dfa38ec5155c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabaaf3678cfd69f97e166e12c30dfa38ec5155c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabaaf3678cfd69f97e166e12c30dfa38ec5155c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabaaf3678cfd69f97e166e12c30dfa38ec5155c/comments", "author": null, "committer": null, "parents": [{"sha": "eb6b2571f3d407896c8a45ee123c5c2a386bb4b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6b2571f3d407896c8a45ee123c5c2a386bb4b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6b2571f3d407896c8a45ee123c5c2a386bb4b9"}], "stats": {"total": 31, "additions": 21, "deletions": 10}, "files": [{"sha": "33a5c70724b411d071bb0062f515353eb3bb7dd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaaf3678cfd69f97e166e12c30dfa38ec5155c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaaf3678cfd69f97e166e12c30dfa38ec5155c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fabaaf3678cfd69f97e166e12c30dfa38ec5155c", "patch": "@@ -1,3 +1,9 @@\n+2005-08-30  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/23630\n+\t* expr.c (expand_expr_real_1) <VIEW_CONVERT_EXPR>: Use gen_lowpart\n+\twhenever the mode sizes match.\n+\n 2005-08-31  Alan Modra  <amodra@bigpond.net.au>\n \n \t* calls.c (load_register_parameters): Fix comment typo.\n@@ -84,8 +90,8 @@\n 2005-08-27  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/23539\n-        * config/rs6000/rs6000.c (expand_block_clear): Use HImode when\n-        bytes >= 2 not bytes == 2.\n+\t* config/rs6000/rs6000.c (expand_block_clear): Use HImode when\n+\tbytes >= 2 not bytes == 2.\n \t(expand_block_move): Same.\n \n 2005-08-27  Richard Guenther  <rguenther@suse.de>"}, {"sha": "e619808272e84bc2de5aafd53cf2505f95cc91c9", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabaaf3678cfd69f97e166e12c30dfa38ec5155c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabaaf3678cfd69f97e166e12c30dfa38ec5155c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fabaaf3678cfd69f97e166e12c30dfa38ec5155c", "patch": "@@ -7505,18 +7505,23 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case VIEW_CONVERT_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);\n \n-      /* If the input and output modes are both the same, we are done.\n-\t Otherwise, if neither mode is BLKmode and both are integral and within\n-\t a word, we can use gen_lowpart.  If neither is true, make sure the\n-\t operand is in memory and convert the MEM to the new mode.  */\n+      /* If the input and output modes are both the same, we are done.  */\n       if (TYPE_MODE (type) == GET_MODE (op0))\n \t;\n+      /* If neither mode is BLKmode, and both modes are the same size\n+\t then we can use gen_lowpart.  */\n       else if (TYPE_MODE (type) != BLKmode && GET_MODE (op0) != BLKmode\n-\t       && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-\t       && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT\n-\t       && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_WORD\n-\t       && GET_MODE_SIZE (GET_MODE (op0)) <= UNITS_PER_WORD)\n+\t       && GET_MODE_SIZE (TYPE_MODE (type))\n+\t\t   == GET_MODE_SIZE (GET_MODE (op0)))\n \top0 = gen_lowpart (TYPE_MODE (type), op0);\n+      /* If both modes are integral, then we can convert from one to the\n+\t other.  */\n+      else if (SCALAR_INT_MODE_P (GET_MODE (op0))\n+\t       && SCALAR_INT_MODE_P (TYPE_MODE (type)))\n+\top0 = convert_modes (TYPE_MODE (type), GET_MODE (op0), op0, \n+\t\t\t     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n+      /* As a last resort, spill op0 to memory, and reload it in a \n+\t different mode.  */\n       else if (!MEM_P (op0))\n \t{\n \t  /* If the operand is not a MEM, force it into memory.  Since we"}]}