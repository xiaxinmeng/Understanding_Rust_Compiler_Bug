{"sha": "3d2cfac61b57d399e5d452b5e7911c8b55c42088", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QyY2ZhYzYxYjU3ZDM5OWU1ZDQ1MmI1ZTc5MTFjOGI1NWM0MjA4OA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-10T23:22:37Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-10T23:22:37Z"}, "message": "i960-protos.h: New file.\n\n\t* i960-protos.h: New file.\n\n\t* i960.c: Include tm_p.h.  Add static prototypes.  Fix compile\n\ttime warnings.\n\n\t* i960.h: Move prototypes to i960-protos.h.  Fix compile time warnings.\n\nFrom-SVN: r31307", "tree": {"sha": "c09deee2f5d91a637cb870ee9845c97e138fe3b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c09deee2f5d91a637cb870ee9845c97e138fe3b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d2cfac61b57d399e5d452b5e7911c8b55c42088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2cfac61b57d399e5d452b5e7911c8b55c42088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d2cfac61b57d399e5d452b5e7911c8b55c42088", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2cfac61b57d399e5d452b5e7911c8b55c42088/comments", "author": null, "committer": null, "parents": [{"sha": "4c25fdcf52b85c8729cf1cdcc299773f12484874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c25fdcf52b85c8729cf1cdcc299773f12484874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c25fdcf52b85c8729cf1cdcc299773f12484874"}], "stats": {"total": 232, "additions": 168, "deletions": 64}, "files": [{"sha": "d5bca8abda5c44ca909c7c8f13cdfb3fdf9ba494", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d2cfac61b57d399e5d452b5e7911c8b55c42088", "patch": "@@ -1,3 +1,12 @@\n+2000-01-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* i960-protos.h: New file.\n+\n+\t* i960.c: Include tm_p.h.  Add static prototypes.  Fix compile\n+\ttime warnings.\n+\t\n+\t* i960.h: Move prototypes to i960-protos.h.  Fix compile time warnings.\n+\n 2000-01-10  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>\n \n \t* combine.c (expand_field_assignment): Do not discard SUBREGs"}, {"sha": "92357c9b0e72cda09a50b25d67c58e5c56f74864", "filename": "gcc/config/i960/i960-protos.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-protos.h?ref=3d2cfac61b57d399e5d452b5e7911c8b55c42088", "patch": "@@ -0,0 +1,104 @@\n+/* Definitions of target machine for GNU compiler, for Intel 80960\n+   Copyright (C) 2000\n+   Free Software Foundation, Inc.\n+   Contributed by Steven McGeady, Intel Corp.\n+   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n+   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef RTX_CODE\n+extern struct rtx_def *legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+/* Define the function that build the compare insn for scc and bcc.  */\n+\n+extern struct rtx_def *gen_compare_reg PARAMS ((enum rtx_code, rtx, rtx));\n+\n+/* Define functions in i960.c and used in insn-output.c.  */\n+\n+extern const char *i960_output_ldconst PARAMS ((rtx, rtx));\n+extern const char *i960_output_call_insn PARAMS ((rtx, rtx, rtx, rtx));\n+extern const char *i960_output_ret_insn PARAMS ((rtx));\n+extern const char *i960_output_move_double PARAMS ((rtx, rtx));\n+extern const char *i960_output_move_double_zero PARAMS ((rtx));\n+extern const char *i960_output_move_quad PARAMS ((rtx, rtx));\n+extern const char *i960_output_move_quad_zero PARAMS ((rtx));\n+\n+extern int literal PARAMS ((rtx, enum machine_mode));\n+extern int hard_regno_mode_ok PARAMS ((int, enum machine_mode));\n+extern int fp_literal PARAMS ((rtx, enum machine_mode));\n+extern int signed_literal PARAMS ((rtx, enum machine_mode));\n+extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n+extern void i960_print_operand PARAMS ((FILE *, rtx, int));\n+extern int fpmove_src_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int logic_operand PARAMS ((rtx, enum machine_mode));\n+extern int fp_arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int signed_arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int fp_literal_one PARAMS ((rtx, enum machine_mode));\n+extern int fp_literal_zero PARAMS ((rtx, enum machine_mode));\n+extern int symbolic_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int eq_or_neq PARAMS ((rtx, enum machine_mode));\n+extern int arith32_operand PARAMS ((rtx, enum machine_mode));\n+extern int power2_operand PARAMS ((rtx, enum machine_mode));\n+extern int cmplpower2_operand PARAMS ((rtx, enum machine_mode));\n+extern enum machine_mode select_cc_mode PARAMS ((RTX_CODE, rtx));\n+extern int i960_address_cost PARAMS ((rtx));\n+extern int emit_move_sequence PARAMS ((rtx *, enum machine_mode));\n+extern int i960_bypass PARAMS ((rtx, rtx, rtx, int));\n+extern void i960_print_operand_addr PARAMS ((FILE *, rtx));\n+extern int i960_expr_alignment PARAMS ((rtx, int));\n+extern int i960_improve_align PARAMS ((rtx, rtx, int));\n+extern int i960_si_ti PARAMS ((rtx, rtx));\n+extern int i960_si_di PARAMS ((rtx, rtx));\n+#ifdef TREE_CODE\n+extern struct rtx_def *i960_function_arg PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t  enum machine_mode,\n+\t\t\t\t\t\t  tree, int));\n+extern rtx i960_va_arg PARAMS ((tree, tree));\n+extern void i960_va_start PARAMS ((int, tree, rtx));\n+#endif /* TREE_CODE */\n+extern enum reg_class secondary_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern void i960_function_name_declare PARAMS ((FILE *, const char *, tree));\n+extern void i960_function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern int i960_round_align PARAMS ((int, tree));\n+extern void i960_setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int));\n+extern tree i960_build_va_list PARAMS ((void));\n+extern int i960_final_reg_parm_stack_space PARAMS ((int, tree));\n+extern int i960_reg_parm_stack_space PARAMS ((tree));\n+#endif /* TREE_CODE */\n+\n+#ifdef REAL_VALUE_TYPE\n+extern void i960_output_long_double PARAMS ((FILE *, REAL_VALUE_TYPE));\n+extern void i960_output_double PARAMS ((FILE *, REAL_VALUE_TYPE));\n+extern void i960_output_float PARAMS ((FILE *, REAL_VALUE_TYPE));\n+#endif /* REAL_VALUE_TYPE */\n+\n+extern int process_pragma PARAMS ((int(*)(void), void(*)(int), const char *));\n+extern int i960_object_bytes_bitalign PARAMS ((int));\n+extern void i960_initialize PARAMS ((void));\n+extern int bitpos PARAMS ((unsigned int));\n+extern int is_mask PARAMS ((unsigned int));\n+extern int bitstr PARAMS ((unsigned int, int *, int *));\n+extern int compute_frame_size PARAMS ((int));\n+extern void i960_function_prologue PARAMS ((FILE *, unsigned int));\n+extern void output_function_profiler PARAMS ((FILE *, int));\n+extern void i960_function_epilogue PARAMS ((FILE *, unsigned int));\n+extern void i960_scan_opcode PARAMS ((const char *));"}, {"sha": "2cde31ab087181051d6ddbac2e7c4e579ffd73b7", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=3d2cfac61b57d399e5d452b5e7911c8b55c42088", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on intel 80960.\n-   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999\n+   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000\n    Free Software Foundation, Inc.\n    Contributed by Steven McGeady, Intel Corp.\n    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include <math.h>\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -41,7 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n-#include <math.h>\n+#include \"tm_p.h\"\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -92,11 +93,10 @@ static int ret_label = 0;\n \n int\n process_pragma (p_getc, p_ungetc, pname)\n-     int (*  p_getc) PROTO ((void));\n-     void (* p_ungetc) PROTO ((int));\n-     char * pname;\n+     int (*  p_getc) PARAMS ((void));\n+     void (* p_ungetc) PARAMS ((int));\n+     const char *pname;\n {\n-  int i;\n   register int c;\n   char buf[20];\n   char *s = buf;\n@@ -259,7 +259,7 @@ signed_arith_operand (op, mode)\n int\n literal (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT) && INTVAL(op) >= 0 && INTVAL(op) < 32);\n }\n@@ -299,7 +299,7 @@ fp_literal(op, mode)\n int\n signed_literal(op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT) && INTVAL(op) > -32 && INTVAL(op) < 32);\n }\n@@ -310,7 +310,7 @@ signed_literal(op, mode)\n int\n symbolic_memory_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -326,7 +326,7 @@ symbolic_memory_operand (op, mode)\n int\n eq_or_neq (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n@@ -348,7 +348,7 @@ arith32_operand (op, mode)\n int\n power2_operand (op,mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -362,7 +362,7 @@ power2_operand (op,mode)\n int\n cmplpower2_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -480,7 +480,7 @@ bitstr (val, s, e)\n enum machine_mode\n select_cc_mode (op, x)\n      RTX_CODE op;\n-     rtx x;\n+     rtx x ATTRIBUTE_UNUSED;\n {\n   if (op == GTU || op == LTU || op == GEU || op == LEU)\n     return CC_UNSmode;\n@@ -623,7 +623,7 @@ emit_move_sequence (operands, mode)\n \n /* Output assembler to move a double word value.  */\n \n-char *\n+const char *\n i960_output_move_double (dst, src)\n      rtx dst, src;\n {\n@@ -695,7 +695,7 @@ i960_output_move_double (dst, src)\n \n /* Output assembler to move a double word zero.  */\n \n-char *\n+const char *\n i960_output_move_double_zero (dst)\n      rtx dst;\n {\n@@ -711,7 +711,7 @@ i960_output_move_double_zero (dst)\n \n /* Output assembler to move a quad word value.  */\n \n-char *\n+const char *\n i960_output_move_quad (dst, src)\n      rtx dst, src;\n {\n@@ -789,7 +789,7 @@ i960_output_move_quad (dst, src)\n \n /* Output assembler to move a quad word zero.  */\n \n-char *\n+const char *\n i960_output_move_quad_zero (dst)\n      rtx dst;\n {\n@@ -809,7 +809,7 @@ i960_output_move_quad_zero (dst)\n /* Emit insns to load a constant to non-floating point registers.\n    Uses several strategies to try to use as few insns as possible.  */\n \n-char *\n+const char *\n i960_output_ldconst (dst, src)\n      register rtx dst, src;\n {\n@@ -1063,7 +1063,7 @@ i960_bypass (insn, op1, op2, cmpbr_flag)\n void\n i960_function_name_declare (file, name, fndecl)\n      FILE *file;\n-     char *name;\n+     const char *name;\n      tree fndecl;\n {\n   register int i, j;\n@@ -1246,6 +1246,11 @@ struct reg_group\n   char length;\n };\n \n+static int i960_form_reg_groups PARAMS ((int, int, int *, int, struct reg_group *));\n+static int i960_reg_group_compare PARAMS ((const void *, const void *));\n+static int i960_split_reg_group PARAMS ((struct reg_group *, int, int));\n+static void i960_arg_size_and_align PARAMS ((enum machine_mode, tree, int *, int *));\n+\n /* The following functions forms the biggest as possible register\n    groups with registers in STATE.  REGS contain states of the\n    registers in range [start, finish_reg).  The function returns the\n@@ -1286,11 +1291,11 @@ i960_form_reg_groups (start_reg, finish_reg, regs, state, reg_groups)\n /* We sort register winodws in descending order by length. */\n static int\n i960_reg_group_compare (group1, group2)\n-     void *group1;\n-     void *group2;\n+     const void *group1;\n+     const void *group2;\n {\n-  struct reg_group *w1 = group1;\n-  struct reg_group *w2 = group2;\n+  const struct reg_group *w1 = group1;\n+  const struct reg_group *w2 = group2;\n \n   if (w1->length > w2->length)\n     return -1;\n@@ -1394,12 +1399,14 @@ i960_function_prologue (file, size)\n \t\t   ((g->length == 4) ? \"q\" :\n \t\t    (g->length == 3) ? \"t\" :\n \t\t    (g->length == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[g->start_reg], reg_names[l->start_reg]);\n+\t\t   reg_names[(unsigned char) g->start_reg],\n+\t\t   reg_names[(unsigned char) l->start_reg]);\n \t  sprintf (tmpstr, \"\\tmov%s\t%s,%s\\n\",\n \t\t   ((g->length == 4) ? \"q\" :\n \t\t    (g->length == 3) ? \"t\" :\n \t\t    (g->length == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[l->start_reg], reg_names[g->start_reg]);\n+\t\t   reg_names[(unsigned char) l->start_reg],\n+\t\t   reg_names[(unsigned char) g->start_reg]);\n \t  strcat (epilogue_string, tmpstr);\n \t  n_remaining_saved_regs -= g->length;\n \t  for (i = 0; i < g->length; i++)\n@@ -1607,7 +1614,7 @@ output_function_profiler (file, labelno)\n void\n i960_function_epilogue (file, size)\n      FILE *file;\n-     unsigned int size;\n+     unsigned int size ATTRIBUTE_UNUSED;\n {\n   if (i960_leaf_ret_reg >= 0)\n     {\n@@ -1667,7 +1674,7 @@ i960_function_epilogue (file, size)\n \n /* Output code for a call insn.  */\n \n-char *\n+const char *\n i960_output_call_insn (target, argsize_rtx, arg_pointer, insn)\n      register rtx target, argsize_rtx, arg_pointer, insn;\n {\n@@ -1719,7 +1726,7 @@ i960_output_call_insn (target, argsize_rtx, arg_pointer, insn)\n \n /* Output code for a return insn.  */\n \n-char *\n+const char *\n i960_output_ret_insn (insn)\n      register rtx insn;\n {\n@@ -1753,7 +1760,7 @@ i960_output_ret_insn (insn)\n    opcode to be tacked on an instruction.  This must at least\n    return a null string.  */\n \n-char *\n+const char *\n i960_br_predict_opcode (lab_ref, insn)\n      rtx lab_ref, insn;\n {\n@@ -1788,7 +1795,7 @@ void\n i960_print_operand (file, x, code)\n      FILE *file;\n      rtx x;\n-     char code;\n+     int code;\n {\n   enum rtx_code rtxcode = GET_CODE (x);\n \n@@ -2065,7 +2072,7 @@ i960_print_operand_addr (file, addr)\n \n int\n legitimate_address_p (mode, addr, strict)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      register rtx addr;\n      int strict;\n {\n@@ -2155,8 +2162,8 @@ legitimate_address_p (mode, addr, strict)\n rtx\n legitimize_address (x, oldx, mode)\n      register rtx x;\n-     register rtx oldx;\n-     enum machine_mode mode;\n+     register rtx oldx ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n { \n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n@@ -2333,7 +2340,7 @@ i960_expr_alignment (x, size)\n       break;\n \n     case ASHIFT:\n-      align = i960_expr_alignment (XEXP (x, 0));\n+      align = i960_expr_alignment (XEXP (x, 0), size);\n \n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n@@ -2348,6 +2355,8 @@ i960_expr_alignment (x, size)\n \n       align = MIN (align, 16);\n       break;\n+    default:\n+      break;\n     }\n \n   return align;\n@@ -2468,7 +2477,7 @@ i960_function_arg_advance (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n      enum machine_mode mode;\n      tree type;\n-     int named;\n+     int named ATTRIBUTE_UNUSED;\n {\n   int size, align;\n \n@@ -2495,7 +2504,7 @@ i960_function_arg (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n      enum machine_mode mode;\n      tree type;\n-     int named;\n+     int named ATTRIBUTE_UNUSED;\n {\n   rtx ret;\n   int size, align;\n@@ -2614,9 +2623,9 @@ i960_round_align (align, tsize)\n void\n i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n      CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int *pretend_size;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     tree type ATTRIBUTE_UNUSED;\n+     int *pretend_size ATTRIBUTE_UNUSED;\n      int no_rtl;\n {\n   /* Note: for a varargs fn with only a va_alist argument, this is 0.  */\n@@ -2840,7 +2849,7 @@ secondary_reload_class (class, mode, in)\n \n void\n i960_scan_opcode (p)\n-     char *p;\n+     const char *p;\n {\n   switch (*p)\n     {"}, {"sha": "d436a41539616b00af64ae80f5b19cef72854a9e", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2cfac61b57d399e5d452b5e7911c8b55c42088/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=3d2cfac61b57d399e5d452b5e7911c8b55c42088", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999\n+   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999, 2000\n    Free Software Foundation, Inc.\n    Contributed by Steven McGeady, Intel Corp.\n    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n@@ -132,7 +132,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Handle pragmas for compatibility with Intel's compilers.  */\n #define HANDLE_PRAGMA(GET, UNGET, NAME) process_pragma (GET, UNGET, NAME)\n-extern int process_pragma ();\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -338,17 +337,17 @@ extern int target_flags;\n {\t\t\t\t\t\t\t\t\\\n   if (TARGET_K_SERIES && TARGET_C_SERIES)\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      warning (\"conflicting architectures defined - using C series\", 0); \\\n+      warning (\"conflicting architectures defined - using C series\"); \\\n       target_flags &= ~TARGET_FLAG_K_SERIES;\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   if (TARGET_K_SERIES && TARGET_MC)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      warning (\"conflicting architectures defined - using K series\", 0); \\\n+      warning (\"conflicting architectures defined - using K series\"); \\\n       target_flags &= ~TARGET_FLAG_MC;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   if (TARGET_C_SERIES && TARGET_MC)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      warning (\"conflicting architectures defined - using C series\", 0);\\\n+      warning (\"conflicting architectures defined - using C series\");\\\n       target_flags &= ~TARGET_FLAG_MC;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   if (TARGET_IC_COMPAT3_0)\t\t\t\t\t\\\n@@ -358,7 +357,7 @@ extern int target_flags;\n       target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\t\t\\\n       if (TARGET_IC_COMPAT2_0)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\", 0); \\\n+\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\"); \\\n \t  target_flags &= ~TARGET_FLAG_IC_COMPAT2_0;\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n@@ -369,7 +368,7 @@ extern int target_flags;\n     }\t\t\t\t\t\t\t\t\\\n   /* ??? See the LONG_DOUBLE_TYPE_SIZE definition below.  */\t\\\n   if (TARGET_LONG_DOUBLE_64)\t\t\t\t\t\\\n-    warning (\"The -mlong-double-64 option does not work yet.\", 0);\\\n+    warning (\"The -mlong-double-64 option does not work yet.\");\\\n   i960_initialize ();\t\t\t\t\t\t\\\n }\n \n@@ -578,7 +577,6 @@ extern int target_flags;\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On 80960, the cpu registers can hold any mode but the float registers\n    can only hold SFmode, DFmode, or XFmode.  */\n-extern int hard_regno_mode_ok ();\n #define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok ((REGNO), (MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n@@ -950,7 +948,6 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-extern struct rtx_def *i960_function_arg ();\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n   i960_function_arg(&CUM, MODE, TYPE, NAMED)\n \n@@ -1156,7 +1153,6 @@ extern struct rtx_def *i960_function_arg ();\n \n /* On 80960, convert non-canonical addresses to canonical form.  */\n \n-extern struct rtx_def *legitimize_address ();\n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n { rtx orig_x = (X);\t\t\t\t\\\n   (X) = legitimize_address (X, OLDX, MODE);\t\\\n@@ -1242,10 +1238,6 @@ extern struct rtx_def *legitimize_address ();\n \n extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n \n-/* Define the function that build the compare insn for scc and bcc.  */\n-\n-extern struct rtx_def *gen_compare_reg ();\n-\n /* Add any extra modes needed to represent the condition code.\n \n    Also, signed and unsigned comparisons are distinguished, as\n@@ -1652,16 +1644,6 @@ extern enum insn_types i960_last_insn_type;\n   {\"power2_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"cmplpower2_operand\", {CONST_INT}},\n \n-/* Define functions in i960.c and used in insn-output.c.  */\n-\n-extern char *i960_output_ldconst ();\n-extern char *i960_output_call_insn ();\n-extern char *i960_output_ret_insn ();\n-extern char *i960_output_move_double ();\n-extern char *i960_output_move_double_zero ();\n-extern char *i960_output_move_quad ();\n-extern char *i960_output_move_quad_zero ();\n-\n /* Defined in reload.c, and used in insn-recog.c.  */\n \n extern int rtx_equal_function_value_matters;"}]}