{"sha": "f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYzZDYwMWI5NjI5ZmZiZjc1NmM5N2RhYzJkNDI0MWVkNDNkOWU0ZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-01-09T12:03:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-09T12:03:27Z"}, "message": "einfo.ads, einfo.adb: Remove uses of flags Has_Default_Init_Cond...\n\n2017-01-09  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.ads, einfo.adb: Remove uses of flags Has_Default_Init_Cond,\n\tIs_Default_Init_Cond_Procedure, and\n\tHas_Inherited_Default_Init_Cond.  Add uses of flags\n\tHas_Own_DIC, Is_DIC_Procedure, and Has_Inherited_DIC.\n\t(Default_Init_Cond_Procedure): Removed.\n\t(DIC_Procedure): New routine.\n\t(Has_Default_Init_Cond): Removed.\n\t(Has_DIC): New routine.\n\t(Has_Inheritable_Invariants): The attribute applies to the base type.\n\t(Has_Inherited_Default_Init_Cond): Removed.\n\t(Has_Inherited_DIC): New routine.\n\t(Has_Inherited_Invariants): The attribute applies to the base type.\n\t(Has_Own_DIC): New routine.\n\t(Has_Own_Invariants): The attribute applies to the base type.\n\t(Is_Default_Init_Cond_Procedure): Removed.\n\t(Is_DIC_Procedure): New routine.\n\t(Set_Default_Init_Cond_Procedure): Removed.\n\t(Set_DIC_Procedure): New routine.\n\t(Set_Has_Default_Init_Cond): Removed.\n\t(Set_Has_Inheritable_Invariants): The attribute applies\n\tto the base type.\n\t(Set_Has_Inherited_Default_Init_Cond): Removed.\n\t(Set_Has_Inherited_DIC): New routine.\n\t(Set_Has_Inherited_Invariants): The attribute applies to the base type.\n\t(Set_Has_Own_DIC): New routine.\n\t(Set_Has_Own_Invariants): The attribute applies to the base type.\n\t(Set_Is_Default_Init_Cond_Procedure): Removed.\n\t(Set_Is_DIC_Procedure): New routine.\n\t(Write_Entity_Flags): Update the output of all flags related to\n\tdefault initial condition.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Update the generation\n\tof the call to the DIC procedure.\n\t(Freeze_Type): Generate the body of the DIC procedure.\n\t* exp_ch7.adb (Build_Invariant_Procedure_Body): Replace\n\tall occurrences of Create_Append with Append_New_To. Do\n\tnot generate an invariant procedure for a class-wide type.\n\tThe generated body acts as a freeze action of the working type.\n\t(Build_Invariant_Procedure_Declaration): Do not generate an\n\tinvariant procedure for a class-wide type.\n\t(Create_Append): Removed.\n\t* exp_util.adb: Add with and use clauses for Sem_Ch3, sem_ch6,\n\tsem_Ch12, Sem_Disp, and GNAT.HTable. Move the handling of\n\tclass-wide pre/postcondition description and data structures from\n\tSem_Prag.\n\t(Build_Class_Wide_Expression): Moved from Sem_Prag.\n\t(Build_DIC_Call): New routine.\n\t(Build_DIC_Procedure_Body): New routine.\n\t(Build_DIC_Procedure_Declaration): New routine.\n\t(Entity_Hash): Moved from Sem_Prag.\n\t(Find_DIC_Type): New routine.\n\t(Update_Primitives_Mapping): Reimplemented.\n\t(Update_Primitives_Mapping_Of_Types): New routine.\n\t* exp_util.ads (Build_Class_Wide_Expression): Moved from Sem_Prag.\n\t(Build_DIC_Call): New routine.\n\t(Build_DIC_Procedure_Body): New routine.\n\t(Build_DIC_Procedure_Declaration): New routine.\n\t(Update_Primitives_Mapping): Moved from Sem_Prag.\n\t(Update_Primitives_Mapping_Of_Types): New routine.\n\t* nlists.adb (Append_New): New routine.\n\t(Append_New_To): New routine.\n\t* nlists.ads (Append_New): New routine.\n\t(Append_New_To): New routine.\n\t* sem_ch3.adb (Analyze_Declarations): Do not generate the bodies\n\tof DIC procedures here. This is now done at the end of the\n\tvisible declarations, private declarations, and at the freeze\n\tpoint of a type.\n\t(Analyze_Private_Extension_Declaration):\n\tA private extension inherits the DIC pragma of a parent type.\n\t(Analyze_Subtype_Declaration): No need to propagate invariant\n\tattributes to a subtype as those apply to the base type.\n\t(Build_Derived_Record_Type): No need to inherit invariants here\n\tas this is now done in Build_Derived_Type.\n\t(Build_Derived_Type): Inherit both the DIC pragma and invariants from\n\ta parent type.\n\t(Process_Full_View): Update the propagation of DIC attributes.\n\t(Propagate_Default_Init_Cond_Attributes): Removed.\n\t* sem_ch7.adb Add with and use clauses for Exp_Util.\n\t(Analyze_Package_Specification): Create the body of the DIC\n\tprocedure at the end of the visible and private declarations.\n\t(Preserve_Full_Attributes): Propagate DIC attributes.\n\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Propagate\n\tDIC attributes.\n\t(Analyze_Task_Type_Declaration): Propagate DIC attributes.\n\t* sem_elab.adb (Check_A_Call): Update the call to\n\tIs_Nontrivial_Default_Init_Cond_Procedure.\n\t* sem_prag.adb Remove the with and use clauses for\n\tGNAT.HTable. Move the handling of class- wide pre/postcondition\n\tdescription and data structures to Exp_Util.\n\t(Analyze_Pragma): Create the declaration of the DIC procedure. There\n\tis no need to propagate invariant-related attributes at this point\n\tas this is done in Build_Invariant_Procedure_Declaration.\n\t(Build_Class_Wide_Expression): Moved to Exp_Util.\n\t(Entity_Hash): Moved to Exp_Util.\n\t(Update_Primitives_Mapping): Moved to Exp_Util.\n\t* sem_prag.ads (Build_Class_Wide_Expression): Moved to Exp_Util.\n\t(Update_Primitives_Mapping): Moved to Exp_Util.\n\t* sem_util.adb: Remove with and use clauses for Ghost\n\tand Sem_Ch13.\n\t(Build_Default_Init_Cond_Call): Removed.\n\t(Build_Default_Init_Cond_Procedure_Bodies): Removed.\n\t(Build_Default_Init_Cond_Procedure_Declaration): Removed.\n\t(Get_Views): Reimplemented.\n\t(Has_Full_Default_Initialization): Reimplement the section on DIC.\n\t(Inherit_Default_Init_Cond_Procedure): Removed.\n\t(Is_Nontrivial_Default_Init_Cond_Procedure): Removed.\n\t(Is_Nontrivial_DIC_Procedure): New routine.\n\t(Is_Verifiable_DIC_Pragma): New routine.\n\t(Propagate_DIC_Attributes): New routine.\n\t* sem_util.ads (Build_Default_Init_Cond_Call): Removed.\n\t(Build_Default_Init_Cond_Procedure_Bodies): Removed.\n\t(Build_Default_Init_Cond_Procedure_Declaration): Removed.\n\t(Inherit_Default_Init_Cond_Procedure): Removed.\n\t(Is_Nontrivial_Default_Init_Cond_Procedure): Removed.\n\t(Is_Nontrivial_DIC_Procedure): New routine.\n\t(Is_Verifiable_DIC_Pragma): New routine.\n\t(Propagate_DIC_Attributes): New routine.\n\t* sem_warn.adb (Is_OK_Fully_Initialized): Reimplement the section\n\ton DIC.\n\t* sinfo.ads, sinfo.adb: Add new attribute Expression_Copy along with\n\tusage in nodes.\n\t(Expression_Copy): New routine along with pragma Inline.\n\t(Set_Expression_Copy): New routine along with pragma Inline.\n\nFrom-SVN: r244224", "tree": {"sha": "03d45e3343a5c67f1cd7ed05075ad1bd4a80c296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03d45e3343a5c67f1cd7ed05075ad1bd4a80c296"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01216d27de7de69ce1f09697e5f61ab414113824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01216d27de7de69ce1f09697e5f61ab414113824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01216d27de7de69ce1f09697e5f61ab414113824"}], "stats": {"total": 3288, "additions": 2036, "deletions": 1252}, "files": [{"sha": "8acf07e4cf303a70a33c8187672e05925615666d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -1,3 +1,128 @@\n+2017-01-09  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.ads, einfo.adb: Remove uses of flags Has_Default_Init_Cond,\n+\tIs_Default_Init_Cond_Procedure, and\n+\tHas_Inherited_Default_Init_Cond.  Add uses of flags\n+\tHas_Own_DIC, Is_DIC_Procedure, and Has_Inherited_DIC.\n+\t(Default_Init_Cond_Procedure): Removed.\n+\t(DIC_Procedure): New routine.\n+\t(Has_Default_Init_Cond): Removed.\n+\t(Has_DIC): New routine.\n+\t(Has_Inheritable_Invariants): The attribute applies to the base type.\n+\t(Has_Inherited_Default_Init_Cond): Removed.\n+\t(Has_Inherited_DIC): New routine.\n+\t(Has_Inherited_Invariants): The attribute applies to the base type.\n+\t(Has_Own_DIC): New routine.\n+\t(Has_Own_Invariants): The attribute applies to the base type.\n+\t(Is_Default_Init_Cond_Procedure): Removed.\n+\t(Is_DIC_Procedure): New routine.\n+\t(Set_Default_Init_Cond_Procedure): Removed.\n+\t(Set_DIC_Procedure): New routine.\n+\t(Set_Has_Default_Init_Cond): Removed.\n+\t(Set_Has_Inheritable_Invariants): The attribute applies\n+\tto the base type.\n+\t(Set_Has_Inherited_Default_Init_Cond): Removed.\n+\t(Set_Has_Inherited_DIC): New routine.\n+\t(Set_Has_Inherited_Invariants): The attribute applies to the base type.\n+\t(Set_Has_Own_DIC): New routine.\n+\t(Set_Has_Own_Invariants): The attribute applies to the base type.\n+\t(Set_Is_Default_Init_Cond_Procedure): Removed.\n+\t(Set_Is_DIC_Procedure): New routine.\n+\t(Write_Entity_Flags): Update the output of all flags related to\n+\tdefault initial condition.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Update the generation\n+\tof the call to the DIC procedure.\n+\t(Freeze_Type): Generate the body of the DIC procedure.\n+\t* exp_ch7.adb (Build_Invariant_Procedure_Body): Replace\n+\tall occurrences of Create_Append with Append_New_To. Do\n+\tnot generate an invariant procedure for a class-wide type.\n+\tThe generated body acts as a freeze action of the working type.\n+\t(Build_Invariant_Procedure_Declaration): Do not generate an\n+\tinvariant procedure for a class-wide type.\n+\t(Create_Append): Removed.\n+\t* exp_util.adb: Add with and use clauses for Sem_Ch3, sem_ch6,\n+\tsem_Ch12, Sem_Disp, and GNAT.HTable. Move the handling of\n+\tclass-wide pre/postcondition description and data structures from\n+\tSem_Prag.\n+\t(Build_Class_Wide_Expression): Moved from Sem_Prag.\n+\t(Build_DIC_Call): New routine.\n+\t(Build_DIC_Procedure_Body): New routine.\n+\t(Build_DIC_Procedure_Declaration): New routine.\n+\t(Entity_Hash): Moved from Sem_Prag.\n+\t(Find_DIC_Type): New routine.\n+\t(Update_Primitives_Mapping): Reimplemented.\n+\t(Update_Primitives_Mapping_Of_Types): New routine.\n+\t* exp_util.ads (Build_Class_Wide_Expression): Moved from Sem_Prag.\n+\t(Build_DIC_Call): New routine.\n+\t(Build_DIC_Procedure_Body): New routine.\n+\t(Build_DIC_Procedure_Declaration): New routine.\n+\t(Update_Primitives_Mapping): Moved from Sem_Prag.\n+\t(Update_Primitives_Mapping_Of_Types): New routine.\n+\t* nlists.adb (Append_New): New routine.\n+\t(Append_New_To): New routine.\n+\t* nlists.ads (Append_New): New routine.\n+\t(Append_New_To): New routine.\n+\t* sem_ch3.adb (Analyze_Declarations): Do not generate the bodies\n+\tof DIC procedures here. This is now done at the end of the\n+\tvisible declarations, private declarations, and at the freeze\n+\tpoint of a type.\n+\t(Analyze_Private_Extension_Declaration):\n+\tA private extension inherits the DIC pragma of a parent type.\n+\t(Analyze_Subtype_Declaration): No need to propagate invariant\n+\tattributes to a subtype as those apply to the base type.\n+\t(Build_Derived_Record_Type): No need to inherit invariants here\n+\tas this is now done in Build_Derived_Type.\n+\t(Build_Derived_Type): Inherit both the DIC pragma and invariants from\n+\ta parent type.\n+\t(Process_Full_View): Update the propagation of DIC attributes.\n+\t(Propagate_Default_Init_Cond_Attributes): Removed.\n+\t* sem_ch7.adb Add with and use clauses for Exp_Util.\n+\t(Analyze_Package_Specification): Create the body of the DIC\n+\tprocedure at the end of the visible and private declarations.\n+\t(Preserve_Full_Attributes): Propagate DIC attributes.\n+\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Propagate\n+\tDIC attributes.\n+\t(Analyze_Task_Type_Declaration): Propagate DIC attributes.\n+\t* sem_elab.adb (Check_A_Call): Update the call to\n+\tIs_Nontrivial_Default_Init_Cond_Procedure.\n+\t* sem_prag.adb Remove the with and use clauses for\n+\tGNAT.HTable. Move the handling of class- wide pre/postcondition\n+\tdescription and data structures to Exp_Util.\n+\t(Analyze_Pragma): Create the declaration of the DIC procedure. There\n+\tis no need to propagate invariant-related attributes at this point\n+\tas this is done in Build_Invariant_Procedure_Declaration.\n+\t(Build_Class_Wide_Expression): Moved to Exp_Util.\n+\t(Entity_Hash): Moved to Exp_Util.\n+\t(Update_Primitives_Mapping): Moved to Exp_Util.\n+\t* sem_prag.ads (Build_Class_Wide_Expression): Moved to Exp_Util.\n+\t(Update_Primitives_Mapping): Moved to Exp_Util.\n+\t* sem_util.adb: Remove with and use clauses for Ghost\n+\tand Sem_Ch13.\n+\t(Build_Default_Init_Cond_Call): Removed.\n+\t(Build_Default_Init_Cond_Procedure_Bodies): Removed.\n+\t(Build_Default_Init_Cond_Procedure_Declaration): Removed.\n+\t(Get_Views): Reimplemented.\n+\t(Has_Full_Default_Initialization): Reimplement the section on DIC.\n+\t(Inherit_Default_Init_Cond_Procedure): Removed.\n+\t(Is_Nontrivial_Default_Init_Cond_Procedure): Removed.\n+\t(Is_Nontrivial_DIC_Procedure): New routine.\n+\t(Is_Verifiable_DIC_Pragma): New routine.\n+\t(Propagate_DIC_Attributes): New routine.\n+\t* sem_util.ads (Build_Default_Init_Cond_Call): Removed.\n+\t(Build_Default_Init_Cond_Procedure_Bodies): Removed.\n+\t(Build_Default_Init_Cond_Procedure_Declaration): Removed.\n+\t(Inherit_Default_Init_Cond_Procedure): Removed.\n+\t(Is_Nontrivial_Default_Init_Cond_Procedure): Removed.\n+\t(Is_Nontrivial_DIC_Procedure): New routine.\n+\t(Is_Verifiable_DIC_Pragma): New routine.\n+\t(Propagate_DIC_Attributes): New routine.\n+\t* sem_warn.adb (Is_OK_Fully_Initialized): Reimplement the section\n+\ton DIC.\n+\t* sinfo.ads, sinfo.adb: Add new attribute Expression_Copy along with\n+\tusage in nodes.\n+\t(Expression_Copy): New routine along with pragma Inline.\n+\t(Set_Expression_Copy): New routine along with pragma Inline.\n+\n 2017-01-06  Bob Duff  <duff@adacore.com>\n \n \t* bindgen.adb (Gen_Adainit, Gen_Adafinal): Change"}, {"sha": "f62c13979c40e783bffd5da954812f64911462c3", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -290,7 +290,7 @@ package body Einfo is\n \n    --    Is_Inlined_Always               Flag1\n    --    Is_Hidden_Non_Overridden_Subpgm Flag2\n-   --    Has_Default_Init_Cond           Flag3\n+   --    Has_Own_DIC                     Flag3\n    --    Is_Frozen                       Flag4\n    --    Has_Discriminants               Flag5\n    --    Is_Dispatching_Operation        Flag6\n@@ -432,8 +432,8 @@ package body Einfo is\n    --    Is_Generic_Instance             Flag130\n \n    --    No_Pool_Assigned                Flag131\n-   --    Is_Default_Init_Cond_Procedure  Flag132\n-   --    Has_Inherited_Default_Init_Cond Flag133\n+   --    Is_DIC_Procedure                Flag132\n+   --    Has_Inherited_DIC               Flag133\n    --    Has_Aliased_Components          Flag135\n    --    No_Strict_Aliasing              Flag136\n    --    Is_Machine_Code_Subprogram      Flag137\n@@ -1527,12 +1527,6 @@ package body Einfo is\n       return Flag39 (Base_Type (Id));\n    end Has_Default_Aspect;\n \n-   function Has_Default_Init_Cond (Id : E) return B is\n-   begin\n-      pragma Assert (Is_Type (Id));\n-      return Flag3 (Base_Type (Id));\n-   end Has_Default_Init_Cond;\n-\n    function Has_Delayed_Aspects (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -1619,19 +1613,19 @@ package body Einfo is\n    function Has_Inheritable_Invariants (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n-      return Flag248 (Id);\n+      return Flag248 (Base_Type (Id));\n    end Has_Inheritable_Invariants;\n \n-   function Has_Inherited_Default_Init_Cond (Id : E) return B is\n+   function Has_Inherited_DIC (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n       return Flag133 (Base_Type (Id));\n-   end Has_Inherited_Default_Init_Cond;\n+   end Has_Inherited_DIC;\n \n    function Has_Inherited_Invariants (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n-      return Flag291 (Id);\n+      return Flag291 (Base_Type (Id));\n    end Has_Inherited_Invariants;\n \n    function Has_Initial_Value (Id : E) return B is\n@@ -1693,10 +1687,16 @@ package body Einfo is\n       return Flag110 (Id);\n    end Has_Out_Or_In_Out_Parameter;\n \n+   function Has_Own_DIC (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag3 (Base_Type (Id));\n+   end Has_Own_DIC;\n+\n    function Has_Own_Invariants (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n-      return Flag232 (Id);\n+      return Flag232 (Base_Type (Id));\n    end Has_Own_Invariants;\n \n    function Has_Partial_Visible_Refinement (Id : E) return B is\n@@ -2155,11 +2155,11 @@ package body Einfo is\n       return Flag74 (Id);\n    end Is_CPP_Class;\n \n-   function Is_Default_Init_Cond_Procedure (Id : E) return B is\n+   function Is_DIC_Procedure (Id : E) return B is\n    begin\n       pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n       return Flag132 (Id);\n-   end Is_Default_Init_Cond_Procedure;\n+   end Is_DIC_Procedure;\n \n    function Is_Descendant_Of_Address (Id : E) return B is\n    begin\n@@ -4563,12 +4563,6 @@ package body Einfo is\n       Set_Flag39 (Id, V);\n    end Set_Has_Default_Aspect;\n \n-   procedure Set_Has_Default_Init_Cond (Id : E; V : B := True) is\n-   begin\n-      pragma Assert (Is_Type (Id));\n-      Set_Flag3 (Base_Type (Id), V);\n-   end Set_Has_Default_Init_Cond;\n-\n    procedure Set_Has_Delayed_Aspects (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4660,19 +4654,19 @@ package body Einfo is\n    procedure Set_Has_Inheritable_Invariants (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n-      Set_Flag248 (Id, V);\n+      Set_Flag248 (Base_Type (Id), V);\n    end Set_Has_Inheritable_Invariants;\n \n-   procedure Set_Has_Inherited_Default_Init_Cond (Id : E; V : B := True) is\n+   procedure Set_Has_Inherited_DIC (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n       Set_Flag133 (Base_Type (Id), V);\n-   end Set_Has_Inherited_Default_Init_Cond;\n+   end Set_Has_Inherited_DIC;\n \n    procedure Set_Has_Inherited_Invariants (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n-      Set_Flag291 (Id, V);\n+      Set_Flag291 (Base_Type (Id), V);\n    end Set_Has_Inherited_Invariants;\n \n    procedure Set_Has_Initial_Value (Id : E; V : B := True) is\n@@ -4735,10 +4729,16 @@ package body Einfo is\n       Set_Flag110 (Id, V);\n    end Set_Has_Out_Or_In_Out_Parameter;\n \n+   procedure Set_Has_Own_DIC (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag3 (Base_Type (Id), V);\n+   end Set_Has_Own_DIC;\n+\n    procedure Set_Has_Own_Invariants (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n-      Set_Flag232 (Id, V);\n+      Set_Flag232 (Base_Type (Id), V);\n    end Set_Has_Own_Invariants;\n \n    procedure Set_Has_Partial_Visible_Refinement (Id : E; V : B := True) is\n@@ -5243,11 +5243,11 @@ package body Einfo is\n       Set_Flag74 (Id, V);\n    end Set_Is_CPP_Class;\n \n-   procedure Set_Is_Default_Init_Cond_Procedure (Id : E; V : B := True) is\n+   procedure Set_Is_DIC_Procedure (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n       Set_Flag132 (Id, V);\n-   end Set_Is_Default_Init_Cond_Procedure;\n+   end Set_Is_DIC_Procedure;\n \n    procedure Set_Is_Descendant_Of_Address (Id : E; V : B := True) is\n    begin\n@@ -7053,39 +7053,6 @@ package body Einfo is\n       end loop;\n    end Declaration_Node;\n \n-   ---------------------------------\n-   -- Default_Init_Cond_Procedure --\n-   ---------------------------------\n-\n-   function Default_Init_Cond_Procedure (Id : E) return E is\n-      Subp_Elmt : Elmt_Id;\n-      Subp_Id   : Entity_Id;\n-      Subps     : Elist_Id;\n-\n-   begin\n-      pragma Assert\n-        (Is_Type (Id)\n-          and then (Has_Default_Init_Cond (Id)\n-                     or else Has_Inherited_Default_Init_Cond (Id)));\n-\n-      Subps := Subprograms_For_Type (Base_Type (Id));\n-\n-      if Present (Subps) then\n-         Subp_Elmt := First_Elmt (Subps);\n-         while Present (Subp_Elmt) loop\n-            Subp_Id := Node (Subp_Elmt);\n-\n-            if Is_Default_Init_Cond_Procedure (Subp_Id) then\n-               return Subp_Id;\n-            end if;\n-\n-            Next_Elmt (Subp_Elmt);\n-         end loop;\n-      end if;\n-\n-      return Empty;\n-   end Default_Init_Cond_Procedure;\n-\n    ---------------------\n    -- Designated_Type --\n    ---------------------\n@@ -7113,6 +7080,36 @@ package body Einfo is\n       end if;\n    end Designated_Type;\n \n+   -------------------\n+   -- DIC_Procedure --\n+   -------------------\n+\n+   function DIC_Procedure (Id : E) return E is\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n+\n+   begin\n+      pragma Assert (Is_Type (Id));\n+\n+      Subps := Subprograms_For_Type (Base_Type (Id));\n+\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Is_DIC_Procedure (Subp_Id) then\n+               return Subp_Id;\n+            end if;\n+\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end DIC_Procedure;\n+\n    ----------------------\n    -- Entry_Index_Type --\n    ----------------------\n@@ -7430,6 +7427,15 @@ package body Einfo is\n       return False;\n    end Has_Attach_Handler;\n \n+   -------------\n+   -- Has_DIC --\n+   -------------\n+\n+   function Has_DIC (Id : E) return B is\n+   begin\n+      return Has_Own_DIC (Id) or else Has_Inherited_DIC (Id);\n+   end Has_DIC;\n+\n    -----------------\n    -- Has_Entries --\n    -----------------\n@@ -7671,7 +7677,7 @@ package body Einfo is\n    begin\n       pragma Assert (Is_Type (Id));\n \n-      Subps := Subprograms_For_Type (Id);\n+      Subps := Subprograms_For_Type (Base_Type (Id));\n \n       if Present (Subps) then\n          Subp_Elmt := First_Elmt (Subps);\n@@ -8407,7 +8413,7 @@ package body Einfo is\n    begin\n       pragma Assert (Is_Type (Id));\n \n-      Subps := Subprograms_For_Type (Id);\n+      Subps := Subprograms_For_Type (Base_Type (Id));\n \n       if Present (Subps) then\n          Subp_Elmt := First_Elmt (Subps);\n@@ -8820,28 +8826,18 @@ package body Einfo is\n       end case;\n    end Set_Component_Alignment;\n \n-   -------------------------------------\n-   -- Set_Default_Init_Cond_Procedure --\n-   -------------------------------------\n+   -----------------------\n+   -- Set_DIC_Procedure --\n+   -----------------------\n \n-   procedure Set_Default_Init_Cond_Procedure (Id : E; V : E) is\n+   procedure Set_DIC_Procedure (Id : E; V : E) is\n       Base_Typ  : Entity_Id;\n       Subp_Elmt : Elmt_Id;\n       Subp_Id   : Entity_Id;\n       Subps     : Elist_Id;\n \n    begin\n-      --  Once set, this attribute cannot be reset\n-\n-      if No (V) then\n-         pragma Assert (No (Default_Init_Cond_Procedure (Id)));\n-         return;\n-      end if;\n-\n-      pragma Assert\n-        (Is_Type (Id)\n-          and then (Has_Default_Init_Cond (Id)\n-                     or else Has_Inherited_Default_Init_Cond (Id)));\n+      pragma Assert (Is_Type (Id));\n \n       Base_Typ := Base_Type (Id);\n       Subps    := Subprograms_For_Type (Base_Typ);\n@@ -8859,31 +8855,33 @@ package body Einfo is\n       while Present (Subp_Elmt) loop\n          Subp_Id := Node (Subp_Elmt);\n \n-         if Is_Default_Init_Cond_Procedure (Subp_Id) then\n+         if Is_DIC_Procedure (Subp_Id) then\n             raise Program_Error;\n          end if;\n \n          Next_Elmt (Subp_Elmt);\n       end loop;\n-   end Set_Default_Init_Cond_Procedure;\n+   end Set_DIC_Procedure;\n \n    -----------------------------\n    -- Set_Invariant_Procedure --\n    -----------------------------\n \n    procedure Set_Invariant_Procedure (Id : E; V : E) is\n+      Base_Typ  : Entity_Id;\n       Subp_Elmt : Elmt_Id;\n       Subp_Id   : Entity_Id;\n       Subps     : Elist_Id;\n \n    begin\n       pragma Assert (Is_Type (Id));\n \n-      Subps := Subprograms_For_Type (Id);\n+      Base_Typ := Base_Type (Id);\n+      Subps    := Subprograms_For_Type (Base_Typ);\n \n       if No (Subps) then\n          Subps := New_Elmt_List;\n-         Set_Subprograms_For_Type (Id, Subps);\n+         Set_Subprograms_For_Type (Base_Typ, Subps);\n       end if;\n \n       Subp_Elmt := First_Elmt (Subps);\n@@ -8907,18 +8905,20 @@ package body Einfo is\n    -------------------------------------\n \n    procedure Set_Partial_Invariant_Procedure (Id : E; V : E) is\n+      Base_Typ  : Entity_Id;\n       Subp_Elmt : Elmt_Id;\n       Subp_Id   : Entity_Id;\n       Subps     : Elist_Id;\n \n    begin\n       pragma Assert (Is_Type (Id));\n \n-      Subps := Subprograms_For_Type (Id);\n+      Base_Typ := Base_Type (Id);\n+      Subps    := Subprograms_For_Type (Base_Typ);\n \n       if No (Subps) then\n          Subps := New_Elmt_List;\n-         Set_Subprograms_For_Type (Id, Subps);\n+         Set_Subprograms_For_Type (Base_Typ, Subps);\n       end if;\n \n       Subp_Elmt := First_Elmt (Subps);\n@@ -9277,7 +9277,6 @@ package body Einfo is\n       W (\"Has_Controlling_Result\",          Flag98  (Id));\n       W (\"Has_Convention_Pragma\",           Flag119 (Id));\n       W (\"Has_Default_Aspect\",              Flag39  (Id));\n-      W (\"Has_Default_Init_Cond\",           Flag3   (Id));\n       W (\"Has_Delayed_Aspects\",             Flag200 (Id));\n       W (\"Has_Delayed_Freeze\",              Flag18  (Id));\n       W (\"Has_Delayed_Rep_Aspects\",         Flag261 (Id));\n@@ -9294,7 +9293,7 @@ package body Einfo is\n       W (\"Has_Implicit_Dereference\",        Flag251 (Id));\n       W (\"Has_Independent_Components\",      Flag34  (Id));\n       W (\"Has_Inheritable_Invariants\",      Flag248 (Id));\n-      W (\"Has_Inherited_Default_Init_Cond\", Flag133 (Id));\n+      W (\"Has_Inherited_DIC\",               Flag133 (Id));\n       W (\"Has_Inherited_Invariants\",        Flag291 (Id));\n       W (\"Has_Initial_Value\",               Flag219 (Id));\n       W (\"Has_Loop_Entry_Attributes\",       Flag260 (Id));\n@@ -9306,6 +9305,7 @@ package body Einfo is\n       W (\"Has_Non_Standard_Rep\",            Flag75  (Id));\n       W (\"Has_Out_Or_In_Out_Parameter\",     Flag110 (Id));\n       W (\"Has_Object_Size_Clause\",          Flag172 (Id));\n+      W (\"Has_Own_DIC\",                     Flag3   (Id));\n       W (\"Has_Own_Invariants\",              Flag232 (Id));\n       W (\"Has_Per_Object_Constraint\",       Flag154 (Id));\n       W (\"Has_Pragma_Controlled\",           Flag27  (Id));\n@@ -9381,8 +9381,8 @@ package body Einfo is\n       W (\"Is_Constructor\",                  Flag76  (Id));\n       W (\"Is_Controlled\",                   Flag42  (Id));\n       W (\"Is_Controlling_Formal\",           Flag97  (Id));\n-      W (\"Is_Default_Init_Cond_Procedure\",  Flag132 (Id));\n       W (\"Is_Descendant_Of_Address\",        Flag223 (Id));\n+      W (\"Is_DIC_Procedure\",                Flag132 (Id));\n       W (\"Is_Discrim_SO_Function\",          Flag176 (Id));\n       W (\"Is_Discriminant_Check_Function\",  Flag264 (Id));\n       W (\"Is_Dispatch_Table_Entity\",        Flag234 (Id));"}, {"sha": "fd63ac5f43130a2ad6b3507f38085be22f9652d3", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -848,16 +848,6 @@ package Einfo is\n --       default expressions (see Freeze.Process_Default_Expressions), which\n --       would not only waste time, but also generate false error messages.\n \n---    Default_Init_Cond_Procedure (synthesized)\n---       Defined in all types. Set for private [sub]types subject to pragma\n---       Default_Initial_Condition, their corresponding full views and derived\n---       types with at least one parent subject to the pragma. Contains the\n---       entity of the procedure which takes a single argument of the given\n---       type and verifies the assumption of the pragma.\n---\n---       Note: the reason this is marked as a synthesized attribute is that the\n---       way this is stored is as an element of the Subprograms_For_Type field.\n-\n --    Default_Value (Node20)\n --       Defined in formal parameters. Points to the node representing the\n --       expression for the default value for the parameter. Empty if the\n@@ -932,6 +922,16 @@ package Einfo is\n --       incomplete type, and the full type is available, then this full type\n --       is returned instead of the incomplete type.\n \n+--    DIC_Procedure (synthesized)\n+--       Defined in all type entities. Set for a private type and its full view\n+--       when the type is subject to pragma Default_Initial_Condition (DIC), or\n+--       when the type inherits a DIC pragma from a parent type. Points to the\n+--       entity of a procedure which takes a single argument of the given type\n+--       and verifies the assertion expression of the DIC pragma at runtime.\n+\n+--       Note: the reason this is marked as a synthesized attribute is that the\n+--       way this is stored is as an element of the Subprograms_For_Type field.\n+\n --    Digits_Value (Uint17)\n --       Defined in floating point types and subtypes and decimal types and\n --       subtypes. Contains the Digits value specified in the declaration.\n@@ -1574,11 +1574,6 @@ package Einfo is\n --       value is set, but it may be overridden by an aspect declaration on\n --       type derivation.\n \n---    Has_Default_Init_Cond (Flag3) [base type only]\n---       Defined in all type entities. Set if pragma Default_Initial_Condition\n---       applies to a private type and by extension to its full view. This flag\n---       is mutually exclusive with flag Has_Inherited_Default_Init_Cond.\n-\n --    Has_Delayed_Aspects (Flag200)\n --      Defined in all entities. Set if the Rep_Item chain for the entity has\n --      one or more N_Aspect_Definition nodes chained which are not to be\n@@ -1600,6 +1595,11 @@ package Einfo is\n --       set, signalling that Freeze.Inherit_Delayed_Rep_Aspects must be called\n --       at the freeze point of the derived type.\n \n+--    Has_DIC (syntherized)\n+--       Defined in all type entities. Set for a private type and its full view\n+--       when the type is subject to pragma Default_Initial_Condition (DIC), or\n+--       when the type inherits a DIC pragma from a parent type.\n+\n --    Has_Discriminants (Flag5)\n --       Defined in all types and subtypes. For types that are allowed to have\n --       discriminants (record types and subtypes, task types and subtypes,\n@@ -1706,18 +1706,17 @@ package Einfo is\n --       will be chained to the rep item chain of the first subtype in the\n --       usual manner.\n \n---    Has_Inheritable_Invariants (Flag248)\n+--    Has_Inheritable_Invariants (Flag248) [base type only]\n --       Defined in all type entities. Set on private types and interface types\n --       which define at least one class-wide invariant. Such invariants must\n --       be inherited by derived types. The flag is also set on the full view\n --       of a private type for completeness.\n \n---    Has_Inherited_Default_Init_Cond (Flag133) [base type only]\n---       Defined in all type entities. Set when a derived type inherits pragma\n---       Default_Initial_Condition from its parent type. This flag is mutually\n---       exclusive with flag Has_Default_Init_Cond.\n+--    Has_Inherited_DIC (Flag133) [base type only]\n+--       Defined in all type entities. Set for a derived type which inherits\n+--       pragma Default_Initial_Condition from a parent type.\n \n---    Has_Inherited_Invariants (Flag291)\n+--    Has_Inherited_Invariants (Flag291) [base type only]\n --       Defined in all type entities. Set on private extensions and derived\n --       types which inherit at least on class-wide invariant from a parent or\n --       an interface type. The flag is also set on the full view of a private\n@@ -1816,10 +1815,14 @@ package Einfo is\n --       families. Set if they have at least one OUT or IN OUT parameter\n --       (allowed for functions only in Ada 2012).\n \n---    Has_Own_Invariants (Flag232)\n+--    Has_Own_DIC (Flag3) [base type only]\n+--       Defined in all type entities. Set for a private type and its full view\n+--       when the type is subject to pragma Default_Initial_Condition.\n+\n+--    Has_Own_Invariants (Flag232) [base type only]\n --       Defined in all type entities. Set on any type which defines at least\n --       one invariant of its own. The flag is also set on the full view of a\n---       private extension or a private type for completeness.\n+--       private type for completeness.\n \n --    Has_Partial_Visible_Refinement (Flag296)\n --       Defined in E_Abstract_State entities. Set when a state has at least\n@@ -2422,14 +2425,15 @@ package Einfo is\n --       Applies to all type entities, true for decimal fixed point\n --       types and subtypes.\n \n---    Is_Default_Init_Cond_Procedure (Flag132)\n---       Defined in functions and procedures. Set for a generated procedure\n---       which verifies the assumption of pragma Default_Initial_Condition.\n-\n --    Is_Descendant_Of_Address (Flag223)\n --       Defined in all entities. True if the entity is type System.Address,\n --       or (recursively) a subtype or derived type of System.Address.\n \n+--    Is_DIC_Procedure (Flag132)\n+--       Defined in functions and procedures. Set for a generated procedure\n+--       which verifies the assumption of pragma Default_Initial_Condition at\n+--       runtime.\n+\n --    Is_Discrete_Or_Fixed_Point_Type (synthesized)\n --       Applies to all entities, true for all discrete types and subtypes\n --       and all fixed-point types and subtypes.\n@@ -5558,16 +5562,16 @@ package Einfo is\n    --    Has_Constrained_Partial_View        (Flag187)\n    --    Has_Controlled_Component            (Flag43)   (base type only)\n    --    Has_Default_Aspect                  (Flag39)   (base type only)\n-   --    Has_Default_Init_Cond               (Flag3)    (base type only)\n    --    Has_Delayed_Rep_Aspects             (Flag261)\n    --    Has_Discriminants                   (Flag5)\n    --    Has_Dynamic_Predicate_Aspect        (Flag258)\n    --    Has_Independent_Components          (Flag34)   (base type only)\n    --    Has_Inheritable_Invariants          (Flag248)  (base type only)\n-   --    Has_Inherited_Default_Init_Cond     (Flag133)  (base type only)\n+   --    Has_Inherited_DIC                   (Flag133)  (base type only)\n    --    Has_Inherited_Invariants            (Flag291)  (base type only)\n    --    Has_Non_Standard_Rep                (Flag75)   (base type only)\n    --    Has_Object_Size_Clause              (Flag172)\n+   --    Has_Own_DIC                         (Flag3)    (base type only)\n    --    Has_Own_Invariants                  (Flag232)  (base type only)\n    --    Has_Pragma_Preelab_Init             (Flag221)\n    --    Has_Pragma_Unreferenced_Objects     (Flag212)\n@@ -5621,7 +5625,8 @@ package Einfo is\n \n    --    Alignment_Clause                    (synth)\n    --    Base_Type                           (synth)\n-   --    Default_Init_Cond_Procedure         (synth)\n+   --    DIC_Procedure                       (synth)\n+   --    Has_DIC                             (synth)\n    --    Has_Invariants                      (synth)\n    --    Implementation_Base_Type            (synth)\n    --    Invariant_Procedure                 (synth)\n@@ -6026,7 +6031,7 @@ package Einfo is\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Constructor                      (Flag76)\n-   --    Is_Default_Init_Cond_Procedure      (Flag132)  (non-generic case only)\n+   --    Is_DIC_Procedure                    (Flag132)  (non-generic case only)\n    --    Is_Discrim_SO_Function              (Flag176)\n    --    Is_Discriminant_Check_Function      (Flag264)\n    --    Is_Eliminated                       (Flag124)\n@@ -6337,7 +6342,7 @@ package Einfo is\n    --    Is_Asynchronous                     (Flag81)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Constructor                      (Flag76)\n-   --    Is_Default_Init_Cond_Procedure      (Flag132)  (non-generic case only)\n+   --    Is_DIC_Procedure                    (Flag132)  (non-generic case only)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Generic_Actual_Subprogram        (Flag274)  (non-generic case only)\n    --    Is_Hidden_Non_Overridden_Subpgm     (Flag2)    (non-generic case only)\n@@ -6982,10 +6987,10 @@ package Einfo is\n    function Has_Controlling_Result              (Id : E) return B;\n    function Has_Convention_Pragma               (Id : E) return B;\n    function Has_Default_Aspect                  (Id : E) return B;\n-   function Has_Default_Init_Cond               (Id : E) return B;\n    function Has_Delayed_Aspects                 (Id : E) return B;\n    function Has_Delayed_Freeze                  (Id : E) return B;\n    function Has_Delayed_Rep_Aspects             (Id : E) return B;\n+   function Has_DIC                             (Id : E) return B;\n    function Has_Discriminants                   (Id : E) return B;\n    function Has_Dispatch_Table                  (Id : E) return B;\n    function Has_Dynamic_Predicate_Aspect        (Id : E) return B;\n@@ -6999,7 +7004,7 @@ package Einfo is\n    function Has_Implicit_Dereference            (Id : E) return B;\n    function Has_Independent_Components          (Id : E) return B;\n    function Has_Inheritable_Invariants          (Id : E) return B;\n-   function Has_Inherited_Default_Init_Cond     (Id : E) return B;\n+   function Has_Inherited_DIC                   (Id : E) return B;\n    function Has_Inherited_Invariants            (Id : E) return B;\n    function Has_Initial_Value                   (Id : E) return B;\n    function Has_Interrupt_Handler               (Id : E) return B;\n@@ -7013,6 +7018,7 @@ package Einfo is\n    function Has_Non_Standard_Rep                (Id : E) return B;\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Out_Or_In_Out_Parameter         (Id : E) return B;\n+   function Has_Own_DIC                         (Id : E) return B;\n    function Has_Own_Invariants                  (Id : E) return B;\n    function Has_Partial_Visible_Refinement      (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n@@ -7098,8 +7104,8 @@ package Einfo is\n    function Is_Controlled                       (Id : E) return B;\n    function Is_Controlling_Formal               (Id : E) return B;\n    function Is_CPP_Class                        (Id : E) return B;\n-   function Is_Default_Init_Cond_Procedure      (Id : E) return B;\n    function Is_Descendant_Of_Address            (Id : E) return B;\n+   function Is_DIC_Procedure                    (Id : E) return B;\n    function Is_Discrim_SO_Function              (Id : E) return B;\n    function Is_Discriminant_Check_Function      (Id : E) return B;\n    function Is_Dispatch_Table_Entity            (Id : E) return B;\n@@ -7664,7 +7670,6 @@ package Einfo is\n    procedure Set_Has_Controlling_Result          (Id : E; V : B := True);\n    procedure Set_Has_Convention_Pragma           (Id : E; V : B := True);\n    procedure Set_Has_Default_Aspect              (Id : E; V : B := True);\n-   procedure Set_Has_Default_Init_Cond           (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Aspects             (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Freeze              (Id : E; V : B := True);\n    procedure Set_Has_Delayed_Rep_Aspects         (Id : E; V : B := True);\n@@ -7681,7 +7686,7 @@ package Einfo is\n    procedure Set_Has_Implicit_Dereference        (Id : E; V : B := True);\n    procedure Set_Has_Independent_Components      (Id : E; V : B := True);\n    procedure Set_Has_Inheritable_Invariants      (Id : E; V : B := True);\n-   procedure Set_Has_Inherited_Default_Init_Cond (Id : E; V : B := True);\n+   procedure Set_Has_Inherited_DIC               (Id : E; V : B := True);\n    procedure Set_Has_Inherited_Invariants        (Id : E; V : B := True);\n    procedure Set_Has_Initial_Value               (Id : E; V : B := True);\n    procedure Set_Has_Loop_Entry_Attributes       (Id : E; V : B := True);\n@@ -7693,6 +7698,7 @@ package Einfo is\n    procedure Set_Has_Non_Standard_Rep            (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Out_Or_In_Out_Parameter     (Id : E; V : B := True);\n+   procedure Set_Has_Own_DIC                     (Id : E; V : B := True);\n    procedure Set_Has_Own_Invariants              (Id : E; V : B := True);\n    procedure Set_Has_Partial_Visible_Refinement  (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n@@ -7778,8 +7784,8 @@ package Einfo is\n    procedure Set_Is_Controlled                   (Id : E; V : B := True);\n    procedure Set_Is_Controlling_Formal           (Id : E; V : B := True);\n    procedure Set_Is_CPP_Class                    (Id : E; V : B := True);\n-   procedure Set_Is_Default_Init_Cond_Procedure  (Id : E; V : B := True);\n    procedure Set_Is_Descendant_Of_Address        (Id : E; V : B := True);\n+   procedure Set_Is_DIC_Procedure                (Id : E; V : B := True);\n    procedure Set_Is_Discrim_SO_Function          (Id : E; V : B := True);\n    procedure Set_Is_Discriminant_Check_Function  (Id : E; V : B := True);\n    procedure Set_Is_Dispatch_Table_Entity        (Id : E; V : B := True);\n@@ -8009,17 +8015,17 @@ package Einfo is\n    -- Access to Subprograms in Subprograms_For_Type --\n    ---------------------------------------------------\n \n-   function Default_Init_Cond_Procedure         (Id : E) return E;\n-   function Invariant_Procedure                 (Id : E) return E;\n-   function Partial_Invariant_Procedure         (Id : E) return E;\n-   function Predicate_Function                  (Id : E) return E;\n-   function Predicate_Function_M                (Id : E) return E;\n+   function DIC_Procedure                        (Id : E) return E;\n+   function Invariant_Procedure                  (Id : E) return E;\n+   function Partial_Invariant_Procedure          (Id : E) return E;\n+   function Predicate_Function                   (Id : E) return E;\n+   function Predicate_Function_M                 (Id : E) return E;\n \n-   procedure Set_Default_Init_Cond_Procedure    (Id : E; V : E);\n-   procedure Set_Invariant_Procedure            (Id : E; V : E);\n-   procedure Set_Partial_Invariant_Procedure    (Id : E; V : E);\n-   procedure Set_Predicate_Function             (Id : E; V : E);\n-   procedure Set_Predicate_Function_M           (Id : E; V : E);\n+   procedure Set_DIC_Procedure                   (Id : E; V : E);\n+   procedure Set_Invariant_Procedure             (Id : E; V : E);\n+   procedure Set_Partial_Invariant_Procedure     (Id : E; V : E);\n+   procedure Set_Predicate_Function              (Id : E; V : E);\n+   procedure Set_Predicate_Function_M            (Id : E; V : E);\n \n    -----------------------------------\n    -- Field Initialization Routines --\n@@ -8459,7 +8465,6 @@ package Einfo is\n    pragma Inline (Has_Controlling_Result);\n    pragma Inline (Has_Convention_Pragma);\n    pragma Inline (Has_Default_Aspect);\n-   pragma Inline (Has_Default_Init_Cond);\n    pragma Inline (Has_Delayed_Aspects);\n    pragma Inline (Has_Delayed_Freeze);\n    pragma Inline (Has_Delayed_Rep_Aspects);\n@@ -8476,7 +8481,7 @@ package Einfo is\n    pragma Inline (Has_Implicit_Dereference);\n    pragma Inline (Has_Independent_Components);\n    pragma Inline (Has_Inheritable_Invariants);\n-   pragma Inline (Has_Inherited_Default_Init_Cond);\n+   pragma Inline (Has_Inherited_DIC);\n    pragma Inline (Has_Inherited_Invariants);\n    pragma Inline (Has_Initial_Value);\n    pragma Inline (Has_Loop_Entry_Attributes);\n@@ -8488,6 +8493,7 @@ package Einfo is\n    pragma Inline (Has_Non_Standard_Rep);\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Out_Or_In_Out_Parameter);\n+   pragma Inline (Has_Own_DIC);\n    pragma Inline (Has_Own_Invariants);\n    pragma Inline (Has_Partial_Visible_Refinement);\n    pragma Inline (Has_Per_Object_Constraint);\n@@ -8584,8 +8590,8 @@ package Einfo is\n    pragma Inline (Is_Controlling_Formal);\n    pragma Inline (Is_CPP_Class);\n    pragma Inline (Is_Decimal_Fixed_Point_Type);\n-   pragma Inline (Is_Default_Init_Cond_Procedure);\n    pragma Inline (Is_Descendant_Of_Address);\n+   pragma Inline (Is_DIC_Procedure);\n    pragma Inline (Is_Digits_Type);\n    pragma Inline (Is_Discrete_Or_Fixed_Point_Type);\n    pragma Inline (Is_Discrete_Type);\n@@ -8978,7 +8984,6 @@ package Einfo is\n    pragma Inline (Set_Has_Controlling_Result);\n    pragma Inline (Set_Has_Convention_Pragma);\n    pragma Inline (Set_Has_Default_Aspect);\n-   pragma Inline (Set_Has_Default_Init_Cond);\n    pragma Inline (Set_Has_Delayed_Aspects);\n    pragma Inline (Set_Has_Delayed_Freeze);\n    pragma Inline (Set_Has_Delayed_Rep_Aspects);\n@@ -8995,7 +9000,7 @@ package Einfo is\n    pragma Inline (Set_Has_Implicit_Dereference);\n    pragma Inline (Set_Has_Independent_Components);\n    pragma Inline (Set_Has_Inheritable_Invariants);\n-   pragma Inline (Set_Has_Inherited_Default_Init_Cond);\n+   pragma Inline (Set_Has_Inherited_DIC);\n    pragma Inline (Set_Has_Inherited_Invariants);\n    pragma Inline (Set_Has_Initial_Value);\n    pragma Inline (Set_Has_Loop_Entry_Attributes);\n@@ -9007,6 +9012,7 @@ package Einfo is\n    pragma Inline (Set_Has_Non_Standard_Rep);\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Out_Or_In_Out_Parameter);\n+   pragma Inline (Set_Has_Own_DIC);\n    pragma Inline (Set_Has_Own_Invariants);\n    pragma Inline (Set_Has_Partial_Visible_Refinement);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n@@ -9090,8 +9096,8 @@ package Einfo is\n    pragma Inline (Set_Is_Controlled);\n    pragma Inline (Set_Is_Controlling_Formal);\n    pragma Inline (Set_Is_CPP_Class);\n-   pragma Inline (Set_Is_Default_Init_Cond_Procedure);\n    pragma Inline (Set_Is_Descendant_Of_Address);\n+   pragma Inline (Set_Is_DIC_Procedure);\n    pragma Inline (Set_Is_Discrim_SO_Function);\n    pragma Inline (Set_Is_Discriminant_Check_Function);\n    pragma Inline (Set_Is_Dispatch_Table_Entity);"}, {"sha": "bee99ca621f40ec619020b22bdd5aaf2bfdef5e3", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -6528,19 +6528,18 @@ package body Exp_Ch3 is\n       --  pragma Default_Initial_Condition, add a runtime check to verify\n       --  the assumption of the pragma (SPARK RM 7.3.3). Generate:\n \n-      --    <Base_Typ>Default_Init_Cond (<Base_Typ> (Def_Id));\n+      --    <Base_Typ>DIC (<Base_Typ> (Def_Id));\n \n       --  Note that the check is generated for source objects only\n \n       if Comes_From_Source (Def_Id)\n-        and then (Has_Default_Init_Cond (Typ)\n-                   or else Has_Inherited_Default_Init_Cond (Typ))\n+        and then Has_DIC (Typ)\n+        and then Present (DIC_Procedure (Typ))\n         and then not Has_Init_Expression (N)\n-        and then Present (Default_Init_Cond_Procedure (Typ))\n       then\n          declare\n-            DIC_Call : constant Node_Id :=\n-                         Build_Default_Init_Cond_Call (Loc, Def_Id, Typ);\n+            DIC_Call : constant Node_Id := Build_DIC_Call (Loc, Def_Id, Typ);\n+\n          begin\n             if Present (Next_N) then\n                Insert_Before_And_Analyze (Next_N, DIC_Call);\n@@ -7320,6 +7319,13 @@ package body Exp_Ch3 is\n       Process_Pending_Access_Types (Def_Id);\n       Freeze_Stream_Operations (N, Def_Id);\n \n+      --  Generate the [spec and] body of the procedure tasked with the runtime\n+      --  verification of pragma Default_Initial_Condition's expression.\n+\n+      if Has_DIC (Def_Id) then\n+         Build_DIC_Procedure_Body (Def_Id);\n+      end if;\n+\n       --  Generate the [spec and] body of the invariant procedure tasked with\n       --  the runtime verification of all invariants that pertain to the type.\n       --  This includes invariants on the partial and full view, inherited"}, {"sha": "7f49f3224414512bb62f7be20d444ee207285f13", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -3525,9 +3525,6 @@ package body Exp_Ch7 is\n       --  inherited class-wide invariants. Priv_Item denotes the first rep\n       --  item of the private type.\n \n-      procedure Create_Append (L : in out List_Id; N : Node_Id);\n-      --  Append arbitrary node N to list L. If there is no list, create one.\n-\n       function Is_Untagged_Private_Derivation\n         (Priv_Typ : Entity_Id;\n          Full_Typ : Entity_Id) return Boolean;\n@@ -3589,7 +3586,7 @@ package body Exp_Ch7 is\n                --  effect.\n \n                if not Has_Null_Body (Proc_Id) then\n-                  Create_Append (Comp_Checks,\n+                  Append_New_To (Comp_Checks,\n                     Make_Procedure_Call_Statement (Loc,\n                       Name                   =>\n                         New_Occurrence_Of (Proc_Id, Loc),\n@@ -3628,7 +3625,7 @@ package body Exp_Ch7 is\n                --  effect.\n \n                if not Has_Null_Body (Proc_Id) then\n-                  Create_Append (Comp_Checks,\n+                  Append_New_To (Comp_Checks,\n                     Make_If_Statement (Loc,\n                       Condition       =>\n                         Make_Op_Ne (Loc,\n@@ -3703,7 +3700,7 @@ package body Exp_Ch7 is\n                --  effect.\n \n                if Present (Comp_Checks) then\n-                  Create_Append (Dim_Checks,\n+                  Append_New_To (Dim_Checks,\n                     Make_Implicit_Loop_Statement (T,\n                       Identifier       => Empty,\n                       Iteration_Scheme =>\n@@ -3906,7 +3903,7 @@ package body Exp_Ch7 is\n                      Var_Stmts := New_List (Make_Null_Statement (Loc));\n                   end if;\n \n-                  Create_Append (Var_Alts,\n+                  Append_New_To (Var_Alts,\n                     Make_Case_Statement_Alternative (Loc,\n                       Discrete_Choices =>\n                         New_Copy_List (Discrete_Choices (Var)),\n@@ -3920,7 +3917,7 @@ package body Exp_Ch7 is\n                --  values only when there is at least one real invariant check.\n \n                if Produced_Variant_Check then\n-                  Create_Append (CL_Checks,\n+                  Append_New_To (CL_Checks,\n                     Make_Case_Statement (Loc,\n                       Expression   =>\n                         Make_Selected_Component (Loc,\n@@ -3980,7 +3977,7 @@ package body Exp_Ch7 is\n                --  effect.\n \n                if not Has_Null_Body (Proc_Id) then\n-                  Create_Append (Comp_Checks,\n+                  Append_New_To (Comp_Checks,\n                     Make_Procedure_Call_Statement (Loc,\n                       Name                   =>\n                         New_Occurrence_Of (Proc_Id, Loc),\n@@ -4023,7 +4020,7 @@ package body Exp_Ch7 is\n                --  effect.\n \n                if not Has_Null_Body (Proc_Id) then\n-                  Create_Append (Comp_Checks,\n+                  Append_New_To (Comp_Checks,\n                     Make_If_Statement (Loc,\n                       Condition       =>\n                         Make_Op_Ne (Loc,\n@@ -4356,7 +4353,7 @@ package body Exp_Ch7 is\n                --  Generate:\n                --    pragma Check (<Nam>, <Expr>, <Str>);\n \n-               Create_Append (Checks,\n+               Append_New_To (Checks,\n                  Make_Pragma (Ploc,\n                    Chars                        => Name_Check,\n                    Pragma_Argument_Associations => Assoc));\n@@ -4443,19 +4440,6 @@ package body Exp_Ch7 is\n          end if;\n       end Add_Type_Invariants;\n \n-      -------------------\n-      -- Create_Append --\n-      -------------------\n-\n-      procedure Create_Append (L : in out List_Id; N : Node_Id) is\n-      begin\n-         if No (L) then\n-            L := New_List;\n-         end if;\n-\n-         Append_To (L, N);\n-      end Create_Append;\n-\n       ------------------------------------\n       -- Is_Untagged_Private_Derivation --\n       ------------------------------------\n@@ -4494,11 +4478,6 @@ package body Exp_Ch7 is\n       Full_Typ : Entity_Id;\n       --  The full view of the working type\n \n-      Freeze_Typ : Entity_Id;\n-      --  The freeze type whose freeze node carries the invariant procedure\n-      --  body. This is either the partial or the full view of the working\n-      --  type.\n-\n       Obj_Id : Entity_Id;\n       --  The _object formal parameter of the invariant procedure\n \n@@ -4539,10 +4518,15 @@ package body Exp_Ch7 is\n \n       pragma Assert (Has_Invariants (Work_Typ));\n \n+      --  ??? invariants of class-wide types are not properly implemented\n+\n+      if Is_Class_Wide_Type (Work_Typ) then\n+         return;\n+\n       --  Nothing to do for interface types as their class-wide invariants are\n       --  inherited by implementing types.\n \n-      if Is_Interface (Work_Typ) then\n+      elsif Is_Interface (Work_Typ) then\n          return;\n       end if;\n \n@@ -4633,7 +4617,6 @@ package body Exp_Ch7 is\n \n       if Partial_Invariant then\n          pragma Assert (Present (Priv_Typ));\n-         Freeze_Typ := Priv_Typ;\n \n          Add_Type_Invariants\n            (Priv_Typ => Priv_Typ,\n@@ -4650,15 +4633,14 @@ package body Exp_Ch7 is\n \n       else\n          pragma Assert (Present (Full_Typ));\n-         Freeze_Typ := Full_Typ;\n \n          --  Check the invariants of the partial view by calling the \"partial\"\n          --  invariant procedure. Generate:\n \n          --    <Work_Typ>Partial_Invariant (_object);\n \n          if Present (Part_Proc) then\n-            Create_Append (Stmts,\n+            Append_New_To (Stmts,\n               Make_Procedure_Call_Statement (Loc,\n                 Name                   => New_Occurrence_Of (Part_Proc, Loc),\n                 Parameter_Associations => New_List (\n@@ -4793,7 +4775,7 @@ package body Exp_Ch7 is\n       --  Otherwise the body is part of the freezing actions of the type\n \n       else\n-         Append_Freeze_Action (Freeze_Typ, Proc_Body);\n+         Append_Freeze_Action (Work_Typ, Proc_Body);\n       end if;\n \n       Ghost_Mode := Save_Ghost_Mode;\n@@ -4860,10 +4842,15 @@ package body Exp_Ch7 is\n \n       pragma Assert (Has_Invariants (Work_Typ));\n \n+      --  ??? invariants of class-wide types are not properly implemented\n+\n+      if Is_Class_Wide_Type (Work_Typ) then\n+         return;\n+\n       --  Nothing to do for interface types as their class-wide invariants are\n       --  inherited by implementing types.\n \n-      if Is_Interface (Work_Typ) then\n+      elsif Is_Interface (Work_Typ) then\n          return;\n \n       --  Nothing to do if the type already has a \"partial\" invariant procedure"}, {"sha": "1529c562b9c4cb70b844b057e53d15288ae53775", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1340, "deletions": 0, "changes": 1340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -46,8 +46,12 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -61,8 +65,46 @@ with Ttypes;   use Ttypes;\n with Urealp;   use Urealp;\n with Validsw;  use Validsw;\n \n+with GNAT.HTable; use GNAT.HTable;\n+\n package body Exp_Util is\n \n+   ---------------------------------------------------------\n+   -- Handling of inherited class-wide pre/postconditions --\n+   ---------------------------------------------------------\n+\n+   --  Following AI12-0113, the expression for a class-wide condition is\n+   --  transformed for a subprogram that inherits it, by replacing calls\n+   --  to primitive operations of the original controlling type into the\n+   --  corresponding overriding operations of the derived type. The following\n+   --  hash table manages this mapping, and is expanded on demand whenever\n+   --  such inherited expression needs to be constructed.\n+\n+   --  The mapping is also used to check whether an inherited operation has\n+   --  a condition that depends on overridden operations. For such an\n+   --  operation we must create a wrapper that is then treated as a normal\n+   --  overriding. In SPARK mode such operations are illegal.\n+\n+   --  For a given root type there may be several type extensions with their\n+   --  own overriding operations, so at various times a given operation of\n+   --  the root will be mapped into different overridings. The root type is\n+   --  also mapped into the current type extension to indicate that its\n+   --  operations are mapped into the overriding operations of that current\n+   --  type extension.\n+\n+   Primitives_Mapping_Size : constant := 511;\n+\n+   subtype Num_Primitives is Integer range 0 .. Primitives_Mapping_Size - 1;\n+   function Entity_Hash (E : Entity_Id) return Num_Primitives;\n+\n+   package Primitives_Mapping is new GNAT.HTable.Simple_HTable\n+     (Header_Num => Num_Primitives,\n+      Key        => Entity_Id,\n+      Element    => Entity_Id,\n+      No_element => Empty,\n+      Hash       => Entity_Hash,\n+      Equal      => \"=\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -113,6 +155,11 @@ package body Exp_Util is\n    --  Force evaluation of bounds of a slice, which may be given by a range\n    --  or by a subtype indication with or without a constraint.\n \n+   function Find_DIC_Type (Typ : Entity_Id) return Entity_Id;\n+   --  Subsidiary to all Build_DIC_Procedure_xxx routines. Find the type which\n+   --  defines the Default_Initial_Condition pragma of type Typ. This is either\n+   --  Typ itself or a parent type when the pragma is inherited.\n+\n    function Make_CW_Equivalent_Type\n      (T : Entity_Id;\n       E : Node_Id) return Entity_Id;\n@@ -984,6 +1031,1074 @@ package body Exp_Util is\n       return Blk;\n    end Build_Abort_Undefer_Block;\n \n+   ---------------------------------\n+   -- Build_Class_Wide_Expression --\n+   ---------------------------------\n+\n+   procedure Build_Class_Wide_Expression\n+     (Prag        : Node_Id;\n+      Subp        : Entity_Id;\n+      Par_Subp    : Entity_Id;\n+      Adjust_Sloc : Boolean)\n+   is\n+      function Replace_Entity (N : Node_Id) return Traverse_Result;\n+      --  Replace reference to formal of inherited operation or to primitive\n+      --  operation of root type, with corresponding entity for derived type,\n+      --  when constructing the class-wide condition of an overriding\n+      --  subprogram.\n+\n+      --------------------\n+      -- Replace_Entity --\n+      --------------------\n+\n+      function Replace_Entity (N : Node_Id) return Traverse_Result is\n+         New_E : Entity_Id;\n+\n+      begin\n+         if Adjust_Sloc then\n+            Adjust_Inherited_Pragma_Sloc (N);\n+         end if;\n+\n+         if Nkind (N) = N_Identifier\n+           and then Present (Entity (N))\n+           and then\n+             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n+           and then\n+             (Nkind (Parent (N)) /= N_Attribute_Reference\n+               or else Attribute_Name (Parent (N)) /= Name_Class)\n+         then\n+            --  The replacement does not apply to dispatching calls within the\n+            --  condition, but only to calls whose static tag is that of the\n+            --  parent type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+              and then Present (Controlling_Argument (Parent (N)))\n+            then\n+               return OK;\n+            end if;\n+\n+            --  Determine whether entity has a renaming\n+\n+            New_E := Primitives_Mapping.Get (Entity (N));\n+\n+            if Present (New_E) then\n+               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n+            end if;\n+\n+            --  Check that there are no calls left to abstract operations if\n+            --  the current subprogram is not abstract.\n+\n+            if Nkind (Parent (N)) = N_Function_Call\n+              and then N = Name (Parent (N))\n+            then\n+               if not Is_Abstract_Subprogram (Subp)\n+                 and then Is_Abstract_Subprogram (Entity (N))\n+               then\n+                  Error_Msg_Sloc := Sloc (Current_Scope);\n+                  Error_Msg_NE\n+                    (\"cannot call abstract subprogram in inherited condition \"\n+                      & \"for&#\", N, Current_Scope);\n+\n+               --  In SPARK mode, reject an inherited condition for an\n+               --  inherited operation if it contains a call to an overriding\n+               --  operation, because this implies that the pre/postcondition\n+               --  of the inherited operation have changed silently.\n+\n+               elsif SPARK_Mode = On\n+                 and then Warn_On_Suspicious_Contract\n+                 and then Present (Alias (Subp))\n+                 and then Present (New_E)\n+                 and then Comes_From_Source (New_E)\n+               then\n+                  Error_Msg_N\n+                    (\"cannot modify inherited condition (SPARK RM 6.1.1(1))\",\n+                     Parent (Subp));\n+                  Error_Msg_Sloc   := Sloc (New_E);\n+                  Error_Msg_Node_2 := Subp;\n+                  Error_Msg_NE\n+                    (\"\\overriding of&# forces overriding of&\",\n+                     Parent (Subp), New_E);\n+               end if;\n+            end if;\n+\n+            --  Update type of function call node, which should be the same as\n+            --  the function's return type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+            then\n+               Set_Etype (Parent (N), Etype (Entity (N)));\n+            end if;\n+\n+         --  The whole expression will be reanalyzed\n+\n+         elsif Nkind (N) in N_Has_Etype then\n+            Set_Analyzed (N, False);\n+         end if;\n+\n+         return OK;\n+      end Replace_Entity;\n+\n+      procedure Replace_Condition_Entities is\n+        new Traverse_Proc (Replace_Entity);\n+\n+      --  Local variables\n+\n+      Par_Formal  : Entity_Id;\n+      Subp_Formal : Entity_Id;\n+\n+   --  Start of processing for Build_Class_Wide_Expression\n+\n+   begin\n+      --  Add mapping from old formals to new formals\n+\n+      Par_Formal  := First_Formal (Par_Subp);\n+      Subp_Formal := First_Formal (Subp);\n+\n+      while Present (Par_Formal) and then Present (Subp_Formal) loop\n+         Primitives_Mapping.Set (Par_Formal, Subp_Formal);\n+         Next_Formal (Par_Formal);\n+         Next_Formal (Subp_Formal);\n+      end loop;\n+\n+      Replace_Condition_Entities (Prag);\n+   end Build_Class_Wide_Expression;\n+\n+   --------------------\n+   -- Build_DIC_Call --\n+   --------------------\n+\n+   function Build_DIC_Call\n+     (Loc    : Source_Ptr;\n+      Obj_Id : Entity_Id;\n+      Typ    : Entity_Id) return Node_Id\n+   is\n+      Proc_Id    : constant Entity_Id := DIC_Procedure (Typ);\n+      Formal_Typ : constant Entity_Id := Etype (First_Formal (Proc_Id));\n+\n+   begin\n+      return\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => New_Occurrence_Of (Proc_Id, Loc),\n+          Parameter_Associations => New_List (\n+            Make_Unchecked_Type_Conversion (Loc,\n+              Subtype_Mark => New_Occurrence_Of (Formal_Typ, Loc),\n+              Expression   => New_Occurrence_Of (Obj_Id, Loc))));\n+   end Build_DIC_Call;\n+\n+   ------------------------------\n+   -- Build_DIC_Procedure_Body --\n+   ------------------------------\n+\n+   procedure Build_DIC_Procedure_Body (Typ : Entity_Id) is\n+      procedure Add_DIC_Check\n+        (DIC_Prag : Node_Id;\n+         DIC_Expr : Node_Id;\n+         Stmts    : in out List_Id);\n+      --  Subsidiary to all Add_xxx_DIC routines. Add a runtime check to verify\n+      --  assertion expression DIC_Expr of pragma DIC_Prag. All generated code\n+      --  is added to list Stmts.\n+\n+      procedure Add_Inherited_DIC\n+        (DIC_Prag  : Node_Id;\n+         Par_Typ   : Entity_Id;\n+         Deriv_Typ : Entity_Id;\n+         Stmts     : in out List_Id);\n+      --  Add a runtime check to verify the assertion expression of inherited\n+      --  pragma DIC_Prag. Par_Typ is parent type which is also the owner of\n+      --  the DIC pragma. Deriv_Typ is the derived type inheriting the DIC\n+      --  pragma. All generated code is added to list Stmts.\n+\n+      procedure Add_Inherited_Tagged_DIC\n+        (DIC_Prag  : Node_Id;\n+         Par_Typ   : Entity_Id;\n+         Deriv_Typ : Entity_Id;\n+         Stmts     : in out List_Id);\n+      --  Add a runtime check to verify assertion expression DIC_Expr of\n+      --  inherited pragma DIC_Prag. This routine applies class-wide pre- and\n+      --  postcondition-like runtime semantics to the check. Par_Typ is the\n+      --  parent type whose DIC pragma is being inherited. Deriv_Typ is the\n+      --  derived type inheriting the DIC pragma. All generated code is added\n+      --  to list Stmts.\n+\n+      procedure Add_Own_DIC\n+        (DIC_Prag : Node_Id;\n+         DIC_Typ  : Entity_Id;\n+         Stmts    : in out List_Id);\n+      --  Add a runtime check to verify the assertion expression of pragma\n+      --  DIC_Prag. DIC_Typ is the owner of the DIC pragma. All generated code\n+      --  is added to list Stmts.\n+\n+      procedure Replace_Object_And_Primitive_References\n+        (Expr      : Node_Id;\n+         Par_Typ   : Entity_Id;\n+         Deriv_Typ : Entity_Id);\n+      --  Expr denotes an arbitrary expression. Par_Typ is a parent type in a\n+      --  type hierarchy. Deriv_Typ is a type derived from Par_Typ. Perform the\n+      --  following substitutions:\n+      --\n+      --    * Replace a reference to the _object parameter of the parent type's\n+      --      DIC procedure with a reference to the _object parameter of the\n+      --      derived type's DIC procedure.\n+      --\n+      --    * Replace a call to an overridden parent primitive with a call to\n+      --      the overriding derived type primitive.\n+      --\n+      --    * Replace a call to an inherited parent primitive with a call to\n+      --      the internally-generated inherited derived type primitive.\n+\n+      procedure Replace_Type_References\n+        (Expr   : Node_Id;\n+         Typ    : Entity_Id;\n+         Obj_Id : Entity_Id);\n+      --  Substitute all references of the current instance of type Typ with\n+      --  references to formal parameter Obj_Id within expression Expr.\n+\n+      -------------------\n+      -- Add_DIC_Check --\n+      -------------------\n+\n+      procedure Add_DIC_Check\n+        (DIC_Prag : Node_Id;\n+         DIC_Expr : Node_Id;\n+         Stmts    : in out List_Id)\n+      is\n+         Loc : constant Source_Ptr := Sloc (DIC_Prag);\n+         Nam : constant Name_Id    := Original_Aspect_Pragma_Name (DIC_Prag);\n+\n+      begin\n+         --  The DIC pragma is ignored, nothing left to do\n+\n+         if Is_Ignored (DIC_Prag) then\n+            null;\n+\n+         --  Otherwise the DIC expression must be checked at runtime. Generate:\n+\n+         --    pragma Check (<Nam>, <DIC_Expr>);\n+\n+         else\n+            Append_New_To (Stmts,\n+              Make_Pragma (Loc,\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Loc, Name_Check),\n+\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Nam)),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => DIC_Expr))));\n+         end if;\n+      end Add_DIC_Check;\n+\n+      -----------------------\n+      -- Add_Inherited_DIC --\n+      -----------------------\n+\n+      procedure Add_Inherited_DIC\n+        (DIC_Prag  : Node_Id;\n+         Par_Typ   : Entity_Id;\n+         Deriv_Typ : Entity_Id;\n+         Stmts     : in out List_Id)\n+      is\n+         Deriv_Proc : constant Entity_Id  := DIC_Procedure (Deriv_Typ);\n+         Deriv_Obj  : constant Entity_Id  := First_Entity  (Deriv_Proc);\n+         Par_Proc   : constant Entity_Id  := DIC_Procedure (Par_Typ);\n+         Par_Obj    : constant Entity_Id  := First_Entity  (Par_Proc);\n+         Loc        : constant Source_Ptr := Sloc (DIC_Prag);\n+\n+      begin\n+         pragma Assert (Present (Deriv_Proc) and then Present (Par_Proc));\n+\n+         --  Verify the inherited DIC assertion expression by calling the DIC\n+         --  procedure of the parent type.\n+\n+         --  Generate:\n+         --    <Par_Typ>DIC (Par_Typ (_object));\n+\n+         Append_New_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => New_Occurrence_Of (Par_Proc, Loc),\n+             Parameter_Associations => New_List (\n+               Convert_To\n+                 (Typ  => Etype (Par_Obj),\n+                  Expr => New_Occurrence_Of (Deriv_Obj, Loc)))));\n+      end Add_Inherited_DIC;\n+\n+      ------------------------------\n+      -- Add_Inherited_Tagged_DIC --\n+      ------------------------------\n+\n+      procedure Add_Inherited_Tagged_DIC\n+        (DIC_Prag  : Node_Id;\n+         Par_Typ   : Entity_Id;\n+         Deriv_Typ : Entity_Id;\n+         Stmts     : in out List_Id)\n+      is\n+         DIC_Args : constant List_Id :=\n+                      Pragma_Argument_Associations (DIC_Prag);\n+         DIC_Arg  : constant Node_Id := First (DIC_Args);\n+         DIC_Expr : constant Node_Id := Expression_Copy (DIC_Arg);\n+         Typ_Decl : constant Node_Id := Declaration_Node (Deriv_Typ);\n+\n+         Expr : Node_Id;\n+\n+      begin\n+         --  The processing of an inherited DIC assertion expression starts off\n+         --  with a copy of the original parent expression where all references\n+         --  to the parent type have already been replaced with references to\n+         --  the _object formal parameter of the parent type's DIC procedure.\n+\n+         pragma Assert (Present (DIC_Expr));\n+         Expr := New_Copy_Tree (DIC_Expr);\n+\n+         --  Perform the following substitutions:\n+\n+         --    * Replace a reference to the _object parameter of the parent\n+         --      type's DIC procedure with a reference to the _object parameter\n+         --      of the derived types' DIC procedure.\n+\n+         --    * Replace a call to an overridden parent primitive with a call\n+         --      to the overriding derived type primitive.\n+\n+         --    * Replace a call to an inherited parent primitive with a call to\n+         --      the internally-generated inherited derived type primitive.\n+\n+         --  Note that primitives defined in the private part are automatically\n+         --  handled by the overriding/inheritance mechanism and do not require\n+         --  an extra replacement pass.\n+\n+         Replace_Object_And_Primitive_References\n+           (Expr      => Expr,\n+            Par_Typ   => Par_Typ,\n+            Deriv_Typ => Deriv_Typ);\n+\n+         --  Preanalyze the DIC expression to detect errors and at the same\n+         --  time capture the visibility of the proper package part.\n+\n+         Set_Parent (Expr, Typ_Decl);\n+         Preanalyze_Assert_Expression (Expr, Any_Boolean);\n+\n+         --  Once the DIC assertion expression is fully processed, add a check\n+         --  to the statements of the DIC procedure.\n+\n+         Add_DIC_Check\n+           (DIC_Prag => DIC_Prag,\n+            DIC_Expr => Expr,\n+            Stmts    => Stmts);\n+      end Add_Inherited_Tagged_DIC;\n+\n+      -----------------\n+      -- Add_Own_DIC --\n+      -----------------\n+\n+      procedure Add_Own_DIC\n+        (DIC_Prag : Node_Id;\n+         DIC_Typ  : Entity_Id;\n+         Stmts    : in out List_Id)\n+      is\n+         DIC_Args : constant List_Id   :=\n+                      Pragma_Argument_Associations (DIC_Prag);\n+         DIC_Arg  : constant Node_Id   := First (DIC_Args);\n+         DIC_Asp  : constant Node_Id   := Corresponding_Aspect (DIC_Prag);\n+         DIC_Expr : constant Node_Id   := Get_Pragma_Arg (DIC_Arg);\n+         DIC_Proc : constant Entity_Id := DIC_Procedure (DIC_Typ);\n+         Obj_Id   : constant Entity_Id := First_Formal (DIC_Proc);\n+\n+         procedure Preanalyze_Own_DIC_For_ASIS;\n+         --  Preanalyze the original DIC expression of an aspect or a source\n+         --  pragma for ASIS.\n+\n+         ---------------------------------\n+         -- Preanalyze_Own_DIC_For_ASIS --\n+         ---------------------------------\n+\n+         procedure Preanalyze_Own_DIC_For_ASIS is\n+            Expr : Node_Id := Empty;\n+\n+         begin\n+            --  The DIC pragma is a source construct, preanalyze the original\n+            --  expression of the pragma.\n+\n+            if Comes_From_Source (DIC_Prag) then\n+               Expr := DIC_Expr;\n+\n+            --  Otherwise preanalyze the expression of the corresponding aspect\n+\n+            elsif Present (DIC_Asp) then\n+               Expr := Expression (DIC_Asp);\n+            end if;\n+\n+            --  The expression must be subjected to the same substitutions as\n+            --  the copy used in the generation of the runtime check.\n+\n+            if Present (Expr) then\n+               Replace_Type_References\n+                 (Expr   => Expr,\n+                  Typ    => DIC_Typ,\n+                  Obj_Id => Obj_Id);\n+\n+               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n+            end if;\n+         end Preanalyze_Own_DIC_For_ASIS;\n+\n+         --  Local variables\n+\n+         Typ_Decl : constant Node_Id := Declaration_Node (DIC_Typ);\n+\n+         Expr : Node_Id;\n+\n+      --  Start of processing for Add_Own_DIC\n+\n+      begin\n+         Expr := New_Copy_Tree (DIC_Expr);\n+\n+         --  Perform the following substituion:\n+\n+         --    * Replace the current instance of DIC_Typ with a reference to\n+         --    the _object formal parameter of the DIC procedure.\n+\n+         Replace_Type_References\n+           (Expr   => Expr,\n+            Typ    => DIC_Typ,\n+            Obj_Id => Obj_Id);\n+\n+         --  Preanalyze the DIC expression to detect errors and at the same\n+         --  time capture the visibility of the proper package part.\n+\n+         Set_Parent (Expr, Typ_Decl);\n+         Preanalyze_Assert_Expression (Expr, Any_Boolean);\n+\n+         --  Save a copy of the expression with all replacements and analysis\n+         --  already taken place in case a derived type inherits the pragma.\n+         --  The copy will be used as the foundation of the derived type's own\n+         --  version of the DIC assertion expression.\n+\n+         if Is_Tagged_Type (DIC_Typ) then\n+            Set_Expression_Copy (DIC_Arg, New_Copy_Tree (Expr));\n+         end if;\n+\n+         --  If the pragma comes from an aspect specification, replace the\n+         --  saved expression because all type references must be substituted\n+         --  for the call to Preanalyze_Spec_Expression in Check_Aspect_At_xxx\n+         --  routines.\n+\n+         if Present (DIC_Asp) then\n+            Set_Entity (Identifier (DIC_Asp), New_Copy_Tree (Expr));\n+         end if;\n+\n+         --  Preanalyze the original DIC expression for ASIS\n+\n+         if ASIS_Mode then\n+            Preanalyze_Own_DIC_For_ASIS;\n+         end if;\n+\n+         --  Once the DIC assertion expression is fully processed, add a check\n+         --  to the statements of the DIC procedure.\n+\n+         Add_DIC_Check\n+           (DIC_Prag => DIC_Prag,\n+            DIC_Expr => Expr,\n+            Stmts    => Stmts);\n+      end Add_Own_DIC;\n+\n+      ---------------------------------------------\n+      -- Replace_Object_And_Primitive_References --\n+      ---------------------------------------------\n+\n+      procedure Replace_Object_And_Primitive_References\n+        (Expr      : Node_Id;\n+         Par_Typ   : Entity_Id;\n+         Deriv_Typ : Entity_Id)\n+      is\n+         Deriv_Obj : Entity_Id;\n+         --  The _object parameter of the derived type's DIC procedure\n+\n+         Par_Obj : Entity_Id;\n+         --  The _object parameter of the parent type's DIC procedure\n+\n+         function Replace_Ref (Ref : Node_Id) return Traverse_Result;\n+         --  Substitute a reference to an entity with a reference to the\n+         --  corresponding entity stored in in table Primitives_Mapping.\n+\n+         -----------------\n+         -- Replace_Ref --\n+         -----------------\n+\n+         function Replace_Ref (Ref : Node_Id) return Traverse_Result is\n+            Context : constant Node_Id    := Parent (Ref);\n+            Loc     : constant Source_Ptr := Sloc (Ref);\n+            New_Id  : Entity_Id;\n+            New_Ref : Node_Id;\n+            Ref_Id  : Entity_Id;\n+            Result  : Traverse_Result;\n+\n+         begin\n+            Result := OK;\n+\n+            --  The current node denotes a reference\n+\n+            if Nkind (Ref) in N_Has_Entity and then Present (Entity (Ref)) then\n+               Ref_Id := Entity (Ref);\n+               New_Id := Primitives_Mapping.Get (Ref_Id);\n+\n+               --  The reference mentions a parent type primitive which has a\n+               --  corresponding derived type primitive.\n+\n+               if Present (New_Id) then\n+                  New_Ref := New_Occurrence_Of (New_Id, Loc);\n+\n+               --  The reference mentions the _object parameter of the parent\n+               --  type's DIC procedure.\n+\n+               elsif Ref_Id = Par_Obj then\n+                  New_Ref := New_Occurrence_Of (Deriv_Obj, Loc);\n+\n+                  --  The reference to _object acts as an actual parameter in a\n+                  --  subprogram call which may be invoking a primitive of the\n+                  --  parent type:\n+\n+                  --    Primitive (... _object ...);\n+\n+                  --  The parent type primitive may not be overridden nor\n+                  --  inherited when it is declared after the derived type\n+                  --  definition:\n+\n+                  --    type Parent is tagged private;\n+                  --    type Child is new Parent with private;\n+                  --    procedure Primitive (Obj : Parent);\n+\n+                  --  In this scenario the _object parameter is converted to\n+                  --  the parent type.\n+\n+                  if Nkind_In (Context, N_Function_Call,\n+                                        N_Procedure_Call_Statement)\n+                    and then\n+                      No (Primitives_Mapping.Get (Entity (Name (Context))))\n+                  then\n+                     New_Ref := Convert_To (Par_Typ, New_Ref);\n+\n+                     --  Do not process the generated type conversion because\n+                     --  both the parent type and the derived type are in the\n+                     --  Primitives_Mapping table. This will clobber the type\n+                     --  conversion by resetting its subtype mark.\n+\n+                     Result := Skip;\n+                  end if;\n+\n+               --  Otherwise there is nothing to replace\n+\n+               else\n+                  New_Ref := Empty;\n+               end if;\n+\n+               if Present (New_Ref) then\n+                  Rewrite (Ref, New_Ref);\n+\n+                  --  Update the return type when the context of the reference\n+                  --  acts as the name of a function call. Note that the update\n+                  --  should not be performed when the reference appears as an\n+                  --  actual in the call.\n+\n+                  if Nkind (Context) = N_Function_Call\n+                    and then Name (Context) = Ref\n+                  then\n+                     Set_Etype (Context, Etype (New_Id));\n+                  end if;\n+               end if;\n+            end if;\n+\n+            --  Reanalyze the reference due to potential replacements\n+\n+            if Nkind (Ref) in N_Has_Etype then\n+               Set_Analyzed (Ref, False);\n+            end if;\n+\n+            return Result;\n+         end Replace_Ref;\n+\n+         procedure Replace_Refs is new Traverse_Proc (Replace_Ref);\n+\n+         --  Local variables\n+\n+         Deriv_Proc : constant Entity_Id := DIC_Procedure (Deriv_Typ);\n+         Par_Proc   : constant Entity_Id := DIC_Procedure (Par_Typ);\n+\n+      --  Start of processing for Replace_Object_And_Primitive_References\n+\n+      begin\n+         pragma Assert (Present (Deriv_Proc) and then Present (Par_Proc));\n+\n+         Deriv_Obj := First_Entity (Deriv_Proc);\n+         Par_Obj   := First_Entity (Par_Proc);\n+\n+         --  Map each primitive operation of the parent type to the proper\n+         --  primitive of the derived type.\n+\n+         Update_Primitives_Mapping_Of_Types\n+           (Par_Typ   => Par_Typ,\n+            Deriv_Typ => Deriv_Typ);\n+\n+         --  Inspect the input expression and perform substitutions where\n+         --  necessary.\n+\n+         Replace_Refs (Expr);\n+      end Replace_Object_And_Primitive_References;\n+\n+      -----------------------------\n+      -- Replace_Type_References --\n+      -----------------------------\n+\n+      procedure Replace_Type_References\n+        (Expr   : Node_Id;\n+         Typ    : Entity_Id;\n+         Obj_Id : Entity_Id)\n+      is\n+         procedure Replace_Type_Ref (N : Node_Id);\n+         --  Substitute a single reference of the current instance of type Typ\n+         --  with a reference to Obj_Id.\n+\n+         ----------------------\n+         -- Replace_Type_Ref --\n+         ----------------------\n+\n+         procedure Replace_Type_Ref (N : Node_Id) is\n+            Ref : Node_Id;\n+\n+         begin\n+            --  Decorate the reference to Typ even though it may be rewritten\n+            --  further down. This is done for two reasons:\n+\n+            --    1) ASIS has all necessary semantic information in the\n+            --    original tree.\n+\n+            --    2) Routines which examine properties of the Original_Node\n+            --    have some semantic information.\n+\n+            if Nkind (N) = N_Identifier then\n+               Set_Entity (N, Typ);\n+               Set_Etype  (N, Typ);\n+\n+            elsif Nkind (N) = N_Selected_Component then\n+               Analyze (Prefix (N));\n+               Set_Entity (Selector_Name (N), Typ);\n+               Set_Etype  (Selector_Name (N), Typ);\n+            end if;\n+\n+            --  Perform the following substitution:\n+\n+            --    Typ  -->  _object\n+\n+            Ref := Make_Identifier (Sloc (N), Chars (Obj_Id));\n+            Set_Entity (Ref, Obj_Id);\n+            Set_Etype  (Ref, Typ);\n+\n+            Rewrite (N, Ref);\n+\n+            Set_Comes_From_Source (N, True);\n+         end Replace_Type_Ref;\n+\n+         procedure Replace_Type_Refs is\n+           new Replace_Type_References_Generic (Replace_Type_Ref);\n+\n+      --  Start of processing for Replace_Type_References\n+\n+      begin\n+         Replace_Type_Refs (Expr, Typ);\n+      end Replace_Type_References;\n+\n+      --  Local variables\n+\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      DIC_Prag     : Node_Id;\n+      DIC_Typ      : Entity_Id;\n+      Dummy_1      : Entity_Id;\n+      Dummy_2      : Entity_Id;\n+      Proc_Body    : Node_Id;\n+      Proc_Body_Id : Entity_Id;\n+      Proc_Decl    : Node_Id;\n+      Proc_Id      : Entity_Id;\n+      Stmts        : List_Id := No_List;\n+\n+      Work_Typ : Entity_Id;\n+      --  The working type\n+\n+   --  Start of processing for Build_DIC_Procedure_Body\n+\n+   begin\n+      Work_Typ := Typ;\n+\n+      --  The input type denotes the implementation base type of a constrained\n+      --  array type. Work with the first subtype as the DIC pragma is on its\n+      --  rep item chain.\n+\n+      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n+         Work_Typ := First_Subtype (Work_Typ);\n+\n+      --  The input denotes the corresponding record type of a protected or a\n+      --  task type. Work with the concurrent type because the corresponding\n+      --  record type may not be visible to clients of the type.\n+\n+      elsif Ekind (Work_Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Work_Typ)\n+      then\n+         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n+      end if;\n+\n+      --  The working type must be either define a DIC pragma of its own or\n+      --  inherit one from a parent type.\n+\n+      pragma Assert (Has_DIC (Work_Typ));\n+\n+      --  Recover the type which defines the DIC pragma. This is either the\n+      --  working type itself or a parent type when the pragma is inherited.\n+\n+      DIC_Typ := Find_DIC_Type (Work_Typ);\n+      pragma Assert (Present (DIC_Typ));\n+\n+      DIC_Prag := Get_Pragma (DIC_Typ, Pragma_Default_Initial_Condition);\n+      pragma Assert (Present (DIC_Prag));\n+\n+      --  Nothing to do if pragma DIC appears without an argument or its sole\n+      --  argument is \"null\".\n+\n+      if not Is_Verifiable_DIC_Pragma (DIC_Prag) then\n+         return;\n+      end if;\n+\n+      --  The working type may lack a DIC procedure declaration. This may be\n+      --  due to several reasons:\n+\n+      --    * The working type's own DIC pragma does not contain a verifiable\n+      --      assertion expression. In this case there is no need to build a\n+      --      DIC procedure because there is nothing to check.\n+\n+      --    * The working type derives from a parent type. In this case a DIC\n+      --      procedure should be built only when the inherited DIC pragma has\n+      --      a verifiable assertion expression.\n+\n+      Proc_Id := DIC_Procedure (Work_Typ);\n+\n+      --  Build a DIC procedure declaration when the working type derives from\n+      --  a parent type.\n+\n+      if No (Proc_Id) then\n+         Build_DIC_Procedure_Declaration (Work_Typ);\n+         Proc_Id := DIC_Procedure (Work_Typ);\n+      end if;\n+\n+      --  At this point there should be a DIC procedure declaration\n+\n+      pragma Assert (Present (Proc_Id));\n+      Proc_Decl := Unit_Declaration_Node (Proc_Id);\n+\n+      --  Nothing to do if the DIC procedure already has a body\n+\n+      if Present (Corresponding_Body (Proc_Decl)) then\n+         return;\n+      end if;\n+\n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the DIC procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Work_Typ);\n+\n+      --  Emulate the environment of the DIC procedure by installing its scope\n+      --  and formal parameters.\n+\n+      Push_Scope (Proc_Id);\n+      Install_Formals (Proc_Id);\n+\n+      --  The working type defines its own DIC pragma. Replace the current\n+      --  instance of the working type with the formal of the DIC procedure.\n+      --  Note that there is no need to consider inherited DIC pragmas from\n+      --  parent types because the working type's DIC pragma \"hides\" all\n+      --  inherited DIC pragmas.\n+\n+      if Has_Own_DIC (Work_Typ) then\n+         pragma Assert (DIC_Typ = Work_Typ);\n+\n+         Add_Own_DIC\n+           (DIC_Prag => DIC_Prag,\n+            DIC_Typ  => DIC_Typ,\n+            Stmts    => Stmts);\n+\n+      --  Otherwise the working type inherits a DIC pragma from a parent type\n+\n+      else\n+         pragma Assert (Has_Inherited_DIC (Work_Typ));\n+         pragma Assert (DIC_Typ /= Work_Typ);\n+\n+         --  The working type is tagged. The verification of the assertion\n+         --  expression is subject to the same semantics as class-wide pre-\n+         --  and postconditions.\n+\n+         if Is_Tagged_Type (Work_Typ) then\n+            Add_Inherited_Tagged_DIC\n+              (DIC_Prag  => DIC_Prag,\n+               Par_Typ   => DIC_Typ,\n+               Deriv_Typ => Work_Typ,\n+               Stmts     => Stmts);\n+\n+         --  Otherwise the working type is not tagged. Verify the assertion\n+         --  expression of the inherited DIC pragma by directly calling the\n+         --  DIC procedure of the parent type.\n+\n+         else\n+            Add_Inherited_DIC\n+              (DIC_Prag  => DIC_Prag,\n+               Par_Typ   => DIC_Typ,\n+               Deriv_Typ => Work_Typ,\n+               Stmts     => Stmts);\n+         end if;\n+      end if;\n+\n+      End_Scope;\n+\n+      --  Produce an empty completing body in the following cases:\n+      --    * Assertions are disabled\n+      --    * The DIC Assertion_Policy is Ignore\n+      --    * Pragma DIC appears without an argument\n+      --    * Pragma DIC appears with argument \"null\"\n+\n+      if No (Stmts) then\n+         Stmts := New_List (Make_Null_Statement (Loc));\n+      end if;\n+\n+      --  Generate:\n+      --    procedure <Work_Typ>DIC (_object : <Work_Typ>) is\n+      --    begin\n+      --       <Stmts>\n+      --    end <Work_Typ>DIC;\n+\n+      Proc_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification                =>\n+            Copy_Subprogram_Spec (Parent (Proc_Id)),\n+          Declarations                 => Empty_List,\n+            Handled_Statement_Sequence =>\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => Stmts));\n+      Proc_Body_Id := Defining_Entity (Proc_Body);\n+\n+      --  Perform minor decoration in case the body is not analyzed\n+\n+      Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n+      Set_Etype (Proc_Body_Id, Standard_Void_Type);\n+      Set_Scope (Proc_Body_Id, Current_Scope);\n+\n+      --  Link both spec and body to avoid generating duplicates\n+\n+      Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n+      Set_Corresponding_Spec (Proc_Body, Proc_Id);\n+\n+      --  The body should not be inserted into the tree when the context is\n+      --  ASIS, GNATprove or a generic unit because it is not part of the\n+      --  template. Note that the body must still be generated in order to\n+      --  resolve the DIC assertion expression.\n+\n+      if ASIS_Mode or GNATprove_Mode or Inside_A_Generic then\n+         null;\n+\n+      --  Otherwise the body is part of the freezing actions of the working\n+      --  type.\n+\n+      else\n+         Append_Freeze_Action (Work_Typ, Proc_Body);\n+      end if;\n+\n+      Ghost_Mode := Save_Ghost_Mode;\n+   end Build_DIC_Procedure_Body;\n+\n+   -------------------------------------\n+   -- Build_DIC_Procedure_Declaration --\n+   -------------------------------------\n+\n+   procedure Build_DIC_Procedure_Declaration (Typ : Entity_Id) is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      DIC_Prag  : Node_Id;\n+      DIC_Typ   : Entity_Id;\n+      Proc_Decl : Node_Id;\n+      Proc_Id   : Entity_Id;\n+      Typ_Decl  : Node_Id;\n+\n+      CRec_Typ : Entity_Id;\n+      --  The corresponding record type of Full_Typ\n+\n+      Full_Base : Entity_Id;\n+      --  The base type of Full_Typ\n+\n+      Full_Typ : Entity_Id;\n+      --  The full view of working type\n+\n+      Obj_Id : Entity_Id;\n+      --  The _object formal parameter of the DIC procedure\n+\n+      Priv_Typ : Entity_Id;\n+      --  The partial view of working type\n+\n+      Work_Typ : Entity_Id;\n+      --  The working type\n+\n+   begin\n+      Work_Typ := Typ;\n+\n+      --  The input type denotes the implementation base type of a constrained\n+      --  array type. Work with the first subtype as the DIC pragma is on its\n+      --  rep item chain.\n+\n+      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n+         Work_Typ := First_Subtype (Work_Typ);\n+\n+      --  The input denotes the corresponding record type of a protected or a\n+      --  task type. Work with the concurrent type because the corresponding\n+      --  record type may not be visible to clients of the type.\n+\n+      elsif Ekind (Work_Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Work_Typ)\n+      then\n+         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n+      end if;\n+\n+      --  The type must be either subject to a DIC pragma or inherit one from a\n+      --  parent type.\n+\n+      pragma Assert (Has_DIC (Work_Typ));\n+\n+      --  Recover the type which defines the DIC pragma. This is either the\n+      --  working type itself or a parent type when the pragma is inherited.\n+\n+      DIC_Typ := Find_DIC_Type (Work_Typ);\n+      pragma Assert (Present (DIC_Typ));\n+\n+      DIC_Prag := Get_Pragma (DIC_Typ, Pragma_Default_Initial_Condition);\n+      pragma Assert (Present (DIC_Prag));\n+\n+      --  Nothing to do if pragma DIC appears without an argument or its sole\n+      --  argument is \"null\".\n+\n+      if not Is_Verifiable_DIC_Pragma (DIC_Prag) then\n+         return;\n+\n+      --  Nothing to do if the type already has a DIC procedure\n+\n+      elsif Present (DIC_Procedure (Work_Typ)) then\n+         return;\n+      end if;\n+\n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the DIC procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Work_Typ);\n+\n+      Proc_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars =>\n+            New_External_Name (Chars (Work_Typ), \"Default_Initial_Condition\"));\n+\n+      --  Perform minor decoration in case the declaration is not analyzed\n+\n+      Set_Ekind (Proc_Id, E_Procedure);\n+      Set_Etype (Proc_Id, Standard_Void_Type);\n+      Set_Scope (Proc_Id, Current_Scope);\n+\n+      Set_Is_DIC_Procedure (Proc_Id);\n+      Set_DIC_Procedure (Work_Typ, Proc_Id);\n+\n+      --  The DIC procedure requires debug info when the assertion expression\n+      --  is subject to Source Coverage Obligations.\n+\n+      if Opt.Generate_SCO then\n+         Set_Needs_Debug_Info (Proc_Id);\n+      end if;\n+\n+      --  Mark the DIC procedure explicitly as Ghost because it does not come\n+      --  from source.\n+\n+      if Ghost_Mode > None then\n+         Set_Is_Ghost_Entity (Proc_Id);\n+      end if;\n+\n+      --  Obtain all views of the input type\n+\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n+\n+      --  Associate the DIC procedure and various relevant flags with all views\n+\n+      Propagate_DIC_Attributes (Priv_Typ,  From_Typ => Work_Typ);\n+      Propagate_DIC_Attributes (Full_Typ,  From_Typ => Work_Typ);\n+      Propagate_DIC_Attributes (Full_Base, From_Typ => Work_Typ);\n+      Propagate_DIC_Attributes (CRec_Typ,  From_Typ => Work_Typ);\n+\n+      --  The declaration of the DIC procedure must be inserted after the\n+      --  declaration of the partial view as this allows for proper external\n+      --  visibility.\n+\n+      if Present (Priv_Typ) then\n+         Typ_Decl := Declaration_Node (Priv_Typ);\n+\n+      --  Derived types with the full view as parent do not have a partial\n+      --  view. Insert the DIC procedure after the derived type.\n+\n+      else\n+         Typ_Decl := Declaration_Node (Full_Typ);\n+      end if;\n+\n+      --  The type should have a declarative node\n+\n+      pragma Assert (Present (Typ_Decl));\n+\n+      --  Create the formal parameter which emulates the variable-like behavior\n+      --  of the current type instance.\n+\n+      Obj_Id := Make_Defining_Identifier (Loc, Chars => Name_uObject);\n+\n+      --  Perform minor decoration in case the declaration is not analyzed\n+\n+      Set_Ekind (Obj_Id, E_In_Parameter);\n+      Set_Etype (Obj_Id, Work_Typ);\n+      Set_Scope (Obj_Id, Proc_Id);\n+\n+      Set_First_Entity (Proc_Id, Obj_Id);\n+\n+      --  Generate:\n+      --    procedure <Work_Typ>DIC (_object : <Work_Typ>);\n+\n+      Proc_Decl :=\n+        Make_Subprogram_Declaration (Loc,\n+          Specification =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Proc_Id,\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Obj_Id,\n+                  Parameter_Type      =>\n+                    New_Occurrence_Of (Work_Typ, Loc)))));\n+\n+      --  The declaration should not be inserted into the tree when the context\n+      --  is ASIS, GNATprove or a generic unit because it is not part of the\n+      --  template.\n+\n+      if ASIS_Mode or GNATprove_Mode or Inside_A_Generic then\n+         null;\n+\n+      --  Otherwise insert the declaration\n+\n+      else\n+         pragma Assert (Present (Typ_Decl));\n+         Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n+      end if;\n+\n+      Ghost_Mode := Save_Ghost_Mode;\n+   end Build_DIC_Procedure_Declaration;\n+\n    --------------------------\n    -- Build_Procedure_Form --\n    --------------------------\n@@ -2224,6 +3339,15 @@ package body Exp_Util is\n       end if;\n    end Ensure_Defined;\n \n+   -----------------\n+   -- Entity_Hash --\n+   -----------------\n+\n+   function Entity_Hash (E : Entity_Id) return Num_Primitives is\n+   begin\n+      return Num_Primitives (E mod Primitives_Mapping_Size);\n+   end Entity_Hash;\n+\n    --------------------\n    -- Entry_Names_OK --\n    --------------------\n@@ -2764,6 +3888,56 @@ package body Exp_Util is\n       return TSS (Utyp, TSS_Finalize_Address);\n    end Finalize_Address;\n \n+   -------------------\n+   -- Find_DIC_Type --\n+   -------------------\n+\n+   function Find_DIC_Type (Typ : Entity_Id) return Entity_Id is\n+      Curr_Typ : Entity_Id;\n+      DIC_Typ  : Entity_Id;\n+\n+   begin\n+      --  The input type defines its own DIC pragma, therefore it is the owner\n+\n+      if Has_Own_DIC (Typ) then\n+         DIC_Typ := Typ;\n+\n+      --  Otherwise the DIC pragma is inherited from a parent type\n+\n+      else\n+         pragma Assert (Has_Inherited_DIC (Typ));\n+\n+         --  Climb the parent chain\n+\n+         Curr_Typ := Typ;\n+         loop\n+            --  Inspect the parent type. Do not consider subtypes as they\n+            --  inherit the DIC attributes from their base types.\n+\n+            DIC_Typ := Base_Type (Etype (Curr_Typ));\n+\n+            --  Look at the full view of a private type because the type may\n+            --  have a hidden parent introduced in the full view.\n+\n+            if Is_Private_Type (DIC_Typ)\n+              and then Present (Full_View (DIC_Typ))\n+            then\n+               DIC_Typ := Full_View (DIC_Typ);\n+            end if;\n+\n+            --  Stop the climb once the nearest parent type which defines a DIC\n+            --  pragma of its own is encountered or when the root of the parent\n+            --  chain is reached.\n+\n+            exit when Has_Own_DIC (DIC_Typ) or else Curr_Typ = DIC_Typ;\n+\n+            Curr_Typ := DIC_Typ;\n+         end loop;\n+      end if;\n+\n+      return DIC_Typ;\n+   end Find_DIC_Type;\n+\n    ------------------------\n    -- Find_Interface_ADT --\n    ------------------------\n@@ -9830,6 +11004,172 @@ package body Exp_Util is\n       end if;\n    end Type_May_Have_Bit_Aligned_Components;\n \n+   -------------------------------\n+   -- Update_Primitives_Mapping --\n+   -------------------------------\n+\n+   procedure Update_Primitives_Mapping\n+     (Inher_Id : Entity_Id;\n+      Subp_Id  : Entity_Id)\n+   is\n+   begin\n+      Update_Primitives_Mapping_Of_Types\n+        (Par_Typ   => Find_Dispatching_Type (Inher_Id),\n+         Deriv_Typ => Find_Dispatching_Type (Subp_Id));\n+   end Update_Primitives_Mapping;\n+\n+   ----------------------------------------\n+   -- Update_Primitives_Mapping_Of_Types --\n+   ----------------------------------------\n+\n+   procedure Update_Primitives_Mapping_Of_Types\n+     (Par_Typ   : Entity_Id;\n+      Deriv_Typ : Entity_Id)\n+   is\n+      procedure Add_Primitive (Prim : Entity_Id);\n+      --  Find a primitive in the inheritance/overriding chain starting from\n+      --  Prim whose dispatching type is parent type Par_Typ and add a mapping\n+      --  between the result and primitive Prim.\n+\n+      -------------------\n+      -- Add_Primitive --\n+      -------------------\n+\n+      procedure Add_Primitive (Prim : Entity_Id) is\n+         function Ancestor_Primitive (Subp : Entity_Id) return Entity_Id;\n+         --  Return the next ancestor primitive in the inheritance/overriding\n+         --  chain of subprogram Subp. Return Empty if no such primitive is\n+         --  available.\n+\n+         ------------------------\n+         -- Ancestor_Primitive --\n+         ------------------------\n+\n+         function Ancestor_Primitive (Subp : Entity_Id) return Entity_Id is\n+            Inher_Prim : constant Entity_Id := Alias (Subp);\n+            Over_Prim  : constant Entity_Id := Overridden_Operation (Subp);\n+\n+         begin\n+            --  The current subprogram overrides an ancestor primitive\n+\n+            if Present (Over_Prim) then\n+               return Over_Prim;\n+\n+            --  The current subprogram is an internally generated alias of an\n+            --  inherited ancestor primitive.\n+\n+            elsif Present (Inher_Prim) then\n+               return Inher_Prim;\n+\n+            --  Otherwise the current subprogram is the root of the inheritance\n+            --  or overriding chain.\n+\n+            else\n+               return Empty;\n+            end if;\n+         end Ancestor_Primitive;\n+\n+         --  Local variables\n+\n+         Par_Prim : Entity_Id;\n+\n+      --  Start of processing for Add_Primitive\n+\n+      begin\n+         --  Inspect both the inheritance chain through the Alias attribute and\n+         --  the overriding chain through the Overridden_Operation looking for\n+         --  an ancestor primitive with the appropriate dispatching type.\n+\n+         Par_Prim := Prim;\n+         while Present (Par_Prim) loop\n+            exit when Find_Dispatching_Type (Par_Prim) = Par_Typ;\n+            Par_Prim := Ancestor_Primitive (Par_Prim);\n+         end loop;\n+\n+         --  Create a mapping of the form:\n+\n+         --    Parent type primitive -> derived type primitive\n+\n+         if Present (Par_Prim) then\n+            Primitives_Mapping.Set (Par_Prim, Prim);\n+         end if;\n+      end Add_Primitive;\n+\n+      --  Local variables\n+\n+      Deriv_Prim : Entity_Id;\n+      Par_Prim   : Entity_Id;\n+      Par_Prims  : Elist_Id;\n+      Prim_Elmt  : Elmt_Id;\n+\n+   --  Start of processing for Update_Primitives_Mapping_Of_Types\n+\n+   begin\n+      --  Nothing to do if there are no types to work with\n+\n+      if No (Par_Typ) or else No (Deriv_Typ) then\n+         return;\n+\n+      --  Nothing to do if the mapping already exists\n+\n+      elsif Primitives_Mapping.Get (Par_Typ) = Deriv_Typ then\n+         return;\n+      end if;\n+\n+      --  Create a mapping of the form:\n+\n+      --    Parent type -> Derived type\n+\n+      --  to prevent any subsequent attempts to produce the same relations.\n+\n+      Primitives_Mapping.Set (Par_Typ, Deriv_Typ);\n+\n+      --  Inspect the primitives of the derived type and determine whether they\n+      --  relate to the primitives of the parent type. If there is a meaningful\n+      --  relation, create a mapping of the form:\n+\n+      --    Parent type primitive -> Derived type primitive\n+\n+      if Present (Direct_Primitive_Operations (Deriv_Typ)) then\n+         Prim_Elmt := First_Elmt (Direct_Primitive_Operations (Deriv_Typ));\n+         while Present (Prim_Elmt) loop\n+            Deriv_Prim := Node (Prim_Elmt);\n+\n+            if Is_Subprogram (Deriv_Prim)\n+              and then Find_Dispatching_Type (Deriv_Prim) = Deriv_Typ\n+            then\n+               Add_Primitive (Deriv_Prim);\n+            end if;\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+      end if;\n+\n+      --  If the parent operation is an interface operation, the overriding\n+      --  indicator is not present. Instead, we get from the interface\n+      --  operation the primitive of the current type that implements it.\n+\n+      if Is_Interface (Par_Typ) then\n+         Par_Prims := Collect_Primitive_Operations (Par_Typ);\n+\n+         if Present (Par_Prims) then\n+            Prim_Elmt := First_Elmt (Par_Prims);\n+\n+            while Present (Prim_Elmt) loop\n+               Par_Prim   := Node (Prim_Elmt);\n+               Deriv_Prim :=\n+                 Find_Primitive_Covering_Interface (Deriv_Typ, Par_Prim);\n+\n+               if Present (Deriv_Prim) then\n+                  Primitives_Mapping.Set (Par_Prim, Deriv_Prim);\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+         end if;\n+      end if;\n+   end Update_Primitives_Mapping_Of_Types;\n+\n    ----------------------------------\n    -- Within_Case_Or_If_Expression --\n    ----------------------------------"}, {"sha": "d02b6b63935113d2c848b7a65e8c03c27ae2a525", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -247,6 +247,39 @@ package Exp_Util is\n    --  inlining of the abort undefer routine. Note that this routine does\n    --  not install a call to Abort_Defer.\n \n+   procedure Build_Class_Wide_Expression\n+     (Prag        : Node_Id;\n+      Subp        : Entity_Id;\n+      Par_Subp    : Entity_Id;\n+      Adjust_Sloc : Boolean);\n+   --  Build the expression for an inherited class-wide condition. Prag is\n+   --  the pragma constructed from the corresponding aspect of the parent\n+   --  subprogram, and Subp is the overriding operation and Par_Subp is\n+   --  the overridden operation that has the condition. Adjust_Sloc is True\n+   --  when the sloc of nodes traversed should be adjusted for the inherited\n+   --  pragma. The routine is also called to check whether an inherited\n+   --  operation that is not overridden but has inherited conditions need\n+   --  a wrapper, because the inherited condition includes calls to other\n+   --  primitives that have been overridden. In that case the first argument\n+   --  is the expression of the original class-wide aspect. In SPARK_Mode, such\n+   --  operation which are just inherited but have modified pre/postconditions\n+   --  are illegal.\n+\n+   function Build_DIC_Call\n+     (Loc    : Source_Ptr;\n+      Obj_Id : Entity_Id;\n+      Typ    : Entity_Id) return Node_Id;\n+   --  Build a call to the DIC procedure of type Typ with Obj_Id as the actual\n+   --  parameter.\n+\n+   procedure Build_DIC_Procedure_Body (Typ : Entity_Id);\n+   --  Create the body of the procedure which verifies the assertion expression\n+   --  of pragma Default_Initial_Condition at runtime.\n+\n+   procedure Build_DIC_Procedure_Declaration (Typ : Entity_Id);\n+   --  Create the declaration of the procedure which verifies the assertion\n+   --  expression of pragma Default_Initial_Condition at runtime.\n+\n    procedure Build_Procedure_Form (N : Node_Id);\n    --  Create a procedure declaration which emulates the behavior of a function\n    --  that returns an array type, for C-compatible generation.\n@@ -1055,6 +1088,21 @@ package Exp_Util is\n    --  is conservative, in that a result of False is decisive. A result of True\n    --  means that such a component may or may not be present.\n \n+   procedure Update_Primitives_Mapping\n+     (Inher_Id : Entity_Id;\n+      Subp_Id  : Entity_Id);\n+   --  Map primitive operations of the parent type to the corresponding\n+   --  operations of the descendant. Note that the descendant type may not be\n+   --  frozen yet, so we cannot use the dispatch table directly. This is called\n+   --  when elaborating a contract for a subprogram, and when freezing a type\n+   --  extension to verify legality rules on inherited conditions.\n+\n+   procedure Update_Primitives_Mapping_Of_Types\n+     (Par_Typ   : Entity_Id;\n+      Deriv_Typ : Entity_Id);\n+   --  Map the primitive operations of parent type Par_Typ to the corresponding\n+   --  primitives of derived type Deriv_Typ.\n+\n    function Within_Case_Or_If_Expression (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N is within a case or an if expression\n "}, {"sha": "e3667862d9dee317c3164a13242cd75346c42231", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -203,7 +203,6 @@ package body Nlists is\n    -----------------\n \n    procedure Append_List (List : List_Id; To : List_Id) is\n-\n       procedure Append_List_Debug;\n       pragma Inline (Append_List_Debug);\n       --  Output debug information if Debug_Flag_N set\n@@ -269,6 +268,28 @@ package body Nlists is\n       Append_List (List, To);\n    end Append_List_To;\n \n+   ----------------\n+   -- Append_New --\n+   ----------------\n+\n+   procedure Append_New (Node : Node_Or_Entity_Id; To : in out List_Id) is\n+   begin\n+      if No (To) then\n+         To := New_List;\n+      end if;\n+\n+      Append (Node, To);\n+   end Append_New;\n+\n+   -------------------\n+   -- Append_New_To --\n+   -------------------\n+\n+   procedure Append_New_To (To : in out List_Id; Node : Node_Or_Entity_Id) is\n+   begin\n+      Append_New (Node, To);\n+   end Append_New_To;\n+\n    ---------------\n    -- Append_To --\n    ---------------"}, {"sha": "7bfeeb96673ba44f1a62a9a3e97a9da49a74f357", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -229,6 +229,16 @@ package Nlists is\n    --  An attempt to append an error node is ignored without complaint and the\n    --  list is unchanged.\n \n+   procedure Append_New (Node : Node_Or_Entity_Id; To : in out List_Id);\n+   pragma Inline (Append_New);\n+   --  Appends Node at the end of node list To. If To is non-existent list, a\n+   --  list is created. Node must be a non-empty node that is not already a\n+   --  member of a node list, and To must be a node list.\n+\n+   procedure Append_New_To (To : in out List_Id; Node : Node_Or_Entity_Id);\n+   pragma Inline (Append_New_To);\n+   --  Like Append_New, but the arguments are in reverse order\n+\n    procedure Append_To (To : List_Id; Node : Node_Or_Entity_Id);\n    pragma Inline (Append_To);\n    --  Like Append, but arguments are the other way round"}, {"sha": "e0520a96d168000022356a50701811b2093b8ef5", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 70, "deletions": 232, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -646,17 +646,6 @@ package body Sem_Ch3 is\n    --  present. If errors are found, error messages are posted, and the\n    --  Real_Range_Specification of Def is reset to Empty.\n \n-   procedure Propagate_Default_Init_Cond_Attributes\n-     (From_Typ             : Entity_Id;\n-      To_Typ               : Entity_Id;\n-      Parent_To_Derivation : Boolean := False;\n-      Private_To_Full_View : Boolean := False);\n-   --  Subsidiary to routines Build_Derived_Type and Process_Full_View. Inherit\n-   --  all attributes related to pragma Default_Initial_Condition from From_Typ\n-   --  to To_Typ. Flag Parent_To_Derivation should be set when the context is\n-   --  the creation of a derived type. Flag Private_To_Full_View should be set\n-   --  when processing both views of a private type.\n-\n    procedure Record_Type_Declaration\n      (T    : Entity_Id;\n       N    : Node_Id;\n@@ -2567,15 +2556,6 @@ package body Sem_Ch3 is\n             if L = Private_Declarations (Context) then\n                Analyze_Package_Contract (Defining_Entity (Context));\n \n-               --  Build the bodies of the default initial condition procedures\n-               --  for all types subject to pragma Default_Initial_Condition.\n-               --  From a purely Ada stand point, this is a freezing activity,\n-               --  however freezing is not available under GNATprove_Mode. To\n-               --  accomodate both scenarios, the bodies are build at the end\n-               --  of private declaration analysis.\n-\n-               Build_Default_Init_Cond_Procedure_Bodies (L);\n-\n             --  Otherwise the contract is analyzed at the end of the visible\n             --  declarations.\n \n@@ -4639,12 +4619,21 @@ package body Sem_Ch3 is\n \n       Build_Derived_Record_Type (N, Parent_Type, T);\n \n+      --  A private extension inherits the Default_Initial_Condition pragma\n+      --  coming from any parent type within the derivation chain.\n+\n+      if Has_DIC (Parent_Type) then\n+         Set_Has_Inherited_DIC (T);\n+      end if;\n+\n       --  A private extension inherits any class-wide invariants coming from a\n       --  parent type or an interface. Note that the invariant procedure of the\n       --  parent type should not be inherited because the private extension may\n       --  define invariants of its own.\n \n-      if Has_Inheritable_Invariants (Parent_Type) then\n+      if Has_Inherited_Invariants (Parent_Type)\n+        or else Has_Inheritable_Invariants (Parent_Type)\n+      then\n          Set_Has_Inherited_Invariants (T);\n \n       elsif Present (Interfaces (T)) then\n@@ -5243,11 +5232,6 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  Propagate invariant-related attributes from the base type to the\n-      --  subtype.\n-\n-      Propagate_Invariant_Attributes (Id, From_Typ => Base_Type (T));\n-\n       --  Remaining processing depends on characteristics of base type\n \n       T := Etype (Id);\n@@ -8863,40 +8847,6 @@ package body Sem_Ch3 is\n                   end;\n                end if;\n \n-               --  A derived type inherits any class-wide invariants coming\n-               --  from a parent type or an interface. Note that the invariant\n-               --  procedure of the parent type should not be inherited because\n-               --  the derived type may define invariants of its own.\n-\n-               if Ada_Version >= Ada_2012\n-                 and then not Is_Interface (Derived_Type)\n-               then\n-                  if Has_Inherited_Invariants (Parent_Type)\n-                    or else Has_Inheritable_Invariants (Parent_Type)\n-                  then\n-                     Set_Has_Inherited_Invariants (Derived_Type);\n-\n-                  elsif not Is_Empty_Elmt_List (Ifaces_List) then\n-                     declare\n-                        Iface      : Entity_Id;\n-                        Iface_Elmt : Elmt_Id;\n-\n-                     begin\n-                        Iface_Elmt := First_Elmt (Ifaces_List);\n-                        while Present (Iface_Elmt) loop\n-                           Iface := Node (Iface_Elmt);\n-\n-                           if Has_Inheritable_Invariants (Iface) then\n-                              Set_Has_Inherited_Invariants (Derived_Type);\n-                              exit;\n-                           end if;\n-\n-                           Next_Elmt (Iface_Elmt);\n-                        end loop;\n-                     end;\n-                  end if;\n-               end if;\n-\n                --  A type extension is automatically Ghost when one of its\n                --  progenitors is Ghost (SPARK RM 6.9(9)). This property is\n                --  also inherited when the parent type is Ghost, but this is\n@@ -9128,9 +9078,54 @@ package body Sem_Ch3 is\n          Set_Default_SSO (Derived_Type);\n       end if;\n \n-      --  Propagate invariant information. The new type has invariants if\n-      --  they are inherited from the parent type, and these invariants can\n-      --  be further inherited, so both flags are set.\n+      --  A derived type inherits the Default_Initial_Condition pragma coming\n+      --  from any parent type within the derivation chain.\n+\n+      if Has_DIC (Parent_Type) then\n+         Set_Has_Inherited_DIC (Derived_Type);\n+      end if;\n+\n+      --  A derived type inherits any class-wide invariants coming from a\n+      --  parent type or an interface. Note that the invariant procedure of\n+      --  the parent type should not be inherited because the derived type may\n+      --  define invariants of its own.\n+\n+      if not Is_Interface (Derived_Type) then\n+         if Has_Inherited_Invariants (Parent_Type)\n+           or else Has_Inheritable_Invariants (Parent_Type)\n+         then\n+            Set_Has_Inherited_Invariants (Derived_Type);\n+\n+         elsif Is_Concurrent_Type (Derived_Type)\n+           or else Is_Tagged_Type (Derived_Type)\n+         then\n+            declare\n+               Iface      : Entity_Id;\n+               Ifaces     : Elist_Id;\n+               Iface_Elmt : Elmt_Id;\n+\n+            begin\n+               Collect_Interfaces\n+                 (T               => Derived_Type,\n+                  Ifaces_List     => Ifaces,\n+                  Exclude_Parents => True);\n+\n+               if Present (Ifaces) then\n+                  Iface_Elmt := First_Elmt (Ifaces);\n+                  while Present (Iface_Elmt) loop\n+                     Iface := Node (Iface_Elmt);\n+\n+                     if Has_Inheritable_Invariants (Iface) then\n+                        Set_Has_Inherited_Invariants (Derived_Type);\n+                        exit;\n+                     end if;\n+\n+                     Next_Elmt (Iface_Elmt);\n+                  end loop;\n+               end if;\n+            end;\n+         end if;\n+      end if;\n \n       --  We similarly inherit predicates\n \n@@ -9142,18 +9137,6 @@ package body Sem_Ch3 is\n \n       Inherit_Rep_Item_Chain (Derived_Type, Parent_Type);\n \n-      --  Propagate the attributes related to pragma Default_Initial_Condition\n-      --  from the parent type to the private extension. A derived type always\n-      --  inherits the default initial condition flag from the parent type. If\n-      --  the derived type carries its own Default_Initial_Condition pragma,\n-      --  the flag is later reset in Analyze_Pragma. Note that both flags are\n-      --  mutually exclusive.\n-\n-      Propagate_Default_Init_Cond_Attributes\n-        (From_Typ             => Parent_Type,\n-         To_Typ               => Derived_Type,\n-         Parent_To_Derivation => True);\n-\n       --  If the parent type has delayed rep aspects, then mark the derived\n       --  type as possibly inheriting a delayed rep aspect.\n \n@@ -15161,6 +15144,10 @@ package body Sem_Ch3 is\n       --  Actual_Subp is the actual subprogram corresponding with the generic\n       --  subprogram Subp.\n \n+      ------------------------\n+      -- Check_Derived_Type --\n+      ------------------------\n+\n       function Check_Derived_Type return Boolean is\n          E        : Entity_Id;\n          Elmt     : Elmt_Id;\n@@ -15171,7 +15158,7 @@ package body Sem_Ch3 is\n \n       begin\n          --  Traverse list of entities in the current scope searching for\n-         --  an incomplete type whose full-view is derived type\n+         --  an incomplete type whose full-view is derived type.\n \n          E := First_Entity (Scope (Derived_Type));\n          while Present (E) and then E /= Derived_Type loop\n@@ -20195,46 +20182,6 @@ package body Sem_Ch3 is\n          Set_Has_Specified_Stream_Output (Full_T);\n       end if;\n \n-      --  Propagate the attributes related to pragma Default_Initial_Condition\n-      --  from the private to the full view. Note that both flags are mutually\n-      --  exclusive.\n-\n-      if Has_Default_Init_Cond (Priv_T)\n-        or else Has_Inherited_Default_Init_Cond (Priv_T)\n-      then\n-         Propagate_Default_Init_Cond_Attributes\n-           (From_Typ             => Priv_T,\n-            To_Typ               => Full_T,\n-            Private_To_Full_View => True);\n-\n-      --  In the case where the full view is derived from another private type,\n-      --  the attributes related to pragma Default_Initial_Condition must be\n-      --  propagated from the full to the private view to maintain consistency\n-      --  of views.\n-\n-      --    package Pack is\n-      --       type Parent_Typ is private\n-      --         with Default_Initial_Condition ...;\n-      --    private\n-      --       type Parent_Typ is ...;\n-      --    end Pack;\n-\n-      --    with Pack; use Pack;\n-      --    package Pack_2 is\n-      --       type Deriv_Typ is private;         --  must inherit\n-      --    private\n-      --       type Deriv_Typ is new Parent_Typ;  --  must inherit\n-      --    end Pack_2;\n-\n-      elsif Has_Default_Init_Cond (Full_T)\n-        or else Has_Inherited_Default_Init_Cond (Full_T)\n-      then\n-         Propagate_Default_Init_Cond_Attributes\n-           (From_Typ             => Full_T,\n-            To_Typ               => Priv_T,\n-            Private_To_Full_View => True);\n-      end if;\n-\n       if Is_Ghost_Entity (Priv_T) then\n \n          --  The Ghost policy in effect at the point of declaration and at the\n@@ -20248,7 +20195,13 @@ package body Sem_Ch3 is\n          Mark_Full_View_As_Ghost (Priv_T, Full_T);\n       end if;\n \n-      --  Propagate invariant-related attributes from the private view to the\n+      --  Propagate Default_Initial_Condition-related attributes from the\n+      --  partial view to the full view and its base type.\n+\n+      Propagate_DIC_Attributes (Full_T, From_Typ => Priv_T);\n+      Propagate_DIC_Attributes (Base_Type (Full_T), From_Typ => Priv_T);\n+\n+      --  Propagate invariant-related attributes from the partial view to the\n       --  full view and its base type.\n \n       Propagate_Invariant_Attributes (Full_T, From_Typ => Priv_T);\n@@ -21085,121 +21038,6 @@ package body Sem_Ch3 is\n       end if;\n    end Process_Subtype;\n \n-   --------------------------------------------\n-   -- Propagate_Default_Init_Cond_Attributes --\n-   --------------------------------------------\n-\n-   procedure Propagate_Default_Init_Cond_Attributes\n-     (From_Typ             : Entity_Id;\n-      To_Typ               : Entity_Id;\n-      Parent_To_Derivation : Boolean := False;\n-      Private_To_Full_View : Boolean := False)\n-   is\n-      procedure Remove_Default_Init_Cond_Procedure (Typ : Entity_Id);\n-      --  Remove the default initial condition procedure (if any) from the\n-      --  Subprograms_For_Type chain of type Typ.\n-\n-      ----------------------------------------\n-      -- Remove_Default_Init_Cond_Procedure --\n-      ----------------------------------------\n-\n-      procedure Remove_Default_Init_Cond_Procedure (Typ : Entity_Id) is\n-         Subps     : constant Elist_Id := Subprograms_For_Type (Typ);\n-         Subp_Elmt : Elmt_Id;\n-         Subp_Id   : Entity_Id;\n-\n-      begin\n-         if Present (Subps) then\n-            Subp_Elmt := First_Elmt (Subps);\n-            while Present (Subp_Elmt) loop\n-               Subp_Id := Node (Subp_Elmt);\n-\n-               if Is_Default_Init_Cond_Procedure (Subp_Id) then\n-                  Remove_Elmt (Subps, Subp_Elmt);\n-                  exit;\n-               end if;\n-\n-               Next_Elmt (Subp_Elmt);\n-            end loop;\n-         end if;\n-      end Remove_Default_Init_Cond_Procedure;\n-\n-      --  Local variables\n-\n-      Inherit_Procedure : Boolean := False;\n-\n-   --  Start of processing for Propagate_Default_Init_Cond_Attributes\n-\n-   begin\n-      if Has_Default_Init_Cond (From_Typ) then\n-\n-         --  A derived type inherits the attributes from its parent type\n-\n-         if Parent_To_Derivation then\n-            Set_Has_Inherited_Default_Init_Cond (To_Typ);\n-\n-         --  A full view shares the attributes with its private view\n-\n-         else\n-            Set_Has_Default_Init_Cond (To_Typ);\n-         end if;\n-\n-         Inherit_Procedure := True;\n-\n-         --  Due to the order of expansion, a derived private type is processed\n-         --  by two routines which both attempt to set the attributes related\n-         --  to pragma Default_Initial_Condition - Build_Derived_Type and then\n-         --  Process_Full_View.\n-\n-         --    package Pack is\n-         --       type Parent_Typ is private\n-         --         with Default_Initial_Condition ...;\n-         --    private\n-         --       type Parent_Typ is ...;\n-         --    end Pack;\n-\n-         --    with Pack; use Pack;\n-         --    package Pack_2 is\n-         --       type Deriv_Typ is private\n-         --         with Default_Initial_Condition ...;\n-         --    private\n-         --       type Deriv_Typ is new Parent_Typ;\n-         --    end Pack_2;\n-\n-         --  When Build_Derived_Type operates, it sets the attributes on the\n-         --  full view without taking into account that the private view may\n-         --  define its own default initial condition procedure. This becomes\n-         --  apparent in Process_Full_View which must undo some of the work by\n-         --  Build_Derived_Type and propagate the attributes from the private\n-         --  to the full view.\n-\n-         if Private_To_Full_View then\n-            Set_Has_Inherited_Default_Init_Cond (To_Typ, False);\n-            Remove_Default_Init_Cond_Procedure (To_Typ);\n-         end if;\n-\n-      --  A type must inherit the default initial condition procedure from a\n-      --  parent type when the parent itself is inheriting the procedure or\n-      --  when it is defining one. This circuitry is also used when dealing\n-      --  with the private / full view of a type.\n-\n-      elsif Has_Inherited_Default_Init_Cond (From_Typ)\n-        or (Parent_To_Derivation\n-              and Present (Get_Pragma\n-                    (From_Typ, Pragma_Default_Initial_Condition)))\n-      then\n-         Set_Has_Inherited_Default_Init_Cond (To_Typ);\n-         Inherit_Procedure := True;\n-      end if;\n-\n-      if Inherit_Procedure\n-        and then No (Default_Init_Cond_Procedure (To_Typ))\n-      then\n-         Set_Default_Init_Cond_Procedure\n-           (To_Typ, Default_Init_Cond_Procedure (From_Typ));\n-      end if;\n-   end Propagate_Default_Init_Cond_Attributes;\n-\n    -----------------------------\n    -- Record_Type_Declaration --\n    -----------------------------"}, {"sha": "9d0eaec17e35bb7648ddb583c0ec8f6009e08e43", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -39,6 +39,7 @@ with Exp_Ch7;   use Exp_Ch7;\n with Exp_Disp;  use Exp_Disp;\n with Exp_Dist;  use Exp_Dist;\n with Exp_Dbug;  use Exp_Dbug;\n+with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n with Lib;       use Lib;\n@@ -1453,19 +1454,12 @@ package body Sem_Ch7 is\n \n          if Is_Type (E) then\n \n-            --  Each private type subject to pragma Default_Initial_Condition\n-            --  declares a specialized procedure which verifies the assumption\n-            --  of the pragma. The declaration appears in the visible part of\n-            --  the package to allow for being called from the outside.\n+            --  Preanalyze and resolve the Default_Initial_Condition assertion\n+            --  expression at the end of the visible declarations to catch any\n+            --  errors.\n \n-            if Has_Default_Init_Cond (E) then\n-               Build_Default_Init_Cond_Procedure_Declaration (E);\n-\n-            --  A private extension inherits the default initial condition\n-            --  procedure from its parent type.\n-\n-            elsif Has_Inherited_Default_Init_Cond (E) then\n-               Inherit_Default_Init_Cond_Procedure (E);\n+            if Has_DIC (E) then\n+               Build_DIC_Procedure_Body (E);\n             end if;\n \n             --  Preanalyze and resolve the invariants of a private type at the\n@@ -1661,18 +1655,28 @@ package body Sem_Ch7 is\n               (\"full view of & does not have preelaborable initialization\", E);\n          end if;\n \n-         --  Preanalyze and resolve the invariants of a private type's full\n-         --  view at the end of the private declarations in case freezing did\n-         --  not take place either due to errors or because the context is a\n-         --  generic unit.\n+         if Is_Type (E) and then Serious_Errors_Detected > 0 then\n \n-         if Is_Type (E)\n-           and then not Is_Private_Type (E)\n-           and then Has_Private_Declaration (E)\n-           and then Has_Invariants (E)\n-           and then Serious_Errors_Detected > 0\n-         then\n-            Build_Invariant_Procedure_Body (E);\n+            --  Preanalyze and resolve the Default_Initial_Condition assertion\n+            --  expression at the end of the private declarations when freezing\n+            --  did not take place due to errors or because the context is a\n+            --  generic unit.\n+\n+            if Has_DIC (E) then\n+               Build_DIC_Procedure_Body (E);\n+            end if;\n+\n+            --  Preanalyze and resolve the invariants of a private type's full\n+            --  view at the end of the private declarations in case freezing\n+            --  did not take place either due to errors or because the context\n+            --  is a generic unit.\n+\n+            if not Is_Private_Type (E)\n+              and then Has_Private_Declaration (E)\n+              and then Has_Invariants (E)\n+            then\n+               Build_Invariant_Procedure_Body (E);\n+            end if;\n          end if;\n \n          Next_Entity (E);\n@@ -2630,6 +2634,16 @@ package body Sem_Ch7 is\n \n          Set_Freeze_Node (Priv, Freeze_Node (Full));\n \n+         --  Propagate Default_Initial_Condition-related attributes from the\n+         --  base type of the full view to the full view and vice versa. This\n+         --  may seem strange, but is necessary depending on which type\n+         --  triggered the generation of the DIC procedure body. As a result,\n+         --  both the full view and its base type carry the same DIC-related\n+         --  information.\n+\n+         Propagate_DIC_Attributes (Full, From_Typ => Full_Base);\n+         Propagate_DIC_Attributes (Full_Base, From_Typ => Full);\n+\n          --  Propagate invariant-related attributes from the base type of the\n          --  full view to the full view and vice versa. This may seem strange,\n          --  but is necessary depending on which type triggered the generation"}, {"sha": "594bac908cb44244888335c9ef6426ac03778abc", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -2212,6 +2212,11 @@ package body Sem_Ch9 is\n             Set_Must_Have_Preelab_Init (T);\n          end if;\n \n+         --  Propagate Default_Initial_Condition-related attributes from the\n+         --  private type to the protected type.\n+\n+         Propagate_DIC_Attributes (T, From_Typ => Def_Id);\n+\n          --  Propagate invariant-related attributes from the private type to\n          --  the protected type.\n \n@@ -3146,6 +3151,11 @@ package body Sem_Ch9 is\n             Set_Must_Have_Preelab_Init (T);\n          end if;\n \n+         --  Propagate Default_Initial_Condition-related attributes from the\n+         --  private type to the task type.\n+\n+         Propagate_DIC_Attributes (T, From_Typ => Def_Id);\n+\n          --  Propagate invariant-related attributes from the private type to\n          --  task type.\n "}, {"sha": "967e7393f87af768ce8ab7409d470b4e66d37ca3", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -1016,7 +1016,7 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      Is_DIC_Proc := Is_Nontrivial_Default_Init_Cond_Procedure (Ent);\n+      Is_DIC_Proc := Is_Nontrivial_DIC_Procedure (Ent);\n \n       --  Elaboration issues in SPARK are reported only for source constructs\n       --  and for nontrivial Default_Initial_Condition procedures. The latter"}, {"sha": "b1a193f196ca395264d01507307f82492fb2ef4e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 346, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -89,8 +89,6 @@ with Urealp;    use Urealp;\n with Validsw;   use Validsw;\n with Warnsw;    use Warnsw;\n \n-with GNAT.HTable; use GNAT.HTable;\n-\n package body Sem_Prag is\n \n    ----------------------------------------------\n@@ -166,40 +164,6 @@ package body Sem_Prag is\n      Table_Increment      => 100,\n      Table_Name           => \"Name_Externals\");\n \n-   ---------------------------------------------------------\n-   -- Handling of inherited class-wide pre/postconditions --\n-   ---------------------------------------------------------\n-\n-   --  Following AI12-0113, the expression for a class-wide condition is\n-   --  transformed for a subprogram that inherits it, by replacing calls\n-   --  to primitive operations of the original controlling type into the\n-   --  corresponding overriding operations of the derived type. The following\n-   --  hash table manages this mapping, and is expanded on demand whenever\n-   --  such inherited expression needs to be constructed.\n-\n-   --  The mapping is also used to check whether an inherited operation has\n-   --  a condition that depends on overridden operations. For such an\n-   --  operation we must create a wrapper that is then treated as a normal\n-   --  overriding. In SPARK mode such operations are illegal.\n-\n-   --  For a given root type there may be several type extensions with their\n-   --  own overriding operations, so at various times a given operation of\n-   --  the root will be mapped into different overridings. The root type is\n-   --  also mapped into the current type extension to indicate that its\n-   --  operations are mapped into the overriding operations of that current\n-   --  type extension.\n-\n-   subtype Num_Primitives is Integer range 0 .. 510;\n-   function Entity_Hash (E : Entity_Id) return Num_Primitives;\n-\n-   package Primitives_Mapping is new Gnat.HTable.Simple_Htable\n-     (Header_Num => Num_Primitives,\n-      Key        => Entity_Id,\n-      Element    => Entity_Id,\n-      No_element => Empty,\n-      Hash       => Entity_Hash,\n-      Equal      => \"=\");\n-\n    -------------------------------------\n    -- Local Subprograms and Variables --\n    -------------------------------------\n@@ -13784,7 +13748,7 @@ package body Sem_Prag is\n \n          --  pragma Default_Initial_Condition [ (null | boolean_EXPRESSION) ];\n \n-         when Pragma_Default_Initial_Condition => Default_Init_Cond : declare\n+         when Pragma_Default_Initial_Condition => DIC : declare\n             Discard : Boolean;\n             Stmt    : Node_Id;\n             Typ     : Entity_Id;\n@@ -13835,13 +13799,21 @@ package body Sem_Prag is\n             --  purposes of legality checks and removal of ignored Ghost code.\n \n             Mark_Pragma_As_Ghost (N, Typ);\n-            Set_Has_Default_Init_Cond (Typ);\n-            Set_Has_Inherited_Default_Init_Cond (Typ, False);\n+\n+            --  The pragma signals that the type defines its own DIC assertion\n+            --  expression.\n+\n+            Set_Has_Own_DIC (Typ);\n \n             --  Chain the pragma on the rep item chain for further processing\n \n             Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n-         end Default_Init_Cond;\n+\n+            --  Create the declaration of the procedure which verifies the\n+            --  assertion expression of pragma DIC at runtime.\n+\n+            Build_DIC_Procedure_Declaration (Typ);\n+         end DIC;\n \n          ----------------------------------\n          -- Default_Scalar_Storage_Order --\n@@ -16819,18 +16791,6 @@ package body Sem_Prag is\n             Typ     : Entity_Id;\n             Typ_Arg : Node_Id;\n \n-            CRec_Typ : Entity_Id;\n-            --  The corresponding record type of Full_Typ\n-\n-            Full_Base : Entity_Id;\n-            --  The base type of Full_Typ\n-\n-            Full_Typ : Entity_Id;\n-            --  The full view of Typ\n-\n-            Priv_Typ : Entity_Id;\n-            --  The partial view of Typ\n-\n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n@@ -16924,16 +16884,6 @@ package body Sem_Prag is\n                Set_Has_Inheritable_Invariants (Typ);\n             end if;\n \n-            Get_Views (Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n-\n-            --  Propagate invariant-related attributes to all views of the type\n-            --  and any additional types that may have been created.\n-\n-            Propagate_Invariant_Attributes (Priv_Typ,  From_Typ => Typ);\n-            Propagate_Invariant_Attributes (Full_Typ,  From_Typ => Typ);\n-            Propagate_Invariant_Attributes (Full_Base, From_Typ => Typ);\n-            Propagate_Invariant_Attributes (CRec_Typ,  From_Typ => Typ);\n-\n             --  Chain the pragma on to the rep item chain, for processing when\n             --  the type is frozen.\n \n@@ -26766,140 +26716,6 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n-   ---------------------------------\n-   -- Build_Class_Wide_Expression --\n-   ---------------------------------\n-\n-   procedure Build_Class_Wide_Expression\n-     (Prag        : Node_Id;\n-      Subp        : Entity_Id;\n-      Par_Subp    : Entity_Id;\n-      Adjust_Sloc : Boolean)\n-   is\n-      function Replace_Entity (N : Node_Id) return Traverse_Result;\n-      --  Replace reference to formal of inherited operation or to primitive\n-      --  operation of root type, with corresponding entity for derived type,\n-      --  when constructing the class-wide condition of an overriding\n-      --  subprogram.\n-\n-      --------------------\n-      -- Replace_Entity --\n-      --------------------\n-\n-      function Replace_Entity (N : Node_Id) return Traverse_Result is\n-         New_E : Entity_Id;\n-\n-      begin\n-         if Adjust_Sloc then\n-            Adjust_Inherited_Pragma_Sloc (N);\n-         end if;\n-\n-         if Nkind (N) = N_Identifier\n-           and then Present (Entity (N))\n-           and then\n-             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n-           and then\n-             (Nkind (Parent (N)) /= N_Attribute_Reference\n-               or else Attribute_Name (Parent (N)) /= Name_Class)\n-         then\n-            --  The replacement does not apply to dispatching calls within the\n-            --  condition, but only to calls whose static tag is that of the\n-            --  parent type.\n-\n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-              and then Present (Controlling_Argument (Parent (N)))\n-            then\n-               return OK;\n-            end if;\n-\n-            --  Determine whether entity has a renaming\n-\n-            New_E := Primitives_Mapping.Get (Entity (N));\n-\n-            if Present (New_E) then\n-               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n-            end if;\n-\n-            --  Check that there are no calls left to abstract operations if\n-            --  the current subprogram is not abstract.\n-\n-            if Nkind (Parent (N)) = N_Function_Call\n-              and then N = Name (Parent (N))\n-            then\n-               if not Is_Abstract_Subprogram (Subp)\n-                 and then Is_Abstract_Subprogram (Entity (N))\n-               then\n-                  Error_Msg_Sloc := Sloc (Current_Scope);\n-                  Error_Msg_NE\n-                    (\"cannot call abstract subprogram in inherited condition \"\n-                      & \"for&#\", N, Current_Scope);\n-\n-               --  In SPARK mode, reject an inherited condition for an\n-               --  inherited operation if it contains a call to an overriding\n-               --  operation, because this implies that the pre/postcondition\n-               --  of the inherited operation have changed silently.\n-\n-               elsif SPARK_Mode = On\n-                 and then Warn_On_Suspicious_Contract\n-                 and then Present (Alias (Subp))\n-                 and then Present (New_E)\n-                 and then Comes_From_Source (New_E)\n-               then\n-                  Error_Msg_N\n-                    (\"cannot modify inherited condition (SPARK RM 6.1.1(1))\",\n-                     Parent (Subp));\n-                  Error_Msg_Sloc   := Sloc (New_E);\n-                  Error_Msg_Node_2 := Subp;\n-                  Error_Msg_NE\n-                    (\"\\overriding of&# forces overriding of&\",\n-                     Parent (Subp), New_E);\n-               end if;\n-            end if;\n-\n-            --  Update type of function call node, which should be the same as\n-            --  the function's return type.\n-\n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-            then\n-               Set_Etype (Parent (N), Etype (Entity (N)));\n-            end if;\n-\n-         --  The whole expression will be reanalyzed\n-\n-         elsif Nkind (N) in N_Has_Etype then\n-            Set_Analyzed (N, False);\n-         end if;\n-\n-         return OK;\n-      end Replace_Entity;\n-\n-      procedure Replace_Condition_Entities is\n-        new Traverse_Proc (Replace_Entity);\n-\n-      --  Local variables\n-\n-      Par_Formal  : Entity_Id;\n-      Subp_Formal : Entity_Id;\n-\n-   --  Start of processing for Build_Class_Wide_Expression\n-\n-   begin\n-      --  Add mapping from old formals to new formals\n-\n-      Par_Formal := First_Formal (Par_Subp);\n-      Subp_Formal  := First_Formal (Subp);\n-\n-      while Present (Par_Formal) and then Present (Subp_Formal) loop\n-         Primitives_Mapping.Set (Par_Formal, Subp_Formal);\n-         Next_Formal (Par_Formal);\n-         Next_Formal (Subp_Formal);\n-      end loop;\n-\n-      Replace_Condition_Entities (Prag);\n-   end Build_Class_Wide_Expression;\n-\n    -----------------------------------\n    -- Build_Pragma_Check_Equivalent --\n    -----------------------------------\n@@ -27930,15 +27746,6 @@ package body Sem_Prag is\n       end if;\n    end Duplication_Error;\n \n-   -----------------\n-   -- Entity_Hash --\n-   -----------------\n-\n-   function Entity_Hash (E : Entity_Id) return Num_Primitives is\n-   begin\n-      return Num_Primitives (E mod 511);\n-   end Entity_Hash;\n-\n    ------------------------------\n    -- Find_Encapsulating_State --\n    ------------------------------\n@@ -29780,145 +29587,4 @@ package body Sem_Prag is\n       return Empty;\n    end Test_Case_Arg;\n \n-   -------------------------------\n-   -- Update_Primitives_Mapping --\n-   -------------------------------\n-\n-   procedure Update_Primitives_Mapping\n-     (Inher_Id : Entity_Id;\n-      Subp_Id  : Entity_Id)\n-   is\n-      function Overridden_Ancestor (S : Entity_Id) return Entity_Id;\n-      --  Locate the primitive operation with the name of S whose controlling\n-      --  type is the dispatching type of Inher_Id.\n-\n-      -------------------------\n-      -- Overridden_Ancestor --\n-      -------------------------\n-\n-      function Overridden_Ancestor (S : Entity_Id) return Entity_Id is\n-         Par : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n-         Anc : Entity_Id;\n-\n-      begin\n-         Anc := S;\n-\n-         --  Locate the ancestor subprogram with the proper controlling type\n-\n-         while Present (Overridden_Operation (Anc)) loop\n-            Anc := Overridden_Operation (Anc);\n-            exit when Find_Dispatching_Type (Anc) = Par;\n-         end loop;\n-\n-         return Anc;\n-      end Overridden_Ancestor;\n-\n-      --  Local variables\n-\n-      Old_Typ  : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n-      Typ      : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n-      Decl     : Node_Id;\n-      Old_Elmt : Elmt_Id;\n-      Old_Prim : Entity_Id;\n-      Prim     : Entity_Id;\n-\n-   --  Start of processing for Update_Primitives_Mapping\n-\n-   begin\n-      --  If the types are already in the map, it has been previously built for\n-      --  some other overriding primitive.\n-\n-      if Primitives_Mapping.Get (Old_Typ) = Typ then\n-         return;\n-\n-      else\n-         --  Initialize new mapping with the primitive operations\n-\n-         Decl := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n-\n-         --  Look for primitive operations of the current type that have\n-         --  overridden an operation of the type related to the original\n-         --  class-wide precondition. There may be several intermediate\n-         --  overridings between them.\n-\n-         while Present (Decl) loop\n-            if Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n-                               N_Subprogram_Declaration)\n-            then\n-               Prim := Defining_Entity (Decl);\n-\n-               if Is_Subprogram (Prim)\n-                 and then Present (Overridden_Operation (Prim))\n-                 and then Find_Dispatching_Type (Prim) = Typ\n-               then\n-                  Old_Prim := Overridden_Ancestor (Prim);\n-\n-                  Primitives_Mapping.Set (Old_Prim, Prim);\n-               end if;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-\n-         --  Now examine inherited operations. these do not override, but have\n-         --  an alias, which is the entity used in a call. That alias may be\n-         --  inherited or come from source, in which case it may override an\n-         --  earlier operation. We only need to examine inherited functions,\n-         --  that can appear within the inherited expression.\n-\n-         Prim := First_Entity (Scope (Subp_Id));\n-         while Present (Prim) loop\n-            if not Comes_From_Source (Prim)\n-              and then Ekind (Prim) = E_Function\n-              and then Present (Alias (Prim))\n-            then\n-               Old_Prim := Alias (Prim);\n-\n-               if Comes_From_Source (Old_Prim) then\n-                  Old_Prim := Overridden_Ancestor (Old_Prim);\n-\n-               else\n-                  while Present (Alias (Old_Prim))\n-                    and then Scope (Old_Prim) /= Scope (Inher_Id)\n-                  loop\n-                     Old_Prim := Alias (Old_Prim);\n-\n-                     if Comes_From_Source (Old_Prim) then\n-                        Old_Prim := Overridden_Ancestor (Old_Prim);\n-                        exit;\n-                     end if;\n-                  end loop;\n-               end if;\n-\n-               Primitives_Mapping.Set (Old_Prim, Prim);\n-            end if;\n-\n-            Next_Entity (Prim);\n-         end loop;\n-\n-         --  If the parent operation is an interface operation, the overriding\n-         --  indicator is not present. Instead, we get from the interface\n-         --  operation the primitive of the current type that implements it.\n-\n-         if Is_Interface (Old_Typ) then\n-            Old_Elmt := First_Elmt (Collect_Primitive_Operations (Old_Typ));\n-            while Present (Old_Elmt) loop\n-               Old_Prim := Node (Old_Elmt);\n-               Prim := Find_Primitive_Covering_Interface (Typ, Old_Prim);\n-\n-               if Present (Prim) then\n-                  Primitives_Mapping.Set (Old_Prim, Prim);\n-               end if;\n-\n-               Next_Elmt (Old_Elmt);\n-            end loop;\n-         end if;\n-      end if;\n-\n-      --  Map the types themselves, so that the process is not repeated for\n-      --  other overriding primitives.\n-\n-      Primitives_Mapping.Set (Old_Typ, Typ);\n-   end Update_Primitives_Mapping;\n-\n end Sem_Prag;"}, {"sha": "1155673a77aa301ba62e48edb0c3c784ee4640ca", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -244,24 +244,6 @@ package Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n \n-   procedure Build_Class_Wide_Expression\n-     (Prag        : Node_Id;\n-      Subp        : Entity_Id;\n-      Par_Subp    : Entity_Id;\n-      Adjust_Sloc : Boolean);\n-   --  Build the expression for an inherited class-wide condition. Prag is\n-   --  the pragma constructed from the corresponding aspect of the parent\n-   --  subprogram, and Subp is the overriding operation and Par_Subp is\n-   --  the overridden operation that has the condition. Adjust_Sloc is True\n-   --  when the sloc of nodes traversed should be adjusted for the inherited\n-   --  pragma. The routine is also called to check whether an inherited\n-   --  operation that is not overridden but has inherited conditions need\n-   --  a wrapper, because the inherited condition includes calls to other\n-   --  primitives that have been overridden. In that case the first argument\n-   --  is the expression of the original class-wide aspect. In SPARK_Mode, such\n-   --  operation which are just inherited but have modified pre/postconditions\n-   --  are illegal.\n-\n    function Build_Pragma_Check_Equivalent\n      (Prag           : Node_Id;\n       Subp_Id        : Entity_Id := Empty;\n@@ -543,13 +525,4 @@ package Sem_Prag is\n    --\n    --    Empty if there is no such argument\n \n-   procedure Update_Primitives_Mapping\n-     (Inher_Id : Entity_Id;\n-      Subp_Id  : Entity_Id);\n-   --  Map primitive operations of the parent type to the corresponding\n-   --  operations of the descendant. Note that the descendant type may not be\n-   --  frozen yet, so we cannot use the dispatch table directly. This is called\n-   --  when elaborating a contract for a subprogram, and when freezing a type\n-   --  extension to verify legality rules on inherited conditions.\n-\n end Sem_Prag;"}, {"sha": "ba64d896b1d799918a5be06c8d9606f82fb39dcd", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 117, "deletions": 396, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -37,7 +37,6 @@ with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet.Sp; use Namet.Sp;\n@@ -52,7 +51,6 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Attr; use Sem_Attr;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n@@ -1194,294 +1192,6 @@ package body Sem_Util is\n       return Decl;\n    end Build_Component_Subtype;\n \n-   ----------------------------------\n-   -- Build_Default_Init_Cond_Call --\n-   ----------------------------------\n-\n-   function Build_Default_Init_Cond_Call\n-     (Loc    : Source_Ptr;\n-      Obj_Id : Entity_Id;\n-      Typ    : Entity_Id) return Node_Id\n-   is\n-      Proc_Id    : constant Entity_Id := Default_Init_Cond_Procedure (Typ);\n-      Formal_Typ : constant Entity_Id := Etype (First_Formal (Proc_Id));\n-\n-   begin\n-      return\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   => New_Occurrence_Of (Proc_Id, Loc),\n-          Parameter_Associations => New_List (\n-            Make_Unchecked_Type_Conversion (Loc,\n-              Subtype_Mark => New_Occurrence_Of (Formal_Typ, Loc),\n-              Expression   => New_Occurrence_Of (Obj_Id, Loc))));\n-   end Build_Default_Init_Cond_Call;\n-\n-   ----------------------------------------------\n-   -- Build_Default_Init_Cond_Procedure_Bodies --\n-   ----------------------------------------------\n-\n-   procedure Build_Default_Init_Cond_Procedure_Bodies (Priv_Decls : List_Id) is\n-      procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id);\n-      --  If type Typ is subject to pragma Default_Initial_Condition, build the\n-      --  body of the procedure which verifies the assumption of the pragma at\n-      --  run time. The generated body is added after the type declaration.\n-\n-      --------------------------------------------\n-      -- Build_Default_Init_Cond_Procedure_Body --\n-      --------------------------------------------\n-\n-      procedure Build_Default_Init_Cond_Procedure_Body (Typ : Entity_Id) is\n-         Param_Id : Entity_Id;\n-         --  The entity of the sole formal parameter of the default initial\n-         --  condition procedure.\n-\n-         procedure Replace_Type_Reference (N : Node_Id);\n-         --  Replace a single reference to type Typ with a reference to formal\n-         --  parameter Param_Id.\n-\n-         ----------------------------\n-         -- Replace_Type_Reference --\n-         ----------------------------\n-\n-         procedure Replace_Type_Reference (N : Node_Id) is\n-         begin\n-            Rewrite (N, New_Occurrence_Of (Param_Id, Sloc (N)));\n-         end Replace_Type_Reference;\n-\n-         procedure Replace_Type_References is\n-           new Replace_Type_References_Generic (Replace_Type_Reference);\n-\n-         --  Local variables\n-\n-         Loc       : constant Source_Ptr := Sloc (Typ);\n-         Prag      : constant Node_Id    :=\n-                       Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-         Proc_Id   : constant Entity_Id  := Default_Init_Cond_Procedure (Typ);\n-         Body_Decl : Node_Id;\n-         Expr      : Node_Id;\n-         Spec_Decl : Node_Id;\n-         Stmt      : Node_Id;\n-\n-         Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n-      --  Start of processing for Build_Default_Init_Cond_Procedure_Body\n-\n-      begin\n-         --  The procedure should be generated only for [sub]types subject to\n-         --  pragma Default_Initial_Condition. Types that inherit the pragma do\n-         --  not get this specialized procedure.\n-\n-         pragma Assert (Has_Default_Init_Cond (Typ));\n-         pragma Assert (Present (Prag));\n-\n-         --  Nothing to do if the spec was not built. This occurs when the\n-         --  expression of the Default_Initial_Condition is missing or is\n-         --  null.\n-\n-         if No (Proc_Id) then\n-            return;\n-\n-         --  Nothing to do if the body was already built\n-\n-         elsif Present (Corresponding_Body (Unit_Declaration_Node (Proc_Id)))\n-         then\n-            return;\n-         end if;\n-\n-         --  The related type may be subject to pragma Ghost. Set the mode now\n-         --  to ensure that the analysis and expansion produce Ghost nodes.\n-\n-         Set_Ghost_Mode_From_Entity (Typ);\n-\n-         Param_Id := First_Formal (Proc_Id);\n-\n-         --  The pragma has an argument. Note that the argument is analyzed\n-         --  after all references to the current instance of the type are\n-         --  replaced.\n-\n-         if Present (Pragma_Argument_Associations (Prag)) then\n-            Expr :=\n-              Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n-\n-            if Nkind (Expr) = N_Null then\n-               Stmt := Make_Null_Statement (Loc);\n-\n-            --  Preserve the original argument of the pragma by replicating it.\n-            --  Replace all references to the current instance of the type with\n-            --  references to the formal parameter.\n-\n-            else\n-               Expr := New_Copy_Tree (Expr);\n-               Replace_Type_References (Expr, Typ);\n-\n-               --  Generate:\n-               --    pragma Check (Default_Initial_Condition, <Expr>);\n-\n-               Stmt :=\n-                 Make_Pragma (Loc,\n-                   Chars            => Name_Check,\n-                   Pragma_Argument_Associations => New_List (\n-                     Make_Pragma_Argument_Association (Loc,\n-                       Expression =>\n-                         Make_Identifier (Loc,\n-                           Chars => Name_Default_Initial_Condition)),\n-                     Make_Pragma_Argument_Association (Loc,\n-                       Expression => Expr)));\n-            end if;\n-\n-         --  Otherwise the pragma appears without an argument\n-\n-         else\n-            Stmt := Make_Null_Statement (Loc);\n-         end if;\n-\n-         --  Generate:\n-         --    procedure <Typ>Default_Init_Cond (I : <Typ>) is\n-         --    begin\n-         --       <Stmt>;\n-         --    end <Typ>Default_Init_Cond;\n-\n-         Spec_Decl := Unit_Declaration_Node (Proc_Id);\n-         Body_Decl :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Copy_Separate_Tree (Specification (Spec_Decl)),\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (Stmt)));\n-\n-         --  Link the spec and body of the default initial condition procedure\n-         --  to prevent the generation of a duplicate body.\n-\n-         Set_Corresponding_Body (Spec_Decl, Defining_Entity (Body_Decl));\n-         Set_Corresponding_Spec (Body_Decl, Proc_Id);\n-\n-         Insert_After_And_Analyze (Declaration_Node (Typ), Body_Decl);\n-         Ghost_Mode := Save_Ghost_Mode;\n-      end Build_Default_Init_Cond_Procedure_Body;\n-\n-      --  Local variables\n-\n-      Decl : Node_Id;\n-      Typ  : Entity_Id;\n-\n-   --  Start of processing for Build_Default_Init_Cond_Procedure_Bodies\n-\n-   begin\n-      --  Inspect the private declarations looking for [sub]type declarations\n-\n-      Decl := First (Priv_Decls);\n-      while Present (Decl) loop\n-         if Nkind_In (Decl, N_Full_Type_Declaration,\n-                            N_Subtype_Declaration)\n-         then\n-            Typ := Defining_Entity (Decl);\n-\n-            --  Guard against partially decorate types due to previous errors\n-\n-            if Is_Type (Typ) then\n-\n-               --  If the type is subject to pragma Default_Initial_Condition,\n-               --  generate the body of the internal procedure which verifies\n-               --  the assertion of the pragma at run time.\n-\n-               if Has_Default_Init_Cond (Typ) then\n-                  Build_Default_Init_Cond_Procedure_Body (Typ);\n-\n-               --  A derived type inherits the default initial condition\n-               --  procedure from its parent type.\n-\n-               elsif Has_Inherited_Default_Init_Cond (Typ) then\n-                  Inherit_Default_Init_Cond_Procedure (Typ);\n-               end if;\n-            end if;\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-   end Build_Default_Init_Cond_Procedure_Bodies;\n-\n-   ---------------------------------------------------\n-   -- Build_Default_Init_Cond_Procedure_Declaration --\n-   ---------------------------------------------------\n-\n-   procedure Build_Default_Init_Cond_Procedure_Declaration (Typ : Entity_Id) is\n-      Loc  : constant Source_Ptr := Sloc (Typ);\n-      Prag : constant Node_Id    :=\n-                  Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n-      Args    : List_Id;\n-      Proc_Id : Entity_Id;\n-\n-   begin\n-      --  The procedure should be generated only for types subject to pragma\n-      --  Default_Initial_Condition. Types that inherit the pragma do not get\n-      --  this specialized procedure.\n-\n-      pragma Assert (Has_Default_Init_Cond (Typ));\n-      pragma Assert (Present (Prag));\n-\n-      Args := Pragma_Argument_Associations (Prag);\n-\n-      --  Nothing to do if default initial condition procedure already built\n-\n-      if Present (Default_Init_Cond_Procedure (Typ)) then\n-         return;\n-\n-      --  Nothing to do if the default initial condition appears without an\n-      --  expression.\n-\n-      elsif No (Args) then\n-         return;\n-\n-      --  Nothing to do if the expression of the default initial condition is\n-      --  null.\n-\n-      elsif Nkind (Get_Pragma_Arg (First (Args))) = N_Null then\n-         return;\n-      end if;\n-\n-      --  The related type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the analysis and expansion produce Ghost nodes.\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n-      Proc_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Typ), \"Default_Init_Cond\"));\n-\n-      --  Associate default initial condition procedure with the private type\n-\n-      Set_Ekind (Proc_Id, E_Procedure);\n-      Set_Is_Default_Init_Cond_Procedure (Proc_Id);\n-      Set_Default_Init_Cond_Procedure (Typ, Proc_Id);\n-\n-      --  Mark the default initial condition procedure explicitly as Ghost\n-      --  because it does not come from source.\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Proc_Id);\n-      end if;\n-\n-      --  Generate:\n-      --    procedure <Typ>Default_Init_Cond (Inn : <Typ>);\n-\n-      Insert_After_And_Analyze (Prag,\n-        Make_Subprogram_Declaration (Loc,\n-          Specification =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Proc_Id,\n-              Parameter_Specifications => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => Make_Temporary (Loc, 'I'),\n-                  Parameter_Type      => New_Occurrence_Of (Typ, Loc))))));\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n-   end Build_Default_Init_Cond_Procedure_Declaration;\n-\n    ---------------------------\n    -- Build_Default_Subtype --\n    ---------------------------\n@@ -8713,6 +8423,8 @@ package body Sem_Util is\n       Full_Base : out Entity_Id;\n       CRec_Typ  : out Entity_Id)\n    is\n+      IP_View : Entity_Id;\n+\n    begin\n       --  Assume that none of the views can be recovered\n \n@@ -8721,53 +8433,46 @@ package body Sem_Util is\n       Full_Base := Empty;\n       CRec_Typ  := Empty;\n \n-      --  The input type is private\n-\n-      if Is_Private_Type (Typ) then\n-         Priv_Typ := Typ;\n-         Full_Typ := Full_View (Priv_Typ);\n-\n-         if Present (Full_Typ) then\n-            Full_Base := Base_Type (Full_Typ);\n-\n-            if Ekind_In (Full_Typ, E_Protected_Type, E_Task_Type) then\n-               CRec_Typ := Corresponding_Record_Type (Full_Typ);\n-            end if;\n-         end if;\n-\n       --  The input type is the corresponding record type of a protected or a\n       --  task type.\n \n-      elsif Ekind (Typ) = E_Record_Type\n+      if Ekind (Typ) = E_Record_Type\n         and then Is_Concurrent_Record_Type (Typ)\n       then\n          CRec_Typ  := Typ;\n          Full_Typ  := Corresponding_Concurrent_Type (CRec_Typ);\n          Full_Base := Base_Type (Full_Typ);\n          Priv_Typ  := Incomplete_Or_Partial_View (Full_Typ);\n \n-      --  Otherwise the input type could be the full view of a private type\n+      --  Otherwise the input type denotes an arbitrary type\n \n       else\n-         Full_Typ  := Typ;\n-         Full_Base := Base_Type (Full_Typ);\n+         IP_View := Incomplete_Or_Partial_View (Typ);\n \n-         if Ekind_In (Full_Typ, E_Protected_Type, E_Task_Type) then\n-            CRec_Typ := Corresponding_Record_Type (Full_Typ);\n-         end if;\n+         --  The input type denotes the full view of a private type\n \n-         --  The type is the full view of a private type, obtain the partial\n-         --  view.\n+         if Present (IP_View) then\n+            Priv_Typ := IP_View;\n+            Full_Typ := Typ;\n \n-         if Has_Private_Declaration (Full_Typ)\n-           and then not Is_Private_Type (Full_Typ)\n-         then\n-            Priv_Typ := Incomplete_Or_Partial_View (Full_Typ);\n+         --  The input type is a private type\n+\n+         elsif Is_Private_Type (Typ) then\n+            Priv_Typ := Typ;\n+            Full_Typ := Full_View (Priv_Typ);\n+\n+         --  Otherwise the input type does not have any views\n+\n+         else\n+            Full_Typ := Typ;\n+         end if;\n \n-            --  The full view of a private type should always have a partial\n-            --  view.\n+         if Present (Full_Typ) then\n+            Full_Base := Base_Type (Full_Typ);\n \n-            pragma Assert (Present (Priv_Typ));\n+            if Ekind_In (Full_Typ, E_Protected_Type, E_Task_Type) then\n+               CRec_Typ := Corresponding_Record_Type (Full_Typ);\n+            end if;\n          end if;\n       end if;\n    end Get_Views;\n@@ -9502,39 +9207,20 @@ package body Sem_Util is\n    -------------------------------------\n \n    function Has_Full_Default_Initialization (Typ : Entity_Id) return Boolean is\n-      Arg  : Node_Id;\n       Comp : Entity_Id;\n       Prag : Node_Id;\n \n    begin\n-      --  A private type and its full view is fully default initialized when it\n-      --  is subject to pragma Default_Initial_Condition without an argument or\n-      --  with a non-null argument. Since any type may act as the full view of\n-      --  a private type, this check must be performed prior to the specialized\n-      --  tests below.\n+      --  A type subject to pragma Default_Initial_Condition is fully default\n+      --  initialized when the pragma appears with a non-null argument. Since\n+      --  any type may act as the full view of a private type, this check must\n+      --  be performed prior to the specialized tests below.\n \n-      if Has_Default_Init_Cond (Typ)\n-        or else Has_Inherited_Default_Init_Cond (Typ)\n-      then\n+      if Has_DIC (Typ) then\n          Prag := Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n-\n-         --  Pragma Default_Initial_Condition must be present if one of the\n-         --  related entity flags is set.\n-\n          pragma Assert (Present (Prag));\n-         Arg := First (Pragma_Argument_Associations (Prag));\n-\n-         --  A non-null argument guarantees full default initialization\n-\n-         if Present (Arg) then\n-            return Nkind (Arg) /= N_Null;\n-\n-         --  Otherwise the missing argument defaults the pragma to \"True\" which\n-         --  is considered a non-null argument (see above).\n \n-         else\n-            return True;\n-         end if;\n+         return Is_Verifiable_DIC_Pragma (Prag);\n       end if;\n \n       --  A scalar type is fully default initialized if it is subject to aspect\n@@ -11302,23 +10988,6 @@ package body Sem_Util is\n       return Off * (Expr_Value (Exp) - Expr_Value (Low_Bound ((Ind))));\n    end Indexed_Component_Bit_Offset;\n \n-   -----------------------------------------\n-   -- Inherit_Default_Init_Cond_Procedure --\n-   -----------------------------------------\n-\n-   procedure Inherit_Default_Init_Cond_Procedure (Typ : Entity_Id) is\n-      Par_Typ : constant Entity_Id := Etype (Typ);\n-\n-   begin\n-      --  A derived type inherits the default initial condition procedure of\n-      --  its parent type.\n-\n-      if No (Default_Init_Cond_Procedure (Typ)) then\n-         Set_Default_Init_Cond_Procedure\n-           (Typ, Default_Init_Cond_Procedure (Par_Typ));\n-      end if;\n-   end Inherit_Default_Init_Cond_Procedure;\n-\n    ----------------------------\n    -- Inherit_Rep_Item_Chain --\n    ----------------------------\n@@ -13493,20 +13162,16 @@ package body Sem_Util is\n       end if;\n    end Is_Local_Variable_Reference;\n \n-   -----------------------------------------------\n-   -- Is_Nontrivial_Default_Init_Cond_Procedure --\n-   -----------------------------------------------\n+   ---------------------------------\n+   -- Is_Nontrivial_DIC_Procedure --\n+   ---------------------------------\n \n-   function Is_Nontrivial_Default_Init_Cond_Procedure\n-     (Id : Entity_Id) return Boolean\n-   is\n+   function Is_Nontrivial_DIC_Procedure (Id : Entity_Id) return Boolean is\n       Body_Decl : Node_Id;\n-      Stmt : Node_Id;\n+      Stmt      : Node_Id;\n \n    begin\n-      if Ekind (Id) = E_Procedure\n-        and then Is_Default_Init_Cond_Procedure (Id)\n-      then\n+      if Ekind (Id) = E_Procedure and then Is_DIC_Procedure (Id) then\n          Body_Decl :=\n            Unit_Declaration_Node\n              (Corresponding_Body (Unit_Declaration_Node (Id)));\n@@ -13530,7 +13195,7 @@ package body Sem_Util is\n       end if;\n \n       return False;\n-   end Is_Nontrivial_Default_Init_Cond_Procedure;\n+   end Is_Nontrivial_DIC_Procedure;\n \n    -------------------------\n    -- Is_Null_Record_Type --\n@@ -15391,6 +15056,21 @@ package body Sem_Util is\n       end if;\n    end Is_Variable;\n \n+   ------------------------------\n+   -- Is_Verifiable_DIC_Pragma --\n+   ------------------------------\n+\n+   function Is_Verifiable_DIC_Pragma (Prag : Node_Id) return Boolean is\n+      Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+\n+   begin\n+      --  To qualify as verifiable, a DIC pragma must have a non-null argument\n+\n+      return\n+        Present (Args)\n+          and then Nkind (Get_Pragma_Arg (First (Args))) /= N_Null;\n+   end Is_Verifiable_DIC_Pragma;\n+\n    ---------------------------\n    -- Is_Visibly_Controlled --\n    ---------------------------\n@@ -18481,7 +18161,6 @@ package body Sem_Util is\n    ---------------------------\n \n    function Primitive_Names_Match (E1, E2 : Entity_Id) return Boolean is\n-\n       function Non_Internal_Name (E : Entity_Id) return Name_Id;\n       --  Given an internal name, returns the corresponding non-internal name\n \n@@ -18701,6 +18380,70 @@ package body Sem_Util is\n       Set_Sloc (Endl, Loc);\n    end Process_End_Label;\n \n+   --------------------------------\n+   -- Propagate_Concurrent_Flags --\n+   --------------------------------\n+\n+   procedure Propagate_Concurrent_Flags\n+     (Typ      : Entity_Id;\n+      Comp_Typ : Entity_Id)\n+   is\n+   begin\n+      if Has_Task (Comp_Typ) then\n+         Set_Has_Task (Typ);\n+      end if;\n+\n+      if Has_Protected (Comp_Typ) then\n+         Set_Has_Protected (Typ);\n+      end if;\n+\n+      if Has_Timing_Event (Comp_Typ) then\n+         Set_Has_Timing_Event (Typ);\n+      end if;\n+   end Propagate_Concurrent_Flags;\n+\n+   ------------------------------\n+   -- Propagate_DIC_Attributes --\n+   ------------------------------\n+\n+   procedure Propagate_DIC_Attributes\n+     (Typ      : Entity_Id;\n+      From_Typ : Entity_Id)\n+   is\n+      DIC_Proc : Entity_Id;\n+\n+   begin\n+      if Present (Typ) and then Present (From_Typ) then\n+         pragma Assert (Is_Type (Typ) and then Is_Type (From_Typ));\n+\n+         --  Nothing to do if both the source and the destination denote the\n+         --  same type.\n+\n+         if From_Typ = Typ then\n+            return;\n+         end if;\n+\n+         DIC_Proc := DIC_Procedure (From_Typ);\n+\n+         --  The setting of the attributes is intentionally conservative. This\n+         --  prevents accidental clobbering of enabled attributes.\n+\n+         if Has_Inherited_DIC (From_Typ)\n+           and then not Has_Inherited_DIC (Typ)\n+         then\n+            Set_Has_Inherited_DIC (Typ);\n+         end if;\n+\n+         if Has_Own_DIC (From_Typ) and then not Has_Own_DIC (Typ) then\n+            Set_Has_Own_DIC (Typ);\n+         end if;\n+\n+         if Present (DIC_Proc) and then No (DIC_Procedure (Typ)) then\n+            Set_DIC_Procedure (Typ, DIC_Proc);\n+         end if;\n+      end if;\n+   end Propagate_DIC_Attributes;\n+\n    ------------------------------------\n    -- Propagate_Invariant_Attributes --\n    ------------------------------------\n@@ -18758,28 +18501,6 @@ package body Sem_Util is\n       end if;\n    end Propagate_Invariant_Attributes;\n \n-   --------------------------------\n-   -- Propagate_Concurrent_Flags --\n-   --------------------------------\n-\n-   procedure Propagate_Concurrent_Flags\n-     (Typ      : Entity_Id;\n-      Comp_Typ : Entity_Id)\n-   is\n-   begin\n-      if Has_Task (Comp_Typ) then\n-         Set_Has_Task (Typ);\n-      end if;\n-\n-      if Has_Protected (Comp_Typ) then\n-         Set_Has_Protected (Typ);\n-      end if;\n-\n-      if Has_Timing_Event (Comp_Typ) then\n-         Set_Has_Timing_Event (Typ);\n-      end if;\n-   end Propagate_Concurrent_Flags;\n-\n    ---------------------------------------\n    -- Record_Possible_Part_Of_Reference --\n    ---------------------------------------"}, {"sha": "b79d02c172d99a7f8ffd394daed24754b368c766", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -209,24 +209,6 @@ package Sem_Util is\n    --  Determine whether a selected component has a type that depends on\n    --  discriminants, and build actual subtype for it if so.\n \n-   function Build_Default_Init_Cond_Call\n-     (Loc    : Source_Ptr;\n-      Obj_Id : Entity_Id;\n-      Typ    : Entity_Id) return Node_Id;\n-   --  Build a call to the default initial condition procedure of type Typ with\n-   --  Obj_Id as the actual parameter.\n-\n-   procedure Build_Default_Init_Cond_Procedure_Bodies (Priv_Decls : List_Id);\n-   --  Inspect the contents of private declarations Priv_Decls and build the\n-   --  bodies the default initial condition procedures for all types subject\n-   --  to pragma Default_Initial_Condition.\n-\n-   procedure Build_Default_Init_Cond_Procedure_Declaration (Typ : Entity_Id);\n-   --  If private type Typ is subject to pragma Default_Initial_Condition,\n-   --  build the declaration of the procedure which verifies the assumption\n-   --  of the pragma at runtime. The declaration is inserted after the related\n-   --  pragma.\n-\n    function Build_Default_Subtype\n      (T : Entity_Id;\n       N : Node_Id) return Entity_Id;\n@@ -1266,10 +1248,6 @@ package Sem_Util is\n    --  either the value is not yet known before back-end processing or it is\n    --  not known at compile time after back-end processing.\n \n-   procedure Inherit_Default_Init_Cond_Procedure (Typ : Entity_Id);\n-   --  Inherit the default initial condition procedure from the parent type of\n-   --  derived type Typ.\n-\n    procedure Inherit_Rep_Item_Chain (Typ : Entity_Id; From_Typ : Entity_Id);\n    --  Inherit the rep item chain of type From_Typ without clobbering any\n    --  existing rep items on Typ's chain. Typ is the destination type.\n@@ -1528,8 +1506,7 @@ package Sem_Util is\n    --  parameter of the current enclosing subprogram.\n    --  Why are OUT parameters not considered here ???\n \n-   function Is_Nontrivial_Default_Init_Cond_Procedure\n-     (Id : Entity_Id) return Boolean;\n+   function Is_Nontrivial_DIC_Procedure (Id : Entity_Id) return Boolean;\n    --  Determine whether entity Id denotes the procedure that verifies the\n    --  assertion expression of pragma Default_Initial_Condition and if it does,\n    --  the encapsulated expression is nontrivial.\n@@ -1751,6 +1728,10 @@ package Sem_Util is\n    --  default is True since this routine is commonly invoked as part of the\n    --  semantic analysis and it must not be disturbed by the rewriten nodes.\n \n+   function Is_Verifiable_DIC_Pragma (Prag : Node_Id) return Boolean;\n+   --  Determine whether pragma Default_Initial_Condition denoted by Prag has\n+   --  an assertion expression which should be verified at runtime.\n+\n    function Is_Visibly_Controlled (T : Entity_Id) return Boolean;\n    --  Check whether T is derived from a visibly controlled type. This is true\n    --  if the root type is declared in Ada.Finalization. If T is derived\n@@ -2050,12 +2031,6 @@ package Sem_Util is\n    --  parameter Ent gives the entity to which the End_Label refers,\n    --  and to which cross-references are to be generated.\n \n-   procedure Propagate_Invariant_Attributes\n-     (Typ      : Entity_Id;\n-      From_Typ : Entity_Id);\n-   --  Inherit all invariant-related attributes form type From_Typ. Typ is the\n-   --  destination type.\n-\n    procedure Propagate_Concurrent_Flags\n      (Typ      : Entity_Id;\n       Comp_Typ : Entity_Id);\n@@ -2065,6 +2040,18 @@ package Sem_Util is\n    --  by one of these flags. This procedure can only set flags for Typ, and\n    --  never clear them. Comp_Typ is the type of a component or a parent.\n \n+   procedure Propagate_DIC_Attributes\n+     (Typ      : Entity_Id;\n+      From_Typ : Entity_Id);\n+   --  Inherit all Default_Initial_Condition-related attributes from type\n+   --  From_Typ. Typ is the destination type.\n+\n+   procedure Propagate_Invariant_Attributes\n+     (Typ      : Entity_Id;\n+      From_Typ : Entity_Id);\n+   --  Inherit all invariant-related attributes form type From_Typ. Typ is the\n+   --  destination type.\n+\n    procedure Record_Possible_Part_Of_Reference\n      (Var_Id : Entity_Id;\n       Ref    : Node_Id);"}, {"sha": "a3c336baeece42a0c46a24ca88279e76914c7fba", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -1702,20 +1702,21 @@ package body Sem_Warn is\n       -----------------------------\n \n       function Is_OK_Fully_Initialized return Boolean is\n+         Prag : Node_Id;\n+\n       begin\n          if Is_Access_Type (Typ) and then Is_Dereferenced (N) then\n             return False;\n \n-         --  If a type has Default_Initial_Condition set, or it inherits it,\n-         --  DIC might be specified with a boolean value, meaning that the type\n-         --  is considered to be fully default initialized (SPARK RM 3.1 and\n-         --  SPARK RM 7.3.3). To avoid generating spurious warnings in this\n-         --  case, consider all types with DIC as fully initialized.\n+         --  A type subject to pragma Default_Initial_Condition is fully\n+         --  default initialized when the pragma appears with a non-null\n+         --  argument (SPARK RM 3.1 and SPARK RM 7.3.3).\n \n-         elsif Has_Default_Init_Cond (Typ)\n-           or else Has_Inherited_Default_Init_Cond (Typ)\n-         then\n-            return True;\n+         elsif Has_DIC (Typ) then\n+            Prag := Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n+            pragma Assert (Present (Prag));\n+\n+            return Is_Verifiable_DIC_Pragma (Prag);\n \n          else\n             return Is_Fully_Initialized_Type (Typ);"}, {"sha": "fd486ddd899310e5926a56cd2d1d45b7f8620ef8", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -1284,6 +1284,14 @@ package body Sinfo is\n       return Node3 (N);\n    end Expression;\n \n+   function Expression_Copy\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma_Argument_Association);\n+      return Node2 (N);\n+   end Expression_Copy;\n+\n    function Expressions\n       (N : Node_Id) return List_Id is\n    begin\n@@ -4555,6 +4563,14 @@ package body Sinfo is\n       Set_Node3_With_Parent (N, Val);\n    end Set_Expression;\n \n+   procedure Set_Expression_Copy\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma_Argument_Association);\n+      Set_Node2 (N, Val);  -- semantic field, no parent set\n+   end Set_Expression_Copy;\n+\n    procedure Set_Expressions\n       (N : Node_Id; Val : List_Id) is\n    begin"}, {"sha": "125f197189149718254efda3c77653f51949c8bc", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f63d601b9629ffbf756c97dac2d4241ed43d9e4e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f63d601b9629ffbf756c97dac2d4241ed43d9e4e", "patch": "@@ -1281,6 +1281,12 @@ package Sinfo is\n    --    target of the assignment or initialization is used to generate the\n    --    left-hand side of individual assignment to each sub-component.\n \n+   --  Expression_Copy (Node2-Sem)\n+   --    Present in N_Pragma_Argument_Association nodes. Contains a copy of the\n+   --    original expression. This field is best used to store pragma-dependent\n+   --    modifications performed on the original expression such as replacement\n+   --    of the current type instance or substitutions of primitives.\n+\n    --  First_Inlined_Subprogram (Node3-Sem)\n    --    Present in the N_Compilation_Unit node for the main program. Points\n    --    to a chain of entities for subprograms that are to be inlined. The\n@@ -2571,6 +2577,7 @@ package Sinfo is\n       --  N_Pragma_Argument_Association\n       --  Sloc points to first token in association\n       --  Chars (Name1) (set to No_Name if no pragma argument identifier)\n+      --  Expression_Copy (Node2-Sem)\n       --  Expression (Node3)\n \n       ------------------------\n@@ -9181,6 +9188,9 @@ package Sinfo is\n    function Expression\n      (N : Node_Id) return Node_Id;    -- Node3\n \n+   function Expression_Copy\n+     (N : Node_Id) return Node_Id;    -- Node2\n+\n    function Expressions\n      (N : Node_Id) return List_Id;    -- List1\n \n@@ -10227,6 +10237,9 @@ package Sinfo is\n    procedure Set_Expression\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n+   procedure Set_Expression_Copy\n+     (N : Node_Id; Val : Node_Id);            -- Node2\n+\n    procedure Set_Expressions\n      (N : Node_Id; Val : List_Id);            -- List1\n \n@@ -11082,7 +11095,7 @@ package Sinfo is\n \n      N_Pragma_Argument_Association =>\n        (1 => True,    --  Chars (Name1)\n-        2 => False,   --  unused\n+        2 => False,   --  Expression_Copy (Node2-Sem)\n         3 => True,    --  Expression (Node3)\n         4 => False,   --  unused\n         5 => False),  --  unused\n@@ -12544,14 +12557,14 @@ package Sinfo is\n         5 => False),  --  unused\n \n      N_Push_Program_Error_Label =>\n-       (1 => False,   --  Exception_Label\n+       (1 => False,   --  unused\n         2 => False,   --  unused\n         3 => False,   --  unused\n         4 => False,   --  unused\n         5 => False),  --  Exception_Label\n \n      N_Push_Storage_Error_Label =>\n-       (1 => False,   --  Exception_Label\n+       (1 => False,   --  unused\n         2 => False,   --  unused\n         3 => False,   --  unused\n         4 => False,   --  unused\n@@ -12790,6 +12803,7 @@ package Sinfo is\n    pragma Inline (Explicit_Actual_Parameter);\n    pragma Inline (Explicit_Generic_Actual_Parameter);\n    pragma Inline (Expression);\n+   pragma Inline (Expression_Copy);\n    pragma Inline (Expressions);\n    pragma Inline (First_Bit);\n    pragma Inline (First_Inlined_Subprogram);\n@@ -13136,6 +13150,7 @@ package Sinfo is\n    pragma Inline (Set_Explicit_Actual_Parameter);\n    pragma Inline (Set_Explicit_Generic_Actual_Parameter);\n    pragma Inline (Set_Expression);\n+   pragma Inline (Set_Expression_Copy);\n    pragma Inline (Set_Expressions);\n    pragma Inline (Set_First_Bit);\n    pragma Inline (Set_First_Inlined_Subprogram);"}]}