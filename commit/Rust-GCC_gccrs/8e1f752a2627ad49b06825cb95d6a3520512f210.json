{"sha": "8e1f752a2627ad49b06825cb95d6a3520512f210", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxZjc1MmEyNjI3YWQ0OWIwNjgyNWNiOTVkNmEzNTIwNTEyZjIxMA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-28T18:03:02Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-28T18:03:02Z"}, "message": "gfortran.h (enum expr_t): New value `EXPR_COMPCALL'.\n\n2008-08-28  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (enum expr_t): New value `EXPR_COMPCALL'.\n\t(gfc_get_typebound_proc): New macro.\n\t(struct gfc_expr): New union-member `compcall' for EXPR_COMPCALL.\n\t(enum gfc_exec_op): New value `EXEC_COMPCALL'.\n\t(gfc_find_typebound_proc): New argument.\n\t(gfc_copy_ref), (gfc_match_varspec): Made public.\n\t* decl.c (match_procedure_in_type): Use gfc_get_typebound_proc.\n\t* expr.c (free_expr0), (gfc_copy_expr): Handle EXPR_COMPCALL.\n\t(gfc_copy_ref): Made public and use new name.\n\t(simplify_const_ref): Use new name of gfc_copy_ref.\n\t(simplify_parameter_variable): Ditto.\n\t(gfc_simplify_expr): gcc_unreachable for EXPR_COMPCALL.\n\t* match.c (match_typebound_call): New method.\n\t(gfc_match_call): Allow for CALL's to typebound procedures.\n\t* module.c (binding_passing), (binding_overriding): New variables.\n\t(expr_types): Add EXPR_COMPCALL.\n\t(mio_expr): gcc_unreachable for EXPR_COMPCALL.\n\t(mio_typebound_proc), (mio_typebound_symtree): New methods.\n\t(mio_f2k_derived): Handle type-bound procedures.\n\t* primary.c (gfc_match_varspec): Made public and parse trailing\n\treferences to type-bound procedures; new argument `sub_flag'.\n\t(gfc_match_rvalue): New name and argument of gfc_match_varspec.\n\t(match_variable): Ditto.\n\t* resolve.c (update_arglist_pass): New method.\n\t(update_compcall_arglist), (resolve_typebound_static): New methods.\n\t(resolve_typebound_call), (resolve_compcall): New methods.\n\t(gfc_resolve_expr): Handle EXPR_COMPCALL.\n\t(resolve_code): Handle EXEC_COMPCALL.\n\t(resolve_fl_derived): New argument to gfc_find_typebound_proc.\n\t(resolve_typebound_procedure): Ditto and removed not-implemented error.\n\t* st.c (gfc_free_statement): Handle EXEC_COMPCALL.\n\t* symbol.c (gfc_find_typebound_proc): New argument `noaccess' and\n\timplement access-checking.\n\t* trans-expr.c (gfc_apply_interface_mapping_to_expr): gcc_unreachable\n\ton EXPR_COMPCALL.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Add missing break.\n\t* trans-openmp.c (gfc_trans_omp_array_reduction): Add missing\n\tintialization of ref->type.\n\n2008-08-28  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/typebound_call_1.f03: New test.\n\t* gfortran.dg/typebound_call_2.f03: New test.\n\t* gfortran.dg/typebound_call_3.f03: New test.\n\t* gfortran.dg/typebound_call_4.f03: New test.\n\t* gfortran.dg/typebound_call_5.f03: New test.\n\t* gfortran.dg/typebound_call_6.f03: New test.\n\t* gfortran.dg/typebound_proc_1.f08: Don't expect not-implemented error.\n\t* gfortran.dg/typebound_proc_2.f90: Ditto.\n\t* gfortran.dg/typebound_proc_5.f03: Ditto.\n\t* gfortran.dg/typebound_proc_6.f03: Ditto.\n\t* gfortran.dg/typebound_proc_7.f03: Ditto.\n\t* gfortran.dg/typebound_proc_8.f03: Ditto.\n\nFrom-SVN: r139724", "tree": {"sha": "40d33bd2a0404b05dfa1fbd4df6b97a4e144ac98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40d33bd2a0404b05dfa1fbd4df6b97a4e144ac98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e1f752a2627ad49b06825cb95d6a3520512f210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1f752a2627ad49b06825cb95d6a3520512f210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1f752a2627ad49b06825cb95d6a3520512f210", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1f752a2627ad49b06825cb95d6a3520512f210/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf7442bb5f155d6e7a1de5fe7922e7831ebefade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7442bb5f155d6e7a1de5fe7922e7831ebefade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7442bb5f155d6e7a1de5fe7922e7831ebefade"}], "stats": {"total": 941, "additions": 884, "deletions": 57}, "files": [{"sha": "e6b1866d42514407d8a2ed5b93c5520f8fc6db86", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1,3 +1,44 @@\n+2008-08-28  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (enum expr_t): New value `EXPR_COMPCALL'.\n+\t(gfc_get_typebound_proc): New macro.\n+\t(struct gfc_expr): New union-member `compcall' for EXPR_COMPCALL.\n+\t(enum gfc_exec_op): New value `EXEC_COMPCALL'.\n+\t(gfc_find_typebound_proc): New argument.\n+\t(gfc_copy_ref), (gfc_match_varspec): Made public.\n+\t* decl.c (match_procedure_in_type): Use gfc_get_typebound_proc.\n+\t* expr.c (free_expr0), (gfc_copy_expr): Handle EXPR_COMPCALL.\n+\t(gfc_copy_ref): Made public and use new name.\n+\t(simplify_const_ref): Use new name of gfc_copy_ref.\n+\t(simplify_parameter_variable): Ditto.\n+\t(gfc_simplify_expr): gcc_unreachable for EXPR_COMPCALL.\n+\t* match.c (match_typebound_call): New method.\n+\t(gfc_match_call): Allow for CALL's to typebound procedures.\n+\t* module.c (binding_passing), (binding_overriding): New variables.\n+\t(expr_types): Add EXPR_COMPCALL.\n+\t(mio_expr): gcc_unreachable for EXPR_COMPCALL.\n+\t(mio_typebound_proc), (mio_typebound_symtree): New methods.\n+\t(mio_f2k_derived): Handle type-bound procedures.\n+\t* primary.c (gfc_match_varspec): Made public and parse trailing\n+\treferences to type-bound procedures; new argument `sub_flag'.\n+\t(gfc_match_rvalue): New name and argument of gfc_match_varspec.\n+\t(match_variable): Ditto.\n+\t* resolve.c (update_arglist_pass): New method.\n+\t(update_compcall_arglist), (resolve_typebound_static): New methods.\n+\t(resolve_typebound_call), (resolve_compcall): New methods.\n+\t(gfc_resolve_expr): Handle EXPR_COMPCALL.\n+\t(resolve_code): Handle EXEC_COMPCALL.\n+\t(resolve_fl_derived): New argument to gfc_find_typebound_proc.\n+\t(resolve_typebound_procedure): Ditto and removed not-implemented error.\n+\t* st.c (gfc_free_statement): Handle EXEC_COMPCALL.\n+\t* symbol.c (gfc_find_typebound_proc): New argument `noaccess' and\n+\timplement access-checking.\n+\t* trans-expr.c (gfc_apply_interface_mapping_to_expr): gcc_unreachable\n+\ton EXPR_COMPCALL.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Add missing break.\n+\t* trans-openmp.c (gfc_trans_omp_array_reduction): Add missing\n+\tintialization of ref->type.\n+\n 2008-08-28  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/37253"}, {"sha": "2b50ea33be84df8fb7198100c81849c58d751588", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -6888,7 +6888,7 @@ match_procedure_in_type (void)\n     }\n \n   /* Construct the data structure.  */\n-  tb = XCNEW (gfc_typebound_proc);\n+  tb = gfc_get_typebound_proc ();\n   tb->where = gfc_current_locus;\n \n   /* Match binding attributes.  */"}, {"sha": "b5a17c0d5d80b28f8192861293f13b49460404cf", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -181,6 +181,10 @@ free_expr0 (gfc_expr *e)\n       gfc_free_actual_arglist (e->value.function.actual);\n       break;\n \n+    case EXPR_COMPCALL:\n+      gfc_free_actual_arglist (e->value.compcall.actual);\n+      break;\n+\n     case EXPR_VARIABLE:\n       break;\n \n@@ -268,8 +272,8 @@ gfc_extract_int (gfc_expr *expr, int *result)\n \n /* Recursively copy a list of reference structures.  */\n \n-static gfc_ref *\n-copy_ref (gfc_ref *src)\n+gfc_ref *\n+gfc_copy_ref (gfc_ref *src)\n {\n   gfc_array_ref *ar;\n   gfc_ref *dest;\n@@ -299,7 +303,7 @@ copy_ref (gfc_ref *src)\n       break;\n     }\n \n-  dest->next = copy_ref (src->next);\n+  dest->next = gfc_copy_ref (src->next);\n \n   return dest;\n }\n@@ -502,6 +506,12 @@ gfc_copy_expr (gfc_expr *p)\n \tgfc_copy_actual_arglist (p->value.function.actual);\n       break;\n \n+    case EXPR_COMPCALL:\n+      q->value.compcall.actual =\n+\tgfc_copy_actual_arglist (p->value.compcall.actual);\n+      q->value.compcall.tbp = p->value.compcall.tbp;\n+      break;\n+\n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n       q->value.constructor = gfc_copy_constructor (p->value.constructor);\n@@ -514,7 +524,7 @@ gfc_copy_expr (gfc_expr *p)\n \n   q->shape = gfc_copy_shape (p->shape, p->rank);\n \n-  q->ref = copy_ref (p->ref);\n+  q->ref = gfc_copy_ref (p->ref);\n \n   return q;\n }\n@@ -1443,7 +1453,7 @@ simplify_const_ref (gfc_expr *p)\n \t\t  cons = p->value.constructor;\n \t\t  for (; cons; cons = cons->next)\n \t\t    {\n-\t\t      cons->expr->ref = copy_ref (p->ref->next);\n+\t\t      cons->expr->ref = gfc_copy_ref (p->ref->next);\n \t\t      simplify_const_ref (cons->expr);\n \t\t    }\n \t\t}\n@@ -1531,7 +1541,7 @@ simplify_parameter_variable (gfc_expr *p, int type)\n \n   /* Do not copy subobject refs for constant.  */\n   if (e->expr_type != EXPR_CONSTANT && p->ref != NULL)\n-    e->ref = copy_ref (p->ref);\n+    e->ref = gfc_copy_ref (p->ref);\n   t = gfc_simplify_expr (e, type);\n \n   /* Only use the simplification if it eliminated all subobject references.  */\n@@ -1670,6 +1680,10 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \treturn FAILURE;\n \n       break;\n+\n+    case EXPR_COMPCALL:\n+      gcc_unreachable ();\n+      break;\n     }\n \n   return SUCCESS;"}, {"sha": "386668dfa47fd942051af3c1c32bbbf02c4c86bc", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -151,7 +151,7 @@ bt;\n /* Expression node types.  */\n typedef enum\n { EXPR_OP = 1, EXPR_FUNCTION, EXPR_CONSTANT, EXPR_VARIABLE,\n-  EXPR_SUBSTRING, EXPR_STRUCTURE, EXPR_ARRAY, EXPR_NULL\n+  EXPR_SUBSTRING, EXPR_STRUCTURE, EXPR_ARRAY, EXPR_NULL, EXPR_COMPCALL\n }\n expr_t;\n \n@@ -1003,14 +1003,16 @@ typedef struct\n \n   /* Once resolved, we use the position of pass_arg in the formal arglist of\n      the binding-target procedure to identify it.  The first argument has\n-     number 0 here, the second 1, and so on.  */\n+     number 1 here, the second 2, and so on.  */\n   unsigned pass_arg_num;\n \n   unsigned nopass:1; /* Whether we have NOPASS (PASS otherwise).  */\n   unsigned non_overridable:1;\n }\n gfc_typebound_proc;\n \n+#define gfc_get_typebound_proc() XCNEW (gfc_typebound_proc)\n+\n \n /* Symbol nodes.  These are important things.  They are what the\n    standard refers to as \"entities\".  The possibly multiple names that\n@@ -1447,11 +1449,13 @@ gfc_intrinsic_sym;\n    EXPR_FUNCTION   Function call, symbol points to function's name\n    EXPR_CONSTANT   A scalar constant: Logical, String, Real, Int or Complex\n    EXPR_VARIABLE   An Lvalue with a root symbol and possible reference list\n-                   which expresses structure, array and substring refs.\n+\t\t   which expresses structure, array and substring refs.\n    EXPR_NULL       The NULL pointer value (which also has a basic type).\n    EXPR_SUBSTRING  A substring of a constant string\n    EXPR_STRUCTURE  A structure constructor\n-   EXPR_ARRAY      An array constructor.  */\n+   EXPR_ARRAY      An array constructor.\n+   EXPR_COMPCALL   Function (or subroutine) call of a procedure pointer\n+\t\t   component or type-bound procedure.  */\n \n #include <gmp.h>\n #include <mpfr.h>\n@@ -1466,7 +1470,8 @@ typedef struct gfc_expr\n   int rank;\n   mpz_t *shape;\t\t/* Can be NULL if shape is unknown at compile time */\n \n-  /* Nonnull for functions and structure constructors */\n+  /* Nonnull for functions and structure constructors, the base object for\n+     component-calls.  */\n   gfc_symtree *symtree;\n \n   gfc_ref *ref;\n@@ -1524,6 +1529,13 @@ typedef struct gfc_expr\n     }\n     function;\n \n+    struct\n+    {\n+      gfc_actual_arglist* actual;\n+      gfc_symtree* tbp;\n+    }\n+    compcall;\n+\n     struct\n     {\n       int length;\n@@ -1770,8 +1782,8 @@ gfc_forall_iterator;\n typedef enum\n {\n   EXEC_NOP = 1, EXEC_ASSIGN, EXEC_LABEL_ASSIGN, EXEC_POINTER_ASSIGN,\n-  EXEC_GOTO, EXEC_CALL, EXEC_ASSIGN_CALL, EXEC_RETURN, EXEC_ENTRY,\n-  EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE, EXEC_INIT_ASSIGN,\n+  EXEC_GOTO, EXEC_CALL, EXEC_COMPCALL, EXEC_ASSIGN_CALL, EXEC_RETURN,\n+  EXEC_ENTRY, EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE, EXEC_INIT_ASSIGN,\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT,\n   EXEC_ALLOCATE, EXEC_DEALLOCATE,\n@@ -2261,7 +2273,7 @@ gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n-gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, const char*);\n+gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*, const char*, bool);\n \n void copy_formal_args (gfc_symbol *dest, gfc_symbol *src);\n \n@@ -2341,6 +2353,7 @@ gfc_expr *gfc_logical_expr (int, locus *);\n mpz_t *gfc_copy_shape (mpz_t *, int);\n mpz_t *gfc_copy_shape_excluding (mpz_t *, int, gfc_expr *);\n gfc_expr *gfc_copy_expr (gfc_expr *);\n+gfc_ref* gfc_copy_ref (gfc_ref*);\n \n gfc_try gfc_specification_expr (gfc_expr *);\n \n@@ -2464,6 +2477,7 @@ bool gfc_check_access (gfc_access, gfc_access);\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);\n symbol_attribute gfc_expr_attr (gfc_expr *);\n match gfc_match_rvalue (gfc_expr **);\n+match gfc_match_varspec (gfc_expr*, int, bool);\n int gfc_check_digit (char, int);\n \n /* trans.c */"}, {"sha": "0da70689443b4e4cdaa0e65dbd9236ede4ca6201", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -2509,6 +2509,48 @@ gfc_match_return (void)\n }\n \n \n+/* Match the call of a type-bound procedure, if CALL%var has already been \n+   matched and var found to be a derived-type variable.  */\n+\n+static match\n+match_typebound_call (gfc_symtree* varst)\n+{\n+  gfc_symbol* var;\n+  gfc_expr* base;\n+  match m;\n+\n+  var = varst->n.sym;\n+\n+  base = gfc_get_expr ();\n+  base->expr_type = EXPR_VARIABLE;\n+  base->symtree = varst;\n+  base->where = gfc_current_locus;\n+  \n+  m = gfc_match_varspec (base, 0, true);\n+  if (m == MATCH_NO)\n+    gfc_error (\"Expected component reference at %C\");\n+  if (m != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Junk after CALL at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (base->expr_type != EXPR_COMPCALL)\n+    {\n+      gfc_error (\"Expected type-bound procedure reference at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  new_st.op = EXEC_COMPCALL;\n+  new_st.expr = base;\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a CALL statement.  The tricky part here are possible\n    alternate return specifiers.  We handle these by having all\n    \"subroutines\" actually return an integer via a register that gives\n@@ -2541,6 +2583,11 @@ gfc_match_call (void)\n \n   sym = st->n.sym;\n \n+  /* If this is a variable of derived-type, it probably starts a type-bound\n+     procedure call.  */\n+  if (sym->attr.flavor != FL_PROCEDURE && sym->ts.type == BT_DERIVED)\n+    return match_typebound_call (st);\n+\n   /* If it does not seem to be callable...  */\n   if (!sym->attr.generic\n \t&& !sym->attr.subroutine)"}, {"sha": "4cbaaa09b18d4678754b1db9f362cca8e7c568fa", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1695,6 +1695,20 @@ static const mstring attr_bits[] =\n     minit (NULL, -1)\n };\n \n+/* For binding attributes.  */\n+static const mstring binding_passing[] =\n+{\n+    minit (\"PASS\", 0),\n+    minit (\"NOPASS\", 1),\n+    minit (NULL, -1)\n+};\n+static const mstring binding_overriding[] =\n+{\n+    minit (\"OVERRIDABLE\", 0),\n+    minit (\"NON_OVERRIDABLE\", 1),\n+    minit (NULL, -1)\n+};\n+\n \n /* Specialization of mio_name.  */\n DECL_MIO_NAME (ab_attribute)\n@@ -2762,6 +2776,7 @@ static const mstring expr_types[] = {\n     minit (\"STRUCTURE\", EXPR_STRUCTURE),\n     minit (\"ARRAY\", EXPR_ARRAY),\n     minit (\"NULL\", EXPR_NULL),\n+    minit (\"COMPCALL\", EXPR_COMPCALL),\n     minit (NULL, -1)\n };\n \n@@ -3025,6 +3040,10 @@ mio_expr (gfc_expr **ep)\n \n     case EXPR_NULL:\n       break;\n+\n+    case EXPR_COMPCALL:\n+      gcc_unreachable ();\n+      break;\n     }\n \n   mio_rparen ();\n@@ -3180,6 +3199,54 @@ mio_namespace_ref (gfc_namespace **nsp)\n \n /* Save/restore the f2k_derived namespace of a derived-type symbol.  */\n \n+static void\n+mio_typebound_proc (gfc_typebound_proc** proc)\n+{\n+  int flag;\n+\n+  if (iomode == IO_INPUT)\n+    {\n+      *proc = gfc_get_typebound_proc ();\n+      (*proc)->where = gfc_current_locus;\n+    }\n+  gcc_assert (*proc);\n+\n+  mio_lparen ();\n+  mio_symtree_ref (&(*proc)->target);\n+\n+  (*proc)->access = MIO_NAME (gfc_access) ((*proc)->access, access_types);\n+\n+  (*proc)->nopass = mio_name ((*proc)->nopass, binding_passing);\n+  (*proc)->non_overridable = mio_name ((*proc)->non_overridable,\n+\t\t\t\t       binding_overriding);\n+\n+  if (iomode == IO_INPUT)\n+    (*proc)->pass_arg = NULL;\n+\n+  flag = (int) (*proc)->pass_arg_num;\n+  mio_integer (&flag);\n+  (*proc)->pass_arg_num = (unsigned) flag;\n+\n+  mio_rparen ();\n+}\n+\n+static void\n+mio_typebound_symtree (gfc_symtree* st)\n+{\n+  if (iomode == IO_OUTPUT && !st->typebound)\n+    return;\n+\n+  if (iomode == IO_OUTPUT)\n+    {\n+      mio_lparen ();\n+      mio_allocated_string (st->name);\n+    }\n+  /* For IO_INPUT, the above is done in mio_f2k_derived.  */\n+\n+  mio_typebound_proc (&st->typebound);\n+  mio_rparen ();\n+}\n+\n static void\n mio_finalizer (gfc_finalizer **f)\n {\n@@ -3223,6 +3290,27 @@ mio_f2k_derived (gfc_namespace *f2k)\n \t}\n     }\n   mio_rparen ();\n+\n+  /* Handle type-bound procedures.  */\n+  mio_lparen ();\n+  if (iomode == IO_OUTPUT)\n+    gfc_traverse_symtree (f2k->sym_root, &mio_typebound_symtree);\n+  else\n+    {\n+      while (peek_atom () == ATOM_LPAREN)\n+\t{\n+\t  gfc_symtree* st;\n+\n+\t  mio_lparen (); \n+\n+\t  require_atom (ATOM_STRING);\n+\t  gfc_get_sym_tree (atom_string, f2k, &st);\n+\t  gfc_free (atom_string);\n+\n+\t  mio_typebound_symtree (st);\n+\t}\n+    }\n+  mio_rparen ();\n }\n \n static void"}, {"sha": "c72f430c860c75592b9595bfc3893bd95a552327", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1676,7 +1676,7 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist **argp)\n }\n \n \n-/* Used by match_varspec() to extend the reference list by one\n+/* Used by gfc_match_varspec() to extend the reference list by one\n    element.  */\n \n static gfc_ref *\n@@ -1699,15 +1699,17 @@ extend_ref (gfc_expr *primary, gfc_ref *tail)\n /* Match any additional specifications associated with the current\n    variable like member references or substrings.  If equiv_flag is\n    set we only match stuff that is allowed inside an EQUIVALENCE\n-   statement.  */\n+   statement.  sub_flag tells whether we expect a type-bound procedure found\n+   to be a subroutine as part of CALL or a FUNCTION.  */\n \n-static match\n-match_varspec (gfc_expr *primary, int equiv_flag)\n+match\n+gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_ref *substring, *tail;\n   gfc_component *component;\n   gfc_symbol *sym = primary->symtree->n.sym;\n+  gfc_symtree *tbp;\n   match m;\n   bool unknown;\n \n@@ -1751,12 +1753,60 @@ match_varspec (gfc_expr *primary, int equiv_flag)\n \n   for (;;)\n     {\n+      gfc_try t;\n+\n       m = gfc_match_name (name);\n       if (m == MATCH_NO)\n \tgfc_error (\"Expected structure component name at %C\");\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n+      tbp = gfc_find_typebound_proc (sym, &t, name, false);\n+      if (tbp)\n+\t{\n+\t  gfc_symbol* tbp_sym;\n+\n+\t  if (t == FAILURE)\n+\t    return MATCH_ERROR;\n+\n+\t  gcc_assert (!tail || !tail->next);\n+\t  gcc_assert (primary->expr_type == EXPR_VARIABLE);\n+\n+\t  tbp_sym = tbp->typebound->target->n.sym;\n+\n+\t  primary->expr_type = EXPR_COMPCALL;\n+\t  primary->value.compcall.tbp = tbp;\n+\t  primary->ts = tbp_sym->ts;\n+\n+\t  m = gfc_match_actual_arglist (tbp_sym->attr.subroutine,\n+\t\t\t\t\t&primary->value.compcall.actual);\n+\t  if (m == MATCH_ERROR)\n+\t    return MATCH_ERROR;\n+\t  if (m == MATCH_NO)\n+\t    {\n+\t      if (sub_flag)\n+\t\tprimary->value.compcall.actual = NULL;\n+\t      else\n+\t\t{\n+\t\t  gfc_error (\"Expected argument list at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t    }\n+\n+\t  if (sub_flag && !tbp_sym->attr.subroutine)\n+\t    {\n+\t      gfc_error (\"'%s' at %C should be a SUBROUTINE\", name);\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  if (!sub_flag && !tbp_sym->attr.function)\n+\t    {\n+\t      gfc_error (\"'%s' at %C should be a FUNCTION\", name);\n+\t      return MATCH_ERROR;\n+\t    }\n+\n+\t  break;\n+\t}\n+\n       component = gfc_find_component (sym, name, false, false);\n       if (component == NULL)\n \treturn MATCH_ERROR;\n@@ -2387,7 +2437,7 @@ gfc_match_rvalue (gfc_expr **result)\n       e->expr_type = EXPR_VARIABLE;\n       e->symtree = symtree;\n \n-      m = match_varspec (e, 0);\n+      m = gfc_match_varspec (e, 0, false);\n       break;\n \n     case FL_PARAMETER:\n@@ -2404,7 +2454,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t}\n \n       e->symtree = symtree;\n-      m = match_varspec (e, 0);\n+      m = gfc_match_varspec (e, 0, false);\n \n       if (sym->ts.is_c_interop || sym->ts.is_iso_c)\n \tbreak;\n@@ -2461,7 +2511,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e = gfc_get_expr ();\n \t  e->expr_type = EXPR_VARIABLE;\n \t  e->symtree = symtree;\n-\t  m = match_varspec (e, 0);\n+\t  m = gfc_match_varspec (e, 0, false);\n \t  break;\n \t}\n \n@@ -2488,7 +2538,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e->symtree = symtree;\n \t  e->expr_type = EXPR_VARIABLE;\n \n-\t  m = match_varspec (e, 0);\n+\t  m = gfc_match_varspec (e, 0, false);\n \t  break;\n \t}\n \n@@ -2584,7 +2634,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t  e = gfc_get_expr ();\n \t  e->symtree = symtree;\n \t  e->expr_type = EXPR_VARIABLE;\n-\t  m = match_varspec (e, 0);\n+\t  m = gfc_match_varspec (e, 0, false);\n \t  break;\n \t}\n \n@@ -2607,9 +2657,9 @@ gfc_match_rvalue (gfc_expr **result)\n \t      break;\n \t    }\n \n-\t  /*FIXME:??? match_varspec does set this for us: */\n+\t  /*FIXME:??? gfc_match_varspec does set this for us: */\n \t  e->ts = sym->ts;\n-\t  m = match_varspec (e, 0);\n+\t  m = gfc_match_varspec (e, 0, false);\n \t  break;\n \t}\n \n@@ -2698,7 +2748,7 @@ gfc_match_rvalue (gfc_expr **result)\n       /* If our new function returns a character, array or structure\n \t type, it might have subsequent references.  */\n \n-      m = match_varspec (e, 0);\n+      m = gfc_match_varspec (e, 0, false);\n       if (m == MATCH_NO)\n \tm = MATCH_YES;\n \n@@ -2882,7 +2932,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n   expr->where = where;\n \n   /* Now see if we have to do more.  */\n-  m = match_varspec (expr, equiv_flag);\n+  m = gfc_match_varspec (expr, equiv_flag, false);\n   if (m != MATCH_YES)\n     {\n       gfc_free_expr (expr);"}, {"sha": "c6f59ad6329d1a23ab2cc7e33be9bced1aebdc1e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 157, "deletions": 15, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -4281,6 +4281,141 @@ fixup_charlen (gfc_expr *e)\n }\n \n \n+/* Update an actual argument to include the passed-object for type-bound\n+   procedures at the right position.  */\n+\n+static gfc_actual_arglist*\n+update_arglist_pass (gfc_actual_arglist* lst, gfc_expr* po, unsigned argpos)\n+{\n+  if (argpos == 1)\n+    {\n+      gfc_actual_arglist* result;\n+\n+      result = gfc_get_actual_arglist ();\n+      result->expr = po;\n+      result->next = lst;\n+\n+      return result;\n+    }\n+\n+  gcc_assert (lst);\n+  gcc_assert (argpos > 1);\n+\n+  lst->next = update_arglist_pass (lst->next, po, argpos - 1);\n+  return lst;\n+}\n+\n+\n+/* Update the arglist of an EXPR_COMPCALL expression to include the\n+   passed-object.  */\n+\n+static gfc_try\n+update_compcall_arglist (gfc_expr* e)\n+{\n+  gfc_expr* po;\n+  gfc_typebound_proc* tbp;\n+\n+  tbp = e->value.compcall.tbp->typebound;\n+\n+  po = gfc_get_expr ();\n+  po->expr_type = EXPR_VARIABLE;\n+  po->symtree = e->symtree;\n+  po->ref = gfc_copy_ref (e->ref);\n+\n+  if (gfc_resolve_expr (po) == FAILURE)\n+    return FAILURE;\n+  if (po->rank > 0)\n+    {\n+      gfc_error (\"Passed-object at %L must be scalar\", &e->where);\n+      return FAILURE;\n+    }\n+\n+  if (tbp->nopass)\n+    {\n+      gfc_free_expr (po);\n+      return SUCCESS;\n+    }\n+\n+  gcc_assert (tbp->pass_arg_num > 0);\n+  e->value.compcall.actual = update_arglist_pass (e->value.compcall.actual, po,\n+\t\t\t\t\t\t  tbp->pass_arg_num);\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve a call to a type-bound procedure, either function or subroutine,\n+   statically from the data in an EXPR_COMPCALL expression.  The adapted\n+   arglist and the target-procedure symtree are returned.  */\n+\n+static gfc_try\n+resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n+\t\t\t  gfc_actual_arglist** actual)\n+{\n+  gcc_assert (e->expr_type == EXPR_COMPCALL);\n+\n+  /* Update the actual arglist for PASS.  */\n+  if (update_compcall_arglist (e) == FAILURE)\n+    return FAILURE;\n+\n+  *actual = e->value.compcall.actual;\n+  *target = e->value.compcall.tbp->typebound->target;\n+\n+  gfc_free_ref_list (e->ref);\n+  e->ref = NULL;\n+  e->value.compcall.actual = NULL;\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve a call to a type-bound subroutine.  */\n+\n+static gfc_try\n+resolve_typebound_call (gfc_code* c)\n+{\n+  gfc_actual_arglist* newactual;\n+  gfc_symtree* target;\n+\n+  /* Transform into an ordinary EXEC_CALL for now.  */\n+\n+  if (resolve_typebound_static (c->expr, &target, &newactual) == FAILURE)\n+    return FAILURE;\n+\n+  c->ext.actual = newactual;\n+  c->symtree = target;\n+  c->op = EXEC_CALL;\n+\n+  gcc_assert (!c->expr->ref && !c->expr->value.compcall.actual);\n+  gfc_free_expr (c->expr);\n+  c->expr = NULL;\n+\n+  return resolve_call (c);\n+}\n+\n+\n+/* Resolve a component-call expression.  */\n+\n+static gfc_try\n+resolve_compcall (gfc_expr* e)\n+{\n+  gfc_actual_arglist* newactual;\n+  gfc_symtree* target;\n+\n+  /* For now, we simply transform it into a EXPR_FUNCTION call with the same\n+     arglist to the TBP's binding target.  */\n+\n+  if (resolve_typebound_static (e, &target, &newactual) == FAILURE)\n+    return FAILURE;\n+\n+  e->value.function.actual = newactual;\n+  e->symtree = target;\n+  e->expr_type = EXPR_FUNCTION;\n+\n+  return gfc_resolve_expr (e);\n+}\n+\n+\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -4317,6 +4452,10 @@ gfc_resolve_expr (gfc_expr *e)\n \n       break;\n \n+    case EXPR_COMPCALL:\n+      t = resolve_compcall (e);\n+      break;\n+\n     case EXPR_SUBSTRING:\n       t = resolve_ref (e);\n       break;\n@@ -4786,7 +4925,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t\tpointer = 0;\n \t\tbreak;\n \t    }\n-       }\n+\t}\n     }\n \n   if (allocatable == 0 && pointer == 0)\n@@ -6201,7 +6340,9 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    omp_workshare_flag = omp_workshare_save;\n \t}\n \n-      t = gfc_resolve_expr (code->expr);\n+      t = SUCCESS;\n+      if (code->op != EXEC_COMPCALL)\n+\tt = gfc_resolve_expr (code->expr);\n       forall_flag = forall_save;\n \n       if (gfc_resolve_expr (code->expr2) == FAILURE)\n@@ -6307,6 +6448,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_call (code);\n \t  break;\n \n+\tcase EXEC_COMPCALL:\n+\t  resolve_typebound_call (code);\n+\t  break;\n+\n \tcase EXEC_SELECT:\n \t  /* Select is complicated. Also, a SELECT construct could be\n \t     a transformed computed GOTO.  */\n@@ -7842,7 +7987,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t     and look for it.  */\n \n \t  me_arg = NULL;\n-\t  stree->typebound->pass_arg_num = 0;\n+\t  stree->typebound->pass_arg_num = 1;\n \t  for (i = proc->formal; i; i = i->next)\n \t    {\n \t      if (!strcmp (i->sym->name, stree->typebound->pass_arg))\n@@ -7866,7 +8011,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t{\n \t  /* Otherwise, take the first one; there should in fact be at least\n \t     one.  */\n-\t  stree->typebound->pass_arg_num = 0;\n+\t  stree->typebound->pass_arg_num = 1;\n \t  if (!proc->formal)\n \t    {\n \t      gfc_error (\"Procedure '%s' with PASS at %L must have at\"\n@@ -7886,14 +8031,19 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t\t     me_arg->name, &where, resolve_bindings_derived->name);\n \t  goto error;\n \t}\n+\n+      gfc_warning (\"Polymorphic entities are not yet implemented,\"\n+\t\t   \" non-polymorphic passed-object dummy argument of '%s'\"\n+\t\t   \" at %L accepted\", proc->name, &where);\n     }\n \n   /* If we are extending some type, check that we don't override a procedure\n      flagged NON_OVERRIDABLE.  */\n   if (super_type)\n     {\n       gfc_symtree* overridden;\n-      overridden = gfc_find_typebound_proc (super_type, stree->name);\n+      overridden = gfc_find_typebound_proc (super_type, NULL,\n+\t\t\t\t\t    stree->name, true);\n \n       if (overridden && check_typebound_override (stree, overridden) == FAILURE)\n \tgoto error;\n@@ -7918,15 +8068,6 @@ resolve_typebound_procedure (gfc_symtree* stree)\n       goto error;\n     }\n \n-  /* FIXME: Remove once typebound-procedures are fully implemented.  */\n-  {\n-    /* Output the error only once so we can do reasonable testing.  */\n-    static bool tbp_error = false;\n-    if (!tbp_error)\n-      gfc_error (\"Type-bound procedures are not yet implemented at %L\", &where);\n-    tbp_error = true;\n-  }\n-\n   return;\n \n error:\n@@ -7984,7 +8125,8 @@ resolve_fl_derived (gfc_symbol *sym)\n     {\n       /* If this type is an extension, see if this component has the same name\n \t as an inherited type-bound procedure.  */\n-      if (super_type && gfc_find_typebound_proc (super_type, c->name))\n+      if (super_type\n+\t  && gfc_find_typebound_proc (super_type, NULL, c->name, true))\n \t{\n \t  gfc_error (\"Component '%s' of '%s' at %L has the same name as an\"\n \t\t     \" inherited type-bound procedure\","}, {"sha": "81d861aee9691b653dab5f017f36310095f08a1d", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -108,6 +108,8 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_ARITHMETIC_IF:\n       break;\n \n+    case EXEC_COMPCALL:\n+      gfc_free_expr (p->expr);\n     case EXEC_CALL:\n     case EXEC_ASSIGN_CALL:\n       gfc_free_actual_arglist (p->ext.actual);"}, {"sha": "0b202eb63289266194142997f5f74e9fe868ff7f", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -4266,23 +4266,45 @@ gfc_get_derived_super_type (gfc_symbol* derived)\n    through the super-types).  */\n \n gfc_symtree*\n-gfc_find_typebound_proc (gfc_symbol* derived, const char* name)\n+gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n+\t\t\t const char* name, bool noaccess)\n {\n   gfc_symtree* res;\n \n+  /* Set default to failure.  */\n+  if (t)\n+    *t = FAILURE;\n+\n   /* Try to find it in the current type's namespace.  */\n   gcc_assert (derived->f2k_derived);\n   res = gfc_find_symtree (derived->f2k_derived->sym_root, name);\n   if (res)\n-    return res->typebound ? res : NULL;\n+    {\n+      if (!res->typebound)\n+\treturn NULL;\n+\n+      /* We found one.  */\n+      if (t)\n+\t*t = SUCCESS;\n+\n+      if (!noaccess && derived->attr.use_assoc\n+\t  && res->typebound->access == ACCESS_PRIVATE)\n+\t{\n+\t  gfc_error (\"'%s' of '%s' is PRIVATE at %C\", name, derived->name);\n+\t  if (t)\n+\t    *t = FAILURE;\n+\t}\n+\n+      return res;\n+    }\n \n   /* Otherwise, recurse on parent type if derived is an extension.  */\n   if (derived->attr.extension)\n     {\n       gfc_symbol* super_type;\n       super_type = gfc_get_derived_super_type (derived);\n       gcc_assert (super_type);\n-      return gfc_find_typebound_proc (super_type, name);\n+      return gfc_find_typebound_proc (super_type, t, name, noaccess);\n     }\n \n   /* Nothing found.  */"}, {"sha": "6c0897897aabff87bec7ea801617848795aa86e4", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -2011,6 +2011,10 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n     case EXPR_STRUCTURE:\n       gfc_apply_interface_mapping_to_cons (mapping, expr->value.constructor);\n       break;\n+\n+    case EXPR_COMPCALL:\n+      gcc_unreachable ();\n+      break;\n     }\n \n   return;"}, {"sha": "ecb568767ffcceaead2d802fc929bd8e9d23ad57", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -901,6 +901,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \t\t  case AR_FULL:\n \t\t    break;\n \t\t  }\n+\t\tbreak;\n \t      }\n \t    }\n \t}"}, {"sha": "11a1f40dfacecc465f0ba5dfc0288a74cad44eee", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -498,6 +498,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   e1->symtree = symtree1;\n   e1->ts = sym->ts;\n   e1->ref = ref = gfc_get_ref ();\n+  ref->type = REF_ARRAY;\n   ref->u.ar.where = where;\n   ref->u.ar.as = sym->as;\n   ref->u.ar.type = AR_FULL;"}, {"sha": "6af70c550c2a3b5ad19c7568e48aa4b9c1f142cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1,3 +1,18 @@\n+2008-08-28  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/typebound_call_1.f03: New test.\n+\t* gfortran.dg/typebound_call_2.f03: New test.\n+\t* gfortran.dg/typebound_call_3.f03: New test.\n+\t* gfortran.dg/typebound_call_4.f03: New test.\n+\t* gfortran.dg/typebound_call_5.f03: New test.\n+\t* gfortran.dg/typebound_call_6.f03: New test.\n+\t* gfortran.dg/typebound_proc_1.f08: Don't expect not-implemented error.\n+\t* gfortran.dg/typebound_proc_2.f90: Ditto.\n+\t* gfortran.dg/typebound_proc_5.f03: Ditto.\n+\t* gfortran.dg/typebound_proc_6.f03: Ditto.\n+\t* gfortran.dg/typebound_proc_7.f03: Ditto.\n+\t* gfortran.dg/typebound_proc_8.f03: Ditto.\n+\n 2008-08-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37207"}, {"sha": "d0da0ecd9948c9209cd0a922c1d729d886e1f9ff", "filename": "gcc/testsuite/gfortran.dg/typebound_call_1.f03", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_1.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -0,0 +1,98 @@\n+! { dg-do run }\n+\n+! Type-bound procedures\n+! Check basic calls to NOPASS type-bound procedures.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE add\n+  CONTAINS\n+    PROCEDURE, NOPASS :: func => func_add\n+    PROCEDURE, NOPASS :: sub => sub_add\n+    PROCEDURE, NOPASS :: echo => echo_add\n+  END TYPE add\n+\n+  TYPE mul\n+  CONTAINS\n+    PROCEDURE, NOPASS :: func => func_mul\n+    PROCEDURE, NOPASS :: sub => sub_mul\n+    PROCEDURE, NOPASS :: echo => echo_mul\n+  END TYPE mul\n+\n+CONTAINS\n+\n+  INTEGER FUNCTION func_add (a, b)\n+    IMPLICIT NONE\n+    INTEGER :: a, b\n+    func_add = a + b\n+  END FUNCTION func_add\n+\n+  INTEGER FUNCTION func_mul (a, b)\n+    IMPLICIT NONE\n+    INTEGER :: a, b\n+    func_mul = a * b\n+  END FUNCTION func_mul\n+\n+  SUBROUTINE sub_add (a, b, c)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(IN) :: a, b\n+    INTEGER, INTENT(OUT) :: c\n+    c = a + b\n+  END SUBROUTINE sub_add\n+\n+  SUBROUTINE sub_mul (a, b, c)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(IN) :: a, b\n+    INTEGER, INTENT(OUT) :: c\n+    c = a * b\n+  END SUBROUTINE sub_mul\n+\n+  SUBROUTINE echo_add ()\n+    IMPLICIT NONE\n+    WRITE (*,*) \"Hi from adder!\"\n+  END SUBROUTINE echo_add\n+\n+  INTEGER FUNCTION echo_mul ()\n+    IMPLICIT NONE\n+    echo_mul = 5\n+    WRITE (*,*) \"Hi from muler!\"\n+  END FUNCTION echo_mul\n+\n+  ! Do the testing here, in the same module as the type is.\n+  SUBROUTINE test ()\n+    IMPLICIT NONE\n+\n+    TYPE(add) :: adder\n+    TYPE(mul) :: muler\n+\n+    INTEGER :: x\n+\n+    IF (adder%func (2, 3) /= 5 .OR. muler%func (2, 3) /= 6) THEN\n+      CALL abort ()\n+    END IF\n+\n+    CALL adder%sub (2, 3, x)\n+    IF (x /= 5) THEN\n+      CALL abort ()\n+    END IF\n+\n+    CALL muler%sub (2, 3, x)\n+    IF (x /= 6) THEN\n+      CALL abort ()\n+    END IF\n+\n+    ! Check procedures without arguments.\n+    CALL adder%echo ()\n+    x = muler%echo ()\n+    CALL adder%echo\n+  END SUBROUTINE test\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m, ONLY: test\n+  CALL test ()\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "d3149d56d39a8493832007e696770ed6dcca8163", "filename": "gcc/testsuite/gfortran.dg/typebound_call_2.f03", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_2.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -0,0 +1,93 @@\n+! { dg-do run }\n+\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+\n+! Type-bound procedures\n+! Check calls with passed-objects.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE add\n+    INTEGER :: wrong\n+    INTEGER :: val\n+  CONTAINS\n+    PROCEDURE, PASS :: func => func_add\n+    PROCEDURE, PASS(me) :: sub => sub_add\n+  END TYPE add\n+\n+  TYPE trueOrFalse\n+    LOGICAL :: val\n+  CONTAINS\n+    PROCEDURE, PASS :: swap\n+  END TYPE trueOrFalse\n+\n+CONTAINS\n+\n+  INTEGER FUNCTION func_add (me, x)\n+    IMPLICIT NONE\n+    TYPE(add) :: me\n+    INTEGER :: x\n+    func_add = me%val + x\n+  END FUNCTION func_add\n+\n+  SUBROUTINE sub_add (res, me, x)\n+    IMPLICIT NONE\n+    INTEGER, INTENT(OUT) :: res\n+    TYPE(add), INTENT(IN) :: me\n+    INTEGER, INTENT(IN) :: x\n+    res = me%val + x\n+  END SUBROUTINE sub_add\n+\n+  SUBROUTINE swap (me1, me2)\n+    IMPLICIT NONE\n+    TYPE(trueOrFalse), INTENT(INOUT) :: me1, me2\n+\n+    IF (.NOT. me1%val .OR. me2%val) THEN\n+      CALL abort ()\n+    END IF\n+    \n+    me1%val = .FALSE.\n+    me2%val = .TRUE.\n+  END SUBROUTINE swap\n+\n+  ! Do the testing here, in the same module as the type is.\n+  SUBROUTINE test ()\n+    IMPLICIT NONE\n+\n+    TYPE(add) :: adder\n+    TYPE(trueOrFalse) :: t, f\n+\n+    INTEGER :: x\n+\n+    adder%wrong = 0\n+    adder%val = 42\n+    IF (adder%func (8) /= 50) THEN\n+      CALL abort ()\n+    END IF\n+\n+    CALL adder%sub (x, 8)\n+    IF (x /=  50) THEN\n+      CALL abort ()\n+    END IF\n+\n+    t%val = .TRUE.\n+    f%val = .FALSE.\n+\n+    CALL t%swap (f)\n+    CALL f%swap (t)\n+\n+    IF (.NOT. t%val .OR. f%val) THEN\n+      CALL abort ()\n+    END IF\n+  END SUBROUTINE test\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m, ONLY: test\n+  CALL test ()\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "f06e1cb70f4ce6a8a8592fc52ac776ca9ff8ae8f", "filename": "gcc/testsuite/gfortran.dg/typebound_call_3.f03", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_3.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+\n+! Type-bound procedures\n+! Check that calls work across module-boundaries.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE trueOrFalse\n+    LOGICAL :: val\n+  CONTAINS\n+    PROCEDURE, PASS :: swap\n+  END TYPE trueOrFalse\n+\n+CONTAINS\n+\n+  SUBROUTINE swap (me1, me2)\n+    IMPLICIT NONE\n+    TYPE(trueOrFalse), INTENT(INOUT) :: me1, me2\n+\n+    IF (.NOT. me1%val .OR. me2%val) THEN\n+      CALL abort ()\n+    END IF\n+    \n+    me1%val = .FALSE.\n+    me2%val = .TRUE.\n+  END SUBROUTINE swap\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m, ONLY: trueOrFalse\n+  IMPLICIT NONE\n+\n+  TYPE(trueOrFalse) :: t, f\n+\n+  t%val = .TRUE.\n+  f%val = .FALSE.\n+\n+  CALL t%swap (f)\n+  CALL f%swap (t)\n+\n+  IF (.NOT. t%val .OR. f%val) THEN\n+    CALL abort ()\n+  END IF\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "d05838bfb276e62bc120a76be334d228b6b07c90", "filename": "gcc/testsuite/gfortran.dg/typebound_call_4.f03", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do compile }\n+\n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+\n+! Type-bound procedures\n+! Check for recognition/errors with more complicated references and some\n+! error-handling in general.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE t\n+  CONTAINS\n+    PROCEDURE, PASS :: proc\n+    PROCEDURE, NOPASS :: func\n+  END TYPE t\n+\n+  TYPE compt\n+    TYPE(t) :: myobj\n+  END TYPE compt\n+\n+CONTAINS\n+\n+  SUBROUTINE proc (me)\n+    IMPLICIT NONE\n+    TYPE(t), INTENT(INOUT) :: me\n+  END SUBROUTINE proc\n+\n+  INTEGER FUNCTION func ()\n+    IMPLICIT NONE\n+    func = 1812\n+  END FUNCTION func\n+\n+  SUBROUTINE test ()\n+    IMPLICIT NONE\n+    TYPE(compt) :: arr(2)\n+\n+    ! These two are OK.\n+    CALL arr(1)%myobj%proc ()\n+    WRITE (*,*) arr(2)%myobj%func ()\n+\n+    ! Base-object must be scalar.\n+    CALL arr(:)%myobj%proc () ! { dg-error \"scalar\" }\n+    WRITE (*,*) arr(:)%myobj%func () ! { dg-error \"scalar\" }\n+\n+    ! Can't CALL a function or take the result of a SUBROUTINE.\n+    CALL arr(1)%myobj%func () ! { dg-error \"SUBROUTINE\" }\n+    WRITE (*,*) arr(2)%myobj%proc () ! { dg-error \"FUNCTION\" }\n+\n+    ! Error.\n+    CALL arr(2)%myobj%proc () x ! { dg-error \"Junk after\" }\n+    WRITE (*,*) arr(1)%myobj%func ! { dg-error \"Expected argument list\" }\n+  END SUBROUTINE test\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "d9a845b073bca6663597726df6fbe5697e187ffb", "filename": "gcc/testsuite/gfortran.dg/typebound_call_5.f03", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_5.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Check for correct access-checking on type-bound procedures.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE t\n+  CONTAINS\n+    PROCEDURE, NOPASS, PRIVATE :: priv => proc\n+    PROCEDURE, NOPASS, PUBLIC :: publ => proc\n+  END TYPE t\n+\n+CONTAINS\n+\n+  SUBROUTINE proc ()\n+  END SUBROUTINE proc\n+\n+  ! This is inside the module.\n+  SUBROUTINE test1 ()\n+    IMPLICIT NONE\n+    TYPE(t) :: obj\n+\n+    CALL obj%priv () ! { dg-bogus \"PRIVATE\" }\n+    CALL obj%publ ()\n+  END SUBROUTINE test1\n+\n+END MODULE m\n+\n+! This is outside the module.\n+SUBROUTINE test2 ()\n+  USE m\n+  IMPLICIT NONE\n+  TYPE(t) :: obj\n+\n+  CALL obj%priv () ! { dg-error \"PRIVATE\" }\n+  CALL obj%publ ()\n+END SUBROUTINE test2\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "0ad510edaed1c860ea2bec5c60d2369c6df4459e", "filename": "gcc/testsuite/gfortran.dg/typebound_call_6.f03", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_6.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! { dg-output \"Super(\\n|\\r\\n|\\r).*Sub\" }\n+\n+! Type-bound procedures\n+! Check for calling right overloaded procedure.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE supert\n+  CONTAINS\n+    PROCEDURE, NOPASS :: proc => proc_super\n+  END TYPE supert\n+\n+  TYPE, EXTENDS(supert) :: subt\n+  CONTAINS\n+    PROCEDURE, NOPASS :: proc => proc_sub\n+  END TYPE subt\n+\n+CONTAINS\n+\n+  SUBROUTINE proc_super ()\n+    IMPLICIT NONE\n+    WRITE (*,*) \"Super\"\n+  END SUBROUTINE proc_super\n+\n+  SUBROUTINE proc_sub ()\n+    IMPLICIT NONE\n+    WRITE (*,*) \"Sub\"\n+  END SUBROUTINE proc_sub\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m\n+  IMPLICIT NONE\n+\n+  TYPE(supert) :: super\n+  TYPE(subt) :: sub\n+\n+  CALL super%proc\n+  CALL sub%proc\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "dafd684718bdfeae55f1779d810e3e96f4b6da7b", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_1.f08", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_1.f08?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1,5 +1,8 @@\n ! { dg-do compile }\n \n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+\n ! Type-bound procedures\n ! Test that the basic syntax for specific bindings is parsed and resolved.\n \n@@ -22,7 +25,7 @@ MODULE testmod\n     ! Might be empty\n   CONTAINS\n     PROCEDURE proc1\n-    PROCEDURE, PASS(me) :: p2 => proc2 ! { dg-error \"not yet implemented\" }\n+    PROCEDURE, PASS(me) :: p2 => proc2\n   END TYPE t1\n \n   TYPE t2"}, {"sha": "70ae2ca73231221e830f2b8a38b63f86960d5629", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_2.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_2.f90?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -31,5 +31,4 @@ END FUNCTION proc2\n END MODULE testmod\n \n ! { dg-final { cleanup-modules \"testmod\" } }\n-! FIXME: Remove not-yet-implemented error when implemented.\n-! { dg-excess-errors \"no IMPLICIT type|not yet implemented\" }\n+! { dg-excess-errors \"no IMPLICIT type\" }"}, {"sha": "edc55a17d30e22be2c83734657580511bbd8d1eb", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_5.f03", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_5.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1,5 +1,8 @@\n ! { dg-do compile }\n \n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+\n ! Type-bound procedures\n ! Test for errors in specific bindings, during resolution.\n \n@@ -117,5 +120,3 @@ END SUBROUTINE proc_no_module\n END PROGRAM main\n \n ! { dg-final { cleanup-modules \"othermod testmod\" } }\n-! FIXME: Remove not-yet-implemented error when implemented.\n-! { dg-excess-errors \"not yet implemented\" }"}, {"sha": "e7d09a055f47ef8e830cc40f32d6ad4ef7ef2dae", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_6.f03", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_6.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -1,5 +1,8 @@\n ! { dg-do compile }\n \n+! FIXME: Remove -w after polymorphic entities are supported.\n+! { dg-options \"-w\" }\n+\n ! Type-bound procedures\n ! Test for the check if overriding methods \"match\" the overridden ones by their\n ! characteristics.\n@@ -178,5 +181,3 @@ END SUBROUTINE proc_tmereal\n END MODULE testmod\n \n ! { dg-final { cleanup-modules \"testmod\" } }\n-! FIXME: Remove not-yet-implemented error when implemented.\n-! { dg-excess-errors \"not yet implemented\" }"}, {"sha": "ebf611e67e22b8e894e9799834caba422c6ca2ee", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_7.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_7.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -30,5 +30,3 @@ END SUBROUTINE proc_noarg\n END MODULE testmod\n \n ! { dg-final { cleanup-modules \"testmod\" } }\n-! FIXME: Remove not-yet-implemented error when implemented.\n-! { dg-excess-errors \"not yet implemented\" }"}, {"sha": "df7764d34744686ae462603534628bcc1094ba66", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_8.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e1f752a2627ad49b06825cb95d6a3520512f210/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_8.f03?ref=8e1f752a2627ad49b06825cb95d6a3520512f210", "patch": "@@ -35,5 +35,3 @@ END SUBROUTINE proc\n END MODULE testmod\n \n ! { dg-final { cleanup-modules \"testmod\" } }\n-! FIXME: Remove not-yet-implemented error when implemented.\n-! { dg-excess-errors \"not yet implemented\" }"}]}