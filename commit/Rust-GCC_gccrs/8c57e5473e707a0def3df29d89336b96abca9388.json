{"sha": "8c57e5473e707a0def3df29d89336b96abca9388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1N2U1NDczZTcwN2EwZGVmM2RmMjlkODkzMzZiOTZhYmNhOTM4OA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-01-02T12:30:56Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-01-02T12:30:56Z"}, "message": "Implement light-weight DImode support.\n\ngcc/\n\tImplement light-weight DImode support.\n\t* config/avr/avr-dimode.md: New file.\n\t* config/avr/avr.md: Include it.\n\t(adjust_len): Add plus64, compare64.\n\t(HIDI): Remove code iterator.\n\t(code_stdname): New code attribute.\n\t(rotx, rotsmode): Remove DI.\n\t(rotl<mode>3, *rotw<mode>, *rotb<mode>): Use HISI instead of HIDI\n\tas code iterator.\n\t* config/avr/avr-protos.h (avr_have_dimode): New.\n\t(avr_out_plus64, avr_out_compare64): New.\n\t* config/avr/avr.c (avr_out_compare): Handle DImode.\n\t(avr_have_dimode): New variable definition and initialization.\n\t(avr_out_compare64, avr_out_plus64): New functions.\n\t(avr_out_plus_1): Use simplify_unary_operation to negate xval.\n\t(adjust_insn_length): Handle ADJUST_LEN_COMPARE64, ADJUST_LEN_PLUS64.\n\t(avr_compare_pattern): Skip DImode comparisons.\n\nlibgcc/\n\tImplement light-weight DImode support.\n\t* config/avr/t-avr (LIB1ASMFUNCS): Add _adddi3, _adddi3_s8,\n\t_subdi3, _cmpdi2, _cmpdi2_s8, _rotldi3.\n\t* config/avr/lib1funcs.S (__adddi3, __adddi3_s8, __subdi3,\n\t__cmpdi2, __cmpdi2_s8, __rotldi3): New functions.\n\nFrom-SVN: r182794", "tree": {"sha": "3c24b38e4a5abc3d1734ad1478057a319e4036c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c24b38e4a5abc3d1734ad1478057a319e4036c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c57e5473e707a0def3df29d89336b96abca9388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c57e5473e707a0def3df29d89336b96abca9388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c57e5473e707a0def3df29d89336b96abca9388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c57e5473e707a0def3df29d89336b96abca9388/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f595f167555e127f24d3defedf431b06209bdfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f595f167555e127f24d3defedf431b06209bdfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f595f167555e127f24d3defedf431b06209bdfc"}], "stats": {"total": 514, "additions": 482, "deletions": 32}, "files": [{"sha": "9081d54022ec797fad7bc7c139cd49483401045f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -1,3 +1,23 @@\n+2012-01-02  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tImplement light-weight DImode support.\n+\t* config/avr/avr-dimode.md: New file.\n+\t* config/avr/avr.md: Include it.\n+\t(adjust_len): Add plus64, compare64.\n+\t(HIDI): Remove code iterator.\n+\t(code_stdname): New code attribute.\n+\t(rotx, rotsmode): Remove DI.\n+\t(rotl<mode>3, *rotw<mode>, *rotb<mode>): Use HISI instead of HIDI\n+\tas code iterator.\n+\t* config/avr/avr-protos.h (avr_have_dimode): New.\n+\t(avr_out_plus64, avr_out_compare64): New.\n+\t* config/avr/avr.c (avr_out_compare): Handle DImode.\n+\t(avr_have_dimode): New variable definition and initialization.\n+\t(avr_out_compare64, avr_out_plus64): New functions.\n+\t(avr_out_plus_1): Use simplify_unary_operation to negate xval.\n+\t(adjust_insn_length): Handle ADJUST_LEN_COMPARE64, ADJUST_LEN_PLUS64.\n+\t(avr_compare_pattern): Skip DImode comparisons.\n+\n 2012-01-02  Revital Eres  <revital.eres@linaro.org>\n \n \t* ddg.c (def_has_ccmode_p): New function."}, {"sha": "3db069b3ad7ec7d12ac3e339fbc1b6712df02e3f", "filename": "gcc/config/avr/avr-dimode.md", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr-dimode.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr-dimode.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-dimode.md?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -0,0 +1,283 @@\n+;;   Machine description for GNU compiler,\n+;;   for Atmel AVR micro controllers.\n+;;   Copyright (C) 1998 - 2011\n+;;   Free Software Foundation, Inc.\n+;;   Contributed by Georg Lay (avr@gjlay.de)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The purpose of this file is to provide a light-weight DImode\n+;; implementation for AVR.  The trouble with DImode is that tree -> RTL\n+;; lowering leads to really unpleasant code for operations that don't\n+;; work byte-wise like NEG, PLUS, MINUS, etc.  Defining optabs entries for\n+;; them won't help because the optab machinery assumes these operations\n+;; are cheap and does not check if a libgcc implementation is available.\n+;;\n+;; The DImode insns are all straight forward -- except movdi.  The approach\n+;; of this implementation is to provide DImode insns without the burden of\n+;; introducing movdi.\n+;; \n+;; The caveat is that if there are insns for some mode, there must also be a\n+;; respective move insn that describes reloads.  Therefore, this\n+;; implementation uses an accumulator-based model with two hard-coded,\n+;; accumulator-like registers\n+;;\n+;;    A[] = reg:DI 18\n+;;    B[] = reg:DI 10\n+;;\n+;; so that no DImode insn contains pseudos or needs reloading.\n+\n+(define_constants\n+  [(ACC_A\t18)\n+   (ACC_B\t10)])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Addition\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_expand \"adddi3\"\n+  [(parallel [(match_operand:DI 0 \"general_operand\" \"\")\n+              (match_operand:DI 1 \"general_operand\" \"\")\n+              (match_operand:DI 2 \"general_operand\" \"\")])]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (DImode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+\n+    if (s8_operand (operands[2], VOIDmode))\n+      {\n+        emit_move_insn (gen_rtx_REG (QImode, REG_X), operands[2]);\n+        emit_insn (gen_adddi3_const8_insn ());\n+      }        \n+    else if (CONST_INT_P (operands[2])\n+             || CONST_DOUBLE_P (operands[2]))\n+      {\n+        emit_insn (gen_adddi3_const_insn (operands[2]));\n+      }\n+    else\n+      {\n+        emit_move_insn (gen_rtx_REG (DImode, ACC_B), operands[2]);\n+        emit_insn (gen_adddi3_insn ());\n+      }\n+\n+    emit_move_insn (operands[0], acc_a);\n+    DONE;\n+  })\n+\n+(define_insn \"adddi3_insn\"\n+  [(set (reg:DI ACC_A)\n+        (plus:DI (reg:DI ACC_A)\n+                 (reg:DI ACC_B)))]\n+  \"avr_have_dimode\"\n+  \"%~call __adddi3\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"adddi3_const8_insn\"\n+  [(set (reg:DI ACC_A)\n+        (plus:DI (reg:DI ACC_A)\n+                 (sign_extend:DI (reg:QI REG_X))))]\n+  \"avr_have_dimode\"\n+  \"%~call __adddi3_s8\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"adddi3_const_insn\"\n+  [(set (reg:DI ACC_A)\n+        (plus:DI (reg:DI ACC_A)\n+                 (match_operand:DI 0 \"const_double_operand\" \"n\")))]\n+  \"avr_have_dimode\n+   && !s8_operand (operands[0], VOIDmode)\"\n+  {\n+    return avr_out_plus64 (operands[0], NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"plus64\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Subtraction\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_expand \"subdi3\"\n+  [(parallel [(match_operand:DI 0 \"general_operand\" \"\")\n+              (match_operand:DI 1 \"general_operand\" \"\")\n+              (match_operand:DI 2 \"general_operand\" \"\")])]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (DImode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+    emit_move_insn (gen_rtx_REG (DImode, ACC_B), operands[2]);\n+    emit_insn (gen_subdi3_insn ());\n+    emit_move_insn (operands[0], acc_a);\n+    DONE;\n+  })\n+\n+(define_insn \"subdi3_insn\"\n+  [(set (reg:DI ACC_A)\n+        (minus:DI (reg:DI ACC_A)\n+                  (reg:DI ACC_B)))]\n+  \"avr_have_dimode\"\n+  \"%~call __subdi3\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"set_czn\")])\n+\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Negation\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_expand \"negdi2\"\n+  [(parallel [(match_operand:DI 0 \"general_operand\" \"\")\n+              (match_operand:DI 1 \"general_operand\" \"\")])]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (DImode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+    emit_insn (gen_negdi2_insn ());\n+    emit_move_insn (operands[0], acc_a);\n+    DONE;\n+  })\n+\n+(define_insn \"negdi2_insn\"\n+  [(set (reg:DI ACC_A)\n+        (neg:DI (reg:DI ACC_A)))]\n+  \"avr_have_dimode\"\n+  \"%~call __negdi2\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Comparison\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_expand \"conditional_jump\"\n+  [(set (pc)\n+        (if_then_else\n+         (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                          (const_int 0)])\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))]\n+  \"avr_have_dimode\")\n+\n+(define_expand \"cbranchdi4\"\n+  [(parallel [(match_operand:DI 1 \"register_operand\" \"\")\n+              (match_operand:DI 2 \"nonmemory_operand\" \"\")\n+              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                               (const_int 0)])\n+              (label_ref (match_operand 3 \"\" \"\"))])]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (DImode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+\n+    if (s8_operand (operands[2], VOIDmode))\n+      {\n+        emit_move_insn (gen_rtx_REG (QImode, REG_X), operands[2]);\n+        emit_insn (gen_compare_const8_di2 ());\n+      }        \n+    else if (CONST_INT_P (operands[2])\n+             || CONST_DOUBLE_P (operands[2]))\n+      {\n+        emit_insn (gen_compare_const_di2 (operands[2]));\n+      }\n+    else\n+      {\n+        emit_move_insn (gen_rtx_REG (DImode, ACC_B), operands[2]);\n+        emit_insn (gen_compare_di2 ());\n+      }\n+\n+    emit_jump_insn (gen_conditional_jump (operands[0], operands[3]));\n+    DONE;\n+  })\n+\n+(define_insn \"compare_di2\"\n+  [(set (cc0)\n+        (compare (reg:DI ACC_A)\n+                 (reg:DI ACC_B)))]\n+  \"avr_have_dimode\"\n+  \"%~call __cmpdi2\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"compare_const8_di2\"\n+  [(set (cc0)\n+        (compare (reg:DI ACC_A)\n+                 (sign_extend:DI (reg:QI REG_X))))]\n+  \"avr_have_dimode\"\n+  \"%~call __cmpdi2_s8\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"compare_const_di2\"\n+  [(set (cc0)\n+        (compare (reg:DI ACC_A)\n+                 (match_operand:DI 0 \"const_double_operand\" \"n\")))\n+   (clobber (match_scratch:QI 1 \"=&d\"))]\n+  \"avr_have_dimode\n+   && !s8_operand (operands[0], VOIDmode)\"\n+  {\n+    return avr_out_compare64 (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"compare64\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Shifts and Rotate\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_code_iterator di_shifts\n+  [ashift ashiftrt lshiftrt rotate])\n+\n+;; Shift functions from libgcc are called without defining these insns,\n+;; but with them we can describe their reduced register footprint.\n+\n+;; \"ashldi3\"\n+;; \"ashrdi3\"\n+;; \"lshrdi3\"\n+;; \"rotldi3\"\n+(define_expand \"<code_stdname>di3\"\n+  [(parallel [(match_operand:DI 0 \"general_operand\" \"\")\n+              (di_shifts:DI (match_operand:DI 1 \"general_operand\" \"\")\n+                            (match_operand:QI 2 \"general_operand\" \"\"))])]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (DImode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+    emit_move_insn (gen_rtx_REG (QImode, 16), operands[2]);\n+    emit_insn (gen_<code_stdname>di3_insn ());\n+    emit_move_insn (operands[0], acc_a);\n+    DONE;\n+  })\n+\n+(define_insn \"<code_stdname>di3_insn\"\n+  [(set (reg:DI ACC_A)\n+        (di_shifts:DI (reg:DI ACC_A)\n+                      (reg:QI 16)))]\n+  \"avr_have_dimode\"\n+  \"%~call __<code_stdname>di3\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"clobber\")])"}, {"sha": "09f82718ae87a234b9d881791086d4e7cd55d282", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -56,6 +56,7 @@ extern const char *avr_out_tstsi (rtx, rtx*, int*);\n extern const char *avr_out_tsthi (rtx, rtx*, int*);\n extern const char *avr_out_tstpsi (rtx, rtx*, int*);\n extern const char *avr_out_compare (rtx, rtx*, int*);\n+extern const char *avr_out_compare64 (rtx, rtx*, int*);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);\n extern const char *avr_out_movpsi (rtx, rtx*, int*);\n \n@@ -89,6 +90,7 @@ extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n extern const char* avr_out_bitop (rtx, rtx*, int*);\n extern const char* avr_out_plus (rtx*, int*, int*);\n extern const char* avr_out_plus_noclobber (rtx*, int*, int*);\n+extern const char* avr_out_plus64 (rtx, int*);\n extern const char* avr_out_addto_sp (rtx*, int*);\n extern const char* avr_out_xload (rtx, rtx*, int*);\n extern const char* avr_out_movmem (rtx, rtx*, int*);\n@@ -128,6 +130,8 @@ extern bool avr_xload_libgcc_p (enum machine_mode);\n extern void asm_output_float (FILE *file, REAL_VALUE_TYPE n);\n #endif\n \n+extern bool avr_have_dimode;\n+\n /* From avr-log.c */\n \n #define avr_edump (avr_log_set_caller_e (__FUNCTION__))"}, {"sha": "652e41c6ae43acdbfaac488fa939355467c98b21", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -164,6 +164,9 @@ static GTY(()) section *progmem_swtable_section;\n    or to address space __pgm*.  */\n static GTY(()) section *progmem_section[6];\n \n+/* Condition for insns/expanders from avr-dimode.md.  */\n+bool avr_have_dimode = true;\n+\n /* To track if code will use .bss and/or .data.  */\n bool avr_need_clear_bss_p = false;\n bool avr_need_copy_data_p = false;\n@@ -4091,14 +4094,17 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)\n   /* Value (0..0xff) held in clobber register xop[2] or -1 if unknown.  */\n   int clobber_val = -1;\n \n-  gcc_assert (REG_P (xreg)\n-              && CONST_INT_P (xval));\n+  gcc_assert (REG_P (xreg));\n+  gcc_assert ((CONST_INT_P (xval) && n_bytes <= 4)\n+              || (const_double_operand (xval, VOIDmode) && n_bytes == 8));\n   \n   if (plen)\n     *plen = 0;\n \n   /* Comparisons == +/-1 and != +/-1 can be done similar to camparing\n-     against 0 by ORing the bytes.  This is one instruction shorter.  */\n+     against 0 by ORing the bytes.  This is one instruction shorter.\n+     Notice that DImode comparisons are always against reg:DI 18\n+     and therefore don't use this.  */\n \n   if (!test_hard_reg_class (LD_REGS, xreg)\n       && compare_eq_p (insn)\n@@ -4216,6 +4222,20 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)\n }\n \n \n+/* Prepare operands of compare_const_di2 to be used with avr_out_compare.  */\n+\n+const char*\n+avr_out_compare64 (rtx insn, rtx *op, int *plen)\n+{\n+  rtx xop[3];\n+\n+  xop[0] = gen_rtx_REG (DImode, 18);\n+  xop[1] = op[0];\n+  xop[2] = op[1];\n+\n+  return avr_out_compare (insn, xop, plen);\n+}\n+\n /* Output test instruction for HImode.  */\n \n const char*\n@@ -5855,7 +5875,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n   *pcc = (MINUS == code) ? CC_SET_CZN : CC_CLOBBER;\n \n   if (MINUS == code)\n-    xval = gen_int_mode (-UINTVAL (xval), mode);\n+    xval = simplify_unary_operation (NEG, mode, xval, mode);\n \n   op[2] = xop[3];\n \n@@ -6030,6 +6050,25 @@ avr_out_plus_noclobber (rtx *xop, int *plen, int *pcc)\n   return avr_out_plus (op, plen, pcc);\n }\n \n+\n+/* Prepare operands of adddi3_const_insn to be used with avr_out_plus_1.  */\n+\n+const char*\n+avr_out_plus64 (rtx addend, int *plen)\n+{\n+  int cc_dummy;\n+  rtx op[4];\n+\n+  op[0] = gen_rtx_REG (DImode, 18);\n+  op[1] = op[0];\n+  op[2] = addend;\n+  op[3] = NULL_RTX;\n+\n+  avr_out_plus_1 (op, plen, MINUS, &cc_dummy);\n+\n+  return \"\";\n+}\n+\n /* Output bit operation (IOR, AND, XOR) with register XOP[0] and compile\n    time constant XOP[2]:\n \n@@ -6415,6 +6454,7 @@ adjust_insn_length (rtx insn, int len)\n     case ADJUST_LEN_OUT_BITOP: avr_out_bitop (insn, op, &len); break;\n       \n     case ADJUST_LEN_OUT_PLUS: avr_out_plus (op, &len, NULL); break;\n+    case ADJUST_LEN_PLUS64: avr_out_plus64 (op[0], &len); break;\n     case ADJUST_LEN_OUT_PLUS_NOCLOBBER:\n       avr_out_plus_noclobber (op, &len, NULL); break;\n \n@@ -6431,6 +6471,7 @@ adjust_insn_length (rtx insn, int len)\n     case ADJUST_LEN_TSTPSI: avr_out_tstpsi (insn, op, &len); break;\n     case ADJUST_LEN_TSTSI: avr_out_tstsi (insn, op, &len); break;\n     case ADJUST_LEN_COMPARE: avr_out_compare (insn, op, &len); break;\n+    case ADJUST_LEN_COMPARE64: avr_out_compare64 (insn, op, &len); break;\n \n     case ADJUST_LEN_LSHRQI: lshrqi3_out (insn, op, &len); break;\n     case ADJUST_LEN_LSHRHI: lshrhi3_out (insn, op, &len); break;\n@@ -8389,7 +8430,9 @@ avr_compare_pattern (rtx insn)\n   if (pattern\n       && NONJUMP_INSN_P (insn)\n       && SET_DEST (pattern) == cc0_rtx\n-      && GET_CODE (SET_SRC (pattern)) == COMPARE)\n+      && GET_CODE (SET_SRC (pattern)) == COMPARE\n+      && DImode != GET_MODE (XEXP (SET_SRC (pattern), 0))\n+      && DImode != GET_MODE (XEXP (SET_SRC (pattern), 1)))\n     {\n       return pattern;\n     }"}, {"sha": "9222f0b6fffcea43e7cd3367c875ae7982962900", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -142,8 +142,8 @@\n ;; Otherwise do special processing depending on the attribute.\n \n (define_attr \"adjust_len\"\n-  \"out_bitop, out_plus, out_plus_noclobber, addto_sp,\n-   tsthi, tstpsi, tstsi, compare, call,\n+  \"out_bitop, out_plus, out_plus_noclobber, plus64, addto_sp,\n+   tsthi, tstpsi, tstsi, compare, compare64, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n    xload, movmem,\n    ashlqi, ashrqi, lshrqi,\n@@ -218,7 +218,6 @@\n (define_mode_iterator QIHI2 [(QI \"\") (HI \"\")])\n (define_mode_iterator QISI [(QI \"\") (HI \"\") (PSI \"\") (SI \"\")])\n (define_mode_iterator QIDI [(QI \"\") (HI \"\") (PSI \"\") (SI \"\") (DI \"\")])\n-(define_mode_iterator HIDI [(HI \"\") (PSI \"\") (SI \"\") (DI \"\")])\n (define_mode_iterator HISI [(HI \"\") (PSI \"\") (SI \"\")])\n \n ;; All supported move-modes\n@@ -247,6 +246,12 @@\n   [(zero_extend \"r\")\n    (sign_extend \"d\")])\n \n+;; Map RTX code to its standard insn name\n+(define_code_attr code_stdname\n+  [(ashift   \"ashl\")\n+   (ashiftrt \"ashr\")\n+   (lshiftrt \"lshr\")\n+   (rotate   \"rotl\")])\n \n ;;========================================================================\n ;; The following is used by nonlocal_goto and setjmp.\n@@ -3094,23 +3099,21 @@\n   [(set_attr \"length\" \"2,4,4,1,3,5,3,0\")\n    (set_attr \"cc\" \"set_n,set_n,clobber,none,set_n,set_n,clobber,none\")])\n \n-;; Split all rotates of HI,SI and DImode registers where rotation is by\n+;; Split all rotates of HI,SI and PSImode registers where rotation is by\n ;; a whole number of bytes.  The split creates the appropriate moves and\n-;; considers all overlap situations.  DImode is split before reload.\n+;; considers all overlap situations.\n \n ;; HImode does not need scratch.  Use attribute for this constraint.\n-;; Use QI scratch for DI mode as this is often split into byte sized operands.\n \n-(define_mode_attr rotx [(DI \"&r,&r,X\") (SI \"&r,&r,X\") (PSI \"&r,&r,X\") (HI \"X,X,X\")])\n-(define_mode_attr rotsmode [(DI \"QI\") (SI \"HI\") (PSI \"QI\") (HI \"QI\")])\n+(define_mode_attr rotx [(SI \"&r,&r,X\") (PSI \"&r,&r,X\") (HI \"X,X,X\")])\n+(define_mode_attr rotsmode [(SI \"HI\") (PSI \"QI\") (HI \"QI\")])\n \n ;; \"rotlhi3\"\n ;; \"rotlpsi3\"\n ;; \"rotlsi3\"\n-;; \"rotldi3\"\n (define_expand \"rotl<mode>3\"\n-  [(parallel [(set (match_operand:HIDI 0 \"register_operand\" \"\")\n-                   (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"\")\n+  [(parallel [(set (match_operand:HISI 0 \"register_operand\" \"\")\n+                   (rotate:HISI (match_operand:HISI 1 \"register_operand\" \"\")\n                                 (match_operand:VOID 2 \"const_int_operand\" \"\")))\n               (clobber (match_dup 3))])]\n   \"\"\n@@ -3129,9 +3132,8 @@\n         else\n           operands[3] = gen_rtx_SCRATCH (QImode);\n       }\n-    else if (<MODE>mode != DImode\n-             && (offset == 1\n-                 || offset == GET_MODE_BITSIZE (<MODE>mode) -1))\n+    else if (offset == 1\n+             || offset == GET_MODE_BITSIZE (<MODE>mode) -1)\n       {\n         /*; Support rotate left/right by 1  */\n \n@@ -3207,18 +3209,17 @@\n \n ;; \"*rotwhi\"\n ;; \"*rotwsi\"\n-;; \"*rotwdi\"\n (define_insn_and_split \"*rotw<mode>\"\n-  [(set (match_operand:HIDI 0 \"register_operand\" \"=r,r,#&r\")\n-        (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"0,r,r\")\n-                     (match_operand 2 \"const_int_operand\" \"n,n,n\")))\n+  [(set (match_operand:HISI 0 \"register_operand\"             \"=r,r,#&r\")\n+        (rotate:HISI (match_operand:HISI 1 \"register_operand\" \"0,r,r\")\n+                     (match_operand 2 \"const_int_operand\"     \"n,n,n\")))\n    (clobber (match_scratch:<rotsmode> 3 \"=<rotx>\"))]\n   \"AVR_HAVE_MOVW\n    && CONST_INT_P (operands[2])\n    && GET_MODE_SIZE (<MODE>mode) % 2 == 0\n    && 0 == INTVAL (operands[2]) % 16\"\n   \"#\"\n-  \"&& (reload_completed || <MODE>mode == DImode)\"\n+  \"&& reload_completed\"\n   [(const_int 0)]\n   {\n     avr_rotate_bytes (operands);\n@@ -3231,19 +3232,18 @@\n ;; \"*rotbhi\"\n ;; \"*rotbpsi\"\n ;; \"*rotbsi\"\n-;; \"*rotbdi\"\n (define_insn_and_split \"*rotb<mode>\"\n-  [(set (match_operand:HIDI 0 \"register_operand\" \"=r,r,#&r\")\n-        (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"0,r,r\")\n-                     (match_operand 2 \"const_int_operand\" \"n,n,n\")))\n+  [(set (match_operand:HISI 0 \"register_operand\"             \"=r,r,#&r\")\n+        (rotate:HISI (match_operand:HISI 1 \"register_operand\" \"0,r,r\")\n+                     (match_operand 2 \"const_int_operand\"     \"n,n,n\")))\n    (clobber (match_scratch:QI 3 \"=<rotx>\"))]\n   \"CONST_INT_P (operands[2])\n    && (8 == INTVAL (operands[2]) % 16\n        || ((!AVR_HAVE_MOVW\n             || GET_MODE_SIZE (<MODE>mode) % 2 != 0)\n            && 0 == INTVAL (operands[2]) % 16))\"\n   \"#\"\n-  \"&& (reload_completed || <MODE>mode == DImode)\"\n+  \"&& reload_completed\"\n   [(const_int 0)]\n   {\n     avr_rotate_bytes (operands);\n@@ -5949,6 +5949,8 @@\n     operands[4] = simplify_gen_subreg (QImode, operands[0], HImode, 1);\n   })\n \n+(include \"avr-dimode.md\")\n+\n (define_insn_and_split \"*extzv.qihi2\"\n   [(set (match_operand:HI 0 \"register_operand\"                      \"=r\")\n         (zero_extend:HI "}, {"sha": "7c7d438ff11b56c0dc066a22957038e7e33babf9", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -1,3 +1,11 @@\n+2012-01-02  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tImplement light-weight DImode support.\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Add _adddi3, _adddi3_s8,\n+\t_subdi3, _cmpdi2, _cmpdi2_s8, _rotldi3.\n+\t* config/avr/lib1funcs.S (__adddi3, __adddi3_s8, __subdi3,\n+\t__cmpdi2, __cmpdi2_s8, __rotldi3): New functions.\n+\n 2011-12-30  Nathan Sidwell  <nathan@acm.org>\n \n \t* libgcov.c (gcov_crc32): Remove global var."}, {"sha": "f7f0865ca1fcec049716f3f57a4d72e04e31a48f", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -1558,6 +1558,71 @@ ENDF __divdi3_moddi3\n \n #endif /* L_divdi3 */\n \n+.section .text.libgcc, \"ax\", @progbits\n+\n+#define TT __tmp_reg__\n+\n+#if defined (L_adddi3)\n+;; (set (reg:DI 18)\n+;;      (plus:DI (reg:DI 18)\n+;;               (reg:DI 10)))\n+DEFUN __adddi3\n+    ADD A0,B0  $  adc A1,B1  $  adc A2,B2  $  adc A3,B3\n+    adc A4,B4  $  adc A5,B5  $  adc A6,B6  $  adc A7,B7\n+    ret\n+ENDF __adddi3\n+#endif /* L_adddi3 */\n+\n+#if defined (L_adddi3_s8)\n+;; (set (reg:DI 18)\n+;;      (plus:DI (reg:DI 18)\n+;;               (sign_extend:SI (reg:QI 26))))\n+DEFUN __adddi3_s8\n+    clr     TT\n+    sbrc    r26, 7\n+    com     TT\n+    ADD A0,r26 $  adc A1,TT  $  adc A2,TT  $  adc A3,TT\n+    adc A4,TT  $  adc A5,TT  $  adc A6,TT  $  adc A7,TT\n+    ret\n+ENDF __adddi3_s8\n+#endif /* L_adddi3_s8 */\n+\n+#if defined (L_subdi3)\n+;; (set (reg:DI 18)\n+;;      (minus:DI (reg:DI 18)\n+;;                (reg:DI 10)))\n+DEFUN __subdi3\n+    SUB A0,B0  $  sbc A1,B1  $  sbc A2,B2  $  sbc A3,B3\n+    sbc A4,B4  $  sbc A5,B5  $  sbc A6,B6  $  sbc A7,B7\n+    ret\n+ENDF __subdi3\n+#endif /* L_subdi3 */\n+\n+#if defined (L_cmpdi2)\n+;; (set (cc0)\n+;;      (compare (reg:DI 18)\n+;;               (reg:DI 10)))\n+DEFUN __cmpdi2\n+    CP  A0,B0  $  cpc A1,B1  $  cpc A2,B2  $  cpc A3,B3\n+    cpc A4,B4  $  cpc A5,B5  $  cpc A6,B6  $  cpc A7,B7\n+    ret\n+ENDF __cmpdi2\n+#endif /* L_cmpdi2 */\n+\n+#if defined (L_cmpdi2_s8)\n+;; (set (cc0)\n+;;      (compare (reg:DI 18)\n+;;               (sign_extend:SI (reg:QI 26))))\n+DEFUN __cmpdi2_s8\n+    clr     TT\n+    sbrc    r26, 7\n+    com     TT\n+    CP  A0,r26 $  cpc A1,TT  $  cpc A2,TT  $  cpc A3,TT\n+    cpc A4,TT  $  cpc A5,TT  $  cpc A6,TT  $  cpc A7,TT\n+    ret\n+ENDF __cmpdi2_s8\n+#endif /* L_cmpdi2_s8 */\n+\n #if defined (L_negdi2)\n DEFUN __negdi2\n \n@@ -1571,6 +1636,8 @@ DEFUN __negdi2\n ENDF __negdi2\n #endif /* L_negdi2 */\n \n+#undef TT\n+\n #undef C7\n #undef C6\n #undef C5\n@@ -2470,6 +2537,29 @@ DEFUN __ashldi3\n ENDF __ashldi3\n #endif /* defined (L_ashldi3) */\n \n+#if defined (L_rotldi3)\n+;; Shift left\n+;; r25:r18 = rotl64 (r25:r18, r17:r16)\n+DEFUN __rotldi3\n+    push r16\n+    andi r16, 63\n+    breq 2f\n+1:  lsl  r18\n+    rol  r19\n+    rol  r20\n+    rol  r21\n+    rol  r22\n+    rol  r23\n+    rol  r24\n+    rol  r25\n+    adc  r18, __zero_reg__\n+    dec  r16\n+    brne 1b\n+2:  pop  r16\n+    ret\n+ENDF __rotldi3\n+#endif /* defined (L_rotldi3) */\n+\n \f\n .section .text.libgcc.fmul, \"ax\", @progbits\n "}, {"sha": "656816032c448b1530fa28235c2369d4fc59061c", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c57e5473e707a0def3df29d89336b96abca9388/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c57e5473e707a0def3df29d89336b96abca9388/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=8c57e5473e707a0def3df29d89336b96abca9388", "patch": "@@ -49,9 +49,9 @@ LIB1ASMFUNCS = \\\n \t_popcountqi2 \\\n \t_bswapsi2 \\\n \t_bswapdi2 \\\n-\t_ashldi3 \\\n-\t_ashrdi3 \\\n-\t_lshrdi3 \\\n+\t_ashldi3 _ashrdi3 _lshrdi3 _rotldi3 \\\n+\t_adddi3 _adddi3_s8 _subdi3 \\\n+\t_cmpdi2 _cmpdi2_s8 \\\n \t_fmul _fmuls _fmulsu\n \n LIB2FUNCS_EXCLUDE = \\"}]}