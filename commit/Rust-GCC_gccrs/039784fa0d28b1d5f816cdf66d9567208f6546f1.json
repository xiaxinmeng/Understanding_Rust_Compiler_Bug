{"sha": "039784fa0d28b1d5f816cdf66d9567208f6546f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM5Nzg0ZmEwZDI4YjFkNWY4MTZjZGY2NmQ5NTY3MjA4ZjY1NDZmMQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-10-02T17:42:44Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-10-02T17:42:44Z"}, "message": "parse.y: Use gcc_assert and gcc_unreachable instead of abort.\n\n2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n\n        * parse.y: Use gcc_assert and gcc_unreachable instead of abort.\n        * tree1.c: Likewise.\n        * treetree.c: Likewise.\n\nFrom-SVN: r88429", "tree": {"sha": "1cfa5994abed8c5eec4b3ca5e3130c1a77c3cc53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cfa5994abed8c5eec4b3ca5e3130c1a77c3cc53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/039784fa0d28b1d5f816cdf66d9567208f6546f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039784fa0d28b1d5f816cdf66d9567208f6546f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039784fa0d28b1d5f816cdf66d9567208f6546f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039784fa0d28b1d5f816cdf66d9567208f6546f1/comments", "author": null, "committer": null, "parents": [{"sha": "7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b"}], "stats": {"total": 164, "additions": 72, "deletions": 92}, "files": [{"sha": "21837cd488239924b37ef0db53eeffc429858187", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=039784fa0d28b1d5f816cdf66d9567208f6546f1", "patch": "@@ -1,3 +1,9 @@\n+2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* parse.y: Use gcc_assert and gcc_unreachable instead of abort.\n+\t* tree1.c: Likewise.\n+\t* treetree.c: Likewise.\n+\n 2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* lex.l: Remove random whitespace."}, {"sha": "8a1db64954f21861fbe3df6c60bd5029715304b6", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=039784fa0d28b1d5f816cdf66d9567208f6546f1", "patch": "@@ -197,8 +197,7 @@ storage typename NAME init_opt SEMICOLON {\n \n   if (VAR_INIT (prod))\n     {\n-      if (! ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code)\n-        abort ();\n+      gcc_assert (((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code);\n     if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n       {\n         fprintf (stderr, \"%s:%i:%i: External reference variables may not have initial value\\n\",\n@@ -217,8 +216,7 @@ storage typename NAME init_opt SEMICOLON {\n      VAR_INIT (prod) ?\n      ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code : NULL,\n      tok->tp.tok.location);\n-  if (!prod->tp.pro.code) \n-    abort ();\n+  gcc_assert (prod->tp.pro.code);\n }\n ;\n \n@@ -287,24 +285,23 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   type = EXPRESSION_TYPE (prod);\n   /* Create a parameter list in a non-front end specific format.  */\n   for (first_parms = NULL, last_parms = NULL, this_parm = PARAMETERS (prod);\n        this_parm;\n        this_parm = this_parm->tp.pro.next)\n     {\n-      if (this_parm->category != production_category)\n-        abort ();\n+      gcc_assert (this_parm->category == production_category);\n+\n       this_parm_var = VARIABLE (this_parm);\n-      if (!this_parm_var)\n-        abort ();\n-      if (this_parm_var->category != production_category)\n-        abort ();\n+\n+      gcc_assert (this_parm_var);\n+      gcc_assert (this_parm_var->category == production_category);\n+\n       this_parms = my_malloc (sizeof (struct prod_token_parm_item));\n-      if (!this_parm_var->tp.pro.main_token)\n-        abort ();\n+      gcc_assert (this_parm_var->tp.pro.main_token);\n \n       this_parms->tp.par.variable_name =\n \tthis_parm_var->tp.pro.main_token->tp.tok.chars;\n@@ -353,22 +350,21 @@ NAME LEFT_BRACE {\n       errorcount++;\n       YYERROR;\n     }\n-  if (!proto->tp.pro.code)\n-    abort ();\n-  tree_code_create_function_initial\n-    (proto->tp.pro.code, tok->tp.tok.location,\n-     FIRST_PARMS (current_function));\n+  gcc_assert (proto->tp.pro.code);\n \n+  tree_code_create_function_initial (proto->tp.pro.code, tok->tp.tok.location,\n+                                     FIRST_PARMS (current_function));\n+\n+#ifdef ENABLE_CHECKING\n   /* Check all the parameters have code.  */\n   for (this_parm = PARAMETERS (proto);\n        this_parm;\n        this_parm = this_parm->tp.pro.next)\n     {\n-      if (! (struct prod_token_parm_item*)VARIABLE (this_parm))\n-        abort ();\n-      if (! (( (struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code))\n-        abort ();\n+      gcc_assert ((struct prod_token_parm_item*)VARIABLE (this_parm));\n+      gcc_assert ((( (struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code));\n     }\n+#endif\n }\n variable_defs_opt statements_opt RIGHT_BRACE {\n   struct prod_token_parm_item* tok;\n@@ -555,12 +551,12 @@ tl_RETURN expression_opt {\n         /* Check same type.  */\n         if (check_type_match (NUMERIC_TYPE (type_prod), $2))\n           {\n-            if (!type_prod->tp.pro.code)\n-              abort ();\n-            if (!exp->tp.pro.code)\n-              abort ();\n+            gcc_assert (type_prod->tp.pro.code);\n+            gcc_assert (exp->tp.pro.code);\n+\n             /* Generate the code. */\n-            tree_code_generate_return (type_prod->tp.pro.code, exp->tp.pro.code);\n+            tree_code_generate_return (type_prod->tp.pro.code,\n+                                       exp->tp.pro.code);\n           }\n       }\n }\n@@ -573,8 +569,7 @@ expression_opt:\n |expression {\n   struct prod_token_parm_item *exp;\n   exp = $1;\n-  if (!exp->tp.pro.code)\n-    abort ();\n+  gcc_assert (exp->tp.pro.code);\n   \n   $$ = $1;\n }\n@@ -680,20 +675,19 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n   for (exp_proto = PARAMETERS (proto), exp = PARAMETERS (prod);\n        exp_proto;\n        exp = exp->tp.pro.next, exp_proto = exp_proto->tp.pro.next)\n-  {\n-    if (!exp)\n-      abort ();\n-    if (!exp_proto)\n-      abort ();\n-    if (!exp->tp.pro.code)\n-      abort ();\n-    var = VARIABLE (exp_proto);\n-    if (!var)\n-      abort ();\n-    if (!var->tp.pro.code)\n-      abort ();\n-    parms = tree_code_add_parameter (parms, var->tp.pro.code, exp->tp.pro.code);\n-  }\n+    {\n+      gcc_assert (exp);\n+      gcc_assert (exp_proto);\n+      gcc_assert (exp->tp.pro.code);\n+\n+      var = VARIABLE (exp_proto);\n+\n+      gcc_assert (var);\n+      gcc_assert (var->tp.pro.code);\n+\n+      parms = tree_code_add_parameter (parms, var->tp.pro.code,\n+                                       exp->tp.pro.code);\n+    }\n   type = tree_code_get_type (NUMERIC_TYPE (prod));\n   prod->tp.pro.code = tree_code_get_expression (EXP_FUNCTION_INVOCATION, type,\n                                                 proto->tp.pro.code, parms,\n@@ -826,8 +820,7 @@ reverse_prod_list (struct prod_token_parm_item *old_first)\n \n   while (current) \n     {\n-      if (current->category != production_category)\n-        abort ();\n+      gcc_assert (current->category == production_category);\n       next = current->tp.pro.next;\n       current->tp.pro.next = prev;\n       prev = current;\n@@ -888,18 +881,14 @@ check_type_match (int type_num, struct prod_token_parm_item *exp)\n           return 1;\n           \n         case VOID_TYPE:\n-          abort ();\n-      \n         default: \n-          abort ();\n+          gcc_unreachable ();\n         }\n       break;\n       \n     case VOID_TYPE:\n-      abort ();\n-      \n     default:\n-      abort ();\n+      gcc_unreachable ();\n       \n     }\n }\n@@ -943,8 +932,7 @@ make_plus_expression (struct prod_token_parm_item* tok,\n \n   NUMERIC_TYPE (prod) = type_code;\n   type = tree_code_get_type (type_code);\n-  if (!type)\n-    abort ();\n+  gcc_assert (type);\n   OP1 (prod) = op1;\n   OP2 (prod) = op2;\n       \n@@ -982,7 +970,7 @@ set_storage (struct prod_token_parm_item *prod)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n "}, {"sha": "a734615f0910daa75d22367a63ce090580630936", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=039784fa0d28b1d5f816cdf66d9567208f6546f1", "patch": "@@ -104,9 +104,6 @@ treelang_handle_option (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n \n   switch (code)\n     {\n-    default:\n-      abort();\n-\n     case OPT_v:\n       if (!version_done)\n \t{\n@@ -129,6 +126,10 @@ treelang_handle_option (size_t scode, const char *arg ATTRIBUTE_UNUSED,\n     case OPT_flexer_trace:\n       option_lexer_trace = value;\n       break;\n+\n+    default:\n+      gcc_unreachable ();\n+\n     }\n \n   return 1;\n@@ -294,7 +295,7 @@ sanity_check (struct prod_token_parm_item *item)\n       break;\n       \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }  \n "}, {"sha": "ade0d9d99c795e92076e44ff346a4d7bd7ef87ee", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039784fa0d28b1d5f816cdf66d9567208f6546f1/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=039784fa0d28b1d5f816cdf66d9567208f6546f1", "patch": "@@ -245,7 +245,7 @@ tree_code_get_type (int type_num)\n       return void_type_node;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -330,8 +330,7 @@ tree_code_create_function_prototype (unsigned char* chars,\n   id = get_identifier ((const char*)chars);\n   for (parm = parms; parm; parm = parm->tp.par.next)\n     {\n-      if (parm->category != parameter_category)\n-        abort ();\n+      gcc_assert (parm->category == parameter_category);\n       type_node = tree_code_get_type (parm->type);\n       type_list = tree_cons (NULL_TREE, type_node, type_list);\n     }\n@@ -375,7 +374,7 @@ tree_code_create_function_prototype (unsigned char* chars,\n \n     case AUTOMATIC_STORAGE:\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Process declaration of function defined elsewhere.  */\n@@ -403,8 +402,7 @@ tree_code_create_function_initial (tree prev_saved,\n   struct prod_token_parm_item* parm;\n \n   fn_decl = prev_saved;\n-  if (!fn_decl)\n-    abort ();\n+  gcc_assert (fn_decl);\n \n   /* Output message if not -quiet.  */\n   announce_function (fn_decl);\n@@ -437,10 +435,8 @@ tree_code_create_function_initial (tree prev_saved,\n \n       /* Some languages have different nominal and real types.  */\n       DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n-      if (!DECL_ARG_TYPE (parm_decl))\n-        abort ();\n-      if (!fn_decl)\n-        abort ();\n+      gcc_assert (DECL_ARG_TYPE (parm_decl));\n+      gcc_assert (fn_decl);\n       DECL_CONTEXT (parm_decl) = fn_decl;\n       DECL_SOURCE_LOCATION (parm_decl) = loc;\n       parm_list = chainon (parm_decl, parm_list);\n@@ -458,12 +454,10 @@ tree_code_create_function_initial (tree prev_saved,\n        param_decl = TREE_CHAIN (param_decl),\n          this_parm = this_parm->tp.par.next)\n     {\n-      if (!this_parm)\n-        abort (); /* Too few.  */\n+      gcc_assert (this_parm); /* Too few.  */\n       *this_parm->tp.par.where_to_put_var_tree = param_decl;\n     }\n-  if (this_parm)\n-    abort (); /* Too many.  */\n+  gcc_assert (!this_parm); /* Too many.  */\n \n   /* Create a new level at the start of the function.  */\n \n@@ -541,8 +535,7 @@ tree_code_create_variable (unsigned int storage_class,\n   var_type = tree_code_get_type (expression_type);\n \n   /* 2. Build the name.  */\n-  if (chars[length] != 0)\n-    abort (); /* Should be null terminated.  */\n+  gcc_assert (chars[length] == 0); /* Should be null terminated.  */\n \n   var_id = get_identifier ((const char*)chars);\n \n@@ -555,8 +548,7 @@ tree_code_create_variable (unsigned int storage_class,\n   else\n     DECL_INITIAL (var_decl) = NULL_TREE;\n \n-  if (TYPE_SIZE (var_type) == 0)\n-    abort (); /* Did not calculate size.  */\n+  gcc_assert (TYPE_SIZE (var_type) != 0); /* Did not calculate size.  */\n \n   DECL_CONTEXT (var_decl) = current_function_decl;\n \n@@ -586,7 +578,7 @@ tree_code_create_variable (unsigned int storage_class,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* This should really only be set if the variable is used.  */\n@@ -611,13 +603,12 @@ tree_code_generate_return (tree type, tree exp)\n   tree setret;\n   tree param;\n \n+#ifdef ENABLE_CHECKING\n   for (param = DECL_ARGUMENTS (current_function_decl);\n        param;\n        param = TREE_CHAIN (param))\n-    {\n-      if (DECL_CONTEXT (param) != current_function_decl)\n-        abort ();\n-    }\n+    gcc_assert (DECL_CONTEXT (param) == current_function_decl);\n+#endif\n \n   if (exp && TREE_TYPE (TREE_TYPE (current_function_decl)) != void_type_node)\n     {\n@@ -692,12 +683,10 @@ tree_code_get_expression (unsigned int exp_type,\n   switch (exp_type)\n     {\n     case EXP_ASSIGN:\n-      if (!op1 || !op2)\n-        abort ();\n+      gcc_assert (op1 && op2);\n       operator = MODIFY_EXPR;\n       ret1 = fold (build2 (operator, void_type_node, op1,\n                            fold (build1 (CONVERT_EXPR, TREE_TYPE (op1), op2))));\n-\n       break;\n \n     case EXP_PLUS:\n@@ -714,8 +703,7 @@ tree_code_get_expression (unsigned int exp_type,\n \n     /* Expand a binary expression.  Ensure the operands are the right type.  */\n     binary_expression:\n-      if (!op1 || !op2)\n-        abort ();\n+      gcc_assert (op1 && op2);\n       ret1  =  fold (build2 (operator, type,\n                        fold (build1 (CONVERT_EXPR, type, op1)),\n                        fold (build1 (CONVERT_EXPR, type, op2))));\n@@ -725,18 +713,15 @@ tree_code_get_expression (unsigned int exp_type,\n          decl for the variable.  If the TYPE is different than the\n          variable type, convert it.  */\n     case EXP_REFERENCE:\n-      if (!op1)\n-        abort ();\n+      gcc_assert (op1);\n       if (type == TREE_TYPE (op1))\n         ret1 = op1;\n       else\n         ret1 = fold (build1 (CONVERT_EXPR, type, op1));\n       break;\n \n     case EXP_FUNCTION_INVOCATION:\n-      if (!op1 || !op2)\n-        abort ();\n-\n+      gcc_assert (op1 && op2);\n       {\n         tree fun_ptr;\n         fun_ptr = fold (build1 (ADDR_EXPR,\n@@ -746,7 +731,7 @@ tree_code_get_expression (unsigned int exp_type,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return ret1;"}]}