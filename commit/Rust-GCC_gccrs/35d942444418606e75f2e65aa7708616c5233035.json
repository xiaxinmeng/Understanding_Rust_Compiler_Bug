{"sha": "35d942444418606e75f2e65aa7708616c5233035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkOTQyNDQ0NDE4NjA2ZTc1ZjJlNjVhYTc3MDg2MTZjNTIzMzAzNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-15T00:29:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-15T00:29:06Z"}, "message": "runtime: copy runtime package time code from Go 1.7\n    \n    Fix handling of function values for -fgo-c-header to generate FuncVal*,\n    not simply FuncVal.\n    \n    While we're here change runtime.nanotime to use clock_gettime with\n    CLOCK_MONOTONIC, rather than gettimeofday.  This is what the gc library\n    does.  It provides nanosecond precision and a monotonic clock.\n    \n    Reviewed-on: https://go-review.googlesource.com/31232\n\nFrom-SVN: r241197", "tree": {"sha": "156c9d476a537c240533dedcf79341b37bcdf5d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/156c9d476a537c240533dedcf79341b37bcdf5d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35d942444418606e75f2e65aa7708616c5233035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d942444418606e75f2e65aa7708616c5233035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35d942444418606e75f2e65aa7708616c5233035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d942444418606e75f2e65aa7708616c5233035/comments", "author": null, "committer": null, "parents": [{"sha": "2a0b23da0560f4d321e28ae3673cd130ebf0e8f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a0b23da0560f4d321e28ae3673cd130ebf0e8f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a0b23da0560f4d321e28ae3673cd130ebf0e8f8"}], "stats": {"total": 763, "additions": 339, "deletions": 424}, "files": [{"sha": "7d0643c7c4be7d13252e48f4b209019cc56e7e79", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -1,4 +1,4 @@\n-ec3dc927da71d15cac48a13c0fb0c1f94572d0d2\n+880cb0a45590d992880fc6aabc7484e54c817eeb\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d99c834c6e400113d76f40f30c77bdba63142c15", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -5928,7 +5928,7 @@ Struct_type::write_field_to_c_header(std::ostream& os, const std::string& name,\n       break;\n \n     case TYPE_FUNCTION:\n-      os << \"FuncVal\";\n+      os << \"FuncVal*\";\n       break;\n \n     case TYPE_POINTER:"}, {"sha": "9e19ad2d75c79d2f165fb654b4ff459a3be1ead9", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -519,7 +519,6 @@ runtime_files = \\\n \treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n-\ttime.c \\\n \t$(runtime_getncpu_file)\n \n goc2c.$(OBJEXT): runtime/goc2c.c"}, {"sha": "4de7131817f67827ec7058e3a21d84ac51e99a1a", "filename": "libgo/Makefile.in", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -262,8 +262,7 @@ am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \t$(am__objects_2) panic.lo parfor.lo print.lo proc.lo \\\n \truntime.lo signal_unix.lo thread.lo $(am__objects_3) yield.lo \\\n \t$(am__objects_4) go-iface.lo lfstack.lo malloc.lo netpoll.lo \\\n-\trdebug.lo reflect.lo runtime1.lo sigqueue.lo time.lo \\\n-\t$(am__objects_5)\n+\trdebug.lo reflect.lo runtime1.lo sigqueue.lo $(am__objects_5)\n am_libgo_llgo_la_OBJECTS = $(am__objects_6)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -918,7 +917,6 @@ runtime_files = \\\n \treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n-\ttime.c \\\n \t$(runtime_getncpu_file)\n \n noinst_DATA = zstdpkglist.go\n@@ -1636,7 +1634,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/yield.Plo@am__quote@\n \n .c.o:"}, {"sha": "477c6be1ab480d93e19d67a7607faf061182b4dd", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -196,15 +196,15 @@ func getcallersp(argp unsafe.Pointer) uintptr\n // argp used in Defer structs when there is no argp.\n const _NoArgs = ^uintptr(0)\n \n-// //go:linkname time_now time.now\n-// func time_now() (sec int64, nsec int32)\n+//go:linkname time_now time.now\n+func time_now() (sec int64, nsec int32)\n \n-/*\n+// For gccgo, expose this for C callers.\n+//go:linkname unixnanotime runtime.unixnanotime\n func unixnanotime() int64 {\n \tsec, nsec := time_now()\n \treturn sec*1e9 + int64(nsec)\n }\n-*/\n \n // round n up to a multiple of a.  a must be a power of 2.\n func round(n, a uintptr) uintptr {"}, {"sha": "d9a1d59a414d23d32829b63e72def00704677108", "filename": "libgo/go/runtime/time.go", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -0,0 +1,307 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Time-related runtime and pieces of package time.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// Export temporarily for gccgo's C code to call:\n+//go:linkname addtimer runtime.addtimer\n+//go:linkname deltimer runtime.deltimer\n+\n+// Package time knows the layout of this structure.\n+// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.\n+// For GOOS=nacl, package syscall knows the layout of this structure.\n+// If this struct changes, adjust ../syscall/net_nacl.go:/runtimeTimer.\n+type timer struct {\n+\ti int // heap index\n+\n+\t// Timer wakes up at when, and then at when+period, ... (period > 0 only)\n+\t// each time calling f(arg, now) in the timer goroutine, so f must be\n+\t// a well-behaved function and not block.\n+\twhen   int64\n+\tperiod int64\n+\tf      func(interface{}, uintptr)\n+\targ    interface{}\n+\tseq    uintptr\n+}\n+\n+var timers struct {\n+\tlock         mutex\n+\tgp           *g\n+\tcreated      bool\n+\tsleeping     bool\n+\trescheduling bool\n+\twaitnote     note\n+\tt            []*timer\n+}\n+\n+// nacl fake time support - time in nanoseconds since 1970\n+var faketime int64\n+\n+// Package time APIs.\n+// Godoc uses the comments in package time, not these.\n+\n+// time.now is implemented in assembly.\n+\n+// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.\n+//go:linkname timeSleep time.Sleep\n+func timeSleep(ns int64) {\n+\tif ns <= 0 {\n+\t\treturn\n+\t}\n+\n+\tt := new(timer)\n+\tt.when = nanotime() + ns\n+\tt.f = goroutineReady\n+\tt.arg = getg()\n+\tlock(&timers.lock)\n+\taddtimerLocked(t)\n+\tgoparkunlock(&timers.lock, \"sleep\", traceEvGoSleep, 2)\n+}\n+\n+// startTimer adds t to the timer heap.\n+//go:linkname startTimer time.startTimer\n+func startTimer(t *timer) {\n+\tif raceenabled {\n+\t\tracerelease(unsafe.Pointer(t))\n+\t}\n+\taddtimer(t)\n+}\n+\n+// stopTimer removes t from the timer heap if it is there.\n+// It returns true if t was removed, false if t wasn't even there.\n+//go:linkname stopTimer time.stopTimer\n+func stopTimer(t *timer) bool {\n+\treturn deltimer(t)\n+}\n+\n+// Go runtime.\n+\n+// Ready the goroutine arg.\n+func goroutineReady(arg interface{}, seq uintptr) {\n+\tgoready(arg.(*g), 0)\n+}\n+\n+func addtimer(t *timer) {\n+\tlock(&timers.lock)\n+\taddtimerLocked(t)\n+\tunlock(&timers.lock)\n+}\n+\n+// Add a timer to the heap and start or kick the timer proc.\n+// If the new timer is earlier than any of the others.\n+// Timers are locked.\n+func addtimerLocked(t *timer) {\n+\t// when must never be negative; otherwise timerproc will overflow\n+\t// during its delta calculation and never expire other runtime\u00b7timers.\n+\tif t.when < 0 {\n+\t\tt.when = 1<<63 - 1\n+\t}\n+\tt.i = len(timers.t)\n+\ttimers.t = append(timers.t, t)\n+\tsiftupTimer(t.i)\n+\tif t.i == 0 {\n+\t\t// siftup moved to top: new earliest deadline.\n+\t\tif timers.sleeping {\n+\t\t\ttimers.sleeping = false\n+\t\t\tnotewakeup(&timers.waitnote)\n+\t\t}\n+\t\tif timers.rescheduling {\n+\t\t\ttimers.rescheduling = false\n+\t\t\tgoready(timers.gp, 0)\n+\t\t}\n+\t}\n+\tif !timers.created {\n+\t\ttimers.created = true\n+\t\tgo timerproc()\n+\t}\n+}\n+\n+// Delete timer t from the heap.\n+// Do not need to update the timerproc: if it wakes up early, no big deal.\n+func deltimer(t *timer) bool {\n+\t// Dereference t so that any panic happens before the lock is held.\n+\t// Discard result, because t might be moving in the heap.\n+\t_ = t.i\n+\n+\tlock(&timers.lock)\n+\t// t may not be registered anymore and may have\n+\t// a bogus i (typically 0, if generated by Go).\n+\t// Verify it before proceeding.\n+\ti := t.i\n+\tlast := len(timers.t) - 1\n+\tif i < 0 || i > last || timers.t[i] != t {\n+\t\tunlock(&timers.lock)\n+\t\treturn false\n+\t}\n+\tif i != last {\n+\t\ttimers.t[i] = timers.t[last]\n+\t\ttimers.t[i].i = i\n+\t}\n+\ttimers.t[last] = nil\n+\ttimers.t = timers.t[:last]\n+\tif i != last {\n+\t\tsiftupTimer(i)\n+\t\tsiftdownTimer(i)\n+\t}\n+\tunlock(&timers.lock)\n+\treturn true\n+}\n+\n+// Timerproc runs the time-driven events.\n+// It sleeps until the next event in the timers heap.\n+// If addtimer inserts a new earlier event, addtimer1 wakes timerproc early.\n+func timerproc() {\n+\ttimers.gp = getg()\n+\tfor {\n+\t\tlock(&timers.lock)\n+\t\ttimers.sleeping = false\n+\t\tnow := nanotime()\n+\t\tdelta := int64(-1)\n+\t\tfor {\n+\t\t\tif len(timers.t) == 0 {\n+\t\t\t\tdelta = -1\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt := timers.t[0]\n+\t\t\tdelta = t.when - now\n+\t\t\tif delta > 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif t.period > 0 {\n+\t\t\t\t// leave in heap but adjust next time to fire\n+\t\t\t\tt.when += t.period * (1 + -delta/t.period)\n+\t\t\t\tsiftdownTimer(0)\n+\t\t\t} else {\n+\t\t\t\t// remove from heap\n+\t\t\t\tlast := len(timers.t) - 1\n+\t\t\t\tif last > 0 {\n+\t\t\t\t\ttimers.t[0] = timers.t[last]\n+\t\t\t\t\ttimers.t[0].i = 0\n+\t\t\t\t}\n+\t\t\t\ttimers.t[last] = nil\n+\t\t\t\ttimers.t = timers.t[:last]\n+\t\t\t\tif last > 0 {\n+\t\t\t\t\tsiftdownTimer(0)\n+\t\t\t\t}\n+\t\t\t\tt.i = -1 // mark as removed\n+\t\t\t}\n+\t\t\tf := t.f\n+\t\t\targ := t.arg\n+\t\t\tseq := t.seq\n+\t\t\tunlock(&timers.lock)\n+\t\t\tif raceenabled {\n+\t\t\t\traceacquire(unsafe.Pointer(t))\n+\t\t\t}\n+\t\t\tf(arg, seq)\n+\t\t\tlock(&timers.lock)\n+\t\t}\n+\t\tif delta < 0 || faketime > 0 {\n+\t\t\t// No timers left - put goroutine to sleep.\n+\t\t\ttimers.rescheduling = true\n+\t\t\tgoparkunlock(&timers.lock, \"timer goroutine (idle)\", traceEvGoBlock, 1)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// At least one timer pending. Sleep until then.\n+\t\ttimers.sleeping = true\n+\t\tnoteclear(&timers.waitnote)\n+\t\tunlock(&timers.lock)\n+\t\tnotetsleepg(&timers.waitnote, delta)\n+\t}\n+}\n+\n+func timejump() *g {\n+\tif faketime == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tlock(&timers.lock)\n+\tif !timers.created || len(timers.t) == 0 {\n+\t\tunlock(&timers.lock)\n+\t\treturn nil\n+\t}\n+\n+\tvar gp *g\n+\tif faketime < timers.t[0].when {\n+\t\tfaketime = timers.t[0].when\n+\t\tif timers.rescheduling {\n+\t\t\ttimers.rescheduling = false\n+\t\t\tgp = timers.gp\n+\t\t}\n+\t}\n+\tunlock(&timers.lock)\n+\treturn gp\n+}\n+\n+// Heap maintenance algorithms.\n+\n+func siftupTimer(i int) {\n+\tt := timers.t\n+\twhen := t[i].when\n+\ttmp := t[i]\n+\tfor i > 0 {\n+\t\tp := (i - 1) / 4 // parent\n+\t\tif when >= t[p].when {\n+\t\t\tbreak\n+\t\t}\n+\t\tt[i] = t[p]\n+\t\tt[i].i = i\n+\t\tt[p] = tmp\n+\t\tt[p].i = p\n+\t\ti = p\n+\t}\n+}\n+\n+func siftdownTimer(i int) {\n+\tt := timers.t\n+\tn := len(t)\n+\twhen := t[i].when\n+\ttmp := t[i]\n+\tfor {\n+\t\tc := i*4 + 1 // left child\n+\t\tc3 := c + 2  // mid child\n+\t\tif c >= n {\n+\t\t\tbreak\n+\t\t}\n+\t\tw := t[c].when\n+\t\tif c+1 < n && t[c+1].when < w {\n+\t\t\tw = t[c+1].when\n+\t\t\tc++\n+\t\t}\n+\t\tif c3 < n {\n+\t\t\tw3 := t[c3].when\n+\t\t\tif c3+1 < n && t[c3+1].when < w3 {\n+\t\t\t\tw3 = t[c3+1].when\n+\t\t\t\tc3++\n+\t\t\t}\n+\t\t\tif w3 < w {\n+\t\t\t\tw = w3\n+\t\t\t\tc = c3\n+\t\t\t}\n+\t\t}\n+\t\tif w >= when {\n+\t\t\tbreak\n+\t\t}\n+\t\tt[i] = t[c]\n+\t\tt[i].i = i\n+\t\tt[c] = tmp\n+\t\tt[c].i = c\n+\t\ti = c\n+\t}\n+}\n+\n+// Entry points for net, time to call nanotime.\n+\n+//go:linkname net_runtimeNano net.runtimeNano\n+func net_runtimeNano() int64 {\n+\treturn nanotime()\n+}\n+\n+//go:linkname time_runtimeNano time.runtimeNano\n+func time_runtimeNano() int64 {\n+\treturn nanotime()\n+}"}, {"sha": "d221847adac2b6f578e418303ad7d7c29f2a60e7", "filename": "libgo/runtime/go-nanotime.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fgo-nanotime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fgo-nanotime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-nanotime.c?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -14,8 +14,8 @@ int64 runtime_nanotime (void)\n int64\n runtime_nanotime (void)\n {\n-  struct timeval tv;\n+  struct timespec ts;\n \n-  gettimeofday (&tv, NULL);\n-  return (int64) tv.tv_sec * 1000000000 + (int64) tv.tv_usec * 1000;\n+  clock_gettime (CLOCK_MONOTONIC, &ts);\n+  return (int64) ts.tv_sec * 1000000000 + (int64) ts.tv_nsec;\n }"}, {"sha": "e674c885aa274009d1b8136aa11ee4e2b816f87b", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -543,5 +543,4 @@ int32\truntime_setgcpercent(int32);\n \n struct Workbuf;\n void\truntime_proc_scan(struct Workbuf**, void (*)(struct Workbuf**, Obj));\n-void\truntime_time_scan(struct Workbuf**, void (*)(struct Workbuf**, Obj));\n void\truntime_netpoll_scan(struct Workbuf**, void (*)(struct Workbuf**, Obj));"}, {"sha": "0b96696ee4211bc4fb481f7b266102d605e46a18", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -1277,7 +1277,6 @@ markroot(ParFor *desc, uint32 i)\n \t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_allp, sizeof runtime_allp, 0});\n \t\tenqueue1(&wbuf, (Obj){(byte*)&work, sizeof work, 0});\n \t\truntime_proc_scan(&wbuf, enqueue1);\n-\t\truntime_time_scan(&wbuf, enqueue1);\n \t\truntime_netpoll_scan(&wbuf, enqueue1);\n \t\tbreak;\n "}, {"sha": "9467c02bc52caca6ffe84ed8605cf770240146b6", "filename": "libgo/runtime/netpoll.goc", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fnetpoll.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fnetpoll.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll.goc?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -89,11 +89,6 @@ static FuncVal deadlineFn\t= {(void(*)(void))deadline};\n static FuncVal readDeadlineFn\t= {(void(*)(void))readDeadline};\n static FuncVal writeDeadlineFn\t= {(void(*)(void))writeDeadline};\n \n-// runtimeNano returns the current value of the runtime clock in nanoseconds.\n-func runtimeNano() (ns int64) {\n-\tns = runtime_nanotime();\n-}\n-\n func runtime_pollServerInit() {\n \truntime_netpollinit();\n }\n@@ -176,13 +171,13 @@ func runtime_pollSetDeadline(pd *PollDesc, d int64, mode int) {\n \t}\n \tpd->seq++;  // invalidate current timers\n \t// Reset current timers.\n-\tif(pd->rt.fv) {\n+\tif(pd->rt.f) {\n \t\truntime_deltimer(&pd->rt);\n-\t\tpd->rt.fv = nil;\n+\t\tpd->rt.f = nil;\n \t}\n-\tif(pd->wt.fv) {\n+\tif(pd->wt.f) {\n \t\truntime_deltimer(&pd->wt);\n-\t\tpd->wt.fv = nil;\n+\t\tpd->wt.f = nil;\n \t}\n \t// Setup new timers.\n \tif(d != 0 && d <= runtime_nanotime())\n@@ -192,7 +187,7 @@ func runtime_pollSetDeadline(pd *PollDesc, d int64, mode int) {\n \tif(mode == 'w' || mode == 'r'+'w')\n \t\tpd->wd = d;\n \tif(pd->rd > 0 && pd->rd == pd->wd) {\n-\t\tpd->rt.fv = &deadlineFn;\n+\t\tpd->rt.f = &deadlineFn;\n \t\tpd->rt.when = pd->rd;\n \t\t// Copy current seq into the timer arg.\n \t\t// Timer func will check the seq against current descriptor seq,\n@@ -203,15 +198,15 @@ func runtime_pollSetDeadline(pd *PollDesc, d int64, mode int) {\n \t\truntime_addtimer(&pd->rt);\n \t} else {\n \t\tif(pd->rd > 0) {\n-\t\t\tpd->rt.fv = &readDeadlineFn;\n+\t\t\tpd->rt.f = &readDeadlineFn;\n \t\t\tpd->rt.when = pd->rd;\n \t\t\tpd->rt.arg.type = nil; // should be *pollDesc type descriptor.\n \t\t\tpd->rt.arg.data = pd;\n \t\t\tpd->rt.seq = pd->seq;\n \t\t\truntime_addtimer(&pd->rt);\n \t\t}\n \t\tif(pd->wd > 0) {\n-\t\t\tpd->wt.fv = &writeDeadlineFn;\n+\t\t\tpd->wt.f = &writeDeadlineFn;\n \t\t\tpd->wt.when = pd->wd;\n \t\t\tpd->wt.arg.type = nil; // should be *pollDesc type descriptor.\n \t\t\tpd->wt.arg.data = pd;\n@@ -244,13 +239,13 @@ func runtime_pollUnblock(pd *PollDesc) {\n \truntime_atomicstorep(&rg, nil);  // full memory barrier between store to closing and read of rg/wg in netpollunblock\n \trg = netpollunblock(pd, 'r', false);\n \twg = netpollunblock(pd, 'w', false);\n-\tif(pd->rt.fv) {\n+\tif(pd->rt.f) {\n \t\truntime_deltimer(&pd->rt);\n-\t\tpd->rt.fv = nil;\n+\t\tpd->rt.f = nil;\n \t}\n-\tif(pd->wt.fv) {\n+\tif(pd->wt.f) {\n \t\truntime_deltimer(&pd->wt);\n-\t\tpd->wt.fv = nil;\n+\t\tpd->wt.f = nil;\n \t}\n \truntime_unlock(pd);\n \tif(rg)\n@@ -408,17 +403,17 @@ deadlineimpl(Eface arg, uintptr seq, bool read, bool write)\n \t\treturn;\n \t}\n \tif(read) {\n-\t\tif(pd->rd <= 0 || pd->rt.fv == nil)\n+\t\tif(pd->rd <= 0 || pd->rt.f == nil)\n \t\t\truntime_throw(\"deadlineimpl: inconsistent read deadline\");\n \t\tpd->rd = -1;\n-\t\truntime_atomicstorep(&pd->rt.fv, nil);  // full memory barrier between store to rd and load of rg in netpollunblock\n+\t\truntime_atomicstorep(&pd->rt.f, nil);  // full memory barrier between store to rd and load of rg in netpollunblock\n \t\trg = netpollunblock(pd, 'r', false);\n \t}\n \tif(write) {\n-\t\tif(pd->wd <= 0 || (pd->wt.fv == nil && !read))\n+\t\tif(pd->wd <= 0 || (pd->wt.f == nil && !read))\n \t\t\truntime_throw(\"deadlineimpl: inconsistent write deadline\");\n \t\tpd->wd = -1;\n-\t\truntime_atomicstorep(&pd->wt.fv, nil);  // full memory barrier between store to wd and load of wg in netpollunblock\n+\t\truntime_atomicstorep(&pd->wt.f, nil);  // full memory barrier between store to wd and load of wg in netpollunblock\n \t\twg = netpollunblock(pd, 'w', false);\n \t}\n \truntime_unlock(pd);"}, {"sha": "f73d7450441e2476b86331cfc05f43bbcae76a46", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d942444418606e75f2e65aa7708616c5233035/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=35d942444418606e75f2e65aa7708616c5233035", "patch": "@@ -66,8 +66,7 @@ typedef\tstruct\tSigTab\t\tSigTab;\n typedef\tstruct\tmcache\t\tMCache;\n typedef struct\tFixAlloc\tFixAlloc;\n typedef\tstruct\thchan\t\tHchan;\n-typedef\tstruct\tTimers\t\tTimers;\n-typedef\tstruct\tTimer\t\tTimer;\n+typedef\tstruct\ttimer\t\tTimer;\n typedef\tstruct\tgcstats\t\tGCStats;\n typedef\tstruct\tLFNode\t\tLFNode;\n typedef\tstruct\tParFor\t\tParFor;\n@@ -181,36 +180,6 @@ enum {\n };\n #endif\n \n-struct\tTimers\n-{\n-\tLock;\n-\tG\t*timerproc;\n-\tbool\t\tsleeping;\n-\tbool\t\trescheduling;\n-\tNote\twaitnote;\n-\tTimer\t**t;\n-\tint32\tlen;\n-\tint32\tcap;\n-};\n-\n-// Package time knows the layout of this structure.\n-// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.\n-// For GOOS=nacl, package syscall knows the layout of this structure.\n-// If this struct changes, adjust ../syscall/net_nacl.go:/runtimeTimer.\n-struct\tTimer\n-{\n-\tintgo\ti;\t// heap index\n-\n-\t// Timer wakes up at when, and then at when+period, ... (period > 0 only)\n-\t// each time calling f(now, arg) in the timer goroutine, so f must be\n-\t// a well-behaved function and not block.\n-\tint64\twhen;\n-\tint64\tperiod;\n-\tFuncVal\t*fv;\n-\tEface\targ;\n-\tuintptr\tseq;\n-};\n-\n // Lock-free stack node.\n struct LFNode\n {\n@@ -403,7 +372,8 @@ bool\t__go_sigsend(int32 sig);\n int32\truntime_callers(int32, Location*, int32, bool keep_callers);\n int64\truntime_nanotime(void)\t// monotonic time\n   __asm__(GOSYM_PREFIX \"runtime.nanotime\");\n-int64\truntime_unixnanotime(void); // real time, can skip\n+int64\truntime_unixnanotime(void) // real time, can skip\n+  __asm__ (GOSYM_PREFIX \"runtime.unixnanotime\");\n void\truntime_dopanic(int32) __attribute__ ((noreturn));\n void\truntime_startpanic(void);\n void\truntime_freezetheworld(void);\n@@ -422,8 +392,10 @@ int64\truntime_tickspersecond(void)\n      __asm__ (GOSYM_PREFIX \"runtime.tickspersecond\");\n void\truntime_blockevent(int64, int32);\n extern int64 runtime_blockprofilerate;\n-void\truntime_addtimer(Timer*);\n-bool\truntime_deltimer(Timer*);\n+void\truntime_addtimer(Timer*)\n+  __asm__ (GOSYM_PREFIX \"runtime.addtimer\");\n+bool\truntime_deltimer(Timer*)\n+  __asm__ (GOSYM_PREFIX \"runtime.deltimer\");\n G*\truntime_netpoll(bool);\n void\truntime_netpollinit(void);\n int32\truntime_netpollopen(uintptr, PollDesc*);"}, {"sha": "b77ad3333d3ee58b6151a286a88511e5f47d95a7", "filename": "libgo/runtime/time.goc", "status": "removed", "additions": 0, "deletions": 353, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a0b23da0560f4d321e28ae3673cd130ebf0e8f8/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a0b23da0560f4d321e28ae3673cd130ebf0e8f8/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=2a0b23da0560f4d321e28ae3673cd130ebf0e8f8", "patch": "@@ -1,353 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Time-related runtime and pieces of package time.\n-\n-package time\n-\n-#include <sys/time.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-enum {\n-\tdebug = 0,\n-};\n-\n-static Timers timers;\n-static void addtimer(Timer*);\n-static void dumptimers(const char*);\n-\n-// nacl fake time support. \n-int64 runtime_timens;\n-\n-// Package time APIs.\n-// Godoc uses the comments in package time, not these.\n-\n-// time.now is implemented in assembly.\n-\n-// runtimeNano returns the current value of the runtime clock in nanoseconds.\n-func runtimeNano() (ns int64) {\n-\tns = runtime_nanotime();\n-}\n-\n-// Sleep puts the current goroutine to sleep for at least ns nanoseconds.\n-func Sleep(ns int64) {\n-\truntime_tsleep(ns, \"sleep\");\n-}\n-\n-// startTimer adds t to the timer heap.\n-func startTimer(t *Timer) {\n-\truntime_addtimer(t);\n-}\n-\n-// stopTimer removes t from the timer heap if it is there.\n-// It returns true if t was removed, false if t wasn't even there.\n-func stopTimer(t *Timer) (stopped bool) {\n-\tstopped = runtime_deltimer(t);\n-}\n-\n-// C runtime.\n-\n-int64 runtime_unixnanotime(void)\n-{\n-\tstruct time_now_ret r;\n-\n-\tr = now();\n-\treturn r.sec*1000000000 + r.nsec;\n-}\n-\n-static void timerproc(void*);\n-static void siftup(int32);\n-static void siftdown(int32);\n-\n-// Ready the goroutine e.data.\n-static void\n-ready(Eface e, uintptr seq)\n-{\n-\tUSED(seq);\n-\n-\truntime_ready(e.__object);\n-}\n-\n-static FuncVal readyv = {(void(*)(void))ready};\n-\n-// Put the current goroutine to sleep for ns nanoseconds.\n-void\n-runtime_tsleep(int64 ns, const char *reason)\n-{\n-\tG* g;\n-\tTimer t;\n-\n-\tg = runtime_g();\n-\n-\tif(ns <= 0)\n-\t\treturn;\n-\n-\tt.when = runtime_nanotime() + ns;\n-\tt.period = 0;\n-\tt.fv = &readyv;\n-\tt.arg.__object = g;\n-\tt.seq = 0;\n-\truntime_lock(&timers);\n-\taddtimer(&t);\n-\truntime_parkunlock(&timers, reason);\n-}\n-\n-void\n-runtime_addtimer(Timer *t)\n-{\n-\truntime_lock(&timers);\n-\taddtimer(t);\n-\truntime_unlock(&timers);\n-}\n-\n-// Add a timer to the heap and start or kick the timer proc\n-// if the new timer is earlier than any of the others.\n-static void\n-addtimer(Timer *t)\n-{\n-\tint32 n;\n-\tTimer **nt;\n-\n-\t// when must never be negative; otherwise timerproc will overflow\n-\t// during its delta calculation and never expire other timers.\n-\tif(t->when < 0)\n-\t\tt->when = (int64)((1ULL<<63)-1);\n-\n-\tif(timers.len >= timers.cap) {\n-\t\t// Grow slice.\n-\t\tn = 16;\n-\t\tif(n <= timers.cap)\n-\t\t\tn = timers.cap*3 / 2;\n-\t\tnt = runtime_malloc(n*sizeof nt[0]);\n-\t\truntime_memmove(nt, timers.t, timers.len*sizeof nt[0]);\n-\t\truntime_free(timers.t);\n-\t\ttimers.t = nt;\n-\t\ttimers.cap = n;\n-\t}\n-\tt->i = timers.len++;\n-\ttimers.t[t->i] = t;\n-\tsiftup(t->i);\n-\tif(t->i == 0) {\n-\t\t// siftup moved to top: new earliest deadline.\n-\t\tif(timers.sleeping) {\n-\t\t\ttimers.sleeping = false;\n-\t\t\truntime_notewakeup(&timers.waitnote);\n-\t\t}\n-\t\tif(timers.rescheduling) {\n-\t\t\ttimers.rescheduling = false;\n-\t\t\truntime_ready(timers.timerproc);\n-\t\t}\n-\t}\n-\tif(timers.timerproc == nil) {\n-\t\ttimers.timerproc = __go_go(timerproc, nil);\n-\t\ttimers.timerproc->issystem = true;\n-\t}\n-\tif(debug)\n-\t\tdumptimers(\"addtimer\");\n-}\n-\n-// Used to force a dereference before the lock is acquired.\n-static int32 gi;\n-\n-// Delete timer t from the heap.\n-// Do not need to update the timerproc:\n-// if it wakes up early, no big deal.\n-bool\n-runtime_deltimer(Timer *t)\n-{\n-\tint32 i;\n-\n-\t// Dereference t so that any panic happens before the lock is held.\n-\t// Discard result, because t might be moving in the heap.\n-\ti = t->i;\n-\tgi = i;\n-\n-\truntime_lock(&timers);\n-\n-\t// t may not be registered anymore and may have\n-\t// a bogus i (typically 0, if generated by Go).\n-\t// Verify it before proceeding.\n-\ti = t->i;\n-\tif(i < 0 || i >= timers.len || timers.t[i] != t) {\n-\t\truntime_unlock(&timers);\n-\t\treturn false;\n-\t}\n-\n-\ttimers.len--;\n-\tif(i == timers.len) {\n-\t\ttimers.t[i] = nil;\n-\t} else {\n-\t\ttimers.t[i] = timers.t[timers.len];\n-\t\ttimers.t[timers.len] = nil;\n-\t\ttimers.t[i]->i = i;\n-\t\tsiftup(i);\n-\t\tsiftdown(i);\n-\t}\n-\tif(debug)\n-\t\tdumptimers(\"deltimer\");\n-\truntime_unlock(&timers);\n-\treturn true;\n-}\n-\n-// Timerproc runs the time-driven events.\n-// It sleeps until the next event in the timers heap.\n-// If addtimer inserts a new earlier event, addtimer\n-// wakes timerproc early.\n-static void\n-timerproc(void* dummy __attribute__ ((unused)))\n-{\n-\tint64 delta, now;\n-\tTimer *t;\n-\tFuncVal *fv;\n-\tvoid (*f)(Eface, uintptr);\n-\tEface arg;\n-\tuintptr seq;\n-\n-\tfor(;;) {\n-\t\truntime_lock(&timers);\n-\t\ttimers.sleeping = false;\n-\t\tnow = runtime_nanotime();\n-\t\tfor(;;) {\n-\t\t\tif(timers.len == 0) {\n-\t\t\t\tdelta = -1;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tt = timers.t[0];\n-\t\t\tdelta = t->when - now;\n-\t\t\tif(delta > 0)\n-\t\t\t\tbreak;\n-\t\t\tif(t->period > 0) {\n-\t\t\t\t// leave in heap but adjust next time to fire\n-\t\t\t\tt->when += t->period * (1 + -delta/t->period);\n-\t\t\t\tsiftdown(0);\n-\t\t\t} else {\n-\t\t\t\t// remove from heap\n-\t\t\t\ttimers.t[0] = timers.t[--timers.len];\n-\t\t\t\ttimers.t[0]->i = 0;\n-\t\t\t\tsiftdown(0);\n-\t\t\t\tt->i = -1;  // mark as removed\n-\t\t\t}\n-\t\t\tfv = t->fv;\n-\t\t\tf = (void*)t->fv->fn;\n-\t\t\targ = t->arg;\n-\t\t\tseq = t->seq;\n-\t\t\truntime_unlock(&timers);\n-\t\t\t__builtin_call_with_static_chain(f(arg, seq), fv);\n-\n-\t\t\t// clear f and arg to avoid leak while sleeping for next timer\n-\t\t\tf = nil;\n-\t\t\tUSED(f);\n-\t\t\targ.__type_descriptor = nil;\n-\t\t\targ.__object = nil;\n-\t\t\tUSED(&arg);\n-\n-\t\t\truntime_lock(&timers);\n-\t\t}\n-\t\tif(delta < 0) {\n-\t\t\t// No timers left - put goroutine to sleep.\n-\t\t\ttimers.rescheduling = true;\n-\t\t\truntime_g()->isbackground = true;\n-\t\t\truntime_parkunlock(&timers, \"timer goroutine (idle)\");\n-\t\t\truntime_g()->isbackground = false;\n-\t\t\tcontinue;\n-\t\t}\n-\t\t// At least one timer pending.  Sleep until then.\n-\t\ttimers.sleeping = true;\n-\t\truntime_noteclear(&timers.waitnote);\n-\t\truntime_unlock(&timers);\n-\t\truntime_notetsleepg(&timers.waitnote, delta);\n-\t}\n-}\n-\n-// heap maintenance algorithms.\n-\n-static void\n-siftup(int32 i)\n-{\n-\tint32 p;\n-\tint64 when;\n-\tTimer **t, *tmp;\n-\n-\tt = timers.t;\n-\twhen = t[i]->when;\n-\ttmp = t[i];\n-\twhile(i > 0) {\n-\t\tp = (i-1)/4;  // parent\n-\t\tif(when >= t[p]->when)\n-\t\t\tbreak;\n-\t\tt[i] = t[p];\n-\t\tt[i]->i = i;\n-\t\tt[p] = tmp;\n-\t\ttmp->i = p;\n-\t\ti = p;\n-\t}\n-}\n-\n-static void\n-siftdown(int32 i)\n-{\n-\tint32 c, c3, len;\n-\tint64 when, w, w3;\n-\tTimer **t, *tmp;\n-\n-\tt = timers.t;\n-\tlen = timers.len;\n-\twhen = t[i]->when;\n-\ttmp = t[i];\n-\tfor(;;) {\n-\t\tc = i*4 + 1;  // left child\n-\t\tc3 = c + 2;  // mid child\n-\t\tif(c >= len) {\n-\t\t\tbreak;\n-\t\t}\n-\t\tw = t[c]->when;\n-\t\tif(c+1 < len && t[c+1]->when < w) {\n-\t\t\tw = t[c+1]->when;\n-\t\t\tc++;\n-\t\t}\n-\t\tif(c3 < len) {\n-\t\t\tw3 = t[c3]->when;\n-\t\t\tif(c3+1 < len && t[c3+1]->when < w3) {\n-\t\t\t\tw3 = t[c3+1]->when;\n-\t\t\t\tc3++;\n-\t\t\t}\n-\t\t\tif(w3 < w) {\n-\t\t\t\tw = w3;\n-\t\t\t\tc = c3;\n-\t\t\t}\n-\t\t}\n-\t\tif(w >= when)\n-\t\t\tbreak;\n-\t\tt[i] = t[c];\n-\t\tt[i]->i = i;\n-\t\tt[c] = tmp;\n-\t\ttmp->i = c;\n-\t\ti = c;\n-\t}\n-}\n-\n-static void\n-dumptimers(const char *msg)\n-{\n-\tTimer *t;\n-\tint32 i;\n-\n-\truntime_printf(\"timers: %s\\n\", msg);\n-\tfor(i = 0; i < timers.len; i++) {\n-\t\tt = timers.t[i];\n-\t\truntime_printf(\"\\t%d\\t%p:\\ti %d when %D period %D fn %p\\n\",\n-\t\t\t\ti, t, t->i, t->when, t->period, t->fv->fn);\n-\t}\n-\truntime_printf(\"\\n\");\n-}\n-\n-void\n-runtime_time_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj))\n-{\n-\tenqueue1(wbufp, (Obj){(byte*)&timers, sizeof timers, 0});\n-}"}]}