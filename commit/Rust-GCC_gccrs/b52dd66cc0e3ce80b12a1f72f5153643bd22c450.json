{"sha": "b52dd66cc0e3ce80b12a1f72f5153643bd22c450", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyZGQ2NmNjMGUzY2U4MGIxMmExZjcyZjUxNTM2NDNiZDIyYzQ1MA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-10-24T04:13:16Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-10-24T04:13:16Z"}, "message": "builtins.c (fold_builtin_exponent): Evaluate constant arguments at compile-time using MPFR.\n\n\t* builtins.c (fold_builtin_exponent): Evaluate constant arguments\n\tat compile-time using MPFR.  Change parameter VALUE to FUNC,\n\tupdate all callers.\n\t(do_mpfr_arg1): Rename `exact' to `inexact'.  Carefully check\n\tfor overflow and underflow at all times and avoid folding in\n\tthose cases.\n\nFrom-SVN: r117995", "tree": {"sha": "b277cb20d80dff8f9087c7b77f7f811189db6154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b277cb20d80dff8f9087c7b77f7f811189db6154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52dd66cc0e3ce80b12a1f72f5153643bd22c450", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52dd66cc0e3ce80b12a1f72f5153643bd22c450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52dd66cc0e3ce80b12a1f72f5153643bd22c450", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52dd66cc0e3ce80b12a1f72f5153643bd22c450/comments", "author": null, "committer": null, "parents": [{"sha": "247140eaf7243f2ce085a2bebeaf08b4a385fb60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247140eaf7243f2ce085a2bebeaf08b4a385fb60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/247140eaf7243f2ce085a2bebeaf08b4a385fb60"}], "stats": {"total": 100, "additions": 45, "deletions": 55}, "files": [{"sha": "c2a16cbc95782459247f1c37d9dca5106d898024", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52dd66cc0e3ce80b12a1f72f5153643bd22c450/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52dd66cc0e3ce80b12a1f72f5153643bd22c450/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b52dd66cc0e3ce80b12a1f72f5153643bd22c450", "patch": "@@ -1,3 +1,12 @@\n+2006-10-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (fold_builtin_exponent): Evaluate constant arguments\n+\tat compile-time using MPFR.  Change parameter VALUE to FUNC,\n+\tupdate all callers.\n+\t(do_mpfr_arg1): Rename `exact' to `inexact'.  Carefully check\n+\tfor overflow and underflow at all times and avoid folding in\n+\tthose cases.\n+\n 2006-10-24  Ben Elliston  <bje@au.ibm.com>\n \n \t* reload1.c: Formatting fixes."}, {"sha": "c165e34a8ff829989b618c45d534eae1d16bb747", "filename": "gcc/builtins.c", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52dd66cc0e3ce80b12a1f72f5153643bd22c450/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52dd66cc0e3ce80b12a1f72f5153643bd22c450/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b52dd66cc0e3ce80b12a1f72f5153643bd22c450", "patch": "@@ -7893,67 +7893,36 @@ fold_builtin_powi (tree fndecl ATTRIBUTE_UNUSED, tree arglist, tree type)\n }\n \n /* A subroutine of fold_builtin to fold the various exponent\n-   functions.  EXP is the CALL_EXPR of a call to a builtin function.\n-   VALUE is the value which will be raised to a power.  */\n+   functions.  Return NULL_TREE if no simplification can me made.\n+   FUNC is the corresponding MPFR exponent function.  */\n \n static tree\n fold_builtin_exponent (tree fndecl, tree arglist,\n-\t\t       const REAL_VALUE_TYPE *value)\n+\t\t       int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t))\n {\n   if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     {\n       tree type = TREE_TYPE (TREE_TYPE (fndecl));\n-      tree arg = TREE_VALUE (arglist);\n-\n-      /* Optimize exp*(0.0) = 1.0.  */\n-      if (real_zerop (arg))\n-\treturn build_real (type, dconst1);\n-\n-      /* Optimize expN(1.0) = N.  */\n-      if (real_onep (arg))\n-\t{\n-\t  REAL_VALUE_TYPE cst;\n-\n-\t  real_convert (&cst, TYPE_MODE (type), value);\n-\t  return build_real (type, cst);\n-\t}\n-\n-      /* Attempt to evaluate expN(integer) at compile-time.  */\n-      if (flag_unsafe_math_optimizations\n-\t  && TREE_CODE (arg) == REAL_CST\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg))\n-\t{\n-\t  REAL_VALUE_TYPE cint;\n-\t  REAL_VALUE_TYPE c;\n-\t  HOST_WIDE_INT n;\n-\n-\t  c = TREE_REAL_CST (arg);\n-\t  n = real_to_integer (&c);\n-\t  real_from_integer (&cint, VOIDmode, n,\n-\t\t\t     n < 0 ? -1 : 0, 0);\n-\t  if (real_identical (&c, &cint))\n-\t    {\n-\t      REAL_VALUE_TYPE x;\n-\n-\t      real_powi (&x, TYPE_MODE (type), value, n);\n-\t      return build_real (type, x);\n-\t    }\n-\t}\n+      tree arg = TREE_VALUE (arglist), res;\n+      \n+      /* Calculate the result when the argument is a constant.  */\n+      if ((res = do_mpfr_arg1 (arg, type, func)))\n+\treturn res;\n \n       /* Optimize expN(logN(x)) = x.  */\n       if (flag_unsafe_math_optimizations)\n \t{\n \t  const enum built_in_function fcode = builtin_mathfn_code (arg);\n \n-\t  if ((value == &dconste\n+\t  if ((func == mpfr_exp\n \t       && (fcode == BUILT_IN_LOG\n \t\t   || fcode == BUILT_IN_LOGF\n \t\t   || fcode == BUILT_IN_LOGL))\n-\t      || (value == &dconst2\n+\t      || (func == mpfr_exp2\n \t\t  && (fcode == BUILT_IN_LOG2\n \t\t      || fcode == BUILT_IN_LOG2F\n \t\t      || fcode == BUILT_IN_LOG2L))\n-\t      || (value == &dconst10\n+\t      || (func == mpfr_exp10\n \t\t  && (fcode == BUILT_IN_LOG10\n \t\t      || fcode == BUILT_IN_LOG10F\n \t\t      || fcode == BUILT_IN_LOG10L)))\n@@ -9046,14 +9015,14 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n       return fold_builtin_cos (arglist, type, fndecl);\n \n     CASE_FLT_FN (BUILT_IN_EXP):\n-      return fold_builtin_exponent (fndecl, arglist, &dconste);\n+      return fold_builtin_exponent (fndecl, arglist, mpfr_exp);\n \n     CASE_FLT_FN (BUILT_IN_EXP2):\n-      return fold_builtin_exponent (fndecl, arglist, &dconst2);\n+      return fold_builtin_exponent (fndecl, arglist, mpfr_exp2);\n \n     CASE_FLT_FN (BUILT_IN_EXP10):\n     CASE_FLT_FN (BUILT_IN_POW10):\n-      return fold_builtin_exponent (fndecl, arglist, &dconst10);\n+      return fold_builtin_exponent (fndecl, arglist, mpfr_exp10);\n \n     CASE_FLT_FN (BUILT_IN_LOG):\n       return fold_builtin_logarithm (fndecl, arglist, &dconste);\n@@ -11301,22 +11270,34 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t))\n         {\n \t  const enum machine_mode mode = TYPE_MODE (type);\n \t  const int prec = REAL_MODE_FORMAT (mode)->p;\n-\t  int exact;\n+\t  int inexact;\n \t  mpfr_t m;\n \n \t  mpfr_init2 (m, prec);\n \t  mpfr_from_real (m, &r);\n-\t  exact = func (m, m, GMP_RNDN);\n-\n-\t  /* Proceed iff we get a normal number, i.e. not NaN or Inf.\n-\t     If -frounding-math is set, proceed iff the result of\n-\t     calling FUNC was exact, i.e. FUNC returned zero.  */\n-\t  if (mpfr_number_p (m)\n-\t      && (! flag_rounding_math || exact == 0))\n+\t  mpfr_clear_flags();\n+\t  inexact = func (m, m, GMP_RNDN);\n+\n+\t  /* Proceed iff we get a normal number, i.e. not NaN or Inf\n+\t     and no overflow/underflow occurred.  If -frounding-math,\n+\t     proceed iff the result of calling FUNC was exact.  */\n+\t  if (mpfr_number_p (m) && !mpfr_overflow_p() && !mpfr_underflow_p()\n+\t      && (!flag_rounding_math || !inexact))\n \t    {\n \t      real_from_mpfr (&r, m);\n-\t      real_convert (&r, mode, &r);\n-\t      result = build_real (type, r);\n+\t      /* Proceed iff GCC's REAL_VALUE_TYPE can hold the MPFR\n+\t\t value, check for overflow/underflow.  If the\n+\t\t REAL_VALUE_TYPE is zero but the mpft_t is not, then\n+\t\t we underflowed in the conversion.  */\n+\t      if (!real_isnan (&r) && !real_isinf (&r)\n+\t\t  && (r.cl == rvc_zero) == (mpfr_zero_p (m) != 0))\n+\t        {\n+\t\t  REAL_VALUE_TYPE rmode;\n+\t\t  real_convert (&rmode, mode, &r);\n+\t\t  /* Proceed iff the specified mode can hold the value.  */\n+\t\t  if (real_identical (&rmode, &r))\n+\t\t    result = build_real (type, rmode);\n+\t\t}\n \t    }\n \t  mpfr_clear (m);\n \t}"}]}