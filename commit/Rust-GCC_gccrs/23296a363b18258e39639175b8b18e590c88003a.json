{"sha": "23296a363b18258e39639175b8b18e590c88003a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMyOTZhMzYzYjE4MjU4ZTM5NjM5MTc1YjhiMThlNTkwYzg4MDAzYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-05T07:46:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-05T07:46:54Z"}, "message": "alpha.c (alpha_expand_mov, [...]): New functions split out of md file expanders.\n\n        * config/alpha/alpha.c (alpha_expand_mov, alpha_expand_mov_nobwx):\n        New functions split out of md file expanders.\n        * config/alpha/alpha-protos.h: Declare them.\n        * config/alpha/alpha.md (movqi, movhi, movsi, movdi): Use them.\n\nFrom-SVN: r45399", "tree": {"sha": "55b1a620876a17f773e34274fc2a7a1835180ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55b1a620876a17f773e34274fc2a7a1835180ccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23296a363b18258e39639175b8b18e590c88003a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23296a363b18258e39639175b8b18e590c88003a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23296a363b18258e39639175b8b18e590c88003a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23296a363b18258e39639175b8b18e590c88003a/comments", "author": null, "committer": null, "parents": [{"sha": "d9ef6ef7d9afac57587fc170ee49f12a25da315c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9ef6ef7d9afac57587fc170ee49f12a25da315c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9ef6ef7d9afac57587fc170ee49f12a25da315c"}], "stats": {"total": 493, "additions": 197, "deletions": 296}, "files": [{"sha": "742e21efa9947575c9066ff45df607bfc9b1198a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23296a363b18258e39639175b8b18e590c88003a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23296a363b18258e39639175b8b18e590c88003a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23296a363b18258e39639175b8b18e590c88003a", "patch": "@@ -1,3 +1,10 @@\n+2001-09-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_expand_mov, alpha_expand_mov_nobwx):\n+\tNew functions split out of md file expanders.\n+\t* config/alpha/alpha-protos.h: Declare them.\n+\t* config/alpha/alpha.md (movqi, movhi, movsi, movdi): Use them.\n+\n 2001-09-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppmacro.c (funlike_invocation_p): No need to restore context."}, {"sha": "025f3af5e8796517c5e8b1727f8f09859956193b", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23296a363b18258e39639175b8b18e590c88003a/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23296a363b18258e39639175b8b18e590c88003a/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=23296a363b18258e39639175b8b18e590c88003a", "patch": "@@ -87,6 +87,8 @@ extern rtx alpha_emit_set_const PARAMS ((rtx, enum machine_mode,\n \t\t\t\t\tHOST_WIDE_INT, int));\n extern rtx alpha_emit_set_long_const PARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t     HOST_WIDE_INT));\n+extern bool alpha_expand_mov PARAMS ((enum machine_mode, rtx *));\n+extern bool alpha_expand_mov_nobwx PARAMS ((enum machine_mode, rtx *));\n extern void alpha_emit_floatuns PARAMS ((rtx[]));\n extern rtx alpha_emit_conditional_branch PARAMS ((enum rtx_code));\n extern rtx alpha_emit_setcc PARAMS ((enum rtx_code));"}, {"sha": "ca4be61da34a5defb24319a759d8515fb978f060", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23296a363b18258e39639175b8b18e590c88003a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23296a363b18258e39639175b8b18e590c88003a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=23296a363b18258e39639175b8b18e590c88003a", "patch": "@@ -1746,6 +1746,182 @@ alpha_emit_set_long_const (target, c1, c2)\n   return target;\n }\n \n+/* Expand a move instruction; return true if all work is done.\n+   We don't handle non-bwx subword loads here.  */\n+\n+bool\n+alpha_expand_mov (mode, operands)\n+     enum machine_mode mode;\n+     rtx *operands;\n+{\n+  /* If the output is not a register, the input must be.  */\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! reg_or_0_operand (operands[1], mode))\n+    operands[1] = force_reg (mode, operands[1]);\n+\n+  /* Early out for non-constants and valid constants.  */\n+  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], mode))\n+    return false;\n+\n+  /* Split large integers.  */\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      HOST_WIDE_INT i0, i1;\n+      rtx temp;\n+\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  i0 = INTVAL (operands[1]);\n+\t  i1 = -(i0 < 0);\n+\t}\n+      else if (HOST_BITS_PER_WIDE_INT >= 64)\n+\t{\n+\t  i0 = CONST_DOUBLE_LOW (operands[1]);\n+\t  i1 = -(i0 < 0);\n+\t}\n+      else\n+\t{\n+\t  i0 = CONST_DOUBLE_LOW (operands[1]);\n+\t  i1 = CONST_DOUBLE_HIGH (operands[1]);\n+\t}\n+\n+      if (HOST_BITS_PER_WIDE_INT >= 64 || i1 == -(i0 < 0))\n+\ttemp = alpha_emit_set_const (operands[0], mode, i0, 3);\n+\n+      if (!temp && TARGET_BUILD_CONSTANTS)\n+\ttemp = alpha_emit_set_long_const (operands[0], i0, i1);\n+\n+      if (temp)\n+\t{\n+\t  if (rtx_equal_p (operands[0], temp))\n+\t    return true;\n+\t  operands[1] = temp;\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Otherwise we've nothing left but to drop the thing to memory.  */\n+  operands[1] = force_const_mem (DImode, operands[1]);\n+  if (reload_in_progress)\n+    {\n+      emit_move_insn (operands[0], XEXP (operands[1], 0));\n+      operands[1] = copy_rtx (operands[1]);\n+      XEXP (operands[1], 0) = operands[0];\n+    }\n+  else\n+    operands[1] = validize_mem (operands[1]);\n+  return false;\n+}\n+\n+/* Expand a non-bwx QImode or HImode move instruction;\n+   return true if all work is done.  */\n+\n+bool\n+alpha_expand_mov_nobwx (mode, operands)\n+     enum machine_mode mode;\n+     rtx *operands;\n+{\n+  /* If the output is not a register, the input must be.  */\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (mode, operands[1]);\n+\n+  /* Handle four memory cases, unaligned and aligned for either the input\n+     or the output.  The only case where we can be called during reload is\n+     for aligned loads; all other cases require temporaries.  */\n+\n+  if (GET_CODE (operands[1]) == MEM\n+      || (GET_CODE (operands[1]) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (operands[1])) == MEM)\n+      || (reload_in_progress && GET_CODE (operands[1]) == REG\n+\t  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+      || (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n+\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n+    {\n+      if (aligned_memory_operand (operands[1], mode))\n+\t{\n+\t  if (reload_in_progress)\n+\t    {\n+\t      emit_insn ((mode == QImode\n+\t\t\t  ? gen_reload_inqi_help\n+\t\t\t  : gen_reload_inhi_help)\n+\t\t         (operands[0], operands[1],\n+\t\t\t  gen_rtx_REG (SImode, REGNO (operands[0]))));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx aligned_mem, bitnum;\n+\t      rtx scratch = gen_reg_rtx (SImode);\n+\n+\t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\n+\t      emit_insn ((mode == QImode\n+\t\t\t  ? gen_aligned_loadqi\n+\t\t\t  : gen_aligned_loadhi)\n+\t\t\t (operands[0], aligned_mem, bitnum, scratch));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Don't pass these as parameters since that makes the generated\n+\t     code depend on parameter evaluation order which will cause\n+\t     bootstrap failures.  */\n+\n+\t  rtx temp1 = gen_reg_rtx (DImode);\n+\t  rtx temp2 = gen_reg_rtx (DImode);\n+\t  rtx seq = ((mode == QImode\n+\t\t      ? gen_unaligned_loadqi\n+\t\t      : gen_unaligned_loadhi)\n+\t\t     (operands[0], get_unaligned_address (operands[1], 0),\n+\t\t      temp1, temp2));\n+\n+\t  alpha_set_memflags (seq, operands[1]);\n+\t  emit_insn (seq);\n+\t}\n+      return true;\n+    }\n+\n+  if (GET_CODE (operands[0]) == MEM\n+      || (GET_CODE (operands[0]) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (operands[0])) == MEM)\n+      || (reload_in_progress && GET_CODE (operands[0]) == REG\n+\t  && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+      || (reload_in_progress && GET_CODE (operands[0]) == SUBREG\n+\t  && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t  && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n+    {\n+      if (aligned_memory_operand (operands[0], mode))\n+\t{\n+\t  rtx aligned_mem, bitnum;\n+\t  rtx temp1 = gen_reg_rtx (SImode);\n+\t  rtx temp2 = gen_reg_rtx (SImode);\n+\n+\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+\n+\t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n+\t\t\t\t\ttemp1, temp2));\n+\t}\n+      else\n+\t{\n+\t  rtx temp1 = gen_reg_rtx (DImode);\n+\t  rtx temp2 = gen_reg_rtx (DImode);\n+\t  rtx temp3 = gen_reg_rtx (DImode);\n+\t  rtx seq = ((mode == QImode\n+\t\t      ? gen_unaligned_storeqi\n+\t\t      : gen_unaligned_storehi)\n+\t\t     (get_unaligned_address (operands[0], 0),\n+\t\t      operands[1], temp1, temp2, temp3));\n+\n+\t  alpha_set_memflags (seq, operands[0]);\n+\t  emit_insn (seq);\n+\t}\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Generate an unsigned DImode to FP conversion.  This is the same code\n    optabs would emit if we didn't have TFmode patterns.\n "}, {"sha": "87458038c4b687a689ad195b34bc3d9f96b654bf", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 12, "deletions": 296, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23296a363b18258e39639175b8b18e590c88003a/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23296a363b18258e39639175b8b18e590c88003a/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=23296a363b18258e39639175b8b18e590c88003a", "patch": "@@ -4809,19 +4809,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (GET_CODE (operands[0]) == MEM\n-      && ! reg_or_0_operand (operands[1], SImode))\n-    operands[1] = force_reg (SImode, operands[1]);\n-\n-  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], SImode))\n-    ;\n-  else if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      operands[1]\n-\t= alpha_emit_set_const (operands[0], SImode, INTVAL (operands[1]), 3);\n-      if (rtx_equal_p (operands[0], operands[1]))\n-\tDONE;\n-    }\n+  if (alpha_expand_mov (SImode, operands))\n+    DONE;\n })\n \n ;; Split a load of a large constant into the appropriate two-insn\n@@ -4901,68 +4890,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  rtx tem;\n-\n-  if (GET_CODE (operands[0]) == MEM\n-      && ! reg_or_0_operand (operands[1], DImode))\n-    operands[1] = force_reg (DImode, operands[1]);\n-\n-  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], DImode))\n-    ;\n-  else if (GET_CODE (operands[1]) == CONST_INT\n-\t   && (tem = alpha_emit_set_const (operands[0], DImode,\n-\t\t\t\t\t   INTVAL (operands[1]), 3)) != 0)\n-    {\n-      if (rtx_equal_p (tem, operands[0]))\n-\tDONE;\n-      else\n-\toperands[1] = tem;\n-    }\n-  else if (CONSTANT_P (operands[1]))\n-    {\n-      if (TARGET_BUILD_CONSTANTS)\n-\t{\n-\t  HOST_WIDE_INT i0, i1;\n-\n-\t  if (GET_CODE (operands[1]) == CONST_INT)\n-\t    {\n-\t      i0 = INTVAL (operands[1]);\n-\t      i1 = -(i0 < 0);\n-\t    }\n-\t  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t    {\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-\t      i0 = CONST_DOUBLE_LOW (operands[1]);\n-\t      i1 = -(i0 < 0);\n-#else\n-\t      i0 = CONST_DOUBLE_LOW (operands[1]);\n-\t      i1 = CONST_DOUBLE_HIGH (operands[1]);\n-#endif\n-\t    }\n-\t  else\n-\t    abort();\n-\n-          tem = alpha_emit_set_long_const (operands[0], i0, i1);\n-          if (rtx_equal_p (tem, operands[0]))\n-\t    DONE;\n-          else\n-\t    operands[1] = tem;\n-\t}\n-      else\n-\t{\n-\t  operands[1] = force_const_mem (DImode, operands[1]);\n-\t  if (reload_in_progress)\n-\t    {\n-\t      emit_move_insn (operands[0], XEXP (operands[1], 0));\n-\t      operands[1] = copy_rtx (operands[1]);\n-\t      XEXP (operands[1], 0) = operands[0];\n-\t    }\n-\t  else\n-\t    operands[1] = validize_mem (operands[1]);\n-\t}\n-    }\n-  else\n-    abort ();\n+  if (alpha_expand_mov (DImode, operands))\n+    DONE;\n })\n \n ;; Split a load of a large constant into the appropriate two-insn\n@@ -5123,234 +5052,21 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (TARGET_BWX)\n-    {\n-      if (GET_CODE (operands[0]) == MEM\n-\t  && ! reg_or_0_operand (operands[1], QImode))\n-\toperands[1] = force_reg (QImode, operands[1]);\n-\n-      if (GET_CODE (operands[1]) == CONST_INT\n-\t       && ! input_operand (operands[1], QImode))\n-\t{\n-\t  operands[1] = alpha_emit_set_const (operands[0], QImode,\n-\t\t\t\t\t      INTVAL (operands[1]), 3);\n-\n-\t  if (rtx_equal_p (operands[0], operands[1]))\n-\t    DONE;\n-\t}\n-\n-      goto def;\n-    }\n-\n-  /* If the output is not a register, the input must be.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (QImode, operands[1]);\n-\n-  /* Handle four memory cases, unaligned and aligned for either the input\n-     or the output.  The only case where we can be called during reload is\n-     for aligned loads; all other cases require temporaries.  */\n-\n-  if (GET_CODE (operands[1]) == MEM\n-      || (GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == MEM)\n-      || (reload_in_progress && GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-      || (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n-\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n-    {\n-      if (aligned_memory_operand (operands[1], QImode))\n-\t{\n-\t  if (reload_in_progress)\n-\t    {\n-\t      emit_insn (gen_reload_inqi_help\n-\t\t         (operands[0], operands[1],\n-\t\t\t  gen_rtx_REG (SImode, REGNO (operands[0]))));\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx aligned_mem, bitnum;\n-\t      rtx scratch = gen_reg_rtx (SImode);\n-\n-\t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-\n-\t      emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n-\t\t\t\t\t     scratch));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Don't pass these as parameters since that makes the generated\n-\t     code depend on parameter evaluation order which will cause\n-\t     bootstrap failures.  */\n-\n-\t  rtx temp1 = gen_reg_rtx (DImode);\n-\t  rtx temp2 = gen_reg_rtx (DImode);\n-\t  rtx seq\n-\t    = gen_unaligned_loadqi (operands[0],\n-\t\t\t\t    get_unaligned_address (operands[1], 0),\n-\t\t\t\t    temp1, temp2);\n-\n-\t  alpha_set_memflags (seq, operands[1]);\n-\t  emit_insn (seq);\n-\t}\n-\n-      DONE;\n-    }\n-\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   || (GET_CODE (operands[0]) == SUBREG\n-\t       && GET_CODE (SUBREG_REG (operands[0])) == MEM)\n-\t   || (reload_in_progress && GET_CODE (operands[0]) == REG\n-\t       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n-\t   || (reload_in_progress && GET_CODE (operands[0]) == SUBREG\n-\t       && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n-    {\n-      if (aligned_memory_operand (operands[0], QImode))\n-\t{\n-\t  rtx aligned_mem, bitnum;\n-\t  rtx temp1 = gen_reg_rtx (SImode);\n-\t  rtx temp2 = gen_reg_rtx (SImode);\n-\n-\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n-\n-\t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\t\ttemp1, temp2));\n-\t}\n-      else\n-\t{\n-\t  rtx temp1 = gen_reg_rtx (DImode);\n-\t  rtx temp2 = gen_reg_rtx (DImode);\n-\t  rtx temp3 = gen_reg_rtx (DImode);\n-\t  rtx seq\n-\t    = gen_unaligned_storeqi (get_unaligned_address (operands[0], 0),\n-\t\t\t\t     operands[1], temp1, temp2, temp3);\n-\n-\t  alpha_set_memflags (seq, operands[0]);\n-\t  emit_insn (seq);\n-\t}\n-      DONE;\n-    }\n- def:;\n+  if (TARGET_BWX\n+      ? alpha_expand_mov (QImode, operands)\n+      : alpha_expand_mov_nobwx (QImode, operands))\n+    DONE;\n })\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  if (TARGET_BWX)\n-    {\n-      if (GET_CODE (operands[0]) == MEM\n-\t  && ! reg_or_0_operand (operands[1], HImode))\n-\toperands[1] = force_reg (HImode, operands[1]);\n-\n-      if (GET_CODE (operands[1]) == CONST_INT\n-\t       && ! input_operand (operands[1], HImode))\n-\t{\n-\t  operands[1] = alpha_emit_set_const (operands[0], HImode,\n-\t\t\t\t\t      INTVAL (operands[1]), 3);\n-\n-\t  if (rtx_equal_p (operands[0], operands[1]))\n-\t    DONE;\n-\t}\n-\n-      goto def;\n-    }\n-\n-  /* If the output is not a register, the input must be.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (HImode, operands[1]);\n-\n-  /* Handle four memory cases, unaligned and aligned for either the input\n-     or the output.  The only case where we can be called during reload is\n-     for aligned loads; all other cases require temporaries.  */\n-\n-  if (GET_CODE (operands[1]) == MEM\n-      || (GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == MEM)\n-      || (reload_in_progress && GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-      || (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n-\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n-    {\n-      if (aligned_memory_operand (operands[1], HImode))\n-\t{\n-\t  if (reload_in_progress)\n-\t    {\n-\t      emit_insn (gen_reload_inhi_help\n-\t\t         (operands[0], operands[1],\n-\t\t\t  gen_rtx_REG (SImode, REGNO (operands[0]))));\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx aligned_mem, bitnum;\n-\t      rtx scratch = gen_reg_rtx (SImode);\n-\n-\t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-\n-\t      emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n-\t\t\t\t\t     scratch));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Don't pass these as parameters since that makes the generated\n-\t     code depend on parameter evaluation order which will cause\n-\t     bootstrap failures.  */\n-\n-\t  rtx temp1 = gen_reg_rtx (DImode);\n-\t  rtx temp2 = gen_reg_rtx (DImode);\n-\t  rtx seq\n-\t    = gen_unaligned_loadhi (operands[0],\n-\t\t\t\t    get_unaligned_address (operands[1], 0),\n-\t\t\t\t    temp1, temp2);\n-\n-\t  alpha_set_memflags (seq, operands[1]);\n-\t  emit_insn (seq);\n-\t}\n-\n-      DONE;\n-    }\n-\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   || (GET_CODE (operands[0]) == SUBREG\n-\t       && GET_CODE (SUBREG_REG (operands[0])) == MEM)\n-\t   || (reload_in_progress && GET_CODE (operands[0]) == REG\n-\t       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n-\t   || (reload_in_progress && GET_CODE (operands[0]) == SUBREG\n-\t       && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n-    {\n-      if (aligned_memory_operand (operands[0], HImode))\n-\t{\n-\t  rtx aligned_mem, bitnum;\n-\t  rtx temp1 = gen_reg_rtx (SImode);\n-\t  rtx temp2 = gen_reg_rtx (SImode);\n-\n-\t  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n-\n-\t  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\t\ttemp1, temp2));\n-\t}\n-      else\n-\t{\n-\t  rtx temp1 = gen_reg_rtx (DImode);\n-\t  rtx temp2 = gen_reg_rtx (DImode);\n-\t  rtx temp3 = gen_reg_rtx (DImode);\n-\t  rtx seq\n-\t    = gen_unaligned_storehi (get_unaligned_address (operands[0], 0),\n-\t\t\t\t     operands[1], temp1, temp2, temp3);\n-\n-\t  alpha_set_memflags (seq, operands[0]);\n-\t  emit_insn (seq);\n-\t}\n-\n-      DONE;\n-    }\n- def:;\n+  if (TARGET_BWX\n+      ? alpha_expand_mov (HImode, operands)\n+      : alpha_expand_mov_nobwx (HImode, operands))\n+    DONE;\n })\n \n ;; Here are the versions for reload.  Note that in the unaligned cases"}]}