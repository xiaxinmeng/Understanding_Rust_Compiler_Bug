{"sha": "00b28cb030eded609070d66ad864d6ce09261504", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiMjhjYjAzMGVkZWQ2MDkwNzBkNjZhZDg2NGQ2Y2UwOTI2MTUwNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-04-03T11:26:41Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-04-03T11:26:41Z"}, "message": "re PR middle-end/20648 (ICE in cfg_layout_redirect_edge_and_branch_force)\n\n        PR middle-end/20648\n        * bb-reorder.c (duplicate_computed_gotos): Do not unfactor\n        a computed goto if the edge to the computed goto block has\n        incoming abnormal edges.  Clarify how the function works.\n\nFrom-SVN: r97486", "tree": {"sha": "2307aea9266f2b95acc3d81d3a480cbbb28d87c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2307aea9266f2b95acc3d81d3a480cbbb28d87c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00b28cb030eded609070d66ad864d6ce09261504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b28cb030eded609070d66ad864d6ce09261504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b28cb030eded609070d66ad864d6ce09261504", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b28cb030eded609070d66ad864d6ce09261504/comments", "author": null, "committer": null, "parents": [{"sha": "e16acfcd1431d5448b7e958ab72f783e1f0f1263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16acfcd1431d5448b7e958ab72f783e1f0f1263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16acfcd1431d5448b7e958ab72f783e1f0f1263"}], "stats": {"total": 69, "additions": 46, "deletions": 23}, "files": [{"sha": "fad5db2d89ba609589c07478aab123b397706967", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b28cb030eded609070d66ad864d6ce09261504/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b28cb030eded609070d66ad864d6ce09261504/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00b28cb030eded609070d66ad864d6ce09261504", "patch": "@@ -1,3 +1,10 @@\n+2005-04-03  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR middle-end/20648\n+\t* bb-reorder.c (duplicate_computed_gotos): Do not unfactor\n+\ta computed goto if the edge to the computed goto block has\n+\tincoming abnormal edges.  Clarify how the function works.\n+\n 2005-04-03  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* params.c (set_param_value): Use gcc_assert & gcc_unreachable.\n@@ -575,7 +582,7 @@\n \tlast_text_section_name as appropriate.\n \t(function_section): Change test for 'unlikely' to depend on\n \tfirst_function_block_is_cold (moved old test to \n-        current_function_section).\n+\tcurrent_function_section).\n \t(current_function_section): New function.\n \t(assemble_start_function): Move code that frees \n \tunlikely_text_section_name; initialize hot_section_end_label; \n@@ -598,8 +605,8 @@\n \n 2005-03-31  Olivier Hainque  <hainque@adacore.com>\n \n-        * dwarf2out.c (dwarf2out_frame_finish): Honor DWARF2_FRAME_INFO\n-        defined and non-zero.\n+\t* dwarf2out.c (dwarf2out_frame_finish): Honor DWARF2_FRAME_INFO\n+\tdefined and non-zero.\n \n 2005-03-31  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n "}, {"sha": "6925114e133ddc3ed9b24a9bb928f77f4fcde00a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b28cb030eded609070d66ad864d6ce09261504/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b28cb030eded609070d66ad864d6ce09261504/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=00b28cb030eded609070d66ad864d6ce09261504", "patch": "@@ -2013,33 +2013,49 @@ duplicate_computed_gotos (void)\n   max_size = uncond_jump_length * PARAM_VALUE (PARAM_MAX_GOTO_DUPLICATION_INSNS);\n   candidates = BITMAP_ALLOC (NULL);\n \n-  /* Build the reorder chain for the original order of blocks.\n-     Look for a computed jump while we are at it.  */\n+  /* Look for blocks that end in a computed jump, and see if such blocks\n+     are suitable for unfactoring.  If a block is a candidate for unfactoring,\n+     mark it in the candidates.  */\n   FOR_EACH_BB (bb)\n     {\n+      rtx insn;\n+      edge e;\n+      edge_iterator ei;\n+      int size, all_flags;\n+\n+      /* Build the reorder chain for the original order of blocks.  */\n       if (bb->next_bb != EXIT_BLOCK_PTR)\n \tbb->rbi->next = bb->next_bb;\n \n-      /* If the block ends in a computed jump and it is small enough,\n-\t make it a candidate for duplication.  */\n-      if (computed_jump_p (BB_END (bb))\n-\t  && !find_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX))\n-\t{\n-\t  rtx insn;\n-\t  int size = 0;\n+      /* Obviously the block has to end in a computed jump.  */\n+      if (!computed_jump_p (BB_END (bb)))\n+\tcontinue;\n \n-\t  FOR_BB_INSNS (bb, insn)\n-\t    if (INSN_P (insn))\n-\t      {\n-\t\tsize += get_attr_length (insn);\n-\t\tif (size > max_size)\n-\t\t  break;\n-\t      }\n+      /* Only consider blocks that can be duplicated.  */\n+      if (find_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX)\n+\t  || !can_duplicate_block_p (bb))\n+\tcontinue;\n \n-\t  if (size <= max_size\n-\t      && can_duplicate_block_p (bb))\n-\t    bitmap_set_bit (candidates, bb->index);\n-\t}\n+      /* Make sure that the block is small enough.  */\n+      size = 0;\n+      FOR_BB_INSNS (bb, insn)\n+\tif (INSN_P (insn))\n+\t  {\n+\t    size += get_attr_length (insn);\n+\t    if (size > max_size)\n+\t       break;\n+\t  }\n+      if (size > max_size)\n+\tcontinue;\n+\n+      /* Final check: there must not be any incoming abnormal edges.  */\n+      all_flags = 0;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tall_flags |= e->flags;\n+      if (all_flags & EDGE_COMPLEX)\n+\tcontinue;\n+\n+      bitmap_set_bit (candidates, bb->index);\n     }\n \n   /* Nothing to do if there is no computed jump here.  */"}]}