{"sha": "610e39013598f4f3bc66c117c3402c07b517cfa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwZTM5MDEzNTk4ZjRmM2JjNjZjMTE3YzM0MDJjMDdiNTE3Y2ZhMA==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2011-12-24T01:42:35Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2011-12-24T01:42:35Z"}, "message": "libitm: Fix privatization safety during upgrades to serial mode.\n\n\tlibitm/\n\t* beginend.cc (GTM::gtm_thread::restart): Add and handle\n\tfinish_serial_upgrade parameter.\n\t* libitm.h (GTM::gtm_thread::restart): Adapt declaration.\n\t* config/linux/rwlock.cc (GTM::gtm_rwlock::write_lock_generic):\n\tDon't unset reader flag.\n\t(GTM::gtm_rwlock::write_upgrade_finish): New.\n\t* config/posix/rwlock.cc: Same.\n\t* config/linux/rwlock.h (GTM::gtm_rwlock::write_upgrade_finish):\n\tDeclare.\n\t* config/posix/rwlock.h: Same.\n\t* method-serial.cc (GTM::gtm_thread::serialirr_mode): Unset reader\n\tflag after commit or after rollback when restarting.\n\nFrom-SVN: r182675", "tree": {"sha": "fd0ffc4afe2a926dc6676559d466c9ae7fad9c2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd0ffc4afe2a926dc6676559d466c9ae7fad9c2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610e39013598f4f3bc66c117c3402c07b517cfa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610e39013598f4f3bc66c117c3402c07b517cfa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610e39013598f4f3bc66c117c3402c07b517cfa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610e39013598f4f3bc66c117c3402c07b517cfa0/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "799142bf743cb04f3a86df85c69481a3c44c1ad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/799142bf743cb04f3a86df85c69481a3c44c1ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/799142bf743cb04f3a86df85c69481a3c44c1ad9"}], "stats": {"total": 88, "additions": 65, "deletions": 23}, "files": [{"sha": "abdf4fb62d8a226947f21a044fe1e2ac99d34ab3", "filename": "libitm/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -1,3 +1,18 @@\n+2011-12-24  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_thread::restart): Add and handle\n+\tfinish_serial_upgrade parameter.\n+\t* libitm.h (GTM::gtm_thread::restart): Adapt declaration.\n+\t* config/linux/rwlock.cc (GTM::gtm_rwlock::write_lock_generic):\n+\tDon't unset reader flag.\n+\t(GTM::gtm_rwlock::write_upgrade_finish): New.\n+\t* config/posix/rwlock.cc: Same.\n+\t* config/linux/rwlock.h (GTM::gtm_rwlock::write_upgrade_finish):\n+\tDeclare.\n+\t* config/posix/rwlock.h: Same.\n+\t* method-serial.cc (GTM::gtm_thread::serialirr_mode): Unset reader\n+\tflag after commit or after rollback when restarting.\n+\n 2011-12-24  Torvald Riegel  <triegel@redhat.com>\n \n \t* beginend.cc (GTM::gtm_thread::begin_transaction): Add comment."}, {"sha": "17f9d7490d898f4caa0e2c75429fd5eb3ef89914", "filename": "libitm/beginend.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -511,11 +511,19 @@ GTM::gtm_thread::trycommit ()\n }\n \n void ITM_NORETURN\n-GTM::gtm_thread::restart (gtm_restart_reason r)\n+GTM::gtm_thread::restart (gtm_restart_reason r, bool finish_serial_upgrade)\n {\n   // Roll back to outermost transaction. Do not reset transaction state because\n   // we will continue executing this transaction.\n   rollback ();\n+\n+  // If we have to restart while an upgrade of the serial lock is happening,\n+  // we need to finish this here, after rollback (to ensure privatization\n+  // safety despite undo writes) and before deciding about the retry strategy\n+  // (which could switch to/from serial mode).\n+  if (finish_serial_upgrade)\n+    gtm_thread::serial_lock.write_upgrade_finish(this);\n+\n   decide_retry_strategy (r);\n \n   // Run dispatch-specific restart code. Retry until we succeed."}, {"sha": "24e7042ff1002574d323d014323073e8c26dfcd6", "filename": "libitm/config/linux/rwlock.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Flinux%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Flinux%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.cc?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -121,17 +121,13 @@ gtm_rwlock::write_lock_generic (gtm_thread *tx)\n   // readers that might still be active.\n   // We don't need an extra barrier here because the CAS and the xchg\n   // operations have full barrier semantics already.\n-\n-  // If this is an upgrade, we are not a reader anymore. This is only safe to\n-  // do after we have acquired the writer lock.\n   // TODO In the worst case, this requires one wait/wake pair for each\n   // active reader. Reduce this!\n-  if (tx != 0)\n-    tx->shared_state.store (-1, memory_order_relaxed);\n-\n   for (gtm_thread *it = gtm_thread::list_of_threads; it != 0;\n       it = it->next_thread)\n     {\n+      if (it == tx)\n+        continue;\n       // Use a loop here to check reader flags again after waiting.\n       while (it->shared_state.load (memory_order_relaxed)\n           != ~(typeof it->shared_state)0)\n@@ -175,6 +171,18 @@ gtm_rwlock::write_upgrade (gtm_thread *tx)\n }\n \n \n+// Has to be called iff the previous upgrade was successful and after it is\n+// safe for the transaction to not be marked as a reader anymore.\n+\n+void\n+gtm_rwlock::write_upgrade_finish (gtm_thread *tx)\n+{\n+  // We are not a reader anymore.  This is only safe to do after we have\n+  // acquired the writer lock.\n+  tx->shared_state.store (-1, memory_order_release);\n+}\n+\n+\n // Release a RW lock from reading.\n \n void"}, {"sha": "987e58014092ce3976faf6fd81cadc59b21f5469", "filename": "libitm/config/linux/rwlock.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Flinux%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Flinux%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.h?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -57,6 +57,7 @@ class gtm_rwlock\n   void write_unlock ();\n \n   bool write_upgrade (gtm_thread *tx);\n+  void write_upgrade_finish (gtm_thread *tx);\n \n  protected:\n   bool write_lock_generic (gtm_thread *tx);"}, {"sha": "f93baf2e10081b3c0d5a688427e0f67c22bc07c7", "filename": "libitm/config/posix/rwlock.cc", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Fposix%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Fposix%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.cc?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -155,10 +155,6 @@ gtm_rwlock::write_lock_generic (gtm_thread *tx)\n   // path of read_lock()).\n   atomic_thread_fence(memory_order_seq_cst);\n \n-  // If this is an upgrade, we are not a reader anymore.\n-  if (tx != 0)\n-    tx->shared_state.store(-1, memory_order_relaxed);\n-\n   // Count the number of active readers to be able to decrease the number of\n   // wake-ups and wait calls that are necessary.\n   //\n@@ -194,6 +190,8 @@ gtm_rwlock::write_lock_generic (gtm_thread *tx)\n \t  it = it->next_thread)\n \t{\n \t  // Don't count ourself if this is an upgrade.\n+          if (it == tx)\n+            continue;\n \t  if (it->shared_state.load(memory_order_relaxed) != (gtm_word)-1)\n \t    readers++;\n \t}\n@@ -231,6 +229,18 @@ gtm_rwlock::write_upgrade (gtm_thread *tx)\n }\n \n \n+// Has to be called iff the previous upgrade was successful and after it is\n+// safe for the transaction to not be marked as a reader anymore.\n+\n+void\n+gtm_rwlock::write_upgrade_finish (gtm_thread *tx)\n+{\n+  // We are not a reader anymore.  This is only safe to do after we have\n+  // acquired the writer lock.\n+  tx->shared_state.store (-1, memory_order_release);\n+}\n+\n+\n // Release a RW lock from reading.\n \n void"}, {"sha": "a1a6042e562dd24ecb6d58bc6164cc8f4095d25d", "filename": "libitm/config/posix/rwlock.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Fposix%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fconfig%2Fposix%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.h?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -72,6 +72,7 @@ class gtm_rwlock\n   void write_unlock ();\n \n   bool write_upgrade (gtm_thread *tx);\n+  void write_upgrade_finish (gtm_thread *tx);\n \n  protected:\n   bool write_lock_generic (gtm_thread *tx);"}, {"sha": "b53792a378105b4527801eecd4ee65b857863b5d", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -231,7 +231,8 @@ struct gtm_thread\n   // In beginend.cc\n   void rollback (gtm_transaction_cp *cp = 0, bool aborting = false);\n   bool trycommit ();\n-  void restart (gtm_restart_reason) ITM_NORETURN;\n+  void restart (gtm_restart_reason, bool finish_serial_upgrade = false)\n+        ITM_NORETURN;\n \n   gtm_thread();\n   ~gtm_thread();"}, {"sha": "bf7982650fff0eb4ebb69c24f189b14d14ab08a8", "filename": "libitm/method-serial.cc", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fmethod-serial.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610e39013598f4f3bc66c117c3402c07b517cfa0/libitm%2Fmethod-serial.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-serial.cc?ref=610e39013598f4f3bc66c117c3402c07b517cfa0", "patch": "@@ -239,7 +239,6 @@ void\n GTM::gtm_thread::serialirr_mode ()\n {\n   struct abi_dispatch *disp = abi_disp ();\n-  bool need_restart = true;\n \n   if (this->state & STATE_SERIAL)\n     {\n@@ -254,7 +253,6 @@ GTM::gtm_thread::serialirr_mode ()\n       bool ok = disp->trycommit (priv_time);\n       // Given that we're already serial, the trycommit better work.\n       assert (ok);\n-      need_restart = false;\n     }\n   else if (serial_lock.write_upgrade (this))\n     {\n@@ -263,18 +261,18 @@ GTM::gtm_thread::serialirr_mode ()\n       // would do for an outermost commit.\n       // We have successfully upgraded to serial mode, so we don't need to\n       // ensure privatization safety for other transactions here.\n+      // However, we are still a reader (wrt. privatization safety) until we\n+      // have either committed or restarted, so finish the upgrade after that.\n       gtm_word priv_time = 0;\n-      if (disp->trycommit (priv_time))\n-\tneed_restart = false;\n+      if (!disp->trycommit (priv_time))\n+        restart (RESTART_SERIAL_IRR, true);\n+      gtm_thread::serial_lock.write_upgrade_finish(this);\n     }\n-\n-  if (need_restart)\n-    restart (RESTART_SERIAL_IRR);\n   else\n-    {\n-      this->state |= (STATE_SERIAL | STATE_IRREVOCABLE);\n-      set_abi_disp (dispatch_serialirr ());\n-    }\n+    restart (RESTART_SERIAL_IRR, false);\n+\n+  this->state |= (STATE_SERIAL | STATE_IRREVOCABLE);\n+  set_abi_disp (dispatch_serialirr ());\n }\n \n void ITM_REGPARM"}]}