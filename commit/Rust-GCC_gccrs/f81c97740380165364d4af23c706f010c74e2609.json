{"sha": "f81c97740380165364d4af23c706f010c74e2609", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgxYzk3NzQwMzgwMTY1MzY0ZDRhZjIzYzcwNmYwMTBjNzRlMjYwOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-11-01T00:40:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-11-01T00:40:33Z"}, "message": "Emit SEH unwind info.\n\n\t* config/i386/cygming.h (TARGET_SEH): New.\n\t(MAX_STACK_ALIGNMENT): New.  Disable alignment for SEH.\n\t(TARGET_ASM_UNWIND_EMIT, TARGET_ASM_UNWIND_EMIT_BEFORE_INSN,\n\tTARGET_ASM_FUNCTION_END_PROLOGUE, SUBTARGET_ASM_UNWIND_INIT): New.\n\t(TARGET_OS_CPP_BUILTINS): Define __SEH__ as needed.\n\t(ASM_DECLARE_FUNCTION_NAME): Use i386_pe_start_function.\n\t(ASM_DECLARE_FUNCTION_SIZE): New.\n\t* config/i386/i386-protos.h: Update.\n\t* config/i386/i386.c (ix86_option_override_internal): Enable\n\tflag_unwind_tables with flag_asynchronous_unwind_tables immediately;\n\trestrict -mpreferred-stack-boundary for SEH; enable flag_fentry.\n\t(ix86_asm_output_function_label): Use SUBTARGET_ASM_UNWIND_INIT.\n\t(ix86_compute_frame_layout): For SEH, disable\n\tuse_fast_prologue_epilogue, move frame pointer to the end of\n\tthe frame.  Initialize hfp_save_offset.\n\t(ix86_expand_prologue): Honor hfp_save_offset.  Emit blockage\n\tat end of prologue for SEH.\n\t(ix86_expand_epilogue): For SEH, use pops, emit a nop if needed,\n\temit blockage at beginning of epilogue.\n\t(ix86_expand_binary_operator): After reload, emit LEA if needed.\n\t(ix86_output_call_insn): New.\n\t* config/i386/i386.h (TARGET_SEH): New.\n\t(struct machine_function): Add member seh.\n\t* config/i386/i386.md (all call patterns): Use ix86_output_call_insn.\n\t* config/i386/winnt.c (struct seh_frame_state): New.\n\t(i386_pe_seh_init, i386_pe_seh_end_prologue, i386_pe_seh_fini,\n\tseh_emit_push, seh_emit_save, seh_emit_stackalloc, seh_cfa_adjust_cfa,\n\tseh_cfa_offset, seh_frame_related_expr, i386_pe_seh_unwind_emit,\n\ti386_pe_start_function, i386_pe_end_function): New.\n\n\t* dwarf2out.c (dwarf2out_frame_debug_expr): Accept CFA as well\n\tas CFA_STORE in rules 12 and 13.\n\nFrom-SVN: r166119", "tree": {"sha": "c5201d7da44fc0f1911791bc4f786c53bbdb15f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5201d7da44fc0f1911791bc4f786c53bbdb15f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f81c97740380165364d4af23c706f010c74e2609", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81c97740380165364d4af23c706f010c74e2609", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f81c97740380165364d4af23c706f010c74e2609", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81c97740380165364d4af23c706f010c74e2609/comments", "author": null, "committer": null, "parents": [{"sha": "b83905048722120272297c58e981a1a7a0d3460b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b83905048722120272297c58e981a1a7a0d3460b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b83905048722120272297c58e981a1a7a0d3460b"}], "stats": {"total": 793, "additions": 677, "deletions": 116}, "files": [{"sha": "3c426806617558520a5fd1571425efaf1c28affe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -1,3 +1,38 @@\n+2010-10-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/cygming.h (TARGET_SEH): New.\n+\t(MAX_STACK_ALIGNMENT): New.  Disable alignment for SEH.\n+\t(TARGET_ASM_UNWIND_EMIT, TARGET_ASM_UNWIND_EMIT_BEFORE_INSN,\n+\tTARGET_ASM_FUNCTION_END_PROLOGUE, SUBTARGET_ASM_UNWIND_INIT): New.\n+\t(TARGET_OS_CPP_BUILTINS): Define __SEH__ as needed.\n+\t(ASM_DECLARE_FUNCTION_NAME): Use i386_pe_start_function.\n+\t(ASM_DECLARE_FUNCTION_SIZE): New.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/i386.c (ix86_option_override_internal): Enable\n+\tflag_unwind_tables with flag_asynchronous_unwind_tables immediately;\n+\trestrict -mpreferred-stack-boundary for SEH; enable flag_fentry.\n+\t(ix86_asm_output_function_label): Use SUBTARGET_ASM_UNWIND_INIT.\n+\t(ix86_compute_frame_layout): For SEH, disable\n+\tuse_fast_prologue_epilogue, move frame pointer to the end of\n+\tthe frame.  Initialize hfp_save_offset.\n+\t(ix86_expand_prologue): Honor hfp_save_offset.  Emit blockage\n+\tat end of prologue for SEH.\n+\t(ix86_expand_epilogue): For SEH, use pops, emit a nop if needed,\n+\temit blockage at beginning of epilogue.\n+\t(ix86_expand_binary_operator): After reload, emit LEA if needed.\n+\t(ix86_output_call_insn): New.\n+\t* config/i386/i386.h (TARGET_SEH): New.\n+\t(struct machine_function): Add member seh.\n+\t* config/i386/i386.md (all call patterns): Use ix86_output_call_insn.\n+\t* config/i386/winnt.c (struct seh_frame_state): New.\n+\t(i386_pe_seh_init, i386_pe_seh_end_prologue, i386_pe_seh_fini,\n+\tseh_emit_push, seh_emit_save, seh_emit_stackalloc, seh_cfa_adjust_cfa,\n+\tseh_cfa_offset, seh_frame_related_expr, i386_pe_seh_unwind_emit,\n+\ti386_pe_start_function, i386_pe_end_function): New.\n+\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr): Accept CFA as well\n+\tas CFA_STORE in rules 12 and 13.\n+\n 2010-10-31  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/46142"}, {"sha": "09ea866c0d7e3bea4ef6767a1be104a3792c6a8c", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -33,6 +33,23 @@ along with GCC; see the file COPYING3.  If not see\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n #endif\n \n+#undef TARGET_SEH\n+#define TARGET_SEH  (TARGET_64BIT_MS_ABI && flag_unwind_tables)\n+\n+/* Win64 with SEH cannot represent DRAP stack frames.  Disable its use.\n+   Force the use of different mechanisms to allocate aligned local data.  */\n+#undef MAX_STACK_ALIGNMENT\n+#define MAX_STACK_ALIGNMENT  (TARGET_SEH ? 128 : MAX_OFILE_ALIGNMENT)\n+\n+/* Support hooks for SEH.  */\n+#undef  TARGET_ASM_UNWIND_EMIT\n+#define TARGET_ASM_UNWIND_EMIT  i386_pe_seh_unwind_emit\n+#undef  TARGET_ASM_UNWIND_EMIT_BEFORE_INSN\n+#define TARGET_ASM_UNWIND_EMIT_BEFORE_INSN  false\n+#undef  TARGET_ASM_FUNCTION_END_PROLOGUE\n+#define TARGET_ASM_FUNCTION_END_PROLOGUE  i386_pe_seh_end_prologue\n+#define SUBTARGET_ASM_UNWIND_INIT  i386_pe_seh_init\n+\n #undef DEFAULT_ABI\n #define DEFAULT_ABI (TARGET_64BIT ? MS_ABI : SYSV_ABI)\n \n@@ -104,6 +121,8 @@ along with GCC; see the file COPYING3.  If not see\n     {\t\t\t\t\t\t\t\t\t\\\n \tif (!TARGET_64BIT)\t\t\t\t\t\t\\\n \t  builtin_define (\"_X86_=1\");\t\t\t\t\t\\\n+\tif (TARGET_SEH)\t\t\t\t\t\t\t\\\n+\t  builtin_define (\"__SEH__\");\t\t\t\t\\\n \tbuiltin_assert (\"system=winnt\");\t\t\t\t\\\n \tbuiltin_define (\"__stdcall=__attribute__((__stdcall__))\");\t\\\n \tbuiltin_define (\"__fastcall=__attribute__((__fastcall__))\");\t\\\n@@ -281,15 +300,12 @@ do {\t\t\t\t\t\t\\\n    properly.  If we are generating SDB debugging information, this\n    will happen automatically, so we only need to handle other cases.  */\n #undef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      i386_pe_maybe_record_exported_symbol (DECL, NAME, 0);\t\t\\\n-      if (write_symbols != SDB_DEBUG)\t\t\t\t\t\\\n-\ti386_pe_declare_function_type (FILE, NAME, TREE_PUBLIC (DECL));\t\\\n-      ASM_OUTPUT_FUNCTION_LABEL (FILE, NAME, DECL);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+  i386_pe_start_function (FILE, NAME, DECL)\n+\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE,NAME,DECL) \\\n+  i386_pe_end_function (FILE, NAME, DECL)\n \n /* Add an external function to the list of functions to be declared at\n    the end of the file.  */"}, {"sha": "f6f9071395f7d0ca23c34e9ccc537d8b7bce3e03", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -225,8 +225,14 @@ extern void i386_pe_asm_output_aligned_decl_common (FILE *, tree,\n \t\t\t\t\t\t    HOST_WIDE_INT,\n \t\t\t\t\t\t    HOST_WIDE_INT);\n extern void i386_pe_file_end (void);\n+extern void i386_pe_start_function (FILE *, const char *, tree);\n+extern void i386_pe_end_function (FILE *, const char *, tree);\n extern tree i386_pe_mangle_decl_assembler_name (tree, tree);\n \n+extern void i386_pe_seh_init (FILE *);\n+extern void i386_pe_seh_end_prologue (FILE *);\n+extern void i386_pe_seh_unwind_emit (FILE *, rtx);\n+\n /* In winnt-cxx.c and winnt-stubs.c  */\n extern void i386_pe_adjust_class_at_definition (tree);\n extern bool i386_pe_type_dllimport_p (tree);\n@@ -263,3 +269,5 @@ extern int asm_preferred_eh_data_format (int, int);\n #ifdef HAVE_ATTR_cpu\n extern enum attr_cpu ix86_schedule;\n #endif\n+\n+extern const char * ix86_output_call_insn (rtx insn, rtx call_op, int addr_op);"}, {"sha": "32d6371a1337ea743397b7fbab0a1dc5d3eda9d2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 194, "deletions": 23, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -2151,6 +2151,7 @@ struct ix86_frame\n   HOST_WIDE_INT frame_pointer_offset;\n   HOST_WIDE_INT hard_frame_pointer_offset;\n   HOST_WIDE_INT stack_pointer_offset;\n+  HOST_WIDE_INT hfp_save_offset;\n   HOST_WIDE_INT reg_save_offset;\n   HOST_WIDE_INT sse_reg_save_offset;\n \n@@ -3573,7 +3574,7 @@ ix86_option_override_internal (bool main_args_p)\n       if (optimize >= 1 && !global_options_set.x_flag_omit_frame_pointer)\n \tflag_omit_frame_pointer = !USE_X86_64_FRAME_POINTER;\n       if (flag_asynchronous_unwind_tables == 2)\n-\tflag_asynchronous_unwind_tables = 1;\n+\tflag_unwind_tables = flag_asynchronous_unwind_tables = 1;\n       if (flag_pcc_struct_return == 2)\n \tflag_pcc_struct_return = 0;\n     }\n@@ -3777,10 +3778,19 @@ ix86_option_override_internal (bool main_args_p)\n   ix86_preferred_stack_boundary = PREFERRED_STACK_BOUNDARY_DEFAULT;\n   if (ix86_preferred_stack_boundary_string)\n     {\n+      int min = (TARGET_64BIT ? 4 : 2);\n+      int max = (TARGET_SEH ? 4 : 12);\n+\n       i = atoi (ix86_preferred_stack_boundary_string);\n-      if (i < (TARGET_64BIT ? 4 : 2) || i > 12)\n-\terror (\"%spreferred-stack-boundary=%d%s is not between %d and 12\",\n-\t       prefix, i, suffix, TARGET_64BIT ? 4 : 2);\n+      if (i < min || i > max)\n+\t{\n+\t  if (min == max)\n+\t    error (\"%spreferred-stack-boundary%s is not supported \"\n+\t\t   \"for this target\", prefix, suffix);\n+\t  else\n+\t    error (\"%spreferred-stack-boundary=%d%s is not between %d and %d\",\n+\t\t   prefix, i, suffix, min, max);\n+\t}\n       else\n \tix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n@@ -3987,7 +3997,13 @@ ix86_option_override_internal (bool main_args_p)\n         sorry (\"-mfentry isn't supported for 32-bit in combination with -fpic\");\n       flag_fentry = 0;\n     }\n-  if (flag_fentry < 0)\n+  else if (TARGET_SEH)\n+    {\n+      if (flag_fentry == 0)\n+\tsorry (\"-mno-fentry isn't compatible with SEH\");\n+      flag_fentry = 1;\n+    }\n+  else if (flag_fentry < 0)\n    {\n #if defined(PROFILE_BEFORE_PROLOGUE)\n      flag_fentry = 1;\n@@ -5536,6 +5552,10 @@ ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n         fprintf (asm_out_file, ASM_LONG \" %#x\\n\", filler_cc);\n     }\n \n+#ifdef SUBTARGET_ASM_UNWIND_INIT\n+  SUBTARGET_ASM_UNWIND_INIT (asm_out_file);\n+#endif\n+\n   ASM_OUTPUT_LABEL (asm_out_file, fname);\n \n   /* Output magic byte marker, if hot-patch attribute is set.  */\n@@ -8934,17 +8954,25 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);\n   gcc_assert (preferred_alignment <= stack_alignment_needed);\n \n+  /* For SEH we have to limit the amount of code movement into the prologue.\n+     At present we do this via a BLOCKAGE, at which point there's very little\n+     scheduling that can be done, which means that there's very little point\n+     in doing anything except PUSHs.  */\n+  if (TARGET_SEH)\n+    cfun->machine->use_fast_prologue_epilogue = false;\n+\n   /* During reload iteration the amount of registers saved can change.\n      Recompute the value as needed.  Do not recompute when amount of registers\n      didn't change as reload does multiple calls to the function and does not\n      expect the decision to change within single iteration.  */\n-  if (!optimize_function_for_size_p (cfun)\n-      && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n+  else if (!optimize_function_for_size_p (cfun)\n+           && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n     {\n       int count = frame->nregs;\n       struct cgraph_node *node = cgraph_node (current_function_decl);\n \n       cfun->machine->use_fast_prologue_epilogue_nregs = count;\n+\n       /* The fast prologue uses move instead of push to save registers.  This\n          is significantly longer, but also executes faster as modern hardware\n          can execute the moves in parallel, but can't do that for push/pop.\n@@ -8986,7 +9014,9 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   /* Skip saved base pointer.  */\n   if (frame_pointer_needed)\n     offset += UNITS_PER_WORD;\n+  frame->hfp_save_offset = offset;\n \n+  /* The traditional frame pointer location is at the top of the frame.  */\n   frame->hard_frame_pointer_offset = offset;\n \n   /* Register save area */\n@@ -9069,6 +9099,27 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   else\n     frame->red_zone_size = 0;\n   frame->stack_pointer_offset -= frame->red_zone_size;\n+\n+  /* The SEH frame pointer location is near the bottom of the frame.\n+     This is enforced by the fact that the difference between the\n+     stack pointer and the frame pointer is limited to 240 bytes in\n+     the unwind data structure.  */\n+  if (TARGET_SEH)\n+    {\n+      HOST_WIDE_INT diff;\n+\n+      /* If we can leave the frame pointer where it is, do so.  */\n+      diff = frame->stack_pointer_offset - frame->hard_frame_pointer_offset;\n+      if (diff > 240 || (diff & 15) != 0)\n+\t{\n+\t  /* Ideally we'd determine what portion of the local stack frame\n+\t     (within the constraint of the lowest 240) is most heavily used.\n+\t     But without that complication, simply bias the frame pointer\n+\t     by 128 bytes so as to maximize the amount of the local stack\n+\t     frame that is addressable with 8-bit offsets.  */\n+\t  frame->hard_frame_pointer_offset = frame->stack_pointer_offset - 128;\n+\t}\n+    }\n }\n \n /* This is semi-inlined memory_address_length, but simplified\n@@ -10001,7 +10052,8 @@ ix86_expand_prologue (void)\n       /* Check if profiling is active and we shall use profiling before\n          prologue variant. If so sorry.  */\n       if (crtl->profile && flag_fentry != 0)\n-        sorry (\"ms_hook_prologue attribute isn't compatible with -mfentry for 32-bit\");\n+        sorry (\"ms_hook_prologue attribute isn't compatible \"\n+\t       \"with -mfentry for 32-bit\");\n \n       /* In ix86_asm_output_function_label we emitted:\n \t 8b ff     movl.s %edi,%edi\n@@ -10130,14 +10182,16 @@ ix86_expand_prologue (void)\n       insn = emit_insn (gen_push (hard_frame_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      if (m->fs.sp_offset == frame.hard_frame_pointer_offset)\n+\t{\n+\t  insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \n-      if (m->fs.cfa_reg == stack_pointer_rtx)\n-        m->fs.cfa_reg = hard_frame_pointer_rtx;\n-      gcc_assert (m->fs.sp_offset == frame.hard_frame_pointer_offset);\n-      m->fs.fp_offset = m->fs.sp_offset;\n-      m->fs.fp_valid = true;\n+\t  if (m->fs.cfa_reg == stack_pointer_rtx)\n+\t    m->fs.cfa_reg = hard_frame_pointer_rtx;\n+\t  m->fs.fp_offset = m->fs.sp_offset;\n+\t  m->fs.fp_valid = true;\n+\t}\n     }\n \n   int_registers_saved = (frame.nregs == 0);\n@@ -10290,12 +10344,15 @@ ix86_expand_prologue (void)\n       insn = emit_insn (adjust_stack_insn (stack_pointer_rtx,\n \t\t\t\t\t   stack_pointer_rtx, eax));\n \n-      if (m->fs.cfa_reg == stack_pointer_rtx)\n+      /* Note that SEH directives need to continue tracking the stack\n+\t pointer even after the frame pointer has been set up.  */\n+      if (m->fs.cfa_reg == stack_pointer_rtx || TARGET_SEH)\n \t{\n-\t  m->fs.cfa_offset += allocate;\n+\t  if (m->fs.cfa_reg == stack_pointer_rtx)\n+\t    m->fs.cfa_offset += allocate;\n \n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n \t\t\t\t     plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t    -allocate)));\n@@ -10317,6 +10374,22 @@ ix86_expand_prologue (void)\n     }\n   gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);\n \n+  /* If we havn't already set up the frame pointer, do so now.  */\n+  if (frame_pointer_needed && !m->fs.fp_valid)\n+    {\n+      insn = ix86_gen_add3 (hard_frame_pointer_rtx, stack_pointer_rtx,\n+\t\t\t    GEN_INT (frame.stack_pointer_offset\n+\t\t\t\t     - frame.hard_frame_pointer_offset));\n+      insn = emit_insn (insn);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, NULL);\n+\n+      if (m->fs.cfa_reg == stack_pointer_rtx)\n+\tm->fs.cfa_reg = hard_frame_pointer_rtx;\n+      m->fs.fp_offset = frame.hard_frame_pointer_offset;\n+      m->fs.fp_valid = true;\n+    }\n+\n   if (!int_registers_saved)\n     ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n   if (frame.nsseregs)\n@@ -10386,6 +10459,11 @@ ix86_expand_prologue (void)\n   /* Emit cld instruction if stringops are used in the function.  */\n   if (TARGET_CLD && ix86_current_function_needs_cld)\n     emit_insn (gen_cld ());\n+\n+  /* SEH requires that the prologue end within 256 bytes of the start of\n+     the function.  Prevent instruction schedules that would extend that.  */\n+  if (TARGET_SEH)\n+    emit_insn (gen_blockage ());\n }\n \n /* Emit code to restore REG using a POP insn.  */\n@@ -10610,13 +10688,16 @@ ix86_expand_epilogue (int style)\n   if (crtl->calls_eh_return && style != 2)\n     frame.reg_save_offset -= 2 * UNITS_PER_WORD;\n \n+  /* EH_RETURN requires the use of moves to function properly.  */\n+  if (crtl->calls_eh_return)\n+    restore_regs_via_mov = true;\n+  /* SEH requires the use of pops to identify the epilogue.  */\n+  else if (TARGET_SEH)\n+    restore_regs_via_mov = false;\n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n      less work than reloading sp and popping the register.  */\n-  if (!m->fs.sp_valid && frame.nregs <= 1)\n-    restore_regs_via_mov = true;\n-  /* EH_RETURN requires the use of moves to function properly.  */\n-  else if (crtl->calls_eh_return)\n+  else if (!m->fs.sp_valid && frame.nregs <= 1)\n     restore_regs_via_mov = true;\n   else if (TARGET_EPILOGUE_USING_MOVE\n \t   && cfun->machine->use_fast_prologue_epilogue\n@@ -10728,6 +10809,22 @@ ix86_expand_epilogue (int style)\n     }\n   else\n     {\n+      /* SEH requires that the function end with (1) a stack adjustment\n+\t if necessary, (2) a sequence of pops, and (3) a return or\n+\t jump instruction.  Prevent insns from the function body from\n+\t being scheduled into this sequence.  */\n+      if (TARGET_SEH)\n+\t{\n+\t  /* Prevent a catch region from being adjacent to the standard\n+\t     epilogue sequence.  Unfortuantely crtl->uses_eh_lsda nor\n+\t     several other flags that would be interesting to test are\n+\t     not yet set up.  */\n+\t  if (flag_non_call_exceptions)\n+\t    emit_insn (gen_nops (const1_rtx));\n+\t  else\n+\t    emit_insn (gen_blockage ());\n+\t}\n+\n       /* First step is to deallocate the stack frame so that we can\n \t pop the registers.  */\n       if (!m->fs.sp_valid)\n@@ -10755,7 +10852,7 @@ ix86_expand_epilogue (int style)\n     {\n       /* If the stack pointer is valid and pointing at the frame\n \t pointer store address, then we only need a pop.  */\n-      if (m->fs.sp_valid && m->fs.sp_offset == frame.hard_frame_pointer_offset)\n+      if (m->fs.sp_valid && m->fs.sp_offset == frame.hfp_save_offset)\n \tix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n       /* Leave results in shorter dependency chains on CPUs that are\n \t able to grok it fast.  */\n@@ -15494,6 +15591,13 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n       gcc_assert (code == PLUS);\n       emit_insn (op);\n     }\n+  else if (reload_completed\n+\t   && code == PLUS\n+\t   && !rtx_equal_p (dst, src1))\n+    {\n+      /* This is going to be an LEA; avoid splitting it later.  */\n+      emit_insn (op);\n+    }\n   else\n     {\n       clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n@@ -21417,6 +21521,73 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   return call;\n }\n \n+/* Output the assembly for a call instruction.  */\n+\n+const char *\n+ix86_output_call_insn (rtx insn, rtx call_op, int addr_op)\n+{\n+  bool direct_p = constant_call_address_operand (call_op, Pmode);\n+  bool seh_nop_p = false;\n+\n+  gcc_assert (addr_op == 0 || addr_op == 1);\n+\n+  if (SIBLING_CALL_P (insn))\n+    {\n+      if (direct_p)\n+\treturn addr_op ? \"jmp\\t%P1\" : \"jmp\\t%P0\";\n+      /* SEH epilogue detection requires the indirect branch case\n+\t to include REX.W.  */\n+      else if (TARGET_SEH)\n+\treturn addr_op ? \"rex.W jmp %A1\" : \"rex.W jmp %A0\";\n+      else\n+\treturn addr_op ? \"jmp\\t%A1\" : \"jmp\\t%A0\";\n+    }\n+\n+  /* SEH unwinding can require an extra nop to be emitted in several\n+     circumstances.  Determine if we have one of those.  */\n+  if (TARGET_SEH)\n+    {\n+      rtx i;\n+\n+      for (i = NEXT_INSN (insn); i ; i = NEXT_INSN (i))\n+\t{\n+\t  /* If we get to another real insn, we don't need the nop.  */\n+\t  if (INSN_P (i))\n+\t    break;\n+\n+\t  /* If we get to the epilogue note, prevent a catch region from\n+\t     being adjacent to the standard epilogue sequence.  If non-\n+\t     call-exceptions, we'll have done this during epilogue emission. */\n+\t  if (NOTE_P (i) && NOTE_KIND (i) == NOTE_INSN_EPILOGUE_BEG\n+\t      && !flag_non_call_exceptions\n+\t      && !can_throw_internal (insn))\n+\t    {\n+\t      seh_nop_p = true;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* If we didn't find a real insn following the call, prevent the\n+\t unwinder from looking into the next function.  */\n+      if (i == NULL)\n+\tseh_nop_p = true;\n+    }\n+\n+  if (direct_p)\n+    {\n+      if (seh_nop_p)\n+\treturn addr_op ? \"call\\t%P1\\n\\tnop\" : \"call\\t%P0\\n\\tnop\";\n+      else\n+\treturn addr_op ? \"call\\t%P1\" : \"call\\t%P0\";\n+    }\n+  else\n+    {\n+      if (seh_nop_p)\n+\treturn addr_op ? \"call\\t%A1\\n\\tnop\" : \"call\\t%A0\\n\\tnop\";\n+      else\n+\treturn addr_op ? \"call\\t%A1\" : \"call\\t%A0\";\n+    }\n+}\n \f\n /* Clear stack slot assignments remembered from previous functions.\n    This is called from INIT_EXPANDERS once before RTL is emitted for each"}, {"sha": "3c7f9f07ea137bc06bf98e8d503d289732c18fdd", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -490,6 +490,9 @@ extern tree x86_mfence;\n /* For the Windows 64-bit ABI.  */\n #define TARGET_64BIT_MS_ABI (TARGET_64BIT && ix86_cfun_abi () == MS_ABI)\n \n+/* This is re-defined by cygming.h.  */\n+#define TARGET_SEH 0\n+\n /* Available call abi.  */\n enum calling_abi\n {\n@@ -2244,6 +2247,9 @@ struct GTY(()) machine_frame_state\n   BOOL_BITFIELD realigned : 1;\n };\n \n+/* Private to winnt.c.  */\n+struct seh_frame_state;\n+\n struct GTY(()) machine_function {\n   struct stack_local_entry *stack_locals;\n   const char *some_ld_name;\n@@ -2312,6 +2318,9 @@ struct GTY(()) machine_function {\n   /* During prologue/epilogue generation, the current frame state.\n      Otherwise, the frame state at the end of the prologue.  */\n   struct machine_frame_state fs;\n+\n+  /* During SEH output, this is non-null.  */\n+  struct seh_frame_state * GTY((skip(\"\"))) seh;\n };\n #endif\n "}, {"sha": "feaf78173fb8e079ab1637d366106ab17907cb88", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 19, "deletions": 82, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -11325,44 +11325,29 @@\n   [(call (mem:QI (match_operand 0 \"constant_call_address_operand\" \"\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"\"\n-{\n-  if (SIBLING_CALL_P (insn))\n-    return \"jmp\\t%P0\";\n-  else\n-    return \"call\\t%P0\";\n-}\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_1\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[0], Pmode))\n-    return \"call\\t%P0\";\n-  return \"call\\t%A0\";\n-}\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*sibcall_1\"\n   [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"@\n-   jmp\\t%P0\n-   jmp\\t%A0\"\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\n    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n-{\n-  if (constant_call_address_operand (operands[0], Pmode))\n-    return \"call\\t%P0\";\n-  return \"call\\t%A0\";\n-}\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_1_rex64_ms_sysv\"\n@@ -11382,27 +11367,21 @@\n    (clobber (reg:DI SI_REG))\n    (clobber (reg:DI DI_REG))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[0], Pmode))\n-    return \"call\\t%P0\";\n-  return \"call\\t%A0\";\n-}\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_1_rex64_large\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rm\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-  \"call\\t%A0\"\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*sibcall_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"@\n-   jmp\\t%P0\n-   jmp\\t%A0\"\n+  { return ix86_output_call_insn (insn, operands[0], 0); }\n   [(set_attr \"type\" \"call\")])\n \n ;; Call subroutine, returning value in operand 0\n@@ -17152,12 +17131,7 @@\n \t(plus:SI (reg:SI SP_REG)\n \t\t (match_operand:SI 3 \"immediate_operand\" \"\")))]\n   \"!TARGET_64BIT\"\n-{\n-  if (SIBLING_CALL_P (insn))\n-    return \"jmp\\t%P1\";\n-  else\n-    return \"call\\t%P1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_pop_1\"\n@@ -17168,11 +17142,7 @@\n \t(plus:SI (reg:SI SP_REG)\n \t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n   \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"call\\t%P1\";\n-  return \"call\\t%A1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*sibcall_value_pop_1\"\n@@ -17183,35 +17153,23 @@\n \t(plus:SI (reg:SI SP_REG)\n \t\t (match_operand:SI 3 \"immediate_operand\" \"i,i\")))]\n   \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"@\n-   jmp\\t%P1\n-   jmp\\t%A1\"\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_0\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n   \"!TARGET_64BIT\"\n-{\n-  if (SIBLING_CALL_P (insn))\n-    return \"jmp\\t%P1\";\n-  else\n-    return \"call\\t%P1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_0_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n \t      (match_operand:DI 2 \"const_int_operand\" \"\")))]\n   \"TARGET_64BIT\"\n-{\n-  if (SIBLING_CALL_P (insn))\n-    return \"jmp\\t%P1\";\n-  else\n-    return \"call\\t%P1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_0_rex64_ms_sysv\"\n@@ -17232,34 +17190,23 @@\n    (clobber (reg:DI SI_REG))\n    (clobber (reg:DI DI_REG))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-{\n-  if (SIBLING_CALL_P (insn))\n-    return \"jmp\\t%P1\";\n-  else\n-    return \"call\\t%P1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n   \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"call\\t%P1\";\n-  return \"call\\t%A1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*sibcall_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n   \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"@\n-   jmp\\t%P1\n-   jmp\\t%A1\"\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_1_rex64\"\n@@ -17268,11 +17215,7 @@\n \t      (match_operand:DI 2 \"\" \"\")))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\n    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"call\\t%P1\";\n-  return \"call\\t%A1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_1_rex64_ms_sysv\"\n@@ -17293,29 +17236,23 @@\n    (clobber (reg:DI SI_REG))\n    (clobber (reg:DI DI_REG))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"call\\t%P1\";\n-  return \"call\\t%A1\";\n-}\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_1_rex64_large\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rm\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n   \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n-  \"call\\t%A1\"\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*sibcall_value_1_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n   \"TARGET_64BIT && SIBLING_CALL_P (insn)\"\n-  \"@\n-   jmp\\t%P1\n-   jmp\\t%A1\"\n+  { return ix86_output_call_insn (insn, operands[1], 1); }\n   [(set_attr \"type\" \"callv\")])\n \f\n ;; We used to use \"int $5\", in honor of #BR which maps to interrupt vector 5."}, {"sha": "45a736ad60e995f3e1667112d0c532292505fe2d", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n+#include \"except.h\"\n #include \"lto-streamer.h\"\n \n /* i386/PE specific attribute support.\n@@ -730,4 +731,384 @@ i386_pe_file_end (void)\n     }\n }\n \n+\f\n+/* x64 Structured Exception Handling unwind info.  */\n+\n+struct seh_frame_state\n+{\n+  /* SEH records saves relative to the \"current\" stack pointer, whether\n+     or not there's a frame pointer in place.  This tracks the current\n+     stack pointer offset from the CFA.  */\n+  HOST_WIDE_INT sp_offset;\n+\n+  /* The CFA is located at CFA_REG + CFA_OFFSET.  */\n+  HOST_WIDE_INT cfa_offset;\n+  rtx cfa_reg;\n+};\n+\n+/* Set up data structures beginning output for SEH.  */\n+\n+void\n+i386_pe_seh_init (FILE *f)\n+{\n+  struct seh_frame_state *seh;\n+\n+  if (!TARGET_SEH)\n+    return;\n+  if (cfun->is_thunk)\n+    return;\n+\n+  /* We cannot support DRAP with SEH.  We turned off support for it by\n+     re-defining MAX_STACK_ALIGNMENT when SEH is enabled.  */\n+  gcc_assert (!stack_realign_drap);\n+\n+  seh = XCNEW (struct seh_frame_state);\n+  cfun->machine->seh = seh;\n+\n+  seh->sp_offset = INCOMING_FRAME_SP_OFFSET;\n+  seh->cfa_offset = INCOMING_FRAME_SP_OFFSET;\n+  seh->cfa_reg = stack_pointer_rtx;\n+\n+  fputs (\"\\t.seh_proc\\t\", f);\n+  assemble_name (f, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (cfun->decl)));\n+  fputc ('\\n', f);\n+}\n+\n+void\n+i386_pe_seh_end_prologue (FILE *f)\n+{\n+  struct seh_frame_state *seh;\n+\n+  if (!TARGET_SEH)\n+    return;\n+  if (cfun->is_thunk)\n+    return;\n+  seh = cfun->machine->seh;\n+\n+  /* Emit an assembler directive to set up the frame pointer.  Always do\n+     this last.  The documentation talks about doing this \"before\" any\n+     other code that uses offsets, but (experimentally) that's after we\n+     emit the codes in reverse order (handled by the assembler).  */\n+  if (seh->cfa_reg != stack_pointer_rtx)\n+    {\n+      HOST_WIDE_INT offset = seh->sp_offset - seh->cfa_offset;\n+\n+      gcc_assert ((offset & 15) == 0);\n+      gcc_assert (IN_RANGE (offset, 0, 240));\n+\n+      fputs (\"\\t.seh_setframe\\t\", f);\n+      print_reg (seh->cfa_reg, 0, f);\n+      fprintf (f, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n+    }\n+\n+  XDELETE (seh);\n+  cfun->machine->seh = NULL;\n+\n+  fputs (\"\\t.seh_endprologue\\n\", f);\n+}\n+\n+static void\n+i386_pe_seh_fini (FILE *f)\n+{\n+  if (!TARGET_SEH)\n+    return;\n+  if (cfun->is_thunk)\n+    return;\n+  fputs (\"\\t.seh_endproc\\n\", f);\n+}\n+\n+/* Emit an assembler directive to save REG via a PUSH.  */\n+\n+static void\n+seh_emit_push (FILE *f, struct seh_frame_state *seh, rtx reg)\n+{\n+  unsigned int regno = REGNO (reg);\n+\n+  gcc_checking_assert (GENERAL_REGNO_P (regno));\n+\n+  seh->sp_offset += UNITS_PER_WORD;\n+  if (seh->cfa_reg == stack_pointer_rtx)\n+    seh->cfa_offset += UNITS_PER_WORD;\n+\n+  fputs (\"\\t.seh_pushreg\\t\", f);\n+  print_reg (reg, 0, f);\n+  fputc ('\\n', f);\n+}\n+\n+/* Emit an assembler directive to save REG at CFA - CFA_OFFSET.  */\n+\n+static void\n+seh_emit_save (FILE *f, struct seh_frame_state *seh,\n+\t       rtx reg, HOST_WIDE_INT cfa_offset)\n+{\n+  unsigned int regno = REGNO (reg);\n+  HOST_WIDE_INT offset;\n+\n+  /* Negative save offsets are of course not supported, since that\n+     would be a store below the stack pointer and thus clobberable.  */\n+  gcc_assert (seh->sp_offset >= cfa_offset);\n+  offset = seh->sp_offset - cfa_offset;\n+\n+  fputs ((SSE_REGNO_P (regno) ? \"\\t.seh_savexmm\\t\"\n+\t : GENERAL_REGNO_P (regno) ?  \"\\t.seh_savereg\\t\"\n+\t : (gcc_unreachable (), \"\")), f);\n+  print_reg (reg, 0, f);\n+  fprintf (f, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n+}\n+\n+/* Emit an assembler directive to adjust RSP by OFFSET.  */\n+\n+static void\n+seh_emit_stackalloc (FILE *f, struct seh_frame_state *seh,\n+\t\t     HOST_WIDE_INT offset)\n+{\n+  /* We're only concerned with prologue stack allocations, which all\n+     are subtractions from the stack pointer.  */\n+  gcc_assert (offset < 0);\n+  offset = -offset;\n+\n+  if (seh->cfa_reg == stack_pointer_rtx)\n+    seh->cfa_offset += offset;\n+  seh->sp_offset += offset;\n+\n+  fprintf (f, \"\\t.seh_stackalloc\\t\" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n+}\n+\n+/* Process REG_CFA_ADJUST_CFA for SEH.  */\n+\n+static void\n+seh_cfa_adjust_cfa (FILE *f, struct seh_frame_state *seh, rtx pat)\n+{\n+  rtx dest, src;\n+  HOST_WIDE_INT reg_offset = 0;\n+  unsigned int dest_regno;\n+\n+  dest = SET_DEST (pat);\n+  src = SET_SRC (pat);\n+\n+  if (GET_CODE (src) == PLUS)\n+    {\n+      reg_offset = INTVAL (XEXP (src, 1));\n+      src = XEXP (src, 0);\n+    }\n+  else if (GET_CODE (src) == MINUS)\n+    {\n+      reg_offset = -INTVAL (XEXP (src, 1));\n+      src = XEXP (src, 0);\n+    }\n+  gcc_assert (src == stack_pointer_rtx);\n+  gcc_assert (seh->cfa_reg == stack_pointer_rtx);\n+  dest_regno = REGNO (dest);\n+\n+  if (dest_regno == STACK_POINTER_REGNUM)\n+    seh_emit_stackalloc (f, seh, reg_offset);\n+  else if (dest_regno == HARD_FRAME_POINTER_REGNUM)\n+    {\n+      seh->cfa_reg = dest;\n+      seh->cfa_offset -= reg_offset;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Process REG_CFA_OFFSET for SEH.  */\n+\n+static void\n+seh_cfa_offset (FILE *f, struct seh_frame_state *seh, rtx pat)\n+{\n+  rtx dest, src;\n+  HOST_WIDE_INT reg_offset;\n+\n+  dest = SET_DEST (pat);\n+  src = SET_SRC (pat);\n+\n+  gcc_assert (MEM_P (dest));\n+  dest = XEXP (dest, 0);\n+  if (REG_P (dest))\n+    reg_offset = 0;\n+  else\n+    {\n+      gcc_assert (GET_CODE (dest) == PLUS);\n+      reg_offset = INTVAL (XEXP (dest, 1));\n+      dest = XEXP (dest, 0);\n+    }\n+  gcc_assert (dest == seh->cfa_reg);\n+\n+  seh_emit_save (f, seh, src, seh->cfa_offset - reg_offset);\n+}\n+\n+/* Process a FRAME_RELATED_EXPR for SEH.  */\n+\n+static void\n+seh_frame_related_expr (FILE *f, struct seh_frame_state *seh, rtx pat)\n+{\n+  rtx dest, src;\n+  HOST_WIDE_INT addend;\n+\n+  /* See the full loop in dwarf2out_frame_debug_expr.  */\n+  if (GET_CODE (pat) == PARALLEL || GET_CODE (pat) == SEQUENCE)\n+    {\n+      int i, n = XVECLEN (pat, 0), pass, npass;\n+\n+      npass = (GET_CODE (pat) == PARALLEL ? 2 : 1);\n+      for (pass = 0; pass < npass; ++pass)\n+\tfor (i = 0; i < n; ++i)\n+\t  {\n+\t    rtx ele = XVECEXP (pat, 0, i);\n+\n+\t    if (GET_CODE (ele) != SET)\n+\t      continue;\n+\t    dest = SET_DEST (ele);\n+\n+\t    /* Process each member of the PARALLEL independently.  The first\n+\t       member is always processed; others only if they are marked.  */\n+\t    if (i == 0 || RTX_FRAME_RELATED_P (ele))\n+\t      {\n+\t\t/* Evaluate all register saves in the first pass and all\n+\t\t   register updates in the second pass.  */\n+\t\tif ((MEM_P (dest) ^ pass) || npass == 1)\n+\t\t  seh_frame_related_expr (f, seh, ele);\n+\t      }\n+\t  }\n+      return;\n+    }\n+\n+  dest = SET_DEST (pat);\n+  src = SET_SRC (pat);\n+\n+  switch (GET_CODE (dest))\n+    {\n+    case REG:\n+      switch (GET_CODE (src))\n+\t{\n+\tcase REG:\n+\t  /* REG = REG: This should be establishing a frame pointer.  */\n+\t  gcc_assert (src == stack_pointer_rtx);\n+\t  gcc_assert (dest == hard_frame_pointer_rtx);\n+\t  seh_cfa_adjust_cfa (f, seh, pat);\n+\t  break;\n+\n+\tcase PLUS:\n+\t  addend = INTVAL (XEXP (src, 1));\n+\t  src = XEXP (src, 0);\n+\t  if (dest == hard_frame_pointer_rtx)\n+\t    seh_cfa_adjust_cfa (f, seh, pat);\n+\t  else if (dest == stack_pointer_rtx)\n+\t    {\n+\t      gcc_assert (src == stack_pointer_rtx);\n+\t      seh_emit_stackalloc (f, seh, addend);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case MEM:\n+      /* A save of some kind.  */\n+      dest = XEXP (dest, 0);\n+      if (GET_CODE (dest) == PRE_DEC)\n+\t{\n+\t  gcc_checking_assert (GET_MODE (src) == Pmode);\n+\t  gcc_checking_assert (REG_P (src));\n+\t  seh_emit_push (f, seh, src);\n+\t}\n+      else\n+\tseh_cfa_offset (f, seh, pat);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* This function looks at a single insn and emits any SEH directives\n+   required for unwind of this insn.  */\n+\n+void\n+i386_pe_seh_unwind_emit (FILE *asm_out_file, rtx insn)\n+{\n+  rtx note, pat;\n+  bool handled_one = false;\n+  struct seh_frame_state *seh;\n+\n+  if (!TARGET_SEH)\n+    return;\n+\n+  /* We free the SEH data once done with the prologue.  Ignore those\n+     RTX_FRAME_RELATED_P insns that are associated with the epilogue.  */\n+  seh = cfun->machine->seh;\n+  if (seh == NULL)\n+    return;\n+\n+  if (NOTE_P (insn) || !RTX_FRAME_RELATED_P (insn))\n+    return;\n+\n+  for (note = REG_NOTES (insn); note ; note = XEXP (note, 1))\n+    {\n+      pat = XEXP (note, 0);\n+      switch (REG_NOTE_KIND (note))\n+\t{\n+\tcase REG_FRAME_RELATED_EXPR:\n+\t  goto found;\n+\n+\tcase REG_CFA_DEF_CFA:\n+\tcase REG_CFA_EXPRESSION:\n+\t  /* Only emitted with DRAP, which we disable.  */\n+\t  gcc_unreachable ();\n+\t  break;\n+\n+\tcase REG_CFA_REGISTER:\n+\t  /* Only emitted in epilogues, which we skip.  */\n+\t  gcc_unreachable ();\n+\n+\tcase REG_CFA_ADJUST_CFA:\n+\t  if (pat == NULL)\n+\t    {\n+\t      pat = PATTERN (insn);\n+\t      if (GET_CODE (pat) == PARALLEL)\n+\t\tpat = XVECEXP (pat, 0, 0);\n+\t    }\n+\t  seh_cfa_adjust_cfa (asm_out_file, seh, pat);\n+\t  handled_one = true;\n+\t  break;\n+\n+\tcase REG_CFA_OFFSET:\n+\t  if (pat == NULL)\n+\t    pat = single_set (insn);\n+\t  seh_cfa_offset (asm_out_file, seh, pat);\n+\t  handled_one = true;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  if (handled_one)\n+    return;\n+  pat = PATTERN (insn);\n+ found:\n+  seh_frame_related_expr (asm_out_file, seh, pat);\n+}\n+\f\n+void\n+i386_pe_start_function (FILE *f, const char *name, tree decl)\n+{\n+  i386_pe_maybe_record_exported_symbol (decl, name, 0);\n+  if (write_symbols != SDB_DEBUG)\n+    i386_pe_declare_function_type (f, name, TREE_PUBLIC (decl));\n+  ASM_OUTPUT_FUNCTION_LABEL (f, name, decl);\n+}\n+\n+void\n+i386_pe_end_function (FILE *f, const char *name ATTRIBUTE_UNUSED,\n+\t\t      tree decl ATTRIBUTE_UNUSED)\n+{\n+  i386_pe_seh_fini (f);\n+}\n+\f\n+\n #include \"gt-winnt.h\""}, {"sha": "9209c0d01aa8c8eb974dd0f68b8d0cd3eb78bcb0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f81c97740380165364d4af23c706f010c74e2609/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f81c97740380165364d4af23c706f010c74e2609", "patch": "@@ -2552,7 +2552,9 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t    regno = REGNO (XEXP (XEXP (dest, 0), 0));\n \n-\t    if (cfa_store.reg == (unsigned) regno)\n+\t    if (cfa.reg == (unsigned) regno)\n+\t      offset -= cfa.offset;\n+\t    else if (cfa_store.reg == (unsigned) regno)\n \t      offset -= cfa_store.offset;\n \t    else\n \t      {\n@@ -2568,7 +2570,9 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  {\n \t    int regno = REGNO (XEXP (dest, 0));\n \n-\t    if (cfa_store.reg == (unsigned) regno)\n+\t    if (cfa.reg == (unsigned) regno)\n+\t      offset = -cfa.offset;\n+\t    else if (cfa_store.reg == (unsigned) regno)\n \t      offset = -cfa_store.offset;\n \t    else\n \t      {"}]}