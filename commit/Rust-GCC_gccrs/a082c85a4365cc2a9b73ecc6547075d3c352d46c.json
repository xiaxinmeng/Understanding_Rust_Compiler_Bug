{"sha": "a082c85a4365cc2a9b73ecc6547075d3c352d46c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA4MmM4NWE0MzY1Y2MyYTliNzNlY2M2NTQ3MDc1ZDNjMzUyZDQ2Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-09T01:32:56Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-09T01:32:56Z"}, "message": "x\n\nFrom-SVN: r13116", "tree": {"sha": "52d6bc1d7084d5aba0f1ee166babb5917339f369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52d6bc1d7084d5aba0f1ee166babb5917339f369"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a082c85a4365cc2a9b73ecc6547075d3c352d46c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a082c85a4365cc2a9b73ecc6547075d3c352d46c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a082c85a4365cc2a9b73ecc6547075d3c352d46c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a082c85a4365cc2a9b73ecc6547075d3c352d46c/comments", "author": null, "committer": null, "parents": [{"sha": "9b04c6a896b81889fb94e7878cef705b1ef716c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b04c6a896b81889fb94e7878cef705b1ef716c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b04c6a896b81889fb94e7878cef705b1ef716c4"}], "stats": {"total": 101, "additions": 64, "deletions": 37}, "files": [{"sha": "e5e21829f35a015d720bc5571c37659ff41acb02", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a082c85a4365cc2a9b73ecc6547075d3c352d46c", "patch": "@@ -6358,6 +6358,7 @@ gen_enumeration_type_die (type, context_die)\n   if (TYPE_SIZE (type))\n     {\n       register tree link;\n+      TREE_ASM_WRITTEN (type) = 1;\n       add_byte_size_attribute (type_die, type);\n       for (link = TYPE_FIELDS (type);\n \t   link != NULL; link = TREE_CHAIN (link))\n@@ -7119,18 +7120,26 @@ gen_struct_or_union_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register dw_die_ref type_die = lookup_type_die (type);\n+  register dw_die_ref scope_die = 0;\n+  register int nested = 0;\n \n   if (type_die && ! TYPE_SIZE (type))\n     return;\n-  else if (! type_die\n-\t   || (TYPE_CONTEXT (type)\n-\t       && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'))\n+\n+  if (TYPE_CONTEXT (type)\n+      && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't')\n+    nested = 1;\n+\n+  if (! type_die || nested)\n+    scope_die = scope_die_for (type, context_die);\n+\n+  if (! type_die || (nested && scope_die == comp_unit_die))\n     /* First occurrence of type or toplevel definition of nested class.  */\n     {\n       register dw_die_ref old_die = type_die;\n       type_die = new_die (TREE_CODE (type) == RECORD_TYPE\n \t\t\t  ? DW_TAG_structure_type : DW_TAG_union_type,\n-\t\t\t  scope_die_for (type, context_die));\n+\t\t\t  scope_die);\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n       if (old_die)\n@@ -7141,7 +7150,11 @@ gen_struct_or_union_type_die (type, context_die)\n \n   /* If this type has been completed, then give it a byte_size attribute and\n      then give a list of members.  */\n-  if (TYPE_SIZE (type))\n+  if (TYPE_SIZE (type)\n+      /* If we're getting a reference to one nested class from another\n+\t nested class, don't recurse.  */\n+      && ! (nested && scope_die != context_die\n+\t    && scope_die == lookup_type_die (TYPE_CONTEXT (type))))\n     {\n       /* Prevent infinite recursion in cases where the type of some member of \n          this type is expressed in terms of this type itself.  */\n@@ -7279,16 +7292,21 @@ gen_type_die (type, context_die)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+      /* If this is a nested type whose containing class hasn't been\n+\t written out yet, writing it out will cover this one, too.  */\n+      if (TYPE_CONTEXT (type)\n+\t  && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'\n+\t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+\tgen_type_die (TYPE_CONTEXT (type), context_die);\n+      else if (TREE_CODE (type) == ENUMERAL_TYPE)\n \tgen_enumeration_type_die (type, context_die);\n       else\n \tgen_struct_or_union_type_die (type, context_die);\n \n       /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n-\t it up if it is ever completed.  */\n-      if (TYPE_SIZE (type) == NULL_TREE)\n-\treturn;\n-      break;\n+\t it up if it is ever completed.  gen_*_type_die will set it for us\n+\t when appropriate.  */\n+      return;\n \n     case VOID_TYPE:\n     case INTEGER_TYPE:"}, {"sha": "e7af7d2a7fbe70487d6747e7748633e1b03c5d1a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=a082c85a4365cc2a9b73ecc6547075d3c352d46c", "patch": "@@ -336,7 +336,7 @@ layout_record (rec)\n \t In both cases, all we do is lay out the decl,\n \t and we do it *after* the record is laid out.  */\n \n-      if (TREE_STATIC (field))\n+      if (TREE_CODE (field) == VAR_DECL)\n \t{\n \t  pending_statics = tree_cons (NULL_TREE, field, pending_statics);\n \t  continue;"}, {"sha": "96fa07a15b69a537c04c432fd6e2981f0c7c0926", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a082c85a4365cc2a9b73ecc6547075d3c352d46c", "patch": "@@ -2752,12 +2752,8 @@ rest_of_type_compilation (type, toplev)\n     TIMEVAR (symout_time, sdbout_symbol (TYPE_STUB_DECL (type), !toplev));\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n-  /* If this is a file-scope type or a class-scope type\n-     for which the containing class has already been completed, write it\n-     out now to avoid ordering headaches with member functions.  */\n-  if (write_symbols == DWARF_DEBUG\n-      && (TYPE_CONTEXT (type) == NULL_TREE\n-\t  || TREE_ASM_WRITTEN (TYPE_CONTEXT (type))))\n+  /* Don't write out function-scope types here.  */\n+  if (write_symbols == DWARF_DEBUG && toplev)\n     TIMEVAR (symout_time, dwarfout_file_scope_decl (TYPE_STUB_DECL (type), 0));\n #endif\n }"}, {"sha": "8ba266a4efaffaa32a6c1ca7ac6f6f35c9553b5e", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=a082c85a4365cc2a9b73ecc6547075d3c352d46c", "patch": "@@ -208,7 +208,9 @@ DEFTREECODE (SET_TYPE, \"set_type\", \"t\", 0)\n \n /* Struct in C, or record in Pascal.  */\n /* Special fields:\n-   TYPE_FIELDS  chain of FIELD_DECLs for the fields of the struct.\n+   TYPE_FIELDS  chain of FIELD_DECLs for the fields of the struct,\n+     and VAR_DECLs, TYPE_DECLs and CONST_DECLs for record-scope variables,\n+     types and enumerators.\n    A few may need to be added for Pascal.  */\n /* See the comment above, before ENUMERAL_TYPE, for how\n    forward references to struct tags are handled in C.  */\n@@ -271,9 +273,9 @@ DEFTREECODE (STRING_CST, \"string_cst\", \"c\", 3)\n     this declaration has its scope.  For FIELD_DECLs, this is the\n     RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field\n     is a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n-    and CONST_DECL nodes, this points to the FUNCTION_DECL for the\n-    containing function, or else yields NULL_TREE if the given decl\n-    has \"file scope\".\n+    and CONST_DECL nodes, this points to either the FUNCTION_DECL for the\n+    containing function, the RECORD_TYPE or UNION_TYPE for the containing\n+    type, or NULL_TREE if the given decl has \"file scope\".\n    DECL_ABSTRACT_ORIGIN, if non-NULL, points to the original (abstract)\n     ..._DECL node of which this decl is an (inlined or template expanded)\n     instance."}, {"sha": "a89ae508382dff464303ae5c5a8fdbc09ec8667b", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a082c85a4365cc2a9b73ecc6547075d3c352d46c", "patch": "@@ -880,8 +880,9 @@ struct tree_type\n /*  For FIELD_DECLs, this is the\n     RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field is\n     a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n-    and CONST_DECL nodes, this points to the FUNCTION_DECL for the\n-    containing function, or else yields NULL_TREE if the given decl has \"file scope\".  */\n+    and CONST_DECL nodes, this points to either the FUNCTION_DECL for the\n+    containing function, the RECORD_TYPE or UNION_TYPE for the containing\n+    type, or NULL_TREE if the given decl has \"file scope\".  */\n #define DECL_CONTEXT(NODE) ((NODE)->decl.context)\n #define DECL_FIELD_CONTEXT(NODE) ((NODE)->decl.context)\n /* In a DECL this is the field where configuration dependent machine"}, {"sha": "e7a566359ad6ad957a86984490e8b5f72f3b4b2c", "filename": "gcc/varasm.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a082c85a4365cc2a9b73ecc6547075d3c352d46c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a082c85a4365cc2a9b73ecc6547075d3c352d46c", "patch": "@@ -1174,16 +1174,21 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t\t see comment in compile_file.  */\n \t      && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n \t    sdbout_symbol (decl, 0);\n+#endif\n+#ifdef DWARF_DEBUGGING_INFO\n+\t  if (write_symbols == DWARF_DEBUG && top_level\n+\t      && DECL_CONTEXT (decl))\n+\t    dwarfout_file_scope_decl (decl, 0);\n #endif\n \t}\n \n-      /* Don't output any DWARF debugging information for variables here.\n-\t In the case of local variables, the information for them is output\n-\t when we do our recursive traversal of the tree representation for\n-\t the entire containing function.  In the case of file-scope variables,\n-\t we output information for all of them at the very end of compilation\n-\t while we are doing our final traversal of the chain of file-scope\n-\t declarations.  */\n+      /* Only output DWARF debugging information for record-scope variables\n+\t here.  In the case of function-scope variables, the information\n+\t for them is output when we do our recursive traversal of the tree\n+\t representation for the entire containing function.  In the case of\n+\t file-scope variables, we output information for all of them at the\n+\t very end of compilation while we are doing our final traversal of\n+\t the chain of file-scope declarations.  */\n \n       return;\n     }\n@@ -1298,14 +1303,19 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t  && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n \tsdbout_symbol (decl, 0);\n #endif\n+#ifdef DWARF_DEBUGGING_INFO\n+      if (write_symbols == DWARF_DEBUG && top_level\n+\t  && DECL_CONTEXT (decl))\n+\tdwarfout_file_scope_decl (decl, 0);\n+#endif\n \n-      /* Don't output any DWARF debugging information for variables here.\n-\t In the case of local variables, the information for them is output\n-\t when we do our recursive traversal of the tree representation for\n-\t the entire containing function.  In the case of file-scope variables,\n-\t we output information for all of them at the very end of compilation\n-\t while we are doing our final traversal of the chain of file-scope\n-\t declarations.  */\n+      /* Only output DWARF debugging information for record-scope variables\n+\t here.  In the case of function-scope variables, the information\n+\t for them is output when we do our recursive traversal of the tree\n+\t representation for the entire containing function.  In the case of\n+\t file-scope variables, we output information for all of them at the\n+\t very end of compilation while we are doing our final traversal of\n+\t the chain of file-scope declarations.  */\n \n #if 0 /* ??? We should either delete this or add a comment describing what\n \t it was intended to do and why we shouldn't delete it.  */"}]}