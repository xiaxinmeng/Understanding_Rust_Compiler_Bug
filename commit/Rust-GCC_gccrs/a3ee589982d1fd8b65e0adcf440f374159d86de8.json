{"sha": "a3ee589982d1fd8b65e0adcf440f374159d86de8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNlZTU4OTk4MmQxZmQ4YjY1ZTBhZGNmNDQwZjM3NDE1OWQ4NmRlOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-14T17:46:57Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-14T17:46:57Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r742", "tree": {"sha": "1dd3553444dcdf00926189b16c77a3f99f79c394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dd3553444dcdf00926189b16c77a3f99f79c394"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3ee589982d1fd8b65e0adcf440f374159d86de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ee589982d1fd8b65e0adcf440f374159d86de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ee589982d1fd8b65e0adcf440f374159d86de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ee589982d1fd8b65e0adcf440f374159d86de8/comments", "author": null, "committer": null, "parents": [{"sha": "f24ec84c7b8cb5bb59e7b0e7e73b2c8107fb6b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24ec84c7b8cb5bb59e7b0e7e73b2c8107fb6b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24ec84c7b8cb5bb59e7b0e7e73b2c8107fb6b5c"}], "stats": {"total": 264, "additions": 164, "deletions": 100}, "files": [{"sha": "897cdec69efff29ff0160b0cfa58c0dcf699858e", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=a3ee589982d1fd8b65e0adcf440f374159d86de8", "patch": "@@ -1613,7 +1613,8 @@ yylex ()\n \t\telse if (TREE_UNSIGNED (traditional_type)\n \t\t\t != TREE_UNSIGNED (ansi_type))\n \t\t  warning (\"integer constant is unsigned in ANSI C, signed with -traditional\");\n-\t\telse abort ();\n+\t\telse\n+\t\t  warning (\"width of integer constant may change on other systems with -traditional\");\n \t      }\n #endif\n "}, {"sha": "83a3a1a8a37c59b260976dfe89b556afe9b763a0", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 38, "deletions": 85, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a3ee589982d1fd8b65e0adcf440f374159d86de8", "patch": "@@ -1048,63 +1048,53 @@ output_move_double (operands)\n       || (optype0 != REGOP && optype0 != CNSTOP && optype1 == REGOP\n \t  && (REGNO (operands[1]) & 1) == 0))\n     {\n-      rtx op1, op2;\n-      rtx base = 0, offset = const0_rtx;\n+      rtx addr;\n+      rtx base, offset;\n \n-      /* OP1 gets the register pair, and OP2 gets the memory address.  */\n       if (optype0 == REGOP)\n-\top1 = operands[0], op2 = operands[1];\n+\taddr = operands[1];\n       else\n-\top1 = operands[1], op2 = operands[0];\n+\taddr = operands[0];\n \n-      /* Now see if we can trust the address to be 8-byte aligned.  */\n-      /* Trust double-precision floats in global variables.  */\n+      /* Now see if we can trust the address to be 8-byte aligned.\n+\t Trust double-precision floats in global variables.  */\n \n-      if (GET_CODE (XEXP (op2, 0)) == LO_SUM && GET_MODE (op2) == DFmode)\n-\t{\n-\t  if (final_sequence)\n-\t    abort ();\n-\t  return (op1 == operands[0] ? \"ldd %1,%0\" : \"std %1,%0\");\n-\t}\n+      if (GET_CODE (XEXP (addr, 0)) == LO_SUM && GET_MODE (addr) == DFmode)\n+\treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n \n-      if (GET_CODE (XEXP (op2, 0)) == PLUS)\n+      base = 0;\n+      if (GET_CODE (XEXP (addr, 0)) == PLUS)\n \t{\n-\t  rtx temp = XEXP (op2, 0);\n-\t  if (GET_CODE (XEXP (temp, 0)) == REG)\n+\t  rtx temp = XEXP (addr, 0);\n+\t  if (GET_CODE (XEXP (temp, 0)) == REG\n+\t      && GET_CODE (XEXP (temp, 1)) == CONST_INT)\n \t    base = XEXP (temp, 0), offset = XEXP (temp, 1);\n-\t  else if (GET_CODE (XEXP (temp, 1)) == REG)\n-\t    base = XEXP (temp, 1), offset = XEXP (temp, 0);\n \t}\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\tbase = XEXP (addr, 0), offset = const0_rtx;\n \n-      /* Trust round enough offsets from the stack or frame pointer.  */\n+      /* Trust round enough offsets from the stack or frame pointer.\n+\t If TARGET_HOPE_ALIGN, trust round enough offset from any register\n+\t for DFmode loads.  If it is obviously unaligned, don't ever\n+\t generate ldd or std.  */\n       if (base\n \t  && (REGNO (base) == FRAME_POINTER_REGNUM\n-\t      || REGNO (base) == STACK_POINTER_REGNUM))\n+\t      || REGNO (base) == STACK_POINTER_REGNUM\n+\t      || (TARGET_HOPE_ALIGN && GET_MODE (addr) == DFmode)))\n \t{\n-\t  if (GET_CODE (offset) == CONST_INT\n-\t      && (INTVAL (offset) & 0x7) == 0)\n-\t    {\n-\t      if (op1 == operands[0])\n-\t\treturn \"ldd %1,%0\";\n-\t      else\n-\t\treturn \"std %1,%0\";\n-\t    }\n+\t  if ((INTVAL (offset) & 0x7) == 0)\n+\t    return (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n \t}\n       /* We know structs not on the stack are properly aligned.  Since a\n \t double asks for 8-byte alignment, we know it must have got that\n \t if it is in a struct.  But a DImode need not be 8-byte aligned,\n-\t because it could be a struct containing two ints or pointers.  */\n-      else if (GET_CODE (operands[1]) == MEM\n-\t       && GET_MODE (operands[1]) == DFmode\n-\t       && (CONSTANT_P (XEXP (operands[1], 0))\n-\t\t   /* Let user ask for it anyway.  */\n-\t\t   || TARGET_HOPE_ALIGN))\n-\treturn \"ldd %1,%0\";\n-      else if (GET_CODE (operands[0]) == MEM\n-\t       && GET_MODE (operands[0]) == DFmode\n-\t       && (CONSTANT_P (XEXP (operands[0], 0))\n-\t\t   || TARGET_HOPE_ALIGN))\n-\treturn \"std %1,%0\";\n+\t because it could be a struct containing two ints or pointers.\n+\t Hence, a constant DFmode address will always be 8-byte aligned.\n+\t If TARGET_HOPE_ALIGN, then assume all doubles are aligned even if this\n+\t is not a constant address.  */\n+      else if (GET_CODE (addr) == MEM && GET_MODE (addr) == DFmode\n+\t       && (CONSTANT_P (addr) || TARGET_HOPE_ALIGN))\n+\treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n     }\n \n   if (optype0 == REGOP && optype1 == REGOP\n@@ -1159,6 +1149,9 @@ output_move_double (operands)\n   return \"\";\n }\n \f\n+/* Output assembler code to perform a doubleword move insn with perands\n+   OPERANDS, one of which must be a floating point register.  */\n+\n char *\n output_fp_move_double (operands)\n      rtx *operands;\n@@ -1169,35 +1162,15 @@ output_fp_move_double (operands)\n     {\n       if (FP_REG_P (operands[1]))\n \treturn \"fmovs %1,%0\\n\\tfmovs %R1,%R0\";\n-      if (GET_CODE (operands[1]) == REG)\n+      else if (GET_CODE (operands[1]) == REG)\n \t{\n \t  if ((REGNO (operands[1]) & 1) == 0)\n \t    return \"std %1,[%@-8]\\n\\tldd [%@-8],%0\";\n \t  else\n \t    return \"st %R1,[%@-4]\\n\\tst %1,[%@-8]\\n\\tldd [%@-8],%0\";\n \t}\n-      addr = XEXP (operands[1], 0);\n-\n-      /* Use ldd if known to be aligned.  */\n-      if (TARGET_HOPE_ALIGN\n-\t  || (GET_CODE (addr) == PLUS\n-\t      && (((XEXP (addr, 0) == frame_pointer_rtx\n-\t\t    || XEXP (addr, 0) == stack_pointer_rtx)\n-\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t   && (INTVAL (XEXP (addr, 1)) & 0x7) == 0)\n-\t\t  /* Arrays are known to be aligned,\n-\t\t     and reg+reg addresses are used (on this machine)\n-\t\t     only for array accesses.  */\n-\t\t  || (REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))))\n-\t  || (GET_MODE (operands[0]) == DFmode\n-\t      && (GET_CODE (addr) == LO_SUM || CONSTANT_P (addr))))\n-\treturn \"ldd %1,%0\";\n-\n-      /* Otherwise use two ld insns.  */\n-      operands[2]\n-\t= gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t   plus_constant_for_output (addr, 4));\n-\treturn \"ld %1,%0\\n\\tld %2,%R0\";\n+      else\n+\treturn output_move_double (operands);\n     }\n   else if (FP_REG_P (operands[1]))\n     {\n@@ -1208,28 +1181,8 @@ output_fp_move_double (operands)\n \t  else\n \t    return \"std %1,[%@-8]\\n\\tld [%@-4],%R0\\n\\tld [%@-8],%0\";\n \t}\n-      addr = XEXP (operands[0], 0);\n-\n-      /* Use std if we can be sure it is well-aligned.  */\n-      if (TARGET_HOPE_ALIGN\n-\t  || (GET_CODE (addr) == PLUS\n-\t      && (((XEXP (addr, 0) == frame_pointer_rtx\n-\t\t    || XEXP (addr, 0) == stack_pointer_rtx)\n-\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t\t   && (INTVAL (XEXP (addr, 1)) & 0x7) == 0)\n-\t\t  /* Arrays are known to be aligned,\n-\t\t     and reg+reg addresses are used (on this machine)\n-\t\t     only for array accesses.  */\n-\t\t  || (REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))))\n-\t  || (GET_MODE (operands[1]) == DFmode\n-\t      && (GET_CODE (addr) == LO_SUM || CONSTANT_P (addr))))\n-\treturn \"std %1,%0\";\n-\n-      /* Otherwise use two st insns.  */\n-      operands[2]\n-\t= gen_rtx (MEM, GET_MODE (operands[0]),\n-\t\t   plus_constant_for_output (addr, 4));\n-      return \"st %r1,%0\\n\\tst %R1,%2\";\n+      else\n+\treturn output_move_double (operands);\n     }\n   else abort ();\n }"}, {"sha": "2693c171205d18da2afdf6255badaaf4c482f842", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=a3ee589982d1fd8b65e0adcf440f374159d86de8", "patch": "@@ -1402,6 +1402,92 @@\n }\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"3\")])\n+\n+;; Allow combiner to combine a fix_truncdfsi2 with a floatsidf2\n+;; This eliminates 2 useless instructions.\n+;; The first one matches if the fixed result is needed.  The second one\n+;; matches if the fixed result is not needed.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(float:DF (fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\")))))\n+   (set (match_operand:SI 2 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:DF (match_dup 1))))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fdtoi %1,%0\\\", operands);\n+  else\n+    {\n+      output_asm_insn (output_fp_move_double (operands), operands);\n+      output_asm_insn (\\\"fdtoi %0,%0\\\", operands);\n+    }\n+  if (GET_CODE (operands[2]) == MEM)\n+    return \\\"st %0,%2\\;fitod %0,%0\\\";\n+  else\n+    return \\\"st %0,[%%fp-4]\\;fitod %0,%0\\;ld [%%fp-4],%2\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"5\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(float:DF (fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\")))))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fdtoi %1,%0\\\", operands);\n+  else\n+    {\n+      output_asm_insn (output_fp_move_double (operands), operands);\n+      output_asm_insn (\\\"fdtoi %0,%0\\\", operands);\n+    }\n+  return \\\"fitod %0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n+\n+;; Allow combiner to combine a fix_truncsfsi2 with a floatsisf2\n+;; This eliminates 2 useless instructions.\n+;; The first one matches if the fixed result is needed.  The second one\n+;; matches if the fixed result is not needed.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(float:SF (fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\")))))\n+   (set (match_operand:SI 2 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:SF (match_dup 1))))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fstoi %1,%0\\\", operands);\n+  else\n+    output_asm_insn (\\\"ld %1,%0\\;fstoi %0,%0\\\", operands);\n+  if (GET_CODE (operands[2]) == MEM)\n+    return \\\"st %0,%2\\;fitos %0,%0\\\";\n+  else\n+    return \\\"st %0,[%%fp-4]\\;fitos %0,%0\\;ld [%%fp-4],%2\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"5\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(float:SF (fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\")))))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[1]))\n+    output_asm_insn (\\\"fstoi %1,%0\\\", operands);\n+  else\n+    output_asm_insn (\\\"ld %1,%0\\;fstoi %0,%0\\\", operands);\n+  return \\\"fitos %0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"length\" \"3\")])\n \f\n ;;- arithmetic instructions\n "}, {"sha": "dee61522db3da864604b075dca6fd0b3d407324b", "filename": "gcc/rtl.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a3ee589982d1fd8b65e0adcf440f374159d86de8", "patch": "@@ -383,21 +383,39 @@ add_dependence (insn, elem, dep_type)\n      rtx elem;\n      enum reg_note dep_type;\n {\n-  rtx link;\n+  rtx link, next;\n \n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n     return;\n \n   /* If elem is part of a sequence that must be scheduled together, then\n-     make the dependence point to the last insn of the sequence.  */\n-  if (NEXT_INSN (elem) && SCHED_GROUP_P (NEXT_INSN (elem)))\n+     make the dependence point to the last insn of the sequence.\n+     When HAVE_cc0, it is possible for NOTEs to exist between users and\n+     setters of the condition codes, so we must skip past notes here.\n+     Otherwise, NOTEs are impossible here.  */\n+\n+  next = NEXT_INSN (elem);\n+\n+#ifdef HAVE_cc0\n+  while (next && GET_CODE (next) == NOTE)\n+    next = NEXT_INSN (next);\n+#endif\n+\n+  if (next && SCHED_GROUP_P (next))\n     {\n-      while (NEXT_INSN (elem) && SCHED_GROUP_P (NEXT_INSN (elem)))\n-\telem = NEXT_INSN (elem);\n-      /* Again, don't depend an insn of itself.  */\n-      if (insn == elem)\n+      /* Notes will never intervene here though, so don't bother checking\n+\t for them.  */\n+      while (next && SCHED_GROUP_P (next))\n+\tnext = NEXT_INSN (next);\n+\n+      /* Again, don't depend an insn on itself.  */\n+      if (insn == next)\n \treturn;\n+\n+      /* Make the dependence to NEXT, the last insn of the group, instead\n+\t of the original ELEM.  */\n+      elem = next;\n     }\n \n   /* Check that we don't already have this dependence.  */"}, {"sha": "2a391e5c61698eae74f61d33a0b3df3cff216221", "filename": "gcc/sched.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ee589982d1fd8b65e0adcf440f374159d86de8/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=a3ee589982d1fd8b65e0adcf440f374159d86de8", "patch": "@@ -1214,18 +1214,24 @@ sched_analyze_2 (x, insn)\n #ifdef HAVE_cc0\n     case CC0:\n       {\n-\trtx link;\n+\trtx link, prev;\n \n-\t/* User of CC0 depends on immediately preceding insn.\n-\t   There may be a note before this insn now, but all notes will\n+\t/* There may be a note before this insn now, but all notes will\n \t   be removed before we actually try to schedule the insns, so\n-\t   it doesn't matter.  */\n+\t   it won't cause a problem later.  We must avoid it here though.  */\n+\n+\t/* User of CC0 depends on immediately preceding insn.\n \tSCHED_GROUP_P (insn) = 1;\n \n-\t/* Make a copy of all dependencies on PREV_INSN, and add to this insn.\n-\t   This is so that all the dependencies will apply to the group.  */\n+\t/* Make a copy of all dependencies on the immediately previous insn,\n+\t   and add to this insn.  This is so that all the dependencies will\n+\t   apply to the group.  */\n+\n+\tprev = PREV_INSN (insn);\n+\twhile (GET_CODE (prev) == NOTE)\n+\t  prev = PREV_INSN (prev);\n \n-\tfor (link = LOG_LINKS (PREV_INSN (insn)); link; link = XEXP (link, 1))\n+\tfor (link = LOG_LINKS (prev); link; link = XEXP (link, 1))\n \t  add_dependence (insn, XEXP (link, 0), GET_MODE (link));\n \n \treturn;"}]}