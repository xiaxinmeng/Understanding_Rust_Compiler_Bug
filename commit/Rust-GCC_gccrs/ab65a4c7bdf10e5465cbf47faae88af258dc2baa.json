{"sha": "ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2NWE0YzdiZGYxMGU1NDY1Y2JmNDdmYWFlODhhZjI1OGRjMmJhYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-02-10T19:14:33Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-02-10T19:14:33Z"}, "message": "hashtable.h: Fold in include/tr1_impl/hashtable.h contents.\n\n2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/tr1/hashtable.h: Fold in include/tr1_impl/hashtable.h\n\tcontents.\n\t* include/tr1_impl/hashtable.h: Remove.\n\t* include/tr1_impl/hashtable_policy.h: Move and rename...\n\t* include/tr1/hashtable_policy.h: ... here.\n\t* include/tr1_impl/unordered_map: Move and rename...\n\t* include/tr1/unordered_map.h: ... here.\n\t* include/tr1_impl/unordered_set: Move and rename...\n\t* include/tr1/unordered_set.h: ... here.\n\t* include/tr1_impl/unordered_map: Move and rename...\n\t* include/tr1/unordered_map.h: ... here.\n\t* include/tr1/unordered_map: Adjust.\n\t* include/tr1/unordered_set: Likewise.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\n\t* include/std/c++0x_warning.h: Move...\n\t* include/bits/c++0x_warning.h: ... here.\n\t* include/debug/unordered_map: Adjust.\n\t* include/debug/unordered_set: Likewise.\n\t* include/std/tuple: Likewise.\n\t* include/std/system_error: Likewise.\n\t* include/std/forward_list: Likewise.\n\t* include/std/thread: Likewise.\n\t* include/std/type_traits: Likewise.\n\t* include/std/future: Likewise.\n\t* include/std/regex: Likewise.\n\t* include/std/atomic: Likewise.\n\t* include/std/ratio: Likewise.\n\t* include/std/random: Likewise.\n\t* include/std/unordered_map: Likewise.\n\t* include/std/chrono: Likewise.: Likewise.\n\t* include/std/condition_variable: Likewise.\n\t* include/std/mutex: Likewise.\n\t* include/std/unordered_set: Likewise.\n\t* include/std/array: Likewise.\n\t* include/profile/unordered_map: Likewise.\n\t* include/profile/unordered_set: Likewise.\n\t* include/c_global/cinttypes: Likewise.\n\t* include/c_global/ctgmath: Likewise.\n\t* include/c_global/cfenv: Likewise.\n\t* include/c_global/cstdint: Likewise.\n\t* include/c_global/cstdbool: Likewise.\n\t* include/c_global/ccomplex: Likewise.\n\n\t* include/bits/shared_ptr.h: Do not include <bits/c++0x_warning.h>\n\tat all, the file is not meant to be included by the users.\n\t* include/bits/functional_hash.h: Likewise.\n\t* include/bits/unique_ptr.h: Likewise.\n\t* include/bits/forward_list.h: Likewise.\n\n\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Adjust dg-*\n\tline numbers.\n\t* testsuite/29_atomics/atomic/cons/copy_neg.cc: Likewise.\n\t* testsuite/23_containers/forward_list/requirements/dr438/\n\tassign_neg.cc: Likewise.\n\t* testsuite/23_containers/forward_list/requirements/dr438/\n\tinsert_neg.cc: Likewise.\n\t* testsuite/23_containers/forward_list/requirements/dr438/\n\tconstructor_1_neg.cc: Likewise.\n\t* testsuite/23_containers/forward_list/requirements/dr438/\n\tconstructor_2_neg.cc: Likewise.\n\t* testsuite/20_util/unique_ptr/modifiers/reset_neg.cc: Likewise.\n\t* testsuite/20_util/unique_ptr/assign/assign_neg.cc: Likewise.\n\nFrom-SVN: r156667", "tree": {"sha": "894eaf852a153a2f29bed99633ed518bdd08ae89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894eaf852a153a2f29bed99633ed518bdd08ae89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/comments", "author": null, "committer": null, "parents": [{"sha": "5418fe84c2377f7bff650c946fe8d667947b5984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5418fe84c2377f7bff650c946fe8d667947b5984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5418fe84c2377f7bff650c946fe8d667947b5984"}], "stats": {"total": 2654, "additions": 1318, "deletions": 1336}, "files": [{"sha": "0420fd425f0c8f5f0a535cf953a0c3895408dd47", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,3 +1,70 @@\n+2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/tr1/hashtable.h: Fold in include/tr1_impl/hashtable.h\n+\tcontents.\n+\t* include/tr1_impl/hashtable.h: Remove.\n+\t* include/tr1_impl/hashtable_policy.h: Move and rename...\n+\t* include/tr1/hashtable_policy.h: ... here.\n+\t* include/tr1_impl/unordered_map: Move and rename...\n+\t* include/tr1/unordered_map.h: ... here.\n+\t* include/tr1_impl/unordered_set: Move and rename...\n+\t* include/tr1/unordered_set.h: ... here.\n+\t* include/tr1_impl/unordered_map: Move and rename...\n+\t* include/tr1/unordered_map.h: ... here.\n+\t* include/tr1/unordered_map: Adjust.\n+\t* include/tr1/unordered_set: Likewise.\n+\t* include/Makefile.am: Adjust.\n+\t* include/Makefile.in: Regenerate.\n+\n+\t* include/std/c++0x_warning.h: Move...\n+\t* include/bits/c++0x_warning.h: ... here.\n+\t* include/debug/unordered_map: Adjust.\n+\t* include/debug/unordered_set: Likewise.\n+\t* include/std/tuple: Likewise.\n+\t* include/std/system_error: Likewise.\n+\t* include/std/forward_list: Likewise.\n+\t* include/std/thread: Likewise.\n+\t* include/std/type_traits: Likewise.\n+\t* include/std/future: Likewise.\n+\t* include/std/regex: Likewise.\n+\t* include/std/atomic: Likewise.\n+\t* include/std/ratio: Likewise.\n+\t* include/std/random: Likewise.\n+\t* include/std/unordered_map: Likewise.\n+\t* include/std/chrono: Likewise.: Likewise.\n+\t* include/std/condition_variable: Likewise.\n+\t* include/std/mutex: Likewise.\n+\t* include/std/unordered_set: Likewise.\n+\t* include/std/array: Likewise.\n+\t* include/profile/unordered_map: Likewise.\n+\t* include/profile/unordered_set: Likewise.\n+\t* include/c_global/cinttypes: Likewise.\n+\t* include/c_global/ctgmath: Likewise.\n+\t* include/c_global/cfenv: Likewise.\n+\t* include/c_global/cstdint: Likewise.\n+\t* include/c_global/cstdbool: Likewise.\n+\t* include/c_global/ccomplex: Likewise.\n+\n+\t* include/bits/shared_ptr.h: Do not include <bits/c++0x_warning.h>\n+\tat all, the file is not meant to be included by the users.\n+\t* include/bits/functional_hash.h: Likewise.\n+\t* include/bits/unique_ptr.h: Likewise.\n+\t* include/bits/forward_list.h: Likewise.\n+\n+\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Adjust dg-*\n+\tline numbers.\n+\t* testsuite/29_atomics/atomic/cons/copy_neg.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/requirements/dr438/\n+\tassign_neg.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/requirements/dr438/\n+\tinsert_neg.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/requirements/dr438/\n+\tconstructor_1_neg.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/requirements/dr438/\n+\tconstructor_2_neg.cc: Likewise.\n+\t* testsuite/20_util/unique_ptr/modifiers/reset_neg.cc: Likewise.\n+\t* testsuite/20_util/unique_ptr/assign/assign_neg.cc: Likewise.\n+\n 2010-02-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/bits/hashtable.h: Fold in include/tr1_impl/hashtable.h"}, {"sha": "23aad14692cf76b4296c8b367cdb1d229fa2e0de", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -31,7 +31,6 @@ std_headers = \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n \t${std_srcdir}/bitset \\\n-\t${std_srcdir}/c++0x_warning.h \\\n \t${std_srcdir}/chrono \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n@@ -89,6 +88,7 @@ bits_headers = \\\n \t${bits_srcdir}/basic_string.h \\\n \t${bits_srcdir}/basic_string.tcc \\\n \t${bits_srcdir}/boost_concept_check.h \\\n+\t${bits_srcdir}/c++0x_warning.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n@@ -569,6 +569,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/gamma.tcc \\\n \t${tr1_srcdir}/hypergeometric.tcc \\\n \t${tr1_srcdir}/hashtable.h \\\n+\t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n@@ -592,8 +593,10 @@ tr1_headers = \\\n \t${tr1_srcdir}/tgmath.h \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/type_traits \\\n-\t${tr1_srcdir}/unordered_set \\\n \t${tr1_srcdir}/unordered_map \\\n+\t${tr1_srcdir}/unordered_map.h \\\n+\t${tr1_srcdir}/unordered_set \\\n+\t${tr1_srcdir}/unordered_set.h \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/wchar.h \\\n \t${tr1_srcdir}/wctype.h\n@@ -614,12 +617,8 @@ tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/cstdlib \\\n \t${tr1_impl_srcdir}/cwchar \\\n \t${tr1_impl_srcdir}/cwctype \\\n-\t${tr1_impl_srcdir}/hashtable \\\n-\t${tr1_impl_srcdir}/hashtable_policy.h \\\n \t${tr1_impl_srcdir}/regex \\\n \t${tr1_impl_srcdir}/type_traits \\\n-\t${tr1_impl_srcdir}/unordered_map \\\n-\t${tr1_impl_srcdir}/unordered_set \\\n \t${tr1_impl_srcdir}/utility\n \n decimal_srcdir = ${glibcxx_srcdir}/include/decimal"}, {"sha": "d4954ae058ccd0319b56665d2e7c129c5a285dd8", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -273,7 +273,6 @@ std_headers = \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n \t${std_srcdir}/bitset \\\n-\t${std_srcdir}/c++0x_warning.h \\\n \t${std_srcdir}/chrono \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n@@ -331,6 +330,7 @@ bits_headers = \\\n \t${bits_srcdir}/basic_string.h \\\n \t${bits_srcdir}/basic_string.tcc \\\n \t${bits_srcdir}/boost_concept_check.h \\\n+\t${bits_srcdir}/c++0x_warning.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n@@ -809,6 +809,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/gamma.tcc \\\n \t${tr1_srcdir}/hypergeometric.tcc \\\n \t${tr1_srcdir}/hashtable.h \\\n+\t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n@@ -832,8 +833,10 @@ tr1_headers = \\\n \t${tr1_srcdir}/tgmath.h \\\n \t${tr1_srcdir}/tuple \\\n \t${tr1_srcdir}/type_traits \\\n-\t${tr1_srcdir}/unordered_set \\\n \t${tr1_srcdir}/unordered_map \\\n+\t${tr1_srcdir}/unordered_map.h \\\n+\t${tr1_srcdir}/unordered_set \\\n+\t${tr1_srcdir}/unordered_set.h \\\n \t${tr1_srcdir}/utility \\\n \t${tr1_srcdir}/wchar.h \\\n \t${tr1_srcdir}/wctype.h\n@@ -853,12 +856,8 @@ tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/cstdlib \\\n \t${tr1_impl_srcdir}/cwchar \\\n \t${tr1_impl_srcdir}/cwctype \\\n-\t${tr1_impl_srcdir}/hashtable \\\n-\t${tr1_impl_srcdir}/hashtable_policy.h \\\n \t${tr1_impl_srcdir}/regex \\\n \t${tr1_impl_srcdir}/type_traits \\\n-\t${tr1_impl_srcdir}/unordered_map \\\n-\t${tr1_impl_srcdir}/unordered_set \\\n \t${tr1_impl_srcdir}/utility\n \n decimal_srcdir = ${glibcxx_srcdir}/include/decimal"}, {"sha": "b74f3396c1d5dce1a9f2284ceda89c063c9df875", "filename": "libstdc++-v3/include/bits/c++0x_warning.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2B0x_warning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2B0x_warning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2B0x_warning.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "previous_filename": "libstdc++-v3/include/std/c++0x_warning.h"}, {"sha": "277e3790ebc88979c6e25a06b66d4788cb789928", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -31,10 +31,6 @@\n \n #pragma GCC system_header\n \n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n-#else\n-\n #include <memory>\n #include <initializer_list>\n #include <ext/cast.h>\n@@ -1282,6 +1278,4 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n _GLIBCXX_END_NAMESPACE // namespace std\n \n-#endif // __GXX_EXPERIMENTAL_CXX0X__\n-\n #endif // _FORWARD_LIST_H"}, {"sha": "02a3feb75ea62f4a05337f9ac8ce1a0054cdcd7e", "filename": "libstdc++-v3/include/bits/functional_hash.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctional_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctional_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffunctional_hash.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -32,10 +32,6 @@\n \n #pragma GCC system_header\n \n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n-#endif\n-\n #include <string>\n #include <system_error>\n "}, {"sha": "8119ad3e1f04a99fe7477f24912a7d735394b997", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // shared_ptr and weak_ptr implementation -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -49,10 +49,6 @@\n #ifndef _SHARED_PTR_H\n #define _SHARED_PTR_H 1\n \n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n-#endif\n-\n #include <bits/shared_ptr_base.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)"}, {"sha": "9a34b0387cca713d27b430218cfdcda51f54f632", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // unique_ptr implementation -*- C++ -*-\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -30,10 +30,6 @@\n #ifndef _UNIQUE_PTR_H\n #define _UNIQUE_PTR_H 1\n \n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n-#endif\n-\n #include <bits/c++config.h>\n #include <debug/debug.h>\n #include <type_traits>"}, {"sha": "b1117e8d42eafe4c123a659414f30d7d16d2c2f9", "filename": "libstdc++-v3/include/c_global/ccomplex", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fccomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fccomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fccomplex?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <ccomplex> -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #define _GLIBCXX_CCOMPLEX 1\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "4e401411767bac56f12645c36d4ed9bacfb65e6d", "filename": "libstdc++-v3/include/c_global/cfenv", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfenv?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <cfenv> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "d8de5ee5c9296b4c2fc0b00c70b2faf369283176", "filename": "libstdc++-v3/include/c_global/cinttypes", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcinttypes?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <cinttypes> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "dd428f2d288feceddb740a44c5bf4e089d9876e0", "filename": "libstdc++-v3/include/c_global/cstdbool", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdbool", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdbool", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdbool?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <cstdbool> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #define _GLIBCXX_CSTDBOOL 1\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-#  include <c++0x_warning.h>\n+#  include <bits/c++0x_warning.h>\n #else\n #  include <bits/c++config.h>\n #  if _GLIBCXX_HAVE_STDBOOL_H"}, {"sha": "28e449cff81772eda21c433b21fde9f8b38ad81a", "filename": "libstdc++-v3/include/c_global/cstdint", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdint?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <cstdint> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "6b51005cc112a537bbe57061bb72fcba532190a8", "filename": "libstdc++-v3/include/c_global/ctgmath", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctgmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctgmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctgmath?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <ctgmath> -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #define _GLIBCXX_CTGMATH 1\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-#  include <c++0x_warning.h>\n+#  include <bits/c++0x_warning.h>\n #else\n #  include <cmath>\n #endif"}, {"sha": "a5e6174fe6ae010232acb504b382f31dc97a850b", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -33,7 +33,7 @@\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n # include <unordered_map>\n #else\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #include <debug/safe_sequence.h>"}, {"sha": "f8517184023873d26e0f5af0bfdc27ba77614744", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -33,7 +33,7 @@\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n # include <unordered_set>\n #else\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #include <debug/safe_sequence.h>"}, {"sha": "b90d58b5ab6cc958956a96b3684adc8b297b2c7e", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -39,7 +39,7 @@\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n # include <unordered_map>\n #else\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #include <initializer_list>"}, {"sha": "128cf602b45a9256366c6c962f859c1dc25db749", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -39,7 +39,7 @@\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n # include <unordered_set>\n #else\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #include <initializer_list>"}, {"sha": "d374c88a2b1d9c62a97a99722833dd3bc0a5442d", "filename": "libstdc++-v3/include/std/array", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <array> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "5ef52f3763f31f146c44355dc352023a3ba5b633", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,7 +1,6 @@\n // -*- C++ -*- header.\n \n-// Copyright (C) 2008, 2009\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,7 +35,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #endif\n \n #include <bits/atomic_base.h>"}, {"sha": "230b7f4e81321cea85597f3c5008de59415e1734", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <chrono> -*- C++ -*-\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #ifdef _GLIBCXX_INCLUDE_AS_TR1"}, {"sha": "c5ce207a9050b1ea120c38b7bd00fe71883729d9", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <chrono>"}, {"sha": "16fdcc283fff0fd0dfd5b38756f291bdf468d4c7", "filename": "libstdc++-v3/include/std/forward_list", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <forward_list> -*- C++ -*-\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <bits/forward_list.h>"}, {"sha": "1ef03643d045cf13144192faec78d96671f4141c", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <functional>"}, {"sha": "7a1e259fc7929e73f4b5c54609d8d36e94ee185e", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -33,7 +33,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <tuple>"}, {"sha": "4d330eedd9258461d45e85673394482fd5d88664", "filename": "libstdc++-v3/include/std/random", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Frandom?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <cmath>"}, {"sha": "e169d79e8a59cb5b5552fc9245fccc527a64e23b", "filename": "libstdc++-v3/include/std/ratio", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fratio?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // ratio -*- C++ -*-\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the \n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <type_traits>"}, {"sha": "e8238299b2253f24cb74e19de79688d69e528830", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <regex> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "0e8c69744e510f01ab4f6a110c574a2622176dd0", "filename": "libstdc++-v3/include/std/system_error", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <system_error> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <bits/c++config.h>"}, {"sha": "2d7a7513834365a67d3575b1fca6719e7a50e8f6", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <thread> -*- C++ -*-\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <chrono>"}, {"sha": "bba7ba7bd08963d30150711fe24d2ce4059d1747", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // <tuple> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <utility>"}, {"sha": "c8166198805854a87dbdcc7edbf1ebe893bd43c5", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // C++0x type_traits -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)"}, {"sha": "d8b94e2698c7406ef240b5fb90b9d2265702b2a7", "filename": "libstdc++-v3/include/std/unordered_map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_map?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <utility>"}, {"sha": "630ea9e99064546c9dcfa8d459be9a91e83a374a", "filename": "libstdc++-v3/include/std/unordered_set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Funordered_set?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -32,7 +32,7 @@\n #pragma GCC system_header\n \n #ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n+# include <bits/c++0x_warning.h>\n #else\n \n #include <utility>"}, {"sha": "5064b1fdddb2ecbb81590a8ebeb5a15e42de152d", "filename": "libstdc++-v3/include/tr1/hashtable.h", "status": "modified", "additions": 1141, "deletions": 18, "changes": 1159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // TR1 hashtable.h header -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,22 +32,1145 @@\n \n #pragma GCC system_header\n \n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  include <tr1_impl/hashtable>\n-#else\n-#  define _GLIBCXX_INCLUDE_AS_TR1\n-#  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n-#  define _GLIBCXX_END_NAMESPACE_TR1 }\n-#  define _GLIBCXX_TR1 tr1::\n-#  include <tr1_impl/hashtable>\n-#  undef _GLIBCXX_TR1\n-#  undef _GLIBCXX_END_NAMESPACE_TR1\n-#  undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n-#  undef _GLIBCXX_INCLUDE_AS_TR1\n-#endif\n+#include <tr1/hashtable_policy.h>\n+\n+namespace std\n+{ \n+namespace tr1\n+{\n+  // Class template _Hashtable, class definition.\n+  \n+  // Meaning of class template _Hashtable's template parameters\n+  \n+  // _Key and _Value: arbitrary CopyConstructible types.\n+  \n+  // _Allocator: an allocator type ([lib.allocator.requirements]) whose\n+  // value type is Value.  As a conforming extension, we allow for\n+  // value type != Value.\n+\n+  // _ExtractKey: function object that takes a object of type Value\n+  // and returns a value of type _Key.\n+  \n+  // _Equal: function object that takes two objects of type k and returns\n+  // a bool-like value that is true if the two objects are considered equal.\n+  \n+  // _H1: the hash function.  A unary function object with argument type\n+  // Key and result type size_t.  Return values should be distributed\n+  // over the entire range [0, numeric_limits<size_t>:::max()].\n+  \n+  // _H2: the range-hashing function (in the terminology of Tavori and\n+  // Dreizin).  A binary function object whose argument types and result\n+  // type are all size_t.  Given arguments r and N, the return value is\n+  // in the range [0, N).\n+  \n+  // _Hash: the ranged hash function (Tavori and Dreizin). A binary function\n+  // whose argument types are _Key and size_t and whose result type is\n+  // size_t.  Given arguments k and N, the return value is in the range\n+  // [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other\n+  // than the default, _H1 and _H2 are ignored.\n+  \n+  // _RehashPolicy: Policy class with three members, all of which govern\n+  // the bucket count. _M_next_bkt(n) returns a bucket count no smaller\n+  // than n.  _M_bkt_for_elements(n) returns a bucket count appropriate\n+  // for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)\n+  // determines whether, if the current bucket count is n_bkt and the\n+  // current element count is n_elt, we need to increase the bucket\n+  // count.  If so, returns make_pair(true, n), where n is the new\n+  // bucket count.  If not, returns make_pair(false, <anything>).\n+  \n+  // ??? Right now it is hard-wired that the number of buckets never\n+  // shrinks.  Should we allow _RehashPolicy to change that?\n+  \n+  // __cache_hash_code: bool.  true if we store the value of the hash\n+  // function along with the value.  This is a time-space tradeoff.\n+  // Storing it may improve lookup speed by reducing the number of times\n+  // we need to call the Equal function.\n+  \n+  // __constant_iterators: bool.  true if iterator and const_iterator are\n+  // both constant iterator types.  This is true for unordered_set and\n+  // unordered_multiset, false for unordered_map and unordered_multimap.\n+  \n+  // __unique_keys: bool.  true if the return value of _Hashtable::count(k)\n+  // is always at most one, false if it may be an arbitrary number.  This\n+  // true for unordered_set and unordered_map, false for unordered_multiset\n+  // and unordered_multimap.\n+  \n+  template<typename _Key, typename _Value, typename _Allocator,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, \n+\t   typename _RehashPolicy,\n+\t   bool __cache_hash_code,\n+\t   bool __constant_iterators,\n+\t   bool __unique_keys>\n+    class _Hashtable\n+    : public __detail::_Rehash_base<_RehashPolicy,\n+\t\t\t\t    _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t       _ExtractKey,\n+\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t       _RehashPolicy,\n+\t\t\t\t\t       __cache_hash_code,\n+\t\t\t\t\t       __constant_iterators,\n+\t\t\t\t\t       __unique_keys> >,\n+      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t       _H1, _H2, _Hash, __cache_hash_code>,\n+      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,\n+\t\t\t\t _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t\t    _ExtractKey,\n+\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t    _RehashPolicy,\n+\t\t\t\t\t    __cache_hash_code,\n+\t\t\t\t\t    __constant_iterators,\n+\t\t\t\t\t    __unique_keys> >\n+    {\n+    public:\n+      typedef _Allocator                                  allocator_type;\n+      typedef _Value                                      value_type;\n+      typedef _Key                                        key_type;\n+      typedef _Equal                                      key_equal;\n+      // mapped_type, if present, comes from _Map_base.\n+      // hasher, if present, comes from _Hash_code_base.\n+      typedef typename _Allocator::difference_type        difference_type;\n+      typedef typename _Allocator::size_type              size_type;\n+      typedef typename _Allocator::pointer                pointer;\n+      typedef typename _Allocator::const_pointer          const_pointer;\n+      typedef typename _Allocator::reference              reference;\n+      typedef typename _Allocator::const_reference        const_reference;\n+      \n+      typedef __detail::_Node_iterator<value_type, __constant_iterators,\n+\t\t\t\t       __cache_hash_code>\n+                                                          local_iterator;\n+      typedef __detail::_Node_const_iterator<value_type,\n+\t\t\t\t\t     __constant_iterators,\n+\t\t\t\t\t     __cache_hash_code>\n+                                                          const_local_iterator;\n+\n+      typedef __detail::_Hashtable_iterator<value_type, __constant_iterators,\n+\t\t\t\t\t    __cache_hash_code>\n+                                                          iterator;\n+      typedef __detail::_Hashtable_const_iterator<value_type,\n+\t\t\t\t\t\t  __constant_iterators,\n+\t\t\t\t\t\t  __cache_hash_code>\n+                                                          const_iterator;\n+\n+      template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,\n+\t       typename _Hashtable2>\n+        friend struct __detail::_Map_base;\n+\n+    private:\n+      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;\n+      typedef typename _Allocator::template rebind<_Node>::other\n+                                                        _Node_allocator_type;\n+      typedef typename _Allocator::template rebind<_Node*>::other\n+                                                        _Bucket_allocator_type;\n+\n+      typedef typename _Allocator::template rebind<_Value>::other\n+                                                        _Value_allocator_type;\n+\n+      _Node_allocator_type   _M_node_allocator;\n+      _Node**                _M_buckets;\n+      size_type              _M_bucket_count;\n+      size_type              _M_element_count;\n+      _RehashPolicy          _M_rehash_policy;\n+      \n+      _Node*\n+      _M_allocate_node(const value_type& __v);\n+  \n+      void\n+      _M_deallocate_node(_Node* __n);\n+  \n+      void\n+      _M_deallocate_nodes(_Node**, size_type);\n+\n+      _Node**\n+      _M_allocate_buckets(size_type __n);\n+  \n+      void\n+      _M_deallocate_buckets(_Node**, size_type __n);\n+\n+    public:\t\t\t    \n+      // Constructor, destructor, assignment, swap\n+      _Hashtable(size_type __bucket_hint,\n+\t\t const _H1&, const _H2&, const _Hash&,\n+\t\t const _Equal&, const _ExtractKey&,\n+\t\t const allocator_type&);\n+  \n+      template<typename _InputIterator>\n+        _Hashtable(_InputIterator __first, _InputIterator __last,\n+\t\t   size_type __bucket_hint,\n+\t\t   const _H1&, const _H2&, const _Hash&, \n+\t\t   const _Equal&, const _ExtractKey&,\n+\t\t   const allocator_type&);\n+  \n+      _Hashtable(const _Hashtable&);\n+    \n+      _Hashtable&\n+      operator=(const _Hashtable&);\n+\n+      ~_Hashtable();\n+\n+      void swap(_Hashtable&);\n+\n+      // Basic container operations\n+      iterator\n+      begin()\n+      {\n+\titerator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n+      }\n+\n+      const_iterator\n+      begin() const\n+      {\n+\tconst_iterator __i(_M_buckets);\n+\tif (!__i._M_cur_node)\n+\t  __i._M_incr_bucket();\n+\treturn __i;\n+      }\n+\n+      iterator\n+      end()\n+      { return iterator(_M_buckets + _M_bucket_count); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_M_buckets + _M_bucket_count); }\n+\n+      size_type\n+      size() const\n+      { return _M_element_count; }\n+  \n+      bool\n+      empty() const\n+      { return size() == 0; }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(_M_node_allocator); }\n+\n+      _Value_allocator_type\n+      _M_get_Value_allocator() const\n+      { return _Value_allocator_type(_M_node_allocator); }\n+\n+      size_type\n+      max_size() const\n+      { return _M_node_allocator.max_size(); }\n+\n+      // Observers\n+      key_equal\n+      key_eq() const\n+      { return this->_M_eq; }\n+\n+      // hash_function, if present, comes from _Hash_code_base.\n+\n+      // Bucket operations\n+      size_type\n+      bucket_count() const\n+      { return _M_bucket_count; }\n+  \n+      size_type\n+      max_bucket_count() const\n+      { return max_size(); }\n+  \n+      size_type\n+      bucket_size(size_type __n) const\n+      { return std::distance(begin(__n), end(__n)); }\n+  \n+      size_type\n+      bucket(const key_type& __k) const\n+      { \n+\treturn this->_M_bucket_index(__k, this->_M_hash_code(__k),\n+\t\t\t\t     bucket_count());\n+      }\n+\n+      local_iterator\n+      begin(size_type __n)\n+      { return local_iterator(_M_buckets[__n]); }\n+\n+      local_iterator\n+      end(size_type)\n+      { return local_iterator(0); }\n+\n+      const_local_iterator\n+      begin(size_type __n) const\n+      { return const_local_iterator(_M_buckets[__n]); }\n+\n+      const_local_iterator\n+      end(size_type) const\n+      { return const_local_iterator(0); }\n+\n+      float\n+      load_factor() const\n+      { \n+\treturn static_cast<float>(size()) / static_cast<float>(bucket_count());\n+      }\n+\n+      // max_load_factor, if present, comes from _Rehash_base.\n+\n+      // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n+      // useful if _RehashPolicy is something other than the default.\n+      const _RehashPolicy&\n+      __rehash_policy() const\n+      { return _M_rehash_policy; }\n+      \n+      void \n+      __rehash_policy(const _RehashPolicy&);\n+\n+      // Lookup.\n+      iterator\n+      find(const key_type& __k);\n+\n+      const_iterator\n+      find(const key_type& __k) const;\n+\n+      size_type\n+      count(const key_type& __k) const;\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __k);\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __k) const;\n+\n+    private:\t\t\t// Find, insert and erase helper functions\n+      // ??? This dispatching is a workaround for the fact that we don't\n+      // have partial specialization of member templates; it would be\n+      // better to just specialize insert on __unique_keys.  There may be a\n+      // cleaner workaround.\n+      typedef typename __gnu_cxx::__conditional_type<__unique_keys,\n+\t\t       \t    std::pair<iterator, bool>, iterator>::__type\n+        _Insert_Return_Type;\n+\n+      typedef typename __gnu_cxx::__conditional_type<__unique_keys,\n+\t\t\t\t\t  std::_Select1st<_Insert_Return_Type>,\n+\t\t\t\t  \t  std::_Identity<_Insert_Return_Type>\n+                                   >::__type\n+        _Insert_Conv_Type;\n+\n+      _Node*\n+      _M_find_node(_Node*, const key_type&,\n+\t\t   typename _Hashtable::_Hash_code_type) const;\n+\n+      iterator\n+      _M_insert_bucket(const value_type&, size_type,\n+\t\t       typename _Hashtable::_Hash_code_type);\n+\n+      std::pair<iterator, bool>\n+      _M_insert(const value_type&, std::tr1::true_type);\n+\n+      iterator\n+      _M_insert(const value_type&, std::tr1::false_type);\n+\n+      void\n+      _M_erase_node(_Node*, _Node**);\n+\n+    public:\t\t\t\t\n+      // Insert and erase\n+      _Insert_Return_Type\n+      insert(const value_type& __v) \n+      { return _M_insert(__v, std::tr1::integral_constant<bool,\n+\t\t\t __unique_keys>()); }\n+\n+      iterator\n+      insert(iterator, const value_type& __v)\n+      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }\n+\n+      const_iterator\n+      insert(const_iterator, const value_type& __v)\n+      { return const_iterator(_Insert_Conv_Type()(this->insert(__v))); }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last);\n+\n+      iterator\n+      erase(iterator);\n+\n+      const_iterator\n+      erase(const_iterator);\n+\n+      size_type\n+      erase(const key_type&);\n+\n+      iterator\n+      erase(iterator, iterator);\n+\n+      const_iterator\n+      erase(const_iterator, const_iterator);\n+\n+      void\n+      clear();\n+\n+      // Set number of buckets to be appropriate for container of n element.\n+      void rehash(size_type __n);\n+      \n+    private:\n+      // Unconditionally change size of bucket array to n.\n+      void _M_rehash(size_type __n);\n+    };\n+\n+\n+  // Definitions of class template _Hashtable's out-of-line member functions.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node*\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_allocate_node(const value_type& __v)\n+    {\n+      _Node* __n = _M_node_allocator.allocate(1);\n+      __try\n+\t{\n+\t  _M_get_Value_allocator().construct(&__n->_M_v, __v);\n+\t  __n->_M_next = 0;\n+\t  return __n;\n+\t}\n+      __catch(...)\n+\t{\n+\t  _M_node_allocator.deallocate(__n, 1);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_node(_Node* __n)\n+    {\n+      _M_get_Value_allocator().destroy(&__n->_M_v);\n+      _M_node_allocator.deallocate(__n, 1);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_nodes(_Node** __array, size_type __n)\n+    {\n+      for (size_type __i = 0; __i < __n; ++__i)\n+\t{\n+\t  _Node* __p = __array[__i];\n+\t  while (__p)\n+\t    {\n+\t      _Node* __tmp = __p;\n+\t      __p = __p->_M_next;\n+\t      _M_deallocate_node(__tmp);\n+\t    }\n+\t  __array[__i] = 0;\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node**\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_allocate_buckets(size_type __n)\n+    {\n+      _Bucket_allocator_type __alloc(_M_node_allocator);\n+\n+      // We allocate one extra bucket to hold a sentinel, an arbitrary\n+      // non-null pointer.  Iterator increment relies on this.\n+      _Node** __p = __alloc.allocate(__n + 1);\n+      std::fill(__p, __p + __n, (_Node*) 0);\n+      __p[__n] = reinterpret_cast<_Node*>(0x1000);\n+      return __p;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_deallocate_buckets(_Node** __p, size_type __n)\n+    {\n+      _Bucket_allocator_type __alloc(_M_node_allocator);\n+      __alloc.deallocate(__p, __n + 1);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(size_type __bucket_hint,\n+\t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t       const _Equal& __eq, const _ExtractKey& __exk,\n+\t       const allocator_type& __a)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __eq,\n+\t\t\t\t\t\t\t__h1, __h2, __h),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+      _M_node_allocator(__a),\n+      _M_bucket_count(0),\n+      _M_element_count(0),\n+      _M_rehash_policy()\n+    {\n+      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename _InputIterator>\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _Hashtable(_InputIterator __f, _InputIterator __l,\n+\t\t size_type __bucket_hint,\n+\t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n+\t\t const _Equal& __eq, const _ExtractKey& __exk,\n+\t\t const allocator_type& __a)\n+      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n+\t__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __eq,\n+\t\t\t\t\t\t\t  __h1, __h2, __h),\n+\t__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n+\t_M_node_allocator(__a),\n+\t_M_bucket_count(0),\n+\t_M_element_count(0),\n+\t_M_rehash_policy()\n+      {\n+\t_M_bucket_count = std::max(_M_rehash_policy._M_next_bkt(__bucket_hint),\n+\t\t\t\t   _M_rehash_policy.\n+\t\t\t\t   _M_bkt_for_elements(__detail::\n+\t\t\t\t\t\t       __distance_fw(__f,\n+\t\t\t\t\t\t\t\t     __l)));\n+\t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n+\t__try\n+\t  {\n+\t    for (; __f != __l; ++__f)\n+\t      this->insert(*__f);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    clear();\n+\t    _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+  \n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _Hashtable(const _Hashtable& __ht)\n+    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n+      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n+      _M_node_allocator(__ht._M_node_allocator),\n+      _M_bucket_count(__ht._M_bucket_count),\n+      _M_element_count(__ht._M_element_count),\n+      _M_rehash_policy(__ht._M_rehash_policy)\n+    {\n+      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n+      __try\n+\t{\n+\t  for (size_type __i = 0; __i < __ht._M_bucket_count; ++__i)\n+\t    {\n+\t      _Node* __n = __ht._M_buckets[__i];\n+\t      _Node** __tail = _M_buckets + __i;\n+\t      while (__n)\n+\t\t{\n+\t\t  *__tail = _M_allocate_node(__n->_M_v);\n+\t\t  this->_M_copy_code(*__tail, __n);\n+\t\t  __tail = &((*__tail)->_M_next);\n+\t\t  __n = __n->_M_next;\n+\t\t}\n+\t    }\n+\t}\n+      __catch(...)\n+\t{\n+\t  clear();\n+\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>&\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    operator=(const _Hashtable& __ht)\n+    {\n+      _Hashtable __tmp(__ht);\n+      this->swap(__tmp);\n+      return *this;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    ~_Hashtable()\n+    {\n+      clear();\n+      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    swap(_Hashtable& __x)\n+    {\n+      // The only base class with member variables is hash_code_base.  We\n+      // define _Hash_code_base::_M_swap because different specializations\n+      // have different members.\n+      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n+\t_H1, _H2, _Hash, __chc>::_M_swap(__x);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator,\n+\t\t\t\t\t\t\t__x._M_node_allocator);\n+\n+      std::swap(_M_rehash_policy, __x._M_rehash_policy);\n+      std::swap(_M_buckets, __x._M_buckets);\n+      std::swap(_M_bucket_count, __x._M_bucket_count);\n+      std::swap(_M_element_count, __x._M_element_count);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    __rehash_policy(const _RehashPolicy& __pol)\n+    {\n+      _M_rehash_policy = __pol;\n+      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n+      if (__n_bkt > _M_bucket_count)\n+\t_M_rehash(__n_bkt);\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    find(const key_type& __k)\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n+      return __p ? iterator(__p, _M_buckets + __n) : this->end();\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    find(const key_type& __k) const\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n+      return __p ? const_iterator(__p, _M_buckets + __n) : this->end();\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::size_type\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    count(const key_type& __k) const\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      std::size_t __result = 0;\n+      for (_Node* __p = _M_buckets[__n]; __p; __p = __p->_M_next)\n+\tif (this->_M_compare(__k, __code, __p))\n+\t  ++__result;\n+      return __result;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator,\n+\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    equal_range(const key_type& __k)\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node** __head = _M_buckets + __n;\n+      _Node* __p = _M_find_node(*__head, __k, __code);\n+      \n+      if (__p)\n+\t{\n+\t  _Node* __p1 = __p->_M_next;\n+\t  for (; __p1; __p1 = __p1->_M_next)\n+\t    if (!this->_M_compare(__k, __code, __p1))\n+\t      break;\n+\n+\t  iterator __first(__p, __head);\n+\t  iterator __last(__p1, __head);\n+\t  if (!__p1)\n+\t    __last._M_incr_bucket();\n+\t  return std::make_pair(__first, __last);\n+\t}\n+      else\n+\treturn std::make_pair(this->end(), this->end());\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::const_iterator,\n+\t      typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::const_iterator>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    equal_range(const key_type& __k) const\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      _Node** __head = _M_buckets + __n;\n+      _Node* __p = _M_find_node(*__head, __k, __code);\n+\n+      if (__p)\n+\t{\n+\t  _Node* __p1 = __p->_M_next;\n+\t  for (; __p1; __p1 = __p1->_M_next)\n+\t    if (!this->_M_compare(__k, __code, __p1))\n+\t      break;\n+\n+\t  const_iterator __first(__p, __head);\n+\t  const_iterator __last(__p1, __head);\n+\t  if (!__p1)\n+\t    __last._M_incr_bucket();\n+\t  return std::make_pair(__first, __last);\n+\t}\n+      else\n+\treturn std::make_pair(this->end(), this->end());\n+    }\n+\n+  // Find the node whose key compares equal to k, beginning the search\n+  // at p (usually the head of a bucket).  Return nil if no node is found.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n+\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::_Node* \n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_find_node(_Node* __p, const key_type& __k,\n+\t\ttypename _Hashtable::_Hash_code_type __code) const\n+    {\n+      for (; __p; __p = __p->_M_next)\n+\tif (this->_M_compare(__k, __code, __p))\n+\t  return __p;\n+      return false;\n+    }\n+\n+  // Insert v in bucket n (assumes no element with its key already present).\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert_bucket(const value_type& __v, size_type __n,\n+\t\t    typename _Hashtable::_Hash_code_type __code)\n+    {\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t  _M_element_count, 1);\n+\n+      // Allocate the new node before doing the rehash so that we don't\n+      // do a rehash if the allocation throws.\n+      _Node* __new_node = _M_allocate_node(__v);\n+\n+      __try\n+\t{\n+\t  if (__do_rehash.first)\n+\t    {\n+\t      const key_type& __k = this->_M_extract(__v);\n+\t      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n+\t      _M_rehash(__do_rehash.second);\n+\t    }\n+\n+\t  __new_node->_M_next = _M_buckets[__n];\n+\t  this->_M_store_code(__new_node, __code);\n+\t  _M_buckets[__n] = __new_node;\n+\t  ++_M_element_count;\n+\t  return iterator(__new_node, _M_buckets + __n);\n+\t}\n+      __catch(...)\n+\t{\n+\t  _M_deallocate_node(__new_node);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  // Insert v if no element with its key is already present.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t  _ExtractKey, _Equal, _H1,\n+\t\t\t\t  _H2, _Hash, _RehashPolicy,\n+\t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+  _M_insert(const value_type& __v, std::tr1::true_type)\n+    {\n+      const key_type& __k = this->_M_extract(__v);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n+\treturn std::make_pair(iterator(__p, _M_buckets + __n), false);\n+      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);\n+    }\n+  \n+  // Insert v unconditionally.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_insert(const value_type& __v, std::tr1::false_type)\n+    {\n+      std::pair<bool, std::size_t> __do_rehash\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t  _M_element_count, 1);\n+      if (__do_rehash.first)\n+\t_M_rehash(__do_rehash.second);\n+ \n+      const key_type& __k = this->_M_extract(__v);\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+      // First find the node, avoid leaking new_node if compare throws.\n+      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n+      _Node* __new_node = _M_allocate_node(__v);\n+\n+      if (__prev)\n+\t{\n+\t  __new_node->_M_next = __prev->_M_next;\n+\t  __prev->_M_next = __new_node;\n+\t}\n+      else\n+\t{\n+\t  __new_node->_M_next = _M_buckets[__n];\n+\t  _M_buckets[__n] = __new_node;\n+\t}\n+      this->_M_store_code(__new_node, __code);\n+\n+      ++_M_element_count;\n+      return iterator(__new_node, _M_buckets + __n);\n+    }\n+\n+  // For erase(iterator) and erase(const_iterator).\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_erase_node(_Node* __p, _Node** __b)\n+    {\n+      _Node* __cur = *__b;\n+      if (__cur == __p)\n+\t*__b = __cur->_M_next;\n+      else\n+\t{\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next != __p)\n+\t    {\n+\t      __cur = __next;\n+\t      __next = __cur->_M_next;\n+\t    }\n+\t  __cur->_M_next = __next->_M_next;\n+\t}\n+\n+      _M_deallocate_node(__p);\n+      --_M_element_count;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    template<typename _InputIterator>\n+      void \n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      insert(_InputIterator __first, _InputIterator __last)\n+      {\n+\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\tstd::pair<bool, std::size_t> __do_rehash\n+\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t    _M_element_count, __n_elt);\n+\tif (__do_rehash.first)\n+\t  _M_rehash(__do_rehash.second);\n+\n+\tfor (; __first != __last; ++__first)\n+\t  this->insert(*__first);\n+      }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(iterator __it)\n+    {\n+      iterator __result = __it;\n+      ++__result;\n+      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n+      return __result;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const_iterator __it)\n+    {\n+      const_iterator __result = __it;\n+      ++__result;\n+      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n+      return __result;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::size_type\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const key_type& __k)\n+    {\n+      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+      size_type __result = 0;\n+      \n+      _Node** __slot = _M_buckets + __n;\n+      while (*__slot && !this->_M_compare(__k, __code, *__slot))\n+\t__slot = &((*__slot)->_M_next);\n+\n+      _Node** __saved_slot = 0;\n+      while (*__slot && this->_M_compare(__k, __code, *__slot))\n+\t{\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 526. Is it undefined if a function in the standard changes\n+\t  // in parameters?\n+\t  if (&this->_M_extract((*__slot)->_M_v) != &__k)\n+\t    {\n+              _Node* __p = *__slot;\n+              *__slot = __p->_M_next;\n+\t      _M_deallocate_node(__p);\n+\t      --_M_element_count;\n+\t      ++__result;\n+\t    }\n+\t  else\n+\t    {\n+\t      __saved_slot = __slot;\n+\t      __slot = &((*__slot)->_M_next);\n+\t    }\n+\t}\n+\n+      if (__saved_slot)\n+\t{\n+\t  _Node* __p = *__saved_slot;\n+\t  *__saved_slot = __p->_M_next;\n+\t  _M_deallocate_node(__p);\n+\t  --_M_element_count;\n+\t  ++__result;\n+\t}\n+\n+      return __result;\n+    }\n+\n+  // ??? This could be optimized by taking advantage of the bucket\n+  // structure, but it's not clear that it's worth doing.  It probably\n+  // wouldn't even be an optimization unless the load factor is large.\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      while (__first != __last)\n+\t__first = this->erase(__first);\n+      return __last;\n+    }\n+  \n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t__chc, __cit, __uk>::const_iterator\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    erase(const_iterator __first, const_iterator __last)\n+    {\n+      while (__first != __last)\n+\t__first = this->erase(__first);\n+      return __last;\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    clear()\n+    {\n+      _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+      _M_element_count = 0;\n+    }\n+ \n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    rehash(size_type __n)\n+    {\n+      _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),\n+\t\t\t _M_rehash_policy._M_bkt_for_elements(_M_element_count\n+\t\t\t\t\t\t\t      + 1)));\n+    }\n+\n+  template<typename _Key, typename _Value, \n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_rehash(size_type __n)\n+    {\n+      _Node** __new_array = _M_allocate_buckets(__n);\n+      __try\n+\t{\n+\t  for (size_type __i = 0; __i < _M_bucket_count; ++__i)\n+\t    while (_Node* __p = _M_buckets[__i])\n+\t      {\n+\t\tstd::size_t __new_index = this->_M_bucket_index(__p, __n);\n+\t\t_M_buckets[__i] = __p->_M_next;\n+\t\t__p->_M_next = __new_array[__new_index];\n+\t\t__new_array[__new_index] = __p;\n+\t      }\n+\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+\t  _M_bucket_count = __n;\n+\t  _M_buckets = __new_array;\n+\t}\n+      __catch(...)\n+\t{\n+\t  // A failure here means that a hash function threw an exception.\n+\t  // We can't restore the previous state without calling the hash\n+\t  // function again, so the only sensible recovery is to delete\n+\t  // everything.\n+\t  _M_deallocate_nodes(__new_array, __n);\n+\t  _M_deallocate_buckets(__new_array, __n);\n+\t  _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n+\t  _M_element_count = 0;\n+\t  __throw_exception_again;\n+\t}\n+    }\n+}\n+}\n \n #endif // _GLIBCXX_TR1_HASHTABLE_H"}, {"sha": "60a4e64499952ea7fffc03f4b5106c9e6271980b", "filename": "libstdc++-v3/include/tr1/hashtable_policy.h", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // Internal policy header for TR1 unordered_set and unordered_map -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,7 +22,7 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-/** @file tr1_impl/hashtable_policy.h\n+/** @file tr1/hashtable_policy.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n  */", "previous_filename": "libstdc++-v3/include/tr1_impl/hashtable_policy.h"}, {"sha": "50bab9e4aefee878879af280e04c5cf4e33439e7", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -39,6 +39,6 @@\n #include <tr1/type_traits>\n #include <tr1/functional_hash.h>\n #include <tr1/hashtable.h>\n-#include <tr1_impl/unordered_map>\n+#include <tr1/unordered_map.h>\n \n #endif // _GLIBCXX_TR1_UNORDERED_MAP"}, {"sha": "9aa20a7266c09c5404f9a6fa79f94e0cbf0d164e", "filename": "libstdc++-v3/include/tr1/unordered_map.h", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n-// TR1 unordered_map -*- C++ -*-\n+// TR1 unordered_map implementation -*- C++ -*-\n \n-// Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,7 +22,7 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-/** @file tr1_impl/unordered_map\n+/** @file tr1/unordered_map.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n  */", "previous_filename": "libstdc++-v3/include/tr1_impl/unordered_map"}, {"sha": "3e2cbb039dcfc9c6ce3e1dc2b64b15eedfb91c78", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -39,6 +39,6 @@\n #include <tr1/type_traits>\n #include <tr1/functional_hash.h>\n #include <tr1/hashtable.h>\n-#include <tr1_impl/unordered_set>\n+#include <tr1/unordered_set.h>\n \n #endif // _GLIBCXX_TR1_UNORDERED_SET"}, {"sha": "e072035ded4de21ae0c3e011f3c4ad88000778f0", "filename": "libstdc++-v3/include/tr1/unordered_set.h", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set.h?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n-// TR1 unordered_set -*- C++ -*-\n+// TR1 unordered_set implementation -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,7 +22,7 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-/** @file tr1_impl/unordered_set\n+/** @file tr1/unordered_set.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n  */", "previous_filename": "libstdc++-v3/include/tr1_impl/unordered_set"}, {"sha": "5be91b010687a493d2c486372087a5a49ad10edb", "filename": "libstdc++-v3/include/tr1_impl/hashtable", "status": "removed", "additions": 0, "deletions": 1187, "changes": 1187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5418fe84c2377f7bff650c946fe8d667947b5984/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5418fe84c2377f7bff650c946fe8d667947b5984/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fhashtable?ref=5418fe84c2377f7bff650c946fe8d667947b5984", "patch": "@@ -1,1187 +0,0 @@\n-// Internal header for TR1 unordered_set and unordered_map -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// Under Section 7 of GPL version 3, you are granted additional\n-// permissions described in the GCC Runtime Library Exception, version\n-// 3.1, as published by the Free Software Foundation.\n-\n-// You should have received a copy of the GNU General Public License and\n-// a copy of the GCC Runtime Library Exception along with this program;\n-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-\n-/** @file tr1_impl/hashtable\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-// This header file defines std::tr1::hashtable, which is used to\n-// implement std::tr1::unordered_set, std::tr1::unordered_map, \n-// std::tr1::unordered_multiset, and std::tr1::unordered_multimap.\n-// hashtable has many template parameters, partly to accommodate\n-// the differences between those four classes and partly to \n-// accommodate policy choices that go beyond TR1 specifications.\n-\n-// Class template hashtable attempts to encapsulate all reasonable\n-// variation among hash tables that use chaining.  It does not handle\n-// open addressing.\n-\n-// References: \n-// M. Austern, \"A Proposal to Add Hash Tables to the Standard\n-//    Library (revision 4),\" WG21 Document N1456=03-0039, 2003.\n-// D. E. Knuth, The Art of Computer Programming, v. 3, Sorting and Searching.\n-// A. Tavori and V. Dreizin, \"Policy-Based Data Structures\", 2004.\n-// http://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/index.html\n-\n-#include <tr1_impl/hashtable_policy.h>\n-\n-namespace std\n-{ \n-namespace tr1\n-{\n-  // Class template _Hashtable, class definition.\n-  \n-  // Meaning of class template _Hashtable's template parameters\n-  \n-  // _Key and _Value: arbitrary CopyConstructible types.\n-  \n-  // _Allocator: an allocator type ([lib.allocator.requirements]) whose\n-  // value type is Value.  As a conforming extension, we allow for\n-  // value type != Value.\n-\n-  // _ExtractKey: function object that takes a object of type Value\n-  // and returns a value of type _Key.\n-  \n-  // _Equal: function object that takes two objects of type k and returns\n-  // a bool-like value that is true if the two objects are considered equal.\n-  \n-  // _H1: the hash function.  A unary function object with argument type\n-  // Key and result type size_t.  Return values should be distributed\n-  // over the entire range [0, numeric_limits<size_t>:::max()].\n-  \n-  // _H2: the range-hashing function (in the terminology of Tavori and\n-  // Dreizin).  A binary function object whose argument types and result\n-  // type are all size_t.  Given arguments r and N, the return value is\n-  // in the range [0, N).\n-  \n-  // _Hash: the ranged hash function (Tavori and Dreizin). A binary function\n-  // whose argument types are _Key and size_t and whose result type is\n-  // size_t.  Given arguments k and N, the return value is in the range\n-  // [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other\n-  // than the default, _H1 and _H2 are ignored.\n-  \n-  // _RehashPolicy: Policy class with three members, all of which govern\n-  // the bucket count. _M_next_bkt(n) returns a bucket count no smaller\n-  // than n.  _M_bkt_for_elements(n) returns a bucket count appropriate\n-  // for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)\n-  // determines whether, if the current bucket count is n_bkt and the\n-  // current element count is n_elt, we need to increase the bucket\n-  // count.  If so, returns make_pair(true, n), where n is the new\n-  // bucket count.  If not, returns make_pair(false, <anything>).\n-  \n-  // ??? Right now it is hard-wired that the number of buckets never\n-  // shrinks.  Should we allow _RehashPolicy to change that?\n-  \n-  // __cache_hash_code: bool.  true if we store the value of the hash\n-  // function along with the value.  This is a time-space tradeoff.\n-  // Storing it may improve lookup speed by reducing the number of times\n-  // we need to call the Equal function.\n-  \n-  // __constant_iterators: bool.  true if iterator and const_iterator are\n-  // both constant iterator types.  This is true for unordered_set and\n-  // unordered_multiset, false for unordered_map and unordered_multimap.\n-  \n-  // __unique_keys: bool.  true if the return value of _Hashtable::count(k)\n-  // is always at most one, false if it may be an arbitrary number.  This\n-  // true for unordered_set and unordered_map, false for unordered_multiset\n-  // and unordered_multimap.\n-  \n-  template<typename _Key, typename _Value, typename _Allocator,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, \n-\t   typename _RehashPolicy,\n-\t   bool __cache_hash_code,\n-\t   bool __constant_iterators,\n-\t   bool __unique_keys>\n-    class _Hashtable\n-    : public __detail::_Rehash_base<_RehashPolicy,\n-\t\t\t\t    _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t\t       _ExtractKey,\n-\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t       _RehashPolicy,\n-\t\t\t\t\t       __cache_hash_code,\n-\t\t\t\t\t       __constant_iterators,\n-\t\t\t\t\t       __unique_keys> >,\n-      public __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t       _H1, _H2, _Hash, __cache_hash_code>,\n-      public __detail::_Map_base<_Key, _Value, _ExtractKey, __unique_keys,\n-\t\t\t\t _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t\t    _ExtractKey,\n-\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t    _RehashPolicy,\n-\t\t\t\t\t    __cache_hash_code,\n-\t\t\t\t\t    __constant_iterators,\n-\t\t\t\t\t    __unique_keys> >\n-    {\n-    public:\n-      typedef _Allocator                                  allocator_type;\n-      typedef _Value                                      value_type;\n-      typedef _Key                                        key_type;\n-      typedef _Equal                                      key_equal;\n-      // mapped_type, if present, comes from _Map_base.\n-      // hasher, if present, comes from _Hash_code_base.\n-      typedef typename _Allocator::difference_type        difference_type;\n-      typedef typename _Allocator::size_type              size_type;\n-      typedef typename _Allocator::pointer                pointer;\n-      typedef typename _Allocator::const_pointer          const_pointer;\n-      typedef typename _Allocator::reference              reference;\n-      typedef typename _Allocator::const_reference        const_reference;\n-      \n-      typedef __detail::_Node_iterator<value_type, __constant_iterators,\n-\t\t\t\t       __cache_hash_code>\n-                                                          local_iterator;\n-      typedef __detail::_Node_const_iterator<value_type,\n-\t\t\t\t\t     __constant_iterators,\n-\t\t\t\t\t     __cache_hash_code>\n-                                                          const_local_iterator;\n-\n-      typedef __detail::_Hashtable_iterator<value_type, __constant_iterators,\n-\t\t\t\t\t    __cache_hash_code>\n-                                                          iterator;\n-      typedef __detail::_Hashtable_const_iterator<value_type,\n-\t\t\t\t\t\t  __constant_iterators,\n-\t\t\t\t\t\t  __cache_hash_code>\n-                                                          const_iterator;\n-\n-      template<typename _Key2, typename _Value2, typename _Ex2, bool __unique2,\n-\t       typename _Hashtable2>\n-        friend struct __detail::_Map_base;\n-\n-    private:\n-      typedef __detail::_Hash_node<_Value, __cache_hash_code> _Node;\n-      typedef typename _Allocator::template rebind<_Node>::other\n-                                                        _Node_allocator_type;\n-      typedef typename _Allocator::template rebind<_Node*>::other\n-                                                        _Bucket_allocator_type;\n-\n-      typedef typename _Allocator::template rebind<_Value>::other\n-                                                        _Value_allocator_type;\n-\n-      _Node_allocator_type   _M_node_allocator;\n-      _Node**                _M_buckets;\n-      size_type              _M_bucket_count;\n-      size_type              _M_element_count;\n-      _RehashPolicy          _M_rehash_policy;\n-      \n-      _Node*\n-      _M_allocate_node(const value_type& __v);\n-  \n-      void\n-      _M_deallocate_node(_Node* __n);\n-  \n-      void\n-      _M_deallocate_nodes(_Node**, size_type);\n-\n-      _Node**\n-      _M_allocate_buckets(size_type __n);\n-  \n-      void\n-      _M_deallocate_buckets(_Node**, size_type __n);\n-\n-    public:\t\t\t    \n-      // Constructor, destructor, assignment, swap\n-      _Hashtable(size_type __bucket_hint,\n-\t\t const _H1&, const _H2&, const _Hash&,\n-\t\t const _Equal&, const _ExtractKey&,\n-\t\t const allocator_type&);\n-  \n-      template<typename _InputIterator>\n-        _Hashtable(_InputIterator __first, _InputIterator __last,\n-\t\t   size_type __bucket_hint,\n-\t\t   const _H1&, const _H2&, const _Hash&, \n-\t\t   const _Equal&, const _ExtractKey&,\n-\t\t   const allocator_type&);\n-  \n-      _Hashtable(const _Hashtable&);\n-    \n-      _Hashtable&\n-      operator=(const _Hashtable&);\n-\n-      ~_Hashtable();\n-\n-      void swap(_Hashtable&);\n-\n-      // Basic container operations\n-      iterator\n-      begin()\n-      {\n-\titerator __i(_M_buckets);\n-\tif (!__i._M_cur_node)\n-\t  __i._M_incr_bucket();\n-\treturn __i;\n-      }\n-\n-      const_iterator\n-      begin() const\n-      {\n-\tconst_iterator __i(_M_buckets);\n-\tif (!__i._M_cur_node)\n-\t  __i._M_incr_bucket();\n-\treturn __i;\n-      }\n-\n-      iterator\n-      end()\n-      { return iterator(_M_buckets + _M_bucket_count); }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(_M_buckets + _M_bucket_count); }\n-\n-      size_type\n-      size() const\n-      { return _M_element_count; }\n-  \n-      bool\n-      empty() const\n-      { return size() == 0; }\n-\n-      allocator_type\n-      get_allocator() const\n-      { return allocator_type(_M_node_allocator); }\n-\n-      _Value_allocator_type\n-      _M_get_Value_allocator() const\n-      { return _Value_allocator_type(_M_node_allocator); }\n-\n-      size_type\n-      max_size() const\n-      { return _M_node_allocator.max_size(); }\n-\n-      // Observers\n-      key_equal\n-      key_eq() const\n-      { return this->_M_eq; }\n-\n-      // hash_function, if present, comes from _Hash_code_base.\n-\n-      // Bucket operations\n-      size_type\n-      bucket_count() const\n-      { return _M_bucket_count; }\n-  \n-      size_type\n-      max_bucket_count() const\n-      { return max_size(); }\n-  \n-      size_type\n-      bucket_size(size_type __n) const\n-      { return std::distance(begin(__n), end(__n)); }\n-  \n-      size_type\n-      bucket(const key_type& __k) const\n-      { \n-\treturn this->_M_bucket_index(__k, this->_M_hash_code(__k),\n-\t\t\t\t     bucket_count());\n-      }\n-\n-      local_iterator\n-      begin(size_type __n)\n-      { return local_iterator(_M_buckets[__n]); }\n-\n-      local_iterator\n-      end(size_type)\n-      { return local_iterator(0); }\n-\n-      const_local_iterator\n-      begin(size_type __n) const\n-      { return const_local_iterator(_M_buckets[__n]); }\n-\n-      const_local_iterator\n-      end(size_type) const\n-      { return const_local_iterator(0); }\n-\n-      float\n-      load_factor() const\n-      { \n-\treturn static_cast<float>(size()) / static_cast<float>(bucket_count());\n-      }\n-\n-      // max_load_factor, if present, comes from _Rehash_base.\n-\n-      // Generalization of max_load_factor.  Extension, not found in TR1.  Only\n-      // useful if _RehashPolicy is something other than the default.\n-      const _RehashPolicy&\n-      __rehash_policy() const\n-      { return _M_rehash_policy; }\n-      \n-      void \n-      __rehash_policy(const _RehashPolicy&);\n-\n-      // Lookup.\n-      iterator\n-      find(const key_type& __k);\n-\n-      const_iterator\n-      find(const key_type& __k) const;\n-\n-      size_type\n-      count(const key_type& __k) const;\n-\n-      std::pair<iterator, iterator>\n-      equal_range(const key_type& __k);\n-\n-      std::pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __k) const;\n-\n-    private:\t\t\t// Find, insert and erase helper functions\n-      // ??? This dispatching is a workaround for the fact that we don't\n-      // have partial specialization of member templates; it would be\n-      // better to just specialize insert on __unique_keys.  There may be a\n-      // cleaner workaround.\n-      typedef typename __gnu_cxx::__conditional_type<__unique_keys,\n-\t\t       \t    std::pair<iterator, bool>, iterator>::__type\n-        _Insert_Return_Type;\n-\n-      typedef typename __gnu_cxx::__conditional_type<__unique_keys,\n-\t\t\t\t\t  std::_Select1st<_Insert_Return_Type>,\n-\t\t\t\t  \t  std::_Identity<_Insert_Return_Type>\n-                                   >::__type\n-        _Insert_Conv_Type;\n-\n-      _Node*\n-      _M_find_node(_Node*, const key_type&,\n-\t\t   typename _Hashtable::_Hash_code_type) const;\n-\n-      iterator\n-      _M_insert_bucket(const value_type&, size_type,\n-\t\t       typename _Hashtable::_Hash_code_type);\n-\n-      std::pair<iterator, bool>\n-      _M_insert(const value_type&, std::tr1::true_type);\n-\n-      iterator\n-      _M_insert(const value_type&, std::tr1::false_type);\n-\n-      void\n-      _M_erase_node(_Node*, _Node**);\n-\n-    public:\t\t\t\t\n-      // Insert and erase\n-      _Insert_Return_Type\n-      insert(const value_type& __v) \n-      { return _M_insert(__v, std::tr1::integral_constant<bool,\n-\t\t\t __unique_keys>()); }\n-\n-      iterator\n-      insert(iterator, const value_type& __v)\n-      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }\n-\n-      const_iterator\n-      insert(const_iterator, const value_type& __v)\n-      { return const_iterator(_Insert_Conv_Type()(this->insert(__v))); }\n-\n-      template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last);\n-\n-      iterator\n-      erase(iterator);\n-\n-      const_iterator\n-      erase(const_iterator);\n-\n-      size_type\n-      erase(const key_type&);\n-\n-      iterator\n-      erase(iterator, iterator);\n-\n-      const_iterator\n-      erase(const_iterator, const_iterator);\n-\n-      void\n-      clear();\n-\n-      // Set number of buckets to be appropriate for container of n element.\n-      void rehash(size_type __n);\n-      \n-    private:\n-      // Unconditionally change size of bucket array to n.\n-      void _M_rehash(size_type __n);\n-    };\n-\n-\n-  // Definitions of class template _Hashtable's out-of-line member functions.\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_allocate_node(const value_type& __v)\n-    {\n-      _Node* __n = _M_node_allocator.allocate(1);\n-      __try\n-\t{\n-\t  _M_get_Value_allocator().construct(&__n->_M_v, __v);\n-\t  __n->_M_next = 0;\n-\t  return __n;\n-\t}\n-      __catch(...)\n-\t{\n-\t  _M_node_allocator.deallocate(__n, 1);\n-\t  __throw_exception_again;\n-\t}\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_node(_Node* __n)\n-    {\n-      _M_get_Value_allocator().destroy(&__n->_M_v);\n-      _M_node_allocator.deallocate(__n, 1);\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_nodes(_Node** __array, size_type __n)\n-    {\n-      for (size_type __i = 0; __i < __n; ++__i)\n-\t{\n-\t  _Node* __p = __array[__i];\n-\t  while (__p)\n-\t    {\n-\t      _Node* __tmp = __p;\n-\t      __p = __p->_M_next;\n-\t      _M_deallocate_node(__tmp);\n-\t    }\n-\t  __array[__i] = 0;\n-\t}\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node**\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_allocate_buckets(size_type __n)\n-    {\n-      _Bucket_allocator_type __alloc(_M_node_allocator);\n-\n-      // We allocate one extra bucket to hold a sentinel, an arbitrary\n-      // non-null pointer.  Iterator increment relies on this.\n-      _Node** __p = __alloc.allocate(__n + 1);\n-      std::fill(__p, __p + __n, (_Node*) 0);\n-      __p[__n] = reinterpret_cast<_Node*>(0x1000);\n-      return __p;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_buckets(_Node** __p, size_type __n)\n-    {\n-      _Bucket_allocator_type __alloc(_M_node_allocator);\n-      __alloc.deallocate(__p, __n + 1);\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _Hashtable(size_type __bucket_hint,\n-\t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t       const _Equal& __eq, const _ExtractKey& __exk,\n-\t       const allocator_type& __a)\n-    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__exk, __eq,\n-\t\t\t\t\t\t\t__h1, __h2, __h),\n-      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n-      _M_node_allocator(__a),\n-      _M_bucket_count(0),\n-      _M_element_count(0),\n-      _M_rehash_policy()\n-    {\n-      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    template<typename _InputIterator>\n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      _Hashtable(_InputIterator __f, _InputIterator __l,\n-\t\t size_type __bucket_hint,\n-\t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t\t const _Equal& __eq, const _ExtractKey& __exk,\n-\t\t const allocator_type& __a)\n-      : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(),\n-\t__detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t  _H1, _H2, _Hash, __chc>(__exk, __eq,\n-\t\t\t\t\t\t\t  __h1, __h2, __h),\n-\t__detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),\n-\t_M_node_allocator(__a),\n-\t_M_bucket_count(0),\n-\t_M_element_count(0),\n-\t_M_rehash_policy()\n-      {\n-\t_M_bucket_count = std::max(_M_rehash_policy._M_next_bkt(__bucket_hint),\n-\t\t\t\t   _M_rehash_policy.\n-\t\t\t\t   _M_bkt_for_elements(__detail::\n-\t\t\t\t\t\t       __distance_fw(__f,\n-\t\t\t\t\t\t\t\t     __l)));\n-\t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n-\t__try\n-\t  {\n-\t    for (; __f != __l; ++__f)\n-\t      this->insert(*__f);\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    clear();\n-\t    _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n-\t    __throw_exception_again;\n-\t  }\n-      }\n-  \n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _Hashtable(const _Hashtable& __ht)\n-    : __detail::_Rehash_base<_RehashPolicy, _Hashtable>(__ht),\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t_H1, _H2, _Hash, __chc>(__ht),\n-      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n-      _M_node_allocator(__ht._M_node_allocator),\n-      _M_bucket_count(__ht._M_bucket_count),\n-      _M_element_count(__ht._M_element_count),\n-      _M_rehash_policy(__ht._M_rehash_policy)\n-    {\n-      _M_buckets = _M_allocate_buckets(_M_bucket_count);\n-      __try\n-\t{\n-\t  for (size_type __i = 0; __i < __ht._M_bucket_count; ++__i)\n-\t    {\n-\t      _Node* __n = __ht._M_buckets[__i];\n-\t      _Node** __tail = _M_buckets + __i;\n-\t      while (__n)\n-\t\t{\n-\t\t  *__tail = _M_allocate_node(__n->_M_v);\n-\t\t  this->_M_copy_code(*__tail, __n);\n-\t\t  __tail = &((*__tail)->_M_next);\n-\t\t  __n = __n->_M_next;\n-\t\t}\n-\t    }\n-\t}\n-      __catch(...)\n-\t{\n-\t  clear();\n-\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n-\t  __throw_exception_again;\n-\t}\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>&\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    operator=(const _Hashtable& __ht)\n-    {\n-      _Hashtable __tmp(__ht);\n-      this->swap(__tmp);\n-      return *this;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    ~_Hashtable()\n-    {\n-      clear();\n-      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    swap(_Hashtable& __x)\n-    {\n-      // The only base class with member variables is hash_code_base.  We\n-      // define _Hash_code_base::_M_swap because different specializations\n-      // have different members.\n-      __detail::_Hash_code_base<_Key, _Value, _ExtractKey, _Equal,\n-\t_H1, _H2, _Hash, __chc>::_M_swap(__x);\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 431. Swapping containers with unequal allocators.\n-      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator,\n-\t\t\t\t\t\t\t__x._M_node_allocator);\n-\n-      std::swap(_M_rehash_policy, __x._M_rehash_policy);\n-      std::swap(_M_buckets, __x._M_buckets);\n-      std::swap(_M_bucket_count, __x._M_bucket_count);\n-      std::swap(_M_element_count, __x._M_element_count);\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    __rehash_policy(const _RehashPolicy& __pol)\n-    {\n-      _M_rehash_policy = __pol;\n-      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);\n-      if (__n_bkt > _M_bucket_count)\n-\t_M_rehash(__n_bkt);\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    find(const key_type& __k)\n-    {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n-      return __p ? iterator(__p, _M_buckets + __n) : this->end();\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::const_iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    find(const key_type& __k) const\n-    {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);\n-      return __p ? const_iterator(__p, _M_buckets + __n) : this->end();\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::size_type\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    count(const key_type& __k) const\n-    {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-      std::size_t __result = 0;\n-      for (_Node* __p = _M_buckets[__n]; __p; __p = __p->_M_next)\n-\tif (this->_M_compare(__k, __code, __p))\n-\t  ++__result;\n-      return __result;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::iterator,\n-\t      typename _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::iterator>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    equal_range(const key_type& __k)\n-    {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-      _Node** __head = _M_buckets + __n;\n-      _Node* __p = _M_find_node(*__head, __k, __code);\n-      \n-      if (__p)\n-\t{\n-\t  _Node* __p1 = __p->_M_next;\n-\t  for (; __p1; __p1 = __p1->_M_next)\n-\t    if (!this->_M_compare(__k, __code, __p1))\n-\t      break;\n-\n-\t  iterator __first(__p, __head);\n-\t  iterator __last(__p1, __head);\n-\t  if (!__p1)\n-\t    __last._M_incr_bucket();\n-\t  return std::make_pair(__first, __last);\n-\t}\n-      else\n-\treturn std::make_pair(this->end(), this->end());\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::const_iterator,\n-\t      typename _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::const_iterator>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    equal_range(const key_type& __k) const\n-    {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-      _Node** __head = _M_buckets + __n;\n-      _Node* __p = _M_find_node(*__head, __k, __code);\n-\n-      if (__p)\n-\t{\n-\t  _Node* __p1 = __p->_M_next;\n-\t  for (; __p1; __p1 = __p1->_M_next)\n-\t    if (!this->_M_compare(__k, __code, __p1))\n-\t      break;\n-\n-\t  const_iterator __first(__p, __head);\n-\t  const_iterator __last(__p1, __head);\n-\t  if (!__p1)\n-\t    __last._M_incr_bucket();\n-\t  return std::make_pair(__first, __last);\n-\t}\n-      else\n-\treturn std::make_pair(this->end(), this->end());\n-    }\n-\n-  // Find the node whose key compares equal to k, beginning the search\n-  // at p (usually the head of a bucket).  Return nil if no node is found.\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,\n-\t\t\t_Equal, _H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node* \n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_find_node(_Node* __p, const key_type& __k,\n-\t\ttypename _Hashtable::_Hash_code_type __code) const\n-    {\n-      for (; __p; __p = __p->_M_next)\n-\tif (this->_M_compare(__k, __code, __p))\n-\t  return __p;\n-      return false;\n-    }\n-\n-  // Insert v in bucket n (assumes no element with its key already present).\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert_bucket(const value_type& __v, size_type __n,\n-\t\t    typename _Hashtable::_Hash_code_type __code)\n-    {\n-      std::pair<bool, std::size_t> __do_rehash\n-\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t  _M_element_count, 1);\n-\n-      // Allocate the new node before doing the rehash so that we don't\n-      // do a rehash if the allocation throws.\n-      _Node* __new_node = _M_allocate_node(__v);\n-\n-      __try\n-\t{\n-\t  if (__do_rehash.first)\n-\t    {\n-\t      const key_type& __k = this->_M_extract(__v);\n-\t      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n-\t      _M_rehash(__do_rehash.second);\n-\t    }\n-\n-\t  __new_node->_M_next = _M_buckets[__n];\n-\t  this->_M_store_code(__new_node, __code);\n-\t  _M_buckets[__n] = __new_node;\n-\t  ++_M_element_count;\n-\t  return iterator(__new_node, _M_buckets + __n);\n-\t}\n-      __catch(...)\n-\t{\n-\t  _M_deallocate_node(__new_node);\n-\t  __throw_exception_again;\n-\t}\n-    }\n-\n-  // Insert v if no element with its key is already present.\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-  _M_insert(const value_type& __v, std::tr1::true_type)\n-    {\n-      const key_type& __k = this->_M_extract(__v);\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-\n-      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n-\treturn std::make_pair(iterator(__p, _M_buckets + __n), false);\n-      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);\n-    }\n-  \n-  // Insert v unconditionally.\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::tr1::false_type)\n-    {\n-      std::pair<bool, std::size_t> __do_rehash\n-\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t  _M_element_count, 1);\n-      if (__do_rehash.first)\n-\t_M_rehash(__do_rehash.second);\n- \n-      const key_type& __k = this->_M_extract(__v);\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-\n-      // First find the node, avoid leaking new_node if compare throws.\n-      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n-      _Node* __new_node = _M_allocate_node(__v);\n-\n-      if (__prev)\n-\t{\n-\t  __new_node->_M_next = __prev->_M_next;\n-\t  __prev->_M_next = __new_node;\n-\t}\n-      else\n-\t{\n-\t  __new_node->_M_next = _M_buckets[__n];\n-\t  _M_buckets[__n] = __new_node;\n-\t}\n-      this->_M_store_code(__new_node, __code);\n-\n-      ++_M_element_count;\n-      return iterator(__new_node, _M_buckets + __n);\n-    }\n-\n-  // For erase(iterator) and erase(const_iterator).\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_erase_node(_Node* __p, _Node** __b)\n-    {\n-      _Node* __cur = *__b;\n-      if (__cur == __p)\n-\t*__b = __cur->_M_next;\n-      else\n-\t{\n-\t  _Node* __next = __cur->_M_next;\n-\t  while (__next != __p)\n-\t    {\n-\t      __cur = __next;\n-\t      __next = __cur->_M_next;\n-\t    }\n-\t  __cur->_M_next = __next->_M_next;\n-\t}\n-\n-      _M_deallocate_node(__p);\n-      --_M_element_count;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    template<typename _InputIterator>\n-      void \n-      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-      insert(_InputIterator __first, _InputIterator __last)\n-      {\n-\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n-\tstd::pair<bool, std::size_t> __do_rehash\n-\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t    _M_element_count, __n_elt);\n-\tif (__do_rehash.first)\n-\t  _M_rehash(__do_rehash.second);\n-\n-\tfor (; __first != __last; ++__first)\n-\t  this->insert(*__first);\n-      }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    erase(iterator __it)\n-    {\n-      iterator __result = __it;\n-      ++__result;\n-      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n-      return __result;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::const_iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    erase(const_iterator __it)\n-    {\n-      const_iterator __result = __it;\n-      ++__result;\n-      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n-      return __result;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::size_type\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    erase(const key_type& __k)\n-    {\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-      size_type __result = 0;\n-      \n-      _Node** __slot = _M_buckets + __n;\n-      while (*__slot && !this->_M_compare(__k, __code, *__slot))\n-\t__slot = &((*__slot)->_M_next);\n-\n-      _Node** __saved_slot = 0;\n-      while (*__slot && this->_M_compare(__k, __code, *__slot))\n-\t{\n-\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t  // 526. Is it undefined if a function in the standard changes\n-\t  // in parameters?\n-\t  if (&this->_M_extract((*__slot)->_M_v) != &__k)\n-\t    {\n-              _Node* __p = *__slot;\n-              *__slot = __p->_M_next;\n-\t      _M_deallocate_node(__p);\n-\t      --_M_element_count;\n-\t      ++__result;\n-\t    }\n-\t  else\n-\t    {\n-\t      __saved_slot = __slot;\n-\t      __slot = &((*__slot)->_M_next);\n-\t    }\n-\t}\n-\n-      if (__saved_slot)\n-\t{\n-\t  _Node* __p = *__saved_slot;\n-\t  *__saved_slot = __p->_M_next;\n-\t  _M_deallocate_node(__p);\n-\t  --_M_element_count;\n-\t  ++__result;\n-\t}\n-\n-      return __result;\n-    }\n-\n-  // ??? This could be optimized by taking advantage of the bucket\n-  // structure, but it's not clear that it's worth doing.  It probably\n-  // wouldn't even be an optimization unless the load factor is large.\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    erase(iterator __first, iterator __last)\n-    {\n-      while (__first != __last)\n-\t__first = this->erase(__first);\n-      return __last;\n-    }\n-  \n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::const_iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    erase(const_iterator __first, const_iterator __last)\n-    {\n-      while (__first != __last)\n-\t__first = this->erase(__first);\n-      return __last;\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    clear()\n-    {\n-      _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n-      _M_element_count = 0;\n-    }\n- \n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    rehash(size_type __n)\n-    {\n-      _M_rehash(std::max(_M_rehash_policy._M_next_bkt(__n),\n-\t\t\t _M_rehash_policy._M_bkt_for_elements(_M_element_count\n-\t\t\t\t\t\t\t      + 1)));\n-    }\n-\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_rehash(size_type __n)\n-    {\n-      _Node** __new_array = _M_allocate_buckets(__n);\n-      __try\n-\t{\n-\t  for (size_type __i = 0; __i < _M_bucket_count; ++__i)\n-\t    while (_Node* __p = _M_buckets[__i])\n-\t      {\n-\t\tstd::size_t __new_index = this->_M_bucket_index(__p, __n);\n-\t\t_M_buckets[__i] = __p->_M_next;\n-\t\t__p->_M_next = __new_array[__new_index];\n-\t\t__new_array[__new_index] = __p;\n-\t      }\n-\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n-\t  _M_bucket_count = __n;\n-\t  _M_buckets = __new_array;\n-\t}\n-      __catch(...)\n-\t{\n-\t  // A failure here means that a hash function threw an exception.\n-\t  // We can't restore the previous state without calling the hash\n-\t  // function again, so the only sensible recovery is to delete\n-\t  // everything.\n-\t  _M_deallocate_nodes(__new_array, __n);\n-\t  _M_deallocate_buckets(__new_array, __n);\n-\t  _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n-\t  _M_element_count = 0;\n-\t  __throw_exception_again;\n-\t}\n-    }\n-}\n-}"}, {"sha": "e5a10738e959d7014f647782f4874e2577023f19", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/assign/assign_neg.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fassign%2Fassign_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -49,13 +49,13 @@ test03()\n   std::unique_ptr<int[2]> p2 = p1;\n }\n \n-// { dg-error \"deleted function\" \"\" { target *-*-* } 358 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 354 }\n // { dg-error \"used here\" \"\" { target *-*-* } 42 }\n // { dg-error \"no matching\" \"\" { target *-*-* } 48 }\n-// { dg-warning \"candidates are\" \"\" { target *-*-* } 119 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 112 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 107 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 102 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 96 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 213 }\n+// { dg-warning \"candidates are\" \"\" { target *-*-* } 115 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 108 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 103 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 98 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 92 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 209 }\n // { dg-error \"used here\" \"\" { target *-*-* } 49 }"}, {"sha": "d4c2b3a6d8accd4f83ca15f2f938436e3dee63fe", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/modifiers/reset_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Freset_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Freset_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fmodifiers%2Freset_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,4 +36,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 35 } \n-// { dg-error \"deleted function\" \"\" { target *-*-* } 348 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 344 }"}, {"sha": "f4bc4cbc9e8db69c08d6f9bf0ed4ce1476dd31a8", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1201 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1197 }\n // { dg-excess-errors \"\" }\n \n // Copyright (C) 2009, 2010 Free Software Foundation"}, {"sha": "8a591dbbb17a4b2a15c571f706dc09d25179d116", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1201 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1197 }\n // { dg-excess-errors \"\" }\n \n // Copyright (C) 2009, 2010 Free Software Foundation"}, {"sha": "9db92f2c64b7c331b02f42378559b2baf646bfc3", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1201 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1197 }\n // { dg-excess-errors \"\" }\n \n // Copyright (C) 2009, 2010 Free Software Foundation"}, {"sha": "804f10b5c60a2c033fd59e50b4e28e6a0ea7f47b", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1201 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1197 }\n // { dg-excess-errors \"\" }\n \n // Copyright (C) 2009, 2010 Free Software Foundation"}, {"sha": "380540a20a795e0ee2616da213c7fd6b8a240dfa", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/assign_neg.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,19 +29,19 @@ int main()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 521 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 231 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 249 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 267 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 285 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 303 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 321 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 339 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 357 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 375 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 393 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 411 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 429 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 447 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 465 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 483 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 230 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 248 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 266 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 284 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 302 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 320 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 338 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 356 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 374 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 392 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 410 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 428 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 446 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 464 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 482 }\n // { dg-excess-errors \"In member function\" }"}, {"sha": "21f77f4c21b5e8ad2d7b39f66810ecaff25e02b5", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/copy_neg.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab65a4c7bdf10e5465cbf47faae88af258dc2baa/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc?ref=ab65a4c7bdf10e5465cbf47faae88af258dc2baa", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,19 +29,19 @@ int main()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 560 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 248 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 266 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 284 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 302 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 320 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 338 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 356 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 374 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 230 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 410 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 428 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 446 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 464 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 482 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 392 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 229 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 247 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 265 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 283 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 301 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 319 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 337 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 355 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 373 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 391 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 409 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 427 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 445 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 463 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 481 }\n // { dg-excess-errors \"In member function\" }"}]}