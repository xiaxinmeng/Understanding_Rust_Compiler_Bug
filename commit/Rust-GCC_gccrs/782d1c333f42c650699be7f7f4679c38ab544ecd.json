{"sha": "782d1c333f42c650699be7f7f4679c38ab544ecd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgyZDFjMzMzZjQyYzY1MDY5OWJlN2Y3ZjQ2NzljMzhhYjU0NGVjZA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-12-16T01:36:09Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-12-16T01:36:09Z"}, "message": "re PR c++/39859 (duplicated and unhelpful error for \"c:n\" (parser))\n\ngcc/cp/\n\tPR c++/39859\n\tPR c++/44522\n\tPR c++/44523\n\t* parser.c (struct cp_parser): Add colon_corrects_to_scope_p field.\n\t(cp_parser_new): Initialize it.\n\t(cp_parser_nested_name_specifier_opt): Auto-correct colons to\n\tscopes if we are able to.\n\t(cp_parser_question_colon_clause): Disallow colon correction.\n\t(cp_parser_label_for_labeled_statement): Likewise.\n\t(cp_parser_range_for): Likewise.\n\t(cp_parser_enum_specifier): Likewise.\n\t(cp_parser_class_head): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\ngcc/testsuite/\n\tPR c++/39859\n\tPR c++/44522\n\tPR c++/44523\n\t* g++.dg/parse/colon-autocorrect-1.C: New testcase.\n\t* g++.dg/parse/colon-autocorrect-2.C: New testcase.\n\nFrom-SVN: r167895", "tree": {"sha": "3ab2ddf89eac92b4a61685e2d4c4770e8b840c97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ab2ddf89eac92b4a61685e2d4c4770e8b840c97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/782d1c333f42c650699be7f7f4679c38ab544ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782d1c333f42c650699be7f7f4679c38ab544ecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782d1c333f42c650699be7f7f4679c38ab544ecd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782d1c333f42c650699be7f7f4679c38ab544ecd/comments", "author": null, "committer": null, "parents": [{"sha": "b2d49fe5aa6529689c71df4a0635041725cb94d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d49fe5aa6529689c71df4a0635041725cb94d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2d49fe5aa6529689c71df4a0635041725cb94d1"}], "stats": {"total": 143, "additions": 132, "deletions": 11}, "files": [{"sha": "0d46bcca404dd5e4a97b87fe98882bae270ddb2c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=782d1c333f42c650699be7f7f4679c38ab544ecd", "patch": "@@ -1,3 +1,19 @@\n+2010-12-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\tPR c++/39859\n+\tPR c++/44522\n+\tPR c++/44523\n+\t* parser.c (struct cp_parser): Add colon_corrects_to_scope_p field.\n+\t(cp_parser_new): Initialize it.\n+\t(cp_parser_nested_name_specifier_opt): Auto-correct colons to\n+\tscopes if we are able to.\n+\t(cp_parser_question_colon_clause): Disallow colon correction.\n+\t(cp_parser_label_for_labeled_statement): Likewise.\n+\t(cp_parser_range_for): Likewise.\n+\t(cp_parser_enum_specifier): Likewise.\n+\t(cp_parser_class_head): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\n 2010-12-15  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR c++/46852"}, {"sha": "3e6930f2c49fa730dbdb6b0316671ecb7b58f8aa", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=782d1c333f42c650699be7f7f4679c38ab544ecd", "patch": "@@ -1700,6 +1700,9 @@ typedef struct GTY(()) cp_parser {\n      a local class.  */\n   bool in_function_body;\n \n+  /* TRUE if we can auto-correct a colon to a scope operator.  */\n+  bool colon_corrects_to_scope_p;\n+\n   /* If non-NULL, then we are parsing a construct where new type\n      definitions are not permitted.  The string stored here will be\n      issued as an error message if a type is defined.  */\n@@ -3244,6 +3247,9 @@ cp_parser_new (void)\n   /* We are not parsing a function body.  */\n   parser->in_function_body = false;\n \n+  /* We can correct until told otherwise.  */\n+  parser->colon_corrects_to_scope_p = true;\n+\n   /* The unparsed function queue is empty.  */\n   push_unparsed_function_queues (parser);\n \n@@ -4553,6 +4559,16 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t     template-id), nor a `::', then we are not looking at a\n \t     nested-name-specifier.  */\n \t  token = cp_lexer_peek_nth_token (parser->lexer, 2);\n+\n+\t  if (token->type == CPP_COLON\n+\t      && parser->colon_corrects_to_scope_p\n+\t      && cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_NAME)\n+\t    {\n+\t      error_at (token->location,\n+\t\t\t\"found %<:%> in nested-name-specifier, expected %<::%>\");\n+\t      token->type = CPP_SCOPE;\n+\t    }\n+\n \t  if (token->type != CPP_SCOPE\n \t      && !cp_parser_nth_token_starts_template_argument_list_p\n \t\t  (parser, 2))\n@@ -6955,12 +6971,15 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n     }\n   else\n     {\n+      bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+      parser->colon_corrects_to_scope_p = false;\n       /* Parse the expression.  */\n       c_inhibit_evaluation_warnings += logical_or_expr == truthvalue_false_node;\n       expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n       c_inhibit_evaluation_warnings +=\n \t((logical_or_expr == truthvalue_true_node)\n \t - (logical_or_expr == truthvalue_false_node));\n+      parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n     }\n \n   /* The next token should be a `:'.  */\n@@ -8153,6 +8172,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n {\n   cp_token *token;\n   tree label = NULL_TREE;\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n \n   /* The next token should be an identifier.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -8163,6 +8183,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n       return;\n     }\n \n+  parser->colon_corrects_to_scope_p = false;\n   switch (token->keyword)\n     {\n     case RID_CASE:\n@@ -8241,6 +8262,8 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n       else\n \tcplus_decl_attributes (&label, attrs, 0);\n     }\n+\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n }\n \n /* Parse an expression-statement.\n@@ -8710,7 +8733,9 @@ cp_parser_range_for (cp_parser *parser)\n   cp_declarator *declarator;\n   const char *saved_message;\n   tree attributes, pushed_scope;\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n \n+  parser->colon_corrects_to_scope_p = false;\n   cp_parser_parse_tentatively (parser);\n   /* New types are not allowed in the type-specifier-seq for a\n      range-based for loop.  */\n@@ -8727,7 +8752,8 @@ cp_parser_range_for (cp_parser *parser)\n   if (cp_parser_error_occurred (parser))\n     {\n       cp_parser_abort_tentative_parse (parser);\n-      return NULL_TREE;\n+      stmt = NULL_TREE;\n+      goto out;\n     }\n   /* Parse the declarator.  */\n   declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n@@ -8774,6 +8800,8 @@ cp_parser_range_for (cp_parser *parser)\n     /* Convert the range-based for loop into a normal for-statement. */\n     stmt = cp_convert_range_for (stmt, range_decl, range_expr);\n \n+ out:\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n   return stmt;\n }\n \n@@ -13343,6 +13371,9 @@ cp_parser_enum_specifier (cp_parser* parser)\n   bool is_anonymous = false;\n   tree underlying_type = NULL_TREE;\n   cp_token *type_start_token = NULL;\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+\n+  parser->colon_corrects_to_scope_p = false;\n \n   /* Parse tentatively so that we can back up if we don't find a\n      enum-specifier.  */\n@@ -13470,15 +13501,21 @@ cp_parser_enum_specifier (cp_parser* parser)\n \t{\n \t  cp_parser_error (parser, \"expected %<{%>\");\n \t  if (has_underlying_type)\n-\t    return NULL_TREE;\n+\t    {\n+\t      type = NULL_TREE;\n+\t      goto out;\n+\t    }\n \t}\n       /* An opaque-enum-specifier must have a ';' here.  */\n       if ((scoped_enum_p || underlying_type)\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \t{\n \t  cp_parser_error (parser, \"expected %<;%> or %<{%>\");\n \t  if (has_underlying_type)\n-\t    return NULL_TREE;\n+\t    {\n+\t      type = NULL_TREE;\n+\t      goto out;\n+\t    }\n \t}\n     }\n \n@@ -13622,6 +13659,8 @@ cp_parser_enum_specifier (cp_parser* parser)\n \t  pop_nested_namespace (nested_name_specifier);\n \t}\n     }\n+ out:\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n   return type;\n }\n \n@@ -17087,6 +17126,7 @@ cp_parser_class_head (cp_parser* parser,\n   bool qualified_p = false;\n   bool invalid_nested_name_p = false;\n   bool invalid_explicit_specialization_p = false;\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n   tree pushed_scope = NULL_TREE;\n   unsigned num_templates;\n   cp_token *type_start_token = NULL, *nested_name_specifier_token_start = NULL;\n@@ -17095,6 +17135,7 @@ cp_parser_class_head (cp_parser* parser,\n   /* Assume no template parameter lists will be used in defining the\n      type.  */\n   num_templates = 0;\n+  parser->colon_corrects_to_scope_p = false;\n \n   *bases = NULL_TREE;\n \n@@ -17234,7 +17275,8 @@ cp_parser_class_head (cp_parser* parser,\n   if (!cp_parser_next_token_starts_class_definition_p (parser))\n     {\n       cp_parser_error (parser, \"expected %<{%> or %<:%>\");\n-      return error_mark_node;\n+      type = error_mark_node;\n+      goto out;\n     }\n \n   /* At this point, we're going ahead with the class-specifier, even\n@@ -17245,13 +17287,15 @@ cp_parser_class_head (cp_parser* parser,\n     {\n       cp_parser_error (parser,\n \t\t       \"global qualification of class name is invalid\");\n-      return error_mark_node;\n+      type = error_mark_node;\n+      goto out;\n     }\n   else if (invalid_nested_name_p)\n     {\n       cp_parser_error (parser,\n \t\t       \"qualified name does not name a class\");\n-      return error_mark_node;\n+      type = error_mark_node;\n+      goto out;\n     }\n   else if (nested_name_specifier)\n     {\n@@ -17454,6 +17498,8 @@ cp_parser_class_head (cp_parser* parser,\n   if (type)\n     DECL_SOURCE_LOCATION (TYPE_NAME (type)) = type_start_token->location;\n   *attributes_p = attributes;\n+ out:\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n   return type;\n }\n \n@@ -17582,6 +17628,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   cp_token *decl_spec_token_start = NULL;\n   cp_token *initializer_token_start = NULL;\n   int saved_pedantic;\n+  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n \n   /* Check for the `__extension__' keyword.  */\n   if (cp_parser_extension_opt (parser, &saved_pedantic))\n@@ -17640,8 +17687,10 @@ cp_parser_member_declaration (cp_parser* parser)\n       return;\n     }\n \n+  parser->colon_corrects_to_scope_p = false;\n+\n   if (cp_parser_using_declaration (parser, /*access_declaration=*/true))\n-    return;\n+    goto out;\n \n   /* Parse the decl-specifier-seq.  */\n   decl_spec_token_start = cp_lexer_peek_token (parser->lexer);\n@@ -17654,7 +17703,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   /* Check for an invalid type-name.  */\n   if (!decl_specifiers.any_type_specifiers_p\n       && cp_parser_parse_and_diagnose_invalid_type_name (parser))\n-    return;\n+    goto out;\n   /* If there is no declarator, then the decl-specifier-seq should\n      specify a type.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n@@ -17824,7 +17873,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  if (cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t      CPP_SEMICOLON))\n \t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t  return;\n+\t\t  goto out;\n \t\t}\n \n \t      if (declares_class_or_enum & 2)\n@@ -17903,7 +17952,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  /* If the next token is a semicolon, consume it.  */\n \t\t  if (token->type == CPP_SEMICOLON)\n \t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t  return;\n+\t\t  goto out;\n \t\t}\n \t      else\n \t\tif (declarator->kind == cdk_function)\n@@ -17958,11 +18007,13 @@ cp_parser_member_declaration (cp_parser* parser)\n \t    }\n \n \t  if (assume_semicolon)\n-\t    return;\n+\t    goto out;\n \t}\n     }\n \n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+ out:\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n }\n \n /* Parse a pure-specifier."}, {"sha": "7de0beae8a823bb7f47e780aabe194af159b362f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=782d1c333f42c650699be7f7f4679c38ab544ecd", "patch": "@@ -1,3 +1,11 @@\n+2010-12-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\tPR c++/39859\n+\tPR c++/44522\n+\tPR c++/44523\n+\t* g++.dg/parse/colon-autocorrect-1.C: New testcase.\n+\t* g++.dg/parse/colon-autocorrect-2.C: New testcase.\n+\n 2010-12-15  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR c++/46852"}, {"sha": "8e25fbac21ff4bde53206a06958ba1ca2a11b011", "filename": "gcc/testsuite/g++.dg/parse/colon-autocorrect-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcolon-autocorrect-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcolon-autocorrect-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcolon-autocorrect-1.C?ref=782d1c333f42c650699be7f7f4679c38ab544ecd", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/44522\n+// { dg-do compile }\n+\n+namespace x {\n+  struct a { };\n+  a A0;\n+}\n+\n+x:a a2;\t\t\t\t// { dg-error \"nested-name-specifier\" }\n+x::a a3 = a2;\n+\n+x:a f (void)\t\t\t// { dg-error \"nested-name-specifier\" }\n+{\n+  x::a a4;\t\t\t// x:a would parse like a label\n+  return a4;\n+}\n+\n+x::a g (x:a a4)\t\t\t// { dg-error \"nested-name-specifier\" }\n+{\n+  return a4;\n+}\n+\n+class B\n+{\n+  x::a f(void)\t\t\t// x:a would parse like a bitfield\n+  {\n+    x::a a4;\n+    a4 = x:A0;\t\t\t// { dg-error \"nested-name-specifier\" }\n+    return a4;\n+  }\n+};"}, {"sha": "1dfcbc0681ab8f43b71acab9dc90fff16e8a34c7", "filename": "gcc/testsuite/g++.dg/parse/colon-autocorrect-2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcolon-autocorrect-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782d1c333f42c650699be7f7f4679c38ab544ecd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcolon-autocorrect-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcolon-autocorrect-2.C?ref=782d1c333f42c650699be7f7f4679c38ab544ecd", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/44523\n+// { dg-do compile }\n+\n+namespace x {\n+  struct a { };\n+}\n+\n+template <typename t>\n+class foo {\n+};\n+\n+foo<x::a> a1;\n+foo<x:a> a2;\t\t\t// { dg-error \"nested-name-specifier\" }\n+\n+x::a a3 = a2;\t\t\t// { dg-error \"conversion\" }"}]}