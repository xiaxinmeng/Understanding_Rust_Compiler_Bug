{"sha": "f62502329f678b44c082429ccf4e705700c4d5ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyNTAyMzI5ZjY3OGI0NGMwODI0MjljY2Y0ZTcwNTcwMGM0ZDVlYQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:37Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:37Z"}, "message": "(\nMigrate from devo/gcc/ch.\n\nFrom-SVN: r22030", "tree": {"sha": "2031e7dc1d04d7f622bcc3ed445e451c9645a295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2031e7dc1d04d7f622bcc3ed445e451c9645a295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f62502329f678b44c082429ccf4e705700c4d5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62502329f678b44c082429ccf4e705700c4d5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62502329f678b44c082429ccf4e705700c4d5ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62502329f678b44c082429ccf4e705700c4d5ea/comments", "author": null, "committer": null, "parents": [{"sha": "db3c7f059cdfae7d62d042ba77daf6ae1f6431fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3c7f059cdfae7d62d042ba77daf6ae1f6431fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3c7f059cdfae7d62d042ba77daf6ae1f6431fd"}], "stats": {"total": 1241, "additions": 1241, "deletions": 0}, "files": [{"sha": "70d30fce4f2a532112b9dddb1d13aafa16beca94", "filename": "gcc/ch/loop.c", "status": "added", "additions": 1241, "deletions": 0, "changes": 1241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62502329f678b44c082429ccf4e705700c4d5ea/gcc%2Fch%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62502329f678b44c082429ccf4e705700c4d5ea/gcc%2Fch%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Floop.c?ref=f62502329f678b44c082429ccf4e705700c4d5ea", "patch": "@@ -0,0 +1,1241 @@\n+/* Implement looping actions for CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <limits.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"ch-tree.h\"\n+#include \"lex.h\"\n+#include \"flags.h\"\n+#include \"actions.h\"\n+#include \"input.h\"\n+#include \"obstack.h\"\n+#include \"assert.h\"\n+#include \"rtl.h\"\n+\n+/* if the user codes '-flocal-loop-counter' on the command line,\n+   ch-actions.c (lang_decode_option) will set this flag. */\n+int flag_local_loop_counter = 1;\n+\n+extern rtx  emit_line_note              PROTO((char *, int)); \n+extern void error                       PROTO((char *, ...));\n+extern rtx  expand_assignment           PROTO((tree, tree, int, int));\n+extern void save_expr_under_name        PROTO((tree, tree));\n+extern void stamp_nesting_label         PROTO((tree));\n+extern int  int_fits_type_p             PROTO((tree, tree));\n+extern void warning                     PROTO((char *, ...));\n+\n+/* forward declarations */\n+static int  declare_temps            PROTO((void));\n+static int  initialize_iter_var      PROTO((void));\n+static void maybe_skip_loop          PROTO((void));\n+static int  bottom_loop_end_check    PROTO((void));\n+static int  increment_temps          PROTO((void));\n+static tree build_temporary_variable PROTO((char *, tree));\n+static tree maybe_make_for_temp      PROTO((tree, char *, tree));\n+static tree chill_unsigned_type      PROTO((tree));\n+\f\n+/* In terms of the parameters passed to build_loop_iterator,\n+ *   there are several types of loops.  They are encoded by\n+ *   the ITER_TYPE enumeration.\n+ *\n+ *   1) DO FOR EVER; ... OD\n+ *      indicated by a NULL_TREE start_exp, step_exp and end_exp,\n+ *      condition == NULL, in_flag = 0, and ever_flag == 1 in the\n+ *      first ITERATOR.\n+ *\n+ *   2) DO WHILE cond; ... OD\n+ *      indicated by NULL_TREE start_exp, step_exp and end_exp, \n+ *      in_flag = 0, and condition != NULL.\n+ *\n+ *   3) DO; ... OD\n+ *      indicated by NULL_TREEs in start_exp, step_exp and end_exp,\n+ *      condition != NULL, in_flag == 0 and ever_flag == 0.  This\n+ *      is not really a loop, but a compound statement.\n+ *\n+ *   4) DO FOR user_var := start_exp \n+ *         [DOWN] TO end_exp BY step_exp; ... DO\n+ *      indicated by non-NULL_TREE start_exp, step_exp and end_exp.\n+ *\n+ *   5) DO FOR user_var [DOWN] IN discrete_mode; ... OD\n+ *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n+ *      discrete mode, with an optional down_flag.\n+ *\n+ *   6) DO FOR user_var [DOWN] IN powerset_expr; ... OD\n+ *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n+ *      powerset mode, with an optional down_flag.\n+ *\n+ *   7) DO FOR user_var [DOWN] IN location; ... OD\n+ *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n+ *      location mode, with an optional down_flag.\n+ */\n+typedef enum \n+{\n+   DO_FOREVER,\n+   DO_OD,\n+   DO_STEP,\n+   DO_POWERSET,\n+   DO_LOC,\n+   DO_LOC_VARYING \n+} ITER_TYPE;\n+\n+\n+typedef struct iterator \n+{\n+/* These variables only have meaning in the first ITERATOR structure. */\n+  ITER_TYPE itype;                  /* type of this iterator */\n+  int  error_flag;                  /* TRUE if no loop was started due to \n+\t\t\t\t       user error */\n+  int  down_flag;                   /* TRUE if DOWN was coded */\n+\n+/* These variables have meaning in every ITERATOR structure. */\n+  tree user_var;                    /* user's explicit iteration variable */\n+  tree start_exp;                   /* user's start expression\n+                                       or IN expression of a FOR .. IN*/\n+  tree step_exp;                    /* user's step expression */\n+  tree end_exp;                     /* user's end expression */\n+  tree start_temp;                  /* temp holding evaluated start_exp */\n+  tree end_temp;                    /* temp holding evaluated end_exp */\n+  tree step_temp;                   /* temp holding evaluated step_exp */\n+  tree powerset_temp;               /* temp holding user's initial powerset expression */\n+  tree loc_ptr_temp;                /* temp holding count for LOC enumeration ptr */\n+  tree iter_var;                    /* hidden variable for the loop */\n+  tree iter_type;                   /* hidden variable's type */\n+  tree stepin_type;                 /* saved type for a DO FOR IN loop */\n+  tree base_type;                   /* LOC enumeration base type */\n+  struct iterator *next;            /* ptr to next iterator for this loop */\n+} ITERATOR;\n+\n+/*\n+ * There's an entry like this for each nested DO loop.\n+ * The list is maintained by push_loop_block\n+ * and pop_loop_block.\n+ */\n+typedef struct loop {\n+  struct loop *nxt_level;   /* pointer to enclosing loop */\n+  ITERATOR    *iter_list;   /* iterators for the current loop */\n+} LOOP;\n+\n+static LOOP *loopstack = (LOOP *)0;\n+\f\n+#if 0\n+\n+Here is a CHILL DO FOR statement:\n+\n+DO FOR user_var := start_exp BY step_exp [DOWN] TO end_exp \n+   WHILE condition;\n+\n+For this loop to be 'safe', like a Pascal FOR loop, the start,\n+end, and increment expressions are computed once, before the\n+assignment to the iteration variable and saved in temporaries,\n+before the first assignment of the iteration variable, so the\n+following works:\n+\n+          FOR i := (i+1) TO (i+10) DO\n+\n+To prevent changes to the start/end/step expressions from\n+effecting the loop''s termination, and to make the loop end-check\n+as simple as possible, we evaluate the step expression into\n+a temporary and compute a hidden iteration count before entering \n+the loop''s body.  User code cannot effect the counter, and the\n+end-loop check simply decrements the counter and checks for zero.\n+\n+The whole phrase FOR iter := ... TO end_exp can be repeated\n+multiple times, with different user-iteration variables.  This\n+is discussed later.\n+\n+The loop counter calculations need careful design since a loop\n+from MININT TO MAXINT must work, in the precision of integers.\n+\n+Here''s how it works, in C:\n+\n+        0) The DO ... OD loop is simply a block with \n+           its own scope.  \n+\n+\t1) The DO FOR EVER is simply implemented:\n+\n+\t   loop_top:\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tgoto loop_top\n+\t   end_loop:\n+\n+\t2) The DO WHILE is also simple:\n+\n+\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tgoto loop_top\n+\t   end_loop:\n+\n+\n+\t3) The DO FOR [while condition] loop (no DOWN)\n+\n+\tpush a new scope,\n+\tdecl iter_var\n+\n+\t\tstep_temp = step_exp\n+                start_temp = start_exp\n+                end_temp = end_exp\n+\t\tif (end_exp < start_exp) goto end_loop\n+                /* following line is all unsigned arithmetic */\n+\t\titer_var = (end_exp - start_exp) / step_exp\n+                user_var = start_temp\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tif (iter_var == 0) goto end_loop\n+                iter_var--\n+                user_var += step_temp\n+\t\tgoto loop_top\n+\tend_loop:\n+\tpop scope\n+\n+\t4) The for [while condition] loop (with DOWN)\n+\n+\tpush a new scope,\n+        decl iter\n+\t\tstep_temp = step_exp\n+                start_temp = start_exp\n+                end_temp = end_exp\n+\t\tif (end_exp > start_exp) goto end_loop\n+                /* following line is all unsigned arithmetic */\n+\t\titer_var = (start_exp - end_exp) / step_exp\n+                user_var = start_temp\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tif (iter_var == 0) goto end_loop\n+                iter_var--\n+\t\tuser_var -= step_temp\n+\t\tgoto loop_top\n+\t    end_loop:\n+\tpop scope\n+\n+\n+        5) The range loop, which iterates over a mode''s possible\n+           values, works just like the above step loops, but with\n+           the start and end values taken from the mode''s lower\n+           and upper domain values.\n+\f\n+\n+\t6) The FOR IN loop, where a location enumeration is\n+           specified (see spec on page 81 of Z.200, bottom\n+           of page 186):\n+\n+\tpush a new scope,\n+        decl iter_var as an unsigned integer\n+             loc_ptr_temp as pointer to a composite base type\n+        \n+               if array is varying\n+                   iter_var = array''s length field\n+               else\n+                   iter_var = sizeof array / sizeof base_type\n+\t       loc_ptr_temp = &of highest or lowest indexable entry\n+\t   loop_top:\n+\t\tif (!condition) goto end_loop\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+                iter_var--\n+                if (iter_var == 0) goto end_loop               \n+\t\tloc_ptr_temp +/-= sizeof array base_type\n+\t\tgoto loop_top\n+\t   end_loop:\n+\tpop scope\n+\n+\t7) The DO FOR (DOWN) IN powerset_exp\n+\n+\tpush a new scope,\n+\tdecl iterator as basetype of powerset\n+\n+\t        powerset_temp := save_expr (start_exp)\n+\t\titer_var := DOWN ? length  : 0\n+\t   loop_top:\n+\t        if (DOWN)\n+\t\t  iter_var := __ffsetclrpowerset (powerset_temp, length,\n+\t\t\t\t\t\t  iter_var);\n+\t        else\n+\t\t  iter_var := __ffsetclrpowerset (powrset_temp, iter_var, 0);\n+\t\tif (iter_var < 0) goto end_loop;\n+\t\tuser_var = iter_var + min_value;\n+\t\tif (!condition) goto end_loop\n+\t\tif (!DOWN) iter_var +:= 1;\n+\t\t.\n+\t\t. body of loop\n+\t\t.\n+\t\tgoto loop_top\n+\t   end_loop:\n+\tpop scope\n+\f\n+\n+So, here''s the general DO FOR schema, as implemented here:\n+\n+        expand_start_loop   -- start the loop''s control scope\n+        -- start scope for synthesized loop variables\n+        declare_temps       -- create, initialize temporary variables\n+        maybe_skip_loop     -- skip loop if end conditions unsatisfiable\n+        initialize_iter_var -- initialize the iteration counter\n+                            -- initialize user''s loop variable\n+        expand_start_loop   -- generate top-of-loop label\n+        top_loop_end_check  -- generate while code and/or\n+                               powerset find-a-bit function call\n+        .\n+        .\n+        .  user''s loop body code\n+        .\n+        .\n+        bottom_loop_end_check  -- exit if counter has become zero\n+        increment_temps     -- update temps for next iteration\n+        expand_end_loop     -- generate jump back to top of loop\n+        expand_end_cond     -- generate label for end of conditional\n+        -- end of scope for synthesized loop variables\n+        free_iterators      -- free up iterator space\n+\n+When there are two or more iterator phrases, each of the\n+above loop steps must act upon all iterators.  For example,\n+the 'increment_temps' step must increment all temporaries\n+(associated with all iterators).\n+\n+ NOTE: Z.200, section 10.1 says that a block is ...\n+       \"the actions statement list in a do action, including any\n+       loop counter and while control\".  This means that an exp-\n+       ression in a WHILE control can include references to the\n+       loop counters created for the loop''s exclusive use.  \n+       Example:\n+\n+             DCL a (1:10) INT;\n+             DCL j INT;\n+             DO FOR j IN a WHILE j > 0;\n+             ...\n+             OD;\n+       The 'j' referenced in the while is the loc-identity 'j'\n+       created inside the loop''s scope, and NOT the 'j' declared\n+       before the loop.\n+#endif\n+\f\n+/*\n+ * The following routines are called directly by the\n+ * CHILL parser.\n+ */\n+void\n+push_loop_block ()\n+{\n+  LOOP *temp = (LOOP *)xmalloc (sizeof (LOOP));\n+\n+  /* push a new loop onto the stack */\n+  temp->nxt_level = loopstack;\n+  temp->iter_list = (ITERATOR *)0;\n+  loopstack = temp;\n+}\n+\n+void\n+pop_loop_block ()\n+{\n+  LOOP *do_temp = loopstack;\n+  ITERATOR  *ip;\n+\n+  /* pop loop block off the list */\n+  loopstack = do_temp->nxt_level;\n+\n+  /* free the loop's iterator blocks */\n+  ip = do_temp->iter_list;\n+  while (ip != NULL)\n+    {\n+      ITERATOR *temp = ip->next;\n+      free (ip);\n+      ip = temp;\n+    }\n+  free (do_temp);\n+}\n+\f\n+void\n+begin_loop_scope ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list;\n+\n+  pushlevel (1);\n+\n+  if (pass >= 2)\n+    {\n+      declare_temps ();\n+\n+      clear_last_expr ();\n+      push_momentary ();\n+      expand_start_bindings (0);\n+    }\n+\n+  push_handler ();\n+\n+}\n+\n+\n+void\n+end_loop_scope (opt_label)\n+     tree opt_label;\n+{\n+  if (opt_label)\n+    possibly_define_exit_label (opt_label);\n+\n+  if (pass == 2)\n+    {\n+      expand_end_bindings (getdecls (), kept_level_p (), 0);\n+      pop_momentary ();\n+    }\n+  poplevel (kept_level_p (), 1, 0);\n+}\n+\f\n+\n+/* we need the above 2 functions somehow modified for initialising\n+   of non-value arrays */\n+\n+void\n+nonvalue_begin_loop_scope ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list;\n+\n+  pushlevel (0); /* this happens only in pass 2 */\n+\n+  declare_temps ();\n+\n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n+}\n+\n+void\n+nonvalue_end_loop_scope ()\n+{\n+  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+  pop_momentary ();\n+  poplevel (kept_level_p (), 1, 0);\n+}\n+\f\n+/* The iterator structure records all aspects of a \n+ * 'FOR i := start [DOWN] TO end' clause or\n+ * 'FOR i IN modename' or 'FOR i IN powerset' clause.\n+ * It's saved on the iter_list of the current LOOP.\n+ */\n+void\n+build_loop_iterator (user_var, start_exp, step_exp, end_exp, \n+\t\t     down_flag, in_flag, ever_flag)\n+     tree user_var, start_exp, step_exp, end_exp;\n+     int  down_flag, in_flag, ever_flag;\n+{\n+  ITERATOR *ip = (ITERATOR *)xmalloc (sizeof (ITERATOR));\n+\n+  /* chain this iterator onto the current loop */\n+  if (loopstack->iter_list == NULL)\n+    loopstack->iter_list = ip;\n+  else\n+    {\n+      ITERATOR *temp = loopstack->iter_list;\n+      while (temp->next != NULL)\n+\ttemp = temp->next;\n+      temp->next = ip;\n+    }\n+\n+  ip->user_var      = user_var;\n+  ip->start_exp     = start_exp;\n+  ip->step_exp      = step_exp;\n+  ip->end_exp       = end_exp;\n+  ip->start_temp    = NULL_TREE;\n+  ip->end_temp      = NULL_TREE;\n+  ip->step_temp     = NULL_TREE;\n+  ip->down_flag     = down_flag;\n+  ip->powerset_temp = NULL_TREE;\n+  ip->iter_var      = NULL_TREE;\n+  ip->iter_type     = NULL_TREE;\n+  ip->stepin_type   = NULL_TREE;\n+  ip->loc_ptr_temp  = NULL_TREE;\n+  ip->error_flag    = 1;          /* assume error will be found */\n+  ip->next          = (ITERATOR *)0;\n+\n+  if (ever_flag)\n+    ip->itype = DO_FOREVER;\n+  else if (in_flag && start_exp != NULL_TREE)\n+    {\n+      if (TREE_CODE (start_exp) == ERROR_MARK)\n+\treturn;\n+      if (TREE_TYPE (start_exp) == NULL_TREE)\n+\t{\n+\t  if (TREE_CODE (start_exp) == CONSTRUCTOR)\n+\t    error (\"modeless tuple not allowed in this context\");\n+\t  else\n+\t    error (\"IN expression does not have a mode\");\n+\t  return;\n+\t}\n+      if (TREE_CODE (TREE_TYPE (start_exp)) == SET_TYPE)\n+\t{\n+\t  if (CH_BOOLS_TYPE_P (TREE_TYPE (start_exp)))\n+\t    {\n+\t      sorry (\"location enumeration for BOOLS\");\n+\t      return;\n+\t    }\n+\t  ip->itype = DO_POWERSET;\n+\t}\n+      else if (discrete_type_p (TREE_TYPE (ip->start_exp)))\n+\t{\n+\t  /* range enumeration */\n+\t  tree type = TREE_TYPE (ip->start_exp);\n+\t  /* save the original type for later use in determine to do a\n+\t     rangecheck or not */\n+\t  ip->stepin_type = type;\n+\t  ip->itype = DO_STEP;\n+\t  if (ip->down_flag)\n+\t    {\n+\t      ip->start_exp = build_chill_upper (type);\n+\t      ip->end_exp = build_chill_lower (type);\n+\t    }\n+\t  else\n+\t    {\n+\t      ip->start_exp = build_chill_lower (type);\n+\t      ip->end_exp = build_chill_upper (type);\n+\t    }\n+\t}\n+      else if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ARRAY_TYPE)\n+\t{\n+\t  if (TYPE_PACKED (TREE_TYPE (ip->start_exp)))\n+\t    {\n+\t      sorry (\"location enumeration for bit-packed arrays\");\n+\t      return;\n+\t    }\n+\t  ip->itype = DO_LOC;\n+\t}\n+      else if (chill_varying_type_p (TREE_TYPE (ip->start_exp)))\n+\tip->itype = DO_LOC_VARYING;\n+      else\n+\t{\n+\t  error (\"Loop's IN expression is not a composite object\");\n+\t  return;\n+\t}\n+    }\n+  else\n+    ip->itype = DO_STEP;\n+  if (ip->itype == DO_STEP)\n+    {\n+      struct ch_class class;\n+\n+      if (ip->step_exp == NULL_TREE)\n+\tip->step_exp = integer_one_node;\n+\n+      if (! discrete_type_p (TREE_TYPE (ip->start_exp)))\n+\t{\n+\t  error (\"start expr must have discrete mode\");\n+\t  return;\n+\t}\n+      if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ENUMERAL_TYPE\n+\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->start_exp)))\n+\t{\n+\t  error (\"DO FOR start expression is a numbered SET\");\n+\t  return;\n+\t}\n+      if (TREE_CODE (ip->end_exp) == ERROR_MARK)\n+\treturn;\n+      if (TREE_CODE (TREE_TYPE (ip->end_exp)) == ENUMERAL_TYPE\n+\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->end_exp)))\n+\t{\n+\t  error (\"TO expression is a numbered SET\");\n+\t  return;\n+\t}\n+      if (! discrete_type_p (TREE_TYPE (ip->end_exp)))\n+\t{\n+\t  error (\"TO expr must have discrete mode\");\n+\t  return;\n+\t}\n+      if (! CH_COMPATIBLE_CLASSES (ip->start_exp, ip->end_exp))\n+\t{\n+\t  error (\"start expr and TO expr must be compatible\");\n+\t  return;\n+\t}\n+      if (step_exp != NULL_TREE)\n+\t{\n+\t  if (TREE_CODE (step_exp) == ERROR_MARK)\n+\t    return;\n+\t  if (! discrete_type_p (TREE_TYPE (step_exp)))\n+\t    {\n+\t      error (\"BY expr must have discrete mode\");\n+\t      return;\n+\t    }\n+\t  if (! CH_COMPATIBLE_CLASSES (ip->start_exp, step_exp))\n+\t    {\n+\t      error (\"start expr and BY expr must be compatible\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (! flag_local_loop_counter)\n+\t{\n+\t  /* In this case, it's a previously-declared VAR_DECL node. */\n+\t  tree id_node = ip->user_var;\n+\t  if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n+\t    ip->user_var = lookup_name (ip->user_var);\n+\n+\t  /* Chill 1984 allows the name to be a defining occurrence,\n+\t     but does not require it. */\n+\t  if (ip->user_var == NULL_TREE)\n+\t    {\n+\t      warning (\"loop identifier undeclared\");\n+\t      ip->user_var = id_node;\n+\t      /* We declare a local name below. */\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (ip->user_var)) == REFERENCE_TYPE)\n+\t\tip->user_var = convert_from_reference (ip->user_var);\n+\n+\t      if (! CH_COMPATIBLE_CLASSES (ip->start_exp, ip->user_var))\n+\t\t{\n+\t\t  error (\"loop variable incompatible with start expression\");\n+\t\t  return;\n+\t\t}\n+\t      class = chill_expr_class (ip->user_var);\n+\t    }\n+\t}\n+      /* Otherwise, declare a new name. */\n+      if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n+\t{\n+\t  class = CH_RESULTING_CLASS (chill_expr_class (ip->start_exp),\n+\t\t\t\t      chill_expr_class (ip->end_exp));\n+\t  if (step_exp)\n+\t    class = CH_RESULTING_CLASS (class, chill_expr_class (step_exp));\n+\n+\t  /* Integer literals noramally have type 'long long'\n+\t     (see convert_integer in lex.c).  That is usually overkill. */\n+\t  if (class.kind == CH_DERIVED_CLASS\n+\t      && class.mode == long_long_integer_type_node\n+\t      && int_fits_type_p (ip->start_exp, integer_type_node)\n+\t      && int_fits_type_p (ip->end_exp, integer_type_node))\n+\t    class.mode = integer_type_node;\n+\t}\n+\n+      if (TREE_CODE (ip->start_exp) == INTEGER_CST\n+\t  && TREE_CODE (ip->end_exp) == INTEGER_CST\n+\t  && compare_int_csts (ip->down_flag ? LT_EXPR : GT_EXPR,\n+\t\t\t       ip->start_exp, ip->end_exp))\n+\twarning (\"body of DO FOR will never execute\");\n+\n+      ip->start_exp = convert_to_class (class, ip->start_exp);\n+      ip->end_exp   = convert_to_class (class, ip->end_exp);\n+      ip->step_exp = convert_to_class (class, ip->step_exp);\n+\n+      if (TREE_CODE (ip->step_exp) != INTEGER_CST)\n+\t{\n+\t  /* generate runtime check for negative BY expr */\n+\t  ip->step_exp = \n+\t    check_range (ip->step_exp, ip->step_exp,\n+\t\t\t integer_zero_node, NULL_TREE);\n+\t}\n+      else if (compare_int_csts (LE_EXPR, ip->step_exp, integer_zero_node))\n+\t{\n+\t  error (\"BY expression is negative or zero\");\n+\t  return;\n+\t}\n+    }\n+\n+  ip->error_flag = 0;           /* no errors! */\n+}\n+\f\n+void\n+build_loop_start (start_label)\n+     tree start_label;\n+{\n+  ITERATOR *firstp = loopstack->iter_list;\n+  \n+  if (firstp->error_flag)\n+    return;\n+\n+  maybe_skip_loop ();\n+\n+  if (initialize_iter_var ())\n+    return;\n+\n+  /* use the label as an 'exit' label, \n+     'goto' needs another sort of label */\n+  expand_start_loop (start_label != NULL_TREE);\n+}\n+\f\n+/*\n+ * Called after the last action of the loop body\n+ * has been parsed.\n+ */\n+void\n+build_loop_end ()\n+{\n+  ITERATOR *ip = loopstack->iter_list;\n+\n+  emit_line_note (input_filename, lineno);\n+\n+  if (ip->error_flag)\n+    return;\n+\n+  if (bottom_loop_end_check ())\n+    return;\n+\n+  if (increment_temps ())\n+    return;\n+\n+  expand_end_loop ();\n+\n+  for (; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_LOC_VARYING:\n+\tcase DO_STEP:\n+\t  expand_end_cond ();\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}\n+\f\n+/*\n+ * Reserve space for any loop-control temporaries, initialize them\n+ */\n+static int\n+declare_temps ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list, *ip;\n+  tree start_ptr;\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\t  break;\n+\tcase DO_STEP:\n+\t  ip->iter_type\n+\t    = type_for_size (TYPE_PRECISION (TREE_TYPE (ip->start_exp)), 1);\n+\n+\t  /* create, initialize temporaries if expressions aren't constant */\n+\t  ip->start_temp = maybe_make_for_temp (ip->start_exp, \"for_start\",\n+\t\t\t\t\t\tTREE_TYPE (ip->start_exp));\n+\t  ip->end_temp = maybe_make_for_temp (ip->end_exp, \"for_end\",\n+\t\t\t\t\t      TREE_TYPE (ip->end_exp));\n+\t  /* this is just the step-expression */\n+\t  ip->step_temp    = maybe_make_for_temp (ip->step_exp, \"for_step\",\n+\t\t\t\t\t\t  TREE_TYPE (ip->step_exp));\n+\t  if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n+\t    {\n+\t      /* (re-)declare the user's iteration variable in the \n+\t\t loop's scope. */\n+\t      tree id_node = ip->user_var;\n+\t      ip->user_var = \n+\t\tdecl_temp1 (id_node, TREE_TYPE (ip->start_exp), 0, NULL_TREE,\n+\t\t\t    0, 0);\n+\t      CH_DERIVED_FLAG (ip->user_var) = CH_DERIVED_FLAG (ip->start_exp);\n+\t      pushdecl (ip->user_var);\n+\t    }\n+\t  ip->iter_var = \n+\t    decl_temp1 (get_unique_identifier (\"iter_var\"),\n+\t\t\tip->iter_type, 0, NULL_TREE, 0, 0);\n+\t  break;\n+\n+\tcase DO_POWERSET:\n+\t  /* the user's powerset-expression */\n+\t  ip->powerset_temp = save_expr (ip->start_exp);\n+\t  mark_addressable (ip->powerset_temp);\n+\n+\t  ip->iter_type = integer_type_node;\n+\t  ip->iter_var = decl_temp1 (get_unique_identifier (\"iter_var\"),\n+\t\t\t\t     ip->iter_type, 0,\n+\t\t\t\t     !ip->down_flag ? integer_zero_node\n+\t\t\t\t     : powersetlen (ip->powerset_temp),\n+\t\t\t\t     0, 0);\n+\n+\t  if (flag_local_loop_counter)\n+\t    {\n+\t      /* declare the user's iteration variable in the loop's scope. */\n+\t      /* in this case, it's just an IDENTIFIER_NODE */\n+\t      ip->user_var = \n+\t\tdecl_temp1 (ip->user_var,\n+\t\t\t    TYPE_DOMAIN (TREE_TYPE (ip->start_exp)),\n+\t\t\t    0, NULL_TREE, 0, 0);\n+\t      pushdecl (ip->user_var);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* in this case, it's a previously-declared VAR_DECL node */\n+\t      ip->user_var = lookup_name (ip->user_var);\n+\t    }\n+\t  break;\n+\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  ip->iter_type = chill_unsigned_type_node;\n+\t  /* create the counter temp */\n+\t  ip->iter_var = \n+\t    build_temporary_variable (\"iter_var\", ip->iter_type);\n+\n+\t  if (!CH_LOCATION_P (ip->start_exp))\n+\t    ip->start_exp\n+\t      = decl_temp1 (get_unique_identifier (\"iter_loc\"),\n+\t\t\t    TREE_TYPE (ip->start_exp), 0,\n+\t\t\t    ip->start_exp, 0, 0);\n+\n+\t  if (ip->itype == DO_LOC)\n+\t    {\n+\t      tree array_type = TREE_TYPE (ip->start_exp);\n+\t      tree ptr_type;\n+\t      tree temp;\n+\t      \n+\t      /* FIXME: check for array type in ip->start_exp */\n+\n+\t      /* create pointer temporary */\n+\t      ip->base_type = TREE_TYPE (array_type);\n+\t      ptr_type = build_pointer_type (ip->base_type);\n+\t      ip->loc_ptr_temp =\n+\t\tbuild_temporary_variable (\"loc_ptr_tmp\", ptr_type);\n+\t      \n+\t      /* declare the user's iteration variable in \n+\t\t the loop's scope, as an expression, to be\n+\t\t passed to build_component_ref later */\n+\t      save_expr_under_name (ip->user_var, \n+\t\tbuild1 (INDIRECT_REF, ip->base_type, \n+\t\t\tip->loc_ptr_temp));\n+\t      \n+\t      /* FIXME: see stor_layout */\n+\t      ip->step_temp = size_in_bytes (ip->base_type);\n+\t      \n+\t      temp = TYPE_DOMAIN (array_type);\n+\n+\t      /* pointer to first array entry to look at */\n+\t      start_ptr = build1 (ADDR_EXPR, ptr_type, ip->start_exp);\n+\t      mark_addressable (ip->start_exp);\n+\t      ip->start_temp = ip->down_flag ? \n+\t\tfold (build (PLUS_EXPR, ptr_type, \n+\t\t\t     start_ptr,\n+\t\t  fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n+\t\t    fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t TYPE_MAX_VALUE (temp),\n+\t\t\t\t TYPE_MIN_VALUE (temp)))))))\n+\t\t  : start_ptr;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree array_length =\n+\t\tconvert (integer_type_node,\n+\t\t  build_component_ref (ip->start_exp, var_length_id));\n+\t      tree array_type = TREE_TYPE (TREE_CHAIN (\n+\t\t\tTYPE_FIELDS (TREE_TYPE (ip->start_exp))));\n+\t      tree array_data_ptr = \n+\t\tbuild_component_ref (ip->start_exp, var_data_id);\n+\t      tree ptr_type;\n+\t      \n+\t      if (TREE_CODE (TREE_TYPE (array_type)) == BOOLEAN_TYPE)\n+\t\t{\n+\t\t  error (\"Can't iterate through array of BOOL\");\n+\t\t  firstp->error_flag = 1;\n+\t\t  return firstp->error_flag;\n+\t\t}\n+\t      \n+\t      /* create pointer temporary */\n+\t      ip->base_type = TREE_TYPE (array_type);\n+\t      ptr_type = build_pointer_type (ip->base_type);\n+\t      ip->loc_ptr_temp = \n+\t\tbuild_temporary_variable (\"loc_ptr_temp\", ptr_type);\n+\t\t\t\t\t\t\t   \n+\t      \n+\t      /* declare the user's iteration variable in \n+\t\t the loop's scope, as an expression, to be\n+\t\t passed to build_component_ref later */\n+\t      save_expr_under_name (ip->user_var, \n+\t\tbuild1 (INDIRECT_REF, ip->base_type, \n+\t\t\tip->loc_ptr_temp));\n+\t      \n+\t      /* FIXME: see stor_layout */\n+\t      ip->step_temp = size_in_bytes (ip->base_type);\n+\t      \n+\t      /* pointer to first array entry to look at */\n+\t      start_ptr = build1 (ADDR_EXPR, ptr_type, array_data_ptr);\n+\t      mark_addressable (array_data_ptr);\n+\t      ip->start_temp = ip->down_flag ? \n+\t\tfold (build (PLUS_EXPR, ptr_type, \n+                  start_ptr,\n+\t\t    fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n+\t\t      fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\t   array_length,\n+\t\t\t\t   integer_one_node))))))\n+\t\t  : start_ptr;\n+\t    }\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * Initialize the hidden iteration-control variables,\n+ * and the user's explicit loop variable.\n+ */\n+static int\n+initialize_iter_var ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list, *ip;\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+     switch (ip->itype)\n+\t{\n+\ttree array_type, array_length; \n+\tcase DO_FOREVER:\n+\t  break;\n+\tcase DO_STEP:\n+\t  {\n+\t    tree count;\n+\t    count = build (MINUS_EXPR, ip->iter_type,\n+\t\t\t   convert (ip->iter_type,\n+\t\t\t\t    ip->down_flag ? ip->start_temp : ip->end_temp),\n+\t\t\t   convert (ip->iter_type,\n+\t\t\t\t    ip->down_flag ? ip->end_temp   : ip->start_temp));\n+\t    count = fold (build (TRUNC_DIV_EXPR, ip->iter_type, \n+\t\t\t\t fold (count),\n+\t\t\t\t ip->step_temp));\n+\t    /* The count in this case is actually one less than the\n+\t       number of iterations, to avoid overflow problems\n+\t       if we iterate *all* the values of iter_type. */\n+\t    /* initialize the loop's hidden counter variable */\n+\t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->iter_var, count));\n+\n+\t    /* initialize user's variable */\n+\t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->user_var, ip->start_temp));\n+\t  }\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  break;\n+\tcase DO_LOC:\n+\t  array_type = TREE_TYPE (ip->start_exp);\n+\t  array_length = fold (build (TRUNC_DIV_EXPR, integer_type_node,\n+\t\t\t\t      size_in_bytes (array_type),\n+\t\t\t\t      size_in_bytes (TREE_TYPE (array_type))));\n+\t  goto do_loc_common;\n+\n+\tcase DO_LOC_VARYING:\n+\t  array_length\n+\t    = convert (integer_type_node,\n+\t\t       build_component_ref (ip->start_exp, var_length_id));\n+\n+\tdo_loc_common:\n+\t  expand_expr_stmt (build_chill_modify_expr (ip->iter_var,\n+\t\t\t\t\t\t     array_length));\n+\t  expand_expr_stmt (\n+\t    build_chill_modify_expr (ip->loc_ptr_temp, \n+\t\t\t\t     ip->start_temp));\n+\t  break;\n+\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/* Generate code to skip the whole loop, if start expression not\n+ * <= end expression (or >= for DOWN loops).  This comparison must\n+ * *NOT* be done in unsigned mode, or it will fail.\n+ *  Also, skip processing an empty VARYING array. \n+ */\n+static void\n+maybe_skip_loop ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list, *ip;\n+\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_STEP:\n+\t  expand_start_cond (\n+\t    build_compare_discrete_expr (ip->down_flag ? GE_EXPR : LE_EXPR, \n+\t\t   ip->start_temp, ip->end_temp), 0);\n+\t  break;\n+    \n+\tcase DO_LOC_VARYING:\n+\t  { tree array_length =\n+\t      convert (integer_type_node,\n+\t        build_component_ref (ip->start_exp, var_length_id));\n+\t    expand_start_cond (\n+\t      build (NE_EXPR, TREE_TYPE (array_length),\n+\t\t     array_length, integer_zero_node), 0);\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}  \n+\f\n+/*\n+ * Check at the top of the loop for a termination\n+ */\n+void\n+top_loop_end_check (condition)\n+     tree condition;\n+{\n+  ITERATOR *ip;\n+\n+  for (ip = loopstack->iter_list; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\tcase DO_STEP:\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  {\n+\t    tree temp1;\n+\t    char *func_name;\n+\t    tree user_type = TREE_TYPE (ip->user_var);\n+\n+\t    if (ip->down_flag)\n+\t      func_name = \"__flsetclrpowerset\";\n+\t    else\n+\t      func_name = \"__ffsetclrpowerset\";\n+\t    \n+\t    temp1 = lookup_name (get_identifier (func_name));\n+\t    if (ip->down_flag)\n+\t      temp1 = build_chill_function_call (temp1,\n+\t        tree_cons (NULL_TREE, force_addr_of (ip->powerset_temp),\n+\t\t  tree_cons (NULL_TREE, ip->iter_var,\n+\t\t    tree_cons (NULL_TREE, integer_zero_node, NULL_TREE))));\n+\t    else\n+\t      temp1 = build_chill_function_call (temp1,\n+\t        tree_cons (NULL_TREE, force_addr_of (ip->powerset_temp),\n+\t\t  tree_cons (NULL_TREE, powersetlen (ip->powerset_temp),\n+\t\t    tree_cons (NULL_TREE, ip->iter_var, NULL_TREE))));\n+\t    expand_assignment (ip->iter_var, temp1, 0, 0);\n+\t    expand_exit_loop_if_false (0, build (GE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t ip->iter_var,\n+\t\t\t\t\t\t integer_zero_node));\n+\t    temp1 = TYPE_MIN_VALUE\n+\t      (TYPE_DOMAIN (TREE_TYPE (ip->powerset_temp)));\n+\t    expand_assignment (ip->user_var,\n+\t\t\t       build (PLUS_EXPR, user_type,\n+\t\t\t\t      convert (user_type, ip->iter_var),\n+\t\t\t\t      convert (user_type, temp1)),\n+\t\t\t       0, 0);\n+\t  }\n+\t  break;\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  emit_line_note (input_filename, lineno); \n+\n+  /* now, exit the loop if the condition isn't TRUE. */\n+  if (condition)\n+    expand_exit_loop_if_false (0, truthvalue_conversion (condition));\n+}\n+\f\n+/*\n+ * Check generated temporaries for loop's end\n+ */\n+static int\n+bottom_loop_end_check ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list, *ip;\n+\n+  emit_line_note (input_filename, lineno);\n+\n+  /* now, generate code to check each loop counter for termination */\n+  for (ip = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\t  break;\n+\tcase DO_STEP:\n+\t  /* exit if it's zero */\n+\t  expand_exit_loop_if_false (0,\n+\t    build (NE_EXPR, boolean_type_node, \n+\t\t   ip->iter_var,\n+\t\t   integer_zero_node));\n+\t  /* decrement iteration counter by one */\n+\t  chill_expand_assignment (ip->iter_var, MINUS_EXPR, integer_one_node);\n+\t  break;\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  /* decrement iteration counter by one */\n+\t  chill_expand_assignment (ip->iter_var, MINUS_EXPR, integer_one_node);\n+\t  /* exit if it's zero */\n+\t  expand_exit_loop_if_false (0,\n+\t    build (NE_EXPR, boolean_type_node, \n+\t\t   ip->iter_var,\n+\t\t   integer_zero_node));\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * increment the loop-control variables.\n+ */\n+static int\n+increment_temps ()\n+{\n+  ITERATOR *firstp = loopstack->iter_list, *ip;\n+\n+  for (ip  = firstp; ip != NULL; ip = ip->next)\n+    {\n+      switch (ip->itype)\n+\t{\n+\tcase DO_FOREVER:\n+\t  break;\n+\tcase DO_STEP:\n+\t  {\n+\t    tree delta =\n+\t      fold (build (ip->down_flag ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t   TREE_TYPE (ip->user_var), ip->user_var,\n+\t\t\t   ip->step_temp));\n+ \t    expand_expr_stmt (\n+\t      build_chill_modify_expr (ip->user_var, delta));\n+\t  }\n+\t  break;\n+\tcase DO_LOC:\n+\tcase DO_LOC_VARYING:\n+\t  /* This statement uses the C semantics, so that \n+\t     the pointer is actually incremented by the \n+\t     length of the object pointed to. */\n+\t  {\n+\t    enum tree_code op = ip->down_flag ? MINUS_EXPR : PLUS_EXPR;\n+\t    tree el_type = TREE_TYPE (TREE_TYPE (ip->loc_ptr_temp));\n+\t    chill_expand_assignment (ip->loc_ptr_temp, NOP_EXPR,\n+\t\t\t\t     build (op,\n+\t\t\t\t\t    TREE_TYPE (ip->loc_ptr_temp),\n+\t\t\t\t\t    ip->loc_ptr_temp,\n+\t\t\t\t\t    size_in_bytes (el_type)));\n+\t  }\n+\t  break;\n+\tcase DO_POWERSET:\n+\t  if (!ip->down_flag)\n+\t    expand_assignment (ip->iter_var,\n+\t\t\t       build (PLUS_EXPR, ip->iter_type,\n+\t\t\t\t      ip->iter_var,\n+\t\t\t\t      integer_one_node),\n+\t\t\t       0, 0);\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return firstp->error_flag;\n+}\n+\f\n+/*\n+ * Generate a (temporary) unique identifier_node of\n+ * the form \"__tmp_%s_%d\"\n+ */\n+tree\n+get_unique_identifier (lead)\n+     char *lead;\n+{\n+  char idbuf [256];\n+  static int idcount = 0;\n+\n+  sprintf (idbuf, \"__tmp_%s_%d\", lead ? lead : \"\", idcount++);\n+  return get_identifier (idbuf);\n+}\n+\f\n+/*\n+ * build a temporary variable, given its NAME and TYPE.\n+ * The name will have a number appended to assure uniqueness.\n+ * return its DECL node.\n+ */\n+static tree\n+build_temporary_variable (name, type)\n+     char *name;\n+     tree type;\n+{\n+  return decl_temp1 (get_unique_identifier (name), type, 0, NULL_TREE, 0, 0);\n+}\n+\n+\n+/*\n+ * If the given expression isn't a constant, build a temp for it\n+ * and evaluate the expression into the temp.  Return the tree\n+ * representing either the original constant expression or the\n+ * temp which now contains the expression's value. \n+ */\n+static tree\n+maybe_make_for_temp (exp, temp_name, exp_type)\n+     tree exp;\n+     char *temp_name;\n+     tree exp_type;\n+{\n+  tree result = exp;\n+\n+  if (exp != NULL_TREE)\n+    {\n+      /* if exp isn't constant, create a temporary for its value */\n+      if (TREE_CONSTANT (exp))\n+\t{\n+          /* FIXME: assure that TREE_TYPE (result) == ip->exp_type */\n+\t  result = convert (exp_type, exp);\n+\t}\n+      else {\n+\t/* build temp, assign the value */\n+\tresult = decl_temp1 (get_unique_identifier (temp_name), exp_type, 0,\n+\t\t\t     exp, 0, 0);\n+      }\n+    }\n+  return result;\n+}\n+\n+\n+/*\n+ * Adapt the C unsigned_type function to CHILL - we need to\n+ * account for any CHILL-specific integer types here.  So far,\n+ * the 16-bit integer type is the only one.\n+ */\n+static tree\n+chill_unsigned_type (type)\n+     tree type;\n+{\n+  extern tree chill_unsigned_type_node;\n+  tree type1 = TYPE_MAIN_VARIANT (type);\n+\n+  if (type1 == chill_integer_type_node)\n+    return chill_unsigned_type_node;\n+  else\n+    return unsigned_type (type);\n+}"}]}