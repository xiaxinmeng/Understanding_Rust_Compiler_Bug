{"sha": "8c4f0c0ceb346e7deb69a44688faab6103aa57da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM0ZjBjMGNlYjM0NmU3ZGViNjlhNDQ2ODhmYWFiNjEwM2FhNTdkYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-26T15:51:13Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T12:23:08Z"}, "message": "c++: namespace reachability [PR 99344]\n\nThis reworks namespace serializing to avoid some issues I ran into\nwhen working on 99170.  In modules, (non-anonymous) namespaces are\nstrange beasts, that always have external linkage, but may have\nmodule-specific visibility.  I still don't get the latter 100%\ncorrect, but this is in the right direction.\n\n\tPR c++/99344\n\tgcc/cp/\n\t* module.cc (trees_out::decl_node): Small refactor.\n\t(depset::hash::add_binding_entity): Return true on meeting an\n\timport.  Set namespace's import here.\n\t(module_state:write_namespaces): Inform of purview too.\n\t(module_state:read_namespaces): Adjust.\n\t* name-lookup.c (implicitly_export_namespace): Delete.\n\t(do_pushdecl): Don't call it.\n\t(push_namespace): Likewise, set purview.\n\t(add_imported_namespace): Reorder parms.\n\t* name-lookup.h (add_imported_namespace): Alter param ordering.\n\tgcc/testsuite/\n\t* g++.dg/modules/namespace-2_a.C\n\t* g++.dg/modules/pr99344_a.C\n\t* g++.dg/modules/pr99344_b.C", "tree": {"sha": "4db3f0b423cdf15b7626c31a68bfff30d1ddc10a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db3f0b423cdf15b7626c31a68bfff30d1ddc10a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c4f0c0ceb346e7deb69a44688faab6103aa57da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4f0c0ceb346e7deb69a44688faab6103aa57da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4f0c0ceb346e7deb69a44688faab6103aa57da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4f0c0ceb346e7deb69a44688faab6103aa57da/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7267237371cc978fa6e0485446af11c60e4b102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7267237371cc978fa6e0485446af11c60e4b102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7267237371cc978fa6e0485446af11c60e4b102"}], "stats": {"total": 219, "additions": 122, "deletions": 97}, "files": [{"sha": "31172824fddeaf4e90ad6bd063c6a3a1e0cbfa84", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=8c4f0c0ceb346e7deb69a44688faab6103aa57da", "patch": "@@ -2377,8 +2377,10 @@ class depset {\n   }\n \n public:\n+  /* This class-member is defined here, but the class was imported.  */\n   bool is_member () const\n   {\n+    gcc_checking_assert (get_entity_kind () == EK_DECL);\n     return get_flag_bit<DB_IS_MEMBER_BIT> ();\n   }\n public:\n@@ -8613,12 +8615,13 @@ trees_out::decl_node (tree decl, walk_kind ref)\n   else if (TREE_CODE (ctx) != FUNCTION_DECL\n \t   || TREE_CODE (decl) == TEMPLATE_DECL\n \t   || (dep_hash->sneakoscope && DECL_IMPLICIT_TYPEDEF_P (decl))\n-\t   || (DECL_LANG_SPECIFIC (decl)\n-\t       && DECL_MODULE_IMPORT_P (decl)))\n-    dep = dep_hash->add_dependency (decl,\n-\t\t\t\t    TREE_CODE (decl) == NAMESPACE_DECL\n-\t\t\t\t    && !DECL_NAMESPACE_ALIAS (decl)\n-\t\t\t\t    ? depset::EK_NAMESPACE : depset::EK_DECL);\n+\t   || (DECL_LANG_SPECIFIC (decl) && DECL_MODULE_IMPORT_P (decl)))\n+    {\n+      auto kind = (TREE_CODE (decl) == NAMESPACE_DECL\n+\t\t   && !DECL_NAMESPACE_ALIAS (decl)\n+\t\t   ? depset::EK_NAMESPACE : depset::EK_DECL);\n+      dep = dep_hash->add_dependency (decl, kind);\n+    }\n \n   if (!dep)\n     {\n@@ -12751,12 +12754,14 @@ struct add_binding_data\n   bool met_namespace;\n };\n \n+/* Return true if we are, or contain something that is exported.  */\n+\n bool\n depset::hash::add_binding_entity (tree decl, WMB_Flags flags, void *data_)\n {\n   auto data = static_cast <add_binding_data *> (data_);\n \n-  if (TREE_CODE (decl) != NAMESPACE_DECL || DECL_NAMESPACE_ALIAS (decl))\n+  if (!(TREE_CODE (decl) == NAMESPACE_DECL && !DECL_NAMESPACE_ALIAS (decl)))\n     {\n       tree inner = decl;\n \n@@ -12811,7 +12816,7 @@ depset::hash::add_binding_entity (tree decl, WMB_Flags flags, void *data_)\n \t\t    d->clear_hidden_binding ();\n \t\t  if (flags & WMB_Export)\n \t\t    OVL_EXPORT_P (d->get_entity ()) = true;\n-\t\t  return false;\n+\t\t  return bool (flags & WMB_Export);\n \t\t}\n \t    }\n \t}\n@@ -12857,30 +12862,37 @@ depset::hash::add_binding_entity (tree decl, WMB_Flags flags, void *data_)\n       /* Binding and contents are mutually dependent.  */\n       dep->deps.safe_push (data->binding);\n \n-      return true;\n+      return (flags & WMB_Using\n+\t      ? flags & WMB_Export : DECL_MODULE_EXPORT_P (decl));\n     }\n   else if (DECL_NAME (decl) && !data->met_namespace)\n     {\n       /* Namespace, walk exactly once.  */\n       gcc_checking_assert (TREE_PUBLIC (decl));\n       data->met_namespace = true;\n-      if (data->hash->add_namespace_entities (decl, data->partitions)\n-\t  || DECL_MODULE_EXPORT_P (decl))\n+      if (data->hash->add_namespace_entities (decl, data->partitions))\n+\t{\n+\t  /* It contains an exported thing, so it is exported.  */\n+\t  gcc_checking_assert (DECL_MODULE_PURVIEW_P (decl));\n+\t  DECL_MODULE_EXPORT_P (decl) = true;\n+\t}\n+\n+      if (DECL_MODULE_PURVIEW_P (decl))\n \t{\n \t  data->hash->make_dependency (decl, depset::EK_NAMESPACE);\n-\t  return true;\n+\n+\t  return DECL_MODULE_EXPORT_P (decl);\n \t}\n     }\n \n   return false;\n }\n \n-/* Recursively find all the namespace bindings of NS.\n-   Add a depset for every binding that contains an export or\n-   module-linkage entity.  Add a defining depset for every such decl\n-   that we need to write a definition.  Such defining depsets depend\n-   on the binding depset.  Returns true if we contain something\n-   explicitly exported.  */\n+/* Recursively find all the namespace bindings of NS.  Add a depset\n+   for every binding that contains an export or module-linkage entity.\n+   Add a defining depset for every such decl that we need to write a\n+   definition.  Such defining depsets depend on the binding depset.\n+   Returns true if we contain something exported.  */\n \n bool\n depset::hash::add_namespace_entities (tree ns, bitmap partitions)\n@@ -15088,36 +15100,29 @@ module_state::write_namespaces (elf_out *to, vec<depset *> spaces,\n       tree ns = b->get_entity ();\n \n       gcc_checking_assert (TREE_CODE (ns) == NAMESPACE_DECL);\n+      /* P1815 may have something to say about this.  */\n+      gcc_checking_assert (TREE_PUBLIC (ns));\n \n-      bool export_p = DECL_MODULE_EXPORT_P (ns);\n-      bool inline_p = DECL_NAMESPACE_INLINE_P (ns);\n-      bool public_p = TREE_PUBLIC (ns);\n-\n-      /* We should only be naming public namespaces, or our own\n-\t private ones.  Internal linkage ones never get to be written\n-\t out -- because that means something erroneously referred to a\n-\t member.  However, Davis Herring's paper probably changes that\n-\t by permitting them to be written out, but then an error if on\n-\t touches them.  (Certain cases cannot be detected until that\n-\t point.)  */ \n-      gcc_checking_assert (public_p || !DECL_MODULE_IMPORT_P (ns));\n       unsigned flags = 0;\n-      if (export_p)\n+      if (TREE_PUBLIC (ns))\n \tflags |= 1;\n-      if (inline_p)\n+      if (DECL_NAMESPACE_INLINE_P (ns))\n \tflags |= 2;\n-      if (public_p)\n+      if (DECL_MODULE_PURVIEW_P (ns))\n \tflags |= 4;\n-      dump () && dump (\"Writing namespace:%u %N%s%s%s\",\n-\t\t       b->cluster, ns, export_p ? \", export\" : \"\",\n-\t\t       public_p ? \", public\" : \"\",\n-\t\t       inline_p ? \", inline\" : \"\");\n+      if (DECL_MODULE_EXPORT_P (ns))\n+\tflags |= 8;\n+\n+      dump () && dump (\"Writing namespace:%u %N%s%s%s%s\",\n+\t\t       b->cluster, ns,\n+\t\t       flags & 1 ? \", public\" : \"\", \n+\t\t       flags & 2 ? \", inline\" : \"\",\n+\t\t       flags & 4 ? \", purview\" : \"\",\n+\t\t       flags & 8 ? \", export\" : \"\");\n       sec.u (b->cluster);\n       sec.u (to->name (DECL_NAME (ns)));\n       write_namespace (sec, b->deps[0]);\n \n-      /* Don't use bools, because this can be near the end of the\n-\t section, and it won't save anything anyway.  */\n       sec.u (flags);\n       write_location (sec, DECL_SOURCE_LOCATION (ns));\n     }\n@@ -15151,26 +15156,40 @@ module_state::read_namespaces (unsigned num)\n       unsigned flags = sec.u ();\n       location_t src_loc = read_location (sec);\n \n-      if (entity_index >= entity_num || !parent)\n+      if (entity_index >= entity_num\n+\t  || !parent\n+\t  || (flags & 0xc) == 0x8)\n \tsec.set_overrun ();\n       if (sec.get_overrun ())\n \tbreak;\n \n       tree id = name ? get_identifier (from ()->name (name)) : NULL_TREE;\n-      bool public_p = flags & 4;\n-      bool inline_p = flags & 2;\n-      bool export_p = flags & 1;\n-\n-      dump () && dump (\"Read namespace:%u %P%s%s%s\",\n-\t\t       entity_index, parent, id, export_p ? \", export\" : \"\",\n-\t\t       public_p ? \", public\" : \"\",\n-\t\t       inline_p ? \", inline\" : \"\");\n-      bool visible_p = (export_p\n-\t\t\t|| (public_p && (is_partition () || is_module ())));\n-      tree inner = add_imported_namespace (parent, id, mod,\n-\t\t\t\t\t   src_loc, visible_p, inline_p);\n-      if (export_p && is_partition ())\n-\tDECL_MODULE_EXPORT_P (inner) = true;\n+\n+      dump () && dump (\"Read namespace:%u %P%s%s%s%s\",\n+\t\t       entity_index, parent, id,\n+\t\t       flags & 1 ? \", public\" : \"\", \n+\t\t       flags & 2 ? \", inline\" : \"\",\n+\t\t       flags & 4 ? \", purview\" : \"\",\n+\t\t       flags & 8 ? \", export\" : \"\");\n+      bool visible_p = ((flags & 8)\n+\t\t\t|| ((flags & 1)\n+\t\t\t    && (flags & 4)\n+\t\t\t    && (is_partition () || is_module ())));\n+      tree inner = add_imported_namespace (parent, id, src_loc, mod,\n+\t\t\t\t\t   bool (flags & 2), visible_p);\n+      if (!inner)\n+\t{\n+\t  sec.set_overrun ();\n+\t  break;\n+\t}\n+\n+      if (is_partition ())\n+\t{\n+\t  if (flags & 4)\n+\t    DECL_MODULE_PURVIEW_P (inner) = true;\n+\t  if (flags & 8)\n+\t    DECL_MODULE_EXPORT_P (inner) = true;\n+\t}\n \n       /* Install the namespace.  */\n       (*entity_ary)[entity_lwm + entity_index] = inner;"}, {"sha": "66c35a1c16dacec375ecb62e82d86a35a7f38600", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=8c4f0c0ceb346e7deb69a44688faab6103aa57da", "patch": "@@ -3490,18 +3490,6 @@ push_local_extern_decl_alias (tree decl)\n   DECL_LOCAL_DECL_ALIAS (decl) = alias;\n }\n \n-/* NS needs to be exported, mark it and all its parents as exported.  */\n-\n-static void\n-implicitly_export_namespace (tree ns)\n-{\n-  while (!DECL_MODULE_EXPORT_P (ns))\n-    {\n-      DECL_MODULE_EXPORT_P (ns) = true;\n-      ns = CP_DECL_CONTEXT (ns);\n-    }\n-}\n-\n /* DECL is a global or module-purview entity.  If it has non-internal\n    linkage, and we have a module vector, record it in the appropriate\n    slot.  We have already checked for duplicates.  */\n@@ -3741,10 +3729,6 @@ do_pushdecl (tree decl, bool hiding)\n \t    decl = update_binding (NULL, binding, mslot, old,\n \t\t\t\t   match, hiding);\n \n-\t    if (match == decl && DECL_MODULE_EXPORT_P (decl)\n-\t\t&& !DECL_MODULE_EXPORT_P (level->this_entity))\n-\t      implicitly_export_namespace (level->this_entity);\n-\n \t    return decl;\n \t  }\n \n@@ -3839,16 +3823,9 @@ do_pushdecl (tree decl, bool hiding)\n \t    }\n \n \t  if (level->kind == sk_namespace\n-\t      && TREE_PUBLIC (level->this_entity))\n-\t    {\n-\t      if (TREE_CODE (decl) != CONST_DECL\n-\t\t  && DECL_MODULE_EXPORT_P (decl)\n-\t\t  && !DECL_MODULE_EXPORT_P (level->this_entity))\n-\t\timplicitly_export_namespace (level->this_entity);\n-\n-\t      if (!not_module_p ())\n-\t\tmaybe_record_mergeable_decl (slot, name, decl);\n-\t    }\n+\t      && TREE_PUBLIC (level->this_entity)\n+\t      && !not_module_p ())\n+\t    maybe_record_mergeable_decl (slot, name, decl);\n \t}\n     }\n   else\n@@ -3936,7 +3913,8 @@ lookup_class_binding (tree klass, tree name)\n \n /* Given a namespace-level binding BINDING, walk it, calling CALLBACK\n    for all decls of the current module.  When partitions are involved,\n-   decls might be mentioned more than once.   */\n+   decls might be mentioned more than once.   Return the accumulation of\n+   CALLBACK results.  */\n \n unsigned\n walk_module_binding (tree binding, bitmap partitions,\n@@ -8932,9 +8910,10 @@ push_namespace (tree name, bool make_inline)\n     {\n       /* A public namespace is exported only if explicitly marked, or\n \t it contains exported entities.  */\n-      if (!DECL_MODULE_EXPORT_P (ns) && TREE_PUBLIC (ns)\n-\t  && module_exporting_p ())\n-\timplicitly_export_namespace (ns);\n+      if (TREE_PUBLIC (ns) && module_exporting_p ())\n+\tDECL_MODULE_EXPORT_P (ns) = true;\n+      if (module_purview_p ())\n+\tDECL_MODULE_PURVIEW_P (ns) = true;\n \n       if (make_inline && !DECL_NAMESPACE_INLINE_P (ns))\n \t{\n@@ -8966,12 +8945,12 @@ pop_namespace (void)\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n-/* An import is defining namespace NAME inside CTX.  Find or create\n-   that namespace and add it to the container's binding-vector.  */\n+/* An IMPORT is an import that is defining namespace NAME inside CTX.  Find or\n+   create that namespace and add it to the container's binding-vector.   */\n \n tree\n-add_imported_namespace (tree ctx, tree name, unsigned origin, location_t loc,\n-\t\t\tbool visible_p, bool inline_p)\n+add_imported_namespace (tree ctx, tree name, location_t loc, unsigned import, \n+\t\t\tbool inline_p, bool visible_p)\n {\n   // FIXME: Something is not correct about the VISIBLE_P handling.  We\n   // need to insert this namespace into\n@@ -8980,9 +8959,10 @@ add_imported_namespace (tree ctx, tree name, unsigned origin, location_t loc,\n   // (c) Do we need to put it in the CURRENT slot?  This is the\n   // confused piece.\n \n-  gcc_checking_assert (origin);\n   tree *slot = find_namespace_slot (ctx, name, true);\n   tree decl = reuse_namespace (slot, ctx, name);\n+\n+  /* Creating and binding.  */\n   if (!decl)\n     {\n       decl = make_namespace (ctx, name, loc, inline_p);\n@@ -9010,7 +8990,7 @@ add_imported_namespace (tree ctx, tree name, unsigned origin, location_t loc,\n       tree final = last->slots[jx];\n       if (visible_p == !STAT_HACK_P (final)\n \t  && MAYBE_STAT_DECL (final) == decl\n-\t  && last->indices[jx].base + last->indices[jx].span == origin\n+\t  && last->indices[jx].base + last->indices[jx].span == import\n \t  && (BINDING_VECTOR_NUM_CLUSTERS (*slot) > 1\n \t      || (BINDING_VECTOR_SLOTS_PER_CLUSTER > BINDING_SLOTS_FIXED\n \t\t  && jx >= BINDING_SLOTS_FIXED)))\n@@ -9021,7 +9001,7 @@ add_imported_namespace (tree ctx, tree name, unsigned origin, location_t loc,\n     }\n \n   /* Append a new slot.  */\n-  tree *mslot = &(tree &)*append_imported_binding_slot (slot, name, origin);\n+  tree *mslot = &(tree &)*append_imported_binding_slot (slot, name, import);\n \n   gcc_assert (!*mslot);\n   *mslot = visible_p ? decl : stat_hack (decl, NULL_TREE);"}, {"sha": "d95472b754534dad51e65c4e0628b9e63b3ab981", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=8c4f0c0ceb346e7deb69a44688faab6103aa57da", "patch": "@@ -504,8 +504,9 @@ enum WMB_Flags\n extern unsigned walk_module_binding (tree binding, bitmap partitions,\n \t\t\t\t     bool (*)(tree decl, WMB_Flags, void *data),\n \t\t\t\t     void *data);\n-extern tree add_imported_namespace (tree ctx, tree name, unsigned module,\n-\t\t\t\t    location_t, bool visible_p, bool inline_p);\n+extern tree add_imported_namespace (tree ctx, tree name, location_t,\n+\t\t\t\t    unsigned module,\n+\t\t\t\t    bool inline_p, bool visible_p);\n extern void note_pending_specializations (tree ns, tree name, bool is_header);\n extern void load_pending_specializations (tree ns, tree name);\n extern const char *get_cxx_dialect_name (enum cxx_dialect dialect);"}, {"sha": "b2c9abb248269dcd58b078d5ab34e868254775d2", "filename": "gcc/testsuite/g++.dg/modules/namespace-2_a.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fnamespace-2_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fnamespace-2_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fnamespace-2_a.C?ref=8c4f0c0ceb346e7deb69a44688faab6103aa57da", "patch": "@@ -32,9 +32,9 @@ export namespace explicit_export\n }\n \n // { dg-final { scan-lang-dump-not {Writable bindings at '::not_exported'} \"module\" } }\n-// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::implicit_export', export, public} \"module\" } }\n-// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::explicit_export', export, public} \"module\" } }\n-// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::also_not_exported', public} \"module\" } }\n-// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::explicit_export::also_exported', export, public} \"module\" } }\n+// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::also_not_exported', public, purview\\n} \"module\" } }\n+// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::implicit_export', public, purview, export\\n} \"module\" } }\n+// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::explicit_export', public, purview, export\\n} \"module\" } }\n+// { dg-final { scan-lang-dump {Writing namespace:[0-9] '::explicit_export::also_exported', public, purview, export\\n} \"module\" } }\n // { dg-final { scan-lang-dump-not {Writing namespace:[0-9] '::not_exported'} \"module\" } }\n // { dg-final { scan-lang-dump-not {Writing namespace:[0-9] '::std'} \"module\" } }"}, {"sha": "e0ba1faf54f3ca65f788efef00a64f5dae2d00e0", "filename": "gcc/testsuite/g++.dg/modules/pr99344_a.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99344_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99344_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99344_a.C?ref=8c4f0c0ceb346e7deb69a44688faab6103aa57da", "patch": "@@ -0,0 +1,23 @@\n+// { dg-additional-options {-fmodules-ts -Wno-pedantic} }\n+module ;\n+       \n+# 4 \"bug_a.ii\" 1\n+\n+namespace STD::RANGES::INNER\n+{\n+void Frob ();\n+}\n+\n+struct gnu_char_traits\n+{\n+  void Frob()\n+  {\n+    STD::RANGES::INNER::Frob ();\n+  }\n+};\n+\n+# 19 \"\" 2\n+\n+export  module  hello;\n+// { dg-module-cmi hello }\n+export void greeter (gnu_char_traits const &name);"}, {"sha": "e54ae3d6fc525656fe54184f1234b9c45e81b20e", "filename": "gcc/testsuite/g++.dg/modules/pr99344_b.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99344_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4f0c0ceb346e7deb69a44688faab6103aa57da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99344_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99344_b.C?ref=8c4f0c0ceb346e7deb69a44688faab6103aa57da", "patch": "@@ -0,0 +1,2 @@\n+// { dg-additional-options -fmodules-ts }\n+import  hello;"}]}