{"sha": "48f46219bd21a0cdd955700b7c0b448d52f457cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhmNDYyMTliZDIxYTBjZGQ5NTU3MDBiN2MwYjQ0OGQ1MmY0NTdjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-04-27T14:47:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-04-27T14:47:57Z"}, "message": "predicates.md (aligned_memory_operand): Mark as define_special_predicate.\n\n        * config/alpha/predicates.md (aligned_memory_operand): Mark\n        as define_special_predicate.\n        (unaligned_memory_operand, normal_memory_operand): Likewise.\n        (reg_or_unaligned_mem_operand): Remove.\n        (any_memory_operand): Match the documentation and check for\n        non-renumbered pseudos during reload.\n        * config/alpha/alpha.c (alpha_secondary_reload): Rename from\n        alpha_secondary_reload_class, update to new interface, make static.\n        Handle CQImode like HImode.  Remove FP subreg check.\n        (alpha_expand_mov): Use replace_equiv_address.\n        (alpha_expand_mov_nobwx): Use any_memory_operand.\n        (TARGET_SECONDARY_RELOAD): New.\n        * config/alpha/alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Remove.\n        (SECONDARY_OUTPUT_RELOAD_CLASS): Remove.\n        * config/alpha/sync.md (I12MODE, I48MODE, modesuffix): Move ...\n        * config/alpha/alpha.md: ... here.\n        (RELOAD12, reloadmode): New.\n        (movcqi): New.\n        (reload_in<RELOAD12>): Macro-ize from reload_inqi, reload_inhi.\n        Don't handle the aligned case here.\n        (reload_out<RELOAD12>): Macro-ize from reload_outqi, reload_outhi.\n        (reload_in<I12MODE>_aligned): Macro-ize from reload_inqi_help,\n        reload_inhi_help.  Don't expect a scratch register.\n        (reload_out<I12MODE>_aligned): Macro-ize from reload_outqi_help,\n        reload_outhi_help.\n        * config/alpha/alpha-protos.h (alpha_secondary_reload_class): Remove.\n\nFrom-SVN: r124220", "tree": {"sha": "13f1f56c69e4fb85cba6ff3f0491b57313c3d470", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13f1f56c69e4fb85cba6ff3f0491b57313c3d470"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48f46219bd21a0cdd955700b7c0b448d52f457cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f46219bd21a0cdd955700b7c0b448d52f457cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f46219bd21a0cdd955700b7c0b448d52f457cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f46219bd21a0cdd955700b7c0b448d52f457cd/comments", "author": null, "committer": null, "parents": [{"sha": "64e8a9f04eaa5a5989607ac36c94c57d6eb9ee14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64e8a9f04eaa5a5989607ac36c94c57d6eb9ee14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64e8a9f04eaa5a5989607ac36c94c57d6eb9ee14"}], "stats": {"total": 453, "additions": 209, "deletions": 244}, "files": [{"sha": "1b3f0efdaa984a59dc8a9ff581769677648099e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -1,3 +1,32 @@\n+2007-04-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/predicates.md (aligned_memory_operand): Mark\n+\tas define_special_predicate.\n+\t(unaligned_memory_operand, normal_memory_operand): Likewise.\n+\t(reg_or_unaligned_mem_operand): Remove.\n+\t(any_memory_operand): Match the documentation and check for\n+\tnon-renumbered pseudos during reload.\n+\t* config/alpha/alpha.c (alpha_secondary_reload): Rename from\n+\talpha_secondary_reload_class, update to new interface, make static.\n+\tHandle CQImode like HImode.  Remove FP subreg check.\n+\t(alpha_expand_mov): Use replace_equiv_address.\n+\t(alpha_expand_mov_nobwx): Use any_memory_operand.\n+\t(TARGET_SECONDARY_RELOAD): New.\n+\t* config/alpha/alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Remove.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Remove.\n+\t* config/alpha/sync.md (I12MODE, I48MODE, modesuffix): Move ...\n+\t* config/alpha/alpha.md: ... here.\n+\t(RELOAD12, reloadmode): New.\n+\t(movcqi): New.\n+\t(reload_in<RELOAD12>): Macro-ize from reload_inqi, reload_inhi.\n+\tDon't handle the aligned case here.\n+\t(reload_out<RELOAD12>): Macro-ize from reload_outqi, reload_outhi.\n+\t(reload_in<I12MODE>_aligned): Macro-ize from reload_inqi_help,\n+\treload_inhi_help.  Don't expect a scratch register.\n+\t(reload_out<I12MODE>_aligned): Macro-ize from reload_outqi_help,\n+\treload_outhi_help.\n+\t* config/alpha/alpha-protos.h (alpha_secondary_reload_class): Remove.\n+\n 2007-04-27  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-forwprop.c (get_prop_dest_stmt): Fix comment typo."}, {"sha": "e7e2d2d08cd770ad7a0928dd2bc5364fde08e525", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -50,9 +50,6 @@ extern void get_aligned_mem (rtx, rtx *, rtx *);\n extern rtx get_unaligned_address (rtx);\n extern rtx get_unaligned_offset (rtx, HOST_WIDE_INT);\n extern enum reg_class alpha_preferred_reload_class (rtx, enum reg_class);\n-extern enum reg_class alpha_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t    enum machine_mode, rtx,\n-\t\t\t\t\t\t    int);\n \n extern void alpha_set_memflags (rtx, rtx);\n extern bool alpha_split_const_mov (enum machine_mode, rtx *);"}, {"sha": "32bb92c89d0c004971e20260c8575a118263c542", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 57, "deletions": 70, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -1533,47 +1533,39 @@ alpha_preferred_reload_class(rtx x, enum reg_class class)\n   return class;\n }\n \n-/* Loading and storing HImode or QImode values to and from memory\n-   usually requires a scratch register.  The exceptions are loading\n-   QImode and HImode from an aligned address to a general register\n-   unless byte instructions are permitted.\n+/* Inform reload about cases where moving X with a mode MODE to a register in\n+   CLASS requires an extra scratch or immediate register.  Return the class\n+   needed for the immediate register.  */\n \n-   We also cannot load an unaligned address or a paradoxical SUBREG\n-   into an FP register.\n-\n-   We also cannot do integral arithmetic into FP regs, as might result\n-   from register elimination into a DImode fp register.  */\n-\n-enum reg_class\n-alpha_secondary_reload_class (enum reg_class class, enum machine_mode mode,\n-\t\t\trtx x, int in)\n+static enum reg_class\n+alpha_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+\t\t\tenum machine_mode mode, secondary_reload_info *sri)\n {\n-  if ((mode == QImode || mode == HImode) && ! TARGET_BWX)\n+  /* Loading and storing HImode or QImode values to and from memory\n+     usually requires a scratch register.  */\n+  if (!TARGET_BWX && (mode == QImode || mode == HImode || mode == CQImode))\n     {\n-      if (GET_CODE (x) == MEM\n-\t  || (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-\t  || (GET_CODE (x) == SUBREG\n-\t      && (GET_CODE (SUBREG_REG (x)) == MEM\n-\t\t  || (GET_CODE (SUBREG_REG (x)) == REG\n-\t\t      && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER))))\n+      if (any_memory_operand (x, mode))\n \t{\n-\t  if (!in || !aligned_memory_operand(x, mode))\n-\t    return GENERAL_REGS;\n+\t  if (in_p)\n+\t    {\n+\t      if (!aligned_memory_operand (x, mode))\n+\t\tsri->icode = reload_in_optab[mode];\n+\t    }\n+\t  else\n+\t    sri->icode = reload_out_optab[mode];\n+\t  return NO_REGS;\n \t}\n     }\n \n+  /* We also cannot do integral arithmetic into FP regs, as might result\n+     from register elimination into a DImode fp register.  */\n   if (class == FLOAT_REGS)\n     {\n-      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == AND)\n-\treturn GENERAL_REGS;\n-\n-      if (GET_CODE (x) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (x))\n-\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+      if (MEM_P (x) && GET_CODE (XEXP (x, 0)) == AND)\n \treturn GENERAL_REGS;\n-\n-      if (in && INTEGRAL_MODE_P (mode)\n-\t  && ! (memory_operand (x, mode) || x == const0_rtx))\n+      if (in_p && INTEGRAL_MODE_P (mode)\n+\t  && !MEM_P (x) && !REG_P (x) && !CONST_INT_P (x))\n \treturn GENERAL_REGS;\n     }\n \n@@ -2160,8 +2152,7 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n   if (reload_in_progress)\n     {\n       emit_move_insn (operands[0], XEXP (operands[1], 0));\n-      operands[1] = copy_rtx (operands[1]);\n-      XEXP (operands[1], 0) = operands[0];\n+      operands[1] = replace_equiv_address (operands[1], operands[0]);\n     }\n   else\n     operands[1] = validize_mem (operands[1]);\n@@ -2174,32 +2165,27 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n bool\n alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n {\n+  rtx seq;\n+\n   /* If the output is not a register, the input must be.  */\n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (mode, operands[1]);\n \n   /* Handle four memory cases, unaligned and aligned for either the input\n      or the output.  The only case where we can be called during reload is\n      for aligned loads; all other cases require temporaries.  */\n \n-  if (GET_CODE (operands[1]) == MEM\n-      || (GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == MEM)\n-      || (reload_in_progress && GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-      || (reload_in_progress && GET_CODE (operands[1]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[1])) == REG\n-\t  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))\n+  if (any_memory_operand (operands[1], mode))\n     {\n       if (aligned_memory_operand (operands[1], mode))\n \t{\n \t  if (reload_in_progress)\n \t    {\n-\t      emit_insn ((mode == QImode\n-\t\t\t  ? gen_reload_inqi_help\n-\t\t\t  : gen_reload_inhi_help)\n-\t\t         (operands[0], operands[1],\n-\t\t\t  gen_rtx_REG (SImode, REGNO (operands[0]))));\n+\t      if (mode == QImode)\n+\t\tseq = gen_reload_inqi_aligned (operands[0], operands[1]);\n+\t      else\n+\t\tseq = gen_reload_inhi_aligned (operands[0], operands[1]);\n+\t      emit_insn (seq);\n \t    }\n \t  else\n \t    {\n@@ -2216,10 +2202,13 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t      else\n \t\tsubtarget = gen_reg_rtx (DImode), copyout = true;\n \n-\t      emit_insn ((mode == QImode\n-\t\t\t  ? gen_aligned_loadqi\n-\t\t\t  : gen_aligned_loadhi)\n-\t\t\t (subtarget, aligned_mem, bitnum, scratch));\n+\t      if (mode == QImode)\n+\t\tseq = gen_aligned_loadqi (subtarget, aligned_mem,\n+\t\t\t\t\t  bitnum, scratch);\n+\t      else\n+\t\tseq = gen_aligned_loadhi (subtarget, aligned_mem,\n+\t\t\t\t\t  bitnum, scratch);\n+\t      emit_insn (seq);\n \n \t      if (copyout)\n \t\temit_move_insn (operands[0], gen_lowpart (mode, subtarget));\n@@ -2231,7 +2220,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t     code depend on parameter evaluation order which will cause\n \t     bootstrap failures.  */\n \n-\t  rtx temp1, temp2, seq, subtarget;\n+\t  rtx temp1, temp2, subtarget, ua;\n \t  bool copyout;\n \n \t  temp1 = gen_reg_rtx (DImode);\n@@ -2243,11 +2232,12 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t  else\n \t    subtarget = gen_reg_rtx (DImode), copyout = true;\n \n-\t  seq = ((mode == QImode\n-\t\t  ? gen_unaligned_loadqi\n-\t\t  : gen_unaligned_loadhi)\n-\t\t (subtarget, get_unaligned_address (operands[1]),\n-\t\t  temp1, temp2));\n+\t  ua = get_unaligned_address (operands[1]);\n+\t  if (mode == QImode)\n+\t    seq = gen_unaligned_loadqi (subtarget, ua, temp1, temp2);\n+\t  else\n+\t    seq = gen_unaligned_loadhi (subtarget, ua, temp1, temp2);\n+\n \t  alpha_set_memflags (seq, operands[1]);\n \t  emit_insn (seq);\n \n@@ -2257,14 +2247,7 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n       return true;\n     }\n \n-  if (GET_CODE (operands[0]) == MEM\n-      || (GET_CODE (operands[0]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[0])) == MEM)\n-      || (reload_in_progress && GET_CODE (operands[0]) == REG\n-\t  && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n-      || (reload_in_progress && GET_CODE (operands[0]) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (operands[0])) == REG\n-\t  && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n+  if (any_memory_operand (operands[0], mode))\n     {\n       if (aligned_memory_operand (operands[0], mode))\n \t{\n@@ -2282,11 +2265,12 @@ alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n \t  rtx temp1 = gen_reg_rtx (DImode);\n \t  rtx temp2 = gen_reg_rtx (DImode);\n \t  rtx temp3 = gen_reg_rtx (DImode);\n-\t  rtx seq = ((mode == QImode\n-\t\t      ? gen_unaligned_storeqi\n-\t\t      : gen_unaligned_storehi)\n-\t\t     (get_unaligned_address (operands[0]),\n-\t\t      operands[1], temp1, temp2, temp3));\n+\t  rtx ua = get_unaligned_address (operands[0]);\n+\n+\t  if (mode == QImode)\n+\t    seq = gen_unaligned_storeqi (ua, operands[1], temp1, temp2, temp3);\n+\t  else\n+\t    seq = gen_unaligned_storehi (ua, operands[1], temp1, temp2, temp3);\n \n \t  alpha_set_memflags (seq, operands[0]);\n \t  emit_insn (seq);\n@@ -10703,6 +10687,9 @@ alpha_init_libfuncs (void)\n #undef TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES alpha_arg_partial_bytes\n \n+#undef TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD alpha_secondary_reload\n+\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P alpha_scalar_mode_supported_p\n #undef TARGET_VECTOR_MODE_SUPPORTED_P"}, {"sha": "958d0eac7b610d3341fc120cc2651471f999abf2", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -582,19 +582,6 @@ enum reg_class {\n \n #define PREFERRED_RELOAD_CLASS  alpha_preferred_reload_class\n \n-/* Loading and storing HImode or QImode values to and from memory\n-   usually requires a scratch register.  The exceptions are loading\n-   QImode and HImode from an aligned address to a general register\n-   unless byte instructions are permitted.\n-   We also cannot load an unaligned address or a paradoxical SUBREG into an\n-   FP register.  */\n-\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  alpha_secondary_reload_class((CLASS), (MODE), (IN), 1)\n-\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT) \\\n-  alpha_secondary_reload_class((CLASS), (MODE), (OUT), 0)\n-\n /* If we are copying between general and FP registers, we need a memory\n    location unless the FIX extension is available.  */\n "}, {"sha": "785082a7f829cfa367bbaf1c7242c918925a09af", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 102, "deletions": 143, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -87,6 +87,16 @@\n    (UNSPECV_SC\t\t16)\t; store-conditional\n   ])\n \n+;; On non-BWX targets, CQImode must be handled the similarly to HImode\n+;; when generating reloads.\n+(define_mode_macro RELOAD12 [QI HI CQI])\n+(define_mode_attr reloadmode [(QI \"qi\") (HI \"hi\") (CQI \"hi\")])\n+\n+;; Other mode macros\n+(define_mode_macro I12MODE [QI HI])\n+(define_mode_macro I48MODE [SI DI])\n+(define_mode_attr modesuffix [(SI \"l\") (DI \"q\")])\n+\n ;; Where necessary, the suffixes _le and _be are used to distinguish between\n ;; little-endian and big-endian patterns.\n ;;\n@@ -6085,136 +6095,120 @@\n     DONE;\n })\n \n-;; Here are the versions for reload.  Note that in the unaligned cases\n-;; we know that the operand must not be a pseudo-register because stack\n-;; slots are always aligned references.\n-\n-(define_expand \"reload_inqi\"\n-  [(parallel [(match_operand:QI 0 \"register_operand\" \"=r\")\n-\t      (match_operand:QI 1 \"any_memory_operand\" \"m\")\n-\t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"! TARGET_BWX\"\n+;; We need to hook into the extra support that we have for HImode \n+;; reloads when BWX insns are not available.\n+(define_expand \"movcqi\"\n+  [(set (match_operand:CQI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:CQI 1 \"general_operand\" \"\"))]\n+  \"!TARGET_BWX\"\n {\n-  rtx scratch, seq;\n-\n-  if (aligned_memory_operand (operands[1], QImode))\n+  if (GET_CODE (operands[0]) == CONCAT || GET_CODE (operands[1]) == CONCAT)\n+    ;\n+  else if (!any_memory_operand (operands[0], CQImode))\n     {\n-      seq = gen_reload_inqi_help (operands[0], operands[1],\n-\t\t\t\t  gen_rtx_REG (SImode, REGNO (operands[2])));\n+      if (!any_memory_operand (operands[1], CQImode))\n+\t{\n+\t  emit_move_insn (gen_lowpart (HImode, operands[0]),\n+\t\t\t  gen_lowpart (HImode, operands[1]));\n+\t  DONE;\n+\t}\n+      if (aligned_memory_operand (operands[1], CQImode))\n+\t{\n+\t  bool done;\n+\tdo_aligned1:\n+\t  operands[1] = gen_lowpart (HImode, operands[1]);\n+\tdo_aligned2:\n+\t  operands[0] = gen_lowpart (HImode, operands[0]);\n+\t  done = alpha_expand_mov_nobwx (HImode, operands);\n+\t  gcc_assert (done);\n+\t  DONE;\n+\t}\n     }\n-  else\n+  else if (aligned_memory_operand (operands[0], CQImode))\n     {\n-      rtx addr;\n-\n-      /* It is possible that one of the registers we got for operands[2]\n-\t might coincide with that of operands[0] (which is why we made\n-\t it TImode).  Pick the other one to use as our scratch.  */\n-      if (REGNO (operands[0]) == REGNO (operands[2]))\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n-      else\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n-\n-      addr = get_unaligned_address (operands[1]);\n-      operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-      seq = gen_unaligned_loadqi (operands[0], addr, scratch, operands[0]);\n-      alpha_set_memflags (seq, operands[1]);\n+      if (MEM_P (operands[1]))\n+\t{\n+\t  rtx x = gen_reg_rtx (HImode);\n+\t  emit_move_insn (gen_lowpart (CQImode, x), operands[1]);\n+\t  operands[1] = x;\n+\t  goto do_aligned2;\n+\t}\n+      goto do_aligned1;\n     }\n-  emit_insn (seq);\n+\n+  gcc_assert (!reload_in_progress);\n+  emit_move_complex_parts (operands[0], operands[1]);\n   DONE;\n })\n \n-(define_expand \"reload_inhi\"\n-  [(parallel [(match_operand:HI 0 \"register_operand\" \"=r\")\n-\t      (match_operand:HI 1 \"any_memory_operand\" \"m\")\n+;; Here are the versions for reload.\n+;; \n+;; The aligned input case is recognized early in alpha_secondary_reload\n+;; in order to avoid allocating an unnecessary scratch register.\n+;; \n+;; Note that in the unaligned cases we know that the operand must not be\n+;; a pseudo-register because stack slots are always aligned references.\n+\n+(define_expand \"reload_in<mode>\"\n+  [(parallel [(match_operand:RELOAD12 0 \"register_operand\" \"=r\")\n+\t      (match_operand:RELOAD12 1 \"any_memory_operand\" \"m\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"! TARGET_BWX\"\n+  \"!TARGET_BWX\"\n {\n-  rtx scratch, seq;\n+  rtx scratch, seq, addr;\n+  unsigned regno = REGNO (operands[2]);\n \n-  if (aligned_memory_operand (operands[1], HImode))\n-    {\n-      seq = gen_reload_inhi_help (operands[0], operands[1],\n-\t\t\t\t  gen_rtx_REG (SImode, REGNO (operands[2])));\n-    }\n-  else\n-    {\n-      rtx addr;\n+  /* It is possible that one of the registers we got for operands[2]\n+     might coincide with that of operands[0] (which is why we made\n+     it TImode).  Pick the other one to use as our scratch.  */\n+  if (regno == REGNO (operands[0]))\n+    regno++;\n+  scratch = gen_rtx_REG (DImode, regno);\n \n-      /* It is possible that one of the registers we got for operands[2]\n-\t might coincide with that of operands[0] (which is why we made\n-\t it TImode).  Pick the other one to use as our scratch.  */\n-      if (REGNO (operands[0]) == REGNO (operands[2]))\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n-      else\n-\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n+  addr = get_unaligned_address (operands[1]);\n+  operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+  seq = gen_unaligned_load<reloadmode> (operands[0], addr,\n+\t\t\t\t\tscratch, operands[0]);\n+  alpha_set_memflags (seq, operands[1]);\n \n-      addr = get_unaligned_address (operands[1]);\n-      operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-      seq = gen_unaligned_loadhi (operands[0], addr, scratch, operands[0]);\n-      alpha_set_memflags (seq, operands[1]);\n-    }\n   emit_insn (seq);\n   DONE;\n })\n \n-(define_expand \"reload_outqi\"\n-  [(parallel [(match_operand:QI 0 \"any_memory_operand\" \"=m\")\n-\t      (match_operand:QI 1 \"register_operand\" \"r\")\n+(define_expand \"reload_out<mode>\"\n+  [(parallel [(match_operand:RELOAD12 0 \"any_memory_operand\" \"=m\")\n+\t      (match_operand:RELOAD12 1 \"register_operand\" \"r\")\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n {\n-  if (aligned_memory_operand (operands[0], QImode))\n-    {\n-      emit_insn (gen_reload_outqi_help\n-\t\t (operands[0], operands[1],\n-\t\t  gen_rtx_REG (SImode, REGNO (operands[2])),\n-\t\t  gen_rtx_REG (SImode, REGNO (operands[2]) + 1)));\n-    }\n-  else\n-    {\n-      rtx addr = get_unaligned_address (operands[0]);\n-      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n-      rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n-      rtx scratch3 = scratch1;\n-      rtx seq;\n-\n-      if (GET_CODE (addr) == REG)\n-\tscratch1 = addr;\n+  unsigned regno = REGNO (operands[2]);\n \n-      seq = gen_unaligned_storeqi (addr, operands[1], scratch1,\n-\t\t\t\t   scratch2, scratch3);\n-      alpha_set_memflags (seq, operands[0]);\n-      emit_insn (seq);\n+  if (<MODE>mode == CQImode)\n+    {\n+      operands[0] = gen_lowpart (HImode, operands[0]);\n+      operands[1] = gen_lowpart (HImode, operands[1]);\n     }\n-  DONE;\n-})\n \n-(define_expand \"reload_outhi\"\n-  [(parallel [(match_operand:HI 0 \"any_memory_operand\" \"=m\")\n-\t      (match_operand:HI 1 \"register_operand\" \"r\")\n-\t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n-  \"! TARGET_BWX\"\n-{\n-  if (aligned_memory_operand (operands[0], HImode))\n+  if (aligned_memory_operand (operands[0], <MODE>mode))\n     {\n-      emit_insn (gen_reload_outhi_help\n+      emit_insn (gen_reload_out<reloadmode>_aligned\n \t\t (operands[0], operands[1],\n-\t\t  gen_rtx_REG (SImode, REGNO (operands[2])),\n-\t\t  gen_rtx_REG (SImode, REGNO (operands[2]) + 1)));\n+\t\t  gen_rtx_REG (SImode, regno),\n+\t\t  gen_rtx_REG (SImode, regno + 1)));\n     }\n   else\n     {\n       rtx addr = get_unaligned_address (operands[0]);\n-      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n-      rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n+      rtx scratch1 = gen_rtx_REG (DImode, regno);\n+      rtx scratch2 = gen_rtx_REG (DImode, regno + 1);\n       rtx scratch3 = scratch1;\n       rtx seq;\n \n       if (GET_CODE (addr) == REG)\n \tscratch1 = addr;\n \n-      seq = gen_unaligned_storehi (addr, operands[1], scratch1,\n-\t\t\t\t   scratch2, scratch3);\n+      seq = gen_unaligned_store<reloadmode> (addr, operands[1], scratch1,\n+\t\t\t\t\t     scratch2, scratch3);\n       alpha_set_memflags (seq, operands[0]);\n       emit_insn (seq);\n     }\n@@ -6225,65 +6219,30 @@\n ;; always get a proper address for a stack slot during reload_foo\n ;; expansion, so we must delay our address manipulations until after.\n \n-(define_insn_and_split \"reload_inqi_help\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (match_operand:QI 1 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+(define_insn_and_split \"reload_in<mode>_aligned\"\n+  [(set (match_operand:I12MODE 0 \"register_operand\" \"=r\")\n+        (match_operand:I12MODE 1 \"memory_operand\" \"m\"))]\n+  \"!TARGET_BWX && (reload_in_progress || reload_completed)\"\n   \"#\"\n-  \"! TARGET_BWX && reload_completed\"\n+  \"!TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-  operands[0] = gen_lowpart (DImode, operands[0]);\n-  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n-\t\t\t\t operands[2]));\n-  DONE;\n-})\n-\n-(define_insn_and_split \"reload_inhi_help\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (match_operand:HI 1 \"memory_operand\" \"m\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n-  \"#\"\n-  \"! TARGET_BWX && reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx aligned_mem, bitnum;\n-  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-  operands[0] = gen_lowpart (DImode, operands[0]);\n-  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n-\t\t\t\t operands[2]));\n-  DONE;\n-})\n-\n-(define_insn_and_split \"reload_outqi_help\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n-        (match_operand:QI 1 \"register_operand\" \"r\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n-  \"#\"\n-  \"! TARGET_BWX && reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx aligned_mem, bitnum;\n-  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n-  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\toperands[2], operands[3]));\n+  emit_insn (gen_aligned_load<reloadmode>\n+\t     (gen_lowpart (DImode, operands[0]), aligned_mem, bitnum,\n+\t      gen_rtx_REG (SImode, REGNO (operands[0]))));\n   DONE;\n })\n \n-(define_insn_and_split \"reload_outhi_help\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n-        (match_operand:HI 1 \"register_operand\" \"r\"))\n+(define_insn_and_split \"reload_out<mode>_aligned\"\n+  [(set (match_operand:I12MODE 0 \"memory_operand\" \"=m\")\n+        (match_operand:I12MODE 1 \"register_operand\" \"r\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))\n    (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"!TARGET_BWX && (reload_in_progress || reload_completed)\"\n   \"#\"\n-  \"! TARGET_BWX && reload_completed\"\n+  \"!TARGET_BWX && reload_completed\"\n   [(const_int 0)]\n {\n   rtx aligned_mem, bitnum;"}, {"sha": "a4e9c9e5abc4c70eeee17060e4959c82bd61be59", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -434,7 +434,7 @@\n ;; use recog during reload, so pretending these codes are accepted \n ;; pessimizes things a tad.\n \n-(define_predicate \"aligned_memory_operand\"\n+(define_special_predicate \"aligned_memory_operand\"\n   (ior (match_test \"op = resolve_reload_operand (op), 0\")\n        (match_code \"mem\"))\n {\n@@ -462,7 +462,7 @@\n \n ;; Similar, but return 1 if OP is a MEM which is not alignable.\n \n-(define_predicate \"unaligned_memory_operand\"\n+(define_special_predicate \"unaligned_memory_operand\"\n   (ior (match_test \"op = resolve_reload_operand (op), 0\")\n        (match_code \"mem\"))\n {\n@@ -489,20 +489,30 @@\n })\n \n ;; Return 1 if OP is any memory location.  During reload a pseudo matches.\n-(define_predicate \"any_memory_operand\"\n-  (ior (match_code \"mem,reg\")\n-       (and (match_code \"subreg\")\n-\t    (match_test \"GET_CODE (SUBREG_REG (op)) == REG\"))))\n+(define_special_predicate \"any_memory_operand\"\n+  (match_code \"mem,reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n \n-;; Return 1 if OP is either a register or an unaligned memory location.\n-(define_predicate \"reg_or_unaligned_mem_operand\"\n-  (ior (match_operand 0 \"register_operand\")\n-       (match_operand 0 \"unaligned_memory_operand\")))\n+  if (MEM_P (op))\n+    return true;\n+  if (reload_in_progress && REG_P (op))\n+    {\n+      unsigned regno = REGNO (op);\n+      if (HARD_REGISTER_NUM_P (regno))\n+\treturn false;\n+      else\n+\treturn reg_renumber[regno] < 0;\n+    }\n+\n+  return false;\n+})\n \n ;; Return 1 is OP is a memory location that is not a reference\n ;; (using an AND) to an unaligned location.  Take into account\n ;; what reload will do.\n-(define_predicate \"normal_memory_operand\"\n+(define_special_predicate \"normal_memory_operand\"\n   (ior (match_test \"op = resolve_reload_operand (op), 0\")\n        (and (match_code \"mem\")\n \t    (match_test \"GET_CODE (XEXP (op, 0)) != AND\"))))"}, {"sha": "9a90245b5a5dea2b252157543057571f71255f91", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f46219bd21a0cdd955700b7c0b448d52f457cd/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=48f46219bd21a0cdd955700b7c0b448d52f457cd", "patch": "@@ -19,10 +19,6 @@\n ;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n ;; Boston, MA 02110-1301, USA.\n \n-(define_mode_macro I12MODE [QI HI])\n-(define_mode_macro I48MODE [SI DI])\n-(define_mode_attr modesuffix [(SI \"l\") (DI \"q\")])\n-\n (define_code_macro FETCHOP [plus minus ior xor and])\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])"}]}