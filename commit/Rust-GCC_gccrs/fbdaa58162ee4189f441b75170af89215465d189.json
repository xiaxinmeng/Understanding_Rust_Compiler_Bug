{"sha": "fbdaa58162ee4189f441b75170af89215465d189", "node_id": "C_kwDOANBUbNoAKGZiZGFhNTgxNjJlZTQxODlmNDQxYjc1MTcwYWY4OTIxNTQ2NWQxODk", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-03-21T15:52:40Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-03-21T18:51:50Z"}, "message": "d: Merge upstream dmd 2503f17e5, phobos a74fa63e6.\n\nD front-end changes:\n\n    - Import dmd mainline development.\n    - Removed internal d_intN and d_unsN aliases to stdint types, which\n      caused a regression on Solaris where int8_t is a char (PR104911).\n\nPhobos changes:\n\n    - Import phobos mainline development.\n\n\tPR d/104911\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 2503f17e5.\n\t* d-convert.cc (convert_expr): Replace d_uns64 with dinteger_t.\n\t* d-lang.cc: Remove dmd/root/file.h include.\n\t(d_handle_option): Update for new front-end interface.\n\t(d_parse_file): Likewise.\n\nlibphobos/ChangeLog:\n\n\t* src/MERGE: Merge upstream phobos a74fa63e6.", "tree": {"sha": "77c5816b721cad2691bea1d228cb5ecc31568f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77c5816b721cad2691bea1d228cb5ecc31568f9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbdaa58162ee4189f441b75170af89215465d189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdaa58162ee4189f441b75170af89215465d189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdaa58162ee4189f441b75170af89215465d189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdaa58162ee4189f441b75170af89215465d189/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a"}], "stats": {"total": 1842, "additions": 1098, "deletions": 744}, "files": [{"sha": "3a6a32ab0248dc6933abc428d534a7a5060c137b", "filename": "gcc/d/d-convert.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fd-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fd-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-convert.cc?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -518,8 +518,8 @@ convert_expr (tree exp, Type *etype, Type *totype)\n       else if (tbtype->ty == TY::Tarray)\n \t{\n \t  /* Assume tvoid->size() == 1.  */\n-\t  d_uns64 fsize = ebtype->nextOf ()->toBasetype ()->size ();\n-\t  d_uns64 tsize = tbtype->nextOf ()->toBasetype ()->size ();\n+\t  dinteger_t fsize = ebtype->nextOf ()->toBasetype ()->size ();\n+\t  dinteger_t tsize = tbtype->nextOf ()->toBasetype ()->size ();\n \n \t  if (fsize != tsize)\n \t    {"}, {"sha": "4a7aa8983b7db1aaa680bdb1cf01a31d32714b5c", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dmd/mangle.h\"\n #include \"dmd/module.h\"\n #include \"dmd/mtype.h\"\n-#include \"dmd/root/file.h\"\n #include \"dmd/target.h\"\n \n #include \"opts.h\"\n@@ -579,7 +578,7 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.fix16997 = value;\n       global.params.markdown = value;\n       global.params.noSharedAccess = value;\n-      global.params.rvalueRefParam = value;\n+      global.params.rvalueRefParam = FeatureState::enabled;\n       global.params.inclusiveInContracts = value;\n       global.params.shortenedMethods = value;\n       break;\n@@ -625,7 +624,7 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       break;\n \n     case OPT_fpreview_rvaluerefparam:\n-      global.params.rvalueRefParam = value;\n+      global.params.rvalueRefParam = FeatureState::enabled;\n       break;\n \n     case OPT_fpreview_shortenedmethods:\n@@ -1069,9 +1068,8 @@ d_parse_file (void)\n \n \t  /* Overwrite the source file for the module, the one created by\n \t     Module::create would have a forced a `.d' suffix.  */\n-\t  m->srcBuffer = FileBuffer::create ();\n-\t  m->srcBuffer->data.length = len;\n-\t  m->srcBuffer->data.ptr = buffer;\n+\t  m->src.length = len;\n+\t  m->src.ptr = buffer;\n \t}\n       else\n \t{\n@@ -1108,7 +1106,7 @@ d_parse_file (void)\n       m->importedFrom = m;\n       m->parse ();\n \n-      if (m->isDocFile)\n+      if (m->filetype == FileType::ddoc)\n \t{\n \t  gendocfile (m);\n \t  /* Remove M from list of modules.  */\n@@ -1146,7 +1144,8 @@ d_parse_file (void)\n       for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n-\t  if (m->isHdrFile || (d_option.fonly && m != Module::rootModule))\n+\t  if (m->filetype == FileType::dhdr\n+\t      || (d_option.fonly && m != Module::rootModule))\n \t    continue;\n \n \t  if (global.params.verbose)\n@@ -1374,7 +1373,7 @@ d_parse_file (void)\n \n       /* Skip generating code for header files, or when the module wasn't\n \t specified by `-fonly=`.  */\n-      if ((m->isHdrFile && m != main_module)\n+      if ((m->filetype == FileType::dhdr && m != main_module)\n \t  || (d_option.fonly && m != Module::rootModule))\n \tcontinue;\n \n@@ -1421,7 +1420,8 @@ d_parse_file (void)\n       for (size_t i = 0; i < modules.length; i++)\n \t{\n \t  Module *m = modules[i];\n-\t  if (m->isHdrFile || (d_option.fonly && m != Module::rootModule))\n+\t  if (m->filetype == FileType::dhdr\n+\t      || (d_option.fonly && m != Module::rootModule))\n \t    continue;\n \n \t  remove (m->hdrfile.toChars ());"}, {"sha": "3e3e11344521092e05f07efaa4d33bd2fb08cde4", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1,4 +1,4 @@\n-cbba5f41a32cfed7f22a213d537f8e2dee0b92f7\n+2503f17e5767bc4fcd0cf3889c90fa0415b0edaa\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "f790730fce9310b44c58aad7277c17e428eaf455", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -234,7 +234,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n \n     abstract void finalizeSize();\n \n-    override final d_uns64 size(const ref Loc loc)\n+    override final uinteger_t size(const ref Loc loc)\n     {\n         //printf(\"+AggregateDeclaration::size() %s, scope = %p, sizeok = %d\\n\", toChars(), _scope, sizeok);\n         bool ok = determineSize(loc);"}, {"sha": "bdeb38e8b45096dc342c10e3e285a8e30e0d5ed2", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -124,7 +124,7 @@ class AggregateDeclaration : public ScopeDsymbol\n     size_t nonHiddenFields();\n     bool determineSize(const Loc &loc);\n     virtual void finalizeSize() = 0;\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     bool fill(const Loc &loc, Expressions *elements, bool ctorinit);\n     Type *getType();\n     bool isDeprecated() const;         // is aggregate deprecated?"}, {"sha": "1a2cf8b0641e26095172b38e9ac63bcef921b4e8", "filename": "gcc/d/dmd/astenums.d", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fastenums.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fastenums.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastenums.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -430,3 +430,12 @@ enum PINLINE : ubyte\n     never,    /// never inline\n     always,   /// always inline\n }\n+\n+/// Source file type\n+enum FileType : ubyte\n+{\n+    d,    /// normal D source file\n+    dhdr, /// D header file (.di)\n+    ddoc, /// Ddoc documentation file (.dd)\n+    c,    /// C source file\n+}"}, {"sha": "9c2bbd672a7a06ef9c0675cef8ac8e8d58c1a0d0", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -247,12 +247,12 @@ extern (C++) class StorageClassDeclaration : AttribDeclaration\n          */\n         if (stc & (STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.manifest))\n             scstc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.extern_ | STC.manifest);\n-        if (stc & (STC.auto_ | STC.scope_ | STC.static_ | STC.tls | STC.manifest | STC.gshared))\n-            scstc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.tls | STC.manifest | STC.gshared);\n+        if (stc & (STC.auto_ | STC.scope_ | STC.static_ | STC.manifest | STC.gshared))\n+            scstc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.manifest | STC.gshared);\n         if (stc & (STC.const_ | STC.immutable_ | STC.manifest))\n             scstc &= ~(STC.const_ | STC.immutable_ | STC.manifest);\n-        if (stc & (STC.gshared | STC.shared_ | STC.tls))\n-            scstc &= ~(STC.gshared | STC.shared_ | STC.tls);\n+        if (stc & (STC.gshared | STC.shared_))\n+            scstc &= ~(STC.gshared | STC.shared_);\n         if (stc & (STC.safe | STC.trusted | STC.system))\n             scstc &= ~(STC.safe | STC.trusted | STC.system);\n         scstc |= stc;"}, {"sha": "5c0120493422f0ec76b7bbbb4b67f5b7dd1b7354", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -146,7 +146,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                             else if (sd && (!sd.statement.hasCode() || sd.statement.isCaseStatement() || sd.statement.isErrorStatement()))\n                             {\n                             }\n-                            else if (!func.getModule().isCFile)\n+                            else if (func.getModule().filetype != FileType.c)\n                             {\n                                 const(char)* gototype = s.isCaseStatement() ? \"case\" : \"default\";\n                                 s.error(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);"}, {"sha": "a38cbb1610b1ba96a7bedfd82e149184cfdb03a1", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -246,7 +246,7 @@ private CT Dsymbol_canThrow(Dsymbol s, FuncDeclaration func, bool mustNotThrow)\n         if (vd.storage_class & STC.manifest)\n         {\n         }\n-        else if (vd.isStatic() || vd.storage_class & (STC.extern_ | STC.tls | STC.gshared))\n+        else if (vd.isStatic() || vd.storage_class & (STC.extern_ | STC.gshared))\n         {\n         }\n         else"}, {"sha": "9941c167b06eef6c0f53524aa4040b1d97e810f8", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -619,31 +619,31 @@ UnionExp Shr(const ref Loc loc, Type type, Expression e1, Expression e2)\n     switch (e1.type.toBasetype().ty)\n     {\n     case Tint8:\n-        value = cast(d_int8)value >> count;\n+        value = cast(byte)value >> count;\n         break;\n     case Tuns8:\n     case Tchar:\n-        value = cast(d_uns8)value >> count;\n+        value = cast(ubyte)value >> count;\n         break;\n     case Tint16:\n-        value = cast(d_int16)value >> count;\n+        value = cast(short)value >> count;\n         break;\n     case Tuns16:\n     case Twchar:\n-        value = cast(d_uns16)value >> count;\n+        value = cast(ushort)value >> count;\n         break;\n     case Tint32:\n-        value = cast(d_int32)value >> count;\n+        value = cast(int)value >> count;\n         break;\n     case Tuns32:\n     case Tdchar:\n-        value = cast(d_uns32)value >> count;\n+        value = cast(uint)value >> count;\n         break;\n     case Tint64:\n-        value = cast(d_int64)value >> count;\n+        value = cast(long)value >> count;\n         break;\n     case Tuns64:\n-        value = cast(d_uns64)value >> count;\n+        value = cast(ulong)value >> count;\n         break;\n     case Terror:\n         emplaceExp!(ErrorExp)(&ue);\n@@ -1106,31 +1106,31 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n             switch (typeb.ty)\n             {\n             case Tint8:\n-                result = cast(d_int8)cast(sinteger_t)r;\n+                result = cast(byte)cast(sinteger_t)r;\n                 break;\n             case Tchar:\n             case Tuns8:\n-                result = cast(d_uns8)cast(dinteger_t)r;\n+                result = cast(ubyte)cast(dinteger_t)r;\n                 break;\n             case Tint16:\n-                result = cast(d_int16)cast(sinteger_t)r;\n+                result = cast(short)cast(sinteger_t)r;\n                 break;\n             case Twchar:\n             case Tuns16:\n-                result = cast(d_uns16)cast(dinteger_t)r;\n+                result = cast(ushort)cast(dinteger_t)r;\n                 break;\n             case Tint32:\n-                result = cast(d_int32)r;\n+                result = cast(int)r;\n                 break;\n             case Tdchar:\n             case Tuns32:\n-                result = cast(d_uns32)r;\n+                result = cast(uint)r;\n                 break;\n             case Tint64:\n-                result = cast(d_int64)r;\n+                result = cast(long)r;\n                 break;\n             case Tuns64:\n-                result = cast(d_uns64)r;\n+                result = cast(ulong)r;\n                 break;\n             default:\n                 assert(0);\n@@ -1348,14 +1348,6 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n         }\n     }\n \n-    static bool sliceBoundsCheck(uinteger_t lwr, uinteger_t upr, uinteger_t newlwr, uinteger_t newupr) pure\n-    {\n-        assert(lwr <= upr);\n-        return !(newlwr <= newupr &&\n-                 lwr <= newlwr &&\n-                 newupr <= upr);\n-    }\n-\n     if (e1.op == EXP.string_ && lwr.op == EXP.int64 && upr.op == EXP.int64)\n     {\n         StringExp es1 = cast(StringExp)e1;\n@@ -1395,6 +1387,16 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n     return ue;\n }\n \n+/* Check whether slice `[newlwr .. newupr]` is in the range `[lwr .. upr]`\n+ */\n+bool sliceBoundsCheck(uinteger_t lwr, uinteger_t upr, uinteger_t newlwr, uinteger_t newupr) pure\n+{\n+    assert(lwr <= upr);\n+    return !(newlwr <= newupr &&\n+             lwr <= newlwr &&\n+             newupr <= upr);\n+}\n+\n /* Set a slice of char/integer array literal 'existingAE' from a string 'newval'.\n  * existingAE[firstIndex..firstIndex+newval.length] = newval.\n  */"}, {"sha": "fb52b63fe29754953c518c6b6da325dd6664decd", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 146, "deletions": 29, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -48,14 +48,16 @@ final class CParser(AST) : Parser!AST\n         Array!structalign_t* packs;     // parallel alignment values\n     }\n \n-    /** C allows declaring a function with a typedef:\n-     *   typedef int (myfunc)(); myfunc fun;\n-     * but we need to distinguish `fun` being a function as opposed to a variable in the\n-     * parse pass. This is accomplished by having a simple symbol table of typedefs\n-     * where we know, by syntax, if they are function types or non-function types.\n-     * funcTypeIds is the symbol table, of the identifiers of typedefs of function types.\n+    /* C cannot be parsed without determining if an identifier is a type or a variable.\n+     * For expressions like `(T)-3`, is it a cast or a minus expression?\n+     * It also occurs with `typedef int (F)(); F fun;`\n+     * but to build the AST we need to distinguish `fun` being a function as opposed to a variable.\n+     * To fix, build a symbol table for the typedefs.\n+     * Symbol table of typedefs indexed by Identifier cast to void*.\n+     * 1. if an identifier is a typedef, then it will return a non-null Type\n+     * 2. if an identifier is not a typedef, then it will return null\n      */\n-    AST.Identifiers funcTypeIds;  /// Identifiers in this are typedefs of function types\n+    Array!(void*) typedefTab;  /// Array of AST.Type[Identifier], typedef's indexed by Identifier\n \n     extern (D) this(TARGET)(AST.Module _module, const(char)[] input, bool doDocComment,\n                             const ref TARGET target)\n@@ -97,6 +99,7 @@ final class CParser(AST) : Parser!AST\n     {\n         //printf(\"cparseTranslationUnit()\\n\");\n         symbols = new AST.Dsymbols();\n+        typedefTab.push(null);  // C11 6.2.1-3 symbol table for \"file scope\"\n         while (1)\n         {\n             if (token.value == TOK.endOfFile)\n@@ -115,6 +118,10 @@ final class CParser(AST) : Parser!AST\n                     wrap.push(s);\n                 }\n \n+                // end of file scope\n+                typedefTab.pop();\n+                assert(typedefTab.length == 0);\n+\n                 return wrap;\n             }\n \n@@ -150,10 +157,17 @@ final class CParser(AST) : Parser!AST\n \n         //printf(\"cparseStatement()\\n\");\n \n-        const funcTypeIdsLengthSave = funcTypeIds.length;\n+        const typedefTabLengthSave = typedefTab.length;\n         auto symbolsSave = symbols;\n+        if (flags & ParseStatementFlags.scope_)\n+        {\n+            typedefTab.push(null);      // introduce new block scope\n+        }\n+\n         if (!(flags & (ParseStatementFlags.scope_ | ParseStatementFlags.curlyScope)))\n+        {\n             symbols = new AST.Dsymbols();\n+        }\n \n         switch (token.value)\n         {\n@@ -593,7 +607,7 @@ final class CParser(AST) : Parser!AST\n         if (pEndloc)\n             *pEndloc = prevloc;\n         symbols = symbolsSave;\n-        funcTypeIds.setDim(funcTypeIdsLengthSave);\n+        typedefTab.setDim(typedefTabLengthSave);\n         return s;\n     }\n \n@@ -1002,8 +1016,18 @@ final class CParser(AST) : Parser!AST\n     {\n         if (token.value == TOK.leftParenthesis)\n         {\n+            auto tk = peek(&token);\n+            if (tk.value == TOK.identifier &&\n+                !isTypedef(tk.ident) &&\n+                peek(tk).value == TOK.rightParenthesis)\n+            {\n+                // ( identifier ) is an expression\n+                return cparseUnaryExp();\n+            }\n+\n             // If ( type-name )\n             auto pt = &token;\n+\n             if (isCastExpression(pt))\n             {\n                 // Expression may be either a cast or a compound literal, which\n@@ -1573,7 +1597,7 @@ final class CParser(AST) : Parser!AST\n             return;\n         }\n \n-        const funcTypeIdsLengthSave = funcTypeIds.length;\n+        const typedefTabLengthSave = typedefTab.length;\n         auto symbolsSave = symbols;\n         Specifier specifier;\n         specifier.packalign = this.packalign;\n@@ -1683,13 +1707,13 @@ final class CParser(AST) : Parser!AST\n                 t.value == TOK.leftCurly)  // start of compound-statement\n             {\n                 auto s = cparseFunctionDefinition(id, dt.isTypeFunction(), specifier);\n-                funcTypeIds.setDim(funcTypeIdsLengthSave);\n+                typedefTab.setDim(typedefTabLengthSave);\n                 symbols = symbolsSave;\n                 symbols.push(s);\n                 return;\n             }\n             AST.Dsymbol s = null;\n-            funcTypeIds.setDim(funcTypeIdsLengthSave);\n+            typedefTab.setDim(typedefTabLengthSave);\n             symbols = symbolsSave;\n             if (!symbols)\n                 symbols = new AST.Dsymbols;     // lazilly create it\n@@ -1747,12 +1771,9 @@ final class CParser(AST) : Parser!AST\n                         }\n                     }\n                 }\n-                else if (isFunctionTypedef(dt))\n-                {\n-                    funcTypeIds.push(id);       // remember function typedefs\n-                }\n                 if (isalias)\n                     s = new AST.AliasDeclaration(token.loc, id, dt);\n+                insertTypedefToTypedefTab(id, dt);       // remember typedefs\n             }\n             else if (id)\n             {\n@@ -1791,6 +1812,8 @@ final class CParser(AST) : Parser!AST\n                         initializer = new AST.VoidInitializer(token.loc);\n                     s = new AST.VarDeclaration(token.loc, dt, id, initializer, specifiersToSTC(level, specifier));\n                 }\n+                if (level != LVL.global)\n+                    insertIdToTypedefTab(id);   // non-typedef declarations can hide typedefs in outer scopes\n             }\n             if (s !is null)\n             {\n@@ -1868,6 +1891,10 @@ final class CParser(AST) : Parser!AST\n      */\n     AST.Dsymbol cparseFunctionDefinition(Identifier id, AST.TypeFunction ft, ref Specifier specifier)\n     {\n+        /* Start function scope\n+         */\n+        typedefTab.push(null);\n+\n         if (token.value != TOK.leftCurly)       // if not start of a compound-statement\n         {\n             // Do declaration-list\n@@ -1930,6 +1957,8 @@ final class CParser(AST) : Parser!AST\n         const locFunc = token.loc;\n \n         auto body = cparseStatement(ParseStatementFlags.curly);  // don't start a new scope; continue with parameter scope\n+        typedefTab.pop();                                        // end of function scope\n+\n         auto fd = new AST.FuncDeclaration(locFunc, prevloc, id, specifiersToSTC(LVL.global, specifier), ft, specifier.noreturn);\n \n         if (addFuncName)\n@@ -2737,6 +2766,16 @@ final class CParser(AST) : Parser!AST\n             return AST.ParameterList(parameters, AST.VarArg.variadic, varargsStc);\n         }\n \n+        /* Create function prototype scope\n+         */\n+        typedefTab.push(null);\n+\n+        AST.ParameterList finish()\n+        {\n+            typedefTab.pop();\n+            return AST.ParameterList(parameters, varargs, varargsStc);\n+        }\n+\n         /* The check for identifier-list comes later,\n          * when doing the trailing declaration-list (opt)\n          */\n@@ -2752,7 +2791,7 @@ final class CParser(AST) : Parser!AST\n                 varargs = AST.VarArg.variadic;  // C-style variadics\n                 nextToken();\n                 check(TOK.rightParenthesis);\n-                return AST.ParameterList(parameters, varargs, varargsStc);\n+                return finish();\n             }\n \n             Specifier specifier;\n@@ -2777,7 +2816,7 @@ final class CParser(AST) : Parser!AST\n             check(TOK.comma);\n         }\n         nextToken();\n-        return AST.ParameterList(parameters, varargs, varargsStc);\n+        return finish();\n     }\n \n     /***********************************\n@@ -4121,12 +4160,14 @@ final class CParser(AST) : Parser!AST\n      *    ( expression )\n      * Params:\n      *    pt = starting token, updated to one past end of constant-expression if true\n-     *    afterParenType = true if already seen ( type-name )\n+     *    afterParenType = true if already seen `( type-name )`\n      * Returns:\n      *    true if matches ( type-name ) ...\n      */\n     private bool isCastExpression(ref Token* pt, bool afterParenType = false)\n     {\n+        enum log = false;\n+        if (log) printf(\"isCastExpression(tk: `%s`, afterParenType: %d)\\n\", token.toChars(pt.value), afterParenType);\n         auto t = pt;\n         switch (t.value)\n         {\n@@ -4144,31 +4185,38 @@ final class CParser(AST) : Parser!AST\n                 {\n                     // ( type-name ) { initializer-list }\n                     if (!isInitializer(tk))\n+                    {\n                         return false;\n+                    }\n                     t = tk;\n                     break;\n                 }\n \n                 if (tk.value == TOK.leftParenthesis && peek(tk).value == TOK.rightParenthesis)\n+                {\n                     return false;    // (type-name)() is not a cast (it might be a function call)\n+                }\n \n                 if (!isCastExpression(tk, true))\n                 {\n                     if (afterParenType) // could be ( type-name ) ( unary-expression )\n                         goto default;   // where unary-expression also matched type-name\n-                    return false;\n+                    return true;\n                 }\n                 // ( type-name ) cast-expression\n                 t = tk;\n                 break;\n \n             default:\n                 if (!afterParenType || !isUnaryExpression(t, afterParenType))\n+                {\n                     return false;\n+                }\n                 // if we've already seen ( type-name ), then this is a cast\n                 break;\n         }\n         pt = t;\n+        if (log) printf(\"isCastExpression true\\n\");\n         return true;\n     }\n \n@@ -4576,9 +4624,14 @@ final class CParser(AST) : Parser!AST\n         return s;\n     }\n \n+    //}\n+\n+    /******************************************************************************/\n+    /************************** typedefTab symbol table ***************************/\n+    //{\n+\n     /********************************\n      * Determines if type t is a function type.\n-     * Make this work without needing semantic analysis.\n      * Params:\n      *  t = type to test\n      * Returns:\n@@ -4591,20 +4644,84 @@ final class CParser(AST) : Parser!AST\n             return true;\n         if (auto tid = t.isTypeIdentifier())\n         {\n-            /* Scan array of typedef identifiers that are an alias for\n-             * a function type\n-             */\n-            foreach (ftid; funcTypeIds[])\n+            auto pt = lookupTypedef(tid.ident);\n+            if (pt && *pt)\n             {\n-                if (tid.ident == ftid)\n-                {\n-                    return true;\n-                }\n+                return (*pt).isTypeFunction() !is null;\n             }\n         }\n         return false;\n     }\n \n+    /********************************\n+     * Determine if `id` is a symbol for a Typedef.\n+     * Params:\n+     *  id = possible typedef\n+     * Returns:\n+     *  true if id is a Type\n+     */\n+    bool isTypedef(Identifier id)\n+    {\n+        auto pt = lookupTypedef(id);\n+        return (pt && *pt);\n+    }\n+\n+    /*******************************\n+     * Add `id` to typedefTab[], but only if it will mask an existing typedef.\n+     * Params: id = identifier for non-typedef symbol\n+     */\n+    void insertIdToTypedefTab(Identifier id)\n+    {\n+        //printf(\"insertIdToTypedefTab(id: %s) level %d\\n\", id.toChars(), cast(int)typedefTab.length - 1);\n+        if (isTypedef(id))  // if existing typedef\n+        {\n+            /* Add id as null, so we can later distinguish it from a non-null typedef\n+             */\n+            auto tab = cast(void*[void*])(typedefTab[$ - 1]);\n+            tab[cast(void*)id] = cast(void*)null;\n+        }\n+    }\n+\n+    /*******************************\n+     * Add `id` to typedefTab[]\n+     * Params:\n+     *  id = identifier for typedef symbol\n+     *  t = type of the typedef symbol\n+     */\n+    void insertTypedefToTypedefTab(Identifier id, AST.Type t)\n+    {\n+        //printf(\"insertTypedefToTypedefTab(id: %s, t: %s) level %d\\n\", id.toChars(), t ? t.toChars() : \"null\".ptr, cast(int)typedefTab.length - 1);\n+        if (auto tid = t.isTypeIdentifier())\n+        {\n+            // Try to resolve the TypeIdentifier to its type\n+            auto pt = lookupTypedef(tid.ident);\n+            if (pt && *pt)\n+                t = *pt;\n+        }\n+        auto tab = cast(void*[void*])(typedefTab[$ - 1]);\n+        tab[cast(void*)id] = cast(void*)t;\n+        typedefTab[$ - 1] = cast(void*)tab;\n+    }\n+\n+    /*********************************\n+     * Lookup id in typedefTab[].\n+     * Returns:\n+     *  if not found, then null.\n+     *  if found, then Type*. Deferencing it will yield null if it is not\n+     *  a typedef, and a type if it is a typedef.\n+     */\n+    AST.Type* lookupTypedef(Identifier id)\n+    {\n+        foreach_reverse (tab; typedefTab[])\n+        {\n+            if (auto pt = cast(void*)id in cast(void*[void*])tab)\n+            {\n+                return cast(AST.Type*)pt;\n+            }\n+        }\n+        return null; // not found\n+    }\n+\n     //}\n \n     /******************************************************************************/"}, {"sha": "13ef34c052b1379b233c47b42aa9ccedb27f2e76", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1908,6 +1908,8 @@ extern(C++):\n             return writeBasicType(t, 0, 'l');\n         else if (id == Id.__c_ulong)\n             return writeBasicType(t, 0, 'm');\n+        else if (id == Id.__c_char)\n+            return writeBasicType(t, 0, 'c');\n         else if (id == Id.__c_wchar_t)\n             return writeBasicType(t, 0, 'w');\n         else if (id == Id.__c_longlong)"}, {"sha": "9078f90dc306b539c4dddab68a20bb474f3f170a", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -343,10 +343,9 @@ UnionExp copyLiteral(Expression e)\n                 {\n                     auto tsa = v.type.isTypeSArray();\n                     auto len = cast(size_t)tsa.dim.toInteger();\n-                    UnionExp uex = void;\n-                    m = createBlockDuplicatedArrayLiteral(&uex, e.loc, v.type, m, len);\n-                    if (m == uex.exp())\n-                        m = uex.copy();\n+                    m = createBlockDuplicatedArrayLiteral(&ue, e.loc, v.type, m, len);\n+                    if (m == ue.exp())\n+                        m = ue.copy();\n                 }\n             }\n             el = m;\n@@ -583,10 +582,9 @@ ArrayLiteralExp createBlockDuplicatedArrayLiteral(UnionExp* pue, const ref Loc l\n         // If it is a multidimensional array literal, do it recursively\n         auto tsa = type.nextOf().isTypeSArray();\n         const len = cast(size_t)tsa.dim.toInteger();\n-        UnionExp ue = void;\n-        elem = createBlockDuplicatedArrayLiteral(&ue, loc, type.nextOf(), elem, len);\n-        if (elem == ue.exp())\n-            elem = ue.copy();\n+        elem = createBlockDuplicatedArrayLiteral(pue, loc, type.nextOf(), elem, len);\n+        if (elem == pue.exp())\n+            elem = pue.copy();\n     }\n \n     // Buzilla 15681\n@@ -791,49 +789,47 @@ bool pointToSameMemoryBlock(Expression agg1, Expression agg2)\n }\n \n // return e1 - e2 as an integer, or error if not possible\n-UnionExp pointerDifference(const ref Loc loc, Type type, Expression e1, Expression e2)\n+Expression pointerDifference(UnionExp* pue, const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n-    UnionExp ue = void;\n     dinteger_t ofs1, ofs2;\n     Expression agg1 = getAggregateFromPointer(e1, &ofs1);\n     Expression agg2 = getAggregateFromPointer(e2, &ofs2);\n     if (agg1 == agg2)\n     {\n         Type pointee = (cast(TypePointer)agg1.type).next;\n         const sz = pointee.size();\n-        emplaceExp!(IntegerExp)(&ue, loc, (ofs1 - ofs2) * sz, type);\n+        emplaceExp!(IntegerExp)(pue, loc, (ofs1 - ofs2) * sz, type);\n     }\n     else if (agg1.op == EXP.string_ && agg2.op == EXP.string_ &&\n              (cast(StringExp)agg1).peekString().ptr == (cast(StringExp)agg2).peekString().ptr)\n     {\n         Type pointee = (cast(TypePointer)agg1.type).next;\n         const sz = pointee.size();\n-        emplaceExp!(IntegerExp)(&ue, loc, (ofs1 - ofs2) * sz, type);\n+        emplaceExp!(IntegerExp)(pue, loc, (ofs1 - ofs2) * sz, type);\n     }\n     else if (agg1.op == EXP.symbolOffset && agg2.op == EXP.symbolOffset &&\n              (cast(SymOffExp)agg1).var == (cast(SymOffExp)agg2).var)\n     {\n-        emplaceExp!(IntegerExp)(&ue, loc, ofs1 - ofs2, type);\n+        emplaceExp!(IntegerExp)(pue, loc, ofs1 - ofs2, type);\n     }\n     else\n     {\n         error(loc, \"`%s - %s` cannot be interpreted at compile time: cannot subtract pointers to two different memory blocks\", e1.toChars(), e2.toChars());\n-        emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n+        emplaceExp!(CTFEExp)(pue, EXP.cantExpression);\n     }\n-    return ue;\n+    return pue.exp();\n }\n \n // Return eptr op e2, where eptr is a pointer, e2 is an integer,\n // and op is EXP.add or EXP.min\n-UnionExp pointerArithmetic(const ref Loc loc, EXP op, Type type, Expression eptr, Expression e2)\n+Expression pointerArithmetic(UnionExp* pue, const ref Loc loc, EXP op, Type type, Expression eptr, Expression e2)\n {\n-    UnionExp ue;\n     if (eptr.type.nextOf().ty == Tvoid)\n     {\n         error(loc, \"cannot perform arithmetic on `void*` pointers at compile time\");\n     Lcant:\n-        emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n-        return ue;\n+        emplaceExp!(CTFEExp)(pue, EXP.cantExpression);\n+        return pue.exp();\n     }\n     if (eptr.op == EXP.address)\n         eptr = (cast(AddrExp)eptr).e1;\n@@ -885,10 +881,10 @@ UnionExp pointerArithmetic(const ref Loc loc, EXP op, Type type, Expression eptr\n     }\n     if (agg1.op == EXP.symbolOffset)\n     {\n-        emplaceExp!(SymOffExp)(&ue, loc, (cast(SymOffExp)agg1).var, indx * sz);\n-        SymOffExp se = cast(SymOffExp)ue.exp();\n+        emplaceExp!(SymOffExp)(pue, loc, (cast(SymOffExp)agg1).var, indx * sz);\n+        SymOffExp se = cast(SymOffExp)pue.exp();\n         se.type = type;\n-        return ue;\n+        return pue.exp();\n     }\n     if (agg1.op != EXP.arrayLiteral && agg1.op != EXP.string_)\n     {\n@@ -903,17 +899,17 @@ UnionExp pointerArithmetic(const ref Loc loc, EXP op, Type type, Expression eptr\n                 ctfeEmplaceExp!IntegerExp(loc, indx, Type.tsize_t),\n                 ctfeEmplaceExp!IntegerExp(loc, indx + dim, Type.tsize_t));\n         se.type = type.toBasetype().nextOf();\n-        emplaceExp!(AddrExp)(&ue, loc, se);\n-        ue.exp().type = type;\n-        return ue;\n+        emplaceExp!(AddrExp)(pue, loc, se);\n+        pue.exp().type = type;\n+        return pue.exp();\n     }\n     // Create a CTFE pointer &agg1[indx]\n     auto ofs = ctfeEmplaceExp!IntegerExp(loc, indx, Type.tsize_t);\n     Expression ie = ctfeEmplaceExp!IndexExp(loc, agg1, ofs);\n     ie.type = type.toBasetype().nextOf(); // https://issues.dlang.org/show_bug.cgi?id=13992\n-    emplaceExp!(AddrExp)(&ue, loc, ie);\n-    ue.exp().type = type;\n-    return ue;\n+    emplaceExp!(AddrExp)(pue, loc, ie);\n+    pue.exp().type = type;\n+    return pue.exp();\n }\n \n // Return 1 if true, 0 if false\n@@ -1755,9 +1751,8 @@ Expression assignAssocArrayElement(const ref Loc loc, AssocArrayLiteralExp aae,\n /// Given array literal oldval of type ArrayLiteralExp or StringExp, of length\n /// oldlen, change its length to newlen. If the newlen is longer than oldlen,\n /// all new elements will be set to the default initializer for the element type.\n-UnionExp changeArrayLiteralLength(const ref Loc loc, TypeArray arrayType, Expression oldval, size_t oldlen, size_t newlen)\n+Expression changeArrayLiteralLength(UnionExp* pue, const ref Loc loc, TypeArray arrayType, Expression oldval, size_t oldlen, size_t newlen)\n {\n-    UnionExp ue;\n     Type elemType = arrayType.next;\n     assert(elemType);\n     Expression defaultElem = elemType.defaultInitLiteral(loc);\n@@ -1794,8 +1789,8 @@ UnionExp changeArrayLiteralLength(const ref Loc loc, TypeArray arrayType, Expres\n                 assert(0);\n             }\n         }\n-        emplaceExp!(StringExp)(&ue, loc, s[0 .. newlen * oldse.sz], newlen, oldse.sz);\n-        StringExp se = cast(StringExp)ue.exp();\n+        emplaceExp!(StringExp)(pue, loc, s[0 .. newlen * oldse.sz], newlen, oldse.sz);\n+        StringExp se = cast(StringExp)pue.exp();\n         se.type = arrayType;\n         se.sz = oldse.sz;\n         se.committed = oldse.committed;\n@@ -1823,11 +1818,11 @@ UnionExp changeArrayLiteralLength(const ref Loc loc, TypeArray arrayType, Expres\n             foreach (size_t i; copylen .. newlen)\n                 (*elements)[i] = defaultElem;\n         }\n-        emplaceExp!(ArrayLiteralExp)(&ue, loc, arrayType, elements);\n-        ArrayLiteralExp aae = cast(ArrayLiteralExp)ue.exp();\n+        emplaceExp!(ArrayLiteralExp)(pue, loc, arrayType, elements);\n+        ArrayLiteralExp aae = cast(ArrayLiteralExp)pue.exp();\n         aae.ownedByCtfe = OwnedBy.ctfe;\n     }\n-    return ue;\n+    return pue.exp();\n }\n \n /*************************** CTFE Sanity Checks ***************************/"}, {"sha": "887bb898383397e3008b0c9c6fc8ebda0a4b2d19", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1894,7 +1894,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         if (e.committed && tb.ty == Tsarray && typeb.ty == Tarray)\n         {\n             se = e.copy().isStringExp();\n-            d_uns64 szx = tb.nextOf().size();\n+            uinteger_t szx = tb.nextOf().size();\n             assert(szx <= 255);\n             se.sz = cast(ubyte)szx;\n             se.len = cast(size_t)tb.isTypeSArray().dim.toInteger();\n@@ -2059,7 +2059,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 }\n \n                 {\n-                    d_uns64 szx = tb.nextOf().size();\n+                    uinteger_t szx = tb.nextOf().size();\n                     assert(szx <= 255);\n                     se.setData(buffer.extractSlice().ptr, newlen, cast(ubyte)szx);\n                 }\n@@ -2742,7 +2742,7 @@ Expression scaleFactor(BinExp be, Scope* sc)\n         // Replace (ptr + int) with (ptr + (int * stride))\n         Type t = Type.tptrdiff_t;\n \n-        d_uns64 stride = t1b.nextOf().size(be.loc);\n+        uinteger_t stride = t1b.nextOf().size(be.loc);\n         if (!t.equals(t2b))\n             be.e2 = be.e2.castTo(sc, t);\n         eoff = be.e2;\n@@ -2757,7 +2757,7 @@ Expression scaleFactor(BinExp be, Scope* sc)\n         Type t = Type.tptrdiff_t;\n         Expression e;\n \n-        d_uns64 stride = t2b.nextOf().size(be.loc);\n+        uinteger_t stride = t2b.nextOf().size(be.loc);\n         if (!t.equals(t1b))\n             e = be.e1.castTo(sc, t);\n         else"}, {"sha": "82a5f3b72f942f0b55538a874e97ed2da1269cec", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -250,7 +250,7 @@ extern (C++) abstract class Declaration : Dsymbol\n         return \"declaration\";\n     }\n \n-    override final d_uns64 size(const ref Loc loc)\n+    override final uinteger_t size(const ref Loc loc)\n     {\n         assert(type);\n         const sz = type.size();\n@@ -1141,7 +1141,7 @@ extern (C++) class VarDeclaration : Declaration\n \n         if (!isField())\n             return;\n-        assert(!(storage_class & (STC.static_ | STC.extern_ | STC.parameter | STC.tls)));\n+        assert(!(storage_class & (STC.static_ | STC.extern_ | STC.parameter)));\n \n         //printf(\"+VarDeclaration::setFieldOffset(ad = %s) %s\\n\", ad.toChars(), toChars());\n \n@@ -1217,7 +1217,7 @@ extern (C++) class VarDeclaration : Declaration\n \n     override final inout(AggregateDeclaration) isThis() inout\n     {\n-        if (!(storage_class & (STC.static_ | STC.extern_ | STC.manifest | STC.templateparameter | STC.tls | STC.gshared | STC.ctfe)))\n+        if (!(storage_class & (STC.static_ | STC.extern_ | STC.manifest | STC.templateparameter | STC.gshared | STC.ctfe)))\n         {\n             /* The casting is necessary because `s = s.parent` is otherwise rejected\n              */\n@@ -1285,7 +1285,7 @@ extern (C++) class VarDeclaration : Declaration\n                 error(\"forward referenced\");\n                 type = Type.terror;\n             }\n-            else if (storage_class & (STC.static_ | STC.extern_ | STC.tls | STC.gshared) ||\n+            else if (storage_class & (STC.static_ | STC.extern_ | STC.gshared) ||\n                 parent.isModule() || parent.isTemplateInstance() || parent.isNspace())\n             {\n                 assert(!isParameter() && !isResult());"}, {"sha": "9986ea3ea3656d49521e6ddc7fa6c372403b05c8", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -71,7 +71,6 @@ struct IntRange;\n     #define STCnodtor             0x10000000ULL    /// do not run destructor\n     #define STCnothrow            0x20000000ULL    /// `nothrow` meaning never throws exceptions\n     #define STCpure               0x40000000ULL    /// `pure` function\n-    #define STCtls                0x80000000ULL    /// thread local\n \n     #define STCalias              0x100000000ULL    /// `alias` parameter\n     #define STCshared             0x200000000ULL    /// accessible from multiple threads\n@@ -123,7 +122,7 @@ class Declaration : public Dsymbol\n     DString mangleOverride;     // overridden symbol with pragma(mangle, \"...\")\n \n     const char *kind() const;\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n \n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n "}, {"sha": "30a8a44415563847eb2070b58e7f3fb5f634b05e", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 21, "deletions": 63, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1886,7 +1886,7 @@ public:\n         {\n             // Check for unsupported type painting operations\n             Type elemtype = (cast(TypeArray)val.type).next;\n-            d_uns64 elemsize = elemtype.size();\n+            const elemsize = elemtype.size();\n \n             // It's OK to cast from fixed length to fixed length array, eg &int[n] to int[d]*.\n             if (val.type.ty == Tsarray && pointee.ty == Tsarray && elemsize == pointee.nextOf().size())\n@@ -2981,8 +2981,7 @@ public:\n             Expression e2 = interpret(&ue2, e.e2, istate);\n             if (exceptionOrCant(e2))\n                 return;\n-            *pue = pointerDifference(e.loc, e.type, e1, e2);\n-            result = (*pue).exp();\n+            result = pointerDifference(pue, e.loc, e.type, e1, e2);\n             return;\n         }\n         if (e.e1.type.ty == Tpointer && e.e2.type.isintegral())\n@@ -2995,8 +2994,7 @@ public:\n             Expression e2 = interpret(&ue2, e.e2, istate);\n             if (exceptionOrCant(e2))\n                 return;\n-            *pue = pointerArithmetic(e.loc, e.op, e.type, e1, e2);\n-            result = (*pue).exp();\n+            result = pointerArithmetic(pue, e.loc, e.op, e.type, e1, e2);\n             return;\n         }\n         if (e.e2.type.ty == Tpointer && e.e1.type.isintegral() && e.op == EXP.add)\n@@ -3009,8 +3007,7 @@ public:\n             Expression e2 = interpret(&ue2, e.e2, istate);\n             if (exceptionOrCant(e2))\n                 return;\n-            *pue = pointerArithmetic(e.loc, e.op, e.type, e2, e1);\n-            result = (*pue).exp();\n+            result = pointerArithmetic(pue, e.loc, e.op, e.type, e2, e1);\n             return;\n         }\n         if (e.e1.type.ty == Tpointer || e.e2.type.ty == Tpointer)\n@@ -3041,7 +3038,7 @@ public:\n         if (e.op == EXP.rightShift || e.op == EXP.leftShift || e.op == EXP.unsignedRightShift)\n         {\n             const sinteger_t i2 = e2.toInteger();\n-            const d_uns64 sz = e1.type.size() * 8;\n+            const uinteger_t sz = e1.type.size() * 8;\n             if (i2 < 0 || i2 >= sz)\n             {\n                 e.error(\"shift by %lld is outside the range 0..%llu\", i2, cast(ulong)sz - 1);\n@@ -3602,7 +3599,9 @@ public:\n                       e.op == EXP.plusPlus ||\n                       e.op == EXP.minusMinus))\n             {\n-                newval = pointerArithmetic(e.loc, e.op, e.type, oldval, newval).copy();\n+                newval = pointerArithmetic(pue, e.loc, e.op, e.type, oldval, newval).copy();\n+                if (newval == pue.exp())\n+                    newval = pue.copy();\n             }\n             else\n             {\n@@ -3675,7 +3674,9 @@ public:\n             UnionExp utmp = void;\n             oldval = resolveSlice(oldval, &utmp);\n \n-            newval = changeArrayLiteralLength(e.loc, cast(TypeArray)t, oldval, oldlen, newlen).copy();\n+            newval = changeArrayLiteralLength(pue, e.loc, cast(TypeArray)t, oldval, oldlen, newlen);\n+            if (newval == pue.exp())\n+                newval = pue.copy();\n \n             e1 = assignToLvalue(e, e1, newval);\n             if (exceptionOrCant(e1))\n@@ -3994,61 +3995,18 @@ public:\n             //   aggregate[] = newval\n             //   aggregate[low..upp] = newval\n             // ------------------------------\n-            version (all) // should be move in interpretAssignCommon as the evaluation of e1\n-            {\n-                Expression oldval = interpretRegion(se.e1, istate);\n-\n-                // Set the $ variable\n-                uinteger_t dollar = resolveArrayLength(oldval);\n-                if (se.lengthVar)\n-                {\n-                    Expression dollarExp = ctfeEmplaceExp!IntegerExp(e1.loc, dollar, Type.tsize_t);\n-                    ctfeGlobals.stack.push(se.lengthVar);\n-                    setValue(se.lengthVar, dollarExp);\n-                }\n-                Expression lwr = interpretRegion(se.lwr, istate);\n-                if (exceptionOrCantInterpret(lwr))\n-                {\n-                    if (se.lengthVar)\n-                        ctfeGlobals.stack.pop(se.lengthVar);\n-                    return lwr;\n-                }\n-                Expression upr = interpretRegion(se.upr, istate);\n-                if (exceptionOrCantInterpret(upr))\n-                {\n-                    if (se.lengthVar)\n-                        ctfeGlobals.stack.pop(se.lengthVar);\n-                    return upr;\n-                }\n-                if (se.lengthVar)\n-                    ctfeGlobals.stack.pop(se.lengthVar); // $ is defined only in [L..U]\n-\n-                const dim = dollar;\n-                lowerbound = lwr ? lwr.toInteger() : 0;\n-                upperbound = upr ? upr.toInteger() : dim;\n-\n-                if (lowerbound < 0 || dim < upperbound)\n-                {\n-                    e.error(\"array bounds `[0..%llu]` exceeded in slice `[%llu..%llu]`\",\n-                        ulong(dim), ulong(lowerbound), ulong(upperbound));\n-                    return CTFEExp.cantexp;\n-                }\n-            }\n-            aggregate = oldval;\n-            firstIndex = lowerbound;\n+            aggregate = interpretRegion(se.e1, istate);\n+            lowerbound = se.lwr ? se.lwr.toInteger() : 0;\n+            upperbound = se.upr ? se.upr.toInteger() : resolveArrayLength(aggregate);\n \n+            // Slice of a slice --> change the bounds\n             if (auto oldse = aggregate.isSliceExp())\n             {\n-                // Slice of a slice --> change the bounds\n-                if (oldse.upr.toInteger() < upperbound + oldse.lwr.toInteger())\n-                {\n-                    e.error(\"slice `[%llu..%llu]` exceeds array bounds `[0..%llu]`\",\n-                        ulong(lowerbound), ulong(upperbound), oldse.upr.toInteger() - oldse.lwr.toInteger());\n-                    return CTFEExp.cantexp;\n-                }\n                 aggregate = oldse.e1;\n                 firstIndex = lowerbound + oldse.lwr.toInteger();\n             }\n+            else\n+                firstIndex = lowerbound;\n         }\n         else\n         {\n@@ -5520,7 +5478,7 @@ public:\n             assert(agg.op == EXP.arrayLiteral || agg.op == EXP.string_);\n             dinteger_t len = ArrayLength(Type.tsize_t, agg).exp().toInteger();\n             //Type *pointee = ((TypePointer *)agg.type)->next;\n-            if (iupr > (len + 1) || iupr < ilwr)\n+            if (sliceBoundsCheck(0, len, ilwr, iupr))\n             {\n                 e.error(\"pointer slice `[%lld..%lld]` exceeds allocated memory block `[0..%lld]`\", ilwr, iupr, len);\n                 result = CTFEExp.cantexp;\n@@ -5624,9 +5582,9 @@ public:\n             //  aggregate[lo1..up1][lwr..upr] ---> aggregate[lwr'..upr']\n             uinteger_t lo1 = se.lwr.toInteger();\n             uinteger_t up1 = se.upr.toInteger();\n-            if (ilwr > iupr || iupr > up1 - lo1)\n+            if (sliceBoundsCheck(0, up1 - lo1, ilwr, iupr))\n             {\n-                e.error(\"slice `[%llu..%llu]` exceeds array bounds `[%llu..%llu]`\", ilwr, iupr, lo1, up1);\n+                e.error(\"slice `[%llu..%llu]` exceeds array bounds `[0..%llu]`\", ilwr, iupr, up1 - lo1);\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n@@ -5641,7 +5599,7 @@ public:\n         }\n         if (e1.op == EXP.arrayLiteral || e1.op == EXP.string_)\n         {\n-            if (iupr < ilwr || dollar < iupr)\n+            if (sliceBoundsCheck(0, dollar, ilwr, iupr))\n             {\n                 e.error(\"slice `[%lld..%lld]` exceeds array bounds `[0..%lld]`\", ilwr, iupr, dollar);\n                 result = CTFEExp.cantexp;"}, {"sha": "9beac6b5dcdf81d676c3154d22dd16097f1e189e", "filename": "gcc/d/dmd/dmacro.d", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdmacro.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdmacro.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -31,18 +31,12 @@ extern (C++) struct MacroTable\n     extern (D) void define(const(char)[] name, const(char)[] text)\n     {\n         //printf(\"MacroTable::define('%.*s' = '%.*s')\\n\", cast(int)name.length, name.ptr, text.length, text.ptr);\n-        Macro* table;\n-        for (table = mactab; table; table = table.next)\n+        if (auto table = name in mactab)\n         {\n-            if (table.name == name)\n-            {\n-                table.text = text;\n-                return;\n-            }\n+            (*table).text = text;\n+            return;\n         }\n-        table = new Macro(name, text);\n-        table.next = mactab;\n-        mactab = table;\n+        mactab[name] = new Macro(name, text);\n     }\n \n     /*****************************************************\n@@ -266,20 +260,16 @@ extern (C++) struct MacroTable\n \n     extern (D) Macro* search(const(char)[] name)\n     {\n-        Macro* table;\n         //printf(\"Macro::search(%.*s)\\n\", cast(int)name.length, name.ptr);\n-        for (table = mactab; table; table = table.next)\n+        if (auto table = name in mactab)\n         {\n-            if (table.name == name)\n-            {\n-                //printf(\"\\tfound %d\\n\", table.textlen);\n-                break;\n-            }\n+            //printf(\"\\tfound %d\\n\", table.textlen);\n+            return *table;\n         }\n-        return table;\n+        return null;\n     }\n \n-    Macro* mactab;\n+    private Macro*[const(char)[]] mactab;\n }\n \n /* ************************************************************************ */\n@@ -288,7 +278,6 @@ private:\n \n struct Macro\n {\n-    Macro* next;            // next in list\n     const(char)[] name;     // macro name\n     const(char)[] text;     // macro replacement text\n     int inuse;              // macro is in use (don't expand)"}, {"sha": "35d2aba70d98a0e85c3f1df07626b127ee0434c0", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 25, "deletions": 53, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -75,7 +75,7 @@ void removeHdrFilesAndFail(ref Param params, ref Modules modules)\n     {\n         foreach (m; modules)\n         {\n-            if (m.isHdrFile)\n+            if (m.filetype == FileType.dhdr)\n                 continue;\n             File.remove(m.hdrfile.toChars());\n         }\n@@ -351,12 +351,10 @@ extern (C++) final class Module : Package\n     const FileName objfile;     // output .obj file\n     const FileName hdrfile;     // 'header' file\n     FileName docfile;           // output documentation file\n-    FileBuffer* srcBuffer;      // set during load(), free'd in parse()\n+    const(ubyte)[] src;         /// Raw content of the file\n     uint errors;                // if any errors in file\n     uint numlines;              // number of lines in source file\n-    bool isHdrFile;             // if it is a header (.di) file\n-    bool isCFile;               // if it is a C (.c) file\n-    bool isDocFile;             // if it is a documentation input file, not D source\n+    FileType filetype;          // source file type\n     bool hasAlwaysInlines;      // contains references to functions that must be inlined\n     bool isPackageFile;         // if it is a package.d\n     Package pkg;                // if isPackageFile is true, the Package that contains this package.d\n@@ -590,24 +588,17 @@ extern (C++) final class Module : Package\n     }\n \n     /**\n-     * Loads the source buffer from the given read result into `this.srcBuffer`.\n+     * Trigger the relevant semantic error when a file cannot be read\n      *\n-     * Will take ownership of the buffer located inside `readResult`.\n+     * We special case `object.d` as a failure is likely to be a rare\n+     * but difficult to diagnose case for the user. Packages also require\n+     * special handling to avoid exposing the compiler's internals.\n      *\n      * Params:\n-     *  loc = the location\n-     *  readResult = the result of reading a file containing the source code\n-     *\n-     * Returns: `true` if successful\n+     *  loc = The location at which the file read originated (e.g. import)\n      */\n-    bool loadSourceBuffer(const ref Loc loc, ref File.ReadResult readResult)\n+    private void onFileReadError(const ref Loc loc)\n     {\n-        //printf(\"Module::loadSourceBuffer('%s') file '%s'\\n\", toChars(), srcfile.toChars());\n-        // take ownership of buffer\n-        srcBuffer = new FileBuffer(readResult.extractSlice());\n-        if (readResult.success)\n-            return true;\n-\n         if (FileName.equals(srcfile.toString(), \"object.d\"))\n         {\n             .error(loc, \"cannot find source code for runtime library file 'object.d'\");\n@@ -621,7 +612,6 @@ extern (C++) final class Module : Package\n             // have a valid location come from the command-line.\n             // Error that their file cannot be found and return early.\n             .error(loc, \"cannot find input file `%s`\", srcfile.toChars());\n-            return false;\n         }\n         else\n         {\n@@ -653,7 +643,6 @@ extern (C++) final class Module : Package\n \n             removeHdrFilesAndFail(global.params, Module.amodules);\n         }\n-        return false;\n     }\n \n     /**\n@@ -666,37 +655,23 @@ extern (C++) final class Module : Package\n      *  loc = the location\n      *\n      * Returns: `true` if successful\n-     * See_Also: loadSourceBuffer\n      */\n     bool read(const ref Loc loc)\n     {\n-        if (srcBuffer)\n+        if (this.src)\n             return true; // already read\n \n         //printf(\"Module::read('%s') file '%s'\\n\", toChars(), srcfile.toChars());\n-\n-\n-\n-        bool success;\n-        if (auto readResult = FileManager.fileManager.lookup(srcfile))\n+        if (auto result = FileManager.fileManager.lookup(srcfile))\n         {\n-            srcBuffer = readResult;\n-            success = true;\n-        }\n-        else\n-        {\n-            auto readResult = File.read(srcfile.toChars());\n-            if (loadSourceBuffer(loc, readResult))\n-            {\n-                FileManager.fileManager.add(srcfile, srcBuffer);\n-                success = true;\n-            }\n-        }\n-        if (success && global.params.emitMakeDeps)\n-        {\n-            global.params.makeDeps.push(srcfile.toChars());\n+            this.src = result.data;\n+            if (global.params.emitMakeDeps)\n+                global.params.makeDeps.push(srcfile.toChars());\n+            return true;\n         }\n-        return success;\n+\n+        this.onFileReadError(loc);\n+        return false;\n     }\n \n     /// syntactic parse\n@@ -830,7 +805,7 @@ extern (C++) final class Module : Package\n         //printf(\"Module::parse(srcname = '%s')\\n\", srcname);\n         isPackageFile = (strcmp(srcfile.name(), package_d) == 0 ||\n                          strcmp(srcfile.name(), package_di) == 0);\n-        const(char)[] buf = cast(const(char)[]) srcBuffer.data;\n+        const(char)[] buf = cast(const(char)[]) this.src;\n \n         bool needsReencoding = true;\n         bool hasBOM = true; //assume there's a BOM\n@@ -942,7 +917,7 @@ extern (C++) final class Module : Package\n         if (buf.length>= 4 && buf[0..4] == \"Ddoc\")\n         {\n             comment = buf.ptr + 4;\n-            isDocFile = true;\n+            filetype = FileType.ddoc;\n             if (!docfile)\n                 setDocfile();\n             return this;\n@@ -955,17 +930,15 @@ extern (C++) final class Module : Package\n         if (FileName.equalsExt(arg, dd_ext))\n         {\n             comment = buf.ptr; // the optional Ddoc, if present, is handled above.\n-            isDocFile = true;\n+            filetype = FileType.ddoc;\n             if (!docfile)\n                 setDocfile();\n             return this;\n         }\n         /* If it has the extension \".di\", it is a \"header\" file.\n          */\n         if (FileName.equalsExt(arg, hdr_ext))\n-        {\n-            isHdrFile = true;\n-        }\n+            filetype = FileType.dhdr;\n \n         /// Promote `this` to a root module if requested via `-i`\n         void checkCompiledImport()\n@@ -982,7 +955,7 @@ extern (C++) final class Module : Package\n          */\n         if (FileName.equalsExt(arg, c_ext) || FileName.equalsExt(arg, i_ext))\n         {\n-            isCFile = true;\n+            filetype = FileType.c;\n \n             scope p = new CParser!AST(this, buf, cast(bool) docfile, target.c);\n             p.nextToken();\n@@ -1014,8 +987,7 @@ extern (C++) final class Module : Package\n             members = p.parseModuleContent();\n             numlines = p.scanloc.linnum;\n         }\n-        srcBuffer.destroy();\n-        srcBuffer = null;\n+\n         /* The symbol table into which the module is to be inserted.\n          */\n \n@@ -1141,7 +1113,7 @@ extern (C++) final class Module : Package\n         //printf(\"+Module::importAll(this = %p, '%s'): parent = %p\\n\", this, toChars(), parent);\n         if (_scope)\n             return; // already done\n-        if (isDocFile)\n+        if (filetype == FileType.ddoc)\n         {\n             error(\"is a Ddoc file, cannot import it\");\n             return;"}, {"sha": "d05060df045d4a3ff4769efee364aa76afe335da", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -425,7 +425,7 @@ extern(C++) void gendocfile(Module m)\n         dc.copyright.nooutput = 1;\n         m.macrotable.define(\"COPYRIGHT\", dc.copyright.body_);\n     }\n-    if (m.isDocFile)\n+    if (m.filetype == FileType.ddoc)\n     {\n         const ploc = m.md ? &m.md.loc : &m.loc;\n         const loc = Loc(ploc.filename ? ploc.filename : srcfilename.ptr,\n@@ -4991,7 +4991,7 @@ private void highlightText(Scope* sc, Dsymbols* a, Loc loc, ref OutBuffer buf, s\n \n         default:\n             leadingBlank = false;\n-            if (sc._module.isDocFile || inCode)\n+            if (sc._module.filetype == FileType.ddoc || inCode)\n                 break;\n             const start = cast(char*)buf[].ptr + i;\n             if (isIdStart(start))"}, {"sha": "aa30b5d741410da63836e15dcc258efb478ff2f5", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -174,7 +174,7 @@ struct Scope\n             m = m.parent;\n         m.addMember(null, sc.scopesym);\n         m.parent = null; // got changed by addMember()\n-        if (_module.isCFile)\n+        if (_module.filetype == FileType.c)\n             sc.flags |= SCOPE.Cfile;\n         // Create the module scope underneath the global scope\n         sc = sc.push(_module);"}, {"sha": "9e50bd56d439675c1528870d92004212b0148f73", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -465,10 +465,7 @@ extern (C++) class Dsymbol : ASTNode\n      final bool isCsymbol()\n      {\n         if (Module m = getModule())\n-        {\n-            if (m.isCFile)\n-                return true;\n-        }\n+            return m.filetype == FileType.c;\n         return false;\n     }\n \n@@ -975,7 +972,7 @@ extern (C++) class Dsymbol : ASTNode\n      * Returns:\n      *  SIZE_INVALID when the size cannot be determined\n      */\n-    d_uns64 size(const ref Loc loc)\n+    uinteger_t size(const ref Loc loc)\n     {\n         error(\"Dsymbol `%s` has no size\", toChars());\n         return SIZE_INVALID;"}, {"sha": "aad0f2da2b4ee150479ad61ff956ec6d5fffed08", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -223,7 +223,7 @@ class Dsymbol : public ASTNode\n     virtual void importAll(Scope *sc);\n     virtual Dsymbol *search(const Loc &loc, Identifier *ident, int flags = IgnoreNone);\n     virtual bool overloadInsert(Dsymbol *s);\n-    virtual d_uns64 size(const Loc &loc);\n+    virtual uinteger_t size(const Loc &loc);\n     virtual bool isforwardRef();\n     virtual AggregateDeclaration *isThis();     // is a 'this' required to access the member\n     virtual bool isExport() const;              // is Dsymbol exported?"}, {"sha": "b31dc9d0eb9b2bd9157fe2d42fc96c614d92a567", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 109, "deletions": 25, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -716,7 +716,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (dsym.storage_class & STC.scope_)\n         {\n-            StorageClass stc = dsym.storage_class & (STC.static_ | STC.extern_ | STC.manifest | STC.tls | STC.gshared);\n+            StorageClass stc = dsym.storage_class & (STC.static_ | STC.extern_ | STC.manifest | STC.gshared);\n             if (stc)\n             {\n                 OutBuffer buf;\n@@ -733,7 +733,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n         }\n \n-        if (dsym.storage_class & (STC.static_ | STC.extern_ | STC.manifest | STC.templateparameter | STC.tls | STC.gshared | STC.ctfe))\n+        if (dsym.storage_class & (STC.static_ | STC.extern_ | STC.manifest | STC.templateparameter | STC.gshared | STC.ctfe))\n         {\n         }\n         else\n@@ -794,7 +794,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (dsym.type.hasWild())\n         {\n-            if (dsym.storage_class & (STC.static_ | STC.extern_ | STC.tls | STC.gshared | STC.manifest | STC.field) || dsym.isDataseg())\n+            if (dsym.storage_class & (STC.static_ | STC.extern_ | STC.gshared | STC.manifest | STC.field) || dsym.isDataseg())\n             {\n                 dsym.error(\"only parameters or stack based variables can be `inout`\");\n             }\n@@ -841,7 +841,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         FuncDeclaration fd = parent.isFuncDeclaration();\n         if (dsym.type.isscope() && !(dsym.storage_class & STC.nodtor))\n         {\n-            if (dsym.storage_class & (STC.field | STC.out_ | STC.ref_ | STC.static_ | STC.manifest | STC.tls | STC.gshared) || !fd)\n+            if (dsym.storage_class & (STC.field | STC.out_ | STC.ref_ | STC.static_ | STC.manifest | STC.gshared) || !fd)\n             {\n                 dsym.error(\"globals, statics, fields, manifest constants, ref and out parameters cannot be `scope`\");\n             }\n@@ -871,7 +871,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 }\n             }\n             else if (!dsym._init &&\n-                     !(dsym.storage_class & (STC.static_ | STC.extern_ | STC.tls | STC.gshared | STC.manifest | STC.field | STC.parameter)) &&\n+                     !(dsym.storage_class & (STC.static_ | STC.extern_ | STC.gshared | STC.manifest | STC.field | STC.parameter)) &&\n                      dsym.type.hasVoidInitPointers())\n             {\n                 if (sc.func.setUnsafe())\n@@ -891,7 +891,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             dsym.error(\"manifest constants must have initializers\");\n \n         bool isBlit = false;\n-        d_uns64 sz;\n+        uinteger_t sz;\n         if (sc.flags & SCOPE.Cfile && !dsym._init)\n         {\n             addDefaultCInitializer(dsym);\n@@ -977,7 +977,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             {\n                 // If local variable, use AssignExp to handle all the various\n                 // possibilities.\n-                if (fd && !(dsym.storage_class & (STC.manifest | STC.static_ | STC.tls | STC.gshared | STC.extern_)) && !dsym._init.isVoidInitializer())\n+                if (fd && !(dsym.storage_class & (STC.manifest | STC.static_ | STC.gshared | STC.extern_)) && !dsym._init.isVoidInitializer())\n                 {\n                     //printf(\"fd = '%s', var = '%s'\\n\", fd.toChars(), toChars());\n                     if (!ei)\n@@ -1476,7 +1476,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (scd.decl)\n         {\n             sc = sc.push();\n-            sc.stc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.tls | STC.gshared);\n+            sc.stc &= ~(STC.auto_ | STC.scope_ | STC.static_ | STC.gshared);\n             sc.inunion = scd.isunion ? scd : null;\n             sc.flags = 0;\n             for (size_t i = 0; i < scd.decl.dim; i++)\n@@ -4233,21 +4233,41 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n          */\n         if (scd.isInstantiated() && scd.semanticRun < PASS.semantic)\n         {\n-            /* Add this prefix to the function:\n-             *      static int gate;\n-             *      if (++gate != 1) return;\n-             * Note that this is not thread safe; should not have threads\n-             * during static construction.\n+            /* Add this prefix to the constructor:\n+             * ```\n+             * static int gate;\n+             * if (++gate != 1) return;\n+             * ```\n+             * or, for shared constructor:\n+             * ```\n+             * shared int gate;\n+             * if (core.atomic.atomicOp!\"+=\"(gate, 1) != 1) return;\n+             * ```\n              */\n+            const bool isShared = !!scd.isSharedStaticCtorDeclaration();\n             auto v = new VarDeclaration(Loc.initial, Type.tint32, Id.gate, null);\n-            v.storage_class = STC.temp | (scd.isSharedStaticCtorDeclaration() ? STC.static_ : STC.tls);\n+            v.storage_class = STC.temp | STC.static_ | (isShared ? STC.shared_ : 0);\n \n             auto sa = new Statements();\n             Statement s = new ExpStatement(Loc.initial, v);\n             sa.push(s);\n \n-            Expression e = new IdentifierExp(Loc.initial, v.ident);\n-            e = new AddAssignExp(Loc.initial, e, IntegerExp.literal!1);\n+            Expression e;\n+            if (isShared)\n+            {\n+                e = doAtomicOp(\"+=\", v.ident, IntegerExp.literal!(1));\n+                if (e is null)\n+                {\n+                    scd.error(\"shared static constructor within a template require `core.atomic : atomicOp` to be present\");\n+                    return;\n+                }\n+            }\n+            else\n+            {\n+                e = new AddAssignExp(\n+                    Loc.initial, new IdentifierExp(Loc.initial, v.ident), IntegerExp.literal!1);\n+            }\n+\n             e = new EqualExp(EXP.notEqual, Loc.initial, e, IntegerExp.literal!1);\n             s = new IfStatement(Loc.initial, null, e, new ReturnStatement(Loc.initial, null), null, Loc.initial);\n \n@@ -4309,22 +4329,41 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n          */\n         if (sdd.isInstantiated() && sdd.semanticRun < PASS.semantic)\n         {\n-            /* Add this prefix to the function:\n-             *      static int gate;\n-             *      if (--gate != 0) return;\n-             * Increment gate during constructor execution.\n-             * Note that this is not thread safe; should not have threads\n-             * during static destruction.\n+            /* Add this prefix to the constructor:\n+             * ```\n+             * static int gate;\n+             * if (--gate != 0) return;\n+             * ```\n+             * or, for shared constructor:\n+             * ```\n+             * shared int gate;\n+             * if (core.atomic.atomicOp!\"-=\"(gate, 1) != 0) return;\n+             * ```\n              */\n+            const bool isShared = !!sdd.isSharedStaticDtorDeclaration();\n             auto v = new VarDeclaration(Loc.initial, Type.tint32, Id.gate, null);\n-            v.storage_class = STC.temp | (sdd.isSharedStaticDtorDeclaration() ? STC.static_ : STC.tls);\n+            v.storage_class = STC.temp | STC.static_ | (isShared ? STC.shared_ : 0);\n \n             auto sa = new Statements();\n             Statement s = new ExpStatement(Loc.initial, v);\n             sa.push(s);\n \n-            Expression e = new IdentifierExp(Loc.initial, v.ident);\n-            e = new AddAssignExp(Loc.initial, e, IntegerExp.literal!(-1));\n+            Expression e;\n+            if (isShared)\n+            {\n+                e = doAtomicOp(\"-=\", v.ident, IntegerExp.literal!(1));\n+                if (e is null)\n+                {\n+                    sdd.error(\"shared static destructo within a template require `core.atomic : atomicOp` to be present\");\n+                    return;\n+                }\n+            }\n+            else\n+            {\n+                e = new AddAssignExp(\n+                    Loc.initial, new IdentifierExp(Loc.initial, v.ident), IntegerExp.literal!(-1));\n+            }\n+\n             e = new EqualExp(EXP.notEqual, Loc.initial, e, IntegerExp.literal!0);\n             s = new IfStatement(Loc.initial, null, e, new ReturnStatement(Loc.initial, null), null, Loc.initial);\n \n@@ -6833,3 +6872,48 @@ bool determineFields(AggregateDeclaration ad)\n \n     return true;\n }\n+\n+/// Do an atomic operation (currently tailored to [shared] static ctors|dtors) needs\n+private CallExp doAtomicOp (string op, Identifier var, Expression arg)\n+{\n+    __gshared Import imp = null;\n+    __gshared Identifier[1] id;\n+\n+    assert(op == \"-=\" || op == \"+=\");\n+\n+    const loc = Loc.initial;\n+\n+    // Below code is similar to `loadStdMath` (used for `^^` operator)\n+    if (!imp)\n+    {\n+        id[0] = Id.core;\n+        auto s = new Import(Loc.initial, id[], Id.atomic, null, true);\n+        // Module.load will call fatal() if there's no std.math available.\n+        // Gag the error here, pushing the error handling to the caller.\n+        uint errors = global.startGagging();\n+        s.load(null);\n+        if (s.mod)\n+        {\n+            s.mod.importAll(null);\n+            s.mod.dsymbolSemantic(null);\n+        }\n+        global.endGagging(errors);\n+        imp = s;\n+    }\n+    // Module couldn't be loaded\n+    if (imp.mod is null)\n+        return null;\n+\n+    Objects* tiargs = new Objects(1);\n+    (*tiargs)[0] = new StringExp(loc, op);\n+\n+    Expressions* args = new Expressions(2);\n+    (*args)[0] = new IdentifierExp(loc, var);\n+    (*args)[1] = arg;\n+\n+    auto sc = new ScopeExp(loc, imp.mod);\n+    auto dti = new DotTemplateInstanceExp(\n+        loc, sc, Id.atomicOp, tiargs);\n+\n+    return CallExp.create(loc, dti, args);\n+}"}, {"sha": "366ed60bf33a3eb90d1e87351f31c609f36d5f65", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1943,7 +1943,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                             {\n                                 // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n                             }\n-                            else if (global.params.rvalueRefParam)\n+                            else if (global.params.rvalueRefParam == FeatureState.enabled)\n                             {\n                                 // Allow implicit conversion to ref\n                             }\n@@ -8346,7 +8346,7 @@ struct TemplateStats\n     }\n }\n \n-void printTemplateStats()\n+extern (C++) void printTemplateStats()\n {\n     static struct TemplateDeclarationStats\n     {"}, {"sha": "46982e391c0f1d6949a498145b739bef03694e1b", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -860,7 +860,7 @@ public:\n             origType = vd.originalType;\n         scope(exit) origType = null;\n \n-        if (!vd.alignment.isDefault())\n+        if (!vd.alignment.isDefault() && !vd.alignment.isUnknown())\n         {\n             buf.printf(\"// Ignoring var %s alignment %d\", vd.toChars(), vd.alignment.get());\n             buf.writenl();\n@@ -940,19 +940,14 @@ public:\n             return;\n         }\n \n-        if (vd.storage_class & (AST.STC.static_ | AST.STC.extern_ | AST.STC.tls | AST.STC.gshared) ||\n+        if (vd.storage_class & (AST.STC.static_ | AST.STC.extern_ | AST.STC.gshared) ||\n         vd.parent && vd.parent.isModule())\n         {\n             if (vd.linkage != LINK.c && vd.linkage != LINK.cpp && !(tdparent && (this.linkage == LINK.c || this.linkage == LINK.cpp)))\n             {\n                 ignored(\"variable %s because of linkage\", vd.toPrettyChars());\n                 return;\n             }\n-            if (vd.storage_class & AST.STC.tls)\n-            {\n-                ignored(\"variable %s because of thread-local storage\", vd.toPrettyChars());\n-                return;\n-            }\n             if (!isSupportedType(type))\n             {\n                 ignored(\"variable %s because its type cannot be mapped to C++\", vd.toPrettyChars());\n@@ -1934,6 +1929,8 @@ public:\n                 buf.writestring(\"unsigned long long\");\n             else if (ed.ident == DMDType.c_long_double)\n                 buf.writestring(\"long double\");\n+            else if (ed.ident == DMDType.c_char)\n+                buf.writestring(\"char\");\n             else if (ed.ident == DMDType.c_wchar_t)\n                 buf.writestring(\"wchar_t\");\n             else if (ed.ident == DMDType.c_complex_float)\n@@ -2681,6 +2678,18 @@ public:\n     {\n         if (vd._init && !vd._init.isVoidInitializer())\n             return AST.initializerToExpression(vd._init);\n+        else if (auto ts = vd.type.isTypeStruct())\n+        {\n+            if (!ts.sym.noDefaultCtor && !ts.sym.isUnionDeclaration())\n+            {\n+                // Generate a call to the default constructor that we've generated.\n+                auto sle = new AST.StructLiteralExp(Loc.initial, ts.sym, new AST.Expressions(0));\n+                sle.type = vd.type;\n+                return sle;\n+            }\n+            else\n+                return vd.type.defaultInitLiteral(Loc.initial);\n+        }\n         else\n             return vd.type.defaultInitLiteral(Loc.initial);\n     }\n@@ -2971,6 +2980,7 @@ struct DMDType\n     __gshared Identifier c_longlong;\n     __gshared Identifier c_ulonglong;\n     __gshared Identifier c_long_double;\n+    __gshared Identifier c_char;\n     __gshared Identifier c_wchar_t;\n     __gshared Identifier c_complex_float;\n     __gshared Identifier c_complex_double;\n@@ -2984,6 +2994,7 @@ struct DMDType\n         c_ulonglong     = Identifier.idPool(\"__c_ulonglong\");\n         c_long_double   = Identifier.idPool(\"__c_long_double\");\n         c_wchar_t       = Identifier.idPool(\"__c_wchar_t\");\n+        c_char          = Identifier.idPool(\"__c_char\");\n         c_complex_float  = Identifier.idPool(\"__c_complex_float\");\n         c_complex_double = Identifier.idPool(\"__c_complex_double\");\n         c_complex_real = Identifier.idPool(\"__c_complex_real\");"}, {"sha": "e9dcdc0532c1c0d8c3b4957f1bed5ffd6c757399", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 84, "deletions": 36, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -658,7 +658,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n             p == fd)\n         {\n             if (log) printf(\"inferring 'return' for parameter %s in function %s\\n\", v.toChars(), fd.toChars());\n-            inferReturn(fd, v);        // infer addition of 'return' to make `return scope`\n+            inferReturn(fd, v, /*returnScope:*/ true); // infer addition of 'return' to make `return scope`\n         }\n \n         if (!(va && va.isScope()) || vaIsRef)\n@@ -1215,7 +1215,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n             sc.func.flags & FUNCFLAG.returnInprocess &&\n             p == sc.func)\n         {\n-            inferReturn(sc.func, v);        // infer addition of 'return'\n+            inferReturn(sc.func, v, /*returnScope:*/ true); // infer addition of 'return'\n             continue;\n         }\n \n@@ -1355,7 +1355,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n             if (sc.func.flags & FUNCFLAG.returnInprocess && p == sc.func &&\n                 (vsr == ScopeRef.Ref || vsr == ScopeRef.RefScope))\n             {\n-                inferReturn(sc.func, v);        // infer addition of 'return'\n+                inferReturn(sc.func, v, /*returnScope:*/ false); // infer addition of 'return'\n             }\n             else\n             {\n@@ -1404,23 +1404,25 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n  * Params:\n  *      fd = function that v is a parameter to\n  *      v = parameter that needs to be STC.return_\n+ *      returnScope = infer `return scope` instead of `return ref`\n  */\n-\n-private void inferReturn(FuncDeclaration fd, VarDeclaration v)\n+private void inferReturn(FuncDeclaration fd, VarDeclaration v, bool returnScope)\n {\n     // v is a local in the current function\n \n-    //printf(\"for function '%s' inferring 'return' for variable '%s'\\n\", fd.toChars(), v.toChars());\n-    v.storage_class |= STC.return_ | STC.returninferred;\n+    //printf(\"for function '%s' inferring 'return' for variable '%s', returnScope: %d\\n\", fd.toChars(), v.toChars(), returnScope);\n+    auto newStcs = STC.return_ | STC.returninferred | (returnScope ? STC.returnScope : 0);\n+    v.storage_class |= newStcs;\n \n     if (v == fd.vthis)\n     {\n         /* v is the 'this' reference, so mark the function\n          */\n-        fd.storage_class |= STC.return_ | STC.returninferred;\n+        fd.storage_class |= newStcs;\n         if (auto tf = fd.type.isTypeFunction())\n         {\n             //printf(\"'this' too %p %s\\n\", tf, sc.func.toChars());\n+            tf.isreturnscope = returnScope;\n             tf.isreturn = true;\n             tf.isreturninferred = true;\n         }\n@@ -1434,7 +1436,7 @@ private void inferReturn(FuncDeclaration fd, VarDeclaration v)\n             {\n                 if (p.ident == v.ident)\n                 {\n-                    p.storageClass |= STC.return_ | STC.returninferred;\n+                    p.storageClass |= newStcs;\n                     break;              // there can be only one\n                 }\n             }\n@@ -1732,33 +1734,69 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n             {\n                 DotVarExp dve = e.e1.isDotVarExp();\n                 FuncDeclaration fd = dve.var.isFuncDeclaration();\n-                AggregateDeclaration ad;\n-                if (global.params.useDIP1000 == FeatureState.enabled && tf.isreturn && fd && (ad = fd.isThis()) !is null)\n+                if (global.params.useDIP1000 == FeatureState.enabled)\n                 {\n-                    if (ad.isClassDeclaration() || tf.isScopeQual)       // this is 'return scope'\n-                        dve.e1.accept(this);\n-                    else if (ad.isStructDeclaration()) // this is 'return ref'\n-                    {\n-                        if (tf.isref)\n+                   if (fd && fd.isThis())\n+                   {\n+                        /* Calling a non-static member function dve.var, which is returning `this`, and with dve.e1 representing `this`\n+                         */\n+\n+                        /*****************************\n+                         * Concoct storage class for member function's implicit `this` parameter.\n+                         * Params:\n+                         *      fd = member function\n+                         * Returns:\n+                         *      storage class for fd's `this`\n+                         */\n+                        StorageClass getThisStorageClass(FuncDeclaration fd)\n                         {\n-                            /* Treat calling:\n-                             *   struct S { ref S foo() return; }\n-                             * as:\n-                             *   this;\n-                             */\n+                            StorageClass stc;\n+                            auto tf = fd.type.toBasetype().isTypeFunction();\n+                            if (tf.isreturn)\n+                                stc |= STC.return_;\n+                            if (tf.isreturnscope)\n+                                stc |= STC.returnScope;\n+                            auto ad = fd.isThis();\n+                            if (ad.isClassDeclaration() || tf.isScopeQual)\n+                                stc |= STC.scope_;\n+                            if (ad.isStructDeclaration())\n+                                stc |= STC.ref_;        // `this` for a struct member function is passed by `ref`\n+                            return stc;\n+                        }\n+\n+                        const psr = buildScopeRef(getThisStorageClass(fd));\n+                        if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n                             dve.e1.accept(this);\n+                        else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n+                        {\n+                            if (tf.isref)\n+                            {\n+                                /* Treat calling:\n+                                 *   struct S { ref S foo() return; }\n+                                 * as:\n+                                 *   this;\n+                                 */\n+                                dve.e1.accept(this);\n+                            }\n+                            else\n+                                escapeByRef(dve.e1, er, live);\n                         }\n-                        else\n-                            escapeByRef(dve.e1, er, live);\n                     }\n                 }\n-                else if (dve.var.storage_class & STC.return_ || tf.isreturn)\n+                else\n                 {\n-                    if (dve.var.storage_class & STC.scope_)\n+                    // Calling member function before dip1000\n+                    StorageClass stc = dve.var.storage_class & (STC.return_ | STC.scope_ | STC.ref_);\n+                    if (tf.isreturn)\n+                        stc |= STC.return_;\n+\n+                    const psr = buildScopeRef(stc);\n+                    if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n                         dve.e1.accept(this);\n-                    else if (dve.var.storage_class & STC.ref_)\n+                    else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n                         escapeByRef(dve.e1, er, live);\n                 }\n+\n                 // If it's also a nested function that is 'return scope'\n                 if (fd && fd.isNested())\n                 {\n@@ -1996,19 +2034,29 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                         return;\n                     }\n \n-                    if (dve.var.storage_class & STC.return_ || tf.isreturn)\n-                    {\n-                        if (dve.var.storage_class & STC.ref_ || tf.isref)\n-                            dve.e1.accept(this);\n-                        else if (dve.var.storage_class & STC.scope_ || tf.isScopeQual)\n-                            escapeByValue(dve.e1, er, live);\n-                    }\n+                    StorageClass stc = dve.var.storage_class & (STC.return_ | STC.scope_ | STC.ref_);\n+                    if (tf.isreturn)\n+                        stc |= STC.return_;\n+                    if (tf.isref)\n+                        stc |= STC.ref_;\n+                    if (tf.isScopeQual)\n+                        stc |= STC.scope_;\n+                    if (tf.isreturnscope)\n+                        stc |= STC.returnScope;\n+\n+                    const psr = buildScopeRef(stc);\n+                    if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n+                         dve.e1.accept(this);\n+                    else if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n+                         escapeByValue(dve.e1, er, live);\n+\n                     // If it's also a nested function that is 'return ref'\n-                    FuncDeclaration fd = dve.var.isFuncDeclaration();\n-                    if (fd && fd.isNested())\n+                    if (FuncDeclaration fd = dve.var.isFuncDeclaration())\n                     {\n-                        if (tf.isreturn)\n+                        if (fd.isNested() && tf.isreturn)\n+                        {\n                             er.byexp.push(e);\n+                        }\n                     }\n                 }\n                 // If it's a delegate, check it too"}, {"sha": "7abfe7f0878735a1c7265561355abbb0254097f7", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1797,7 +1797,7 @@ extern (C++) final class IntegerExp : Expression\n     {\n         super(Loc.initial, EXP.int64, __traits(classInstanceSize, IntegerExp));\n         this.type = Type.tint32;\n-        this.value = cast(d_int32)value;\n+        this.value = cast(int)value;\n     }\n \n     static IntegerExp create(const ref Loc loc, dinteger_t value, Type type)\n@@ -1838,8 +1838,8 @@ extern (C++) final class IntegerExp : Expression\n         const val = normalize(ty, value);\n         value = val;\n         return (ty == Tuns64)\n-            ? real_t(cast(d_uns64)val)\n-            : real_t(cast(d_int64)val);\n+            ? real_t(cast(ulong)val)\n+            : real_t(cast(long)val);\n     }\n \n     override real_t toImaginary()\n@@ -1895,38 +1895,38 @@ extern (C++) final class IntegerExp : Expression\n             break;\n \n         case Tint8:\n-            result = cast(d_int8)value;\n+            result = cast(byte)value;\n             break;\n \n         case Tchar:\n         case Tuns8:\n-            result = cast(d_uns8)value;\n+            result = cast(ubyte)value;\n             break;\n \n         case Tint16:\n-            result = cast(d_int16)value;\n+            result = cast(short)value;\n             break;\n \n         case Twchar:\n         case Tuns16:\n-            result = cast(d_uns16)value;\n+            result = cast(ushort)value;\n             break;\n \n         case Tint32:\n-            result = cast(d_int32)value;\n+            result = cast(int)value;\n             break;\n \n         case Tdchar:\n         case Tuns32:\n-            result = cast(d_uns32)value;\n+            result = cast(uint)value;\n             break;\n \n         case Tint64:\n-            result = cast(d_int64)value;\n+            result = cast(long)value;\n             break;\n \n         case Tuns64:\n-            result = cast(d_uns64)value;\n+            result = cast(ulong)value;\n             break;\n \n         case Tpointer:"}, {"sha": "580281643ca92d45147e0b05c2766966fafbbfe3", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1992,7 +1992,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n             }\n             else if (p.storageClass & STC.ref_)\n             {\n-                if (global.params.rvalueRefParam &&\n+                if (global.params.rvalueRefParam == FeatureState.enabled &&\n                     !arg.isLvalue() &&\n                     targ.isCopyable())\n                 {   /* allow rvalues to be passed to ref parameters by copying\n@@ -7118,6 +7118,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n+        exp.e1 = exp.e1.arrayFuncConv(sc);\n+\n         Type tb = exp.e1.type.toBasetype();\n         switch (tb.ty)\n         {\n@@ -7441,6 +7443,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n+        if (exp.to && !exp.to.isTypeSArray() && !exp.to.isTypeFunction())\n+            exp.e1 = exp.e1.arrayFuncConv(sc);\n+\n         // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n         if (exp.e1.op == EXP.type)\n             exp.e1 = resolveAliasThis(sc, exp.e1);\n@@ -10336,7 +10341,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n                 // Need to divide the result by the stride\n                 // Replace (ptr - ptr) with (ptr - ptr) / stride\n-                d_int64 stride;\n+                long stride;\n \n                 // make sure pointer types are compatible\n                 if (Expression ex = typeCombine(exp, sc))\n@@ -10351,7 +10356,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 {\n                     e = new IntegerExp(exp.loc, 0, Type.tptrdiff_t);\n                 }\n-                else if (stride == cast(d_int64)SIZE_INVALID)\n+                else if (stride == cast(long)SIZE_INVALID)\n                     e = ErrorExp.get();\n                 else\n                 {\n@@ -12575,6 +12580,13 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n         Expression e = new IntegerExp(exp.loc, actualAlignment, Type.tsize_t);\n         return e;\n     }\n+    else if (sc.flags & SCOPE.Cfile && exp.ident == Id.__sizeof && exp.e1.isStringExp())\n+    {\n+        // Sizeof string literal includes the terminating 0\n+        auto se = exp.e1.isStringExp();\n+        Expression e = new IntegerExp(exp.loc, (se.len + 1) * se.sz, Type.tsize_t);\n+        return e;\n+    }\n     else\n     {\n         if (exp.e1.isTypeExp() || exp.e1.isTemplateExp())"}, {"sha": "9ba38078c3f1d42887aa5b085095139ca3305a39", "filename": "gcc/d/dmd/file_manager.d", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -20,38 +20,12 @@ import dmd.identifier;\n enum package_d  = \"package.\" ~ mars_ext;\n enum package_di = \"package.\" ~ hdr_ext;\n \n-extern(C++) struct FileManager\n+struct FileManager\n {\n     private StringTable!(FileBuffer*) files;\n     private __gshared bool initialized = false;\n \n nothrow:\n-    extern(D) private FileBuffer* readToFileBuffer(const(char)[] filename)\n-    {\n-        if (!initialized)\n-            FileManager._init();\n-\n-        auto readResult = File.read(filename);\n-        if (readResult.success)\n-        {\n-            FileBuffer* fb;\n-            if (auto val = files.lookup(filename))\n-                fb = val.value;\n-\n-            if (!fb)\n-                fb = FileBuffer.create();\n-\n-            fb.data = readResult.extractSlice();\n-\n-            return files.insert(filename, fb) == null ? null : fb;\n-        }\n-        else\n-        {\n-            return null;\n-        }\n-\n-    }\n-\n     /********************************************\n     * Look for the source file if it's different from filename.\n     * Look for .di, .d, directory, and along global.path.\n@@ -63,7 +37,7 @@ nothrow:\n     *      the found file name or\n     *      `null` if it is not different from filename.\n     */\n-    extern(D) static const(char)[] lookForSourceFile(const char[] filename, const char*[] path)\n+    static const(char)[] lookForSourceFile(const char[] filename, const char*[] path)\n     {\n         //printf(\"lookForSourceFile(`%.*s`)\\n\", cast(int)filename.length, filename.ptr);\n         /* Search along path[] for .di file, then .d file, then .i file, then .c file.\n@@ -74,6 +48,9 @@ nothrow:\n         scope(exit) FileName.free(sdi.ptr);\n \n         const sd = FileName.forceExt(filename, mars_ext);\n+        // Special file name representing `stdin`, always assume its presence\n+        if (sd == \"__stdin.d\")\n+            return sd;\n         if (FileName.exists(sd) == 1)\n             return sd;\n         scope(exit) FileName.free(sd.ptr);\n@@ -164,33 +141,35 @@ nothrow:\n      * Returns: the loaded source file if it was found in memory,\n      *      otherwise `null`\n      */\n-    extern(D) FileBuffer* lookup(FileName filename)\n+    const(FileBuffer)* lookup(FileName filename)\n     {\n         if (!initialized)\n             FileManager._init();\n \n-        if (auto val = files.lookup(filename.toString))\n+        const name = filename.toString;\n+        if (auto val = files.lookup(name))\n+            return val.value;\n+\n+        if (name == \"__stdin.d\")\n         {\n-            // There is a chance that the buffer could've been\n-            // stolen by a reader with extractSlice, so we should\n-            // try and do our reading logic if that happens.\n-            if (val !is null && val.value.data !is null)\n-            {\n-                return val.value;\n-            }\n+            auto buffer = new FileBuffer(readFromStdin().extractSlice());\n+            if (this.files.insert(name, buffer) is null)\n+                assert(0, \"stdin: Insert after lookup failure should never return `null`\");\n+            return buffer;\n         }\n \n-        const name = filename.toString;\n-        auto res = FileName.exists(name);\n-        if (res == 1)\n-            return readToFileBuffer(name);\n+        if (FileName.exists(name) != 1)\n+            return null;\n \n-        return null;\n-    }\n+        auto readResult = File.read(name);\n+        if (!readResult.success)\n+            return null;\n \n-    extern(C++) FileBuffer* lookup(const(char)* filename)\n-    {\n-        return lookup(FileName(filename.toDString));\n+        FileBuffer* fb = new FileBuffer(readResult.extractSlice());\n+        if (files.insert(name, fb) is null)\n+            assert(0, \"Insert after lookup failure should never return `null`\");\n+\n+        return fb;\n     }\n \n     /**\n@@ -201,15 +180,15 @@ nothrow:\n      * Returns: the loaded source file if it was found in memory,\n      *      otherwise `null`\n      */\n-    extern(D) const(char)[][] getLines(FileName file)\n+    const(char)[][] getLines(FileName file)\n     {\n         if (!initialized)\n             FileManager._init();\n \n         const(char)[][] lines;\n-        if (FileBuffer* buffer = lookup(file))\n+        if (const buffer = lookup(file))\n         {\n-            ubyte[] slice = buffer.data[0 .. buffer.data.length];\n+            const slice = buffer.data[0 .. buffer.data.length];\n             size_t start, end;\n             ubyte c;\n             for (auto i = 0; i < slice.length; i++)\n@@ -260,7 +239,7 @@ nothrow:\n      *\n      * Returns: The FileBuffer added, or null\n      */\n-    extern(D) FileBuffer* add(FileName filename, FileBuffer* filebuffer)\n+    FileBuffer* add(FileName filename, FileBuffer* filebuffer)\n     {\n         if (!initialized)\n             FileManager._init();\n@@ -269,19 +248,10 @@ nothrow:\n         return val == null ? null : val.value;\n     }\n \n-    extern(C++) FileBuffer* add(const(char)* filename, FileBuffer* filebuffer)\n-    {\n-        if (!initialized)\n-            FileManager._init();\n-\n-        auto val = files.insert(filename.toDString, filebuffer);\n-        return val == null ? null : val.value;\n-    }\n-\n     __gshared fileManager = FileManager();\n \n     // Initialize the global FileManager singleton\n-    extern(C++) static __gshared void _init()\n+    private void _init()\n     {\n         if (!initialized)\n         {\n@@ -295,3 +265,46 @@ nothrow:\n         files._init();\n     }\n }\n+\n+private FileBuffer readFromStdin() nothrow\n+{\n+    import core.stdc.stdio;\n+    import dmd.errors;\n+    import dmd.root.rmem;\n+\n+    enum bufIncrement = 128 * 1024;\n+    size_t pos = 0;\n+    size_t sz = bufIncrement;\n+\n+    ubyte* buffer = null;\n+    for (;;)\n+    {\n+        buffer = cast(ubyte*)mem.xrealloc(buffer, sz + 4); // +2 for sentinel and +2 for lexer\n+\n+        // Fill up buffer\n+        do\n+        {\n+            assert(sz > pos);\n+            size_t rlen = fread(buffer + pos, 1, sz - pos, stdin);\n+            pos += rlen;\n+            if (ferror(stdin))\n+            {\n+                import core.stdc.errno;\n+                error(Loc.initial, \"cannot read from stdin, errno = %d\", errno);\n+                fatal();\n+            }\n+            if (feof(stdin))\n+            {\n+                // We're done\n+                assert(pos < sz + 2);\n+                buffer[pos .. pos + 4] = '\\0';\n+                return FileBuffer(buffer[0 .. pos]);\n+            }\n+        } while (pos < sz);\n+\n+        // Buffer full, expand\n+        sz += bufIncrement;\n+    }\n+\n+    assert(0);\n+}"}, {"sha": "6705f24301f3be0150753cff57369433dee7e234", "filename": "gcc/d/dmd/file_manager.h", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a/gcc%2Fd%2Fdmd%2Ffile_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a/gcc%2Fd%2Fdmd%2Ffile_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.h?ref=4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a", "patch": "@@ -1,19 +0,0 @@\n-\n-/* Copyright (C) 1999-2022 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * https://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * https://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/dmd/file_manager.h\n- */\n-\n-#pragma once\n-\n-#include \"root/file.h\"\n-\n-struct FileManager\n-{\n-    static void _init();\n-    FileBuffer* lookup(const char* filename);\n-    FileBuffer* add(const char* filename, FileBuffer* filebuffer);\n-};"}, {"sha": "6697a05a14248d953526ae6b8b29080e6df2fdef", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -161,11 +161,11 @@ extern (C++) struct Param\n     FeatureState dtorFields; // destruct fields of partially constructed objects\n                             // https://issues.dlang.org/show_bug.cgi?id=14246\n     bool fieldwise;         // do struct equality testing field-wise rather than by memcmp()\n-    bool rvalueRefParam;    // allow rvalues to be arguments to ref parameters\n-                            // https://dconf.org/2019/talks/alexandrescu.html\n-                            // https://gist.github.com/andralex/e5405a5d773f07f73196c05f8339435a\n-                            // https://digitalmars.com/d/archives/digitalmars/D/Binding_rvalues_to_ref_parameters_redux_325087.html\n-                            // Implementation: https://github.com/dlang/dmd/pull/9817\n+    FeatureState rvalueRefParam; // allow rvalues to be arguments to ref parameters\n+                                 // https://dconf.org/2019/talks/alexandrescu.html\n+                                 // https://gist.github.com/andralex/e5405a5d773f07f73196c05f8339435a\n+                                 // https://digitalmars.com/d/archives/digitalmars/D/Binding_rvalues_to_ref_parameters_redux_325087.html\n+                                 // Implementation: https://github.com/dlang/dmd/pull/9817\n \n     CppStdRevision cplusplus = CppStdRevision.cpp11;    // version of C++ standard to support\n \n@@ -486,15 +486,6 @@ alias dinteger_t = ulong;\n alias sinteger_t = long;\n alias uinteger_t = ulong;\n \n-alias d_int8 = int8_t;\n-alias d_uns8 = uint8_t;\n-alias d_int16 = int16_t;\n-alias d_uns16 = uint16_t;\n-alias d_int32 = int32_t;\n-alias d_uns32 = uint32_t;\n-alias d_int64 = int64_t;\n-alias d_uns64 = uint64_t;\n-\n version (DMDLIB)\n {\n     version = LocOffset;"}, {"sha": "9bbe0c9fe03847fee4118fcb66bb1d0a6eb46e89", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -145,7 +145,7 @@ struct Param\n     FeatureState dtorFields;  // destruct fields of partially constructed objects\n                               // https://issues.dlang.org/show_bug.cgi?id=14246\n     bool fieldwise;         // do struct equality testing field-wise rather than by memcmp()\n-    bool rvalueRefParam;    // allow rvalues to be arguments to ref parameters\n+    FeatureState rvalueRefParam;    // allow rvalues to be arguments to ref parameters\n     CppStdRevision cplusplus;  // version of C++ name mangling to support\n     bool markdown;          // enable Markdown replacements in Ddoc\n     bool vmarkdown;         // list instances of Markdown replacements in Ddoc\n@@ -346,15 +346,6 @@ typedef long long sinteger_t;\n typedef unsigned long long uinteger_t;\n #endif\n \n-typedef int8_t                  d_int8;\n-typedef uint8_t                 d_uns8;\n-typedef int16_t                 d_int16;\n-typedef uint16_t                d_uns16;\n-typedef int32_t                 d_int32;\n-typedef uint32_t                d_uns32;\n-typedef int64_t                 d_int64;\n-typedef uint64_t                d_uns64;\n-\n // file location\n struct Loc\n {\n@@ -415,4 +406,12 @@ enum class PINLINE : uint8_t\n     always        // always inline\n };\n \n+enum class FileType : uint8_t\n+{\n+    d,    /// normal D source file\n+    dhdr, /// D header file (.di)\n+    ddoc, /// Ddoc documentation file (.dd)\n+    c,    /// C source file\n+};\n+\n typedef uinteger_t StorageClass;"}, {"sha": "f2552d4d1cf4b01d6d4be62744bcdf23f576a41a", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -2843,7 +2843,6 @@ string stcToString(ref StorageClass stc)\n         SCstring(STC.pure_, Token.toString(TOK.pure_)),\n         SCstring(STC.ref_, Token.toString(TOK.ref_)),\n         SCstring(STC.return_, Token.toString(TOK.return_)),\n-        SCstring(STC.tls, \"__thread\"),\n         SCstring(STC.gshared, Token.toString(TOK.gshared)),\n         SCstring(STC.nogc, \"@nogc\"),\n         SCstring(STC.live, \"@live\"),"}, {"sha": "2ec75ab25167a95277249d3e7131fd2141d92525", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -123,6 +123,7 @@ immutable Msgtable[] msgtable =\n     { \"__c_longlong\" },\n     { \"__c_ulonglong\" },\n     { \"__c_long_double\" },\n+    { \"__c_char\" },\n     { \"__c_wchar_t\" },\n     { \"__c_complex_float\" },\n     { \"__c_complex_double\" },\n@@ -359,6 +360,8 @@ immutable Msgtable[] msgtable =\n     { \"core\" },\n     { \"etc\" },\n     { \"attribute\" },\n+    { \"atomic\" },\n+    { \"atomicOp\" },\n     { \"math\" },\n     { \"sin\" },\n     { \"cos\" },"}, {"sha": "ec44ee0df5c473aa61d33141840cee260d8c86b8", "filename": "gcc/d/dmd/importc.d", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fimportc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fimportc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimportc.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -274,6 +274,7 @@ Expression castCallAmbiguity(Expression e, Scope* sc)\n \n bool cFuncEquivalence(TypeFunction tf1, TypeFunction tf2)\n {\n+    //printf(\"cFuncEquivalence()\\n  %s\\n  %s\\n\", tf1.toChars(), tf2.toChars());\n     if (tf1.equals(tf2))\n         return true;\n \n@@ -284,22 +285,31 @@ bool cFuncEquivalence(TypeFunction tf1, TypeFunction tf2)\n     if (tf1.parameterList.length == 0 && tf2.parameterList.length == 0)\n         return true;\n \n-    if (!tf1.parameterList.hasIdentifierList &&\n-        !tf2.parameterList.hasIdentifierList)\n-        return false;   // both functions are prototyped\n-\n-    // Otherwise ignore variadicness, as K+R functions are all variadic\n-\n     if (!tf1.nextOf().equals(tf2.nextOf()))\n         return false;   // function return types don't match\n \n     if (tf1.parameterList.length != tf2.parameterList.length)\n         return false;\n \n+    if (!tf1.parameterList.hasIdentifierList && !tf2.parameterList.hasIdentifierList) // if both are prototyped\n+    {\n+        if (tf1.parameterList.varargs != tf2.parameterList.varargs)\n+            return false;\n+    }\n+\n     foreach (i, fparam ; tf1.parameterList)\n     {\n         Type t1 = fparam.type;\n         Type t2 = tf2.parameterList[i].type;\n+\n+        /* Strip off head const.\n+         * Not sure if this is C11, but other compilers treat\n+         * `void fn(int)` and `fn(const int x)`\n+         * as equivalent.\n+         */\n+        t1 = t1.mutableOf();\n+        t2 = t2.mutableOf();\n+\n         if (!t1.equals(t2))\n             return false;\n     }"}, {"sha": "3ff2eae2651805cd1d8ae417474010d2c7df7eff", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -371,6 +371,12 @@ class Lexer\n                                 'd';\n                     return;\n                 }\n+                else if (p[1] == '8' && p[2] == '\\\"') // C UTF-8 string literal\n+                {\n+                    p += 2;\n+                    escapeStringConstant(t);\n+                    return;\n+                }\n                 goto case_ident;\n \n             case 'r':\n@@ -1979,8 +1985,8 @@ class Lexer\n                 if (base <= 10 && n > 0 && (isalpha(p[1]) || p[1] == '_' || p[1] & 0x80))\n                 {\n                     if (Ccompile && base == 10 &&\n-                        (p[1] == 'f' || p[1] == 'F' || p[1] == 'l' || p[1] == 'L'))\n-                        goto Lreal;  // if `1.f` or `1.L`\n+                        (p[1] == 'e' || p[1] == 'E' || p[1] == 'f' || p[1] == 'F' || p[1] == 'l' || p[1] == 'L'))\n+                        goto Lreal;  // if `1.e6` or `1.f` or `1.L`\n                     goto Ldone; // if \".identifier\" or \".unicode\"\n                 }\n                 if (base == 16 && (!ishex(p[1]) || p[1] == '_' || p[1] & 0x80))\n@@ -2495,8 +2501,10 @@ class Lexer\n             }\n         }\n         const isLong = (result == TOK.float80Literal || result == TOK.imaginary80Literal);\n-        if (isOutOfRange && !isLong)\n+        if (isOutOfRange && !isLong && (!Ccompile || hex))\n         {\n+            /* C11 6.4.4.2 doesn't actually care if it is not representable if it is not hex\n+             */\n             const char* suffix = (result == TOK.float32Literal || result == TOK.imaginary32Literal) ? \"f\" : \"\";\n             error(scanloc, \"number `%s%s` is not representable\", sbufptr, suffix);\n         }"}, {"sha": "048b3a0452c45dd98508d1283d24fe9e6678c78c", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -71,12 +71,10 @@ class Module : public Package\n     FileName objfile;   // output .obj file\n     FileName hdrfile;   // 'header' file\n     FileName docfile;   // output documentation file\n-    FileBuffer *srcBuffer; // set during load(), free'd in parse()\n+    DArray<unsigned char> src; // Raw content of the file\n     unsigned errors;    // if any errors in file\n     unsigned numlines;  // number of lines in source file\n-    bool isHdrFile;     // if it is a header (.di) file\n-    bool isCFile;       // if it is a C (.c) file\n-    bool isDocFile;     // if it is a documentation input file, not D source\n+    FileType filetype;  // source file type\n     bool hasAlwaysInlines; // contains references to functions that must be inlined\n     bool isPackageFile; // if it is a package.d\n     Package *pkg;       // if isPackageFile is true, the Package that contains this package.d"}, {"sha": "1494044da596aebb2bca71693ea9fd9201e7ff96", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -55,7 +55,7 @@ import dmd.visitor;\n enum LOGDOTEXP = 0;         // log ::dotExp()\n enum LOGDEFAULTINIT = 0;    // log ::defaultInit()\n \n-enum SIZE_INVALID = (~cast(d_uns64)0);   // error return from size() functions\n+enum SIZE_INVALID = (~cast(uinteger_t)0);   // error return from size() functions\n \n \n /***************************\n@@ -887,12 +887,12 @@ extern (C++) abstract class Type : ASTNode\n         stringtable = stringtable.init;\n     }\n \n-    final d_uns64 size()\n+    final uinteger_t size()\n     {\n         return size(Loc.initial);\n     }\n \n-    d_uns64 size(const ref Loc loc)\n+    uinteger_t size(const ref Loc loc)\n     {\n         error(loc, \"no size for type `%s`\", toChars());\n         return SIZE_INVALID;\n@@ -2770,7 +2770,7 @@ extern (C++) final class TypeError : Type\n         return this;\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return SIZE_INVALID;\n     }\n@@ -3237,7 +3237,7 @@ extern (C++) final class TypeBasic : Type\n         return this;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         uint size;\n         //printf(\"TypeBasic::size()\\n\");\n@@ -3411,8 +3411,8 @@ extern (C++) final class TypeBasic : Type\n             // If converting from integral to integral\n             if (tob.flags & TFlags.integral)\n             {\n-                d_uns64 sz = size(Loc.initial);\n-                d_uns64 tosz = tob.size(Loc.initial);\n+                const sz = size(Loc.initial);\n+                const tosz = tob.size(Loc.initial);\n \n                 /* Can't convert to smaller size\n                  */\n@@ -3512,7 +3512,7 @@ extern (C++) final class TypeVector : Type\n         return new TypeVector(basetype.syntaxCopy());\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return basetype.size();\n     }\n@@ -3661,7 +3661,7 @@ extern (C++) final class TypeSArray : TypeArray\n         return dim.isIntegerExp() && dim.isIntegerExp().getInteger() == 0;\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         //printf(\"TypeSArray::size()\\n\");\n         const n = numberOfElems(loc);\n@@ -3860,7 +3860,7 @@ extern (C++) final class TypeDArray : TypeArray\n         return result;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         //printf(\"TypeDArray::size()\\n\");\n         return target.ptrsize * 2;\n@@ -3964,7 +3964,7 @@ extern (C++) final class TypeAArray : TypeArray\n         return result;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return target.ptrsize;\n     }\n@@ -4056,7 +4056,7 @@ extern (C++) final class TypePointer : TypeNext\n         return result;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return target.ptrsize;\n     }\n@@ -4159,7 +4159,7 @@ extern (C++) final class TypeReference : TypeNext\n         return result;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return target.ptrsize;\n     }\n@@ -4596,8 +4596,10 @@ extern (C++) final class TypeFunction : TypeNext\n         if (global.gag && !global.params.showGaggedErrors)\n             return null;\n         // show qualification when toChars() is the same but types are different\n-        auto at = arg.type.toChars();\n-        bool qual = !arg.type.equals(par.type) && strcmp(at, par.type.toChars()) == 0;\n+        // https://issues.dlang.org/show_bug.cgi?id=19948\n+        // when comparing the type with strcmp, we need to drop the qualifier\n+        auto at = arg.type.mutableOf().toChars();\n+        bool qual = !arg.type.equals(par.type) && strcmp(at, par.type.mutableOf().toChars()) == 0;\n         if (qual)\n             at = arg.type.toPrettyChars(true);\n         OutBuffer buf;\n@@ -4845,7 +4847,7 @@ extern (C++) final class TypeFunction : TypeNext\n                             // Need to make this a rvalue through a temporary\n                             m = MATCH.convert;\n                         }\n-                        else if (!global.params.rvalueRefParam ||\n+                        else if (global.params.rvalueRefParam != FeatureState.enabled ||\n                                  p.storageClass & STC.out_ ||\n                                  !arg.type.isCopyable())  // can't copy to temp for ref parameter\n                         {\n@@ -5328,7 +5330,7 @@ extern (C++) final class TypeDelegate : TypeNext\n         return t;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return target.ptrsize * 2;\n     }\n@@ -5435,7 +5437,7 @@ extern (C++) final class TypeTraits : Type\n         v.visit(this);\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return SIZE_INVALID;\n     }\n@@ -5562,7 +5564,7 @@ extern (C++) abstract class TypeQualified : Type\n         idents.push(e);\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         error(this.loc, \"size of type `%s` is not known\", toChars());\n         return SIZE_INVALID;\n@@ -5717,7 +5719,7 @@ extern (C++) final class TypeTypeof : TypeQualified\n         return s;\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         if (exp.type)\n             return exp.type.size(loc);\n@@ -5792,7 +5794,7 @@ extern (C++) final class TypeStruct : Type\n         return \"struct\";\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return sym.size(loc);\n     }\n@@ -6148,7 +6150,7 @@ extern (C++) final class TypeEnum : Type\n         return this;\n     }\n \n-    override d_uns64 size(const ref Loc loc)\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return sym.getMemtype(loc).size(loc);\n     }\n@@ -6315,7 +6317,7 @@ extern (C++) final class TypeClass : Type\n         return \"class\";\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return target.ptrsize;\n     }\n@@ -6718,7 +6720,7 @@ extern (C++) final class TypeNull : Type\n         return true;\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return tvoidptr.size(loc);\n     }\n@@ -6777,7 +6779,7 @@ extern (C++) final class TypeNoreturn : Type\n         return true;  // bottom type can be implicitly converted to any other type\n     }\n \n-    override d_uns64 size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc) const\n     {\n         return 0;\n     }"}, {"sha": "07c574d42b79e88ef6d23f8ad1dbdbbd528f0b5a", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -100,7 +100,7 @@ enum class TY : uint8_t\n     TMAX\n };\n \n-#define SIZE_INVALID (~(d_uns64)0)   // error return from size() functions\n+#define SIZE_INVALID (~(uinteger_t)0)   // error return from size() functions\n \n \n /**\n@@ -230,8 +230,8 @@ class Type : public ASTNode\n     char *toPrettyChars(bool QualifyTypes = false);\n     static void _init();\n \n-    d_uns64 size();\n-    virtual d_uns64 size(const Loc &loc);\n+    uinteger_t size();\n+    virtual uinteger_t size(const Loc &loc);\n     virtual unsigned alignsize();\n     Type *trySemantic(const Loc &loc, Scope *sc);\n     Type *merge2();\n@@ -357,7 +357,7 @@ class TypeError : public Type\n     const char *kind();\n     TypeError *syntaxCopy();\n \n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     Expression *defaultInitLiteral(const Loc &loc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -393,7 +393,7 @@ class TypeBasic : public Type\n \n     const char *kind();\n     TypeBasic *syntaxCopy();\n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     unsigned alignsize();\n     bool isintegral();\n     bool isfloating() /*const*/;\n@@ -418,7 +418,7 @@ class TypeVector : public Type\n     static TypeVector *create(Type *basetype);\n     const char *kind();\n     TypeVector *syntaxCopy();\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     unsigned alignsize();\n     bool isintegral();\n     bool isfloating();\n@@ -448,7 +448,7 @@ class TypeSArray : public TypeArray\n     const char *kind();\n     TypeSArray *syntaxCopy();\n     bool isIncomplete();\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     unsigned alignsize();\n     bool isString();\n     bool isZeroInit(const Loc &loc);\n@@ -471,7 +471,7 @@ class TypeDArray : public TypeArray\n public:\n     const char *kind();\n     TypeDArray *syntaxCopy();\n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     unsigned alignsize() /*const*/;\n     bool isString();\n     bool isZeroInit(const Loc &loc) /*const*/;\n@@ -491,7 +491,7 @@ class TypeAArray : public TypeArray\n     static TypeAArray *create(Type *t, Type *index);\n     const char *kind();\n     TypeAArray *syntaxCopy();\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     bool isZeroInit(const Loc &loc) /*const*/;\n     bool isBoolean() /*const*/;\n     bool hasPointers() /*const*/;\n@@ -507,7 +507,7 @@ class TypePointer : public TypeNext\n     static TypePointer *create(Type *t);\n     const char *kind();\n     TypePointer *syntaxCopy();\n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     MATCH implicitConvTo(Type *to);\n     MATCH constConv(Type *to);\n     bool isscalar() /*const*/;\n@@ -522,7 +522,7 @@ class TypeReference : public TypeNext\n public:\n     const char *kind();\n     TypeReference *syntaxCopy();\n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     bool isZeroInit(const Loc &loc) /*const*/;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -655,7 +655,7 @@ class TypeDelegate : public TypeNext\n     const char *kind();\n     TypeDelegate *syntaxCopy();\n     Type *addStorageClass(StorageClass stc);\n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     unsigned alignsize() /*const*/;\n     MATCH implicitConvTo(Type *to);\n     bool isZeroInit(const Loc &loc) /*const*/;\n@@ -675,7 +675,7 @@ class TypeTraits : public Type\n \n     const char *kind();\n     TypeTraits *syntaxCopy();\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     Dsymbol *toDsymbol(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -704,7 +704,7 @@ class TypeQualified : public Type\n     void addIdent(Identifier *ident);\n     void addInst(TemplateInstance *inst);\n     void addIndex(RootObject *expr);\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n \n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -744,7 +744,7 @@ class TypeTypeof : public TypeQualified\n     const char *kind();\n     TypeTypeof *syntaxCopy();\n     Dsymbol *toDsymbol(Scope *sc);\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -778,7 +778,7 @@ class TypeStruct : public Type\n \n     static TypeStruct *create(StructDeclaration *sym);\n     const char *kind();\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     unsigned alignsize();\n     TypeStruct *syntaxCopy();\n     Dsymbol *toDsymbol(Scope *sc);\n@@ -808,7 +808,7 @@ class TypeEnum : public Type\n \n     const char *kind();\n     TypeEnum *syntaxCopy();\n-    d_uns64 size(const Loc &loc);\n+    uinteger_t size(const Loc &loc);\n     unsigned alignsize();\n     Type *memType(const Loc &loc = Loc());\n     Dsymbol *toDsymbol(Scope *sc);\n@@ -844,7 +844,7 @@ class TypeClass : public Type\n     CPPMANGLE cppmangle;\n \n     const char *kind();\n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     TypeClass *syntaxCopy();\n     Dsymbol *toDsymbol(Scope *sc);\n     ClassDeclaration *isClassHandle();\n@@ -899,7 +899,7 @@ class TypeNull : public Type\n     MATCH implicitConvTo(Type *to);\n     bool isBoolean() /*const*/;\n \n-    d_uns64 size(const Loc &loc) /*const*/;\n+    uinteger_t size(const Loc &loc) /*const*/;\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -911,7 +911,7 @@ class TypeNoreturn final : public Type\n     MATCH implicitConvTo(Type* to);\n     MATCH constConv(Type* to);\n     bool isBoolean() /* const */;\n-    d_uns64 size(const Loc& loc) /* const */;\n+    uinteger_t size(const Loc& loc) /* const */;\n     unsigned alignsize();\n \n     void accept(Visitor *v) { v->visit(this); }"}, {"sha": "5a86931305a1280bb1e638280f4d3dbb97f8e656", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -221,7 +221,7 @@ package void setLengthVarIfKnown(VarDeclaration lengthVar, Expression arr)\n         return;\n     if (lengthVar._init && !lengthVar._init.isVoidInitializer())\n         return; // we have previously calculated the length\n-    d_uns64 len;\n+    dinteger_t len;\n     if (auto se = arr.isStringExp())\n         len = se.len;\n     else if (auto ale = arr.isArrayLiteralExp())\n@@ -253,7 +253,7 @@ package void setLengthVarIfKnown(VarDeclaration lengthVar, Type type)\n     auto tsa = type.toBasetype().isTypeSArray();\n     if (!tsa)\n         return; // we don't know the length yet\n-    d_uns64 len = tsa.dim.toInteger();\n+    const len = tsa.dim.toInteger();\n     Expression dollar = new IntegerExp(Loc.initial, len, Type.tsize_t);\n     lengthVar._init = new ExpInitializer(Loc.initial, dollar);\n     lengthVar.storage_class |= STC.static_ | STC.const_;\n@@ -809,7 +809,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n             if (e.e2.isConst() == 1)\n             {\n                 sinteger_t i2 = e.e2.toInteger();\n-                d_uns64 sz = e.e1.type.size(e.e1.loc);\n+                uinteger_t sz = e.e1.type.size(e.e1.loc);\n                 assert(sz != SIZE_INVALID);\n                 sz *= 8;\n                 if (i2 < 0 || i2 >= sz)\n@@ -895,7 +895,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         if (e.e2.isConst() == 1)\n         {\n             sinteger_t i2 = e.e2.toInteger();\n-            d_uns64 sz = e.e1.type.size(e.e1.loc);\n+            uinteger_t sz = e.e1.type.size(e.e1.loc);\n             assert(sz != SIZE_INVALID);\n             sz *= 8;\n             if (i2 < 0 || i2 >= sz)"}, {"sha": "f6472bf925d413b447f10e34e8a8ad7e29360298", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -30,7 +30,7 @@ import dmd.tokens;\n \n /***********************************************************\n  */\n-class Parser(AST) : Lexer\n+class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n {\n     AST.ModuleDeclaration* md;\n \n@@ -1263,7 +1263,7 @@ class Parser(AST) : Lexer\n         }\n \n         checkConflictSTCGroup(STC.const_ | STC.immutable_ | STC.manifest);\n-        checkConflictSTCGroup(STC.gshared | STC.shared_ | STC.tls);\n+        checkConflictSTCGroup(STC.gshared | STC.shared_);\n         checkConflictSTCGroup!true(STC.safeGroup);\n \n         return orig;\n@@ -9599,5 +9599,3 @@ private bool writeMixin(const(char)[] s, ref Loc loc)\n \n     return true;\n }\n-\n-"}, {"sha": "44ca024d1057049966323dc9db144bb925d396e8", "filename": "gcc/d/dmd/root/file.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a/gcc%2Fd%2Fdmd%2Froot%2Ffile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a/gcc%2Fd%2Fdmd%2Froot%2Ffile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.h?ref=4a3073f04e8b7987ad7bfe1bc23bfeb1d627ee6a", "patch": "@@ -1,41 +0,0 @@\n-\n-/* Copyright (C) 1999-2022 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * https://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * https://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/dmd/root/file.h\n- */\n-\n-#pragma once\n-\n-#include \"array.h\"\n-#include \"filename.h\"\n-\n-struct FileBuffer\n-{\n-    DArray<unsigned char> data;\n-\n-    FileBuffer(const FileBuffer &) /* = delete */;\n-    ~FileBuffer() { mem.xfree(data.ptr); }\n-\n-    static FileBuffer *create();\n-};\n-\n-struct File\n-{\n-    struct ReadResult\n-    {\n-        bool success;\n-        FileBuffer buffer;\n-    };\n-\n-    // Read the full content of a file.\n-    static ReadResult read(const char *name);\n-\n-    // Write a file, returning `true` on success.\n-    static bool write(const char *name, const void *data, d_size_t size);\n-\n-    // Delete a file.\n-    static void remove(const char *name);\n-};"}, {"sha": "3b7b75b0aff9bedd9266c1cd075f8c4e9cfc4bac", "filename": "gcc/d/dmd/root/filename.d", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -36,6 +36,8 @@ version (Windows)\n     import core.sys.windows.windef;\n     import core.sys.windows.winnls;\n \n+    import dmd.common.string : extendedPathThen;\n+\n     extern (Windows) DWORD GetFullPathNameW(LPCWSTR, DWORD, LPWSTR, LPWSTR*) nothrow @nogc;\n     extern (Windows) void SetLastError(DWORD) nothrow @nogc;\n     extern (C) char* getcwd(char* buffer, size_t maxlen) nothrow;\n@@ -855,7 +857,7 @@ nothrow:\n         }\n         else version (Windows)\n         {\n-            return name.toWStringzThen!((wname)\n+            return name.extendedPathThen!((wname)\n             {\n                 const dw = GetFileAttributesW(&wname[0]);\n                 if (dw == -1)\n@@ -1005,7 +1007,7 @@ nothrow:\n                 // Have canonicalize_file_name, which malloc's memory.\n                 // We need a dmd.root.rmem allocation though.\n                 auto path = name.toCStringThen!((n) => canonicalize_file_name(n.ptr));\n-                scope(exit) .free(path.ptr);\n+                scope(exit) .free(path);\n                 if (path !is null)\n                     return xarraydup(path.toDString);\n             }\n@@ -1124,7 +1126,6 @@ version(Windows)\n      */\n     private int _mkdir(const(char)[] path) nothrow\n     {\n-        import dmd.common.string : extendedPathThen;\n         const createRet = path.extendedPathThen!(\n             p => CreateDirectoryW(&p[0], null /*securityAttributes*/));\n         // different conventions for CreateDirectory and mkdir"}, {"sha": "93c596ff0cdd47c13c6b1d82976412590f7f733b", "filename": "gcc/d/dmd/root/string.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Froot%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Froot%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstring.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -201,10 +201,10 @@ int dstrcmp()( scope const char[] s1, scope const char[] s2 ) @trusted\n unittest\n {\n     assert(dstrcmp(\"Fraise\", \"Fraise\")      == 0);\n-    assert(dstrcmp(\"Baguette\", \"Croissant\") == -1);\n-    assert(dstrcmp(\"Croissant\", \"Baguette\") == 1);\n+    assert(dstrcmp(\"Baguette\", \"Croissant\") < 0);\n+    assert(dstrcmp(\"Croissant\", \"Baguette\") > 0);\n \n-    static assert(dstrcmp(\"Baguette\", \"Croissant\") == -1);\n+    static assert(dstrcmp(\"Baguette\", \"Croissant\") < 0);\n \n     // UTF-8 decoding for the CT variant\n     assert(dstrcmp(\"\uc548\ub155\ud558\uc138\uc694!\", \"\uc548\ub155\ud558\uc138\uc694!\") == 0);"}, {"sha": "b9029a16ef88723abaf7f968306eac0e20bd5c0a", "filename": "gcc/d/dmd/semantic2.d", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -330,11 +330,14 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         // gets imported, it is unaffected by context.\n         Scope* sc = Scope.createGlobal(mod); // create root scope\n         //printf(\"Module = %p\\n\", sc.scopesym);\n-        // Pass 2 semantic routines: do initializers and function bodies\n-        for (size_t i = 0; i < mod.members.dim; i++)\n+        if (mod.members)\n         {\n-            Dsymbol s = (*mod.members)[i];\n-            s.semantic2(sc);\n+            // Pass 2 semantic routines: do initializers and function bodies\n+            for (size_t i = 0; i < mod.members.dim; i++)\n+            {\n+                Dsymbol s = (*mod.members)[i];\n+                s.semantic2(sc);\n+            }\n         }\n         if (mod.userAttribDecl)\n         {"}, {"sha": "d237caf93561e0f7ebaa3a617a3ff2f5e5f7783d", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -187,14 +187,17 @@ private extern(C++) final class Semantic3Visitor : Visitor\n         // gets imported, it is unaffected by context.\n         Scope* sc = Scope.createGlobal(mod); // create root scope\n         //printf(\"Module = %p\\n\", sc.scopesym);\n-        // Pass 3 semantic routines: do initializers and function bodies\n-        for (size_t i = 0; i < mod.members.dim; i++)\n+        if (mod.members)\n         {\n-            Dsymbol s = (*mod.members)[i];\n-            //printf(\"Module %s: %s.semantic3()\\n\", toChars(), s.toChars());\n-            s.semantic3(sc);\n+            // Pass 3 semantic routines: do initializers and function bodies\n+            for (size_t i = 0; i < mod.members.dim; i++)\n+            {\n+                Dsymbol s = (*mod.members)[i];\n+                //printf(\"Module %s: %s.semantic3()\\n\", toChars(), s.toChars());\n+                s.semantic3(sc);\n \n-            mod.runDeferredSemantic2();\n+                mod.runDeferredSemantic2();\n+            }\n         }\n         if (mod.userAttribDecl)\n         {\n@@ -1282,6 +1285,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 if (funcdecl.type == f)\n                     f = cast(TypeFunction)f.copy();\n                 f.isreturn = true;\n+                f.isreturnscope = cast(bool) (funcdecl.storage_class & STC.returnScope);\n                 if (funcdecl.storage_class & STC.returninferred)\n                     f.isreturninferred = true;\n             }"}, {"sha": "6ffba68fc491b8ffa6b84b8c0caf18d82a6f284b", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -987,18 +987,17 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 if (dim == 2)\n                 {\n                     Parameter p = (*fs.parameters)[0];\n-                    auto var = new VarDeclaration(loc, p.type.mutableOf(), Identifier.generateId(\"__key\"), null);\n-                    var.storage_class |= STC.temp | STC.foreach_;\n-                    if (var.storage_class & (STC.ref_ | STC.out_))\n-                        var.storage_class |= STC.nodtor;\n+                    fs.key = new VarDeclaration(loc, p.type.mutableOf(), Identifier.generateId(\"__key\"), null);\n+                    fs.key.storage_class |= STC.temp | STC.foreach_;\n+                    if (fs.key.isReference())\n+                        fs.key.storage_class |= STC.nodtor;\n \n-                    fs.key = var;\n                     if (p.storageClass & STC.ref_)\n                     {\n-                        if (var.type.constConv(p.type) == MATCH.nomatch)\n+                        if (fs.key.type.constConv(p.type) == MATCH.nomatch)\n                         {\n                             fs.error(\"key type mismatch, `%s` to `ref %s`\",\n-                                     var.type.toChars(), p.type.toChars());\n+                                     fs.key.type.toChars(), p.type.toChars());\n                             return retError();\n                         }\n                     }\n@@ -1008,7 +1007,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                         IntRange dimrange = getIntRange(ta.dim);\n                         // https://issues.dlang.org/show_bug.cgi?id=12504\n                         dimrange.imax = SignExtendedNumber(dimrange.imax.value-1);\n-                        if (!IntRange.fromType(var.type).contains(dimrange))\n+                        if (!IntRange.fromType(fs.key.type).contains(dimrange))\n                         {\n                             fs.error(\"index type `%s` cannot cover index range 0..%llu\",\n                                      p.type.toChars(), ta.dim.toInteger());\n@@ -1020,17 +1019,15 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 // Now declare the value\n                 {\n                     Parameter p = (*fs.parameters)[dim - 1];\n-                    auto var = new VarDeclaration(loc, p.type, p.ident, null);\n-                    var.storage_class |= STC.foreach_;\n-                    var.storage_class |= p.storageClass & (STC.scope_ | STC.IOR | STC.TYPECTOR);\n-                    if (var.isReference())\n-                        var.storage_class |= STC.nodtor;\n-\n-                    fs.value = var;\n-                    if (var.storage_class & STC.ref_)\n+                    fs.value = new VarDeclaration(loc, p.type, p.ident, null);\n+                    fs.value.storage_class |= STC.foreach_;\n+                    fs.value.storage_class |= p.storageClass & (STC.scope_ | STC.IOR | STC.TYPECTOR);\n+                    if (fs.value.isReference())\n                     {\n+                        fs.value.storage_class |= STC.nodtor;\n+\n                         if (fs.aggr.checkModifiable(sc2, ModifyFlags.noError) == Modifiable.initialization)\n-                            var.setInCtorOnly = true;\n+                            fs.value.setInCtorOnly = true;\n \n                         Type t = tab.nextOf();\n                         if (t.constConv(p.type) == MATCH.nomatch)\n@@ -1053,7 +1050,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                  */\n                 auto id = Identifier.generateId(\"__r\");\n                 auto ie = new ExpInitializer(loc, new SliceExp(loc, fs.aggr, null, null));\n-                const valueIsRef = cast(bool) ((*fs.parameters)[dim - 1].storageClass & STC.ref_);\n+                const valueIsRef = (*fs.parameters)[$ - 1].isReference();\n                 VarDeclaration tmp;\n                 if (fs.aggr.op == EXP.arrayLiteral && !valueIsRef)\n                 {"}, {"sha": "eb85c676a4b5dda29a63c81240e7f1c1f724f1eb", "filename": "gcc/d/dmd/target.d", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -61,7 +61,7 @@ extern (C++) struct Target\n     import dmd.dscope : Scope;\n     import dmd.expression : Expression;\n     import dmd.func : FuncDeclaration;\n-    import dmd.globals : Loc, d_int64;\n+    import dmd.globals : Loc;\n     import dmd.astenums : LINK, TY;\n     import dmd.mtype : Type, TypeFunction, TypeTuple;\n     import dmd.root.ctfloat : real_t;\n@@ -125,18 +125,18 @@ extern (C++) struct Target\n      */\n     extern (C++) struct FPTypeProperties(T)\n     {\n-        real_t max;                         /// largest representable value that's not infinity\n-        real_t min_normal;                  /// smallest representable normalized value that's not 0\n-        real_t nan;                         /// NaN value\n-        real_t infinity;                    /// infinity value\n-        real_t epsilon;                     /// smallest increment to the value 1\n-\n-        d_int64 dig;                        /// number of decimal digits of precision\n-        d_int64 mant_dig;                   /// number of bits in mantissa\n-        d_int64 max_exp;                    /// maximum int value such that 2$(SUPERSCRIPT `max_exp-1`) is representable\n-        d_int64 min_exp;                    /// minimum int value such that 2$(SUPERSCRIPT `min_exp-1`) is representable as a normalized value\n-        d_int64 max_10_exp;                 /// maximum int value such that 10$(SUPERSCRIPT `max_10_exp` is representable)\n-        d_int64 min_10_exp;                 /// minimum int value such that 10$(SUPERSCRIPT `min_10_exp`) is representable as a normalized value\n+        real_t max;         /// largest representable value that's not infinity\n+        real_t min_normal;  /// smallest representable normalized value that's not 0\n+        real_t nan;         /// NaN value\n+        real_t infinity;    /// infinity value\n+        real_t epsilon;     /// smallest increment to the value 1\n+\n+        long dig;           /// number of decimal digits of precision\n+        long mant_dig;      /// number of bits in mantissa\n+        long max_exp;       /// maximum int value such that 2$(SUPERSCRIPT `max_exp-1`) is representable\n+        long min_exp;       /// minimum int value such that 2$(SUPERSCRIPT `min_exp-1`) is representable as a normalized value\n+        long max_10_exp;    /// maximum int value such that 10$(SUPERSCRIPT `max_10_exp` is representable)\n+        long min_10_exp;    /// minimum int value such that 10$(SUPERSCRIPT `min_10_exp`) is representable as a normalized value\n     }\n \n     FPTypeProperties!float FloatProperties;     ///\n@@ -245,17 +245,6 @@ extern (C++) struct Target\n      */\n     extern (C++) bool isReturnOnStack(TypeFunction tf, bool needsThis);\n \n-    /***\n-     * Determine the size a value of type `t` will be when it\n-     * is passed on the function parameter stack.\n-     * Params:\n-     *  loc = location to use for error messages\n-     *  t = type of parameter\n-     * Returns:\n-     *  size used on parameter stack\n-     */\n-    extern (C++) ulong parameterSize(const ref Loc loc, Type t);\n-\n     /**\n      * Decides whether an `in` parameter of the specified POD type is to be\n      * passed by reference or by value. To be used with `-preview=in` only!"}, {"sha": "096c16fd610753efc884d426522a2bd9e8d74d59", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -175,12 +175,12 @@ struct Target\n         real_t infinity;\n         real_t epsilon;\n \n-        d_int64 dig;\n-        d_int64 mant_dig;\n-        d_int64 max_exp;\n-        d_int64 min_exp;\n-        d_int64 max_10_exp;\n-        d_int64 min_10_exp;\n+        int64_t dig;\n+        int64_t mant_dig;\n+        int64_t max_exp;\n+        int64_t min_exp;\n+        int64_t max_10_exp;\n+        int64_t min_10_exp;\n     };\n \n     FPTypeProperties<float> FloatProperties;\n@@ -194,7 +194,6 @@ struct Target\n public:\n     void _init(const Param& params);\n     // Type sizes and support.\n-    void setTriple(const char* _triple);\n     unsigned alignsize(Type *type);\n     unsigned fieldalign(Type *type);\n     Type *va_listType(const Loc &loc, Scope *sc);  // get type of va_list\n@@ -204,7 +203,6 @@ struct Target\n     LINK systemLinkage();\n     TypeTuple *toArgTypes(Type *t);\n     bool isReturnOnStack(TypeFunction *tf, bool needsThis);\n-    d_uns64 parameterSize(const Loc& loc, Type *t);\n     bool preferPassByRef(Type *t);\n     Expression *getTargetInfo(const char* name, const Loc& loc);\n     bool isCalleeDestroyingArgs(TypeFunction* tf);"}, {"sha": "868637691412b27684da254017ba0a137796b169", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -314,3 +314,4 @@ Tuple *isTuple(RootObject *o);\n Parameter *isParameter(RootObject *o);\n TemplateParameter *isTemplateParameter(RootObject *o);\n bool isError(const RootObject *const o);\n+void printTemplateStats();"}, {"sha": "1790996619bf572b4f1099176c66ab3bbadb94a3", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -942,17 +942,17 @@ nothrow:\n         switch (value)\n         {\n         case TOK.int32Literal:\n-            sprintf(&buffer[0], \"%d\", cast(d_int32)intvalue);\n+            sprintf(&buffer[0], \"%d\", cast(int)intvalue);\n             break;\n         case TOK.uns32Literal:\n         case TOK.wcharLiteral:\n         case TOK.dcharLiteral:\n         case TOK.wchar_tLiteral:\n-            sprintf(&buffer[0], \"%uU\", cast(d_uns32)unsvalue);\n+            sprintf(&buffer[0], \"%uU\", cast(uint)unsvalue);\n             break;\n         case TOK.charLiteral:\n         {\n-            const v = cast(d_int32)intvalue;\n+            const v = cast(int)intvalue;\n             if (v >= ' ' && v <= '~')\n                 sprintf(&buffer[0], \"'%c'\", v);\n             else"}, {"sha": "dbdcfd4af85a1f1613903c85d75312c810e5f260", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -166,28 +166,28 @@ shared static this()\n /**\n  * get an array of size_t values that indicate possible pointer words in memory\n  *  if interpreted as the type given as argument\n- * Returns: the size of the type in bytes, d_uns64.max on error\n+ * Returns: the size of the type in bytes, ulong.max on error\n  */\n-d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n+ulong getTypePointerBitmap(Loc loc, Type t, Array!(ulong)* data)\n {\n-    d_uns64 sz;\n+    ulong sz;\n     if (t.ty == Tclass && !(cast(TypeClass)t).sym.isInterfaceDeclaration())\n         sz = (cast(TypeClass)t).sym.AggregateDeclaration.size(loc);\n     else\n         sz = t.size(loc);\n     if (sz == SIZE_INVALID)\n-        return d_uns64.max;\n+        return ulong.max;\n \n     const sz_size_t = Type.tsize_t.size(loc);\n     if (sz > sz.max - sz_size_t)\n     {\n         error(loc, \"size overflow for type `%s`\", t.toChars());\n-        return d_uns64.max;\n+        return ulong.max;\n     }\n \n-    d_uns64 bitsPerWord = sz_size_t * 8;\n-    d_uns64 cntptr = (sz + sz_size_t - 1) / sz_size_t;\n-    d_uns64 cntdata = (cntptr + bitsPerWord - 1) / bitsPerWord;\n+    ulong bitsPerWord = sz_size_t * 8;\n+    ulong cntptr = (sz + sz_size_t - 1) / sz_size_t;\n+    ulong cntdata = (cntptr + bitsPerWord - 1) / bitsPerWord;\n \n     data.setDim(cast(size_t)cntdata);\n     data.zero();\n@@ -196,15 +196,15 @@ d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n     {\n         alias visit = Visitor.visit;\n     public:\n-        extern (D) this(Array!(d_uns64)* _data, d_uns64 _sz_size_t)\n+        extern (D) this(Array!(ulong)* _data, ulong _sz_size_t)\n         {\n             this.data = _data;\n             this.sz_size_t = _sz_size_t;\n         }\n \n-        void setpointer(d_uns64 off)\n+        void setpointer(ulong off)\n         {\n-            d_uns64 ptroff = off / sz_size_t;\n+            ulong ptroff = off / sz_size_t;\n             (*data)[cast(size_t)(ptroff / (8 * sz_size_t))] |= 1L << (ptroff % (8 * sz_size_t));\n         }\n \n@@ -242,12 +242,12 @@ d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n \n         override void visit(TypeSArray t)\n         {\n-            d_uns64 arrayoff = offset;\n-            d_uns64 nextsize = t.next.size();\n+            ulong arrayoff = offset;\n+            ulong nextsize = t.next.size();\n             if (nextsize == SIZE_INVALID)\n                 error = true;\n-            d_uns64 dim = t.dim.toInteger();\n-            for (d_uns64 i = 0; i < dim; i++)\n+            ulong dim = t.dim.toInteger();\n+            for (ulong i = 0; i < dim; i++)\n             {\n                 offset = arrayoff + i * nextsize;\n                 t.next.accept(this);\n@@ -340,7 +340,7 @@ d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n \n         override void visit(TypeStruct t)\n         {\n-            d_uns64 structoff = offset;\n+            ulong structoff = offset;\n             foreach (v; t.sym.fields)\n             {\n                 offset = structoff + v.offset;\n@@ -355,7 +355,7 @@ d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n         // a \"toplevel\" class is treated as an instance, while TypeClass fields are treated as references\n         void visitClass(TypeClass t)\n         {\n-            d_uns64 classoff = offset;\n+            ulong classoff = offset;\n             // skip vtable-ptr and monitor\n             if (t.sym.baseClass)\n                 visitClass(cast(TypeClass)t.sym.baseClass.type);\n@@ -367,9 +367,9 @@ d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n             offset = classoff;\n         }\n \n-        Array!(d_uns64)* data;\n-        d_uns64 offset;\n-        d_uns64 sz_size_t;\n+        Array!(ulong)* data;\n+        ulong offset;\n+        ulong sz_size_t;\n         bool error;\n     }\n \n@@ -378,7 +378,7 @@ d_uns64 getTypePointerBitmap(Loc loc, Type t, Array!(d_uns64)* data)\n         pbv.visitClass(cast(TypeClass)t);\n     else\n         t.accept(pbv);\n-    return pbv.error ? d_uns64.max : sz;\n+    return pbv.error ? ulong.max : sz;\n }\n \n /**\n@@ -406,9 +406,9 @@ private Expression pointerBitmap(TraitsExp e)\n         return ErrorExp.get();\n     }\n \n-    Array!(d_uns64) data;\n-    d_uns64 sz = getTypePointerBitmap(e.loc, t, &data);\n-    if (sz == d_uns64.max)\n+    Array!(ulong) data;\n+    ulong sz = getTypePointerBitmap(e.loc, t, &data);\n+    if (sz == ulong.max)\n         return ErrorExp.get();\n \n     auto exps = new Expressions(data.dim + 1);"}, {"sha": "e5f839bb8a340e17b545185f264afab7667b28e0", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1304,7 +1304,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             // default arg must be an lvalue\n             if (isRefOrOut && !isAuto &&\n                 !(global.params.previewIn && (fparam.storageClass & STC.in_)) &&\n-                !(global.params.rvalueRefParam))\n+                global.params.rvalueRefParam != FeatureState.enabled)\n                 e = e.toLvalue(sc, e);\n \n             fparam.defaultArg = e;\n@@ -1504,16 +1504,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n \n                 /* Scope attribute is not necessary if the parameter type does not have pointers\n                  */\n-                /* Constructors are treated as if they are being returned through the hidden parameter,\n-                 * which is by ref, and the ref there is ignored.\n-                 */\n-                const returnByRef = tf.isref && !tf.isctor;\n-                if (!returnByRef && isRefReturnScope(fparam.storageClass))\n-                {\n-                    /* if `ref return scope`, evaluate to `ref` `return scope`\n-                     */\n-                    fparam.storageClass |= STC.returnScope;\n-                }\n                 const sr = buildScopeRef(fparam.storageClass);\n                 switch (sr)\n                 {\n@@ -1534,17 +1524,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                         break;\n                 }\n \n-                /* now set STC.returnScope based only on tf.isref. This is inconsistent, as mentioned above,\n-                 * but necessary for compatibility for now.\n-                 */\n-                fparam.storageClass &= ~STC.returnScope;\n-                if (!tf.isref && isRefReturnScope(fparam.storageClass))\n-                {\n-                    /* if `ref return scope`, evaluate to `ref` `return scope`\n-                     */\n-                    fparam.storageClass |= STC.returnScope;\n-                }\n-\n                 // Remove redundant storage classes for type, they are already applied\n                 fparam.storageClass &= ~(STC.TYPECTOR);\n \n@@ -2411,7 +2390,7 @@ Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier iden\n         }\n         if (ident == Id.__sizeof)\n         {\n-            d_uns64 sz = mt.size(loc);\n+            const sz = mt.size(loc);\n             if (sz == SIZE_INVALID)\n                 return ErrorExp.get();\n             e = new IntegerExp(loc, sz, Type.tsize_t);"}, {"sha": "10f5807f5c30266b8938d263959f28f17d9d6b4b", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_AliasDeclaration.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_AliasDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_AliasDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_AliasDeclaration.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -125,7 +125,6 @@ typedef /* noreturn */ char Impossible[0];\n template <typename T>\n struct Array final\n {\n-    // Ignoring var length alignment 0\n     uint32_t length;\n     Array()\n     {"}, {"sha": "2d48999c41073de8b46c99ff5d0d34f62c534a19", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_StructDeclaration.d", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_StructDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_StructDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_StructDeclaration.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -175,7 +175,7 @@ struct A final\n         s()\n     {\n     }\n-    A(int32_t a, S s = S(0, 0, 0LL, {})) :\n+    A(int32_t a, S s = S()) :\n         a(a),\n         s(s)\n         {}\n@@ -186,6 +186,37 @@ union U\n     int32_t i;\n     char c;\n };\n+\n+struct Array final\n+{\n+    uint32_t length;\n+private:\n+    _d_dynamicArray< char > data;\n+    char smallarray[1$?:32=u|64=LLU$];\n+public:\n+    Array() :\n+        length()\n+    {\n+    }\n+    Array(uint32_t length) :\n+        length(length)\n+        {}\n+};\n+\n+struct Params final\n+{\n+    bool obj;\n+    Array ddocfiles;\n+    Params() :\n+        obj(true),\n+        ddocfiles()\n+    {\n+    }\n+    Params(bool obj, Array ddocfiles = Array()) :\n+        obj(obj),\n+        ddocfiles(ddocfiles)\n+        {}\n+};\n ---\n */\n \n@@ -284,3 +315,17 @@ extern(C++) union U\n     int i;\n     char c;\n }\n+\n+extern (C++) struct Array\n+{\n+    uint length;\n+private:\n+    char[] data;\n+    char[1] smallarray;\n+}\n+\n+extern (C++) struct Params\n+{\n+    bool obj = true;\n+    Array ddocfiles;\n+}"}, {"sha": "e9e57da87f02b542db24b09e3d1215e1317cdc8d", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_TemplateDeclaration.d", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_TemplateDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_TemplateDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_TemplateDeclaration.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -73,14 +73,10 @@ struct ActualBuffer final\n template <typename T>\n struct A final\n {\n-    // Ignoring var x alignment 0\n     T x;\n-    // Ignoring var Enum alignment 0\n     enum : int32_t { Enum = 42 };\n \n-    // Ignoring var GsharedNum alignment 0\n     static int32_t GsharedNum;\n-    // Ignoring var MemNum alignment 0\n     const int32_t MemNum;\n     void foo();\n     A()\n@@ -91,8 +87,6 @@ struct A final\n template <typename T>\n struct NotInstantiated final\n {\n-    // Ignoring var noInit alignment 0\n-    // Ignoring var missingSem alignment 0\n     NotInstantiated()\n     {\n     }\n@@ -113,7 +107,6 @@ struct B final\n template <typename T>\n struct Foo final\n {\n-    // Ignoring var val alignment 0\n     T val;\n     Foo()\n     {\n@@ -123,7 +116,6 @@ struct Foo final\n template <typename T>\n struct Bar final\n {\n-    // Ignoring var v alignment 0\n     Foo<T > v;\n     Bar()\n     {\n@@ -141,9 +133,7 @@ struct Array final\n     void get() const;\n     template <typename T>\n     bool opCast() const;\n-    // Ignoring var i alignment 0\n     typename T::Member i;\n-    // Ignoring var j alignment 0\n     typename Outer::Member::Nested j;\n     void visit(typename T::Member::Nested i);\n     Array()\n@@ -159,7 +149,6 @@ extern A<A<int32_t > > aaint;\n template <typename T>\n class Parent\n {\n-    // Ignoring var parentMember alignment 0\n public:\n     T parentMember;\n     void parentFinal();\n@@ -169,7 +158,6 @@ public:\n template <typename T>\n class Child final : public Parent<T >\n {\n-    // Ignoring var childMember alignment 0\n public:\n     T childMember;\n     void parentVirtual();\n@@ -207,14 +195,10 @@ extern HasMixinsTemplate<bool > hmti;\n template <typename T>\n struct NotAA final\n {\n-    // Ignoring var length alignment 0\n     enum : int32_t { length = 12 };\n \n-    // Ignoring var buffer alignment 0\n     T buffer[length];\n-    // Ignoring var otherBuffer alignment 0\n     T otherBuffer[SomeOtherLength];\n-    // Ignoring var calcBuffer alignment 0\n     T calcBuffer[foo(1)];\n     NotAA()\n     {\n@@ -224,9 +208,7 @@ struct NotAA final\n template <typename Buffer>\n struct BufferTmpl final\n {\n-    // Ignoring var buffer alignment 0\n     Buffer buffer;\n-    // Ignoring var buffer2 alignment 0\n     Buffer buffer2;\n     BufferTmpl()\n     {"}, {"sha": "2f5b7dfe68d51abfafa7df6b43c98b4933247b4b", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_forwarding.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_forwarding.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_forwarding.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_forwarding.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -86,7 +86,6 @@ struct ExternDStructRequired final\n template <typename T>\n struct ExternDTemplStruct final\n {\n-    // Ignoring var member alignment 0\n     T member;\n     ExternDTemplStruct()\n     {\n@@ -129,7 +128,6 @@ extern TemplClass<int32_t >* templClass;\n template <typename T>\n class TemplClass\n {\n-    // Ignoring var member alignment 0\n public:\n     T member;\n };\n@@ -139,7 +137,6 @@ extern TemplStruct<int32_t >* templStruct;\n template <typename T>\n class TemplStruct\n {\n-    // Ignoring var member alignment 0\n public:\n     T member;\n };"}, {"sha": "1e1b88736d4511dfeecf078347b2f2131668236d", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_ignored.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -62,11 +62,9 @@ private:\n template <typename T>\n struct WithImaginaryTemplate final\n {\n-    // Ignoring var member alignment 0\n     float member;\n     // Ignored function onReturn because its return type cannot be mapped to C++\n     // Ignored function onParam because one of its parameters has type `ifloat` which cannot be mapped to C++\n-    // Ignoring var onVariable alignment 0\n     // Ignored variable onVariable because its type cannot be mapped to C++\n     WithImaginaryTemplate()\n     {"}, {"sha": "c7d4c14e0c7a8baced058e8642d3e1c039f4d491", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_invalid_identifiers.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_invalid_identifiers.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_invalid_identifiers.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_invalid_identifiers.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -58,7 +58,6 @@ namespace const_cast\n template <typename register_>\n struct S final\n {\n-    // Ignoring var x alignment 0\n     register_ x;\n     S()\n     {\n@@ -104,7 +103,6 @@ extern void user(Alias<Base* >* i);\n template <typename typename_>\n struct InvalidNames final\n {\n-    // Ignoring var register alignment 0\n     typename_ register_;\n     void foo(typename_ and_);\n     InvalidNames()"}, {"sha": "8a7eb7ffffba946104cd9c6b04220f14250c46c4", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_names.d", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_names.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_names.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_names.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -63,13 +63,9 @@ struct Outer final\n         template <typename U>\n         struct InnerTmpl final\n         {\n-            // Ignoring var innerTmplOuterPtr alignment 0\n             static Outer* innerTmplOuterPtr;\n-            // Ignoring var innerTmplPtr alignment 0\n             static Middle* innerTmplPtr;\n-            // Ignoring var innerTmplInnerPtr alignment 0\n             static Inner* innerTmplInnerPtr;\n-            // Ignoring var innerTmplInnerTmplPtr alignment 0\n             static InnerTmpl* innerTmplInnerTmplPtr;\n             InnerTmpl()\n             {\n@@ -84,15 +80,11 @@ struct Outer final\n     template <typename T>\n     struct MiddleTmpl final\n     {\n-        // Ignoring var middleTmplPtr alignment 0\n         static MiddleTmpl<T >* middleTmplPtr;\n-        // Ignoring var middleTmplInnerTmplPtr alignment 0\n         static MiddleTmpl<T >* middleTmplInnerTmplPtr;\n         struct Inner final\n         {\n-            // Ignoring var ptr alignment 0\n             static Inner* ptr;\n-            // Ignoring var ptr2 alignment 0\n             static MiddleTmpl<T >* ptr2;\n             Inner()\n             {\n@@ -102,13 +94,9 @@ struct Outer final\n         template <typename U>\n         struct InnerTmpl final\n         {\n-            // Ignoring var innerTmplPtr alignment 0\n             static InnerTmpl* innerTmplPtr;\n-            // Ignoring var innerTmplPtrDiff alignment 0\n             static InnerTmpl<char >* innerTmplPtrDiff;\n-            // Ignoring var middleTmplInnerTmplPtr alignment 0\n             static MiddleTmpl<T >* middleTmplInnerTmplPtr;\n-            // Ignoring var a alignment 0\n             static T a;\n             static U bar();\n             InnerTmpl()"}, {"sha": "d41cb1bc2138fa203c12acb4787f4e37c5a1f590", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_required_symbols.d", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_required_symbols.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_required_symbols.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_required_symbols.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -65,9 +65,7 @@ enum class ExternDEnum\n template <>\n struct ExternDStructTemplate final\n {\n-    // Ignoring var i alignment 0\n     int32_t i;\n-    // Ignoring var d alignment 0\n     double d;\n     ExternDStructTemplate()\n     {\n@@ -131,7 +129,7 @@ struct ExternCppStruct final\n         st()\n     {\n     }\n-    ExternCppStruct(ExternDStruct s, ExternDEnum e = (ExternDEnum)0, ExternDStructTemplate< > st = ExternDStructTemplate< >(0, NAN)) :\n+    ExternCppStruct(ExternDStruct s, ExternDEnum e = (ExternDEnum)0, ExternDStructTemplate< > st = ExternDStructTemplate< >()) :\n         s(s),\n         e(e),\n         st(st)"}, {"sha": "95c784627fa5ec657c9a70b78ce6213c2e48687f", "filename": "gcc/testsuite/gdc.test/compilable/scope.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fscope.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -142,7 +142,7 @@ int f1_20682(return scope ref D d) @safe\n     return d.pos;\n }\n \n-ref int f2_20682(return scope ref D d) @safe\n+ref int f2_20682(return ref scope D d) @safe\n {\n     return d.pos;\n }"}, {"sha": "6122e41833931273d9043f2ba0aab128013ef96a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19948.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19948.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19948.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19948.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -0,0 +1,18 @@\n+// https://issues.dlang.org/show_bug.cgi?id=19948\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail19948.d(15): Error: function `fail19948.func(const(X))` is not callable using argument types `(X)`\n+fail_compilation/fail19948.d(15):        cannot pass argument `X()` of type `fail19948.main.X` to parameter `const(fail19948.X)`\n+---\n+*/\n+\n+struct X {}\n+void main()\n+{\n+    struct X {}\n+    func(X());\n+}\n+\n+void func(const(X)) {}"}, {"sha": "31195f6c7a5780b89ca223da99366380d3484d6f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22881.d", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22881.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22881.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22881.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -0,0 +1,60 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail22881.d(101): Error: pointer slice `[0..6]` exceeds allocated memory block `[0..5]`\n+fail_compilation/fail22881.d(102): Error: pointer slice `[0..6]` exceeds allocated memory block `[0..5]`\n+fail_compilation/fail22881.d(110): Error: pointer slice `[3..5]` exceeds allocated memory block `[0..4]`\n+fail_compilation/fail22881.d(113):        called from here: `ptr22881()`\n+fail_compilation/fail22881.d(113):        while evaluating: `static assert(ptr22881())`\n+fail_compilation/fail22881.d(203): Error: slice `[0..2]` is out of bounds\n+fail_compilation/fail22881.d(207):        called from here: `null22881()`\n+fail_compilation/fail22881.d(207):        while evaluating: `static assert(null22881())`\n+fail_compilation/fail22881.d(305): Error: slice `[2..4]` exceeds array bounds `[0..3]`\n+fail_compilation/fail22881.d(308):        called from here: `slice22881()`\n+fail_compilation/fail22881.d(308):        while evaluating: `static assert(slice22881())`\n+fail_compilation/fail22881.d(401): Error: slice `[0..1]` exceeds array bounds `[0..0]`\n+fail_compilation/fail22881.d(403): Error: slice `[0..1]` exceeds array bounds `[0..0]`\n+---\n+*/\n+#line 100\n+// SliceExp: e1.type.ty == pointer\n+static pstr22881 = \"hello\".ptr[0 .. 6];\n+static parr22881 = ['h','e','l','l','o'].ptr[0 .. 6];\n+\n+bool ptr22881()\n+{\n+    char *p1 = new char[4].ptr;\n+    p1[0 .. 4] = \"str\\0\";\n+    char *s1 = p1[1 .. 3].ptr;\n+    char *s2 = s1[1 .. 3].ptr;  // = p1[2 .. 4]\n+    char *s3 = s2[1 .. 3].ptr;  // = p1[3 .. 5]\n+    return true;\n+}\n+static assert(ptr22881());\n+\n+\n+#line 200\n+// SliceExp: e1.op == null\n+bool null22881()\n+{\n+    string[][1] nullexp;\n+    nullexp[0][0 .. 2] = \"st\";\n+    return true;\n+}\n+static assert(null22881());\n+\n+#line 300\n+// SliceExp: e1.op == slice\n+bool slice22881()\n+{\n+    char[] str = \"abcd\".dup;\n+    char[] slice = str[1 .. 4];\n+    slice[2 .. 4] = \"ab\";\n+    return true;\n+}\n+static assert(slice22881());\n+\n+#line 400\n+// SliceExp: e1.op == arrayLiteral\n+static arr22881 = [][0 .. 1];\n+// SliceExp: e1.op == string_\n+static str22881 = \"\"[0 .. 1];"}, {"sha": "fce4ab7345e46fa66adf62d0782ce1f03f0b2016", "filename": "gcc/testsuite/gdc.test/fail_compilation/pull12941.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fpull12941.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fpull12941.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fpull12941.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1,9 +1,9 @@\n /* TEST_OUTPUT:\n ---\n fail_compilation/pull12941.d(110): Error: `pull12941.foo` called with argument types `(int*)` matches both:\n-fail_compilation/pull12941.d(101):     `pull12941.foo(ref return scope int* p)`\n+fail_compilation/pull12941.d(101):     `pull12941.foo(return ref scope int* p)`\n and:\n-fail_compilation/pull12941.d(102):     `pull12941.foo(out return scope int* p)`\n+fail_compilation/pull12941.d(102):     `pull12941.foo(return out scope int* p)`\n fail_compilation/pull12941.d(111): Error: function `pull12941.bar(return scope int* p)` is not callable using argument types `(int)`\n fail_compilation/pull12941.d(111):        cannot pass argument `1` of type `int` to parameter `return scope int* p`\n fail_compilation/pull12941.d(112): Error: function `pull12941.abc(return ref int* p)` is not callable using argument types `(int)`"}, {"sha": "68269ae2da377dc1f1381d1d8bb08e899978ec40", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope2.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -130,7 +130,7 @@ fail_compilation/retscope2.d(721): Error: returning `s.get1()` escapes a referen\n \n struct S700\n {\n-    @safe S700* get1() return scope\n+    @safe S700* get1() scope return\n     {\n         return &this;\n     }"}, {"sha": "f2a117c0b80e7d216f7f08053896443d9caba976", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15191.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -56,7 +56,7 @@ int* addrOfRefGlobal()\n }\n \n // Slice:\n-ref int*[1] identityArr(ref return scope int*[1] x)\n+ref int*[1] identityArr(return ref scope int*[1] x)\n {\n \treturn x;\n }"}, {"sha": "80f8fbe2613d69e3d4e0872e17787f779033743d", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17422.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17422.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17422.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17422.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -7,7 +7,7 @@ fail_compilation/test17422.d(23): Error: scope variable `p` may not be returned\n */\n struct RC\n {\n-    Object get() return scope @trusted\n+    Object get() return @trusted\n     {\n         return cast(Object) &store[0];\n     }"}, {"sha": "72826352af2098b3038012f63ecdb120e3310bc6", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20881.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20881.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20881.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20881.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -0,0 +1,30 @@\n+/*\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test20881.d(27): Error: address of variable `s` assigned to `global` with longer lifetime\n+fail_compilation/test20881.d(28): Error: address of variable `s` assigned to `global` with longer lifetime\n+fail_compilation/test20881.d(29): Error: address of variable `s` assigned to `global` with longer lifetime\n+---\n+*/\n+@safe:\n+\n+// https://issues.dlang.org/show_bug.cgi?id=20881\n+\n+struct S\n+{\n+    int* ptr;\n+\n+    auto borrowA() return /*scope inferred*/ { return ptr; }\n+    int* borrowB() return { return ptr; }\n+    int* borrowC() scope return { return ptr; }\n+}\n+\n+void main()\n+{\n+    static int* global;\n+    S s;\n+    global = s.borrowA;\n+    global = s.borrowB;\n+    global = s.borrowC;\n+}"}, {"sha": "925210bf875c375b3515c148469c36023a3bc79e", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21912.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -32,12 +32,12 @@ Dg escapeAssign(int i, return scope Dg dg)\n     return dg;\n }\n \n-ref Dg identityR(ref return scope Dg dg)\n+ref Dg identityR(return ref scope Dg dg)\n {\n     return dg;\n }\n \n-ref Dg escapeAssignRef(int i, ref return scope Dg dg)\n+ref Dg escapeAssignRef(int i, return ref scope Dg dg)\n {\n     dg = () => i;\n     return dg;"}, {"sha": "286800748962f8bd466bd91b8523cc17d82c89a7", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/test22898.cpp", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest22898.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest22898.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest22898.cpp?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -0,0 +1,7 @@\n+int testCppCMangle (unsigned long long val, char ch)\n+{\n+    int vch = (char)val;\n+    if (vch != ch)\n+        return 0;\n+    return vch;\n+}"}, {"sha": "32506238785abaa987c03e62e88a7f38dc3883cc", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test22898.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22898.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22898.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22898.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -0,0 +1,28 @@\n+// EXTRA_CPP_SOURCES: test22898.cpp\n+\n+import core.stdc.config;\n+\n+extern(C++):\n+\n+version (AArch64) version = UnsignedChar;\n+version (ARM)     version = UnsignedChar;\n+version (RISCV32) version = UnsignedChar;\n+version (RISCV64) version = UnsignedChar;\n+version (PPC)     version = UnsignedChar;\n+version (PPC64)   version = UnsignedChar;\n+version (S390)    version = UnsignedChar;\n+version (SystemZ) version = UnsignedChar;\n+\n+version (UnsignedChar)\n+    enum __c_char : ubyte;\n+else\n+    enum __c_char : byte;\n+\n+int testCppCMangle (cpp_ulonglong, __c_char);\n+\n+void main()\n+{\n+    auto val = cast(cpp_ulonglong)18446744073709551488UL;\n+    auto ch = cast(__c_char)val;\n+    assert(testCppCMangle(val, ch) == cast(int)ch);\n+}"}, {"sha": "6eb555ed29bac3304137bc34cd4f400d2c9910a3", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1,4 +1,4 @@\n-16cb085b584f100fa677e2e64ff6b6dbb4921ad1\n+a74fa63e6775d626850d8ebd854d9803c7ffb97d\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "06b37978ba64d71b08f85c0cd08b65de7587ddbb", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -1153,7 +1153,7 @@ if (!(isImplicitlyConvertible!(S, T) &&\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=16108\n-@system unittest\n+@safe unittest\n {\n     static struct A\n     {\n@@ -1341,20 +1341,20 @@ if (is (T == immutable) && isExactSomeString!T && is(S == enum))\n     assert(to!string(a) == \"[1.5, 2.5]\");\n }\n \n-@system unittest\n+@safe unittest\n {\n     // Conversion representing class object with string\n     class A\n     {\n-        override string toString() const { return \"an A\"; }\n+        override string toString() @safe const { return \"an A\"; }\n     }\n     A a;\n     assert(to!string(a) == \"null\");\n     a = new A;\n     assert(to!string(a) == \"an A\");\n \n     // https://issues.dlang.org/show_bug.cgi?id=7660\n-    class C { override string toString() const { return \"C\"; } }\n+    class C { override string toString() @safe const { return \"C\"; } }\n     struct S { C c; alias c this; }\n     S s; s.c = new C();\n     assert(to!string(s) == \"C\");\n@@ -1739,10 +1739,10 @@ if (!isImplicitlyConvertible!(S, T) && isAssociativeArray!S &&\n     foreach (k1, v1; value)\n     {\n         // Cast values temporarily to Unqual!V2 to store them to result variable\n-        result[to!K2(k1)] = cast(Unqual!V2) to!V2(v1);\n+        result[to!K2(k1)] = to!(Unqual!V2)(v1);\n     }\n     // Cast back to original type\n-    return cast(T) result;\n+    return () @trusted { return cast(T) result; }();\n }\n \n @safe unittest\n@@ -3105,7 +3105,7 @@ if (isSomeString!Source && !is(Source == enum) &&\n  *     A $(LREF ConvException) if `source` is empty, if no number could be\n  *     parsed, or if an overflow occurred.\n  */\n-auto parse(Target, Source, Flag!\"doCount\" doCount = No.doCount)(ref Source source)\n+auto parse(Target, Source, Flag!\"doCount\" doCount = No.doCount)(ref scope Source source)\n if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum) &&\n     isFloatingPoint!Target && !is(Target == enum))\n {\n@@ -3122,6 +3122,13 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         alias p = source;\n     }\n \n+    void advanceSource() @trusted\n+    {\n+        // p is assigned from source.representation above so the cast is valid\n+        static if (isNarrowString!Source)\n+            source = cast(Source) p;\n+    }\n+\n     static immutable real[14] negtab =\n         [ 1e-4096L,1e-2048L,1e-1024L,1e-512L,1e-256L,1e-128L,1e-64L,1e-32L,\n                 1e-16L,1e-8L,1e-4L,1e-2L,1e-1L,1.0L ];\n@@ -3138,6 +3145,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n \n     enforce(!p.empty, bailOut());\n \n+\n     size_t count = 0;\n     bool sign = false;\n     switch (p.front)\n@@ -3168,8 +3176,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         // skip past the last 'f'\n         ++count;\n         p.popFront();\n-        static if (isNarrowString!Source)\n-            source = cast(Source) p;\n+        advanceSource();\n         static if (doCount)\n         {\n             return tuple!(\"data\", \"count\")(sign ? -Target.infinity : Target.infinity, count);\n@@ -3189,8 +3196,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         p.popFront();\n         if (p.empty)\n         {\n-            static if (isNarrowString!Source)\n-                source = cast(Source) p;\n+            advanceSource();\n             static if (doCount)\n             {\n                 return tuple!(\"data\", \"count\")(cast (Target) (sign ? -0.0 : 0.0), count);\n@@ -3222,8 +3228,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         // skip past the last 'n'\n         ++count;\n         p.popFront();\n-        static if (isNarrowString!Source)\n-            source = cast(Source) p;\n+        advanceSource();\n         static if (doCount)\n         {\n             return tuple!(\"data\", \"count\")(Target.nan, count);\n@@ -3418,8 +3423,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n     // if overflow occurred\n     enforce(ldval != real.infinity, new ConvException(\"Range error\"));\n \n-    static if (isNarrowString!Source)\n-        source = cast(Source) p;\n+    advanceSource();\n     static if (doCount)\n     {\n         return tuple!(\"data\", \"count\")(cast (Target) (sign ? -ldval : ldval), count);\n@@ -3430,6 +3434,7 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n     }\n }\n \n+\n ///\n @safe unittest\n {"}, {"sha": "f4f421670445f0a3ee53c5cc7a8a4a2b55057f89", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -234,7 +234,7 @@ import std.meta : anySatisfy, allSatisfy;\n import std.traits : hasElaborateCopyConstructor, hasElaborateDestructor;\n import std.traits : isAssignable, isCopyable, isStaticArray, isRvalueAssignable;\n import std.traits : ConstOf, ImmutableOf, InoutOf, TemplateArgsOf;\n-import std.traits : CommonType;\n+import std.traits : CommonType, DeducedParameterType;\n import std.typecons : ReplaceTypeUnless;\n import std.typecons : Flag;\n \n@@ -359,6 +359,10 @@ public:\n \n         /// ditto\n         this(immutable(T) value) immutable;\n+\n+        /// ditto\n+        this(Value)(Value value) inout\n+        if (is(Value == DeducedParameterType!(inout(T))));\n     }\n \n     static foreach (tid, T; Types)\n@@ -414,6 +418,25 @@ public:\n         {\n             @disable this(immutable(T) value) immutable;\n         }\n+\n+        static if (isCopyable!(inout(T)))\n+        {\n+            static if (IndexOf!(inout(T), Map!(InoutOf, Types)) == tid)\n+            {\n+                /// ditto\n+                this(Value)(Value value) inout\n+                if (is(Value == DeducedParameterType!(inout(T))))\n+                {\n+                    __traits(getMember, storage, Storage.memberName!T) = value;\n+                    tag = tid;\n+                }\n+            }\n+        }\n+        else\n+        {\n+            @disable this(Value)(Value value) inout\n+            if (is(Value == DeducedParameterType!(inout(T))));\n+        }\n     }\n \n     static if (anySatisfy!(hasElaborateCopyConstructor, Types))\n@@ -1554,6 +1577,16 @@ version (D_BetterC) {} else\n     SumType!Value s;\n }\n \n+// Construction of inout-qualified SumTypes\n+// https://issues.dlang.org/show_bug.cgi?id=22901\n+@safe unittest\n+{\n+    static inout(SumType!(int[])) example(inout(int[]) arr)\n+    {\n+        return inout(SumType!(int[]))(arr);\n+    }\n+}\n+\n /// True if `T` is an instance of the `SumType` template, otherwise false.\n private enum bool isSumTypeInstance(T) = is(T == SumType!Args, Args...);\n "}, {"sha": "9ca676d312abeb4d3b53c02ab0802d34bdf3d61f", "filename": "libphobos/src/std/traits.d", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftraits.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -9080,3 +9080,43 @@ enum isCopyable(S) = __traits(isCopyable, S);\n     static assert(isCopyable!int);\n     static assert(isCopyable!(int[]));\n }\n+\n+/**\n+ * The parameter type deduced by IFTI when an expression of type T is passed as\n+ * an argument to a template function.\n+ *\n+ * For all types other than pointer and slice types, `DeducedParameterType!T`\n+ * is the same as `T`. For pointer and slice types, it is `T` with the\n+ * outer-most layer of qualifiers dropped.\n+ */\n+package(std) template DeducedParameterType(T)\n+{\n+    static if (is(T == U*, U) || is(T == U[], U))\n+        alias DeducedParameterType = Unqual!T;\n+    else\n+        alias DeducedParameterType = T;\n+}\n+\n+@safe unittest\n+{\n+    static assert(is(DeducedParameterType!(const(int)) == const(int)));\n+    static assert(is(DeducedParameterType!(const(int[2])) == const(int[2])));\n+\n+    static assert(is(DeducedParameterType!(const(int*)) == const(int)*));\n+    static assert(is(DeducedParameterType!(const(int[])) == const(int)[]));\n+}\n+\n+@safe unittest\n+{\n+    static struct NoCopy\n+    {\n+        @disable this(this);\n+    }\n+\n+    static assert(is(DeducedParameterType!NoCopy == NoCopy));\n+}\n+\n+@safe unittest\n+{\n+    static assert(is(DeducedParameterType!(inout(int[])) == inout(int)[]));\n+}"}, {"sha": "eeeda7218132c353413ec9c48e8787af18f6e782", "filename": "libphobos/src/std/uni/package.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdaa58162ee4189f441b75170af89215465d189/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d?ref=fbdaa58162ee4189f441b75170af89215465d189", "patch": "@@ -9824,7 +9824,7 @@ dchar toLower(dchar c)\n \n /++\n     Creates a new array which is identical to `s` except that all of its\n-    characters are converted to lowercase (by preforming Unicode lowercase mapping).\n+    characters are converted to lowercase (by performing Unicode lowercase mapping).\n     If none of `s` characters were affected, then `s` itself is returned if `s` is a\n     `string`-like type.\n \n@@ -10028,7 +10028,7 @@ dchar toUpper(dchar c)\n \n /++\n     Allocates a new array which is identical to `s` except that all of its\n-    characters are converted to uppercase (by preforming Unicode uppercase mapping).\n+    characters are converted to uppercase (by performing Unicode uppercase mapping).\n     If none of `s` characters were affected, then `s` itself is returned if `s`\n     is a `string`-like type.\n "}]}