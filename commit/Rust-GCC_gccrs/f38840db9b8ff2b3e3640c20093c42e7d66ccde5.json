{"sha": "f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4ODQwZGI5YjhmZjJiM2UzNjQwYzIwMDkzYzQyZTdkNjZjY2RlNQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-02-28T03:28:18Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2006-02-28T03:28:18Z"}, "message": "* rtl.def (define_constraint, define_register_constraint)\n\t(define_memory_constraint, define_address_constraint): New MD forms.\n\t* gensupport.c (process_rtx): Put define_constraint etc on the\n\tpredicate queue.\n\t* genpreds.c (process_define_predicate): Adjust comment.  Validate\n\tthe name, and call validate_exp to validate the expression.\n\t(mark_mode_tests, write_extract_subexp): Can assume correct input.\n\t(write_predicate_expr): Likewise.  NAME argument no longer necessary;\n\tall callers changed.\n\t(validate_exp, needs_variable, struct constraint_data)\n\t(constraints_by_letter_table, first_constraint, last_constraint_ptr)\n\t(FOR_ALL_CONSTRAINTS, generic_constraint_letters, const_int_constraints)\n\t(const_dbl_constraints, constraint_max_namelen)\n\t(have_register_constraints, have_memory_constraints)\n\t(have_address_constraints, have_address_constraints)\n\t(have_extra_constraints, have_const_int_constraints)\n\t(have_const_dbl_constraints, mangle, add_constraint)\n\t(process_define_constraint, process_define_register_constraint)\n\t(write_enum_constraint_num, write_lookup_constraint)\n\t(write_insn_constraint_len, write_regclass_for_constraint)\n\t(write_constraint_satisfied_p, write_insn_const_int_ok_for_constraint)\n\t(write_insn_extra_memory_constraint)\n\t(write_insn_extra_address_constraint)\n\t(write_satisfies_constraint_fns): New.\n\t(write_tm_preds_h): If we have new-style constraint definitions,\n\tprototype the functions generated from them, and define the\n\told constraint interface (still used by generic code) in terms of\n\tthose functions.\n\t(write_insn_preds_c): If we have new-style constraint definitions,\n\tgenerate all relevant functions from those definitions.\n\t(main): Handle define_constraint etc.\n\t* genoutput.c (struct constraint_data, indep_constraints)\n\t(mdep_constraint_letters, constraints_by_letter_table, note_constraint)\n\t(mdep_constraint_len): New data structures and functions, defined\n\t#ifdef USE_MD_CONSTRAINTS.\n\t(check_constraint_len): Don't define #ifdef USE_MD_CONSTRAINTS.\n\t(validate_insn_alternatives): If USE_MD_CONSTRAINTS is defined,\n\tuse new logic to validate operand constraints against constraint\n\tdefinitions.\n\t(main): Process define_constraint etc. if USE_MD_CONSTRAINTS is\n\tdefined.\n\t* defaults.h: If none of the old-style constraint macros are\n\tdefined, define USE_MD_CONSTRAINTS; do not provide defaults for any\n\told-style macros; and poison REG_CLASS_FROM_LETTER,\n\tCONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_LETTER_P, and\n\tEXTRA_CONSTRAINT.\n\t* recog.c (reg_fits_class_p): If cl is NO_REGS, return 0 immediately.\n\t* doc/md.texi: Document new constraint-definition mechanism and the\n\tC interface it provides.  Remove references to old mechanism\n \telsewhere in the document.\n\t(Machine Constraints): Use pathnames relative to gcc directory,\n\ti.e. config/ARCH/FILE.  Change i386 section to refer to\n\tconfig/i386/predicates.md; update that section to match docstrings.\n\t* doc/tm.texi: Move all documentation of the old constraint-\n\tdefinition macros to their own section, clearly mark as obsolete.\n\n\t* config/i386/predicates.md (R, q, Q, l, a, b, c, d, S, D, A, f, t)\n\t(u, y, x, Y, I, J, K, L, M, N, O, G, C, e, Z): New constraint\n\tdefinitions.\n\t* config/i386/i386.h (REG_CLASS_FROM_LETTER, CONST_OK_FOR_LETTER_P)\n\t(CONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT): Delete.\n\t* config/i386/i386.md (*movdf_nointeger): Remove stray 'H' from\n\tconstraint strings.\n\t(splits and peepholes): Use satisfies_constraint_*.\n\t* config/i386/i386.c (memory_address_length)\n\t(ix86_attr_length_immediate_default): Use satisfies_constraint_*.\n\nFrom-SVN: r111508", "tree": {"sha": "bfe845d7fbc0991a92a6a103f30e8889f0bd0a62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe845d7fbc0991a92a6a103f30e8889f0bd0a62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "167f0c7e07a7cd702c966436c8cd6875cceb8697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/167f0c7e07a7cd702c966436c8cd6875cceb8697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/167f0c7e07a7cd702c966436c8cd6875cceb8697"}], "stats": {"total": 1977, "additions": 1678, "deletions": 299}, "files": [{"sha": "7538a9f81430c02eaf9cb00932391eeae2a11574", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -1,3 +1,72 @@\n+2006-02-27  Zack Weinberg  <zackw@panix.com>\n+\n+\t* rtl.def (define_constraint, define_register_constraint)\n+\t(define_memory_constraint, define_address_constraint): New MD forms.\n+\t* gensupport.c (process_rtx): Put define_constraint etc on the\n+\tpredicate queue.\n+\t* genpreds.c (process_define_predicate): Adjust comment.  Validate\n+\tthe name, and call validate_exp to validate the expression.\n+\t(mark_mode_tests, write_extract_subexp): Can assume correct input.\n+\t(write_predicate_expr): Likewise.  NAME argument no longer necessary;\n+\tall callers changed.\n+\t(validate_exp, needs_variable, struct constraint_data)\n+\t(constraints_by_letter_table, first_constraint, last_constraint_ptr)\n+\t(FOR_ALL_CONSTRAINTS, generic_constraint_letters, const_int_constraints)\n+\t(const_dbl_constraints, constraint_max_namelen)\n+\t(have_register_constraints, have_memory_constraints)\n+\t(have_address_constraints, have_address_constraints)\n+\t(have_extra_constraints, have_const_int_constraints)\n+\t(have_const_dbl_constraints, mangle, add_constraint)\n+\t(process_define_constraint, process_define_register_constraint)\n+\t(write_enum_constraint_num, write_lookup_constraint)\n+\t(write_insn_constraint_len, write_regclass_for_constraint)\n+\t(write_constraint_satisfied_p, write_insn_const_int_ok_for_constraint)\n+\t(write_insn_extra_memory_constraint)\n+\t(write_insn_extra_address_constraint)\n+\t(write_satisfies_constraint_fns): New.\n+\t(write_tm_preds_h): If we have new-style constraint definitions,\n+\tprototype the functions generated from them, and define the\n+\told constraint interface (still used by generic code) in terms of\n+\tthose functions.\n+\t(write_insn_preds_c): If we have new-style constraint definitions,\n+\tgenerate all relevant functions from those definitions.\n+\t(main): Handle define_constraint etc.\n+\t* genoutput.c (struct constraint_data, indep_constraints)\n+\t(mdep_constraint_letters, constraints_by_letter_table, note_constraint)\n+\t(mdep_constraint_len): New data structures and functions, defined\n+\t#ifdef USE_MD_CONSTRAINTS.\n+\t(check_constraint_len): Don't define #ifdef USE_MD_CONSTRAINTS.\n+\t(validate_insn_alternatives): If USE_MD_CONSTRAINTS is defined,\n+\tuse new logic to validate operand constraints against constraint\n+\tdefinitions.\n+\t(main): Process define_constraint etc. if USE_MD_CONSTRAINTS is\n+\tdefined.\n+\t* defaults.h: If none of the old-style constraint macros are\n+\tdefined, define USE_MD_CONSTRAINTS; do not provide defaults for any\n+\told-style macros; and poison REG_CLASS_FROM_LETTER,\n+\tCONST_OK_FOR_LETTER_P, CONST_DOUBLE_OK_FOR_LETTER_P, and\n+\tEXTRA_CONSTRAINT.\n+\t* recog.c (reg_fits_class_p): If cl is NO_REGS, return 0 immediately.\n+\t* doc/md.texi: Document new constraint-definition mechanism and the\n+\tC interface it provides.  Remove references to old mechanism\n+ \telsewhere in the document.\n+\t(Machine Constraints): Use pathnames relative to gcc directory,\n+\ti.e. config/ARCH/FILE.  Change i386 section to refer to\n+\tconfig/i386/predicates.md; update that section to match docstrings.\n+\t* doc/tm.texi: Move all documentation of the old constraint-\n+\tdefinition macros to their own section, clearly mark as obsolete.\n+\n+\t* config/i386/predicates.md (R, q, Q, l, a, b, c, d, S, D, A, f, t)\n+\t(u, y, x, Y, I, J, K, L, M, N, O, G, C, e, Z): New constraint\n+\tdefinitions.\n+\t* config/i386/i386.h (REG_CLASS_FROM_LETTER, CONST_OK_FOR_LETTER_P)\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT): Delete.\n+\t* config/i386/i386.md (*movdf_nointeger): Remove stray 'H' from\n+\tconstraint strings.\n+\t(splits and peepholes): Use satisfies_constraint_*.\n+\t* config/i386/i386.c (memory_address_length)\n+\t(ix86_attr_length_immediate_default): Use satisfies_constraint_*.\n+\n 2006-02-27  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* lambda-code.c (can_convert_to_perfect_nest): Allow any type of"}, {"sha": "fae111e986f0c9217e6302ae1e442807d1329e2f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -13291,9 +13291,7 @@ memory_address_length (rtx addr)\n       /* Find the length of the displacement constant.  */\n       if (disp)\n \t{\n-\t  if (GET_CODE (disp) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (disp), 'K')\n-\t      && base)\n+\t  if (base && satisfies_constraint_K (disp))\n \t    len = 1;\n \t  else\n \t    len = 4;\n@@ -13326,9 +13324,7 @@ ix86_attr_length_immediate_default (rtx insn, int shortform)\n     if (CONSTANT_P (recog_data.operand[i]))\n       {\n \tgcc_assert (!len);\n-\tif (shortform\n-\t    && GET_CODE (recog_data.operand[i]) == CONST_INT\n-\t    && CONST_OK_FOR_LETTER_P (INTVAL (recog_data.operand[i]), 'K'))\n+\tif (shortform && satisfies_constraint_K (recog_data.operand[i]))\n \t  len = 1;\n \telse\n \t  {"}, {"sha": "fc8f62661b5802b037f81f4a8c108ea7583e69e8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -1196,92 +1196,6 @@ enum reg_class\n #define INDEX_REG_CLASS INDEX_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n-/* Unused letters:\n-    B                 TU W   \n-          h jk          vw  z\n-*/\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\\\n-  ((C) == 'r' ? GENERAL_REGS :\t\t\t\t\t\\\n-   (C) == 'R' ? LEGACY_REGS :\t\t\t\t\t\\\n-   (C) == 'q' ? TARGET_64BIT ? GENERAL_REGS : Q_REGS :\t\t\\\n-   (C) == 'Q' ? Q_REGS :\t\t\t\t\t\\\n-   (C) == 'f' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n-\t\t ? FLOAT_REGS\t\t\t\t\t\\\n-\t\t : NO_REGS) :\t\t\t\t\t\\\n-   (C) == 't' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n-\t\t ? FP_TOP_REG\t\t\t\t\t\\\n-\t\t : NO_REGS) :\t\t\t\t\t\\\n-   (C) == 'u' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n-\t\t ? FP_SECOND_REG\t\t\t\t\\\n-\t\t : NO_REGS) :\t\t\t\t\t\\\n-   (C) == 'a' ? AREG :\t\t\t\t\t\t\\\n-   (C) == 'b' ? BREG :\t\t\t\t\t\t\\\n-   (C) == 'c' ? CREG :\t\t\t\t\t\t\\\n-   (C) == 'd' ? DREG :\t\t\t\t\t\t\\\n-   (C) == 'x' ? TARGET_SSE ? SSE_REGS : NO_REGS :\t\t\\\n-   (C) == 'Y' ? TARGET_SSE2? SSE_REGS : NO_REGS :\t\t\\\n-   (C) == 'y' ? TARGET_MMX ? MMX_REGS : NO_REGS :\t\t\\\n-   (C) == 'A' ? AD_REGS :\t\t\t\t\t\\\n-   (C) == 'D' ? DIREG :\t\t\t\t\t\t\\\n-   (C) == 'S' ? SIREG :\t\t\t\t\t\t\\\n-   (C) == 'l' ? INDEX_REGS :\t\t\t\t\t\\\n-   NO_REGS)\n-\n-/* The letters I, J, K, L, M, N, and O in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   I is for non-DImode shifts.\n-   J is for DImode shifts.\n-   K is for signed imm8 operands.\n-   L is for andsi as zero-extending move.\n-   M is for shifts that can be executed by the \"lea\" opcode.\n-   N is for immediate operands for out/in instructions (0-255)\n-   O is for TImode shifts.\n-   */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'I' ? (VALUE) >= 0 && (VALUE) <= 31\t\t\t\\\n-   : (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 63\t\t\t\\\n-   : (C) == 'K' ? (VALUE) >= -128 && (VALUE) <= 127\t\t\\\n-   : (C) == 'L' ? (VALUE) == 0xff || (VALUE) == 0xffff\t\t\\\n-   : (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3\t\t\t\\\n-   : (C) == 'N' ? (VALUE) >= 0 && (VALUE) <= 255\t\t\\\n-   : (C) == 'O' ? (VALUE) >= 0 && (VALUE) <= 127\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  We allow constants even if\n-   TARGET_387 isn't set, because the stack register converter may need to\n-   load 0.0 into the function value register.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'G' ? standard_80387_constant_p (VALUE) \\\n-   : 0)\n-\n-/* A C expression that defines the optional machine-dependent\n-   constraint letters that can be used to segregate specific types of\n-   operands, usually memory references, for the target machine.  Any\n-   letter that is not elsewhere defined and not matched by\n-   `REG_CLASS_FROM_LETTER' may be used.  Normally this macro will not\n-   be defined.\n-\n-   If it is required for a particular target machine, it should\n-   return 1 if VALUE corresponds to the operand type represented by\n-   the constraint letter C.  If C is not defined as an extra\n-   constraint, the value returned should be 0 regardless of VALUE.  */\n-\n-#define EXTRA_CONSTRAINT(VALUE, D)\t\t\t\t\t\\\n-  ((D) == 'e' ? x86_64_immediate_operand (VALUE, VOIDmode)\t\t\\\n-   : (D) == 'Z' ? x86_64_zext_immediate_operand (VALUE, VOIDmode)\t\\\n-   : (D) == 'C' ? standard_sse_constant_p (VALUE)\t\t\t\\\n-   : 0)\n-\n /* Place additional restrictions on the register class to use when it\n    is necessary to be able to hold a value of mode MODE in a reload\n    register for which class CLASS would ordinarily be used.  */"}, {"sha": "4e64da31a3ff335e5548209c997562e880861aa2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -2440,9 +2440,9 @@\n \n (define_insn \"*movdf_nointeger\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t\"=f#Y,m  ,f#Y,*r  ,o  ,Y*x#f,Y*x#f,Y*x#f  ,m    \")\n+\t\t\t\"=f#Y,m  ,f#Y,*r  ,o  ,Y*x#f,Y*x#f,Y*x#f ,m    \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\"fm#Y,f#Y,G  ,*roF,F*r,C    ,Y*x#f,HmY*x#f,Y*x#f\"))]\n+\t\t\t\"fm#Y,f#Y,G  ,*roF,F*r,C    ,Y*x#f,mY*x#f,Y*x#f\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && ((optimize_size || !TARGET_INTEGER_DFMODE_MOVES) && !TARGET_64BIT)\n    && (reload_in_progress || reload_completed\n@@ -19038,8 +19038,9 @@\n   \"! TARGET_PARTIAL_REG_STALL && reload_completed\n    && ((GET_MODE (operands[0]) == HImode \n \t&& ((!optimize_size && !TARGET_FAST_PREFIX)\n+            /* ??? next two lines just !satisfies_constraint_K (...) */\n \t    || GET_CODE (operands[2]) != CONST_INT\n-\t    || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')))\n+\t    || satisfies_constraint_K (operands[2])))\n        || (GET_MODE (operands[0]) == QImode \n \t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n   [(parallel [(set (match_dup 0)\n@@ -19361,8 +19362,7 @@\n \t   (const_int 0)]))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n    && (true_regnum (operands[2]) != 0\n-       || (GET_CODE (operands[3]) == CONST_INT\n-\t   && CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'K')))\n+       || satisfies_constraint_K (operands[3]))\n    && peep2_reg_dead_p (1, operands[2])\"\n   [(parallel\n      [(set (match_dup 0)\n@@ -19928,8 +19928,7 @@\n \t\t\t    (match_operand:DI 2 \"immediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || !CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))\"\n+   && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0) (mult:DI (match_dup 3) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n@@ -19942,8 +19941,7 @@\n \t\t\t    (match_operand:SI 2 \"immediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || !CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))\"\n+   && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n@@ -19957,8 +19955,7 @@\n \t\t\t      (match_operand:SI 2 \"immediate_operand\" \"\"))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || !CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))\"\n+   && !satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 1))\n    (parallel [(set (match_dup 0) (zero_extend:DI (mult:SI (match_dup 3) (match_dup 2))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n@@ -19975,7 +19972,7 @@\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_scratch:DI 3 \"r\")]\n   \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n-   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n+   && satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel [(set (match_dup 0) (mult:DI (match_dup 0) (match_dup 3)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n@@ -19991,7 +19988,7 @@\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_scratch:SI 3 \"r\")]\n   \"(TARGET_K8 || TARGET_GENERIC64) && !optimize_size\n-   && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')\"\n+   && satisfies_constraint_K (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel [(set (match_dup 0) (mult:SI (match_dup 0) (match_dup 3)))\n \t      (clobber (reg:CC FLAGS_REG))])]"}, {"sha": "d97f6fccbca8d1e06531909d9962ce71b50352fe", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -947,3 +947,137 @@\n \n (define_predicate \"absneg_operator\"\n   (match_code \"abs,neg\"))\n+\n+;;; Constraint definitions.\n+;;; Unused letters:\n+;;;     B     H           TU W   \n+;;;           h jk          vw  z\n+\n+;; Integer register constraints.\n+;; It is not necessary to define 'r' here.\n+(define_register_constraint \"R\" \"LEGACY_REGS\"\n+ \"Legacy register---the eight integer registers available on all\n+  i386 processors (@code{a}, @code{b}, @code{c}, @code{d},\n+  @code{si}, @code{di}, @code{bp}, @code{sp}).\")\n+\n+(define_register_constraint \"q\" \"TARGET_64BIT ? GENERAL_REGS : Q_REGS\"\n+ \"Any register accessible as @code{@var{r}l}.  In 32-bit mode, @code{a},\n+  @code{b}, @code{c}, and @code{d}; in 64-bit mode, any integer register.\")\n+\n+(define_register_constraint \"Q\" \"Q_REGS\"\n+ \"Any register accessible as @code{@var{r}h}: @code{a}, @code{b},\n+  @code{c}, and @code{d}.\")\n+\n+(define_register_constraint \"l\" \"INDEX_REGS\"\n+ \"@internal Any register that can be used as the index in a base+index\n+  memory access: that is, any general register except the stack pointer.\")\n+\n+(define_register_constraint \"a\" \"AREG\"\n+ \"The @code{a} register.\")\n+\n+(define_register_constraint \"b\" \"BREG\"\n+ \"The @code{b} register.\")\n+\n+(define_register_constraint \"c\" \"CREG\"\n+ \"The @code{c} register.\")\n+\n+(define_register_constraint \"d\" \"DREG\"\n+ \"The @code{d} register.\")\n+\n+(define_register_constraint \"S\" \"SIREG\"\n+ \"The @code{si} register.\")\n+\n+(define_register_constraint \"D\" \"DIREG\"\n+ \"The @code{di} register.\")\n+\n+(define_register_constraint \"A\" \"AD_REGS\"\n+ \"The @code{a} and @code{d} registers, as a pair (for instructions\n+  that return half the result in one and half in the other).\")\n+\n+;; Floating-point register constraints.\n+(define_register_constraint \"f\"\n+ \"TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387 ? FLOAT_REGS : NO_REGS\"\n+ \"Any 80387 floating-point (stack) register.\")\n+\n+(define_register_constraint \"t\"\n+ \"TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387 ? FP_TOP_REG : NO_REGS\"\n+ \"Top of 80387 floating-point stack (@code{%st(0)}).\")\n+\n+(define_register_constraint \"u\"\n+ \"TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387 ? FP_SECOND_REG : NO_REGS\"\n+ \"Second from top of 80387 floating-point stack (@code{%st(1)}).\")\n+\n+;; Vector registers (also used for plain floating point nowadays).\n+(define_register_constraint \"y\" \"TARGET_MMX ? MMX_REGS : NO_REGS\"\n+ \"Any MMX register.\")\n+\n+(define_register_constraint \"x\" \"TARGET_SSE ? SSE_REGS : NO_REGS\"\n+ \"Any SSE register.\")\n+\n+(define_register_constraint \"Y\" \"TARGET_SSE2? SSE_REGS : NO_REGS\"\n+ \"@internal Any SSE2 register.\")\n+\n+;; Integer constant constraints.\n+(define_constraint \"I\"\n+  \"Integer constant in the range 0 @dots{} 31, for 32-bit shifts.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 31\")))\n+\n+(define_constraint \"J\"\n+  \"Integer constant in the range 0 @dots{} 63, for 64-bit shifts.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 63\")))\n+\n+(define_constraint \"K\"\n+  \"Signed 8-bit integer constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -128 && ival <= 127\")))\n+\n+(define_constraint \"L\"\n+  \"@code{0xFF} or @code{0xFFFF}, for andsi as a zero-extending move.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0xFF || ival == 0xFFFF\")))\n+\n+(define_constraint \"M\"\n+  \"0, 1, 2, or 3 (shifts for the @code{lea} instruction).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 3\")))\n+\n+(define_constraint \"N\"\n+  \"Unsigned 8-bit integer constant (for @code{in} and @code{out} \n+   instructions).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 255\")))\n+\n+(define_constraint \"O\"\n+  \"@internal Integer constant in the range 0 @dots{} 127, for 128-bit shifts.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 127\")))\n+\n+;; Floating-point constant constraints.\n+;; We allow constants even if TARGET_80387 isn't set, because the\n+;; stack register converter may need to load 0.0 into the function\n+;; value register (top of stack).\n+(define_constraint \"G\"\n+  \"Standard 80387 floating point constant.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"standard_80387_constant_p (op)\")))\n+\n+;; This can theoretically be any mode's CONST0_RTX.\n+(define_constraint \"C\"\n+  \"Standard SSE floating point constant.\"\n+  (match_test \"standard_sse_constant_p (op)\"))\n+\n+;; Constant-or-symbol-reference constraints.\n+\n+(define_constraint \"e\"\n+  \"32-bit signed integer constant, or a symbolic reference known\n+   to fit that range (for immediate operands in sign-extending x86-64\n+   instructions).\"\n+  (match_operand 0 \"x86_64_immediate_operand\"))\n+\n+(define_constraint \"Z\"\n+  \"32-bit unsigned integer constant, or a symbolic reference known\n+   to fit that range (for immediate operands in zero-extending x86-64\n+   instructions).\"\n+  (match_operand 0 \"x86_64_zext_immediate_operand\"))"}, {"sha": "624f039dfea2ea704f9eb2a35ac564633241151e", "filename": "gcc/defaults.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -752,6 +752,33 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define DEFAULT_USE_CXA_ATEXIT 0\n #endif\n \n+/* If none of these macros are defined, the port must use the new\n+   technique of defining constraints in the machine description.\n+   tm_p.h will define those macros that machine-independent code\n+   still uses.  */\n+#if  !defined CONSTRAINT_LEN\t\t\t\\\n+  && !defined REG_CLASS_FROM_LETTER\t\t\\\n+  && !defined REG_CLASS_FROM_CONSTRAINT\t\t\\\n+  && !defined CONST_OK_FOR_LETTER_P\t\t\\\n+  && !defined CONST_OK_FOR_CONSTRAINT_P\t\t\\\n+  && !defined CONST_DOUBLE_OK_FOR_LETTER_P\t\\\n+  && !defined CONST_DOUBLE_OK_FOR_CONSTRAINT_P  \\\n+  && !defined EXTRA_CONSTRAINT\t\t\t\\\n+  && !defined EXTRA_CONSTRAINT_STR\t\t\\\n+  && !defined EXTRA_MEMORY_CONSTRAINT\t\t\\\n+  && !defined EXTRA_ADDRESS_CONSTRAINT\n+\n+#define USE_MD_CONSTRAINTS\n+\n+#if GCC_VERSION >= 3000 && defined IN_GCC\n+/* These old constraint macros shouldn't appear anywhere in a\n+   configuration using MD constraint definitions.  */\n+#pragma GCC poison REG_CLASS_FROM_LETTER CONST_OK_FOR_LETTER_P \\\n+                   CONST_DOUBLE_OK_FOR_LETTER_P EXTRA_CONSTRAINT\n+#endif\n+\n+#else /* old constraint mechanism in use */\n+\n /* Determine whether extra constraint letter should be handled\n    via address reload (like 'o').  */\n #ifndef EXTRA_MEMORY_CONSTRAINT\n@@ -791,6 +818,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define EXTRA_CONSTRAINT_STR(OP, C,STR) EXTRA_CONSTRAINT (OP, C)\n #endif\n \n+#endif /* old constraint mechanism in use */\n+\n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(m, x, y) 2\n #endif"}, {"sha": "6a3300bae3e866fbaeda66df20c152fae47539aa", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 331, "deletions": 90, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -1051,6 +1051,8 @@ have.  Constraints can also require two operands to match.\n * Class Preferences::   Constraints guide which hard register to put things in.\n * Modifiers::           More precise control over effects of constraints.\n * Machine Constraints:: Existing constraints for some particular machines.\n+* Define Constraints::  How to define machine-specific constraints.\n+* C Constraint Interface:: How to test constraints from C code.\n @end menu\n @end ifset\n \n@@ -1273,15 +1275,6 @@ Other letters can be defined in machine-dependent fashion to stand for\n particular classes of registers or other arbitrary operand types.\n @samp{d}, @samp{a} and @samp{f} are defined on the 68000/68020 to stand\n for data, address and floating point registers.\n-\n-@ifset INTERNALS\n-The machine description macro @code{REG_CLASS_FROM_LETTER} has first\n-cut at the otherwise unused letters.  If it evaluates to @code{NO_REGS},\n-then @code{EXTRA_CONSTRAINT} is evaluated.\n-\n-A typical use for @code{EXTRA_CONSTRAINT} would be to distinguish certain\n-types of memory references that affect other insn operands.\n-@end ifset\n @end table\n \n @ifset INTERNALS\n@@ -1624,35 +1617,16 @@ general-purpose registers respectively; @pxref{Simple Constraints}), and\n @samp{I}, usually the letter indicating the most common\n immediate-constant format.\n \n-For each machine architecture, the\n-@file{config/@var{machine}/@var{machine}.h} file defines additional\n-constraints.  These constraints are used by the compiler itself for\n-instruction generation, as well as for @code{asm} statements; therefore,\n-some of the constraints are not particularly interesting for @code{asm}.\n-The constraints are defined through these macros:\n-\n-@table @code\n-@item REG_CLASS_FROM_LETTER\n-Register class constraints (usually lowercase).\n-\n-@item CONST_OK_FOR_LETTER_P\n-Immediate constant constraints, for non-floating point constants of\n-word size or smaller precision (usually uppercase).\n-\n-@item CONST_DOUBLE_OK_FOR_LETTER_P\n-Immediate constant constraints, for all floating point constants and for\n-constants of greater than word size precision (usually uppercase).\n-\n-@item EXTRA_CONSTRAINT\n-Special cases of registers or memory.  This macro is not required, and\n-is only defined for some machines.\n-@end table\n-\n-Inspecting these macro definitions in the compiler source for your\n-machine is the best way to be certain you have the right constraints.\n-However, here is a summary of the machine-dependent constraints\n-available on some particular machines.\n-\n+Each architecture defines additional constraints.  These constraints\n+are used by the compiler itself for instruction generation, as well as\n+for @code{asm} statements; therefore, some of the constraints are not\n+particularly useful for @code{asm}.  Here is a summary of some of the\n+machine-dependent constraints available on some particular machines;\n+it includes both constraints that are useful for @code{asm} and\n+constraints that aren't.  The compiler source file mentioned in the\n+table heading for each architecture is the definitive reference for\n+the meanings of that architecture's constraints.\n+ \n @table @emph\n @item ARM family---@file{config/arm/arm.h}\n @table @code\n@@ -1908,93 +1882,109 @@ A 15-bit signed integer constant.\n A positive 16-bit constant.\n @end table\n \n-@item Intel 386---@file{config/i386/i386.h}\n+@item Intel 386---@file{config/i386/predicates.md}\n @table @code\n-@item q\n-@samp{a}, @code{b}, @code{c}, or @code{d} register for the i386.\n-For x86-64 it is equivalent to @samp{r} class (for 8-bit instructions that\n-do not use upper halves).\n-\n-@item Q\n-@samp{a}, @code{b}, @code{c}, or @code{d} register (for 8-bit instructions,\n-that do use upper halves).\n-\n @item R\n-Legacy register---equivalent to @code{r} class in i386 mode.\n-(for non-8-bit registers used together with 8-bit upper halves in a single\n-instruction)\n-\n-@item A\n-Specifies the @samp{a} or @samp{d} registers.  This is primarily useful\n-for 64-bit integer values (when in 32-bit mode) intended to be returned\n-with the @samp{d} register holding the most significant bits and the\n-@samp{a} register holding the least significant bits.\n+Legacy register---the eight integer registers available on all\n+i386 processors (@code{a}, @code{b}, @code{c}, @code{d},\n+@code{si}, @code{di}, @code{bp}, @code{sp}).\n \n-@item f\n-Floating point register\n+@item q\n+Any register accessible as @code{@var{r}l}.  In 32-bit mode, @code{a},\n+@code{b}, @code{c}, and @code{d}; in 64-bit mode, any integer register.\n \n-@item t\n-First (top of stack) floating point register\n+@item Q\n+Any register accessible as @code{@var{r}h}: @code{a}, @code{b},\n+@code{c}, and @code{d}.\n \n-@item u\n-Second floating point register\n+@ifset INTERNALS\n+@item l\n+Any register that can be used as the index in a base+index memory\n+access: that is, any general register except the stack pointer.\n+@end ifset\n \n @item a\n-@samp{a} register\n+The @code{a} register.\n \n @item b\n-@samp{b} register\n+The @code{b} register.\n \n @item c\n-@samp{c} register\n-\n-@item C\n-Specifies constant that can be easily constructed in SSE register without\n-loading it from memory.\n+The @code{c} register.\n \n @item d\n-@samp{d} register\n+The @code{d} register.\n+\n+@item S\n+The @code{si} register.\n \n @item D\n-@samp{di} register\n+The @code{di} register.\n \n-@item S\n-@samp{si} register\n+@item A\n+The @code{a} and @code{d} registers, as a pair (for instructions that\n+return half the result in one and half in the other).\n \n-@item x\n-@samp{xmm} SSE register\n+@item f\n+Any 80387 floating-point (stack) register.\n+\n+@item t\n+Top of 80387 floating-point stack (@code{%st(0)}).\n+\n+@item u\n+Second from top of 80387 floating-point stack (@code{%st(1)}).\n \n @item y\n-MMX register\n+Any MMX register.\n+\n+@item x\n+Any SSE register.\n+\n+@ifset INTERNALS\n+@item Y\n+Any SSE2 register.\n+@end ifset\n \n @item I\n-Constant in range 0 to 31 (for 32-bit shifts)\n+Integer constant in the range 0 @dots{} 31, for 32-bit shifts.\n \n @item J\n-Constant in range 0 to 63 (for 64-bit shifts)\n+Integer constant in the range 0 @dots{} 63, for 64-bit shifts.\n \n @item K\n-@samp{0xff}\n+Signed 8-bit integer constant.\n \n @item L\n-@samp{0xffff}\n+@code{0xFF} or @code{0xFFFF}, for andsi as a zero-extending move.\n \n @item M\n-0, 1, 2, or 3 (shifts for @code{lea} instruction)\n+0, 1, 2, or 3 (shifts for the @code{lea} instruction).\n \n @item N\n-Constant in range 0 to 255 (for @code{out} instruction)\n+Unsigned 8-bit integer constant (for @code{in} and @code{out} \n+instructions).\n \n-@item Z\n-Constant in range 0 to @code{0xffffffff} or symbolic reference known to fit specified range.\n-(for using immediates in zero extending 32-bit to 64-bit x86-64 instructions)\n+@ifset INTERNALS\n+@item O\n+Integer constant in the range 0 @dots{} 127, for 128-bit shifts.\n+@end ifset\n+\n+@item G\n+Standard 80387 floating point constant.\n+\n+@item C\n+Standard SSE floating point constant.\n \n @item e\n-Constant in range @minus{}2147483648 to 2147483647 or symbolic reference known to fit specified range.\n-(for using immediates in 64-bit x86-64 instructions)\n+32-bit signed integer constant, or a symbolic reference known\n+to fit that range (for immediate operands in sign-extending x86-64\n+instructions).\n+\n+@item Z\n+32-bit unsigned integer constant, or a symbolic reference known\n+to fit that range (for immediate operands in zero-extending x86-64\n+instructions).\n \n-@item G\n-Standard 80387 floating point constant\n @end table\n \n @item Intel IA-64---@file{config/ia64/ia64.h}\n@@ -2868,6 +2858,257 @@ Unsigned constant valid for BccUI instructions\n @end table\n \n @ifset INTERNALS\n+@node Define Constraints\n+@subsection Defining Machine-Specific Constraints\n+@cindex defining constraints\n+@cindex constraints, defining\n+\n+Machine-specific constraints fall into two categories: register and\n+non-register constraints.  Within the latter category, constraints\n+which allow subsets of all possible memory or address operands should\n+be specially marked, to give @code{reload} more information.\n+\n+Machine-specific constraints can be given names of arbitrary length,\n+but they must be entirely composed of letters, digits, underscores\n+(@samp{_}), and angle brackets (@samp{< >}).  Like C identifiers, they\n+must begin with a letter or underscore. \n+\n+In order to avoid ambiguity in operand constraint strings, no\n+constraint can have a name that begins with any other constraint's\n+name.  For example, if @code{x} is defined as a constraint name,\n+@code{xy} may not be, and vice versa.  As a consequence of this rule,\n+no constraint may begin with one of the generic constraint letters:\n+@samp{E F V X g i m n o p r s}.\n+\n+Register constraints correspond directly to register classes.\n+@xref{Register Classes}.  There is thus not much flexibility in their\n+definitions.\n+\n+@deffn {MD Expression} define_register_constraint name regclass docstring\n+All three arguments are string constants.\n+@var{name} is the name of the constraint, as it will appear in\n+@code{match_operand} expressions.  @var{regclass} can be either the\n+name of the corresponding register class (@pxref{Register Classes}),\n+or a C expression which evaluates to the appropriate register class.\n+If it is an expression, it must have no side effects, and it cannot\n+look at the operand.  The usual use of expressions is to map some\n+register constraints to @code{NO_REGS} when the register class\n+is not available on a given subarchitecture.\n+\n+@var{docstring} is a sentence documenting the meaning of the\n+constraint.  Docstrings are explained further below.\n+@end deffn\n+\n+Non-register constraints are more like predicates: the constraint\n+definition gives a Boolean expression which indicates whether the\n+constraint matches.\n+\n+@deffn {MD Expression} define_constraint name docstring exp\n+The @var{name} and @var{docstring} arguments are the same as for\n+@code{define_register_constraint}, but note that the docstring comes\n+immediately after the name for these expressions.  @var{exp} is an RTL\n+expression, obeying the same rules as the RTL expressions in predicate\n+definitions.  @xref{Defining Predicates}, for details.  If it\n+evaluates true, the constraint matches; if it evaluates false, it\n+doesn't. Constraint expressions should indicate which RTL codes they\n+might match, just like predicate expressions.\n+\n+@code{match_test} C expressions have access to the\n+following variables:\n+\n+@table @var\n+@item op\n+The RTL object defining the operand.\n+@item mode\n+The machine mode of @var{op}.\n+@item ival\n+@samp{INTVAL (@var{op})}, if @var{op} is a @code{const_int}.\n+@item hval\n+@samp{CONST_DOUBLE_HIGH (@var{op})}, if @var{op} is an integer\n+@code{const_double}.\n+@item lval\n+@samp{CONST_DOUBLE_LOW (@var{op})}, if @var{op} is an integer\n+@code{const_double}.\n+@item rval\n+@samp{CONST_DOUBLE_REAL_VALUE (@var{op})}, if @var{op} is a floating-point\n+@code{const_@/double}.\n+@end table\n+\n+The @var{*val} variables should only be used once another piece of the\n+expression has verified that @var{op} is the appropriate kind of RTL\n+object.\n+@end deffn\n+\n+Most non-register constraints should be defined with\n+@code{define_constraint}.  The remaining two definition expressions\n+are only appropriate for constraints that should be handled specially\n+by @code{reload} if they fail to match.\n+\n+@deffn {MD Expression} define_memory_constraint name docstring exp\n+Use this expression for constraints that match a subset of all memory\n+operands: that is, @code{reload} can make them match by converting the\n+operand to the form @samp{@w{(mem (reg @var{X}))}}, where @var{X} is a\n+base register (from the register class specified by\n+@code{BASE_REG_CLASS}, @pxref{Register Classes}).\n+\n+For example, on the S/390, some instructions do not accept arbitrary\n+memory references, but only those that do not make use of an index\n+register.  The constraint letter @samp{Q} is defined to represent a\n+memory address of this type.  If @samp{Q} is defined with\n+@code{define_memory_constraint}, a @samp{Q} constraint can handle any\n+memory operand, because @code{reload} knows it can simply copy the\n+memory address into a base register if required.  This is analogous to\n+the way a @samp{o} constraint can handle any memory operand.\n+\n+The syntax and semantics are otherwise identical to\n+@code{define_constraint}.\n+@end deffn\n+\n+@deffn {MD Expression} define_address_constraint name docstring exp\n+Use this expression for constraints that match a subset of all address\n+operands: that is, @code{reload} can make the constraint match by\n+converting the operand to the form @samp{@w{(reg @var{X})}}, again\n+with @var{X} a base register.\n+\n+Constraints defined with @code{define_address_constraint} can only be\n+used with the @code{address_operand} predicate, or machine-specific\n+predicates that work the same way.  They are treated analogously to\n+the generic @samp{p} constraint.\n+\n+The syntax and semantics are otherwise identical to\n+@code{define_constraint}.\n+@end deffn\n+\n+For historical reasons, names beginning with the letters @samp{G H}\n+are reserved for constraints that match only @code{const_double}s, and\n+names beginning with the letters @samp{I J K L M N O P} are reserved\n+for constraints that match only @code{const_int}s.  This may change in\n+the future.  For the time being, constraints with these names must be\n+written in a stylized form, so that @code{genpreds} can tell you did\n+it correctly:\n+\n+@smallexample\n+@group\n+(define_constraint \"[@var{GHIJKLMNOP}]@dots{}\"\n+  \"@var{doc}@dots{}\"\n+  (and (match_code \"const_int\")  ; @r{@code{const_double} for G/H}\n+       @var{condition}@dots{}))            ; @r{usually a @code{match_test}}\n+@end group\n+@end smallexample\n+@c the semicolons line up in the formatted manual\n+\n+It is fine to use names beginning with other letters for constraints\n+that match @code{const_double}s or @code{const_int}s.\n+\n+Each docstring in a constraint definition should be one or more complete\n+sentences, marked up in Texinfo format.  @emph{They are currently unused.}\n+In the future they will be copied into the GCC manual, in @ref{Machine\n+Constraints}, replacing the hand-maintained tables currently found in\n+that section.  Also, in the future the compiler may use this to give\n+more helpful diagnostics when poor choice of @code{asm} constraints\n+causes a reload failure.\n+\n+If you put the pseudo-Texinfo directive @samp{@@internal} at the\n+beginning of a docstring, then (in the future) it will appear only in\n+the internals manual's version of the machine-specific constraint tables.\n+Use this for constraints that should not appear in @code{asm} statements.\n+\n+@node C Constraint Interface\n+@subsection Testing constraints from C\n+@cindex testing constraints\n+@cindex constraints, testing\n+\n+It is occasionally useful to test a constraint from C code rather than\n+implicitly via the constraint string in a @code{match_operand}.  The\n+generated file @file{tm_p.h} declares a few interfaces for working\n+with machine-specific constraints.  None of these interfaces work with\n+the generic constraints described in @ref{Simple Constraints}.  This\n+may change in the future.\n+\n+@strong{Warning:} @file{tm_p.h} may declare other functions that\n+operate on constraints, besides the ones documented here.  Do not use\n+those functions from machine-dependent code.  They exist to implement\n+the old constraint interface that machine-independent components of\n+the compiler still expect.  They will change or disappear in the\n+future.\n+\n+Some valid constraint names are not valid C identifiers, so there is a\n+mangling scheme for referring to them from C@.  Constraint names that\n+do not contain angle brackets or underscores are left unchanged.\n+Underscores are doubled, each @samp{<} is replaced with @samp{_l}, and\n+each @samp{>} with @samp{_g}.  Here are some examples:\n+\n+@c the @c's prevent double blank lines in the printed manual.\n+@example\n+@multitable {Original} {Mangled}\n+@headitem Original @tab Mangled        @c\n+@item @code{x}     @tab @code{x}       @c\n+@item @code{P42x}  @tab @code{P42x}    @c\n+@item @code{P4_x}  @tab @code{P4__x}   @c\n+@item @code{P4>x}  @tab @code{P4_gx}   @c\n+@item @code{P4>>}  @tab @code{P4_g_g}  @c\n+@item @code{P4_g>} @tab @code{P4__g_g} @c\n+@end multitable\n+@end example\n+\n+Throughout this section, the variable @var{c} is either a constraint\n+in the abstract sense, or a constant from @code{enum constraint_num};\n+the variable @var{m} is a mangled constraint name (usually as part of\n+a larger identifier).\n+\n+@deftp Enum constraint_num\n+For each machine-specific constraint, there is a corresponding\n+enumeration constant: @samp{CONSTRAINT_} plus the mangled name of the\n+constraint.  Functions that take an @code{enum constraint_num} as an\n+argument expect one of these constants.\n+\n+Machine-independent constraints do not have associated constants.\n+This may change in the future.\n+@end deftp\n+\n+@deftypefun {inline bool} satisfies_constraint_@var{m} (rtx @var{exp})\n+For each machine-specific, non-register constraint @var{m}, there is\n+one of these functions; it returns @code{true} if @var{exp} satisfies the\n+constraint.  These functions are only visible if @file{rtl.h} was included\n+before @file{tm_p.h}.\n+@end deftypefun\n+\n+@deftypefun bool constraint_satisfied_p (rtx @var{exp}, enum constraint_num @var{c})\n+Like the @code{satisfies_constraint_@var{m}} functions, but the\n+constraint to test is given as an argument, @var{c}.  If @var{c}\n+specifies a register constraint, this function will always return\n+@code{false}.\n+@end deftypefun\n+\n+@deftypefun {enum reg_class} regclass_for_constraint (enum constraint_num @var{c})\n+Returns the register class associated with @var{c}.  If @var{c} is not\n+a register constraint, or those registers are not available for the\n+currently selected subtarget, returns @code{NO_REGS}.\n+@end deftypefun\n+\n+Here is an example use of @code{satisfies_constraint_@var{m}}.  In\n+peephole optimizations (@pxref{Peephole Definitions}), operand\n+constraint strings are ignored, so if there are relevant constraints,\n+they must be tested in the C condition.  In the example, the\n+optimization is applied if operand 2 does @emph{not} satisfy the\n+@samp{K} constraint.  (This is a simplified version of a peephole\n+definition from the i386 machine description.)\n+\n+@smallexample\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (match_operand:SI 1 \"memory_operand\" \"\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+\n+  \"!satisfies_constraint_K (operands[2])\"\n+\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 0) (mult:SI (match_dup 3) (match_dup 2)))]\n+\n+  \"\")\n+@end smallexample\n+\n @node Standard Names\n @section Standard Pattern Names For Generation\n @cindex standard pattern names"}, {"sha": "778ecc9a9a56a6c85af3c1f45ebff21af5cd5fe7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -33,6 +33,7 @@ through the macros defined in the @file{.h} file.\n * Type Layout::         Defining sizes and properties of basic user data types.\n * Registers::           Naming and describing the hardware registers.\n * Register Classes::    Defining the classes of hardware registers.\n+* Old Constraints::     The old way to define machine-specific constraints.\n * Stack and Calling::   Defining which way the stack grows and by how much.\n * Varargs::\t\tDefining the varargs macros.\n * Trampolines::         Code set up at run time to enter a nested function.\n@@ -2300,36 +2301,6 @@ address where its value is either multiplied by a scale factor or\n added to another register (as well as added to a displacement).\n @end defmac\n \n-@defmac CONSTRAINT_LEN (@var{char}, @var{str})\n-For the constraint at the start of @var{str}, which starts with the letter\n-@var{c}, return the length.  This allows you to have register class /\n-constant / extra constraints that are longer than a single letter;\n-you don't need to define this macro if you can do with single-letter\n-constraints only.  The definition of this macro should use\n-DEFAULT_CONSTRAINT_LEN for all the characters that you don't want\n-to handle specially.\n-There are some sanity checks in genoutput.c that check the constraint lengths\n-for the md file, so you can also use this macro to help you while you are\n-transitioning from a byzantine single-letter-constraint scheme: when you\n-return a negative length for a constraint you want to re-use, genoutput\n-will complain about every instance where it is used in the md file.\n-@end defmac\n-\n-@defmac REG_CLASS_FROM_LETTER (@var{char})\n-A C expression which defines the machine-dependent operand constraint\n-letters for register classes.  If @var{char} is such a letter, the\n-value should be the register class corresponding to it.  Otherwise,\n-the value should be @code{NO_REGS}.  The register letter @samp{r},\n-corresponding to class @code{GENERAL_REGS}, will not be passed\n-to this macro; you do not need to handle it.\n-@end defmac\n-\n-@defmac REG_CLASS_FROM_CONSTRAINT (@var{char}, @var{str})\n-Like @code{REG_CLASS_FROM_LETTER}, but you also get the constraint string\n-passed in @var{str}, so that you can use suffixes to distinguish between\n-different variants.\n-@end defmac\n-\n @defmac REGNO_OK_FOR_BASE_P (@var{num})\n A C expression which is nonzero if register number @var{num} is\n suitable for use as a base register in operand addresses.  It may be\n@@ -2682,8 +2653,45 @@ as below:\n @end smallexample\n @end defmac\n \n-Three other special macros describe which operands fit which constraint\n-letters.\n+@node Old Constraints\n+@section Obsolete Macros for Defining Constraints\n+@cindex defining constraints, obsolete method\n+@cindex constraints, defining, obsolete method\n+\n+Machine-specific constraints can be defined with these macros instead\n+of the machine description constructs described in @ref{Define\n+Constraints}.  This mechanism is obsolete.  New ports should not use\n+it; old ports should convert to the new mechanism.\n+\n+@defmac CONSTRAINT_LEN (@var{char}, @var{str})\n+For the constraint at the start of @var{str}, which starts with the letter\n+@var{c}, return the length.  This allows you to have register class /\n+constant / extra constraints that are longer than a single letter;\n+you don't need to define this macro if you can do with single-letter\n+constraints only.  The definition of this macro should use\n+DEFAULT_CONSTRAINT_LEN for all the characters that you don't want\n+to handle specially.\n+There are some sanity checks in genoutput.c that check the constraint lengths\n+for the md file, so you can also use this macro to help you while you are\n+transitioning from a byzantine single-letter-constraint scheme: when you\n+return a negative length for a constraint you want to re-use, genoutput\n+will complain about every instance where it is used in the md file.\n+@end defmac\n+\n+@defmac REG_CLASS_FROM_LETTER (@var{char})\n+A C expression which defines the machine-dependent operand constraint\n+letters for register classes.  If @var{char} is such a letter, the\n+value should be the register class corresponding to it.  Otherwise,\n+the value should be @code{NO_REGS}.  The register letter @samp{r},\n+corresponding to class @code{GENERAL_REGS}, will not be passed\n+to this macro; you do not need to handle it.\n+@end defmac\n+\n+@defmac REG_CLASS_FROM_CONSTRAINT (@var{char}, @var{str})\n+Like @code{REG_CLASS_FROM_LETTER}, but you also get the constraint string\n+passed in @var{str}, so that you can use suffixes to distinguish between\n+different variants.\n+@end defmac\n \n @defmac CONST_OK_FOR_LETTER_P (@var{value}, @var{c})\n A C expression that defines the machine-dependent operand constraint"}, {"sha": "4eac581872965e30c926c23e72990939cb8d8c00", "filename": "gcc/genoutput.c", "status": "modified", "additions": 174, "deletions": 13, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -54,12 +54,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      a. `predicate', an int-valued function, is the match_operand predicate\n      for this operand.\n \n-     b. `constraint' is the constraint for this operand.  This exists\n-     only if register constraints appear in match_operand rtx's.\n+     b. `constraint' is the constraint for this operand.\n \n      c. `address_p' indicates that the operand appears within ADDRESS\n-     rtx's.  This exists only if there are *no* register constraints\n-     in the match_operand rtx's.\n+     rtx's.\n \n      d. `mode' is the machine mode that that operand is supposed to have.\n \n@@ -189,8 +187,35 @@ static void gen_insn (rtx, int);\n static void gen_peephole (rtx, int);\n static void gen_expand (rtx, int);\n static void gen_split (rtx, int);\n+\n+#ifdef USE_MD_CONSTRAINTS\n+\n+struct constraint_data\n+{\n+  struct constraint_data *next_this_letter;\n+  int lineno;\n+  unsigned int namelen;\n+  const char name[1];\n+};\n+\n+/* This is a complete list (unlike the one in genpreds.c) of constraint\n+   letters and modifiers with machine-independent meaning.  The only\n+   omission is digits, as these are handled specially.  */\n+static const char indep_constraints[] = \",=+%*?!#&<>EFVXgimnoprs\";\n+\n+static struct constraint_data *\n+constraints_by_letter_table[1 << CHAR_BIT];\n+\n+static int mdep_constraint_len (const char *, int, int);\n+static void note_constraint (rtx, int);\n+\n+#else  /* !USE_MD_CONSTRAINTS */\n+\n static void check_constraint_len (void);\n static int constraint_len (const char *, int);\n+\n+#endif /* !USE_MD_CONSTRAINTS */\n+\n \f\n static void\n output_prologue (void)\n@@ -725,6 +750,20 @@ validate_insn_alternatives (struct data *d)\n \n \tfor (p = d->operand[start].constraint; (c = *p); p += len)\n \t  {\n+#ifdef USE_MD_CONSTRAINTS\n+\t    if (ISSPACE (c) || strchr (indep_constraints, c))\n+\t      len = 1;\n+\t    else if (ISDIGIT (c))\n+\t      {\n+\t\tconst char *q = p;\n+\t\tdo\n+\t\t  q++;\n+\t\twhile (ISDIGIT (*q));\n+\t\tlen = q - p;\n+\t      }\n+\t    else\n+\t      len = mdep_constraint_len (p, d->lineno, start);\n+#else\n \t    len = CONSTRAINT_LEN (c, p);\n \n \t    if (len < 1 || (len > 1 && strchr (\",#*+=&%!0123456789\", c)))\n@@ -735,6 +774,7 @@ validate_insn_alternatives (struct data *d)\n \t\tlen = 1;\n \t\thave_error = 1;\n \t      }\n+#endif\n \n \t    if (c == ',')\n \t      {\n@@ -826,7 +866,9 @@ gen_insn (rtx insn, int lineno)\n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n \n+#ifndef USE_MD_CONSTRAINTS\n   check_constraint_len ();\n+#endif\n   validate_insn_operands (d);\n   validate_insn_alternatives (d);\n   place_operands (d);\n@@ -983,15 +1025,37 @@ main (int argc, char **argv)\n       if (desc == NULL)\n \tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_INSN)\n-\tgen_insn (desc, line_no);\n-      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n-\tgen_peephole (desc, line_no);\n-      if (GET_CODE (desc) == DEFINE_EXPAND)\n-\tgen_expand (desc, line_no);\n-      if (GET_CODE (desc) == DEFINE_SPLIT\n-\t  || GET_CODE (desc) == DEFINE_PEEPHOLE2)\n-\tgen_split (desc, line_no);\n+      switch (GET_CODE (desc))\n+\t{\n+\tcase DEFINE_INSN:\n+\t  gen_insn (desc, line_no);\n+\t  break;\n+\n+\tcase DEFINE_PEEPHOLE:\n+\t  gen_peephole (desc, line_no);\n+\t  break;\n+\n+\tcase DEFINE_EXPAND:\n+\t  gen_expand (desc, line_no);\n+\t  break;\n+\n+\tcase DEFINE_SPLIT:\n+\tcase DEFINE_PEEPHOLE2:\n+\t  gen_split (desc, line_no);\n+\t  break;\n+\n+#ifdef USE_MD_CONSTRAINTS\n+\tcase DEFINE_CONSTRAINT:\n+\tcase DEFINE_REGISTER_CONSTRAINT:\n+\tcase DEFINE_ADDRESS_CONSTRAINT:\n+\tcase DEFINE_MEMORY_CONSTRAINT:\n+\t  note_constraint (desc, line_no);\n+\t  break;\n+#endif\n+\n+\tdefault:\n+\t  break;\n+\t}\n       next_index_number++;\n     }\n \n@@ -1043,6 +1107,102 @@ strip_whitespace (const char *s)\n   return q;\n }\n \n+#ifdef USE_MD_CONSTRAINTS\n+\n+/* Record just enough information about a constraint to allow checking\n+   of operand constraint strings above, in validate_insn_alternatives.\n+   Does not validate most properties of the constraint itself; does\n+   enforce no duplicate names, no overlap with MI constraints, and no\n+   prefixes.  EXP is the define_*constraint form, LINENO the line number\n+   reported by the reader.  */\n+static void\n+note_constraint (rtx exp, int lineno)\n+{\n+  const char *name = XSTR (exp, 0);\n+  unsigned int namelen = strlen (name);\n+  struct constraint_data **iter, **slot, *new;\n+\n+  if (strchr (indep_constraints, name[0]))\n+    {\n+      if (name[1] == '\\0')\n+\tmessage_with_line (lineno, \"constraint letter '%s' cannot be \"\n+\t\t\t   \"redefined by the machine description\", name);\n+      else\n+\tmessage_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n+\t\t\t   \"the machine description, as it begins with '%c'\",\n+\t\t\t   name, name[0]);\n+      have_error = 1;\n+      return;\n+    }\n+\n+  slot = &constraints_by_letter_table[(unsigned int)name[0]];\n+  for (iter = slot; *iter; iter = &(*iter)->next_this_letter)\n+    {\n+      /* This causes slot to end up pointing to the\n+\t next_this_letter field of the last constraint with a name\n+\t of equal or greater length than the new constraint; hence\n+\t the new constraint will be inserted after all previous\n+\t constraints with names of the same length.  */\n+      if ((*iter)->namelen >= namelen)\n+\tslot = iter;\n+\n+      if (!strcmp ((*iter)->name, name))\n+\t{\n+\t  message_with_line (lineno, \"redefinition of constraint '%s'\", name);\n+\t  message_with_line ((*iter)->lineno, \"previous definition is here\");\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+      else if (!strncmp ((*iter)->name, name, (*iter)->namelen))\n+\t{\n+\t  message_with_line (lineno, \"defining constraint '%s' here\", name);\n+\t  message_with_line ((*iter)->lineno, \"renders constraint '%s' \"\n+\t\t\t     \"(defined here) a prefix\", (*iter)->name);\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+      else if (!strncmp ((*iter)->name, name, namelen))\n+\t{\n+\t  message_with_line (lineno, \"constraint '%s' is a prefix\", name);\n+\t  message_with_line ((*iter)->lineno, \"of constraint '%s' \"\n+\t\t\t     \"(defined here)\", (*iter)->name);\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+    }\n+  new = xmalloc (sizeof (struct constraint_data) + namelen);\n+  strcpy ((char *)new + offsetof(struct constraint_data, name), name);\n+  new->namelen = namelen;\n+  new->lineno = lineno;\n+  new->next_this_letter = *slot;\n+  *slot = new;\n+}\n+\n+/* Return the length of the constraint name beginning at position S\n+   of an operand constraint string, or issue an error message if there\n+   is no such constraint.  Does not expect to be called for generic\n+   constraints.  */\n+static int\n+mdep_constraint_len (const char *s, int lineno, int opno)\n+{\n+  struct constraint_data *p;\n+\n+  p = constraints_by_letter_table[(unsigned int)s[0]];\n+\n+  if (p)\n+    for (; p; p = p->next_this_letter)\n+      if (!strncmp (s, p->name, p->namelen))\n+\treturn p->namelen;\n+\n+  message_with_line (lineno,\n+\t\t     \"error: undefined machine-specific constraint \"\n+\t\t     \"at this point: \\\"%s\\\"\", s);\n+  message_with_line (lineno, \"note:  in operand %d\", opno);\n+  have_error = 1;\n+  return 1; /* safe */\n+}\n+\n+#else\n /* Verify that DEFAULT_CONSTRAINT_LEN is used properly and not\n    tampered with.  This isn't bullet-proof, but it should catch\n    most genuine mistakes.  */\n@@ -1076,3 +1236,4 @@ constraint_len (const char *p, int genoutput_default_constraint_len)\n #undef DEFAULT_CONSTRAINT_LEN\n #define DEFAULT_CONSTRAINT_LEN(C,STR) 1\n }\n+#endif"}, {"sha": "9c0bb352e17a5927c25dcce8fe81cf3825282155", "filename": "gcc/genpreds.c", "status": "modified", "additions": 826, "deletions": 59, "changes": 885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -27,57 +27,102 @@ Boston, MA 02110-1301, USA.  */\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n-#include \"gensupport.h\"\n #include \"obstack.h\"\n+#include \"gensupport.h\"\n \n-/* The new way to declare predicates is with (define_predicate) or\n-   (define_special_predicate) expressions in the machine description.\n-   This provides a function body as well as a name.  */\n-static void\n-process_define_predicate (rtx defn)\n+/* Given a predicate expression EXP, from form NAME at line LINENO,\n+   verify that it does not contain any RTL constructs which are not\n+   valid in predicate definitions.  Returns true if EXP is\n+   INvalid; issues error messages, caller need not.  */\n+static bool\n+validate_exp (rtx exp, const char *name, int lineno)\n {\n-  struct pred_data *pred;\n-  if (XEXP (defn, 1) == 0)\n+  if (exp == 0)\n     {\n-      error (\"%s: must give a predicate expression\", XSTR (defn, 0));\n-      return;\n+      message_with_line (lineno, \"%s: must give a predicate expression\", name);\n+      return true;\n     }\n \n-  pred = XCNEW (struct pred_data);\n-  pred->name    = XSTR (defn, 0);\n-  pred->exp     = XEXP (defn, 1);\n-  pred->c_block = XSTR (defn, 2);\n+  switch (GET_CODE (exp))\n+    {\n+      /* Ternary, binary, unary expressions: recurse into subexpressions.  */\n+    case IF_THEN_ELSE:\n+      if (validate_exp (XEXP (exp, 2), name, lineno))\n+\treturn true;\n+      /* else fall through */\n+    case AND:\n+    case IOR:\n+      if (validate_exp (XEXP (exp, 1), name, lineno))\n+\treturn true;\n+      /* else fall through */\n+    case NOT:\n+      return validate_exp (XEXP (exp, 0), name, lineno);\n \n-  if (GET_CODE (defn) == DEFINE_SPECIAL_PREDICATE)\n-    pred->special = true;\n+      /* MATCH_CODE might have a syntax error in its path expression.  */\n+    case MATCH_CODE:\n+      {\n+\tconst char *p;\n+\tfor (p = XSTR (exp, 1); *p; p++)\n+\t  {\n+\t    if (!ISDIGIT (*p) && !ISLOWER (*p))\n+\t      {\n+\t\tmessage_with_line (lineno, \"%s: invalid character in path \"\n+\t\t\t\t   \"string '%s'\", name, XSTR (exp, 1));\n+\t\thave_error = 1;\n+\t\treturn true;\n+\t      }\n+\t  }\n+      }\n+      /* fall through */\n \n-  add_predicate (pred);\n+      /* These need no special checking.  */\n+    case MATCH_OPERAND:\n+    case MATCH_TEST:\n+      return false;\n+\n+    default:\n+      message_with_line (lineno,\n+\t\t\t \"%s: cannot use '%s' in a predicate expression\",\n+\t\t\t name, GET_RTX_NAME (GET_CODE (exp)));\n+      have_error = 1;\n+      return true;\n+    }\n }\n \n-/* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare\n-   an enumeration in portable C, so we have to condition all these\n-   prototypes on HAVE_MACHINE_MODES.  */\n+/* Predicates are defined with (define_predicate) or\n+   (define_special_predicate) expressions in the machine description.  */\n static void\n-write_tm_preds_h (void)\n+process_define_predicate (rtx defn, int lineno)\n {\n-  struct pred_data *p;\n+  struct pred_data *pred;\n+  const char *p;\n \n-  printf (\"\\\n-/* Generated automatically by the program '%s'\\n\\\n-   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+  if (!ISALPHA (XSTR (defn, 0)[0]) && XSTR (defn, 0)[0] != '_')\n+    goto bad_name;\n+  for (p = XSTR (defn, 0) + 1; *p; p++)\n+    if (!ISALNUM (*p) && *p != '_')\n+      goto bad_name;\n+  \n+  if (validate_exp (XEXP (defn, 1), XSTR (defn, 0), lineno))\n+    return;\n \n-  puts (\"\\\n-#ifndef GCC_TM_PREDS_H\\n\\\n-#define GCC_TM_PREDS_H\\n\\\n-\\n\\\n-#ifdef HAVE_MACHINE_MODES\");\n+  pred = XCNEW (struct pred_data);\n+  pred->name = XSTR (defn, 0);\n+  pred->exp = XEXP (defn, 1);\n+  pred->c_block = XSTR (defn, 2);\n \n-  FOR_ALL_PREDICATES (p)\n-    printf (\"extern int %s (rtx, enum machine_mode);\\n\", p->name);\n+  if (GET_CODE (defn) == DEFINE_SPECIAL_PREDICATE)\n+    pred->special = true;\n \n-  puts (\"\\\n-#endif /* HAVE_MACHINE_MODES */\\n\\\n-#endif /* tm-preds.h */\");\n+  add_predicate (pred);\n+  return;\n+\n+ bad_name:\n+  message_with_line (lineno,\n+\t\t     \"%s: predicate name must be a valid C function name\",\n+\t\t     XSTR (defn, 0));\n+  have_error = 1;\n+  return;\n }\n \n /* Given a predicate, if it has an embedded C block, write the block\n@@ -146,6 +191,59 @@ write_predicate_subfunction (struct pred_data *p)\n   fputs (\"\\n\\n\", stdout);\n }\n \n+/* Given a predicate expression EXP, from form NAME, determine whether\n+   it refers to the variable given as VAR.  */\n+static bool\n+needs_variable (rtx exp, const char *var)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+      /* Ternary, binary, unary expressions need a variable if\n+\t any of their subexpressions do.  */\n+    case IF_THEN_ELSE:\n+      if (needs_variable (XEXP (exp, 2), var))\n+\treturn true;\n+      /* else fall through */\n+    case AND:\n+    case IOR:\n+      if (needs_variable (XEXP (exp, 1), var))\n+\treturn true;\n+      /* else fall through */\n+    case NOT:\n+      return needs_variable (XEXP (exp, 0), var);\n+\n+      /* MATCH_CODE uses \"op\", but nothing else.  */\n+    case MATCH_CODE:\n+      return !strcmp (var, \"op\");\n+\n+      /* MATCH_OPERAND uses \"op\" and may use \"mode\".  */\n+    case MATCH_OPERAND:\n+      if (!strcmp (var, \"op\"))\n+\treturn true;\n+      if (!strcmp (var, \"mode\") && GET_MODE (exp) == VOIDmode)\n+\treturn true;\n+      return false;\n+\n+      /* MATCH_TEST uses var if XSTR (exp, 0) =~ /\\b${var}\\b/o; */\n+    case MATCH_TEST:\n+      {\n+\tconst char *p = XSTR (exp, 0);\n+\tconst char *q = strstr (p, var);\n+\tif (!q)\n+\t  return false;\n+\tif (q != p && (ISALNUM (q[-1]) || q[-1] == '_'))\n+\t  return false;\n+\tq += strlen (var);\n+\tif (ISALNUM (q[0] || q[0] == '_'))\n+\t  return false;\n+      }\n+      return true;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Given an RTL expression EXP, find all subexpressions which we may\n    assume to perform mode tests.  Normal MATCH_OPERAND does;\n    MATCH_CODE does if it applies to the whole expression and accepts\n@@ -214,8 +312,7 @@ mark_mode_tests (rtx exp)\n       break;\n \n     default:\n-      error (\"'%s' cannot be used in a define_predicate expression\",\n-\t     GET_RTX_NAME (GET_CODE (exp)));\n+      gcc_unreachable ();\n     }\n }\n \n@@ -325,10 +422,7 @@ write_extract_subexp (const char *path)\n       else if (ISDIGIT (path[i]))\n \tfputs (\"XEXP (\", stdout);\n       else\n-\t{\n-\t  error (\"bad character in path string '%s'\", path);\n-\t  return;\n-\t}\n+\tgcc_unreachable ();\n     }\n \n   fputs (\"op\", stdout);\n@@ -370,39 +464,39 @@ write_match_code (const char *path, const char *codes)\n /* EXP is an RTL (sub)expression for a predicate.  Recursively\n    descend the expression and write out an equivalent C expression.  */\n static void\n-write_predicate_expr (const char *name, rtx exp)\n+write_predicate_expr (rtx exp)\n {\n   switch (GET_CODE (exp))\n     {\n     case AND:\n       putchar ('(');\n-      write_predicate_expr (name, XEXP (exp, 0));\n+      write_predicate_expr (XEXP (exp, 0));\n       fputs (\") && (\", stdout);\n-      write_predicate_expr (name, XEXP (exp, 1));\n+      write_predicate_expr (XEXP (exp, 1));\n       putchar (')');\n       break;\n   \n     case IOR:\n       putchar ('(');\n-      write_predicate_expr (name, XEXP (exp, 0));\n+      write_predicate_expr (XEXP (exp, 0));\n       fputs (\") || (\", stdout);\n-      write_predicate_expr (name, XEXP (exp, 1));\n+      write_predicate_expr (XEXP (exp, 1));\n       putchar (')');\n       break;\n \n     case NOT:\n       fputs (\"!(\", stdout);\n-      write_predicate_expr (name, XEXP (exp, 0));\n+      write_predicate_expr (XEXP (exp, 0));\n       putchar (')');\n       break;\n \n     case IF_THEN_ELSE:\n       putchar ('(');\n-      write_predicate_expr (name, XEXP (exp, 0));\n+      write_predicate_expr (XEXP (exp, 0));\n       fputs (\") ? (\", stdout);\n-      write_predicate_expr (name, XEXP (exp, 1));\n+      write_predicate_expr (XEXP (exp, 1));\n       fputs (\") : (\", stdout);\n-      write_predicate_expr (name, XEXP (exp, 2));\n+      write_predicate_expr (XEXP (exp, 2));\n       putchar (')');\n       break;\n \n@@ -422,9 +516,7 @@ write_predicate_expr (const char *name, rtx exp)\n       break;\n \n     default:\n-      error (\"%s: cannot use '%s' in a predicate expression\",\n-\t     name, GET_RTX_NAME (GET_CODE (exp)));\n-      putchar ('0');\n+      gcc_unreachable ();\n     }\n }\n \n@@ -443,9 +535,651 @@ write_one_predicate_function (struct pred_data *p)\n   printf (\"int\\n%s (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n\"\n \t  \"{\\n  return \",\n \t  p->name);\n-  write_predicate_expr (p->name, p->exp);\n+  write_predicate_expr (p->exp);\n   fputs (\";\\n}\\n\\n\", stdout);\n }\n+\f\n+/* Constraints fall into two categories: register constraints\n+   (define_register_constraint), and others (define_constraint,\n+   define_memory_constraint, define_address_constraint).  We\n+   work out automatically which of the various old-style macros\n+   they correspond to, and produce appropriate code.  They all\n+   go in the same hash table so we can verify that there are no\n+   duplicate names.  */\n+\n+/* All data from one constraint definition.  */\n+struct constraint_data\n+{\n+  struct constraint_data *next_this_letter;\n+  struct constraint_data *next_textual;\n+  const char *name;\n+  const char *c_name;    /* same as .name unless mangling is necessary */\n+  size_t namelen;\n+  const char *regclass;  /* for register constraints */\n+  rtx exp;               /* for other constraints */\n+  unsigned int lineno;   /* line of definition */\n+  unsigned int is_register  : 1;\n+  unsigned int is_const_int : 1;\n+  unsigned int is_const_dbl : 1;\n+  unsigned int is_extra     : 1;\n+  unsigned int is_memory    : 1;\n+  unsigned int is_address   : 1;\n+};\n+\n+/* Overview of all constraints beginning with a given letter.  */\n+\n+static struct constraint_data *\n+constraints_by_letter_table[1<<CHAR_BIT];\n+\n+/* For looking up all the constraints in the order that they appeared\n+   in the machine description.  */\n+static struct constraint_data *first_constraint;\n+static struct constraint_data **last_constraint_ptr = &first_constraint;\n+\n+#define FOR_ALL_CONSTRAINTS(iter_) \\\n+  for (iter_ = first_constraint; iter_; iter_ = iter_->next_textual)\n+\n+/* These letters, and all names beginning with them, are reserved for\n+   generic constraints.  */\n+static const char generic_constraint_letters[] = \"EFVXgimnoprs\";\n+\n+/* Machine-independent code expects that constraints with these\n+   (initial) letters will allow only (a subset of all) CONST_INTs.  */\n+\n+static const char const_int_constraints[] = \"IJKLMNOP\";\n+\n+/* Machine-independent code expects that constraints with these\n+   (initial) letters will allow only (a subset of all) CONST_DOUBLEs.  */\n+\n+static const char const_dbl_constraints[] = \"GH\";\n+\n+/* Summary data used to decide whether to output various functions and\n+   macro definitions.  */\n+static unsigned int constraint_max_namelen;\n+static bool have_register_constraints;\n+static bool have_memory_constraints;\n+static bool have_address_constraints;\n+static bool have_extra_constraints;\n+static bool have_const_int_constraints;\n+static bool have_const_dbl_constraints;\n+\n+/* Convert NAME, which contains angle brackets and/or underscores, to\n+   a string that can be used as part of a C identifier.  The string\n+   comes from the rtl_obstack.  */\n+static const char *\n+mangle (const char *name)\n+{\n+  for (; *name; name++)\n+    switch (*name)\n+      {\n+      case '_': obstack_grow (rtl_obstack, \"__\", 2); break;\n+      case '<':\tobstack_grow (rtl_obstack, \"_l\", 2); break;\n+      case '>':\tobstack_grow (rtl_obstack, \"_g\", 2); break;\n+      default: obstack_1grow (rtl_obstack, *name); break;\n+      }\n+\n+  obstack_1grow (rtl_obstack, '\\0');\n+  return obstack_finish (rtl_obstack);\n+}\n+\n+/* Add one constraint, of any sort, to the tables.  NAME is its name;\n+   REGCLASS is the register class, if any; EXP is the expression to\n+   test, if any;  IS_MEMORY and IS_ADDRESS indicate memory and address\n+   constraints, respectively; LINENO is the line number from the MD reader.\n+   Not all combinations of arguments are valid; most importantly, REGCLASS\n+   is mutually exclusive with EXP, and IS_MEMORY/IS_ADDRESS are only\n+   meaningful for constraints with EXP.\n+\n+   This function enforces all syntactic and semantic rules about what\n+   constraints can be defined.  */\n+\n+static void\n+add_constraint (const char *name, const char *regclass,\n+\t\trtx exp, bool is_memory, bool is_address,\n+\t\tint lineno)\n+{\n+  struct constraint_data *c, **iter, **slot;\n+  const char *p;\n+  bool need_mangled_name = false;\n+  bool is_const_int;\n+  bool is_const_dbl;\n+  size_t namelen;\n+\n+  if (exp && validate_exp (exp, name, lineno))\n+    return;\n+\n+  if (!ISALPHA (name[0]) && name[0] != '_')\n+    {\n+      if (name[1] == '\\0')\n+\tmessage_with_line (lineno, \"constraint name '%s' is not \"\n+\t\t\t   \"a letter or underscore\", name);\n+      else\n+\tmessage_with_line (lineno, \"constraint name '%s' does not begin \"\n+\t\t\t   \"with a letter or underscore\", name);\n+      have_error = 1;\n+      return;\n+    }\n+  for (p = name; *p; p++)\n+    if (!ISALNUM (*p))\n+      {\n+\tif (*p == '<' || *p == '>' || *p == '_')\n+\t  need_mangled_name = true;\n+\telse\n+\t  {\n+\t    message_with_line (lineno,\n+\t\t\t       \"constraint name '%s' must be composed of \"\n+\t\t\t       \"letters, digits, underscores, and \"\n+\t\t\t       \"angle brackets\", name);\n+\t    have_error = 1;\n+\t    return;\n+\t  }\n+      }\n+\n+  if (strchr (generic_constraint_letters, name[0]))\n+    {\n+      if (name[1] == '\\0')\n+\tmessage_with_line (lineno, \"constraint letter '%s' cannot be \"\n+\t\t\t   \"redefined by the machine description\", name);\n+      else\n+\tmessage_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n+\t\t\t   \"the machine description, as it begins with '%c'\",\n+\t\t\t   name, name[0]);\n+      have_error = 1;\n+      return;\n+    }\n+\n+  \n+  namelen = strlen (name);\n+  slot = &constraints_by_letter_table[(unsigned int)name[0]];\n+  for (iter = slot; *iter; iter = &(*iter)->next_this_letter)\n+    {\n+      /* This causes slot to end up pointing to the\n+\t next_this_letter field of the last constraint with a name\n+\t of equal or greater length than the new constraint; hence\n+\t the new constraint will be inserted after all previous\n+\t constraints with names of the same length.  */\n+      if ((*iter)->namelen >= namelen)\n+\tslot = iter;\n+\n+      if (!strcmp ((*iter)->name, name))\n+\t{\n+\t  message_with_line (lineno, \"redefinition of constraint '%s'\", name);\n+\t  message_with_line ((*iter)->lineno, \"previous definition is here\");\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+      else if (!strncmp ((*iter)->name, name, (*iter)->namelen))\n+\t{\n+\t  message_with_line (lineno, \"defining constraint '%s' here\", name);\n+\t  message_with_line ((*iter)->lineno, \"renders constraint '%s' \"\n+\t\t\t     \"(defined here) a prefix\", (*iter)->name);\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+      else if (!strncmp ((*iter)->name, name, namelen))\n+\t{\n+\t  message_with_line (lineno, \"constraint '%s' is a prefix\", name);\n+\t  message_with_line ((*iter)->lineno, \"of constraint '%s' \"\n+\t\t\t     \"(defined here)\", (*iter)->name);\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+    }\n+\n+  is_const_int = strchr (const_int_constraints, name[0]) != 0;\n+  is_const_dbl = strchr (const_dbl_constraints, name[0]) != 0;\n+\n+  if (is_const_int || is_const_dbl)\n+    {\n+      enum rtx_code appropriate_code\n+\t= is_const_int ? CONST_INT : CONST_DOUBLE;\n+\n+      /* Consider relaxing this requirement in the future.  */\n+      if (regclass\n+\t  || GET_CODE (exp) != AND\n+\t  || GET_CODE (XEXP (exp, 0)) != MATCH_CODE\n+\t  || strcmp (XSTR (XEXP (exp, 0), 0),\n+\t\t     GET_RTX_NAME (appropriate_code)))\n+\t{\n+\t  if (name[1] == '\\0')\n+\t    message_with_line (lineno, \"constraint letter '%c' is reserved \"\n+\t\t\t       \"for %s constraints\",\n+\t\t\t       name[0], GET_RTX_NAME (appropriate_code));\n+\t  else\n+\t    message_with_line (lineno, \"constraint names beginning with '%c' \"\n+\t\t\t       \"(%s) are reserved for %s constraints\",\n+\t\t\t       name[0], name, \n+\t\t\t       GET_RTX_NAME (appropriate_code));\n+\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+\n+      if (is_memory)\n+\t{\n+\t  if (name[1] == '\\0')\n+\t    message_with_line (lineno, \"constraint letter '%c' cannot be a \"\n+\t\t\t       \"memory constraint\", name[0]);\n+\t  else\n+\t    message_with_line (lineno, \"constraint name '%s' begins with '%c', \"\n+\t\t\t       \"and therefore cannot be a memory constraint\",\n+\t\t\t       name, name[0]);\n+\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+      else if (is_address)\n+\t{\n+\t  if (name[1] == '\\0')\n+\t    message_with_line (lineno, \"constraint letter '%c' cannot be a \"\n+\t\t\t       \"memory constraint\", name[0]);\n+\t  else\n+\t    message_with_line (lineno, \"constraint name '%s' begins with '%c', \"\n+\t\t\t       \"and therefore cannot be a memory constraint\",\n+\t\t\t       name, name[0]);\n+\n+\t  have_error = 1;\n+\t  return;\n+\t}\n+\n+      /* Remove the redundant (and (match_code \"const_(int|double)\")\n+\t from the expression.  */\n+      exp = XEXP (exp, 1);\n+    }\n+\n+  \n+  c = obstack_alloc (rtl_obstack, sizeof (struct constraint_data));\n+  c->name = name;\n+  c->c_name = need_mangled_name ? mangle (name) : name;\n+  c->lineno = lineno;\n+  c->namelen = namelen;\n+  c->regclass = regclass;\n+  c->exp = exp;\n+  c->is_register = regclass != 0;\n+  c->is_const_int = is_const_int;\n+  c->is_const_dbl = is_const_dbl;\n+  c->is_extra = !(regclass || is_const_int || is_const_dbl);\n+  c->is_memory = is_memory;\n+  c->is_address = is_address;\n+\n+  c->next_this_letter = *slot;\n+  *slot = c;\n+\n+  /* Insert this constraint in the list of all constraints in textual\n+     order.  */\n+  c->next_textual = 0;\n+  *last_constraint_ptr = c;\n+  last_constraint_ptr = &c->next_textual;\n+\n+  constraint_max_namelen = MAX (constraint_max_namelen, strlen (name));\n+  have_register_constraints |= c->is_register;\n+  have_const_int_constraints |= c->is_const_int;\n+  have_const_dbl_constraints |= c->is_const_dbl;\n+  have_extra_constraints |= c->is_extra;\n+  have_memory_constraints |= c->is_memory;\n+  have_address_constraints |= c->is_address;\n+}\n+\n+/* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT, or\n+   DEFINE_ADDRESS_CONSTRAINT expression, C.  */\n+static void\n+process_define_constraint (rtx c, int lineno)\n+{\n+  add_constraint (XSTR (c, 0), 0, XEXP (c, 2),\n+\t\t  GET_CODE (c) == DEFINE_MEMORY_CONSTRAINT,\n+\t\t  GET_CODE (c) == DEFINE_ADDRESS_CONSTRAINT,\n+\t\t  lineno);\n+}\n+\n+/* Process a DEFINE_REGISTER_CONSTRAINT expression, C.  */\n+static void\n+process_define_register_constraint (rtx c, int lineno)\n+{\n+  add_constraint (XSTR (c, 0), XSTR (c, 1), 0, false, false, lineno);\n+}\n+\n+/* Write out an enumeration with one entry per machine-specific\n+   constraint.  */\n+static void\n+write_enum_constraint_num (void)\n+{\n+  struct constraint_data *c;\n+\n+  fputs (\"enum constraint_num\\n\"\n+\t \"{\\n\"\n+\t \"  CONSTRAINT__UNKNOWN = 0\", stdout);\n+  FOR_ALL_CONSTRAINTS (c)\n+    printf (\",\\n  CONSTRAINT_%s\", c->c_name);\n+  puts (\"\\n};\\n\");\n+}\n+\n+/* Write out a function which looks at a string and determines what\n+   constraint name, if any, it begins with.  */\n+static void\n+write_lookup_constraint (void)\n+{\n+  unsigned int i;\n+  puts (\"enum constraint_num\\n\"\n+\t\"lookup_constraint (const char *str)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (str[0])\\n\"\n+\t\"    {\");\n+\n+  for (i = 0; i < ARRAY_SIZE(constraints_by_letter_table); i++)\n+    {\n+      struct constraint_data *c = constraints_by_letter_table[i];\n+      if (!c)\n+\tcontinue;\n+\n+      printf (\"    case '%c':\\n\", i);\n+      if (c->namelen == 1)\n+\tprintf (\"      return CONSTRAINT_%s;\\n\", c->c_name);\n+      else\n+\t{\n+\t  do\n+\t    {\n+\t      printf (\"      if (!strncmp (str, \\\"%s\\\", %lu))\\n\"\n+\t\t      \"        return CONSTRAINT_%s;\\n\",\n+\t\t      c->name, (unsigned long int) c->namelen, c->c_name);\n+\t      c = c->next_this_letter;\n+\t    }\n+\t  while (c);\n+\t  puts (\"      break;\");\n+\t}\n+    }\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return CONSTRAINT__UNKNOWN;\\n\"\n+\t\"}\\n\");\n+}\n+\n+/* Write out the function which computes constraint name lengths from\n+   their enumerators. */\n+static void\n+write_insn_constraint_len (void)\n+{\n+  struct constraint_data *c;\n+\n+  if (constraint_max_namelen == 1)\n+    return;\n+\n+  puts (\"unsigned int\\n\"\n+\t\"insn_constraint_len (enum constraint_num c)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (c)\\n\"\n+\t\"    {\");\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->namelen > 1)\n+      printf (\"    case CONSTRAINT_%s: return %lu;\\n\", c->c_name,\n+\t      (unsigned long int) c->namelen);\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return 1;\\n\"\n+\t\"}\\n\");\n+}\n+  \n+/* Write out the function which computes the register class corresponding\n+   to a register constraint.  */\n+static void\n+write_regclass_for_constraint (void)\n+{\n+  struct constraint_data *c;\n+\n+  puts (\"enum reg_class\\n\"\n+\t\"regclass_for_constraint (enum constraint_num c)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (c)\\n\"\n+\t\"    {\");\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_register)\n+      printf (\"    case CONSTRAINT_%s: return %s;\\n\", c->c_name, c->regclass);\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return NO_REGS;\\n\"\n+\t\"}\\n\");\n+}\n+\n+/* Write out the functions which compute whether a given value matches\n+   a given non-register constraint.  */\n+static void\n+write_satisfies_constraint_fns (void)\n+{\n+  struct constraint_data *c;\n+\n+  /* A fair number of places include tm_p.h without including rtl.h.  */\n+  puts (\"#ifdef GCC_RTL_H\\n\");\n+  \n+  FOR_ALL_CONSTRAINTS (c)\n+    if (!c->is_register)\n+      {\n+\tbool needs_ival = needs_variable (c->exp, \"ival\");\n+\tbool needs_hval = needs_variable (c->exp, \"hval\");\n+\tbool needs_lval = needs_variable (c->exp, \"lval\");\n+\tbool needs_rval = needs_variable (c->exp, \"rval\");\n+\tbool needs_mode = (needs_variable (c->exp, \"mode\")\n+\t\t\t   || needs_hval || needs_lval || needs_rval);\n+\n+\tprintf (\"static inline bool\\n\"\n+\t\t\"satisfies_constraint_%s (rtx op)\\n\"\n+\t\t\"{\\n\", c->c_name);\n+\tif (needs_mode)\n+\t  puts (\"enum machine_mode mode = GET_MODE (op);\");\n+\tif (needs_ival)\n+\t  puts (\"  HOST_WIDE_INT ival = 0;\");\n+\tif (needs_hval)\n+\t  puts (\"  HOST_WIDE_INT hval = 0;\");\n+\tif (needs_lval)\n+\t  puts (\"  unsigned HOST_WIDE_INT lval = 0;\");\n+\tif (needs_rval)\n+\t  puts (\"  const REAL_VALUE_TYPE *rval = 0;\");\n+\n+\tif (needs_ival)\n+\t  puts (\"  if (GET_CODE (op) == CONST_INT)\\n\"\n+\t\t\"    ival = INTVAL (op);\");\n+\tif (needs_hval)\n+\t  puts (\"  if (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode)\"\n+\t\t\"    hval = CONST_DOUBLE_HIGH (op);\");\n+\tif (needs_lval)\n+\t  puts (\"  if (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode)\"\n+\t\t\"    lval = CONST_DOUBLE_LOW (op);\");\n+\tif (needs_rval)\n+\t  puts (\"  if (GET_CODE (op) == CONST_DOUBLE && mode != VOIDmode)\"\n+\t\t\"    rval = CONST_DOUBLE_REAL_VALUE (op);\");\n+\t  \n+\tfputs (\"  return \", stdout);\n+\twrite_predicate_expr (c->exp);\n+\tfputs (\";\\n}\\n\", stdout);\n+      }\n+\n+  puts (\"\\n#endif /* rtl.h visible */\\n\");\n+}\n+\n+/* Write out the wrapper function, constraint_satisfied_p, that maps\n+   a CONSTRAINT_xxx constant to one of the predicate functions generated\n+   above.  */\n+static void\n+write_constraint_satisfied_p (void)\n+{\n+  struct constraint_data *c;\n+\n+  puts (\"bool\\n\"\n+\t\"constraint_satisfied_p (rtx op, enum constraint_num c)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (c)\\n\"\n+\t\"    {\");\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (!c->is_register)\n+      printf (\"    case CONSTRAINT_%s: \"\n+\t      \"return satisfies_constraint_%s (op);\\n\",\n+\t      c->c_name, c->c_name);\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return false;\\n\"\n+\t\"}\\n\");\n+}\n+\n+/* Write out the function which computes whether a given value matches\n+   a given CONST_INT constraint.  This doesn't just forward to\n+   constraint_satisfied_p because caller passes the INTVAL, not the RTX.  */\n+static void\n+write_insn_const_int_ok_for_constraint (void)\n+{\n+  struct constraint_data *c;\n+\n+  puts (\"bool\\n\"\n+\t\"insn_const_int_ok_for_constraint (HOST_WIDE_INT ival, \"\n+\t                                  \"enum constraint_num c)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (c)\\n\"\n+\t\"    {\");\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_const_int)\n+      {\n+\tprintf (\"    case CONSTRAINT_%s:\\n      return \", c->c_name);\n+\twrite_predicate_expr (c->exp);\n+\tfputs (\";\\n\\n\", stdout);\n+      }\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return false;\\n\"\n+\t\"}\\n\");\n+}\n+\n+\n+/* Write out the function which computes whether a given constraint is\n+   a memory constraint.  */\n+static void\n+write_insn_extra_memory_constraint (void)\n+{\n+  struct constraint_data *c;\n+\n+  puts (\"bool\\n\"\n+\t\"insn_extra_memory_constraint (enum constraint_num c)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (c)\\n\"\n+\t\"    {\");\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_memory)\n+      printf (\"    case CONSTRAINT_%s:\\n      return true;\\n\\n\", c->c_name);\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return false;\\n\"\n+\t\"}\\n\");\n+}\n+\n+/* Write out the function which computes whether a given constraint is\n+   an address constraint.  */\n+static void\n+write_insn_extra_address_constraint (void)\n+{\n+  struct constraint_data *c;\n+\n+  puts (\"bool\\n\"\n+\t\"insn_extra_address_constraint (enum constraint_num c)\\n\"\n+\t\"{\\n\"\n+\t\"  switch (str[0])\\n\"\n+\t\"    {\");\n+\n+  FOR_ALL_CONSTRAINTS (c)\n+    if (c->is_address)\n+      printf (\"    case CONSTRAINT_%s:\\n      return true;\\n\\n\", c->c_name);\n+\n+  puts (\"    default: break;\\n\"\n+\t\"    }\\n\"\n+\t\"  return false;\\n\"\n+\t\"}\\n\");\n+}\n+\n+\f\n+/* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare\n+   an enumeration in portable C, so we have to condition all these\n+   prototypes on HAVE_MACHINE_MODES.  */\n+static void\n+write_tm_preds_h (void)\n+{\n+  struct pred_data *p;\n+\n+  printf (\"\\\n+/* Generated automatically by the program '%s'\\n\\\n+   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+\n+  puts (\"\\\n+#ifndef GCC_TM_PREDS_H\\n\\\n+#define GCC_TM_PREDS_H\\n\\\n+\\n\\\n+#ifdef HAVE_MACHINE_MODES\");\n+\n+  FOR_ALL_PREDICATES (p)\n+    printf (\"extern int %s (rtx, enum machine_mode);\\n\", p->name);\n+\n+  puts (\"#endif /* HAVE_MACHINE_MODES */\\n\");\n+\n+  if (constraint_max_namelen > 0)\n+    {\n+      write_enum_constraint_num ();\n+      puts (\"extern enum constraint_num lookup_constraint (const char *);\\n\"\n+\t    \"extern bool constraint_satisfied_p (rtx, enum constraint_num);\\n\");\n+\n+      if (constraint_max_namelen > 1)\n+\tputs (\"extern size_t insn_constraint_len (enum constraint_num);\\n\"\n+\t      \"#define CONSTRAINT_LEN(c_,s_) \"\n+\t      \"insn_constraint_len (lookup_constraint (s_))\\n\");\n+      else\n+\tputs (\"#define CONSTRAINT_LEN(c_,s_) 1\\n\");\n+      if (have_register_constraints)\n+\tputs (\"extern enum reg_class regclass_for_constraint \"\n+\t      \"(enum constraint_num);\\n\"\n+\t      \"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) \\\\\\n\"\n+\t      \"    regclass_for_constraint (lookup_constraint (s_))\\n\");\n+      else\n+\tputs (\"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) NO_REGS\");\n+      if (have_const_int_constraints)\n+\tputs (\"extern bool insn_const_int_ok_for_constraint \"\n+\t      \"(HOST_WIDE_INT, enum constraint_num);\\n\"\n+\t      \"#define CONST_OK_FOR_CONSTRAINT_P(v_,c_,s_) \\\\\\n\"\n+\t      \"    insn_const_int_ok_for_constraint (v_, \"\n+\t      \"lookup_constraint (s_))\\n\");\n+      if (have_const_dbl_constraints)\n+\tputs (\"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) \\\\\\n\"\n+\t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n+      else\n+\tputs (\"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) 0\\n\");\n+      if (have_extra_constraints)\n+\tputs (\"#define EXTRA_CONSTRAINT_STR(v_,c_,s_) \\\\\\n\"\n+\t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n+      if (have_memory_constraints)\n+\tputs (\"extern bool \"\n+\t      \"insn_extra_memory_constraint (enum constraint_num);\\n\"\n+\t      \"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) \"\n+\t      \"insn_extra_memory_constraint (lookup_constraint (s_))\\n\");\n+      else\n+\tputs (\"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) false\\n\");\n+      if (have_address_constraints)\n+\tputs (\"extern bool \"\n+\t      \"insn_extra_address_constraint (enum constraint_num)\"\n+\t      \"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) \"\n+\t      \"insn_extra_address_constraint (lookup_constraint (s_))\\n\");\n+      else\n+\tputs (\"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) false\\n\");\n+\n+      if (have_const_int_constraints || have_const_dbl_constraints\n+\t  || have_extra_constraints)\n+\twrite_satisfies_constraint_fns ();\n+    }\n+\n+  puts (\"#endif /* tm-preds.h */\");\n+}\n \n /* Write insn-preds.c.  \n    N.B. the list of headers to include was copied from genrecog; it\n@@ -486,6 +1220,24 @@ write_insn_preds_c (void)\n \n   FOR_ALL_PREDICATES (p)\n     write_one_predicate_function (p);\n+\n+  if (constraint_max_namelen > 0)\n+    {\n+      write_lookup_constraint ();\n+      write_regclass_for_constraint ();\n+      write_constraint_satisfied_p ();\n+      \n+      if (constraint_max_namelen > 1)\n+\twrite_insn_constraint_len ();\n+\n+      if (have_const_int_constraints)\n+\twrite_insn_const_int_ok_for_constraint ();\n+\n+      if (have_memory_constraints)\n+\twrite_insn_extra_memory_constraint ();\n+      if (have_address_constraints)\n+\twrite_insn_extra_address_constraint ();\n+    }\n }\n \n /* Argument parsing.  */\n@@ -516,11 +1268,26 @@ main (int argc, char **argv)\n     return FATAL_EXIT_CODE;\n \n   while ((defn = read_md_rtx (&pattern_lineno, &next_insn_code)) != 0)\n-    {\n-      if (GET_CODE (defn) == DEFINE_PREDICATE\n-\t  || GET_CODE (defn) == DEFINE_SPECIAL_PREDICATE)\n-\tprocess_define_predicate (defn);\n-    }\n+    switch (GET_CODE (defn))\n+      {\n+      case DEFINE_PREDICATE:\n+      case DEFINE_SPECIAL_PREDICATE:\n+\tprocess_define_predicate (defn, pattern_lineno);\n+\tbreak;\n+\n+      case DEFINE_CONSTRAINT:\n+      case DEFINE_MEMORY_CONSTRAINT:\n+      case DEFINE_ADDRESS_CONSTRAINT:\n+\tprocess_define_constraint (defn, pattern_lineno);\n+\tbreak;\n+\n+      case DEFINE_REGISTER_CONSTRAINT:\n+\tprocess_define_register_constraint (defn, pattern_lineno);\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n \n   if (gen_header)\n     write_tm_preds_h ();"}, {"sha": "a880b111c0fd7449377e2d76a5019805037ddc0d", "filename": "gcc/gensupport.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -287,6 +287,10 @@ process_rtx (rtx desc, int lineno)\n \n     case DEFINE_PREDICATE:\n     case DEFINE_SPECIAL_PREDICATE:\n+    case DEFINE_CONSTRAINT:\n+    case DEFINE_REGISTER_CONSTRAINT:\n+    case DEFINE_MEMORY_CONSTRAINT:\n+    case DEFINE_ADDRESS_CONSTRAINT:\n       queue_pattern (desc, &define_pred_tail, read_rtx_filename, lineno);\n       break;\n "}, {"sha": "e3cdfd799148e65cb7e9a2811db024b1dc0a9b88", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -2664,6 +2664,10 @@ reg_fits_class_p (rtx operand, enum reg_class cl, int offset,\n \t\t  enum machine_mode mode)\n {\n   int regno = REGNO (operand);\n+\n+  if (cl == NO_REGS)\n+    return 0;\n+\n   if (regno < FIRST_PSEUDO_REGISTER\n       && TEST_HARD_REG_BIT (reg_class_contents[(int) cl],\n \t\t\t    regno + offset))"}, {"sha": "84b24bc543bbf640dadcadc6deacd3bb3f45f0a9", "filename": "gcc/rtl.def", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38840db9b8ff2b3e3640c20093c42e7d66ccde5/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=f38840db9b8ff2b3e3640c20093c42e7d66ccde5", "patch": "@@ -874,6 +874,61 @@ DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", RTX_EXTRA)\n DEF_RTL_EXPR(DEFINE_PREDICATE, \"define_predicate\", \"ses\", RTX_EXTRA)\n DEF_RTL_EXPR(DEFINE_SPECIAL_PREDICATE, \"define_special_predicate\", \"ses\", RTX_EXTRA)\n \n+/* Definition of a register operand constraint.  This simply maps the\n+   constraint string to a register class.\n+\n+   Operand:\n+   0: The name of the constraint (often, but not always, a single letter).\n+   1: A C expression which evaluates to the appropriate register class for\n+      this constraint.  If this is not just a constant, it should look only\n+      at -m switches and the like.\n+   2: A docstring for this constraint, in Texinfo syntax; not currently\n+      used, in future will be incorporated into the manual's list of\n+      machine-specific operand constraints.  */\n+DEF_RTL_EXPR(DEFINE_REGISTER_CONSTRAINT, \"define_register_constraint\", \"sss\", RTX_EXTRA)\n+\n+/* Definition of a non-register operand constraint.  These look at the\n+   operand and decide whether it fits the constraint.\n+\n+   DEFINE_CONSTRAINT gets no special treatment if it fails to match.\n+   It is appropriate for constant-only constraints, and most others.\n+\n+   DEFINE_MEMORY_CONSTRAINT tells reload that this constraint can be made\n+   to match, if it doesn't already, by converting the operand to the form\n+   (mem (reg X)) where X is a base register.  It is suitable for constraints\n+   that describe a subset of all memory references.\n+\n+   DEFINE_ADDRESS_CONSTRAINT tells reload that this constraint can be made\n+   to match, if it doesn't already, by converting the operand to the form\n+   (reg X) where X is a base register.  It is suitable for constraints that\n+   describe a subset of all address references.\n+\n+   When in doubt, use plain DEFINE_CONSTRAINT.  \n+\n+   Operand:\n+   0: The name of the constraint (often, but not always, a single letter).\n+   1: A docstring for this constraint, in Texinfo syntax; not currently\n+      used, in future will be incorporated into the manual's list of\n+      machine-specific operand constraints.\n+   2: A boolean expression which computes whether or not the constraint\n+      matches.  It should follow the same rules as a define_predicate\n+      expression, including the bit about specifying the set of RTX codes\n+      that could possibly match.  MATCH_TEST subexpressions may make use of\n+      these variables:\n+        `op'    - the RTL object defining the operand.\n+        `mode'  - the mode of `op'.\n+\t`ival'  - INTVAL(op), if op is a CONST_INT.\n+        `hval'  - CONST_DOUBLE_HIGH(op), if op is an integer CONST_DOUBLE.\n+        `lval'  - CONST_DOUBLE_LOW(op), if op is an integer CONST_DOUBLE.\n+        `rval'  - CONST_DOUBLE_REAL_VALUE(op), if op is a floating-point\n+                  CONST_DOUBLE.\n+      Do not use ival/hval/lval/rval if op is not the appropriate kind of\n+      RTL object.  */\n+DEF_RTL_EXPR(DEFINE_CONSTRAINT, \"define_constraint\", \"sse\", RTX_EXTRA)\n+DEF_RTL_EXPR(DEFINE_MEMORY_CONSTRAINT, \"define_memory_constraint\", \"sse\", RTX_EXTRA)\n+DEF_RTL_EXPR(DEFINE_ADDRESS_CONSTRAINT, \"define_address_constraint\", \"sse\", RTX_EXTRA)\n+   \n+\n /* Constructions for CPU pipeline description described by NDFAs.  */\n \n /* (define_cpu_unit string [string]) describes cpu functional"}]}