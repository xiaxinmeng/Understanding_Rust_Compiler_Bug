{"sha": "34f97b9407c6a39f133b3446e8c788d19a9f9e34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmOTdiOTQwN2M2YTM5ZjEzM2IzNDQ2ZThjNzg4ZDE5YTlmOWUzNA==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2010-04-28T17:41:31Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-04-28T17:41:31Z"}, "message": "predicate aware uninitialized analysis\n\nFrom-SVN: r158835", "tree": {"sha": "371e321349590c66d4a3929d9c841eb7fe2c2cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/371e321349590c66d4a3929d9c841eb7fe2c2cfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34f97b9407c6a39f133b3446e8c788d19a9f9e34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f97b9407c6a39f133b3446e8c788d19a9f9e34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f97b9407c6a39f133b3446e8c788d19a9f9e34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f97b9407c6a39f133b3446e8c788d19a9f9e34/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85fac79c205b0b415d0eb0a8a4fe6a28f50a92a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85fac79c205b0b415d0eb0a8a4fe6a28f50a92a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85fac79c205b0b415d0eb0a8a4fe6a28f50a92a5"}], "stats": {"total": 3207, "additions": 3121, "deletions": 86}, "files": [{"sha": "c84d857011d9a27b68a35f289709a5a969b31c59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -1,3 +1,49 @@\n+2010-04-28  Xinliang David Li  <davidxl@google.com>\n+\n+\tPR c/42643\n+\t* tree-ssa-uninit.c (can_skip_redundant_opnd): New function.\n+\t(compute_uninit_opnds_pos): New function.\n+\t(is_non_loop_exit_postdominating): New function.\n+\t(compute_control_dep_chain): New function.\n+\t(find_pdom): New function.\n+\t(convert_control_dep_chain_into_preds): New function.\n+\t(find_predicates): New function.\n+\t(find_control_equiv_block): New function.\n+\t(collect_phi_def_edges): New function.\n+\t(find_def_preds): New function.\n+\t(find_dom): New function.\n+\t(dump_predicates): New function.\n+\t(get_cmp_code): New function.\n+\t(is_value_included_in): New function.\n+\t(find_matching_predicate_in_rest_chains): New function.\n+\t(use_pred_not_overlap_with_undef_path_pred): New function.\n+\t(is_use_properly_guarded): New function.\n+\t(normalize_cond_1): New function.\n+\t(is_and_or_or): New function.\n+\t(normalize_cond): New function.\n+\t(is_gcond_subset_of): New function.\n+\t(is_subset_of_any): New function.\n+\t(is_or_set_subset_of): New function.\n+\t(is_and_set_subset_of): New function.\n+\t(is_norm_cond_subset_of): New function.\n+\t(is_pred_expr_subset_of): New function.\n+\t(is_pred_chain_subset_of): New function.\n+\t(is_included_in): New function.\n+\t(is_superset_of): New function.\n+\t(find_uninit_use): New function.\n+\t(warn_uninitialized_phi): New function.\n+\t(compute_possibly_undefined_names): New function.\n+\t(ssa_undefined_value_p): New function.\n+\t(execute_late_warn_uninitialized): New function.\n+\t* tree-ssa.c (ssa_undefined_value_p): Removed.\n+\t(warn_uninit): Changed to extern.\n+\t(warn_uninitialized_phi): Removed.\n+\t(warn_uninitialized_vars): Changed to extern.\n+\t(execute_late_warn_uninitialized): Removed\n+\t* tree-flow.h: Add new prototypes.\n+\t* timevar.def: Add new time variable.\n+\t* Makefile.in: Add new build file.\n+\n 2010-04-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/elf.h (ASM_DECLARE_OBJECT_NAME): Use gnu_unique_object"}, {"sha": "d924f3ba790228247542d48c7230cb76e27fbb5d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -1385,6 +1385,7 @@ OBJS-common = \\\n \ttree-ssa-threadedge.o \\\n \ttree-ssa-threadupdate.o \\\n \ttree-ssa-uncprop.o \\\n+\ttree-ssa-uninit.o \\\n \ttree-ssa.o \\\n \ttree-ssanames.o \\\n \ttree-stdarg.o \\\n@@ -2288,6 +2289,12 @@ tree-ssa-structalias.o: tree-ssa-structalias.c \\\n    $(GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(TIMEVAR_H) alloc-pool.h $(SPLAY_TREE_H) $(PARAMS_H) \\\n    gt-tree-ssa-structalias.h $(CGRAPH_H) $(ALIAS_H) pointer-set.h\n+tree-ssa-uninit.o : tree-ssa-uninit.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n+   $(TOPLEV_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) langhooks.h tree-pass.h $(BASIC_BLOCK_H) $(BITMAP_H) \\\n+   $(FLAGS_H) $(GGC_H) hard-reg-set.h $(HASHTAB_H) pointer-set.h \\\n+   $(GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H)\n tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h $(DIAGNOSTIC_H) \\\n    $(TOPLEV_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "a35d126585cedbb319224c55d62ded57d51fbb70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -1,3 +1,39 @@\n+2010-04-28  Xinliang David Li  <davidxl@google.com>\n+\n+\t* gcc.dg/uninit-pred-2_b.c: New test.\n+\t* gcc.dg/uninit-pred-4_b.c: New test.\n+\t* gcc.dg/uninit-pred-3_d.c: New test.\n+\t* gcc.dg/uninit-pred-6_b.c: New test.\n+\t* gcc.dg/uninit-pred-8_b.c: New test.\n+\t* gcc.dg/uninit-pred-3_a.c: New test.\n+\t* gcc.dg/uninit-pred-2_c.c: New test.\n+\t* gcc.dg/uninit-pred-5_a.c: New test.\n+\t* gcc.dg/uninit-pred-3_e.c: New test.\n+\t* gcc.dg/uninit-pred-7_a.c: New test.\n+\t* gcc.dg/uninit-pred-6_c.c: New test.\n+\t* gcc.dg/uninit-pred-9_a.c: New test.\n+\t* gcc.dg/uninit-pred-8_c.c: New test.\n+\t* gcc.dg/uninit-pred-3_b.c: New test.\n+\t* gcc.dg/uninit-pred-5_b.c: New test.\n+\t* gcc.dg/uninit-pred-7_b.c: New test.\n+\t* gcc.dg/uninit-pred-6_d.c: New test.\n+\t* gcc.dg/uninit-pred-9_b.c: New test.\n+\t* gcc.dg/uninit-pred-2_a.c: New test.\n+\t* gcc.dg/uninit-pred-4_a.c: New test.\n+\t* gcc.dg/uninit-pred-3_c.c: New test.\n+\t* gcc.dg/uninit-pred-6_a.c: New test.\n+\t* gcc.dg/uninit-pred-8_a.c: New test.\n+\t* gcc.dg/uninit-pred-7_c.c: New test.\n+\t* gcc.dg/uninit-pred-6_e.c: New test.\n+\t* g++.dg/uninit-pred-loop-1_b.cc: New test.\n+\t* g++.dg/uninit-pred-1_a.C: New test.\n+\t* g++.dg/uninit-pred-1_b.C: New test.\n+\t* g++.dg/uninit-pred-2_a.C: New test.\n+\t* g++.dg/uninit-pred-2_b.C: New test.\n+\t* g++.dg/uninit-pred-loop-1_a.cc: New test.\n+\t* g++.dg/uninit-pred-loop-1_c.cc: New test.\n+\t* g++.dg/uninit-pred-loop_1.cc: New test.\n+\n 2010-04-28  Martin Jambor  <mjambor@suse.cz>\n \n \t* gcc.dg/lto/20091209-1_0.c: New testcase."}, {"sha": "58bb9c5d45af69b60d27d9434225e21e33cadc77", "filename": "gcc/testsuite/g++.dg/uninit-pred-1_a.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-1_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-1_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-1_a.C?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+typedef long long int64;\n+void incr ();\n+bool is_valid (int);\n+int  get_time ();\n+\n+class A \n+{\n+public:\n+  A ();\n+  ~A () {\n+    if (I) delete I;\n+  }\n+\n+private:\n+  int* I;\n+};\n+\n+bool get_url (A *);\n+\n+class M {\n+\n+ public:\n+__attribute__ ((always_inline))  int GetC (int *c)  {\n+\n+    A details_str;\n+    if (!get_url (&details_str))\n+      {\n+        incr ();\n+        return 1;\n+      }\n+\n+    *c = get_time ();\n+    return -1;\n+  }\n+\n+  void do_sth();\n+  void do_sth2();\n+   \n+  void P (int64 t)\n+    {\n+      int cc; /* { dg-bogus \"uninitialized\" \"uninitialized variable warning\" }  */ \n+      if (GetC (&cc) >= 0 )\n+        return;\n+      \n+      if (t && cc <= 0 )  /* { dg-bogus \"uninitialized\" \"uninitialized variable warning\" } */\n+        {\n+          this->do_sth();\n+          return;\n+        }\n+\n+    do_sth2();\n+  }\n+};\n+\n+M* m; \n+void foo(int x)\n+{\n+  m = new M;\n+  m->P(x);\n+}"}, {"sha": "0d5b71ec899377acfd9550742c1e0a653437361b", "filename": "gcc/testsuite/g++.dg/uninit-pred-1_b.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-1_b.C?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+typedef long long int64;\n+void incr ();\n+bool is_valid (int);\n+int  get_time ();\n+\n+class A \n+{\n+public:\n+  A ();\n+  ~A () {\n+    if (I) delete I;\n+  }\n+\n+private:\n+  int* I;\n+};\n+\n+bool get_url (A *);\n+\n+class M {\n+\n+ public:\n+__attribute__ ((always_inline))  int GetC (int *c)  {\n+\n+    A details_str;\n+    if (!get_url (&details_str))\n+      {\n+        incr ();\n+        return 1;\n+      }\n+\n+    *c = get_time ();\n+    return -1;\n+  }\n+\n+  void do_sth();\n+  void do_sth2();\n+   \n+  void P (int64 t)\n+    {\n+      int cc; /* { dg-excess-errors \"note: 'cc' was declared here\" } */\n+      if (GetC (&cc) <= 0 ) /* return flag checked wrongly */\n+        return;\n+      \n+      if (t && cc <= 0 )  /* { dg-warning \"uninitialized\" \"uninitialized variable warning\" } */\n+        {\n+          this->do_sth();\n+          return;\n+        }\n+\n+    do_sth2();\n+  }\n+};\n+\n+M* m; \n+void foo(int x)\n+{\n+  m = new M;\n+  m->P(x);\n+}"}, {"sha": "918c94375c205a90d52703f0d6bbf6af3ac16e2b", "filename": "gcc/testsuite/g++.dg/uninit-pred-2_a.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-2_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-2_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-2_a.C?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+typedef long long int64;\n+void incr ();\n+bool is_valid (int);\n+int  get_time ();\n+\n+class A \n+{\n+public:\n+  A ();\n+  ~A () {\n+    if (I) delete I;\n+  }\n+\n+private:\n+  int* I;\n+};\n+\n+bool get_url (A *);\n+\n+class M {\n+\n+ public:\n+__attribute__ ((always_inline))  bool GetC (int *c)  {\n+\n+    A details_str;\n+    if (get_url (&details_str))\n+      {\n+        *c = get_time ();\n+        return true;\n+      }\n+\n+    return false;\n+  }\n+\n+  void do_sth();\n+  void do_sth2();\n+   \n+  void P (int64 t)\n+    {\n+      int cc; \n+      if (!GetC (&cc)) /* return flag checked properly */\n+        return;\n+      \n+      if (cc <= 0)  /* { dg-bogus \"uninitialized\" \"uninitialized variable warning\" } */\n+        {\n+          this->do_sth();\n+          return;\n+        }\n+\n+    do_sth2();\n+  }\n+};\n+\n+M* m; \n+void foo(int x)\n+{\n+  m = new M;\n+  m->P(x);\n+}"}, {"sha": "7259d8f95a46439a9788cffee6121e6da09e5efa", "filename": "gcc/testsuite/g++.dg/uninit-pred-2_b.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-2_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-2_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-2_b.C?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+typedef long long int64;\n+void incr ();\n+bool is_valid (int);\n+int  get_time ();\n+\n+class A \n+{\n+public:\n+  A ();\n+  ~A () {\n+    if (I) delete I;\n+  }\n+\n+private:\n+  int* I;\n+};\n+\n+bool get_url (A *);\n+\n+class M {\n+\n+ public:\n+__attribute__ ((always_inline))  bool GetC (int *c)  {\n+\n+    A details_str;\n+    if (get_url (&details_str))\n+      {\n+        *c = get_time ();\n+        return true;\n+      }\n+\n+    return false;\n+  }\n+\n+  void do_sth();\n+  void do_sth2();\n+   \n+  void P (int64 t)\n+    {\n+      int cc; /* { dg-excess-errors \"note\" } */\n+      if (GetC (&cc)) /* return flag checked wrongly */\n+        return;\n+      \n+      if (cc <= 0)  /* { dg-warning \"uninitialized\" \"uninitialized variable warning\" } */\n+        {\n+          this->do_sth();\n+          return;\n+        }\n+\n+    do_sth2();\n+  }\n+};\n+\n+M* m; \n+void foo(int x)\n+{\n+  m = new M;\n+  m->P(x);\n+}"}, {"sha": "835cdbae320a97a3d9541c8598681757ce59c223", "filename": "gcc/testsuite/g++.dg/uninit-pred-loop-1_a.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_a.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_a.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_a.cc?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+extern int bar();\n+int foo(void)\n+{\n+ for (;;) {\n+   int err = ({int _err; /*  { dg-bogus \"uninitialized\" \"false warning\" } */\n+     for (int i = 0; i < 16; ++i) {\n+       _err = 17;\n+       _err = bar();\n+     }\n+     _err; /*  { dg-bogus \"uninitialized\" \"false warning\" } */\n+   });\n+\n+   if (err == 0) return 17; \n+ }\n+\n+ return 18;\n+}\n+"}, {"sha": "e4ef3d22c069def9c054058648c2bace2414ce8a", "filename": "gcc/testsuite/g++.dg/uninit-pred-loop-1_b.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_b.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_b.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_b.cc?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+extern int bar();\n+int foo(int n)\n+{\n+ for (;;) {\n+   int err = ({int _err; \n+     for (int i = 0; i < n; ++i) {\n+       _err = 17;\n+       _err = bar();\n+     }\n+     _err; \n+   }); /* { dg-warning \"uninitialized\" \"warn on _err\" } */\n+\n+   if (err == 0) return 17; \n+ }\n+\n+ return 18;\n+}\n+"}, {"sha": "7f6b41d31ff371e072c997eb9f87b37936e6dabb", "filename": "gcc/testsuite/g++.dg/uninit-pred-loop-1_c.cc", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop-1_c.cc?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+extern int bar();\n+int foo(int n, int m)\n+{\n+ for (;;) {\n+   int err = ({int _err; \n+     for (int i = 0; i < 16; ++i) {\n+       if (m+i > n)\n+          break;\n+       _err = 17;\n+       _err = bar();\n+     }\n+     _err; \n+   }); \n+\n+   if (err == 0) return 17; }); /* { dg-warning \"uninitialized\" \"warn on _err\" } */\n+ }\n+\n+ return 18;\n+}\n+"}, {"sha": "835cdbae320a97a3d9541c8598681757ce59c223", "filename": "gcc/testsuite/g++.dg/uninit-pred-loop_1.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop_1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop_1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Funinit-pred-loop_1.cc?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+extern int bar();\n+int foo(void)\n+{\n+ for (;;) {\n+   int err = ({int _err; /*  { dg-bogus \"uninitialized\" \"false warning\" } */\n+     for (int i = 0; i < 16; ++i) {\n+       _err = 17;\n+       _err = bar();\n+     }\n+     _err; /*  { dg-bogus \"uninitialized\" \"false warning\" } */\n+   });\n+\n+   if (err == 0) return 17; \n+ }\n+\n+ return 18;\n+}\n+"}, {"sha": "2730534e90e39819e81f7353d13c311ca6de66ca", "filename": "gcc/testsuite/gcc.dg/uninit-11.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-11.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -17,10 +17,10 @@ void f2(void)\n \n void f3(int p)\n {\n-  int x;\t\t/* { dg-warning \"may be used\" \"conditional\" } */\n+  int x;\t\t\n   if (p)\n     x = p;\n-  sink = x;\n+  sink = x;            /* { dg-warning \"may be used\" \"conditional\" } */\n }\n \n void f4(int p)"}, {"sha": "df2a27c4472eae4f530e7b150f584162ec276407", "filename": "gcc/testsuite/gcc.dg/uninit-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-5.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -1,7 +1,7 @@\n /* Spurious uninitialized-variable warnings.  */\n-\n+/* Disable jump threading, etc to test compiler analysis.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O -Wuninitialized\" } */\n+/* { dg-options \"-O -Wuninitialized -fno-tree-dce -fno-tree-vrp -fno-tree-dominator-opts\" } */\n \n extern void use(int);\n extern void foo(void);"}, {"sha": "5edf21d309fd07220bb576999d9a9fcc94afaee2", "filename": "gcc/testsuite/gcc.dg/uninit-pred-2_a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar (void);\n+void blah (int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = 1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (flag)\n+    blah(v); /* { dg-bogus \"uninitialized\" \"bogus uninitialized var warning\" } */ \n+\n+  return 0;\n+}"}, {"sha": "ac7697e3c82730ed4d38cf0e9a9b4a0119b14a88", "filename": "gcc/testsuite/gcc.dg/uninit-pred-2_b.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar (void);\n+void blah (int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v; \n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = 1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  /* Wrong guard */\n+  if (!flag)\n+    blah(v); /* { dg-warning \"uninitialized\" \"real uninitialized var warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "941f6328d0f0b8dca383ef7e888f62fa1bc500c3", "filename": "gcc/testsuite/gcc.dg/uninit-pred-2_c.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-2_c.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar (void);\n+void blah (int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v; \n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = 1;\n+    }\n+\n+  if (m) g++;\n+  else bar();\n+\n+  if (flag)\n+    blah(v); /* { dg-bogus \"uninitialized\" \"bogus uninitialized var warning\" } */ \n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v; \n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = 1;\n+    }\n+\n+  if (m) g++;\n+  else bar();\n+\n+  if (flag)\n+    blah(v); /* { dg-bogus \"uninitialized\" \"bogus uninitialized var warning\" } */ \n+  else\n+    blah(v); /* { dg-warning \"uninitialized\" \"real uninitialized var warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "0ef0650aeca20e0488c2431fd697c7cb6be4231d", "filename": "gcc/testsuite/gcc.dg/uninit-pred-3_a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = 1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (r > 0)\n+    if (flag)\n+      blah(v); /* {dg-bogus \"uninitialized\" \"bogus warning\" } */\n+  return 0;\n+}"}, {"sha": "978210d50796d46b51af2fd4b1d4dd1416c6a2fc", "filename": "gcc/testsuite/gcc.dg/uninit-pred-3_b.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = 1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (r > 0)\n+     goto use;\n+  if (flag)\n+    {\n+use:\n+      blah(v); /* { dg-warning \"uninitialized\" \"real warning\" } */\n+    }\n+\n+  return 0;\n+}"}, {"sha": "1309790786c38eeec9f98dba28aacb0029c337b8", "filename": "gcc/testsuite/gcc.dg/uninit-pred-3_c.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_c.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = -1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (r > 0)\n+    if (flag < 0)\n+      blah(v); /* {dg-bogus \"uninitialized\" \"bogus warning\" } */\n+  return 0;\n+}"}, {"sha": "9f938763caade0580f76683d68c7f9a748de4c24", "filename": "gcc/testsuite/gcc.dg/uninit-pred-3_d.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_d.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = -1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (r > 0)\n+    if (flag  == -1)\n+      blah(v); /* {dg-bogus \"uninitialized\" \"bogus warning\" } */\n+  return 0;\n+}"}, {"sha": "66e2a3a93167cac72ff1fab7f6cbc032da79a934", "filename": "gcc/testsuite/gcc.dg/uninit-pred-3_e.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-3_e.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int m, int r)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (n)\n+    {\n+      v = r;\n+      flag = -1;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (r > 0)\n+    if (flag  <= 0 )\n+      blah(v); /* { dg-warning \"uninitialized\" \"real warning\" } */\n+  return 0;\n+}"}, {"sha": "7b2d291a66f15664f0dee76b07fd73e4683a4a29", "filename": "gcc/testsuite/gcc.dg/uninit-pred-4_a.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-4_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-4_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-4_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+int foo (int n, int m, int r, int t)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (t)\n+    {\n+      if (n)\n+        {\n+          v = r;    /* init path 1 */\n+          flag = 1;\n+        }\n+\n+      if (m)\n+        g++;\n+      else \n+        bar();\n+\n+      if (flag)  /* properly  guarded */\n+        blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+    }\n+  else\n+    {\n+      v = r+1; /* init path 2 */\n+      flag = 2;\n+    }\n+\n+  if (m)\n+    g++;\n+  else \n+    bar();\n+\n+  if (flag)  /* properly guarded */\n+    blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "3766395889db4630218d6ea83336e71ca17aeb7f", "filename": "gcc/testsuite/gcc.dg/uninit-pred-4_b.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-4_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-4_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-4_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+int foo (int n, int m, int r, int t)\n+{\n+  int flag = 0;\n+  int v;\n+\n+  if (t)\n+    {\n+      if (n)\n+        {\n+          v = r;    /* init path 1 */\n+          flag = 1;\n+        }\n+\n+      if (m) g++;\n+      else bar();\n+\n+      if (flag)  /* properly  guarded */\n+        blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+    }\n+  else\n+    {\n+      v = r+1; /* init path 2 */\n+      flag = 2;\n+    }\n+\n+  if (m) g++;\n+  else bar();\n+\n+  if (g)   /* guard can not be determined statically to be safe */\n+    blah(v); /* { dg-warning \"uninitialized\" \"real warning\" } */\n+\n+  return 0;\n+}\n+"}, {"sha": "845f3c46124a0952cba75fa7df199b7203278ef1", "filename": "gcc/testsuite/gcc.dg/uninit-pred-5_a.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-5_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-5_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-5_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+int bar();\n+int blah(int);\n+void t(int);\n+\n+__attribute__((always_inline)) \n+int foo (int n, int* v, int r)\n+{\n+  int flag = 0;\n+  if (r > n)\n+    {\n+      *v = bar();\n+      flag = 1;\n+    }\n+\n+  if (n > g)\n+    g++;\n+  else \n+    bar();\n+\n+  return flag;\n+}\n+\n+int a[100];\n+int b[100];\n+int blah(int n)\n+{\n+  int i;\n+   for (i = 0 ; i < n; i++)\n+     {\n+       int v;\n+       if (!foo (n, &v, b[i]))\n+         return 0;\n+       t (v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+     }\n+   return 1;\n+}\n+\t"}, {"sha": "13f1e31f805fb97035a1edbeb0f6c9e06ec32fe7", "filename": "gcc/testsuite/gcc.dg/uninit-pred-5_b.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-5_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-5_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-5_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+int bar();\n+int blah(int);\n+void t(int);\n+\n+__attribute__((always_inline)) \n+int foo (int n, int* v, int r)\n+{\n+  int flag = 0;\n+  if (r > n)\n+    {\n+      *v = bar();\n+      flag = 1;\n+    }\n+\n+  if (n > g)\n+    g++;\n+  else \n+    bar();\n+\n+  return flag;\n+}\n+\n+int a[100];\n+int b[100];\n+int blah(int n)\n+{\n+  int i;\n+   for (i = 0 ; i < n; i++)\n+     {\n+       int v;\n+       if (foo (n, &v, b[i]))\n+         return 0;\n+       t (v); /* { dg-warning \"uninitialized\" \"real warning\" } */\n+     }\n+   return 1;\n+}\n+\t"}, {"sha": "aa44f76160d8f35a67c9b09ce36d942c293d90ff", "filename": "gcc/testsuite/gcc.dg/uninit-pred-6_a.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,40 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n && l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n && l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if (n)\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}\n+"}, {"sha": "dcc9a14a3c9c304c94c0592f07adcba7fb017480", "filename": "gcc/testsuite/gcc.dg/uninit-pred-6_b.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,46 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n)\n+    if (l)\n+      v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if (l)\n+    if (n)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n)\n+    if (l)\n+      v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if (n || l)\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}\n+"}, {"sha": "f60868dad237865a57bd58ab5839602ea45e608b", "filename": "gcc/testsuite/gcc.dg/uninit-pred-6_c.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_c.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,46 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n > 10)\n+    if (l)\n+      v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( (n > 10) && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if (l)\n+    if (n > 12)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n > 10)\n+    if (l)\n+      v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if (n > 8 )\n+    if (l)\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "704c3e6e1d1a9dd8278dc70efb8ba8fb3c98cf74", "filename": "gcc/testsuite/gcc.dg/uninit-pred-6_d.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_d.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,24 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+"}, {"sha": "21f429daf4d19d908f2d8b88d7a0faa350be2da4", "filename": "gcc/testsuite/gcc.dg/uninit-pred-6_e.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-6_e.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,43 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n > 10)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( (n > 10) && (l < 100))\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n > 100 )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n > 10)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n < 10)\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+\n+  return 0;\n+}"}, {"sha": "c2ba2a4248d707b8d2bd6d112d525c4d89984c8a", "filename": "gcc/testsuite/gcc.dg/uninit-pred-7_a.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,54 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( l )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n && l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if (m || l)\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  if ( l )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "338d18c95e3f491b5dd7fec75a29b730634ad851", "filename": "gcc/testsuite/gcc.dg/uninit-pred-7_b.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,23 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n > 10)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if (( n > 10) || (l != 100))\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "1bbe5014dec5c0997ec31ff4dcd7564e91a6970c", "filename": "gcc/testsuite/gcc.dg/uninit-pred-7_c.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-7_c.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,33 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if (n )\n+    {\n+      if (l)\n+        g++;\n+      else \n+        goto l;\n+    }\n+  else\n+    {\n+l:\n+      blah (v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+    }\n+\n+  return 0;\n+}"}, {"sha": "1b7c472420cc3f6f64bf8998ff019cf3b8a92f36", "filename": "gcc/testsuite/gcc.dg/uninit-pred-8_a.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,45 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || m || r || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n ||  m || r || l)\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( l )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n || m || r )\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n || m || r || l)\n+      blah(v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "06e2eba27d056d559a7094fe318c7ac03e5b6576", "filename": "gcc/testsuite/gcc.dg/uninit-pred-8_b.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,45 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n < 10 || m > 100 || r < 20 || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n < 10 ||  m > 100 || r < 20 )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n < 10 ||  m > 100 || r < 10 )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n < 10 || m > 100 || r < 20 || l)\n+    v = r;\n+\n+  if (m) g++;\n+  else   bar();\n+\n+  if ( n < 10 ||  m > 100 || r < 20 )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( n < 10 ||  m > 100 || r < 30 )\n+      blah(v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "39d1bcd934638a9c9898523a98f01d464208a16c", "filename": "gcc/testsuite/gcc.dg/uninit-pred-8_c.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-8_c.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,39 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n < 10 && m > 100  && r < 20 )\n+    v = r;\n+\n+  if (m) g++; \n+  else  bar();\n+\n+  if ( n <= 8 &&  m > 101  && r < 19 )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if (n < 10 && m > 100  && r < 20 )\n+    v = r;\n+\n+  if (m) g++; \n+  else  bar();\n+\n+  if ( n <= 8 &&  m > 99  && r < 19 )\n+      blah(v); /* { dg-warning \"uninitialized\" \"warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "67fb8ab9778f94ed7d2d6fa9d12f2d036d8bc37d", "filename": "gcc/testsuite/gcc.dg/uninit-pred-9_a.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-9_a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-9_a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-9_a.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,23 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if ( (n < 10) && (m == l)  && (r < 20) )\n+    v = r;\n+\n+  if (m) g++; \n+  else  bar();\n+\n+  if ( (n <= 8) &&  (m == l)  && (r < 19) )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "d9ae75e0765757f615632e6b9fcea1505107534f", "filename": "gcc/testsuite/gcc.dg/uninit-pred-9_b.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-9_b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-9_b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pred-9_b.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,44 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+int g;\n+void bar();\n+void blah(int);\n+\n+int foo (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if ( (n < 10) && (m != 100)  && (r < 20) )\n+    v = r;\n+\n+  if (m) g++; \n+  else  bar();\n+\n+  if (l > 100)\n+    if ( (n <= 9) &&  (m < 100)  && (r < 19) )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  if ( (n <= 8) &&  (m < 99)  && (r < 19) )\n+      blah(v); /* { dg-bogus \"uninitialized\" \"bogus warning\" } */\n+\n+  return 0;\n+}\n+\n+int foo_2 (int n, int l, int m, int r)\n+{\n+  int v;\n+\n+  if ( (n < 10) && (m != 100)  && (r < 20) )\n+    v = r;\n+\n+  if (m) g++; \n+  else  bar();\n+\n+  if (l > 100)\n+    if ( (n <= 8) &&  (m < 101)  && (r < 19) )\n+      blah(v); /* { dg-warning \"uninitialized\" \"real warning\" } */\n+\n+  return 0;\n+}"}, {"sha": "c43847b5248b91cf9323b354e1e7a1c48c17ae2f", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -219,6 +219,7 @@ DEFTIMEVAR (TV_FINAL                 , \"final\")\n DEFTIMEVAR (TV_SYMOUT                , \"symout\")\n DEFTIMEVAR (TV_VAR_TRACKING          , \"variable tracking\")\n DEFTIMEVAR (TV_TREE_IFCOMBINE        , \"tree if-combine\")\n+DEFTIMEVAR (TV_TREE_UNINIT           , \"uninit var anaysis\")\n DEFTIMEVAR (TV_PLUGIN_INIT           , \"plugin initialization\")\n DEFTIMEVAR (TV_PLUGIN_RUN            , \"plugin execution\")\n "}, {"sha": "465cf2e252b6aad7729eae972cad36c8676e4fed", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -575,6 +575,8 @@ extern void flush_pending_stmts (edge);\n extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n extern bool ssa_undefined_value_p (tree);\n+extern void warn_uninit (tree, const char *, void *);\n+extern unsigned int warn_uninitialized_vars (bool);\n extern void execute_update_addresses_taken (bool);\n \n /* Call-back function for walk_use_def_chains().  At each reaching"}, {"sha": "4f23962485f447c36b6353f7ec9d65854d7ea909", "filename": "gcc/tree-ssa-uninit.c", "status": "added", "additions": 1762, "deletions": 0, "changes": 1762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -0,0 +1,1762 @@\n+/* Predicate aware uninitialized variable warning.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008 Free Software\n+   Foundation, Inc.\n+   Contributed by Xinliang David Li <davidxl@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"langhooks.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"bitmap.h\"\n+#include \"pointer-set.h\"\n+#include \"tree-flow.h\"\n+#include \"gimple.h\"\n+#include \"tree-inline.h\"\n+#include \"varray.h\"\n+#include \"timevar.h\"\n+#include \"hashtab.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"toplev.h\"\n+#include \"timevar.h\"\n+\n+/* This implements the pass that does predicate aware warning on uses of\n+   possibly uninitialized variables. The pass first collects the set of\n+   possibly uninitialized SSA names. For each such name, it walks through\n+   all its immediate uses. For each immediate use, it rebuilds the condition\n+   expression (the predicate) that guards the use. The predicate is then\n+   examined to see if the variable is always defined under that same condition.\n+   This is done either by pruning the unrealizable paths that lead to the\n+   default definitions or by checking if the predicate set that guards the\n+   defining paths is a superset of the use predicate.  */\n+\n+\n+/* Pointer set of potentially undefined ssa names, i.e.,\n+   ssa names that are defined by phi with operands that\n+   are not defined or potentially undefined.  */\n+static struct pointer_set_t *possibly_undefined_names = 0;\n+\n+/* Bit mask handling macros.  */\n+#define MASK_SET_BIT(mask, pos) mask |= (1 << pos)\n+#define MASK_TEST_BIT(mask, pos) (mask & (1 << pos))\n+#define MASK_EMPTY(mask) (mask == 0)\n+\n+/* Returns the first bit position (starting from LSB)\n+   in mask that is non zero. Returns -1 if the mask is empty.  */\n+static int\n+get_mask_first_set_bit (unsigned mask)\n+{\n+  int pos = 0;\n+  if (mask == 0)\n+    return -1;\n+\n+  while ((mask & (1 << pos)) == 0)\n+    pos++;\n+\n+  return pos;\n+}\n+#define MASK_FIRST_SET_BIT(mask) get_mask_first_set_bit (mask)\n+\n+\n+/* Return true if T, an SSA_NAME, has an undefined value.  */\n+\n+bool\n+ssa_undefined_value_p (tree t)\n+{\n+  tree var = SSA_NAME_VAR (t);\n+\n+  /* Parameters get their initial value from the function entry.  */\n+  if (TREE_CODE (var) == PARM_DECL)\n+    return false;\n+\n+  /* Hard register variables get their initial value from the ether.  */\n+  if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n+    return false;\n+\n+  /* The value is undefined iff its definition statement is empty.  */\n+  return (gimple_nop_p (SSA_NAME_DEF_STMT (t))\n+          || (possibly_undefined_names\n+              && pointer_set_contains (possibly_undefined_names, t)));\n+}\n+\n+/* Checks if the operand OPND of PHI is defined by \n+   another phi with one operand defined by this PHI, \n+   but the rest operands are all defined. If yes, \n+   returns true to skip this this operand as being\n+   redundant. Can be enhanced to be more general.  */\n+\n+static bool\n+can_skip_redundant_opnd (tree opnd, gimple phi)\n+{\n+  gimple op_def;\n+  tree phi_def;\n+  int i, n;\n+\n+  phi_def = gimple_phi_result (phi);\n+  op_def = SSA_NAME_DEF_STMT (opnd);\n+  if (gimple_code (op_def) != GIMPLE_PHI)\n+    return false;\n+  n = gimple_phi_num_args (op_def);\n+  for (i = 0; i < n; ++i)\n+    {\n+      tree op = gimple_phi_arg_def (op_def, i);\n+      if (TREE_CODE (op) != SSA_NAME)\n+        continue;\n+      if (op != phi_def && ssa_undefined_value_p (op))\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Returns a bit mask holding the positions of arguments in PHI\n+   that have empty (or possibly empty) definitions.  */\n+\n+static unsigned\n+compute_uninit_opnds_pos (gimple phi)\n+{\n+  size_t i, n;\n+  unsigned uninit_opnds = 0;\n+\n+  n = gimple_phi_num_args (phi);\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      tree op = gimple_phi_arg_def (phi, i);\n+      if (TREE_CODE (op) == SSA_NAME\n+          && ssa_undefined_value_p (op)\n+          && !can_skip_redundant_opnd (op, phi))\n+        MASK_SET_BIT (uninit_opnds, i);\n+    }\n+  return uninit_opnds;\n+}\n+\n+/* Find the immediate postdominator PDOM of the specified\n+   basic block BLOCK.  */\n+\n+static inline basic_block\n+find_pdom (basic_block block)\n+{\n+   if (block == EXIT_BLOCK_PTR)\n+     return EXIT_BLOCK_PTR;\n+   else\n+     {\n+       basic_block bb\n+           = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n+       if (! bb)\n+         return EXIT_BLOCK_PTR;\n+       return bb;\n+     }\n+}\n+\n+/* Find the immediate DOM of the specified\n+   basic block BLOCK.  */\n+\n+static inline basic_block\n+find_dom (basic_block block)\n+{\n+   if (block == ENTRY_BLOCK_PTR)\n+     return ENTRY_BLOCK_PTR;\n+   else\n+     {\n+       basic_block bb = get_immediate_dominator (CDI_DOMINATORS, block);\n+       if (! bb)\n+         return ENTRY_BLOCK_PTR;\n+       return bb;\n+     }\n+}\n+\n+/* Returns true if BB1 is postdominating BB2 and BB1 is\n+   not a loop exit bb. The loop exit bb check is simple and does\n+   not cover all cases.  */\n+\n+static bool\n+is_non_loop_exit_postdominating (basic_block bb1, basic_block bb2)\n+{\n+  if (!dominated_by_p (CDI_POST_DOMINATORS, bb2, bb1))\n+    return false;\n+\n+  if (single_pred_p (bb1) && !single_succ_p (bb2))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Find the closest postdominator of a specified BB, which is control\n+   equivalent to BB.  */\n+\n+static inline  basic_block\n+find_control_equiv_block (basic_block bb)\n+{\n+  basic_block pdom;\n+\n+  pdom = find_pdom (bb);\n+\n+  /* Skip the postdominating bb that is also loop exit.  */\n+  if (!is_non_loop_exit_postdominating (pdom, bb))\n+    return NULL;\n+\n+  if (dominated_by_p (CDI_DOMINATORS, pdom, bb))\n+    return pdom;\n+\n+  return NULL;\n+}\n+\n+#define MAX_NUM_CHAINS 8\n+#define MAX_CHAIN_LEN 5\n+\n+/* Computes the control dependence chains (paths of edges)\n+   for DEP_BB up to the dominating basic block BB (the head node of a\n+   chain should be dominated by it).  CD_CHAINS is pointer to a\n+   dynamic array holding the result chains. CUR_CD_CHAIN is the current\n+   chain being computed.  *NUM_CHAINS is total number of chains.  The\n+   function returns true if the information is successfully computed,\n+   return false if there is no control dependence or not computed.  */\n+\n+static bool\n+compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n+                           VEC(edge, heap) **cd_chains,\n+                           size_t *num_chains,\n+                           VEC(edge, heap) **cur_cd_chain)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  size_t i;\n+  bool found_cd_chain = false;\n+  size_t cur_chain_len = 0;\n+\n+  if (EDGE_COUNT (bb->succs) < 2)\n+    return false;\n+\n+  /* Could  use a set instead.  */\n+  cur_chain_len = VEC_length (edge, *cur_cd_chain);\n+  if (cur_chain_len > MAX_CHAIN_LEN)\n+    return false;\n+\n+  for (i = 0; i < cur_chain_len; i++)\n+    {\n+      edge e = VEC_index (edge, *cur_cd_chain, i);\n+      /* cycle detected. */\n+      if (e->src == bb)\n+        return false;\n+    }\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      basic_block cd_bb;\n+      if (e->flags & (EDGE_FAKE | EDGE_ABNORMAL))\n+        continue;\n+\n+      cd_bb = e->dest;\n+      VEC_safe_push (edge, heap, *cur_cd_chain, e);\n+      while (!is_non_loop_exit_postdominating (cd_bb, bb))\n+        {\n+          if (cd_bb == dep_bb)\n+            {\n+              /* Found a direct control dependence.  */\n+              if (*num_chains < MAX_NUM_CHAINS)\n+                {\n+                  cd_chains[*num_chains]\n+                      = VEC_copy (edge, heap, *cur_cd_chain);\n+                  (*num_chains)++;\n+                }\n+              found_cd_chain = true;\n+              /* check path from next edge.  */\n+              break;\n+            }\n+\n+          /* Now check if DEP_BB is indirectly control dependent on BB.  */\n+          if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n+                                         num_chains, cur_cd_chain))\n+            {\n+              found_cd_chain = true;\n+              break;\n+            }\n+\n+          cd_bb = find_pdom (cd_bb);\n+          if (cd_bb == EXIT_BLOCK_PTR)\n+            break;\n+        }\n+      VEC_pop (edge, *cur_cd_chain);\n+      gcc_assert (VEC_length (edge, *cur_cd_chain) == cur_chain_len);\n+    }\n+  gcc_assert (VEC_length (edge, *cur_cd_chain) == cur_chain_len);\n+\n+  return found_cd_chain;\n+}\n+\n+typedef struct use_pred_info\n+{\n+  gimple cond;\n+  bool invert;\n+} *use_pred_info_t;\n+\n+DEF_VEC_P(use_pred_info_t);\n+DEF_VEC_ALLOC_P(use_pred_info_t, heap);\n+\n+\n+/* Converts the chains of control dependence edges into a set of\n+   predicates. A control dependence chain is represented by a vector\n+   edges. DEP_CHAINS points to an array of dependence chains.\n+   NUM_CHAINS is the size of the chain array. One edge in a dependence\n+   chain is mapped to predicate expression represented by use_pred_info_t\n+   type. One dependence chain is converted to a composite predicate that\n+   is the result of AND operation of use_pred_info_t mapped to each edge.\n+   A composite predicate is presented by a vector of use_pred_info_t. On\n+   return, *PREDS points to the resulting array of composite predicates.\n+   *NUM_PREDS is the number of composite predictes.  */\n+\n+static bool\n+convert_control_dep_chain_into_preds (VEC(edge, heap) **dep_chains,\n+                                      size_t num_chains,\n+                                      VEC(use_pred_info_t, heap) ***preds,\n+                                      size_t *num_preds)\n+{\n+  bool has_valid_pred = false;\n+  size_t i, j;\n+  if (num_chains == 0 || num_chains >= MAX_NUM_CHAINS)\n+    return false;\n+\n+  /* Now convert CD chains into predicates  */\n+  has_valid_pred = true;\n+\n+  /* Now convert the control dep chain into a set\n+     of predicates.  */\n+  *preds = XCNEWVEC (VEC(use_pred_info_t, heap) *,\n+                     num_chains);\n+  *num_preds = num_chains;\n+\n+  for (i = 0; i < num_chains; i++)\n+    {\n+      VEC(edge, heap) *one_cd_chain = dep_chains[i];\n+      for (j = 0; j < VEC_length (edge, one_cd_chain); j++)\n+        {\n+          gimple cond_stmt;\n+          gimple_stmt_iterator gsi;\n+          basic_block guard_bb;\n+          use_pred_info_t one_pred;\n+          edge e;\n+\n+          e = VEC_index (edge, one_cd_chain, j);\n+          guard_bb = e->src;\n+          gsi = gsi_last_bb (guard_bb);\n+          if (gsi_end_p (gsi))\n+            {\n+              has_valid_pred = false;\n+              break;\n+            }\n+          cond_stmt = gsi_stmt (gsi);\n+          if (gimple_code (cond_stmt) == GIMPLE_CALL\n+              && EDGE_COUNT (e->src->succs) >= 2)\n+            {\n+              /* Ignore EH edge. Can add assertion\n+                 on the other edge's flag.  */\n+              continue;\n+            }\n+          /* Skip if there is essentially one succesor.  */\n+          if (EDGE_COUNT (e->src->succs) == 2)\n+            {\n+              edge e1;\n+              edge_iterator ei1;\n+              bool skip = false;\n+\n+              FOR_EACH_EDGE (e1, ei1, e->src->succs)\n+                {\n+                  if (EDGE_COUNT (e1->dest->succs) == 0)\n+                    {\n+                      skip = true;\n+                      break;\n+                    }\n+                }\n+              if (skip)\n+                continue;\n+            }\n+          if (gimple_code (cond_stmt) != GIMPLE_COND)\n+            {\n+              has_valid_pred = false;\n+              break;\n+            }\n+          one_pred = XNEW (struct use_pred_info);\n+          one_pred->cond = cond_stmt;\n+          one_pred->invert = !!(e->flags & EDGE_FALSE_VALUE);\n+          VEC_safe_push (use_pred_info_t, heap, (*preds)[i], one_pred);\n+        }\n+\n+      if (!has_valid_pred)\n+        break;\n+    }\n+  return has_valid_pred;\n+}\n+\n+/* Computes all control dependence chains for USE_BB. The control\n+   dependence chains are then converted to an array of composite\n+   predicates pointed to by PREDS.  PHI_BB is the basic block of\n+   the phi whose result is used in USE_BB.  */\n+\n+static bool\n+find_predicates (VEC(use_pred_info_t, heap) ***preds,\n+                 size_t *num_preds,\n+                 basic_block phi_bb,\n+                 basic_block use_bb)\n+{\n+  size_t num_chains = 0, i;\n+  VEC(edge, heap) **dep_chains = 0;\n+  VEC(edge, heap) *cur_chain = 0;\n+  bool has_valid_pred = false;\n+  basic_block cd_root = 0;\n+\n+  dep_chains = XCNEWVEC (VEC(edge, heap) *, MAX_NUM_CHAINS);\n+\n+  /* First find the closest bb that is control equivalent to PHI_BB\n+     that also dominates USE_BB.  */\n+  cd_root = phi_bb;\n+  while (dominated_by_p (CDI_DOMINATORS, use_bb, cd_root))\n+    {\n+      basic_block ctrl_eq_bb = find_control_equiv_block (cd_root);\n+      if (ctrl_eq_bb && dominated_by_p (CDI_DOMINATORS, use_bb, ctrl_eq_bb))\n+        cd_root = ctrl_eq_bb;\n+      else\n+        break;\n+    }\n+\n+  compute_control_dep_chain (cd_root, use_bb,\n+                             dep_chains, &num_chains,\n+                             &cur_chain);\n+\n+  has_valid_pred\n+      = convert_control_dep_chain_into_preds (dep_chains,\n+                                              num_chains,\n+                                              preds,\n+                                              num_preds);\n+  /* Free individual chain  */\n+  VEC_free (edge, heap, cur_chain);\n+  for (i = 0; i < num_chains; i++)\n+      VEC_free (edge, heap, dep_chains[i]);\n+  free (dep_chains);\n+  return has_valid_pred;\n+}\n+\n+/* Computes the set of incoming edges of PHI that have non empty\n+   definitions of a phi chain.  The collection will be done\n+   recursively on operands that are defined by phis. CD_ROOT\n+   is the control dependence root. *EDGES holds the result, and\n+   VISITED_PHIS is a pointer set for detecting cycles.  */\n+\n+static void\n+collect_phi_def_edges (gimple phi, basic_block cd_root,\n+                       VEC(edge, heap) **edges,\n+                       struct pointer_set_t *visited_phis)\n+{\n+  size_t i, n;\n+  edge opnd_edge;\n+  tree opnd;\n+\n+  if (pointer_set_insert (visited_phis, phi))\n+    return;\n+\n+  n = gimple_phi_num_args (phi);\n+  for (i = 0; i < n; i++)\n+    {\n+      opnd_edge = gimple_phi_arg_edge (phi, i);\n+      opnd = gimple_phi_arg_def (phi, i);\n+\n+      if (TREE_CODE (opnd) != SSA_NAME\n+          || !ssa_undefined_value_p (opnd))\n+        VEC_safe_push (edge, heap, *edges, opnd_edge);\n+      else\n+        {\n+          gimple def = SSA_NAME_DEF_STMT (opnd);\n+          if (gimple_code (def) == GIMPLE_PHI\n+              && dominated_by_p (CDI_DOMINATORS,\n+                                 gimple_bb (def), cd_root))\n+            collect_phi_def_edges (def, cd_root, edges,\n+                                   visited_phis);\n+        }\n+    }\n+}\n+\n+/* For each use edge of PHI, computes all control dependence chains.\n+   The control dependence chains are then converted to an array of\n+   composite predicates pointed to by PREDS.  */\n+\n+static bool\n+find_def_preds (VEC(use_pred_info_t, heap) ***preds,\n+                size_t *num_preds, gimple phi)\n+{\n+  size_t num_chains = 0, i, n;\n+  VEC(edge, heap) **dep_chains = 0;\n+  VEC(edge, heap) *cur_chain = 0;\n+  VEC(edge, heap) *def_edges = 0;\n+  bool has_valid_pred = false;\n+  basic_block phi_bb, cd_root = 0;\n+  struct pointer_set_t *visited_phis;\n+\n+  dep_chains = XCNEWVEC (VEC(edge, heap) *, MAX_NUM_CHAINS);\n+\n+  phi_bb = gimple_bb (phi);\n+  /* First find the closest dominating bb to be\n+     the control dependence root  */\n+  cd_root = find_dom (phi_bb);\n+  if (!cd_root)\n+    return false;\n+\n+  visited_phis = pointer_set_create ();\n+  collect_phi_def_edges (phi, cd_root, &def_edges, visited_phis);\n+  pointer_set_destroy (visited_phis);\n+\n+  n = VEC_length (edge, def_edges);\n+  if (n == 0)\n+    return false;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      size_t prev_nc, j;\n+      edge opnd_edge;\n+\n+      opnd_edge = VEC_index (edge, def_edges, i);\n+      prev_nc = num_chains;\n+      compute_control_dep_chain (cd_root, opnd_edge->src,\n+                                 dep_chains, &num_chains,\n+                                 &cur_chain);\n+      /* Free individual chain  */\n+      VEC_free (edge, heap, cur_chain);\n+      cur_chain = 0;\n+\n+      /* Now update the newly added chains with\n+         the phi operand edge:  */\n+      if (EDGE_COUNT (opnd_edge->src->succs) > 1)\n+        {\n+          if (prev_nc == num_chains\n+              && num_chains < MAX_NUM_CHAINS)\n+            num_chains++;\n+          for (j = prev_nc; j < num_chains; j++)\n+            {\n+              VEC_safe_push (edge, heap, dep_chains[j], opnd_edge);\n+            }\n+        }\n+    }\n+\n+  has_valid_pred\n+      = convert_control_dep_chain_into_preds (dep_chains,\n+                                              num_chains,\n+                                              preds,\n+                                              num_preds);\n+  for (i = 0; i < num_chains; i++)\n+      VEC_free (edge, heap, dep_chains[i]);\n+  free (dep_chains);\n+  return has_valid_pred;\n+}\n+\n+/* Dumps the predicates (PREDS) for USESTMT.  */\n+\n+static void\n+dump_predicates (gimple usestmt, size_t num_preds,\n+                 VEC(use_pred_info_t, heap) **preds,\n+                 const char* msg)\n+{\n+  size_t i, j;\n+  VEC(use_pred_info_t, heap) *one_pred_chain;\n+  fprintf (dump_file, msg);\n+  print_gimple_stmt (dump_file, usestmt, 0, 0);\n+  fprintf (dump_file, \"is guarded by :\\n\");\n+  /* do some dumping here:  */\n+  for (i = 0; i < num_preds; i++)\n+    {\n+      size_t np;\n+\n+      one_pred_chain = preds[i];\n+      np = VEC_length (use_pred_info_t, one_pred_chain);\n+\n+      for (j = 0; j < np; j++)\n+        {\n+          use_pred_info_t one_pred\n+              = VEC_index (use_pred_info_t, one_pred_chain, j);\n+          if (one_pred->invert)\n+            fprintf (dump_file, \" (.NOT.) \");\n+          print_gimple_stmt (dump_file, one_pred->cond, 0, 0);\n+          if (j < np - 1)\n+            fprintf (dump_file, \"(.AND.)\\n\");\n+        }\n+      if (i < num_preds - 1)\n+        fprintf (dump_file, \"(.OR.)\\n\");\n+    }\n+}\n+\n+/* Destroys the predicate set *PREDS.  */\n+\n+static void\n+destroy_predicate_vecs (size_t n,\n+                        VEC(use_pred_info_t, heap) ** preds)\n+{\n+  size_t i, j;\n+  for (i = 0; i < n; i++)\n+    {\n+      for (j = 0; j < VEC_length (use_pred_info_t, preds[i]); j++)\n+        free (VEC_index (use_pred_info_t, preds[i], j));\n+      VEC_free (use_pred_info_t, heap, preds[i]);\n+    }\n+  free (preds);\n+}\n+\n+\n+/* Computes the 'normalized' conditional code with operand \n+   swapping and condition inversion.  */\n+\n+static enum tree_code\n+get_cmp_code (enum tree_code orig_cmp_code,\n+              bool swap_cond, bool invert)\n+{\n+  enum tree_code tc = orig_cmp_code;\n+\n+  if (swap_cond)\n+    tc = swap_tree_comparison (orig_cmp_code);\n+  if (invert)\n+    tc = invert_tree_comparison (tc, false);\n+\n+  switch (tc)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      break;\n+    default:\n+      return ERROR_MARK;\n+    }\n+  return tc;\n+}\n+\n+/* Returns true if VAL falls in the range defined by BOUNDARY and CMPC, i.e.\n+   all values in the range satisfies (x CMPC BOUNDARY) == true.  */\n+\n+static bool\n+is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n+{\n+  bool inverted = false;\n+  bool is_unsigned;\n+  bool result;\n+\n+  /* Only handle integer constant here.  */\n+  if (TREE_CODE (val) != INTEGER_CST\n+      || TREE_CODE (boundary) != INTEGER_CST)\n+    return true;\n+\n+  is_unsigned = TYPE_UNSIGNED (TREE_TYPE (val));\n+\n+  if (cmpc == GE_EXPR || cmpc == GT_EXPR\n+      || cmpc == NE_EXPR)\n+    {\n+      cmpc = invert_tree_comparison (cmpc, false);\n+      inverted = true;\n+    }\n+\n+  if (is_unsigned)\n+    {\n+      if (cmpc == EQ_EXPR)\n+        result = tree_int_cst_equal (val, boundary);\n+      else if (cmpc == LT_EXPR)\n+        result = INT_CST_LT_UNSIGNED (val, boundary);\n+      else\n+        {\n+          gcc_assert (cmpc == LE_EXPR);\n+          result = (tree_int_cst_equal (val, boundary)\n+                    || INT_CST_LT_UNSIGNED (val, boundary));\n+        }\n+    }\n+  else\n+    {\n+      if (cmpc == EQ_EXPR)\n+        result = tree_int_cst_equal (val, boundary);\n+      else if (cmpc == LT_EXPR)\n+        result = INT_CST_LT (val, boundary);\n+      else\n+        {\n+          gcc_assert (cmpc == LE_EXPR);\n+          result = (tree_int_cst_equal (val, boundary)\n+                    || INT_CST_LT (val, boundary));\n+        }\n+    }\n+\n+  if (inverted)\n+    result ^= 1;\n+\n+  return result;\n+}\n+\n+/* Returns true if PRED is common among all the predicate\n+   chains (PREDS) (and therefore can be factored out).\n+   NUM_PRED_CHAIN is the size of array PREDS.  */\n+\n+static bool\n+find_matching_predicate_in_rest_chains (use_pred_info_t pred,\n+                                        VEC(use_pred_info_t, heap) **preds,\n+                                        size_t num_pred_chains)\n+{\n+  size_t i, j, n;\n+\n+  /* trival case  */\n+  if (num_pred_chains == 1)\n+    return true;\n+\n+  for (i = 1; i < num_pred_chains; i++)\n+    {\n+      bool found = false;\n+      VEC(use_pred_info_t, heap) *one_chain = preds[i];\n+      n = VEC_length (use_pred_info_t, one_chain);\n+      for (j = 0; j < n; j++)\n+        {\n+          use_pred_info_t pred2\n+              = VEC_index (use_pred_info_t, one_chain, j);\n+          /* can relax the condition comparison to not\n+             use address comparison. However, the most common\n+             case is that multiple control dependent paths share\n+             a common path prefix, so address comparison should\n+             be ok.  */\n+\n+          if (pred2->cond == pred->cond\n+              && pred2->invert == pred->invert)\n+            {\n+              found = true;\n+              break;\n+            }\n+        }\n+      if (!found)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+/* Forward declaration.  */\n+static bool\n+is_use_properly_guarded (gimple use_stmt,\n+                         basic_block use_bb,\n+                         gimple phi,\n+                         unsigned uninit_opnds,\n+                         struct pointer_set_t *visited_phis);\n+\n+/* A helper function that determines if the predicate set\n+   of the use is not overlapping with that of the uninit paths.\n+   The most common senario of guarded use is in Example 1:\n+     Example 1:\n+           if (some_cond)\n+           {\n+              x = ...;\n+              flag = true;\n+           }\n+\n+            ... some code ...\n+\n+           if (flag)\n+              use (x);\n+\n+     The real world examples are usually more complicated, but similar\n+     and usually result from inlining:\n+\n+         bool init_func (int * x)\n+         {\n+             if (some_cond)\n+                return false;\n+             *x  =  ..\n+             return true;\n+         }\n+\n+         void foo(..)\n+         {\n+             int x;\n+\n+             if (!init_func(&x))\n+                return;\n+\n+             .. some_code ...\n+             use (x);\n+         }\n+\n+     Another possible use scenario is in the following trivial example:\n+\n+     Example 2:\n+          if (n > 0)\n+             x = 1;\n+          ...\n+          if (n > 0)\n+            {\n+              if (m < 2)\n+                 .. = x;\n+            }\n+\n+     Predicate analysis needs to compute the composite predicate:\n+\n+       1) 'x' use predicate: (n > 0) .AND. (m < 2)\n+       2) 'x' default value  (non-def) predicate: .NOT. (n > 0)\n+       (the predicate chain for phi operand defs can be computed\n+       starting from a bb that is control equivalent to the phi's\n+       bb and is dominating the operand def.)\n+\n+       and check overlapping:\n+          (n > 0) .AND. (m < 2) .AND. (.NOT. (n > 0))\n+        <==> false\n+\n+     This implementation provides framework that can handle\n+     scenarios. (Note that many simple cases are handled properly\n+     without the predicate analysis -- this is due to jump threading\n+     transformation which eliminates the merge point thus makes\n+     path sensitive analysis unnecessary.)\n+\n+     NUM_PREDS is the number is the number predicate chains, PREDS is\n+     the array of chains, PHI is the phi node whose incoming (undefined)\n+     paths need to be pruned, and UNINIT_OPNDS is the bitmap holding\n+     uninit operand positions. VISITED_PHIS is the pointer set of phi\n+     stmts being checked.  */\n+\n+\n+static bool\n+use_pred_not_overlap_with_undef_path_pred (\n+    size_t num_preds,\n+    VEC(use_pred_info_t, heap) **preds,\n+    gimple phi, unsigned uninit_opnds,\n+    struct pointer_set_t *visited_phis)\n+{\n+  unsigned int i, n;\n+  gimple flag_def = 0;\n+  tree  boundary_cst = 0;\n+  enum tree_code cmp_code;\n+  bool swap_cond = false;\n+  bool invert = false;\n+  VEC(use_pred_info_t, heap) *the_pred_chain;\n+\n+  gcc_assert (num_preds > 0);\n+  /* Find within the common prefix of multiple predicate chains\n+     a predicate that is a comparison of a flag variable against\n+     a constant.  */\n+  the_pred_chain = preds[0];\n+  n = VEC_length (use_pred_info_t, the_pred_chain);\n+  for (i = 0; i < n; i++)\n+    {\n+      gimple cond;\n+      tree cond_lhs, cond_rhs, flag = 0;\n+\n+      use_pred_info_t the_pred\n+          = VEC_index (use_pred_info_t, the_pred_chain, i);\n+\n+      cond = the_pred->cond;\n+      invert = the_pred->invert;\n+      cond_lhs = gimple_cond_lhs (cond);\n+      cond_rhs = gimple_cond_rhs (cond);\n+      cmp_code = gimple_cond_code (cond);\n+\n+      if (cond_lhs != NULL_TREE && TREE_CODE (cond_lhs) == SSA_NAME\n+          && cond_rhs != NULL_TREE && is_gimple_constant (cond_rhs))\n+        {\n+          boundary_cst = cond_rhs;\n+          flag = cond_lhs;\n+        }\n+      else if (cond_rhs != NULL_TREE && TREE_CODE (cond_rhs) == SSA_NAME\n+               && cond_lhs != NULL_TREE && is_gimple_constant (cond_lhs))\n+        {\n+          boundary_cst = cond_lhs;\n+          flag = cond_rhs;\n+          swap_cond = true;\n+        }\n+\n+      if (!flag)\n+        continue;\n+\n+      flag_def = SSA_NAME_DEF_STMT (flag);\n+\n+      if (!flag_def)\n+        continue;\n+\n+      if ((gimple_code (flag_def) == GIMPLE_PHI)\n+          && (gimple_bb (flag_def) == gimple_bb (phi))\n+          && find_matching_predicate_in_rest_chains (\n+              the_pred, preds, num_preds))\n+        break;\n+\n+      flag_def = 0;\n+    }\n+\n+  if (!flag_def)\n+    return false;\n+\n+  /* Now check all the uninit incoming edge has a constant flag value\n+     that is in conflict with the use guard/predicate.  */\n+  cmp_code = get_cmp_code (cmp_code, swap_cond, invert);\n+\n+  if (cmp_code == ERROR_MARK)\n+    return false;\n+\n+  for (i = 0; i < sizeof (unsigned); i++)\n+    {\n+      tree flag_arg;\n+\n+      if (!MASK_TEST_BIT (uninit_opnds, i))\n+        continue;\n+\n+      flag_arg = gimple_phi_arg_def (flag_def, i);\n+      if (!is_gimple_constant (flag_arg))\n+        return false;\n+\n+      /* Now check if the constant is in the guarded range.  */\n+      if (is_value_included_in (flag_arg, boundary_cst, cmp_code))\n+        {\n+          tree opnd;\n+          gimple opnd_def;\n+\n+          /* Now that we know that this undefined edge is not\n+             pruned. If the operand is defined by another phi,\n+             we can further prune the incoming edges of that\n+             phi by checking the predicates of this operands.  */\n+\n+          opnd = gimple_phi_arg_def (phi, i);\n+          opnd_def = SSA_NAME_DEF_STMT (opnd);\n+          if (gimple_code (opnd_def) == GIMPLE_PHI)\n+            {\n+              edge opnd_edge;\n+              unsigned uninit_opnds2\n+                  = compute_uninit_opnds_pos (opnd_def);\n+              gcc_assert (!MASK_EMPTY (uninit_opnds2));\n+              opnd_edge = gimple_phi_arg_edge (phi, i);\n+              if (!is_use_properly_guarded (phi,\n+                                            opnd_edge->src,\n+                                            opnd_def,\n+                                            uninit_opnds2,\n+                                            visited_phis))\n+                  return false;\n+            }\n+          else\n+            return false;\n+        }\n+    }\n+\n+  return true;\n+}\n+\n+/* Returns true if TC is AND or OR */\n+\n+static inline bool\n+is_and_or_or (enum tree_code tc, tree typ)\n+{\n+  return (tc == TRUTH_AND_EXPR\n+          || tc == TRUTH_OR_EXPR\n+          || tc == BIT_IOR_EXPR\n+          || (tc == BIT_AND_EXPR\n+              && (typ == 0 || TREE_CODE (typ) == BOOLEAN_TYPE)));\n+}\n+\n+typedef struct norm_cond\n+{\n+  VEC(gimple, heap) *conds;\n+  enum tree_code cond_code;\n+  bool invert;\n+} *norm_cond_t;\n+\n+\n+/* Normalizes gimple condition COND. The normalization follows\n+   UD chains to form larger condition expression trees. NORM_COND\n+   holds the normalized result. COND_CODE is the logical opcode\n+   (AND or OR) of the normalized tree.  */\n+\n+static void\n+normalize_cond_1 (gimple cond,\n+                  norm_cond_t norm_cond,\n+                  enum tree_code cond_code)\n+{\n+  enum gimple_code gc;\n+  enum tree_code cur_cond_code;\n+  tree rhs1, rhs2;\n+\n+  gc = gimple_code (cond);\n+  if (gc != GIMPLE_ASSIGN)\n+    {\n+      VEC_safe_push (gimple, heap, norm_cond->conds, cond);\n+      return;\n+    }\n+\n+  cur_cond_code = gimple_assign_rhs_code (cond);\n+  rhs1 = gimple_assign_rhs1 (cond);\n+  rhs2 = gimple_assign_rhs2 (cond);\n+  if (cur_cond_code == NE_EXPR)\n+    {\n+      if (integer_zerop (rhs2)\n+          && (TREE_CODE (rhs1) == SSA_NAME))\n+        normalize_cond_1 (\n+            SSA_NAME_DEF_STMT (rhs1),\n+            norm_cond, cond_code);\n+      else if (integer_zerop (rhs1)\n+               && (TREE_CODE (rhs2) == SSA_NAME))\n+        normalize_cond_1 (\n+            SSA_NAME_DEF_STMT (rhs2),\n+            norm_cond, cond_code);\n+      else\n+        VEC_safe_push (gimple, heap, norm_cond->conds, cond);\n+\n+      return;\n+    }\n+\n+  if (is_and_or_or (cur_cond_code, TREE_TYPE (rhs1))\n+      && (cond_code == cur_cond_code || cond_code == ERROR_MARK)\n+      && (TREE_CODE (rhs1) == SSA_NAME && TREE_CODE (rhs2) == SSA_NAME))\n+    {\n+      normalize_cond_1 (SSA_NAME_DEF_STMT (rhs1),\n+                        norm_cond, cur_cond_code);\n+      normalize_cond_1 (SSA_NAME_DEF_STMT (rhs2),\n+                        norm_cond, cur_cond_code);\n+      norm_cond->cond_code = cur_cond_code;\n+    }\n+  else\n+    VEC_safe_push (gimple, heap, norm_cond->conds, cond);\n+}\n+\n+/* See normalize_cond_1 for details. INVERT is a flag to indicate\n+   if COND needs to be inverted or not.  */\n+\n+static void\n+normalize_cond (gimple cond, norm_cond_t norm_cond, bool invert)\n+{\n+  enum tree_code cond_code;\n+\n+  norm_cond->cond_code = ERROR_MARK;\n+  norm_cond->invert = false;\n+  norm_cond->conds = NULL;\n+  gcc_assert (gimple_code (cond) == GIMPLE_COND);\n+  cond_code = gimple_cond_code (cond);\n+  if (invert)\n+    cond_code = invert_tree_comparison (cond_code, false);\n+\n+  if (cond_code == NE_EXPR)\n+    {\n+      if (integer_zerop (gimple_cond_rhs (cond))\n+          && (TREE_CODE (gimple_cond_lhs (cond)) == SSA_NAME))\n+        normalize_cond_1 (\n+            SSA_NAME_DEF_STMT (gimple_cond_lhs (cond)),\n+            norm_cond, ERROR_MARK);\n+      else if (integer_zerop (gimple_cond_lhs (cond))\n+               && (TREE_CODE (gimple_cond_rhs (cond)) == SSA_NAME))\n+        normalize_cond_1 (\n+            SSA_NAME_DEF_STMT (gimple_cond_rhs (cond)),\n+            norm_cond, ERROR_MARK);\n+      else\n+        {\n+          VEC_safe_push (gimple, heap, norm_cond->conds, cond);\n+          norm_cond->invert = invert;\n+        }\n+    }\n+  else\n+    {\n+      VEC_safe_push (gimple, heap, norm_cond->conds, cond);\n+      norm_cond->invert = invert;\n+    }\n+\n+  gcc_assert (VEC_length (gimple, norm_cond->conds) == 1\n+              || is_and_or_or (norm_cond->cond_code, NULL));\n+}\n+\n+/* Returns true if the domain for condition COND1 is a subset of\n+   COND2. REVERSE is a flag. when it is true the function checks\n+   if COND1 is a superset of COND2. INVERT1 and INVERT2 are flags\n+   to indicate if COND1 and COND2 need to be inverted or not.  */\n+\n+static bool\n+is_gcond_subset_of (gimple cond1, bool invert1,\n+                    gimple cond2, bool invert2,\n+                    bool reverse)\n+{\n+  enum gimple_code gc1, gc2;\n+  enum tree_code cond1_code, cond2_code;\n+  gimple tmp;\n+  tree cond1_lhs, cond1_rhs, cond2_lhs, cond2_rhs;\n+\n+  /* Take the short cut.  */\n+  if (cond1 == cond2)\n+    return true;\n+\n+  if (reverse)\n+    {\n+      tmp = cond1;\n+      cond1 = cond2;\n+      cond2 = tmp;\n+    }\n+\n+  gc1 = gimple_code (cond1);\n+  gc2 = gimple_code (cond2);\n+\n+  if ((gc1 != GIMPLE_ASSIGN && gc1 != GIMPLE_COND)\n+      || (gc2 != GIMPLE_ASSIGN && gc2 != GIMPLE_COND))\n+    return cond1 == cond2;\n+\n+  cond1_code = ((gc1 == GIMPLE_ASSIGN)\n+                ? gimple_assign_rhs_code (cond1)\n+                : gimple_cond_code (cond1));\n+\n+  cond2_code = ((gc2 == GIMPLE_ASSIGN)\n+                ? gimple_assign_rhs_code (cond2)\n+                : gimple_cond_code (cond2));\n+\n+  if (TREE_CODE_CLASS (cond1_code) != tcc_comparison\n+      || TREE_CODE_CLASS (cond2_code) != tcc_comparison)\n+    return false;\n+\n+  if (invert1)\n+    cond1_code = invert_tree_comparison (cond1_code, false);\n+  if (invert2)\n+    cond2_code = invert_tree_comparison (cond2_code, false);\n+\n+  cond1_lhs = ((gc1 == GIMPLE_ASSIGN)\n+               ? gimple_assign_rhs1 (cond1)\n+               : gimple_cond_lhs (cond1));\n+  cond1_rhs = ((gc1 == GIMPLE_ASSIGN)\n+               ? gimple_assign_rhs2 (cond1)\n+               : gimple_cond_rhs (cond1));\n+  cond2_lhs = ((gc2 == GIMPLE_ASSIGN)\n+               ? gimple_assign_rhs1 (cond2)\n+               : gimple_cond_lhs (cond2));\n+  cond2_rhs = ((gc2 == GIMPLE_ASSIGN)\n+               ? gimple_assign_rhs2 (cond2)\n+               : gimple_cond_rhs (cond2));\n+\n+  /* Assuming const operands have been swapped to the\n+     rhs at this point of the analysis.  */\n+\n+  if (cond1_lhs != cond2_lhs)\n+    return false;\n+\n+  if (!is_gimple_constant (cond1_rhs)\n+      || TREE_CODE (cond1_rhs) != INTEGER_CST)\n+    return (cond1_rhs == cond2_rhs);\n+\n+  if (!is_gimple_constant (cond2_rhs)\n+      || TREE_CODE (cond2_rhs) != INTEGER_CST)\n+    return (cond1_rhs == cond2_rhs);\n+\n+  if (cond1_code == EQ_EXPR)\n+    return is_value_included_in (cond1_rhs,\n+                                 cond2_rhs, cond2_code);\n+  if (cond1_code == NE_EXPR || cond2_code == EQ_EXPR)\n+    return ((cond2_code == cond1_code)\n+            && tree_int_cst_equal (cond1_rhs, cond2_rhs));\n+\n+  if (((cond1_code == GE_EXPR || cond1_code == GT_EXPR)\n+       && (cond2_code == LE_EXPR || cond2_code == LT_EXPR))\n+      || ((cond1_code == LE_EXPR || cond1_code == LT_EXPR)\n+          && (cond2_code == GE_EXPR || cond2_code == GT_EXPR)))\n+    return false;\n+\n+  if (cond1_code != GE_EXPR && cond1_code != GT_EXPR\n+      && cond1_code != LE_EXPR && cond1_code != LT_EXPR)\n+    return false;\n+\n+  if (cond1_code == GT_EXPR)\n+    {\n+      cond1_code = GE_EXPR;\n+      cond1_rhs = fold_binary (PLUS_EXPR, TREE_TYPE (cond1_rhs),\n+                               cond1_rhs,\n+                               fold_convert (TREE_TYPE (cond1_rhs),\n+                                             integer_one_node));\n+    }\n+  else if (cond1_code == LT_EXPR)\n+    {\n+      cond1_code = LE_EXPR;\n+      cond1_rhs = fold_binary (MINUS_EXPR, TREE_TYPE (cond1_rhs),\n+                               cond1_rhs,\n+                               fold_convert (TREE_TYPE (cond1_rhs),\n+                                             integer_one_node));\n+    }\n+\n+  if (!cond1_rhs)\n+    return false;\n+\n+  gcc_assert (cond1_code == GE_EXPR || cond1_code == LE_EXPR);\n+\n+  if (cond2_code == GE_EXPR || cond2_code == GT_EXPR ||\n+      cond2_code == LE_EXPR || cond2_code == LT_EXPR)\n+    return is_value_included_in (cond1_rhs,\n+                                 cond2_rhs, cond2_code);\n+  else if (cond2_code == NE_EXPR)\n+    return\n+        (is_value_included_in (cond1_rhs,\n+                               cond2_rhs, cond2_code)\n+         && !is_value_included_in (cond2_rhs,\n+                                   cond1_rhs, cond1_code));\n+  return false;\n+}\n+\n+/* Returns true if the domain of the condition expression \n+   in COND is a subset of any of the sub-conditions\n+   of the normalized condtion NORM_COND.  INVERT is a flag\n+   to indicate of the COND needs to be inverted.\n+   REVERSE is a flag. When it is true, the check is reversed --\n+   it returns true if COND is a superset of any of the subconditions\n+   of NORM_COND.  */\n+\n+static bool\n+is_subset_of_any (gimple cond, bool invert,\n+                  norm_cond_t norm_cond, bool reverse)\n+{\n+  size_t i;\n+  size_t len = VEC_length (gimple, norm_cond->conds);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (is_gcond_subset_of (cond, invert,\n+                              VEC_index (gimple, norm_cond->conds, i),\n+                              false, reverse))\n+        return true;\n+    }\n+  return false;\n+}\n+\n+/* NORM_COND1 and NORM_COND2 are normalized logical/BIT OR\n+   expressions (formed by following UD chains not control\n+   dependence chains). The function returns true of domain\n+   of and expression NORM_COND1 is a subset of NORM_COND2's.\n+   The implementation is conservative, and it returns false if\n+   it the inclusion relationship may not hold.  */\n+\n+static bool\n+is_or_set_subset_of (norm_cond_t norm_cond1,\n+                     norm_cond_t norm_cond2)\n+{\n+  size_t i;\n+  size_t len = VEC_length (gimple, norm_cond1->conds);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (!is_subset_of_any (VEC_index (gimple, norm_cond1->conds, i),\n+                             false, norm_cond2, false))\n+        return false;\n+    }\n+  return true;\n+}\n+\n+/* NORM_COND1 and NORM_COND2 are normalized logical AND\n+   expressions (formed by following UD chains not control\n+   dependence chains). The function returns true of domain\n+   of and expression NORM_COND1 is a subset of NORM_COND2's.  */\n+\n+static bool\n+is_and_set_subset_of (norm_cond_t norm_cond1,\n+                      norm_cond_t norm_cond2)\n+{\n+  size_t i;\n+  size_t len = VEC_length (gimple, norm_cond2->conds);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (!is_subset_of_any (VEC_index (gimple, norm_cond2->conds, i),\n+                             false, norm_cond1, true))\n+        return false;\n+    }\n+  return true;\n+}\n+\n+/* Returns true of the domain if NORM_COND1 is a subset \n+   of that of NORM_COND2. Returns false if it can not be \n+   proved to be so.  */\n+\n+static bool\n+is_norm_cond_subset_of (norm_cond_t norm_cond1,\n+                        norm_cond_t norm_cond2)\n+{\n+  size_t i;\n+  enum tree_code code1, code2;\n+\n+  code1 = norm_cond1->cond_code;\n+  code2 = norm_cond2->cond_code;\n+\n+  if (code1 == TRUTH_AND_EXPR || code1 == BIT_AND_EXPR)\n+    {\n+      /* Both conditions are AND expressions.  */\n+      if (code2 == TRUTH_AND_EXPR || code2 == BIT_AND_EXPR)\n+        return is_and_set_subset_of (norm_cond1, norm_cond2);\n+      /* NORM_COND1 is an AND expression, and NORM_COND2 is an OR\n+         expression. In this case, returns true if any subexpression\n+         of NORM_COND1 is a subset of any subexpression of NORM_COND2.  */\n+      else if (code2 == TRUTH_OR_EXPR || code2 == BIT_IOR_EXPR)\n+        {\n+          size_t len1;\n+          len1 = VEC_length (gimple, norm_cond1->conds);\n+          for (i = 0; i < len1; i++)\n+            {\n+              gimple cond1 = VEC_index (gimple, norm_cond1->conds, i);\n+              if (is_subset_of_any (cond1, false, norm_cond2, false))\n+                return true;\n+            }\n+          return false;\n+        }\n+      else\n+        {\n+          gcc_assert (code2 == ERROR_MARK);\n+          gcc_assert (VEC_length (gimple, norm_cond2->conds) == 1);\n+          return is_subset_of_any (VEC_index (gimple, norm_cond2->conds, 0),\n+                                   norm_cond2->invert, norm_cond1, true);\n+        }\n+    }\n+  /* NORM_COND1 is an OR expression  */\n+  else if (code1 == TRUTH_OR_EXPR || code1 == BIT_IOR_EXPR)\n+    {\n+      if (code2 != code1)\n+        return false;\n+\n+      return is_or_set_subset_of (norm_cond1, norm_cond2);\n+    }\n+  else\n+    {\n+      gcc_assert (code1 == ERROR_MARK);\n+      gcc_assert (VEC_length (gimple, norm_cond1->conds) == 1);\n+      /* Conservatively returns false if NORM_COND1 is non-decomposible\n+         and NORM_COND2 is an AND expression.  */\n+      if (code2 == TRUTH_AND_EXPR || code2 == BIT_AND_EXPR)\n+        return false;\n+\n+      if (code2 == TRUTH_OR_EXPR || code2 == BIT_IOR_EXPR)\n+        return is_subset_of_any (VEC_index (gimple, norm_cond1->conds, 0),\n+                                 norm_cond1->invert, norm_cond2, false);\n+\n+      gcc_assert (code2 == ERROR_MARK);\n+      gcc_assert (VEC_length (gimple, norm_cond2->conds) == 1);\n+      return is_gcond_subset_of (VEC_index (gimple, norm_cond1->conds, 0),\n+                                 norm_cond1->invert,\n+                                 VEC_index (gimple, norm_cond2->conds, 0),\n+                                 norm_cond2->invert, false);\n+    }\n+}\n+\n+/* Returns true of the domain of single predicate expression\n+   EXPR1 is a subset of that of EXPR2. Returns false if it\n+   can not be proved.  */\n+\n+static bool\n+is_pred_expr_subset_of (use_pred_info_t expr1,\n+                        use_pred_info_t expr2)\n+{\n+  gimple cond1, cond2;\n+  enum tree_code code1, code2;\n+  struct norm_cond norm_cond1, norm_cond2;\n+  bool is_subset = false;\n+\n+  cond1 = expr1->cond;\n+  cond2 = expr2->cond;\n+  code1 = gimple_cond_code (cond1);\n+  code2 = gimple_cond_code (cond2);\n+\n+  if (expr1->invert)\n+    code1 = invert_tree_comparison (code1, false);\n+  if (expr2->invert)\n+    code2 = invert_tree_comparison (code2, false);\n+\n+  /* Fast path -- match exactly  */\n+  if ((gimple_cond_lhs (cond1) == gimple_cond_lhs (cond2))\n+      && (gimple_cond_rhs (cond1) == gimple_cond_rhs (cond2))\n+      && (code1 == code2))\n+    return true;\n+\n+  /* Normalize conditions. To keep NE_EXPR, do not invert\n+     with both need inversion.  */\n+  normalize_cond (cond1, &norm_cond1, (expr1->invert));\n+  normalize_cond (cond2, &norm_cond2, (expr2->invert));\n+\n+  is_subset = is_norm_cond_subset_of (&norm_cond1, &norm_cond2);\n+\n+  /* Free memory  */\n+  VEC_free (gimple, heap, norm_cond1.conds);\n+  VEC_free (gimple, heap, norm_cond2.conds);\n+  return is_subset ;\n+}\n+\n+/* Returns true if the domain of PRED1 is a subset\n+   of that of PRED2. Returns false if it can not be proved so.  */\n+\n+static bool\n+is_pred_chain_subset_of (VEC(use_pred_info_t, heap) *pred1,\n+                         VEC(use_pred_info_t, heap) *pred2)\n+{\n+  size_t np1, np2, i1, i2;\n+\n+  np1 = VEC_length (use_pred_info_t, pred1);\n+  np2 = VEC_length (use_pred_info_t, pred2);\n+\n+  for (i2 = 0; i2 < np2; i2++)\n+    {\n+      bool found = false;\n+      use_pred_info_t info2\n+          = VEC_index (use_pred_info_t, pred2, i2);\n+      for (i1 = 0; i1 < np1; i1++)\n+        {\n+          use_pred_info_t info1\n+              = VEC_index (use_pred_info_t, pred1, i1);\n+          if (is_pred_expr_subset_of (info1, info2))\n+            {\n+              found = true;\n+              break;\n+            }\n+        }\n+      if (!found)\n+        return false;\n+    }\n+  return true;\n+}\n+\n+/* Returns true if the domain defined by\n+   one pred chain ONE_PRED is a subset of the domain\n+   of *PREDS. It returns false if ONE_PRED's domain is\n+   not a subset of any of the sub-domains of PREDS (\n+   corresponding to each individual chains in it), even\n+   though it may be still be a subset of whole domain\n+   of PREDS which is the union (ORed) of all its subdomains.\n+   In other words, the result is conservative.  */\n+\n+static bool\n+is_included_in (VEC(use_pred_info_t, heap) *one_pred,\n+                VEC(use_pred_info_t, heap) **preds,\n+                size_t n)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      if (is_pred_chain_subset_of (one_pred, preds[i]))\n+        return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* compares two predicate sets PREDS1 and PREDS2 and returns\n+   true if the domain defined by PREDS1 is a superset\n+   of PREDS2's domain. N1 and N2 are array sizes of PREDS1 and\n+   PREDS2 respectively. The implementation chooses not to build\n+   generic trees (and relying on the folding capability of the\n+   compiler), but instead performs brute force comparison of\n+   individual predicate chains (won't be a compile time problem\n+   as the chains are pretty short). When the function returns\n+   false, it does not necessarily mean *PREDS1 is not a superset\n+   of *PREDS2, but mean it may not be so since the analysis can\n+   not prove it. In such cases, false warnings may still be\n+   emitted.  */\n+\n+static bool\n+is_superset_of (VEC(use_pred_info_t, heap) **preds1,\n+                size_t n1,\n+                VEC(use_pred_info_t, heap) **preds2,\n+                size_t n2)\n+{\n+  size_t i;\n+  VEC(use_pred_info_t, heap) *one_pred_chain;\n+\n+  for (i = 0; i < n2; i++)\n+    {\n+      one_pred_chain = preds2[i];\n+      if (!is_included_in (one_pred_chain, preds1, n1))\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Computes the predicates that guard the use and checks\n+   if the incoming paths that have empty (or possibly\n+   empty) defintion can be pruned/filtered. The function returns\n+   true if it can be determined that the use of PHI's def in\n+   USE_STMT is guarded with a predicate set not overlapping with\n+   predicate sets of all runtime paths that do not have a definition.\n+   Returns false if it is not or it can not be determined. USE_BB is\n+   the bb of the use (for phi operand use, the bb is not the bb of\n+   the phi stmt, but the src bb of the operand edge). UNINIT_OPNDS\n+   is a bit vector. If an operand of PHI is uninitialized, the\n+   correponding bit in the vector is 1.  VISIED_PHIS is a pointer\n+   set of phis being visted.  */\n+\n+static bool\n+is_use_properly_guarded (gimple use_stmt,\n+                         basic_block use_bb,\n+                         gimple phi,\n+                         unsigned uninit_opnds,\n+                         struct pointer_set_t *visited_phis)\n+{\n+  basic_block phi_bb;\n+  VEC(use_pred_info_t, heap) **preds = 0;\n+  VEC(use_pred_info_t, heap) **def_preds = 0;\n+  size_t num_preds = 0, num_def_preds = 0;\n+  bool has_valid_preds = false;\n+  bool is_properly_guarded = false;\n+\n+  if (pointer_set_insert (visited_phis, phi))\n+    return false;\n+\n+  phi_bb = gimple_bb (phi);\n+\n+  if (is_non_loop_exit_postdominating (use_bb, phi_bb))\n+    return false;\n+\n+  has_valid_preds = find_predicates (&preds, &num_preds,\n+                                     phi_bb, use_bb);\n+\n+  if (!has_valid_preds)\n+    {\n+      destroy_predicate_vecs (num_preds, preds);\n+      return false;\n+    }\n+\n+  if (dump_file)\n+    dump_predicates (use_stmt, num_preds, preds,\n+                     \"Use in stmt \");\n+\n+  has_valid_preds = find_def_preds (&def_preds,\n+                                    &num_def_preds, phi);\n+\n+  if (has_valid_preds)\n+    {\n+      if (dump_file)\n+        dump_predicates (phi, num_def_preds, def_preds,\n+                         \"Operand defs of phi \");\n+      is_properly_guarded =\n+          is_superset_of (def_preds, num_def_preds,\n+                          preds, num_preds);\n+    }\n+\n+  /* further prune the dead incoming phi edges. */\n+  if (!is_properly_guarded)\n+    is_properly_guarded\n+        = use_pred_not_overlap_with_undef_path_pred (\n+            num_preds, preds, phi, uninit_opnds, visited_phis);\n+\n+  destroy_predicate_vecs (num_preds, preds);\n+  destroy_predicate_vecs (num_def_preds, def_preds);\n+  return is_properly_guarded;\n+}\n+\n+/* Searches through all uses of a potentially\n+   uninitialized variable defined by PHI and returns a use\n+   statement if the use is not properly guarded. It returns\n+   NULL if all uses are guarded. UNINIT_OPNDS is a bitvector\n+   holding the position(s) of uninit PHI operands. WORKLIST\n+   is the vector of candidate phis that may be updated by this\n+   function. ADDED_TO_WORKLIST is the pointer set tracking\n+   if the new phi is already in the worklist.  */\n+\n+static gimple\n+find_uninit_use (gimple phi, unsigned uninit_opnds,\n+                 VEC(gimple, heap) **worklist,\n+\t\t struct pointer_set_t *added_to_worklist)\n+{\n+  tree phi_result;\n+  use_operand_p use_p;\n+  gimple use_stmt;\n+  imm_use_iterator iter;\n+\n+  phi_result = gimple_phi_result (phi);\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, phi_result)\n+    {\n+      struct pointer_set_t *visited_phis;\n+      basic_block use_bb;\n+\n+      use_stmt = use_p->loc.stmt;\n+\n+      visited_phis = pointer_set_create ();\n+\n+      use_bb = gimple_bb (use_stmt);\n+      if (gimple_code (use_stmt) == GIMPLE_PHI)\n+        {\n+\t  unsigned i, n;\n+          n = gimple_phi_num_args (use_stmt);\n+\n+          /* Find the matching phi argument of the use.  */\n+          for (i = 0; i < n; ++i)\n+            {\n+               if (gimple_phi_arg_def_ptr (use_stmt, i) == use_p->use)\n+\t         {\n+\t\t    edge e = gimple_phi_arg_edge (use_stmt, i);\n+\t\t    use_bb = e->src;\n+                    break;\n+\t\t }\n+\t    }\n+\t}\n+\n+      if (is_use_properly_guarded (use_stmt,\n+                                   use_bb, \n+                                   phi,\n+                                   uninit_opnds,\n+                                   visited_phis))\n+        {\n+          pointer_set_destroy (visited_phis);\n+          continue;\n+        }\n+      pointer_set_destroy (visited_phis);\n+\n+      /* Found one real use, return.  */\n+      if (gimple_code (use_stmt) != GIMPLE_PHI)\n+         return use_stmt;\n+\n+      /* Found a phi use that is not guarded,\n+         add the phi to the worklist.  */\n+      if (!pointer_set_insert (added_to_worklist,\n+                               use_stmt))\n+        {\n+          VEC_safe_push (gimple, heap, *worklist, use_stmt);\n+          pointer_set_insert (possibly_undefined_names,\n+\t                      phi_result);\n+        }\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n+   and gives warning if there exists a runtime path from the entry to a\n+   use of the PHI def that does not contain a definition. In other words,\n+   the warning is on the real use. The more dead paths that can be pruned\n+   by the compiler, the fewer false positives the warning is. WORKLIST\n+   is a vector of candidate phis to be examined. ADDED_TO_WORKLIST is\n+   a pointer set tracking if the new phi is added to the worklist or not.  */\n+\n+static void\n+warn_uninitialized_phi (gimple phi, VEC(gimple, heap) **worklist,\n+                        struct pointer_set_t *added_to_worklist)\n+{\n+  unsigned uninit_opnds;\n+  gimple uninit_use_stmt = 0;\n+  tree uninit_op;\n+\n+  /* Don't look at memory tags.  */\n+  if (!is_gimple_reg (gimple_phi_result (phi)))\n+    return;\n+\n+  uninit_opnds = compute_uninit_opnds_pos (phi);\n+\n+  if  (MASK_EMPTY (uninit_opnds))\n+    return;\n+\n+  /* Now check if we have any use of the value without proper guard.  */\n+  uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n+                                     worklist, added_to_worklist);\n+\n+  /* All uses are properly guarded.  */\n+  if (!uninit_use_stmt)\n+    return;\n+\n+  uninit_op = gimple_phi_arg_def (phi, MASK_FIRST_SET_BIT (uninit_opnds));\n+  warn_uninit (uninit_op,\n+               \"%qD may be used uninitialized in this function\",\n+               uninit_use_stmt);\n+\n+}\n+\n+\n+/* Entry point to the late uninitialized warning pass.  */\n+\n+static unsigned int\n+execute_late_warn_uninitialized (void)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  VEC(gimple, heap) *worklist = 0;\n+  struct pointer_set_t *added_to_worklist;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  /* Re-do the plain uninitialized variable check, as optimization may have\n+     straightened control flow.  Do this first so that we don't accidentally\n+     get a \"may be\" warning when we'd have seen an \"is\" warning later.  */\n+  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/1);\n+\n+  timevar_push (TV_TREE_UNINIT);\n+\n+  possibly_undefined_names = pointer_set_create ();\n+  added_to_worklist = pointer_set_create ();\n+\n+  /* Initialize worklist  */\n+  FOR_EACH_BB (bb)\n+    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+        gimple phi = gsi_stmt (gsi);\n+        size_t n, i;\n+\n+        n = gimple_phi_num_args (phi);\n+\n+        /* Don't look at memory tags.  */\n+        if (!is_gimple_reg (gimple_phi_result (phi)))\n+          continue;\n+\n+        for (i = 0; i < n; ++i)\n+          {\n+            tree op = gimple_phi_arg_def (phi, i);\n+            if (TREE_CODE (op) == SSA_NAME\n+                && ssa_undefined_value_p (op))\n+              {\n+                VEC_safe_push (gimple, heap, worklist, phi);\n+\t\tpointer_set_insert (added_to_worklist, phi);\n+                break;\n+              }\n+          }\n+      }\n+\n+  while (VEC_length (gimple, worklist) != 0)\n+    {\n+      gimple cur_phi = 0;\n+      cur_phi = VEC_pop (gimple, worklist);\n+      warn_uninitialized_phi (cur_phi, &worklist, added_to_worklist);\n+    }\n+  \n+  VEC_free (gimple, heap, worklist);\n+  pointer_set_destroy (added_to_worklist);\n+  pointer_set_destroy (possibly_undefined_names);\n+  possibly_undefined_names = NULL;\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  timevar_pop (TV_TREE_UNINIT);\n+  return 0;\n+}\n+\n+static bool\n+gate_warn_uninitialized (void)\n+{\n+  return warn_uninitialized != 0;\n+}\n+\n+struct gimple_opt_pass pass_late_warn_uninitialized =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"uninit\",\t\t\t\t/* name */\n+  gate_warn_uninitialized,\t\t/* gate */\n+  execute_late_warn_uninitialized,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_NONE,     \t        \t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};"}, {"sha": "820eb3b376ab01819853694434ff505c141744e5", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 7, "deletions": 82, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f97b9407c6a39f133b3446e8c788d19a9f9e34/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=34f97b9407c6a39f133b3446e8c788d19a9f9e34", "patch": "@@ -1603,25 +1603,6 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n }\n \n \f\n-/* Return true if T, an SSA_NAME, has an undefined value.  */\n-\n-bool\n-ssa_undefined_value_p (tree t)\n-{\n-  tree var = SSA_NAME_VAR (t);\n-\n-  /* Parameters get their initial value from the function entry.  */\n-  if (TREE_CODE (var) == PARM_DECL)\n-    return false;\n-\n-  /* Hard register variables get their initial value from the ether.  */\n-  if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n-    return false;\n-\n-  /* The value is undefined iff its definition statement is empty.  */\n-  return gimple_nop_p (SSA_NAME_DEF_STMT (t));\n-}\n-\n /* Emit warnings for uninitialized variables.  This is done in two passes.\n \n    The first pass notices real uses of SSA names with undefined values.\n@@ -1640,7 +1621,7 @@ ssa_undefined_value_p (tree t)\n /* Emit a warning for T, an SSA_NAME, being uninitialized.  The exact\n    warning text is in MSGID and LOCUS may contain a location or be null.  */\n \n-static void\n+void\n warn_uninit (tree t, const char *gmsgid, void *data)\n {\n   tree var = SSA_NAME_VAR (t);\n@@ -1770,28 +1751,7 @@ warn_uninitialized_var (tree *tp, int *walk_subtrees, void *data_)\n   return NULL_TREE;\n }\n \n-/* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n-   and warn about them.  */\n-\n-static void\n-warn_uninitialized_phi (gimple phi)\n-{\n-  size_t i, n = gimple_phi_num_args (phi);\n-\n-  /* Don't look at memory tags.  */\n-  if (!is_gimple_reg (gimple_phi_result (phi)))\n-    return;\n-\n-  for (i = 0; i < n; ++i)\n-    {\n-      tree op = gimple_phi_arg_def (phi, i);\n-      if (TREE_CODE (op) == SSA_NAME)\n-\twarn_uninit (op, \"%qD may be used uninitialized in this function\",\n-\t\t     NULL);\n-    }\n-}\n-\n-static unsigned int\n+unsigned int\n warn_uninitialized_vars (bool warn_possibly_uninitialized)\n {\n   gimple_stmt_iterator gsi;\n@@ -1800,7 +1760,6 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \n   data.warn_possibly_uninitialized = warn_possibly_uninitialized;\n \n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -1818,10 +1777,6 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t}\n     }\n \n-  /* Post-dominator information can not be reliably updated. Free it\n-     after the use.  */\n-\n-  free_dominance_info (CDI_POST_DOMINATORS);\n   return 0;\n }\n \n@@ -1834,25 +1789,14 @@ execute_early_warn_uninitialized (void)\n      as possible, thus don't do it here.  However, without\n      optimization we need to warn here about \"may be uninitialized\".\n   */\n-  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n-  return 0;\n-}\n-\n-static unsigned int\n-execute_late_warn_uninitialized (void)\n-{\n-  basic_block bb;\n-  gimple_stmt_iterator gsi;\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n \n-  /* Re-do the plain uninitialized variable check, as optimization may have\n-     straightened control flow.  Do this first so that we don't accidentally\n-     get a \"may be\" warning when we'd have seen an \"is\" warning later.  */\n-  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/1);\n+  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n \n-  FOR_EACH_BB (bb)\n-    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      warn_uninitialized_phi (gsi_stmt (gsi));\n+  /* Post-dominator information can not be reliably updated. Free it\n+     after the use.  */\n \n+  free_dominance_info (CDI_POST_DOMINATORS);\n   return 0;\n }\n \n@@ -1881,25 +1825,6 @@ struct gimple_opt_pass pass_early_warn_uninitialized =\n  }\n };\n \n-struct gimple_opt_pass pass_late_warn_uninitialized =\n-{\n- {\n-  GIMPLE_PASS,\n-  \"*late_warn_uninitialized\",\t\t/* name */\n-  gate_warn_uninitialized,\t\t/* gate */\n-  execute_late_warn_uninitialized,\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_NONE,\t\t\t\t/* tv_id */\n-  PROP_ssa,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};\n-\n /* Compute TREE_ADDRESSABLE and DECL_GIMPLE_REG_P for local variables.  */\n \n void"}]}