{"sha": "7f2935c734c36f84ab62b20a04de465e19061333", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YyOTM1YzczNGMzNmY4NGFiNjJiMjBhMDRkZTQ2NWUxOTA2MTMzMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-03-16T21:59:07Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-03-16T21:59:07Z"}, "message": "Initial revision\n\nFrom-SVN: r9191", "tree": {"sha": "0194faf594c2891f5c06b75959e9314b81c1b28c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0194faf594c2891f5c06b75959e9314b81c1b28c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f2935c734c36f84ab62b20a04de465e19061333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2935c734c36f84ab62b20a04de465e19061333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2935c734c36f84ab62b20a04de465e19061333", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2935c734c36f84ab62b20a04de465e19061333/comments", "author": null, "committer": null, "parents": [{"sha": "b310a51d35b01c9ce4e617e357ade93d87cd1c90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b310a51d35b01c9ce4e617e357ade93d87cd1c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b310a51d35b01c9ce4e617e357ade93d87cd1c90"}], "stats": {"total": 9686, "additions": 9686, "deletions": 0}, "files": [{"sha": "aa37aac25b5c0105857fbea05ab8feee9ed53b43", "filename": "gcc/cppalloc.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcppalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcppalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppalloc.c?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,81 @@\n+/* Part of CPP library.  (memory allocation - xmalloc etc)\n+   Copyright (C) 1986, 87, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994.\n+   Based on CCCP program by by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+static void\n+memory_full ()\n+{\n+  fatal (\"Memory exhausted.\");\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *ptr = (char *) malloc (size);\n+  if (ptr != 0) return (ptr);\n+  memory_full ();\n+  /*NOTREACHED*/\n+  return 0;\n+}\n+\n+char *\n+xrealloc (old, size)\n+     char *old;\n+     unsigned size;\n+{\n+  register char *ptr = (char *) realloc (old, size);\n+  if (ptr != 0) return (ptr);\n+  memory_full ();\n+  /*NOTREACHED*/\n+  return 0;\n+}\n+\n+char *\n+xcalloc (number, size)\n+     unsigned number, size;\n+{\n+  register unsigned total = number * size;\n+  register char *ptr = (char *) malloc (total);\n+  if (ptr != 0) {\n+    if (total > 100)\n+      bzero (ptr, total);\n+    else {\n+      /* It's not too long, so loop, zeroing by longs.\n+\t It must be safe because malloc values are always well aligned.  */\n+      register long *zp = (long *) ptr;\n+      register long *zl = (long *) (ptr + total - 4);\n+      register int i = total - 4;\n+      while (zp < zl)\n+\t*zp++ = 0;\n+      if (i < 0)\n+\ti = 0;\n+      while (i < total)\n+\tptr[i++] = 0;\n+    }\n+    return ptr;\n+  }\n+  memory_full ();\n+  /*NOTREACHED*/\n+  return 0;\n+}"}, {"sha": "e552989087c1ffd96cbf3da53f52007822623d81", "filename": "gcc/cpperror.c", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,338 @@\n+/* Default error handlers for CPP Library.\n+   Copyright (C) 1986, 87, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994.\n+   Based on CCCP program by by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"cpplib.h\"\n+#include <stdio.h>\n+\n+/* This defines \"errno\" properly for VMS, and gives us EACCES. */\n+#include <errno.h>\n+#ifndef errno\n+extern int errno;\n+#endif\n+\n+#ifndef VMS\n+#ifndef HAVE_STRERROR\n+extern int sys_nerr;\n+#if defined(bsd4_4) || defined(__NetBSD__)\n+extern const char *const sys_errlist[];\n+#else\n+extern char *sys_errlist[];\n+#endif\n+#else\t/* HAVE_STERRROR */\n+char *strerror ();\n+#endif\n+#else\t/* VMS */\n+char *strerror (int,...);\n+#endif\n+\n+/* Print the file names and line numbers of the #include\n+   commands which led to the current file.  */\n+\n+void\n+cpp_print_containing_files (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip;\n+  int i;\n+  int first = 1;\n+\n+  /* If stack of files hasn't changed since we last printed\n+     this info, don't repeat it.  */\n+  if (pfile->input_stack_listing_current)\n+    return;\n+\n+  ip = cpp_file_buffer (pfile);\n+\n+  /* Give up if we don't find a source file.  */\n+  if (ip == NULL)\n+    return;\n+\n+  /* Find the other, outer source files.  */\n+  while ((ip = CPP_PREV_BUFFER (ip)), ip != CPP_NULL_BUFFER (pfile))\n+    {\n+      long line, col;\n+      cpp_buf_line_and_col (ip, &line, &col);\n+      if (ip->fname != NULL)\n+\t{\n+\t  if (first)\n+\t    {\n+\t      first = 0;\n+\t      fprintf (stderr, \"In file included\");\n+\t    }\n+\t  else\n+\t    fprintf (stderr, \",\\n                \");\n+\t}\n+\n+/* start-sanitize-mpw */\n+#ifdef MPW\n+      fprintf (stderr, \" File \\\"%s\\\"; Line %d  # \", ip->nominal_fname, line);\n+#else\n+/* end-sanitize-mpw */\n+      fprintf (stderr, \" from %s:%d\", ip->nominal_fname, line);\n+/* start-sanitize-mpw */\n+#endif /* MPW */\n+/* end-sanitize-mpw */\n+    }\n+  if (! first)\n+    fprintf (stderr, \":\\n\");\n+\n+  /* Record we have printed the status as of this time.  */\n+  pfile->input_stack_listing_current = 1;\n+}\n+\n+void\n+cpp_print_file_and_line (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  if (ip != NULL)\n+    {\n+      long line, col;\n+      cpp_buf_line_and_col (ip, &line, &col);\n+      if (pfile->show_column)\n+\tfprintf (stderr, \"%s:%d:%d: \", ip->nominal_fname, line, col);\n+      else\n+\tfprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n+    }\n+}\n+\n+void\n+cpp_error (pfile, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  cpp_print_containing_files (pfile);\n+  cpp_print_file_and_line (pfile);\n+  fprintf (stderr, msg, arg1, arg2, arg3);\n+  fprintf (stderr, \"\\n\");\n+  pfile->errors++;\n+}\n+\n+/* Print error message but don't count it.  */\n+\n+void\n+cpp_warning (pfile, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n+    pfile->errors++;\n+\n+  cpp_print_containing_files (pfile);\n+  cpp_print_file_and_line (pfile);\n+  fprintf (stderr, \"warning: \");\n+  fprintf (stderr, msg, arg1, arg2, arg3);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+void\n+cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  int i;\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  cpp_print_containing_files (pfile);\n+\n+  if (ip != NULL)\n+    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n+\n+  fprintf (stderr, msg, arg1, arg2, arg3);\n+  fprintf (stderr, \"\\n\");\n+  pfile->errors++;\n+}\n+\n+void\n+cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  int i;\n+  cpp_buffer *ip;\n+\n+  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n+    pfile->errors++;\n+\n+  cpp_print_containing_files (pfile);\n+\n+  ip = cpp_file_buffer (pfile);\n+\n+  if (ip != NULL)\n+    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n+  fprintf (stderr, \"warning: \");\n+  fprintf (stderr, msg, arg1, arg2, arg3);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+/* Print an error message and maybe count it.  */\n+\n+void\n+cpp_pedwarn (pfile, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (CPP_OPTIONS (pfile)->pedantic_errors)\n+    cpp_error (pfile, msg, arg1, arg2, arg3);\n+  else\n+    cpp_warning (pfile, msg, arg1, arg2, arg3);\n+}\n+\n+void\n+cpp_pedwarn_with_line (pfile, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (CPP_OPTIONS (pfile)->pedantic_errors)\n+    cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3);\n+  else\n+    cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3);\n+}\n+\n+/* Report a warning (or an error if pedantic_errors)\n+   giving specified file name and line number, not current.  */\n+\n+void\n+cpp_pedwarn_with_file_and_line (pfile, file, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *file;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (!CPP_OPTIONS (pfile)->pedantic_errors\n+      && CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+  if (file != NULL)\n+    fprintf (stderr, \"%s:%d: \", file, line);\n+  if (CPP_OPTIONS (pfile)->pedantic_errors)\n+    pfile->errors++;\n+  else\n+    fprintf (stderr, \"warning: \");\n+  fprintf (stderr, msg, arg1, arg2, arg3);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+void\n+fatal (str, arg)\n+     char *str, *arg;\n+{\n+  fprintf (stderr, \"%s: \", progname);\n+  fprintf (stderr, str, arg);\n+  fprintf (stderr, \"\\n\");\n+  exit (FAILURE_EXIT_CODE);\n+}\n+\n+\f\n+/*\n+ * my_strerror - return the descriptive text associated with an `errno' code.\n+ */\n+\n+char *\n+my_strerror (errnum)\n+     int errnum;\n+{\n+  char *result;\n+\n+#ifndef VMS\n+#ifndef HAVE_STRERROR\n+  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);\n+#else\n+  result = strerror (errnum);\n+#endif\n+#else\t/* VMS */\n+  /* VAXCRTL's strerror() takes an optional second argument, which only\n+     matters when the first argument is EVMSERR.  However, it's simplest\n+     just to pass it unconditionally.  `vaxc$errno' is declared in\n+     <errno.h>, and maintained by the library in parallel with `errno'.\n+     We assume that caller's `errnum' either matches the last setting of\n+     `errno' by the library or else does not have the value `EVMSERR'.  */\n+\n+  result = strerror (errnum, vaxc$errno);\n+#endif\n+\n+  if (!result)\n+    result = \"undocumented I/O error\";\n+\n+  return result;\n+}\n+\n+/* Error including a message from `errno'.  */\n+\n+void\n+cpp_error_from_errno (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  int i;\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  cpp_print_containing_files (pfile);\n+\n+  if (ip != NULL)\n+    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n+\n+  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (errno));\n+\n+  pfile->errors++;\n+}\n+\n+void\n+cpp_perror_with_name (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  fprintf (stderr, \"%s: \", progname);\n+  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (errno));\n+  pfile->errors++;\n+}\n+\n+void\n+cpp_pfatal_with_name (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  cpp_perror_with_name (pfile, name);\n+#ifdef VMS\n+  exit (vaxc$errno);\n+#else\n+  exit (FAILURE_EXIT_CODE);\n+#endif\n+}"}, {"sha": "11fdfdd95ebde0b08ce3ee94d2b2902b2621462e", "filename": "gcc/cppexp.c", "status": "added", "additions": 988, "deletions": 0, "changes": 988, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,988 @@\n+/* Parse C expressions for CCCP.\n+   Copyright (C) 1987, 1992, 1994, 1995 Free Software Foundation.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!\n+\n+Written by Per Bothner 1994. */\n+\n+/* Parse a C expression from text in a string  */\n+   \n+#include \"config.h\"\n+#include \"cpplib.h\"\n+\n+#ifdef MULTIBYTE_CHARS\n+#include <stdlib.h>\n+#include <locale.h>\n+#endif\n+\n+#include <stdio.h>\n+\n+/* This is used for communicating lists of keywords with cccp.c.  */\n+struct arglist {\n+  struct arglist *next;\n+  U_CHAR *name;\n+  int length;\n+  int argno;\n+};\n+\n+/* Define a generic NULL if one hasn't already been defined.  */\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef GENERIC_PTR\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define GENERIC_PTR void *\n+#else\n+#define GENERIC_PTR char *\n+#endif\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR ((GENERIC_PTR)0)\n+#endif\n+\n+extern char *xmalloc ();\n+\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n+#endif\n+\n+#ifndef MAX_CHAR_TYPE_SIZE\n+#define MAX_CHAR_TYPE_SIZE CHAR_TYPE_SIZE\n+#endif\n+\n+#ifndef MAX_INT_TYPE_SIZE\n+#define MAX_INT_TYPE_SIZE INT_TYPE_SIZE\n+#endif\n+\n+#ifndef MAX_LONG_TYPE_SIZE\n+#define MAX_LONG_TYPE_SIZE LONG_TYPE_SIZE\n+#endif\n+\n+#ifndef MAX_WCHAR_TYPE_SIZE\n+#define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n+#endif\n+\n+/* Yield nonzero if adding two numbers with A's and B's signs can yield a\n+   number with SUM's sign, where A, B, and SUM are all C integers.  */\n+#define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n+\n+static void integer_overflow ();\n+static long left_shift ();\n+static long right_shift ();\n+\n+#define ERROR 299\n+#define OROR 300\n+#define ANDAND 301\n+#define EQUAL 302\n+#define NOTEQUAL 303\n+#define LEQ 304\n+#define GEQ 305\n+#define LSH 306\n+#define RSH 307\n+#define NAME 308\n+#define INT 309\n+#define CHAR 310\n+\n+#define LEFT_OPERAND_REQUIRED 1\n+#define RIGHT_OPERAND_REQUIRED 2\n+#define HAVE_VALUE 4\n+/*#define UNSIGNEDP 8*/\n+\n+struct operation {\n+    short op;\n+    char rprio; /* Priority of op (relative to it right operand). */\n+    char flags;\n+    char unsignedp;    /* true if value should be treated as unsigned */\n+    long value;        /* The value logically \"right\" of op. */\n+};\n+\f\n+/* Take care of parsing a number (anything that starts with a digit).\n+   LEN is the number of characters in it.  */\n+\n+/* maybe needs to actually deal with floating point numbers */\n+\n+struct operation\n+parse_number (pfile, start, olen)\n+     cpp_reader *pfile;\n+     char *start;\n+     int olen;\n+{\n+  struct operation op;\n+  register char *p = start;\n+  register int c;\n+  register unsigned long n = 0, nd, ULONG_MAX_over_base;\n+  register int base = 10;\n+  register int len = olen;\n+  register int overflow = 0;\n+  register int digit, largest_digit = 0;\n+  int spec_long = 0;\n+\n+  op.unsignedp = 0;\n+\n+  for (c = 0; c < len; c++)\n+    if (p[c] == '.') {\n+      /* It's a float since it contains a point.  */\n+      cpp_error (pfile,\n+\t\t \"floating point numbers not allowed in #if expressions\");\n+      op.op = ERROR;\n+      return op;\n+    }\n+\n+  if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n+    p += 2;\n+    base = 16;\n+    len -= 2;\n+  }\n+  else if (*p == '0')\n+    base = 8;\n+\n+  ULONG_MAX_over_base = (unsigned long) -1 / base;\n+/* start-sanitize-mpw */\n+  /* Work around yet another MPW C bug. */\n+#ifdef MPW_C\n+  ULONG_MAX_over_base = ((unsigned long) -1) / ((unsigned long) base);\n+#endif /* MPW_C */\n+/* end-sanitize-mpw */\n+\n+  for (; len > 0; len--) {\n+    c = *p++;\n+\n+    if (c >= '0' && c <= '9')\n+      digit = c - '0';\n+    else if (base == 16 && c >= 'a' && c <= 'f')\n+      digit = c - 'a' + 10;\n+    else if (base == 16 && c >= 'A' && c <= 'F')\n+      digit = c - 'A' + 10;\n+    else {\n+      /* `l' means long, and `u' means unsigned.  */\n+      while (1) {\n+\tif (c == 'l' || c == 'L')\n+\t  {\n+\t    if (spec_long)\n+\t      cpp_error (pfile, \"two `l's in integer constant\");\n+\t    spec_long = 1;\n+\t  }\n+\telse if (c == 'u' || c == 'U')\n+\t  {\n+\t    if (op.unsignedp)\n+\t      cpp_error (pfile, \"two `u's in integer constant\");\n+\t    op.unsignedp = 1;\n+\t  }\n+\telse\n+\t  break;\n+\n+\tif (--len == 0)\n+\t  break;\n+\tc = *p++;\n+      }\n+      /* Don't look for any more digits after the suffixes.  */\n+      break;\n+    }\n+    if (largest_digit < digit)\n+      largest_digit = digit;\n+    nd = n * base + digit;\n+    overflow |= ULONG_MAX_over_base < n | nd < n;\n+    n = nd;\n+  }\n+\n+  if (len != 0)\n+    {\n+      cpp_error (pfile, \"Invalid number in #if expression\");\n+      op.op = ERROR;\n+      return op;\n+    }\n+\n+  if (base <= largest_digit)\n+    cpp_warning (pfile, \"integer constant contains digits beyond the radix\");\n+\n+  if (overflow)\n+    cpp_warning (pfile, \"integer constant out of range\");\n+\n+  /* If too big to be signed, consider it unsigned.  */\n+  if ((long) n < 0 && ! op.unsignedp)\n+    {\n+      if (base == 10)\n+\tcpp_warning (pfile, \"integer constant is so large that it is unsigned\");\n+      op.unsignedp = 1;\n+    }\n+\n+  op.value = n;\n+  op.op = INT;\n+  return op;\n+}\n+\n+struct token {\n+  char *operator;\n+  int token;\n+};\n+\n+static struct token tokentab2[] = {\n+  {\"&&\", ANDAND},\n+  {\"||\", OROR},\n+  {\"<<\", LSH},\n+  {\">>\", RSH},\n+  {\"==\", EQUAL},\n+  {\"!=\", NOTEQUAL},\n+  {\"<=\", LEQ},\n+  {\">=\", GEQ},\n+  {\"++\", ERROR},\n+  {\"--\", ERROR},\n+  {NULL, ERROR}\n+};\n+\n+/* Read one token. */\n+\n+struct operation\n+cpp_lex (pfile)\n+cpp_reader *pfile;\n+{\n+  register int c;\n+  register int namelen;\n+  register struct token *toktab;\n+  enum cpp_token token;\n+  struct operation op;\n+  U_CHAR *tok_start, *tok_end;\n+  int old_written;\n+\n+ retry:\n+\n+  c = CPP_BUF_PEEK (CPP_BUFFER (pfile));\n+  if (c == '#')\n+    return parse_number (pfile,\n+\t\t\t cpp_read_check_assertion (pfile) ? \"1\" : \"0\", 1);\n+\n+  old_written = CPP_WRITTEN (pfile);\n+  cpp_skip_hspace (pfile);\n+  if (c == '\\n')\n+    {\n+      op.op = 0;\n+      return op;\n+    }\n+\n+  token = cpp_get_token (pfile);\n+  tok_start = pfile->token_buffer + old_written;\n+  tok_end = CPP_PWRITTEN (pfile);\n+  pfile->limit = tok_start;\n+  switch (token)\n+  {\n+    case CPP_EOF: /* Should not happen ... */\n+      op.op = 0;\n+      return op;\n+    case CPP_VSPACE:\n+    case CPP_POP:\n+      if (CPP_BUFFER (pfile)->fname != NULL)\n+\t{\n+\t  op.op = 0;\n+\t  return op;\n+\t}\n+      goto retry;\n+    case CPP_HSPACE:   case CPP_COMMENT: \n+      goto retry;\n+    case CPP_NUMBER:\n+      return parse_number (pfile, tok_start, tok_end - tok_start);\n+    case CPP_STRING:\n+      cpp_error (pfile, \"string constants not allowed in #if expressions\");\n+      op.op = ERROR;\n+      return op;\n+    case CPP_CHAR:\n+      /* This code for reading a character constant\n+\t handles multicharacter constants and wide characters.\n+\t It is mostly copied from c-lex.c.  */\n+      {\n+        register int result = 0;\n+\tregister num_chars = 0;\n+\tunsigned width = MAX_CHAR_TYPE_SIZE;\n+\tint wide_flag = 0;\n+\tint max_chars;\n+\tU_CHAR *ptr = tok_start;\n+#ifdef MULTIBYTE_CHARS\n+\tchar token_buffer[MAX_LONG_TYPE_SIZE/MAX_CHAR_TYPE_SIZE + MB_CUR_MAX];\n+#else\n+\tchar token_buffer[MAX_LONG_TYPE_SIZE/MAX_CHAR_TYPE_SIZE + 1];\n+#endif\n+\n+\tif (*ptr == 'L')\n+\t  {\n+\t    ptr++;\n+\t    wide_flag = 1;\n+\t    width = MAX_WCHAR_TYPE_SIZE;\n+#ifdef MULTIBYTE_CHARS\n+\t    max_chars = MB_CUR_MAX;\n+#else\n+\t    max_chars = 1;\n+#endif\n+\t  }\n+\telse\n+\t    max_chars = MAX_LONG_TYPE_SIZE / width;\n+\n+\twhile (1)\n+\t  {\n+\t    if (ptr >= CPP_PWRITTEN (pfile) || (c = *ptr++) == '\\'')\n+\t      break;\n+\n+\t    if (c == '\\\\')\n+\t      {\n+\t\tc = cpp_parse_escape (pfile, &ptr);\n+\t\tif (width < HOST_BITS_PER_INT\n+\t\t  && (unsigned) c >= (1 << width))\n+\t\t    cpp_pedwarn (pfile,\n+\t\t\t\t \"escape sequence out of range for character\");\n+\t      }\n+\n+\t    num_chars++;\n+\n+\t    /* Merge character into result; ignore excess chars.  */\n+\t    if (num_chars < max_chars + 1)\n+\t      {\n+\t        if (width < HOST_BITS_PER_INT)\n+\t\t  result = (result << width) | (c & ((1 << width) - 1));\n+\t\telse\n+\t\t  result = c;\n+\t\ttoken_buffer[num_chars - 1] = c;\n+\t      }\n+\t  }\n+\n+\ttoken_buffer[num_chars] = 0;\n+\n+\tif (c != '\\'')\n+\t  cpp_error (pfile, \"malformatted character constant\");\n+\telse if (num_chars == 0)\n+\t  cpp_error (pfile, \"empty character constant\");\n+\telse if (num_chars > max_chars)\n+\t  {\n+\t    num_chars = max_chars;\n+\t    cpp_error (pfile, \"character constant too long\");\n+\t  }\n+\telse if (num_chars != 1 && ! CPP_TRADITIONAL (pfile))\n+\t  cpp_warning (pfile, \"multi-character character constant\");\n+\n+\t/* If char type is signed, sign-extend the constant.  */\n+\tif (! wide_flag)\n+\t  {\n+\t    int num_bits = num_chars * width;\n+\n+\t    if (cpp_lookup (pfile, \"__CHAR_UNSIGNED__\",\n+\t\t\t    sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n+\t\t|| ((result >> (num_bits - 1)) & 1) == 0)\n+\t\top.value\n+\t\t    = result & ((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n+\t    else\n+\t\top.value\n+\t\t    = result | ~((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n+\t  }\n+\telse\n+\t  {\n+#ifdef MULTIBYTE_CHARS\n+\t    /* Set the initial shift state and convert the next sequence.  */\n+\t      result = 0;\n+\t      /* In all locales L'\\0' is zero and mbtowc will return zero,\n+\t\t so don't use it.  */\n+\t      if (num_chars > 1\n+\t\t  || (num_chars == 1 && token_buffer[0] != '\\0'))\n+\t        {\n+\t\t  wchar_t wc;\n+\t\t  (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n+\t\t  if (mbtowc (& wc, token_buffer, num_chars) == num_chars)\n+\t\t    result = wc;\n+\t\t  else\n+\t\t    cpp_warning (pfile,\"Ignoring invalid multibyte character\");\n+\t        }\n+#endif\n+\t      op.value = result;\n+\t    }\n+        }\n+\n+      /* This is always a signed type.  */\n+      op.unsignedp = 0;\n+      op.op = CHAR;\n+    \n+      return op;\n+\n+    case CPP_NAME:\n+      return parse_number (pfile, \"0\", 0);\n+\n+    case CPP_OTHER:\n+      /* See if it is a special token of length 2.  */\n+      if (tok_start + 2 == tok_end)\n+        {\n+\t  for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n+\t    if (tok_start[0] == toktab->operator[0]\n+\t\t&& tok_start[1] == toktab->operator[1])\n+\t\tbreak;\n+\t  if (toktab->token == ERROR)\n+\t    {\n+\t      char *buf = (char *) alloca (40);\n+\t      sprintf (buf, \"`%s' not allowed in operand of `#if'\", tok_start);\n+\t      cpp_error (pfile, buf);\n+\t    }\n+\t  op.op = toktab->token; \n+\t  return op;\n+\t}\n+      /* fall through */\n+    default:\n+      op.op = *tok_start;\n+      return op;\n+  }\n+}\n+\n+\n+/* Parse a C escape sequence.  STRING_PTR points to a variable\n+   containing a pointer to the string to parse.  That pointer\n+   is updated past the characters we use.  The value of the\n+   escape sequence is returned.\n+\n+   A negative value means the sequence \\ newline was seen,\n+   which is supposed to be equivalent to nothing at all.\n+\n+   If \\ is followed by a null character, we return a negative\n+   value and leave the string pointer pointing at the null character.\n+\n+   If \\ is followed by 000, we return 0 and leave the string pointer\n+   after the zeros.  A value of 0 does not mean end of string.  */\n+\n+int\n+cpp_parse_escape (pfile, string_ptr)\n+     cpp_reader *pfile;\n+     char **string_ptr;\n+{\n+  register int c = *(*string_ptr)++;\n+  switch (c)\n+    {\n+    case 'a':\n+      return TARGET_BELL;\n+    case 'b':\n+      return TARGET_BS;\n+    case 'e':\n+    case 'E':\n+      if (CPP_PEDANTIC (pfile))\n+\tcpp_pedwarn (pfile, \"non-ANSI-standard escape sequence, `\\\\%c'\", c);\n+      return 033;\n+    case 'f':\n+      return TARGET_FF;\n+    case 'n':\n+      return TARGET_NEWLINE;\n+    case 'r':\n+      return TARGET_CR;\n+    case 't':\n+      return TARGET_TAB;\n+    case 'v':\n+      return TARGET_VT;\n+    case '\\n':\n+      return -2;\n+    case 0:\n+      (*string_ptr)--;\n+      return 0;\n+      \n+    case '0':\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+    case '5':\n+    case '6':\n+    case '7':\n+      {\n+\tregister int i = c - '0';\n+\tregister int count = 0;\n+\twhile (++count < 3)\n+\t  {\n+\t    c = *(*string_ptr)++;\n+\t    if (c >= '0' && c <= '7')\n+\t      i = (i << 3) + c - '0';\n+\t    else\n+\t      {\n+\t\t(*string_ptr)--;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif ((i & ~((1 << MAX_CHAR_TYPE_SIZE) - 1)) != 0)\n+\t  {\n+\t    i &= (1 << MAX_CHAR_TYPE_SIZE) - 1;\n+\t    cpp_warning (pfile,\n+\t\t\t  \"octal character constant does not fit in a byte\");\n+\t  }\n+\treturn i;\n+      }\n+    case 'x':\n+      {\n+\tregister unsigned i = 0, overflow = 0, digits_found = 0, digit;\n+\tfor (;;)\n+\t  {\n+\t    c = *(*string_ptr)++;\n+\t    if (c >= '0' && c <= '9')\n+\t      digit = c - '0';\n+\t    else if (c >= 'a' && c <= 'f')\n+\t      digit = c - 'a' + 10;\n+\t    else if (c >= 'A' && c <= 'F')\n+\t      digit = c - 'A' + 10;\n+\t    else\n+\t      {\n+\t\t(*string_ptr)--;\n+\t\tbreak;\n+\t      }\n+\t    overflow |= i ^ (i << 4 >> 4);\n+\t    i = (i << 4) + digit;\n+\t    digits_found = 1;\n+\t  }\n+\tif (!digits_found)\n+\t  cpp_error (pfile, \"\\\\x used with no following hex digits\");\n+\tif (overflow | (i & ~((1 << BITS_PER_UNIT) - 1)))\n+\t  {\n+\t    i &= (1 << BITS_PER_UNIT) - 1;\n+\t    cpp_warning (pfile,\n+\t\t\t \"hex character constant does not fit in a byte\");\n+\t  }\n+\treturn i;\n+      }\n+    default:\n+      return c;\n+    }\n+}\n+\n+static void\n+integer_overflow (pfile)\n+     cpp_reader *pfile;\n+{\n+  if (CPP_PEDANTIC (pfile))\n+    cpp_pedwarn (pfile, \"integer overflow in preprocessor expression\");\n+}\n+\n+static long\n+left_shift (pfile, a, unsignedp, b)\n+     cpp_reader *pfile;\n+     long a;\n+     int unsignedp;\n+     unsigned long b;\n+{\n+  if (b >= HOST_BITS_PER_LONG)\n+    {\n+      if (! unsignedp && a != 0)\n+\tinteger_overflow (pfile);\n+      return 0;\n+    }\n+  else if (unsignedp)\n+    return (unsigned long) a << b;\n+  else\n+    {\n+      long l = a << b;\n+      if (l >> b != a)\n+\tinteger_overflow (pfile);\n+      return l;\n+    }\n+}\n+\n+static long\n+right_shift (pfile, a, unsignedp, b)\n+     cpp_reader *pfile;\n+     long a;\n+     int unsignedp;\n+     unsigned long b;\n+{\n+  if (b >= HOST_BITS_PER_LONG)\n+    return unsignedp ? 0 : a >> (HOST_BITS_PER_LONG - 1);\n+  else if (unsignedp)\n+    return (unsigned long) a >> b;\n+  else\n+    return a >> b;\n+}\n+\f\n+/* These priorities are all even, so we can handle associatively. */\n+#define PAREN_INNER_PRIO 0\n+#define COMMA_PRIO 4\n+#define COND_PRIO (COMMA_PRIO+2)\n+#define OROR_PRIO (COND_PRIO+2)\n+#define ANDAND_PRIO (OROR_PRIO+2)\n+#define OR_PRIO (ANDAND_PRIO+2)\n+#define XOR_PRIO (OR_PRIO+2)\n+#define AND_PRIO (XOR_PRIO+2)\n+#define EQUAL_PRIO (AND_PRIO+2)\n+#define LESS_PRIO (EQUAL_PRIO+2)\n+#define SHIFT_PRIO (LESS_PRIO+2)\n+#define PLUS_PRIO (SHIFT_PRIO+2)\n+#define MUL_PRIO (PLUS_PRIO+2)\n+#define UNARY_PRIO (MUL_PRIO+2)\n+#define PAREN_OUTER_PRIO (UNARY_PRIO+2)\n+\n+#define COMPARE(OP) \\\n+  top->unsignedp = 0;\\\n+  top->value = (unsigned1 || unsigned2) ? (unsigned long) v1 OP v2 : (v1 OP v2)\n+\n+/* Parse and evaluate a C expression, reading from PFILE.\n+   Returns the value of the expression.  */\n+\n+long\n+cpp_parse_expr (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* The implementation is an operator precedence parser,\n+     i.e. a bottom-up parser, using a stack for not-yet-reduced tokens.\n+\n+     The stack base is 'stack', and the current stack pointer is 'top'.\n+     There is a stack element for each operator (only),\n+     and the most recently pushed operator is 'top->op'.\n+     An operand (value) is stored in the 'value' field of the stack\n+     element of the operator that precedes it.\n+     In that case the 'flags' field has the HAVE_VALUE flag set.  */\n+\n+#define INIT_STACK_SIZE 20\n+  struct operation init_stack[INIT_STACK_SIZE];\n+  struct operation *stack = init_stack;\n+  struct operation *limit = stack + INIT_STACK_SIZE;\n+  register struct operation *top = stack;\n+  int lprio, rprio;\n+\n+  top->rprio = 0;\n+  top->flags = 0;\n+  for (;;)\n+    {\n+      struct operation op;\n+      char flags = 0;\n+\n+      /* Read a token */\n+      op =  cpp_lex (pfile);\n+\n+      /* See if the token is an operand, in which case go to set_value.\n+\t If the token is an operator, figure out its left and right\n+\t priorities, and then goto maybe_reduce. */\n+\n+      switch (op.op)\n+\t{\n+\tcase NAME:\n+\t  top->value = 0, top->unsignedp = 0;\n+\t  goto set_value;\n+\tcase INT:  case CHAR:\n+\t  top->value = op.value;\n+\t  top->unsignedp = op.unsignedp;\n+\t  goto set_value;\n+\tcase 0:\n+\t  lprio = 0;  goto maybe_reduce;\n+\tcase '+':  case '-':\n+\t  /* Is this correct if unary ? FIXME */\n+\t  flags = RIGHT_OPERAND_REQUIRED;\n+\t  lprio = PLUS_PRIO;  rprio = lprio + 1;  goto maybe_reduce;\n+\tcase '!':  case '~':\n+\t  flags = RIGHT_OPERAND_REQUIRED;\n+\t  rprio = UNARY_PRIO;  lprio = rprio + 1;  goto maybe_reduce;\n+\tcase '*':  case '/':  case '%':\n+\t  lprio = MUL_PRIO;  goto binop;\n+\tcase '<':  case '>':  case LEQ:  case GEQ:\n+\t  lprio = LESS_PRIO;  goto binop;\n+\tcase EQUAL:  case NOTEQUAL:\n+\t  lprio = EQUAL_PRIO;  goto binop;\n+\tcase LSH:  case RSH:\n+\t  lprio = SHIFT_PRIO;  goto binop;\n+\tcase '&':  lprio = AND_PRIO;  goto binop;\n+\tcase '^':  lprio = XOR_PRIO;  goto binop;\n+\tcase '|':  lprio = OR_PRIO;  goto binop;\n+\tcase ANDAND:  lprio = ANDAND_PRIO;  goto binop;\n+\tcase OROR:  lprio = OROR_PRIO;  goto binop;\n+\tcase ',':\n+\t  lprio = COMMA_PRIO;  goto binop;\n+\tcase '(':\n+\t  lprio = PAREN_OUTER_PRIO;  rprio = PAREN_INNER_PRIO;\n+\t  goto maybe_reduce;\n+\tcase ')':\n+\t  lprio = PAREN_INNER_PRIO;  rprio = PAREN_OUTER_PRIO;\n+\t  goto maybe_reduce;\n+        case ':':\n+\t  lprio = COND_PRIO;  rprio = COND_PRIO;\n+\t  goto maybe_reduce;\n+        case '?':\n+\t  lprio = COND_PRIO + 1;  rprio = COND_PRIO;\n+\t  goto maybe_reduce;\n+\tbinop:\n+\t  flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n+\t  rprio = lprio + 1;\n+\t  goto maybe_reduce;\n+\tdefault:\n+\t  cpp_error (pfile, \"invalid character in #if\");\n+\t  goto syntax_error;\n+\t}\n+\n+    set_value:\n+      /* Push a value onto the stack. */\n+      if (top->flags & HAVE_VALUE)\n+\t{\n+\t  cpp_error (pfile, \"syntax error in #if\");\n+\t  goto syntax_error;\n+\t}\n+      top->flags |= HAVE_VALUE;\n+      continue;\n+\n+    maybe_reduce:\n+      /* Push an operator, and check if we can reduce now. */\n+      while (top->rprio > lprio)\n+\t{\n+\t  long v1 = top[-1].value, v2 = top[0].value;\n+\t  int unsigned1 = top[-1].unsignedp, unsigned2 = top[0].unsignedp;\n+\t  top--;\n+\t  if ((top[1].flags & LEFT_OPERAND_REQUIRED)\n+\t      && ! (top[0].flags & HAVE_VALUE))\n+\t    {\n+\t      cpp_error (pfile, \"syntax error - missing left operand\");\n+\t      goto syntax_error;\n+\t    }\n+\t  if ((top[1].flags & RIGHT_OPERAND_REQUIRED)\n+\t      && ! (top[1].flags & HAVE_VALUE))\n+\t    {\n+\t      cpp_error (pfile, \"syntax error - missing right operand\");\n+\t      goto syntax_error;\n+\t    }\n+\t  /* top[0].value = (top[1].op)(v1, v2);*/\n+\t  switch (top[1].op)\n+\t    {\n+\t    case '+':\n+\t      if (!(top->flags & HAVE_VALUE))\n+\t\t{ /* Unary '+' */\n+\t\t  top->value = v2;\n+\t\t  top->unsignedp = unsigned2;\n+\t\t  top->flags |= HAVE_VALUE;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  top->value = v1 + v2;\n+\t\t  top->unsignedp = unsigned1 || unsigned2;\n+\t\t  if (! top->unsignedp\n+\t\t      && ! possible_sum_sign (v1, v2, top->value))\n+\t\t    integer_overflow (pfile);\n+\t\t}\n+\t      break;\n+\t    case '-':\n+\t      if (!(top->flags & HAVE_VALUE))\n+\t\t{ /* Unary '-' */\n+\t\t  top->value = - v2;\n+\t\t  if ((top->value & v2) < 0 && ! unsigned2)\n+\t\t    integer_overflow (pfile);\n+\t\t  top->unsignedp = unsigned2;\n+\t\t  top->flags |= HAVE_VALUE;\n+\t\t}\n+\t      else\n+\t\t{ /* Binary '-' */\n+\t\t  top->value = v1 - v2;\n+\t\t  top->unsignedp = unsigned1 || unsigned2;\n+\t\t  if (! top->unsignedp\n+\t\t      && ! possible_sum_sign (top->value, v2, v1))\n+\t\t    integer_overflow (pfile);\n+\t\t}\n+\t      break;\n+\t    case '*':\n+\t      top->unsignedp = unsigned1 || unsigned2;\n+\t      if (top->unsignedp)\n+\t\ttop->value = (unsigned long) v1 * v2;\n+\t      else\n+\t\t{\n+\t\t  top->value = v1 * v2;\n+\t\t  if (v1\n+\t\t      && (top->value / v1 != v2\n+\t\t\t  || (top->value & v1 & v2) < 0))\n+\t\t    integer_overflow (pfile);\n+\t\t}\n+\t      break;\n+\t    case '/':\n+\t      if (v2 == 0)\n+\t\t{\n+\t\t  cpp_error (pfile, \"division by zero in #if\");\n+\t\t  v2 = 1;\n+\t\t}\n+\t      top->unsignedp = unsigned1 || unsigned2;\n+\t      if (top->unsignedp)\n+\t\ttop->value = (unsigned long) v1 / v2;\n+\t      else\n+\t\t{\n+\t\t  top->value = v1 / v2;\n+\t\t  if ((top->value & v1 & v2) < 0)\n+\t\t    integer_overflow (pfile);\n+\t\t}\n+\t      break;\n+\t    case '%':\n+\t      if (v2 == 0)\n+\t\t{\n+\t\t  cpp_error (pfile, \"division by zero in #if\");\n+\t\t  v2 = 1;\n+\t\t}\n+\t      top->unsignedp = unsigned1 || unsigned2;\n+\t      if (top->unsignedp)\n+\t\ttop->value = (unsigned long) v1 % v2;\n+\t      else\n+\t\ttop->value = v1 % v2;\n+\t      break;\n+\t    case '!':\n+\t      if (top->flags & HAVE_VALUE)\n+\t\t{\n+\t\t  cpp_error (pfile, \"syntax error\");\n+\t\t  goto syntax_error;\n+\t\t}\n+\t      top->value = ! v2;\n+\t      top->unsignedp = 0;\n+\t      top->flags |= HAVE_VALUE;\n+\t      break;\n+\t    case '~':\n+\t      if (top->flags & HAVE_VALUE)\n+\t\t{\n+\t\t  cpp_error (pfile, \"syntax error\");\n+\t\t  goto syntax_error;\n+\t\t}\n+\t      top->value = ~ v2;\n+\t      top->unsignedp = unsigned2;\n+\t      top->flags |= HAVE_VALUE;\n+\t      break;\n+\t    case '<':  COMPARE(<);  break;\n+\t    case '>':  COMPARE(>);  break;\n+\t    case LEQ:  COMPARE(<=); break;\n+\t    case GEQ:  COMPARE(>=); break;\n+\t    case EQUAL:\n+\t      top->value = (v1 == v2);\n+\t      top->unsignedp = 0;\n+\t      break;\n+\t    case NOTEQUAL:\n+\t      top->value = (v1 != v2);\n+\t      top->unsignedp = 0;\n+\t      break;\n+\t    case LSH:\n+\t      top->unsignedp = unsigned1;\n+\t      if (v2 < 0 && ! unsigned2)\n+\t\ttop->value = right_shift (pfile, v1, unsigned1, -v2);\n+\t      else\n+\t\ttop->value = left_shift (pfile, v1, unsigned1, v2);\n+\t      break;\n+\t    case RSH:\n+\t      top->unsignedp = unsigned1;\n+\t      if (v2 < 0 && ! unsigned2)\n+\t\ttop->value = left_shift (pfile, v1, unsigned1, -v2);\n+\t      else\n+\t\ttop->value = right_shift (pfile, v1, unsigned1, v2);\n+\t      break;\n+#define LOGICAL(OP) \\\n+\t      top->value = v1 OP v2;\\\n+\t      top->unsignedp = unsigned1 || unsigned2;\n+\t    case '&':  LOGICAL(&); break;\n+\t    case '^':  LOGICAL(^);  break;\n+\t    case '|':  LOGICAL(|);  break;\n+\t    case ANDAND:\n+\t      top->value = v1 && v2;  top->unsignedp = 0;  break;\n+\t    case OROR:\n+\t      top->value = v1 || v2;  top->unsignedp = 0;  break;\n+\t    case ',':\n+\t      if (CPP_PEDANTIC (pfile))\n+\t\tcpp_pedwarn (pfile, \"comma operator in operand of `#if'\");\n+\t      top->value = v2;\n+\t      top->unsignedp = unsigned2;\n+\t      break;\n+\t    case '(':  case '?':\n+\t      cpp_error (pfile, \"syntax error in #if\");\n+\t      goto syntax_error;\n+\t    case ':':\n+\t      if (top[0].op != '?')\n+\t\t{\n+\t\t  cpp_error (pfile,\n+\t\t\t     \"syntax error ':' without preceding '?'\");\n+\t\t  goto syntax_error;\n+\t\t}\n+\t      else if (! (top[1].flags & HAVE_VALUE)\n+\t\t       || !(top[-1].flags & HAVE_VALUE)\n+\t\t       || !(top[0].flags & HAVE_VALUE))\n+\t\t{\n+\t\t  cpp_error (pfile, \"bad syntax for ?: operator\");\n+\t\t  goto syntax_error;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  top--;\n+\t\t  top->value = top->value ? v1 : v2;\n+\t\t  top->unsignedp = unsigned1 || unsigned2;\n+\t\t}\n+\t      break;\n+\t    case ')':\n+\t      if ((top[1].flags & HAVE_VALUE)\n+\t\t  || ! (top[0].flags & HAVE_VALUE)\n+\t\t  || top[0].op != '('\n+\t\t  || (top[-1].flags & HAVE_VALUE))\n+\t\t{\n+\t\t  cpp_error (pfile, \"mismatched parentheses in #if\");\n+\t\t  goto syntax_error;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  top--;\n+\t\t  top->value = v1;\n+\t\t  top->unsignedp = unsigned1;\n+\t\t  top->flags |= HAVE_VALUE;\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      fprintf (stderr,\n+\t\t       top[1].op >= ' ' && top[1].op <= '~'\n+\t\t       ? \"unimplemented operator '%c'\\n\"\n+\t\t       : \"unimplemented operator '\\\\%03o'\\n\",\n+\t\t       top[1].op);\n+\t    }\n+\t}\n+      if (op.op == 0)\n+\t{\n+\t  if (top != stack)\n+\t    cpp_error (pfile, \"internal error in #if expression\");\n+\t  if (stack != init_stack)\n+\t    free (stack);\n+\t  return top->value;\n+\t}\n+      top++;\n+      \n+      /* Check for and handle stack overflow. */\n+      if (top == limit)\n+\t{\n+\t  struct operation *new_stack;\n+\t  int old_size = (char*)limit - (char*)stack;\n+\t  int new_size = 2 * old_size;\n+\t  if (stack != init_stack)\n+\t    new_stack = (struct operation*) xrealloc (stack, new_size);\n+\t  else\n+\t    {\n+\t      new_stack = (struct operation*) xmalloc (new_size);\n+\t      bcopy (stack, new_stack, old_size);\n+\t    }\n+\t  stack = new_stack;\n+\t  top = (struct operation*)((char*) new_stack + old_size);\n+\t  limit = (struct operation*)((char*) new_stack + new_size);\n+\t}\n+      \n+      top->flags = flags;\n+      top->rprio = rprio;\n+      top->op = op.op;\n+    }\n+ syntax_error:\n+  if (stack != init_stack)\n+    free (stack);\n+  skip_rest_of_line (pfile);\n+  return 0;\n+}"}, {"sha": "fe7cbbf15f15e3120453f3e83bf4cb17373d97a9", "filename": "gcc/cpphash.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,192 @@\n+/* Part of CPP library.  (Macro hash table support.)\n+   Copyright (C) 1986, 87, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994.\n+   Based on CCCP program by by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+\n+/* Define a generic NULL if one hasn't already been defined.  */\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+/*\n+ * return hash function on name.  must be compatible with the one\n+ * computed a step at a time, elsewhere\n+ */\n+int\n+hashf (name, len, hashsize)\n+     register const U_CHAR *name;\n+     register int len;\n+     int hashsize;\n+{\n+  register int r = 0;\n+\n+  while (len--)\n+    r = HASHSTEP (r, *name++);\n+\n+  return MAKE_POS (r) % hashsize;\n+}\n+\n+/*\n+ * find the most recent hash node for name name (ending with first\n+ * non-identifier char) installed by install\n+ *\n+ * If LEN is >= 0, it is the length of the name.\n+ * Otherwise, compute the length by scanning the entire name.\n+ *\n+ * If HASH is >= 0, it is the precomputed hash code.\n+ * Otherwise, compute the hash code.\n+ */\n+HASHNODE *\n+cpp_lookup (pfile, name, len, hash)\n+     struct parse_file *pfile;\n+     const U_CHAR *name;\n+     int len;\n+     int hash;\n+{\n+  register const U_CHAR *bp;\n+  register HASHNODE *bucket;\n+\n+  if (len < 0)\n+    {\n+      for (bp = name; is_idchar[*bp]; bp++) ;\n+      len = bp - name;\n+    }\n+\n+  if (hash < 0)\n+    hash = hashf (name, len, HASHSIZE);\n+\n+  bucket = hashtab[hash];\n+  while (bucket) {\n+    if (bucket->length == len && strncmp (bucket->name, name, len) == 0)\n+      return bucket;\n+    bucket = bucket->next;\n+  }\n+  return (HASHNODE*) 0;\n+}\n+\n+/*\n+ * Delete a hash node.  Some weirdness to free junk from macros.\n+ * More such weirdness will have to be added if you define more hash\n+ * types that need it.\n+ */\n+\n+/* Note that the DEFINITION of a macro is removed from the hash table\n+   but its storage is not freed.  This would be a storage leak\n+   except that it is not reasonable to keep undefining and redefining\n+   large numbers of macros many times.\n+   In any case, this is necessary, because a macro can be #undef'd\n+   in the middle of reading the arguments to a call to it.\n+   If #undef freed the DEFINITION, that would crash.  */\n+\n+void\n+delete_macro (hp)\n+     HASHNODE *hp;\n+{\n+\n+  if (hp->prev != NULL)\n+    hp->prev->next = hp->next;\n+  if (hp->next != NULL)\n+    hp->next->prev = hp->prev;\n+\n+  /* make sure that the bucket chain header that\n+     the deleted guy was on points to the right thing afterwards. */\n+  if (hp == *hp->bucket_hdr)\n+    *hp->bucket_hdr = hp->next;\n+\n+#if 0\n+  if (hp->type == T_MACRO) {\n+    DEFINITION *d = hp->value.defn;\n+    struct reflist *ap, *nextap;\n+\n+    for (ap = d->pattern; ap != NULL; ap = nextap) {\n+      nextap = ap->next;\n+      free (ap);\n+    }\n+    free (d);\n+  }\n+#endif\n+  free (hp);\n+}\n+/*\n+ * install a name in the main hash table, even if it is already there.\n+ *   name stops with first non alphanumeric, except leading '#'.\n+ * caller must check against redefinition if that is desired.\n+ * delete_macro () removes things installed by install () in fifo order.\n+ * this is important because of the `defined' special symbol used\n+ * in #if, and also if pushdef/popdef directives are ever implemented.\n+ *\n+ * If LEN is >= 0, it is the length of the name.\n+ * Otherwise, compute the length by scanning the entire name.\n+ *\n+ * If HASH is >= 0, it is the precomputed hash code.\n+ * Otherwise, compute the hash code.\n+ */\n+HASHNODE *\n+install (name, len, type, ivalue, value, hash)\n+     U_CHAR *name;\n+     int len;\n+     enum node_type type;\n+     int ivalue;\n+     char *value;\n+     int hash;\n+{\n+  register HASHNODE *hp;\n+  register int i, bucket;\n+  register U_CHAR *p, *q;\n+\n+  if (len < 0) {\n+    p = name;\n+    while (is_idchar[*p])\n+      p++;\n+    len = p - name;\n+  }\n+\n+  if (hash < 0)\n+    hash = hashf (name, len, HASHSIZE);\n+\n+  i = sizeof (HASHNODE) + len + 1;\n+  hp = (HASHNODE *) xmalloc (i);\n+  bucket = hash;\n+  hp->bucket_hdr = &hashtab[bucket];\n+  hp->next = hashtab[bucket];\n+  hashtab[bucket] = hp;\n+  hp->prev = NULL;\n+  if (hp->next != NULL)\n+    hp->next->prev = hp;\n+  hp->type = type;\n+  hp->length = len;\n+  if (hp->type == T_CONST)\n+    hp->value.ival = ivalue;\n+  else\n+    hp->value.cpval = value;\n+  hp->name = ((U_CHAR *) hp) + sizeof (HASHNODE);\n+  p = hp->name;\n+  q = name;\n+  for (i = 0; i < len; i++)\n+    *p++ = *q++;\n+  hp->name[len] = 0;\n+  return hp;\n+}"}, {"sha": "b4d7207820803cc672b40291caf27d26ae59de5c", "filename": "gcc/cpphash.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,40 @@\n+enum node_type;\n+\n+/* different kinds of things that can appear in the value field\n+   of a hash node.  Actually, this may be useless now. */\n+union hashval {\n+  int ival;\n+  char *cpval;\n+  DEFINITION *defn;\n+#if 0\n+  KEYDEF *keydef;\n+#endif\n+};\n+\n+struct hashnode {\n+  struct hashnode *next;\t/* double links for easy deletion */\n+  struct hashnode *prev;\n+  struct hashnode **bucket_hdr;\t/* also, a back pointer to this node's hash\n+\t\t\t\t   chain is kept, in case the node is the head\n+\t\t\t\t   of the chain and gets deleted. */\n+  enum node_type type;\t\t/* type of special token */\n+  int length;\t\t\t/* length of token, for quick comparison */\n+  U_CHAR *name;\t\t\t/* the actual name */\n+  union hashval value;\t\t/* pointer to expansion, or whatever */\n+};\n+\n+typedef struct hashnode HASHNODE;\n+\n+/* Some definitions for the hash table.  The hash function MUST be\n+   computed as shown in hashf () below.  That is because the rescan\n+   loop computes the hash value `on the fly' for most tokens,\n+   in order to avoid the overhead of a lot of procedure calls to\n+   the hashf () function.  Hashf () only exists for the sake of\n+   politeness, for use when speed isn't so important. */\n+\n+#define HASHSIZE 1403\n+static HASHNODE *hashtab[HASHSIZE];\n+#define HASHSTEP(old, c) ((old << 2) + c)\n+#define MAKE_POS(v) (v & 0x7fffffff) /* make number positive */\n+\n+extern HASHNODE* install PARAMS ((U_CHAR*,int,enum node_type, int,char*,int));"}, {"sha": "6c4e555debf5b0209db7af81d2daa82cc95fe9e6", "filename": "gcc/cpplib.c", "status": "added", "additions": 7288, "deletions": 0, "changes": 7288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=7f2935c734c36f84ab62b20a04de465e19061333"}, {"sha": "ae4757a76bff499cf150b601348c821b960498b1", "filename": "gcc/cpplib.h", "status": "added", "additions": 657, "deletions": 0, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,657 @@\n+/* Definitions for CPP library.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994-95.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define STATIC_BUFFERS\n+\n+typedef unsigned char U_CHAR;\n+\n+#ifndef FAILURE_EXIT_CODE\n+#define FAILURE_EXIT_CODE 33\t/* gnu cc command understands this */\n+#endif\n+\n+#ifndef SUCCESS_EXIT_CODE\n+#define SUCCESS_EXIT_CODE 0\t/* 0 means success on Unix.  */\n+#endif\n+\n+struct parse_file;\n+typedef struct cpp_reader cpp_reader;\n+typedef struct cpp_buffer cpp_buffer;\n+typedef struct cpp_options cpp_options;\n+typedef struct hashnode cpp_hashnode;\n+\n+enum cpp_token {\n+  CPP_EOF = -1,\n+  CPP_OTHER = 0,\n+  CPP_COMMENT = 1,\n+  CPP_HSPACE,\n+  CPP_VSPACE, /* newlines and #line directives */\n+  CPP_NAME,\n+  CPP_NUMBER,\n+  CPP_CHAR,\n+  CPP_STRING,\n+  CPP_DIRECTIVE,\n+  CPP_LPAREN,   /* \"(\" */\n+  CPP_RPAREN,   /* \")\" */\n+  CPP_LBRACE,   /* \"{\" */\n+  CPP_RBRACE,   /* \"}\" */\n+  CPP_COMMA,    /* \",\" */\n+  CPP_SEMICOLON,/* \";\" */\n+  CPP_3DOTS,    /* \"...\" */\n+#if 0\n+  CPP_ANDAND, /* \"&&\" */\n+  CPP_OROR,   /* \"||\" */\n+  CPP_LSH,    /* \"<<\" */\n+  CPP_RSH,    /* \">>\" */\n+  CPP_EQL,    /* \"==\" */\n+  CPP_NEQ,    /* \"!=\" */\n+  CPP_LEQ,    /* \"<=\" */\n+  CPP_GEQ,    /* \">=\" */\n+  CPP_PLPL,   /* \"++\" */\n+  CPP_MINMIN, /* \"--\" */\n+#endif\n+  /* POP_TOKEN is returned when we've popped a cpp_buffer. */\n+  CPP_POP\n+};\n+\n+#ifndef PARAMS\n+#ifdef __STDC\n+#define PARAMS(P) P\n+#else\n+#define PARAMS(P) ()\n+#endif\n+#endif /* !PARAMS */\n+\n+typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader*));\n+typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader*));\n+\n+/* A parse_marker indicates a previous position,\n+   which we can backtrack to. */\n+\n+struct parse_marker {\n+  cpp_buffer *buf;\n+  struct parse_marker *next;\n+  int position;\n+};\n+\n+extern void parse_set_mark PARAMS ((struct parse_marker*, cpp_reader*));\n+extern void parse_clear_mark PARAMS ((struct parse_marker*));\n+extern void parse_goto_mark PARAMS((struct parse_marker*, cpp_reader*));\n+extern void parse_move_mark PARAMS((struct parse_marker*, cpp_reader*));\n+\n+extern int cpp_handle_options PARAMS ((cpp_reader*, int, char**));\n+extern enum cpp_token cpp_get_token PARAMS ((struct parse_marker*));\n+extern void cpp_skip_hspace PARAMS((cpp_reader*));\n+extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n+\n+\n+/* Maintain and search list of included files, for #import.  */\n+\n+#define IMPORT_HASH_SIZE 31\n+\n+struct import_file {\n+  char *name;\n+  ino_t inode;\n+  dev_t dev;\n+  struct import_file *next;\n+};\n+\n+/* If we have a huge buffer, may need to cache more recent counts */\n+#define CPP_LINE_BASE(BUF) ((BUF)->buf + (BUF)->line_base)\n+\n+struct cpp_buffer {\n+  unsigned char *buf;\n+  unsigned char *cur;\n+  unsigned char *rlimit; /* end of valid data */\n+  unsigned char *alimit; /* end of allocated buffer */\n+  unsigned char *prev;  /* start of current token */\n+\n+  char *fname;\n+  /* Filename specified with #line command.  */\n+  char *nominal_fname;\n+\n+  /* Record where in the search path this file was found.\n+     For #include_next.  */\n+  struct file_name_list *dir;\n+\n+  long line_base;\n+  long lineno; /* Line number at CPP_LINE_BASE. */\n+  long colno; /* Column number at CPP_LINE_BASE. */\n+#ifndef STATIC_BUFFERS\n+  cpp_buffer *chain;\n+#endif\n+  parse_underflow_t underflow;\n+  parse_cleanup_t cleanup;\n+  void *data;\n+  struct parse_marker *marks;\n+  /* Value of if_stack at start of this file.\n+     Used to prohibit unmatched #endif (etc) in an include file.  */\n+  struct if_stack *if_stack;\n+\n+  /* True if this is a header file included using <FILENAME>.  */\n+  char system_header_p;\n+  char seen_eof;\n+\n+  /* True if buffer contains escape sequences.\n+     Currently there are are only two kind:\n+     \"@-\" means following identifier should not be macro-expanded.\n+     \"@@\" means a normal '@'. */\n+  char has_escapes;\n+};\n+\n+struct cpp_pending;  /* Forward declaration - for C++. */\n+\n+typedef struct assertion_hashnode ASSERTION_HASHNODE;\n+#define ASSERTION_HASHSIZE 37\n+\n+#ifdef STATIC_BUFFERS\n+/* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n+   efficiency, and partly to limit runaway recursion.  */\n+#define CPP_STACK_MAX 200\n+#endif\n+\n+struct cpp_reader {\n+  unsigned char *limit;\n+  parse_underflow_t get_token;\n+  cpp_buffer *buffer;\n+#ifdef STATIC_BUFFERS\n+  cpp_buffer buffer_stack[CPP_STACK_MAX];\n+#endif\n+\n+  int errors;\t\t\t/* Error counter for exit code */\n+  /* While scanning a comment or a string constant,\n+     this records the line it started on, for error messages.  */\n+  int start_line;\n+  void *data;\n+\n+  U_CHAR *token_buffer;\n+  int token_buffer_size;\n+\n+  /* Current depth in #include directives that use <...>.  */\n+  int system_include_depth;\n+\n+  /* List of included files that contained #pragma once.  */\n+  struct file_name_list *dont_repeat_files;\n+\n+  /* List of other included files.\n+     If ->control_macro if nonzero, the file had a #ifndef\n+     around the entire contents, and ->control_macro gives the macro name.  */\n+  struct file_name_list *all_include_files;\n+\n+  /* Current maximum length of directory names in the search path\n+     for include files.  (Altered as we get more of them.)  */\n+  int max_include_len;\n+\n+  /* Hash table of files already included with #include or #import.  */\n+  struct import_file *import_hash_table[IMPORT_HASH_SIZE];\n+\n+  struct if_stack *if_stack;\n+\n+  /* Nonzero means we are inside an IF during a -pcp run.  In this mode\n+     macro expansion is done, and preconditions are output for all macro\n+     uses requiring them. */\n+  char pcp_inside_if;\n+\n+  /* Nonzero means we have printed (while error reporting) a list of\n+     containing files that matches the current status. */\n+  char input_stack_listing_current;\n+\n+  /* If non-zero, macros are not expanded. */\n+  char no_macro_expand;\n+\n+  /* Print column number in error messages. */\n+  char show_column;\n+\n+  /* We're printed a warning recommending against using #import. */\n+  char import_warning;\n+\n+  /* If true, character between '<' and '>' are a single (string) token. */\n+  char parsing_include_directive;\n+\n+  /* True if escape sequences (as described for has_escapes in\n+     parse_buffer) should be emitted. */\n+  char output_escapes;\n+\n+  /* 0: Have seen non-white-space on this line.\n+     1: Only seen white space so far on this line.\n+     2: Only seen white space so far in this file. */\n+   char only_seen_white;\n+\n+  /* Nonzero means this file was included with a -imacros or -include\n+     command line and should not be recorded as an include file.  */\n+\n+  int no_record_file;\n+\n+  long lineno;\n+\n+  struct tm *timebuf;\n+\n+  ASSERTION_HASHNODE *assertion_hashtab[ASSERTION_HASHSIZE];\n+\n+  /* Buffer of -M output.  */\n+  char *deps_buffer;\n+\n+  /* Number of bytes allocated in above.  */\n+  int deps_allocated_size;\n+\n+  /* Number of bytes used.  */\n+  int deps_size;\n+\n+  /* Number of bytes since the last newline.  */\n+  int deps_column;\n+};\n+\n+#define CPP_BUF_PEEK(BUFFER) \\\n+  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur : EOF)\n+#define CPP_BUF_GET(BUFFER) \\\n+  ((BUFFER)->cur < (BUFFER)->rlimit ? *(BUFFER)->cur++ : EOF)\n+#define CPP_FORWARD(BUFFER, N) ((BUFFER)->cur += (N))\n+\n+/* Number of characters currently in PFILE's output buffer. */\n+#define CPP_WRITTEN(PFILE) ((PFILE)->limit - (PFILE)->token_buffer)\n+#define CPP_PWRITTEN(PFILE) ((PFILE)->limit)\n+\n+/* Make sure PFILE->token_buffer has space for at least N more characters. */\n+#define CPP_RESERVE(PFILE, N) \\\n+  (CPP_WRITTEN (PFILE) + N > (PFILE)->token_buffer_size \\\n+   && (cpp_grow_buffer (PFILE, N), 0))\n+\n+/* Append string STR (of length N) to PFILE's output buffer.\n+   Assume there is enough space. */\n+#define CPP_PUTS_Q(PFILE, STR, N) \\\n+  (bcopy (STR, (PFILE)->limit, (N)), (PFILE)->limit += (N))\n+/* Append string STR (of length N) to PFILE's output buffer.  Make space. */\n+#define CPP_PUTS(PFILE, STR, N) CPP_RESERVE(PFILE, N), CPP_PUTS_Q(PFILE, STR,N)\n+/* Append character CH to PFILE's output buffer.  Assume sufficient space. */\n+#define CPP_PUTC_Q(PFILE, CH) (*(PFILE)->limit++ = (CH))\n+/* Append character CH to PFILE's output buffer.  Make space if need be. */\n+#define CPP_PUTC(PFILE, CH) (CPP_RESERVE (PFILE, 1), CPP_PUTC_Q (PFILE, CH))\n+/* Make sure PFILE->limit is followed by '\\0'. */\n+#define CPP_NUL_TERMINATE_Q(PFILE) (*(PFILE)->limit = 0)\n+#define CPP_NUL_TERMINATE(PFILE) (CPP_RESERVE(PFILE, 1), *(PFILE)->limit = 0)\n+#define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n+#define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n+\n+#define CPP_OPTIONS(PFILE) ((cpp_options*)(PFILE)->data)\n+#define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n+#ifdef STATIC_BUFFERS\n+#define CPP_PREV_BUFFER(BUFFER) ((BUFFER)+1)\n+#define CPP_NULL_BUFFER(PFILE) (&(PFILE)->buffer_stack[CPP_STACK_MAX])\n+#else\n+#define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->chain)\n+#define CPP_NULL_BUFFER(PFILE) ((cpp_buffer*)0)\n+#endif\n+\n+/* Pointed to by parse_file::data. */\n+struct cpp_options {\n+  char *in_fname;\n+\n+  /* Name of output file, for error messages.  */\n+  char *out_fname;\n+\n+  /* Non-0 means -v, so print the full set of include dirs.  */\n+  char verbose;\n+\n+  /* Nonzero means use extra default include directories for C++.  */\n+\n+  char cplusplus;\n+\n+  /* Nonzero means handle cplusplus style comments */\n+\n+  char cplusplus_comments;\n+\n+  /* Nonzero means handle #import, for objective C.  */\n+\n+  char objc;\n+\n+  /* Nonzero means this is an assembly file, and allow\n+     unknown directives, which could be comments.  */\n+\n+  int lang_asm;\n+\n+  /* Nonzero means turn NOTREACHED into #pragma NOTREACHED etc */\n+\n+  char for_lint;\n+\n+  /* Nonzero means handle CHILL comment syntax\n+     and output CHILL string delimeter for __DATE___ etc. */\n+\n+  char chill;\n+\n+  /* Nonzero means copy comments into the output file.  */\n+\n+  char put_out_comments;\n+\n+  /* Nonzero means don't process the ANSI trigraph sequences.  */\n+\n+  char no_trigraphs;\n+\n+  /* Nonzero means print the names of included files rather than\n+     the preprocessed output.  1 means just the #include \"...\",\n+     2 means #include <...> as well.  */\n+\n+  char print_deps;\n+\n+  /* Nonzero if missing .h files in -M output are assumed to be generated\n+     files and not errors.  */\n+\n+  char print_deps_missing_files;\n+\n+  /* If true, fopen (deps_file, \"a\") else fopen (deps_file, \"w\"). */\n+  char print_deps_append;\n+\n+  /* Nonzero means print names of header files (-H).  */\n+\n+  char print_include_names;\n+\n+  /* Nonzero means try to make failure to fit ANSI C an error.  */\n+\n+  char pedantic_errors;\n+\n+  /* Nonzero means don't print warning messages.  -w.  */\n+\n+  char inhibit_warnings;\n+\n+  /* Nonzero means warn if slash-star appears in a comment.  */\n+\n+  char warn_comments;\n+\n+  /* Nonzero means warn if there are any trigraphs.  */\n+\n+  char warn_trigraphs;\n+\n+  /* Nonzero means warn if #import is used.  */\n+\n+  char warn_import;\n+\n+  /* Nonzero means warn if a macro argument is (or would be)\n+     stringified with -traditional.  */\n+\n+  char warn_stringify;\n+\n+  /* Nonzero means turn warnings into errors.  */\n+\n+  char warnings_are_errors;\n+\n+  /* Nonzero causes output not to be done,\n+     but directives such as #define that have side effects\n+     are still obeyed.  */\n+\n+  char no_output;\n+\n+  /* Nonzero means don't output line number information.  */\n+\n+  char no_line_commands;\n+\n+/* Nonzero means output the text in failing conditionals,\n+   inside #failed ... #endfailed.  */\n+\n+  char output_conditionals;\n+\n+  /* Nonzero means -I- has been seen,\n+     so don't look for #include \"foo\" the source-file directory.  */\n+  char ignore_srcdir;\n+\n+/* Zero means dollar signs are punctuation.\n+   -$ stores 0; -traditional may store 1.  Default is 1 for VMS, 0 otherwise.\n+   This must be 0 for correct processing of this ANSI C program:\n+\t#define foo(a) #a\n+\t#define lose(b) foo (b)\n+\t#define test$\n+\tlose (test)\t*/\n+  char dollars_in_ident;\n+#ifndef DOLLARS_IN_IDENTIFIERS\n+#define DOLLARS_IN_IDENTIFIERS 1\n+#endif\n+\n+  /* Nonzero means try to imitate old fashioned non-ANSI preprocessor.  */\n+  char traditional;\n+\n+  /* Nonzero means give all the error messages the ANSI standard requires.  */\n+  char pedantic;\n+\n+  char done_initializing;\n+\n+  struct file_name_list *include;\t/* First dir to search */\n+  /* First dir to search for <file> */\n+  /* This is the first element to use for #include <...>.\n+     If it is 0, use the entire chain for such includes.  */\n+  struct file_name_list *first_bracket_include;\n+  /* This is the first element in the chain that corresponds to\n+     a directory of system header files.  */\n+  struct file_name_list *first_system_include;\n+  struct file_name_list *last_include;\t/* Last in chain */\n+\n+  /* Chain of include directories to put at the end of the other chain.  */\n+  struct file_name_list *after_include;\n+  struct file_name_list *last_after_include;\t/* Last in chain */\n+\n+  /* Chain to put at the start of the system include files.  */\n+  struct file_name_list *before_system;\n+  struct file_name_list *last_before_system;\t/* Last in chain */\n+\n+  /* Directory prefix that should replace `/usr' in the standard\n+     include file directories.  */\n+  char *include_prefix;\n+\n+  char inhibit_predefs;\n+  char no_standard_includes;\n+  char no_standard_cplusplus_includes;\n+\n+/* dump_only means inhibit output of the preprocessed text\n+             and instead output the definitions of all user-defined\n+             macros in a form suitable for use as input to cccp.\n+   dump_names means pass #define and the macro name through to output.\n+   dump_definitions means pass the whole definition (plus #define) through\n+*/\n+\n+  enum {dump_none = 0, dump_only, dump_names, dump_definitions}\n+     dump_macros;\n+\n+/* Nonzero means pass all #define and #undef directives which we actually\n+   process through to the output stream.  This feature is used primarily\n+   to allow cc1 to record the #defines and #undefs for the sake of\n+   debuggers which understand about preprocessor macros, but it may\n+   also be useful with -E to figure out how symbols are defined, and\n+   where they are defined.  */\n+  int debug_output;\n+\n+  /* Pending -D, -U and -A options, in reverse order. */\n+  struct cpp_pending *pending;\n+\n+  /* File name which deps are being written to.\n+     This is 0 if deps are being written to stdout.  */\n+  char *deps_file;\n+\n+  /* Target-name to write with the dependency information.  */\n+  char *deps_target;\n+};\n+\n+#define CPP_TRADITIONAL(PFILE) (CPP_OPTIONS(PFILE)-> traditional)\n+#define CPP_PEDANTIC(PFILE) (CPP_OPTIONS (PFILE)->pedantic)\n+#define CPP_PRINT_DEPS(PFILE) (CPP_OPTIONS (PFILE)->print_deps)\n+\n+#define PARSE_GETC(IN) ((IN)-> cur < (IN)->limit || ((IN)->cur = (IN)->token_buffer, (IN)->underflow (IN) != EOF_TOKEN) ? *(IN)->cur++ : EOF)\n+\n+/* Name under which this program was invoked.  */\n+\n+extern char *progname;\n+\n+/* The structure of a node in the hash table.  The hash table\n+   has entries for all tokens defined by #define commands (type T_MACRO),\n+   plus some special tokens like __LINE__ (these each have their own\n+   type, and the appropriate code is run when that type of node is seen.\n+   It does not contain control words like \"#define\", which are recognized\n+   by a separate piece of code. */\n+\n+/* different flavors of hash nodes --- also used in keyword table */\n+enum node_type {\n+ T_DEFINE = 1,\t/* the `#define' keyword */\n+ T_INCLUDE,\t/* the `#include' keyword */\n+ T_INCLUDE_NEXT, /* the `#include_next' keyword */\n+ T_IMPORT,      /* the `#import' keyword */\n+ T_IFDEF,\t/* the `#ifdef' keyword */\n+ T_IFNDEF,\t/* the `#ifndef' keyword */\n+ T_IF,\t\t/* the `#if' keyword */\n+ T_ELSE,\t/* `#else' */\n+ T_PRAGMA,\t/* `#pragma' */\n+ T_ELIF,\t/* `#elif' */\n+ T_UNDEF,\t/* `#undef' */\n+ T_LINE,\t/* `#line' */\n+ T_ERROR,\t/* `#error' */\n+ T_WARNING,\t/* `#warning' */\n+ T_ENDIF,\t/* `#endif' */\n+ T_SCCS,\t/* `#sccs', used on system V.  */\n+ T_IDENT,\t/* `#ident', used on system V.  */\n+ T_ASSERT,\t/* `#assert', taken from system V.  */\n+ T_UNASSERT,\t/* `#unassert', taken from system V.  */\n+ T_SPECLINE,\t/* special symbol `__LINE__' */\n+ T_DATE,\t/* `__DATE__' */\n+ T_FILE,\t/* `__FILE__' */\n+ T_BASE_FILE,\t/* `__BASE_FILE__' */\n+ T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n+ T_VERSION,\t/* `__VERSION__' */\n+ T_SIZE_TYPE,   /* `__SIZE_TYPE__' */\n+ T_PTRDIFF_TYPE,   /* `__PTRDIFF_TYPE__' */\n+ T_WCHAR_TYPE,   /* `__WCHAR_TYPE__' */\n+ T_USER_LABEL_PREFIX_TYPE, /* `__USER_LABEL_PREFIX__' */\n+ T_REGISTER_PREFIX_TYPE,   /* `__REGISTER_PREFIX__' */\n+ T_TIME,\t/* `__TIME__' */\n+ T_CONST,\t/* Constant value, used by `__STDC__' */\n+ T_MACRO,\t/* macro defined by `#define' */\n+ T_DISABLED,\t/* macro temporarily turned off for rescan */\n+ T_SPEC_DEFINED, /* special `defined' macro for use in #if statements */\n+ T_PCSTRING,\t/* precompiled string (hashval is KEYDEF *) */\n+ T_UNUSED\t/* Used for something not defined.  */\n+ };\n+\n+/* Structure returned by create_definition */\n+typedef struct macrodef MACRODEF;\n+struct macrodef\n+{\n+  struct definition *defn;\n+  U_CHAR *symnam;\n+  int symlen;\n+};\n+\n+/* Structure allocated for every #define.  For a simple replacement\n+   such as\n+   \t#define foo bar ,\n+   nargs = -1, the `pattern' list is null, and the expansion is just\n+   the replacement text.  Nargs = 0 means a functionlike macro with no args,\n+   e.g.,\n+       #define getchar() getc (stdin) .\n+   When there are args, the expansion is the replacement text with the\n+   args squashed out, and the reflist is a list describing how to\n+   build the output from the input: e.g., \"3 chars, then the 1st arg,\n+   then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg\".\n+   The chars here come from the expansion.  Whatever is left of the\n+   expansion after the last arg-occurrence is copied after that arg.\n+   Note that the reflist can be arbitrarily long---\n+   its length depends on the number of times the arguments appear in\n+   the replacement text, not how many args there are.  Example:\n+   #define f(x) x+x+x+x+x+x+x would have replacement text \"++++++\" and\n+   pattern list\n+     { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }\n+   where (x, y) means (nchars, argno). */\n+\n+typedef struct definition DEFINITION;\n+struct definition {\n+  int nargs;\n+  int length;\t\t\t/* length of expansion string */\n+  int predefined;\t\t/* True if the macro was builtin or */\n+\t\t\t\t/* came from the command line */\n+  U_CHAR *expansion;\n+  int line;\t\t\t/* Line number of definition */\n+  char *file;\t\t\t/* File of definition */\n+  char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n+  struct reflist {\n+    struct reflist *next;\n+    char stringify;\t\t/* nonzero if this arg was preceded by a\n+\t\t\t\t   # operator. */\n+    char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n+    char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n+    char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n+    int nchars;\t\t\t/* Number of literal chars to copy before\n+\t\t\t\t   this arg occurrence.  */\n+    int argno;\t\t\t/* Number of arg to substitute (origin-0) */\n+  } *pattern;\n+  union {\n+    /* Names of macro args, concatenated in reverse order\n+       with comma-space between them.\n+       The only use of this is that we warn on redefinition\n+       if this differs between the old and new definitions.  */\n+    U_CHAR *argnames;\n+  } args;\n+};\n+\n+extern U_CHAR is_idchar[256];\n+\n+/* Stack of conditionals currently in progress\n+   (including both successful and failing conditionals).  */\n+\n+struct if_stack {\n+  struct if_stack *next;\t/* for chaining to the next stack frame */\n+  char *fname;\t\t/* copied from input when frame is made */\n+  int lineno;\t\t\t/* similarly */\n+  int if_succeeded;\t\t/* true if a leg of this if-group\n+\t\t\t\t    has been passed through rescan */\n+  U_CHAR *control_macro;\t/* For #ifndef at start of file,\n+\t\t\t\t   this is the macro name tested.  */\n+  enum node_type type;\t\t/* type of last directive seen in this group */\n+};\n+typedef struct if_stack IF_STACK_FRAME;\n+\n+extern void cpp_buf_line_and_col PARAMS((cpp_buffer*, long*, long*));\n+extern cpp_buffer* cpp_file_buffer PARAMS((cpp_reader*));\n+\n+extern void cpp_error ();\n+extern void cpp_warning ();\n+extern void cpp_pedwarn ();\n+extern void cpp_error_with_line ();\n+extern void cpp_warning_with_line ();\n+extern void cpp_pedwarn_with_line ();\n+extern void cpp_pedwarn_with_file_and_line ();\n+extern void fatal ();\n+extern void cpp_error_from_errno ();\n+extern void cpp_perror_with_name ();\n+extern void cpp_pfatal_with_name ();\n+\n+extern void cpp_grow_buffer PARAMS ((cpp_reader*, long));\n+extern int cpp_parse_escape PARAMS ((cpp_reader*, char**));\n+extern cpp_buffer* cpp_push_buffer PARAMS ((cpp_reader *, U_CHAR*, long));\n+extern cpp_buffer* cpp_pop_buffer PARAMS ((cpp_reader *));\n+\n+extern cpp_hashnode* cpp_lookup PARAMS ((cpp_reader*, const U_CHAR*,\n+\t\t\t\t\t int, int));\n+\n+extern long cpp_parse_expr PARAMS ((cpp_reader*));\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "32131720c93ed85ec2ca1ea54eca144c3c8d6b83", "filename": "gcc/cppmain.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2935c734c36f84ab62b20a04de465e19061333/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=7f2935c734c36f84ab62b20a04de465e19061333", "patch": "@@ -0,0 +1,102 @@\n+/* CPP main program, using CPP Library.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994-95.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"cpplib.h\"\n+#include <stdio.h>\n+\n+extern char *getenv ();\n+\n+cpp_reader parse_in;\n+cpp_options options;\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  char *p;\n+  int i;\n+  int argi = 1;  /* Next argument to handle. */\n+  struct cpp_options *opts = &options;\n+\n+  p = argv[0] + strlen (argv[0]);\n+  while (p != argv[0] && p[-1] != '/') --p;\n+  progname = p;\n+\n+  init_parse_file (&parse_in);\n+  parse_in.data = opts;\n+\n+  init_parse_options (opts);\n+  \n+  argi += cpp_handle_options (&parse_in, argc - argi , argv + argi);\n+  if (argi < argc)\n+    fatal (\"Invalid option `%s'\", argv[argi]);\n+  parse_in.show_column = 1;\n+\n+  i = push_parse_file (&parse_in, opts->in_fname);\n+  if (i != SUCCESS_EXIT_CODE)\n+    return i;\n+\n+  /* Now that we know the input file is valid, open the output.  */\n+\n+  if (!opts->out_fname || !strcmp (opts->out_fname, \"\"))\n+    opts->out_fname = \"stdout\";\n+  else if (! freopen (opts->out_fname, \"w\", stdout))\n+    cpp_pfatal_with_name (&parse_in, opts->out_fname);\n+\n+  for (;;)\n+    {\n+#if 0\n+      int ch = PARSE_GETC (&parse_in);\n+      if (ch < 0)\n+\tbreak;\n+      if (! opts->no_output)\n+\tputchar (ch);\n+#else\n+      enum cpp_token kind;\n+      if (! opts->no_output)\n+\t{\n+\t  fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout);\n+\t}\n+      parse_in.limit = parse_in.token_buffer;\n+      kind = cpp_get_token (&parse_in);\n+      if (kind == CPP_EOF)\n+\tbreak;\n+#endif\n+    }\n+\n+  cpp_finish (&parse_in);\n+\n+  if (parse_in.errors)\n+    exit (FAILURE_EXIT_CODE);\n+  exit (SUCCESS_EXIT_CODE);\n+}"}]}