{"sha": "86ac5e79ab137815e463c0b46495551c641e33d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhYzVlNzlhYjEzNzgxNWU0NjNjMGI0NjQ5NTU1MWM2NDFlMzNkOA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-02-15T09:36:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:36:35Z"}, "message": "checks.adb (Build_Discriminant_Checks): If the expression being checks is an aggregate retrieve the values of its...\n\n2006-02-13  Ed Schonberg  <schonberg@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* checks.adb (Build_Discriminant_Checks): If the expression being\n\tchecks is an aggregate retrieve the values of its discriminants to\n\tgenerate the check, rather than creating a temporary and a reference\n\tto it.\n\t(Apply_Access_Check): Rewritten to handle new Is_Known_Null flag\n\t(Install_Null_Excluding_Check): Ditto\n\t(Selected_Length_Checks): Build actual subtype for the original Ck_Node,\n\tnot for the renamed object, so that the actual itype is attached in the\n\tproper context.\n\nFrom-SVN: r111052", "tree": {"sha": "2379d905d5a4d1e77ca8bcbcd41a68d2a05d0a4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2379d905d5a4d1e77ca8bcbcd41a68d2a05d0a4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ac5e79ab137815e463c0b46495551c641e33d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ac5e79ab137815e463c0b46495551c641e33d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ac5e79ab137815e463c0b46495551c641e33d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ac5e79ab137815e463c0b46495551c641e33d8/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32c65fc062e4ad4f981e4db110436a23f3c8e4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c65fc062e4ad4f981e4db110436a23f3c8e4f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c65fc062e4ad4f981e4db110436a23f3c8e4f0"}], "stats": {"total": 192, "additions": 115, "deletions": 77}, "files": [{"sha": "6a58415a0bf2a46b7b888bab94f9d2036c3e1833", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 115, "deletions": 77, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac5e79ab137815e463c0b46495551c641e33d8/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac5e79ab137815e463c0b46495551c641e33d8/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=86ac5e79ab137815e463c0b46495551c641e33d8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -382,60 +382,22 @@ package body Checks is\n       P : constant Node_Id := Prefix (N);\n \n    begin\n-      if Inside_A_Generic then\n-         return;\n-      end if;\n-\n-      if Is_Entity_Name (P) then\n-         Check_Unset_Reference (P);\n-      end if;\n-\n-      --  We do not need access checks if prefix is known to be non-null\n-\n-      if Known_Non_Null (P) then\n-         return;\n-\n-      --  We do not need access checks if they are suppressed on the type\n-\n-      elsif Access_Checks_Suppressed (Etype (P)) then\n-         return;\n-\n       --  We do not need checks if we are not generating code (i.e. the\n       --  expander is not active). This is not just an optimization, there\n       --  are cases (e.g. with pragma Debug) where generating the checks\n       --  can cause real trouble).\n \n-      elsif not Expander_Active then\n-         return;\n-\n-      --  We do not need checks if not needed because of short circuiting\n-\n-      elsif not Check_Needed (P, Access_Check) then\n+      if not Expander_Active then\n          return;\n       end if;\n \n-      --  Case where P is an entity name\n-\n-      if Is_Entity_Name (P) then\n-         declare\n-            Ent : constant Entity_Id := Entity (P);\n-\n-         begin\n-            if Access_Checks_Suppressed (Ent) then\n-               return;\n-            end if;\n-\n-            --  Otherwise we are going to generate an access check, and\n-            --  are we have done it, the entity will now be known non null\n-            --  But we have to check for safe sequential semantics here!\n+      --  No check if short circuiting makes check unnecessary\n \n-            if Safe_To_Capture_Value (N, Ent) then\n-               Set_Is_Known_Non_Null (Ent);\n-            end if;\n-         end;\n+      if not Check_Needed (P, Access_Check) then\n+         return;\n       end if;\n \n-      --  Access check is required\n+      --  Otherwise go ahead and install the check\n \n       Install_Null_Excluding_Check (P);\n    end Apply_Access_Check;\n@@ -472,9 +434,8 @@ package body Checks is\n          Type_Level :=\n            Make_Integer_Literal (Loc, Type_Access_Level (Typ));\n \n-         --  Raise Program_Error if the accessibility level of the\n-         --  the access parameter is deeper than the level of the\n-         --  target access type.\n+         --  Raise Program_Error if the accessibility level of the the access\n+         --  parameter is deeper than the level of the target access type.\n \n          Insert_Action (N,\n            Make_Raise_Program_Error (Loc,\n@@ -2387,7 +2348,40 @@ package body Checks is\n       Dref     : Node_Id;\n       Dval     : Node_Id;\n \n+      function Aggregate_Discriminant_Val (Disc : Entity_Id) return Node_Id;\n+\n+      ----------------------------------\n+      -- Aggregate_Discriminant_Value --\n+      ----------------------------------\n+\n+      function Aggregate_Discriminant_Val (Disc : Entity_Id) return Node_Id is\n+         Assoc : Node_Id;\n+\n+      begin\n+         --  The aggregate has been normalized with named associations. We\n+         --  use the Chars field to locate the discriminant to take into\n+         --  account discriminants in derived types, which carry the same\n+         --  name as those in the parent.\n+\n+         Assoc := First (Component_Associations (N));\n+         while Present (Assoc) loop\n+            if Chars (First (Choices (Assoc))) = Chars (Disc) then\n+               return Expression (Assoc);\n+            else\n+               Next (Assoc);\n+            end if;\n+         end loop;\n+\n+         --  Discriminant must have been found in the loop above\n+\n+         raise Program_Error;\n+      end Aggregate_Discriminant_Val;\n+\n+   --  Start of processing for Build_Discriminant_Checks\n+\n    begin\n+      --  Loop through discriminants evolving the condition\n+\n       Cond := Empty;\n       Disc := First_Elmt (Discriminant_Constraint (T_Typ));\n \n@@ -2422,6 +2416,11 @@ package body Checks is\n                 T_Typ,\n                 Stored_Constraint (T_Typ)));\n \n+         elsif Nkind (N) = N_Aggregate then\n+            Dref :=\n+               Duplicate_Subexpr_No_Checks\n+                 (Aggregate_Discriminant_Val (Disc_Ent));\n+\n          else\n             Dref :=\n               Make_Selected_Component (Loc,\n@@ -2664,7 +2663,7 @@ package body Checks is\n       --  Check that null-excluding objects are always initialized\n \n       if K = N_Object_Declaration\n-        and then not Present (Expression (N))\n+        and then No (Expression (N))\n       then\n          --  Add a an expression that assignates null. This node is needed\n          --  by Apply_Compile_Time_Constraint_Error, that will replace this\n@@ -4802,42 +4801,81 @@ package body Checks is\n    ----------------------------------\n \n    procedure Install_Null_Excluding_Check (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Etyp : constant Entity_Id  := Etype (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Typ : constant Entity_Id  := Etype (N);\n+\n+      procedure Mark_Non_Null;\n+      --  After installation of check, marks node as non-null if entity\n+\n+      -------------------\n+      -- Mark_Non_Null --\n+      -------------------\n+\n+      procedure Mark_Non_Null is\n+      begin\n+         if Is_Entity_Name (N) then\n+            Set_Is_Known_Null (Entity (N), False);\n+\n+            if Safe_To_Capture_Value (N, Entity (N)) then\n+               Set_Is_Known_Non_Null (Entity (N), True);\n+            end if;\n+         end if;\n+      end Mark_Non_Null;\n+\n+   --  Start of processing for Install_Null_Excluding_Check\n \n    begin\n-      pragma Assert (Is_Access_Type (Etyp));\n+      pragma Assert (Is_Access_Type (Typ));\n \n-      --  Don't need access check if:\n-      --   1) we are analyzing a generic\n-      --   2) it is known to be non-null\n-      --   3) the check was suppressed on the type\n-      --   4) This is an attribute reference that returns an access type.\n+      --  No check inside a generic (why not???)\n \n-      if Inside_A_Generic\n-        or else Access_Checks_Suppressed (Etyp)\n-      then\n+      if Inside_A_Generic then\n          return;\n-      elsif Nkind (N) = N_Attribute_Reference\n-        and then\n-         (Attribute_Name (N) = Name_Access\n-            or else\n-          Attribute_Name (N) = Name_Unchecked_Access\n-            or else\n-          Attribute_Name (N) = Name_Unrestricted_Access)\n-      then\n+      end if;\n+\n+      --  No check needed if known to be non-null\n+\n+      if Known_Non_Null (N) then\n          return;\n-         --  Otherwise install access check\n+      end if;\n \n-      else\n-         Insert_Action (N,\n-           Make_Raise_Constraint_Error (Loc,\n-             Condition =>\n-               Make_Op_Eq (Loc,\n-                 Left_Opnd  => Duplicate_Subexpr_Move_Checks (N),\n-                 Right_Opnd => Make_Null (Loc)),\n-             Reason    => CE_Access_Check_Failed));\n+      --  If known to be null, here is where we generate a compile time check\n+\n+      if Known_Null (N) then\n+         Apply_Compile_Time_Constraint_Error\n+           (N,\n+            \"null value not allowed here?\",\n+            CE_Access_Check_Failed);\n+         Mark_Non_Null;\n+         return;\n       end if;\n+\n+      --  If entity is never assigned, for sure a warning is appropriate\n+\n+      if Is_Entity_Name (N) then\n+         Check_Unset_Reference (N);\n+      end if;\n+\n+      --  No check needed if checks are suppressed on the range. Note that we\n+      --  don't set Is_Known_Non_Null in this case (we could legitimately do\n+      --  so, since the program is erroneous, but we don't like to casually\n+      --  propagate such conclusions from erroneosity).\n+\n+      if Access_Checks_Suppressed (Typ) then\n+         return;\n+      end if;\n+\n+      --  Otherwise install access check\n+\n+      Insert_Action (N,\n+        Make_Raise_Constraint_Error (Loc,\n+          Condition =>\n+            Make_Op_Eq (Loc,\n+              Left_Opnd  => Duplicate_Subexpr_Move_Checks (N),\n+              Right_Opnd => Make_Null (Loc)),\n+          Reason => CE_Access_Check_Failed));\n+\n+      Mark_Non_Null;\n    end Install_Null_Excluding_Check;\n \n    --------------------------\n@@ -5375,7 +5413,7 @@ package body Checks is\n             Freeze_Before (Ck_Node, T_Typ);\n \n             Expr_Actual := Get_Referenced_Object (Ck_Node);\n-            Exptyp      := Get_Actual_Subtype (Expr_Actual);\n+            Exptyp      := Get_Actual_Subtype (Ck_Node);\n \n             if Is_Access_Type (Exptyp) then\n                Exptyp := Designated_Type (Exptyp);"}]}