{"sha": "636b1630184a37a9d5647cff19103bca34c8f125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2YjE2MzAxODRhMzdhOWQ1NjQ3Y2ZmMTkxMDNiY2EzNGM4ZjEyNQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-25T09:48:56Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Attempt to significantly reduce warning count by modifying error message format", "tree": {"sha": "516de1905cac342736b81a943e0a9390dda4e882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/516de1905cac342736b81a943e0a9390dda4e882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636b1630184a37a9d5647cff19103bca34c8f125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b1630184a37a9d5647cff19103bca34c8f125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636b1630184a37a9d5647cff19103bca34c8f125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636b1630184a37a9d5647cff19103bca34c8f125/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf"}], "stats": {"total": 885, "additions": 457, "deletions": 428}, "files": [{"sha": "f45f168e7d3da0572aed8f48362fe32281e57208", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b1630184a37a9d5647cff19103bca34c8f125/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b1630184a37a9d5647cff19103bca34c8f125/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=636b1630184a37a9d5647cff19103bca34c8f125", "patch": "@@ -683,8 +683,8 @@ Lexer::build_token ()\n \t  else /*if (!ISDIGIT (peek_input ()))*/\n \t    {\n \t      // single dot .\n-\t      // Only if followed by a non-number - otherwise is float \n-        // nope, float cannot start with '.'. \n+\t      // Only if followed by a non-number - otherwise is float\n+\t      // nope, float cannot start with '.'.\n \t      current_column++;\n \t      return Token::make (DOT, loc);\n \t    }\n@@ -730,7 +730,8 @@ Lexer::build_token ()\n       // int and float literals\n       if (ISDIGIT (current_char))\n \t{ //  _ not allowed as first char\n-\t  if (current_char == '0' && is_non_decimal_int_literal_separator (peek_input ()))\n+\t  if (current_char == '0'\n+\t      && is_non_decimal_int_literal_separator (peek_input ()))\n \t    {\n \t      // handle binary, octal, hex literals\n \t      TokenPtr non_dec_int_lit_ptr\n@@ -761,14 +762,15 @@ Lexer::build_token ()\n \n       // DEBUG: check for specific character problems:\n       if (current_char == '0')\n-        fprintf(stderr, \"'0' uncaught before unexpected character\\n\");\n+\tfprintf (stderr, \"'0' uncaught before unexpected character\\n\");\n       else if (current_char == ']')\n-        fprintf(stderr, \"']' uncaught before unexpected character\\n\");\n+\tfprintf (stderr, \"']' uncaught before unexpected character\\n\");\n       else if (current_char == 0x5d)\n-        fprintf(stderr, \"whatever 0x5d is (not '0' or ']') uncaught before unexpected character\\n\");\n+\tfprintf (stderr, \"whatever 0x5d is (not '0' or ']') uncaught before \"\n+\t\t\t \"unexpected character\\n\");\n \n       // didn't match anything so error\n-      rust_error_at (loc, \"unexpected character '%x'\", current_char);\n+      rust_error_at (loc, \"unexpected character %<%x%>\", current_char);\n       current_column++;\n     }\n }\n@@ -867,7 +869,7 @@ Lexer::parse_in_type_suffix ()\n     }\n   else\n     {\n-      rust_error_at (get_current_location (), \"unknown number suffix '%s'\",\n+      rust_error_at (get_current_location (), \"unknown number suffix %<%s%>\",\n \t\t     suffix.c_str ());\n \n       return std::make_pair (CORETYPE_UNKNOWN, additional_length_offset);\n@@ -967,7 +969,7 @@ Lexer::parse_escape (char opening_char)\n \tif (hexLong > 255 || hexLong < 0)\n \t  rust_error_at (\n \t    get_current_location (),\n-\t    \"byte \\\\x escape '\\\\x%X' out of range - allows up to '\\\\xFF'\",\n+\t    \"byte \\\\x escape %<\\\\x%X%> out of range - allows up to %<\\\\xFF%>\",\n \t    static_cast<unsigned int> (hexLong));\n \tchar hexChar = static_cast<char> (hexLong);\n \n@@ -1005,8 +1007,8 @@ Lexer::parse_escape (char opening_char)\n       // string continue\n       return std::make_tuple (0, parse_partial_string_continue (), true);\n     default:\n-      rust_error_at (get_current_location (), \"unknown escape sequence '\\\\%c'\",\n-\t\t     current_char);\n+      rust_error_at (get_current_location (),\n+\t\t     \"unknown escape sequence %<\\\\%c%>\", current_char);\n       // returns false if no parsing could be done\n       // return false;\n       return std::make_tuple (output_char, additional_length_offset, false);\n@@ -1045,7 +1047,7 @@ Lexer::parse_utf8_escape (char opening_char)\n \tif (hexLong > 127 || hexLong < 0)\n \t  rust_error_at (\n \t    get_current_location (),\n-\t    \"ascii \\\\x escape '\\\\x%X' out of range - allows up to '\\\\x7F'\",\n+\t    \"ascii \\\\x escape %<\\\\x%X%> out of range - allows up to %<\\\\x7F%>\",\n \t    static_cast<unsigned int> (hexLong));\n \tchar hexChar = static_cast<char> (hexLong);\n \n@@ -1086,8 +1088,8 @@ Lexer::parse_utf8_escape (char opening_char)\n       // string continue\n       return std::make_tuple (0, parse_partial_string_continue (), true);\n     default:\n-      rust_error_at (get_current_location (), \"unknown escape sequence '\\\\%c'\",\n-\t\t     current_char);\n+      rust_error_at (get_current_location (),\n+\t\t     \"unknown escape sequence %<\\\\%c%>\", current_char);\n       // returns false if no parsing could be done\n       // return false;\n       return std::make_tuple (output_char, additional_length_offset, false);\n@@ -1154,7 +1156,8 @@ Lexer::parse_partial_hex_escape ()\n   if (!is_x_digit (current_char))\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"invalid character '\\\\x%c' in \\\\x sequence\", current_char);\n+\t\t     \"invalid character %<\\\\x%c%> in \\\\x sequence\",\n+\t\t     current_char);\n     }\n   hexNum[0] = current_char;\n \n@@ -1166,7 +1169,8 @@ Lexer::parse_partial_hex_escape ()\n   if (!is_x_digit (current_char))\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"invalid character '\\\\x%c' in \\\\x sequence\", current_char);\n+\t\t     \"invalid character %<\\\\x%c%> in \\\\x sequence\",\n+\t\t     current_char);\n     }\n   hexNum[1] = current_char;\n \n@@ -1233,7 +1237,7 @@ Lexer::parse_partial_unicode_escape ()\n \t{\n \t  // actually an error, but allow propagation anyway\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"expected terminating '}' in unicode escape\");\n+\t\t\t \"expected terminating %<}%> in unicode escape\");\n \t  // return false;\n \t  return std::make_pair (Codepoint (0), additional_length_offset);\n \t}\n@@ -1283,8 +1287,8 @@ Lexer::parse_byte_char (Location loc)\n \n       if (byte_char > 127)\n \t{\n-\t  rust_error_at (get_current_location (), \"byte char '%c' out of range\",\n-\t\t\t byte_char);\n+\t  rust_error_at (get_current_location (),\n+\t\t\t \"byte char %<%c%> out of range\", byte_char);\n \t  byte_char = 0;\n \t}\n \n@@ -1320,7 +1324,7 @@ Lexer::parse_byte_char (Location loc)\n   else\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"no character inside '' for byte char\");\n+\t\t     \"no character inside %<%> for byte char\");\n     }\n \n   current_column += length;\n@@ -1359,7 +1363,7 @@ Lexer::parse_byte_string (Location loc)\n \t  if (output_char > 127)\n \t    {\n \t      rust_error_at (get_current_location (),\n-\t\t\t     \"char '%c' in byte string out of range\",\n+\t\t\t     \"char %<%c%> in byte string out of range\",\n \t\t\t     output_char);\n \t      output_char = 0;\n \t    }\n@@ -1427,7 +1431,7 @@ Lexer::parse_raw_byte_string (Location loc)\n   if (current_char != '\"')\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"raw byte string has no opening '\\\"'\");\n+\t\t     \"raw byte string has no opening %<\\\"%>\");\n     }\n \n   skip_input ();\n@@ -1508,13 +1512,13 @@ Lexer::parse_raw_identifier (Location loc)\n   // if just a single underscore, not an identifier\n   if (first_is_underscore && length == 1)\n     rust_error_at (get_current_location (),\n-\t\t   \"'_' is not a valid raw identifier\");\n+\t\t   \"%<_%> is not a valid raw identifier\");\n \n   if (str == \"crate\" || str == \"extern\" || str == \"self\" || str == \"super\"\n       || str == \"Self\")\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"'%s' is a forbidden raw identifier\", str.c_str ());\n+\t\t     \"%<%s%> is a forbidden raw identifier\", str.c_str ());\n \n       return nullptr;\n     }\n@@ -1657,7 +1661,7 @@ Lexer::parse_raw_string (Location loc, int initial_hash_count)\n   current_char = peek_input ();\n \n   if (current_char != '\"')\n-    rust_error_at (get_current_location (), \"raw string has no opening '\\\"'\");\n+    rust_error_at (get_current_location (), \"raw string has no opening %<\\\"%>\");\n \n   length++;\n   skip_input ();\n@@ -1751,7 +1755,7 @@ Lexer::parse_non_decimal_int_literal (Location loc, IsDigitFunc is_digit_func,\n   if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64)\n     {\n       rust_error_at (get_current_location (),\n-\t\t     \"invalid type suffix '%s' for integer (%s) literal\",\n+\t\t     \"invalid type suffix %<%s%> for integer (%s) literal\",\n \t\t     get_type_hint_string (type_hint),\n \t\t     base == 16\n \t\t       ? \"hex\"\n@@ -1843,7 +1847,7 @@ Lexer::parse_decimal_int_or_float (Location loc)\n \t  && type_hint != CORETYPE_UNKNOWN)\n \t{\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"invalid type suffix '%s' for float literal\",\n+\t\t\t \"invalid type suffix %<%s%> for float literal\",\n \t\t\t get_type_hint_string (type_hint));\n \t  // ignore invalid type suffix as everything else seems fine\n \t  type_hint = CORETYPE_UNKNOWN;\n@@ -1892,7 +1896,7 @@ Lexer::parse_decimal_int_or_float (Location loc)\n \t  && type_hint != CORETYPE_UNKNOWN)\n \t{\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"invalid type suffix '%s' for float literal\",\n+\t\t\t \"invalid type suffix %<%s%> for float literal\",\n \t\t\t get_type_hint_string (type_hint));\n \t  // ignore invalid type suffix as everything else seems fine\n \t  type_hint = CORETYPE_UNKNOWN;\n@@ -1914,10 +1918,10 @@ Lexer::parse_decimal_int_or_float (Location loc)\n \n       if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64)\n \t{\n-\t  rust_error_at (get_current_location (),\n-\t\t\t \"invalid type suffix '%s' for integer \"\n-\t\t\t \"(decimal) literal\",\n-\t\t\t get_type_hint_string (type_hint));\n+\t  rust_error_at (\n+\t    get_current_location (),\n+\t    \"invalid type suffix %<%s%> for integer (decimal) literal\",\n+\t    get_type_hint_string (type_hint));\n \t  // ignore invalid type suffix as everything else seems fine\n \t  type_hint = CORETYPE_UNKNOWN;\n \t}"}, {"sha": "51ff16e80a1d8d20562b3c364a96a3f11019606a", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 286, "deletions": 275, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b1630184a37a9d5647cff19103bca34c8f125/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b1630184a37a9d5647cff19103bca34c8f125/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=636b1630184a37a9d5647cff19103bca34c8f125", "patch": "@@ -238,7 +238,7 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n       }\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"expected '>' at end of generic argument - found '%s'\",\n+\t\t     \"expected %<>%> at end of generic argument - found %<%s%>\",\n \t\t     tok->get_token_description ());\n       return false;\n     }\n@@ -583,8 +583,7 @@ Parser<ManagedTokenSource>::parse_simple_path ()\n \t{\n \t  fprintf (stderr,\n \t\t   \"when parsing simple path, somehow empty path segment was \"\n-\t\t   \"not filtered out. Path \"\n-\t\t   \"begins with '%s' \\n\",\n+\t\t   \"not filtered out. Path begins with '%s' \\n\",\n \t\t   segments.at (0).as_string ().c_str ());\n \t}\n     }\n@@ -629,8 +628,8 @@ Parser<ManagedTokenSource>::parse_simple_path_segment ()\n       gcc_fallthrough ();\n     default:\n       // do nothing but inactivates warning from gcc when compiling\n-      // could put the rust_error_at thing here but fallthrough (from failing\n-      // $crate condition) isn't completely obvious if it is.\n+      /* could put the rust_error_at thing here but fallthrough (from failing\n+       * $crate condition) isn't completely obvious if it is. */\n \n       // test prevent error\n       return AST::SimplePathSegment::create_error ();\n@@ -722,7 +721,7 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n \t  {\n \t    rust_error_at (\n \t      t->get_locus (),\n-\t      \"unknown token '%s' in attribute body - literal expected\",\n+\t      \"unknown token %<%s%> in attribute body - literal expected\",\n \t      t->get_token_description ());\n \t    skip_after_end_attribute ();\n \t    return nullptr;\n@@ -771,7 +770,7 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n       return nullptr;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unknown token '%s' in attribute body - attribute input \"\n+\t\t     \"unknown token %<%s%> in attribute body - attribute input \"\n \t\t     \"or none expected\",\n \t\t     t->get_token_description ());\n       skip_after_end_attribute ();\n@@ -838,7 +837,7 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting delimiters (for a \"\n+\t\t     \"unexpected token %<%s%> - expecting delimiters (for a \"\n \t\t     \"delimited token tree)\",\n \t\t     t->get_token_description ());\n       return AST::DelimTokenTree::create_empty ();\n@@ -858,7 +857,7 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n \t  // TODO: is this error handling appropriate?\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"failed to parse token tree in delimited token tree - found '%s'\",\n+\t    \"failed to parse token tree in delimited token tree - found %<%s%>\",\n \t    t->get_token_description ());\n \t  return AST::DelimTokenTree::create_empty ();\n \t}\n@@ -892,13 +891,13 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting closing delimiter '%s' \"\n-\t\t     \"(for a delimited token tree)\",\n-\t\t     t->get_token_description (),\n-\t\t     (delim_type == AST::PARENS\n-\t\t\t? \")\"\n-\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n+\t\"(for a delimited token tree)\",\n+\tt->get_token_description (),\n+\t(delim_type == AST::PARENS ? \")\"\n+\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return empty token tree despite possibly parsing valid token tree -\n        * TODO is this a good idea? */\n@@ -927,11 +926,11 @@ Parser<ManagedTokenSource>::parse_token_tree ()\n     case RIGHT_SQUARE:\n     case RIGHT_CURLY:\n       // error - should not be called when this a token\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unexpected closing delimiter '%s' - token tree requires \"\n-\t\t     \"either paired delimiters \"\n-\t\t     \"or non-delimiter tokens\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unexpected closing delimiter %<%s%> - token tree requires \"\n+\t\"either paired delimiters or non-delimiter tokens\",\n+\tt->get_token_description ());\n       lexer.skip_token ();\n       return nullptr;\n     default:\n@@ -983,8 +982,8 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n   std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n \n   // TODO: decide how to deal with VisItem vs MacroItem dichotomy\n-  // best current solution: catch all keywords that would imply a VisItem in a\n-  // switch and have MacroItem as a last resort\n+  /* best current solution: catch all keywords that would imply a VisItem in a\n+   * switch and have MacroItem as a last resort */\n \n   const_TokenPtr t = lexer.peek_token ();\n \n@@ -1037,16 +1036,17 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n       else if (lexer.peek_token (1)->get_id () == SCOPE_RESOLUTION\n \t       || lexer.peek_token (1)->get_id () == EXCLAM)\n \t{\n-\t  // path (probably) or macro invocation, so probably a macro invocation\n-\t  // semi\n+\t  /* path (probably) or macro invocation, so probably a macro invocation\n+\t   * semi */\n \t  return parse_macro_item (std::move (outer_attrs));\n \t}\n       gcc_fallthrough ();\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n     default:\n       // otherwise unrecognised\n       // return parse_macro_item(std::move(outer_attrs));\n-      rust_error_at (t->get_locus (), \"unrecognised token '%s' for start of %s\",\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unrecognised token %<%s%> for start of %s\",\n \t\t     t->get_token_description (),\n \t\t     called_from_statement ? \"statement\" : \"item\");\n       // skip somewhere?\n@@ -1066,8 +1066,8 @@ Parser<ManagedTokenSource>::parse_outer_attributes ()\n     {\n       AST::Attribute outer_attr = parse_outer_attribute ();\n \n-      // Ensure only valid outer attributes are added to the outer_attributes\n-      // list\n+      /* Ensure only valid outer attributes are added to the outer_attributes\n+       * list */\n       if (!outer_attr.is_empty ())\n \t{\n \t  outer_attributes.push_back (std::move (outer_attr));\n@@ -1104,10 +1104,10 @@ Parser<ManagedTokenSource>::parse_outer_attribute ()\n       if (id == EXCLAM)\n \t{\n \t  // this is inner attribute syntax, so throw error\n-\t  rust_error_at (lexer.peek_token ()->get_locus (),\n-\t\t\t \"token '!' found, indicating inner attribute \"\n-\t\t\t \"definition. Inner attributes are not \"\n-\t\t\t \"possible at this location.\");\n+\t  rust_error_at (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"token %<!%> found, indicating inner attribute definition. Inner \"\n+\t    \"attributes are not possible at this location\");\n \t} // TODO: are there any cases where this wouldn't be an error?\n       return AST::Attribute::create_empty ();\n     }\n@@ -1166,15 +1166,15 @@ Parser<ManagedTokenSource>::parse_vis_item (\n \t    default:\n \t      rust_error_at (\n \t\tt->get_locus (),\n-\t\t\"unexpected token '%s' in some sort of extern production\",\n+\t\t\"unexpected token %<%s%> in some sort of extern production\",\n \t\tt->get_token_description ());\n \t      lexer.skip_token (2); // TODO: is this right thing to do?\n \t      return nullptr;\n \t    }\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token '%s' in some sort of extern production\",\n+\t    \"unexpected token %<%s%> in some sort of extern production\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n@@ -1218,7 +1218,7 @@ Parser<ManagedTokenSource>::parse_vis_item (\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token '%s' in some sort of const production\",\n+\t    \"unexpected token %<%s%> in some sort of const production\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n@@ -1245,7 +1245,7 @@ Parser<ManagedTokenSource>::parse_vis_item (\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token '%s' in some sort of unsafe production\",\n+\t    \"unexpected token %<%s%> in some sort of unsafe production\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n@@ -1290,8 +1290,7 @@ Parser<ManagedTokenSource>::parse_macro_item (\n \t{\n \t  fprintf (stderr,\n \t\t   \"just add to last error: token is not macro_rules and is \"\n-\t\t   \"not an identifier either \"\n-\t\t   \"- it is '%s'\",\n+\t\t   \"not an identifier either - it is '%s'\",\n \t\t   t->get_token_description ());\n \t}\n \n@@ -1311,7 +1310,7 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (\n     {\n       rust_error_at (\n \tt->get_locus (),\n-\t\"macro rules definition does not start with 'macro_rules'\");\n+\t\"macro rules definition does not start with %<macro_rules%>\");\n       // skip after somewhere?\n       return nullptr;\n     }\n@@ -1353,7 +1352,7 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting delimiters (for a \"\n+\t\t     \"unexpected token %<%s%> - expecting delimiters (for a \"\n \t\t     \"macro rules definition)\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -1442,14 +1441,13 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting closing delimiter '%s' \"\n-\t\t     \"(for a macro rules \"\n-\t\t     \"definition)\",\n-\t\t     t->get_token_description (),\n-\t\t     (delim_type == AST::PARENS\n-\t\t\t? \")\"\n-\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n+\t\"(for a macro rules definition)\",\n+\tt->get_token_description (),\n+\t(delim_type == AST::PARENS ? \")\"\n+\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return empty macro definiton despite possibly parsing mostly valid one\n        * - TODO is this a good idea? */\n@@ -1490,7 +1488,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting delimiters (for a \"\n+\t\t     \"unexpected token %<%s%> - expecting delimiters (for a \"\n \t\t     \"macro invocation semi body)\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -1508,10 +1506,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \n       if (tree == nullptr)\n \t{\n-\t  rust_error_at (\n-\t    t->get_locus (),\n-\t    \"failed to parse token tree for macro invocation semi - found '%s'\",\n-\t    t->get_token_description ());\n+\t  rust_error_at (t->get_locus (),\n+\t\t\t \"failed to parse token tree for macro invocation semi \"\n+\t\t\t \"- found %<%s%>\",\n+\t\t\t t->get_token_description ());\n \t  return nullptr;\n \t}\n \n@@ -1555,14 +1553,13 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting closing delimiter '%s' \"\n-\t\t     \"(for a macro invocation \"\n-\t\t     \"semi)\",\n-\t\t     t->get_token_description (),\n-\t\t     (delim_type == AST::PARENS\n-\t\t\t? \")\"\n-\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n+\t\"(for a macro invocation semi)\",\n+\tt->get_token_description (),\n+\t(delim_type == AST::PARENS ? \")\"\n+\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return empty macro invocation despite possibly parsing mostly valid one\n        * - TODO is this a good idea? */\n@@ -1612,9 +1609,7 @@ Parser<ManagedTokenSource>::parse_macro_rule ()\n   AST::MacroMatcher matcher = parse_macro_matcher ();\n \n   if (matcher.is_error ())\n-    {\n-      return AST::MacroRule::create_error ();\n-    }\n+    return AST::MacroRule::create_error ();\n \n   if (!skip_token (MATCH_ARROW))\n     {\n@@ -1655,7 +1650,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n     default:\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unexpected token '%s' - expecting delimiters (for a macro matcher)\",\n+\t\"unexpected token %<%s%> - expecting delimiters (for a macro matcher)\",\n \tt->get_token_description ());\n       return AST::MacroMatcher::create_error ();\n     }\n@@ -1674,7 +1669,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \t{\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"failed to parse macro match for macro matcher - found '%s'\",\n+\t    \"failed to parse macro match for macro matcher - found %<%s%>\",\n \t    t->get_token_description ());\n \t  return AST::MacroMatcher::create_error ();\n \t}\n@@ -1699,13 +1694,13 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n   else\n     {\n       // tokens don't match opening delimiters, so produce error\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' - expecting closing delimiter '%s' \"\n-\t\t     \"(for a macro matcher)\",\n-\t\t     t->get_token_description (),\n-\t\t     (delim_type == AST::PARENS\n-\t\t\t? \")\"\n-\t\t\t: (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> \"\n+\t\"(for a macro matcher)\",\n+\tt->get_token_description (),\n+\t(delim_type == AST::PARENS ? \")\"\n+\t\t\t\t   : (delim_type == AST::SQUARE ? \"]\" : \"}\")));\n \n       /* return error macro matcher despite possibly parsing mostly correct one?\n        * TODO is this the best idea? */\n@@ -1749,11 +1744,11 @@ Parser<ManagedTokenSource>::parse_macro_match ()\n \t    return parse_macro_match_repetition ();\n \t  default:\n \t    // error: unrecognised\n-\t    rust_error_at (t2->get_locus (),\n-\t\t\t   \"unrecognised token combination '$%s' at start of \"\n-\t\t\t   \"macro match - did you \"\n-\t\t\t   \"mean '$identifier' or '$('?\",\n-\t\t\t   t2->get_token_description ());\n+\t    rust_error_at (\n+\t      t2->get_locus (),\n+\t      \"unrecognised token combination %<$%s%> at start of \"\n+\t      \"macro match - did you mean %<$identifier%> or %<$(%>?\",\n+\t      t2->get_token_description ());\n \t    // skip somewhere?\n \t    return nullptr;\n \t  }\n@@ -1763,7 +1758,7 @@ Parser<ManagedTokenSource>::parse_macro_match ()\n     case RIGHT_CURLY:\n       // not allowed\n       rust_error_at (t->get_locus (),\n-\t\t     \"closing delimiters like '%s' are not allowed at the \"\n+\t\t     \"closing delimiters like %<%s%> are not allowed at the \"\n \t\t     \"start of a macro match\",\n \t\t     t->get_token_description ());\n       // skip somewhere?\n@@ -1802,9 +1797,10 @@ Parser<ManagedTokenSource>::parse_macro_match_fragment ()\n   AST::MacroFragSpec frag = AST::get_frag_spec_from_str (t->get_str ());\n   if (frag == AST::INVALID)\n     {\n-      rust_error_at (t->get_locus (),\n-\t\t     \"invalid fragment specifier '%s' in fragment macro match\",\n-\t\t     t->get_str ().c_str ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"invalid fragment specifier %<%s%> in fragment macro match\",\n+\tt->get_str ().c_str ());\n       return nullptr;\n     }\n \n@@ -1903,10 +1899,11 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n       lexer.skip_token ();\n       break;\n     default:\n-      rust_error_at (t->get_locus (),\n-\t\t     \"expected macro repetition operator ('*', '+', or '?') in \"\n-\t\t     \"macro match - found '%s'\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"expected macro repetition operator (%<*%>, %<+%>, or %<?%>) in \"\n+\t\"macro match - found %<%s%>\",\n+\tt->get_token_description ());\n       // skip after somewhere?\n       return nullptr;\n     }\n@@ -1979,7 +1976,7 @@ Parser<ManagedTokenSource>::parse_visibility ()\n \treturn AST::Visibility::create_in_path (std::move (path));\n       }\n     default:\n-      rust_error_at (t->get_locus (), \"unexpected token '%s' in visibility\",\n+      rust_error_at (t->get_locus (), \"unexpected token %<%s%> in visibility\",\n \t\t     t->get_token_description ());\n       lexer.skip_token ();\n       return AST::Visibility::create_error ();\n@@ -2051,7 +2048,7 @@ Parser<ManagedTokenSource>::parse_module (\n     default:\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unexpected token '%s' in module declaration/definition item\",\n+\t\"unexpected token %<%s%> in module declaration/definition item\",\n \tt->get_token_description ());\n       lexer.skip_token ();\n       return nullptr;\n@@ -2093,9 +2090,10 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     default:\n-      rust_error_at (crate_name_tok->get_locus (),\n-\t\t     \"expecting crate name (identifier or 'self'), found '%s'\",\n-\t\t     crate_name_tok->get_token_description ());\n+      rust_error_at (\n+\tcrate_name_tok->get_locus (),\n+\t\"expecting crate name (identifier or %<self%>), found %<%s%>\",\n+\tcrate_name_tok->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n     }\n@@ -2132,9 +2130,10 @@ Parser<ManagedTokenSource>::parse_extern_crate (\n       lexer.skip_token ();\n       break;\n     default:\n-      rust_error_at (as_name_tok->get_locus (),\n-\t\t     \"expecting as clause name (identifier or '_'), found '%s'\",\n-\t\t     as_name_tok->get_token_description ());\n+      rust_error_at (\n+\tas_name_tok->get_locus (),\n+\t\"expecting as clause name (identifier or %<_%>), found %<%s%>\",\n+\tas_name_tok->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n     }\n@@ -2280,8 +2279,8 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\treturn nullptr;\n \t      }\n \n-\t    // TODO: find way to determine whether GLOBAL or NO_PATH path type -\n-\t    // placeholder\n+\t    /* TODO: find way to determine whether GLOBAL or NO_PATH path type -\n+\t     * placeholder */\n \t    return std::unique_ptr<AST::UseTreeList> (\n \t      new AST::UseTreeList (AST::UseTreeList::NO_PATH,\n \t\t\t\t    AST::SimplePath::create_empty (),\n@@ -2290,15 +2289,14 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \tcase AS:\n \t  // this is not allowed\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"use declaration with rebind 'as' requires a valid \"\n+\t\t\t \"use declaration with rebind %<as%> requires a valid \"\n \t\t\t \"simple path - none found.\");\n \t  skip_after_semicolon ();\n \t  return nullptr;\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token '%s' in use tree with no valid \"\n-\t\t\t \"simple path (i.e. list or \"\n-\t\t\t \"glob use tree)\",\n+\t\t\t \"unexpected token %<%s%> in use tree with no valid \"\n+\t\t\t \"simple path (i.e. list or glob use tree)\",\n \t\t\t t->get_token_description ());\n \t  skip_after_semicolon ();\n \t  return nullptr;\n@@ -2382,11 +2380,11 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\t\t\t\t  std::move (path), locus,\n \t\t\t\t\t  std::string (\"_\")));\n \t      default:\n-\t\trust_error_at (\n-\t\t  t->get_locus (),\n-\t\t  \"unexpected token '%s' in use tree with as clause - expected \"\n-\t\t  \"identifier or '_'\",\n-\t\t  t->get_token_description ());\n+\t\trust_error_at (t->get_locus (),\n+\t\t\t       \"unexpected token %<%s%> in use tree with as \"\n+\t\t\t       \"clause - expected \"\n+\t\t\t       \"identifier or %<_%>\",\n+\t\t\t       t->get_token_description ());\n \t\tskip_after_semicolon ();\n \t\treturn nullptr;\n \t      }\n@@ -2408,7 +2406,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t\t\t\t    locus));\n \tdefault:\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token '%s' in use tree with valid path\",\n+\t\t\t \"unexpected token %<%s%> in use tree with valid path\",\n \t\t\t t->get_token_description ());\n \t  // skip_after_semicolon();\n \t  return nullptr;\n@@ -2766,8 +2764,7 @@ Parser<ManagedTokenSource>::parse_lifetime_params ()\n {\n   std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n \n-  // if end_token is not specified, it defaults to EOF, so should work fine\n-  while (lexer.peek_token ()->get_id () != end_token)\n+  while (lexer.peek_token ()->get_id () != END_OF_FILE)\n     {\n       AST::LifetimeParam lifetime_param = parse_lifetime_param ();\n \n@@ -2781,7 +2778,7 @@ Parser<ManagedTokenSource>::parse_lifetime_params ()\n \tnew AST::LifetimeParam (std::move (lifetime_param))));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       // skip commas, including trailing commas\n       lexer.skip_token ();\n@@ -2808,16 +2805,18 @@ Parser<ManagedTokenSource>::parse_lifetime_params (EndTokenPred is_end_token)\n \n       if (lifetime_param.is_error ())\n \t{\n-      // TODO: is it worth throwing away all lifetime params just because one failed?\n-      rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse lifetime param in lifetime params\");\n-      return {};\n+\t  // TODO: is it worth throwing away all lifetime params just because\n+\t  // one failed?\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse lifetime param in lifetime params\");\n+\t  return {};\n \t}\n \n       lifetime_params.push_back (std::unique_ptr<AST::LifetimeParam> (\n \tnew AST::LifetimeParam (std::move (lifetime_param))));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       // skip commas, including trailing commas\n       lexer.skip_token ();\n@@ -2844,14 +2843,14 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs ()\n \n       if (lifetime_param.is_error ())\n \t{\n-    // not an error as only way to exit if trailing comma\n+\t  // not an error as only way to exit if trailing comma\n \t  break;\n \t}\n \n       lifetime_params.push_back (std::move (lifetime_param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       // skip commas, including trailing commas\n       lexer.skip_token ();\n@@ -2868,7 +2867,8 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs ()\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n std::vector<AST::LifetimeParam>\n-Parser<ManagedTokenSource>::parse_lifetime_params_objs (EndTokenPred is_end_token)\n+Parser<ManagedTokenSource>::parse_lifetime_params_objs (\n+  EndTokenPred is_end_token)\n {\n   std::vector<AST::LifetimeParam> lifetime_params;\n \n@@ -2878,15 +2878,17 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs (EndTokenPred is_end_toke\n \n       if (lifetime_param.is_error ())\n \t{\n-      // TODO: is it worth throwing away all lifetime params just because one failed?\n-      rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse lifetime param in lifetime params\");\n-      return {};\n+\t  // TODO: is it worth throwing away all lifetime params just because\n+\t  // one failed?\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse lifetime param in lifetime params\");\n+\t  return {};\n \t}\n \n       lifetime_params.push_back (std::move (lifetime_param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       // skip commas, including trailing commas\n       lexer.skip_token ();\n@@ -2897,31 +2899,33 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs (EndTokenPred is_end_toke\n   return lifetime_params;\n }\n \n-/* Parses various types of generic parameters (templated). Will also consume any trailing\n- * comma. Has extra is_end_token predicate checking.\n+/* Parses various types of generic parameters (templated). Will also consume any\n+ * trailing comma. Has extra is_end_token predicate checking.\n  * TODO: is this best solution? implements most of the same algorithm. */\n template <typename ManagedTokenSource>\n template <typename ParseFunction, typename EndTokenPred>\n auto\n-Parser<ManagedTokenSource>::parse_generic_params (ParseFunction parsing_function, EndTokenPred is_end_token, std::string error_msg) -> std::vector<decltype(parsing_function ())>\n+Parser<ManagedTokenSource>::parse_generic_params (\n+  ParseFunction parsing_function, EndTokenPred is_end_token,\n+  std::string error_msg) -> std::vector<decltype (parsing_function ())>\n {\n-  std::vector<decltype(parsing_function ())> params;\n+  std::vector<decltype (parsing_function ())> params;\n \n   while (!is_end_token (lexer.peek_token ()->get_id ()))\n     {\n       auto param = parsing_function ();\n \n       if (param.is_error ())\n \t{\n-      // TODO: is it worth throwing away all params just because one failed?\n-      rust_error_at (lexer.peek_token ()->get_locus (), error_msg.c_str ());\n-      return {};\n+\t  // TODO: is it worth throwing away all params just because one failed?\n+\t  rust_error_at (lexer.peek_token ()->get_locus (), error_msg.c_str ());\n+\t  return {};\n \t}\n \n       params.push_back (std::move (param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n       // skip commas, including trailing commas\n       lexer.skip_token ();\n@@ -3305,7 +3309,8 @@ Parser<ManagedTokenSource>::parse_for_lifetimes ()\n       return params;\n     }\n \n-  // cannot specify end token due to parsing problems with '>' tokens being nested\n+  // cannot specify end token due to parsing problems with '>' tokens being\n+  // nested\n   params = parse_lifetime_params_objs (is_right_angle_tok);\n \n   if (!skip_generics_right_angle ())\n@@ -3662,7 +3667,7 @@ Parser<ManagedTokenSource>::parse_struct (\n \t\t\t       std::move (outer_attrs), locus));\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' in struct declaration\",\n+\t\t     \"unexpected token %<%s%> in struct declaration\",\n \t\t     t->get_token_description ());\n       // skip somewhere?\n       return nullptr;\n@@ -4081,10 +4086,11 @@ Parser<ManagedTokenSource>::parse_const_item (\n       lexer.skip_token ();\n       break;\n     default:\n-      rust_error_at (ident_tok->get_locus (),\n-\t\t     \"expected item name (identifier or '_') in constant item \"\n-\t\t     \"declaration - found '%s'\",\n-\t\t     ident_tok->get_token_description ());\n+      rust_error_at (\n+\tident_tok->get_locus (),\n+\t\"expected item name (identifier or %<_%>) in constant item \"\n+\t\"declaration - found %<%s%>\",\n+\tident_tok->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n     }\n@@ -4342,14 +4348,13 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t    break;\n \t  case LEFT_CURLY:\n \t    definition = parse_block_expr ();\n-\t    // FIXME: are these outer attributes meant to be passed into the\n-\t    // block?\n+\t    /* FIXME: are these outer attributes meant to be passed into the\n+\t     * block? */\n \t    break;\n \t  default:\n \t    rust_error_at (t->get_locus (),\n-\t\t\t   \"expected ';' or definiton at the end of trait %s \"\n-\t\t\t   \"definition - found '%s' \"\n-\t\t\t   \"instead\",\n+\t\t\t   \"expected %<;%> or definiton at the end of trait %s \"\n+\t\t\t   \"definition - found %<%s%> instead\",\n \t\t\t   is_method ? \"method\" : \"function\",\n \t\t\t   t->get_token_description ());\n \t    // skip?\n@@ -4402,8 +4407,8 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \t  {\n \t    return macro_invoc;\n \t  }\n-\t// FIXME: macro invocations can only start with certain tokens. be more\n-\t// picky with these?\n+\t/* FIXME: macro invocations can only start with certain tokens. be more\n+\t * picky with these? */\n       }\n     }\n }\n@@ -4739,16 +4744,17 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n \t\t\t\t\t\t\t\t outer_attrs));\n \t      default:\n \t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token '%s' in some sort of const \"\n+\t\t\t       \"unexpected token %<%s%> in some sort of const \"\n \t\t\t       \"item in inherent impl\",\n \t\t\t       t->get_token_description ());\n \t\tlexer.skip_token (1); // TODO: is this right thing to do?\n \t\treturn nullptr;\n \t      }\n \t  default:\n-\t    rust_error_at (t->get_locus (),\n-\t\t\t   \"unrecognised token '%s' for item in inherent impl\",\n-\t\t\t   t->get_token_description ());\n+\t    rust_error_at (\n+\t      t->get_locus (),\n+\t      \"unrecognised token %<%s%> for item in inherent impl\",\n+\t      t->get_token_description ());\n \t    // skip?\n \t    return nullptr;\n \t  }\n@@ -4776,17 +4782,17 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n \t  return parse_inherent_impl_function_or_method (\n \t    AST::Visibility::create_error (), std::move (outer_attrs));\n \tdefault:\n-\t  rust_error_at (\n-\t    t->get_locus (),\n-\t    \"unexpected token '%s' in some sort of const item in inherent impl\",\n-\t    t->get_token_description ());\n+\t  rust_error_at (t->get_locus (),\n+\t\t\t \"unexpected token %<%s%> in some sort of const item \"\n+\t\t\t \"in inherent impl\",\n+\t\t\t t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n \t}\n       gcc_unreachable ();\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' for item in inherent impl\",\n+\t\t     \"unrecognised token %<%s%> for item in inherent impl\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -4959,15 +4965,15 @@ Parser<ManagedTokenSource>::parse_trait_impl_item ()\n \t\t\t\t\t\t\t      outer_attrs));\n \t      default:\n \t\trust_error_at (t->get_locus (),\n-\t\t\t       \"unexpected token '%s' in some sort of const \"\n+\t\t\t       \"unexpected token %<%s%> in some sort of const \"\n \t\t\t       \"item in trait impl\",\n \t\t\t       t->get_token_description ());\n \t\tlexer.skip_token (1); // TODO: is this right thing to do?\n \t\treturn nullptr;\n \t      }\n \t  default:\n \t    rust_error_at (t->get_locus (),\n-\t\t\t   \"unrecognised token '%s' for item in trait impl\",\n+\t\t\t   \"unrecognised token %<%s%> for item in trait impl\",\n \t\t\t   t->get_token_description ());\n \t    // skip?\n \t    return nullptr;\n@@ -4998,15 +5004,15 @@ Parser<ManagedTokenSource>::parse_trait_impl_item ()\n \tdefault:\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token '%s' in some sort of const item in trait impl\",\n+\t    \"unexpected token %<%s%> in some sort of const item in trait impl\",\n \t    t->get_token_description ());\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n \t}\n       gcc_unreachable ();\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' for item in trait impl\",\n+\t\t     \"unrecognised token %<%s%> for item in trait impl\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -5345,8 +5351,7 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t\t  {\n \t\t    rust_error_at (t->get_locus (),\n \t\t\t\t   \"expected comma or right parentheses in \"\n-\t\t\t\t   \"named function parameters, \"\n-\t\t\t\t   \"found '%s'\",\n+\t\t\t\t   \"named function parameters, found %<%s%>\",\n \t\t\t\t   t->get_token_description ());\n \t\t  }\n \t\telse\n@@ -5399,9 +5404,10 @@ Parser<ManagedTokenSource>::parse_external_item ()\n       }\n     default:\n       // error\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' in extern block item declaration\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unrecognised token %<%s%> in extern block item declaration\",\n+\tt->get_token_description ());\n       skip_after_semicolon ();\n       return nullptr;\n     }\n@@ -5763,10 +5769,10 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \n   // skip any trailing commas\n   if (lexer.peek_token ()->get_id () == COMMA)\n-      lexer.skip_token ();\n+    lexer.skip_token ();\n \n   if (!skip_generics_right_angle ())\n-      return AST::GenericArgs::create_empty ();\n+    return AST::GenericArgs::create_empty ();\n \n   lifetime_args.shrink_to_fit ();\n   type_args.shrink_to_fit ();\n@@ -5893,19 +5899,22 @@ Parser<ManagedTokenSource>::parse_type_path_function ()\n       std::unique_ptr<AST::Type> type = parse_type ();\n       if (type == nullptr)\n \t{\n-\t  // this is an error as there should've been a ')' there if there wasn't a type\n-    rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse type in parameters of type path function\");\n-    // skip somewhere?\n-    return AST::TypePathFunction::create_error ();\n+\t  // this is an error as there should've been a ')' there if there\n+\t  // wasn't a type\n+\t  rust_error_at (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"failed to parse type in parameters of type path function\");\n+\t  // skip somewhere?\n+\t  return AST::TypePathFunction::create_error ();\n \t}\n \n       inputs.push_back (std::move (type));\n \n       // skip commas, including trailing commas\n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t  break;\n+\tbreak;\n \n-\t  lexer.skip_token ();\n+      lexer.skip_token ();\n     }\n \n   if (!skip_token (RIGHT_PAREN))\n@@ -6361,7 +6370,7 @@ Parser<ManagedTokenSource>::parse_method ()\n \n   // skip comma if it exists\n   if (lexer.peek_token ()->get_id () == COMMA)\n-      lexer.skip_token ();\n+    lexer.skip_token ();\n \n   // parse function parameters\n   std::vector<AST::FunctionParam> function_params = parse_function_params ();\n@@ -6539,11 +6548,11 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n       expr_parsed = parse_labelled_loop_expr (std::move (outer_attrs));\n       break;\n     default:\n-      rust_error_at (t->get_locus (),\n-\t\t     \"could not recognise expr beginning with '%s' as an expr \"\n-\t\t     \"with block in parsing \"\n-\t\t     \"expr statement.\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"could not recognise expr beginning with %<%s%> as an expr \"\n+\t\"with block in parsing expr statement.\",\n+\tt->get_token_description ());\n       skip_after_next_block ();\n       return nullptr;\n     }\n@@ -6854,10 +6863,10 @@ Parser<ManagedTokenSource>::parse_closure_expr (\n \t}\n       break;\n     default:\n-      rust_error_at (\n-\tt->get_locus (),\n-\t\"unexpected token '%s' in closure expression - expected '|' or '||'\",\n-\tt->get_token_description ());\n+      rust_error_at (t->get_locus (),\n+\t\t     \"unexpected token %<%s%> in closure expression - expected \"\n+\t\t     \"%<|%> or %<||%>\",\n+\t\t     t->get_token_description ());\n       // skip somewhere?\n       return nullptr;\n     }\n@@ -6980,7 +6989,7 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n     default:\n       // error - cannot be a literal expr\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' when parsing literal expression\",\n+\t\t     \"unexpected token %<%s%> when parsing literal expression\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -7131,8 +7140,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t     \"if let expression probably exists, but is being parsed \"\n-\t\t     \"as an if expression. This may \"\n-\t\t     \"be a parser error.\");\n+\t\t     \"as an if expression. This may be a parser error.\");\n       // skip somewhere?\n       return nullptr;\n     }\n@@ -7242,7 +7250,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \tdefault:\n \t  // error - invalid token\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unexpected token '%s' after else in if expression\",\n+\t\t\t \"unexpected token %<%s%> after else in if expression\",\n \t\t\t t->get_token_description ());\n \t  // skip somewhere?\n \t  return nullptr;\n@@ -7268,8 +7276,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t     \"if expression probably exists, but is being parsed as an \"\n-\t\t     \"if let expression. This may \"\n-\t\t     \"be a parser error.\");\n+\t\t     \"if let expression. This may be a parser error.\");\n       // skip somewhere?\n       return nullptr;\n     }\n@@ -7405,7 +7412,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t  // error - invalid token\n \t  rust_error_at (\n \t    t->get_locus (),\n-\t    \"unexpected token '%s' after else in if let expression\",\n+\t    \"unexpected token %<%s%> after else in if let expression\",\n \t    t->get_token_description ());\n \t  // skip somewhere?\n \t  return nullptr;\n@@ -7425,9 +7432,9 @@ Parser<ManagedTokenSource>::parse_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-      locus = lexer.peek_token ()->get_locus ();\n+    locus = lexer.peek_token ()->get_locus ();\n   else\n-      locus = label.get_locus ();\n+    locus = label.get_locus ();\n   skip_token (LOOP);\n \n   // parse loop body, which is required\n@@ -7453,9 +7460,9 @@ Parser<ManagedTokenSource>::parse_while_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-      locus = lexer.peek_token ()->get_locus ();\n+    locus = lexer.peek_token ()->get_locus ();\n   else\n-      locus = label.get_locus ();\n+    locus = label.get_locus ();\n   skip_token (WHILE);\n \n   // ensure it isn't a while let loop\n@@ -7508,9 +7515,9 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-      locus = lexer.peek_token ()->get_locus ();\n+    locus = lexer.peek_token ()->get_locus ();\n   else\n-      locus = label.get_locus ();\n+    locus = label.get_locus ();\n   skip_token (WHILE);\n \n   /* check for possible accidental recognition of a while loop as a while let\n@@ -7578,9 +7585,9 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-      locus = lexer.peek_token ()->get_locus ();\n+    locus = lexer.peek_token ()->get_locus ();\n   else\n-      locus = label.get_locus ();\n+    locus = label.get_locus ();\n   skip_token (FOR);\n \n   // parse pattern, which is required\n@@ -7644,7 +7651,7 @@ Parser<ManagedTokenSource>::parse_labelled_loop_expr (\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t     \"expected lifetime in labelled loop expr (to parse loop \"\n-\t\t     \"label) - found '%s'\",\n+\t\t     \"label) - found %<%s%>\",\n \t\t     lexer.peek_token ()->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -7683,7 +7690,7 @@ Parser<ManagedTokenSource>::parse_labelled_loop_expr (\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' when parsing labelled loop\",\n+\t\t     \"unexpected token %<%s%> when parsing labelled loop\",\n \t\t     t->get_token_description ());\n       // skip?\n       return nullptr;\n@@ -8083,9 +8090,9 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t{\n \t  // single-element array expression\n \t  std::vector<std::unique_ptr<AST::Expr> > exprs;\n-    exprs.reserve (1);\n+\t  exprs.reserve (1);\n \t  exprs.push_back (std::move (initial_expr));\n-    exprs.shrink_to_fit ();\n+\t  exprs.shrink_to_fit ();\n \n \t  std::unique_ptr<AST::ArrayElemsValues> array_elems (\n \t    new AST::ArrayElemsValues (std::move (exprs)));\n@@ -8127,7 +8134,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \n \t  skip_token (RIGHT_SQUARE);\n \n-    exprs.shrink_to_fit ();\n+\t  exprs.shrink_to_fit ();\n \n \t  std::unique_ptr<AST::ArrayElemsValues> array_elems (\n \t    new AST::ArrayElemsValues (std::move (exprs)));\n@@ -8141,7 +8148,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t  // error\n \t  rust_error_at (\n \t    lexer.peek_token ()->get_locus (),\n-\t    \"unexpected token '%s' in array expression (arrayelems)\",\n+\t    \"unexpected token %<%s%> in array expression (arrayelems)\",\n \t    lexer.peek_token ()->get_token_description ());\n \t  // skip somewhere?\n \t  return nullptr;\n@@ -8282,9 +8289,9 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n       // error\n       const_TokenPtr t = lexer.peek_token ();\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' in grouped or tuple expression \"\n-\t\t     \"(parenthesised expression) - \"\n-\t\t     \"expected ')' for grouped expr and ',' for tuple expr\",\n+\t\t     \"unexpected token %<%s%> in grouped or tuple expression \"\n+\t\t     \"(parenthesised expression) - expected %<)%> for grouped \"\n+\t\t     \"expr and %<,%> for tuple expr\",\n \t\t     t->get_token_description ());\n       // skip somewhere?\n       return nullptr;\n@@ -8462,8 +8469,8 @@ Parser<ManagedTokenSource>::parse_type ()\n       }\n     case LEFT_PAREN:\n       /* tuple type or parenthesised type - requires further disambiguation (the\n-       * usual). ok apparently can be a parenthesised TraitBound too, so could be\n-       * TraitObjectTypeOneBound or TraitObjectType */\n+       * usual). ok apparently can be a parenthesised TraitBound too, so could\n+       * be TraitObjectTypeOneBound or TraitObjectType */\n       return parse_paren_prefixed_type ();\n     case FOR:\n       // TraitObjectTypeOneBound or BareFunctionType\n@@ -8612,7 +8619,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  }\n       }\n     default:\n-      rust_error_at (t->get_locus (), \"unrecognised token '%s' in type\",\n+      rust_error_at (t->get_locus (), \"unrecognised token %<%s%> in type\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -8837,9 +8844,8 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' in bare function type or trait \"\n-\t\t     \"object type or trait \"\n-\t\t     \"object type one bound\",\n+\t\t     \"unrecognised token %<%s%> in bare function type or trait \"\n+\t\t     \"object type or trait object type one bound\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9047,7 +9053,7 @@ Parser<ManagedTokenSource>::parse_raw_pointer_type ()\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' in raw pointer type\",\n+\t\t     \"unrecognised token %<%s%> in raw pointer type\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9118,7 +9124,7 @@ Parser<ManagedTokenSource>::parse_slice_or_array_type ()\n       // error\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unrecognised token '%s' in slice or array type after inner type\",\n+\t\"unrecognised token %<%s%> in slice or array type after inner type\",\n \tt->get_token_description ());\n       return nullptr;\n     }\n@@ -9241,8 +9247,8 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n       }\n     case LEFT_PAREN:\n       /* tuple type or parenthesised type - requires further disambiguation (the\n-       * usual). ok apparently can be a parenthesised TraitBound too, so could be\n-       * TraitObjectTypeOneBound */\n+       * usual). ok apparently can be a parenthesised TraitBound too, so could\n+       * be TraitObjectTypeOneBound */\n       return parse_paren_prefixed_type_no_bounds ();\n     case FOR:\n     case ASYNC:\n@@ -9259,10 +9265,10 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \t  /* cannot be one bound because lifetime prevents it from being\n \t   * traitbound not allowed as type no bounds, only here for error\n \t   * message */\n-\t  rust_error_at (lexer.peek_token ()->get_locus (),\n-\t\t\t \"lifetime (probably lifetime bound, in type param \"\n-\t\t\t \"bounds, in ImplTraitType) is \"\n-\t\t\t \"not allowed in TypeNoBounds\");\n+\t  rust_error_at (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"lifetime (probably lifetime bound, in type param \"\n+\t    \"bounds, in ImplTraitType) is not allowed in TypeNoBounds\");\n \t  return nullptr;\n \t}\n       else\n@@ -9351,7 +9357,7 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n       }\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' in type no bounds\",\n+\t\t     \"unrecognised token %<%s%> in type no bounds\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9510,16 +9516,17 @@ Parser<ManagedTokenSource>::parse_literal_or_range_pattern ()\n \t  break;\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n-\t\t\t \"token type '%s' cannot be parsed as range pattern \"\n+\t\t\t \"token type %<%s%> cannot be parsed as range pattern \"\n \t\t\t \"bound or literal after minus symbol\",\n \t\t\t range_lower->get_token_description ());\n \t  return nullptr;\n \t}\n       break;\n     default:\n-      rust_error_at (range_lower->get_locus (),\n-\t\t     \"token type '%s' cannot be parsed as range pattern bound\",\n-\t\t     range_lower->get_token_description ());\n+      rust_error_at (\n+\trange_lower->get_locus (),\n+\t\"token type %<%s%> cannot be parsed as range pattern bound\",\n+\trange_lower->get_token_description ());\n       return nullptr;\n     }\n \n@@ -9613,7 +9620,7 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \t      range_lower_locus, true));\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n-\t\t\t \"token type '%s' cannot be parsed as range pattern \"\n+\t\t\t \"token type %<%s%> cannot be parsed as range pattern \"\n \t\t\t \"bound after minus symbol\",\n \t\t\t range_lower->get_token_description ());\n \t  return nullptr;\n@@ -9652,9 +9659,10 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \t  new AST::RangePatternBoundQualPath (std::move (path)));\n       }\n     default:\n-      rust_error_at (range_lower->get_locus (),\n-\t\t     \"token type '%s' cannot be parsed as range pattern bound\",\n-\t\t     range_lower->get_token_description ());\n+      rust_error_at (\n+\trange_lower->get_locus (),\n+\t\"token type %<%s%> cannot be parsed as range pattern bound\",\n+\trange_lower->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -9702,8 +9710,8 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t}\n       else\n \t{\n-\t  rust_error_at (t->get_locus (), \"unexpected token '-' in pattern - \"\n-\t\t\t\t\t  \"did you forget an integer literal?\");\n+\t  rust_error_at (t->get_locus (), \"unexpected token %<-%> in pattern - \"\n+\t\t\t\t\t  \"did you forget an integer literal\");\n \t  return nullptr;\n \t}\n     case UNDERSCORE:\n@@ -9834,7 +9842,7 @@ Parser<ManagedTokenSource>::parse_pattern ()\n \t  }\n       }\n     default:\n-      rust_error_at (t->get_locus (), \"unexpected token '%s' in pattern\",\n+      rust_error_at (t->get_locus (), \"unexpected token %<%s%> in pattern\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -9860,7 +9868,7 @@ Parser<ManagedTokenSource>::parse_reference_pattern ()\n       break;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' in reference pattern\",\n+\t\t     \"unexpected token %<%s%> in reference pattern\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -10060,7 +10068,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' in grouped or tuple pattern \"\n+\t\t     \"unrecognised token %<%s%> in grouped or tuple pattern \"\n \t\t     \"after first pattern\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -10446,7 +10454,7 @@ Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n     default:\n       // error\n       rust_error_at (t->get_locus (),\n-\t\t     \"unexpected token '%s' in tuple struct items\",\n+\t\t     \"unexpected token %<%s%> in tuple struct items\",\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n@@ -10493,8 +10501,8 @@ Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n     }\n \n   /* FIXME: this method of parsing prevents parsing any outer attributes on the\n-   * .. - also there seems to be no distinction between having etc and not having\n-   * etc. */\n+   * .. - also there seems to be no distinction between having etc and not\n+   * having etc. */\n   if (lexer.peek_token ()->get_id () == DOT_DOT)\n     {\n       lexer.skip_token ();\n@@ -10588,7 +10596,7 @@ Parser<ManagedTokenSource>::parse_struct_pattern_field ()\n \tdefault:\n \t  // error\n \t  rust_error_at (t->get_locus (),\n-\t\t\t \"unrecognised token '%s' in struct pattern field\",\n+\t\t\t \"unrecognised token %<%s%> in struct pattern field\",\n \t\t\t t->get_token_description ());\n \t  return nullptr;\n \t}\n@@ -10722,9 +10730,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \t    }\n \t  default:\n \t    rust_error_at (t2->get_locus (),\n-\t\t\t   \"unrecognised token '%s' after parsing unsafe - \"\n-\t\t\t   \"expected beginning of \"\n-\t\t\t   \"expression or statement\",\n+\t\t\t   \"unrecognised token %<%s%> after parsing unsafe - \"\n+\t\t\t   \"expected beginning of expression or statement\",\n \t\t\t   t->get_token_description ());\n \t    // skip somewhere?\n \t    return ExprOrStmt::create_error ();\n@@ -10925,7 +10932,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t  default:\n \t    rust_error_at (\n \t      t3->get_locus (),\n-\t      \"unrecognised token '%s' in macro invocation - (opening) \"\n+\t      \"unrecognised token %<%s%> in macro invocation - (opening) \"\n \t      \"delimiter expected\",\n \t      t3->get_token_description ());\n \t    return ExprOrStmt::create_error ();\n@@ -10946,7 +10953,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t\trust_error_at (\n \t\t  t3->get_locus (),\n \t\t  \"failed to parse token tree for macro invocation (or semi) - \"\n-\t\t  \"found '%s'\",\n+\t\t  \"found %<%s%>\",\n \t\t  t3->get_token_description ());\n \t\treturn ExprOrStmt::create_error ();\n \t      }\n@@ -10995,12 +11002,14 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \telse\n \t  {\n \t    // tokens don't match opening delimiters, so produce error\n-\t    rust_error_at (\n-\t      t2->get_locus (),\n-\t      \"unexpected token '%s' - expecting closing delimiter '%s' (for a \"\n-\t      \"macro invocation)\",\n-\t      t2->get_token_description (),\n-\t      (type == AST::PARENS ? \")\" : (type == AST::SQUARE ? \"]\" : \"}\")));\n+\t    rust_error_at (t2->get_locus (),\n+\t\t\t   \"unexpected token %<%s%> - expecting closing \"\n+\t\t\t   \"delimiter %<%s%> (for a \"\n+\t\t\t   \"macro invocation)\",\n+\t\t\t   t2->get_token_description (),\n+\t\t\t   (type == AST::PARENS\n+\t\t\t      ? \")\"\n+\t\t\t      : (type == AST::SQUARE ? \"]\" : \"}\")));\n \t    return ExprOrStmt::create_error ();\n \t  }\n       }\n@@ -11176,7 +11185,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_field ()\n       return nullptr;\n     default:\n       rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' as first token of struct expr \"\n+\t\t     \"unrecognised token %<%s%> as first token of struct expr \"\n \t\t     \"field - expected identifier or int literal\",\n \t\t     t->get_token_description ());\n       return nullptr;\n@@ -11219,10 +11228,11 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n       type = AST::CURLY;\n       break;\n     default:\n-      rust_error_at (t3->get_locus (),\n-\t\t     \"unrecognised token '%s' in macro invocation - (opening) \"\n-\t\t     \"delimiter expected\",\n-\t\t     t3->get_token_description ());\n+      rust_error_at (\n+\tt3->get_locus (),\n+\t\"unrecognised token %<%s%> in macro invocation - (opening) \"\n+\t\"delimiter expected\",\n+\tt3->get_token_description ());\n       return ExprOrStmt::create_error ();\n     }\n   lexer.skip_token ();\n@@ -11240,7 +11250,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \t{\n \t  rust_error_at (t3->get_locus (),\n \t\t\t \"failed to parse token tree for macro invocation (or \"\n-\t\t\t \"semi) - found '%s'\",\n+\t\t\t \"semi) - found %<%s%>\",\n \t\t\t t3->get_token_description ());\n \t  return ExprOrStmt::create_error ();\n \t}\n@@ -11291,7 +11301,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n       // tokens don't match opening delimiters, so produce error\n       rust_error_at (\n \tt->get_locus (),\n-\t\"unexpected token '%s' - expecting closing delimiter '%s' (for a \"\n+\t\"unexpected token %<%s%> - expecting closing delimiter %<%s%> (for a \"\n \t\"macro invocation)\",\n \tt->get_token_description (),\n \t(type == AST::PARENS ? \")\" : (type == AST::SQUARE ? \"]\" : \"}\")));\n@@ -11304,7 +11314,7 @@ template <typename ManagedTokenSource>\n void\n Parser<ManagedTokenSource>::unexpected_token (const_TokenPtr t)\n {\n-  rust_error_at (t->get_locus (), \"unexpected %s\\n\",\n+  rust_error_at (t->get_locus (), \"unexpected token %<%s%>\\n\",\n \t\t t->get_token_description ());\n }\n \n@@ -11349,7 +11359,7 @@ Parser<ManagedTokenSource>::expect_token (TokenId token_id)\n     }\n   else\n     {\n-      rust_error_at (t->get_locus (), \"expecting %s but %s found!\\n\",\n+      rust_error_at (t->get_locus (), \"expecting %<%s%> but %<%s%> found\\n\",\n \t\t     get_token_description (token_id),\n \t\t     t->get_token_description ());\n \n@@ -11594,7 +11604,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t  if (path.is_single_segment ())\n \t\t    {\n \t\t      // have to return an identifier expression or something\n-          /* HACK: may have to become permanent, but this is my\n+\t\t      /* HACK: may have to become permanent, but this is my\n \t\t       * current identifier expression */\n \t\t      return std::unique_ptr<AST::IdentifierExpr> (\n \t\t\tnew AST::IdentifierExpr (tok->get_str (),\n@@ -11953,7 +11963,7 @@ Parser<ManagedTokenSource>::null_denotation (\n       return parse_array_expr (std::move (outer_attrs), true);\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"found unexpected token '%s' in null denotation\",\n+\t\t     \"found unexpected token %<%s%> in null denotation\",\n \t\t     tok->get_token_description ());\n       return nullptr;\n     }\n@@ -12271,7 +12281,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t\t\t   restrictions);\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"found unexpected token '%s' in left denotation\",\n+\t\t     \"found unexpected token %<%s%> in left denotation\",\n \t\t     tok->get_token_description ());\n       return nullptr;\n     }\n@@ -12309,7 +12319,7 @@ get_lbp_for_arithmetic_or_logical_expr (\n       // WTF? should not happen, this is an error\n       rust_error_at (\n \tLocation (),\n-\t\"could not get LBP for ArithmeticOrLogicalExpr - unknown ExprType!\");\n+\t\"could not get LBP for ArithmeticOrLogicalExpr - unknown ExprType\");\n       return LBP_PLUS;\n     }\n }\n@@ -12591,9 +12601,8 @@ get_lbp_for_comparison_expr (AST::ComparisonExpr::ExprType expr_type)\n       return LBP_SMALLER_EQUAL;\n     default:\n       // WTF? should not happen, this is an error\n-      rust_error_at (\n-\tLocation (),\n-\t\"could not get LBP for ComparisonExpr - unknown ExprType!\");\n+      rust_error_at (Location (),\n+\t\t     \"could not get LBP for ComparisonExpr - unknown ExprType\");\n       return LBP_EQUAL;\n     }\n }\n@@ -12878,7 +12887,7 @@ get_lbp_for_compound_assignment_expr (\n       // WTF? should not happen, this is an error\n       rust_error_at (\n \tLocation (),\n-\t\"could not get LBP for CompoundAssignmentExpr - unknown ExprType!\");\n+\t\"could not get LBP for CompoundAssignmentExpr - unknown ExprType\");\n       return LBP_PLUS;\n     }\n }\n@@ -13168,8 +13177,9 @@ Parser<ManagedTokenSource>::parse_await_expr (\n    * as await */\n   if (!skip_token (IDENTIFIER))\n     {\n-      rust_error_at (tok->get_locus (), \"failed to skip 'await' in await expr \"\n-\t\t\t\t\t\"- this is probably a deep issue.\");\n+      rust_error_at (tok->get_locus (),\n+\t\t     \"failed to skip %<await%> in await expr \"\n+\t\t     \"- this is probably a deep issue\");\n       // skip somewhere?\n       return nullptr;\n     }\n@@ -13618,10 +13628,11 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n \t\t\t\t\t   std::move (outer_attrs)));\n       }\n     default:\n-      rust_error_at (t->get_locus (),\n-\t\t     \"unrecognised token '%s' in struct (or enum) expression - \"\n-\t\t     \"expected '}', identifier, int literal, or '..'\",\n-\t\t     t->get_token_description ());\n+      rust_error_at (\n+\tt->get_locus (),\n+\t\"unrecognised token %<%s%> in struct (or enum) expression - \"\n+\t\"expected %<}%>, identifier, int literal, or %<..%>\",\n+\tt->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -13649,9 +13660,9 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n       std::unique_ptr<AST::Expr> expr = parse_expr ();\n       if (expr == nullptr)\n \t{\n-\t  rust_error_at (t->get_locus (),\n-\t\t\t \"failed to parse expression in struct \"\n-\t\t\t \"(or enum) expression tuple\");\n+\t  rust_error_at (\n+\t    t->get_locus (),\n+\t    \"failed to parse expression in struct (or enum) expression tuple\");\n \t  return nullptr;\n \t}\n       exprs.push_back (std::move (expr));\n@@ -13724,7 +13735,7 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n       gcc_fallthrough ();\n     default:\n       rust_error_at (tok->get_locus (),\n-\t\t     \"unrecognised token '%s' in path in expression\",\n+\t\t     \"unrecognised token %<%s%> in path in expression\",\n \t\t     tok->get_token_description ());\n       return AST::PathInExpression::create_error ();\n     }\n@@ -13847,10 +13858,10 @@ Parser<ManagedTokenSource>::parse_closure_expr_pratt (\n \tbreak;\n       }\n     default:\n-      rust_error_at (\n-\ttok->get_locus (),\n-\t\"unexpected token '%s' in closure expression - expected '|' or '||'\",\n-\ttok->get_token_description ());\n+      rust_error_at (tok->get_locus (),\n+\t\t     \"unexpected token %<%s%> in closure expression - expected \"\n+\t\t     \"%<|%> or %<||%>\",\n+\t\t     tok->get_token_description ());\n       // skip somewhere?\n       return nullptr;\n     }"}, {"sha": "d76d81613fe9732c9444cb0a7b01d6e68c135c68", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 135, "deletions": 121, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636b1630184a37a9d5647cff19103bca34c8f125/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636b1630184a37a9d5647cff19103bca34c8f125/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=636b1630184a37a9d5647cff19103bca34c8f125", "patch": "@@ -235,41 +235,49 @@ void\n Session::init ()\n {\n #ifndef TARGET_RUST_OS_INFO\n-# define TARGET_RUST_OS_INFO()\n+#define TARGET_RUST_OS_INFO()\n #endif\n //#define builtin_rust_info(KEY, VALUE) rust_add_target_info (KEY, VALUE)\n // might as well use c++ stuff\n-#define builtin_rust_info(KEY, VALUE) options.target_data.insert_key_value_pair(KEY, VALUE)\n-\n-    // initialise target hooks\n-    //targetrustm.rust_cpu_info();\n-    //targetrustm.rust_os_info();\n-    // ok, that's not working too well TODO - see if can salvage old implementation \n-    TARGET_RUST_CPU_INFO ();\n-    TARGET_RUST_OS_INFO ();\n-\n-    /* note that due to issues with gcc targets, some implementations of those two macros above \n-     * (TARGET_RUST_CPU_INFO and TARGET_RUST_OS_INFO) are not function calls, but actually inline \n-     * substitutions. As such, they can't be stored with a function pointer in a \"real\" target hook. \n-     * At least, that's my current understanding of it. */\n-        \n+#define builtin_rust_info(KEY, VALUE)                                          \\\n+  options.target_data.insert_key_value_pair (KEY, VALUE)\n+\n+  // initialise target hooks\n+  // targetrustm.rust_cpu_info();\n+  // targetrustm.rust_os_info();\n+  // ok, that's not working too well TODO - see if can salvage old\n+  // implementation\n+  TARGET_RUST_CPU_INFO ();\n+  TARGET_RUST_OS_INFO ();\n+\n+  /* note that due to issues with gcc targets, some implementations of those two\n+   * macros above (TARGET_RUST_CPU_INFO and TARGET_RUST_OS_INFO) are not\n+   * function calls, but actually inline substitutions. As such, they can't be\n+   * stored with a function pointer in a \"real\" target hook.\n+   * At least, that's my current understanding of it. */\n+\n #undef builtin_rust_info\n \n-    // target-independent values that should exist in all targets\n-    options.target_data.insert_key_value_pair (\"target_pointer_width\", std::to_string (POINTER_SIZE));\n-    options.target_data.insert_key_value_pair (\"target_endian\", BYTES_BIG_ENDIAN ? \"big\" : \"little\");\n+  // target-independent values that should exist in all targets\n+  options.target_data.insert_key_value_pair (\"target_pointer_width\",\n+\t\t\t\t\t     std::to_string (POINTER_SIZE));\n+  options.target_data.insert_key_value_pair (\"target_endian\", BYTES_BIG_ENDIAN\n+\t\t\t\t\t\t\t\t? \"big\"\n+\t\t\t\t\t\t\t\t: \"little\");\n \n-    // TODO: find min atomic width and max atomic width\n-    // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if inside bounds)\n-    // in rustc, min atomic width is a known quantity (or 8 if not known), and max is also a known quantity (or is pointer size if not known)\n-    // TODO: add atomic pointer if some criteria is satisfied\n+  // TODO: find min atomic width and max atomic width\n+  // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if\n+  // inside bounds) in rustc, min atomic width is a known quantity (or 8 if not\n+  // known), and max is also a known quantity (or is pointer size if not known)\n+  // TODO: add atomic pointer if some criteria is satisfied\n \n-    // TODO: find whether target has \"atomic cas\"\n+  // TODO: find whether target has \"atomic cas\"\n \n-    // add debug_assertions if enabled and proc_macro if crate type has it or whatever\n+  // add debug_assertions if enabled and proc_macro if crate type has it or\n+  // whatever\n \n-    // derived values from hook\n-    options.target_data.init_derived_values ();\n+  // derived values from hook\n+  options.target_data.init_derived_values ();\n }\n \n /* Initialise default options. Actually called before handle_option, unlike init\n@@ -328,9 +336,9 @@ Session::enable_dump (std::string arg)\n    * created */\n   if (arg == \"all\")\n     {\n-      rust_error_at (\n-\tLocation (),\n-\t\"dumping all is not supported as of now. choose 'lex', 'parse', or 'target_options\");\n+      rust_error_at (Location (),\n+\t\t     \"dumping all is not supported as of now. choose %<lex%>, \"\n+\t\t     \"%<parse%>, or %<target_options%>\");\n       return false;\n     }\n   else if (arg == \"lex\")\n@@ -356,25 +364,28 @@ Session::enable_dump (std::string arg)\n   else if (arg == \"resolution\")\n     {\n       options.dump_option = CompileOptions::RESOLUTION_DUMP;\n-    } \n-  else if (arg == \"target_options\") {\n+    }\n+  else if (arg == \"target_options\")\n+    {\n       // special case - dump all target options, and then quit compilation\n-      // nope, option handling called before init, so have to make this an actual compile option\n-      //options.target_data.dump_target_options();\n-      //return false;\n+      // nope, option handling called before init, so have to make this an\n+      // actual compile option\n+      // options.target_data.dump_target_options();\n+      // return false;\n       options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n     }\n   else if (arg == \"\")\n     {\n-      rust_error_at (Location (),\n-\t\t\"dump option was not given a name. choose 'lex', 'parse', or 'target_options'\");\n+      rust_error_at (Location (), \"dump option was not given a name. choose \"\n+\t\t\t\t  \"%<lex%>, %<parse%>, or %<target_options%>\");\n       return false;\n     }\n   else\n     {\n       rust_error_at (Location (),\n-\t\t\"dump option '%s' was unrecognised. choose 'lex', 'parse', or 'target_options\",\n-\t\targ.c_str ());\n+\t\t     \"dump option %<%s%> was unrecognised. choose %<lex%>, \"\n+\t\t     \"%<parse%>, or %<target_options%>\",\n+\t\t     arg.c_str ());\n       return false;\n     }\n   return true;\n@@ -399,7 +410,7 @@ Session::parse_file (const char *filename)\n {\n   RAIIFile file_wrap (filename);\n \n-  if (file_wrap.get_raw() == nullptr)\n+  if (file_wrap.get_raw () == nullptr)\n     {\n       rust_fatal_error (Location (), \"cannot open filename %s: %m\", filename);\n     }\n@@ -420,7 +431,8 @@ Session::parse_file (const char *filename)\n     {\n     case CompileOptions::LEXER_DUMP:\n       parser.debug_dump_lex_output ();\n-      // TODO: rewrite lexer dump or something so that it allows for the crate to already be parsed\n+      // TODO: rewrite lexer dump or something so that it allows for the crate\n+      // to already be parsed\n       break;\n     case CompileOptions::PARSER_AST_DUMP:\n       parser.debug_dump_ast_output (parsed_crate);\n@@ -583,7 +595,7 @@ contains_name (const std::vector<AST::Attribute> &attrs, std::string name)\n   for (const auto &attr : attrs)\n     {\n       if (attr.get_path () == name)\n-\t    return true;\n+\treturn true;\n     }\n \n   return false;\n@@ -696,8 +708,7 @@ Session::injection (AST::Crate &crate)\n   // create use tree and decl\n   std::unique_ptr<AST::UseTreeGlob> use_tree (\n     new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n-\t\t\t  AST::SimplePath (std::move (segments)),\n-\t\t\t  Location ()));\n+\t\t\t  AST::SimplePath (std::move (segments)), Location ()));\n   AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\"),\n \t\t\t       nullptr);\n   std::unique_ptr<AST::UseDeclaration> use_decl (\n@@ -754,88 +765,91 @@ Session::resolution (AST::Crate &crate)\n   fprintf (stderr, \"finished name resolution\\n\");\n }\n \n-void \n-TargetOptions::dump_target_options () const \n-  {\n-    fprintf (stderr, \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n-    for (const auto& pairs : features) \n-      {\n-        for (const auto& value : pairs.second)\n-            fprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (), value.c_str ());\n-        \n-        if (pairs.second.empty ())\n-            fprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n-      }\n-    if (features.empty ())\n-        fprintf (stderr, \"No target options available!\\n\");\n+void\n+TargetOptions::dump_target_options () const\n+{\n+  fprintf (stderr,\n+\t   \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n+  for (const auto &pairs : features)\n+    {\n+      for (const auto &value : pairs.second)\n+\tfprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (), value.c_str ());\n \n-    fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n-  }\n+      if (pairs.second.empty ())\n+\tfprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n+    }\n+  if (features.empty ())\n+    fprintf (stderr, \"No target options available!\\n\");\n \n-void \n-TargetOptions::init_derived_values () \n-  {\n-    // enable derived values based on target families\n-    if (has_key_value_pair (\"target_family\", \"unix\"))\n-        insert_key (\"unix\");\n-    if (has_key_value_pair (\"target_family\", \"windows\"))\n-        insert_key (\"windows\");\n-        \n-    // implicitly enable features - this should not be required in general\n-    if (has_key_value_pair (\"target_feature\", \"aes\")) \n-        enable_implicit_feature_reqs (\"aes\");\n-    if (has_key_value_pair (\"target_feature\", \"avx\"))\n-        enable_implicit_feature_reqs (\"sse4.2\");\n-    if (has_key_value_pair (\"target_feature\", \"avx2\"))\n-        enable_implicit_feature_reqs (\"avx\");\n-    if (has_key_value_pair (\"target_feature\", \"pclmulqdq\"))\n-        enable_implicit_feature_reqs (\"sse2\");\n-    if (has_key_value_pair (\"target_feature\", \"sha\"))\n-        enable_implicit_feature_reqs (\"sse2\");\n-    if (has_key_value_pair (\"target_feature\", \"sse2\"))\n-        enable_implicit_feature_reqs (\"sse\");\n-    if (has_key_value_pair (\"target_feature\", \"sse3\"))\n-        enable_implicit_feature_reqs (\"sse2\");\n-    if (has_key_value_pair (\"target_feature\", \"sse4.1\"))\n-        enable_implicit_feature_reqs (\"sse3\");\n-    if (has_key_value_pair (\"target_feature\", \"sse4.2\"))\n-        enable_implicit_feature_reqs (\"sse4.1\");\n-    if (has_key_value_pair (\"target_feature\", \"ssse3\"))\n-        enable_implicit_feature_reqs (\"sse3\");\n-  }\n+  fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n+}\n+\n+void\n+TargetOptions::init_derived_values ()\n+{\n+  // enable derived values based on target families\n+  if (has_key_value_pair (\"target_family\", \"unix\"))\n+    insert_key (\"unix\");\n+  if (has_key_value_pair (\"target_family\", \"windows\"))\n+    insert_key (\"windows\");\n+\n+  // implicitly enable features - this should not be required in general\n+  if (has_key_value_pair (\"target_feature\", \"aes\"))\n+    enable_implicit_feature_reqs (\"aes\");\n+  if (has_key_value_pair (\"target_feature\", \"avx\"))\n+    enable_implicit_feature_reqs (\"sse4.2\");\n+  if (has_key_value_pair (\"target_feature\", \"avx2\"))\n+    enable_implicit_feature_reqs (\"avx\");\n+  if (has_key_value_pair (\"target_feature\", \"pclmulqdq\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sha\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sse2\"))\n+    enable_implicit_feature_reqs (\"sse\");\n+  if (has_key_value_pair (\"target_feature\", \"sse3\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sse4.1\"))\n+    enable_implicit_feature_reqs (\"sse3\");\n+  if (has_key_value_pair (\"target_feature\", \"sse4.2\"))\n+    enable_implicit_feature_reqs (\"sse4.1\");\n+  if (has_key_value_pair (\"target_feature\", \"ssse3\"))\n+    enable_implicit_feature_reqs (\"sse3\");\n+}\n \n-void \n-TargetOptions::enable_implicit_feature_reqs (std::string feature) \n-  {\n-    if (feature == \"aes\") \n-        enable_implicit_feature_reqs (\"sse2\");\n-    else if (feature == \"avx\")\n-        enable_implicit_feature_reqs (\"sse4.2\");\n-    else if (feature == \"avx2\")\n-        enable_implicit_feature_reqs (\"avx\");\n-    else if (feature == \"fma\")\n-        enable_implicit_feature_reqs (\"avx\");\n-    else if (feature == \"pclmulqdq\") \n-        enable_implicit_feature_reqs (\"sse2\");\n-    else if (feature == \"sha\")\n-        enable_implicit_feature_reqs (\"sse2\");\n-    else if (feature == \"sse2\")\n-        enable_implicit_feature_reqs (\"sse\");\n-    else if (feature == \"sse3\")\n-        enable_implicit_feature_reqs (\"sse2\");\n-    else if (feature == \"sse4.1\")\n-        enable_implicit_feature_reqs (\"sse3\");\n-    else if (feature == \"sse4.2\")\n-        enable_implicit_feature_reqs (\"sse4.1\");\n-    else if (feature == \"ssse3\")\n-        enable_implicit_feature_reqs (\"sse3\");\n-\n-    if (!has_key_value_pair (\"target_feature\", feature)) {\n-        insert_key_value_pair (\"target_feature\", feature);\n-\n-        fprintf (stderr, \"had to implicitly enable feature '%s'!\", feature.c_str ());\n+void\n+TargetOptions::enable_implicit_feature_reqs (std::string feature)\n+{\n+  if (feature == \"aes\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"avx\")\n+    enable_implicit_feature_reqs (\"sse4.2\");\n+  else if (feature == \"avx2\")\n+    enable_implicit_feature_reqs (\"avx\");\n+  else if (feature == \"fma\")\n+    enable_implicit_feature_reqs (\"avx\");\n+  else if (feature == \"pclmulqdq\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sha\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sse2\")\n+    enable_implicit_feature_reqs (\"sse\");\n+  else if (feature == \"sse3\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sse4.1\")\n+    enable_implicit_feature_reqs (\"sse3\");\n+  else if (feature == \"sse4.2\")\n+    enable_implicit_feature_reqs (\"sse4.1\");\n+  else if (feature == \"ssse3\")\n+    enable_implicit_feature_reqs (\"sse3\");\n+\n+  if (!has_key_value_pair (\"target_feature\", feature))\n+    {\n+      insert_key_value_pair (\"target_feature\", feature);\n+\n+      fprintf (stderr, \"had to implicitly enable feature '%s'!\",\n+\t       feature.c_str ());\n     }\n-  }\n+}\n \n // NOTEs:\n /* mrustc compile pipeline:"}]}