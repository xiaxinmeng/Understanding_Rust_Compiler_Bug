{"sha": "570094e524d9b9205eefc42ab3cbffa52b9653c7", "node_id": "C_kwDOANBUbNoAKDU3MDA5NGU1MjRkOWI5MjA1ZWVmYzQyYWIzY2JmZmE1MmI5NjUzYzc", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-02-10T14:44:47Z"}, "committer": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-03-30T11:52:28Z"}, "message": "libproc_macro: Move some types to their own module\n\nThe file for the rust interfaces became quite long and we could\ntherefore split it in multiple module and reexport their symbol at the\nroot level. This way the code is shorter and well separated whilst\nkeeping the exact same interface as the libproc_macro from rustc.\n\nChangeLog:\n\n\t* librust/proc_macro/rust/lib.rs: Remove somes types.\n\t* librust/proc_macro/rust/ident.rs: Add Ident type to it's own\n\tmodule.\n\t* librust/proc_macro/rust/literal.rs: Add Literal type to it's\n\town module.\n\t* librust/proc_macro/rust/span.rs: Add Span type to it's own\n\tmodule.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "9680c8528e70dc0a8524b1234affd763c20e9047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9680c8528e70dc0a8524b1234affd763c20e9047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/570094e524d9b9205eefc42ab3cbffa52b9653c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570094e524d9b9205eefc42ab3cbffa52b9653c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/570094e524d9b9205eefc42ab3cbffa52b9653c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/570094e524d9b9205eefc42ab3cbffa52b9653c7/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b42b30da3e3c40542a5991fe5123bb3b50b73255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b42b30da3e3c40542a5991fe5123bb3b50b73255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b42b30da3e3c40542a5991fe5123bb3b50b73255"}], "stats": {"total": 511, "additions": 262, "deletions": 249}, "files": [{"sha": "f9bf814676247decffaaf47b4087f112806740b3", "filename": "librust/proc_macro/rust/ident.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Fident.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Fident.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fident.rs?ref=570094e524d9b9205eefc42ab3cbffa52b9653c7", "patch": "@@ -0,0 +1,43 @@\n+use std::fmt;\n+use Span;\n+\n+#[derive(Clone)]\n+pub struct Ident {\n+    // Internal implementation details\n+}\n+\n+impl Ident {\n+    /// Creates a new identifier from a string and a span\n+    pub fn new(_string: &str, _span: Span) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// Creates a raw new identifier from a string and a span\n+    pub fn new_raw(_string: &str, _span: Span) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// Return the span of the identifier\n+    pub fn span(&self) -> Span {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// change the span of the identifier\n+    pub fn set_span(&mut self, _span: Span) {\n+        todo!(\"Implement this function\")\n+    }\n+}\n+\n+impl fmt::Display for Ident {\n+    /// Display as lossless converted string\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!(\"Implement this function\")\n+    }\n+}\n+\n+impl fmt::Debug for Ident {\n+    /// display debug friendly version of the Identifier\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!(\"Implement this function\")\n+    }\n+}"}, {"sha": "8e7e077f5914c952691b7e169d3078b441077b48", "filename": "librust/proc_macro/rust/lib.rs", "status": "modified", "additions": 8, "deletions": 249, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Flib.rs?ref=570094e524d9b9205eefc42ab3cbffa52b9653c7", "patch": "@@ -1,6 +1,12 @@\n+pub use ident::Ident;\n+pub use literal::Literal;\n+pub use span::Span;\n use std::error;\n use std::fmt;\n-use std::str::FromStr;\n+\n+mod ident;\n+mod literal;\n+mod span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Delimiter {\n@@ -11,264 +17,17 @@ pub enum Delimiter {\n     None,\n }\n \n-#[derive(Copy, Clone)]\n-pub struct Span {\n-    // Internal implementation details\n-}\n-\n-impl Span {\n-    // TODO: Add experimental API functions for this type\n-\n-    /// Creates a new span that resolves at the macro call location\n-    pub fn call_site() -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// Creates a new span that resolved sometimes at macro call site, and\n-    /// sometimes at macro definition site\n-    pub fn mixed_site() -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// Creates a new span with the same line/column informations but that\n-    /// resolve symbols as though it were at `other`\n-    pub fn resolved_at(&self, other: Span) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// Creates a new span with the same name resolution behavior as self, but\n-    /// with the line/column information of `other`.\n-    pub fn located_at(&self, other: Span) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// Return the source text behind a span.\n-    pub fn source_text(&self) -> Option<String> {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct Ident {\n-    // Internal implementation details\n-}\n-\n-impl Ident {\n-    /// Creates a new identifier from a string and a span\n-    pub fn new(string: &str, span: Span) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// Creates a raw new identifier from a string and a span\n-    pub fn new_raw(string: &str, span: Span) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// Return the span of the identifier\n-    pub fn span(&self) -> Span {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    /// change the span of the identifier\n-    pub fn set_span(&mut self, span: Span) {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n-impl fmt::Display for Ident {\n-    /// Display as lossless converted string\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    /// display debug friendly version of the Identifier\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct LexError;\n \n impl fmt::Display for LexError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         todo!(\"Implement this function\")\n     }\n }\n \n impl error::Error for LexError {}\n \n-#[derive(Clone)]\n-pub struct Literal {\n-    // Internal implementation details\n-}\n-\n-impl Literal {\n-    // TODO: Add experimental API functions for this type\n-\n-    pub fn u8_suffixed(n: u8) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u16_suffixed(n: u16) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u32_suffixed(n: u32) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u64_suffixed(n: u64) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u128_suffixed(n: u128) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn usize_suffixed(n: usize) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i8_suffixed(n: i8) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i16_suffixed(n: i16) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i32_suffixed(n: i32) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i64_suffixed(n: i64) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i128_suffixed(n: i128) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn isize_suffixed(n: isize) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    // Unsuffixed\n-\n-    pub fn u8_unsuffixed(n: u8) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u16_unsuffixed(n: u16) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u32_unsuffixed(n: u32) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u64_unsuffixed(n: u64) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn u128_unsuffixed(n: u128) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn usize_unsuffixed(n: usize) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i8_unsuffixed(n: i8) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i16_unsuffixed(n: i16) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i32_unsuffixed(n: i32) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i64_unsuffixed(n: i64) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn i128_unsuffixed(n: i128) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn isize_unsuffixed(n: isize) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn f32_unsuffixed(n: f32) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn f32_suffixed(n: f32) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn f64_unsuffixed(n: f64) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn f64_suffixed(n: f64) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn string(string: &str) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn character(c: char) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn byte_string(bytes: &[u8]) -> Self {\n-        todo!(\"Implement this function\")\n-    }\n-\n-    pub fn span(&self) -> Span {\n-        todo!(\"Get the span of a literal\")\n-    }\n-\n-    pub fn set_span(&mut self, span: Span) {\n-        todo!(\"Set the span of a literal\")\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n-impl fmt::Display for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n-impl FromStr for Literal {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<Self, LexError> {\n-        todo!(\"Implement this function\")\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Spacing {\n     Alone,"}, {"sha": "515c7d2737a6a034254ab6b08af5d9fae10aad76", "filename": "librust/proc_macro/rust/literal.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Fliteral.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Fliteral.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fliteral.rs?ref=570094e524d9b9205eefc42ab3cbffa52b9653c7", "patch": "@@ -0,0 +1,167 @@\n+use std::fmt;\n+use std::str::FromStr;\n+use LexError;\n+use Span;\n+\n+#[derive(Clone)]\n+pub struct Literal {\n+    // Internal implementation details\n+}\n+\n+impl Literal {\n+    // TODO: Add experimental API functions for this type\n+\n+    pub fn u8_suffixed(_n: u8) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u16_suffixed(_n: u16) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u32_suffixed(_n: u32) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u64_suffixed(_n: u64) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u128_suffixed(_n: u128) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn usize_suffixed(_n: usize) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i8_suffixed(_n: i8) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i16_suffixed(_n: i16) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i32_suffixed(_n: i32) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i64_suffixed(_n: i64) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i128_suffixed(_n: i128) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn isize_suffixed(_n: isize) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    // Unsuffixed\n+\n+    pub fn u8_unsuffixed(_n: u8) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u16_unsuffixed(_n: u16) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u32_unsuffixed(_n: u32) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u64_unsuffixed(_n: u64) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn u128_unsuffixed(_n: u128) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn usize_unsuffixed(_n: usize) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i8_unsuffixed(_n: i8) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i16_unsuffixed(_n: i16) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i32_unsuffixed(_n: i32) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i64_unsuffixed(_n: i64) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn i128_unsuffixed(_n: i128) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn isize_unsuffixed(_n: isize) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn f32_unsuffixed(_n: f32) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn f32_suffixed(_n: f32) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn f64_unsuffixed(_n: f64) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn f64_suffixed(_n: f64) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn string(_string: &str) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn character(_c: char) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn byte_string(_bytes: &[u8]) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    pub fn span(&self) -> Span {\n+        todo!(\"Get the span of a literal\")\n+    }\n+\n+    pub fn set_span(&mut self, _span: Span) {\n+        todo!(\"Set the span of a literal\")\n+    }\n+}\n+\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!(\"Implement this function\")\n+    }\n+}\n+\n+impl fmt::Display for Literal {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!(\"Implement this function\")\n+    }\n+}\n+\n+impl FromStr for Literal {\n+    type Err = LexError;\n+\n+    fn from_str(_src: &str) -> Result<Self, LexError> {\n+        todo!(\"Implement this function\")\n+    }\n+}"}, {"sha": "646e35c356a7a52ec1619cdc7f2fff3421b4153b", "filename": "librust/proc_macro/rust/span.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Fspan.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/570094e524d9b9205eefc42ab3cbffa52b9653c7/librust%2Fproc_macro%2Frust%2Fspan.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fspan.rs?ref=570094e524d9b9205eefc42ab3cbffa52b9653c7", "patch": "@@ -0,0 +1,44 @@\n+use std::fmt;\n+\n+#[derive(Copy, Clone)]\n+pub struct Span {\n+    // Internal implementation details\n+}\n+\n+impl Span {\n+    // TODO: Add experimental API functions for this type\n+\n+    /// Creates a new span that resolves at the macro call location\n+    pub fn call_site() -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// Creates a new span that resolved sometimes at macro call site, and\n+    /// sometimes at macro definition site\n+    pub fn mixed_site() -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// Creates a new span with the same line/column informations but that\n+    /// resolve symbols as though it were at `other`\n+    pub fn resolved_at(&self, _other: Span) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// Creates a new span with the same name resolution behavior as self, but\n+    /// with the line/column information of `other`.\n+    pub fn located_at(&self, _other: Span) -> Self {\n+        todo!(\"Implement this function\")\n+    }\n+\n+    /// Return the source text behind a span.\n+    pub fn source_text(&self) -> Option<String> {\n+        todo!(\"Implement this function\")\n+    }\n+}\n+\n+impl fmt::Debug for Span {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        todo!(\"Implement this function\")\n+    }\n+}"}]}