{"sha": "0b99f25372431148e637b98f02e7cbe03feef7f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI5OWYyNTM3MjQzMTE0OGU2MzdiOThmMDJlN2NiZTAzZmVlZjdmOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-15T09:01:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-15T09:01:42Z"}, "message": "re PR target/82981 (unnecessary __multi3 call for mips64r6 linux kernel)\n\n\tPR target/82981\n\t* internal-fn.c: Include gimple-ssa.h, tree-phinodes.h and\n\tssa-iterators.h.\n\t(can_widen_mult_without_libcall): New function.\n\t(expand_mul_overflow): If only checking unsigned mul overflow,\n\tnot result, and can do efficiently MULT_HIGHPART_EXPR, emit that.\n\tDon't use WIDEN_MULT_EXPR if it would involve a libcall, unless\n\tno other way works.  Add MULT_HIGHPART_EXPR + MULT_EXPR support.\n\t(expand_DIVMOD): Formatting fix.\n\t* expmed.h (expand_mult): Add NO_LIBCALL argument.\n\t* expmed.c (expand_mult): Likewise.  Use OPTAB_WIDEN rather\n\tthan OPTAB_LIB_WIDEN if NO_LIBCALL is true, and allow it to fail.\n\n\t* gcc.target/mips/pr82981.c: New test.\n\nFrom-SVN: r254758", "tree": {"sha": "63d30374d3cf9bdc2b71e04db9d013a8c15c009c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63d30374d3cf9bdc2b71e04db9d013a8c15c009c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b99f25372431148e637b98f02e7cbe03feef7f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b99f25372431148e637b98f02e7cbe03feef7f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b99f25372431148e637b98f02e7cbe03feef7f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b99f25372431148e637b98f02e7cbe03feef7f9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65205a116a8d1c076f0709d92acad2453caa1efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65205a116a8d1c076f0709d92acad2453caa1efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65205a116a8d1c076f0709d92acad2453caa1efb"}], "stats": {"total": 133, "additions": 126, "deletions": 7}, "files": [{"sha": "277c5578707dba6b745a223f54ec53545d841a10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b99f25372431148e637b98f02e7cbe03feef7f9", "patch": "@@ -1,5 +1,18 @@\n 2017-11-15  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/82981\n+\t* internal-fn.c: Include gimple-ssa.h, tree-phinodes.h and\n+\tssa-iterators.h.\n+\t(can_widen_mult_without_libcall): New function.\n+\t(expand_mul_overflow): If only checking unsigned mul overflow,\n+\tnot result, and can do efficiently MULT_HIGHPART_EXPR, emit that.\n+\tDon't use WIDEN_MULT_EXPR if it would involve a libcall, unless\n+\tno other way works.  Add MULT_HIGHPART_EXPR + MULT_EXPR support.\n+\t(expand_DIVMOD): Formatting fix.\n+\t* expmed.h (expand_mult): Add NO_LIBCALL argument.\n+\t* expmed.c (expand_mult): Likewise.  Use OPTAB_WIDEN rather\n+\tthan OPTAB_LIB_WIDEN if NO_LIBCALL is true, and allow it to fail.\n+\n \tPR tree-optimization/82977\n \t* tree-ssa-strlen.c (strlen_optimize_stmt): Pass a reference to a copy\n \tconstructed temporary to strlen_to_stridx.put."}, {"sha": "dacb2b9771ae45d0a17162777138b404f48be8ca", "filename": "gcc/expmed.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0b99f25372431148e637b98f02e7cbe03feef7f9", "patch": "@@ -3284,7 +3284,7 @@ expand_mult_const (machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \n rtx\n expand_mult (machine_mode mode, rtx op0, rtx op1, rtx target,\n-\t     int unsignedp)\n+\t     int unsignedp, bool no_libcall)\n {\n   enum mult_variant variant;\n   struct algorithm algorithm;\n@@ -3420,14 +3420,16 @@ expand_mult (machine_mode mode, rtx op0, rtx op1, rtx target,\n     {\n       op0 = force_reg (GET_MODE (op0), op0);\n       return expand_binop (mode, add_optab, op0, op0,\n-\t\t\t   target, unsignedp, OPTAB_LIB_WIDEN);\n+\t\t\t   target, unsignedp,\n+\t\t\t   no_libcall ? OPTAB_WIDEN : OPTAB_LIB_WIDEN);\n     }\n \n   /* This used to use umul_optab if unsigned, but for non-widening multiply\n      there is no difference between signed and unsigned.  */\n   op0 = expand_binop (mode, do_trapv ? smulv_optab : smul_optab,\n-\t\t      op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);\n-  gcc_assert (op0);\n+\t\t      op0, op1, target, unsignedp,\n+\t\t      no_libcall ? OPTAB_WIDEN : OPTAB_LIB_WIDEN);\n+  gcc_assert (op0 || no_libcall);\n   return op0;\n }\n "}, {"sha": "6b57ec634d56fb54c5445a1c1e050020dec7bc2f", "filename": "gcc/expmed.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=0b99f25372431148e637b98f02e7cbe03feef7f9", "patch": "@@ -727,7 +727,7 @@ extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n \t\t\t      machine_mode, machine_mode, bool, rtx *);\n extern rtx extract_low_bits (machine_mode, machine_mode, rtx);\n-extern rtx expand_mult (machine_mode, rtx, rtx, rtx, int);\n+extern rtx expand_mult (machine_mode, rtx, rtx, rtx, int, bool = false);\n extern rtx expand_mult_highpart_adjust (scalar_int_mode, rtx, rtx, rtx,\n \t\t\t\t\trtx, int);\n "}, {"sha": "1c00792fec79323ddc456bd7d9e75efd0aa2dfe4", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0b99f25372431148e637b98f02e7cbe03feef7f9", "patch": "@@ -46,6 +46,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"builtins.h\"\n #include \"optabs-tree.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-phinodes.h\"\n+#include \"ssa-iterators.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -1172,6 +1175,35 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n     }\n }\n \n+/* Return true if UNS WIDEN_MULT_EXPR with result mode WMODE and operand\n+   mode MODE can be expanded without using a libcall.  */\n+\n+static bool\n+can_widen_mult_without_libcall (scalar_int_mode wmode, scalar_int_mode mode,\n+\t\t\t\trtx op0, rtx op1, bool uns)\n+{\n+  if (find_widening_optab_handler (umul_widen_optab, wmode, mode)\n+      != CODE_FOR_nothing)\n+    return true;\n+    \n+  if (find_widening_optab_handler (smul_widen_optab, wmode, mode)\n+      != CODE_FOR_nothing)\n+    return true;\n+\n+  rtx_insn *last = get_last_insn ();\n+  if (CONSTANT_P (op0))\n+    op0 = convert_modes (wmode, mode, op0, uns);\n+  else\n+    op0 = gen_raw_REG (wmode, LAST_VIRTUAL_REGISTER + 1);\n+  if (CONSTANT_P (op1))\n+    op1 = convert_modes (wmode, mode, op1, uns);\n+  else\n+    op1 = gen_raw_REG (wmode, LAST_VIRTUAL_REGISTER + 2);\n+  rtx ret = expand_mult (wmode, op0, op1, NULL_RTX, uns, true);\n+  delete_insns_since (last);\n+  return ret != NULL_RTX;\n+} \n+\n /* Add mul overflow checking to the statement STMT.  */\n \n static void\n@@ -1465,9 +1497,29 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       ops.op1 = make_tree (type, op1);\n       ops.op2 = NULL_TREE;\n       ops.location = loc;\n+\n+      /* Optimize unsigned overflow check where we don't use the\n+\t multiplication result, just whether overflow happened.\n+\t If we can do MULT_HIGHPART_EXPR, that followed by\n+\t comparison of the result against zero is cheapest.\n+\t We'll still compute res, but it should be DCEd later.  */\n+      use_operand_p use;\n+      gimple *use_stmt;\n+      if (!is_ubsan\n+\t  && lhs\n+\t  && uns\n+\t  && !(uns0_p && uns1_p && !unsr_p)\n+\t  && can_mult_highpart_p (mode, uns) == 1\n+\t  && single_imm_use (lhs, &use, &use_stmt)\n+\t  && is_gimple_assign (use_stmt)\n+\t  && gimple_assign_rhs_code (use_stmt) == IMAGPART_EXPR)\n+\tgoto highpart;\n+\n       if (GET_MODE_2XWIDER_MODE (mode).exists (&wmode)\n-\t  && targetm.scalar_mode_supported_p (wmode))\n+\t  && targetm.scalar_mode_supported_p (wmode)\n+\t  && can_widen_mult_without_libcall (wmode, mode, op0, op1, uns))\n \t{\n+\ttwoxwider:\n \t  ops.code = WIDEN_MULT_EXPR;\n \t  ops.type\n \t    = build_nonstandard_integer_type (GET_MODE_PRECISION (wmode), uns);\n@@ -1495,6 +1547,35 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t       profile_probability::very_likely ());\n \t    }\n \t}\n+      else if (can_mult_highpart_p (mode, uns) == 1)\n+\t{\n+\thighpart:\n+\t  ops.code = MULT_HIGHPART_EXPR;\n+\t  ops.type = type;\n+\n+\t  rtx hipart = expand_expr_real_2 (&ops, NULL_RTX, mode,\n+\t\t\t\t\t   EXPAND_NORMAL);\n+\t  ops.code = MULT_EXPR;\n+\t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  if (uns)\n+\t    /* For the unsigned multiplication, there was overflow if\n+\t       HIPART is non-zero.  */\n+\t    do_compare_rtx_and_jump (hipart, const0_rtx, EQ, true, mode,\n+\t\t\t\t     NULL_RTX, NULL, done_label,\n+\t\t\t\t     profile_probability::very_likely ());\n+\t  else\n+\t    {\n+\t      rtx signbit = expand_shift (RSHIFT_EXPR, mode, res, prec - 1,\n+\t\t\t\t\t  NULL_RTX, 0);\n+\t      /* RES is low half of the double width result, HIPART\n+\t\t the high half.  There was overflow if\n+\t\t HIPART is different from RES < 0 ? -1 : 0.  */\n+\t      do_compare_rtx_and_jump (signbit, hipart, EQ, true, mode,\n+\t\t\t\t       NULL_RTX, NULL, done_label,\n+\t\t\t\t       profile_probability::very_likely ());\n+\t    }\n+\t  \n+\t}\n       else if (int_mode_for_size (prec / 2, 1).exists (&hmode)\n \t       && 2 * GET_MODE_PRECISION (hmode) == prec)\n \t{\n@@ -1800,6 +1881,11 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  tem = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t  emit_move_insn (res, tem);\n \t}\n+      else if (GET_MODE_2XWIDER_MODE (mode).exists (&wmode)\n+\t       && targetm.scalar_mode_supported_p (wmode))\n+\t/* Even emitting a libcall is better than not detecting overflow\n+\t   at all.  */\n+\tgoto twoxwider;\n       else\n \t{\n \t  gcc_assert (!is_ubsan);\n@@ -2588,7 +2674,7 @@ expand_DIVMOD (internal_fn, gcall *call_stmt)\n   expand_expr (build2 (COMPLEX_EXPR, TREE_TYPE (lhs),\n \t\t       make_tree (TREE_TYPE (arg0), quotient),\n \t\t       make_tree (TREE_TYPE (arg1), remainder)),\n-\t      target, VOIDmode, EXPAND_NORMAL);\n+\t       target, VOIDmode, EXPAND_NORMAL);\n }\n \n /* Expand a call to FN using the operands in STMT.  FN has a single"}, {"sha": "e006115e8fc7557fd42704e8a4f1d03bfedff491", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b99f25372431148e637b98f02e7cbe03feef7f9", "patch": "@@ -1,3 +1,8 @@\n+2017-11-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/82981\n+\t* gcc.target/mips/pr82981.c: New test.\n+\n 2017-11-15  Martin Liska  <mliska@suse.cz>\n \n \t* g++.dg/ubsan/vptr-12.C: New test."}, {"sha": "677e4cc01e9f2de746f5b47c081db17b48deb5fc", "filename": "gcc/testsuite/gcc.target/mips/pr82981.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr82981.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b99f25372431148e637b98f02e7cbe03feef7f9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr82981.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fpr82981.c?ref=0b99f25372431148e637b98f02e7cbe03feef7f9", "patch": "@@ -0,0 +1,13 @@\n+/* PR target/82981 */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O2\" } } */\n+/* { dg-options \"-march=mips64r6 -mabi=64 -mexplicit-relocs\" } */\n+\n+unsigned long\n+func (unsigned long a, unsigned long b)\n+{\n+  return a > (~0UL) / b;\n+}\n+\n+/* { dg-final { scan-assembler-not \"__multi3\" } } */\n+/* { dg-final { scan-assembler \"\\tdmuhu\" } } */"}]}