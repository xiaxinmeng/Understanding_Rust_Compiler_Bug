{"sha": "8637c116c5683c55157faae65db93c3ebf973cab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYzN2MxMTZjNTY4M2M1NTE1N2ZhYWU2NWRiOTNjM2ViZjk3M2NhYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-05-07T15:10:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-05-07T15:10:55Z"}, "message": "revert: re PR tree-optimization/78496 (Missed opportunities for jump threading)\n\n2017-05-07  Jeff Law  <law@redhat.com>\n\n\tRevert:\n\t2017-05-06  Jeff Law  <law@redhat.com>\n\tPR tree-optimization/78496\n\t* tree-vrp.c (simplify_assert_expr_using_ranges): Remove debugging\n\tcode.\n\n\tPR tree-optimization/78496\n\t* tree-vrp.c (simplify_assert_expr_using_ranges): New function.\n\t(simplify_stmt_using_ranges): Call it.\n\t(vrp_dom_walker::before_dom_children): Extract equivalences\n\tfrom an ASSERT_EXPR with an equality comparison against a\n\tconstant.\n\n\tRevert:\n\t2017-05-06  Jeff Law  <law@redhat.com>\n\tPR tree-optimization/78496\n\t* gcc.dg/tree-ssa/ssa-thread-16.c: New test.\n\t* gcc.dg/tree-ssa/ssa-thread-17.c: New test.\n\nFrom-SVN: r247727", "tree": {"sha": "1607907c7ebee729b63c3e46bcaa83a4ea9c1b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1607907c7ebee729b63c3e46bcaa83a4ea9c1b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8637c116c5683c55157faae65db93c3ebf973cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8637c116c5683c55157faae65db93c3ebf973cab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8637c116c5683c55157faae65db93c3ebf973cab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8637c116c5683c55157faae65db93c3ebf973cab/comments", "author": null, "committer": null, "parents": [{"sha": "9267267a3d54fee843f2610caf426265783be1b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9267267a3d54fee843f2610caf426265783be1b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9267267a3d54fee843f2610caf426265783be1b8"}], "stats": {"total": 151, "additions": 26, "deletions": 125}, "files": [{"sha": "4adb9a83f0a0f806dcf0c804d59dbc83466f8c7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8637c116c5683c55157faae65db93c3ebf973cab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8637c116c5683c55157faae65db93c3ebf973cab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8637c116c5683c55157faae65db93c3ebf973cab", "patch": "@@ -1,3 +1,18 @@\n+2017-05-07  Jeff Law  <law@redhat.com>\n+\n+\tRevert:\n+\t2017-05-06  Jeff Law  <law@redhat.com>\n+\tPR tree-optimization/78496\n+\t* tree-vrp.c (simplify_assert_expr_using_ranges): Remove debugging\n+\tcode.\n+\n+\tPR tree-optimization/78496\n+\t* tree-vrp.c (simplify_assert_expr_using_ranges): New function.\n+\t(simplify_stmt_using_ranges): Call it.\n+\t(vrp_dom_walker::before_dom_children): Extract equivalences\n+\tfrom an ASSERT_EXPR with an equality comparison against a\n+\tconstant.\n+\n 2017-05-06  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/78496"}, {"sha": "df971bd475076411dc79926c1dd4938ca99b1672", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8637c116c5683c55157faae65db93c3ebf973cab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8637c116c5683c55157faae65db93c3ebf973cab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8637c116c5683c55157faae65db93c3ebf973cab", "patch": "@@ -1,3 +1,11 @@\n+2017-05-07  Jeff Law  <law@redhat.com>\n+\n+\tRevert:\n+\t2017-05-06  Jeff Law  <law@redhat.com>\n+\tPR tree-optimization/78496\n+\t* gcc.dg/tree-ssa/ssa-thread-16.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-thread-17.c: New test.\n+\n 2017-05-06  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/78496"}, {"sha": "78c349ca14d99ee9648c988aa376727c74fa15c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-16.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9267267a3d54fee843f2610caf426265783be1b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9267267a3d54fee843f2610caf426265783be1b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-16.c?ref=9267267a3d54fee843f2610caf426265783be1b8", "patch": "@@ -1,38 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n-\n-/* We should thread the if (exp == 2) conditional on the\n-   the path from inside the if (x) THEN arm.  It is the only\n-   jump threading opportunity in this code.  */\n-   \n-/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"vrp1\" } } */\n-\n-\n-extern void abort (void) __attribute__ ((__nothrow__, __leaf__))\n-  __attribute__ ((__noreturn__));\n-\n-int x;\n-\n-\n-int code;\n-void\n-do_jump (int exp)\n-{\n-  switch (code)\n-    {\n-    case 4:\n-      if ((exp) == 1)\n-\tgoto normal;\n-      if (x)\n-\t{\n-\t  if (exp != 0)\n-\t    abort ();\n-\t}\n-      if ((exp) == 2)\n-\tgoto normal;\n-    case 3:\n-\tabort ();\n-    }\n-  normal:\n-      ;\n-}"}, {"sha": "692658fbb4b4445d0022bd2c82a9d332c8b4f4c9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-17.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9267267a3d54fee843f2610caf426265783be1b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9267267a3d54fee843f2610caf426265783be1b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-17.c?ref=9267267a3d54fee843f2610caf426265783be1b8", "patch": "@@ -1,36 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-vrp1-details\" } */\n-\n-/* We should simplify one ASSERT_EXPR from a relational\n-   into an equality test.  */\n-/* { dg-final { scan-tree-dump-times \"Folded into:\\[^\\r\\n\\]*ASSERT_EXPR\\*\\[^\\r\\n\\]* == 1\" 1 \"vrp1\" } } */\n-\n-/* And simplification of the ASSERT_EXPR leads to a jump threading opportunity.  */\n-/* { dg-final { scan-tree-dump-times \"Threaded\" 1 \"vrp1\" } } */\n-\n-extern void abort (void) __attribute__ ((__nothrow__, __leaf__))\n-  __attribute__ ((__noreturn__));\n-\n-union gimple_statement_d;\n-typedef union gimple_statement_d *gimple;\n-\n-\n-\n-union gimple_statement_d\n-{\n-  unsigned num_ops;\n-};\n-\n-void\n-gimple_assign_set_rhs_with_ops_1 (int code, gimple stmt, unsigned new_rhs_ops)\n-{\n-\n-  stmt->num_ops = new_rhs_ops + 1;\n-  if (stmt->num_ops <= 1)\n-    abort ();\n-  if (new_rhs_ops > 1)\n-    if (stmt->num_ops <= 2)\n-      abort ();\n-  if (new_rhs_ops > 2)\n-      abort ();\n-}"}, {"sha": "cf50e908257c00bd9ecd5f1274cdaf5fa0896949", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8637c116c5683c55157faae65db93c3ebf973cab/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8637c116c5683c55157faae65db93c3ebf973cab/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8637c116c5683c55157faae65db93c3ebf973cab", "patch": "@@ -9600,42 +9600,6 @@ range_fits_type_p (value_range *vr, unsigned dest_precision, signop dest_sgn)\n   return true;\n }\n \n-/* Simplify STMT, an ASSERT_EXPR, using ranges.  This is helpful because jump\n-   threading looks at the ASSERT_EXPRs.  Collapsing the condition of\n-   an ASSERT_EXPR from a relational to an equality test is where most\n-   of the benefit occurrs, so that's the only thing we currently do.  */\n-\n-static bool\n-simplify_assert_expr_using_ranges (gimple *stmt)\n-{\n-  tree cond = TREE_OPERAND (gimple_assign_rhs1 (stmt), 1);\n-  tree_code code = TREE_CODE (cond);\n-  tree op0 = TREE_OPERAND (cond, 0);\n-\n-  /* The condition of the ASSERT_EXPR must be a simple relational\n-     between an SSA_NAME (with a range) and a constant.  */\n-  if (TREE_CODE (op0) != SSA_NAME\n-      || !INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n-    return false;\n-\n-  tree op1 = TREE_OPERAND (cond, 1);\n-  if (TREE_CODE (op1) != INTEGER_CST)\n-    return false;\n-\n-  value_range *vr = get_value_range (op0);\n-  if (!vr || vr->type != VR_RANGE)\n-    return false;\n-\n-  tree res = test_for_singularity (code, op0, op1, vr);\n-  if (res)\n-    {\n-      TREE_SET_CODE (cond, EQ_EXPR);\n-      TREE_OPERAND (cond, 1) = res;\n-      return true;\n-    }\n-  return false;\n-}\n-\n /* Simplify a conditional using a relational operator to an equality\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n@@ -10370,9 +10334,6 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n \tcase MAX_EXPR:\n \t  return simplify_min_or_max_using_ranges (gsi, stmt);\n \n-\tcase ASSERT_EXPR:\n-\t  return simplify_assert_expr_using_ranges (stmt);\n-\n \tdefault:\n \t  break;\n \t}\n@@ -10637,25 +10598,16 @@ vrp_dom_walker::before_dom_children (basic_block bb)\n \t{\n \t  tree rhs1 = gimple_assign_rhs1 (stmt);\n \t  tree cond = TREE_OPERAND (rhs1, 1);\n-\t  tree lhs = gimple_assign_lhs (stmt);\n-\t  m_const_and_copies->record_const_or_copy (lhs, TREE_OPERAND (rhs1, 0));\n-\n-\t  if (TREE_CODE (cond) == EQ_EXPR)\n-\t    {\n-\t      tree cond_op0 = TREE_OPERAND (cond, 0);\n-\t      tree cond_op1 = TREE_OPERAND (cond, 1);\n-\t      if (TREE_CODE (cond_op0) == SSA_NAME)\n-\t\tm_const_and_copies->record_const_or_copy (cond_op0, cond_op1);\n-\t      continue;\n-\t    }\n-\n \t  tree inverted = invert_truthvalue (cond);\n \t  vec<cond_equivalence> p;\n \t  p.create (3);\n \t  record_conditions (&p, cond, inverted);\n \t  for (unsigned int i = 0; i < p.length (); i++)\n \t    m_avail_exprs_stack->record_cond (&p[i]);\n \n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  m_const_and_copies->record_const_or_copy (lhs,\n+\t\t\t\t\t\t    TREE_OPERAND (rhs1, 0));\n \t  p.release ();\n \t  continue;\n \t}"}]}