{"sha": "5d5c854105ab9b3ad4600e280eab5499cb560831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1Yzg1NDEwNWFiOWIzYWQ0NjAwZTI4MGVhYjU0OTljYjU2MDgzMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-03T22:55:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-03T22:55:32Z"}, "message": "pa.md (call expanders): Emit different patterns for named calls and indirect calls.\n\n\t* pa.md (call expanders): Emit different patterns for named calls\n\tand indirect calls.\n\t(call_internal_symref, call_internal_reg): New patterns.\n\t(call_internal): Deleted.  Now handled by call_interal_{symref,reg}.\n\t(call_value_internal_symref, call_value_internal_reg): New patterns.\n\t(call_value_internal): Deleted.  Now handled by\n\tcall_value_internal_{symref,reg).\n\nFrom-SVN: r4837", "tree": {"sha": "48e2cc21fd4bfe91be4d99dc3364a810fa3bcd78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e2cc21fd4bfe91be4d99dc3364a810fa3bcd78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5c854105ab9b3ad4600e280eab5499cb560831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5c854105ab9b3ad4600e280eab5499cb560831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5c854105ab9b3ad4600e280eab5499cb560831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5c854105ab9b3ad4600e280eab5499cb560831/comments", "author": null, "committer": null, "parents": [{"sha": "9c9a6f426c6c2293514d1feeaa611ca97311d7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c9a6f426c6c2293514d1feeaa611ca97311d7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c9a6f426c6c2293514d1feeaa611ca97311d7e1"}], "stats": {"total": 93, "additions": 64, "deletions": 29}, "files": [{"sha": "5461f257881ecb165849137fb49b86834e7d06ec", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 64, "deletions": 29, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5c854105ab9b3ad4600e280eab5499cb560831/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5c854105ab9b3ad4600e280eab5499cb560831/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=5d5c854105ab9b3ad4600e280eab5499cb560831", "patch": "@@ -2754,7 +2754,17 @@\n     op = force_reg (SImode, XEXP (operands[0], 0));\n   else\n     op = XEXP (operands[0], 0);\n-  emit_call_insn (gen_call_internal (op, operands[1]));\n+\n+  /* Use two different patterns for calls to explicitly named functions\n+     and calls through function pointers.  This is necessary as these two\n+     types of calls use different calling conventions, and CSE might try\n+     to change the named call into an indirect call in some cases (using\n+     two patterns keeps CSE from performing this optimization).  */\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    emit_call_insn (gen_call_internal_symref (op, operands[1]));\n+  else\n+    emit_call_insn (gen_call_internal_reg (op, operands[1]));\n+\n   if (flag_pic)\n     {\n       if (!hppa_save_pic_table_rtx)\n@@ -2765,23 +2775,29 @@\n   DONE;\n }\")\n \n-(define_insn \"call_internal\"\n- [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"r,S\"))\n-\t(match_operand 1 \"\" \"i,i\"))\n-  (clobber (reg:SI 2))]\n+(define_insn \"call_internal_symref\"\n+ [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"\"))\n+\t(match_operand 1 \"\" \"i\"))\n+  (clobber (reg:SI 2))\n+  (use (const_int 0))]\n  \"\"\n  \"*\n {\n-  if (which_alternative == 0)\n-    return \\\"copy %0,22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,31\\;copy 31,2\\\";\n-  else\n-    {\n-      output_arg_descriptor (insn);\n-      return \\\"bl %0,2%#\\\";\n-    }\n+  output_arg_descriptor (insn);\n+  return \\\"bl %0,2%#\\\";\n }\"\n- [(set_attr \"type\" \"dyncall,call\")\n-  (set_attr \"length\" \"3,1\")])\n+ [(set_attr \"type\" \"call\")\n+  (set_attr \"length\" \"1\")])\n+\n+(define_insn \"call_internal_reg\"\n+ [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(match_operand 1 \"\" \"i\"))\n+  (clobber (reg:SI 2))\n+  (use (const_int 1))]\n+ \"\"\n+ \"copy %0,22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,31\\;copy 31,2\"\n+ [(set_attr \"type\" \"dyncall\")\n+  (set_attr \"length\" \"3\")])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -2798,7 +2814,18 @@\n     op = force_reg (SImode, XEXP (operands[1], 0));\n   else\n     op = XEXP (operands[1], 0);\n-  emit_call_insn (gen_call_value_internal (operands[0], op, operands[2]));\n+\n+  /* Use two different patterns for calls to explicitly named functions\n+     and calls through function pointers.  This is necessary as these two\n+     types of calls use different calling conventions, and CSE might try\n+     to change the named call into an indirect call in some cases (using\n+     two patterns keeps CSE from performing this optimization).  */\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    emit_call_insn (gen_call_value_internal_symref (operands[0], op,\n+\t\t\t\t\t\t    operands[2]));\n+  else\n+    emit_call_insn (gen_call_value_internal_reg (operands[0], op, operands[2]));\n+\n   if (flag_pic)\n     {\n       if (!hppa_save_pic_table_rtx)\n@@ -2809,25 +2836,33 @@\n   DONE;\n }\")\n \n-(define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"\" \"=rfx,rfx\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_operand_address\" \"r,S\"))\n-\t      (match_operand 2 \"\" \"i,i\")))\n-   (clobber (reg:SI 2))]\n+(define_insn \"call_value_internal_symref\"\n+  [(set (match_operand 0 \"\" \"=rfx\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 2))\n+   (use (const_int 0))]\n   ;;- Don't use operand 1 for most machines.\n   \"\"\n   \"*\n {\n-  if (which_alternative == 0)\n-    return \\\"copy %1,22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,31\\;copy 31,2\\\";\n-  else\n-    {\n-      output_arg_descriptor (insn);\n-      return \\\"bl %1,2%#\\\";\n-    }\n+  output_arg_descriptor (insn);\n+  return \\\"bl %1,2%#\\\";\n }\"\n- [(set_attr \"type\" \"dyncall,call\")\n-  (set_attr \"length\" \"3,1\")])\n+ [(set_attr \"type\" \"call\")\n+  (set_attr \"length\" \"1\")])\n+\n+(define_insn \"call_value_internal_reg\"\n+  [(set (match_operand 0 \"\" \"=rfx\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 2))\n+   (use (const_int 1))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"copy %1,22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,31\\;copy 31,2\"\n+ [(set_attr \"type\" \"dyncall\")\n+  (set_attr \"length\" \"3\")])\n \n (define_insn \"nop\"\n   [(const_int 0)]"}]}