{"sha": "9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVkMzEzY2MyMzIzMmE4ZThmMTZhNWIxZTk0ZmM5M2IxYTM4ZTBmNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-05T10:10:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-05T10:10:33Z"}, "message": "tree-vectorizer.h (vect_estimate_min_profitable_iters): Remove.\n\n\n\t* tree-vectorizer.h (vect_estimate_min_profitable_iters): Remove.\n\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Declare here.\n\t(vect_analyze_loop_operations): Use loop count estimate to rule out\n\tunprofitable vectorization.\n\t(vect_estimate_min_profitable_iters): Return ret_min_profitable_estimate.\n\nFrom-SVN: r192116", "tree": {"sha": "88edb41c967da7bd2c560dc597fb4040c4c6a618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88edb41c967da7bd2c560dc597fb4040c4c6a618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/comments", "author": null, "committer": null, "parents": [{"sha": "440d347233baeb164433435f63fda2093e98cb6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/440d347233baeb164433435f63fda2093e98cb6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/440d347233baeb164433435f63fda2093e98cb6a"}], "stats": {"total": 86, "additions": 74, "deletions": 12}, "files": [{"sha": "e9df431a20d9148091b0d0d7022854d07acd8f64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "patch": "@@ -1,3 +1,11 @@\n+2012-10-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-vectorizer.h (vect_estimate_min_profitable_iters): Remove.\n+\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Declare here.\n+\t(vect_analyze_loop_operations): Use loop count estimate to rule out\n+\tunprofitable vectorization.\n+\t(vect_estimate_min_profitable_iters): Return ret_min_profitable_estimate.\n+\n 2012-10-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/54810"}, {"sha": "58edfcbe48029c21dec340fce30fc50918b7aaf2", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "patch": "@@ -140,6 +140,8 @@ along with GCC; see the file COPYING3.  If not see\n    http://gcc.gnu.org/projects/tree-ssa/vectorization.html\n */\n \n+static void vect_estimate_min_profitable_iters (loop_vec_info, int *, int *);\n+\n /* Function vect_determine_vectorization_factor\n \n    Determine the vectorization factor (VF).  VF is the number of data elements\n@@ -1287,6 +1289,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   unsigned int th;\n   bool only_slp_in_loop = true, ok;\n   HOST_WIDE_INT max_niter;\n+  HOST_WIDE_INT estimated_niter;\n+  int min_profitable_estimate;\n \n   if (dump_kind_p (MSG_NOTE))\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1490,7 +1494,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n      vector stmts depends on VF.  */\n   vect_update_slp_costs_according_to_vf (loop_vinfo);\n \n-  min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n+  vect_estimate_min_profitable_iters (loop_vinfo, &min_profitable_iters,\n+\t\t\t\t      &min_profitable_estimate);\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n \n   if (min_profitable_iters < 0)\n@@ -1508,6 +1513,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n                             * vectorization_factor) - 1);\n \n+\n   /* Use the cost model only if it is more conservative than user specified\n      threshold.  */\n \n@@ -1531,6 +1537,23 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       return false;\n     }\n \n+  if ((estimated_niter = estimated_stmt_executions_int (loop)) != -1\n+      && ((unsigned HOST_WIDE_INT) estimated_niter\n+          <= MAX (th, (unsigned)min_profitable_estimate)))\n+    {\n+      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: estimated iteration count too \"\n+                         \"small.\");\n+      if (dump_kind_p (MSG_NOTE))\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not vectorized: estimated iteration count smaller \"\n+                         \"than specified loop bound parameter or minimum \"\n+                         \"profitable iterations (whichever is more \"\n+                         \"conservative).\");\n+      return false;\n+    }\n+\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n       || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n@@ -2603,15 +2626,15 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n \n    Return the number of iterations required for the vector version of the\n    loop to be profitable relative to the cost of the scalar version of the\n-   loop.\n+   loop.  */\n \n-   TODO: Take profile info into account before making vectorization\n-   decisions, if available.  */\n-\n-int\n-vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n+static void\n+vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n+\t\t\t\t    int *ret_min_profitable_niters,\n+\t\t\t\t    int *ret_min_profitable_estimate)\n {\n   int min_profitable_iters;\n+  int min_profitable_estimate;\n   int peel_iters_prologue;\n   int peel_iters_epilogue;\n   unsigned vec_inside_cost = 0;\n@@ -2628,7 +2651,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   if (!flag_vect_cost_model)\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\");\n-      return 0;\n+      *ret_min_profitable_niters = 0;\n+      *ret_min_profitable_estimate = 0;\n+      return;\n     }\n \n   /* Requires loop versioning tests to handle misalignment.  */\n@@ -2863,7 +2888,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t\t\t \"divided by the scalar iteration cost = %d \"\n \t\t\t \"is greater or equal to the vectorization factor = %d.\",\n \t\t\t vec_inside_cost, scalar_single_iter_cost, vf);\n-      return -1;\n+      *ret_min_profitable_niters = -1;\n+      *ret_min_profitable_estimate = -1;\n+      return;\n     }\n \n   if (dump_kind_p (MSG_NOTE))\n@@ -2879,6 +2906,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                    scalar_single_iter_cost);\n       dump_printf (MSG_NOTE, \"  Scalar outside cost: %d\\n\",\n                    scalar_outside_cost);\n+      dump_printf (MSG_NOTE, \"  Vector outside cost: %d\\n\",\n+                   vec_outside_cost);\n       dump_printf (MSG_NOTE, \"  prologue iterations: %d\\n\",\n                    peel_iters_prologue);\n       dump_printf (MSG_NOTE, \"  epilogue iterations: %d\\n\",\n@@ -2898,9 +2927,35 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if (dump_kind_p (MSG_NOTE))\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"  Profitability threshold = %d\\n\", min_profitable_iters);\n+                     \"  Runtime profitability threshold = %d\\n\", min_profitable_iters);\n+\n+  *ret_min_profitable_niters = min_profitable_iters;\n+\n+  /* Calculate number of iterations required to make the vector version\n+     profitable, relative to the loop bodies only.\n+\n+     Non-vectorized variant is SIC * niters and it must win over vector\n+     variant on the expected loop trip count.  The following condition must hold true:\n+     SIC * niters > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC + SOC  */\n+\n+  if (vec_outside_cost <= 0)\n+    min_profitable_estimate = 1;\n+  else\n+    {\n+      min_profitable_estimate = ((vec_outside_cost + scalar_outside_cost) * vf\n+\t\t\t\t - vec_inside_cost * peel_iters_prologue\n+\t\t\t\t - vec_inside_cost * peel_iters_epilogue)\n+\t\t\t\t / ((scalar_single_iter_cost * vf)\n+\t\t\t\t   - vec_inside_cost);\n+    }\n+  min_profitable_estimate --;\n+  min_profitable_estimate = MAX (min_profitable_estimate, min_profitable_iters);\n+  if (dump_kind_p (MSG_NOTE))\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"  Static estimate profitability threshold = %d\\n\",\n+                      min_profitable_iters);\n \n-  return min_profitable_iters;\n+  *ret_min_profitable_estimate = min_profitable_estimate;\n }\n \n "}, {"sha": "5762e00b69ef6c3785f493bd9433da7953ff12a3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9ed313cc23232a8e8f16a5b1e94fc93b1a38e0f7", "patch": "@@ -976,7 +976,6 @@ extern bool vectorizable_live_operation (gimple, gimple_stmt_iterator *,\n extern bool vectorizable_reduction (gimple, gimple_stmt_iterator *, gimple *,\n                                     slp_tree);\n extern bool vectorizable_induction (gimple, gimple_stmt_iterator *, gimple *);\n-extern int vect_estimate_min_profitable_iters (loop_vec_info);\n extern tree get_initial_def_for_reduction (gimple, tree, tree *);\n extern int vect_min_worthwhile_factor (enum tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *, int,"}]}