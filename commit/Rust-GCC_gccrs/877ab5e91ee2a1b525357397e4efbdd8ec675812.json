{"sha": "877ab5e91ee2a1b525357397e4efbdd8ec675812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc3YWI1ZTkxZWUyYTFiNTI1MzU3Mzk3ZTRlZmJkZDhlYzY3NTgxMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-19T20:36:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-19T20:36:48Z"}, "message": "cgraphunit.c (handle_alias_pairs): Declare; free alias_pairs\n\n\n\t* cgraphunit.c (handle_alias_pairs): Declare; free alias_pairs\n\t(cgraph_process_new_functions): Process also aliases.\n\t* lto-streamer-out.c (struct sets): Remove.\n\t(trivally_defined_alias): Remove.\n\t(output_alias_pair_p): Remove.\n\t(output_unreferenced_globals): Remove.\n\t(produce_symtab); Do not handle alias pairs.\n\t(produce_asm_for_decls): Likewise.\n\t* lto-streamer-in.c (input_alias_pairs): Remove.\n\t(lto_read_body): Do not input alias pairs.\n\t(lto_input_constructors_and_inits): Remove.\n\nFrom-SVN: r187681", "tree": {"sha": "3aa47f917669fe469cc6d7484079962de3a39622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3aa47f917669fe469cc6d7484079962de3a39622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/877ab5e91ee2a1b525357397e4efbdd8ec675812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/877ab5e91ee2a1b525357397e4efbdd8ec675812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/877ab5e91ee2a1b525357397e4efbdd8ec675812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/877ab5e91ee2a1b525357397e4efbdd8ec675812/comments", "author": null, "committer": null, "parents": [{"sha": "38e55ac9e0ee61b20b52115171e67d3c3e497a02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38e55ac9e0ee61b20b52115171e67d3c3e497a02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38e55ac9e0ee61b20b52115171e67d3c3e497a02"}], "stats": {"total": 231, "additions": 29, "deletions": 202}, "files": [{"sha": "84928803e9ebb1c8e9a6a5af515767ca86e928df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=877ab5e91ee2a1b525357397e4efbdd8ec675812", "patch": "@@ -1,3 +1,17 @@\n+2012-05-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (handle_alias_pairs): Declare; free alias_pairs\n+\t(cgraph_process_new_functions): Process also aliases.\n+\t* lto-streamer-out.c (struct sets): Remove.\n+\t(trivally_defined_alias): Remove.\n+\t(output_alias_pair_p): Remove.\n+\t(output_unreferenced_globals): Remove.\n+\t(produce_symtab); Do not handle alias pairs.\n+\t(produce_asm_for_decls): Likewise.\n+\t* lto-streamer-in.c (input_alias_pairs): Remove.\n+\t(lto_read_body): Do not input alias pairs.\n+\t(lto_input_constructors_and_inits): Remove.\n+\n 2012-05-18  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (handle_alias_pairs): Cleanup; handle all types of aliases."}, {"sha": "e3416c6adaac092ea98735d6177f04b0bc89aa78", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=877ab5e91ee2a1b525357397e4efbdd8ec675812", "patch": "@@ -205,6 +205,7 @@ static void expand_all_functions (void);\n static void mark_functions_to_output (void);\n static void expand_function (struct cgraph_node *);\n static void cgraph_analyze_function (struct cgraph_node *);\n+static void handle_alias_pairs (void);\n \n FILE *cgraph_dump_file;\n \n@@ -284,6 +285,8 @@ cgraph_process_new_functions (void)\n \n   if (!cgraph_new_nodes)\n     return false;\n+  finish_aliases_1 ();\n+  handle_alias_pairs ();\n   /*  Note that this queue may grow as its being processed, as the new\n       functions may generate new ones.  */\n   for (csi = csi_start (cgraph_new_nodes); !csi_end_p (csi); csi_next (&csi))\n@@ -1089,6 +1092,7 @@ handle_alias_pairs (void)\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n \t}\n     }\n+  VEC_free (alias_pair, gc, alias_pairs);\n }\n \n "}, {"sha": "63497f6d45603e963d7b71dbb5a9ae15afea4034", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=877ab5e91ee2a1b525357397e4efbdd8ec675812", "patch": "@@ -931,39 +931,6 @@ input_function (tree fn_decl, struct data_in *data_in,\n }\n \n \n-/* Read initializer expressions for public statics.  DATA_IN is the\n-   file being read.  IB is the input block used for reading.  */\n-\n-static void\n-input_alias_pairs (struct lto_input_block *ib, struct data_in *data_in)\n-{\n-  tree var;\n-\n-  clear_line_info (data_in);\n-\n-  var = stream_read_tree (ib, data_in);\n-  while (var)\n-    {\n-      const char *orig_name, *new_name;\n-      alias_pair *p;\n-\n-      p = VEC_safe_push (alias_pair, gc, alias_pairs, NULL);\n-      p->decl = var;\n-      p->target = stream_read_tree (ib, data_in);\n-\n-      /* If the target is a static object, we may have registered a\n-\t new name for it to avoid clashes between statics coming from\n-\t different files.  In that case, use the new name.  */\n-      orig_name = IDENTIFIER_POINTER (p->target);\n-      new_name = lto_get_decl_name_mapping (data_in->file_data, orig_name);\n-      if (strcmp (orig_name, new_name) != 0)\n-\tp->target = get_identifier (new_name);\n-\n-      var = stream_read_tree (ib, data_in);\n-    }\n-}\n-\n-\n /* Read the body from DATA for function FN_DECL and fill it in.\n    FILE_DATA are the global decls and types.  SECTION_TYPE is either\n    LTO_section_function_body or LTO_section_static_initializer.  If\n@@ -1059,10 +1026,6 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n \n       pop_cfun ();\n     }\n-  else\n-    {\n-      input_alias_pairs (&ib_main, data_in);\n-    }\n \n   clear_line_info (data_in);\n   lto_data_in_delete (data_in);\n@@ -1081,17 +1044,6 @@ lto_input_function_body (struct lto_file_decl_data *file_data,\n }\n \n \n-/* Read in VAR_DECL using DATA.  FILE_DATA holds the global decls and\n-   types.  */\n-\n-void\n-lto_input_constructors_and_inits (struct lto_file_decl_data *file_data,\n-\t\t\t\t  const char *data)\n-{\n-  lto_read_body (file_data, NULL, data, LTO_section_static_initializer);\n-}\n-\n-\n /* Read the physical representation of a tree node with tag TAG from\n    input block IB using the per-file context in DATA_IN.  */\n "}, {"sha": "7f12e1c56b15a80891977cb3f53003c2dd36463c", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 6, "deletions": 131, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=877ab5e91ee2a1b525357397e4efbdd8ec675812", "patch": "@@ -852,115 +852,6 @@ output_function (struct cgraph_node *node)\n }\n \n \n-/* Used to pass data to trivally_defined_alias callback.  */\n-struct sets {\n-  cgraph_node_set set;\n-  varpool_node_set vset;\n-};\n-\n-\n-/* Return true if alias pair P belongs to the set of cgraph nodes in\n-   SET.  If P is a an alias for a VAR_DECL, it can always be emitted.\n-   However, for FUNCTION_DECL aliases, we should only output the pair\n-   if it belongs to a function whose cgraph node is in SET.\n-   Otherwise, the LTRANS phase will get into trouble when finalizing\n-   aliases because the alias will refer to a function not defined in\n-   the file processed by LTRANS.  */\n-\n-static bool\n-trivally_defined_alias (tree decl ATTRIBUTE_UNUSED,\n-\t\t\ttree target, void *data)\n-{\n-  struct sets *set = (struct sets *) data;\n-  struct cgraph_node *fnode = NULL;\n-  struct varpool_node *vnode = NULL;\n-\n-  fnode = cgraph_node_for_asm (target);\n-  if (fnode)\n-    return cgraph_node_in_set_p (fnode, set->set);\n-  vnode = varpool_node_for_asm (target);\n-  return vnode && varpool_node_in_set_p (vnode, set->vset);\n-}\n-\n-/* Return true if alias pair P should be output in the current\n-   partition contains cgrpah nodes SET and varpool nodes VSET.\n-   DEFINED is set of all aliases whose targets are defined in\n-   the partition.\n-\n-   Normal aliases are output when they are defined, while WEAKREF\n-   aliases are output when they are used.  */\n-\n-static bool\n-output_alias_pair_p (alias_pair *p, symbol_alias_set_t *defined,\n-\t\t     cgraph_node_set set, varpool_node_set vset)\n-{\n-  struct cgraph_node *node;\n-  struct varpool_node *vnode;\n-\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n-    {\n-      if (TREE_CODE (p->decl) == VAR_DECL)\n-\t{\n-\t  vnode = varpool_get_node (p->decl);\n-\t  return (vnode\n-\t\t  && referenced_from_this_partition_p (&vnode->symbol.ref_list,\n-\t\t\t\t\t\t      set, vset));\n-\t}\n-      node = cgraph_get_node (p->decl);\n-      return (node\n-\t      && (referenced_from_this_partition_p (&node->symbol.ref_list,\n-\t\t\t\t\t\t    set, vset)\n-\t\t  || reachable_from_this_partition_p (node, set)));\n-    }\n-  else\n-    return symbol_alias_set_contains (defined, p->decl);\n-}\n-\n-/* Output any unreferenced global symbol defined in SET, alias pairs\n-   and labels.  */\n-\n-static void\n-output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n-{\n-  struct output_block *ob;\n-  alias_pair *p;\n-  unsigned i;\n-  symbol_alias_set_t *defined;\n-  struct sets setdata;\n-\n-  setdata.set = set;\n-  setdata.vset = vset;\n-\n-  ob = create_output_block (LTO_section_static_initializer);\n-  ob->cgraph_node = NULL;\n-\n-  clear_line_info (ob);\n-\n-  /* Make string 0 be a NULL string.  */\n-  streamer_write_char_stream (ob->string_stream, 0);\n-\n-  /* We really need to propagate in both directoins:\n-     for normal aliases we propagate from first defined alias to\n-     all aliases defined based on it.  For weakrefs we propagate in\n-     the oposite direction.  */\n-  defined = propagate_aliases_backward (trivally_defined_alias, &setdata);\n-\n-  /* Emit the alias pairs for the nodes in SET.  */\n-  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n-    if (output_alias_pair_p (p, defined, set, vset))\n-      {\n-\tstream_write_tree (ob, p->decl, true);\n-\tstream_write_tree (ob, p->target, true);\n-      }\n-  symbol_alias_set_destroy (defined);\n-\n-  streamer_write_record_start (ob, LTO_null);\n-\n-  produce_asm (ob, NULL);\n-  destroy_output_block (ob);\n-}\n-\n-\n /* Emit toplevel asms.  */\n \n void\n@@ -1387,8 +1278,7 @@ write_symbol (struct streamer_tree_cache_d *cache,\n    SET and VSET are cgraph/varpool node sets we are outputting.  */\n \n static void\n-produce_symtab (struct output_block *ob,\n-\t        cgraph_node_set set, varpool_node_set vset)\n+produce_symtab (struct output_block *ob)\n {\n   struct streamer_tree_cache_d *cache = ob->writer_cache;\n   char *section_name = lto_get_section_name (LTO_section_symtab, NULL, NULL);\n@@ -1399,12 +1289,6 @@ produce_symtab (struct output_block *ob,\n   lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n   lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n   int i;\n-  alias_pair *p;\n-  struct sets setdata;\n-  symbol_alias_set_t *defined;\n-\n-  setdata.set = set;\n-  setdata.vset = vset;\n \n   lto_begin_section (section_name, false);\n   free (section_name);\n@@ -1478,13 +1362,6 @@ produce_symtab (struct output_block *ob,\n       write_symbol (cache, &stream, vnode->symbol.decl, seen, false);\n     }\n \n-  /* Write all aliases.  */\n-  defined = propagate_aliases_backward (trivally_defined_alias, &setdata);\n-  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n-    if (output_alias_pair_p (p, defined, set, vset))\n-      write_symbol (cache, &stream, p->decl, seen, true);\n-  symbol_alias_set_destroy (defined);\n-\n   lto_write_stream (&stream);\n   pointer_set_destroy (seen);\n \n@@ -1499,7 +1376,8 @@ produce_symtab (struct output_block *ob,\n    recover these on other side.  */\n \n static void\n-produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n+produce_asm_for_decls (cgraph_node_set set ATTRIBUTE_UNUSED,\n+\t\t       varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   struct lto_out_decl_state *out_state;\n   struct lto_out_decl_state *fn_out_state;\n@@ -1514,11 +1392,6 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n   ob = create_output_block (LTO_section_decls);\n   ob->global = true;\n \n-  /* Write out unreferenced globals, alias pairs and labels.  We defer\n-     doing this until now so that we can write out only what is\n-     needed.  */\n-  output_unreferenced_globals (set, vset);\n-\n   memset (&header, 0, sizeof (struct lto_decl_header));\n \n   section_name = lto_get_section_name (LTO_section_decls, NULL, NULL);\n@@ -1528,6 +1401,8 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n   /* Make string 0 be a NULL string.  */\n   streamer_write_char_stream (ob->string_stream, 0);\n \n+  gcc_assert (!alias_pairs);\n+\n   /* Write the global symbols.  */\n   out_state = lto_get_out_decl_state ();\n   num_fns = VEC_length (lto_out_decl_state_ptr, lto_function_decl_states);\n@@ -1591,7 +1466,7 @@ produce_asm_for_decls (cgraph_node_set set, varpool_node_set vset)\n   /* Write the symbol table.  It is used by linker to determine dependencies\n      and thus we can skip it for WPA.  */\n   if (!flag_wpa)\n-    produce_symtab (ob, set, vset);\n+    produce_symtab (ob);\n \n   /* Write command line opts.  */\n   lto_write_options ();"}, {"sha": "06774d833b009b3e2cf4e5c15faae7ca844ee37e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=877ab5e91ee2a1b525357397e4efbdd8ec675812", "patch": "@@ -1,3 +1,8 @@\n+2012-05-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_materialize_constructors_and_inits): Remove.\n+\t(read_cgraph_and_symbols): Remove handling of alias pairs.\n+\n 2012-05-17  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (add_references_to_partition): Handle external vars."}, {"sha": "b94c8a7f8694dc10be56a5cd74cb35182e705b4e", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/877ab5e91ee2a1b525357397e4efbdd8ec675812/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=877ab5e91ee2a1b525357397e4efbdd8ec675812", "patch": "@@ -156,20 +156,6 @@ lto_splay_tree_new (void)\n \t\t\t NULL);\n }\n \n-/* Read the constructors and inits.  */\n-\n-static void\n-lto_materialize_constructors_and_inits (struct lto_file_decl_data * file_data)\n-{\n-  size_t len;\n-  const char *data = lto_get_section_data (file_data, \n-\t\t\t\t\t   LTO_section_static_initializer,\n-\t\t\t\t\t   NULL, &len);\n-  lto_input_constructors_and_inits (file_data, data);\n-  lto_free_section_data (file_data, LTO_section_static_initializer, NULL,\n-\t\t\t data, len);\n-}\n-\n /* Return true when NODE has a clone that is analyzed (i.e. we need\n    to load its body even if the node itself is not needed).  */\n \n@@ -1883,15 +1869,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   timevar_push (TV_IPA_LTO_DECL_INIT_IO);\n \n-  /* FIXME lto. This loop needs to be changed to use the pass manager to\n-     call the ipa passes directly.  */\n-  if (!seen_error ())\n-    for (i = 0; i < last_file_ix; i++)\n-      {\n-\tstruct lto_file_decl_data *file_data = all_file_decl_data [i];\n-\tlto_materialize_constructors_and_inits (file_data);\n-      }\n-\n   /* Indicate that the cgraph is built and ready.  */\n   cgraph_function_flags_ready = true;\n "}]}