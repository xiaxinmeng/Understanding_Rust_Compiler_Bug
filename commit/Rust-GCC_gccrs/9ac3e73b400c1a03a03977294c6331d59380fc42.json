{"sha": "9ac3e73b400c1a03a03977294c6331d59380fc42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFjM2U3M2I0MDBjMWEwM2EwMzk3NzI5NGM2MzMxZDU5MzgwZmM0Mg==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2002-12-09T17:54:07Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2002-12-09T17:54:07Z"}, "message": "tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): Remove definition.\n\n\t* doc/tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): Remove definition.\n\t* defaults.h (FUNCTION_ARG_REG_LITTLE_ENDIAN): Remove definition.\n\t* calls.c (store_unaligned_arguments_into_pseudos) Remove\n\tFUNCTION_ARG_REG_LITTLE_ENDIAN.\n\t* stmt.c (expand_return): Ditto.\n\t* expr.c (move_block_from_reg): Ditto.\n\t(copy_blkmode_from_reg): Ditto.\n\t* expmed.c (store_bit_field): Ditto.\n\nFrom-SVN: r59962", "tree": {"sha": "7c649b2f3775a2897cd06bd008e189cfbd967e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c649b2f3775a2897cd06bd008e189cfbd967e27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ac3e73b400c1a03a03977294c6331d59380fc42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac3e73b400c1a03a03977294c6331d59380fc42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ac3e73b400c1a03a03977294c6331d59380fc42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac3e73b400c1a03a03977294c6331d59380fc42/comments", "author": null, "committer": null, "parents": [{"sha": "e46af8eda8570b3d2c908b99c0ca808c7c8bafa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e46af8eda8570b3d2c908b99c0ca808c7c8bafa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e46af8eda8570b3d2c908b99c0ca808c7c8bafa9"}], "stats": {"total": 52, "additions": 15, "deletions": 37}, "files": [{"sha": "3cb1aa8b4bba50976169ea6f30e07ab76486dcb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -1,3 +1,14 @@\n+2002-12-09  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* doc/tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): Remove definition.\n+\t* defaults.h (FUNCTION_ARG_REG_LITTLE_ENDIAN): Remove definition.\n+\t* calls.c (store_unaligned_arguments_into_pseudos) Remove\n+\tFUNCTION_ARG_REG_LITTLE_ENDIAN.\n+\t* stmt.c (expand_return): Ditto.\n+\t* expr.c (move_block_from_reg): Ditto.\n+\t(copy_blkmode_from_reg): Ditto.\n+\t* expmed.c (store_bit_field): Ditto. \n+\n 2002-12-09  Svein E. Seldal  <Svein.Seldal@solidas.com>\n \n \t* config.gcc: Added tic4x-* target as an alias to c4x-*"}, {"sha": "41725b5776989743f6701c8e05992272d6ae6e2c", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -1071,7 +1071,6 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n \t   this means we must skip the empty high order bytes when\n \t   calculating the bit offset.  */\n \tif (BYTES_BIG_ENDIAN\n-\t    && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n \t    && bytes < UNITS_PER_WORD)\n \t  big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n "}, {"sha": "0c71996c4205546394c102dd07cd26eb2affc421", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -513,16 +513,6 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define PREFERRED_DEBUGGING_TYPE NO_DEBUG\n #endif\n \n-/* This is set to 1 if BYTES_BIG_ENDIAN is defined but the target uses a\n-   little-endian method of passing and returning structures in registers.\n-   On the HP-UX IA64 and PA64 platforms structures are aligned differently\n-   then integral values and setting this value to 1 will allow for the\n-   special handling of structure arguments and return values in regs.  */\n-\n-#ifndef FUNCTION_ARG_REG_LITTLE_ENDIAN\n-#define FUNCTION_ARG_REG_LITTLE_ENDIAN 0\n-#endif\n-\n /* Define codes for all the float formats that we know of.  */\n #define UNKNOWN_FLOAT_FORMAT 0\n #define IEEE_FLOAT_FORMAT 1"}, {"sha": "342f6096bdf75759a34d4668e9b87221806dbb05", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -3584,14 +3584,6 @@ nonzero, the caller does not make a copy.  Instead, it passes a pointer to the\n determined that the value won't be modified, it need not make a copy;\n otherwise a copy must be made.\n \n-@findex FUNCTION_ARG_REG_LITTLE_ENDIAN\n-@item FUNCTION_ARG_REG_LITTLE_ENDIAN\n-If defined TRUE on a big-endian system then structure arguments passed\n-(and returned) in registers are passed in a little-endian manner instead of\n-the big-endian manner.  On the HP-UX IA64 and PA64 platforms structures are\n-aligned differently then integral values and setting this value to true will\n-allow for the special handling of structure arguments and return values.\n-\n @findex CUMULATIVE_ARGS\n @item CUMULATIVE_ARGS\n A C type for declaring a variable that is used as the first argument of"}, {"sha": "5eb933c5530a459734318624b70bbb4f6309b9d0", "filename": "gcc/expmed.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -404,7 +404,6 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n   if (BYTES_BIG_ENDIAN\n-      && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n       && GET_CODE (op0) != MEM\n       && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n     bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));"}, {"sha": "85d329f9ffce3df200465ff07633226bd08d52a7", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -2147,8 +2147,7 @@ move_block_from_reg (regno, x, nregs, size)\n   /* If SIZE is that of a mode no bigger than a word, just use that\n      mode's store operation.  */\n   if (size <= UNITS_PER_WORD\n-      && (mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0)) != BLKmode\n-      && !FUNCTION_ARG_REG_LITTLE_ENDIAN)\n+      && (mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0)) != BLKmode)\n     {\n       emit_move_insn (adjust_address (x, mode, 0), gen_rtx_REG (mode, regno));\n       return;\n@@ -2157,9 +2156,7 @@ move_block_from_reg (regno, x, nregs, size)\n   /* Blocks smaller than a word on a BYTES_BIG_ENDIAN machine must be aligned\n      to the left before storing to memory.  Note that the previous test\n      doesn't handle all cases (e.g. SIZE == 3).  */\n-  if (size < UNITS_PER_WORD\n-      && BYTES_BIG_ENDIAN\n-      && !FUNCTION_ARG_REG_LITTLE_ENDIAN)\n+  if (size < UNITS_PER_WORD && BYTES_BIG_ENDIAN)\n     {\n       rtx tem = operand_subword (x, 0, 1, BLKmode);\n       rtx shift;\n@@ -2523,26 +2520,17 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n     }\n \n   /* This code assumes srcreg is at least a full word.  If it isn't, copy it\n-     into a new pseudo which is a full word.\n+     into a new pseudo which is a full word.  */\n \n-     If FUNCTION_ARG_REG_LITTLE_ENDIAN is set and convert_to_mode does a copy,\n-     the wrong part of the register gets copied so we fake a type conversion\n-     in place.  */\n   if (GET_MODE (srcreg) != BLKmode\n       && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n-    {\n-      if (FUNCTION_ARG_REG_LITTLE_ENDIAN)\n-\tsrcreg = simplify_gen_subreg (word_mode, srcreg, GET_MODE (srcreg), 0);\n-      else\n-\tsrcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n-    }\n+    srcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n \n   /* Structures whose size is not a multiple of a word are aligned\n      to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n      machine, this means we must skip the empty high order bytes when\n      calculating the bit offset.  */\n   if (BYTES_BIG_ENDIAN\n-      && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n       && bytes % UNITS_PER_WORD)\n     big_endian_correction\n       = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD) * BITS_PER_UNIT));"}, {"sha": "fdae2b8a0b6d801292558b14f1b9b487002b410d", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac3e73b400c1a03a03977294c6331d59380fc42/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9ac3e73b400c1a03a03977294c6331d59380fc42", "patch": "@@ -3106,7 +3106,6 @@ expand_return (retval)\n \t machine, this means we must skip the empty high order bytes when\n \t calculating the bit offset.  */\n       if (BYTES_BIG_ENDIAN\n-\t  && !FUNCTION_ARG_REG_LITTLE_ENDIAN\n \t  && bytes % UNITS_PER_WORD)\n \tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n \t\t\t\t\t\t  * BITS_PER_UNIT));"}]}