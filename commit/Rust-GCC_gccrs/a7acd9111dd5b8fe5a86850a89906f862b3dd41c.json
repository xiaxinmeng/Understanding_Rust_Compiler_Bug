{"sha": "a7acd9111dd5b8fe5a86850a89906f862b3dd41c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhY2Q5MTExZGQ1YjhmZTVhODY4NTBhODk5MDZmODYyYjNkZDQxYw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-08-04T01:34:34Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-08-04T01:34:34Z"}, "message": "(v9 sparc_builtin_saveregs): Save quadword fp regs on 16 byte boundaries.\n\n(v9 sparc_builtin_saveregs): Save quadword fp regs on\n16 byte boundaries.  Handle non-zero number of named fp args.\n\nFrom-SVN: r7855", "tree": {"sha": "42f7323335b02e61236ec08f2145845f6be111e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42f7323335b02e61236ec08f2145845f6be111e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7acd9111dd5b8fe5a86850a89906f862b3dd41c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7acd9111dd5b8fe5a86850a89906f862b3dd41c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7acd9111dd5b8fe5a86850a89906f862b3dd41c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7acd9111dd5b8fe5a86850a89906f862b3dd41c/comments", "author": null, "committer": null, "parents": [{"sha": "29421402b7e58876daa370f41f8162ea80dbee5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29421402b7e58876daa370f41f8162ea80dbee5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29421402b7e58876daa370f41f8162ea80dbee5b"}], "stats": {"total": 34, "additions": 22, "deletions": 12}, "files": [{"sha": "e80c280df1a3226cad2514f1f28d9584090b7924", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7acd9111dd5b8fe5a86850a89906f862b3dd41c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7acd9111dd5b8fe5a86850a89906f862b3dd41c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a7acd9111dd5b8fe5a86850a89906f862b3dd41c", "patch": "@@ -3086,27 +3086,36 @@ sparc_builtin_saveregs (arglist)\n {\n   tree fntype = TREE_TYPE (current_function_decl);\n   /* First unnamed integer register.  */\n-  int first_intreg = current_function_args_info.arg_count[0];\n+  int first_intreg = current_function_args_info.arg_count[(int) SPARC_ARG_INT];\n   /* Number of integer registers we need to save.  */\n   int n_intregs = MAX (0, NPARM_REGS (SImode) - first_intreg);\n   /* First unnamed SFmode float reg (no, you can't pass SFmode floats as\n-     unnamed arguments, we just number them that way).  */\n-  int first_floatreg = current_function_args_info.arg_count[1] + 1 & ~1;\n+     unnamed arguments, we just number them that way).  We must round up to\n+     the next double word float reg - that is the first one to save.  */\n+  int first_floatreg = current_function_args_info.arg_count[(int) SPARC_ARG_FLOAT] + 1 & ~1;\n   /* Number of SFmode float regs to save.  */\n   int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n   int ptrsize = GET_MODE_SIZE (Pmode);\n   rtx valist, regbuf, fpregs;\n-  int regno;\n+  int bufsize, adjust, regno;\n \n   /* Allocate block of memory for the regs.\n-     We only allocate as much as we need.  */\n+     We only allocate as much as we need, but we must ensure quadword float\n+     regs are stored with the appropriate alignment.  */\n   /* ??? If n_intregs + n_floatregs == 0, should we allocate at least 1 byte?\n      Or can assign_stack_local accept a 0 SIZE argument?  */\n \n-  regbuf = assign_stack_local (BLKmode,\n-\t\t\t       (n_intregs * UNITS_PER_WORD\n-\t\t\t\t+ n_floatregs * FLOAT_TYPE_SIZE/BITS_PER_UNIT),\n-\t\t\t       BITS_PER_WORD);\n+  bufsize = (n_intregs * UNITS_PER_WORD) + (n_floatregs * (UNITS_PER_WORD / 2));\n+  /* Add space in front of the int regs to ensure proper alignment of quadword\n+     fp regs.  We must add the space in front because va_start assumes this.  */\n+  if (n_floatregs >= 4)\n+    adjust = ((n_intregs + first_floatreg / 2) % 2) * UNITS_PER_WORD;\n+  else\n+    adjust = 0;\n+\n+  regbuf = assign_stack_local (BLKmode, bufsize + adjust,\n+\t\t\t       GET_MODE_BITSIZE (TFmode));\n+  regbuf = gen_rtx (MEM, BLKmode, plus_constant (XEXP (regbuf, 0), adjust));\n   MEM_IN_STRUCT_P (regbuf) = 1;\n \n   /* Save int args.\n@@ -3130,9 +3139,10 @@ sparc_builtin_saveregs (arglist)\n   for (regno = first_floatreg; regno < NPARM_REGS (SFmode); regno += 2)\n     emit_move_insn (gen_rtx (MEM, DFmode,\n \t\t\t     plus_constant (fpregs,\n-\t\t\t\t\t    GET_MODE_SIZE (SFmode) * regno)),\n-\t\t    gen_rtx (REG, DFmode, BASE_INCOMING_ARG_REG (DFmode)\n-\t\t\t     + regno));\n+\t\t\t\t\t    GET_MODE_SIZE (SFmode)\n+\t\t\t\t\t    * (regno - first_floatreg))),\n+\t\t    gen_rtx (REG, DFmode,\n+\t\t\t     BASE_INCOMING_ARG_REG (DFmode) + regno));\n \n   /* Return the address of the regbuf.  */\n "}]}