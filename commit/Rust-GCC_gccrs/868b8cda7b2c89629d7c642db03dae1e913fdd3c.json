{"sha": "868b8cda7b2c89629d7c642db03dae1e913fdd3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY4YjhjZGE3YjJjODk2MjlkN2M2NDJkYjAzZGFlMWU5MTNmZGQzYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-07-24T21:04:12Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-07-24T21:04:12Z"}, "message": "builtins.def (BUILT_IN_PRINTF, [...]): Changed from front-end builtins to normal builtins, using DEF_LIB_BUILTIN.\n\n\n\t* builtins.def (BUILT_IN_PRINTF, BUILT_IN_FPRINTF): Changed from\n\tfront-end builtins to normal builtins, using DEF_LIB_BUILTIN.\n\t(BUILT_IN_PRINTF_UNLOCKED, BUILT_IN_FPRINTF_UNLOCKED): Changed\n\tfrom front-end to normal builtins, using DEF_EXT_LIB_BUILTIN.\n\t(DEF_FRONT_END_LIB_BUILTIN): Delete.\n\t(DEF_EXT_FRONT_END_LIB_BUILTIN): Delete.\n\t(BUILT_IN_FWRITE_UNLOCKED): Wrap long line.\n\n\t* builtins.c (build_string_literal): New function to construct\n\ta char* pointer to a string literal.\n\t(expand_builtin_fputs): Change 2nd argument from \"int ignore\" to\n\t\"rtx target\" to be consistent with other expand_builtin_* functions.\n\tChange 3rd argument from \"int unlocked\" to \"bool unlocked\".\n\t(expand_builtin_printf): Rewrite of c_expand_builtin_printf from\n\tc-common.c to avoid front-end dependencies.  Optimize printf(\"\")\n\tas a no-op when the result isn't required.  Handle embedded NULs\n\tin format string.\n\t(expand_builtin_fprintf): A rewrite of c_expand_builtin_fprintf\n\tfrom c-common.c to avoid front-end dependencies.  Likewise, optimize\n\tfprintf(fp,\"\") as a no-op when the result isn't required, evaluating\n\tfp for side-effects.  Handle embedded NULs in format string.\n\t(expand_builtin_sprintf): Fix typo.\n\t(expand_builtin): Don't expand BUILT_IN_FPRINT{,_UNLOCKED} when not\n\toptimizing.  Adjust calls of expand_builtin_fputs to match the API\n\tchange. Expand BUILT_IN_PRINTF and BUILT_IN_PRINTF_UNLOCKED using\n\texpand_builtin_printf.  Likewise, expand BUILT_IN_FPRINTF_UNLOCKED\n\tand BUILT_IN_FPRINTF using expand_builtin_fprintf.\n\n\t* c-common.c (is_valid_printf_arglist): Delete.\n\t(c_expand_builtin): Delete.\n\t(c_expand_builtin_printf): Moved to builtins.c. Delete.\n\t(c_expand_builtin_fprintf): Moved to builtins.c.  Delete.\n\t(c_expand_expr): No longer treat CALL_EXPRs specially.\n\t(CALLED_AS_BUILT_IN): Delete.\n\nFrom-SVN: r69760", "tree": {"sha": "b05c49149bd1ed00301b62af2657b2f3d047bc0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b05c49149bd1ed00301b62af2657b2f3d047bc0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/868b8cda7b2c89629d7c642db03dae1e913fdd3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868b8cda7b2c89629d7c642db03dae1e913fdd3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868b8cda7b2c89629d7c642db03dae1e913fdd3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868b8cda7b2c89629d7c642db03dae1e913fdd3c/comments", "author": null, "committer": null, "parents": [{"sha": "2a868ea448b0730a00817462c13182b1c1d52c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a868ea448b0730a00817462c13182b1c1d52c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a868ea448b0730a00817462c13182b1c1d52c22"}], "stats": {"total": 658, "additions": 317, "deletions": 341}, "files": [{"sha": "4a68dfba09074c3b891c098f07b85fad3e934792", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=868b8cda7b2c89629d7c642db03dae1e913fdd3c", "patch": "@@ -1,3 +1,40 @@\n+2003-07-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.def (BUILT_IN_PRINTF, BUILT_IN_FPRINTF): Changed from\n+\tfront-end builtins to normal builtins, using DEF_LIB_BUILTIN.\n+\t(BUILT_IN_PRINTF_UNLOCKED, BUILT_IN_FPRINTF_UNLOCKED): Changed\n+\tfrom front-end to normal builtins, using DEF_EXT_LIB_BUILTIN.\n+\t(DEF_FRONT_END_LIB_BUILTIN): Delete.\n+\t(DEF_EXT_FRONT_END_LIB_BUILTIN): Delete.\n+\t(BUILT_IN_FWRITE_UNLOCKED): Wrap long line.\n+\n+\t* builtins.c (build_string_literal): New function to construct\n+\ta char* pointer to a string literal.\n+\t(expand_builtin_fputs): Change 2nd argument from \"int ignore\" to\n+\t\"rtx target\" to be consistent with other expand_builtin_* functions.\n+\tChange 3rd argument from \"int unlocked\" to \"bool unlocked\".\n+\t(expand_builtin_printf): Rewrite of c_expand_builtin_printf from\n+\tc-common.c to avoid front-end dependencies.  Optimize printf(\"\")\n+\tas a no-op when the result isn't required.  Handle embedded NULs\n+\tin format string.\n+\t(expand_builtin_fprintf): A rewrite of c_expand_builtin_fprintf\n+\tfrom c-common.c to avoid front-end dependencies.  Likewise, optimize\n+\tfprintf(fp,\"\") as a no-op when the result isn't required, evaluating\n+\tfp for side-effects.  Handle embedded NULs in format string.\n+\t(expand_builtin_sprintf): Fix typo.\n+\t(expand_builtin): Don't expand BUILT_IN_FPRINT{,_UNLOCKED} when not\n+\toptimizing.  Adjust calls of expand_builtin_fputs to match the API\n+\tchange. Expand BUILT_IN_PRINTF and BUILT_IN_PRINTF_UNLOCKED using\n+\texpand_builtin_printf.  Likewise, expand BUILT_IN_FPRINTF_UNLOCKED\n+\tand BUILT_IN_FPRINTF using expand_builtin_fprintf.\n+\n+\t* c-common.c (is_valid_printf_arglist): Delete.\n+\t(c_expand_builtin): Delete.\n+\t(c_expand_builtin_printf): Moved to builtins.c. Delete.\n+\t(c_expand_builtin_fprintf): Moved to builtins.c.  Delete.\n+\t(c_expand_expr): No longer treat CALL_EXPRs specially.\n+\t(CALLED_AS_BUILT_IN): Delete.\n+\n 2003-07-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \tPR optimization/11631"}, {"sha": "a8c1d47277f7824a722952aadce5cdf40ec92a59", "filename": "gcc/builtins.c", "status": "modified", "additions": 261, "deletions": 11, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=868b8cda7b2c89629d7c642db03dae1e913fdd3c", "patch": "@@ -90,6 +90,7 @@ static const char *c_getstr (tree);\n static rtx c_readstr (const char *, enum machine_mode);\n static int target_char_cast (tree, char *);\n static rtx get_memory_rtx (tree);\n+static tree build_string_literal (int, const char *);\n static int apply_args_size (void);\n static int apply_result_size (void);\n #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n@@ -140,7 +141,9 @@ static rtx expand_builtin_strrchr (tree, rtx, enum machine_mode);\n static rtx expand_builtin_alloca (tree, rtx);\n static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n-static rtx expand_builtin_fputs (tree, int, int);\n+static rtx expand_builtin_fputs (tree, rtx, bool);\n+static rtx expand_builtin_printf (tree, rtx, enum machine_mode, bool);\n+static rtx expand_builtin_fprintf (tree, rtx, enum machine_mode, bool);\n static rtx expand_builtin_sprintf (tree, rtx, enum machine_mode);\n static tree stabilize_va_list (tree, int);\n static rtx expand_builtin_expect (tree, rtx);\n@@ -820,10 +823,10 @@ expand_builtin_prefetch (tree arglist)\n       if ((! (*insn_data[(int) CODE_FOR_prefetch].operand[0].predicate)\n \t     (op0,\n \t      insn_data[(int) CODE_FOR_prefetch].operand[0].mode))\n-\t  || (GET_MODE(op0) != Pmode))\n+\t  || (GET_MODE (op0) != Pmode))\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t  if (GET_MODE(op0) != Pmode)\n+\t  if (GET_MODE (op0) != Pmode)\n \t    op0 = convert_memory_address (Pmode, op0);\n #endif\n \t  op0 = force_reg (Pmode, op0);\n@@ -2137,7 +2140,7 @@ expand_powi (rtx x, enum machine_mode mode, HOST_WIDE_INT n)\n \n   val = (n < 0) ? -n : n;\n \n-  memset (cache, 0, sizeof(cache));\n+  memset (cache, 0, sizeof (cache));\n   cache[1] = x;\n \n   result = expand_powi_1 (mode, (n < 0) ? -n : n, cache);\n@@ -4258,7 +4261,7 @@ expand_builtin_unop (enum machine_mode target_mode, tree arglist, rtx target,\n    long, we attempt to transform this call into __builtin_fputc().  */\n \n static rtx\n-expand_builtin_fputs (tree arglist, int ignore, int unlocked)\n+expand_builtin_fputs (tree arglist, rtx target, bool unlocked)\n {\n   tree len, fn;\n   tree fn_fputc = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n@@ -4268,7 +4271,7 @@ expand_builtin_fputs (tree arglist, int ignore, int unlocked)\n \n   /* If the return value is used, or the replacement _DECL isn't\n      initialized, don't do the transformation.  */\n-  if (!ignore || !fn_fputc || !fn_fwrite)\n+  if (target != const0_rtx || !fn_fputc || !fn_fwrite)\n     return 0;\n \n   /* Verify the arguments in the original call.  */\n@@ -4330,8 +4333,7 @@ expand_builtin_fputs (tree arglist, int ignore, int unlocked)\n     }\n \n   return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t      (ignore ? const0_rtx : NULL_RTX),\n-\t\t      VOIDmode, EXPAND_NORMAL);\n+\t\t      const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n \n /* Expand a call to __builtin_expect.  We return our argument and emit a\n@@ -4551,6 +4553,227 @@ expand_builtin_cabs (tree arglist, rtx target)\n   return expand_complex_abs (mode, op0, target, 0);\n }\n \n+/* Create a new constant string literal and return a char* pointer to it.\n+   The STRING_CST value is the LEN characters at STR.  */\n+static tree\n+build_string_literal (int len, const char *str)\n+{\n+  tree t, elem, index, type;\n+\n+  t = build_string (len, str);\n+  elem = build_type_variant (char_type_node, 1, 0);\n+  index = build_index_type (build_int_2 (len - 1, 0));\n+  type = build_array_type (elem, index);\n+  TREE_TYPE (t) = type;\n+  TREE_CONSTANT (t) = 1;\n+  TREE_READONLY (t) = 1;\n+  TREE_STATIC (t) = 1;\n+\n+  type = build_pointer_type (type);\n+  t = build1 (ADDR_EXPR, type, t);\n+\n+  type = build_pointer_type (elem);\n+  t = build1 (NOP_EXPR, type, t);\n+  return t;\n+}\n+\n+/* Expand a call to printf or printf_unlocked with argument list ARGLIST.\n+   Return 0 if a normal call should be emitted rather than transforming\n+   the function inline.  If convenient, the result should be placed in\n+   TARGET with mode MODE.  UNLOCKED indicates this is a printf_unlocked \n+   call.  */\n+static rtx\n+expand_builtin_printf (tree arglist, rtx target, enum machine_mode mode,\n+\t\t       bool unlocked)\n+{\n+  tree fn_putchar = unlocked\n+\t\t    ? implicit_built_in_decls[BUILT_IN_PUTCHAR_UNLOCKED]\n+\t\t    : implicit_built_in_decls[BUILT_IN_PUTCHAR];\n+  tree fn_puts = unlocked ? implicit_built_in_decls[BUILT_IN_PUTS_UNLOCKED]\n+\t\t\t  : implicit_built_in_decls[BUILT_IN_PUTS];\n+  const char *fmt_str;\n+  tree fn, fmt, arg;\n+\n+  /* If the return value is used, don't do the transformation.  */\n+  if (target != const0_rtx)\n+    return 0;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (! arglist)\n+    return 0;\n+  fmt = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (fmt)) != POINTER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return 0;\n+\n+  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg).  */\n+  if (strcmp (fmt_str, \"%s\\n\") == 0)\n+    {\n+      if (! arglist\n+          || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      fn = fn_puts;\n+    }\n+  /* If the format specifier was \"%c\", call __builtin_putchar(arg).  */\n+  else if (strcmp (fmt_str, \"%c\") == 0)\n+    {\n+      if (! arglist\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      fn = fn_putchar;\n+    }\n+  else\n+    {\n+      /* We can't handle anything else with % args or %% ... yet.  */\n+      if (strchr (fmt_str, '%'))\n+        return 0;\n+\n+      if (arglist)\n+\treturn 0;\n+\n+      /* If the format specifier was \"\", printf does nothing.  */\n+      if (fmt_str[0] == '\\0')\n+\treturn const0_rtx;\n+      /* If the format specifier has length of 1, call putchar.  */\n+      if (fmt_str[1] == '\\0')\n+\t{\n+\t  /* Given printf(\"c\"), (where c is any one character,)\n+\t     convert \"c\"[0] to an int and pass that to the replacement\n+\t     function.  */\n+\t  arg = build_int_2 (fmt_str[0], 0);\n+\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t  fn = fn_putchar;\n+\t}\n+      else\n+\t{\n+\t  /* If the format specifier was \"string\\n\", call puts(\"string\").  */\n+\t  size_t len = strlen (fmt_str);\n+\t  if (fmt_str[len - 1] == '\\n')\n+\t    {\n+\t      /* Create a NUL-terminalted string that's one char shorter\n+\t\t than the original, stripping off the trailing '\\n'.  */\n+\t      char *newstr = (char *) alloca (len);\n+\t      memcpy (newstr, fmt_str, len - 1);\n+\t      newstr[len - 1] = 0;\n+\n+\t      arg = build_string_literal (len, newstr);\n+\t      arglist = build_tree_list (NULL_TREE, arg);\n+\t      fn = fn_puts;\n+\t    }\n+\t  else\n+\t    /* We'd like to arrange to call fputs(string,stdout) here,\n+\t       but we need stdout and don't have a way to get it yet.  */\n+\t    return 0;\n+\t}\n+    }\n+\n+  if (!fn)\n+    return 0;\n+  return expand_expr (build_function_call_expr (fn, arglist),\n+\t\t      target, mode, EXPAND_NORMAL);\n+}\n+\n+/* Expand a call to fprintf or fprintf_unlocked with argument list ARGLIST.\n+   Return 0 if a normal call should be emitted rather than transforming\n+   the function inline.  If convenient, the result should be placed in\n+   TARGET with mode MODE.  UNLOCKED indicates this is a fprintf_unlocked \n+   call.  */\n+static rtx\n+expand_builtin_fprintf (tree arglist, rtx target, enum machine_mode mode,\n+\t\t        bool unlocked)\n+{\n+  tree fn_fputc = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n+\t\t\t   : implicit_built_in_decls[BUILT_IN_FPUTC];\n+  tree fn_fputs = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTS_UNLOCKED]\n+\t\t\t   : implicit_built_in_decls[BUILT_IN_FPUTS];\n+  const char *fmt_str;\n+  tree fn, fmt, fp, arg;\n+\n+  /* If the return value is used, don't do the transformation.  */\n+  if (target != const0_rtx)\n+    return 0;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (! arglist)\n+    return 0;\n+  fp = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (fp)) != POINTER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  fmt = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (fmt)) != POINTER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return 0;\n+\n+  /* If the format specifier was \"%s\", call __builtin_fputs(arg,fp).  */\n+  if (strcmp (fmt_str, \"%s\") == 0)\n+    {\n+      if (! arglist\n+          || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      arg = TREE_VALUE (arglist);\n+      arglist = build_tree_list (NULL_TREE, fp);\n+      arglist = tree_cons (NULL_TREE, arg, arglist);\n+      fn = fn_fputs;\n+    }\n+  /* If the format specifier was \"%c\", call __builtin_fputc(arg,fp).  */\n+  else if (strcmp (fmt_str, \"%c\") == 0)\n+    {\n+      if (! arglist\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      arg = TREE_VALUE (arglist);\n+      arglist = build_tree_list (NULL_TREE, fp);\n+      arglist = tree_cons (NULL_TREE, arg, arglist);\n+      fn = fn_fputc;\n+    }\n+  else\n+    {\n+      /* We can't handle anything else with % args or %% ... yet.  */\n+      if (strchr (fmt_str, '%'))\n+        return 0;\n+\n+      if (arglist)\n+\treturn 0;\n+\n+      /* If the format specifier was \"\", fprintf does nothing.  */\n+      if (fmt_str[0] == '\\0')\n+\t{\n+\t  /* Evaluate and ignore FILE* argument for side-effects.  */\n+\t  expand_expr (fp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return const0_rtx;\n+\t}\n+\n+      /* When \"string\" doesn't contain %, replace all cases of\n+\t fprintf(stream,string) with fputs(string,stream).  The fputs\n+\t builtin will take care of special cases like length == 1.  */\n+      arglist = build_tree_list (NULL_TREE, fp);\n+      arglist = tree_cons (NULL_TREE, fmt, arglist);\n+      fn = fn_fputs;\n+    }\n+\n+  if (!fn)\n+    return 0;\n+  return expand_expr (build_function_call_expr (fn, arglist),\n+\t\t      target, mode, EXPAND_NORMAL);\n+}\n+\n /* Expand a call to sprintf with argument list ARGLIST.  Return 0 if\n    a normal call should be emitted rather than expanding the function\n    inline.  If convenient, the result should be placed in TARGET with\n@@ -4574,7 +4797,7 @@ expand_builtin_sprintf (tree arglist, rtx target, enum machine_mode mode)\n   if (! arglist)\n     return 0;\n   fmt = TREE_VALUE (arglist);\n-  if (TREE_CODE (TREE_TYPE (dest)) != POINTER_TYPE)\n+  if (TREE_CODE (TREE_TYPE (fmt)) != POINTER_TYPE)\n     return 0;\n   arglist = TREE_CHAIN (arglist);\n \n@@ -4721,12 +4944,14 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       case BUILT_IN_FPUTC:\n       case BUILT_IN_FPUTS:\n       case BUILT_IN_FWRITE:\n+      case BUILT_IN_FPRINTF:\n       case BUILT_IN_PUTCHAR_UNLOCKED:\n       case BUILT_IN_PUTS_UNLOCKED:\n       case BUILT_IN_PRINTF_UNLOCKED:\n       case BUILT_IN_FPUTC_UNLOCKED:\n       case BUILT_IN_FPUTS_UNLOCKED:\n       case BUILT_IN_FWRITE_UNLOCKED:\n+      case BUILT_IN_FPRINTF_UNLOCKED:\n       case BUILT_IN_FLOOR:\n       case BUILT_IN_FLOORF:\n       case BUILT_IN_FLOORL:\n@@ -5167,13 +5392,38 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_trap ();\n       return const0_rtx;\n \n+    case BUILT_IN_PRINTF:\n+      target = expand_builtin_printf (arglist, target, mode, false);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_PRINTF_UNLOCKED:\n+      target = expand_builtin_printf (arglist, target, mode, true);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_FPUTS:\n-      target = expand_builtin_fputs (arglist, ignore,/*unlocked=*/ 0);\n+      target = expand_builtin_fputs (arglist, target, false);\n       if (target)\n \treturn target;\n       break;\n+\n     case BUILT_IN_FPUTS_UNLOCKED:\n-      target = expand_builtin_fputs (arglist, ignore,/*unlocked=*/ 1);\n+      target = expand_builtin_fputs (arglist, target, true);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_FPRINTF:\n+      target = expand_builtin_fprintf (arglist, target, mode, false);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_FPRINTF_UNLOCKED:\n+      target = expand_builtin_fprintf (arglist, target, mode, true);\n       if (target)\n \treturn target;\n       break;"}, {"sha": "e05795d5ca5fd4dff382ac01c9dda547f1c88068", "filename": "gcc/builtins.def", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=868b8cda7b2c89629d7c642db03dae1e913fdd3c", "patch": "@@ -70,9 +70,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, BT_LAST,\t\\\n                false, false, false, ATTRS, true)\n \n-\n /* A fallback builtin is a builtin (like __builtin_puts) that falls\n-   back to the corresopnding library function if necessary -- but\n+   back to the corresponding library function if necessary -- but\n    for which we should not introduce the non-`__builtin' variant of\n    the name.  */\n #undef DEF_FALLBACK_BUILTIN\t\t\t\t\n@@ -124,21 +123,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n    \t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS)\n \n-/* Like DEF_LIB_BUILTIN, except that the function is expanded in the\n-   front-end.  */\n-#undef DEF_FRONT_END_LIB_BUILTIN\t\t\t\n-#define DEF_FRONT_END_LIB_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n-  DEF_BUILTIN (ENUM, NAME, BUILT_IN_FRONTEND, TYPE, TYPE,\t\\\n-\t       true, true, false, ATTRS, true)\n-\n-/* Like DEF_FRONT_END_LIB_BUILTIN, except that the function is not one\n-   that is specified by ANSI/ISO C.  So, when we're being fully\n-   conformant we ignore the version of these builtins that does not\n-   begin with __builtin.  */\n-#undef DEF_EXT_FRONT_END_LIB_BUILTIN\t\t\t\n-#define DEF_EXT_FRONT_END_LIB_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n-  DEF_BUILTIN (ENUM, NAME, BUILT_IN_FRONTEND, TYPE, TYPE,\t\\\n-\t       true, true, true, ATTRS, true)\n \n DEF_EXT_LIB_BUILTIN(BUILT_IN_ALLOCA,\n \t\t    \"__builtin_alloca\",\n@@ -769,10 +753,10 @@ DEF_GCC_BUILTIN(BUILT_IN_PREFETCH,\n \n /* stdio.h builtins (without FILE *).  */\n \n-DEF_FRONT_END_LIB_BUILTIN(BUILT_IN_PRINTF,\n-\t\t\t  \"__builtin_printf\",\n-\t\t\t  BT_FN_INT_CONST_STRING_VAR,\n-\t\t\t  ATTR_FORMAT_PRINTF_1_2)\n+DEF_LIB_BUILTIN(BUILT_IN_PRINTF,\n+\t\t\"__builtin_printf\",\n+\t\tBT_FN_INT_CONST_STRING_VAR,\n+\t\tATTR_FORMAT_PRINTF_1_2)\n DEF_LIB_BUILTIN(BUILT_IN_PUTCHAR,\n \t\t\"__builtin_putchar\",\n \t\tBT_FN_INT_INT,\n@@ -840,10 +824,10 @@ DEF_FALLBACK_BUILTIN(BUILT_IN_FWRITE,\n \t\t     \"__builtin_fwrite\",\n \t\t     BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR,\n \t\t      ATTR_NOTHROW_NONNULL_1_4)\n-DEF_FRONT_END_LIB_BUILTIN(BUILT_IN_FPRINTF,\n-\t\t\t \"__builtin_fprintf\",\n-\t\t\t BT_FN_INT_PTR_CONST_STRING_VAR,\n-\t\t\t ATTR_FORMAT_PRINTF_2_3)\n+DEF_LIB_BUILTIN(BUILT_IN_FPRINTF,\n+\t\t\"__builtin_fprintf\",\n+\t\tBT_FN_INT_PTR_CONST_STRING_VAR,\n+\t\tATTR_FORMAT_PRINTF_2_3)\n \n /* stdio unlocked builtins (without FILE *).  */\n \n@@ -853,10 +837,10 @@ DEF_EXT_FALLBACK_BUILTIN(BUILT_IN_PUTCHAR_UNLOCKED,\n DEF_EXT_FALLBACK_BUILTIN(BUILT_IN_PUTS_UNLOCKED,\n \t\t\t \"__builtin_puts_unlocked\",\n \t\t\t BT_FN_INT_CONST_STRING, ATTR_NOTHROW_NONNULL_1)\n-DEF_EXT_FRONT_END_LIB_BUILTIN(BUILT_IN_PRINTF_UNLOCKED,\n-\t\t\t      \"__builtin_printf_unlocked\",\n-\t\t\t      BT_FN_INT_CONST_STRING_VAR,\n-\t\t\t      ATTR_FORMAT_PRINTF_1_2)\n+DEF_EXT_LIB_BUILTIN(BUILT_IN_PRINTF_UNLOCKED,\n+\t\t    \"__builtin_printf_unlocked\",\n+\t\t    BT_FN_INT_CONST_STRING_VAR,\n+\t\t    ATTR_FORMAT_PRINTF_1_2)\n \n /* stdio unlocked builtins (with FILE *).  */\n \n@@ -876,11 +860,12 @@ DEF_BUILTIN (BUILT_IN_FPUTS_UNLOCKED,\n \t     true, true, true, ATTR_NOTHROW_NONNULL_1_2, true)\n DEF_EXT_FALLBACK_BUILTIN(BUILT_IN_FWRITE_UNLOCKED,\n \t\t\t \"__builtin_fwrite_unlocked\",\n-\t\t\t BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR, ATTR_NOTHROW_NONNULL_1_4)\n-DEF_EXT_FRONT_END_LIB_BUILTIN(BUILT_IN_FPRINTF_UNLOCKED,\n-\t\t\t      \"__builtin_fprintf_unlocked\",\n-\t\t\t      BT_FN_INT_PTR_CONST_STRING_VAR,\n-\t\t\t      ATTR_FORMAT_PRINTF_2_3)\n+\t\t\t BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR,\n+\t\t\t ATTR_NOTHROW_NONNULL_1_4)\n+DEF_EXT_LIB_BUILTIN(BUILT_IN_FPRINTF_UNLOCKED,\n+\t\t    \"__builtin_fprintf_unlocked\",\n+\t\t    BT_FN_INT_PTR_CONST_STRING_VAR,\n+\t\t    ATTR_FORMAT_PRINTF_2_3)\n \n   /* ISO C99 floating point unordered comparisons.  */\n DEF_GCC_BUILTIN(BUILT_IN_ISGREATER, "}, {"sha": "2e985c2a4d2c32d4bb93fcab67363ee6b9a13923", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868b8cda7b2c89629d7c642db03dae1e913fdd3c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=868b8cda7b2c89629d7c642db03dae1e913fdd3c", "patch": "@@ -1175,14 +1175,6 @@ fix_string_type (tree value)\n   return value;\n }\n \f\n-static int is_valid_printf_arglist (tree);\n-static rtx c_expand_builtin (tree, rtx, enum machine_mode,\n-\t\t\t     enum expand_modifier);\n-static rtx c_expand_builtin_printf (tree, rtx, enum machine_mode,\n-\t\t\t\t    enum expand_modifier, int, int);\n-static rtx c_expand_builtin_fprintf (tree, rtx, enum machine_mode,\n-\t\t\t\t     enum expand_modifier, int, int);\n-\f\n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n    requires to be a constant expression.\n@@ -4053,20 +4045,6 @@ c_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier)\n       }\n       break;\n \n-    case CALL_EXPR:\n-      {\n-\tif (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-\t    && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t\t== FUNCTION_DECL)\n-\t    && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t    && (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t\t== BUILT_IN_FRONTEND))\n-\t  return c_expand_builtin (exp, target, tmode, modifier);\n-\telse\n-\t  abort ();\n-      }\n-      break;\n-\n     case COMPOUND_LITERAL_EXPR:\n       {\n \t/* Initialize the anonymous variable declared in the compound\n@@ -4135,280 +4113,6 @@ c_staticp (tree exp)\n     return 1;\n   return 0;\n }\n-\n-#define CALLED_AS_BUILT_IN(NODE) \\\n-   (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__builtin_\", 10))\n-\n-static rtx\n-c_expand_builtin (tree exp, rtx target, enum machine_mode tmode,\n-\t\t  enum expand_modifier modifier)\n-{\n-  tree type = TREE_TYPE (exp);\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  enum tree_code code = TREE_CODE (exp);\n-  const int ignore = (target == const0_rtx\n-\t\t      || ((code == NON_LVALUE_EXPR || code == NOP_EXPR\n-\t\t\t   || code == CONVERT_EXPR || code == REFERENCE_EXPR\n-\t\t\t   || code == COND_EXPR)\n-\t\t\t  && TREE_CODE (type) == VOID_TYPE));\n-\n-  if (! optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-    return expand_call (exp, target, ignore);\n-\n-  switch (fcode)\n-    {\n-    case BUILT_IN_PRINTF:\n-      target = c_expand_builtin_printf (arglist, target, tmode,\n-\t\t\t\t\tmodifier, ignore, /*unlocked=*/ 0);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_PRINTF_UNLOCKED:\n-      target = c_expand_builtin_printf (arglist, target, tmode,\n-\t\t\t\t\tmodifier, ignore, /*unlocked=*/ 1);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_FPRINTF:\n-      target = c_expand_builtin_fprintf (arglist, target, tmode,\n-\t\t\t\t\t modifier, ignore, /*unlocked=*/ 0);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_FPRINTF_UNLOCKED:\n-      target = c_expand_builtin_fprintf (arglist, target, tmode,\n-\t\t\t\t\t modifier, ignore, /*unlocked=*/ 1);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    default:\t\t\t/* just do library call, if unknown builtin */\n-      error (\"built-in function `%s' not currently supported\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n-    }\n-\n-  /* The switch statement above can drop through to cause the function\n-     to be called normally.  */\n-  return expand_call (exp, target, ignore);\n-}\n-\n-/* Check an arglist to *printf for problems.  The arglist should start\n-   at the format specifier, with the remaining arguments immediately\n-   following it.  */\n-static int\n-is_valid_printf_arglist (tree arglist)\n-{\n-  /* Save this value so we can restore it later.  */\n-  const int SAVE_pedantic = pedantic;\n-  int diagnostic_occurred = 0;\n-  tree attrs;\n-\n-  /* Set this to a known value so the user setting won't affect code\n-     generation.  */\n-  pedantic = 1;\n-  /* Check to make sure there are no format specifier errors.  */\n-  attrs = tree_cons (get_identifier (\"format\"),\n-\t\t     tree_cons (NULL_TREE,\n-\t\t\t\tget_identifier (\"printf\"),\n-\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t   integer_one_node,\n-\t\t\t\t\t   tree_cons (NULL_TREE,\n-\t\t\t\t\t\t      build_int_2 (2, 0),\n-\t\t\t\t\t\t      NULL_TREE))),\n-\t\t     NULL_TREE);\n-  check_function_format (&diagnostic_occurred, attrs, arglist);\n-\n-  /* Restore the value of `pedantic'.  */\n-  pedantic = SAVE_pedantic;\n-\n-  /* If calling `check_function_format_ptr' produces a warning, we\n-     return false, otherwise we return true.  */\n-  return ! diagnostic_occurred;\n-}\n-\n-/* If the arguments passed to printf are suitable for optimizations,\n-   we attempt to transform the call.  */\n-static rtx\n-c_expand_builtin_printf (tree arglist, rtx target, enum machine_mode tmode,\n-\t\t\t enum expand_modifier modifier, int ignore,\n-\t\t\t int unlocked)\n-{\n-  tree fn_putchar = unlocked ?\n-    implicit_built_in_decls[BUILT_IN_PUTCHAR_UNLOCKED] : implicit_built_in_decls[BUILT_IN_PUTCHAR];\n-  tree fn_puts = unlocked ?\n-    implicit_built_in_decls[BUILT_IN_PUTS_UNLOCKED] : implicit_built_in_decls[BUILT_IN_PUTS];\n-  tree fn, format_arg, stripped_string;\n-\n-  /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation.  */\n-  if (!ignore || !fn_putchar || !fn_puts)\n-    return 0;\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (arglist == 0\n-      || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE))\n-    return 0;\n-\n-  /* Check the specifier vs. the parameters.  */\n-  if (!is_valid_printf_arglist (arglist))\n-    return 0;\n-\n-  format_arg = TREE_VALUE (arglist);\n-  stripped_string = format_arg;\n-  STRIP_NOPS (stripped_string);\n-  if (stripped_string && TREE_CODE (stripped_string) == ADDR_EXPR)\n-    stripped_string = TREE_OPERAND (stripped_string, 0);\n-\n-  /* If the format specifier isn't a STRING_CST, punt.  */\n-  if (TREE_CODE (stripped_string) != STRING_CST)\n-    return 0;\n-\n-  /* OK!  We can attempt optimization.  */\n-\n-  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg2).  */\n-  if (strcmp (TREE_STRING_POINTER (stripped_string), \"%s\\n\") == 0)\n-    {\n-      arglist = TREE_CHAIN (arglist);\n-      fn = fn_puts;\n-    }\n-  /* If the format specifier was \"%c\", call __builtin_putchar (arg2).  */\n-  else if (strcmp (TREE_STRING_POINTER (stripped_string), \"%c\") == 0)\n-    {\n-      arglist = TREE_CHAIN (arglist);\n-      fn = fn_putchar;\n-    }\n-  else\n-    {\n-      /* We can't handle anything else with % args or %% ... yet.  */\n-      if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n-\treturn 0;\n-\n-      /* If the resulting constant string has a length of 1, call\n-         putchar.  Note, TREE_STRING_LENGTH includes the terminating\n-         NULL in its count.  */\n-      if (TREE_STRING_LENGTH (stripped_string) == 2)\n-        {\n-\t  /* Given printf(\"c\"), (where c is any one character,)\n-             convert \"c\"[0] to an int and pass that to the replacement\n-             function.  */\n-\t  arglist = build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0);\n-\t  arglist = build_tree_list (NULL_TREE, arglist);\n-\n-\t  fn = fn_putchar;\n-        }\n-      /* If the resulting constant was \"string\\n\", call\n-         __builtin_puts(\"string\").  Ensure \"string\" has at least one\n-         character besides the trailing \\n.  Note, TREE_STRING_LENGTH\n-         includes the terminating NULL in its count.  */\n-      else if (TREE_STRING_LENGTH (stripped_string) > 2\n-\t       && TREE_STRING_POINTER (stripped_string)\n-\t       [TREE_STRING_LENGTH (stripped_string) - 2] == '\\n')\n-        {\n-\t  /* Create a NULL-terminated string that's one char shorter\n-\t     than the original, stripping off the trailing '\\n'.  */\n-\t  const int newlen = TREE_STRING_LENGTH (stripped_string) - 1;\n-\t  char *newstr = alloca (newlen);\n-\t  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);\n-\t  newstr[newlen - 1] = 0;\n-\n-\t  arglist = fix_string_type (build_string (newlen, newstr));\n-\t  arglist = build_tree_list (NULL_TREE, arglist);\n-\t  fn = fn_puts;\n-\t}\n-      else\n-\t/* We'd like to arrange to call fputs(string) here, but we\n-           need stdout and don't have a way to get it ... yet.  */\n-\treturn 0;\n-    }\n-\n-  return expand_expr (build_function_call (fn, arglist),\n-\t\t      (ignore ? const0_rtx : target),\n-\t\t      tmode, modifier);\n-}\n-\n-/* If the arguments passed to fprintf are suitable for optimizations,\n-   we attempt to transform the call.  */\n-static rtx\n-c_expand_builtin_fprintf (tree arglist, rtx target, enum machine_mode tmode,\n-\t\t\t  enum expand_modifier modifier, int ignore,\n-\t\t\t  int unlocked)\n-{\n-  tree fn_fputc = unlocked ?\n-    implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED] : implicit_built_in_decls[BUILT_IN_FPUTC];\n-  tree fn_fputs = unlocked ?\n-    implicit_built_in_decls[BUILT_IN_FPUTS_UNLOCKED] : implicit_built_in_decls[BUILT_IN_FPUTS];\n-  tree fn, format_arg, stripped_string;\n-\n-  /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation.  */\n-  if (!ignore || !fn_fputc || !fn_fputs)\n-    return 0;\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (arglist == 0\n-      || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n-      || (TREE_CHAIN (arglist) == 0)\n-      || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) !=\n-\t  POINTER_TYPE))\n-    return 0;\n-\n-  /* Check the specifier vs. the parameters.  */\n-  if (!is_valid_printf_arglist (TREE_CHAIN (arglist)))\n-    return 0;\n-\n-  format_arg = TREE_VALUE (TREE_CHAIN (arglist));\n-  stripped_string = format_arg;\n-  STRIP_NOPS (stripped_string);\n-  if (stripped_string && TREE_CODE (stripped_string) == ADDR_EXPR)\n-    stripped_string = TREE_OPERAND (stripped_string, 0);\n-\n-  /* If the format specifier isn't a STRING_CST, punt.  */\n-  if (TREE_CODE (stripped_string) != STRING_CST)\n-    return 0;\n-\n-  /* OK!  We can attempt optimization.  */\n-\n-  /* If the format specifier was \"%s\", call __builtin_fputs(arg3, arg1).  */\n-  if (strcmp (TREE_STRING_POINTER (stripped_string), \"%s\") == 0)\n-    {\n-      tree newarglist = build_tree_list (NULL_TREE, TREE_VALUE (arglist));\n-      arglist = tree_cons (NULL_TREE,\n-\t\t\t   TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))),\n-\t\t\t   newarglist);\n-      fn = fn_fputs;\n-    }\n-  /* If the format specifier was \"%c\", call __builtin_fputc (arg3, arg1).  */\n-  else if (strcmp (TREE_STRING_POINTER (stripped_string), \"%c\") == 0)\n-    {\n-      tree newarglist = build_tree_list (NULL_TREE, TREE_VALUE (arglist));\n-      arglist = tree_cons (NULL_TREE,\n-\t\t\t   TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))),\n-\t\t\t   newarglist);\n-      fn = fn_fputc;\n-    }\n-  else\n-    {\n-      /* We can't handle anything else with % args or %% ... yet.  */\n-      if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n-\treturn 0;\n-\n-      /* When \"string\" doesn't contain %, replace all cases of\n-         fprintf(stream,string) with fputs(string,stream).  The fputs\n-         builtin will take take of special cases like length==1.  */\n-      arglist = tree_cons (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\t   build_tree_list (NULL_TREE, TREE_VALUE (arglist)));\n-      fn = fn_fputs;\n-    }\n-\n-  return expand_expr (build_function_call (fn, arglist),\n-\t\t      (ignore ? const0_rtx : target),\n-\t\t      tmode, modifier);\n-}\n \f\n \n /* Given a boolean expression ARG, return a tree representing an increment"}]}