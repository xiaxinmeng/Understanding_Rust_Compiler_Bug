{"sha": "cde30fe04594843d87226653c19dbc5e05fad7b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RlMzBmZTA0NTk0ODQzZDg3MjI2NjUzYzE5ZGJjNWUwNWZhZDdiNA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2017-11-18T07:35:18Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2017-11-18T07:35:18Z"}, "message": "hash-set.h (hash_set::empty): New.\n\n\t* hash-set.h (hash_set::empty): New.\n\t* tree-ssa-threadbackward.h: Delete.\n\t* tree-ssa-threadbackward.c (class thread_jumps): New.\n\tMove max_threaded_paths into class.\n\t(fsm_find_thread_path): Remove arguments that are now in class.\n\t(profitable_jump_thread_path): Rename to...\n\t(thread_jumps::profitable_jump_thread_path): ...this.\n\t(convert_and_register_jump_thread_path): Rename to...\n\t(thread_jumps::convert_and_register_current_path): ...this.\n\t(check_subpath_and_update_thread_path): Rename to...\n\t(thread_jumps::check_subpath_and_update_thread_path): ...this.\n\t(register_jump_thread_path_if_profitable): Rename to...\n\t(thread_jumps::register_jump_thread_path_if_profitable): ...this.\n\t(handle_phi): Rename to...\n\t(thread_jumps::handle_phi): ...this.\n\t(handle_assignment): Rename to...\n\t(thread_jumps::handle_assignment): ...this.\n\t(fsm_find_control_statement_thread_paths): Rename to...\n\t(thread_jumps::fsm_find_control_statement_thread_paths): ...this.\n\t(find_jump_threads_backwards): Rename to...\n\t(thread_jumps::find_jump_threads_backwards): ...this.\n\tInitialize path local data.\n\t(pass_thread_jumps::execute): Call find_jump_threads_backwards\n\tfrom within thread_jumps class.\n\t(pass_early_thread_jumps::execute): Same.\n\nFrom-SVN: r254913", "tree": {"sha": "b5e137d10e39d84e2c7bf7e20768a34595c91cd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5e137d10e39d84e2c7bf7e20768a34595c91cd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cde30fe04594843d87226653c19dbc5e05fad7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde30fe04594843d87226653c19dbc5e05fad7b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde30fe04594843d87226653c19dbc5e05fad7b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde30fe04594843d87226653c19dbc5e05fad7b4/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f32e0e16b20cfbbbca6c8c5c799eb22aa870700b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32e0e16b20cfbbbca6c8c5c799eb22aa870700b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32e0e16b20cfbbbca6c8c5c799eb22aa870700b"}], "stats": {"total": 337, "additions": 167, "deletions": 170}, "files": [{"sha": "2c3f733b6bb6b2641e633814fd739e27fb30e361", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde30fe04594843d87226653c19dbc5e05fad7b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde30fe04594843d87226653c19dbc5e05fad7b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cde30fe04594843d87226653c19dbc5e05fad7b4", "patch": "@@ -1,3 +1,31 @@\n+2017-11-18  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* hash-set.h (hash_set::empty): New.\n+\t* tree-ssa-threadbackward.h: Delete.\n+\t* tree-ssa-threadbackward.c (class thread_jumps): New.\n+\tMove max_threaded_paths into class.\n+\t(fsm_find_thread_path): Remove arguments that are now in class.\n+\t(profitable_jump_thread_path): Rename to...\n+\t(thread_jumps::profitable_jump_thread_path): ...this.\n+\t(convert_and_register_jump_thread_path): Rename to...\n+\t(thread_jumps::convert_and_register_current_path): ...this.\n+\t(check_subpath_and_update_thread_path): Rename to...\n+\t(thread_jumps::check_subpath_and_update_thread_path): ...this.\n+\t(register_jump_thread_path_if_profitable): Rename to...\n+\t(thread_jumps::register_jump_thread_path_if_profitable): ...this.\n+\t(handle_phi): Rename to...\n+\t(thread_jumps::handle_phi): ...this.\n+\t(handle_assignment): Rename to...\n+\t(thread_jumps::handle_assignment): ...this.\n+\t(fsm_find_control_statement_thread_paths): Rename to...\n+\t(thread_jumps::fsm_find_control_statement_thread_paths): ...this.\n+\t(find_jump_threads_backwards): Rename to...\n+\t(thread_jumps::find_jump_threads_backwards): ...this.\n+\tInitialize path local data.\n+\t(pass_thread_jumps::execute): Call find_jump_threads_backwards\n+\tfrom within thread_jumps class.\n+\t(pass_early_thread_jumps::execute): Same.\n+\n 2017-11-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.c (cgraph_node::dump): Do IPA sanity checking on IPA counts."}, {"sha": "8ce796d1c48eb918a2f42a9d51659a004010b9cf", "filename": "gcc/hash-set.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde30fe04594843d87226653c19dbc5e05fad7b4/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde30fe04594843d87226653c19dbc5e05fad7b4/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=cde30fe04594843d87226653c19dbc5e05fad7b4", "patch": "@@ -80,6 +80,10 @@ class hash_set\n \n   size_t elements () const { return m_table.elements (); }\n \n+  /* Clear the hash table.  */\n+\n+  void empty () { m_table.empty (); }\n+\n   class iterator\n   {\n   public:"}, {"sha": "6fdbc9039f99c3e3fc800197c0b91f18cd54a34f", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 135, "deletions": 145, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde30fe04594843d87226653c19dbc5e05fad7b4/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde30fe04594843d87226653c19dbc5e05fad7b4/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=cde30fe04594843d87226653c19dbc5e05fad7b4", "patch": "@@ -38,7 +38,35 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-vectorizer.h\"\n \n-static int max_threaded_paths;\n+class thread_jumps\n+{\n+ public:\n+  void find_jump_threads_backwards (basic_block bb, bool speed_p);\n+ private:\n+  edge profitable_jump_thread_path (basic_block bbi, tree name, tree arg,\n+\t\t\t\t    bool *creates_irreducible_loop);\n+  void convert_and_register_current_path (edge taken_edge);\n+  void register_jump_thread_path_if_profitable (tree name, tree arg,\n+\t\t\t\t\t\tbasic_block def_bb);\n+  void handle_assignment (gimple *stmt, tree name, basic_block def_bb);\n+  void handle_phi (gphi *phi, tree name, basic_block def_bb);\n+  void fsm_find_control_statement_thread_paths (tree name);\n+  bool check_subpath_and_update_thread_path (basic_block last_bb,\n+\t\t\t\t\t     basic_block new_bb,\n+\t\t\t\t\t     int *next_path_length);\n+\n+  /* Maximum number of BBs we are allowed to thread.  */\n+  int m_max_threaded_paths;\n+  /* Hash to keep track of seen bbs.  */\n+  hash_set<basic_block> m_visited_bbs;\n+  /* Current path we're analyzing.  */\n+  auto_vec<basic_block> m_path;\n+  /* Tracks if we have recursed through a loop PHI node.  */\n+  bool m_seen_loop_phi;\n+  /* Indicate that we could increase code size to improve the\n+     code path.  */\n+  bool m_speed_p;\n+};\n \n /* Simple helper to get the last statement from BB, which is assumed\n    to be a control statement.   Return NULL if the last statement is\n@@ -61,14 +89,15 @@ get_gimple_control_stmt (basic_block bb)\n \n /* Return true if the CFG contains at least one path from START_BB to\n    END_BB.  When a path is found, record in PATH the blocks from\n-   END_BB to START_BB.  VISITED_BBS is used to make sure we don't fall\n-   into an infinite loop.  Bound the recursion to basic blocks\n-   belonging to LOOP.  */\n+   END_BB to START_BB.  LOCAL_VISITED_BBS is used to make sure we\n+   don't fall into an infinite loop.  Bound the recursion to basic\n+   blocks belonging to LOOP.  */\n \n static bool\n fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n \t\t      vec<basic_block> &path,\n-\t\t      hash_set<basic_block> &visited_bbs, loop_p loop)\n+\t\t      hash_set<basic_block> &local_visited_bbs,\n+\t\t      loop_p loop)\n {\n   if (loop != start_bb->loop_father)\n     return false;\n@@ -79,12 +108,13 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n       return true;\n     }\n \n-  if (!visited_bbs.add (start_bb))\n+  if (!local_visited_bbs.add (start_bb))\n     {\n       edge e;\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, start_bb->succs)\n-\tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop))\n+\tif (fsm_find_thread_path (e->dest, end_bb, path, local_visited_bbs,\n+\t\t\t\t  loop))\n \t  {\n \t    path.safe_push (start_bb);\n \t    return true;\n@@ -102,16 +132,14 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n    NAME is the SSA_NAME of the variable we found to have a constant\n    value on PATH.  ARG is the constant value of NAME on that path.\n \n-   BBI will be appended to PATH when we have a profitable jump threading\n-   path.  Callers are responsible for removing BBI from PATH in that case.\n-\n-   SPEED_P indicate that we could increase code size to improve the\n-   code path.  */\n+   BBI will be appended to PATH when we have a profitable jump\n+   threading path.  Callers are responsible for removing BBI from PATH\n+   in that case.  */\n \n-static edge\n-profitable_jump_thread_path (vec<basic_block> &path,\n-\t\t\t     basic_block bbi, tree name, tree arg,\n-\t\t\t     bool speed_p, bool *creates_irreducible_loop)\n+edge\n+thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n+\t\t\t\t\t   tree arg,\n+\t\t\t\t\t   bool *creates_irreducible_loop)\n {\n   /* Note BBI is not in the path yet, hence the +1 in the test below\n      to make sure BBI is accounted for in the path length test.  */\n@@ -125,10 +153,11 @@ profitable_jump_thread_path (vec<basic_block> &path,\n      wanted by wiring up all the incoming edges.  If we run this\n      early in IPA, that might be worth doing.   For now we just\n      reject that case.  */\n-  if (path.is_empty ())\n+  if (m_path.is_empty ())\n       return NULL;\n \n-  if (path.length () + 1 > (unsigned) PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+  if (m_path.length () + 1\n+      > (unsigned) PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n@@ -137,7 +166,7 @@ profitable_jump_thread_path (vec<basic_block> &path,\n       return NULL;\n     }\n \n-  if (max_threaded_paths <= 0)\n+  if (m_max_threaded_paths <= 0)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n@@ -149,11 +178,11 @@ profitable_jump_thread_path (vec<basic_block> &path,\n   /* Add BBI to the path.\n      From this point onward, if we decide we the path is not profitable\n      to thread, we must remove BBI from the path.  */\n-  path.safe_push (bbi);\n+  m_path.safe_push (bbi);\n \n   int n_insns = 0;\n   gimple_stmt_iterator gsi;\n-  loop_p loop = path[0]->loop_father;\n+  loop_p loop = m_path[0]->loop_father;\n   bool path_crosses_loops = false;\n   bool threaded_through_latch = false;\n   bool multiway_branch_in_path = false;\n@@ -167,9 +196,9 @@ profitable_jump_thread_path (vec<basic_block> &path,\n      will have to be duplicated, we will not record the path if there\n      are too many instructions on the path.  Also check that all the\n      blocks in the path belong to a single loop.  */\n-  for (unsigned j = 0; j < path.length (); j++)\n+  for (unsigned j = 0; j < m_path.length (); j++)\n     {\n-      basic_block bb = path[j];\n+      basic_block bb = m_path[j];\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \" bb:%i\", bb->index);\n@@ -180,7 +209,7 @@ profitable_jump_thread_path (vec<basic_block> &path,\n \t loop father, nor how many statements are in that block because\n \t it will not be copied or whether or not it ends in a multiway\n \t branch.  */\n-      if (j < path.length () - 1)\n+      if (j < m_path.length () - 1)\n \t{\n \t  int orig_n_insns = n_insns;\n \t  if (bb->loop_father != loop)\n@@ -225,7 +254,7 @@ profitable_jump_thread_path (vec<basic_block> &path,\n \t\t}\n \t    }\n \n-\t  if (!contains_hot_bb && speed_p)\n+\t  if (!contains_hot_bb && m_speed_p)\n \t    contains_hot_bb |= optimize_bb_for_speed_p (bb);\n \t  for (gsi = gsi_after_labels (bb);\n \t       !gsi_end_p (gsi);\n@@ -267,7 +296,7 @@ profitable_jump_thread_path (vec<basic_block> &path,\n \tthreaded_through_latch = true;\n     }\n \n-  gimple *stmt = get_gimple_control_stmt (path[0]);\n+  gimple *stmt = get_gimple_control_stmt (m_path[0]);\n   gcc_assert (stmt);\n \n   /* We are going to remove the control statement at the end of the\n@@ -300,14 +329,14 @@ profitable_jump_thread_path (vec<basic_block> &path,\n      latch, then this thread would create an irreducible loop.\n \n      We have to know the outgoing edge to figure this out.  */\n-  edge taken_edge = find_taken_edge (path[0], arg);\n+  edge taken_edge = find_taken_edge (m_path[0], arg);\n \n   /* There are cases where we may not be able to extract the\n      taken edge.  For example, a computed goto to an absolute\n      address.  Handle those cases gracefully.  */\n   if (taken_edge == NULL)\n     {\n-      path.pop ();\n+      m_path.pop ();\n       return NULL;\n     }\n \n@@ -323,23 +352,23 @@ profitable_jump_thread_path (vec<basic_block> &path,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n \t\t \"the path crosses loops.\\n\");\n-      path.pop ();\n+      m_path.pop ();\n       return NULL;\n     }\n \n   /* Threading is profitable if the path duplicated is hot but also\n      in a case we separate cold path from hot path and permit optimization\n      of the hot path later.  Be on the agressive side here. In some testcases,\n      as in PR 78407 this leads to noticeable improvements.  */\n-  if (speed_p && (optimize_edge_for_speed_p (taken_edge) || contains_hot_bb))\n+  if (m_speed_p && (optimize_edge_for_speed_p (taken_edge) || contains_hot_bb))\n     {\n       if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n \t\t     \"the number of instructions on the path \"\n \t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n-\t  path.pop ();\n+\t  m_path.pop ();\n \t  return NULL;\n \t}\n     }\n@@ -349,7 +378,7 @@ profitable_jump_thread_path (vec<basic_block> &path,\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n \t\t \"duplication of %i insns is needed and optimizing for size.\\n\",\n \t\t n_insns);\n-      path.pop ();\n+      m_path.pop ();\n       return NULL;\n     }\n \n@@ -364,15 +393,15 @@ profitable_jump_thread_path (vec<basic_block> &path,\n      so bad.  */\n   if (!threaded_multiway_branch && *creates_irreducible_loop\n       && (n_insns * (unsigned) PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n-\t  > (path.length () *\n+\t  > (m_path.length () *\n \t     (unsigned) PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS))))\n \n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"FSM would create irreducible loop without threading \"\n \t\t \"multiway branch.\\n\");\n-      path.pop ();\n+      m_path.pop ();\n       return NULL;\n     }\n \n@@ -392,7 +421,7 @@ profitable_jump_thread_path (vec<basic_block> &path,\n \tfprintf (dump_file,\n \t\t \"FSM did not thread around loop and would copy too \"\n \t\t \"many statements.\\n\");\n-      path.pop ();\n+      m_path.pop ();\n       return NULL;\n     }\n \n@@ -406,28 +435,28 @@ profitable_jump_thread_path (vec<basic_block> &path,\n \tfprintf (dump_file,\n \t\t \"FSM Thread through multiway branch without threading \"\n \t\t \"a multiway branch.\\n\");\n-      path.pop ();\n+      m_path.pop ();\n       return NULL;\n     }\n   return taken_edge;\n }\n \n-/* PATH is vector of blocks forming a jump threading path in reverse\n-   order.  TAKEN_EDGE is the edge taken from path[0].\n+/* The current path PATH is a vector of blocks forming a jump threading\n+   path in reverse order.  TAKEN_EDGE is the edge taken from path[0].\n \n-   Convert that path into the form used by register_jump_thread and\n-   register the path.   */\n+   Convert the current path into the form used by register_jump_thread and\n+   register it.   */\n \n-static void\n-convert_and_register_jump_thread_path (vec<basic_block> &path, edge taken_edge)\n+void\n+thread_jumps::convert_and_register_current_path (edge taken_edge)\n {\n   vec<jump_thread_edge *> *jump_thread_path = new vec<jump_thread_edge *> ();\n \n   /* Record the edges between the blocks in PATH.  */\n-  for (unsigned int j = 0; j + 1 < path.length (); j++)\n+  for (unsigned int j = 0; j + 1 < m_path.length (); j++)\n     {\n-      basic_block bb1 = path[path.length () - j - 1];\n-      basic_block bb2 = path[path.length () - j - 2];\n+      basic_block bb1 = m_path[m_path.length () - j - 1];\n+      basic_block bb2 = m_path[m_path.length () - j - 2];\n \n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n@@ -441,7 +470,7 @@ convert_and_register_jump_thread_path (vec<basic_block> &path, edge taken_edge)\n   jump_thread_path->safe_push (x);\n \n   register_jump_thread (jump_thread_path);\n-  --max_threaded_paths;\n+  --m_max_threaded_paths;\n }\n \n /* While following a chain of SSA_NAME definitions, we jumped from a\n@@ -455,11 +484,10 @@ convert_and_register_jump_thread_path (vec<basic_block> &path, edge taken_edge)\n \n    Store the length of the subpath in NEXT_PATH_LENGTH.  */\n \n-static bool\n-check_subpath_and_update_thread_path (basic_block last_bb, basic_block new_bb,\n-\t\t\t\t      hash_set<basic_block> &visited_bbs,\n-\t\t\t\t      vec<basic_block> &path,\n-\t\t\t\t      int *next_path_length)\n+bool\n+thread_jumps::check_subpath_and_update_thread_path (basic_block last_bb,\n+\t\t\t\t\t\t    basic_block new_bb,\n+\t\t\t\t\t\t    int *next_path_length)\n {\n   edge e;\n   int e_count = 0;\n@@ -468,10 +496,10 @@ check_subpath_and_update_thread_path (basic_block last_bb, basic_block new_bb,\n \n   FOR_EACH_EDGE (e, ei, last_bb->preds)\n     {\n-      hash_set<basic_block> visited_bbs;\n+      hash_set<basic_block> local_visited_bbs;\n \n-      if (fsm_find_thread_path (new_bb, e->src, next_path, visited_bbs,\n-\t\t\t\te->src->loop_father))\n+      if (fsm_find_thread_path (new_bb, e->src, next_path,\n+\t\t\t\tlocal_visited_bbs, e->src->loop_father))\n \t++e_count;\n \n       /* If there is more than one path, stop.  */\n@@ -488,16 +516,16 @@ check_subpath_and_update_thread_path (basic_block last_bb, basic_block new_bb,\n      NEXT_PATH.  Don't add them here to avoid pollution.  */\n   for (unsigned int i = 0; i + 1 < next_path.length (); i++)\n     {\n-      if (visited_bbs.contains (next_path[i]))\n+      if (m_visited_bbs.contains (next_path[i]))\n \treturn false;\n     }\n \n   /* Now add the nodes to VISISTED_BBS.  */\n   for (unsigned int i = 0; i + 1 < next_path.length (); i++)\n-    visited_bbs.add (next_path[i]);\n+    m_visited_bbs.add (next_path[i]);\n \n   /* Append all the nodes from NEXT_PATH to PATH.  */\n-  path.safe_splice (next_path);\n+  m_path.safe_splice (next_path);\n   *next_path_length = next_path.length ();\n \n   return true;\n@@ -507,58 +535,37 @@ check_subpath_and_update_thread_path (basic_block last_bb, basic_block new_bb,\n \n    NAME is an SSA NAME with a possible constant value of ARG on PATH.\n \n-   DEF_BB is the basic block that ultimately defines the constant.\n+   DEF_BB is the basic block that ultimately defines the constant.  */\n \n-   SPEED_P indicate that we could increase code size to improve the\n-   code path.\n-*/\n-\n-static void\n-register_jump_thread_path_if_profitable (vec<basic_block> &path,\n-\t\t\t\t\t tree name,\n-\t\t\t\t\t tree arg,\n-\t\t\t\t\t basic_block def_bb,\n-\t\t\t\t\t bool speed_p)\n+void\n+thread_jumps::register_jump_thread_path_if_profitable (tree name, tree arg,\n+\t\t\t\t\t\t       basic_block def_bb)\n {\n   if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n     return;\n \n   bool irreducible = false;\n-  edge taken_edge = profitable_jump_thread_path (path, def_bb, name, arg,\n-\t\t\t\t\t\t speed_p, &irreducible);\n+  edge taken_edge = profitable_jump_thread_path (def_bb, name, arg,\n+\t\t\t\t\t\t &irreducible);\n   if (taken_edge)\n     {\n-      convert_and_register_jump_thread_path (path, taken_edge);\n-      path.pop ();\n+      convert_and_register_current_path (taken_edge);\n+      m_path.pop ();\n \n       if (irreducible)\n-\tvect_free_loop_info_assumptions (path[0]->loop_father);\n+\tvect_free_loop_info_assumptions (m_path[0]->loop_father);\n     }\n }\n \n-static void fsm_find_control_statement_thread_paths (tree,\n-\t\t\t\t\t\t     hash_set<basic_block> &,\n-\t\t\t\t\t\t     vec<basic_block> &,\n-\t\t\t\t\t\t     bool, bool);\n-\n /* Given PHI which defines NAME in block DEF_BB, recurse through the\n    PHI's arguments searching for paths where NAME will ultimately have\n    a constant value.\n \n-   VISITED_BBS tracks the blocks that have been encountered.\n-\n    PATH contains the series of blocks to traverse that will result in\n-   NAME having a constant value.\n-\n-   SEEN_LOOP_PHI tracks if we have recursed through a loop PHI node.\n+   NAME having a constant value.  */\n \n-   SPEED_P indicates if we are optimizing for speed over space.  */\n-\n-static void\n-handle_phi (gphi *phi, tree name, basic_block def_bb,\n-\t    hash_set<basic_block> &visited_bbs,\n-\t    vec<basic_block> &path,\n-\t    bool seen_loop_phi, bool speed_p)\n+void\n+thread_jumps::handle_phi (gphi *phi, tree name, basic_block def_bb)\n {\n   /* Iterate over the arguments of PHI.  */\n   for (unsigned int i = 0; i < gimple_phi_num_args (phi); i++)\n@@ -572,17 +579,16 @@ handle_phi (gphi *phi, tree name, basic_block def_bb,\n \n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  path.safe_push (bbi);\n+\t  m_path.safe_push (bbi);\n \t  /* Recursively follow SSA_NAMEs looking for a constant\n \t     definition.  */\n-\t  fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n-\t\t\t\t\t\t   seen_loop_phi, speed_p);\n+\t  fsm_find_control_statement_thread_paths (arg);\n \n-\t  path.pop ();\n+\t  m_path.pop ();\n \t  continue;\n \t}\n \n-      register_jump_thread_path_if_profitable (path, name, arg, bbi, speed_p);\n+      register_jump_thread_path_if_profitable (name, arg, bbi);\n     }\n }\n \n@@ -620,55 +626,38 @@ handle_assignment_p (gimple *stmt)\n    PHI's arguments searching for paths where NAME will ultimately have\n    a constant value.\n \n-   VISITED_BBS tracks the blocks that have been encountered.\n-\n    PATH contains the series of blocks to traverse that will result in\n-   NAME having a constant value.\n+   NAME having a constant value.  */\n \n-   SEEN_LOOP_PHI tracks if we have recursed through a loop PHI node.\n-\n-   SPEED_P indicates if we are optimizing for speed over space.  */\n-\n-static void\n-handle_assignment (gimple *stmt, tree name, basic_block def_bb,\n-\t\t   hash_set<basic_block> &visited_bbs,\n-\t\t   vec<basic_block> &path,\n-\t\t   bool seen_loop_phi, bool speed_p)\n+void\n+thread_jumps::handle_assignment (gimple *stmt, tree name, basic_block def_bb)\n {\n   tree arg = gimple_assign_rhs1 (stmt);\n \n   if (TREE_CODE (arg) == SSA_NAME)\n-    fsm_find_control_statement_thread_paths (arg, visited_bbs,\n-\t\t\t\t\t     path, seen_loop_phi, speed_p);\n+    fsm_find_control_statement_thread_paths (arg);\n \n   else\n     {\n       /* register_jump_thread_path_if_profitable will push the current\n \t block onto the path.  But the path will always have the current\n \t block at this point.  So we can just pop it.  */\n-      path.pop ();\n+      m_path.pop ();\n \n-      register_jump_thread_path_if_profitable (path, name, arg, def_bb,\n-\t\t\t\t\t       speed_p);\n+      register_jump_thread_path_if_profitable (name, arg, def_bb);\n \n       /* And put the current block back onto the path so that the\n \t state of the stack is unchanged when we leave.  */\n-      path.safe_push (def_bb);\n+      m_path.safe_push (def_bb);\n     }\n }\n \n /* We trace the value of the SSA_NAME NAME back through any phi nodes\n    looking for places where it gets a constant value and save the\n-   path.\n-\n-   SPEED_P indicate that we could increase code size to improve the\n-   code path.  */\n+   path.  */\n \n-static void\n-fsm_find_control_statement_thread_paths (tree name,\n-\t\t\t\t\t hash_set<basic_block> &visited_bbs,\n-\t\t\t\t\t vec<basic_block> &path,\n-\t\t\t\t\t bool seen_loop_phi, bool speed_p)\n+void\n+thread_jumps::fsm_find_control_statement_thread_paths (tree name)\n {\n   /* If NAME appears in an abnormal PHI, then don't try to trace its\n      value back through PHI nodes.  */\n@@ -697,18 +686,18 @@ fsm_find_control_statement_thread_paths (tree name,\n     return;\n \n   /* Avoid infinite recursion.  */\n-  if (visited_bbs.add (def_bb))\n+  if (m_visited_bbs.add (def_bb))\n     return;\n \n   int next_path_length = 0;\n-  basic_block last_bb_in_path = path.last ();\n+  basic_block last_bb_in_path = m_path.last ();\n \n   if (loop_containing_stmt (def_stmt)->header == gimple_bb (def_stmt))\n     {\n       /* Do not walk through more than one loop PHI node.  */\n-      if (seen_loop_phi)\n+      if (m_seen_loop_phi)\n \treturn;\n-      seen_loop_phi = true;\n+      m_seen_loop_phi = true;\n     }\n \n   /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n@@ -720,37 +709,34 @@ fsm_find_control_statement_thread_paths (tree name,\n \t will already be in VISITED_BBS.  When they are not equal, then we\n \t must ensure that first block is accounted for to ensure we do not\n \t create bogus jump threading paths.  */\n-      visited_bbs.add (path[0]);\n+      m_visited_bbs.add (m_path[0]);\n       if (!check_subpath_and_update_thread_path (last_bb_in_path, def_bb,\n-\t\t\t\t\t\t visited_bbs, path,\n \t\t\t\t\t\t &next_path_length))\n \treturn;\n     }\n \n-  gcc_assert (path.last () == def_bb);\n+  gcc_assert (m_path.last () == def_bb);\n \n   if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    handle_phi (as_a <gphi *> (def_stmt), name, def_bb,\n-\t\tvisited_bbs, path, seen_loop_phi, speed_p);\n+    handle_phi (as_a <gphi *> (def_stmt), name, def_bb);\n   else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    handle_assignment (def_stmt, name, def_bb,\n-\t\t       visited_bbs, path, seen_loop_phi, speed_p);\n+    handle_assignment (def_stmt, name, def_bb);\n \n   /* Remove all the nodes that we added from NEXT_PATH.  */\n   if (next_path_length)\n-    path.truncate (path.length () - next_path_length);\n+    m_path.truncate (m_path.length () - next_path_length);\n }\n \n /* Search backwards from BB looking for paths where NAME (an SSA_NAME)\n    is a constant.  Record such paths for jump threading.\n \n    It is assumed that BB ends with a control statement and that by\n    finding a path where NAME is a constant, we can thread the path.\n-   SPEED_P indicate that we could increase code size to improve the\n+   SPEED_P_ indicate that we could increase code size to improve the\n    code path.  */\n \n-void  \n-find_jump_threads_backwards (basic_block bb, bool speed_p)\n+void\n+thread_jumps::find_jump_threads_backwards (basic_block bb, bool speed_p)\n {     \n   gimple *stmt = get_gimple_control_stmt (bb);\n   if (!stmt)\n@@ -774,13 +760,15 @@ find_jump_threads_backwards (basic_block bb, bool speed_p)\n   if (!name || TREE_CODE (name) != SSA_NAME)\n     return;\n \n-  auto_vec<basic_block> bb_path;\n-  bb_path.safe_push (bb);\n-  hash_set<basic_block> visited_bbs;\n+  /* Initialize pass local data that's different for each BB.  */\n+  m_path.truncate (0);\n+  m_path.safe_push (bb);\n+  m_visited_bbs.empty ();\n+  m_seen_loop_phi = false;\n+  m_speed_p = speed_p;\n+  m_max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n \n-  max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n-  fsm_find_control_statement_thread_paths (name, visited_bbs, bb_path, false,\n-\t\t\t\t\t   speed_p);\n+  fsm_find_control_statement_thread_paths (name);\n }\n \n namespace {\n@@ -823,11 +811,12 @@ pass_thread_jumps::execute (function *fun)\n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n \n   /* Try to thread each block with more than one successor.  */\n+  thread_jumps threader;\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (EDGE_COUNT (bb->succs) > 1)\n-\tfind_jump_threads_backwards (bb, true);\n+\tthreader.find_jump_threads_backwards (bb, true);\n     }\n   bool changed = thread_through_all_blocks (true);\n \n@@ -883,11 +872,12 @@ pass_early_thread_jumps::execute (function *fun)\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n   /* Try to thread each block with more than one successor.  */\n+  thread_jumps threader;\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (EDGE_COUNT (bb->succs) > 1)\n-\tfind_jump_threads_backwards (bb, false);\n+\tthreader.find_jump_threads_backwards (bb, false);\n     }\n   thread_through_all_blocks (true);\n "}, {"sha": "f758ff1f1ade9c345c1f3879af5c4918d5f5fedf", "filename": "gcc/tree-ssa-threadbackward.h", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32e0e16b20cfbbbca6c8c5c799eb22aa870700b/gcc%2Ftree-ssa-threadbackward.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32e0e16b20cfbbbca6c8c5c799eb22aa870700b/gcc%2Ftree-ssa-threadbackward.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.h?ref=f32e0e16b20cfbbbca6c8c5c799eb22aa870700b", "patch": "@@ -1,25 +0,0 @@\n-/* Header file for SSA dominator optimizations.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_TREE_SSA_THREADFSM_H\n-#define GCC_TREE_SSA_THREADFSM_H\n-\n-extern void find_jump_threads_backwards (edge);\n-\n-#endif /* GCC_TREE_SSA_THREADFSM_H */"}]}