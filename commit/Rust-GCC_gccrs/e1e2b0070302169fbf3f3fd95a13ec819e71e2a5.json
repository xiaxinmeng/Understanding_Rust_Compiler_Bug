{"sha": "e1e2b0070302169fbf3f3fd95a13ec819e71e2a5", "node_id": "C_kwDOANBUbNoAKGUxZTJiMDA3MDMwMjE2OWZiZjNmM2ZkOTVhMTNlYzgxOWU3MWUyYTU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-05T21:31:50Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-03T09:29:52Z"}, "message": "ada: Fix support of Default_Component_Value aspect on derived types\n\nThe support of the Default_Component_Value aspect on derived constrained\narray types is broken because of a couple of issues: 1) the derived types\nincorrectly inherit the initialization procedure of the ancestor types\nand 2) the propagation of the aspect does not work for constrained array\ntypes (unlike for unconstrained array types).\n\ngcc/ada/\n\n\t* exp_tss.adb (Base_Init_Proc): Do not return the Init_Proc of the\n\tancestor type for a derived array type.\n\t* sem_ch13.adb (Inherit_Aspects_At_Freeze_Point): Factor out the\n\tcommon processing done on representation items.\n\tFor Default_Component_Value and Default_Value, look into the first\n\tsubtype to find out the representation items.", "tree": {"sha": "673a5901734022780dec8ae59d78801f889968aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/673a5901734022780dec8ae59d78801f889968aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fee53a3194c0d8b747486b23980f1214cc1355b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee53a3194c0d8b747486b23980f1214cc1355b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee53a3194c0d8b747486b23980f1214cc1355b9"}], "stats": {"total": 210, "additions": 133, "deletions": 77}, "files": [{"sha": "23ee3496b2380bc207dd311d7e9e62e2f1a2874d", "filename": "gcc/ada/exp_tss.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5/gcc%2Fada%2Fexp_tss.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5/gcc%2Fada%2Fexp_tss.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.adb?ref=e1e2b0070302169fbf3f3fd95a13ec819e71e2a5", "patch": "@@ -78,8 +78,11 @@ package body Exp_Tss is\n       else\n          Proc := Init_Proc (Base_Type (Full_Type), Ref);\n \n+         --  For derived record types, if the base type does not have one,\n+         --  we use the Init_Proc of the ancestor type.\n+\n          if No (Proc)\n-           and then Is_Composite_Type (Full_Type)\n+           and then Is_Record_Type (Full_Type)\n            and then Is_Derived_Type (Full_Type)\n          then\n             return Init_Proc (Root_Type (Full_Type), Ref);"}, {"sha": "e5f0ebcd6a2adb9cd97890e91b7df6da65488d4e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 129, "deletions": 76, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e2b0070302169fbf3f3fd95a13ec819e71e2a5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e1e2b0070302169fbf3f3fd95a13ec819e71e2a5", "patch": "@@ -13493,12 +13493,68 @@ package body Sem_Ch13 is\n    -------------------------------------\n \n    procedure Inherit_Aspects_At_Freeze_Point (Typ : Entity_Id) is\n+      function Get_Inherited_Rep_Item\n+        (E   : Entity_Id;\n+         Nam : Name_Id) return Node_Id;\n+      --  Search the Rep_Item chain of entity E for an instance of a rep item\n+      --  (pragma, attribute definition clause, or aspect specification) whose\n+      --  name matches the given name Nam, and that has been inherited from its\n+      --  parent, i.e. that has not been directly specified for E . If one is\n+      --  found, it is returned, otherwise Empty is returned.\n+\n+      function Get_Inherited_Rep_Item\n+        (E    : Entity_Id;\n+         Nam1 : Name_Id;\n+         Nam2 : Name_Id) return Node_Id;\n+      --  Search the Rep_Item chain of entity E for an instance of a rep item\n+      --  (pragma, attribute definition clause, or aspect specification) whose\n+      --  name matches one of the given names Nam1 or Nam2, and that has been\n+      --  inherited from its parent, i.e. that has not been directly specified\n+      --  for E . If one is found, it is returned, otherwise Empty is returned.\n+\n       function Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n         (Rep_Item : Node_Id) return Boolean;\n       --  This routine checks if Rep_Item is either a pragma or an aspect\n       --  specification node whose corresponding pragma (if any) is present in\n       --  the Rep Item chain of the entity it has been specified to.\n \n+      ----------------------------\n+      -- Get_Inherited_Rep_Item --\n+      ----------------------------\n+\n+      function Get_Inherited_Rep_Item\n+        (E   : Entity_Id;\n+         Nam : Name_Id) return Node_Id\n+      is\n+         Rep : constant Node_Id\n+                 := Get_Rep_Item (E, Nam, Check_Parents => True);\n+      begin\n+         if Present (Rep)\n+           and then not Has_Rep_Item (E, Nam, Check_Parents => False)\n+         then\n+            return Rep;\n+         else\n+            return Empty;\n+         end if;\n+      end Get_Inherited_Rep_Item;\n+\n+      function Get_Inherited_Rep_Item\n+        (E    : Entity_Id;\n+         Nam1 : Name_Id;\n+         Nam2 : Name_Id) return Node_Id\n+      is\n+         Rep : constant Node_Id\n+                 := Get_Rep_Item (E, Nam1, Nam2, Check_Parents => True);\n+      begin\n+         if Present (Rep)\n+           and then not Has_Rep_Item (E, Nam1, Nam2, Check_Parents => False)\n+         then\n+            return Rep;\n+         else\n+            return Empty;\n+         end if;\n+      end Get_Inherited_Rep_Item;\n+\n       --------------------------------------------------\n       -- Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item --\n       --------------------------------------------------\n@@ -13513,6 +13569,8 @@ package body Sem_Ch13 is\n            Present_In_Rep_Item (Entity (Rep_Item), Aspect_Rep_Item (Rep_Item));\n       end Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item;\n \n+      Rep : Node_Id;\n+\n    --  Start of processing for Inherit_Aspects_At_Freeze_Point\n \n    begin\n@@ -13543,40 +13601,36 @@ package body Sem_Ch13 is\n \n       --  Ada_05/Ada_2005\n \n-      if not Has_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005, False)\n-        and then Has_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005))\n+      Rep := Get_Inherited_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Is_Ada_2005_Only (Typ);\n       end if;\n \n       --  Ada_12/Ada_2012\n \n-      if not Has_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012, False)\n-        and then Has_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012))\n+      Rep := Get_Inherited_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Is_Ada_2012_Only (Typ);\n       end if;\n \n       --  Ada_2022\n \n-      if not Has_Rep_Item (Typ, Name_Ada_2022, False)\n-        and then Has_Rep_Item (Typ, Name_Ada_2022)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Ada_2022))\n+      Rep := Get_Inherited_Rep_Item (Typ, Name_Ada_2022);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Is_Ada_2022_Only (Typ);\n       end if;\n \n       --  Atomic/Shared\n \n-      if not Has_Rep_Item (Typ, Name_Atomic, Name_Shared, False)\n-        and then Has_Rep_Pragma (Typ, Name_Atomic, Name_Shared)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Atomic, Name_Shared))\n+      Rep := Get_Inherited_Rep_Item (Typ,  Name_Atomic, Name_Shared);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Is_Atomic (Typ);\n          Set_Is_Volatile (Typ);\n@@ -13591,87 +13645,91 @@ package body Sem_Ch13 is\n          Set_Convention (Typ, Convention (Base_Type (Typ)));\n       end if;\n \n-      --  Default_Component_Value\n+      --  Default_Component_Value (for base types only)\n \n-      --  Verify that there is no rep_item declared for the type, and there\n-      --  is one coming from an ancestor.\n+      --  Note that we need to look into the first subtype because the base\n+      --  type may be the implicit base type built by the compiler for the\n+      --  declaration of a constrained subtype with the aspect.\n \n-      if Is_Array_Type (Typ)\n-        and then Is_Base_Type (Typ)\n-        and then not Has_Rep_Item (Typ, Name_Default_Component_Value, False)\n-        and then Has_Rep_Item (Typ, Name_Default_Component_Value)\n-      then\n+      if Is_Array_Type (Typ) and then Is_Base_Type (Typ) then\n          declare\n+            F_Typ : constant Entity_Id := First_Subtype (Typ);\n+\n             E : Entity_Id;\n \n          begin\n-            E := Entity (Get_Rep_Item (Typ, Name_Default_Component_Value));\n+            Rep :=\n+              Get_Inherited_Rep_Item (F_Typ, Name_Default_Component_Value);\n+            if Present (Rep) then\n+               E := Entity (Rep);\n \n-            --  Deal with private types\n+               --  Deal with private types\n \n-            if Is_Private_Type (E) then\n-               E := Full_View (E);\n-            end if;\n+               if Is_Private_Type (E) then\n+                  E := Full_View (E);\n+               end if;\n \n-            Set_Default_Aspect_Component_Value (Typ,\n-              Default_Aspect_Component_Value (E));\n+               Set_Default_Aspect_Component_Value\n+                 (Typ, Default_Aspect_Component_Value (E));\n+               Set_Has_Default_Aspect (Typ);\n+            end if;\n          end;\n       end if;\n \n-      --  Default_Value\n+      --  Default_Value (for base types only)\n \n-      if Is_Scalar_Type (Typ)\n-        and then Is_Base_Type (Typ)\n-        and then not Has_Rep_Item (Typ, Name_Default_Value, False)\n-        and then Has_Rep_Item (Typ, Name_Default_Value)\n-      then\n-         Set_Has_Default_Aspect (Typ);\n+      --  Note that we need to look into the first subtype because the base\n+      --  type may be the implicit base type built by the compiler for the\n+      --  declaration of a constrained subtype with the aspect.\n \n+      if Is_Scalar_Type (Typ) and then Is_Base_Type (Typ) then\n          declare\n+            F_Typ : constant Entity_Id := First_Subtype (Typ);\n+\n             E : Entity_Id;\n \n          begin\n-            E := Entity (Get_Rep_Item (Typ, Name_Default_Value));\n+            Rep := Get_Inherited_Rep_Item (F_Typ, Name_Default_Value);\n+            if Present (Rep) then\n+               E := Entity (Rep);\n \n-            --  Deal with private types\n+               --  Deal with private types\n \n-            if Is_Private_Type (E) then\n-               E := Full_View (E);\n-            end if;\n+               if Is_Private_Type (E) then\n+                  E := Full_View (E);\n+               end if;\n \n-            Set_Default_Aspect_Value (Typ, Default_Aspect_Value (E));\n+               Set_Default_Aspect_Value (Typ, Default_Aspect_Value (E));\n+               Set_Has_Default_Aspect (Typ);\n+            end if;\n          end;\n       end if;\n \n       --  Discard_Names\n \n-      if not Has_Rep_Item (Typ, Name_Discard_Names, False)\n-        and then Has_Rep_Item (Typ, Name_Discard_Names)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Discard_Names))\n+      Rep := Get_Inherited_Rep_Item (Typ, Name_Discard_Names);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Discard_Names (Typ);\n       end if;\n \n       --  Volatile\n \n-      if not Has_Rep_Item (Typ, Name_Volatile, False)\n-        and then Has_Rep_Item (Typ, Name_Volatile)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Volatile))\n+      Rep := Get_Inherited_Rep_Item (Typ, Name_Volatile);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Is_Volatile (Typ);\n          Set_Treat_As_Volatile (Typ);\n       end if;\n \n       --  Volatile_Full_Access and Full_Access_Only\n \n-      if not Has_Rep_Item (Typ, Name_Volatile_Full_Access, False)\n-        and then not Has_Rep_Item (Typ, Name_Full_Access_Only, False)\n-        and then (Has_Rep_Item (Typ, Name_Volatile_Full_Access)\n-                    or else Has_Rep_Item (Typ, Name_Full_Access_Only))\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Volatile_Full_Access))\n+      Rep := Get_Inherited_Rep_Item\n+               (Typ, Name_Volatile_Full_Access, Name_Full_Access_Only);\n+      if Present (Rep)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n       then\n          Set_Is_Volatile_Full_Access (Typ);\n          Set_Is_Volatile (Typ);\n@@ -13688,48 +13746,43 @@ package body Sem_Ch13 is\n          begin\n             --  Atomic_Components\n \n-            if not Has_Rep_Item (Typ, Name_Atomic_Components, False)\n-              and then Has_Rep_Item (Typ, Name_Atomic_Components)\n-              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Atomic_Components))\n+            Rep := Get_Inherited_Rep_Item (Typ, Name_Atomic_Components);\n+            if Present (Rep)\n+              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n             then\n                Set_Has_Atomic_Components (Imp_Bas_Typ);\n             end if;\n \n             --  Volatile_Components\n \n-            if not Has_Rep_Item (Typ, Name_Volatile_Components, False)\n-              and then Has_Rep_Item (Typ, Name_Volatile_Components)\n-              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Volatile_Components))\n+            Rep := Get_Inherited_Rep_Item (Typ, Name_Volatile_Components);\n+            if Present (Rep)\n+              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n             then\n                Set_Has_Volatile_Components (Imp_Bas_Typ);\n             end if;\n \n             --  Finalize_Storage_Only\n \n-            if not Has_Rep_Pragma (Typ, Name_Finalize_Storage_Only, False)\n-              and then Has_Rep_Pragma (Typ, Name_Finalize_Storage_Only)\n-            then\n+            Rep := Get_Inherited_Rep_Item (Typ, Name_Finalize_Storage_Only);\n+            if Present (Rep) then\n                Set_Finalize_Storage_Only (Bas_Typ);\n             end if;\n \n             --  Universal_Aliasing\n \n-            if not Has_Rep_Item (Typ, Name_Universal_Aliasing, False)\n-              and then Has_Rep_Item (Typ, Name_Universal_Aliasing)\n-              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Universal_Aliasing))\n+            Rep := Get_Inherited_Rep_Item (Typ, Name_Universal_Aliasing);\n+            if Present (Rep)\n+              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item (Rep)\n             then\n                Set_Universal_Aliasing (Imp_Bas_Typ);\n             end if;\n \n             --  Bit_Order\n \n             if Is_Record_Type (Typ) and then Typ = Bas_Typ then\n-               if not Has_Rep_Item (Typ, Name_Bit_Order, False)\n-                 and then Has_Rep_Item (Typ, Name_Bit_Order)\n-               then\n+               Rep := Get_Inherited_Rep_Item (Typ, Name_Bit_Order);\n+               if Present (Rep) then\n                   Set_Reverse_Bit_Order (Bas_Typ,\n                     Reverse_Bit_Order\n                       (Implementation_Base_Type (Etype (Bas_Typ))));"}]}