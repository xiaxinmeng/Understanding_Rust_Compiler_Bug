{"sha": "bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0MDRlMWI4YzZjMGE2ZWRiMmJlNGU4NDA2MTllNjk5MmVlZjBiZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-07-18T17:04:10Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-07-18T17:04:10Z"}, "message": "[multiple changes]\n\n2013-07-18  Vladimir Makarov  <vmakarov@redhat.com>\n\t    Wei Mi  <wmi@google.com>\n\n\tPR rtl-optimization/57878\n\t* lra-assigns.c (assign_by_spills): Move non_reload_pseudos to the\n\ttop.\n\t(reload_pseudo_compare_func): Check nregs first for reload\n\tpseudos.\n\n2013-07-18  Wei Mi  <wmi@google.com>\n\n\tPR rtl-optimization/57878\n\t* g++.dg/pr57518.C: New test.\n\nFrom-SVN: r201036", "tree": {"sha": "51d7c38951680676bb379b4b4a546db8ee29b88b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51d7c38951680676bb379b4b4a546db8ee29b88b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/comments", "author": null, "committer": null, "parents": [{"sha": "d675843fa61423a8da33fb2cab4f7b82b19835f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d675843fa61423a8da33fb2cab4f7b82b19835f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d675843fa61423a8da33fb2cab4f7b82b19835f5"}], "stats": {"total": 257, "additions": 255, "deletions": 2}, "files": [{"sha": "b34c787a492055330e15b21629cc08357ebcd161", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "patch": "@@ -1,3 +1,12 @@\n+2013-07-18  Vladimir Makarov  <vmakarov@redhat.com>\n+\t    Wei Mi  <wmi@google.com>\n+\n+\tPR rtl-optimization/57878\n+\t* lra-assigns.c (assign_by_spills): Move non_reload_pseudos to the\n+\ttop.\n+\t(reload_pseudo_compare_func): Check nregs first for reload\n+\tpseudos.\n+\n 2013-07-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* tree-pass.h (pass_ipa_lto_wpa_fixup): Remove redundant decl."}, {"sha": "54ffc779f116aa3a7a82fe4604011588fbe00d6a", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "patch": "@@ -116,6 +116,11 @@ struct regno_assign_info\n /* Map regno to the corresponding regno assignment info.  */\n static struct regno_assign_info *regno_assign_info;\n \n+/* All inherited, subreg or optional pseudos created before last spill\n+   sub-pass.  Such pseudos are permitted to get memory instead of hard\n+   regs.  */\n+static bitmap_head non_reload_pseudos;\n+\n /* Process a pseudo copy with execution frequency COPY_FREQ connecting\n    REGNO1 and REGNO2 to form threads.  */\n static void\n@@ -194,6 +199,15 @@ reload_pseudo_compare_func (const void *v1p, const void *v2p)\n   if ((diff = (ira_class_hard_regs_num[cl1]\n \t       - ira_class_hard_regs_num[cl2])) != 0)\n     return diff;\n+  if ((diff\n+       = (ira_reg_class_max_nregs[cl2][lra_reg_info[r2].biggest_mode]\n+\t  - ira_reg_class_max_nregs[cl1][lra_reg_info[r1].biggest_mode])) != 0\n+      /* The code below executes rarely as nregs == 1 in most cases.\n+\t So we should not worry about using faster data structures to\n+\t check reload pseudos.  */\n+      && ! bitmap_bit_p (&non_reload_pseudos, r1)\n+      && ! bitmap_bit_p (&non_reload_pseudos, r2))\n+    return diff;\n   if ((diff = (regno_assign_info[regno_assign_info[r2].first].freq\n \t       - regno_assign_info[regno_assign_info[r1].first].freq)) != 0)\n     return diff;\n@@ -1155,7 +1169,6 @@ assign_by_spills (void)\n   rtx insn;\n   basic_block bb;\n   bitmap_head changed_insns, do_not_assign_nonreload_pseudos;\n-  bitmap_head non_reload_pseudos;\n   unsigned int u;\n   bitmap_iterator bi;\n   bool reload_p;"}, {"sha": "1a73f415b8948537b73226875db0a328279f720a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "patch": "@@ -1,3 +1,8 @@\n+2013-07-18  Wei Mi  <wmi@google.com>\n+\n+\tPR rtl-optimization/57878\n+\t* g++.dg/pr57518.C: New test.\n+\n 2013-07-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.dg/pr42611.c: Move dg-error to correct line.\n@@ -92,7 +97,7 @@\n \n \tPR target/57362\n \t* g++.dg/ext/pr57362.C: New.\n-\t\n+\n 2013-07-11  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/57631"}, {"sha": "b1aa25c486c3abf6ad52e73e6efd3554c1650b38", "filename": "gcc/testsuite/g++.dg/pr57878.C", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57878.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc404e1b8c6c0a6edb2be4e840619e6992eef0bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57878.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57878.C?ref=bc404e1b8c6c0a6edb2be4e840619e6992eef0bd", "patch": "@@ -0,0 +1,226 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-m32 -O2 -fno-omit-frame-pointer -fPIC -std=gnu++11\" } */\n+\n+typedef int int32;\n+typedef long long int64;\n+typedef unsigned int uint32;\n+typedef unsigned long long uint64;\n+namespace std {\n+  typedef unsigned int size_t;\n+  template<class _CharT>\n+  struct char_traits;\n+  template<typename _Tp>\n+  inline _Tp* __addressof(_Tp& __r) noexcept {\n+    return reinterpret_cast<_Tp*> (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));\n+  }\n+  template<typename _Tp>\n+  struct remove_reference {\n+    typedef _Tp type;\n+  };\n+  template<typename _Tp>\n+  constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept {\n+    return static_cast<_Tp&&>(__t);\n+  }\n+}\n+typedef unsigned int size_t;\n+extern \"C++\" {\n+  inline void* operator new(std::size_t, void* __p) noexcept {\n+    return __p;\n+  }\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp>\n+    class new_allocator {\n+  public:\n+    typedef size_t size_type;\n+    typedef _Tp* pointer;\n+  };\n+}\n+namespace std {\n+  template<typename _Tp>\n+  using __allocator_base = __gnu_cxx::new_allocator<_Tp>;\n+  template<typename _Tp>\n+  class allocator\n+    : public __allocator_base<_Tp> {\n+  public:\n+    typedef size_t size_type;\n+    template<typename _Tp1>\n+    struct rebind {\n+      typedef allocator<_Tp1> other;\n+    };\n+  };\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    class __sso_string_base;\n+  template<typename _CharT, typename _Traits = std::char_traits<_CharT>, typename _Alloc = std::allocator<_CharT>, template <typename, typename, typename> class _Base = __sso_string_base>\n+    class __versa_string;\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    struct __vstring_utility {\n+    typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;\n+    template<typename _Alloc1>\n+    struct _Alloc_hider\n+      : public _Alloc1 {\n+      _Alloc_hider(const _Alloc1& __a, _CharT* __ptr)\n+  : _Alloc1(__a), _M_p(__ptr) {\n+      }\n+      _CharT* _M_p;\n+    };\n+  };\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    class __sso_string_base\n+      : protected __vstring_utility<_CharT, _Traits, _Alloc> {\n+    typedef __vstring_utility<_CharT, _Traits, _Alloc> _Util_Base;\n+    typedef typename _Util_Base::_CharT_alloc_type _CharT_alloc_type;\n+    typedef typename _CharT_alloc_type::size_type size_type;\n+  private:\n+    typename _Util_Base::template _Alloc_hider<_CharT_alloc_type>\n+    _M_dataplus;\n+    size_type _M_string_length;\n+    enum {\n+      _S_local_capacity = 15 };\n+    union {\n+      _CharT _M_local_data[_S_local_capacity + 1];\n+    };\n+    template<typename _InIterator>\n+    void _M_construct(_InIterator __beg, _InIterator __end);\n+  public:\n+    size_type _M_max_size() const;\n+    _CharT* _M_data() const {\n+      return _M_dataplus._M_p;\n+    }\n+    size_type _M_length() const {\n+      return _M_string_length;\n+    }\n+    __sso_string_base(const __sso_string_base& __rcs);\n+    const _CharT_alloc_type& _M_get_allocator() const {\n+    }\n+  };\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    __sso_string_base<_CharT, _Traits, _Alloc>:: __sso_string_base(const __sso_string_base& __rcs)\n+    : _M_dataplus(__rcs._M_get_allocator(), _M_local_data) {\n+    _M_construct(__rcs._M_data(), __rcs._M_data() + __rcs._M_length());\n+  }\n+  template<typename _CharT, typename _Traits, typename _Alloc, template <typename, typename, typename> class _Base>\n+    class __versa_string\n+      : private _Base<_CharT, _Traits, _Alloc> {\n+  };\n+}\n+template<typename _CharT, typename _Traits = std::char_traits<_CharT>, typename _Alloc = std::allocator<_CharT> >\n+class basic_string\n+  : public __gnu_cxx::__versa_string<_CharT, _Traits, _Alloc> {\n+};\n+typedef basic_string<char> string;\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Alloc, typename _Tp>\n+    class __alloctr_rebind_helper {\n+  public:\n+    static const bool __value = true;\n+  };\n+  template<typename _Alloc, typename _Tp, bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>\n+    struct __alloctr_rebind;\n+  template<typename _Alloc, typename _Tp> struct __alloctr_rebind<_Alloc, _Tp, true>\n+  {\n+    typedef typename _Alloc::template rebind<_Tp>::other __type;\n+  };\n+  template<typename _Alloc>\n+    struct allocator_traits {\n+  private:\n+    template<typename _Tp>\n+    static typename _Tp::pointer _S_pointer_helper(_Tp*);\n+    typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer;\n+  public:\n+    typedef __pointer pointer;\n+    template<typename _Tp>\n+    using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;\n+  };\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Alloc> struct __alloc_traits\n+    : std::allocator_traits<_Alloc>\n+  {\n+    typedef std::allocator_traits<_Alloc> _Base_type;\n+    template<typename _Tp>\n+    struct rebind {\n+      typedef typename _Base_type::template rebind_alloc<_Tp>\n+      other;\n+    };\n+  };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _T1, typename... _Args>\n+    inline void _Construct(_T1* __p, _Args&&... __args) {\n+    ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...);\n+  }\n+  template<typename _Tp, typename _Alloc>\n+    struct _Vector_base {\n+    typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;\n+    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer pointer;\n+    struct _Vector_impl\n+      : public _Tp_alloc_type {\n+      pointer _M_start;\n+      pointer _M_finish;\n+    };\n+  public:\n+    _Vector_impl _M_impl;\n+  };\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n+    class vector\n+      : protected _Vector_base<_Tp, _Alloc> {\n+    typedef _Vector_base<_Tp, _Alloc> _Base;\n+  public:\n+    typedef _Tp value_type;\n+    typedef typename _Base::pointer pointer;\n+    typedef size_t size_type;\n+    size_type size() const;\n+    void push_back(const value_type& __x) {\n+      _M_emplace_back_aux(__x);\n+    }\n+    template<typename... _Args>\n+    void _M_emplace_back_aux(_Args&&... __args);\n+    size_type _M_check_len();\n+  };\n+  template<typename _Tp, typename _Alloc> template<typename... _Args>\n+    void vector<_Tp, _Alloc>:: _M_emplace_back_aux(_Args&&... __args) {\n+    const size_type __len = _M_check_len();\n+    pointer __new_start(static_cast<pointer>(::operator new(__len * sizeof(_Tp))));\n+    pointer __new_temp(__new_start + size());\n+    ::new((void *)__new_temp) _Tp(std::forward<_Args>(__args)...);\n+    pointer __cur = __new_start;\n+    pointer __first = this->_M_impl._M_start;\n+    pointer __last = this->_M_impl._M_finish;\n+    for (;\n+\t __first != __last;\n+\t ++__first, ++__cur) std::_Construct(std::__addressof(*__cur), *__first);\n+  }\n+}\n+using std::vector;\n+class DL {\n+public:\n+  struct ChunkId {\n+    int64 disk_id;\n+    uint64 handle;\n+    uint64 version;\n+    string capability;\n+    ChunkId();\n+  };\n+  struct ChunkInfo {\n+    ChunkId id;\n+    uint64 mtime;\n+    uint32 length;\n+    int32 space_used;\n+  };\n+};\n+class FDB {\n+  void CollectChunk(const DL::ChunkInfo& chunk, const int& location);\n+private:\n+  struct ChunkData {\n+    int location;\n+    DL::ChunkInfo chunk_info;\n+  };\n+  vector<ChunkData> chunk_data_;\n+};\n+void FDB::CollectChunk(const DL::ChunkInfo& chunk, const int& location) {\n+  ChunkData chunk_data;\n+  chunk_data_.push_back( chunk_data);\n+}"}]}