{"sha": "79a490a95b8a5c194a479dcccae76d9f0393309b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhNDkwYTk1YjhhNWMxOTRhNDc5ZGNjY2FlNzZkOWYwMzkzMzA5Yg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-08T14:21:54Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-08T14:21:54Z"}, "message": "predict.h: Convert to ISO C90 prototypes.\n\n\n\t* predict.h: Convert to ISO C90 prototypes.\n\t* predict.c: Likewise.\n\t* tree-dump.h: Likewise.\n\t* tree-dump.c: Likewise.\n\t* diagnostic.h: Likewise.\n\t* diagnostic.c: Likewise.\n\t* combine.c: Likewise.\n\n\t* rtl.h: Convert prototypes of combine.c to ISO C90.\n\nFrom-SVN: r67626", "tree": {"sha": "1a402c61c8f88ad5941bc58f486ce8f44d76cbda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a402c61c8f88ad5941bc58f486ce8f44d76cbda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79a490a95b8a5c194a479dcccae76d9f0393309b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a490a95b8a5c194a479dcccae76d9f0393309b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a490a95b8a5c194a479dcccae76d9f0393309b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a490a95b8a5c194a479dcccae76d9f0393309b/comments", "author": null, "committer": null, "parents": [{"sha": "b4fac6a0c4bb7bf4e0d31999ecdf4e43804f6a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4fac6a0c4bb7bf4e0d31999ecdf4e43804f6a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4fac6a0c4bb7bf4e0d31999ecdf4e43804f6a81"}], "stats": {"total": 1101, "additions": 395, "deletions": 706}, "files": [{"sha": "68214e9b19882911f1b727295092cce6c4f65232", "filename": "gcc/combine.c", "status": "modified", "additions": 165, "deletions": 310, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -336,86 +336,80 @@ static struct undobuf undobuf;\n \n static int n_occurrences;\n \n-static void do_SUBST\t\t\tPARAMS ((rtx *, rtx));\n-static void do_SUBST_INT\t\tPARAMS ((int *, int));\n-static void init_reg_last_arrays\tPARAMS ((void));\n-static void setup_incoming_promotions   PARAMS ((void));\n-static void set_nonzero_bits_and_sign_copies  PARAMS ((rtx, rtx, void *));\n-static int cant_combine_insn_p\tPARAMS ((rtx));\n-static int can_combine_p\tPARAMS ((rtx, rtx, rtx, rtx, rtx *, rtx *));\n-static int sets_function_arg_p\tPARAMS ((rtx));\n-static int combinable_i3pat\tPARAMS ((rtx, rtx *, rtx, rtx, int, rtx *));\n-static int contains_muldiv\tPARAMS ((rtx));\n-static rtx try_combine\t\tPARAMS ((rtx, rtx, rtx, int *));\n-static void undo_all\t\tPARAMS ((void));\n-static void undo_commit\t\tPARAMS ((void));\n-static rtx *find_split_point\tPARAMS ((rtx *, rtx));\n-static rtx subst\t\tPARAMS ((rtx, rtx, rtx, int, int));\n-static rtx combine_simplify_rtx\tPARAMS ((rtx, enum machine_mode, int, int));\n-static rtx simplify_if_then_else  PARAMS ((rtx));\n-static rtx simplify_set\t\tPARAMS ((rtx));\n-static rtx simplify_logical\tPARAMS ((rtx, int));\n-static rtx expand_compound_operation  PARAMS ((rtx));\n-static rtx expand_field_assignment  PARAMS ((rtx));\n-static rtx make_extraction\tPARAMS ((enum machine_mode, rtx, HOST_WIDE_INT,\n-\t\t\t\t\t rtx, unsigned HOST_WIDE_INT, int,\n-\t\t\t\t\t int, int));\n-static rtx extract_left_shift\tPARAMS ((rtx, int));\n-static rtx make_compound_operation  PARAMS ((rtx, enum rtx_code));\n-static int get_pos_from_mask\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t unsigned HOST_WIDE_INT *));\n-static rtx force_to_mode\tPARAMS ((rtx, enum machine_mode,\n-\t\t\t\t\t unsigned HOST_WIDE_INT, rtx, int));\n-static rtx if_then_else_cond\tPARAMS ((rtx, rtx *, rtx *));\n-static rtx known_cond\t\tPARAMS ((rtx, enum rtx_code, rtx, rtx));\n-static int rtx_equal_for_field_assignment_p PARAMS ((rtx, rtx));\n-static rtx make_field_assignment  PARAMS ((rtx));\n-static rtx apply_distributive_law  PARAMS ((rtx));\n-static rtx simplify_and_const_int  PARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t    unsigned HOST_WIDE_INT));\n-static unsigned HOST_WIDE_INT cached_nonzero_bits\n-\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static unsigned HOST_WIDE_INT nonzero_bits1\n-\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static unsigned int cached_num_sign_bit_copies\n-\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t enum machine_mode, unsigned int));\n-static unsigned int num_sign_bit_copies1\n-\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t enum machine_mode, unsigned int));\n-static int merge_outer_ops\tPARAMS ((enum rtx_code *, HOST_WIDE_INT *,\n-\t\t\t\t\t enum rtx_code, HOST_WIDE_INT,\n-\t\t\t\t\t enum machine_mode, int *));\n-static rtx simplify_shift_const\tPARAMS ((rtx, enum rtx_code, enum machine_mode,\n-\t\t\t\t\t rtx, int));\n-static int recog_for_combine\tPARAMS ((rtx *, rtx, rtx *));\n-static rtx gen_lowpart_for_combine  PARAMS ((enum machine_mode, rtx));\n-static rtx gen_binary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n-\t\t\t\t\t rtx, rtx));\n-static enum rtx_code simplify_comparison  PARAMS ((enum rtx_code, rtx *, rtx *));\n-static void update_table_tick\tPARAMS ((rtx));\n-static void record_value_for_reg  PARAMS ((rtx, rtx, rtx));\n-static void check_promoted_subreg PARAMS ((rtx, rtx));\n-static void record_dead_and_set_regs_1  PARAMS ((rtx, rtx, void *));\n-static void record_dead_and_set_regs  PARAMS ((rtx));\n-static int get_last_value_validate  PARAMS ((rtx *, rtx, int, int));\n-static rtx get_last_value\tPARAMS ((rtx));\n-static int use_crosses_set_p\tPARAMS ((rtx, int));\n-static void reg_dead_at_p_1\tPARAMS ((rtx, rtx, void *));\n-static int reg_dead_at_p\tPARAMS ((rtx, rtx));\n-static void move_deaths\t\tPARAMS ((rtx, rtx, int, rtx, rtx *));\n-static int reg_bitfield_target_p  PARAMS ((rtx, rtx));\n-static void distribute_notes\tPARAMS ((rtx, rtx, rtx, rtx));\n-static void distribute_links\tPARAMS ((rtx));\n-static void mark_used_regs_combine PARAMS ((rtx));\n-static int insn_cuid\t\tPARAMS ((rtx));\n-static void record_promoted_value PARAMS ((rtx, rtx));\n-static rtx reversed_comparison  PARAMS ((rtx, enum machine_mode, rtx, rtx));\n-static enum rtx_code combine_reversed_comparison_code PARAMS ((rtx));\n+static void do_SUBST (rtx *, rtx);\n+static void do_SUBST_INT (int *, int);\n+static void init_reg_last_arrays (void);\n+static void setup_incoming_promotions (void);\n+static void set_nonzero_bits_and_sign_copies (rtx, rtx, void *);\n+static int cant_combine_insn_p (rtx);\n+static int can_combine_p (rtx, rtx, rtx, rtx, rtx *, rtx *);\n+static int sets_function_arg_p (rtx);\n+static int combinable_i3pat (rtx, rtx *, rtx, rtx, int, rtx *);\n+static int contains_muldiv (rtx);\n+static rtx try_combine (rtx, rtx, rtx, int *);\n+static void undo_all (void);\n+static void undo_commit (void);\n+static rtx *find_split_point (rtx *, rtx);\n+static rtx subst (rtx, rtx, rtx, int, int);\n+static rtx combine_simplify_rtx (rtx, enum machine_mode, int, int);\n+static rtx simplify_if_then_else (rtx);\n+static rtx simplify_set (rtx);\n+static rtx simplify_logical (rtx, int);\n+static rtx expand_compound_operation (rtx);\n+static rtx expand_field_assignment (rtx);\n+static rtx make_extraction (enum machine_mode, rtx, HOST_WIDE_INT,\n+\t\t\t    rtx, unsigned HOST_WIDE_INT, int, int, int);\n+static rtx extract_left_shift (rtx, int);\n+static rtx make_compound_operation (rtx, enum rtx_code);\n+static int get_pos_from_mask (unsigned HOST_WIDE_INT,\n+\t\t\t      unsigned HOST_WIDE_INT *);\n+static rtx force_to_mode (rtx, enum machine_mode,\n+\t\t\t  unsigned HOST_WIDE_INT, rtx, int);\n+static rtx if_then_else_cond (rtx, rtx *, rtx *);\n+static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n+static int rtx_equal_for_field_assignment_p (rtx, rtx);\n+static rtx make_field_assignment (rtx);\n+static rtx apply_distributive_law (rtx);\n+static rtx simplify_and_const_int (rtx, enum machine_mode, rtx,\n+\t\t\t\t   unsigned HOST_WIDE_INT);\n+static unsigned HOST_WIDE_INT cached_nonzero_bits (rtx, enum machine_mode,\n+\t\t\t\t\t\t   rtx, enum machine_mode,\n+\t\t\t\t\t\t   unsigned HOST_WIDE_INT);\n+static unsigned HOST_WIDE_INT nonzero_bits1 (rtx, enum machine_mode, rtx,\n+\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t     unsigned HOST_WIDE_INT);\n+static unsigned int cached_num_sign_bit_copies (rtx, enum machine_mode, rtx,\n+\t\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\t\tunsigned int);\n+static unsigned int num_sign_bit_copies1 (rtx, enum machine_mode, rtx,\n+\t\t\t\t\t  enum machine_mode, unsigned int);\n+static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n+\t\t\t    HOST_WIDE_INT, enum machine_mode, int *);\n+static rtx simplify_shift_const\t(rtx, enum rtx_code, enum machine_mode, rtx,\n+\t\t\t\t int);\n+static int recog_for_combine (rtx *, rtx, rtx *);\n+static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n+static rtx gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);\n+static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n+static void update_table_tick (rtx);\n+static void record_value_for_reg (rtx, rtx, rtx);\n+static void check_promoted_subreg (rtx, rtx);\n+static void record_dead_and_set_regs_1 (rtx, rtx, void *);\n+static void record_dead_and_set_regs (rtx);\n+static int get_last_value_validate (rtx *, rtx, int, int);\n+static rtx get_last_value (rtx);\n+static int use_crosses_set_p (rtx, int);\n+static void reg_dead_at_p_1 (rtx, rtx, void *);\n+static int reg_dead_at_p (rtx, rtx);\n+static void move_deaths (rtx, rtx, int, rtx, rtx *);\n+static int reg_bitfield_target_p (rtx, rtx);\n+static void distribute_notes (rtx, rtx, rtx, rtx);\n+static void distribute_links (rtx);\n+static void mark_used_regs_combine (rtx);\n+static int insn_cuid (rtx);\n+static void record_promoted_value (rtx, rtx);\n+static rtx reversed_comparison (rtx, enum machine_mode, rtx, rtx);\n+static enum rtx_code combine_reversed_comparison_code (rtx);\n \f\n /* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n    insn.  The substitution can be undone by undo_all.  If INTO is already\n@@ -424,8 +418,7 @@ static enum rtx_code combine_reversed_comparison_code PARAMS ((rtx));\n    the undo table.  */\n \n static void\n-do_SUBST (into, newval)\n-     rtx *into, newval;\n+do_SUBST (rtx *into, rtx newval)\n {\n   struct undo *buf;\n   rtx oldval = *into;\n@@ -480,8 +473,7 @@ do_SUBST (into, newval)\n    not safe.  */\n \n static void\n-do_SUBST_INT (into, newval)\n-     int *into, newval;\n+do_SUBST_INT (int *into, int newval)\n {\n   struct undo *buf;\n   int oldval = *into;\n@@ -510,9 +502,7 @@ do_SUBST_INT (into, newval)\n    Return nonzero if the combiner has turned an indirect jump\n    instruction into a direct jump.  */\n int\n-combine_instructions (f, nregs)\n-     rtx f;\n-     unsigned int nregs;\n+combine_instructions (rtx f, unsigned int nregs)\n {\n   rtx insn, next;\n #ifdef HAVE_cc0\n@@ -794,7 +784,7 @@ combine_instructions (f, nregs)\n /* Wipe the reg_last_xxx arrays in preparation for another pass.  */\n \n static void\n-init_reg_last_arrays ()\n+init_reg_last_arrays (void)\n {\n   unsigned int nregs = combine_max_regno;\n \n@@ -812,7 +802,7 @@ init_reg_last_arrays ()\n /* Set up any promoted values for incoming argument registers.  */\n \n static void\n-setup_incoming_promotions ()\n+setup_incoming_promotions (void)\n {\n #ifdef PROMOTE_FUNCTION_ARGS\n   unsigned int regno;\n@@ -852,10 +842,8 @@ setup_incoming_promotions ()\n    by any set of X.  */\n \n static void\n-set_nonzero_bits_and_sign_copies (x, set, data)\n-     rtx x;\n-     rtx set;\n-     void *data ATTRIBUTE_UNUSED;\n+set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n+\t\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int num;\n \n@@ -937,12 +925,8 @@ set_nonzero_bits_and_sign_copies (x, set, data)\n    will return 1.  */\n \n static int\n-can_combine_p (insn, i3, pred, succ, pdest, psrc)\n-     rtx insn;\n-     rtx i3;\n-     rtx pred ATTRIBUTE_UNUSED;\n-     rtx succ;\n-     rtx *pdest, *psrc;\n+can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n+\t       rtx *pdest, rtx *psrc)\n {\n   int i;\n   rtx set = 0, src, dest;\n@@ -1227,8 +1211,7 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n    argument for a function in a hard register.  */\n \n static int\n-sets_function_arg_p (pat)\n-     rtx pat;\n+sets_function_arg_p (rtx pat)\n {\n   int i;\n   rtx inner_dest;\n@@ -1301,13 +1284,8 @@ sets_function_arg_p (pat)\n    Return 1 if the combination is valid, zero otherwise.  */\n \n static int\n-combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n-     rtx i3;\n-     rtx *loc;\n-     rtx i2dest;\n-     rtx i1dest;\n-     int i1_not_in_src;\n-     rtx *pi3dest_killed;\n+combinable_i3pat (rtx i3, rtx *loc, rtx i2dest, rtx i1dest,\n+\t\t  int i1_not_in_src, rtx *pi3dest_killed)\n {\n   rtx x = *loc;\n \n@@ -1387,8 +1365,7 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n    and division.  We don't count multiplications by powers of two here.  */\n \n static int\n-contains_muldiv (x)\n-     rtx x;\n+contains_muldiv (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1419,8 +1396,7 @@ contains_muldiv (x)\n    can't perform combinations.  */\n \n static int\n-cant_combine_insn_p (insn)\n-     rtx insn;\n+cant_combine_insn_p (rtx insn)\n {\n   rtx set;\n   rtx src, dest;\n@@ -1476,9 +1452,7 @@ cant_combine_insn_p (insn)\n    new direct jump instruction.  */\n \n static rtx\n-try_combine (i3, i2, i1, new_direct_jump_p)\n-     rtx i3, i2, i1;\n-     int *new_direct_jump_p;\n+try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n {\n   /* New patterns for I3 and I2, respectively.  */\n   rtx newpat, newi2pat = 0;\n@@ -2829,7 +2803,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n /* Undo all the modifications recorded in undobuf.  */\n \n static void\n-undo_all ()\n+undo_all (void)\n {\n   struct undo *undo, *next;\n \n@@ -2852,7 +2826,7 @@ undo_all ()\n    of the undos to the free list.  */\n \n static void\n-undo_commit ()\n+undo_commit (void)\n {\n   struct undo *undo, *next;\n \n@@ -2874,9 +2848,7 @@ undo_commit ()\n    two insns.  */\n \n static rtx *\n-find_split_point (loc, insn)\n-     rtx *loc;\n-     rtx insn;\n+find_split_point (rtx *loc, rtx insn)\n {\n   rtx x = *loc;\n   enum rtx_code code = GET_CODE (x);\n@@ -3291,10 +3263,7 @@ find_split_point (loc, insn)\n    by copying if `n_occurrences' is nonzero.  */\n \n static rtx\n-subst (x, from, to, in_dest, unique_copy)\n-     rtx x, from, to;\n-     int in_dest;\n-     int unique_copy;\n+subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode op0_mode = VOIDmode;\n@@ -3564,11 +3533,8 @@ subst (x, from, to, in_dest, unique_copy)\n    X is returned; IN_DEST is nonzero if we are inside a SET_DEST.  */\n \n static rtx\n-combine_simplify_rtx (x, op0_mode, last, in_dest)\n-     rtx x;\n-     enum machine_mode op0_mode;\n-     int last;\n-     int in_dest;\n+combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n+\t\t      int in_dest)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -3687,7 +3653,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\tx = gen_binary (cond_code, mode, cond, cop1);\n \t      else if (true_rtx == const0_rtx && false_rtx == const_true_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n-\t\t\t   \t\t(cond_code, cond, cop1, NULL))\n+\t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n \t\tx = gen_binary (reversed, mode, cond, cop1);\n \n@@ -3704,11 +3670,11 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t       && INTVAL (false_rtx) == - STORE_FLAG_VALUE\n \t\t       && true_rtx == const0_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n-\t\t\t   \t\t(cond_code, cond, cop1, NULL))\n+\t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n \t\tx = simplify_gen_unary (NEG, mode,\n \t\t\t\t\tgen_binary (reversed, mode,\n-\t\t\t\t\t  \t    cond, cop1),\n+\t\t\t\t\t\t    cond, cop1),\n \t\t\t\t\tmode);\n \t      else\n \t\treturn gen_rtx_IF_THEN_ELSE (mode,\n@@ -4148,10 +4114,10 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t   && flag_unsafe_math_optimizations)\n \t  || GET_CODE (XEXP (x, 0)) == FLOAT_EXTEND)\n \treturn simplify_gen_unary (GET_MODE_SIZE (GET_MODE (XEXP (XEXP (x, 0),\n-\t\t  \t\t\t\t\t    0)))\n-\t    \t\t\t   > GET_MODE_SIZE (mode)\n+\t\t\t\t\t\t\t    0)))\n+\t\t\t\t   > GET_MODE_SIZE (mode)\n \t\t\t\t   ? FLOAT_TRUNCATE : FLOAT_EXTEND,\n-\t    \t\t\t   mode,\n+\t\t\t\t   mode,\n \t\t\t\t   XEXP (XEXP (x, 0), 0), mode);\n \n       /*  (float_truncate (float x)) is (float x)  */\n@@ -4729,8 +4695,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n /* Simplify X, an IF_THEN_ELSE expression.  Return the new expression.  */\n \n static rtx\n-simplify_if_then_else (x)\n-     rtx x;\n+simplify_if_then_else (rtx x)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx cond = XEXP (x, 0);\n@@ -5063,8 +5028,7 @@ simplify_if_then_else (x)\n /* Simplify X, a SET expression.  Return the new expression.  */\n \n static rtx\n-simplify_set (x)\n-     rtx x;\n+simplify_set (rtx x)\n {\n   rtx src = SET_SRC (x);\n   rtx dest = SET_DEST (x);\n@@ -5398,9 +5362,7 @@ simplify_set (x)\n    result.  LAST is nonzero if this is the last retry.  */\n \n static rtx\n-simplify_logical (x, last)\n-     rtx x;\n-     int last;\n+simplify_logical (rtx x, int last)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx op0 = XEXP (x, 0);\n@@ -5710,8 +5672,7 @@ simplify_logical (x, last)\n    It is the inverse of this function, loosely speaking.  */\n \n static rtx\n-expand_compound_operation (x)\n-     rtx x;\n+expand_compound_operation (rtx x)\n {\n   unsigned HOST_WIDE_INT pos = 0, len;\n   int unsignedp = 0;\n@@ -5919,8 +5880,7 @@ expand_compound_operation (x)\n    support variable lengths.  */\n \n static rtx\n-expand_field_assignment (x)\n-     rtx x;\n+expand_field_assignment (rtx x)\n {\n   rtx inner;\n   rtx pos;\t\t\t/* Always counts from low bit.  */\n@@ -6070,15 +6030,9 @@ expand_field_assignment (x)\n    can't handle it.  */\n \n static rtx\n-make_extraction (mode, inner, pos, pos_rtx, len,\n-\t\t unsignedp, in_dest, in_compare)\n-     enum machine_mode mode;\n-     rtx inner;\n-     HOST_WIDE_INT pos;\n-     rtx pos_rtx;\n-     unsigned HOST_WIDE_INT len;\n-     int unsignedp;\n-     int in_dest, in_compare;\n+make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n+\t\t rtx pos_rtx, unsigned HOST_WIDE_INT len, int unsignedp,\n+\t\t int in_dest, int in_compare)\n {\n   /* This mode describes the size of the storage area\n      to fetch the overall value from.  Within that, we\n@@ -6462,9 +6416,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n    with any other operations in X.  Return X without that shift if so.  */\n \n static rtx\n-extract_left_shift (x, count)\n-     rtx x;\n-     int count;\n+extract_left_shift (rtx x, int count)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -6525,9 +6477,7 @@ extract_left_shift (x, count)\n    or a COMPARE against zero, it is COMPARE.  */\n \n static rtx\n-make_compound_operation (x, in_code)\n-     rtx x;\n-     enum rtx_code in_code;\n+make_compound_operation (rtx x, enum rtx_code in_code)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -6795,9 +6745,7 @@ make_compound_operation (x, in_code)\n    *PLEN is set to the length of the field.  */\n \n static int\n-get_pos_from_mask (m, plen)\n-     unsigned HOST_WIDE_INT m;\n-     unsigned HOST_WIDE_INT *plen;\n+get_pos_from_mask (unsigned HOST_WIDE_INT m, unsigned HOST_WIDE_INT *plen)\n {\n   /* Get the bit number of the first 1 bit from the right, -1 if none.  */\n   int pos = exact_log2 (m & -m);\n@@ -6834,12 +6782,8 @@ get_pos_from_mask (m, plen)\n    NOT, NEG, or XOR.  */\n \n static rtx\n-force_to_mode (x, mode, mask, reg, just_select)\n-     rtx x;\n-     enum machine_mode mode;\n-     unsigned HOST_WIDE_INT mask;\n-     rtx reg;\n-     int just_select;\n+force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n+\t       rtx reg, int just_select)\n {\n   enum rtx_code code = GET_CODE (x);\n   int next_select = just_select || code == XOR || code == NOT || code == NEG;\n@@ -7386,9 +7330,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n    If we return zero, we set *PTRUE and *PFALSE to X.  */\n \n static rtx\n-if_then_else_cond (x, ptrue, pfalse)\n-     rtx x;\n-     rtx *ptrue, *pfalse;\n+if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n {\n   enum machine_mode mode = GET_MODE (x);\n   enum rtx_code code = GET_CODE (x);\n@@ -7586,10 +7528,7 @@ if_then_else_cond (x, ptrue, pfalse)\n    arise with IF_THEN_ELSE expressions.  */\n \n static rtx\n-known_cond (x, cond, reg, val)\n-     rtx x;\n-     enum rtx_code cond;\n-     rtx reg, val;\n+known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx temp;\n@@ -7740,9 +7679,7 @@ known_cond (x, cond, reg, val)\n    assignment as a field assignment.  */\n \n static int\n-rtx_equal_for_field_assignment_p (x, y)\n-     rtx x;\n-     rtx y;\n+rtx_equal_for_field_assignment_p (rtx x, rtx y)\n {\n   if (x == y || rtx_equal_p (x, y))\n     return 1;\n@@ -7779,8 +7716,7 @@ rtx_equal_for_field_assignment_p (x, y)\n    We only handle the most common cases.  */\n \n static rtx\n-make_field_assignment (x)\n-     rtx x;\n+make_field_assignment (rtx x)\n {\n   rtx dest = SET_DEST (x);\n   rtx src = SET_SRC (x);\n@@ -7907,8 +7843,7 @@ make_field_assignment (x)\n    if so.  */\n \n static rtx\n-apply_distributive_law (x)\n-     rtx x;\n+apply_distributive_law (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx lhs, rhs, other;\n@@ -8034,11 +7969,8 @@ apply_distributive_law (x)\n    X is zero, we are to always construct the equivalent form.  */\n \n static rtx\n-simplify_and_const_int (x, mode, varop, constop)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx varop;\n-     unsigned HOST_WIDE_INT constop;\n+simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n+\t\t\tunsigned HOST_WIDE_INT constop)\n {\n   unsigned HOST_WIDE_INT nonzero;\n   int i;\n@@ -8162,12 +8094,9 @@ simplify_and_const_int (x, mode, varop, constop)\n    identical subexpressions on the first or the second level.  */\n \n static unsigned HOST_WIDE_INT\n-cached_nonzero_bits (x, mode, known_x, known_mode, known_ret)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx known_x;\n-     enum machine_mode known_mode;\n-     unsigned HOST_WIDE_INT known_ret;\n+cached_nonzero_bits (rtx x, enum machine_mode mode, rtx known_x,\n+\t\t     enum machine_mode known_mode,\n+\t\t     unsigned HOST_WIDE_INT known_ret)\n {\n   if (x == known_x && mode == known_mode)\n     return known_ret;\n@@ -8218,12 +8147,9 @@ cached_nonzero_bits (x, mode, known_x, known_mode, known_ret)\n    a shift, AND, or zero_extract, we can do better.  */\n \n static unsigned HOST_WIDE_INT\n-nonzero_bits1 (x, mode, known_x, known_mode, known_ret)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx known_x;\n-     enum machine_mode known_mode;\n-     unsigned HOST_WIDE_INT known_ret;\n+nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n+\t       enum machine_mode known_mode,\n+\t       unsigned HOST_WIDE_INT known_ret)\n {\n   unsigned HOST_WIDE_INT nonzero = GET_MODE_MASK (mode);\n   unsigned HOST_WIDE_INT inner_nz;\n@@ -8696,12 +8622,9 @@ nonzero_bits1 (x, mode, known_x, known_mode, known_ret)\n    first or the second level.  */\n \n static unsigned int\n-cached_num_sign_bit_copies (x, mode, known_x, known_mode, known_ret)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx known_x;\n-     enum machine_mode known_mode;\n-     unsigned int known_ret;\n+cached_num_sign_bit_copies (rtx x, enum machine_mode mode, rtx known_x,\n+\t\t\t    enum machine_mode known_mode,\n+\t\t\t    unsigned int known_ret)\n {\n   if (x == known_x && mode == known_mode)\n     return known_ret;\n@@ -8747,12 +8670,9 @@ cached_num_sign_bit_copies (x, mode, known_x, known_mode, known_ret)\n    be between 1 and the number of bits in MODE.  */\n \n static unsigned int\n-num_sign_bit_copies1 (x, mode, known_x, known_mode, known_ret)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx known_x;\n-     enum machine_mode known_mode;\n-     unsigned int known_ret;\n+num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,\n+\t\t      enum machine_mode known_mode,\n+\t\t      unsigned int known_ret)\n {\n   enum rtx_code code = GET_CODE (x);\n   unsigned int bitwidth;\n@@ -9111,10 +9031,7 @@ num_sign_bit_copies1 (x, mode, known_x, known_mode, known_ret)\n    implies that it must be called from a define_split.  */\n \n unsigned int\n-extended_count (x, mode, unsignedp)\n-     rtx x;\n-     enum machine_mode mode;\n-     int unsignedp;\n+extended_count (rtx x, enum machine_mode mode, int unsignedp)\n {\n   if (nonzero_sign_valid == 0)\n     return 0;\n@@ -9149,13 +9066,7 @@ extended_count (x, mode, unsignedp)\n    return 0 and do not change *POP0, *PCONST0, and *PCOMP_P.  */\n \n static int\n-merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n-     enum rtx_code *pop0;\n-     HOST_WIDE_INT *pconst0;\n-     enum rtx_code op1;\n-     HOST_WIDE_INT const1;\n-     enum machine_mode mode;\n-     int *pcomp_p;\n+merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1, HOST_WIDE_INT const1, enum machine_mode mode, int *pcomp_p)\n {\n   enum rtx_code op0 = *pop0;\n   HOST_WIDE_INT const0 = *pconst0;\n@@ -9273,12 +9184,9 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n    are ASHIFTRT and ROTATE, which are always done in their original mode,  */\n \n static rtx\n-simplify_shift_const (x, code, result_mode, varop, orig_count)\n-     rtx x;\n-     enum rtx_code code;\n-     enum machine_mode result_mode;\n-     rtx varop;\n-     int orig_count;\n+simplify_shift_const (rtx x, enum rtx_code code,\n+\t\t      enum machine_mode result_mode, rtx varop,\n+\t\t      int orig_count)\n {\n   enum rtx_code orig_code = code;\n   unsigned int count;\n@@ -10036,10 +9944,7 @@ simplify_shift_const (x, code, result_mode, varop, orig_count)\n    or -1.  */\n \n static int\n-recog_for_combine (pnewpat, insn, pnotes)\n-     rtx *pnewpat;\n-     rtx insn;\n-     rtx *pnotes;\n+recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n {\n   rtx pat = *pnewpat;\n   int insn_code_number;\n@@ -10144,9 +10049,7 @@ recog_for_combine (pnewpat, insn, pnotes)\n #undef gen_lowpart\n \n static rtx\n-gen_lowpart_for_combine (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n {\n   rtx result;\n \n@@ -10258,10 +10161,7 @@ gen_lowpart_for_combine (mode, x)\n    fold; if not, a new expression is allocated.  */\n \n static rtx\n-gen_binary (code, mode, op0, op1)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1;\n+gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0, rtx op1)\n {\n   rtx result;\n   rtx tem;\n@@ -10320,10 +10220,7 @@ gen_binary (code, mode, op0, op1)\n    should have been detected earlier.  Hence we ignore all such cases.  */\n \n static enum rtx_code\n-simplify_comparison (code, pop0, pop1)\n-     enum rtx_code code;\n-     rtx *pop0;\n-     rtx *pop1;\n+simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n {\n   rtx op0 = *pop0;\n   rtx op1 = *pop1;\n@@ -11470,8 +11367,7 @@ simplify_comparison (code, pop0, pop1)\n /* Like jump.c' reversed_comparison_code, but use combine infrastructure for\n    searching backward.  */\n static enum rtx_code\n-combine_reversed_comparison_code (exp)\n-     rtx exp;\n+combine_reversed_comparison_code (rtx exp)\n {\n   enum rtx_code code1 = reversed_comparison_code (exp, NULL);\n   rtx x;\n@@ -11491,9 +11387,7 @@ combine_reversed_comparison_code (exp)\n /* Return comparison with reversed code of EXP and operands OP0 and OP1.\n    Return NULL_RTX in case we fail to do the reversal.  */\n static rtx\n-reversed_comparison (exp, mode, op0, op1)\n-     rtx exp, op0, op1;\n-     enum machine_mode mode;\n+reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n {\n   enum rtx_code reversed_code = combine_reversed_comparison_code (exp);\n   if (reversed_code == UNKNOWN)\n@@ -11507,8 +11401,7 @@ reversed_comparison (exp, mode, op0, op1)\n    for each register mentioned.  Similar to mention_regs in cse.c  */\n \n static void\n-update_table_tick (x)\n-     rtx x;\n+update_table_tick (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -11579,10 +11472,7 @@ update_table_tick (x)\n    with VALUE also zero and is used to invalidate the register.  */\n \n static void\n-record_value_for_reg (reg, insn, value)\n-     rtx reg;\n-     rtx insn;\n-     rtx value;\n+record_value_for_reg (rtx reg, rtx insn, rtx value)\n {\n   unsigned int regno = REGNO (reg);\n   unsigned int endregno\n@@ -11689,9 +11579,7 @@ record_value_for_reg (reg, insn, value)\n    set is occurring.  */\n \n static void\n-record_dead_and_set_regs_1 (dest, setter, data)\n-     rtx dest, setter;\n-     void *data;\n+record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n {\n   rtx record_dead_insn = (rtx) data;\n \n@@ -11733,8 +11621,7 @@ record_dead_and_set_regs_1 (dest, setter, data)\n    subroutine call).  */\n \n static void\n-record_dead_and_set_regs (insn)\n-     rtx insn;\n+record_dead_and_set_regs (rtx insn)\n {\n   rtx link;\n   unsigned int i;\n@@ -11792,9 +11679,7 @@ record_dead_and_set_regs (insn)\n    missed because of that.  */\n \n static void\n-record_promoted_value (insn, subreg)\n-     rtx insn;\n-     rtx subreg;\n+record_promoted_value (rtx insn, rtx subreg)\n {\n   rtx links, set;\n   unsigned int regno = REGNO (SUBREG_REG (subreg));\n@@ -11836,9 +11721,7 @@ record_promoted_value (insn, subreg)\n    note what it implies to the registers used in it.  */\n \n static void\n-check_promoted_subreg (insn, x)\n-     rtx insn;\n-     rtx x;\n+check_promoted_subreg (rtx insn, rtx x)\n {\n   if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n       && GET_CODE (SUBREG_REG (x)) == REG)\n@@ -11875,11 +11758,7 @@ check_promoted_subreg (insn, x)\n    we don't know exactly what registers it was produced from.  */\n \n static int\n-get_last_value_validate (loc, insn, tick, replace)\n-     rtx *loc;\n-     rtx insn;\n-     int tick;\n-     int replace;\n+get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n {\n   rtx x = *loc;\n   const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n@@ -11979,8 +11858,7 @@ get_last_value_validate (loc, insn, tick, replace)\n    is known longer known reliably.  */\n \n static rtx\n-get_last_value (x)\n-     rtx x;\n+get_last_value (rtx x)\n {\n   unsigned int regno;\n   rtx value;\n@@ -12044,9 +11922,7 @@ get_last_value (x)\n    that is set in an instruction more recent than FROM_CUID.  */\n \n static int\n-use_crosses_set_p (x, from_cuid)\n-     rtx x;\n-     int from_cuid;\n+use_crosses_set_p (rtx x, int from_cuid)\n {\n   const char *fmt;\n   int i;\n@@ -12104,10 +11980,7 @@ static int reg_dead_flag;\n    reg_dead_flag to 1 if X is a CLOBBER and to -1 it is a SET.  */\n \n static void\n-reg_dead_at_p_1 (dest, x, data)\n-     rtx dest;\n-     rtx x;\n-     void *data ATTRIBUTE_UNUSED;\n+reg_dead_at_p_1 (rtx dest, rtx x, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned int regno, endregno;\n \n@@ -12131,9 +12004,7 @@ reg_dead_at_p_1 (dest, x, data)\n    must be assumed to be always live.  */\n \n static int\n-reg_dead_at_p (reg, insn)\n-     rtx reg;\n-     rtx insn;\n+reg_dead_at_p (rtx reg, rtx insn)\n {\n   basic_block block;\n   unsigned int i;\n@@ -12192,8 +12063,7 @@ reg_dead_at_p (reg, insn)\n    that in flow.c, but much simpler since we don't care about pseudos.  */\n \n static void\n-mark_used_regs_combine (x)\n-     rtx x;\n+mark_used_regs_combine (rtx x)\n {\n   RTX_CODE code = GET_CODE (x);\n   unsigned int regno;\n@@ -12298,9 +12168,7 @@ mark_used_regs_combine (x)\n    Return the note used to record the death, if there was one.  */\n \n rtx\n-remove_death (regno, insn)\n-     unsigned int regno;\n-     rtx insn;\n+remove_death (unsigned int regno, rtx insn)\n {\n   rtx note = find_regno_note (insn, REG_DEAD, regno);\n \n@@ -12324,12 +12192,8 @@ remove_death (regno, insn)\n    notes will then be distributed as needed.  */\n \n static void\n-move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n-     rtx x;\n-     rtx maybe_kill_insn;\n-     int from_cuid;\n-     rtx to_insn;\n-     rtx *pnotes;\n+move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n+\t     rtx *pnotes)\n {\n   const char *fmt;\n   int len, i;\n@@ -12497,9 +12361,7 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n    pattern of an insn.  X must be a REG.  */\n \n static int\n-reg_bitfield_target_p (x, body)\n-     rtx x;\n-     rtx body;\n+reg_bitfield_target_p (rtx x, rtx body)\n {\n   int i;\n \n@@ -12548,10 +12410,7 @@ reg_bitfield_target_p (x, body)\n    on the type of note.  */\n \n static void\n-distribute_notes (notes, from_insn, i3, i2)\n-     rtx notes;\n-     rtx from_insn;\n-     rtx i3, i2;\n+distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n {\n   rtx note, next_note;\n   rtx tem;\n@@ -13106,8 +12965,7 @@ distribute_notes (notes, from_insn, i3, i2)\n    add a link pointing at I3 when I3's destination is changed.  */\n \n static void\n-distribute_links (links)\n-     rtx links;\n+distribute_links (rtx links)\n {\n   rtx link, next_link;\n \n@@ -13195,8 +13053,7 @@ distribute_links (links)\n /* Compute INSN_CUID for INSN, which is an insn made by combine.  */\n \n static int\n-insn_cuid (insn)\n-     rtx insn;\n+insn_cuid (rtx insn)\n {\n   while (insn != 0 && INSN_UID (insn) > max_uid_cuid\n \t && GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE)\n@@ -13209,8 +13066,7 @@ insn_cuid (insn)\n }\n \f\n void\n-dump_combine_stats (file)\n-     FILE *file;\n+dump_combine_stats (FILE *file)\n {\n   fnotice\n     (file,\n@@ -13219,8 +13075,7 @@ dump_combine_stats (file)\n }\n \n void\n-dump_combine_total_stats (file)\n-     FILE *file;\n+dump_combine_total_stats (FILE *file)\n {\n   fnotice\n     (file,"}, {"sha": "674f5e3c2cd3ac1fb327b759b80f356e1e5c054f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 93, "deletions": 169, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -45,46 +45,44 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define prefix_was_emitted_for(BUFFER) (BUFFER)->state.emitted_prefix_p\n \n /* Prototypes.  */\n-static void output_flush PARAMS ((output_buffer *));\n-static void output_do_verbatim PARAMS ((output_buffer *, text_info *));\n-static void output_buffer_to_stream PARAMS ((output_buffer *));\n-static void output_format PARAMS ((output_buffer *, text_info *));\n-static void output_indent PARAMS ((output_buffer *));\n+static void output_flush (output_buffer *);\n+static void output_do_verbatim (output_buffer *, text_info *);\n+static void output_buffer_to_stream (output_buffer *);\n+static void output_format (output_buffer *, text_info *);\n+static void output_indent (output_buffer *);\n \n-static char *build_message_string PARAMS ((const char *, ...))\n+static char *build_message_string (const char *, ...)\n      ATTRIBUTE_PRINTF_1;\n-static void format_with_decl PARAMS ((output_buffer *, text_info *, tree));\n-static void diagnostic_for_decl PARAMS ((diagnostic_context *,\n-\t\t\t\t\t diagnostic_info *, tree));\n-static void set_real_maximum_length PARAMS ((output_buffer *));\n-\n-static void output_unsigned_decimal PARAMS ((output_buffer *, unsigned int));\n-static void output_long_decimal PARAMS ((output_buffer *, long int));\n-static void output_long_unsigned_decimal PARAMS ((output_buffer *,\n-\t\t\t\t\t\t  long unsigned int));\n-static void output_octal PARAMS ((output_buffer *, unsigned int));\n-static void output_long_octal PARAMS ((output_buffer *, unsigned long int));\n-static void output_hexadecimal PARAMS ((output_buffer *, unsigned int));\n-static void output_long_hexadecimal PARAMS ((output_buffer *,\n-\t\t\t\t\t     unsigned long int));\n-static void output_append_r PARAMS ((output_buffer *, const char *, int));\n-static void wrap_text PARAMS ((output_buffer *, const char *, const char *));\n-static void maybe_wrap_text PARAMS ((output_buffer *, const char *,\n-\t\t\t\t     const char *));\n-static void output_clear_data PARAMS ((output_buffer *));\n-\n-static void default_diagnostic_starter PARAMS ((diagnostic_context *,\n-                                                diagnostic_info *));\n-static void default_diagnostic_finalizer PARAMS ((diagnostic_context *,\n-                                                  diagnostic_info *));\n-\n-static void error_recursion PARAMS ((diagnostic_context *)) ATTRIBUTE_NORETURN;\n-static bool text_specifies_location PARAMS ((text_info *, location_t *));\n-static bool diagnostic_count_diagnostic PARAMS ((diagnostic_context *,\n-                                                 diagnostic_info *));\n-static void diagnostic_action_after_output PARAMS ((diagnostic_context *,\n-\t\t\t\t\t\t    diagnostic_info *));\n-static void real_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n+static void format_with_decl (output_buffer *, text_info *, tree);\n+static void diagnostic_for_decl (diagnostic_context *, diagnostic_info *,\n+\t\t\t\t tree);\n+static void set_real_maximum_length (output_buffer *);\n+\n+static void output_unsigned_decimal (output_buffer *, unsigned int);\n+static void output_long_decimal (output_buffer *, long int);\n+static void output_long_unsigned_decimal (output_buffer *,\n+\t\t\t\t\t  long unsigned int);\n+static void output_octal (output_buffer *, unsigned int);\n+static void output_long_octal (output_buffer *, unsigned long int);\n+static void output_hexadecimal (output_buffer *, unsigned int);\n+static void output_long_hexadecimal (output_buffer *, unsigned long int);\n+static void output_append_r (output_buffer *, const char *, int);\n+static void wrap_text (output_buffer *, const char *, const char *);\n+static void maybe_wrap_text (output_buffer *, const char *, const char *);\n+static void output_clear_data (output_buffer *);\n+\n+static void default_diagnostic_starter (diagnostic_context *,\n+\t\t\t\t\tdiagnostic_info *);\n+static void default_diagnostic_finalizer (diagnostic_context *,\n+\t\t\t\t\t  diagnostic_info *);\n+\n+static void error_recursion (diagnostic_context *) ATTRIBUTE_NORETURN;\n+static bool text_specifies_location (text_info *, location_t *);\n+static bool diagnostic_count_diagnostic (diagnostic_context *,\n+\t\t\t\t\t diagnostic_info *);\n+static void diagnostic_action_after_output (diagnostic_context *,\n+\t\t\t\t\t    diagnostic_info *);\n+static void real_abort (void) ATTRIBUTE_NORETURN;\n \n extern int rtl_dump_and_exit;\n extern int warnings_are_errors;\n@@ -103,8 +101,7 @@ See %s for instructions.\\n\"\n /* Subroutine of output_set_maximum_length.  Set up BUFFER's\n    internal maximum characters per line.  */\n static void\n-set_real_maximum_length (buffer)\n-     output_buffer *buffer;\n+set_real_maximum_length (output_buffer *buffer)\n {\n   /* If we're told not to wrap lines then do the obvious thing.  In case\n    we'll emit prefix only once per diagnostic message, it is appropriate\n@@ -129,19 +126,15 @@ set_real_maximum_length (buffer)\n /* Sets the number of maximum characters per line BUFFER can output\n    in line-wrapping mode.  A LENGTH value 0 suppresses line-wrapping.  */\n void\n-output_set_maximum_length (buffer, length)\n-     output_buffer *buffer;\n-     int length;\n+output_set_maximum_length (output_buffer *buffer, int length)\n {\n   output_line_cutoff (buffer) = length;\n   set_real_maximum_length (buffer);\n }\n \n /* Sets BUFFER's PREFIX.  */\n void\n-output_set_prefix (buffer, prefix)\n-     output_buffer *buffer;\n-     const char *prefix;\n+output_set_prefix (output_buffer *buffer, const char *prefix)\n {\n   buffer->state.prefix = prefix;\n   set_real_maximum_length (buffer);\n@@ -152,8 +145,7 @@ output_set_prefix (buffer, prefix)\n /*  Return a pointer to the last character emitted in the output\n     BUFFER area.  A NULL pointer means no character available.  */\n const char *\n-output_last_position (buffer)\n-     const output_buffer *buffer;\n+output_last_position (const output_buffer *buffer)\n {\n   const char *p = NULL;\n \n@@ -164,8 +156,7 @@ output_last_position (buffer)\n \n /* Free BUFFER's prefix, a previously malloc'd string.  */\n void\n-output_destroy_prefix (buffer)\n-     output_buffer *buffer;\n+output_destroy_prefix (output_buffer *buffer)\n {\n   if (buffer->state.prefix != NULL)\n     {\n@@ -176,17 +167,15 @@ output_destroy_prefix (buffer)\n \n /* Zero out any text output so far in BUFFER.  */\n void\n-output_clear_message_text (buffer)\n-     output_buffer *buffer;\n+output_clear_message_text (output_buffer *buffer)\n {\n   obstack_free (&buffer->obstack, obstack_base (&buffer->obstack));\n   output_text_length (buffer) = 0;\n }\n \n /* Zero out any formatting data used so far by BUFFER.  */\n static void\n-output_clear_data (buffer)\n-     output_buffer *buffer;\n+output_clear_data (output_buffer *buffer)\n {\n   prefix_was_emitted_for (buffer) = false;\n   output_indentation (buffer) = 0;\n@@ -195,10 +184,8 @@ output_clear_data (buffer)\n /* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH\n    characters per line.  */\n void\n-init_output_buffer (buffer, prefix, maximum_length)\n-     output_buffer *buffer;\n-     const char *prefix;\n-     int maximum_length;\n+init_output_buffer (output_buffer *buffer, const char *prefix,\n+\t\t    int maximum_length)\n {\n   memset (buffer, 0, sizeof (output_buffer));\n   obstack_init (&buffer->obstack);\n@@ -212,8 +199,7 @@ init_output_buffer (buffer, prefix, maximum_length)\n \n /* Reinitialize BUFFER.  */\n void\n-output_clear (buffer)\n-     output_buffer *buffer;\n+output_clear (output_buffer *buffer)\n {\n   output_clear_message_text (buffer);\n   output_clear_data (buffer);\n@@ -222,8 +208,7 @@ output_clear (buffer)\n /* Finishes constructing a NULL-terminated character string representing\n    the BUFFERed message.  */\n const char *\n-output_finalize_message (buffer)\n-     output_buffer *buffer;\n+output_finalize_message (output_buffer *buffer)\n {\n   obstack_1grow (&buffer->obstack, '\\0');\n   return output_message_text (buffer);\n@@ -232,16 +217,14 @@ output_finalize_message (buffer)\n /* Return the amount of characters BUFFER can accept to\n    make a full line.  */\n int\n-output_space_left (buffer)\n-     const output_buffer *buffer;\n+output_space_left (const output_buffer *buffer)\n {\n   return line_wrap_cutoff (buffer) - output_text_length (buffer);\n }\n \n /* Write out BUFFER's prefix.  */\n void\n-output_emit_prefix (buffer)\n-     output_buffer *buffer;\n+output_emit_prefix (output_buffer *buffer)\n {\n   if (buffer->state.prefix != NULL)\n     {\n@@ -273,18 +256,15 @@ output_emit_prefix (buffer)\n \n /* Have BUFFER start a new line.  */\n void\n-output_add_newline (buffer)\n-     output_buffer *buffer;\n+output_add_newline (output_buffer *buffer)\n {\n   obstack_1grow (&buffer->obstack, '\\n');\n   output_text_length (buffer) = 0;\n }\n \n /* Appends a character to BUFFER.  */\n void\n-output_add_character (buffer, c)\n-     output_buffer *buffer;\n-     int c;\n+output_add_character (output_buffer *buffer, int c)\n {\n   if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n     output_add_newline (buffer);\n@@ -294,8 +274,7 @@ output_add_character (buffer, c)\n \n /* Adds a space to BUFFER.  */\n void\n-output_add_space (buffer)\n-     output_buffer *buffer;\n+output_add_space (output_buffer *buffer)\n {\n   if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n     {\n@@ -309,9 +288,7 @@ output_add_space (buffer)\n /* These functions format an INTEGER into BUFFER as suggested by their\n    names.  */\n void\n-output_decimal (buffer, i)\n-     output_buffer *buffer;\n-     int i;\n+output_decimal (output_buffer *buffer, int i)\n {\n   output_formatted_scalar (buffer, \"%d\", i);\n }\n@@ -367,10 +344,7 @@ output_pointer (output_buffer *buffer, void *p)\n /* Append to BUFFER a string specified by its STARTING character\n    and LENGTH.  */\n static void\n-output_append_r (buffer, start, length)\n-     output_buffer *buffer;\n-     const char *start;\n-     int length;\n+output_append_r (output_buffer *buffer, const char *start, int length)\n {\n   obstack_grow (&buffer->obstack, start, length);\n   output_text_length (buffer) += length;\n@@ -381,10 +355,7 @@ output_append_r (buffer, start, length)\n    and skip any leading whitespace if appropriate.  The caller must ensure\n    that it is safe to do so.  */\n void\n-output_append (buffer, start, end)\n-     output_buffer *buffer;\n-     const char *start;\n-     const char *end;\n+output_append (output_buffer *buffer, const char *start, const char *end)\n {\n   /* Emit prefix and skip whitespace if we're starting a new line.  */\n   if (is_starting_newline (buffer))\n@@ -401,8 +372,7 @@ output_append (buffer, start, end)\n    the current indentation level, assuming that a newline has just\n    been written to the buffer.  */\n static void\n-output_indent (buffer)\n-     output_buffer *buffer;\n+output_indent (output_buffer *buffer)\n {\n   int n = output_indentation (buffer);\n   int i;\n@@ -413,10 +383,7 @@ output_indent (buffer)\n \n /* Wrap a text delimited by START and END into BUFFER.  */\n static void\n-wrap_text (buffer, start, end)\n-     output_buffer *buffer;\n-     const char *start;\n-     const char *end;\n+wrap_text (output_buffer *buffer, const char *start, const char *end)\n {\n   bool is_wrapping = output_is_line_wrapping (buffer);\n \n@@ -448,10 +415,7 @@ wrap_text (buffer, start, end)\n \n /* Same as wrap_text but wrap text only when in line-wrapping mode.  */\n static void\n-maybe_wrap_text (buffer, start, end)\n-     output_buffer *buffer;\n-     const char *start;\n-     const char *end;\n+maybe_wrap_text (output_buffer *buffer, const char *start, const char *end)\n {\n   if (output_is_line_wrapping (buffer))\n     wrap_text (buffer, start, end);\n@@ -463,18 +427,14 @@ maybe_wrap_text (buffer, start, end)\n /* Append a STRING to BUFFER; the STRING might be line-wrapped if in\n    appropriate mode.  */\n void\n-output_add_string (buffer, str)\n-     output_buffer *buffer;\n-     const char *str;\n+output_add_string (output_buffer *buffer, const char *str)\n {\n   maybe_wrap_text (buffer, str, str + (str ? strlen (str) : 0));\n }\n \n /* Append an identifier ID to BUFFER.  */\n void\n-output_add_identifier (buffer, id)\n-     output_buffer *buffer;\n-     tree id;\n+output_add_identifier (output_buffer *buffer, tree id)\n {\n   output_append (buffer, IDENTIFIER_POINTER (id),\n \t\t IDENTIFIER_POINTER (id) + IDENTIFIER_LENGTH (id));\n@@ -484,8 +444,7 @@ output_add_identifier (buffer, id)\n    and reinitialize.  */\n \n static void\n-output_buffer_to_stream (buffer)\n-     output_buffer *buffer;\n+output_buffer_to_stream (output_buffer *buffer)\n {\n   const char *text = output_finalize_message (buffer);\n   fputs (text, output_buffer_attached_stream (buffer));\n@@ -507,9 +466,7 @@ output_buffer_to_stream (buffer)\n    %*.s: a substring the length of which is specified by an integer.\n    %H: location_t.  */\n static void\n-output_format (buffer, text)\n-     output_buffer *buffer;\n-     text_info *text;\n+output_format (output_buffer *buffer, text_info *text)\n {\n   for (; *text->format_spec; ++text->format_spec)\n     {\n@@ -650,8 +607,7 @@ build_message_string (const char *msg, ...)\n \n /* Same as diagnostic_build_prefix, but only the source FILE is given.  */\n char *\n-file_name_as_prefix (f)\n-     const char *f;\n+file_name_as_prefix (const char *f)\n {\n   return build_message_string (\"%s: \", f);\n }\n@@ -673,10 +629,7 @@ output_printf (struct output_buffer *buffer, const char *msgid, ...)\n \n /* Print a message relevant to the given DECL.  */\n static void\n-format_with_decl (buffer, text, decl)\n-     output_buffer *buffer;\n-     text_info *text;\n-     tree decl;\n+format_with_decl (output_buffer *buffer, text_info *text, tree decl)\n {\n   const char *p;\n \n@@ -722,8 +675,7 @@ format_with_decl (buffer, text, decl)\n \n /* Flush the content of BUFFER onto the attached stream.  */\n static void\n-output_flush (buffer)\n-     output_buffer *buffer;\n+output_flush (output_buffer *buffer)\n {\n   output_buffer_to_stream (buffer);\n   output_clear_data (buffer);\n@@ -734,9 +686,7 @@ output_flush (buffer)\n /* Helper subroutine of output_verbatim and verbatim. Do the appropriate\n    settings needed by BUFFER for a verbatim formatting.  */\n static void\n-output_do_verbatim (buffer, text)\n-     output_buffer *buffer;\n-     text_info *text;\n+output_do_verbatim (output_buffer *buffer, text_info *text)\n {\n   diagnostic_prefixing_rule_t rule = output_prefixing_rule (buffer);\n   int line_cutoff = output_line_cutoff (buffer);\n@@ -769,8 +719,7 @@ output_verbatim (output_buffer *buffer, const char *msgid, ...)\n \f\n /* Initialize the diagnostic message outputting machinery.  */\n void\n-diagnostic_initialize (context)\n-     diagnostic_context *context;\n+diagnostic_initialize (diagnostic_context *context)\n {\n   memset (context, 0, sizeof *context);\n   obstack_init (&context->buffer.obstack);\n@@ -790,9 +739,7 @@ diagnostic_initialize (context)\n    for a location_t.  If so, update the object pointed by LOCUS to reflect\n    the specified location in *TEXT->args_ptr.  */\n static bool\n-text_specifies_location (text, locus)\n-     text_info *text;\n-     location_t *locus;\n+text_specifies_location (text_info *text, location_t *locus)\n {\n   const char *p;\n   /* Skip any leading text.  */\n@@ -811,13 +758,9 @@ text_specifies_location (text, locus)\n }\n \n void\n-diagnostic_set_info (diagnostic, msgid, args, file, line, kind)\n-     diagnostic_info *diagnostic;\n-     const char *msgid;\n-     va_list *args;\n-     const char *file;\n-     int line;\n-     diagnostic_t kind;\n+diagnostic_set_info (diagnostic_info *diagnostic, const char *msgid,\n+\t\t     va_list *args, const char *file,  int line,\n+\t\t     diagnostic_t kind)\n {\n   diagnostic->message.err_no = errno;\n   diagnostic->message.args_ptr = args;\n@@ -835,8 +778,7 @@ diagnostic_set_info (diagnostic, msgid, args, file, line, kind)\n /* Return a malloc'd string describing a location.  The caller is\n    responsible for freeing the memory.  */\n char *\n-diagnostic_build_prefix (diagnostic)\n-     diagnostic_info *diagnostic;\n+diagnostic_build_prefix (diagnostic_info *diagnostic)\n {\n   static const char *const diagnostic_kind_text[] = {\n #define DEFINE_DIAGNOSTIC_KIND(K, T) (T),\n@@ -857,18 +799,16 @@ diagnostic_build_prefix (diagnostic)\n }\n \n void\n-diagnostic_flush_buffer (context)\n-     diagnostic_context *context;\n+diagnostic_flush_buffer (diagnostic_context *context)\n {\n   output_buffer_to_stream (&context->buffer);\n   fflush (output_buffer_attached_stream (&context->buffer));\n }\n \n /* Count a diagnostic.  Return true if the message should be printed.  */\n static bool\n-diagnostic_count_diagnostic (context, diagnostic)\n-    diagnostic_context *context;\n-    diagnostic_info *diagnostic;\n+diagnostic_count_diagnostic (diagnostic_context *context,\n+\t\t\t     diagnostic_info *diagnostic)\n {\n   diagnostic_t kind = diagnostic->kind;\n   switch (kind)\n@@ -930,9 +870,8 @@ diagnostic_count_diagnostic (context, diagnostic)\n /* Take any action which is expected to happen after the diagnostic\n    is written out.  This function does not always return.  */\n static void\n-diagnostic_action_after_output (context, diagnostic)\n-     diagnostic_context *context;\n-     diagnostic_info *diagnostic;\n+diagnostic_action_after_output (diagnostic_context *context,\n+\t\t\t\tdiagnostic_info *diagnostic)\n {\n   switch (diagnostic->kind)\n     {\n@@ -970,8 +909,7 @@ diagnostic_action_after_output (context, diagnostic)\n /* Called when the start of a function definition is parsed,\n    this function prints on stderr the name of the function.  */\n void\n-announce_function (decl)\n-     tree decl;\n+announce_function (tree decl)\n {\n   if (!quiet_flag)\n     {\n@@ -988,9 +926,7 @@ announce_function (decl)\n /* The default function to print out name of current function that caused\n    an error.  */\n void\n-lhd_print_error_function (context, file)\n-     diagnostic_context *context;\n-     const char *file;\n+lhd_print_error_function (diagnostic_context *context, const char *file)\n {\n   if (diagnostic_last_function_changed (context))\n     {\n@@ -1026,16 +962,14 @@ lhd_print_error_function (context, file)\n   We ignore the FILE parameter, as it cannot be relied upon.  */\n \n void\n-diagnostic_report_current_function (context)\n-     diagnostic_context *context;\n+diagnostic_report_current_function (diagnostic_context *context)\n {\n   diagnostic_report_current_module (context);\n   (*lang_hooks.print_error_function) (context, input_filename);\n }\n \n void\n-diagnostic_report_current_module (context)\n-     diagnostic_context *context;\n+diagnostic_report_current_module (diagnostic_context *context)\n {\n   struct file_stack *p;\n \n@@ -1063,9 +997,8 @@ diagnostic_report_current_module (context)\n }\n \n static void\n-default_diagnostic_starter (context, diagnostic)\n-     diagnostic_context *context;\n-     diagnostic_info *diagnostic;\n+default_diagnostic_starter (diagnostic_context *context,\n+\t\t\t    diagnostic_info *diagnostic)\n {\n   diagnostic_report_current_function (context);\n   output_set_prefix (&context->buffer, diagnostic_build_prefix (diagnostic));\n@@ -1086,9 +1019,8 @@ default_diagnostic_finalizer (context, diagnostic)\n    in the documentation of output_format.  */\n \n void\n-diagnostic_report_diagnostic (context, diagnostic)\n-     diagnostic_context *context;\n-     diagnostic_info *diagnostic;\n+diagnostic_report_diagnostic (diagnostic_context *context,\n+\t\t\t      diagnostic_info *diagnostic)\n {\n   if (context->lock++)\n     error_recursion (context);\n@@ -1109,10 +1041,8 @@ diagnostic_report_diagnostic (context, diagnostic)\n    MSG is a format string which uses %s to substitute the declaration\n    name; subsequent substitutions are a la output_format.  */\n static void\n-diagnostic_for_decl (context, diagnostic, decl)\n-     diagnostic_context *context;\n-     diagnostic_info *diagnostic;\n-     tree decl;\n+diagnostic_for_decl (diagnostic_context *context,\n+\t\t     diagnostic_info *diagnostic, tree decl)\n {\n   if (context->lock++)\n     error_recursion (context);\n@@ -1135,8 +1065,7 @@ diagnostic_for_decl (context, diagnostic, decl)\n    instead of `Internal compiler error in ../../GCC/gcc/expr.c'.  */\n \n const char *\n-trim_filename (name)\n-     const char *name;\n+trim_filename (const char *name)\n {\n   static const char this_file[] = __FILE__;\n   const char *p = name, *q = this_file;\n@@ -1390,8 +1319,7 @@ fnotice (FILE *file, const char *msgid, ...)\n \n /* Warn about a use of an identifier which was marked deprecated.  */\n void\n-warn_deprecated_use (node)\n-     tree node;\n+warn_deprecated_use (tree node)\n {\n   if (node == 0 || !warn_deprecated_decl)\n     return;\n@@ -1433,8 +1361,7 @@ warn_deprecated_use (node)\n    This mustn't use internal_error, that will cause infinite recursion.  */\n \n static void\n-error_recursion (context)\n-     diagnostic_context *context;\n+error_recursion (diagnostic_context *context)\n {\n   if (context->lock < 3)\n     output_flush (&context->buffer);\n@@ -1450,10 +1377,7 @@ error_recursion (context)\n    code generally, thanks to a special macro.  */\n \n void\n-fancy_abort (file, line, function)\n-     const char *file;\n-     int line;\n-     const char *function;\n+fancy_abort (const char *file, int line, const char *function)\n {\n   internal_error (\"in %s, at %s:%d\", function, trim_filename (file), line);\n }\n@@ -1462,8 +1386,8 @@ fancy_abort (file, line, function)\n    this file, so that there are no functions after it that call abort\n    and get the system abort instead of our macro.  */\n #undef abort\n-static void \n-real_abort ()\n+static void\n+real_abort (void)\n {\n   abort ();\n }"}, {"sha": "6e5d7faf1cae9e327ccb8e38c1777e935f01e44f", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -99,7 +99,7 @@ typedef struct\n    an output_buffer.  A client-supplied formatter returns true if everything\n    goes well.  */\n typedef struct output_buffer output_buffer;\n-typedef bool (*printer_fn) PARAMS ((output_buffer *, text_info *));\n+typedef bool (*printer_fn) (output_buffer *, text_info *);\n \n /* The output buffer datatype.  This is best seen as an abstract datatype\n    whose fields should not be accessed directly by clients.  */\n@@ -171,8 +171,8 @@ struct output_buffer\n \n /*  Forward declarations.  */\n typedef struct diagnostic_context diagnostic_context;\n-typedef void (*diagnostic_starter_fn) PARAMS ((diagnostic_context *,\n-                                               diagnostic_info *));\n+typedef void (*diagnostic_starter_fn) (diagnostic_context *,\n+\t\t\t\t       diagnostic_info *);\n typedef diagnostic_starter_fn diagnostic_finalizer_fn;\n \n /* This data structure bundles altogether any information relevant to\n@@ -207,7 +207,7 @@ struct diagnostic_context\n   diagnostic_finalizer_fn end_diagnostic;\n \n   /* Client hook to report an internal error.  */\n-  void (*internal_error) PARAMS ((const char *, va_list *));\n+  void (*internal_error) (const char *, va_list *);\n \n   /* Function of last diagnostic message; more generally, function such that\n      if next diagnostic message is in it then we don't have to mention the\n@@ -291,45 +291,39 @@ extern diagnostic_context *global_dc;\n #define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)\n \n /* Diagnostic related functions.  */\n-extern void diagnostic_initialize\tPARAMS ((diagnostic_context *));\n-extern void diagnostic_report_current_module PARAMS ((diagnostic_context *));\n-extern void diagnostic_report_current_function PARAMS ((diagnostic_context *));\n-extern void diagnostic_flush_buffer\tPARAMS ((diagnostic_context *));\n-extern void diagnostic_report_diagnostic PARAMS ((diagnostic_context *,\n-                                                 diagnostic_info *));\n-extern void diagnostic_set_info         PARAMS ((diagnostic_info *,\n-                                                 const char *, va_list *,\n-                                                 const char *, int,\n-                                                 diagnostic_t));\n-extern char *diagnostic_build_prefix    PARAMS ((diagnostic_info *));\n+extern void diagnostic_initialize (diagnostic_context *);\n+extern void diagnostic_report_current_module (diagnostic_context *);\n+extern void diagnostic_report_current_function (diagnostic_context *);\n+extern void diagnostic_flush_buffer (diagnostic_context *);\n+extern void diagnostic_report_diagnostic (diagnostic_context *,\n+\t\t\t\t\t  diagnostic_info *);\n+extern void diagnostic_set_info (diagnostic_info *, const char *, va_list *,\n+\t\t\t\t const char *, int, diagnostic_t);\n+extern char *diagnostic_build_prefix (diagnostic_info *);\n \n /* Pure text formatting support functions.  */\n-extern void init_output_buffer\t\tPARAMS ((output_buffer *,\n-\t\t\t\t\t\t const char *, int));\n-extern void output_clear\t\tPARAMS ((output_buffer *));\n-extern const char *output_last_position PARAMS ((const output_buffer *));\n-extern void output_set_prefix\t\tPARAMS ((output_buffer *,\n-\t\t\t\t\t\t const char *));\n-extern void output_destroy_prefix\tPARAMS ((output_buffer *));\n-extern void output_set_maximum_length   PARAMS ((output_buffer *, int));\n-extern void output_emit_prefix\t\tPARAMS ((output_buffer *));\n-extern void output_add_newline\t\tPARAMS ((output_buffer *));\n-extern void output_add_space\t\tPARAMS ((output_buffer *));\n-extern int output_space_left\t\tPARAMS ((const output_buffer *));\n-extern void output_append\t\tPARAMS ((output_buffer *, const char *,\n-\t\t\t\t\t\t const char *));\n-extern void output_add_character\tPARAMS ((output_buffer *, int));\n-extern void output_decimal\t\tPARAMS ((output_buffer *, int));\n-extern void output_add_string\t\tPARAMS ((output_buffer *,\n-\t\t\t\t\t\t const char *));\n-extern void output_add_identifier\tPARAMS ((output_buffer *, tree));\n-extern const char *output_finalize_message PARAMS ((output_buffer *));\n-extern void output_clear_message_text\tPARAMS ((output_buffer *));\n-extern void output_printf\t\tPARAMS ((output_buffer *, const char *,\n-\t\t\t\t\t\t ...)) ATTRIBUTE_PRINTF_2;\n+extern void init_output_buffer (output_buffer *, const char *, int);\n+extern void output_clear (output_buffer *);\n+extern const char *output_last_position (const output_buffer *);\n+extern void output_set_prefix (output_buffer *, const char *);\n+extern void output_destroy_prefix (output_buffer *);\n+extern void output_set_maximum_length (output_buffer *, int);\n+extern void output_emit_prefix (output_buffer *);\n+extern void output_add_newline (output_buffer *);\n+extern void output_add_space (output_buffer *);\n+extern int output_space_left (const output_buffer *);\n+extern void output_append (output_buffer *, const char *, const char *);\n+extern void output_add_character (output_buffer *, int);\n+extern void output_decimal (output_buffer *, int);\n+extern void output_add_string (output_buffer *, const char *);\n+extern void output_add_identifier (output_buffer *, tree);\n+extern const char *output_finalize_message (output_buffer *);\n+extern void output_clear_message_text (output_buffer *);\n+extern void output_printf (output_buffer *, const char *, ...)\n+     ATTRIBUTE_PRINTF_2;\n extern void output_verbatim (output_buffer *, const char *, ...);\n extern void verbatim (const char *, ...);\n-extern char *file_name_as_prefix\tPARAMS ((const char *));\n-extern void inform                      PARAMS ((const char *, ...));\n+extern char *file_name_as_prefix (const char *);\n+extern void inform (const char *, ...);\n \n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "e42eed04f1e32b1975dcfa465f5c226cd9c7a054", "filename": "gcc/predict.c", "status": "modified", "additions": 58, "deletions": 95, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -65,25 +65,21 @@ static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n #define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n-static bool predicted_by_p\t\t PARAMS ((basic_block,\n-\t\t\t\t\t\t  enum br_predictor));\n-static void combine_predictions_for_insn PARAMS ((rtx, basic_block));\n-static void dump_prediction\t\t PARAMS ((enum br_predictor, int,\n-\t\t\t\t\t\t  basic_block, int));\n-static void estimate_loops_at_level\t PARAMS ((struct loop *loop));\n-static void propagate_freq\t\t PARAMS ((struct loop *));\n-static void estimate_bb_frequencies\t PARAMS ((struct loops *));\n-static void counts_to_freqs\t\t PARAMS ((void));\n-static void process_note_predictions\t PARAMS ((basic_block, int *,\n-\t\t\t\t\t\t  dominance_info,\n-\t\t\t\t\t\t  dominance_info));\n-static void process_note_prediction\t PARAMS ((basic_block, int *, \n-\t\t\t\t\t\t  dominance_info,\n-\t\t\t\t\t\t  dominance_info, int, int));\n-static bool last_basic_block_p           PARAMS ((basic_block));\n-static void compute_function_frequency\t PARAMS ((void));\n-static void choose_function_section\t PARAMS ((void));\n-static bool can_predict_insn_p\t\t PARAMS ((rtx));\n+static bool predicted_by_p (basic_block, enum br_predictor);\n+static void combine_predictions_for_insn (rtx, basic_block);\n+static void dump_prediction (enum br_predictor, int, basic_block, int);\n+static void estimate_loops_at_level (struct loop *loop);\n+static void propagate_freq (struct loop *);\n+static void estimate_bb_frequencies (struct loops *);\n+static void counts_to_freqs (void);\n+static void process_note_predictions (basic_block, int *, dominance_info,\n+\t\t\t\t      dominance_info);\n+static void process_note_prediction (basic_block, int *, dominance_info,\n+\t\t\t\t     dominance_info, int, int);\n+static bool last_basic_block_p (basic_block);\n+static void compute_function_frequency (void);\n+static void choose_function_section (void);\n+static bool can_predict_insn_p (rtx);\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -117,8 +113,7 @@ static const struct predictor_info predictor_info[]= {\n    for maximal performance.  */\n \n bool\n-maybe_hot_bb_p (bb)\n-     basic_block bb;\n+maybe_hot_bb_p (basic_block bb)\n {\n   if (profile_info && flag_branch_probabilities\n       && (bb->count\n@@ -132,8 +127,7 @@ maybe_hot_bb_p (bb)\n /* Return true in case BB is cold and should be optimized for size.  */\n \n bool\n-probably_cold_bb_p (bb)\n-     basic_block bb;\n+probably_cold_bb_p (basic_block bb)\n {\n   if (profile_info && flag_branch_probabilities\n       && (bb->count\n@@ -146,8 +140,7 @@ probably_cold_bb_p (bb)\n \n /* Return true in case BB is probably never executed.  */\n bool\n-probably_never_executed_bb_p (bb)\n-\tbasic_block bb;\n+probably_never_executed_bb_p (basic_block bb)\n {\n   if (profile_info && flag_branch_probabilities)\n     return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n@@ -158,9 +151,7 @@ probably_never_executed_bb_p (bb)\n    PREDICTOR.  */\n \n static bool\n-predicted_by_p (bb, predictor)\n-     basic_block bb;\n-     enum br_predictor predictor;\n+predicted_by_p (basic_block bb, enum br_predictor predictor)\n {\n   rtx note;\n   if (!INSN_P (bb->end))\n@@ -173,10 +164,7 @@ predicted_by_p (bb, predictor)\n }\n \n void\n-predict_insn (insn, predictor, probability)\n-     rtx insn;\n-     int probability;\n-     enum br_predictor predictor;\n+predict_insn (rtx insn, enum br_predictor predictor, int probability)\n {\n   if (!any_condjump_p (insn))\n     abort ();\n@@ -194,10 +182,8 @@ predict_insn (insn, predictor, probability)\n /* Predict insn by given predictor.  */\n \n void\n-predict_insn_def (insn, predictor, taken)\n-     rtx insn;\n-     enum br_predictor predictor;\n-     enum prediction taken;\n+predict_insn_def (rtx insn, enum br_predictor predictor,\n+\t\t  enum prediction taken)\n {\n    int probability = predictor_info[(int) predictor].hitrate;\n \n@@ -210,10 +196,7 @@ predict_insn_def (insn, predictor, taken)\n /* Predict edge E with given probability if possible.  */\n \n void\n-predict_edge (e, predictor, probability)\n-     edge e;\n-     int probability;\n-     enum br_predictor predictor;\n+predict_edge (edge e, enum br_predictor predictor, int probability)\n {\n   rtx last_insn;\n   last_insn = e->src->end;\n@@ -234,8 +217,7 @@ predict_edge (e, predictor, probability)\n    At the moment we represent predictions only on conditional\n    jumps, not at computed jump or other complicated cases.  */\n static bool\n-can_predict_insn_p (insn)\n-\trtx insn;\n+can_predict_insn_p (rtx insn)\n {\n   return (GET_CODE (insn) == JUMP_INSN\n \t  && any_condjump_p (insn)\n@@ -245,10 +227,8 @@ can_predict_insn_p (insn)\n /* Predict edge E by given predictor if possible.  */\n \n void\n-predict_edge_def (e, predictor, taken)\n-     edge e;\n-     enum br_predictor predictor;\n-     enum prediction taken;\n+predict_edge_def (edge e, enum br_predictor predictor,\n+\t\t  enum prediction taken)\n {\n    int probability = predictor_info[(int) predictor].hitrate;\n \n@@ -262,8 +242,7 @@ predict_edge_def (e, predictor, taken)\n    to be done each time we invert the condition used by the jump.  */\n \n void\n-invert_br_probabilities (insn)\n-     rtx insn;\n+invert_br_probabilities (rtx insn)\n {\n   rtx note;\n \n@@ -278,11 +257,8 @@ invert_br_probabilities (insn)\n /* Dump information about the branch prediction to the output file.  */\n \n static void\n-dump_prediction (predictor, probability, bb, used)\n-     enum br_predictor predictor;\n-     int probability;\n-     basic_block bb;\n-     int used;\n+dump_prediction (enum br_predictor predictor, int probability,\n+\t\t basic_block bb, int used)\n {\n   edge e = bb->succ;\n \n@@ -315,9 +291,7 @@ dump_prediction (predictor, probability, bb, used)\n    note if not already present.  Remove now useless REG_BR_PRED notes.  */\n \n static void\n-combine_predictions_for_insn (insn, bb)\n-     rtx insn;\n-     basic_block bb;\n+combine_predictions_for_insn (rtx insn, basic_block bb)\n {\n   rtx prob_note = find_reg_note (insn, REG_BR_PROB, 0);\n   rtx *pnote = &REG_NOTES (insn);\n@@ -417,8 +391,7 @@ combine_predictions_for_insn (insn, bb)\n    predictions).  */\n \n void\n-estimate_probability (loops_info)\n-     struct loops *loops_info;\n+estimate_probability (struct loops *loops_info)\n {\n   dominance_info dominators, post_dominators;\n   basic_block bb;\n@@ -657,7 +630,7 @@ estimate_probability (loops_info)\n    values.  */\n \n void\n-expected_value_to_br_prob ()\n+expected_value_to_br_prob (void)\n {\n   rtx insn, cond, ev = NULL_RTX, ev_reg = NULL_RTX;\n \n@@ -725,11 +698,10 @@ expected_value_to_br_prob ()\n     }\n }\n \f\n-/* Check whether this is the last basic block of function.  Commonly tehre\n-   is one extra common cleanup block.  */\n+/* Check whether this is the last basic block of function.  Commonly\n+   there is one extra common cleanup block.  */\n static bool\n-last_basic_block_p (bb)\n-     basic_block bb;\n+last_basic_block_p (basic_block bb)\n {\n   if (bb == EXIT_BLOCK_PTR)\n     return false;\n@@ -740,20 +712,17 @@ last_basic_block_p (bb)\n \t      && bb->succ->dest->next_bb == EXIT_BLOCK_PTR));\n }\n \n-/* Sets branch probabilities according to PREDiction and FLAGS. HEADS[bb->index]\n-   should be index of basic block in that we need to alter branch predictions\n-   (i.e. the first of our dominators such that we do not post-dominate it)\n-   (but we fill this information on demand, so -1 may be there in case this\n-   was not needed yet).  */\n+/* Sets branch probabilities according to PREDiction and\n+   FLAGS. HEADS[bb->index] should be index of basic block in that we\n+   need to alter branch predictions (i.e. the first of our dominators\n+   such that we do not post-dominate it) (but we fill this information\n+   on demand, so -1 may be there in case this was not needed yet).  */\n \n static void\n-process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n-     basic_block bb;\n-     int *heads;\n-     dominance_info dominators;\n-     dominance_info post_dominators;\n-     int pred;\n-     int flags;\n+process_note_prediction (basic_block bb, int *heads,\n+\t\t\t dominance_info dominators,\n+\t\t\t dominance_info post_dominators, int pred,\n+\t\t\t int flags)\n {\n   edge e;\n   int y;\n@@ -809,11 +778,9 @@ process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n    process_note_prediction.  */\n \n static void\n-process_note_predictions (bb, heads, dominators, post_dominators)\n-     basic_block bb;\n-     int *heads;\n-     dominance_info dominators;\n-     dominance_info post_dominators;\n+process_note_predictions (basic_block bb, int *heads,\n+\t\t\t  dominance_info dominators,\n+\t\t\t  dominance_info post_dominators)\n {\n   rtx insn;\n   edge e;\n@@ -871,7 +838,7 @@ process_note_predictions (bb, heads, dominators, post_dominators)\n    branch probabilities.  */\n \n void\n-note_prediction_to_br_prob ()\n+note_prediction_to_br_prob (void)\n {\n   basic_block bb;\n   dominance_info post_dominators, dominators;\n@@ -936,8 +903,7 @@ typedef struct edge_info_def\n    Propagate the frequencies for LOOP.  */\n \n static void\n-propagate_freq (loop)\n-     struct loop *loop;\n+propagate_freq (struct loop *loop)\n {\n   basic_block head = loop->header;\n   basic_block bb;\n@@ -1019,7 +985,7 @@ propagate_freq (loop)\n \t\t\t  sizeof (real_almost_one));\n \t\t}\n \n-\t      /* BLOCK_INFO (bb)->frequency = frequency \n+\t      /* BLOCK_INFO (bb)->frequency = frequency\n \t\t\t\t\t      / (1 - cyclic_probability) */\n \n \t      sreal_sub (&cyclic_probability, &real_one, &cyclic_probability);\n@@ -1068,8 +1034,7 @@ propagate_freq (loop)\n /* Estimate probabilities of loopback edges in loops at same nest level.  */\n \n static void\n-estimate_loops_at_level (first_loop)\n-     struct loop *first_loop;\n+estimate_loops_at_level (struct loop *first_loop)\n {\n   struct loop *loop;\n \n@@ -1080,7 +1045,7 @@ estimate_loops_at_level (first_loop)\n       unsigned i;\n \n       estimate_loops_at_level (loop->inner);\n-      \n+\n       if (loop->latch->succ)  /* Do not do this for dummy function loop.  */\n \t{\n \t  /* Find current loop back edge and mark it.  */\n@@ -1099,7 +1064,7 @@ estimate_loops_at_level (first_loop)\n /* Convert counts measured by profile driven feedback to frequencies.  */\n \n static void\n-counts_to_freqs ()\n+counts_to_freqs (void)\n {\n   gcov_type count_max = 1;\n   basic_block bb;\n@@ -1117,8 +1082,7 @@ counts_to_freqs ()\n    function can execute at average to be still considered not expensive.  */\n \n bool\n-expensive_function_p (threshold)\n-\tint threshold;\n+expensive_function_p (int threshold)\n {\n   unsigned int sum = 0;\n   basic_block bb;\n@@ -1157,8 +1121,7 @@ expensive_function_p (threshold)\n /* Estimate basic blocks frequency by given branch probabilities.  */\n \n static void\n-estimate_bb_frequencies (loops)\n-     struct loops *loops;\n+estimate_bb_frequencies (struct loops *loops)\n {\n   basic_block bb;\n   sreal freq_max;\n@@ -1256,7 +1219,7 @@ estimate_bb_frequencies (loops)\n \n /* Decide whether function is hot, cold or unlikely executed.  */\n static void\n-compute_function_frequency ()\n+compute_function_frequency (void)\n {\n   basic_block bb;\n \n@@ -1277,12 +1240,12 @@ compute_function_frequency ()\n \n /* Choose appropriate section for the function.  */\n static void\n-choose_function_section ()\n+choose_function_section (void)\n {\n   if (DECL_SECTION_NAME (current_function_decl)\n       || !targetm.have_named_sections\n       /* Theoretically we can split the gnu.linkonce text section too,\n- \t but this requires more work as the frequency needs to match\n+\t but this requires more work as the frequency needs to match\n \t for all generated objects so we need to merge the frequency\n \t of all instances.  For now just never set frequency for these.  */\n       || DECL_ONE_ONLY (current_function_decl))"}, {"sha": "6ac7d7f28b8f71d2d6e96fd6c86aef5329ef1363", "filename": "gcc/predict.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the\n    builtins used in the GNU compiler.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -37,13 +37,11 @@ enum prediction\n /* Flags for NOTE_PREDICTION */\n #define IS_TAKEN 1\t\t/* Predict edges to the block as taken.  */\n \n-extern void predict_insn_def\tPARAMS ((rtx, enum br_predictor,\n-\t\t\t\t\t enum prediction));\n-extern void predict_insn\tPARAMS ((rtx, enum br_predictor, int));\n+extern void predict_insn_def (rtx, enum br_predictor, enum prediction);\n+extern void predict_insn (rtx, enum br_predictor, int);\n \n /* Avoid unneeded dependency on basic_block.h  */\n #ifdef BASIC_BLOCK\n-extern void predict_edge\tPARAMS ((edge, enum br_predictor, int));\n-extern void predict_edge_def\tPARAMS ((edge, enum br_predictor,\n-\t\t\t\t\t enum prediction));\n+extern void predict_edge (edge, enum br_predictor, int);\n+extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n #endif"}, {"sha": "3e4a1c02d85caa4d5d02445055fc9123efd705fa", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -2087,12 +2087,12 @@ extern rtx delete_insn_and_edges\tPARAMS ((rtx));\n extern void delete_insn_chain_and_edges\tPARAMS ((rtx, rtx));\n \n /* In combine.c */\n-extern int combine_instructions\t\tPARAMS ((rtx, unsigned int));\n-extern unsigned int extended_count\tPARAMS ((rtx, enum machine_mode, int));\n-extern rtx remove_death\t\t\tPARAMS ((unsigned int, rtx));\n+extern int combine_instructions (rtx, unsigned int);\n+extern unsigned int extended_count (rtx, enum machine_mode, int);\n+extern rtx remove_death (unsigned int, rtx);\n #ifdef BUFSIZ\n-extern void dump_combine_stats\t\tPARAMS ((FILE *));\n-extern void dump_combine_total_stats\tPARAMS ((FILE *));\n+extern void dump_combine_stats (FILE *);\n+extern void dump_combine_total_stats (FILE *);\n #endif\n \n /* In sched.c.  */"}, {"sha": "b9854469ded55f17e3f2c00e163c8b6e0d4bc543", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 27, "deletions": 65, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -30,21 +30,18 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-dump.h\"\n #include \"langhooks.h\"\n \n-static unsigned int queue PARAMS ((dump_info_p, tree, int));\n-static void dump_index PARAMS ((dump_info_p, unsigned int));\n-static void dequeue_and_dump PARAMS ((dump_info_p));\n-static void dump_new_line PARAMS ((dump_info_p));\n-static void dump_maybe_newline PARAMS ((dump_info_p));\n-static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n+static unsigned int queue (dump_info_p, tree, int);\n+static void dump_index (dump_info_p, unsigned int);\n+static void dequeue_and_dump (dump_info_p);\n+static void dump_new_line (dump_info_p);\n+static void dump_maybe_newline (dump_info_p);\n+static void dump_string_field (dump_info_p, const char *, const char *);\n \n /* Add T to the end of the queue of nodes to dump.  Returns the index\n    assigned to T.  */\n \n static unsigned int\n-queue (di, t, flags)\n-     dump_info_p di;\n-     tree t;\n-     int flags;\n+queue (dump_info_p di, tree t, int flags)\n {\n   dump_queue_p dq;\n   dump_node_info_p dni;\n@@ -82,9 +79,7 @@ queue (di, t, flags)\n }\n \n static void\n-dump_index (di, index)\n-     dump_info_p di;\n-     unsigned int index;\n+dump_index (dump_info_p di, unsigned int index)\n {\n   fprintf (di->stream, \"@%-6u \", index);\n   di->column += 8;\n@@ -95,11 +90,7 @@ dump_index (di, index)\n    index of T is printed.  */\n \n void\n-queue_and_dump_index (di, field, t, flags)\n-     dump_info_p di;\n-     const char *field;\n-     tree t;\n-     int flags;\n+queue_and_dump_index (dump_info_p di, const char *field, tree t, int flags)\n {\n   unsigned int index;\n   splay_tree_node n;\n@@ -127,9 +118,7 @@ queue_and_dump_index (di, field, t, flags)\n /* Dump the type of T.  */\n \n void\n-queue_and_dump_type (di, t)\n-     dump_info_p di;\n-     tree t;\n+queue_and_dump_type (dump_info_p di, tree t)\n {\n   queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n }\n@@ -143,8 +132,7 @@ queue_and_dump_type (di, t)\n    place to start printing more fields.  */\n \n static void\n-dump_new_line (di)\n-     dump_info_p di;\n+dump_new_line (dump_info_p di)\n {\n   fprintf (di->stream, \"\\n%*s\", SOL_COLUMN, \"\");\n   di->column = SOL_COLUMN;\n@@ -153,8 +141,7 @@ dump_new_line (di)\n /* If necessary, insert a new line.  */\n \n static void\n-dump_maybe_newline (di)\n-     dump_info_p di;\n+dump_maybe_newline (dump_info_p di)\n {\n   int extra;\n \n@@ -172,10 +159,7 @@ dump_maybe_newline (di)\n /* Dump pointer PTR using FIELD to identify it.  */\n \n void\n-dump_pointer (di, field, ptr)\n-     dump_info_p di;\n-     const char *field;\n-     void *ptr;\n+dump_pointer (dump_info_p di, const char *field, void *ptr)\n {\n   dump_maybe_newline (di);\n   fprintf (di->stream, \"%-4s: %-8lx \", field, (long) ptr);\n@@ -185,10 +169,7 @@ dump_pointer (di, field, ptr)\n /* Dump integer I using FIELD to identify it.  */\n \n void\n-dump_int (di, field, i)\n-     dump_info_p di;\n-     const char *field;\n-     int i;\n+dump_int (dump_info_p di, const char *field, int i)\n {\n   dump_maybe_newline (di);\n   fprintf (di->stream, \"%-4s: %-7d \", field, i);\n@@ -198,9 +179,7 @@ dump_int (di, field, i)\n /* Dump the string S.  */\n \n void\n-dump_string (di, string)\n-     dump_info_p di;\n-     const char *string;\n+dump_string (dump_info_p di, const char *string)\n {\n   dump_maybe_newline (di);\n   fprintf (di->stream, \"%-13s \", string);\n@@ -213,10 +192,7 @@ dump_string (di, string)\n /* Dump the string field S.  */\n \n static void\n-dump_string_field (di, field, string)\n-     dump_info_p di;\n-     const char *field;\n-     const char *string;\n+dump_string_field (dump_info_p di, const char *field, const char *string)\n {\n   dump_maybe_newline (di);\n   fprintf (di->stream, \"%-4s: %-7s \", field, string);\n@@ -229,8 +205,7 @@ dump_string_field (di, field, string)\n /* Dump the next node in the queue.  */\n \n static void\n-dequeue_and_dump (di)\n-     dump_info_p di;\n+dequeue_and_dump (dump_info_p di)\n {\n   dump_queue_p dq;\n   splay_tree_node stn;\n@@ -277,7 +252,7 @@ dequeue_and_dump (di)\n       tree bases = BINFO_BASETYPES (t);\n       unsigned n_bases = bases ? TREE_VEC_LENGTH (bases): 0;\n       tree accesses = BINFO_BASEACCESSES (t);\n-      \n+\n       dump_child (\"type\", BINFO_TYPE (t));\n \n       if (TREE_VIA_VIRTUAL (t))\n@@ -299,11 +274,11 @@ dequeue_and_dump (di)\n \t    string = \"priv\";\n \t  else\n \t    abort ();\n-\t  \n+\n \t  dump_string (di, string);\n \t  queue_and_dump_index (di, \"binf\", base, DUMP_BINFO);\n \t}\n-      \n+\n       goto done;\n     }\n \n@@ -616,21 +591,15 @@ dequeue_and_dump (di)\n /* Return nonzero if FLAG has been specified for the dump, and NODE\n    is not the root node of the dump.  */\n \n-int dump_flag (di, flag, node)\n-     dump_info_p di;\n-     int flag;\n-     tree node;\n+int dump_flag (dump_info_p di, int flag, tree node)\n {\n   return (di->flags & flag) && (node != di->node);\n }\n \n /* Dump T, and all its children, on STREAM.  */\n \n void\n-dump_node (t, flags, stream)\n-     tree t;\n-     int flags;\n-     FILE *stream;\n+dump_node (tree t, int flags, FILE *stream)\n {\n   struct dump_info di;\n   dump_queue_p dq;\n@@ -707,9 +676,7 @@ static const struct dump_option_value_info dump_options[] =\n    Multiple calls will reopen and append to the dump file.  */\n \n FILE *\n-dump_begin (phase, flag_ptr)\n-     enum tree_dump_index phase;\n-     int *flag_ptr;\n+dump_begin (enum tree_dump_index phase, int *flag_ptr)\n {\n   FILE *stream;\n   char *name;\n@@ -733,17 +700,15 @@ dump_begin (phase, flag_ptr)\n /* Returns nonzero if tree dump PHASE is enabled.  */\n \n int\n-dump_enabled_p (phase)\n-     enum tree_dump_index phase;\n+dump_enabled_p (enum tree_dump_index phase)\n {\n   return dump_files[phase].state;\n }\n \n /* Returns the switch name of PHASE.  */\n \n const char *\n-dump_flag_name (phase)\n-     enum tree_dump_index phase;\n+dump_flag_name (enum tree_dump_index phase)\n {\n   return dump_files[phase].swtch;\n }\n@@ -752,9 +717,7 @@ dump_flag_name (phase)\n    dump_begin.  */\n \n void\n-dump_end (phase, stream)\n-     enum tree_dump_index phase ATTRIBUTE_UNUSED;\n-     FILE *stream;\n+dump_end (enum tree_dump_index phase ATTRIBUTE_UNUSED, FILE *stream)\n {\n   fclose (stream);\n }\n@@ -763,8 +726,7 @@ dump_end (phase, stream)\n    relevant details in the dump_files array.  */\n \n int\n-dump_switch_p (arg)\n-     const char *arg;\n+dump_switch_p (const char *arg)\n {\n   unsigned ix;\n   const char *option_value;"}, {"sha": "3f6497b23f8916ba64a0a38a5f0abebef9b1d37a", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a490a95b8a5c194a479dcccae76d9f0393309b/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=79a490a95b8a5c194a479dcccae76d9f0393309b", "patch": "@@ -1,5 +1,5 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n This file is part of GCC.\n@@ -77,19 +77,12 @@ struct dump_info\n #define dump_child(field, child) \\\n   queue_and_dump_index (di, field, child, DUMP_NONE)\n \n-extern void dump_pointer\n-  PARAMS ((dump_info_p, const char *, void *));\n-extern void dump_int\n-  PARAMS ((dump_info_p, const char *, int));\n-extern void dump_string\n-  PARAMS ((dump_info_p, const char *));\n-extern void dump_stmt\n-  PARAMS ((dump_info_p, tree));\n-extern void dump_next_stmt\n-  PARAMS ((dump_info_p, tree));\n-extern void queue_and_dump_index\n-  PARAMS ((dump_info_p, const char *, tree, int));\n-extern void queue_and_dump_type\n-  PARAMS ((dump_info_p, tree));\n+extern void dump_pointer (dump_info_p, const char *, void *);\n+extern void dump_int (dump_info_p, const char *, int);\n+extern void dump_string (dump_info_p, const char *);\n+extern void dump_stmt (dump_info_p, tree);\n+extern void dump_next_stmt (dump_info_p, tree);\n+extern void queue_and_dump_index (dump_info_p, const char *, tree, int);\n+extern void queue_and_dump_type (dump_info_p, tree);\n \n #endif /* ! GCC_TREE_DUMP_H */"}]}