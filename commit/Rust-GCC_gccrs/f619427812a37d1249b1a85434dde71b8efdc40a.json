{"sha": "f619427812a37d1249b1a85434dde71b8efdc40a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxOTQyNzgxMmEzN2QxMjQ5YjFhODU0MzRkZGU3MWI4ZWZkYzQwYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-10-01T13:12:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T13:12:26Z"}, "message": "checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated): Handle case of appearing in range in membership test.\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):\n\tHandle case of appearing in range in membership test.\n\t* exp_ch4.adb (Expand_Membership_Minimize_Eliminate_Overflow):\n\tNew procedure (Expand_N_In): Use\n\tExpand_Membership_Minimize_Eliminate_Overflow.\n\t* rtsfind.ads: Add RE_Bignum_In_LLI_Range.\n\t* s-bignum.ads, s-bignum.adb (Bignum_In_LLI_Range): New function.\n\t* sinfo.ads, sinfo.adb (No_Minimize_Eliminate): New flag.\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* uintp.ads: Minor reformatting.\n\nFrom-SVN: r191918", "tree": {"sha": "93e1d49dd1f5bb39c1680522d66c5b96eea18009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93e1d49dd1f5bb39c1680522d66c5b96eea18009"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f619427812a37d1249b1a85434dde71b8efdc40a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f619427812a37d1249b1a85434dde71b8efdc40a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f619427812a37d1249b1a85434dde71b8efdc40a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f619427812a37d1249b1a85434dde71b8efdc40a/comments", "author": null, "committer": null, "parents": [{"sha": "e0df453331f97b78cbd77a377a3d2531137eb7b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0df453331f97b78cbd77a377a3d2531137eb7b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0df453331f97b78cbd77a377a3d2531137eb7b2"}], "stats": {"total": 512, "additions": 470, "deletions": 42}, "files": [{"sha": "775307730b887a3b28d7fbdcfe7ff0e84934d3c7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -1,3 +1,18 @@\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):\n+\tHandle case of appearing in range in membership test.\n+\t* exp_ch4.adb (Expand_Membership_Minimize_Eliminate_Overflow):\n+\tNew procedure (Expand_N_In): Use\n+\tExpand_Membership_Minimize_Eliminate_Overflow.\n+\t* rtsfind.ads: Add RE_Bignum_In_LLI_Range.\n+\t* s-bignum.ads, s-bignum.adb (Bignum_In_LLI_Range): New function.\n+\t* sinfo.ads, sinfo.adb (No_Minimize_Eliminate): New flag.\n+\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* uintp.ads: Minor reformatting.\n+\n 2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n \n \t* checks.adb: Improve warning message."}, {"sha": "b83c87fdb7ea21921629693fe54612e6cc262c9d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -1091,6 +1091,12 @@ package body Checks is\n       if Is_Signed_Integer_Arithmetic_Op (P)\n         or else Nkind (Op) in N_Membership_Test\n         or else Nkind (Op) in N_Op_Compare\n+\n+        --  We may also be a range operand in a membership test\n+\n+        or else (Nkind (Op) = N_Range\n+                  and then Nkind (Parent (Op)) in N_Membership_Test)\n+\n       then\n          return;\n       end if;"}, {"sha": "0da35541e4c6dca9cdcb0e223d125f225abec6f5", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 353, "deletions": 9, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -164,6 +164,12 @@ package body Exp_Ch4 is\n    --  concatenation. The operands can be of any appropriate type, and can\n    --  include both arrays and singleton elements.\n \n+   procedure Expand_Membership_Minimize_Eliminate_Overflow (N : Node_Id);\n+   --  N is an N_In membership test mode, with the overflow check mode\n+   --  set to Minimized or Eliminated, and the type of the left operand\n+   --  is a signed integer type. This is a case where top level processing\n+   --  is required to handle overflow checks in subtrees.\n+\n    procedure Fixup_Universal_Fixed_Operation (N : Node_Id);\n    --  N is a N_Op_Divide or N_Op_Multiply node whose result is universal\n    --  fixed. We do not have such a type at runtime, so the purpose of this\n@@ -875,7 +881,7 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n-      --  Would be nice to comment the branches of this very long if ???\n+      --  Case of tagged type or type requiring finalization\n \n       if Is_Tagged_Type (T) or else Needs_Finalization (T) then\n          if Is_CPP_Constructor_Call (Exp) then\n@@ -3705,6 +3711,332 @@ package body Exp_Ch4 is\n          --  Set_Etype (Cnode, Atyp);\n    end Expand_Concatenate;\n \n+   ---------------------------------------------------\n+   -- Expand_Membership_Minimize_Eliminate_Overflow --\n+   ---------------------------------------------------\n+\n+   procedure Expand_Membership_Minimize_Eliminate_Overflow (N : Node_Id) is\n+      pragma Assert (Nkind (N) = N_In);\n+      --  Despite the name, this routine applies only to N_In, not to\n+      --  N_Not_In. The latter is always rewritten as not (X in Y).\n+\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Lop   : constant Node_Id    := Left_Opnd (N);\n+      Rop   : constant Node_Id    := Right_Opnd (N);\n+      Ltype : constant Entity_Id  := Etype (Lop);\n+      Rtype : constant Entity_Id  := Etype (Rop);\n+\n+      Restype : constant Entity_Id := Etype (N);\n+      --  Save result type\n+\n+      Lo, Hi : Uint;\n+      --  Bounds in Minimize calls, not used yet ???\n+\n+      LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n+      --  Entity for Long_Long_Integer'Base (Standard should export this???)\n+\n+   begin\n+      Minimize_Eliminate_Overflow_Checks (Lop, Lo, Hi);\n+\n+      --  If right operand is a subtype name, and the subtype name has no\n+      --  predicate, then we can just replace the right operand with an\n+      --  explicit range T'First .. T'Last, and use the explicit range code.\n+\n+      if Nkind (Rop) /= N_Range and then No (Predicate_Function (Rtype)) then\n+         Rewrite (Rop,\n+           Make_Range (Loc,\n+             Low_Bound =>\n+               Make_Attribute_Reference (Loc,\n+                 Attribute_Name => Name_First,\n+                 Prefix         => New_Reference_To (Rtype, Loc)),\n+\n+             High_Bound =>\n+               Make_Attribute_Reference (Loc,\n+                 Attribute_Name => Name_Last,\n+                 Prefix         => New_Reference_To (Rtype, Loc))));\n+         Analyze_And_Resolve (Rop, Rtype, Suppress => All_Checks);\n+      end if;\n+\n+      --  Here for the explicit range case. Note that the bounds of the range\n+      --  have not been processed for minimized or eliminated checks.\n+\n+      if Nkind (Rop) = N_Range then\n+         Minimize_Eliminate_Overflow_Checks (Low_Bound (Rop),  Lo, Hi);\n+         Minimize_Eliminate_Overflow_Checks (High_Bound (Rop), Lo, Hi);\n+\n+         --  We have A in B .. C, treated as  A >= B and then A <= C\n+\n+         --  Bignum case\n+\n+         if Is_RTE (Ltype, RE_Bignum)\n+           or else Is_RTE (Etype (Low_Bound (Rop)), RE_Bignum)\n+           or else Is_RTE (Etype (High_Bound (Rop)), RE_Bignum)\n+         then\n+            declare\n+               Blk    : constant Node_Id   := Make_Bignum_Block (Loc);\n+               Bnn    : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n+               Lopnd  : constant Node_Id   := Convert_To_Bignum (Lop);\n+               Lbound : constant Node_Id   :=\n+                          Convert_To_Bignum (Low_Bound (Rop));\n+               Hbound : constant Node_Id   :=\n+                          Convert_To_Bignum (High_Bound (Rop));\n+\n+            --  Now we insert code that looks like\n+\n+            --    Bnn : Boolean;\n+\n+            --    declare\n+            --       M : Mark_Id := SS_Mark;\n+            --       L : Bignum  := Lopnd;\n+            --    begin\n+            --       Bnn := Big_GE (L, Lbound) and then Big_LE (L, Hbound)\n+            --       SS_Release (M);\n+            --    end;\n+\n+            --  and rewrite the membership test as a reference to Bnn\n+\n+            begin\n+               Insert_After\n+                 (Last (Declarations (Blk)),\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => Bnn,\n+                    Object_Definition   =>\n+                      New_Occurrence_Of (RTE (RE_Bignum), Loc),\n+                    Expression          => Lopnd));\n+\n+               Insert_Before\n+                 (First (Statements (Handled_Statement_Sequence (Blk))),\n+                  Make_Assignment_Statement (Loc,\n+                    Name       => New_Occurrence_Of (Bnn, Loc),\n+                    Expression =>\n+                      Make_And_Then (Loc,\n+                        Left_Opnd =>\n+                          Make_Function_Call (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of (RTE (RE_Big_GE), Loc),\n+                            Parameter_Associations => New_List (Lbound)),\n+                        Right_Opnd =>\n+                          Make_Function_Call (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of (RTE (RE_Big_GE), Loc),\n+                            Parameter_Associations => New_List (Hbound)))));\n+\n+               Insert_Actions (N, New_List (\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Bnn,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Boolean, Loc)),\n+                 Blk));\n+\n+               Rewrite (N, New_Occurrence_Of (Bnn, Loc));\n+               Analyze_And_Resolve (N);\n+               return;\n+            end;\n+\n+         --  Here if no bignums around\n+\n+         else\n+            --  Case where types are all the same\n+\n+            if Ltype = Etype (Low_Bound (Rop))\n+                 and then\n+               Ltype = Etype (High_Bound (Rop))\n+            then\n+               null;\n+\n+            --  If types are not all the same, it means that we have rewritten\n+            --  at least one of them to be of type Long_Long_Integer, and we\n+            --  will convert the other operands to Long_Long_Integer.\n+\n+            else\n+               Convert_To_And_Rewrite (LLIB, Lop);\n+               Analyze_And_Resolve (Lop, LLIB, Suppress => All_Checks);\n+\n+               Convert_To_And_Rewrite (LLIB, Low_Bound (Rop));\n+               Convert_To_And_Rewrite (LLIB, High_Bound (Rop));\n+               Set_Analyzed (Rop, False);\n+               Analyze_And_Resolve (Rop, LLIB, Suppress => All_Checks);\n+            end if;\n+\n+            --  Now the three operands are of the same signed integer type,\n+            --  so we can use the normal expansion routine for membership.\n+\n+            Set_No_Minimize_Eliminate (N);\n+            Expand_N_In (N);\n+         end if;\n+\n+      --  Right operand is a subtype name and the subtype has a predicate. We\n+      --  have to make sure predicate is checked, and for that we need to use\n+      --  the standard N_In circuitry with appropriate types.\n+\n+      else\n+         pragma Assert (Present (Predicate_Function (Rtype)));\n+\n+         --  If types are \"right\", just call Expand_N_In preventing recursion\n+\n+         if Base_Type (Ltype) = Base_Type (Rtype) then\n+            Set_No_Minimize_Eliminate (N);\n+            Expand_N_In (N);\n+\n+         --  Bignum case\n+\n+         elsif Is_RTE (Ltype, RE_Bignum) then\n+\n+            --  For X in T, we want to insert code that looks like\n+\n+            --    Bnn : Boolean;\n+\n+            --    declare\n+            --       M   : Mark_Id := SS_Mark;\n+            --       Lnn : Long_Long_Integer'Base\n+            --       Nnn : Bignum;\n+\n+            --    begin\n+            --      Nnn := X;\n+\n+            --      if not Bignum_In_LLI_Range (Nnn) then\n+            --         Bnn := False;\n+            --      else\n+            --         Lnn := From_Bignum (Nnn);\n+            --         Bnn := Lnn in T'Base and then T'Base (Lnn) in T;\n+            --      end if;\n+            --\n+            --       SS_Release (M);\n+            --    end;\n+\n+            --  And then rewrite the original membership as a reference to Bnn.\n+            --  A bit gruesome, but here goes.\n+\n+            declare\n+               Blk    : constant Node_Id   := Make_Bignum_Block (Loc);\n+               Bnn    : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n+               Lnn    : constant Entity_Id := Make_Temporary (Loc, 'L', N);\n+               Nnn    : constant Entity_Id := Make_Temporary (Loc, 'N', N);\n+               Nin    : Node_Id;\n+\n+            begin\n+               --  The last membership test is marked to prevent recursion\n+\n+               Nin :=\n+                 Make_In (Loc,\n+                   Left_Opnd =>\n+                     Convert_To (Base_Type (Rtype),\n+                       New_Occurrence_Of (Lnn, Loc)),\n+                   Right_Opnd => New_Occurrence_Of (Rtype, Loc));\n+               Set_No_Minimize_Eliminate (Nin);\n+\n+               --  Now decorate the block\n+\n+               Insert_After\n+                 (Last (Declarations (Blk)),\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => Lnn,\n+                    Object_Definition   => New_Occurrence_Of (LLIB, Loc)));\n+\n+               Insert_After\n+                 (Last (Declarations (Blk)),\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => Nnn,\n+                    Object_Definition   =>\n+                      New_Occurrence_Of (RTE (RE_Bignum), Loc)));\n+\n+               Insert_List_Before\n+                 (First (Statements (Handled_Statement_Sequence (Blk))),\n+                  New_List (\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Nnn, Loc),\n+                      Expression => Relocate_Node (Lop)),\n+\n+                    Make_If_Statement (Loc,\n+                      Condition =>\n+                        Make_Function_Call (Loc,\n+                          Name =>\n+                            New_Occurrence_Of\n+                              (RTE (RE_Bignum_In_LLI_Range), Loc),\n+                          Parameter_Associations => New_List (\n+                            New_Occurrence_Of (Nnn, Loc))),\n+\n+                      Then_Statements => New_List (\n+                        Make_Assignment_Statement (Loc,\n+                          Name       => New_Occurrence_Of (Bnn, Loc),\n+                          Expression =>\n+                            New_Occurrence_Of (Standard_False, Loc))),\n+\n+                      Else_Statements => New_List (\n+                        Make_Assignment_Statement (Loc,\n+                          Name => New_Occurrence_Of (Lnn, Loc),\n+                          Expression =>\n+                            Make_Function_Call (Loc,\n+                              Name                   =>\n+                                New_Occurrence_Of (RTE (RE_From_Bignum), Loc),\n+                              Parameter_Associations => New_List (\n+                                  New_Occurrence_Of (Nnn, Loc)))),\n+\n+                        Make_Assignment_Statement (Loc,\n+                          Name => New_Occurrence_Of (Bnn, Loc),\n+                          Expression =>\n+                            Make_And_Then (Loc,\n+                              Left_Opnd =>\n+                                Make_In (Loc,\n+                                  Left_Opnd  =>\n+                                    New_Occurrence_Of (Lnn, Loc),\n+                                  Right_Opnd =>\n+                                    New_Occurrence_Of\n+                                      (Base_Type (Rtype), Loc)),\n+                              Right_Opnd => Nin))))));\n+\n+               Insert_Actions (N, New_List (\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Bnn,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Boolean, Loc)),\n+                 Blk));\n+\n+               Rewrite (N, New_Occurrence_Of (Bnn, Loc));\n+               Analyze_And_Resolve (N);\n+               return;\n+            end;\n+\n+         --  Not bignum case, but types don't match (this means we rewrote the\n+         --  left operand to be Long_Long_Integer.\n+\n+         else\n+            pragma Assert (Base_Type (Ltype) = LLIB);\n+\n+            --  We rewrite the membership test as\n+\n+            --    Lop in T'Base and then T'Base (Lop) in T\n+\n+            declare\n+               Nin : Node_Id;\n+\n+            begin\n+               --  The last membership test is marked to prevent recursion\n+\n+               Nin :=\n+                 Make_In (Loc,\n+                   Left_Opnd =>\n+                     Convert_To (Base_Type (Rtype), Duplicate_Subexpr (Lop)),\n+                   Right_Opnd => New_Occurrence_Of (Rtype, Loc));\n+               Set_No_Minimize_Eliminate (Nin);\n+\n+               --  Now do the rewrite\n+\n+               Rewrite (N,\n+                 Make_And_Then (Loc,\n+                   Left_Opnd =>\n+                     Make_In (Loc,\n+                       Left_Opnd  => Lop,\n+                       Right_Opnd =>\n+                         New_Occurrence_Of (Base_Type (Ltype), Loc)),\n+                   Right_Opnd => Nin));\n+\n+               Analyze_And_Resolve (N, Restype, Suppress => All_Checks);\n+            end;\n+         end if;\n+      end if;\n+   end Expand_Membership_Minimize_Eliminate_Overflow;\n+\n    ------------------------\n    -- Expand_N_Allocator --\n    ------------------------\n@@ -5130,6 +5462,18 @@ package body Exp_Ch4 is\n       Ltyp := Etype (Left_Opnd  (N));\n       Rtyp := Etype (Right_Opnd (N));\n \n+      --  If Minimize/Eliminate overflow mode and type is a signed integer\n+      --  type, then expand with a separate procedure. Note the use of the\n+      --  flag No_Minimize_Eliminate to prevent infinite recursion.\n+\n+      if Overflow_Check_Mode (Empty) in Minimized_Or_Eliminated\n+        and then Is_Signed_Integer_Type (Ltyp)\n+        and then not No_Minimize_Eliminate (N)\n+      then\n+         Expand_Membership_Minimize_Eliminate_Overflow (N);\n+         return;\n+      end if;\n+\n       --  Check case of explicit test for an expression in range of its\n       --  subtype. This is suspicious usage and we replace it with a 'Valid\n       --  test and give a warning. For floating point types however, this is a\n@@ -5225,9 +5569,9 @@ package body Exp_Ch4 is\n               and then Expr_Value (Type_High_Bound (Ltyp)) = Expr_Value (Hi)\n               and then Expr_Value (Type_Low_Bound  (Ltyp)) = Expr_Value (Lo)\n \n-               --  Kill warnings in instances, since they may be cases where we\n-               --  have a test in the generic that makes sense with some types\n-               --  and not with other types.\n+              --  Kill warnings in instances, since they may be cases where we\n+              --  have a test in the generic that makes sense with some types\n+              --  and not with other types.\n \n               and then not In_Instance\n             then\n@@ -5388,8 +5732,8 @@ package body Exp_Ch4 is\n             --  type if they come from the original type definition. Also this\n             --  way we get all the processing above for an explicit range.\n \n-               --  Don't do this for predicated types, since in this case we\n-               --  want to check the predicate!\n+            --  Don't do this for predicated types, since in this case we\n+            --  want to check the predicate!\n \n             elsif Is_Scalar_Type (Typ) then\n                if No (Predicate_Function (Typ)) then\n@@ -5398,12 +5742,12 @@ package body Exp_Ch4 is\n                       Low_Bound =>\n                         Make_Attribute_Reference (Loc,\n                           Attribute_Name => Name_First,\n-                          Prefix => New_Reference_To (Typ, Loc)),\n+                          Prefix         => New_Reference_To (Typ, Loc)),\n \n                       High_Bound =>\n                         Make_Attribute_Reference (Loc,\n                           Attribute_Name => Name_Last,\n-                          Prefix => New_Reference_To (Typ, Loc))));\n+                          Prefix         => New_Reference_To (Typ, Loc))));\n                   Analyze_And_Resolve (N, Restyp);\n                end if;\n \n@@ -5423,7 +5767,7 @@ package body Exp_Ch4 is\n                    Reason => PE_Unchecked_Union_Restriction));\n \n                --  Prevent Gigi from generating incorrect code by rewriting the\n-               --  test as False.\n+               --  test as False. What is this undocumented thing about ???\n \n                Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n                goto Leave;"}, {"sha": "ee9919a5fd419523a6dc6deaa43899778fa3b200", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -778,6 +778,7 @@ package Rtsfind is\n      RE_Big_NE,                          -- System.Bignums\n \n      RE_Bignum,                          -- System.Bignums\n+     RE_Bignum_In_LLI_Range,             -- System.Bignums\n      RE_To_Bignum,                       -- System.Bignums\n      RE_From_Bignum,                     -- System.Bignums\n \n@@ -2021,6 +2022,7 @@ package Rtsfind is\n      RE_Big_NE                           => System_Bignums,\n \n      RE_Bignum                           => System_Bignums,\n+     RE_Bignum_In_LLI_Range              => System_Bignums,\n      RE_To_Bignum                        => System_Bignums,\n      RE_From_Bignum                      => System_Bignums,\n "}, {"sha": "3474e1b5f4158f7f09227d28d6601fd94d5156e8", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -963,6 +963,33 @@ package body System.Bignums is\n       raise Constraint_Error with \"expression value out of range\";\n    end From_Bignum;\n \n+   -------------------------\n+   -- Bignum_In_LLI_Range --\n+   -------------------------\n+\n+   function Bignum_In_LLI_Range (X : Bignum) return Boolean is\n+   begin\n+      --  If length is 0 or 1, definitely fits\n+\n+      if X.Len <= 1 then\n+         return True;\n+\n+      --  If length is greater than 2, definitely does not fit\n+\n+      elsif X.Len > 2 then\n+         return False;\n+\n+      --  Length is 2, more tests needed\n+\n+      else\n+         declare\n+            Mag : constant DD := X.D (1) & X.D (2);\n+         begin\n+            return Mag < 2 ** 63 or else (X.Neg and then Mag = 2 ** 63);\n+         end;\n+      end if;\n+   end Bignum_In_LLI_Range;\n+\n    ---------------\n    -- Normalize --\n    ---------------"}, {"sha": "ecc0784ca508cb8071ebff6d8d71891267115b53", "filename": "gcc/ada/s-bignum.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fs-bignum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fs-bignum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.ads?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -91,6 +91,10 @@ package System.Bignums is\n    --  Perform indicated comparison on bignums, returning result as Boolean.\n    --  No exception raised for any input arguments.\n \n+   function Bignum_In_LLI_Range (X : Bignum) return Boolean;\n+   --  Returns True if the Bignum value is in the range of Long_Long_Integer,\n+   --  so that a call to From_Bignum is guaranteed not to raise an exception.\n+\n    function To_Bignum (X : Long_Long_Integer) return Bignum;\n    --  Convert Long_Long_Integer to Bignum. No exception can be raised for any\n    --  input argument."}, {"sha": "e5773e0d4d94a9ce0c3715131ba5dc1cee73d83d", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -2235,6 +2235,15 @@ package body Sinfo is\n       return Flag13 (N);\n    end No_Initialization;\n \n+   function No_Minimize_Eliminate\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_In\n+        or else NT (N).Nkind = N_Not_In);\n+      return Flag17 (N);\n+   end No_Minimize_Eliminate;\n+\n    function No_Truncation\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5288,6 +5297,15 @@ package body Sinfo is\n       Set_Flag13 (N, Val);\n    end Set_No_Initialization;\n \n+   procedure Set_No_Minimize_Eliminate\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_In\n+        or else NT (N).Nkind = N_Not_In);\n+      Set_Flag17 (N, Val);\n+   end Set_No_Minimize_Eliminate;\n+\n    procedure Set_No_Truncation\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "fd595a78ae159d161f8f4ff1fcae8c40daad27b4", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -1545,6 +1545,11 @@ package Sinfo is\n    --    should not be taken into account (needed for in place initialization\n    --    with aggregates).\n \n+   --  No_Minimize_Eliminate (Flag17-Sem)\n+   --    This flag is present in membership operator nodes (N_In/N_Not_In).\n+   --    It is used to indicate that processing for extended overflow checking\n+   --    modes is not required (this is used to prevent infinite recursion).\n+\n    --  No_Truncation (Flag17-Sem)\n    --    Present in N_Unchecked_Type_Conversion node. This flag has an effect\n    --    only if the RM_Size of the source is greater than the RM_Size of the\n@@ -3675,13 +3680,15 @@ package Sinfo is\n       --  Left_Opnd (Node2)\n       --  Right_Opnd (Node3)\n       --  Alternatives (List4) (set to No_List if only one set alternative)\n+      --  No_Minimize_Eliminate (Flag17)\n       --  plus fields for expression\n \n       --  N_Not_In\n       --  Sloc points to NOT of NOT IN\n       --  Left_Opnd (Node2)\n       --  Right_Opnd (Node3)\n       --  Alternatives (List4) (set to No_List if only one set alternative)\n+      --  No_Minimize_Eliminate (Flag17)\n       --  plus fields for expression\n \n       --------------------\n@@ -8794,6 +8801,9 @@ package Sinfo is\n    function No_Initialization\n      (N : Node_Id) return Boolean;    -- Flag13\n \n+   function No_Minimize_Eliminate\n+     (N : Node_Id) return Boolean;    -- Flag17\n+\n    function No_Truncation\n      (N : Node_Id) return Boolean;    -- Flag17\n \n@@ -9766,6 +9776,9 @@ package Sinfo is\n    procedure Set_No_Initialization\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n+   procedure Set_No_Minimize_Eliminate\n+     (N : Node_Id; Val : Boolean := True);    -- Flag17\n+\n    procedure Set_No_Truncation\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n@@ -12017,6 +12030,7 @@ package Sinfo is\n    pragma Inline (No_Elaboration_Check);\n    pragma Inline (No_Entities_Ref_In_Spec);\n    pragma Inline (No_Initialization);\n+   pragma Inline (No_Minimize_Eliminate);\n    pragma Inline (No_Truncation);\n    pragma Inline (Null_Present);\n    pragma Inline (Null_Exclusion_Present);\n@@ -12337,6 +12351,7 @@ package Sinfo is\n    pragma Inline (Set_No_Elaboration_Check);\n    pragma Inline (Set_No_Entities_Ref_In_Spec);\n    pragma Inline (Set_No_Initialization);\n+   pragma Inline (Set_No_Minimize_Eliminate);\n    pragma Inline (Set_No_Truncation);\n    pragma Inline (Set_Null_Present);\n    pragma Inline (Set_Null_Exclusion_Present);"}, {"sha": "b730f44879ad91a08e675d32bfce399a3178324f", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f619427812a37d1249b1a85434dde71b8efdc40a/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=f619427812a37d1249b1a85434dde71b8efdc40a", "patch": "@@ -248,18 +248,18 @@ package Uintp is\n    --  not in Char_Code range.\n \n    function Num_Bits (Input : Uint) return Nat;\n-   --  Approximate number of binary bits in given universal integer.\n-   --  This function is used for capacity checks, and it can be one\n-   --  bit off without affecting its usage.\n+   --  Approximate number of binary bits in given universal integer. This\n+   --  function is used for capacity checks, and it can be one bit off\n+   --  without affecting its usage.\n \n    ---------------------\n    -- Output Routines --\n    ---------------------\n \n    type UI_Format is (Hex, Decimal, Auto);\n    --  Used to determine whether UI_Image/UI_Write output is in hexadecimal\n-   --  or decimal format. Auto, the default setting, lets the routine make\n-   --  a decision based on the value.\n+   --  or decimal format. Auto, the default setting, lets the routine make a\n+   --  decision based on the value.\n \n    UI_Image_Max    : constant := 48; -- Enough for a 128-bit number\n    UI_Image_Buffer : String (1 .. UI_Image_Max);\n@@ -271,18 +271,18 @@ package Uintp is\n    --  followed by the value in UI_Image_Buffer. The form of the value is an\n    --  integer literal in either decimal (no base) or hexadecimal (base 16)\n    --  format. If Hex is True on entry, then hex mode is forced, otherwise\n-   --  UI_Image makes a guess at which output format is more convenient. The\n-   --  value must fit in UI_Image_Buffer. If necessary, the result is an\n+   --  UI_Image makes a guess at which output format is more convenient.\n+   --  The value must fit in UI_Image_Buffer. If necessary, the result is an\n    --  approximation of the proper value, using an exponential format. The\n    --  image of No_Uint is output as a single question mark.\n \n    procedure UI_Write (Input : Uint; Format : UI_Format := Auto);\n    --  Writes a representation of Uint, consisting of a possible minus sign,\n    --  followed by the value to the output file. The form of the value is an\n    --  integer literal in either decimal (no base) or hexadecimal (base 16)\n-   --  format as appropriate. UI_Format shows which format to use. Auto,\n-   --  the default, asks UI_Write to make a guess at which output format\n-   --  will be more convenient to read.\n+   --  format as appropriate. UI_Format shows which format to use. Auto, the\n+   --  default, asks UI_Write to make a guess at which output format will be\n+   --  more convenient to read.\n \n    procedure pid (Input : Uint);\n    pragma Export (Ada, pid);\n@@ -355,11 +355,11 @@ package Uintp is\n    -- Mark/Release Processing --\n    -----------------------------\n \n-   --  The space used by Uint data is not automatically reclaimed. However,\n-   --  a mark-release regime is implemented which allows storage to be\n-   --  released back to a previously noted mark. This is used for example\n-   --  when doing comparisons, where only intermediate results get stored\n-   --  that do not need to be saved for future use.\n+   --  The space used by Uint data is not automatically reclaimed. However, a\n+   --  mark-release regime is implemented which allows storage to be released\n+   --  back to a previously noted mark. This is used for example when doing\n+   --  comparisons, where only intermediate results get stored that do not\n+   --  need to be saved for future use.\n \n    type Save_Mark is private;\n \n@@ -370,18 +370,16 @@ package Uintp is\n    --  Release storage allocated since mark was noted\n \n    procedure Release_And_Save (M : Save_Mark; UI : in out Uint);\n-   --  Like Release, except that the given Uint value (which is typically\n-   --  among the data being released) is recopied after the release, so\n-   --  that it is the most recent item, and UI is updated to point to\n-   --  its copied location.\n+   --  Like Release, except that the given Uint value (which is typically among\n+   --  the data being released) is recopied after the release, so that it is\n+   --  the most recent item, and UI is updated to point to its copied location.\n \n    procedure Release_And_Save (M : Save_Mark; UI1, UI2 : in out Uint);\n    --  Like Release, except that the given Uint values (which are typically\n-   --  among the data being released) are recopied after the release, so\n-   --  that they are the most recent items, and UI1 and UI2 are updated if\n-   --  necessary to point to the copied locations. This routine is careful\n-   --  to do things in the right order, so that the values do not clobber\n-   --  one another.\n+   --  among the data being released) are recopied after the release, so that\n+   --  they are the most recent items, and UI1 and UI2 are updated if necessary\n+   --  to point to the copied locations. This routine is careful to do things\n+   --  in the right order, so that the values do not clobber one another.\n \n    -----------------------------------\n    -- Representation of Uint Values --\n@@ -499,15 +497,14 @@ private\n    type UI_Vector is array (Pos range <>) of Int;\n    --  Vector containing the integer values of a Uint value\n \n-   --  Note: An earlier version of this package used pointers of arrays\n-   --  of Ints (dynamically allocated) for the Uint type. The change\n-   --  leads to a few less natural idioms used throughout this code, but\n-   --  eliminates all uses of the heap except for the table package itself.\n-   --  For example, Uint parameters are often converted to UI_Vectors for\n-   --  internal manipulation. This is done by creating the local UI_Vector\n-   --  using the function N_Digits on the Uint to find the size needed for\n-   --  the vector, and then calling Init_Operand to copy the values out\n-   --  of the table into the vector.\n+   --  Note: An earlier version of this package used pointers of arrays of Ints\n+   --  (dynamically allocated) for the Uint type. The change leads to a few\n+   --  less natural idioms used throughout this code, but eliminates all uses\n+   --  of the heap except for the table package itself. For example, Uint\n+   --  parameters are often converted to UI_Vectors for internal manipulation.\n+   --  This is done by creating the local UI_Vector using the function N_Digits\n+   --  on the Uint to find the size needed for the vector, and then calling\n+   --  Init_Operand to copy the values out of the table into the vector.\n \n    type Uint_Entry is record\n       Length : Pos;"}]}