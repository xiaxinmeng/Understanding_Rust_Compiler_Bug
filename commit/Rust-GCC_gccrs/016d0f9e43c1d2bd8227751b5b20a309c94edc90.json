{"sha": "016d0f9e43c1d2bd8227751b5b20a309c94edc90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2ZDBmOWU0M2MxZDJiZDgyMjc3NTFiNWIyMGEzMDljOTRlZGM5MA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-03-09T10:54:57Z"}, "committer": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-03-09T10:54:57Z"}, "message": "Insert default return_void at the end of coroutine body\n\nException in coroutine is not correctly handled because the default\nreturn_void call is now inserted before the finish suspend point,\nrather than at the end of the original coroutine body.  This patch\nfixes the issue by expanding code as following:\n  co_await promise.initial_suspend();\n  try {\n    // The original coroutine body\n\n    promise.return_void(); // The default return_void call.\n  } catch (...) {\n    promise.unhandled_exception();\n  }\n  final_suspend:\n  // ...\n\ngcc/cp/\n    * coroutines.cc (build_actor_fn): Factor out code inserting the\n    default return_void call to...\n    (morph_fn_to_coro): ...here, also hoist local var declarations.\n\ngcc/testsuite/\n    * g++.dg/coroutines/torture/co-ret-15-default-return_void.C: New.", "tree": {"sha": "865c048244c3f8f01427e8bd3afc581227a75513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/865c048244c3f8f01427e8bd3afc581227a75513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/016d0f9e43c1d2bd8227751b5b20a309c94edc90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016d0f9e43c1d2bd8227751b5b20a309c94edc90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/016d0f9e43c1d2bd8227751b5b20a309c94edc90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016d0f9e43c1d2bd8227751b5b20a309c94edc90/comments", "author": null, "committer": null, "parents": [{"sha": "cb2c60206f4f2218f84ccde21663b00de068d8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2c60206f4f2218f84ccde21663b00de068d8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2c60206f4f2218f84ccde21663b00de068d8c7"}], "stats": {"total": 133, "additions": 102, "deletions": 31}, "files": [{"sha": "128880bed03f6c8b300e761401643f76b3b3461c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=016d0f9e43c1d2bd8227751b5b20a309c94edc90", "patch": "@@ -1,3 +1,9 @@\n+2020-03-09  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* coroutines.cc (build_actor_fn): Factor out code inserting the\n+\tdefault return_void call to...\n+\t(morph_fn_to_coro): ...here, also hoist local var declarations.\n+\n 2020-03-08  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/93729"}, {"sha": "920575b0f54fc3ad123d44f467b709c46ef2c366", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=016d0f9e43c1d2bd8227751b5b20a309c94edc90", "patch": "@@ -2161,21 +2161,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   r = coro_build_expr_stmt (initial_await, loc);\n   add_stmt (r);\n \n-  /* Now we've built the promise etc, process fnbody for co_returns.\n-     We want the call to return_void () below and it has no params so\n-     we can create it once here.\n-     Calls to return_value () will have to be checked and created as\n-     required.  */\n-\n-  tree return_void = NULL_TREE;\n-  tree rvm\n-    = lookup_promise_method (orig, coro_return_void_identifier, loc,\n-\t\t\t     /*musthave=*/false);\n-  if (rvm && rvm != error_mark_node)\n-    return_void\n-      = build_new_method_call (ap, rvm, NULL, NULL_TREE, LOOKUP_NORMAL, NULL,\n-\t\t\t       tf_warning_or_error);\n-\n   /* co_return branches to the final_suspend label, so declare that now.  */\n   tree fs_label = create_named_label_with_ctx (loc, \"final.suspend\", actor);\n \n@@ -2190,15 +2175,6 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   /* Add in our function body with the co_returns rewritten to final form.  */\n   add_stmt (fnbody);\n \n-  /* [stmt.return.coroutine] (2.2 : 3) if p.return_void() is a valid\n-     expression, flowing off the end of a coroutine is equivalent to\n-     co_return; otherwise UB.\n-     We just inject the call to p.return_void() here, and fall through to\n-     the final_suspend: label (eliding the goto).  If the function body has\n-     a co_return, then this statement will be unreachable and DCEd.  */\n-  if (return_void != NULL_TREE)\n-    add_stmt (return_void);\n-\n   /* Final suspend starts here.  */\n   r = build_stmt (loc, LABEL_EXPR, fs_label);\n   add_stmt (r);\n@@ -3815,18 +3791,48 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n       BIND_EXPR_BLOCK (first) = replace_blk;\n     }\n \n+  /* actor's version of the promise.  */\n+  tree actor_frame = build1_loc (fn_start, INDIRECT_REF, coro_frame_type,\n+\t\t\t\t DECL_ARGUMENTS (actor));\n+  tree ap_m = lookup_member (coro_frame_type, get_identifier (\"__p\"), 1, 0,\n+\t\t\t     tf_warning_or_error);\n+  tree ap = build_class_member_access_expr (actor_frame, ap_m, NULL_TREE,\n+\t\t\t\t\t    false, tf_warning_or_error);\n+\n+  /* Now we've built the promise etc, process fnbody for co_returns.\n+     We want the call to return_void () below and it has no params so\n+     we can create it once here.\n+     Calls to return_value () will have to be checked and created as\n+     required.  */\n+\n+  tree return_void = NULL_TREE;\n+  tree rvm\n+    = lookup_promise_method (orig, coro_return_void_identifier, fn_start,\n+\t\t\t     /*musthave=*/false);\n+  if (rvm && rvm != error_mark_node)\n+    return_void\n+      = build_new_method_call (ap, rvm, NULL, NULL_TREE, LOOKUP_NORMAL, NULL,\n+\t\t\t       tf_warning_or_error);\n+\n+  /* [stmt.return.coroutine] (2.2 : 3) if p.return_void() is a valid\n+     expression, flowing off the end of a coroutine is equivalent to\n+     co_return; otherwise UB.\n+     We just inject the call to p.return_void() here, and fall through to\n+     the final_suspend: label (eliding the goto).  If the function body has\n+     a co_return, then this statement will be unreachable and DCEd.  */\n+  if (return_void != NULL_TREE)\n+    {\n+      tree append = push_stmt_list ();\n+      add_stmt (fnbody);\n+      add_stmt (return_void);\n+      fnbody = pop_stmt_list(append);\n+    }\n+\n   if (flag_exceptions)\n     {\n       tree ueh_meth\n \t= lookup_promise_method (orig, coro_unhandled_exception_identifier,\n \t\t\t\t fn_start, /*musthave=*/true);\n-      /* actor's version of the promise.  */\n-      tree actor_frame = build1_loc (fn_start, INDIRECT_REF, coro_frame_type,\n-\t\t\t\t     DECL_ARGUMENTS (actor));\n-      tree ap_m = lookup_member (coro_frame_type, get_identifier (\"__p\"), 1, 0,\n-\t\t\t\t tf_warning_or_error);\n-      tree ap = build_class_member_access_expr (actor_frame, ap_m, NULL_TREE,\n-\t\t\t\t\t\tfalse, tf_warning_or_error);\n       /* Build promise.unhandled_exception();  */\n       tree ueh\n \t= build_new_method_call (ap, ueh_meth, NULL, NULL_TREE, LOOKUP_NORMAL,"}, {"sha": "cf7243d99c88e5229712feb3b59fcbf163d69a1f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=016d0f9e43c1d2bd8227751b5b20a309c94edc90", "patch": "@@ -1,3 +1,7 @@\n+2020-03-09  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* g++.dg/coroutines/torture/co-ret-15-default-return_void.C: New.\n+\n 2020-03-09  Kewen Lin  <linkw@gcc.gnu.org>\n \n \tPR testsuite/94019"}, {"sha": "e600feae1299a6066519f33fc9d4c2a0e51c0f99", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-15-default-return_void.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-15-default-return_void.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016d0f9e43c1d2bd8227751b5b20a309c94edc90/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-15-default-return_void.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-15-default-return_void.C?ref=016d0f9e43c1d2bd8227751b5b20a309c94edc90", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run }\n+//\n+// Check if default return_void is insert at correct position.\n+#include <cassert>\n+#include \"../coro.h\"\n+\n+class resumable {\n+public:\n+  class promise_type;\n+  using coro_handle = std::coroutine_handle<promise_type>;\n+  resumable(coro_handle handle) : handle_(handle) { assert(handle); }\n+  resumable(resumable&) = delete;\n+  resumable(resumable&&) = delete;\n+  bool resume() {\n+    if (!handle_.done())\n+      handle_.resume();\n+    return !handle_.done();\n+  }\n+  int recent_val();\n+  ~resumable() { handle_.destroy(); }\n+private:\n+  coro_handle handle_;\n+};\n+\n+class resumable::promise_type {\n+public:\n+  friend class resumable;\n+  using coro_handle = std::coroutine_handle<promise_type>;\n+  auto get_return_object() { return coro_handle::from_promise(*this); }\n+  auto initial_suspend() { return std::suspend_always(); }\n+  auto final_suspend() { return std::suspend_always(); }\n+  void return_void() { value_ = -1; }\n+  void unhandled_exception() {}\n+private:\n+  int value_ = 0;\n+};\n+\n+int resumable::recent_val() {return handle_.promise().value_;}\n+\n+resumable foo(int n){\n+  co_await std::suspend_always();\n+  throw 1;\n+}\n+\n+int bar (int n) {\n+  resumable res = foo(n);\n+  while(res.resume());\n+  return res.recent_val();\n+}\n+\n+int main() {\n+  int res = bar(3);\n+  assert(res == 0);\n+  return 0;\n+}"}]}