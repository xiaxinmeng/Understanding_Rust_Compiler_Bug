{"sha": "b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjY2E1ZWNiYjI4NDE4MTFhNmM2YWVhYTQwYTMwNDAyODlhZWJhMw==", "commit": {"author": {"name": "Caroline Tice", "email": "cmtice@google.com", "date": "2015-08-02T01:17:39Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2015-08-02T01:17:39Z"}, "message": "re PR bootstrap/66521 (xgcc: cc1plus segfaults when compiling libstdc++-v3/src/c++11/ostream-inst.cc)\n\nFix PR 66521\n\nlibvtv/ChangeLog\n\n2015-08-01  Caroline Tice  <cmtice@google.com>\n\n        PR 66521\n        * Makefile.am: Update to match latest tree.\n        * Makefile.in: Regenerate.\n        * testsuite/lib/libvtv: Brought up to date.\n        * vtv_malloc.cc (VTV_DEBUG): Update function call to match renamed\n        function (old bug!).\n        * vtv_rts.cc (debug_functions, debug_init, debug_verify_vtable): Update\n        initializations to work correctly with VTV_DEBUG defined.\n\ngcc/ChangeLog:\n\n2015-08-01  Caroline Tice  <cmtice@google.com>\n\n        PR 66521\n        * vtable-verify.c (vtbl_mangled_name_types, vtbl_mangled_name_ids): New\n        global variables.\n        (vtbl_find_mangled_name):  New function.\n        (vtbl_register_mangled_name):  New function.\n        (vtbl_map_get_node):  If DECL_ASSEMBLER_NAME is \"<anon>\", look up\n        mangled name in mangled name vectors.\n        (find_or_create_vtbl_map_node):  Ditto.\n        (var_is_used_for_virtual_call_p):  Add recursion_depth parameter;\n        update recursion_depth on function entry; pass it to every recursive\n        call; automatically exit if depth > 25 (give up looking at that point).\n        (verify_bb_vtables):  Initialize recursion_depth and pass it to\n        var_is_used_for_virtual_call_p.\n        * vtable-verify.h (vtbl_mangbled_name_types, vtbl_mangled_name_ids): New\n        global variable decls.\n        (vtbl_register_mangled_name): New extern function decl.\n\ngcc/cp/ChangeLog:\n2015-08-01  Caroline Tice  <cmtice@google.com>\n\n        PR 66521\n        * mangle.c : Add vtable-verify.h to include files.\n        (get_mangled_vtable_map_var_name):  If the DECL_ASSEMBLER_NAME\n        is \"<anon>\" get the real mangled name for the class instead, and\n        also store the real mangled name in a vector for use later.\n\nFrom-SVN: r226471", "tree": {"sha": "542c49f18581e9f2ecf6316e769cb4cee782b47c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/542c49f18581e9f2ecf6316e769cb4cee782b47c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/comments", "author": {"login": "cmtice", "id": 5561162, "node_id": "MDQ6VXNlcjU1NjExNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/5561162?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cmtice", "html_url": "https://github.com/cmtice", "followers_url": "https://api.github.com/users/cmtice/followers", "following_url": "https://api.github.com/users/cmtice/following{/other_user}", "gists_url": "https://api.github.com/users/cmtice/gists{/gist_id}", "starred_url": "https://api.github.com/users/cmtice/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cmtice/subscriptions", "organizations_url": "https://api.github.com/users/cmtice/orgs", "repos_url": "https://api.github.com/users/cmtice/repos", "events_url": "https://api.github.com/users/cmtice/events{/privacy}", "received_events_url": "https://api.github.com/users/cmtice/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "68e3e6a259b235add2d0c0f7dc3f92e7a47c5e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e3e6a259b235add2d0c0f7dc3f92e7a47c5e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e3e6a259b235add2d0c0f7dc3f92e7a47c5e90"}], "stats": {"total": 219, "additions": 186, "deletions": 33}, "files": [{"sha": "ea9dbe11596dc18e4e4c7710f89b6c5f5638e323", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -1,3 +1,22 @@\n+2015-08-01  Caroline Tice  <cmtice@google.com>\n+\n+\tPR 66521\n+\t* vtable-verify.c (vtbl_mangled_name_types, vtbl_mangled_name_ids): New\n+\tglobal variables.\n+\t(vtbl_find_mangled_name):  New function.\n+\t(vtbl_register_mangled_name):  New function.\n+\t(vtbl_map_get_node):  If DECL_ASSEMBLER_NAME is \"<anon>\", look up\n+\tmangled name in mangled name vectors.\n+\t(find_or_create_vtbl_map_node):  Ditto.\n+\t(var_is_used_for_virtual_call_p):  Add recursion_depth parameter;\n+\tupdate recursion_depth on function entry; pass it to every recursive\n+\tcall; automatically exit if depth > 25 (give up looking at that point).\n+\t(verify_bb_vtables):  Initialize recursion_depth and pass it to\n+\tvar_is_used_for_virtual_call_p.\n+\t* vtable-verify.h (vtbl_mangbled_name_types, vtbl_mangled_name_ids): New\n+\tglobal variable decls.\n+\t(vtbl_register_mangled_name): New extern function decl.\n+\n 2015-08-01  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree.c (operation_can_overflow, operation_no_trapping_overflow): New"}, {"sha": "db7d616df0b30072489eba5b44e7a5cfb1a33add", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -1,3 +1,11 @@\n+2015-08-01  Caroline Tice  <cmtice@google.com>\n+\n+\tPR 66521\n+\t* mangle.c : Add vtable-verify.h to include files.\n+\t(get_mangled_vtable_map_var_name):  If the DECL_ASSEMBLER_NAME\n+\tis \"<anon>\" get the real mangled name for the class instead, and\n+\talso store the real mangled name in a vector for use later.\n+\n 2015-07-31  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/66977"}, {"sha": "d471f4f0a0681945eca64ce3e4af0de49d997f45", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"cgraph.h\"\n #include \"attribs.h\"\n+#include \"vtable-verify.h\"\n \n /* Debugging support.  */\n \n@@ -4036,6 +4037,13 @@ get_mangled_vtable_map_var_name (tree class_type)\n   gcc_assert (TREE_CODE (class_type) == RECORD_TYPE);\n \n   tree class_id = DECL_ASSEMBLER_NAME (TYPE_NAME (class_type));\n+\n+  if (strstr (IDENTIFIER_POINTER (class_id), \"<anon>\") != NULL)\n+    {\n+      class_id = get_mangled_id (TYPE_NAME (class_type));\n+      vtbl_register_mangled_name (TYPE_NAME (class_type), class_id);\n+    }\n+\n   unsigned int len = strlen (IDENTIFIER_POINTER (class_id)) +\n                      strlen (prefix) +\n                      strlen (postfix) + 1;"}, {"sha": "a8345882045fba8b15cabf6116b78d4d9606ecaa", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -310,6 +310,70 @@ static vtbl_map_table_type *vtbl_map_hash;\n /* Vtable map variable nodes stored in a vector.  */\n vec<struct vtbl_map_node *> vtbl_map_nodes_vec;\n \n+/* Vector of mangled names for anonymous classes.  */\n+extern GTY(()) vec<tree, va_gc> *vtbl_mangled_name_types;\n+extern GTY(()) vec<tree, va_gc> *vtbl_mangled_name_ids;\n+vec<tree, va_gc> *vtbl_mangled_name_types;\n+vec<tree, va_gc> *vtbl_mangled_name_ids;\n+\n+/* Look up class_type (a type decl for record types) in the vtbl_mangled_names_*\n+   vectors.  This is a linear lookup.  Return the associated mangled name for\n+   the class type.  This is for handling types from anonymous namespaces, whose\n+   DECL_ASSEMBLER_NAME ends up being \"<anon>\", which is useless for our\n+   purposes.\n+\n+   We use two vectors of trees to keep track of the mangled names:  One is a\n+   vector of class types and the other is a vector of the mangled names.  The\n+   assumption is that these two vectors are kept in perfect lock-step so that\n+   vtbl_mangled_name_ids[i] is the mangled name for\n+   vtbl_mangled_name_types[i].  */\n+\n+static tree\n+vtbl_find_mangled_name (tree class_type)\n+{\n+  tree result = NULL_TREE;\n+  unsigned i;\n+\n+  if (!vtbl_mangled_name_types or !vtbl_mangled_name_ids)\n+    return result;\n+\n+  if (vtbl_mangled_name_types->length() != vtbl_mangled_name_ids->length())\n+    return result;\n+\n+  for (i = 0; i < vtbl_mangled_name_types->length(); ++i)\n+    if ((*vtbl_mangled_name_types)[i] == class_type)\n+      {\n+\tresult = (*vtbl_mangled_name_ids)[i];\n+\tbreak;\n+      }\n+\n+  return result;\n+}\n+\n+/* Store a class type decl and its mangled name, for an anonymous RECORD_TYPE,\n+   in the vtbl_mangled_names vector.  Make sure there is not already an\n+   entry for the class type before adding it.  */\n+\n+void\n+vtbl_register_mangled_name (tree class_type, tree mangled_name)\n+{\n+  if (!vtbl_mangled_name_types)\n+    vec_alloc (vtbl_mangled_name_types, 10);\n+\n+  if (!vtbl_mangled_name_ids)\n+    vec_alloc (vtbl_mangled_name_ids, 10);\n+\n+  gcc_assert (vtbl_mangled_name_types->length() ==\n+\t      vtbl_mangled_name_ids->length());\n+    \n+\n+  if (vtbl_find_mangled_name (class_type) == NULL_TREE)\n+    {\n+      vec_safe_push (vtbl_mangled_name_types, class_type);\n+      vec_safe_push (vtbl_mangled_name_ids, mangled_name);\n+    }\n+}\n+\n /* Return vtbl_map node for CLASS_NAME  without creating a new one.  */\n \n struct vtbl_map_node *\n@@ -339,6 +403,9 @@ vtbl_map_get_node (tree class_type)\n   gcc_assert (HAS_DECL_ASSEMBLER_NAME_P (class_type_decl));\n   class_name = DECL_ASSEMBLER_NAME (class_type_decl);\n \n+  if (strstr (IDENTIFIER_POINTER (class_name), \"<anon>\") != NULL)\n+    class_name = vtbl_find_mangled_name (class_type_decl);\n+\n   key.class_name = class_name;\n   slot = (struct vtbl_map_node **) vtbl_map_hash->find_slot (&key, NO_INSERT);\n   if (!slot)\n@@ -370,6 +437,10 @@ find_or_create_vtbl_map_node (tree base_class_type)\n \n   gcc_assert (HAS_DECL_ASSEMBLER_NAME_P (class_type_decl));\n   key.class_name = DECL_ASSEMBLER_NAME (class_type_decl);\n+\n+  if (strstr (IDENTIFIER_POINTER (key.class_name), \"<anon>\") != NULL)\n+    key.class_name = vtbl_find_mangled_name (class_type_decl);\n+\n   slot = (struct vtbl_map_node **) vtbl_map_hash->find_slot (&key, INSERT);\n \n   if (*slot)\n@@ -482,7 +553,8 @@ extract_object_class_type (tree rhs)\n    the use chain.  */\n \n static bool\n-var_is_used_for_virtual_call_p (tree lhs, int *mem_ref_depth)\n+var_is_used_for_virtual_call_p (tree lhs, int *mem_ref_depth,\n+\t\t\t\tint *recursion_depth)\n {\n   imm_use_iterator imm_iter;\n   bool found_vcall = false;\n@@ -494,6 +566,14 @@ var_is_used_for_virtual_call_p (tree lhs, int *mem_ref_depth)\n   if (*mem_ref_depth > 2)\n     return false;\n \n+  if (*recursion_depth > 25)\n+    /* If we've recursed this far the chances are pretty good that\n+       we're not going to find what we're looking for, and that we've\n+       gone down a recursion black hole. Time to stop.  */\n+    return false;\n+\n+  *recursion_depth = *recursion_depth + 1;\n+\n   /* Iterate through the immediate uses of the current variable.  If\n      it's a virtual function call, we're done.  Otherwise, if there's\n      an LHS for the use stmt, add the ssa var to the work list\n@@ -516,7 +596,8 @@ var_is_used_for_virtual_call_p (tree lhs, int *mem_ref_depth)\n         {\n           found_vcall = var_is_used_for_virtual_call_p\n \t                                            (gimple_phi_result (stmt2),\n-\t                                             mem_ref_depth);\n+\t                                             mem_ref_depth,\n+\t\t\t\t\t\t     recursion_depth);\n         }\n       else if (is_gimple_assign (stmt2))\n         {\n@@ -538,7 +619,8 @@ var_is_used_for_virtual_call_p (tree lhs, int *mem_ref_depth)\n \t  if (*mem_ref_depth < 3)\n \t    found_vcall = var_is_used_for_virtual_call_p\n \t                                            (gimple_assign_lhs (stmt2),\n-\t\t\t\t\t\t     mem_ref_depth);\n+\t\t\t\t\t\t     mem_ref_depth,\n+\t\t\t\t\t\t     recursion_depth);\n         }\n \n       else\n@@ -595,9 +677,11 @@ verify_bb_vtables (basic_block bb)\n           tree tmp0;\n           bool found;\n \t  int mem_ref_depth = 0;\n+\t  int recursion_depth = 0;\n \n           /* Make sure this vptr field access is for a virtual call.  */\n-          if (!var_is_used_for_virtual_call_p (lhs, &mem_ref_depth))\n+          if (!var_is_used_for_virtual_call_p (lhs, &mem_ref_depth,\n+\t\t\t\t\t       &recursion_depth))\n             continue;\n \n           /* Now we have found the virtual method dispatch and"}, {"sha": "178ba3635014cd00d8d5a103a1f4b2163baa7c87", "filename": "gcc/vtable-verify.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fvtable-verify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/gcc%2Fvtable-verify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.h?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -127,6 +127,11 @@ extern bool vtv_debug;\n /* The global vector of vtbl_map_nodes.  */\n extern vec<struct vtbl_map_node *> vtbl_map_nodes_vec;\n \n+/*  The global vectors for mangled class names for anonymous classes.  */\n+extern GTY(()) vec<tree, va_gc> *vtbl_mangled_name_types;\n+extern GTY(()) vec<tree, va_gc> *vtbl_mangled_name_ids;\n+\n+extern void vtbl_register_mangled_name (tree, tree);\n extern struct vtbl_map_node *vtbl_map_get_node (tree);\n extern struct vtbl_map_node *find_or_create_vtbl_map_node (tree);\n extern void vtbl_map_node_class_insert (struct vtbl_map_node *, unsigned);"}, {"sha": "612c660d668c12f8202a31db96dd480ab44539b3", "filename": "libvtv/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2FChangeLog?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -1,3 +1,14 @@\n+2015-08-01  Caroline Tice  <cmtice@google.com>\n+\n+\tPR 66521\n+\t* Makefile.am:  Update to match latest tree.\n+\t* Makefile.in: Regenerate.\n+\t* testsuite/lib/libvtv: Brought up to date.\n+\t* vtv_malloc.cc (VTV_DEBUG): Update function call to match renamed\n+\tfunction (old bug!).\n+\t* vtv_rts.cc (debug_functions, debug_init, debug_verify_vtable): Update\n+\tinitializations to work correctly with VTV_DEBUG defined.\n+\n 2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n \n \t* Makefile.in: Regenerated with automake-1.11.6."}, {"sha": "561b7e25448e27f1236ee70a80b0ce5110194ef7", "filename": "libvtv/testsuite/Makefile.am", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2FMakefile.am?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -1,11 +1,13 @@\n-## Process this with automake to create Makefile.in\n+## Process this file with automake to produce Makefile.in.\n \n AUTOMAKE_OPTIONS = foreign dejagnu\n \n-EXPECT = `if [ -f ../../expect/expect ] ; then \\\n-\t  echo ../../expect/expect ; \\\n-\t  else echo expect ; fi`\n+# May be used by various substitution variables.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n \n-RUNTEST = `if [ -f ${srcdir}/../../dejagnu/runtest ] ; then \\\n-\t   echo ${srcdir}/../../dejagnu/runtest ; \\\n-\t   else echo runtest ;  fi`\n+EXPECT = $(shell if test -f $(top_builddir)/../expect/expect; then \\\n+\t   echo $(top_builddir)/../expect/expect; else echo expect; fi)\n+\n+_RUNTEST = $(shell if test -f $(top_srcdir)/../dejagnu/runtest; then \\\n+\t     echo $(top_srcdir)/../dejagnu/runtest; else echo runtest; fi)\n+RUNTEST = \"$(_RUNTEST) $(AM_RUNTESTFLAGS)\""}, {"sha": "e19e13e7e5ff1bfdb9872d3294c4a68c89ec7f5e", "filename": "libvtv/testsuite/Makefile.in", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2FMakefile.in?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -217,14 +217,16 @@ top_srcdir = @top_srcdir@\n toplevel_builddir = @toplevel_builddir@\n toplevel_srcdir = @toplevel_srcdir@\n AUTOMAKE_OPTIONS = foreign dejagnu\n-EXPECT = `if [ -f ../../expect/expect ] ; then \\\n-\t  echo ../../expect/expect ; \\\n-\t  else echo expect ; fi`\n \n-RUNTEST = `if [ -f ${srcdir}/../../dejagnu/runtest ] ; then \\\n-\t   echo ${srcdir}/../../dejagnu/runtest ; \\\n-\t   else echo runtest ;  fi`\n+# May be used by various substitution variables.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+EXPECT = $(shell if test -f $(top_builddir)/../expect/expect; then \\\n+\t   echo $(top_builddir)/../expect/expect; else echo expect; fi)\n \n+_RUNTEST = $(shell if test -f $(top_srcdir)/../dejagnu/runtest; then \\\n+\t     echo $(top_srcdir)/../dejagnu/runtest; else echo runtest; fi)\n+\n+RUNTEST = \"$(_RUNTEST) $(AM_RUNTESTFLAGS)\"\n all: all-am\n \n .SUFFIXES:"}, {"sha": "aefcbd26ef4fab5b9e4ec03ec7e1d2ddaa45c891", "filename": "libvtv/testsuite/lib/libvtv.exp", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Ftestsuite%2Flib%2Flibvtv.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Ftestsuite%2Flib%2Flibvtv.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Flib%2Flibvtv.exp?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -23,24 +23,28 @@ proc load_gcc_lib { filename } {\n }\n \n load_lib dg.exp\n-load_gcc_lib file-format.exp\n+\n+# Required to use gcc-dg.exp - however, the latter should NOT be\n+#\u00a0loaded until ${tool}_target_compile is defined since it uses that\n+# to determine default LTO options.\n+\n+load_gcc_lib prune.exp\n+load_gcc_lib target-libpath.exp\n+load_gcc_lib wrapper.exp\n load_gcc_lib target-supports.exp\n-load_gcc_lib target-supports-dg.exp\n load_gcc_lib target-utils.exp\n+load_gcc_lib gcc-defs.exp\n+load_gcc_lib timeout.exp\n+load_gcc_lib file-format.exp\n+load_gcc_lib target-supports-dg.exp\n load_gcc_lib scanasm.exp\n load_gcc_lib scandump.exp\n load_gcc_lib scanrtl.exp\n load_gcc_lib scantree.exp\n load_gcc_lib scanipa.exp\n-load_gcc_lib prune.exp\n-load_gcc_lib target-libpath.exp\n-load_gcc_lib wrapper.exp\n-load_gcc_lib gcc-defs.exp\n-load_gcc_lib torture-options.exp\n-load_gcc_lib timeout.exp\n load_gcc_lib timeout-dg.exp\n+load_gcc_lib torture-options.exp\n load_gcc_lib fortran-modules.exp\n-load_gcc_lib gcc-dg.exp\n \n set dg-do-what-default run\n \n@@ -143,10 +147,20 @@ proc libvtv_init { args } {\n     }\n     lappend ALWAYS_CFLAGS \"additional_flags=-I${srcdir}/..\"\n \n+    # We use atomic operations in the testcases to validate results.\n+    if { ([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t && [check_effective_target_ia32] } {\n+\tlappend ALWAYS_CFLAGS \"additional_flags=-march=i486\"\n+    }\n+\n     if [istarget *-*-darwin*] {\n \tlappend ALWAYS_CFLAGS \"additional_flags=-shared-libgcc\"\n     }\n \n+    if [istarget sparc*-*-*] {\n+\tlappend ALWAYS_CFLAGS \"additional_flags=-mcpu=v9\"\n+    }\n+\n     if [info exists TOOL_OPTIONS] {\n \tlappend ALWAYS_CFLAGS \"additional_flags=$TOOL_OPTIONS\"\n     }\n@@ -155,9 +169,8 @@ proc libvtv_init { args } {\n     # error-message parsing machinery.\n     lappend ALWAYS_CFLAGS \"additional_flags=-fmessage-length=0\"\n \n-    # Turn on vtable verification\n-    lappend ALWAYS_CFLAGS \"-fvtable-verify=std\"\n-    # lappend ALWAYS_CFLAGS \"ldflags=-lvtv\"\n+    # Turn on vtable verification.\n+    lappend ALWAYS_CFLAGS \"additional_flags=-fvtable-verify=std\"\n }\n \n #"}, {"sha": "5249248ce82f051abde40be9dd30031928c7545b", "filename": "libvtv/vtv_malloc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Fvtv_malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Fvtv_malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_malloc.cc?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -145,7 +145,7 @@ change_protections_on_data_chunks (int protection_flag)\n     }\n \n #ifdef VTV_DEBUG\n-    VTV_malloc_dump_stats ();\n+    __vtv_malloc_dump_stats ();\n #endif\n }\n "}, {"sha": "7bde2f46e4f308fee5f6130c0c93daa6cfc4b305", "filename": "libvtv/vtv_rts.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Fvtv_rts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cca5ecbb2841811a6c6aeaa40a3040289aeba3/libvtv%2Fvtv_rts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_rts.cc?ref=b0cca5ecbb2841811a6c6aeaa40a3040289aeba3", "patch": "@@ -201,14 +201,15 @@ unsigned long long verify_vtable_cycles = 0;\n    debugging/tracing will not be ON on production environments */\n \n static const bool debug_hash = HASHTABLE_STATS;\n-static const int debug_functions = 0;\n-static const int debug_init = 0;\n-static const int debug_verify_vtable = 0;\n \n #ifdef VTV_DEBUG\n static const int debug_functions = 1;\n static const int debug_init = 1;\n static const int debug_verify_vtable = 1;\n+#else\n+static const int debug_functions = 0;\n+static const int debug_init = 0;\n+static const int debug_verify_vtable = 0;\n #endif\n \n /* Global file descriptor variables for logging, tracing and debugging.  */"}]}