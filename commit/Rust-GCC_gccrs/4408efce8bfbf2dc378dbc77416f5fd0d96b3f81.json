{"sha": "4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQwOGVmY2U4YmZiZjJkYzM3OGRiYzc3NDE2ZjVmZDBkOTZiM2Y4MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-05T15:52:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-05T15:52:34Z"}, "message": "sh.c (trap_exit, sp_switch): New variables.\n\n\t* sh.c (trap_exit, sp_switch): New variables.\n\t(print_operand, case '@'): If trap_exit is nonzero, then use\n\ta trapa instead of an rte/rts to exit the current function.\n\t(sh_expand_prologue): Switch stacks at function entry as needed.\n\t(sh_expand_epilogue): Similarly at function exit.\n\t(function_epilogue): Clear trap_exit and sp_switch too.\n\t(sh_valid_machine_decl_attribute): New function.\n\t* sh.h (VALID_MACHINE_DECL_ATTRIBUTE): Define.\n\t(sp_switch): Declare.\n\t* sh.md (sp_switch_1, sp_switch_2): New named patterns.\n\nFrom-SVN: r14148", "tree": {"sha": "d5842c80a99dd931b8bff0664169a4ac2160a951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5842c80a99dd931b8bff0664169a4ac2160a951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/comments", "author": null, "committer": null, "parents": [{"sha": "916b1701c2f14c41c71a8dc6816e49a24e9609e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b1701c2f14c41c71a8dc6816e49a24e9609e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916b1701c2f14c41c71a8dc6816e49a24e9609e4"}], "stats": {"total": 133, "additions": 130, "deletions": 3}, "files": [{"sha": "fb723ba5b34b924089c2f2c902dfba026f9e7aa9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 94, "deletions": 3, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "patch": "@@ -43,6 +43,16 @@ Boston, MA 02111-1307, USA.  */\n    output code for the next function appropriate for an interrupt handler.  */\n int pragma_interrupt;\n \n+/* This is set by the trap_exit attribute for functions.   It specifies\n+   a trap number to be used in a trapa instruction at function exit\n+   (instead of an rte instruction).  */\n+int trap_exit;\n+\n+/* This is used by the sp_switch attribute for functions.  It specifies\n+   a variable holding the address of the stack the interrupt function\n+   should switch to/from at entry/exit.  */\n+rtx sp_switch;\n+\n /* This is set by #pragma trapa, and is similar to the above, except that\n    the compiler doesn't emit code to preserve all registers.  */\n static int pragma_trapa;\n@@ -160,7 +170,7 @@ print_operand_address (stream, x)\n    according to modifier code.\n \n    '.'  print a .s if insn needs delay slot\n-   '@'  print rte or rts depending upon pragma interruptness\n+   '@'  print trap, rte or rts depending upon pragma interruptness\n    '#'  output a nop if there is nothing to put in the delay slot\n    'O'  print a constant without the #\n    'R'  print the LSW of a dp value - changes if in little endian\n@@ -181,7 +191,9 @@ print_operand (stream, x, code)\n \tfprintf (stream, \".s\");\n       break;\n     case '@':\n-      if (pragma_interrupt)\n+      if (trap_exit)\n+\tfprintf (stream, \"trapa #%d\", trap_exit);\n+      else if (pragma_interrupt)\n \tfprintf (stream, \"rte\");\n       else\n \tfprintf (stream, \"rts\");\n@@ -2670,6 +2682,10 @@ sh_expand_prologue ()\n         }\n     }\n \n+  /* If we're supposed to switch stacks at function entry, do so now.  */\n+  if (sp_switch)\n+    emit_insn (gen_sp_switch_1 ());\n+\n   push_regs (live_regs_mask, live_regs_mask2);\n \n   output_stack_adjust (-get_frame_size (), stack_pointer_rtx, 3);\n@@ -2712,6 +2728,10 @@ sh_expand_epilogue ()\n \n   output_stack_adjust (extra_push + current_function_pretend_args_size,\n \t\t       stack_pointer_rtx, 7);\n+\n+  /* Switch back to the normal stack if necessary.  */\n+  if (sp_switch)\n+    emit_insn (gen_sp_switch_2 ());\n }\n \n /* Clear variables at function end.  */\n@@ -2721,7 +2741,8 @@ function_epilogue (stream, size)\n      FILE *stream;\n      int size;\n {\n-  pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n+  trap_exit = pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n+  sp_switch = NULL_RTX;\n }\n \n rtx\n@@ -2847,6 +2868,76 @@ handle_pragma (file, t)\n \n   return retval;\n }\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.\n+\n+   Supported attributes:\n+\n+   interrupt_handler -- specifies this function is an interrupt handler.\n+\n+   sp_switch -- specifies an alternate stack for an interrupt handler\n+   to run on.\n+\n+   trap_exit -- use a trapa to exit an interrupt function intead of\n+   an rte instruction.  */\n+\n+int\n+sh_valid_machine_decl_attribute (decl, attributes, attr, args)\n+     tree decl;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  int retval = 0;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    return 0;\n+\n+  if (is_attribute_p (\"interrupt_handler\", attr))\n+    {\n+      pragma_interrupt = 1;\n+      return 1;\n+    }\n+\n+  if (is_attribute_p (\"sp_switch\", attr))\n+    {\n+      /* The sp_switch attribute only has meaning for interrupt functions.  */\n+      if (!pragma_interrupt)\n+\treturn 0;\n+\n+      /* sp_switch must have an argument.  */\n+      if (!args || TREE_CODE (args) != TREE_LIST)\n+\treturn 0;\n+\n+      /* The argument must be a constant string.  */\n+      if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n+\treturn 0;\n+\n+      sp_switch = gen_rtx (SYMBOL_REF, VOIDmode,\n+\t\t\t   TREE_STRING_POINTER (TREE_VALUE (args)));\n+      return 1;\n+    }\n+\n+  if (is_attribute_p (\"trap_exit\", attr))\n+    {\n+      /* The trap_exit attribute only has meaning for interrupt functions.  */\n+      if (!pragma_interrupt)\n+\treturn 0;\n+\n+      /* trap_exit must have an argument.  */\n+      if (!args || TREE_CODE (args) != TREE_LIST)\n+\treturn 0;\n+\n+      /* The argument must be a constant integer.  */\n+      if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n+\treturn 0;\n+\n+      trap_exit = TREE_INT_CST_LOW (TREE_VALUE (args));\n+      return 1;\n+    }\n+}\n+\n \f\n /* Predicates used by the templates.  */\n "}, {"sha": "ce5e26a3300b47dace4de2ed83ceeffb556938cf", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "patch": "@@ -1639,6 +1639,18 @@ extern char *output_far_jump();\n \n extern int pragma_interrupt;\n \n+/* Set to an RTX containing the address of the stack to switch to\n+   for interrupt functions.  */\n+extern struct rtx_def *sp_switch;\n+\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+extern int sh_valid_machine_decl_attribute ();\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+\n #define MOVE_RATIO (TARGET_SMALLCODE ? 2 : 16)\n \f\n /* Instructions with unfilled delay slots take up an extra two bytes for"}, {"sha": "d0f79ff37184b580bbb6a3be3c86f0c4c8d78fbf", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4408efce8bfbf2dc378dbc77416f5fd0d96b3f81/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=4408efce8bfbf2dc378dbc77416f5fd0d96b3f81", "patch": "@@ -2827,3 +2827,27 @@\n \t   && REGNO (SUBREG_REG (operands[2])) >= FIRST_FP_REG))\n    && reg_unused_after (operands[0], insn)\"\n   \"fmov.s\t@(%0,%1),%2\")\n+\n+;; Switch to a new stack with its address in sp_switch (a SYMBOL_REF).  */\n+(define_insn \"sp_switch_1\"\n+  [(const_int 1)]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[1];\n+\n+  xoperands[0] = sp_switch;\n+  output_asm_insn (\\\"mov.l r0,@-r15\\;mov.l %0,r0\\\", xoperands);\n+  output_asm_insn (\\\"mov.l @r0,r0\\;mov.l r15,@-r0\\\", xoperands);\n+  return \\\"mov r0,r15\\\";\n+}\"\n+  [(set_attr \"length\" \"10\")])\n+   (set_attr \"type\" \"move\")])\n+\n+;; Switch back to the original stack for interrupt funtions with the\n+;; sp_switch attribute.  */\n+(define_insn \"sp_switch_2\"\n+  [(const_int 2)]\n+  \"\"\n+  \"mov.l @r15+,r15\\;mov.l @r15+,r0\"\n+  [(set_attr \"length\" \"4\")])"}]}