{"sha": "531b10fcb0fe5c86576bda5fd201d8acc7db4525", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxYjEwZmNiMGZlNWM4NjU3NmJkYTVmZDIwMWQ4YWNjN2RiNDUyNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-02T18:50:51Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-02T18:50:51Z"}, "message": "stmt.c (emit_case_bit_tests): Remove.\n\ngcc/\n\t* stmt.c (emit_case_bit_tests): Remove.\n\t(expand_case): Remove expand_switch_using_bit_tests_p code.\n\t* tree-switch-conversion.c (hoist_edge_and_branch_if_true): New.\n\t(MAX_CASE_BIT_TESTS): Moved from stmt.c to here.\n\t(lshift_cheap_p): Likewise.\n\t(expand_switch_using_bit_tests_p): Likewise.\n\t(struct case_bit_test): Likewise.\n\t(case_bit_test_cmp): Likewise.\n\t(emit_case_bit_tests): New implementation for GIMPLE.\n\t(gen_inbound_check): Do not release post-dominator info here.\n\t(process_switch): Reorder code.  Expand as bit tests if it\n\tlooks like a win.\n\t(do_switchconv): Release post-dominator info here if something\n\tchanged.\n\t(struct gimple_opt_pass): Verify more.\n\t* tree.h (expand_switch_using_bit_tests_p): Remove prototype.\n\ntestsuite/\n\t* gcc.dg/tree-ssa/pr36881.c: Fix test case to not expand as bit tests.\n\nFrom-SVN: r189173", "tree": {"sha": "2c4953f29803cb45e33d5e4c0629352930996603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c4953f29803cb45e33d5e4c0629352930996603"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/531b10fcb0fe5c86576bda5fd201d8acc7db4525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531b10fcb0fe5c86576bda5fd201d8acc7db4525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531b10fcb0fe5c86576bda5fd201d8acc7db4525", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531b10fcb0fe5c86576bda5fd201d8acc7db4525/comments", "author": null, "committer": null, "parents": [{"sha": "8153b03d4ba0090c68bf08239a582852c51ee920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8153b03d4ba0090c68bf08239a582852c51ee920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8153b03d4ba0090c68bf08239a582852c51ee920"}], "stats": {"total": 764, "additions": 525, "deletions": 239}, "files": [{"sha": "bee63bb8f1330cf0bcbadfbd7907d38e19c02784", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=531b10fcb0fe5c86576bda5fd201d8acc7db4525", "patch": "@@ -1,3 +1,22 @@\n+2012-07-02  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* stmt.c (emit_case_bit_tests): Remove.\n+\t(expand_case): Remove expand_switch_using_bit_tests_p code.\n+\t* tree-switch-conversion.c (hoist_edge_and_branch_if_true): New.\n+\t(MAX_CASE_BIT_TESTS): Moved from stmt.c to here.\n+\t(lshift_cheap_p): Likewise.\n+\t(expand_switch_using_bit_tests_p): Likewise.\n+\t(struct case_bit_test): Likewise.\n+\t(case_bit_test_cmp): Likewise.\n+\t(emit_case_bit_tests): New implementation for GIMPLE.\n+\t(gen_inbound_check): Do not release post-dominator info here.\n+\t(process_switch): Reorder code.  Expand as bit tests if it\n+\tlooks like a win.\n+\t(do_switchconv): Release post-dominator info here if something\n+\tchanged.\n+\t(struct gimple_opt_pass): Verify more.\n+\t* tree.h (expand_switch_using_bit_tests_p): Remove prototype.\n+\n 2012-07-02  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/38474"}, {"sha": "f06becd25696a4cbf66ded96de71dc3205e369cc", "filename": "gcc/stmt.c", "status": "modified", "additions": 11, "deletions": 198, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=531b10fcb0fe5c86576bda5fd201d8acc7db4525", "patch": "@@ -107,9 +107,6 @@ static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n static void expand_null_return_1 (void);\n static void expand_value_return (rtx);\n-static bool lshift_cheap_p (void);\n-static int case_bit_test_cmp (const void *, const void *);\n-static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, rtx);\n static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n@@ -1719,151 +1716,6 @@ add_case_node (struct case_node *head, tree type, tree low, tree high,\n   return r;\n }\n \f\n-/* Maximum number of case bit tests.  */\n-#define MAX_CASE_BIT_TESTS  3\n-\n-/* A case_bit_test represents a set of case nodes that may be\n-   selected from using a bit-wise comparison.  HI and LO hold\n-   the integer to be tested against, LABEL contains the label\n-   to jump to upon success and BITS counts the number of case\n-   nodes handled by this test, typically the number of bits\n-   set in HI:LO.  */\n-\n-struct case_bit_test\n-{\n-  HOST_WIDE_INT hi;\n-  HOST_WIDE_INT lo;\n-  rtx label;\n-  int bits;\n-};\n-\n-/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n-\n-static\n-bool lshift_cheap_p (void)\n-{\n-  static bool init[2] = {false, false};\n-  static bool cheap[2] = {true, true};\n-\n-  bool speed_p = optimize_insn_for_speed_p ();\n-\n-  if (!init[speed_p])\n-    {\n-      rtx reg = gen_rtx_REG (word_mode, 10000);\n-      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n-\t\t\t       speed_p);\n-      cheap[speed_p] = cost < COSTS_N_INSNS (3);\n-      init[speed_p] = true;\n-    }\n-\n-  return cheap[speed_p];\n-}\n-\n-/* Comparison function for qsort to order bit tests by decreasing\n-   number of case nodes, i.e. the node with the most cases gets\n-   tested first.  */\n-\n-static int\n-case_bit_test_cmp (const void *p1, const void *p2)\n-{\n-  const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n-  const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n-\n-  if (d2->bits != d1->bits)\n-    return d2->bits - d1->bits;\n-\n-  /* Stabilize the sort.  */\n-  return CODE_LABEL_NUMBER (d2->label) - CODE_LABEL_NUMBER (d1->label);\n-}\n-\n-/*  Expand a switch statement by a short sequence of bit-wise\n-    comparisons.  \"switch(x)\" is effectively converted into\n-    \"if ((1 << (x-MINVAL)) & CST)\" where CST and MINVAL are\n-    integer constants.\n-\n-    INDEX_EXPR is the value being switched on, which is of\n-    type INDEX_TYPE.  MINVAL is the lowest case value of in\n-    the case nodes, of INDEX_TYPE type, and RANGE is highest\n-    value minus MINVAL, also of type INDEX_TYPE.  NODES is\n-    the set of case nodes, and DEFAULT_LABEL is the label to\n-    branch to should none of the cases match.\n-\n-    There *MUST* be MAX_CASE_BIT_TESTS or less unique case\n-    node targets.  */\n-\n-static void\n-emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n-\t\t     tree range, case_node_ptr nodes, rtx default_label)\n-{\n-  struct case_bit_test test[MAX_CASE_BIT_TESTS];\n-  enum machine_mode mode;\n-  rtx expr, index, label;\n-  unsigned int i,j,lo,hi;\n-  struct case_node *n;\n-  unsigned int count;\n-\n-  count = 0;\n-  for (n = nodes; n; n = n->right)\n-    {\n-      label = label_rtx (n->code_label);\n-      for (i = 0; i < count; i++)\n-\tif (label == test[i].label)\n-\t  break;\n-\n-      if (i == count)\n-\t{\n-\t  gcc_assert (count < MAX_CASE_BIT_TESTS);\n-\t  test[i].hi = 0;\n-\t  test[i].lo = 0;\n-\t  test[i].label = label;\n-\t  test[i].bits = 1;\n-\t  count++;\n-\t}\n-      else\n-        test[i].bits++;\n-\n-      lo = tree_low_cst (fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t      n->low, minval), 1);\n-      hi = tree_low_cst (fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t\t      n->high, minval), 1);\n-      for (j = lo; j <= hi; j++)\n-        if (j >= HOST_BITS_PER_WIDE_INT)\n-\t  test[i].hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);\n-\telse\n-\t  test[i].lo |= (HOST_WIDE_INT) 1 << j;\n-    }\n-\n-  qsort (test, count, sizeof(*test), case_bit_test_cmp);\n-\n-  index_expr = fold_build2 (MINUS_EXPR, index_type,\n-\t\t\t    fold_convert (index_type, index_expr),\n-\t\t\t    fold_convert (index_type, minval));\n-  index = expand_normal (index_expr);\n-  do_pending_stack_adjust ();\n-\n-  mode = TYPE_MODE (index_type);\n-  expr = expand_normal (range);\n-  if (default_label)\n-    emit_cmp_and_jump_insns (index, expr, GTU, NULL_RTX, mode, 1,\n-\t\t\t     default_label);\n-\n-  index = convert_to_mode (word_mode, index, 0);\n-  index = expand_binop (word_mode, ashl_optab, const1_rtx,\n-\t\t\tindex, NULL_RTX, 1, OPTAB_WIDEN);\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      expr = immed_double_const (test[i].lo, test[i].hi, word_mode);\n-      expr = expand_binop (word_mode, and_optab, index, expr,\n-\t\t\t   NULL_RTX, 1, OPTAB_WIDEN);\n-      emit_cmp_and_jump_insns (expr, const0_rtx, NE, NULL_RTX,\n-\t\t\t       word_mode, 1, test[i].label);\n-    }\n-\n-  if (default_label)\n-    emit_jump (default_label);\n-}\n-\n #ifndef HAVE_casesi\n #define HAVE_casesi 0\n #endif\n@@ -1872,27 +1724,6 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n #define HAVE_tablejump 0\n #endif\n \n-/* Return true if a switch should be expanded as a bit test.\n-   INDEX_EXPR is the index expression, RANGE is the difference between\n-   highest and lowest case, UNIQ is number of unique case node targets\n-   not counting the default case and COUNT is the number of comparisons\n-   needed, not counting the default case.  */\n-bool\n-expand_switch_using_bit_tests_p (tree index_expr, tree range,\n-\t\t\t\t unsigned int uniq, unsigned int count)\n-{\n-  if (optab_handler (ashl_optab, word_mode) == CODE_FOR_nothing)\n-    return false;\n- \n-  return (! TREE_CONSTANT (index_expr)\n-\t  && compare_tree_int (range, GET_MODE_BITSIZE (word_mode)) < 0\n-\t  && compare_tree_int (range, 0) > 0\n-\t  && lshift_cheap_p ()\n-\t  && ((uniq == 1 && count >= 3)\n-\t      || (uniq == 2 && count >= 5)\n-\t      || (uniq == 3 && count >= 6)));\n-}\n-\n /* Return the smallest number of different values for which it is best to use a\n    jump-table instead of a tree of conditional branches.  */\n \n@@ -2035,40 +1866,22 @@ expand_case (gimple stmt)\n       /* Compute span of values.  */\n       range = fold_build2 (MINUS_EXPR, index_type, maxval, minval);\n \n-      /* Try implementing this switch statement by a short sequence of\n-\t bit-wise comparisons.  However, we let the binary-tree case\n-\t below handle constant index expressions.  */\n-      if (expand_switch_using_bit_tests_p (index_expr, range, uniq, count))\n-\t{\n-\t  /* Optimize the case where all the case values fit in a\n-\t     word without having to subtract MINVAL.  In this case,\n-\t     we can optimize away the subtraction.  */\n-\t  if (compare_tree_int (minval, 0) > 0\n-\t      && compare_tree_int (maxval, GET_MODE_BITSIZE (word_mode)) < 0)\n-\t    {\n-\t      minval = build_int_cst (index_type, 0);\n-\t      range = maxval;\n-\t    }\n-\t  emit_case_bit_tests (index_type, index_expr, minval, range,\n-\t\t\t       case_list, default_label);\n-\t}\n-\n       /* If range of values is much bigger than number of values,\n \t make a sequence of conditional branches instead of a dispatch.\n \t If the switch-index is a constant, do it this way\n \t because we can optimize it.  */\n \n-      else if (count < case_values_threshold ()\n-\t       || compare_tree_int (range,\n-\t\t\t\t    (optimize_insn_for_size_p () ? 3 : 10) * count) > 0\n-\t       /* RANGE may be signed, and really large ranges will show up\n-\t\t  as negative numbers.  */\n-\t       || compare_tree_int (range, 0) < 0\n-\t       || !flag_jump_tables\n-\t       || TREE_CONSTANT (index_expr)\n-\t       /* If neither casesi or tablejump is available, we can\n-\t\t  only go this way.  */\n-\t       || (!HAVE_casesi && !HAVE_tablejump))\n+      if (count < case_values_threshold ()\n+\t  || compare_tree_int (range,\n+\t\t\t       (optimize_insn_for_size_p () ? 3 : 10) * count) > 0\n+\t  /* RANGE may be signed, and really large ranges will show up\n+\t     as negative numbers.  */\n+\t  || compare_tree_int (range, 0) < 0\n+\t  || !flag_jump_tables\n+\t  || TREE_CONSTANT (index_expr)\n+\t  /* If neither casesi or tablejump is available, we can\n+\t     only go this way.  */\n+\t  || (!HAVE_casesi && !HAVE_tablejump))\n \t{\n \t  index = expand_normal (index_expr);\n "}, {"sha": "066eb5c209594bea69b772fdfa18d2b7a68319a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=531b10fcb0fe5c86576bda5fd201d8acc7db4525", "patch": "@@ -1,3 +1,7 @@\n+2012-07-02  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* gcc.dg/tree-ssa/pr36881.c: Fix test case to not expand as bit tests.\n+\n 2012-07-01  Wei Guozhi  <carrot@google.com>\n \n \tPR target/53447"}, {"sha": "96922e3a62f8d5a440e080653da287ada8740d38", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr36881.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr36881.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr36881.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr36881.c?ref=531b10fcb0fe5c86576bda5fd201d8acc7db4525", "patch": "@@ -13,7 +13,10 @@ const char *foo (int i)\n     case 7: p = \"abc\"; break;\n     case 2:\n     case 8: p = \"def\"; break;\n-    default: p = \"ghi\"; break;\n+    case 9: p = \"ghi\"; break;\n+    case 5: p = \"jkl\"; break;\n+    case 3: p = \"mno\"; break;\n+    default: p = \"prq\"; break;\n     }\n   return p;\n }"}, {"sha": "de8c9e874d6c84205483c76f942eb2e242d3f619", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 487, "deletions": 38, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=531b10fcb0fe5c86576bda5fd201d8acc7db4525", "patch": "@@ -1,7 +1,7 @@\n-/* Switch Conversion converts variable initializations based on switch\n-   statements to initializations from a static array.\n-   Copyright (C) 2006, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n-   Contributed by Martin Jambor <jamborm@suse.cz>\n+/* Lower GIMPLE_SWITCH expressions to something more efficient than\n+   a jump table.\n+   Copyright (C) 2006, 2008, 2009, 2010, 2011, 2012\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -20,6 +20,458 @@ along with GCC; see the file COPYING3.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n+/* This file handles the lowering of GIMPLE_SWITCH to an indexed\n+   load, or a series of bit-test-and-branch expressions.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"line-map.h\"\n+#include \"params.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-flow-inline.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"langhooks.h\"\n+\n+/* Need to include expr.h and optabs.h for lshift_cheap_p.  */\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+\f\n+/* Maximum number of case bit tests.\n+   FIXME: This should be derived from PARAM_CASE_VALUES_THRESHOLD and\n+\t  targetm.case_values_threshold(), or be its own param.  */\n+#define MAX_CASE_BIT_TESTS  3\n+\n+/* Split the basic block at the statement pointed to by GSIP, and insert\n+   a branch to the target basic block of E_TRUE conditional on tree\n+   expression COND.\n+\n+   It is assumed that there is already an edge from the to-be-split\n+   basic block to E_TRUE->dest block.  This edge is removed, and the\n+   profile information on the edge is re-used for the new conditional\n+   jump.\n+   \n+   The CFG is updated.  The dominator tree will not be valid after\n+   this transformation, but the immediate dominators are updated if\n+   UPDATE_DOMINATORS is true.\n+   \n+   Returns the newly created basic block.  */\n+\n+static basic_block\n+hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,\n+\t\t\t       tree cond, edge e_true,\n+\t\t\t       bool update_dominators)\n+{\n+  tree tmp;\n+  gimple cond_stmt;\n+  edge e_false;\n+  basic_block new_bb, split_bb = gsi_bb (*gsip);\n+  bool dominated_e_true = false;\n+\n+  gcc_assert (e_true->src == split_bb);\n+\n+  if (update_dominators\n+      && get_immediate_dominator (CDI_DOMINATORS, e_true->dest) == split_bb)\n+    dominated_e_true = true;\n+\n+  tmp = force_gimple_operand_gsi (gsip, cond, /*simple=*/true, NULL,\n+\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n+  cond_stmt = gimple_build_cond_from_tree (tmp, NULL_TREE, NULL_TREE);\n+  gsi_insert_before (gsip, cond_stmt, GSI_SAME_STMT);\n+\n+  e_false = split_block (split_bb, cond_stmt);\n+  new_bb = e_false->dest;\n+  redirect_edge_pred (e_true, split_bb);\n+\n+  e_true->flags &= ~EDGE_FALLTHRU;\n+  e_true->flags |= EDGE_TRUE_VALUE;\n+\n+  e_false->flags &= ~EDGE_FALLTHRU;\n+  e_false->flags |= EDGE_FALSE_VALUE;\n+  e_false->probability = REG_BR_PROB_BASE - e_true->probability;\n+  e_false->count = split_bb->count - e_true->count;\n+  new_bb->count = e_false->count;\n+\n+  if (update_dominators)\n+    {\n+      if (dominated_e_true)\n+\tset_immediate_dominator (CDI_DOMINATORS, e_true->dest, split_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, e_false->dest, split_bb);\n+    }\n+\n+  return new_bb;\n+}\n+\n+\n+/* Determine whether \"1 << x\" is relatively cheap in word_mode.  */\n+/* FIXME: This is the function that we need rtl.h and optabs.h for.\n+   This function (and similar RTL-related cost code in e.g. IVOPTS) should\n+   be moved to some kind of interface file for GIMPLE/RTL interactions.  */\n+static bool\n+lshift_cheap_p (void)\n+{\n+  /* FIXME: This should be made target dependent via this \"this_target\"\n+     mechanism, similar to e.g. can_copy_init_p in gcse.c.  */\n+  static bool init[2] = {false, false};\n+  static bool cheap[2] = {true, true};\n+  bool speed_p;\n+\n+  /* If the targer has no lshift in word_mode, the operation will most\n+     probably not be cheap.  ??? Does GCC even work for such targets?  */\n+  if (optab_handler (ashl_optab, word_mode) == CODE_FOR_nothing)\n+    return false;\n+\n+  speed_p = optimize_insn_for_speed_p ();\n+\n+  if (!init[speed_p])\n+    {\n+      rtx reg = gen_raw_REG (word_mode, 10000);\n+      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n+\t\t\t       speed_p);\n+      cheap[speed_p] = cost < COSTS_N_INSNS (MAX_CASE_BIT_TESTS);\n+      init[speed_p] = true;\n+    }\n+\n+  return cheap[speed_p];\n+}\n+\n+/* Return true if a switch should be expanded as a bit test.\n+   RANGE is the difference between highest and lowest case.\n+   UNIQ is number of unique case node targets, not counting the default case.\n+   COUNT is the number of comparisons needed, not counting the default case.  */\n+\n+static bool\n+expand_switch_using_bit_tests_p (tree range,\n+\t\t\t\t unsigned int uniq,\n+\t\t\t\t unsigned int count)\n+{\n+  return (((uniq == 1 && count >= 3)\n+\t   || (uniq == 2 && count >= 5)\n+\t   || (uniq == 3 && count >= 6))\n+\t  && lshift_cheap_p ()\n+\t  && compare_tree_int (range, GET_MODE_BITSIZE (word_mode)) < 0\n+\t  && compare_tree_int (range, 0) > 0);\n+}\n+\f\n+/* Implement switch statements with bit tests\n+\n+A GIMPLE switch statement can be expanded to a short sequence of bit-wise\n+comparisons.  \"switch(x)\" is converted into \"if ((1 << (x-MINVAL)) & CST)\"\n+where CST and MINVAL are integer constants.  This is better than a series\n+of compare-and-banch insns in some cases,  e.g. we can implement:\n+\n+\tif ((x==4) || (x==6) || (x==9) || (x==11))\n+\n+as a single bit test:\n+\n+\tif ((1<<x) & ((1<<4)|(1<<6)|(1<<9)|(1<<11)))\n+\n+This transformation is only applied if the number of case targets is small,\n+if CST constains at least 3 bits, and \"x << 1\" is cheap.  The bit tests are\n+performed in \"word_mode\".\n+\n+The following example shows the code the transformation generates:\n+\n+\tint bar(int x)\n+\t{\n+\t\tswitch (x)\n+\t\t{\n+\t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n+\t\tcase '5':  case '6':  case '7':  case '8':  case '9':\n+\t\tcase 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n+\t\tcase 'F':\n+\t\t\treturn 1;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+==>\n+\n+\tbar (int x)\n+\t{\n+\t\ttmp1 = x - 48;\n+\t\tif (tmp1 > (70 - 48)) goto L2;\n+\t\ttmp2 = 1 << tmp1;\n+\t\ttmp3 = 0b11111100000001111111111;\n+\t\tif ((tmp2 & tmp3) != 0) goto L1 ; else goto L2;\n+\tL1:\n+\t\treturn 1;\n+\tL2:\n+\t\treturn 0;\n+\t}\n+\n+TODO: There are still some improvements to this transformation that could\n+be implemented:\n+\n+* A narrower mode than word_mode could be used if that is cheaper, e.g.\n+  for x86_64 where a narrower-mode shift may result in smaller code.\n+\n+* The compounded constant could be shifted rather than the one.  The\n+  test would be either on the sign bit or on the least significant bit,\n+  depending on the direction of the shift.  On some machines, the test\n+  for the branch would be free if the bit to test is already set by the\n+  shift operation.\n+\n+This transformation was contributed by Roger Sayle, see this e-mail:\n+   http://gcc.gnu.org/ml/gcc-patches/2003-01/msg01950.html\n+*/\n+\n+/* A case_bit_test represents a set of case nodes that may be\n+   selected from using a bit-wise comparison.  HI and LO hold\n+   the integer to be tested against, TARGET_EDGE contains the\n+   edge to the basic block to jump to upon success and BITS\n+   counts the number of case nodes handled by this test,\n+   typically the number of bits set in HI:LO.  The LABEL field\n+   is used to quickly identify all cases in this set without\n+   looking at label_to_block for every case label.  */\n+\n+struct case_bit_test\n+{\n+  HOST_WIDE_INT hi;\n+  HOST_WIDE_INT lo;\n+  edge target_edge;\n+  tree label;\n+  int bits;\n+};\n+\n+/* Comparison function for qsort to order bit tests by decreasing\n+   probability of execution.  Our best guess comes from a measured\n+   profile.  If the profile counts are equal, break even on the\n+   number of case nodes, i.e. the node with the most cases gets\n+   tested first.\n+\n+   TODO: Actually this currently runs before a profile is available.\n+   Therefore the case-as-bit-tests transformation should be done\n+   later in the pass pipeline, or something along the lines of\n+   \"Efficient and effective branch reordering using profile data\"\n+   (Yang et. al., 2002) should be implemented (although, how good\n+   is a paper is called \"Efficient and effective ...\" when the\n+   latter is implied by the former, but oh well...).  */\n+\n+static int\n+case_bit_test_cmp (const void *p1, const void *p2)\n+{\n+  const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n+  const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n+\n+  if (d2->target_edge->count != d1->target_edge->count)\n+    return d2->target_edge->count - d1->target_edge->count;\n+  if (d2->bits != d1->bits)\n+    return d2->bits - d1->bits;\n+\n+  /* Stabilize the sort.  */\n+  return LABEL_DECL_UID (d2->label) - LABEL_DECL_UID (d1->label);\n+}\n+\n+/*  Expand a switch statement by a short sequence of bit-wise\n+    comparisons.  \"switch(x)\" is effectively converted into\n+    \"if ((1 << (x-MINVAL)) & CST)\" where CST and MINVAL are\n+    integer constants.\n+\n+    INDEX_EXPR is the value being switched on.\n+\n+    MINVAL is the lowest case value of in the case nodes,\n+    and RANGE is highest value minus MINVAL.  MINVAL and RANGE\n+    are not guaranteed to be of the same type as INDEX_EXPR\n+    (the gimplifier doesn't change the type of case label values,\n+    and MINVAL and RANGE are derived from those values).\n+\n+    There *MUST* be MAX_CASE_BIT_TESTS or less unique case\n+    node targets.  */\n+\n+static void\n+emit_case_bit_tests (gimple swtch, tree index_expr,\n+\t\t     tree minval, tree range)\n+{\n+  struct case_bit_test test[MAX_CASE_BIT_TESTS];\n+  unsigned int i, j, k;\n+  unsigned int count;\n+\n+  basic_block switch_bb = gimple_bb (swtch);\n+  basic_block default_bb, new_default_bb, new_bb;\n+  edge default_edge;\n+  bool update_dom = dom_info_available_p (CDI_DOMINATORS);\n+\n+  VEC (basic_block, heap) *bbs_to_fix_dom = NULL;\n+\n+  tree index_type = TREE_TYPE (index_expr);\n+  tree unsigned_index_type = unsigned_type_for (index_type);\n+  unsigned int branch_num = gimple_switch_num_labels (swtch);\n+\n+  gimple_stmt_iterator gsi;\n+  gimple shift_stmt;\n+\n+  tree idx, tmp, csui;\n+  tree word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n+  tree word_mode_zero = fold_convert (word_type_node, integer_zero_node);\n+  tree word_mode_one = fold_convert (word_type_node, integer_one_node);\n+\n+  memset (&test, 0, sizeof (test));\n+\n+  /* Get the edge for the default case.  */\n+  tmp = gimple_switch_label (swtch, 0);\n+  default_bb = label_to_block (CASE_LABEL (tmp));\n+  default_edge = find_edge (switch_bb, default_bb);\n+\n+  /* Go through all case labels, and collect the case labels, profile\n+     counts, and other information we need to build the branch tests.  */\n+  count = 0;\n+  for (i = 1; i < branch_num; i++)\n+    {\n+      unsigned int lo, hi;\n+      tree cs = gimple_switch_label (swtch, i);\n+      tree label = CASE_LABEL (cs);\n+      for (k = 0; k < count; k++)\n+\tif (label == test[k].label)\n+\t  break;\n+\n+      if (k == count)\n+\t{\n+\t  edge e = find_edge (switch_bb, label_to_block (label));\n+\t  gcc_assert (e);\n+\t  gcc_checking_assert (count < MAX_CASE_BIT_TESTS);\n+\t  test[k].hi = 0;\n+\t  test[k].lo = 0;\n+\t  test[k].target_edge = e;\n+\t  test[k].label = label;\n+\t  test[k].bits = 1;\n+\t  count++;\n+\t}\n+      else\n+        test[k].bits++;\n+\n+      lo = tree_low_cst (int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t  CASE_LOW (cs), minval),\n+\t\t\t 1);\n+      if (CASE_HIGH (cs) == NULL_TREE)\n+\thi = lo;\n+      else\n+\thi = tree_low_cst (int_const_binop (MINUS_EXPR, \n+\t\t\t\t\t    CASE_HIGH (cs), minval),\n+\t\t\t   1);\n+\n+      for (j = lo; j <= hi; j++)\n+        if (j >= HOST_BITS_PER_WIDE_INT)\n+\t  test[k].hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);\n+\telse\n+\t  test[k].lo |= (HOST_WIDE_INT) 1 << j;\n+    }\n+\n+  qsort (test, count, sizeof(*test), case_bit_test_cmp);\n+\n+  /* We generate two jumps to the default case label.\n+     Split the default edge, so that we don't have to do any PHI node\n+     updating.  */\n+  new_default_bb = split_edge (default_edge);\n+\n+  if (update_dom)\n+    {\n+      bbs_to_fix_dom = VEC_alloc (basic_block, heap, 10);\n+      VEC_quick_push (basic_block, bbs_to_fix_dom, switch_bb);\n+      VEC_quick_push (basic_block, bbs_to_fix_dom, default_bb);\n+      VEC_quick_push (basic_block, bbs_to_fix_dom, new_default_bb);\n+    }\n+\n+  /* Now build the test-and-branch code.  */\n+\n+  gsi = gsi_last_bb (switch_bb);\n+\n+  /* idx = (unsigned) (x - minval) */\n+  idx = fold_build2 (MINUS_EXPR, index_type, index_expr,\n+\t\t     fold_convert (index_type, minval));\n+  idx = fold_convert (unsigned_index_type, idx);\n+  idx = force_gimple_operand_gsi (&gsi, idx,\n+\t\t\t\t  /*simple=*/true, NULL_TREE,\n+\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n+\n+  /* if (idx > range) goto default */\n+  range = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t    fold_convert (unsigned_index_type, range),\n+\t\t\t\t    /*simple=*/true, NULL_TREE,\n+\t\t\t\t    /*before=*/true, GSI_SAME_STMT);\n+  tmp = fold_build2 (GT_EXPR, boolean_type_node, idx, range);\n+  new_bb = hoist_edge_and_branch_if_true (&gsi, tmp, default_edge, update_dom);\n+  if (update_dom)\n+    VEC_quick_push (basic_block, bbs_to_fix_dom, new_bb);\n+  gcc_assert (gimple_bb (swtch) == new_bb);\n+  gsi = gsi_last_bb (new_bb);\n+\n+  /* Any blocks dominated by the GIMPLE_SWITCH, but that are not successors\n+     of NEW_BB, are still immediately dominated by SWITCH_BB.  Make it so.  */\n+  if (update_dom)\n+    {\n+      VEC (basic_block, heap) *dom_bbs;\n+      basic_block dom_son;\n+\n+      dom_bbs = get_dominated_by (CDI_DOMINATORS, new_bb);\n+      FOR_EACH_VEC_ELT (basic_block, dom_bbs, i, dom_son)\n+\t{\n+\t  edge e = find_edge (new_bb, dom_son);\n+\t  if (e && single_pred_p (e->dest))\n+\t    continue;\n+\t  set_immediate_dominator (CDI_DOMINATORS, dom_son, switch_bb);\n+\t  VEC_safe_push (basic_block, heap, bbs_to_fix_dom, dom_son);\n+\t}\n+      VEC_free (basic_block, heap, dom_bbs);\n+    }\n+\n+  /* csui = (1 << (word_mode) idx) */\n+  tmp = create_tmp_var (word_type_node, \"csui\");\n+  add_referenced_var (tmp);\n+  csui = make_ssa_name (tmp, NULL);\n+  tmp = fold_build2 (LSHIFT_EXPR, word_type_node, word_mode_one,\n+\t\t     fold_convert (word_type_node, idx));\n+  tmp = force_gimple_operand_gsi (&gsi, tmp,\n+\t\t\t\t  /*simple=*/false, NULL_TREE,\n+\t\t\t\t  /*before=*/true, GSI_SAME_STMT);\n+  shift_stmt = gimple_build_assign (csui, tmp);\n+  SSA_NAME_DEF_STMT (csui) = shift_stmt;\n+  gsi_insert_before (&gsi, shift_stmt, GSI_SAME_STMT);\n+  update_stmt (shift_stmt);\n+\n+  /* for each unique set of cases:\n+        if (const & csui) goto target  */\n+  for (k = 0; k < count; k++)\n+    {\n+      tmp = build_int_cst_wide (word_type_node, test[k].lo, test[k].hi);\n+      tmp = fold_build2 (BIT_AND_EXPR, word_type_node, csui, tmp);\n+      tmp = force_gimple_operand_gsi (&gsi, tmp,\n+\t\t\t\t      /*simple=*/true, NULL_TREE,\n+\t\t\t\t      /*before=*/true, GSI_SAME_STMT);\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, word_mode_zero);\n+      new_bb = hoist_edge_and_branch_if_true (&gsi, tmp, test[k].target_edge,\n+\t\t\t\t\t      update_dom);\n+      if (update_dom)\n+\tVEC_safe_push (basic_block, heap, bbs_to_fix_dom, new_bb);\n+      gcc_assert (gimple_bb (swtch) == new_bb);\n+      gsi = gsi_last_bb (new_bb);\n+    }\n+\n+  /* We should have removed all edges now.  */\n+  gcc_assert (EDGE_COUNT (gsi_bb (gsi)->succs) == 0);\n+\n+  /* If nothing matched, go to the default label.  */\n+  make_edge (gsi_bb (gsi), new_default_bb, EDGE_FALLTHRU);\n+\n+  /* The GIMPLE_SWITCH is now redundant.  */\n+  gsi_remove (&gsi, true);\n+\n+  if (update_dom)\n+    {\n+      /* Fix up the dominator tree.  */\n+      iterate_fix_dominators (CDI_DOMINATORS, bbs_to_fix_dom, true);\n+      VEC_free (basic_block, heap, bbs_to_fix_dom);\n+    }\n+}\n+\f\n /*\n      Switch initialization conversion\n \n@@ -75,26 +527,10 @@ is changed into:\n \n There are further constraints.  Specifically, the range of values across all\n case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default\n-eight) times the number of the actual switch branches. */\n+eight) times the number of the actual switch branches.\n \n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"line-map.h\"\n-#include \"params.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"basic-block.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-flow-inline.h\"\n-#include \"tree-ssa-operands.h\"\n-#include \"input.h\"\n-#include \"tree-pass.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"tree-dump.h\"\n-#include \"timevar.h\"\n-#include \"langhooks.h\"\n+This transformation was contributed by Martin Jambor, see this e-mail:\n+   http://gcc.gnu.org/ml/gcc-patches/2008-07/msg00011.html  */\n \n /* The main structure of the pass.  */\n struct switch_conv_info\n@@ -799,13 +1235,6 @@ gen_inbound_check (gimple swtch, struct switch_conv_info *info)\n \n   gcc_assert (info->default_values);\n \n-  /* Make no effort to update the post-dominator tree.  It is actually not\n-     that hard for the transformations we have performed, but it is not\n-     supported by iterate_fix_dominators.\n-     Freeing post-dominance info is dome early to avoid pointless work in\n-     create_basic_block, which is called when we split SWITCH_BB.  */\n-  free_dominance_info (CDI_POST_DOMINATORS);\n-\n   bb0 = gimple_bb (swtch);\n \n   tidx = gimple_assign_lhs (info->arr_ref_first);\n@@ -885,7 +1314,7 @@ gen_inbound_check (gimple swtch, struct switch_conv_info *info)\n \n       set_immediate_dominator (CDI_DOMINATORS, bb1, bb0);\n       set_immediate_dominator (CDI_DOMINATORS, bb2, bb0);\n-      if (! get_immediate_dominator(CDI_DOMINATORS, bbf))\n+      if (! get_immediate_dominator (CDI_DOMINATORS, bbf))\n \t/* If bbD was the immediate dominator ...  */\n \tset_immediate_dominator (CDI_DOMINATORS, bbf, bb0);\n \n@@ -920,17 +1349,30 @@ process_switch (gimple swtch)\n      during gimplification).  */\n   gcc_checking_assert (TREE_TYPE (info.index_expr) != error_mark_node);\n \n-  /* If there is no common successor, we cannot do the transformation.  */\n-  if (! info.final_bb)\n-    return \"no common successor to all case label target blocks found\";\n+  /* A switch on a constant should have been optimized in tree-cfg-cleanup.  */\n+  gcc_checking_assert (! TREE_CONSTANT (info.index_expr));\n \n-  if (info.uniq <= 2)\n+  if (info.uniq <= MAX_CASE_BIT_TESTS)\n     {\n-      if (expand_switch_using_bit_tests_p (info.index_expr, info.range_size,\n+      if (expand_switch_using_bit_tests_p (info.range_size,\n \t\t\t\t\t   info.uniq, info.count))\n-\treturn \"expanding as bit test is preferable\";\n+\t{\n+\t  if (dump_file)\n+\t    fputs (\"  expanding as bit test is preferable\\n\", dump_file);\n+\t  emit_case_bit_tests (swtch, info.index_expr,\n+\t\t\t       info.range_min, info.range_size);\n+\t  return NULL;\n+\t}\n+\n+      if (info.uniq <= 2)\n+\t/* This will be expanded as a decision tree in stmt.c:expand_case.  */\n+\treturn \"  expanding as jumps is preferable\";\n     }\n \n+  /* If there is no common successor, we cannot do the transformation.  */\n+  if (! info.final_bb)\n+    return \"no common successor to all case label target blocks found\";\n+\n   /* Check the case label values are within reasonable range:  */\n   if (!check_range (&info))\n     {\n@@ -999,6 +1441,11 @@ do_switchconv (void)\n \t\tfputs (\"Switch converted\\n\", dump_file);\n \t\tfputs (\"--------------------------------\\n\", dump_file);\n \t      }\n+\n+\t    /* Make no effort to update the post-dominator tree.  It is actually not\n+\t       that hard for the transformations we have performed, but it is not\n+\t       supported by iterate_fix_dominators.  */\n+\t    free_dominance_info (CDI_POST_DOMINATORS);\n \t  }\n \telse\n \t  {\n@@ -1039,6 +1486,8 @@ struct gimple_opt_pass pass_convert_switch =\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_update_ssa \n-  | TODO_ggc_collect | TODO_verify_ssa  /* todo_flags_finish */\n+  | TODO_ggc_collect | TODO_verify_ssa\n+  | TODO_verify_stmts\n+  | TODO_verify_flow\t\t\t/* todo_flags_finish */\n  }\n };"}, {"sha": "390f77c1fc15d85c16abeb34daf1d68bbf2eea58", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531b10fcb0fe5c86576bda5fd201d8acc7db4525/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=531b10fcb0fe5c86576bda5fd201d8acc7db4525", "patch": "@@ -5728,8 +5728,6 @@ extern bool parse_input_constraint (const char **, int, int, int, int,\n \t\t\t\t    const char * const *, bool *, bool *);\n extern void expand_asm_stmt (gimple);\n extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n-extern bool expand_switch_using_bit_tests_p (tree, tree, unsigned int,\n-\t\t\t\t\t     unsigned int);\n extern void expand_case (gimple);\n #ifdef HARD_CONST\n /* Silly ifdef to avoid having all includers depend on hard-reg-set.h.  */"}]}