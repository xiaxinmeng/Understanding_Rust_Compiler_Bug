{"sha": "712266515f4ba06d8a2d90584984f461a37b5d68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEyMjY2NTE1ZjRiYTA2ZDhhMmQ5MDU4NDk4NGY0NjFhMzdiNWQ2OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-06-05T16:31:05Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-06-05T16:31:05Z"}, "message": "shared_mutex (__shared_mutex_pthread, [...]): New helper types implementing the shared mutex requirements.\n\n\t* include/std/shared_mutex (__shared_mutex_pthread,\n\t__shared_mutex_cv): New helper types implementing the shared mutex\n\trequirements.\n\t(shared_mutex): New type for C++17.\n\t(shared_timed_mutex): Derive from one of the new helper types.\n\t* testsuite/30_threads/shared_mutex/cons/1.cc: New.\n\t* testsuite/30_threads/shared_mutex/cons/assign_neg.cc: New.\n\t* testsuite/30_threads/shared_mutex/cons/copy_neg.cc: New.\n\t* testsuite/30_threads/shared_mutex/requirements/standard_layout.cc:\n\tNew.\n\t* testsuite/30_threads/shared_mutex/try_lock/1.cc: New.\n\t* testsuite/30_threads/shared_mutex/try_lock/2.cc: New.\n\nFrom-SVN: r224158", "tree": {"sha": "4db90c305b0169cfa766539cc422e6084c4acf8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db90c305b0169cfa766539cc422e6084c4acf8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/712266515f4ba06d8a2d90584984f461a37b5d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712266515f4ba06d8a2d90584984f461a37b5d68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712266515f4ba06d8a2d90584984f461a37b5d68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712266515f4ba06d8a2d90584984f461a37b5d68/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e918809cd0ef1567551c8893afda6268c598d42d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e918809cd0ef1567551c8893afda6268c598d42d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e918809cd0ef1567551c8893afda6268c598d42d"}], "stats": {"total": 703, "additions": 533, "deletions": 170}, "files": [{"sha": "0badc6db107ac20f1faca918f92bb426863b42a8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -1,3 +1,18 @@\n+2015-06-05  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/shared_mutex (__shared_mutex_pthread,\n+\t__shared_mutex_cv): New helper types implementing the shared mutex\n+\trequirements.\n+\t(shared_mutex): New type for C++17.\n+\t(shared_timed_mutex): Derive from one of the new helper types.\n+\t* testsuite/30_threads/shared_mutex/cons/1.cc: New.\n+\t* testsuite/30_threads/shared_mutex/cons/assign_neg.cc: New.\n+\t* testsuite/30_threads/shared_mutex/cons/copy_neg.cc: New.\n+\t* testsuite/30_threads/shared_mutex/requirements/standard_layout.cc:\n+\tNew.\n+\t* testsuite/30_threads/shared_mutex/try_lock/1.cc: New.\n+\t* testsuite/30_threads/shared_mutex/try_lock/2.cc: New.\n+\n 2015-06-05  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tAdd __is_nothrow_swappable and take it into use."}, {"sha": "0a893eef2022252d66bb3aab6ec30794cb2b4d45", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 250, "deletions": 170, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -52,25 +52,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n #ifdef _GLIBCXX_HAS_GTHREADS\n \n+#if __cplusplus > 201402L\n+// TODO: #define __cpp_lib_shared_mutex 201505\n+  class shared_mutex;\n+#endif\n+\n #define __cpp_lib_shared_timed_mutex 201402\n+  class shared_timed_mutex;\n \n-  /// shared_timed_mutex\n-  class shared_timed_mutex\n+#if _GLIBCXX_USE_PTHREAD_RWLOCK_T\n+  /// A shared mutex type implemented using pthread_rwlock_t.\n+  class __shared_mutex_pthread\n   {\n-#if _GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK\n-    typedef chrono::system_clock\t__clock_t;\n+    friend class shared_timed_mutex;\n \n #ifdef PTHREAD_RWLOCK_INITIALIZER\n     pthread_rwlock_t\t_M_rwlock = PTHREAD_RWLOCK_INITIALIZER;\n \n   public:\n-    shared_timed_mutex() = default;\n-    ~shared_timed_mutex() = default;\n+    __shared_mutex_pthread() = default;\n+    ~__shared_mutex_pthread() = default;\n #else\n     pthread_rwlock_t\t_M_rwlock;\n \n   public:\n-    shared_timed_mutex()\n+    __shared_mutex_pthread()\n     {\n       int __ret = pthread_rwlock_init(&_M_rwlock, NULL);\n       if (__ret == ENOMEM)\n@@ -83,18 +89,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n     }\n \n-    ~shared_timed_mutex()\n+    ~__shared_mutex_pthread()\n     {\n       int __ret __attribute((__unused__)) = pthread_rwlock_destroy(&_M_rwlock);\n       // Errors not handled: EBUSY, EINVAL\n       _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n     }\n #endif\n \n-    shared_timed_mutex(const shared_timed_mutex&) = delete;\n-    shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n-\n-    // Exclusive ownership\n+    __shared_mutex_pthread(const __shared_mutex_pthread&) = delete;\n+    __shared_mutex_pthread& operator=(const __shared_mutex_pthread&) = delete;\n \n     void\n     lock()\n@@ -116,48 +120,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n-    template<typename _Rep, typename _Period>\n-      bool\n-      try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)\n-      {\n-\treturn try_lock_until(__clock_t::now() + __rel_time);\n-      }\n-\n-    template<typename _Duration>\n-      bool\n-      try_lock_until(const chrono::time_point<__clock_t, _Duration>& __atime)\n-      {\n-\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n-\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n-\n-\t__gthread_time_t __ts =\n-\t  {\n-\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t    static_cast<long>(__ns.count())\n-\t  };\n-\n-\tint __ret = pthread_rwlock_timedwrlock(&_M_rwlock, &__ts);\n-\t// On self-deadlock, we just fail to acquire the lock.  Technically,\n-\t// the program violated the precondition.\n-\tif (__ret == ETIMEDOUT || __ret == EDEADLK)\n-\t  return false;\n-\t// Errors not handled: EINVAL\n-\t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n-\treturn true;\n-      }\n-\n-    template<typename _Clock, typename _Duration>\n-      bool\n-      try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n-      {\n-\t// DR 887 - Sync unknown clock to known clock.\n-\tconst typename _Clock::time_point __c_entry = _Clock::now();\n-\tconst __clock_t::time_point __s_entry = __clock_t::now();\n-\tconst auto __delta = __abs_time - __c_entry;\n-\tconst auto __s_atime = __s_entry + __delta;\n-\treturn try_lock_until(__s_atime);\n-      }\n-\n     void\n     unlock()\n     {\n@@ -198,74 +160,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n-    template<typename _Rep, typename _Period>\n-      bool\n-      try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)\n-      {\n-\treturn try_lock_shared_until(__clock_t::now() + __rel_time);\n-      }\n-\n-    template<typename _Duration>\n-      bool\n-      try_lock_shared_until(const chrono::time_point<__clock_t,\n-\t\t\t    _Duration>& __atime)\n-      {\n-\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n-\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n-\n-\t__gthread_time_t __ts =\n-\t  {\n-\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t    static_cast<long>(__ns.count())\n-\t  };\n-\n-\tint __ret;\n-\t// Unlike for lock(), we are not allowed to throw an exception so if\n-\t// the maximum number of read locks has been exceeded, or we would\n-\t// deadlock, we just try to acquire the lock again (and will time out\n-\t// eventually). \n-\t// In cases where we would exceed the maximum number of read locks\n-\t// throughout the whole time until the timeout, we will fail to\n-\t// acquire the lock even if it would be logically free; however, this\n-\t// is allowed by the standard, and we made a \"strong effort\"\n-\t// (see C++14 30.4.1.4p26).\n-\t// For cases where the implementation detects a deadlock we\n-\t// intentionally block and timeout so that an early return isn't\n-\t// mistaken for a spurious failure, which might help users realise\n-\t// there is a deadlock.\n-\tdo\n-\t  __ret = pthread_rwlock_timedrdlock(&_M_rwlock, &__ts);\n-\twhile (__ret == EAGAIN || __ret == EDEADLK);\n-\tif (__ret == ETIMEDOUT)\n-\t  return false;\n-\t// Errors not handled: EINVAL\n-\t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n-\treturn true;\n-      }\n-\n-    template<typename _Clock, typename _Duration>\n-      bool\n-      try_lock_shared_until(const chrono::time_point<_Clock,\n-\t\t\t    _Duration>& __abs_time)\n-      {\n-\t// DR 887 - Sync unknown clock to known clock.\n-\tconst typename _Clock::time_point __c_entry = _Clock::now();\n-\tconst __clock_t::time_point __s_entry = __clock_t::now();\n-\tconst auto __delta = __abs_time - __c_entry;\n-\tconst auto __s_atime = __s_entry + __delta;\n-\treturn try_lock_shared_until(__s_atime);\n-      }\n-\n     void\n     unlock_shared()\n     {\n       unlock();\n     }\n \n-#else // ! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)\n+    void* native_handle() { return &_M_rwlock; }\n+  };\n+#endif\n \n-    // Must use the same clock as condition_variable\n-    typedef chrono::system_clock\t__clock_t;\n+#if ! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)\n+  /// A shared mutex type implemented using std::condition_variable.\n+  class __shared_mutex_cv\n+  {\n+    friend class shared_timed_mutex;\n \n     // Based on Howard Hinnant's reference implementation from N2406.\n \n@@ -312,15 +221,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     unsigned _M_readers() const { return _M_state & _S_max_readers; }\n \n   public:\n-    shared_timed_mutex() : _M_state(0) {}\n+    __shared_mutex_cv() : _M_state(0) {}\n \n-    ~shared_timed_mutex()\n+    ~__shared_mutex_cv()\n     {\n       _GLIBCXX_DEBUG_ASSERT( _M_state == 0 );\n     }\n \n-    shared_timed_mutex(const shared_timed_mutex&) = delete;\n-    shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n+    __shared_mutex_cv(const __shared_mutex_cv&) = delete;\n+    __shared_mutex_cv& operator=(const __shared_mutex_cv&) = delete;\n \n     // Exclusive ownership\n \n@@ -347,35 +256,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-    template<typename _Rep, typename _Period>\n-      bool\n-      try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)\n-      {\n-\treturn try_lock_until(__clock_t::now() + __rel_time);\n-      }\n-\n-    template<typename _Clock, typename _Duration>\n-      bool\n-      try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n-      {\n-\tunique_lock<mutex> __lk(_M_mut);\n-\tif (!_M_gate1.wait_until(__lk, __abs_time,\n-\t\t\t\t [=]{ return !_M_write_entered(); }))\n-\t  {\n-\t    return false;\n-\t  }\n-\t_M_state |= _S_write_entered;\n-\tif (!_M_gate2.wait_until(__lk, __abs_time,\n-\t\t\t\t [=]{ return _M_readers() == 0; }))\n-\t  {\n-\t    _M_state ^= _S_write_entered;\n-\t    // Wake all threads blocked while the write-entered flag was set.\n-\t    _M_gate1.notify_all();\n-\t    return false;\n-\t  }\n-\treturn true;\n-      }\n-\n     void\n     unlock()\n     {\n@@ -411,28 +291,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-    template<typename _Rep, typename _Period>\n-      bool\n-      try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)\n-      {\n-\treturn try_lock_shared_until(__clock_t::now() + __rel_time);\n-      }\n-\n-    template <typename _Clock, typename _Duration>\n-      bool\n-      try_lock_shared_until(const chrono::time_point<_Clock,\n-\t\t\t\t\t\t     _Duration>& __abs_time)\n-      {\n-\tunique_lock<mutex> __lk(_M_mut);\n-\tif (!_M_gate1.wait_until(__lk, __abs_time,\n-\t\t\t\t [=]{ return _M_state < _S_max_readers; }))\n-\t  {\n-\t    return false;\n-\t  }\n-\t++_M_state;\n-\treturn true;\n-      }\n-\n     void\n     unlock_shared()\n     {\n@@ -455,6 +313,228 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_gate1.notify_one();\n \t}\n     }\n+  };\n+#endif\n+\n+#if __cplusplus > 201402L\n+  /// The standard shared mutex type.\n+  class shared_mutex\n+  {\n+  public:\n+    shared_mutex() = default;\n+    ~shared_mutex() = default;\n+\n+    shared_mutex(const shared_mutex&) = delete;\n+    shared_mutex& operator=(const shared_mutex&) = delete;\n+\n+    // Exclusive ownership\n+\n+    void lock() { _M_impl.lock(); }\n+    bool try_lock() { return _M_impl.try_lock(); }\n+    void unlock() { _M_impl.try_lock(); }\n+\n+    // Shared ownership\n+\n+    void lock_shared() { _M_impl.lock_shared(); }\n+    bool try_lock_shared() { return _M_impl.try_lock_shared(); }\n+    void unlock_shared() { _M_impl.unlock_shared(); }\n+\n+#if _GLIBCXX_USE_PTHREAD_RWLOCK_T\n+    typedef void* native_handle_type;\n+    native_handle_type native_handle() { return _M_impl.native_handle(); }\n+\n+  private:\n+    __shared_mutex_pthread _M_impl;\n+#else\n+  private:\n+    __shared_mutex_cv _M_impl;\n+#endif\n+  };\n+#endif // C++17\n+\n+#if _GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK\n+  using __shared_timed_mutex_base = __shared_mutex_pthread;\n+#else\n+  using __shared_timed_mutex_base = __shared_mutex_cv;\n+#endif\n+\n+  /// The standard shared timed mutex type.\n+  class shared_timed_mutex\n+  : private __shared_timed_mutex_base\n+  {\n+    using _Base = __shared_timed_mutex_base;\n+\n+    // Must use the same clock as condition_variable for __shared_mutex_cv.\n+    typedef chrono::system_clock\t__clock_t;\n+\n+  public:\n+    shared_timed_mutex() = default;\n+    ~shared_timed_mutex() = default;\n+\n+    shared_timed_mutex(const shared_timed_mutex&) = delete;\n+    shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n+\n+    // Exclusive ownership\n+\n+    void lock() { _Base::lock(); }\n+    bool try_lock() { return _Base::try_lock(); }\n+    void unlock() { _Base::unlock(); }\n+\n+    template<typename _Rep, typename _Period>\n+      bool\n+      try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      {\n+\treturn try_lock_until(__clock_t::now() + __rel_time);\n+      }\n+\n+    // Shared ownership\n+\n+    void lock_shared() { _Base::lock_shared(); }\n+    bool try_lock_shared() { return _Base::try_lock_shared(); }\n+    void unlock_shared() { _Base::unlock_shared(); }\n+\n+    template<typename _Rep, typename _Period>\n+      bool\n+      try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      {\n+\treturn try_lock_shared_until(__clock_t::now() + __rel_time);\n+      }\n+\n+#if _GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK\n+\n+    // Exclusive ownership\n+\n+    template<typename _Duration>\n+      bool\n+      try_lock_until(const chrono::time_point<__clock_t, _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tint __ret = pthread_rwlock_timedwrlock(&_M_rwlock, &__ts);\n+\t// On self-deadlock, we just fail to acquire the lock.  Technically,\n+\t// the program violated the precondition.\n+\tif (__ret == ETIMEDOUT || __ret == EDEADLK)\n+\t  return false;\n+\t// Errors not handled: EINVAL\n+\t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+\treturn true;\n+      }\n+\n+    template<typename _Clock, typename _Duration>\n+      bool\n+      try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n+      {\n+\t// DR 887 - Sync unknown clock to known clock.\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __clock_t::time_point __s_entry = __clock_t::now();\n+\tconst auto __delta = __abs_time - __c_entry;\n+\tconst auto __s_atime = __s_entry + __delta;\n+\treturn try_lock_until(__s_atime);\n+      }\n+\n+    // Shared ownership\n+\n+    template<typename _Duration>\n+      bool\n+      try_lock_shared_until(const chrono::time_point<__clock_t,\n+\t\t\t    _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tint __ret;\n+\t// Unlike for lock(), we are not allowed to throw an exception so if\n+\t// the maximum number of read locks has been exceeded, or we would\n+\t// deadlock, we just try to acquire the lock again (and will time out\n+\t// eventually).\n+\t// In cases where we would exceed the maximum number of read locks\n+\t// throughout the whole time until the timeout, we will fail to\n+\t// acquire the lock even if it would be logically free; however, this\n+\t// is allowed by the standard, and we made a \"strong effort\"\n+\t// (see C++14 30.4.1.4p26).\n+\t// For cases where the implementation detects a deadlock we\n+\t// intentionally block and timeout so that an early return isn't\n+\t// mistaken for a spurious failure, which might help users realise\n+\t// there is a deadlock.\n+\tdo\n+\t  __ret = pthread_rwlock_timedrdlock(&_M_rwlock, &__ts);\n+\twhile (__ret == EAGAIN || __ret == EDEADLK);\n+\tif (__ret == ETIMEDOUT)\n+\t  return false;\n+\t// Errors not handled: EINVAL\n+\t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+\treturn true;\n+      }\n+\n+    template<typename _Clock, typename _Duration>\n+      bool\n+      try_lock_shared_until(const chrono::time_point<_Clock,\n+\t\t\t\t\t\t     _Duration>& __abs_time)\n+      {\n+\t// DR 887 - Sync unknown clock to known clock.\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __clock_t::time_point __s_entry = __clock_t::now();\n+\tconst auto __delta = __abs_time - __c_entry;\n+\tconst auto __s_atime = __s_entry + __delta;\n+\treturn try_lock_shared_until(__s_atime);\n+      }\n+\n+#else // ! (_GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK)\n+\n+    // Exclusive ownership\n+\n+    template<typename _Clock, typename _Duration>\n+      bool\n+      try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n+      {\n+\tunique_lock<mutex> __lk(_M_mut);\n+\tif (!_M_gate1.wait_until(__lk, __abs_time,\n+\t\t\t\t [=]{ return !_M_write_entered(); }))\n+\t  {\n+\t    return false;\n+\t  }\n+\t_M_state |= _S_write_entered;\n+\tif (!_M_gate2.wait_until(__lk, __abs_time,\n+\t\t\t\t [=]{ return _M_readers() == 0; }))\n+\t  {\n+\t    _M_state ^= _S_write_entered;\n+\t    // Wake all threads blocked while the write-entered flag was set.\n+\t    _M_gate1.notify_all();\n+\t    return false;\n+\t  }\n+\treturn true;\n+      }\n+\n+    // Shared ownership\n+\n+    template <typename _Clock, typename _Duration>\n+      bool\n+      try_lock_shared_until(const chrono::time_point<_Clock,\n+\t\t\t\t\t\t     _Duration>& __abs_time)\n+      {\n+\tunique_lock<mutex> __lk(_M_mut);\n+\tif (!_M_gate1.wait_until(__lk, __abs_time,\n+\t\t\t\t [=]{ return _M_state < _S_max_readers; }))\n+\t  {\n+\t    return false;\n+\t  }\n+\t++_M_state;\n+\treturn true;\n+      }\n+\n #endif // _GLIBCXX_USE_PTHREAD_RWLOCK_T && _GTHREAD_USE_MUTEX_TIMEDLOCK\n   };\n #endif // _GLIBCXX_HAS_GTHREADS"}, {"sha": "f54406dc93a51ce8063e9d4bd6530b5797cfda12", "filename": "libstdc++-v3/testsuite/30_threads/shared_mutex/cons/1.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2F1.cc?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++17 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++17 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++17 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+#include <system_error>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::shared_mutex mutex_type;\n+\n+  try\n+    {\n+      mutex_type m1;\n+    }\n+  catch (const std::system_error& e)\n+    {\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  return 0;\n+}"}, {"sha": "7571323178090130f980d1771f9243eebeeea371", "filename": "libstdc++-v3/testsuite/30_threads/shared_mutex/cons/assign_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2Fassign_neg.cc?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+\n+void test01()\n+{\n+  // assign\n+  typedef std::shared_mutex mutex_type;\n+  mutex_type m1;\n+  mutex_type m2;\n+  m1 = m2;\t\t\t// { dg-error \"deleted\" }\n+}\n+\n+// { dg-prune-output \"include\" }"}, {"sha": "42ede2d9289313a900d3984b7560c11c2ecf6fb7", "filename": "libstdc++-v3/testsuite/30_threads/shared_mutex/cons/copy_neg.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Fcons%2Fcopy_neg.cc?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+\n+void test01()\n+{\n+  // assign\n+  typedef std::shared_mutex mutex_type;\n+  mutex_type m1;\n+  mutex_type m2(m1);\t\t// { dg-error \"deleted\" }\n+}\n+\n+// { dg-prune-output \"include\" }"}, {"sha": "8a92c7da21af496d17e461d2665cb585725daf30", "filename": "libstdc++-v3/testsuite/30_threads/shared_mutex/requirements/standard_layout.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Frequirements%2Fstandard_layout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Frequirements%2Fstandard_layout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Frequirements%2Fstandard_layout.cc?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+#include <testsuite_common_types.h>\n+\n+void test01()\n+{\n+  __gnu_test::standard_layout test;\n+  test.operator()<std::shared_mutex>();\n+}"}, {"sha": "d5ab9620e4809eaf2563a9c21b4c1d506ee76a9e", "filename": "libstdc++-v3/testsuite/30_threads/shared_mutex/try_lock/1.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Ftry_lock%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Ftry_lock%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Ftry_lock%2F1.cc?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++17 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++17 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++17 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+#include <system_error>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::shared_mutex mutex_type;\n+\n+  try\n+    {\n+      mutex_type m;\n+      bool b = m.try_lock();\n+      VERIFY( b );\n+      m.unlock();\n+    }\n+  catch (const std::system_error& e)\n+    {\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  return 0;\n+}"}, {"sha": "be9e3ae42f219d4b01dcdcc131a6b0ef3ccbfddb", "filename": "libstdc++-v3/testsuite/30_threads/shared_mutex/try_lock/2.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Ftry_lock%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712266515f4ba06d8a2d90584984f461a37b5d68/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Ftry_lock%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_mutex%2Ftry_lock%2F2.cc?ref=712266515f4ba06d8a2d90584984f461a37b5d68", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++17 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++17 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++17 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+#include <thread>\n+#include <system_error>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::shared_mutex mutex_type;\n+\n+  try\n+    {\n+      mutex_type m;\n+      m.lock();\n+      bool b;\n+\n+      std::thread t([&] {\n+        try\n+          {\n+            b = m.try_lock();\n+          }\n+        catch (const std::system_error& e)\n+          {\n+            VERIFY( false );\n+          }\n+      });\n+      t.join();\n+      VERIFY( !b );\n+\n+      m.unlock();\n+    }\n+  catch (const std::system_error& e)\n+    {\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  return 0;\n+}"}]}