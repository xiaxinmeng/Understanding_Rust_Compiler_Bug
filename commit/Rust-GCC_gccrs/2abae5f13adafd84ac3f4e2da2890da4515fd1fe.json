{"sha": "2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFiYWU1ZjEzYWRhZmQ4NGFjM2Y0ZTJkYTI4OTBkYTQ1MTVmZDFmZQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-07-31T02:43:11Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-07-31T02:43:11Z"}, "message": "New Graphite files.\n\n2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* ChangeLog.graphite: New.\n\t* graphite-blocking.c: New.\n\t* graphite-clast-to-gimple.c: New.\n\t* graphite-clast-to-gimple.h: New.\n\t* graphite-dependences.c: New.\n\t* graphite-dependences.h: New.\n\t* graphite-interchange.c: New.\n\t* graphite-poly.c: New.\n\t* graphite-poly.h: New.\n\t* graphite-ppl.c: New.\n\t* graphite-ppl.h: New.\n\t* graphite-scop-detection.c: New.\n\t* graphite-scop-detection.h: New.\n\t* graphite-sese-to-poly.c: New.\n\t* graphite-sese-to-poly.h: New.\n\t* sese.c: New.\n\t* sese.h: New.\n\nFrom-SVN: r150300", "tree": {"sha": "624d5145af586181a9560d3ebefda21001a91b62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/624d5145af586181a9560d3ebefda21001a91b62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7c705bbbdc98ccb45cb953582f8964cfa3de61e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c705bbbdc98ccb45cb953582f8964cfa3de61e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c705bbbdc98ccb45cb953582f8964cfa3de61e"}], "stats": {"total": 15642, "additions": 15642, "deletions": 0}, "files": [{"sha": "cf85cdc89efb883977cc09eba57fad66f69a645f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -1,3 +1,23 @@\n+2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* ChangeLog.graphite: New.\n+\t* graphite-blocking.c: New.\n+\t* graphite-clast-to-gimple.c: New.\n+\t* graphite-clast-to-gimple.h: New.\n+\t* graphite-dependences.c: New.\n+\t* graphite-dependences.h: New.\n+\t* graphite-interchange.c: New.\n+\t* graphite-poly.c: New.\n+\t* graphite-poly.h: New.\n+\t* graphite-ppl.c: New.\n+\t* graphite-ppl.h: New.\n+\t* graphite-scop-detection.c: New.\n+\t* graphite-scop-detection.h: New.\n+\t* graphite-sese-to-poly.c: New.\n+\t* graphite-sese-to-poly.h: New.\n+\t* sese.c: New.\n+\t* sese.h: New.\n+\n 2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-chrec.c (evolution_function_right_is_integer_cst): New."}, {"sha": "ff6e748179db0feb4ec765449acd04d2c1c1783b", "filename": "gcc/ChangeLog.graphite", "status": "added", "additions": 5163, "deletions": 0, "changes": 5163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe"}, {"sha": "4961c7f6d5ac1f87cb15c548edbd2578bd39fedd", "filename": "gcc/graphite-blocking.c", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,210 @@\n+/* Heuristics and transform for loop blocking and strip mining on\n+   polyhedral representation.\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Pranav Garg  <pranav.garg2107@gmail.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"params.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"sese.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+\n+\n+/* Strip mines with a factor STRIDE the loop around PBB at depth\n+   LOOP_DEPTH.  The following example comes from the wiki page:\n+   http://gcc.gnu.org/wiki/Graphite/Strip_mine\n+\n+   The strip mine of a loop with a tile of 64 can be obtained with a\n+   scattering function as follows:\n+\n+   $ cat ./albert_strip_mine.cloog\n+   # language: C\n+   c\n+\n+   # parameter {n | n >= 0}\n+   1 3\n+   #  n  1\n+   1  1  0\n+   1\n+   n\n+\n+   1 # Number of statements:\n+\n+   1\n+   # {i | 0 <= i <= n}\n+   2 4\n+   #  i  n   1\n+   1  1  0   0\n+   1 -1  1   0\n+\n+   0  0  0\n+   1\n+   i\n+\n+   1 # Scattering functions\n+\n+   3 6\n+   #  NEW  OLD    i    n    1\n+   1  -64    0    1    0    0\n+   1   64    0   -1    0   63\n+   0    0    1   -1    0    0\n+\n+   1\n+   NEW  OLD\n+\n+   #the output of CLooG is like this:\n+   #$ cloog ./albert_strip_mine.cloog\n+   # for (NEW=0;NEW<=floord(n,64);NEW++) {\n+   #   for (OLD=max(64*NEW,0);OLD<=min(64*NEW+63,n);OLD++) {\n+   #     S1(i = OLD) ;\n+   #   }\n+   # }\n+*/\n+\n+static bool\n+pbb_strip_mine_loop_depth (poly_bb_p pbb, int loop_depth, int stride)\n+{\n+  ppl_dimension_type iter, dim;\n+  ppl_Polyhedron_t res = PBB_TRANSFORMED_SCATTERING (pbb);\n+  ppl_dimension_type strip = psct_scattering_dim_for_loop_depth (pbb,\n+\t\t\t\t\t\t\t\t loop_depth);\n+\n+  psct_add_scattering_dimension (pbb, strip);\n+\n+  iter = psct_iterator_dim (pbb, loop_depth);\n+  ppl_Polyhedron_space_dimension (res, &dim);\n+\n+  /* Lower bound of the striped loop.  */\n+  {\n+    ppl_Constraint_t new_cstr;\n+    ppl_Linear_Expression_t expr;\n+\n+    ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+    ppl_set_coef (expr, strip, -1 * stride);\n+    ppl_set_coef (expr, iter, 1);\n+\n+    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+    ppl_delete_Linear_Expression (expr);\n+    ppl_Polyhedron_add_constraint (res, new_cstr);\n+    ppl_delete_Constraint (new_cstr);\n+  }\n+\n+  /* Upper bound of the striped loop.  */\n+  {\n+    ppl_Constraint_t new_cstr;\n+    ppl_Linear_Expression_t expr;\n+\n+    ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+    ppl_set_coef (expr, strip, stride);\n+    ppl_set_coef (expr, iter, -1);\n+    ppl_set_inhomogeneous (expr, stride - 1);\n+\n+    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+    ppl_delete_Linear_Expression (expr);\n+    ppl_Polyhedron_add_constraint (res, new_cstr);\n+    ppl_delete_Constraint (new_cstr);\n+  }\n+\n+  return true;\n+}\n+\n+/* Returns true when strip mining with STRIDE of the loop around PBB\n+   at depth LOOP_DEPTH is profitable.  */\n+\n+static bool\n+pbb_strip_mine_profitable_p (poly_bb_p pbb,\n+\t\t\t     graphite_dim_t loop_depth,\n+\t\t\t     int stride)\n+{\n+  Value niter, strip_stride;\n+  bool res;\n+\n+  value_init (strip_stride);\n+  value_init (niter);\n+  value_set_si (strip_stride, stride);\n+  pbb_number_of_iterations (pbb, loop_depth, niter);\n+  res = value_gt (niter, strip_stride);\n+  value_clear (strip_stride);\n+  value_clear (niter);\n+\n+  return res;\n+}\n+\n+/* Strip mines all the loops around PBB.  Nothing profitable in all this:\n+   this is just a driver function.  */\n+\n+static bool\n+pbb_do_strip_mine (poly_bb_p pbb)\n+{\n+  graphite_dim_t loop_depth;\n+  int stride = 64;\n+  bool transform_done = false;\n+\n+  for (loop_depth = 0; loop_depth < pbb_dim_iter_domain (pbb); loop_depth++)\n+    if (pbb_strip_mine_profitable_p (pbb, loop_depth, stride))\n+      transform_done |= pbb_strip_mine_loop_depth (pbb, loop_depth, stride);\n+\n+  return transform_done;\n+}\n+\n+/* Strip mines all the loops in SCOP.  Nothing profitable in all this:\n+   this is just a driver function.  */\n+\n+bool\n+scop_do_strip_mine (scop_p scop)\n+{\n+  poly_bb_p pbb;\n+  int i;\n+  bool transform_done = false;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    transform_done |= pbb_do_strip_mine (pbb);\n+\n+  return transform_done;\n+}\n+\n+#endif"}, {"sha": "bf540a2d1ca2de19f1e61adc2b3ef5d93b6e44a9", "filename": "gcc/graphite-clast-to-gimple.c", "status": "added", "additions": 1317, "deletions": 0, "changes": 1317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,1317 @@\n+/* Translation of CLAST (CLooG AST) to Gimple.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"sese.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+#include \"graphite-scop-detection.h\"\n+#include \"graphite-clast-to-gimple.h\"\n+#include \"graphite-dependences.h\"\n+\n+/* Verifies properties that GRAPHITE should maintain during translation.  */\n+\n+static inline void\n+graphite_verify (void)\n+{\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_dominators (CDI_POST_DOMINATORS);\n+  verify_ssa (false);\n+  verify_loop_closed_ssa ();\n+#endif\n+}\n+\n+/* For a given loop DEPTH in the loop nest of the original black box\n+   PBB, return the old induction variable associated to that loop.  */\n+\n+static inline tree\n+pbb_to_depth_to_oldiv (poly_bb_p pbb, int depth)\n+{\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+  sese region = SCOP_REGION (PBB_SCOP (pbb));\n+  loop_p loop = gbb_loop_at_index (gbb, region, depth);\n+\n+  return (tree) loop->aux;\n+}\n+\n+/* For a given scattering dimension, return the new induction variable\n+   associated to it.  */\n+\n+static inline tree\n+newivs_to_depth_to_newiv (VEC (tree, heap) *newivs, int depth)\n+{\n+  return VEC_index (tree, newivs, depth);\n+}\n+\n+\f\n+\n+/* Returns the tree variable from the name NAME that was given in\n+   Cloog representation.  */\n+\n+static tree\n+clast_name_to_gcc (const char *name, sese region, VEC (tree, heap) *newivs,\n+\t\t   htab_t newivs_index)\n+{\n+  int index;\n+  VEC (tree, heap) *params = SESE_PARAMS (region);\n+  htab_t params_index = SESE_PARAMS_INDEX (region);\n+\n+  if (params && params_index)\n+    {\n+      index = clast_name_to_index (name, params_index);\n+\n+      if (index >= 0)\n+\treturn VEC_index (tree, params, index);\n+    }\n+\n+  gcc_assert (newivs && newivs_index);\n+  index = clast_name_to_index (name, newivs_index);\n+  gcc_assert (index >= 0);\n+\n+  return newivs_to_depth_to_newiv (newivs, index);\n+}\n+\n+/* Returns the maximal precision type for expressions E1 and E2.  */\n+\n+static inline tree\n+max_precision_type (tree e1, tree e2)\n+{\n+  tree type1 = TREE_TYPE (e1);\n+  tree type2 = TREE_TYPE (e2);\n+  return TYPE_PRECISION (type1) > TYPE_PRECISION (type2) ? type1 : type2;\n+}\n+\n+static tree\n+clast_to_gcc_expression (tree, struct clast_expr *, sese, VEC (tree, heap) *,\n+\t\t\t htab_t);\n+\n+/* Converts a Cloog reduction expression R with reduction operation OP\n+   to a GCC expression tree of type TYPE.  */\n+\n+static tree\n+clast_to_gcc_expression_red (tree type, enum tree_code op,\n+\t\t\t     struct clast_reduction *r,\n+\t\t\t     sese region, VEC (tree, heap) *newivs,\n+\t\t\t     htab_t newivs_index)\n+{\n+  int i;\n+  tree res = clast_to_gcc_expression (type, r->elts[0], region, newivs,\n+\t\t\t\t      newivs_index);\n+  tree operand_type = (op == POINTER_PLUS_EXPR) ? sizetype : type;\n+\n+  for (i = 1; i < r->n; i++)\n+    {\n+      tree t = clast_to_gcc_expression (operand_type, r->elts[i], region,\n+\t\t\t\t\tnewivs, newivs_index);\n+      res = fold_build2 (op, type, res, t);\n+    }\n+\n+  return res;\n+}\n+\n+/* Converts a Cloog AST expression E back to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+clast_to_gcc_expression (tree type, struct clast_expr *e,\n+\t\t\t sese region, VEC (tree, heap) *newivs,\n+\t\t\t htab_t newivs_index)\n+{\n+  switch (e->type)\n+    {\n+    case expr_term:\n+      {\n+\tstruct clast_term *t = (struct clast_term *) e;\n+\n+\tif (t->var)\n+\t  {\n+\t    if (value_one_p (t->val))\n+\t      {\n+\t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n+\t\t\t\t\t       newivs_index);\n+\t\treturn fold_convert (type, name);\n+\t      }\n+\n+\t    else if (value_mone_p (t->val))\n+\t      {\n+\t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n+\t\t\t\t\t       newivs_index);\n+\t\tname = fold_convert (type, name);\n+\t\treturn fold_build1 (NEGATE_EXPR, type, name);\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n+\t\t\t\t\t       newivs_index);\n+\t\ttree cst = gmp_cst_to_tree (type, t->val);\n+\t\tname = fold_convert (type, name);\n+\t\treturn fold_build2 (MULT_EXPR, type, cst, name);\n+\t      }\n+\t  }\n+\telse\n+\t  return gmp_cst_to_tree (type, t->val);\n+      }\n+\n+    case expr_red:\n+      {\n+        struct clast_reduction *r = (struct clast_reduction *) e;\n+\n+        switch (r->type)\n+          {\n+\t  case clast_red_sum:\n+\t    return clast_to_gcc_expression_red\n+\t      (type, POINTER_TYPE_P (type) ? POINTER_PLUS_EXPR : PLUS_EXPR,\n+\t       r, region, newivs, newivs_index);\n+\n+\t  case clast_red_min:\n+\t    return clast_to_gcc_expression_red (type, MIN_EXPR, r, region,\n+\t\t\t\t\t\tnewivs, newivs_index);\n+\n+\t  case clast_red_max:\n+\t    return clast_to_gcc_expression_red (type, MAX_EXPR, r, region,\n+\t\t\t\t\t\tnewivs, newivs_index);\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+          }\n+        break;\n+      }\n+\n+    case expr_bin:\n+      {\n+\tstruct clast_binary *b = (struct clast_binary *) e;\n+\tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n+\ttree tl = clast_to_gcc_expression (type, lhs, region, newivs,\n+\t\t\t\t\t   newivs_index);\n+\ttree tr = gmp_cst_to_tree (type, b->RHS);\n+\n+\tswitch (b->type)\n+\t  {\n+\t  case clast_bin_fdiv:\n+\t    return fold_build2 (FLOOR_DIV_EXPR, type, tl, tr);\n+\n+\t  case clast_bin_cdiv:\n+\t    return fold_build2 (CEIL_DIV_EXPR, type, tl, tr);\n+\n+\t  case clast_bin_div:\n+\t    return fold_build2 (EXACT_DIV_EXPR, type, tl, tr);\n+\n+\t  case clast_bin_mod:\n+\t    return fold_build2 (TRUNC_MOD_EXPR, type, tl, tr);\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns the type for the expression E.  */\n+\n+static tree\n+gcc_type_for_clast_expr (struct clast_expr *e,\n+\t\t\t sese region, VEC (tree, heap) *newivs,\n+\t\t\t htab_t newivs_index)\n+{\n+  switch (e->type)\n+    {\n+    case expr_term:\n+      {\n+\tstruct clast_term *t = (struct clast_term *) e;\n+\n+\tif (t->var)\n+\t  return TREE_TYPE (clast_name_to_gcc (t->var, region, newivs,\n+\t\t\t\t\t       newivs_index));\n+\telse\n+\t  return NULL_TREE;\n+      }\n+\n+    case expr_red:\n+      {\n+        struct clast_reduction *r = (struct clast_reduction *) e;\n+\n+\tif (r->n == 1)\n+\t  return gcc_type_for_clast_expr (r->elts[0], region, newivs,\n+\t\t\t\t\t  newivs_index);\n+\telse\n+\t  {\n+\t    int i;\n+\t    for (i = 0; i < r->n; i++)\n+\t      {\n+\t\ttree type = gcc_type_for_clast_expr (r->elts[i], region,\n+\t\t\t\t\t\t     newivs, newivs_index);\n+\t\tif (type)\n+\t\t  return type;\n+\t      }\n+\t    return NULL_TREE;\n+\t  }\n+      }\n+\n+    case expr_bin:\n+      {\n+\tstruct clast_binary *b = (struct clast_binary *) e;\n+\tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n+\treturn gcc_type_for_clast_expr (lhs, region, newivs,\n+\t\t\t\t\tnewivs_index);\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns the type for the equation CLEQ.  */\n+\n+static tree\n+gcc_type_for_clast_eq (struct clast_equation *cleq,\n+\t\t       sese region, VEC (tree, heap) *newivs,\n+\t\t       htab_t newivs_index)\n+{\n+  tree type = gcc_type_for_clast_expr (cleq->LHS, region, newivs,\n+\t\t\t\t       newivs_index);\n+  if (type)\n+    return type;\n+\n+  return gcc_type_for_clast_expr (cleq->RHS, region, newivs, newivs_index);\n+}\n+\n+/* Translates a clast equation CLEQ to a tree.  */\n+\n+static tree\n+graphite_translate_clast_equation (sese region,\n+\t\t\t\t   struct clast_equation *cleq,\n+\t\t\t\t   VEC (tree, heap) *newivs,\n+\t\t\t\t   htab_t newivs_index)\n+{\n+  enum tree_code comp;\n+  tree type = gcc_type_for_clast_eq (cleq, region, newivs, newivs_index);\n+  tree lhs = clast_to_gcc_expression (type, cleq->LHS, region, newivs,\n+\t\t\t\t      newivs_index);\n+  tree rhs = clast_to_gcc_expression (type, cleq->RHS, region, newivs,\n+\t\t\t\t      newivs_index);\n+\n+  if (cleq->sign == 0)\n+    comp = EQ_EXPR;\n+\n+  else if (cleq->sign > 0)\n+    comp = GE_EXPR;\n+\n+  else\n+    comp = LE_EXPR;\n+\n+  return fold_build2 (comp, boolean_type_node, lhs, rhs);\n+}\n+\n+/* Creates the test for the condition in STMT.  */\n+\n+static tree\n+graphite_create_guard_cond_expr (sese region, struct clast_guard *stmt,\n+\t\t\t\t VEC (tree, heap) *newivs,\n+\t\t\t\t htab_t newivs_index)\n+{\n+  tree cond = NULL;\n+  int i;\n+\n+  for (i = 0; i < stmt->n; i++)\n+    {\n+      tree eq = graphite_translate_clast_equation (region, &stmt->eq[i],\n+\t\t\t\t\t\t   newivs, newivs_index);\n+\n+      if (cond)\n+\tcond = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (eq), cond, eq);\n+      else\n+\tcond = eq;\n+    }\n+\n+  return cond;\n+}\n+\n+/* Creates a new if region corresponding to Cloog's guard.  */\n+\n+static edge\n+graphite_create_new_guard (sese region, edge entry_edge,\n+\t\t\t   struct clast_guard *stmt,\n+\t\t\t   VEC (tree, heap) *newivs,\n+\t\t\t   htab_t newivs_index)\n+{\n+  tree cond_expr = graphite_create_guard_cond_expr (region, stmt, newivs,\n+\t\t\t\t\t\t    newivs_index);\n+  edge exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n+  return exit_edge;\n+}\n+\n+/* Walks a CLAST and returns the first statement in the body of a\n+   loop.  */\n+\n+static struct clast_user_stmt *\n+clast_get_body_of_loop (struct clast_stmt *stmt)\n+{\n+  if (!stmt\n+      || CLAST_STMT_IS_A (stmt, stmt_user))\n+    return (struct clast_user_stmt *) stmt;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_for))\n+    return clast_get_body_of_loop (((struct clast_for *) stmt)->body);\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    return clast_get_body_of_loop (((struct clast_guard *) stmt)->then);\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_block))\n+    return clast_get_body_of_loop (((struct clast_block *) stmt)->body);\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Given a CLOOG_IV, returns the type that it should have in GCC land.\n+   If the information is not available, i.e. in the case one of the\n+   transforms created the loop, just return integer_type_node.  */\n+\n+static tree\n+gcc_type_for_cloog_iv (const char *cloog_iv, gimple_bb_p gbb)\n+{\n+  struct ivtype_map_elt_s tmp;\n+  PTR *slot;\n+\n+  tmp.cloog_iv = cloog_iv;\n+  slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((ivtype_map_elt) *slot)->type;\n+\n+  return integer_type_node;\n+}\n+\n+/* Returns the induction variable for the loop that gets translated to\n+   STMT.  */\n+\n+static tree\n+gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for)\n+{\n+  struct clast_stmt *stmt = (struct clast_stmt *) stmt_for;\n+  struct clast_user_stmt *body = clast_get_body_of_loop (stmt);\n+  const char *cloog_iv = stmt_for->iterator;\n+  CloogStatement *cs = body->statement;\n+  poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n+\n+  return gcc_type_for_cloog_iv (cloog_iv, PBB_BLACK_BOX (pbb));\n+}\n+\n+/* Creates a new LOOP corresponding to Cloog's STMT.  Inserts an\n+   induction variable for the new LOOP.  New LOOP is attached to CFG\n+   starting at ENTRY_EDGE.  LOOP is inserted into the loop tree and\n+   becomes the child loop of the OUTER_LOOP.  NEWIVS_INDEX binds\n+   CLooG's scattering name to the induction variable created for the\n+   loop of STMT.  The new induction variable is inserted in the NEWIVS\n+   vector.  */\n+\n+static struct loop *\n+graphite_create_new_loop (sese region, edge entry_edge,\n+\t\t\t  struct clast_for *stmt,\n+\t\t\t  loop_p outer, VEC (tree, heap) **newivs,\n+\t\t\t  htab_t newivs_index)\n+{\n+  tree type = gcc_type_for_iv_of_clast_loop (stmt);\n+  tree lb = clast_to_gcc_expression (type, stmt->LB, region, *newivs,\n+\t\t\t\t     newivs_index);\n+  tree ub = clast_to_gcc_expression (type, stmt->UB, region, *newivs,\n+\t\t\t\t     newivs_index);\n+  tree stride = gmp_cst_to_tree (type, stmt->stride);\n+  tree ivvar = create_tmp_var (type, \"graphite_IV\");\n+  tree iv, iv_after_increment;\n+  loop_p loop = create_empty_loop_on_edge\n+    (entry_edge, lb, stride, ub, ivvar, &iv, &iv_after_increment,\n+     outer ? outer : entry_edge->src->loop_father);\n+\n+  add_referenced_var (ivvar);\n+\n+  save_clast_name_index (newivs_index, stmt->iterator,\n+\t\t\t VEC_length (tree, *newivs));\n+  VEC_safe_push (tree, heap, *newivs, iv);\n+  return loop;\n+}\n+\n+/* Inserts in MAP a tuple (OLD_NAME, NEW_NAME) for the induction\n+   variables of the loops around GBB in SESE.  */\n+\n+static void\n+build_iv_mapping (htab_t map, sese region,\n+\t\t  VEC (tree, heap) *newivs, htab_t newivs_index,\n+\t\t  struct clast_user_stmt *user_stmt)\n+{\n+  struct clast_stmt *t;\n+  int index = 0;\n+  CloogStatement *cs = user_stmt->statement;\n+  poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n+\n+  for (t = user_stmt->substitutions; t; t = t->next, index++)\n+    {\n+      struct clast_expr *expr = (struct clast_expr *)\n+       ((struct clast_assignment *)t)->RHS;\n+      tree type = gcc_type_for_clast_expr (expr, region, newivs,\n+\t\t\t\t\t   newivs_index);\n+      tree old_name = pbb_to_depth_to_oldiv (pbb, index);\n+      tree e = clast_to_gcc_expression (type, expr, region, newivs,\n+\t\t\t\t\tnewivs_index);\n+      set_rename (map, old_name, e);\n+    }\n+}\n+\n+/* Helper function for htab_traverse.  */\n+\n+static int\n+copy_renames (void **slot, void *s)\n+{\n+  struct rename_map_elt_s *entry = (struct rename_map_elt_s *) *slot;\n+  htab_t res = (htab_t) s;\n+  tree old_name = entry->old_name;\n+  tree expr = entry->expr;\n+  struct rename_map_elt_s tmp;\n+  PTR *x;\n+\n+  tmp.old_name = old_name;\n+  x = htab_find_slot (res, &tmp, INSERT);\n+\n+  if (!*x)\n+    *x = new_rename_map_elt (old_name, expr);\n+\n+  return 1;\n+}\n+\n+/* Construct bb_pbb_def with BB and PBB. */\n+\n+static bb_pbb_def *\n+new_bb_pbb_def (basic_block bb, poly_bb_p pbb)\n+{\n+  bb_pbb_def *bb_pbb_p;\n+\n+  bb_pbb_p = XNEW (bb_pbb_def);\n+  bb_pbb_p->bb = bb;\n+  bb_pbb_p->pbb = pbb;\n+\n+  return bb_pbb_p;\n+}\n+\n+/* Mark BB with it's relevant PBB via hashing table BB_PBB_MAPPING.  */\n+\n+static void\n+mark_bb_with_pbb (poly_bb_p pbb, basic_block bb, htab_t bb_pbb_mapping)\n+{\n+  bb_pbb_def tmp;\n+  PTR *x;\n+\n+  tmp.bb = bb;\n+  x = htab_find_slot (bb_pbb_mapping, &tmp, INSERT);\n+\n+  if (!*x)\n+    *x = new_bb_pbb_def (bb, pbb);\n+}\n+\n+/* Returns the scattering dimension for STMTFOR.\n+\n+   FIXME: This is a hackish solution to locate the scattering\n+   dimension in newly created loops. Here the hackish solush\n+   assume that the stmt_for->iterator is always something like:\n+   scat_1 , scat_3 etc., where after \"scat_\" is loop level in\n+   scattering dimension.\n+*/\n+\n+static int get_stmtfor_depth (struct clast_for *stmtfor)\n+{\n+  const char * iterator = stmtfor->iterator;\n+  const char * depth;\n+\n+  depth = strchr (iterator, '_');\n+  if (!strncmp (iterator, \"scat_\", 5))\n+    return atoi (depth+1);\n+\n+  gcc_unreachable();\n+}\n+\n+/* Translates a CLAST statement STMT to GCC representation in the\n+   context of a SESE.\n+\n+   - NEXT_E is the edge where new generated code should be attached.\n+   - CONTEXT_LOOP is the loop in which the generated code will be placed\n+   - RENAME_MAP contains a set of tuples of new names associated to\n+     the original variables names.\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n+*/\n+\n+static edge\n+translate_clast (sese region, struct loop *context_loop,\n+\t\t struct clast_stmt *stmt, edge next_e,\n+\t\t htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t htab_t newivs_index, htab_t bb_pbb_mapping)\n+{\n+  if (!stmt)\n+    return next_e;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_root))\n+    return translate_clast (region, context_loop, stmt->next, next_e,\n+\t\t\t    rename_map, newivs, newivs_index, bb_pbb_mapping);\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_user))\n+    {\n+      gimple_bb_p gbb;\n+      basic_block new_bb;\n+      CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n+      poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n+      gbb = PBB_BLACK_BOX (pbb);\n+\n+      if (GBB_BB (gbb) == ENTRY_BLOCK_PTR)\n+\treturn next_e;\n+\n+      build_iv_mapping (rename_map, region, *newivs, newivs_index,\n+\t\t\t(struct clast_user_stmt *) stmt);\n+      next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), region,\n+\t\t\t\t\t       next_e, rename_map);\n+      new_bb = next_e->src;\n+      mark_bb_with_pbb (pbb, new_bb, bb_pbb_mapping);\n+      recompute_all_dominators ();\n+      update_ssa (TODO_update_ssa);\n+      graphite_verify ();\n+      return translate_clast (region, context_loop, stmt->next, next_e,\n+\t\t\t      rename_map, newivs, newivs_index,\n+\t\t\t      bb_pbb_mapping);\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_for))\n+    {\n+      struct clast_for *stmtfor = (struct clast_for *)stmt;\n+      struct loop *loop\n+\t= graphite_create_new_loop (region, next_e, stmtfor,\n+\t\t\t\t    context_loop, newivs, newivs_index);\n+      edge last_e = single_exit (loop);\n+      edge to_body = single_succ_edge (loop->header);\n+      basic_block after = to_body->dest;\n+\n+      loop->aux = XNEW (int);\n+      /* Pass scattering level information of the new loop by LOOP->AUX.  */\n+      *((int *)(loop->aux)) = get_stmtfor_depth (stmtfor);\n+\n+      /* Create a basic block for loop close phi nodes.  */\n+      last_e = single_succ_edge (split_edge (last_e));\n+\n+      /* Translate the body of the loop.  */\n+      next_e = translate_clast\n+\t(region, loop, ((struct clast_for *) stmt)->body,\n+\t single_succ_edge (loop->header), rename_map, newivs,\n+\t newivs_index, bb_pbb_mapping);\n+      redirect_edge_succ_nodup (next_e, after);\n+      set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n+\n+      /* Remove from rename_map all the tuples containing variables\n+\t defined in loop's body.  */\n+      insert_loop_close_phis (rename_map, loop);\n+\n+      recompute_all_dominators ();\n+      graphite_verify ();\n+      return translate_clast (region, context_loop, stmt->next, last_e,\n+\t\t\t      rename_map, newivs, newivs_index,\n+\t\t\t      bb_pbb_mapping);\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    {\n+      edge last_e = graphite_create_new_guard (region, next_e,\n+\t\t\t\t\t       ((struct clast_guard *) stmt),\n+\t\t\t\t\t       *newivs, newivs_index);\n+      edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n+      edge false_e = get_false_edge_from_guard_bb (next_e->dest);\n+      edge exit_true_e = single_succ_edge (true_e->dest);\n+      edge exit_false_e = single_succ_edge (false_e->dest);\n+      htab_t before_guard = htab_create (10, rename_map_elt_info,\n+\t\t\t\t\t eq_rename_map_elts, free);\n+\n+      htab_traverse (rename_map, copy_renames, before_guard);\n+      next_e = translate_clast (region, context_loop,\n+\t\t\t\t((struct clast_guard *) stmt)->then,\n+\t\t\t\ttrue_e, rename_map, newivs, newivs_index,\n+\t\t\t\tbb_pbb_mapping);\n+      insert_guard_phis (last_e->src, exit_true_e, exit_false_e,\n+\t\t\t before_guard, rename_map);\n+\n+      htab_delete (before_guard);\n+      recompute_all_dominators ();\n+      graphite_verify ();\n+\n+      return translate_clast (region, context_loop, stmt->next, last_e,\n+\t\t\t      rename_map, newivs, newivs_index,\n+\t\t\t      bb_pbb_mapping);\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_block))\n+    {\n+      next_e = translate_clast (region, context_loop,\n+\t\t\t\t((struct clast_block *) stmt)->body,\n+\t\t\t\tnext_e, rename_map, newivs, newivs_index,\n+\t\t\t\tbb_pbb_mapping);\n+      recompute_all_dominators ();\n+      graphite_verify ();\n+      return translate_clast (region, context_loop, stmt->next, next_e,\n+\t\t\t      rename_map, newivs, newivs_index,\n+\t\t\t      bb_pbb_mapping);\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Returns the first cloog name used in EXPR.  */\n+\n+static const char *\n+find_cloog_iv_in_expr (struct clast_expr *expr)\n+{\n+  struct clast_term *term = (struct clast_term *) expr;\n+\n+  if (expr->type == expr_term\n+      && !term->var)\n+    return NULL;\n+\n+  if (expr->type == expr_term)\n+    return term->var;\n+\n+  if (expr->type == expr_red)\n+    {\n+      int i;\n+      struct clast_reduction *red = (struct clast_reduction *) expr;\n+\n+      for (i = 0; i < red->n; i++)\n+\t{\n+\t  const char *res = find_cloog_iv_in_expr ((red)->elts[i]);\n+\n+\t  if (res)\n+\t    return res;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Build for a clast_user_stmt USER_STMT a map between the CLAST\n+   induction variables and the corresponding GCC old induction\n+   variables.  This information is stored on each GRAPHITE_BB.  */\n+\n+static void\n+compute_cloog_iv_types_1 (poly_bb_p pbb, struct clast_user_stmt *user_stmt)\n+{\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+  struct clast_stmt *t;\n+  int index = 0;\n+\n+  for (t = user_stmt->substitutions; t; t = t->next, index++)\n+    {\n+      PTR *slot;\n+      struct ivtype_map_elt_s tmp;\n+      struct clast_expr *expr = (struct clast_expr *) \n+\t((struct clast_assignment *)t)->RHS;\n+\n+      /* Create an entry (clast_var, type).  */\n+      tmp.cloog_iv = find_cloog_iv_in_expr (expr);\n+      if (!tmp.cloog_iv)\n+\tcontinue;\n+\n+      slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, INSERT);\n+\n+      if (!*slot)\n+\t{\n+\t  tree oldiv = pbb_to_depth_to_oldiv (pbb, index);\n+\t  tree type = oldiv ? TREE_TYPE (oldiv) : integer_type_node;\n+\t  *slot = new_ivtype_map_elt (tmp.cloog_iv, type);\n+\t}\n+    }\n+}\n+\n+/* Walk the CLAST tree starting from STMT and build for each\n+   clast_user_stmt a map between the CLAST induction variables and the\n+   corresponding GCC old induction variables.  This information is\n+   stored on each GRAPHITE_BB.  */\n+\n+static void\n+compute_cloog_iv_types (struct clast_stmt *stmt)\n+{\n+  if (!stmt)\n+    return;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_root))\n+    goto next;\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_user))\n+    {\n+      CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n+      poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n+      gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+\n+      if (!GBB_CLOOG_IV_TYPES (gbb))\n+\tGBB_CLOOG_IV_TYPES (gbb) = htab_create (10, ivtype_map_elt_info,\n+\t\t\t\t\t\teq_ivtype_map_elts, free);\n+\n+      compute_cloog_iv_types_1 (pbb, (struct clast_user_stmt *) stmt);\n+      goto next;\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_for))\n+    {\n+      struct clast_stmt *s = ((struct clast_for *) stmt)->body;\n+      compute_cloog_iv_types (s);\n+      goto next;\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    {\n+      struct clast_stmt *s = ((struct clast_guard *) stmt)->then;\n+      compute_cloog_iv_types (s);\n+      goto next;\n+    }\n+\n+  if (CLAST_STMT_IS_A (stmt, stmt_block))\n+    {\n+      struct clast_stmt *s = ((struct clast_block *) stmt)->body;\n+      compute_cloog_iv_types (s);\n+      goto next;\n+    }\n+\n+  gcc_unreachable ();\n+\n+ next:\n+  compute_cloog_iv_types (stmt->next);\n+}\n+\n+/* Free the SCATTERING domain list.  */\n+\n+static void\n+free_scattering (CloogDomainList *scattering)\n+{\n+  while (scattering)\n+    {\n+      CloogDomain *dom = cloog_domain (scattering);\n+      CloogDomainList *next = cloog_next_domain (scattering);\n+\n+      cloog_domain_free (dom);\n+      free (scattering);\n+      scattering = next;\n+    }\n+}\n+\n+/* Initialize Cloog's parameter names from the names used in GIMPLE.\n+   Initialize Cloog's iterator names, using 'graphite_iterator_%d'\n+   from 0 to scop_nb_loops (scop).  */\n+\n+static void\n+initialize_cloog_names (scop_p scop, CloogProgram *prog)\n+{\n+  sese region = SCOP_REGION (scop);\n+  int i;\n+  int nb_iterators = scop_max_loop_depth (scop);\n+  int nb_scattering = cloog_program_nb_scattdims (prog);\n+  char **iterators = XNEWVEC (char *, nb_iterators * 2);\n+  char **scattering = XNEWVEC (char *, nb_scattering);\n+\n+  cloog_program_set_names (prog, cloog_names_malloc ());\n+  cloog_names_set_nb_parameters (cloog_program_names (prog),\n+\t\t\t\t VEC_length (tree, SESE_PARAMS (region)));\n+  cloog_names_set_parameters (cloog_program_names (prog),\n+\t\t\t      SESE_PARAMS_NAMES (region));\n+\n+  for (i = 0; i < nb_iterators; i++)\n+    {\n+      int len = 4 + 16;\n+      iterators[i] = XNEWVEC (char, len);\n+      snprintf (iterators[i], len, \"git_%d\", i);\n+    }\n+\n+  cloog_names_set_nb_iterators (cloog_program_names (prog),\n+\t\t\t\tnb_iterators);\n+  cloog_names_set_iterators (cloog_program_names (prog),\n+\t\t\t     iterators);\n+\n+  for (i = 0; i < nb_scattering; i++)\n+    {\n+      int len = 5 + 16;\n+      scattering[i] = XNEWVEC (char, len);\n+      snprintf (scattering[i], len, \"scat_%d\", i);\n+    }\n+\n+  cloog_names_set_nb_scattering (cloog_program_names (prog),\n+\t\t\t\t nb_scattering);\n+  cloog_names_set_scattering (cloog_program_names (prog),\n+\t\t\t      scattering);\n+}\n+\n+/* Build cloog program for SCoP.  */\n+\n+static void\n+build_cloog_prog (scop_p scop, CloogProgram *prog)\n+{\n+  int i;\n+  int max_nb_loops = scop_max_loop_depth (scop);\n+  poly_bb_p pbb;\n+  CloogLoop *loop_list = NULL;\n+  CloogBlockList *block_list = NULL;\n+  CloogDomainList *scattering = NULL;\n+  int nbs = 2 * max_nb_loops + 1;\n+  int *scaldims;\n+\n+  cloog_program_set_context\n+    (prog, new_Cloog_Domain_from_ppl_Pointset_Powerset (SCOP_CONTEXT (scop)));\n+  nbs = unify_scattering_dimensions (scop);\n+  scaldims = (int *) xmalloc (nbs * (sizeof (int)));\n+  cloog_program_set_nb_scattdims (prog, nbs);\n+  initialize_cloog_names (scop, prog);\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    {\n+      CloogStatement *stmt;\n+      CloogBlock *block;\n+\n+      /* Dead code elimination: when the domain of a PBB is empty,\n+\t don't generate code for the PBB.  */\n+      if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (PBB_DOMAIN (pbb)))\n+\tcontinue;\n+\n+      /* Build the new statement and its block.  */\n+      stmt = cloog_statement_alloc (GBB_BB (PBB_BLACK_BOX (pbb))->index);\n+      block = cloog_block_alloc (stmt, 0, NULL, pbb_dim_iter_domain (pbb));\n+      cloog_statement_set_usr (stmt, pbb);\n+\n+      /* Build loop list.  */\n+      {\n+        CloogLoop *new_loop_list = cloog_loop_malloc ();\n+        cloog_loop_set_next (new_loop_list, loop_list);\n+        cloog_loop_set_domain\n+\t  (new_loop_list,\n+\t   new_Cloog_Domain_from_ppl_Pointset_Powerset (PBB_DOMAIN (pbb)));\n+        cloog_loop_set_block (new_loop_list, block);\n+        loop_list = new_loop_list;\n+      }\n+\n+      /* Build block list.  */\n+      {\n+        CloogBlockList *new_block_list = cloog_block_list_malloc ();\n+\n+        cloog_block_list_set_next (new_block_list, block_list);\n+        cloog_block_list_set_block (new_block_list, block);\n+        block_list = new_block_list;\n+      }\n+\n+      /* Build scattering list.  */\n+      {\n+        /* XXX: Replace with cloog_domain_list_alloc(), when available.  */\n+        CloogDomainList *new_scattering\n+\t  = (CloogDomainList *) xmalloc (sizeof (CloogDomainList));\n+        ppl_Polyhedron_t scat;\n+\tCloogDomain *dom;\n+\n+\tscat = PBB_TRANSFORMED_SCATTERING (pbb);\n+\tdom = new_Cloog_Domain_from_ppl_Polyhedron (scat);\n+\n+        cloog_set_next_domain (new_scattering, scattering);\n+        cloog_set_domain (new_scattering, dom);\n+        scattering = new_scattering;\n+      }\n+    }\n+\n+  cloog_program_set_loop (prog, loop_list);\n+  cloog_program_set_blocklist (prog, block_list);\n+\n+  for (i = 0; i < nbs; i++)\n+    scaldims[i] = 0 ;\n+\n+  cloog_program_set_scaldims (prog, scaldims);\n+\n+  /* Extract scalar dimensions to simplify the code generation problem.  */\n+  cloog_program_extract_scalars (prog, scattering);\n+\n+  /* Apply scattering.  */\n+  cloog_program_scatter (prog, scattering);\n+  free_scattering (scattering);\n+\n+  /* Iterators corresponding to scalar dimensions have to be extracted.  */\n+  cloog_names_scalarize (cloog_program_names (prog), nbs,\n+\t\t\t cloog_program_scaldims (prog));\n+\n+  /* Free blocklist.  */\n+  {\n+    CloogBlockList *next = cloog_program_blocklist (prog);\n+\n+    while (next)\n+      {\n+        CloogBlockList *toDelete = next;\n+        next = cloog_block_list_next (next);\n+        cloog_block_list_set_next (toDelete, NULL);\n+        cloog_block_list_set_block (toDelete, NULL);\n+        cloog_block_list_free (toDelete);\n+      }\n+    cloog_program_set_blocklist (prog, NULL);\n+  }\n+}\n+\n+/* Return the options that will be used in GLOOG.  */\n+\n+static CloogOptions *\n+set_cloog_options (void)\n+{\n+  CloogOptions *options = cloog_options_malloc ();\n+\n+  /* Change cloog output language to C.  If we do use FORTRAN instead, cloog\n+     will stop e.g. with \"ERROR: unbounded loops not allowed in FORTRAN.\", if\n+     we pass an incomplete program to cloog.  */\n+  options->language = LANGUAGE_C;\n+\n+  /* Enable complex equality spreading: removes dummy statements\n+     (assignments) in the generated code which repeats the\n+     substitution equations for statements.  This is useless for\n+     GLooG.  */\n+  options->esp = 1;\n+\n+  /* Enable C pretty-printing mode: normalizes the substitution\n+     equations for statements.  */\n+  options->cpp = 1;\n+\n+  /* Allow cloog to build strides with a stride width different to one.\n+     This example has stride = 4:\n+\n+     for (i = 0; i < 20; i += 4)\n+       A  */\n+  options->strides = 1;\n+\n+  /* Disable optimizations and make cloog generate source code closer to the\n+     input.  This is useful for debugging,  but later we want the optimized\n+     code.\n+\n+     XXX: We can not disable optimizations, as loop blocking is not working\n+     without them.  */\n+  if (0)\n+    {\n+      options->f = -1;\n+      options->l = INT_MAX;\n+    }\n+\n+  return options;\n+}\n+\n+/* Prints STMT to STDERR.  */\n+\n+void\n+print_clast_stmt (FILE *file, struct clast_stmt *stmt)\n+{\n+  CloogOptions *options = set_cloog_options ();\n+\n+  pprint (file, stmt, 0, options);\n+  cloog_options_free (options);\n+}\n+\n+/* Prints STMT to STDERR.  */\n+\n+void\n+debug_clast_stmt (struct clast_stmt *stmt)\n+{\n+  print_clast_stmt (stderr, stmt);\n+}\n+\n+/* Translate SCOP to a CLooG program and clast.  These two\n+   representations should be freed together: a clast cannot be used\n+   without a program.  */\n+\n+cloog_prog_clast\n+scop_to_clast (scop_p scop)\n+{\n+  CloogOptions *options = set_cloog_options ();\n+  cloog_prog_clast pc;\n+\n+  /* Connect new cloog prog generation to graphite.  */\n+  pc.prog = cloog_program_malloc ();\n+  build_cloog_prog (scop, pc.prog);\n+  pc.prog = cloog_program_generate (pc.prog, options);\n+  pc.stmt = cloog_clast_create (pc.prog, options);\n+\n+  cloog_options_free (options);\n+  return pc;\n+}\n+\n+/* Prints to FILE the code generated by CLooG for SCOP.  */\n+\n+void\n+print_generated_program (FILE *file, scop_p scop)\n+{\n+  CloogOptions *options = set_cloog_options ();\n+  cloog_prog_clast pc = scop_to_clast (scop);\n+\n+  fprintf (file, \"       (prog: \\n\");\n+  cloog_program_print (file, pc.prog);\n+  fprintf (file, \"       )\\n\");\n+\n+  fprintf (file, \"       (clast: \\n\");\n+  pprint (file, pc.stmt, 0, options);\n+  fprintf (file, \"       )\\n\");\n+\n+  cloog_options_free (options);\n+  cloog_clast_free (pc.stmt);\n+  cloog_program_free (pc.prog);\n+}\n+\n+/* Prints to STDERR the code generated by CLooG for SCOP.  */\n+\n+void\n+debug_generated_program (scop_p scop)\n+{\n+  print_generated_program (stderr, scop);\n+}\n+\n+/* A LOOP is in normal form for Graphite when it contains only one\n+   scalar phi node that defines the main induction variable of the\n+   loop, only one increment of the IV, and only one exit condition.  */\n+\n+static void\n+graphite_loop_normal_form (loop_p loop)\n+{\n+  struct tree_niter_desc niter;\n+  tree nit;\n+  gimple_seq stmts;\n+  edge exit = single_dom_exit (loop);\n+\n+  bool known_niter = number_of_iterations_exit (loop, exit, &niter, false);\n+\n+  /* At this point we should know the number of iterations,  */\n+  gcc_assert (known_niter);\n+\n+  nit = force_gimple_operand (unshare_expr (niter.niter), &stmts, true,\n+\t\t\t      NULL_TREE);\n+  if (stmts)\n+    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+\n+  loop->aux = canonicalize_loop_ivs (loop, &nit);\n+}\n+\n+/* Converts REGION to loop normal form: one induction variable per loop.  */\n+\n+static void\n+build_graphite_loop_normal_form (sese region)\n+{\n+  int i;\n+  loop_p loop;\n+\n+  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+    graphite_loop_normal_form (loop);\n+}\n+\n+/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n+   the given SCOP.  Return true if code generation succeeded.\n+   BB_PBB_MAPPING is a basic_block and it's related poly_bb_p mapping.\n+*/\n+\n+bool\n+gloog (scop_p scop, htab_t bb_pbb_mapping)\n+{\n+  edge new_scop_exit_edge = NULL;\n+  VEC (tree, heap) *newivs = VEC_alloc (tree, heap, 10);\n+  loop_p context_loop;\n+  sese region = SCOP_REGION (scop);\n+  ifsese if_region = NULL;\n+  htab_t rename_map, newivs_index;\n+  cloog_prog_clast pc = scop_to_clast (scop);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nCLAST generated by CLooG: \\n\");\n+      print_clast_stmt (dump_file, pc.stmt);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  build_graphite_loop_normal_form (region);\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  if_region = move_sese_in_condition (region);\n+  sese_insert_phis_for_liveouts (region,\n+\t\t\t\t if_region->region->exit->src,\n+\t\t\t\t if_region->false_region->exit,\n+\t\t\t\t if_region->true_region->exit);\n+\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+  context_loop = SESE_ENTRY (region)->src->loop_father;\n+  compute_cloog_iv_types (pc.stmt);\n+\n+  rename_map = htab_create (10, rename_map_elt_info, eq_rename_map_elts, free);\n+  newivs_index = htab_create (10, clast_name_index_elt_info,\n+\t\t\t      eq_clast_name_indexes, free);\n+\n+  new_scop_exit_edge = translate_clast (region, context_loop, pc.stmt,\n+\t\t\t\t\tif_region->true_region->entry,\n+\t\t\t\t\trename_map, &newivs, newivs_index,\n+\t\t\t\t\tbb_pbb_mapping);\n+  sese_reset_aux_in_loops (region);\n+  graphite_verify ();\n+  sese_adjust_liveout_phis (region, rename_map,\n+\t\t\t    if_region->region->exit->src,\n+\t\t\t    if_region->false_region->exit,\n+\t\t\t    if_region->true_region->exit);\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  htab_delete (rename_map);\n+  htab_delete (newivs_index);\n+  VEC_free (tree, heap, newivs);\n+  cloog_clast_free (pc.stmt);\n+  cloog_program_free (pc.prog);\n+  return true;\n+}\n+\n+\f\n+\n+/* Find BB's related poly_bb_p in hash table BB_PBB_MAPPING.  */\n+\n+static poly_bb_p\n+find_pbb_via_hash (htab_t bb_pbb_mapping, basic_block bb)\n+{\n+  bb_pbb_def tmp;\n+  PTR *slot;\n+\n+  tmp.bb = bb;\n+  slot = htab_find_slot (bb_pbb_mapping, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((bb_pbb_def *) *slot)->pbb;\n+\n+  return NULL;\n+}\n+\n+/* Free loop->aux in newly created loops by translate_clast.  */\n+\n+void\n+free_aux_in_new_loops (void)\n+{\n+  loop_p loop;\n+  loop_iterator li;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      if (!loop->aux)\n+\tcontinue;\n+      free(loop->aux);\n+      loop->aux = NULL;\n+    }\n+}\n+\n+/* Check data dependency in LOOP. BB_PBB_MAPPING is a basic_block and\n+   it's related poly_bb_p mapping.\n+*/\n+\n+static bool\n+dependency_in_loop_p (loop_p loop, htab_t bb_pbb_mapping)\n+{\n+  unsigned i,j;\n+  int level = 0;\n+  basic_block *bbs = get_loop_body_in_dom_order (loop);\n+\n+  level = *((int *)(loop->aux));\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      poly_bb_p pbb1 = find_pbb_via_hash (bb_pbb_mapping, bbs[i]);\n+\n+      if (pbb1 == NULL)\n+       continue;\n+\n+      for (j = 0; j < loop->num_nodes; j++)\n+       {\n+\t poly_bb_p pbb2 = find_pbb_via_hash (bb_pbb_mapping, bbs[j]);\n+\n+\t if (pbb2 == NULL)\n+\t   continue;\n+\n+\t if (dependency_between_pbbs_p (pbb1, pbb2, level))\n+\t   {\n+\t     free (bbs);\n+\t     return true;\n+\t   }\n+       }\n+    }\n+\n+  free (bbs);\n+\n+  return false;\n+}\n+\n+/* Mark loop as parallel if data dependency does not exist.\n+   BB_PBB_MAPPING is a basic_block and it's related poly_bb_p mapping.\n+*/\n+\n+void mark_loops_parallel (htab_t bb_pbb_mapping)\n+{\n+  loop_p loop;\n+  loop_iterator li;\n+  int num_no_dependency = 0;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      if (!loop->aux)\n+\tcontinue;\n+\n+      if (!dependency_in_loop_p (loop, bb_pbb_mapping))\n+\t{\n+\t  loop->can_be_parallel = true;\n+\t  num_no_dependency++;\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\n%d loops carried no dependency.\\n\",\n+\t       num_no_dependency);\n+    }\n+}\n+\n+#endif"}, {"sha": "e0ae6eedb3da7b764e8d8724ec0d8e44802d767d", "filename": "gcc/graphite-clast-to-gimple.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-clast-to-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-clast-to-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,66 @@\n+/* Translation of CLAST (CLooG AST) to Gimple.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GRAPHITE_CLAST_TO_GIMPLE_H\n+#define GCC_GRAPHITE_CLAST_TO_GIMPLE_H\n+\n+/* Data structure for CLooG program representation.  */\n+\n+typedef struct cloog_prog_clast {\n+  CloogProgram *prog;\n+  struct clast_stmt *stmt;\n+} cloog_prog_clast;\n+\n+/* Stores BB's related PBB.  */\n+\n+typedef struct bb_pbb_def\n+{\n+  basic_block bb;\n+  poly_bb_p pbb;\n+}bb_pbb_def;\n+\n+extern bool gloog (scop_p, htab_t);\n+extern cloog_prog_clast scop_to_clast (scop_p);\n+extern void debug_clast_stmt (struct clast_stmt *);\n+extern void print_clast_stmt (FILE *, struct clast_stmt *);\n+extern void debug_clast_name_indexes (htab_t);\n+extern void mark_loops_parallel (htab_t);\n+extern void free_aux_in_new_loops (void);\n+\n+/* Hash function for data base element BB_PBB.  */\n+\n+static inline hashval_t\n+bb_pbb_map_hash (const void *bb_pbb)\n+{\n+  return (hashval_t)(((const bb_pbb_def *)bb_pbb)->bb->index);\n+}\n+\n+/* Compare data base element BB_PBB1 and BB_PBB2.  */\n+\n+static inline int\n+eq_bb_pbb_map (const void *bb_pbb1, const void *bb_pbb2)\n+{\n+  const bb_pbb_def *bp1 = (const bb_pbb_def *) bb_pbb1;\n+  const bb_pbb_def *bp2 = (const bb_pbb_def *) bb_pbb2;\n+  return (bp1->bb->index == bp2->bb->index);\n+}\n+\n+\n+#endif"}, {"sha": "3cd41ede5664a4de58c4d1f34d548748d493dff6", "filename": "gcc/graphite-dependences.c", "status": "added", "additions": 692, "deletions": 0, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,692 @@\n+/* Data dependence analysis for Graphite.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Konrad Trifunovic <konrad.trifunovic@inria.fr>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"sese.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+#include \"graphite-dependences.h\"\n+\n+/* Creates a new polyhedral data reference pair and\n+   returns it.  Parameter SOURCE denotes a source data reference\n+   while parameter SINK denotes a sink data reference.  Both\n+   SOURCE and SINK define a pair of references, thus they\n+   define an edge in DDG (Data Dependence Graph).  */\n+\n+static poly_dr_pair_p\n+new_poly_dr_pair (poly_dr_p source,\n+                  poly_dr_p sink,\n+                  ppl_Pointset_Powerset_C_Polyhedron_t ddp)\n+{\n+  poly_dr_pair_p pdrpp;\n+\n+  pdrpp = XNEW (struct poly_dr_pair);\n+  pdrpp->source = source;\n+  pdrpp->sink = sink;\n+  pdrpp->ddp = ddp;\n+\n+  return pdrpp;\n+}\n+\n+/* Comparison function for poly_dr_pair hash table.  */\n+\n+int\n+eq_poly_dr_pair_p (const void *pdrpp1, const void *pdrpp2)\n+{\n+  const struct poly_dr_pair *p1 = (const struct poly_dr_pair *) pdrpp1;\n+  const struct poly_dr_pair *p2 = (const struct poly_dr_pair *) pdrpp2;\n+\n+  return (p1->source == p2->source\n+          && p1->sink == p2->sink);\n+}\n+\n+/* Hash function for poly_dr_pair hashtable.  */\n+\n+hashval_t\n+hash_poly_dr_pair_p (const void *pdrpp)\n+{\n+  const struct poly_dr_pair *p = (const struct poly_dr_pair *) pdrpp;\n+\n+  return (hashval_t) ((long) p->source + (long) p->sink);\n+}\n+\n+/* Returns a polyhedron of dimension DIM.\n+\n+   Maps the dimensions [0, ..., cut - 1] of polyhedron P to OFFSET0\n+   and the dimensions [cut, ..., nb_dim] to DIM - GDIM.  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+map_into_dep_poly (graphite_dim_t dim, graphite_dim_t gdim,\n+\t\t   ppl_Pointset_Powerset_C_Polyhedron_t p,\n+\t\t   graphite_dim_t cut,\n+\t\t   graphite_dim_t offset)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&res, p);\n+  ppl_insert_dimensions_pointset (res, 0, offset);\n+  ppl_insert_dimensions_pointset (res, offset + cut,\n+\t\t\t\t  dim - offset - cut - gdim);\n+\n+  return res;\n+}\n+\n+/* Swap [cut0, ..., cut1] to the end of DR: \"a CUT0 b CUT1 c\" is\n+   transformed into \"a CUT0 c CUT1' b\"\n+\n+   Add NB0 zeros before \"a\":  \"00...0 a CUT0 c CUT1' b\"\n+   Add NB1 zeros between \"a\" and \"c\":  \"00...0 a 00...0 c CUT1' b\"\n+   Add DIM - NB0 - NB1 - PDIM zeros between \"c\" and \"b\":\n+   \"00...0 a 00...0 c 00...0 b\".  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+map_dr_into_dep_poly (graphite_dim_t dim,\n+\t\t      ppl_Pointset_Powerset_C_Polyhedron_t dr,\n+\t\t      graphite_dim_t cut0, graphite_dim_t cut1,\n+\t\t      graphite_dim_t nb0, graphite_dim_t nb1)\n+{\n+  ppl_dimension_type pdim;\n+  ppl_dimension_type *map;\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+  ppl_dimension_type i;\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&res, dr);\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (res, &pdim);\n+\n+  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, pdim);\n+\n+  /* First mapping: move 'g' vector to right position.  */\n+  for (i = 0; i < cut0; i++)\n+    map[i] = i;\n+\n+  for (i = cut0; i < cut1; i++)\n+    map[i] = pdim - cut1 + i;\n+\n+  for (i = cut1; i < pdim; i++)\n+    map[i] = cut0 + i - cut1;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (res, map, pdim);\n+  free (map);\n+\n+  /* After swapping 's' and 'g' vectors, we have to update a new cut.  */\n+  cut1 = pdim - cut1 + cut0;\n+\n+  ppl_insert_dimensions_pointset (res, 0, nb0);\n+  ppl_insert_dimensions_pointset (res, nb0 + cut0, nb1);\n+  ppl_insert_dimensions_pointset (res, nb0 + nb1 + cut1,\n+\t\t\t\t  dim - nb0 - nb1 - pdim);\n+\n+  return res;\n+}\n+\n+/* Builds a constraints of the form \"POS1 - POS2 CSTR_TYPE C\" */\n+\n+static ppl_Constraint_t\n+build_pairwise_constraint (graphite_dim_t dim,\n+\t\t           graphite_dim_t pos1, graphite_dim_t pos2,\n+\t\t\t   int c, enum ppl_enum_Constraint_Type cstr_type)\n+{\n+  ppl_Linear_Expression_t expr;\n+  ppl_Constraint_t cstr;\n+  ppl_Coefficient_t coef;\n+  Value v, v_op, v_c;\n+\n+  value_init (v);\n+  value_init (v_op);\n+  value_init (v_c);\n+\n+  value_set_si (v, 1);\n+  value_set_si (v_op, -1);\n+  value_set_si (v_c, c);\n+\n+  ppl_new_Coefficient (&coef);\n+  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+\n+  ppl_assign_Coefficient_from_mpz_t (coef, v);\n+  ppl_Linear_Expression_add_to_coefficient (expr, pos1, coef);\n+  ppl_assign_Coefficient_from_mpz_t (coef, v_op);\n+  ppl_Linear_Expression_add_to_coefficient (expr, pos2, coef);\n+  ppl_assign_Coefficient_from_mpz_t (coef, v_c);\n+  ppl_Linear_Expression_add_to_inhomogeneous (expr, coef);\n+\n+  ppl_new_Constraint (&cstr, expr, cstr_type);\n+\n+  ppl_delete_Linear_Expression (expr);\n+  ppl_delete_Coefficient (coef);\n+  value_clear (v);\n+  value_clear (v_op);\n+  value_clear (v_c);\n+\n+  return cstr;\n+}\n+\n+/* Builds subscript equality constraints.  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+dr_equality_constraints (graphite_dim_t dim,\n+\t\t         graphite_dim_t pos, graphite_dim_t nb_subscripts)\n+{\n+  ppl_Polyhedron_t subscript_equalities;\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+  Value v, v_op;\n+  graphite_dim_t i;\n+\n+  value_init (v);\n+  value_init (v_op);\n+  value_set_si (v, 1);\n+  value_set_si (v_op, -1);\n+\n+  ppl_new_C_Polyhedron_from_space_dimension (&subscript_equalities, dim, 0);\n+  for (i = 0; i < nb_subscripts; i++)\n+    {\n+      ppl_Linear_Expression_t expr;\n+      ppl_Constraint_t cstr;\n+      ppl_Coefficient_t coef;\n+\n+      ppl_new_Coefficient (&coef);\n+      ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+\n+      ppl_assign_Coefficient_from_mpz_t (coef, v);\n+      ppl_Linear_Expression_add_to_coefficient (expr, pos + i, coef);\n+      ppl_assign_Coefficient_from_mpz_t (coef, v_op);\n+      ppl_Linear_Expression_add_to_coefficient (expr, pos + i + nb_subscripts,\n+\t\t\t\t\t\tcoef);\n+\n+      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n+      ppl_Polyhedron_add_constraint (subscript_equalities, cstr);\n+\n+      ppl_delete_Linear_Expression (expr);\n+      ppl_delete_Constraint (cstr);\n+      ppl_delete_Coefficient (coef);\n+    }\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n+    (&res, subscript_equalities);\n+  value_clear (v);\n+  value_clear (v_op);\n+  ppl_delete_Polyhedron (subscript_equalities);\n+\n+  return res;\n+}\n+\n+/* Builds scheduling equality constraints.  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+build_pairwise_scheduling_equality (graphite_dim_t dim,\n+\t\t                    graphite_dim_t pos, graphite_dim_t offset)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+  ppl_Polyhedron_t equalities;\n+  ppl_Constraint_t cstr;\n+\n+  ppl_new_C_Polyhedron_from_space_dimension (&equalities, dim, 0);\n+\n+  cstr = build_pairwise_constraint (dim, pos, pos + offset, 0,\n+\t\t\t\t    PPL_CONSTRAINT_TYPE_EQUAL);\n+  ppl_Polyhedron_add_constraint (equalities, cstr);\n+  ppl_delete_Constraint (cstr);\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&res, equalities);\n+  ppl_delete_Polyhedron (equalities);\n+  return res;\n+}\n+\n+/* Builds scheduling inequality constraints.  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+build_pairwise_scheduling_inequality (graphite_dim_t dim,\n+\t\t\t\t      graphite_dim_t pos,\n+\t\t\t\t      graphite_dim_t offset,\n+\t\t\t\t      bool direction)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+  ppl_Polyhedron_t equalities;\n+  ppl_Constraint_t cstr;\n+\n+  ppl_new_C_Polyhedron_from_space_dimension (&equalities, dim, 0);\n+\n+  if (direction)\n+    cstr = build_pairwise_constraint (dim, pos, pos + offset, -1,\n+\t\t\t\t      PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+  else\n+    cstr = build_pairwise_constraint (dim, pos, pos + offset, 1,\n+\t\t\t\t      PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL);\n+\n+  ppl_Polyhedron_add_constraint (equalities, cstr);\n+  ppl_delete_Constraint (cstr);\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&res, equalities);\n+  ppl_delete_Polyhedron (equalities);\n+  return res;\n+}\n+\n+/* Returns true when adding the lexicographical constraints at level I\n+   to the RES dependence polyhedron returns an empty polyhedron.  */\n+\n+static bool\n+lexicographically_gt_p (ppl_Pointset_Powerset_C_Polyhedron_t res,\n+\t\t\tgraphite_dim_t dim,\n+\t\t\tgraphite_dim_t offset,\n+\t\t\tbool direction, graphite_dim_t i)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t ineq;\n+  bool empty_p;\n+\n+  ineq = build_pairwise_scheduling_inequality (dim, i, offset,\n+\t\t\t\t\t       direction);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (ineq, res);\n+  empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (ineq);\n+  if (!empty_p)\n+    ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, ineq);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (ineq);\n+\n+  return !empty_p;\n+}\n+\n+/* Build the precedence constraints for the lexicographical comparison\n+   of time vectors RES following the lexicographical order.  */\n+\n+static void\n+build_lexicographically_gt_constraint (ppl_Pointset_Powerset_C_Polyhedron_t *res,\n+\t\t\t\t       graphite_dim_t dim,\n+\t\t\t\t       graphite_dim_t tdim1,\n+\t\t\t\t       graphite_dim_t offset,\n+\t\t\t\t       bool direction)\n+{\n+  graphite_dim_t i;\n+\n+  if (lexicographically_gt_p (*res, dim, offset, direction, 0))\n+    return;\n+\n+  for (i = 0; i < tdim1 - 1; i++)\n+    {\n+      ppl_Pointset_Powerset_C_Polyhedron_t sceq;\n+\n+      sceq = build_pairwise_scheduling_equality (dim, i, offset);\n+      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, sceq);\n+      ppl_delete_Pointset_Powerset_C_Polyhedron (sceq);\n+\n+      if (lexicographically_gt_p (*res, dim, offset, direction, i + 1))\n+\treturn;\n+    }\n+\n+  if (i == tdim1 - 1)\n+    {\n+      ppl_delete_Pointset_Powerset_C_Polyhedron (*res);\n+      ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (res, dim, 1);\n+    }\n+}\n+\n+/* Build the dependence polyhedron for data references PDR1 and PDR2.  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+dependence_polyhedron_1 (poly_bb_p pbb1, poly_bb_p pbb2,\n+\t\t         ppl_Pointset_Powerset_C_Polyhedron_t d1,\n+\t\t         ppl_Pointset_Powerset_C_Polyhedron_t d2,\n+\t\t         poly_dr_p pdr1, poly_dr_p pdr2,\n+\t                 ppl_Polyhedron_t s1, ppl_Polyhedron_t s2,\n+\t\t         bool direction,\n+\t\t         bool original_scattering_p)\n+{\n+  scop_p scop = PBB_SCOP (pbb1);\n+  graphite_dim_t tdim1 = original_scattering_p ?\n+    pbb_nb_scattering_orig (pbb1) : pbb_nb_scattering_transform (pbb1);\n+  graphite_dim_t tdim2 = original_scattering_p ?\n+    pbb_nb_scattering_orig (pbb2) : pbb_nb_scattering_transform (pbb2);\n+  graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb1);\n+  graphite_dim_t ddim2 = pbb_dim_iter_domain (pbb2);\n+  graphite_dim_t sdim1 = pdr_nb_subscripts (pdr1) + 1;\n+  graphite_dim_t gdim = scop_nb_params (scop);\n+  graphite_dim_t dim1 = pdr_dim (pdr1);\n+  graphite_dim_t dim2 = pdr_dim (pdr2);\n+  graphite_dim_t dim = tdim1 + tdim2 + dim1 + dim2;\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+  ppl_Pointset_Powerset_C_Polyhedron_t id1, id2, isc1, isc2, idr1, idr2;\n+  ppl_Pointset_Powerset_C_Polyhedron_t sc1, sc2, dreq;\n+\n+  gcc_assert (PBB_SCOP (pbb1) == PBB_SCOP (pbb2));\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&sc1, s1);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&sc2, s2);\n+\n+  id1 = map_into_dep_poly (dim, gdim, d1, ddim1, tdim1);\n+  id2 = map_into_dep_poly (dim, gdim, d2, ddim2, tdim1 + ddim1 + tdim2);\n+  isc1 = map_into_dep_poly (dim, gdim, sc1, ddim1 + tdim1, 0);\n+  isc2 = map_into_dep_poly (dim, gdim, sc2, ddim2 + tdim2, tdim1 + ddim1);\n+\n+  idr1 = map_dr_into_dep_poly (dim, PDR_ACCESSES (pdr1), ddim1, ddim1 + gdim,\n+\t\t\t       tdim1, tdim2 + ddim2);\n+  idr2 = map_dr_into_dep_poly (dim, PDR_ACCESSES (pdr2), ddim2, ddim2 + gdim,\n+\t\t\t       tdim1 + ddim1 + tdim2, sdim1);\n+\n+  /* Now add the subscript equalities.  */\n+  dreq = dr_equality_constraints (dim, tdim1 + ddim1 + tdim2 + ddim2, sdim1);\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&res, dim, 0);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, id1);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, id2);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, isc1);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, isc2);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, idr1);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, idr2);\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, dreq);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (id1);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (id2);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (sc1);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (sc2);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (isc1);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (isc2);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (idr1);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (idr2);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (dreq);\n+\n+  if (!ppl_Pointset_Powerset_C_Polyhedron_is_empty (res))\n+    build_lexicographically_gt_constraint (&res, dim, MIN (tdim1, tdim2),\n+\t\t\t\t\t   tdim1 + ddim1, direction);\n+  return res;\n+}\n+\n+/* Build the dependence polyhedron for data references PDR1 and PDR2.\n+   If possible use already cached information.  */\n+\n+static ppl_Pointset_Powerset_C_Polyhedron_t\n+dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n+\t\t       ppl_Pointset_Powerset_C_Polyhedron_t d1,\n+\t\t       ppl_Pointset_Powerset_C_Polyhedron_t d2,\n+\t\t       poly_dr_p pdr1, poly_dr_p pdr2,\n+\t               ppl_Polyhedron_t s1, ppl_Polyhedron_t s2,\n+\t\t       bool direction,\n+\t\t       bool original_scattering_p)\n+{\n+  poly_dr_pair tmp;\n+  PTR *x = NULL;\n+  ppl_Pointset_Powerset_C_Polyhedron_t res;\n+\n+  if (original_scattering_p)\n+    {\n+      tmp.source = pdr1;\n+      tmp.sink = pdr2;\n+      x = htab_find_slot (SCOP_ORIGINAL_PDR_PAIRS (PBB_SCOP (pbb1)),\n+                          &tmp, INSERT);\n+\n+      if (x && *x)\n+        {\n+          if (dump_file && (dump_flags & TDF_DETAILS))\n+            fprintf (dump_file, \"\\nddp cache: hit.\\n\");\n+          return ((poly_dr_pair *)*x)->ddp;\n+        }\n+      else if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"\\nddp cache: miss.\\n\");\n+    }\n+\n+  res = dependence_polyhedron_1 (pbb1, pbb2, d1, d2, pdr1, pdr2,\n+                                 s1, s2, direction, original_scattering_p);\n+\n+  if (original_scattering_p)\n+    {\n+      gcc_assert (x && *x == NULL);\n+      *x = new_poly_dr_pair (pdr1, pdr2, res);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"\\nddp cache: add element.\\n\");\n+    }\n+\n+  return res;\n+}\n+\n+/* Returns true when the PBB_TRANSFORMED_SCATTERING functions of PBB1\n+   and PBB2 respect the data dependences of PBB_ORIGINAL_SCATTERING\n+   functions.  */\n+\n+static bool\n+graphite_legal_transform_dr (poly_bb_p pbb1, poly_bb_p pbb2,\n+\t\t\t     poly_dr_p pdr1, poly_dr_p pdr2)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n+  ppl_Pointset_Powerset_C_Polyhedron_t d2 = PBB_DOMAIN (pbb2);\n+  ppl_Polyhedron_t so1 = PBB_ORIGINAL_SCATTERING (pbb1);\n+  ppl_Polyhedron_t so2 = PBB_ORIGINAL_SCATTERING (pbb2);\n+  ppl_Pointset_Powerset_C_Polyhedron_t po;\n+\n+  graphite_dim_t sdim1 = pdr_nb_subscripts (pdr1) + 1;\n+  graphite_dim_t sdim2 = pdr_nb_subscripts (pdr2) + 1;\n+\n+  if (sdim1 != sdim2)\n+    return true;\n+\n+  po = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, so1, so2,\n+\t\t\t      true, true);\n+\n+  if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (po))\n+    return true;\n+  else\n+    {\n+      ppl_Polyhedron_t st1 = PBB_TRANSFORMED_SCATTERING (pbb1);\n+      ppl_Polyhedron_t st2 = PBB_TRANSFORMED_SCATTERING (pbb2);\n+      ppl_Pointset_Powerset_C_Polyhedron_t pt;\n+      graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb1);\n+      graphite_dim_t otdim1 = pbb_nb_scattering_orig (pbb1);\n+      graphite_dim_t otdim2 = pbb_nb_scattering_orig (pbb2);\n+      graphite_dim_t ttdim1 = pbb_nb_scattering_transform (pbb1);\n+      graphite_dim_t ttdim2 = pbb_nb_scattering_transform (pbb2);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"\\nloop carries dependency.\\n\");\n+      pt = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, st1, st2,\n+\t\t\t\t  false, false);\n+\n+      /* Extend PO and PT to have the same dimensions.  */\n+      ppl_insert_dimensions_pointset (po, otdim1, ttdim1);\n+      ppl_insert_dimensions_pointset (po, otdim1 + ttdim1 + ddim1 + otdim2,\n+\t\t\t\t      ttdim2);\n+      ppl_insert_dimensions_pointset (pt, 0, otdim1);\n+      ppl_insert_dimensions_pointset (pt, otdim1 + ttdim1 + ddim1, otdim2);\n+\n+      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (po, pt);\n+      return ppl_Pointset_Powerset_C_Polyhedron_is_empty (po);\n+    }\n+}\n+\n+/* Iterates over the data references of PBB1 and PBB2 and detect\n+   whether the transformed schedule is correct.  */\n+\n+static bool\n+graphite_legal_transform_bb (poly_bb_p pbb1, poly_bb_p pbb2)\n+{\n+  int i, j;\n+  poly_dr_p pdr1, pdr2;\n+\n+  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr1); i++)\n+    for (j = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), j, pdr2); j++)\n+      if (!graphite_legal_transform_dr (pbb1, pbb2, pdr1, pdr2))\n+        return false;\n+  return true;\n+}\n+\n+/* Iterates over the SCOP and detect whether the transformed schedule\n+   is correct.  */\n+\n+bool\n+graphite_legal_transform (scop_p scop)\n+{\n+  int i, j;\n+  poly_bb_p pbb1, pbb2;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n+    for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n+      if (!graphite_legal_transform_bb (pbb1, pbb2))\n+\treturn false;\n+\n+  return true;\n+}\n+\n+/* Remove all the dimensions except alias information at dimension\n+   ALIAS_DIM.  */\n+\n+static void\n+build_alias_set_powerset (ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset,\n+\t\t\t  ppl_dimension_type alias_dim)\n+{\n+  ppl_dimension_type *ds;\n+  ppl_dimension_type access_dim;\n+  unsigned i, pos = 0;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (alias_powerset,\n+\t\t\t\t\t\t      &access_dim);\n+  ds = XNEWVEC (ppl_dimension_type, access_dim-1);\n+  for (i = 0; i < access_dim; i++)\n+    {\n+      if (i == alias_dim)\n+\tcontinue;\n+\n+      ds[pos] = i;\n+      pos++;\n+    }\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions (alias_powerset,\n+\t\t\t\t\t\t\t      ds,\n+\t\t\t\t\t\t\t      access_dim - 1);\n+  free (ds);\n+}\n+\n+/* Return true when PDR1 and PDR2 may alias.  */\n+\n+static bool\n+poly_drs_may_alias_p (poly_dr_p pdr1, poly_dr_p pdr2)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset1, alias_powerset2;\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses1 = PDR_ACCESSES (pdr1);\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses2 = PDR_ACCESSES (pdr2);\n+  ppl_dimension_type alias_dim1 = pdr_alias_set_dim (pdr1);\n+  ppl_dimension_type alias_dim2 = pdr_alias_set_dim (pdr2);\n+  int empty_p;\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&alias_powerset1, accesses1);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+    (&alias_powerset2, accesses2);\n+\n+  build_alias_set_powerset (alias_powerset1, alias_dim1);\n+  build_alias_set_powerset (alias_powerset2, alias_dim2);\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign\n+    (alias_powerset1, alias_powerset2);\n+\n+  empty_p =  ppl_Pointset_Powerset_C_Polyhedron_is_empty (alias_powerset1);\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset1);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset2);\n+\n+  return !empty_p;\n+}\n+\n+/* Returns TRUE when the dependence polyhedron between PDR1 and\n+   PDR2 represents a loop carried dependence at level LEVEL. Otherwise\n+   return FALSE.  */\n+\n+static bool\n+graphite_carried_dependence_level_k (poly_dr_p pdr1, poly_dr_p pdr2,\n+\t\t\t\t     int level)\n+{\n+  poly_bb_p pbb1 = PDR_PBB (pdr1);\n+  poly_bb_p pbb2 = PDR_PBB (pdr2);\n+  ppl_Pointset_Powerset_C_Polyhedron_t d1 = PBB_DOMAIN (pbb1);\n+  ppl_Pointset_Powerset_C_Polyhedron_t d2 = PBB_DOMAIN (pbb2);\n+  ppl_Polyhedron_t so1 = PBB_TRANSFORMED_SCATTERING (pbb1);\n+  ppl_Polyhedron_t so2 = PBB_TRANSFORMED_SCATTERING (pbb2);\n+  ppl_Pointset_Powerset_C_Polyhedron_t po;\n+  ppl_Pointset_Powerset_C_Polyhedron_t eqpp;\n+  graphite_dim_t sdim1 = pdr_nb_subscripts (pdr1) + 1;\n+  graphite_dim_t sdim2 = pdr_nb_subscripts (pdr2) + 1;\n+  graphite_dim_t tdim1 = pbb_nb_scattering_transform (pbb1);\n+  graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb1);\n+  ppl_dimension_type dim;\n+  bool empty_p;\n+\n+  if ((PDR_TYPE (pdr1) == PDR_READ && PDR_TYPE (pdr2) == PDR_READ)\n+      || !poly_drs_may_alias_p (pdr1, pdr2))\n+    return false;\n+\n+  if (sdim1 != sdim2)\n+    return true;\n+\n+  po = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, so1, so2,\n+\t\t\t      true, false);\n+  if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (po))\n+    {\n+      ppl_delete_Pointset_Powerset_C_Polyhedron (po);\n+      return false;\n+    }\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (po, &dim);\n+  eqpp = build_pairwise_scheduling_inequality (dim, level, tdim1 + ddim1, 1);\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (eqpp, po);\n+  empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (eqpp);\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (po);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (eqpp);\n+  return !empty_p;\n+}\n+\n+/* Check data dependency between PBB1 and PBB2 at level LEVEL.  */\n+\n+bool\n+dependency_between_pbbs_p (poly_bb_p pbb1, poly_bb_p pbb2, int level)\n+{\n+  int i, j;\n+  poly_dr_p pdr1, pdr2;\n+\n+  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr1); i++)\n+    for (j = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), j, pdr2); j++)\n+      if (graphite_carried_dependence_level_k (pdr1, pdr2, level))\n+\treturn true;\n+\n+  return false;\n+}\n+\n+#endif"}, {"sha": "ccf0b971b2376133edfa0687be4b062a578d1c50", "filename": "gcc/graphite-dependences.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-dependences.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-dependences.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,50 @@\n+/* Graphite polyhedral representation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Konrad Trifunovic <konrad.trifunovic@gmail.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GRAPHITE_DEPENDENCES_H\n+#define GCC_GRAPHITE_DEPENDENCES_H\n+\n+extern bool graphite_legal_transform (scop_p);\n+extern bool dependency_between_pbbs_p (poly_bb_p, poly_bb_p, int);\n+\n+typedef struct poly_dr_pair *poly_dr_pair_p;\n+\n+typedef struct poly_dr_pair\n+{\n+  /* Source polyhedral data reference of the dependence.  */\n+  poly_dr_p source;\n+\n+  /* Sink data reference of the dependence.  */\n+  poly_dr_p sink;\n+\n+  /* Data dependence polyhedron descibing dependence\n+     between SOURCE and SINK data references.  */\n+  ppl_Pointset_Powerset_C_Polyhedron_t ddp;\n+}poly_dr_pair;\n+\n+\n+#define PDRP_SOURCE(PDRP) (PDR->source)\n+#define PDRP_SINK(PDRP) (PDR->sink)\n+#define PDRP_DDP(PDRP) (PDR->ddp)\n+\n+extern int eq_poly_dr_pair_p (const void *, const void *);\n+extern hashval_t hash_poly_dr_pair_p (const void *);\n+\n+#endif"}, {"sha": "4639afe68d38ba74768bf8f245e610c76858d6bd", "filename": "gcc/graphite-interchange.c", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,398 @@\n+/* Interchange heuristics and transform for loop interchange on\n+   polyhedral representation.\n+\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Harsha Jagasia <harsha.jagasia@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"params.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"sese.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+\n+/* Returns the subscript dimension defined by CSTR in PDR.  */\n+\n+static ppl_dimension_type\n+compute_subscript (poly_dr_p pdr, ppl_const_Constraint_t cstr)\n+{\n+  graphite_dim_t i;\n+  ppl_Linear_Expression_t expr;\n+  ppl_Coefficient_t coef;\n+  Value val;\n+\n+  value_init (val);\n+  ppl_new_Coefficient (&coef);\n+\n+  for (i = 0; i < pdr_nb_subscripts (pdr); i++)\n+    {\n+      ppl_dimension_type sub_dim = pdr_subscript_dim (pdr, i);\n+\n+      ppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n+      ppl_Linear_Expression_coefficient (expr, sub_dim, coef);\n+      ppl_delete_Linear_Expression (expr);\n+      ppl_Coefficient_to_mpz_t (coef, val);\n+\n+      if (value_notzero_p (val))\n+\t{\n+\t  gcc_assert (value_one_p (val)\n+\t\t      || value_mone_p (val));\n+\n+\t  value_clear (val);\n+\t  ppl_delete_Coefficient (coef);\n+\t  return sub_dim;\n+\t}\n+    }\n+\n+  gcc_unreachable ();\n+  return 0;\n+}\n+\n+static void\n+compute_array_size_cstr (ppl_dimension_type sub_dim, Value res,\n+\t\t\t ppl_const_Constraint_t cstr)\n+{\n+  ppl_Linear_Expression_t expr;\n+  ppl_Coefficient_t coef;\n+  Value val;\n+\n+  value_init (val);\n+  ppl_new_Coefficient (&coef);\n+  ppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n+  ppl_Linear_Expression_coefficient (expr, sub_dim, coef);\n+  ppl_Coefficient_to_mpz_t (coef, val);\n+\n+  value_set_si (res, 0);\n+\n+  if (value_notzero_p (val))\n+    {\n+      gcc_assert (value_one_p (val) || value_mone_p (val));\n+      ppl_Linear_Expression_inhomogeneous_term (expr, coef);\n+      ppl_Coefficient_to_mpz_t (coef, res);\n+      value_absolute (res, res);\n+    }\n+\n+  value_clear (val);\n+  ppl_delete_Coefficient (coef);\n+  ppl_delete_Linear_Expression (expr);\n+}\n+\n+/* Returns in ARRAY_SIZE the size in bytes of the array PDR for the\n+   subscript at dimension SUB_DIM.  */\n+\n+static void\n+compute_array_size_poly (poly_dr_p pdr, ppl_dimension_type sub_dim, Value array_size,\n+\t\t\t ppl_const_Polyhedron_t ph)\n+{\n+  ppl_const_Constraint_System_t pcs;\n+  ppl_Constraint_System_const_iterator_t cit, cend;\n+  ppl_const_Constraint_t cstr;\n+  Value val;\n+  Value res;\n+\n+  if (sub_dim >= pdr_subscript_dim (pdr, pdr_nb_subscripts (pdr)))\n+    {\n+      value_set_si (array_size, 1);\n+      return;\n+    }\n+\n+  value_init (val);\n+  value_init (res);\n+\n+  value_set_si (res, 0);\n+\n+  ppl_Polyhedron_get_constraints (ph, &pcs);\n+  ppl_new_Constraint_System_const_iterator (&cit);\n+  ppl_new_Constraint_System_const_iterator (&cend);\n+      \n+  for (ppl_Constraint_System_begin (pcs, cit),\n+\t ppl_Constraint_System_end (pcs, cend);\n+       !ppl_Constraint_System_const_iterator_equal_test (cit, cend);\n+       ppl_Constraint_System_const_iterator_increment (cit))\n+    {\n+      ppl_Constraint_System_const_iterator_dereference (cit, &cstr);\n+\n+      if (ppl_Constraint_type (cstr) == PPL_CONSTRAINT_TYPE_EQUAL)\n+\tcontinue;\n+\n+      compute_array_size_cstr (sub_dim, val, cstr);\n+      value_max (res, res, val);\n+    }\n+\n+  compute_array_size_poly (pdr, sub_dim + 1, val, ph);\n+  value_multiply (array_size, res, val);\n+\n+  value_clear (res);\n+  value_clear (val);\n+}\n+\n+/* Initializes ARRAY_SIZE, the size in bytes of the array for the\n+   subscript at dimension SUB_DIM in PDR.  */\n+\n+static void\n+compute_array_size (poly_dr_p pdr, ppl_dimension_type sub_dim, Value array_size)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_t data_container = PDR_DATA_CONTAINER (pdr);\n+  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n+  Value val;\n+\n+  value_set_si (array_size, 1);\n+  if (sub_dim >= pdr_subscript_dim (pdr, pdr_nb_subscripts (pdr)))\n+    return;\n+\n+  value_init (val);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n+\n+  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (data_container, it),\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (data_container, end);\n+       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n+    {\n+      ppl_const_Polyhedron_t ph;\n+\n+      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n+      compute_array_size_poly (pdr, sub_dim, val, ph);\n+      value_max (array_size, array_size, val);\n+    }\n+\n+  value_clear (val);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n+}\n+\n+/* Computes ACCESS_STRIDES, the sum of all the strides of PDR at\n+   LOOP_DEPTH.  */\n+\n+static void\n+gather_access_strides_poly (poly_dr_p pdr, ppl_const_Polyhedron_t ph,\n+\t\t\t    ppl_dimension_type loop_dim, Value res)\n+{\n+  ppl_const_Constraint_System_t pcs;\n+  ppl_Constraint_System_const_iterator_t cit, cend;\n+  ppl_const_Constraint_t cstr;\n+  ppl_Linear_Expression_t expr;\n+  ppl_Coefficient_t coef;\n+  Value stride;\n+  Value array_size;\n+\n+  value_init (array_size);\n+  value_init (stride);\n+  ppl_new_Coefficient (&coef);\n+  value_set_si (res, 0);\n+\n+  ppl_Polyhedron_get_constraints (ph, &pcs);\n+  ppl_new_Constraint_System_const_iterator (&cit);\n+  ppl_new_Constraint_System_const_iterator (&cend);\n+\n+  for (ppl_Constraint_System_begin (pcs, cit),\n+\t ppl_Constraint_System_end (pcs, cend);\n+       !ppl_Constraint_System_const_iterator_equal_test (cit, cend);\n+       ppl_Constraint_System_const_iterator_increment (cit))\n+    {\n+      ppl_Constraint_System_const_iterator_dereference (cit, &cstr);\n+      ppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n+      ppl_Linear_Expression_coefficient (expr, loop_dim, coef);\n+      ppl_delete_Linear_Expression (expr);\n+      ppl_Coefficient_to_mpz_t (coef, stride);\n+\n+      if (value_zero_p (stride))\n+\tcontinue;\n+\n+      value_absolute (stride, stride);\n+      compute_array_size (pdr, compute_subscript (pdr, cstr), array_size);\n+      value_multiply (stride, stride, array_size);\n+      value_addto (res, res, stride);\n+    }\n+\n+  value_clear (array_size);\n+  value_clear (stride);\n+  ppl_delete_Coefficient (coef);\n+  ppl_delete_Constraint_System_const_iterator (cit);\n+  ppl_delete_Constraint_System_const_iterator (cend);\n+}\n+\n+/* Computes ACCESS_STRIDES, the sum of all the strides of PDR at\n+   LOOP_DEPTH.  */\n+\n+static void\n+gather_access_strides (poly_dr_p pdr, graphite_dim_t loop_depth,\n+\t\t       Value access_strides)\n+{\n+  ppl_dimension_type loop_dim = pdr_iterator_dim (pdr, loop_depth);\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses = PDR_ACCESSES (pdr);\n+  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n+  Value res;\n+\n+  value_init (res);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n+\n+  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (accesses, it),\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (accesses, end);\n+       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n+    {\n+      ppl_const_Polyhedron_t ph;\n+\n+      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n+      gather_access_strides_poly (pdr, ph, loop_dim, res);\n+      value_addto (access_strides, access_strides, res);\n+    }\n+\n+  value_clear (res);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n+}\n+\n+/* Returns true when it is profitable to interchange loop at depth1\n+   and loop at depth2 with depth1 < depth2 for the polyhedral black\n+   box PBB.  */\n+\n+static bool\n+pbb_interchange_profitable_p (graphite_dim_t depth1, graphite_dim_t depth2, poly_bb_p pbb)\n+{\n+  int i;\n+  poly_dr_p pdr;\n+  Value access_strides1, access_strides2;\n+  bool res;\n+\n+  gcc_assert (depth1 < depth2);\n+\n+  value_init (access_strides1);\n+  value_init (access_strides2);\n+\n+  value_set_si (access_strides1, 0);\n+  value_set_si (access_strides2, 0);\n+\n+  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+    {\n+      gather_access_strides (pdr, depth1, access_strides1);\n+      gather_access_strides (pdr, depth2, access_strides2);\n+    }\n+\n+  res = value_lt (access_strides1, access_strides2);\n+\n+  value_clear (access_strides1);\n+  value_clear (access_strides2);\n+\n+  return res;\n+}\n+\n+/* Interchanges the loops at DEPTH1 and DEPTH2 of the original\n+   scattering and assigns the resulting polyhedron to the transformed\n+   scattering.  */\n+\n+static void\n+pbb_interchange_loop_depths (graphite_dim_t depth1, graphite_dim_t depth2, poly_bb_p pbb)\n+{\n+  ppl_dimension_type i, dim;\n+  ppl_dimension_type *map;\n+  ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n+  ppl_dimension_type dim1 = psct_iterator_dim (pbb, depth1);\n+  ppl_dimension_type dim2 = psct_iterator_dim (pbb, depth2);\n+\n+  ppl_Polyhedron_space_dimension (poly, &dim);\n+  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);\n+\n+  for (i = 0; i < dim; i++)\n+    map[i] = i;\n+\n+  map[dim1] = dim2;\n+  map[dim2] = dim1;\n+\n+  ppl_Polyhedron_map_space_dimensions (poly, map, dim);\n+  free (map);\n+}\n+\n+/* Interchanges all the loop depths that are considered profitable for PBB.  */\n+\n+static bool\n+pbb_do_interchange (poly_bb_p pbb, scop_p scop)\n+{\n+  graphite_dim_t i, j;\n+  bool transform_done = false;\n+\n+  for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n+    for (j = i + 1; j < pbb_dim_iter_domain (pbb); j++)\n+      if (pbb_interchange_profitable_p (i, j, pbb))\n+\t{\n+\t  pbb_interchange_loop_depths (i, j, pbb);\n+\n+\t  if (graphite_legal_transform (scop))\n+\t    {\n+\t      transform_done = true;\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"PBB %d: loops at depths %d and %d will be interchanged.\\n\",\n+\t\t\t GBB_BB (PBB_BLACK_BOX (pbb))->index, (int) i, (int) j);\n+\t    }\n+\t  else\n+\t    /* Undo the transform.  */\n+\t    pbb_interchange_loop_depths (j, i, pbb);\n+\t}\n+\n+  return transform_done;\n+}\n+\n+/* Interchanges all the loop depths that are considered profitable for SCOP.  */\n+\n+bool\n+scop_do_interchange (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  bool transform_done = false;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    transform_done |= pbb_do_interchange (pbb, scop);\n+\n+  return transform_done;\n+}\n+\n+#endif\n+"}, {"sha": "da2beb3c4d79e4997402aed4070a5f5234ca750c", "filename": "gcc/graphite-poly.c", "status": "added", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,752 @@\n+/* Graphite polyhedral representation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Tobias Grosser <grosser@fim.uni-passau.de>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"params.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"sese.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+#include \"graphite-dependences.h\"\n+\n+/* Return the maximal loop depth in SCOP.  */\n+\n+int\n+scop_max_loop_depth (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  int max_nb_loops = 0;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    {\n+      int nb_loops = pbb_dim_iter_domain (pbb);\n+      if (max_nb_loops < nb_loops)\n+        max_nb_loops = nb_loops;\n+    }\n+\n+  return max_nb_loops;\n+}\n+\n+/* Extend the scattering matrix of PBB to MAX_SCATTERING scattering\n+   dimensions.  */\n+\n+static void\n+extend_scattering (poly_bb_p pbb, int max_scattering)\n+{\n+  ppl_dimension_type nb_old_dims, nb_new_dims;\n+  int nb_added_dims, i;\n+  ppl_Coefficient_t coef;\n+  Value one;\n+\n+  nb_added_dims = max_scattering - pbb_nb_scattering_transform (pbb);\n+  value_init (one);\n+  value_set_si (one, 1);\n+  ppl_new_Coefficient (&coef);\n+  ppl_assign_Coefficient_from_mpz_t (coef, one);\n+\n+  gcc_assert (nb_added_dims >= 0);\n+\n+  nb_old_dims = pbb_nb_scattering_transform (pbb) + pbb_dim_iter_domain (pbb)\n+    + scop_nb_params (PBB_SCOP (pbb));\n+  nb_new_dims = nb_old_dims + nb_added_dims;\n+\n+  ppl_insert_dimensions (PBB_TRANSFORMED_SCATTERING (pbb),\n+\t\t\t pbb_nb_scattering_transform (pbb), nb_added_dims);\n+  PBB_NB_SCATTERING_TRANSFORM (pbb) += nb_added_dims;\n+\n+  /* Add identity matrix for the added dimensions.  */\n+  for (i = max_scattering - nb_added_dims; i < max_scattering; i++)\n+    {\n+      ppl_Constraint_t cstr;\n+      ppl_Linear_Expression_t expr;\n+\n+      ppl_new_Linear_Expression_with_dimension (&expr, nb_new_dims);\n+      ppl_Linear_Expression_add_to_coefficient (expr, i, coef);\n+      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n+      ppl_Polyhedron_add_constraint (PBB_TRANSFORMED_SCATTERING (pbb), cstr);\n+      ppl_delete_Constraint (cstr);\n+      ppl_delete_Linear_Expression (expr);\n+    }\n+\n+  ppl_delete_Coefficient (coef);\n+  value_clear (one);\n+}\n+\n+/* All scattering matrices in SCOP will have the same number of scattering\n+   dimensions.  */\n+\n+int\n+unify_scattering_dimensions (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  graphite_dim_t max_scattering = 0;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    max_scattering = MAX (pbb_nb_scattering_transform (pbb), max_scattering);\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    extend_scattering (pbb, max_scattering);\n+\n+  return max_scattering;\n+}\n+\n+/* Prints to FILE the scattering function of PBB.  */\n+\n+void\n+print_scattering_function (FILE *file, poly_bb_p pbb)\n+{\n+  graphite_dim_t i;\n+\n+  if (!PBB_TRANSFORMED_SCATTERING (pbb))\n+    return;\n+\n+  fprintf (file, \"scattering bb_%d (\\n\", GBB_BB (PBB_BLACK_BOX (pbb))->index);\n+  fprintf (file, \"#  eq\");\n+\n+  for (i = 0; i < pbb_nb_scattering_transform (pbb); i++)\n+    fprintf (file, \"     s%d\", (int) i);\n+\n+  for (i = 0; i < pbb_nb_local_vars (pbb); i++)\n+    fprintf (file, \"    lv%d\", (int) i);\n+\n+  for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n+    fprintf (file, \"     i%d\", (int) i);\n+\n+  for (i = 0; i < pbb_nb_params (pbb); i++)\n+    fprintf (file, \"     p%d\", (int) i);\n+\n+  fprintf (file, \"    cst\\n\");\n+\n+  ppl_print_polyhedron_matrix (file, PBB_TRANSFORMED_SCATTERING (pbb));\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Prints to FILE the iteration domain of PBB.  */\n+\n+void\n+print_iteration_domain (FILE *file, poly_bb_p pbb)\n+{\n+  print_pbb_domain (file, pbb);\n+}\n+\n+/* Prints to FILE the scattering functions of every PBB of SCOP.  */\n+\n+void\n+print_scattering_functions (FILE *file, scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    print_scattering_function (file, pbb);\n+}\n+\n+/* Prints to FILE the iteration domains of every PBB of SCOP.  */\n+\n+void\n+print_iteration_domains (FILE *file, scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    print_iteration_domain (file, pbb);\n+}\n+\n+/* Prints to STDERR the scattering function of PBB.  */\n+\n+void\n+debug_scattering_function (poly_bb_p pbb)\n+{\n+  print_scattering_function (stderr, pbb);\n+}\n+\n+/* Prints to STDERR the iteration domain of PBB.  */\n+\n+void\n+debug_iteration_domain (poly_bb_p pbb)\n+{\n+  print_iteration_domain (stderr, pbb);\n+}\n+\n+/* Prints to STDERR the scattering functions of every PBB of SCOP.  */\n+\n+void\n+debug_scattering_functions (scop_p scop)\n+{\n+  print_scattering_functions (stderr, scop);\n+}\n+\n+/* Prints to STDERR the iteration domains of every PBB of SCOP.  */\n+\n+void\n+debug_iteration_domains (scop_p scop)\n+{\n+  print_iteration_domains (stderr, scop);\n+}\n+\n+/* Apply graphite transformations to all the basic blocks of SCOP.  */\n+\n+bool\n+apply_poly_transforms (scop_p scop)\n+{\n+  bool transform_done = false;\n+\n+  gcc_assert (graphite_legal_transform (scop));\n+\n+  /* Generate code even if we did not apply any real transformation.\n+     This also allows to check the performance for the identity\n+     transformation: GIMPLE -> GRAPHITE -> GIMPLE\n+     Keep in mind that CLooG optimizes in control, so the loop structure\n+     may change, even if we only use -fgraphite-identity.  */\n+  if (flag_graphite_identity)\n+    transform_done = true;\n+\n+  if (flag_graphite_force_parallel)\n+    transform_done = true;\n+\n+  if (flag_loop_block)\n+    gcc_unreachable (); /* Not yet supported.  */\n+\n+  if (flag_loop_strip_mine)\n+    {\n+      transform_done |= scop_do_strip_mine (scop);\n+      gcc_assert (graphite_legal_transform (scop));\n+    }\n+\n+  if (flag_loop_interchange)\n+    {\n+      transform_done |= scop_do_interchange (scop);\n+      gcc_assert (graphite_legal_transform (scop));\n+    }\n+\n+  return transform_done;\n+}\n+\n+/* Create a new polyhedral data reference and add it to PBB. It is defined by\n+   its ACCESSES, its TYPE*/\n+\n+void\n+new_poly_dr (poly_bb_p pbb,\n+\t     ppl_Pointset_Powerset_C_Polyhedron_t accesses,\n+\t     ppl_Pointset_Powerset_C_Polyhedron_t data_container,\n+\t     enum POLY_DR_TYPE type, void *cdr)\n+{\n+  poly_dr_p pdr = XNEW (struct poly_dr);\n+\n+  PDR_PBB (pdr) = pbb;\n+  PDR_ACCESSES (pdr) = accesses;\n+  PDR_DATA_CONTAINER (pdr) = data_container;\n+  PDR_TYPE (pdr) = type;\n+  PDR_CDR (pdr) = cdr;\n+  VEC_safe_push (poly_dr_p, heap, PBB_DRS (pbb), pdr);\n+}\n+\n+/* Free polyhedral data reference PDR.  */\n+\n+void\n+free_poly_dr (poly_dr_p pdr)\n+{\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (PDR_ACCESSES (pdr));\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (PDR_DATA_CONTAINER (pdr));\n+\n+  XDELETE (pdr);\n+}\n+\n+/* Create a new polyhedral black box.  */\n+\n+void\n+new_poly_bb (scop_p scop, void *black_box)\n+{\n+  poly_bb_p pbb = XNEW (struct poly_bb);\n+\n+  PBB_DOMAIN (pbb) = NULL;\n+  PBB_SCOP (pbb) = scop;\n+  pbb_set_black_box (pbb, black_box);\n+  PBB_TRANSFORMED_SCATTERING (pbb) = NULL;\n+  PBB_ORIGINAL_SCATTERING (pbb) = NULL;\n+  PBB_DRS (pbb) = VEC_alloc (poly_dr_p, heap, 3);\n+  PBB_NB_SCATTERING_TRANSFORM (pbb) = 0;\n+  PBB_NB_LOCAL_VARIABLES (pbb) = 0;\n+  VEC_safe_push (poly_bb_p, heap, SCOP_BBS (scop), pbb);\n+}\n+\n+/* Free polyhedral black box.  */\n+\n+void\n+free_poly_bb (poly_bb_p pbb)\n+{\n+  int i;\n+  poly_dr_p pdr;\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (PBB_DOMAIN (pbb));\n+\n+  if (PBB_TRANSFORMED_SCATTERING (pbb))\n+    ppl_delete_Polyhedron (PBB_TRANSFORMED_SCATTERING (pbb));\n+\n+  if (PBB_ORIGINAL_SCATTERING (pbb))\n+    ppl_delete_Polyhedron (PBB_ORIGINAL_SCATTERING (pbb));\n+\n+  if (PBB_DRS (pbb))\n+    for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+      free_poly_dr (pdr);\n+\n+  VEC_free (poly_dr_p, heap, PBB_DRS (pbb));\n+  XDELETE (pbb);\n+}\n+\n+static void\n+print_pdr_access_layout (FILE *file, poly_dr_p pdr)\n+{\n+  graphite_dim_t i;\n+\n+  fprintf (file, \"#  eq\");\n+\n+  for (i = 0; i < pdr_dim_iter_domain (pdr); i++)\n+    fprintf (file, \"     i%d\", (int) i);\n+\n+  for (i = 0; i < pdr_nb_params (pdr); i++)\n+    fprintf (file, \"     p%d\", (int) i);\n+\n+  fprintf (file, \"  alias\");\n+\n+  for (i = 0; i < pdr_nb_subscripts (pdr); i++)\n+    fprintf (file, \"   sub%d\", (int) i);\n+\n+  fprintf (file, \"    cst\\n\");\n+}\n+\n+/* Prints to FILE the polyhedral data reference PDR.  */\n+\n+void\n+print_pdr (FILE *file, poly_dr_p pdr)\n+{\n+  fprintf (file, \"pdr (\");\n+\n+  switch (PDR_TYPE (pdr))\n+    {\n+    case PDR_READ:\n+      fprintf (file, \"read \\n\");\n+      break;\n+\n+    case PDR_WRITE:\n+      fprintf (file, \"write \\n\");\n+      break;\n+\n+    case PDR_MAY_WRITE:\n+      fprintf (file, \"may_write \\n\");\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  dump_data_reference (file, (data_reference_p) PDR_CDR (pdr));\n+\n+  fprintf (file, \"data accesses (\\n\");\n+  print_pdr_access_layout (file, pdr);\n+  ppl_print_powerset_matrix (file, PDR_ACCESSES (pdr));\n+  fprintf (file, \")\\n\");\n+\n+  fprintf (file, \"data container (\\n\");\n+  print_pdr_access_layout (file, pdr);\n+  ppl_print_powerset_matrix (file, PDR_DATA_CONTAINER (pdr));\n+  fprintf (file, \")\\n\");\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Prints to STDERR the polyhedral data reference PDR.  */\n+\n+void\n+debug_pdr (poly_dr_p pdr)\n+{\n+  print_pdr (stderr, pdr);\n+}\n+\n+/* Creates a new SCOP containing REGION.  */\n+\n+scop_p\n+new_scop (void *region)\n+{\n+  scop_p scop = XNEW (struct scop);\n+\n+  SCOP_DEP_GRAPH (scop) = NULL;\n+  SCOP_CONTEXT (scop) = NULL;\n+  scop_set_region (scop, region);\n+  SCOP_BBS (scop) = VEC_alloc (poly_bb_p, heap, 3);\n+  SCOP_ORIGINAL_PDR_PAIRS (scop) = htab_create (10, hash_poly_dr_pair_p,\n+                                                eq_poly_dr_pair_p, free);\n+  return scop;\n+}\n+\n+/* Deletes SCOP.  */\n+\n+void\n+free_scop (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    free_poly_bb (pbb);\n+\n+  VEC_free (poly_bb_p, heap, SCOP_BBS (scop));\n+\n+  if (SCOP_CONTEXT (scop))\n+    ppl_delete_Pointset_Powerset_C_Polyhedron (SCOP_CONTEXT (scop));\n+\n+  htab_delete (SCOP_ORIGINAL_PDR_PAIRS (scop));\n+  XDELETE (scop);\n+}\n+\n+/* Print to FILE the domain of PBB.  */\n+\n+void\n+print_pbb_domain (FILE *file, poly_bb_p pbb)\n+{\n+  graphite_dim_t i;\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+\n+  if (!PBB_DOMAIN (pbb))\n+    return;\n+\n+  fprintf (file, \"domains bb_%d (\\n\", GBB_BB (gbb)->index);\n+  fprintf (file, \"#  eq\");\n+\n+  for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n+    fprintf (file, \"     i%d\", (int) i);\n+\n+  for (i = 0; i < pbb_nb_params (pbb); i++)\n+    fprintf (file, \"     p%d\", (int) i);\n+\n+  fprintf (file, \"    cst\\n\");\n+\n+  if (PBB_DOMAIN (pbb))\n+    ppl_print_powerset_matrix (file, PBB_DOMAIN (pbb));\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Dump the cases of a graphite basic block GBB on FILE.  */\n+\n+static void\n+dump_gbb_cases (FILE *file, gimple_bb_p gbb)\n+{\n+  int i;\n+  gimple stmt;\n+  VEC (gimple, heap) *cases;\n+\n+  if (!gbb)\n+    return;\n+\n+  cases = GBB_CONDITION_CASES (gbb);\n+  if (VEC_empty (gimple, cases))\n+    return;\n+\n+  fprintf (file, \"cases bb_%d (\", GBB_BB (gbb)->index);\n+\n+  for (i = 0; VEC_iterate (gimple, cases, i, stmt); i++)\n+    print_gimple_stmt (file, stmt, 0, 0);\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Dump conditions of a graphite basic block GBB on FILE.  */\n+\n+static void\n+dump_gbb_conditions (FILE *file, gimple_bb_p gbb)\n+{\n+  int i;\n+  gimple stmt;\n+  VEC (gimple, heap) *conditions;\n+\n+  if (!gbb)\n+    return;\n+\n+  conditions = GBB_CONDITIONS (gbb);\n+  if (VEC_empty (gimple, conditions))\n+    return;\n+\n+  fprintf (file, \"conditions bb_%d (\", GBB_BB (gbb)->index);\n+\n+  for (i = 0; VEC_iterate (gimple, conditions, i, stmt); i++)\n+    print_gimple_stmt (file, stmt, 0, 0);\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Print to FILE all the data references of PBB.  */\n+\n+void\n+print_pdrs (FILE *file, poly_bb_p pbb)\n+{\n+  int i;\n+  poly_dr_p pdr;\n+\n+  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+    print_pdr (file, pdr);\n+}\n+\n+/* Print to STDERR all the data references of PBB.  */\n+\n+void\n+debug_pdrs (poly_bb_p pbb)\n+{\n+  print_pdrs (stderr, pbb);\n+}\n+\n+/* Print to FILE the domain and scattering function of PBB.  */\n+\n+void\n+print_pbb (FILE *file, poly_bb_p pbb)\n+{\n+  dump_gbb_conditions (file, PBB_BLACK_BOX (pbb));\n+  dump_gbb_cases (file, PBB_BLACK_BOX (pbb));\n+  print_pdrs (file, pbb);\n+  print_pbb_domain (file, pbb);\n+  print_scattering_function (file, pbb);\n+}\n+\n+/* Print to FILE the parameters of SCOP.  */\n+\n+void\n+print_scop_params (FILE *file, scop_p scop)\n+{\n+  int i;\n+  tree t;\n+\n+  fprintf (file, \"parameters (\\n\");\n+  for (i = 0; VEC_iterate (tree, SESE_PARAMS (SCOP_REGION (scop)), i, t); i++)\n+    {\n+      fprintf (file, \"p_%d -> \", i);\n+      print_generic_expr (file, t, 0);\n+      fprintf (file, \"\\n\");\n+    }\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Print to FILE the context of SCoP.  */\n+void\n+print_scop_context (FILE *file, scop_p scop)\n+{\n+  graphite_dim_t i;\n+\n+  fprintf (file, \"context (\\n\");\n+  fprintf (file, \"#  eq\");\n+\n+  for (i = 0; i < scop_nb_params (scop); i++)\n+    fprintf (file, \"     p%d\", (int) i);\n+\n+  fprintf (file, \"    cst\\n\");\n+\n+  if (SCOP_CONTEXT (scop))\n+    ppl_print_powerset_matrix (file, SCOP_CONTEXT (scop));\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Print to FILE the SCOP.  */\n+\n+void\n+print_scop (FILE *file, scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  print_scop_params (file, scop);\n+  print_scop_context (file, scop);\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    print_pbb (file, pbb);\n+}\n+\n+/* Print to STDERR the domain of PBB.  */\n+\n+void\n+debug_pbb_domain (poly_bb_p pbb)\n+{\n+  print_pbb_domain (stderr, pbb);\n+}\n+\n+/* Print to FILE the domain and scattering function of PBB.  */\n+\n+void\n+debug_pbb (poly_bb_p pbb)\n+{\n+  print_pbb (stderr, pbb);\n+}\n+\n+/* Print to STDERR the context of SCOP.  */\n+\n+void\n+debug_scop_context (scop_p scop)\n+{\n+  print_scop_context (stderr, scop);\n+}\n+\n+/* Print to STDERR the SCOP.  */\n+\n+void\n+debug_scop (scop_p scop)\n+{\n+  print_scop (stderr, scop);\n+}\n+\n+/* Print to STDERR the parameters of SCOP.  */\n+\n+void\n+debug_scop_params (scop_p scop)\n+{\n+  print_scop_params (stderr, scop);\n+}\n+\n+\n+/* The dimension in the transformed scattering polyhedron of PBB\n+   containing the scattering iterator for the loop at depth LOOP_DEPTH.  */\n+\n+ppl_dimension_type\n+psct_scattering_dim_for_loop_depth (poly_bb_p pbb, graphite_dim_t loop_depth)\n+{\n+  ppl_const_Constraint_System_t pcs;\n+  ppl_Constraint_System_const_iterator_t cit, cend;\n+  ppl_const_Constraint_t cstr;\n+  ppl_Polyhedron_t ph = PBB_TRANSFORMED_SCATTERING (pbb);\n+  ppl_dimension_type iter = psct_iterator_dim (pbb, loop_depth);\n+  ppl_Linear_Expression_t expr;\n+  ppl_Coefficient_t coef;\n+  Value val;\n+  graphite_dim_t i;\n+\n+  value_init (val);\n+  ppl_new_Coefficient (&coef);\n+  ppl_Polyhedron_get_constraints (ph, &pcs);\n+  ppl_new_Constraint_System_const_iterator (&cit);\n+  ppl_new_Constraint_System_const_iterator (&cend);\n+\n+  for (ppl_Constraint_System_begin (pcs, cit),\n+\t ppl_Constraint_System_end (pcs, cend);\n+       !ppl_Constraint_System_const_iterator_equal_test (cit, cend);\n+       ppl_Constraint_System_const_iterator_increment (cit))\n+    {\n+      ppl_Constraint_System_const_iterator_dereference (cit, &cstr);\n+      ppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n+      ppl_Linear_Expression_coefficient (expr, iter, coef);\n+      ppl_Coefficient_to_mpz_t (coef, val);\n+\n+      if (value_zero_p (val))\n+\t{\n+\t  ppl_delete_Linear_Expression (expr);\n+\t  continue;\n+\t}\n+\n+      for (i = 0; i < pbb_nb_scattering_transform (pbb); i++)\n+\t{\n+\t  ppl_dimension_type scatter = psct_scattering_dim (pbb, i);\n+\n+\t  ppl_Linear_Expression_coefficient (expr, scatter, coef);\n+\t  ppl_Coefficient_to_mpz_t (coef, val);\n+\n+\t  if (value_notzero_p (val))\n+\t    {\n+\t      value_clear (val);\n+\t      ppl_delete_Linear_Expression (expr);\n+\t      ppl_delete_Coefficient (coef);\n+\t      ppl_delete_Constraint_System_const_iterator (cit);\n+\t      ppl_delete_Constraint_System_const_iterator (cend);\n+\n+\t      return scatter;\n+\t    }\n+\t}\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Returns the number of iterations NITER of the loop around PBB at\n+   depth LOOP_DEPTH.  */\n+\n+void\n+pbb_number_of_iterations (poly_bb_p pbb,\n+\t\t\t  graphite_dim_t loop_depth,\n+\t\t\t  Value niter)\n+{\n+  ppl_dimension_type loop_iter = pbb_iterator_dim (pbb, loop_depth);\n+  ppl_Linear_Expression_t le;\n+  ppl_Coefficient_t num, denom;\n+  Value dv;\n+  int maximum;\n+  ppl_dimension_type dim;\n+\n+  value_init (dv);\n+  ppl_new_Coefficient (&num);\n+  ppl_new_Coefficient (&denom);\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PBB_DOMAIN (pbb), &dim);\n+  ppl_new_Linear_Expression_with_dimension (&le, dim);\n+  ppl_set_coef (le, loop_iter, 1);\n+  ppl_Pointset_Powerset_C_Polyhedron_maximize (PBB_DOMAIN (pbb), le,\n+\t\t\t\t\t       num, denom, &maximum);\n+\n+  if (maximum == 1)\n+    {\n+      ppl_Coefficient_to_mpz_t (num, niter);\n+      ppl_Coefficient_to_mpz_t (denom, dv);\n+      value_division (niter, niter, dv);\n+    }\n+  else\n+    value_set_si (niter, -1);\n+\n+  value_clear (dv);\n+  ppl_delete_Linear_Expression (le);\n+  ppl_delete_Coefficient (num);\n+  ppl_delete_Coefficient (denom);\n+}\n+\n+#endif\n+"}, {"sha": "83d5fca212b0a31bd7845f43db5cf50193185fc3", "filename": "gcc/graphite-poly.h", "status": "added", "additions": 581, "deletions": 0, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,581 @@\n+/* Graphite polyhedral representation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Tobias Grosser <grosser@fim.uni-passau.de>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GRAPHITE_POLY_H\n+#define GCC_GRAPHITE_POLY_H\n+\n+typedef struct poly_dr *poly_dr_p;\n+DEF_VEC_P(poly_dr_p);\n+DEF_VEC_ALLOC_P (poly_dr_p, heap);\n+\n+typedef struct poly_bb *poly_bb_p;\n+DEF_VEC_P(poly_bb_p);\n+DEF_VEC_ALLOC_P (poly_bb_p, heap);\n+\n+typedef struct scop *scop_p;\n+DEF_VEC_P(scop_p);\n+DEF_VEC_ALLOC_P (scop_p, heap);\n+\n+typedef ppl_dimension_type graphite_dim_t;\n+\n+static inline graphite_dim_t pbb_dim_iter_domain (const struct poly_bb *);\n+static inline graphite_dim_t pbb_nb_params (const struct poly_bb *);\n+static inline graphite_dim_t scop_nb_params (scop_p);\n+\n+/* A data reference can write or read some memory or we\n+   just know it may write some memory.  */\n+enum POLY_DR_TYPE\n+{\n+  PDR_READ,\n+  /* PDR_MAY_READs are represented using PDR_READS. This does not limit the\n+     expressiveness.  */\n+  PDR_WRITE,\n+  PDR_MAY_WRITE\n+};\n+\n+struct poly_dr\n+{\n+  /* A pointer to compiler's data reference description.  */\n+  void *compiler_dr;\n+\n+  /* A pointer to the PBB that contains this data reference.  */\n+  poly_bb_p pbb;\n+\n+  enum POLY_DR_TYPE type;\n+\n+  /* The access polyhedron contains the polyhedral space this data\n+     reference will access.\n+\n+     The polyhedron contains these dimensions:\n+\n+      - The alias set (a):\n+      Every memory access is classified in at least one alias set.\n+\n+      - The subscripts (s_0, ..., s_n):\n+      The memory is accessed using zero or more subscript dimensions.\n+\n+      - The iteration domain (variables and parameters)\n+\n+     Do not hardcode the dimensions.  Use the following accessor functions:\n+     - pdr_alias_set_dim\n+     - pdr_subscript_dim\n+     - pdr_iterator_dim\n+     - pdr_parameter_dim\n+\n+     Example:\n+\n+     | int A[1335][123];\n+     | int *p = malloc ();\n+     |\n+     | k = ...\n+     | for i\n+     |   {\n+     |     if (unknown_function ())\n+     |       p = A;\n+     |       ... = p[?][?];\n+     | \t   for j\n+     |       A[i][j+b] = m;\n+     |   }\n+\n+     The data access A[i][j+k] in alias set \"5\" is described like this:\n+\n+     | i   j   k   a   s0  s1  1\n+     | 0   0   0   1   0   0  -5     =  0\n+     |-1   0   0   0   1   0   0     =  0\n+     | 0  -1  -1   0   0   1   0     =  0\n+\n+     The constraints on the data container A[1335][123] are:\n+\n+     | i   j   k   a   s0  s1  1\n+     | 0   0   0   0   1   0   0     >= 0\n+     | 0   0   0   0   0   1   0     >= 0\n+     | 0   0   0   0  -1   0 1335    >= 0\n+     | 0   0   0   0   0  -1 123     >= 0\n+\n+     The pointer \"*p\" in alias set \"5\" and \"7\" is described as a union of\n+     polyhedron:\n+\n+\n+     | i   k   a   s0  1\n+     | 0   0   1   0  -5   =  0\n+     | 0   0   0   1   0   >= 0\n+\n+     \"or\"\n+\n+     | i   k   a   s0  1\n+     | 0   0   1   0  -7   =  0\n+     | 0   0   0   1   0   >= 0\n+\n+     \"*p\" accesses all of the object allocated with 'malloc'.\n+\n+     The scalar data access \"m\" is represented as an array with zero subscript\n+     dimensions.\n+\n+     | i   j   k   a   1\n+     | 0   0   0  -1   15  = 0 */\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses;\n+  ppl_Pointset_Powerset_C_Polyhedron_t data_container;\n+};\n+\n+#define PDR_CDR(PDR) (PDR->compiler_dr)\n+#define PDR_PBB(PDR) (PDR->pbb)\n+#define PDR_TYPE(PDR) (PDR->type)\n+#define PDR_ACCESSES(PDR) (PDR->accesses)\n+#define PDR_DATA_CONTAINER(PDR) (PDR->data_container)\n+\n+void new_poly_dr (poly_bb_p, ppl_Pointset_Powerset_C_Polyhedron_t,\n+\t\t  ppl_Pointset_Powerset_C_Polyhedron_t,\n+\t\t  enum POLY_DR_TYPE, void *);\n+void free_poly_dr (poly_dr_p);\n+void debug_pdr (poly_dr_p);\n+void print_pdr (FILE *, poly_dr_p);\n+static inline scop_p pdr_scop (poly_dr_p pdr);\n+\n+/* The number of subscripts of the PDR.  */\n+\n+static inline graphite_dim_t\n+pdr_nb_subscripts (poly_dr_p pdr)\n+{\n+  poly_bb_p pbb = PDR_PBB (pdr);\n+  ppl_dimension_type dim;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PDR_ACCESSES (pdr),\n+\t\t\t\t\t\t      &dim);\n+  return dim - pbb_dim_iter_domain (pbb) - pbb_nb_params (pbb) - 1;\n+}\n+\n+/* The dimension of the iteration domain of the scop of PDR.  */\n+\n+static inline ppl_dimension_type\n+pdr_dim_iter_domain (poly_dr_p pdr)\n+{\n+  return pbb_dim_iter_domain (PDR_PBB (pdr));\n+}\n+\n+/* The number of parameters of the scop of PDR.  */\n+\n+static inline ppl_dimension_type\n+pdr_nb_params (poly_dr_p pdr)\n+{\n+  return scop_nb_params (pdr_scop (pdr));\n+}\n+\n+/* The dimension of the accesses polyhedron of PDR.  */\n+\n+static inline graphite_dim_t\n+pdr_dim (poly_dr_p pdr)\n+{\n+  graphite_dim_t alias_nb_dimensions = 1;\n+\n+  return pbb_dim_iter_domain (PDR_PBB (pdr)) + alias_nb_dimensions\n+    + pdr_nb_subscripts (pdr) + scop_nb_params (pdr_scop (pdr));\n+}\n+\n+/* The dimension of the alias set in PDR.  */\n+\n+static inline ppl_dimension_type\n+pdr_alias_set_dim (poly_dr_p pdr)\n+{\n+  poly_bb_p pbb = PDR_PBB (pdr);\n+\n+  return pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);\n+}\n+\n+/* The dimension in PDR containing subscript S.  */\n+\n+static inline ppl_dimension_type\n+pdr_subscript_dim (poly_dr_p pdr, graphite_dim_t s)\n+{\n+  poly_bb_p pbb = PDR_PBB (pdr);\n+\n+  return pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb) + 1 + s;\n+}\n+\n+/* The dimension in PDR containing the loop iterator ITER.  */\n+\n+static inline ppl_dimension_type\n+pdr_iterator_dim (poly_dr_p pdr ATTRIBUTE_UNUSED, graphite_dim_t iter)\n+{\n+  return iter;\n+}\n+\n+/* The dimension in PDR containing parameter PARAM.  */\n+\n+static inline ppl_dimension_type\n+pdr_parameter_dim (poly_dr_p pdr, graphite_dim_t param)\n+{\n+  poly_bb_p pbb = PDR_PBB (pdr);\n+\n+  return pbb_dim_iter_domain (pbb) + param;\n+}\n+\n+/* POLY_BB represents a blackbox in the polyhedral model.  */\n+\n+struct poly_bb\n+{\n+  void *black_box;\n+\n+  scop_p scop;\n+\n+  /* The iteration domain of this bb.\n+     Example:\n+\n+     for (i = a - 7*b + 8; i <= 3*a + 13*b + 20; i++)\n+       for (j = 2; j <= 2*i + 5; j++)\n+         for (k = 0; k <= 5; k++)\n+           S (i,j,k)\n+\n+     Loop iterators: i, j, k\n+     Parameters: a, b\n+\n+     | i >=  a -  7b +  8\n+     | i <= 3a + 13b + 20\n+     | j >= 2\n+     | j <= 2i + 5\n+     | k >= 0\n+     | k <= 5\n+\n+     The number of variables in the DOMAIN may change and is not\n+     related to the number of loops in the original code.  */\n+  ppl_Pointset_Powerset_C_Polyhedron_t domain;\n+\n+  /* The data references we access.  */\n+  VEC (poly_dr_p, heap) *drs;\n+\n+  /* The scattering function containing the transformations.  */\n+  ppl_Polyhedron_t transformed_scattering;\n+\n+\n+  /* The original scattering function.  */\n+  ppl_Polyhedron_t original_scattering;\n+\n+  /* The number of local variables.  */\n+  int nb_local_variables;\n+\n+  /* The number of scattering dimensions in the TRANSFORMED scattering.  */\n+  int nb_scattering_transform;\n+};\n+\n+#define PBB_BLACK_BOX(PBB) ((gimple_bb_p) PBB->black_box)\n+#define PBB_SCOP(PBB) (PBB->scop)\n+#define PBB_DOMAIN(PBB) (PBB->domain)\n+#define PBB_DRS(PBB) (PBB->drs)\n+#define PBB_TRANSFORMED_SCATTERING(PBB) (PBB->transformed_scattering)\n+#define PBB_ORIGINAL_SCATTERING(PBB) (PBB->original_scattering)\n+#define PBB_NB_LOCAL_VARIABLES(PBB) (PBB->nb_local_variables)\n+#define PBB_NB_SCATTERING_TRANSFORM(PBB) (PBB->nb_scattering_transform)\n+\n+extern void new_poly_bb (scop_p, void *);\n+extern void free_poly_bb (poly_bb_p);\n+extern void debug_loop_vec (poly_bb_p);\n+extern void schedule_to_scattering (poly_bb_p, int);\n+extern void print_pbb_domain (FILE *, poly_bb_p);\n+extern void print_pbb (FILE *, poly_bb_p);\n+extern void print_scop_context (FILE *, scop_p);\n+extern void print_scop (FILE *, scop_p);\n+extern void debug_pbb_domain (poly_bb_p);\n+extern void debug_pbb (poly_bb_p);\n+extern void print_pdrs (FILE *, poly_bb_p);\n+extern void debug_pdrs (poly_bb_p);\n+extern void debug_scop_context (scop_p);\n+extern void debug_scop (scop_p);\n+extern void print_scop_params (FILE *, scop_p);\n+extern void debug_scop_params (scop_p);\n+extern void print_iteration_domain (FILE *, poly_bb_p);\n+extern void print_iteration_domains (FILE *, scop_p);\n+extern void debug_iteration_domain (poly_bb_p);\n+extern void debug_iteration_domains (scop_p);\n+extern bool scop_do_interchange (scop_p);\n+extern bool scop_do_strip_mine (scop_p);\n+extern void pbb_number_of_iterations (poly_bb_p, graphite_dim_t, Value);\n+\n+/* The scop that contains the PDR.  */\n+\n+static inline scop_p pdr_scop (poly_dr_p pdr)\n+{\n+  return PBB_SCOP (PDR_PBB (pdr));\n+}\n+\n+/* Set black box of PBB to BLACKBOX.  */\n+\n+static inline void\n+pbb_set_black_box (poly_bb_p pbb, void *black_box)\n+{\n+  pbb->black_box = black_box;\n+}\n+\n+/* The number of loops around PBB: the dimension of the iteration\n+   domain.  */\n+\n+static inline graphite_dim_t\n+pbb_dim_iter_domain (const struct poly_bb *pbb)\n+{\n+  scop_p scop = PBB_SCOP (pbb);\n+  ppl_dimension_type dim;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PBB_DOMAIN (pbb), &dim);\n+  return dim - scop_nb_params (scop);\n+}\n+\n+/* The number of params defined in PBB.  */\n+\n+static inline graphite_dim_t\n+pbb_nb_params (const struct poly_bb *pbb)\n+{\n+  scop_p scop = PBB_SCOP (pbb);\n+\n+  return scop_nb_params (scop);\n+}\n+\n+/* The number of scattering dimensions in the SCATTERING polyhedron\n+   of a PBB for a given SCOP.  */\n+\n+static inline graphite_dim_t\n+pbb_nb_scattering_orig (const struct poly_bb *pbb)\n+{\n+  return 2 * pbb_dim_iter_domain (pbb) + 1;\n+}\n+\n+/* The number of scattering dimensions in PBB.  */\n+\n+static inline graphite_dim_t\n+pbb_nb_scattering_transform (const struct poly_bb *pbb)\n+{\n+  return PBB_NB_SCATTERING_TRANSFORM (pbb);\n+}\n+\n+/* Returns the number of local variables used in the transformed\n+   scattering polyhedron of PBB.  */\n+\n+static inline graphite_dim_t\n+pbb_nb_local_vars (const struct poly_bb *pbb)\n+{\n+  /* For now we do not have any local variables, as we do not do strip\n+     mining for example.  */\n+  return PBB_NB_LOCAL_VARIABLES (pbb);\n+}\n+\n+/* The dimension in the domain of PBB containing the iterator ITER.  */\n+\n+static inline ppl_dimension_type\n+pbb_iterator_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t iter)\n+{\n+  return iter;\n+}\n+\n+/* The dimension in the domain of PBB containing the iterator ITER.  */\n+\n+static inline ppl_dimension_type\n+pbb_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n+{\n+  return param\n+    + pbb_dim_iter_domain (pbb);\n+}\n+\n+/* The dimension in the original scattering polyhedron of PBB\n+   containing the scattering iterator SCATTER.  */\n+\n+static inline ppl_dimension_type\n+psco_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n+{\n+  gcc_assert (scatter < pbb_nb_scattering_orig (pbb));\n+  return scatter;\n+}\n+\n+/* The dimension in the transformed scattering polyhedron of PBB\n+   containing the scattering iterator SCATTER.  */\n+\n+static inline ppl_dimension_type\n+psct_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n+{\n+  gcc_assert (scatter <= pbb_nb_scattering_transform (pbb));\n+  return scatter;\n+}\n+\n+ppl_dimension_type psct_scattering_dim_for_loop_depth (poly_bb_p,\n+\t\t\t\t\t\t       graphite_dim_t);\n+\n+/* The dimension in the transformed scattering polyhedron of PBB of\n+   the local variable LV.  */\n+\n+static inline ppl_dimension_type\n+psct_local_var_dim (poly_bb_p pbb, graphite_dim_t lv)\n+{\n+  gcc_assert (lv <= pbb_nb_local_vars (pbb));\n+  return lv + pbb_nb_scattering_transform (pbb);\n+}\n+\n+/* The dimension in the original scattering polyhedron of PBB\n+   containing the loop iterator ITER.  */\n+\n+static inline ppl_dimension_type\n+psco_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n+{\n+  gcc_assert (iter < pbb_dim_iter_domain (pbb));\n+  return iter + pbb_nb_scattering_orig (pbb);\n+}\n+\n+/* The dimension in the transformed scattering polyhedron of PBB\n+   containing the loop iterator ITER.  */\n+\n+static inline ppl_dimension_type\n+psct_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n+{\n+  gcc_assert (iter < pbb_dim_iter_domain (pbb));\n+  return iter\n+    + pbb_nb_scattering_transform (pbb)\n+    + pbb_nb_local_vars (pbb);\n+}\n+\n+/* The dimension in the original scattering polyhedron of PBB\n+   containing parameter PARAM.  */\n+\n+static inline ppl_dimension_type\n+psco_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n+{\n+  gcc_assert (param < pbb_nb_params (pbb));\n+  return param\n+    + pbb_nb_scattering_orig (pbb)\n+    + pbb_dim_iter_domain (pbb);\n+}\n+\n+/* The dimension in the transformed scattering polyhedron of PBB\n+   containing parameter PARAM.  */\n+\n+static inline ppl_dimension_type\n+psct_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n+{\n+  gcc_assert (param < pbb_nb_params (pbb));\n+  return param\n+    + pbb_nb_scattering_transform (pbb)\n+    + pbb_nb_local_vars (pbb)\n+    + pbb_dim_iter_domain (pbb);\n+}\n+\n+/* Adds to the transformed scattering polyhedron of PBB a new local\n+   variable and returns its index.  */\n+\n+static inline graphite_dim_t\n+psct_add_local_variable (poly_bb_p pbb)\n+{\n+  graphite_dim_t nlv = pbb_nb_local_vars (pbb);\n+  ppl_dimension_type lv_column = psct_local_var_dim (pbb, nlv);\n+  ppl_insert_dimensions (PBB_TRANSFORMED_SCATTERING (pbb), lv_column, 1);\n+  PBB_NB_LOCAL_VARIABLES (pbb) += 1;\n+  return nlv;\n+}\n+\n+/* Adds a dimension to the transformed scattering polyhedron of PBB at\n+   INDEX.  */\n+\n+static inline void\n+psct_add_scattering_dimension (poly_bb_p pbb, ppl_dimension_type index)\n+{\n+  gcc_assert (index < pbb_nb_scattering_transform (pbb));\n+\n+  ppl_insert_dimensions (PBB_TRANSFORMED_SCATTERING (pbb), index, 1);\n+  PBB_NB_SCATTERING_TRANSFORM (pbb) += 1;\n+}\n+\n+/* A SCOP is a Static Control Part of the program, simple enough to be\n+   represented in polyhedral form.  */\n+struct scop\n+{\n+  /* A SCOP is defined as a SESE region.  */\n+  void *region;\n+\n+  /* Number of parameters in SCoP.  */\n+  graphite_dim_t nb_params;\n+\n+  /* All the basic blocks in this scop that contain memory references\n+     and that will be represented as statements in the polyhedral\n+     representation.  */\n+  VEC (poly_bb_p, heap) *bbs;\n+\n+  /* Data dependence graph for this SCoP.  */\n+  struct graph *dep_graph;\n+\n+  /* The context describes known restrictions concerning the parameters\n+     and relations in between the parameters.\n+\n+  void f (int8_t a, uint_16_t b) {\n+    c = 2 a + b;\n+    ...\n+  }\n+\n+  Here we can add these restrictions to the context:\n+\n+  -128 >= a >= 127\n+     0 >= b >= 65,535\n+     c = 2a + b  */\n+  ppl_Pointset_Powerset_C_Polyhedron_t context;\n+\n+  /* A hashtable of the original pairs of dependent data references.\n+     For each pair of dependent data references, the dependence\n+     polyhedron is stored also.  */\n+  htab_t original_pdr_pairs;\n+};\n+\n+#define SCOP_BBS(S) (S->bbs)\n+#define SCOP_REGION(S) ((sese) S->region)\n+#define SCOP_DEP_GRAPH(S) (S->dep_graph)\n+#define SCOP_CONTEXT(S) (S->context)\n+#define SCOP_ORIGINAL_PDR_PAIRS(S) (S->original_pdr_pairs)\n+\n+extern scop_p new_scop (void *);\n+extern void free_scop (scop_p);\n+extern void free_scops (VEC (scop_p, heap) *);\n+extern void print_generated_program (FILE *, scop_p);\n+extern void debug_generated_program (scop_p);\n+extern void print_scattering_function (FILE *, poly_bb_p);\n+extern void print_scattering_functions (FILE *, scop_p);\n+extern void debug_scattering_function (poly_bb_p);\n+extern void debug_scattering_functions (scop_p);\n+extern int scop_max_loop_depth (scop_p);\n+extern int unify_scattering_dimensions (scop_p);\n+extern bool apply_poly_transforms (scop_p);\n+extern bool graphite_legal_transform (scop_p);\n+\n+/* Set the region of SCOP to REGION.  */\n+\n+static inline void\n+scop_set_region (scop_p scop, void *region)\n+{\n+  scop->region = region;\n+}\n+\n+/* Returns the number of parameters for SCOP.  */\n+\n+static inline graphite_dim_t\n+scop_nb_params (scop_p scop)\n+{\n+  return scop->nb_params;\n+}\n+\n+/* Set the number of params of SCOP to NB_PARAMS.  */\n+\n+static inline void\n+scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n+{\n+  scop->nb_params = nb_params;\n+}\n+\n+#endif"}, {"sha": "967b6ea7958db2329cf543a813bc67e9e0fa7e71", "filename": "gcc/graphite-ppl.c", "status": "added", "additions": 616, "deletions": 0, "changes": 616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-ppl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-ppl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-ppl.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,616 @@\n+/* Gimple Represented as Polyhedra.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>\n+   and Tobias Grosser <grosser@fim.uni-passau.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"ppl_c.h\"\n+#include \"cloog/cloog.h\"\n+#include \"graphite-ppl.h\"\n+\n+/* Translates row ROW of the CloogMatrix MATRIX to a PPL Constraint.  */\n+\n+static ppl_Constraint_t\n+cloog_matrix_to_ppl_constraint (CloogMatrix *matrix, int row)\n+{\n+  int j;\n+  ppl_Constraint_t cstr;\n+  ppl_Coefficient_t coef;\n+  ppl_Linear_Expression_t expr;\n+  ppl_dimension_type dim = matrix->NbColumns - 2;\n+\n+  ppl_new_Coefficient (&coef);\n+  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+\n+  for (j = 1; j < matrix->NbColumns - 1; j++)\n+    {\n+      ppl_assign_Coefficient_from_mpz_t (coef, matrix->p[row][j]);\n+      ppl_Linear_Expression_add_to_coefficient (expr, j - 1, coef);\n+    }\n+\n+  ppl_assign_Coefficient_from_mpz_t (coef,\n+\t\t\t\t     matrix->p[row][matrix->NbColumns - 1]);\n+  ppl_Linear_Expression_add_to_inhomogeneous (expr, coef);\n+  ppl_delete_Coefficient (coef);\n+\n+  if (value_zero_p (matrix->p[row][0]))\n+    ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n+  else\n+    ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+\n+  ppl_delete_Linear_Expression (expr);\n+  return cstr;\n+}\n+\n+/* Creates a PPL constraint system from MATRIX.  */\n+\n+static void\n+new_Constraint_System_from_Cloog_Matrix (ppl_Constraint_System_t *pcs,\n+\t\t\t\t\t CloogMatrix *matrix)\n+{\n+  int i;\n+\n+  ppl_new_Constraint_System (pcs);\n+\n+  for (i = 0; i < matrix->NbRows; i++)\n+    {\n+      ppl_Constraint_t c = cloog_matrix_to_ppl_constraint (matrix, i);\n+      ppl_Constraint_System_insert_Constraint (*pcs, c);\n+      ppl_delete_Constraint (c);\n+    }\n+}\n+\n+/* Creates a PPL Polyhedron from MATRIX.  */\n+\n+void\n+new_C_Polyhedron_from_Cloog_Matrix (ppl_Polyhedron_t *ph,\n+\t\t\t\t      CloogMatrix *matrix)\n+{\n+  ppl_Constraint_System_t cs;\n+  new_Constraint_System_from_Cloog_Matrix (&cs, matrix);\n+  ppl_new_C_Polyhedron_recycle_Constraint_System (ph, cs);\n+}\n+\n+/* Counts the number of constraints in PCS.  */\n+\n+static int\n+ppl_Constrain_System_number_of_constraints (ppl_const_Constraint_System_t pcs)\n+{\n+  ppl_Constraint_System_const_iterator_t cit, end;\n+  int num = 0;\n+\n+  ppl_new_Constraint_System_const_iterator (&cit);\n+  ppl_new_Constraint_System_const_iterator (&end);\n+\n+  for (ppl_Constraint_System_begin (pcs, cit),\n+        ppl_Constraint_System_end (pcs, end);\n+       !ppl_Constraint_System_const_iterator_equal_test (cit, end);\n+       ppl_Constraint_System_const_iterator_increment (cit))\n+    num++;\n+\n+  ppl_delete_Constraint_System_const_iterator (cit);\n+  ppl_delete_Constraint_System_const_iterator (end);\n+  return num;\n+}\n+\n+static void\n+oppose_constraint (CloogMatrix *m, int row)\n+{\n+  int k;\n+\n+  /* Do not oppose the first column: it is the eq/ineq one.  */\n+  for (k = 1; k < m->NbColumns; k++)\n+    value_oppose (m->p[row][k], m->p[row][k]);\n+}\n+\n+/* Inserts constraint CSTR at row ROW of matrix M.  */\n+\n+void\n+insert_constraint_into_matrix (CloogMatrix *m, int row,\n+\t\t\t       ppl_const_Constraint_t cstr)\n+{\n+  ppl_Coefficient_t c;\n+  ppl_dimension_type i, dim, nb_cols = m->NbColumns;\n+\n+  ppl_Constraint_space_dimension (cstr, &dim);\n+  ppl_new_Coefficient (&c);\n+\n+  for (i = 0; i < dim; i++)\n+    {\n+      ppl_Constraint_coefficient (cstr, i, c);\n+      ppl_Coefficient_to_mpz_t (c, m->p[row][i + 1]);\n+    }\n+\n+  for (i = dim; i < nb_cols - 1; i++)\n+    value_set_si (m->p[row][i + 1], 0);\n+\n+  ppl_Constraint_inhomogeneous_term  (cstr, c);\n+  ppl_Coefficient_to_mpz_t (c, m->p[row][nb_cols - 1]);\n+  value_set_si (m->p[row][0], 1);\n+\n+  switch (ppl_Constraint_type (cstr))\n+    {\n+    case PPL_CONSTRAINT_TYPE_LESS_THAN:\n+      oppose_constraint (m, row);\n+    case PPL_CONSTRAINT_TYPE_GREATER_THAN:\n+      value_sub_int (m->p[row][nb_cols - 1],\n+\t\t     m->p[row][nb_cols - 1], 1);\n+      break;\n+\n+    case PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL:\n+      oppose_constraint (m, row);\n+    case PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL:\n+      break;\n+\n+    case PPL_CONSTRAINT_TYPE_EQUAL:\n+      value_set_si (m->p[row][0], 0);\n+      break;\n+\n+    default:\n+      /* Not yet implemented.  */\n+      gcc_unreachable();\n+    }\n+\n+  ppl_delete_Coefficient (c);\n+}\n+\n+/* Creates a CloogMatrix from constraint system PCS.  */\n+\n+static CloogMatrix *\n+new_Cloog_Matrix_from_ppl_Constraint_System (ppl_const_Constraint_System_t pcs)\n+{\n+  CloogMatrix *matrix;\n+  ppl_Constraint_System_const_iterator_t cit, end;\n+  ppl_dimension_type dim;\n+  int rows;\n+  int row = 0;\n+\n+  rows = ppl_Constrain_System_number_of_constraints (pcs);\n+  ppl_Constraint_System_space_dimension (pcs, &dim);\n+  matrix = cloog_matrix_alloc (rows, dim + 2);\n+  ppl_new_Constraint_System_const_iterator (&cit);\n+  ppl_new_Constraint_System_const_iterator (&end);\n+\n+  for (ppl_Constraint_System_begin (pcs, cit),\n+        ppl_Constraint_System_end (pcs, end);\n+       !ppl_Constraint_System_const_iterator_equal_test (cit, end);\n+       ppl_Constraint_System_const_iterator_increment (cit))\n+    {\n+      ppl_const_Constraint_t c;\n+      ppl_Constraint_System_const_iterator_dereference (cit, &c);\n+      insert_constraint_into_matrix (matrix, row, c);\n+      row++;\n+    }\n+\n+  ppl_delete_Constraint_System_const_iterator (cit);\n+  ppl_delete_Constraint_System_const_iterator (end);\n+\n+  return matrix;\n+}\n+\n+/* Creates a CloogMatrix from polyhedron PH.  */\n+\n+CloogMatrix *\n+new_Cloog_Matrix_from_ppl_Polyhedron (ppl_const_Polyhedron_t ph)\n+{\n+  ppl_const_Constraint_System_t pcs;\n+  CloogMatrix *res;\n+\n+  ppl_Polyhedron_get_constraints (ph, &pcs);\n+  res = new_Cloog_Matrix_from_ppl_Constraint_System (pcs);\n+\n+  return res;\n+}\n+\n+/* Creates a CloogDomain from polyhedron PH.  */\n+\n+CloogDomain *\n+new_Cloog_Domain_from_ppl_Polyhedron (ppl_const_Polyhedron_t ph)\n+{\n+  CloogMatrix *mat = new_Cloog_Matrix_from_ppl_Polyhedron (ph);\n+  CloogDomain *res = cloog_domain_matrix2domain (mat);\n+  cloog_matrix_free (mat);\n+  return res;\n+}\n+\n+/* Creates a CloogDomain from a pointset powerset PS.  */\n+\n+CloogDomain *\n+new_Cloog_Domain_from_ppl_Pointset_Powerset (\n+  ppl_Pointset_Powerset_C_Polyhedron_t ps)\n+{\n+  CloogDomain *res = NULL;\n+  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n+\n+  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n+       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n+    {\n+      ppl_const_Polyhedron_t ph;\n+      CloogDomain *tmp;\n+\n+      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n+      tmp = new_Cloog_Domain_from_ppl_Polyhedron (ph);\n+\n+      if (res == NULL)\n+\tres = tmp;\n+      else\n+\tres = cloog_domain_union (res, tmp);\n+    }\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n+\n+  gcc_assert (res != NULL);\n+\n+  return res;\n+}\n+\n+/* Set the inhomogeneous term of E to X.  */\n+\n+void\n+ppl_set_inhomogeneous_gmp (ppl_Linear_Expression_t e, Value x)\n+{\n+  Value v0, v1;\n+  ppl_Coefficient_t c;\n+\n+  value_init (v0);\n+  value_init (v1);\n+  ppl_new_Coefficient (&c);\n+\n+  ppl_Linear_Expression_inhomogeneous_term (e, c);\n+  ppl_Coefficient_to_mpz_t (c, v1);\n+  value_oppose (v1, v1);\n+  value_assign (v0, x);\n+  value_addto (v0, v0, v1);\n+  ppl_assign_Coefficient_from_mpz_t (c, v0);\n+  ppl_Linear_Expression_add_to_inhomogeneous (e, c);\n+\n+  value_clear (v0);\n+  value_clear (v1);\n+  ppl_delete_Coefficient (c);\n+}\n+\n+/* Set E[I] to X.  */\n+\n+void\n+ppl_set_coef_gmp (ppl_Linear_Expression_t e, ppl_dimension_type i, Value x)\n+{\n+  Value v0, v1;\n+  ppl_Coefficient_t c;\n+\n+  value_init (v0);\n+  value_init (v1);\n+  ppl_new_Coefficient (&c);\n+\n+  ppl_Linear_Expression_coefficient (e, i, c);\n+  ppl_Coefficient_to_mpz_t (c, v1);\n+  value_oppose (v1, v1);\n+  value_assign (v0, x);\n+  value_addto (v0, v0, v1);\n+  ppl_assign_Coefficient_from_mpz_t (c, v0);\n+  ppl_Linear_Expression_add_to_coefficient (e, i, c);\n+\n+  value_clear (v0);\n+  value_clear (v1);\n+  ppl_delete_Coefficient (c);\n+}\n+\n+/* Insert after X NB_NEW_DIMS empty dimensions into PH.\n+\n+   With x = 3 and nb_new_dims = 4\n+\n+   |  d0 d1 d2 d3 d4\n+\n+   is transformed to\n+\n+   |  d0 d1 d2 x0 x1 x2 x3 d3 d4\n+\n+   | map = {0, 1, 2, 7, 8, 3, 4, 5, 6}\n+*/\n+\n+void\n+ppl_insert_dimensions_pointset (ppl_Pointset_Powerset_C_Polyhedron_t ph, int x,\n+\t\t\t\tint nb_new_dims)\n+{\n+  ppl_dimension_type i, dim;\n+  ppl_dimension_type *map;\n+  ppl_dimension_type x_ppl, nb_new_dims_ppl;\n+\n+  x_ppl = (ppl_dimension_type) x;\n+  nb_new_dims_ppl = (ppl_dimension_type) nb_new_dims;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (ph, &dim);\n+  ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed (ph, nb_new_dims);\n+\n+  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim + nb_new_dims);\n+\n+  for (i = 0; i < x_ppl; i++)\n+    map[i] = i;\n+\n+  for (i = x_ppl; i < x_ppl + nb_new_dims_ppl; i++)\n+    map[dim + i - x_ppl] = i;\n+\n+  for (i = x_ppl + nb_new_dims_ppl; i < dim + nb_new_dims_ppl; i++)\n+    map[i - nb_new_dims_ppl] = i;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (ph, map, dim + nb_new_dims);\n+  free (map);\n+}\n+\n+/* Insert after X NB_NEW_DIMS empty dimensions into PH.\n+\n+   With x = 3 and nb_new_dims = 4\n+\n+   |  d0 d1 d2 d3 d4\n+\n+   is transformed to\n+\n+   |  d0 d1 d2 x0 x1 x2 x3 d3 d4\n+\n+   | map = {0, 1, 2, 7, 8, 3, 4, 5, 6}\n+*/\n+\n+void\n+ppl_insert_dimensions (ppl_Polyhedron_t ph, int x,\n+\t\t       int nb_new_dims)\n+{\n+  ppl_dimension_type i, dim;\n+  ppl_dimension_type *map;\n+  ppl_dimension_type x_ppl, nb_new_dims_ppl;\n+\n+  x_ppl = (ppl_dimension_type) x;\n+  nb_new_dims_ppl = (ppl_dimension_type) nb_new_dims;\n+\n+  ppl_Polyhedron_space_dimension (ph, &dim);\n+  ppl_Polyhedron_add_space_dimensions_and_embed (ph, nb_new_dims);\n+\n+  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim + nb_new_dims);\n+\n+  for (i = 0; i < x_ppl; i++)\n+    map[i] = i;\n+\n+  for (i = x_ppl; i < x_ppl + nb_new_dims_ppl; i++)\n+    map[dim + i - x_ppl] = i;\n+\n+  for (i = x_ppl + nb_new_dims_ppl; i < dim + nb_new_dims_ppl; i++)\n+    map[i - nb_new_dims_ppl] = i;\n+\n+  ppl_Polyhedron_map_space_dimensions (ph, map, dim + nb_new_dims);\n+  free (map);\n+}\n+\n+/* Based on the original polyhedron PH, returns a new polyhedron with\n+   an extra dimension placed at position LOOP + 1 that slices the\n+   dimension LOOP into strips of size STRIDE.  */\n+\n+ppl_Polyhedron_t\n+ppl_strip_loop (ppl_Polyhedron_t ph, ppl_dimension_type loop, int stride)\n+{\n+  ppl_const_Constraint_System_t pcs;\n+  ppl_Constraint_System_const_iterator_t cit, end;\n+  ppl_const_Constraint_t cstr;\n+  ppl_Linear_Expression_t expr;\n+  int v;\n+  ppl_dimension_type dim;\n+  ppl_Polyhedron_t res;\n+  ppl_Coefficient_t c;\n+  Value val;\n+\n+  value_init (val);\n+  ppl_new_Coefficient (&c);\n+\n+  ppl_Polyhedron_space_dimension (ph, &dim);\n+  ppl_Polyhedron_get_constraints (ph, &pcs);\n+\n+  /* Start from a copy of the constraints.  */\n+  ppl_new_C_Polyhedron_from_space_dimension (&res, dim + 1, 0);\n+  ppl_Polyhedron_add_constraints (res, pcs);\n+\n+  /* Add an empty dimension for the strip loop.  */\n+  ppl_insert_dimensions (res, loop, 1);\n+\n+  /* Identify the constraints that define the lower and upper bounds\n+     of the strip-mined loop, and add them to the strip loop.  */\n+  {\n+    ppl_Polyhedron_t tmp;\n+\n+    ppl_new_C_Polyhedron_from_space_dimension (&tmp, dim + 1, 0);\n+    ppl_new_Constraint_System_const_iterator (&cit);\n+    ppl_new_Constraint_System_const_iterator (&end);\n+\n+    for (ppl_Constraint_System_begin (pcs, cit),\n+\t   ppl_Constraint_System_end (pcs, end);\n+\t !ppl_Constraint_System_const_iterator_equal_test (cit, end);\n+\t ppl_Constraint_System_const_iterator_increment (cit))\n+      {\n+\tppl_Constraint_System_const_iterator_dereference (cit, &cstr);\n+\tppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n+\tppl_Linear_Expression_coefficient (expr, loop, c);\n+\tppl_delete_Linear_Expression (expr);\n+\tppl_Coefficient_to_mpz_t (c, val);\n+\tv = value_get_si (val);\n+\n+\tif (0 < v || v < 0)\n+\t  ppl_Polyhedron_add_constraint (tmp, cstr);\n+      }\n+    ppl_delete_Constraint_System_const_iterator (cit);\n+    ppl_delete_Constraint_System_const_iterator (end);\n+\n+    ppl_insert_dimensions (tmp, loop + 1, 1);\n+    ppl_Polyhedron_get_constraints (tmp, &pcs);\n+    ppl_Polyhedron_add_constraints (res, pcs);\n+    ppl_delete_Polyhedron (tmp);\n+  }\n+\n+  /* Lower bound of a tile starts at \"stride * outer_iv\".  */\n+  {\n+    ppl_Constraint_t new_cstr;\n+    ppl_new_Linear_Expression_with_dimension (&expr, dim + 1);\n+\n+    ppl_set_coef (expr, loop + 1, 1);\n+    ppl_set_coef (expr, loop, -1 * stride);\n+\n+    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+    ppl_delete_Linear_Expression (expr);\n+    ppl_Polyhedron_add_constraint (res, new_cstr);\n+    ppl_delete_Constraint (new_cstr);\n+  }\n+\n+  /* Upper bound of a tile stops at \"stride * outer_iv + stride - 1\",\n+     or at the old upper bound that is not modified.  */\n+  {\n+    ppl_Constraint_t new_cstr;\n+    ppl_new_Linear_Expression_with_dimension (&expr, dim + 1);\n+\n+    ppl_set_coef (expr, loop + 1, -1);\n+    ppl_set_coef (expr, loop, stride);\n+    ppl_set_inhomogeneous (expr, stride - 1);\n+\n+    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+    ppl_delete_Linear_Expression (expr);\n+    ppl_Polyhedron_add_constraint (res, new_cstr);\n+    ppl_delete_Constraint (new_cstr);\n+  }\n+\n+  value_clear (val);\n+  ppl_delete_Coefficient (c);\n+  return res;\n+}\n+\n+/* Lexicographically compares two linear expressions A and B and\n+   returns negative when A < B, 0 when A == B and positive when A > B.  */\n+\n+int\n+ppl_lexico_compare_linear_expressions (ppl_Linear_Expression_t a,\n+\t\t\t\t       ppl_Linear_Expression_t b)\n+{\n+  ppl_dimension_type min_length, length1, length2;\n+  ppl_dimension_type i;\n+  ppl_Coefficient_t c;\n+  int res;\n+  Value va, vb;\n+\n+  ppl_Linear_Expression_space_dimension (a, &length1);\n+  ppl_Linear_Expression_space_dimension (b, &length2);\n+  ppl_new_Coefficient (&c);\n+  value_init (va);\n+  value_init (vb);\n+\n+  if (length1 < length2)\n+    min_length = length1;\n+  else\n+    min_length = length2;\n+\n+  for (i = 0; i < min_length; i++)\n+    {\n+      ppl_Linear_Expression_coefficient (a, i, c);\n+      ppl_Coefficient_to_mpz_t (c, va);\n+      ppl_Linear_Expression_coefficient (b, i, c);\n+      ppl_Coefficient_to_mpz_t (c, vb);\n+      res = value_compare (va, vb);\n+\n+      if (res == 0)\n+\tcontinue;\n+\n+      value_clear (va);\n+      value_clear (vb);\n+      ppl_delete_Coefficient (c);\n+      return res;\n+    }\n+\n+  value_clear (va);\n+  value_clear (vb);\n+  ppl_delete_Coefficient (c);\n+  return length1 - length2;\n+}\n+\n+/* Print to FILE the polyhedron PH under its PolyLib matrix form.  */\n+\n+void\n+ppl_print_polyhedron_matrix (FILE *file, ppl_const_Polyhedron_t ph)\n+{\n+  CloogMatrix *mat = new_Cloog_Matrix_from_ppl_Polyhedron (ph);\n+  cloog_matrix_print (file, mat);\n+  cloog_matrix_free (mat);\n+}\n+\n+/* Print to FILE the powerset PS in its PolyLib matrix form.  */\n+\n+void\n+ppl_print_powerset_matrix (FILE *file,\n+\t\t\t   ppl_Pointset_Powerset_C_Polyhedron_t ps)\n+{\n+  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n+\n+  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n+       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n+       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n+    {\n+      ppl_const_Polyhedron_t ph;\n+\n+      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n+      ppl_print_polyhedron_matrix (file, ph);\n+    }\n+\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n+}\n+\n+/* Print to STDERR the polyhedron PH under its PolyLib matrix form.  */\n+\n+void\n+debug_ppl_polyhedron_matrix (ppl_Polyhedron_t ph)\n+{\n+  ppl_print_polyhedron_matrix (stderr, ph);\n+}\n+\n+/* Print to STDERR the powerset PS in its PolyLib matrix form.  */\n+\n+void\n+debug_ppl_powerset_matrix (ppl_Pointset_Powerset_C_Polyhedron_t ps)\n+{\n+  ppl_print_powerset_matrix (stderr, ps);\n+}\n+\n+/* Read from FILE a polyhedron under PolyLib matrix form and return a\n+   PPL polyhedron object.  */\n+\n+void\n+ppl_read_polyhedron_matrix (ppl_Polyhedron_t *ph, FILE *file)\n+{\n+  CloogMatrix *mat = cloog_matrix_read (file);\n+  new_C_Polyhedron_from_Cloog_Matrix (ph, mat);\n+  cloog_matrix_free (mat);\n+}\n+#endif"}, {"sha": "8a23c93cc0fb0aabbe39a6395eafbf48bd3702c9", "filename": "gcc/graphite-ppl.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-ppl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-ppl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-ppl.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,133 @@\n+/* Gimple Represented as Polyhedra.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n+   and Tobias Grosser <grosser@fim.uni-passau.de>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+#ifndef GCC_GRAPHITE_PPL_H\n+#define GCC_GRAPHITE_PPL_H\n+\n+#include \"double-int.h\"\n+#include \"tree.h\"\n+\n+CloogMatrix *new_Cloog_Matrix_from_ppl_Polyhedron (ppl_const_Polyhedron_t);\n+CloogDomain *new_Cloog_Domain_from_ppl_Polyhedron (ppl_const_Polyhedron_t);\n+CloogDomain * new_Cloog_Domain_from_ppl_Pointset_Powerset (\n+  ppl_Pointset_Powerset_C_Polyhedron_t);\n+void new_C_Polyhedron_from_Cloog_Matrix (ppl_Polyhedron_t *, CloogMatrix *);\n+void insert_constraint_into_matrix (CloogMatrix *, int, ppl_const_Constraint_t);\n+ppl_Polyhedron_t ppl_strip_loop (ppl_Polyhedron_t, ppl_dimension_type, int);\n+int ppl_lexico_compare_linear_expressions (ppl_Linear_Expression_t,\n+\t\t\t\t\t   ppl_Linear_Expression_t);\n+\n+void ppl_print_polyhedron_matrix (FILE *, ppl_const_Polyhedron_t);\n+void ppl_print_powerset_matrix (FILE *, ppl_Pointset_Powerset_C_Polyhedron_t);\n+void debug_ppl_polyhedron_matrix (ppl_Polyhedron_t);\n+void debug_ppl_powerset_matrix (ppl_Pointset_Powerset_C_Polyhedron_t);\n+void ppl_read_polyhedron_matrix (ppl_Polyhedron_t *, FILE *);\n+void ppl_insert_dimensions (ppl_Polyhedron_t, int, int);\n+void ppl_insert_dimensions_pointset (ppl_Pointset_Powerset_C_Polyhedron_t, int,\n+\t\t\t\t     int);\n+void ppl_set_inhomogeneous_gmp (ppl_Linear_Expression_t, Value);\n+void ppl_set_coef_gmp (ppl_Linear_Expression_t, ppl_dimension_type, Value);\n+\n+/* Assigns to RES the value of the INTEGER_CST T.  */\n+\n+static inline void\n+tree_int_to_gmp (tree t, Value res)\n+{\n+  double_int di = tree_to_double_int (t);\n+  mpz_set_double_int (res, di, TYPE_UNSIGNED (TREE_TYPE (t)));\n+}\n+\n+/* Converts a GMP constant VAL to a tree and returns it.  */\n+\n+static inline tree\n+gmp_cst_to_tree (tree type, Value val)\n+{\n+  tree t = type ? type : integer_type_node;\n+  Value tmp;\n+  double_int di;\n+\n+  value_init (tmp);\n+  value_assign (tmp, val);\n+  di = mpz_get_double_int (t, tmp, true);\n+  value_clear (tmp);\n+\n+  return double_int_to_tree (t, di);\n+}\n+\n+/* Set the inhomogeneous term of E to the integer X.  */\n+\n+static inline void\n+ppl_set_inhomogeneous (ppl_Linear_Expression_t e, int x)\n+{\n+  Value v;\n+  value_init (v);\n+  value_set_si (v, x);\n+  ppl_set_inhomogeneous_gmp (e, v);\n+  value_clear (v);\n+}\n+\n+/* Set the inhomogeneous term of E to the tree X.  */\n+\n+static inline void\n+ppl_set_inhomogeneous_tree (ppl_Linear_Expression_t e, tree x)\n+{\n+  Value v;\n+  value_init (v);\n+  tree_int_to_gmp (x, v);\n+  ppl_set_inhomogeneous_gmp (e, v);\n+  value_clear (v);\n+}\n+\n+/* Set E[I] to integer X.  */\n+\n+static inline void\n+ppl_set_coef (ppl_Linear_Expression_t e, ppl_dimension_type i, int x)\n+{\n+  Value v;\n+  value_init (v);\n+  value_set_si (v, x);\n+  ppl_set_coef_gmp (e, i, v);\n+  value_clear (v);\n+}\n+\n+/* Set E[I] to tree X.  */\n+\n+static inline void\n+ppl_set_coef_tree (ppl_Linear_Expression_t e, ppl_dimension_type i, tree x)\n+{\n+  Value v;\n+  value_init (v);\n+  tree_int_to_gmp (x, v);\n+  ppl_set_coef_gmp (e, i, v);\n+  value_clear (v);\n+}\n+\n+/* Sets RES to the max of V1 and V2.  */\n+\n+static inline void\n+value_max (Value res, Value v1, Value v2)\n+{\n+  if (value_compare (v1, v2) < 0)\n+    value_assign (res, v2);\n+  value_assign (res, v1);\n+}\n+\n+#endif\n+"}, {"sha": "60cb95ba7243edd4a9597473024443cc2742d349", "filename": "gcc/graphite-scop-detection.c", "status": "added", "additions": 1640, "deletions": 0, "changes": 1640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,1640 @@\n+/* Detection of Static Control Parts (SCoP) for Graphite.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Tobias Grosser <grosser@fim.uni-passau.de>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"sese.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+#include \"graphite-scop-detection.h\"\n+\n+/* The type of the analyzed basic block.  */\n+\n+typedef enum gbb_type {\n+  GBB_UNKNOWN,\n+  GBB_LOOP_SING_EXIT_HEADER,\n+  GBB_LOOP_MULT_EXIT_HEADER,\n+  GBB_LOOP_EXIT,\n+  GBB_COND_HEADER,\n+  GBB_SIMPLE,\n+  GBB_LAST\n+} gbb_type;\n+\n+/* Detect the type of BB.  Loop headers are only marked, if they are\n+   new.  This means their loop_father is different to LAST_LOOP.\n+   Otherwise they are treated like any other bb and their type can be\n+   any other type.  */\n+\n+static gbb_type\n+get_bb_type (basic_block bb, struct loop *last_loop)\n+{\n+  VEC (basic_block, heap) *dom;\n+  int nb_dom, nb_suc;\n+  struct loop *loop = bb->loop_father;\n+\n+  /* Check, if we entry into a new loop. */\n+  if (loop != last_loop)\n+    {\n+      if (single_exit (loop) != NULL)\n+        return GBB_LOOP_SING_EXIT_HEADER;\n+      else if (loop->num != 0)\n+        return GBB_LOOP_MULT_EXIT_HEADER;\n+      else\n+\treturn GBB_COND_HEADER;\n+    }\n+\n+  dom = get_dominated_by (CDI_DOMINATORS, bb);\n+  nb_dom = VEC_length (basic_block, dom);\n+  VEC_free (basic_block, heap, dom);\n+\n+  if (nb_dom == 0)\n+    return GBB_LAST;\n+\n+  nb_suc = VEC_length (edge, bb->succs);\n+\n+  if (nb_dom == 1 && nb_suc == 1)\n+    return GBB_SIMPLE;\n+\n+  return GBB_COND_HEADER;\n+}\n+\n+/* A SCoP detection region, defined using bbs as borders.\n+\n+   All control flow touching this region, comes in passing basic_block\n+   ENTRY and leaves passing basic_block EXIT.  By using bbs instead of\n+   edges for the borders we are able to represent also regions that do\n+   not have a single entry or exit edge.\n+\n+   But as they have a single entry basic_block and a single exit\n+   basic_block, we are able to generate for every sd_region a single\n+   entry and exit edge.\n+\n+   1   2\n+    \\ /\n+     3\t<- entry\n+     |\n+     4\n+    / \\\t\t\tThis region contains: {3, 4, 5, 6, 7, 8}\n+   5   6\n+   |   |\n+   7   8\n+    \\ /\n+     9\t<- exit  */\n+\n+\n+typedef struct sd_region_p\n+{\n+  /* The entry bb dominates all bbs in the sd_region.  It is part of\n+     the region.  */\n+  basic_block entry;\n+\n+  /* The exit bb postdominates all bbs in the sd_region, but is not\n+     part of the region.  */\n+  basic_block exit;\n+} sd_region;\n+\n+DEF_VEC_O(sd_region);\n+DEF_VEC_ALLOC_O(sd_region, heap);\n+\n+\n+/* Moves the scops from SOURCE to TARGET and clean up SOURCE.  */\n+\n+static void\n+move_sd_regions (VEC (sd_region, heap) **source,\n+\t\t VEC (sd_region, heap) **target)\n+{\n+  sd_region *s;\n+  int i;\n+\n+  for (i = 0; VEC_iterate (sd_region, *source, i, s); i++)\n+    VEC_safe_push (sd_region, heap, *target, s);\n+\n+  VEC_free (sd_region, heap, *source);\n+}\n+\n+/* Something like \"n * m\" is not allowed.  */\n+\n+static bool\n+graphite_can_represent_init (tree e)\n+{\n+  switch (TREE_CODE (e))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      return graphite_can_represent_init (CHREC_LEFT (e))\n+\t&& graphite_can_represent_init (CHREC_RIGHT (e));\n+\n+    case MULT_EXPR:\n+      if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n+\treturn host_integerp (TREE_OPERAND (e, 1), 0);\n+      else\n+\treturn host_integerp (TREE_OPERAND (e, 0), 0);\n+\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case MINUS_EXPR:\n+      return graphite_can_represent_init (TREE_OPERAND (e, 0))\n+\t&& graphite_can_represent_init (TREE_OPERAND (e, 1));\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n+      return graphite_can_represent_init (TREE_OPERAND (e, 0));\n+\n+   default:\n+     break;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true when SCEV can be represented in the polyhedral model.\n+\n+   An expression can be represented, if it can be expressed as an\n+   affine expression.  For loops (i, j) and parameters (m, n) all\n+   affine expressions are of the form:\n+\n+   x1 * i + x2 * j + x3 * m + x4 * n + x5 * 1 where x1..x5 element of Z\n+\n+   1 i + 20 j + (-2) m + 25\n+\n+   Something like \"i * n\" or \"n * m\" is not allowed.\n+\n+   OUTERMOST_LOOP defines the outermost loop that can variate.  */\n+\n+static bool\n+graphite_can_represent_scev (tree scev, int outermost_loop)\n+{\n+  if (chrec_contains_undetermined (scev))\n+    return false;\n+\n+  if (TREE_CODE (scev) == POLYNOMIAL_CHREC\n+\n+      /* Check for constant strides.  With a non constant stride of\n+\t 'n' we would have a value of 'iv * n'.  */\n+      && (!evolution_function_right_is_integer_cst (scev)\n+\n+\t  /* Check the initial value: 'n * m' cannot be represented.  */\n+\t  || !graphite_can_represent_init (scev)))\n+    return false;\n+\n+  /* Only affine functions can be represented.  */\n+  if (!scev_is_linear_expression (scev))\n+    return false;\n+\n+  return evolution_function_is_invariant_p (scev, outermost_loop)\n+    || evolution_function_is_affine_multivariate_p (scev, outermost_loop);\n+}\n+\n+\n+/* Return true when EXPR can be represented in the polyhedral model.\n+\n+   This means an expression can be represented, if it is linear with\n+   respect to the loops and the strides are non parametric.\n+   LOOP is the place where the expr will be evaluated and OUTERMOST_LOOP\n+   defindes the outermost loop that can variate.  SCOP_ENTRY defines the\n+   entry of the region we analyse.  */\n+\n+static bool\n+graphite_can_represent_expr (basic_block scop_entry, loop_p loop,\n+\t\t\t     loop_p outermost_loop, tree expr)\n+{\n+  tree scev = analyze_scalar_evolution (loop, expr);\n+\n+  scev = instantiate_scev (scop_entry, loop, scev);\n+\n+  return graphite_can_represent_scev (scev, outermost_loop->num);\n+}\n+\n+/* Return false if the tree_code of the operand OP or any of its operands\n+   is component_ref.  */\n+\n+static bool\n+exclude_component_ref (tree op)\n+{\n+  int i;\n+  int len;\n+\n+  if (!op)\n+    return true;\n+\n+  if (TREE_CODE (op) == COMPONENT_REF)\n+    return false;\n+\n+  len = TREE_OPERAND_LENGTH (op);\n+  for (i = 0; i < len; ++i)\n+    if (!exclude_component_ref (TREE_OPERAND (op, i)))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true if the data references of STMT can be represented by\n+   Graphite.  */\n+\n+static bool\n+stmt_has_simple_data_refs_p (loop_p outermost_loop, gimple stmt)\n+{\n+  data_reference_p dr;\n+  unsigned i;\n+  int j;\n+  bool res = true;\n+  int loop = outermost_loop->num;\n+  VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 5);\n+\n+  graphite_find_data_references_in_stmt (outermost_loop, stmt, &drs);\n+\n+  for (j = 0; VEC_iterate (data_reference_p, drs, j, dr); j++)\n+    for (i = 0; i < DR_NUM_DIMENSIONS (dr); i++)\n+      if (!graphite_can_represent_scev (DR_ACCESS_FN (dr, i), loop))\n+\t{\n+\t  res = false;\n+\t  goto done;\n+\t}\n+\n+ done:\n+  free_data_refs (drs);\n+  return res;\n+}\n+\n+/* Return true if we can create an affine data-ref for OP in STMT\n+   in regards to OUTERMOST_LOOP.  */\n+\n+static bool\n+stmt_simple_memref_p (loop_p outermost_loop, gimple stmt, tree op)\n+{\n+  data_reference_p dr;\n+  unsigned int i;\n+  VEC(tree,heap) *fns;\n+  tree t;\n+  bool res = true;\n+\n+  dr = create_data_ref (outermost_loop, op, stmt, true);\n+  fns = DR_ACCESS_FNS (dr);\n+\n+  for (i = 0; VEC_iterate (tree, fns, i, t); i++)\n+    if (!graphite_can_represent_scev (t, outermost_loop->num))\n+      {\n+\tres = false;\n+\tbreak;\n+      }\n+\n+  free_data_ref (dr);\n+  return res;\n+}\n+\n+/* Return true if the operand OP used in STMT is simple in regards to\n+   OUTERMOST_LOOP.  */\n+\n+static bool\n+is_simple_operand (loop_p outermost_loop, gimple stmt, tree op)\n+{\n+  /* It is not a simple operand when it is a declaration,  */\n+  if (DECL_P (op))\n+      return false;\n+\n+  /* or a structure,  */\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (op)))\n+      return false;\n+\n+  /* or a memory access that cannot be analyzed by the data reference\n+     analysis.  */\n+  if (handled_component_p (op) || INDIRECT_REF_P (op))\n+    if (!stmt_simple_memref_p (outermost_loop, stmt, op))\n+      return false;\n+\n+  return exclude_component_ref (op);\n+}\n+\n+/* Return true only when STMT is simple enough for being handled by\n+   Graphite.  This depends on SCOP_ENTRY, as the parameters are\n+   initialized relatively to this basic block, the linear functions\n+   are initialized to OUTERMOST_LOOP and BB is the place where we try\n+   to evaluate the STMT.  */\n+\n+static bool\n+stmt_simple_for_scop_p (basic_block scop_entry, loop_p outermost_loop,\n+\t\t\tgimple stmt, basic_block bb)\n+{\n+  loop_p loop = bb->loop_father;\n+\n+  gcc_assert (scop_entry);\n+\n+  /* GIMPLE_ASM and GIMPLE_CALL may embed arbitrary side effects.\n+     Calls have side-effects, except those to const or pure\n+     functions.  */\n+  if (gimple_has_volatile_ops (stmt)\n+      || (gimple_code (stmt) == GIMPLE_CALL\n+\t  && !(gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE)))\n+      || (gimple_code (stmt) == GIMPLE_ASM))\n+    return false;\n+\n+  if (!stmt_has_simple_data_refs_p (outermost_loop, stmt))\n+    return false;\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_RETURN:\n+    case GIMPLE_LABEL:\n+      return true;\n+\n+    case GIMPLE_COND:\n+      {\n+\ttree op;\n+\tssa_op_iter op_iter;\n+        enum tree_code code = gimple_cond_code (stmt);\n+\n+\t/* We can handle all binary comparisons.  Inequalities are\n+\t   also supported as they can be represented with union of\n+\t   polyhedra.  */\n+        if (!(code == LT_EXPR\n+\t      || code == GT_EXPR\n+\t      || code == LE_EXPR\n+\t      || code == GE_EXPR\n+\t      || code == EQ_EXPR\n+\t      || code == NE_EXPR))\n+          return false;\n+\n+\tFOR_EACH_SSA_TREE_OPERAND (op, stmt, op_iter, SSA_OP_ALL_USES)\n+\t  if (!graphite_can_represent_expr (scop_entry, loop, outermost_loop,\n+\t\t\t\t\t    op)\n+\t      /* We can not handle REAL_TYPE. Failed for pr39260.  */\n+\t      || TREE_CODE (TREE_TYPE (op)) == REAL_TYPE)\n+\t    return false;\n+\n+\treturn true;\n+      }\n+\n+    case GIMPLE_ASSIGN:\n+      {\n+\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\n+\tswitch (get_gimple_rhs_class (code))\n+\t  {\n+\t  case GIMPLE_UNARY_RHS:\n+\t  case GIMPLE_SINGLE_RHS:\n+\t    return (is_simple_operand (outermost_loop, stmt,\n+\t\t\t\t       gimple_assign_lhs (stmt))\n+\t\t    && is_simple_operand (outermost_loop, stmt,\n+\t\t\t\t\t  gimple_assign_rhs1 (stmt)));\n+\n+\t  case GIMPLE_BINARY_RHS:\n+\t    return (is_simple_operand (outermost_loop, stmt,\n+\t\t\t\t       gimple_assign_lhs (stmt))\n+\t\t    && is_simple_operand (outermost_loop, stmt,\n+\t\t\t\t\t  gimple_assign_rhs1 (stmt))\n+\t\t    && is_simple_operand (outermost_loop, stmt,\n+\t\t\t\t\t  gimple_assign_rhs2 (stmt)));\n+\n+\t  case GIMPLE_INVALID_RHS:\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n+\n+    case GIMPLE_CALL:\n+      {\n+\tsize_t i;\n+\tsize_t n = gimple_call_num_args (stmt);\n+\ttree lhs = gimple_call_lhs (stmt);\n+\n+\tif (lhs && !is_simple_operand (outermost_loop, stmt, lhs))\n+\t  return false;\n+\n+\tfor (i = 0; i < n; i++)\n+\t  if (!is_simple_operand (outermost_loop, stmt,\n+\t\t\t\t  gimple_call_arg (stmt, i)))\n+\t    return false;\n+\n+\treturn true;\n+      }\n+\n+    default:\n+      /* These nodes cut a new scope.  */\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Returns the statement of BB that contains a harmful operation: that\n+   can be a function call with side effects, the induction variables\n+   are not linear with respect to SCOP_ENTRY, etc.  The current open\n+   scop should end before this statement.  The evaluation is limited using\n+   OUTERMOST_LOOP as outermost loop that may change.  */\n+\n+static gimple\n+harmful_stmt_in_bb (basic_block scop_entry, loop_p outer_loop, basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (!stmt_simple_for_scop_p (scop_entry, outer_loop, gsi_stmt (gsi), bb))\n+      return gsi_stmt (gsi);\n+\n+  return NULL;\n+}\n+\n+/* Return true when it is not possible to represent LOOP in the\n+   polyhedral representation.  This is evaluated taking SCOP_ENTRY and\n+   OUTERMOST_LOOP in mind.  */\n+\n+static bool\n+graphite_can_represent_loop (basic_block scop_entry, loop_p outermost_loop,\n+\t\t\t     loop_p loop)\n+{\n+  tree niter = number_of_latch_executions (loop);\n+\n+  /* Number of iterations unknown.  */\n+  if (chrec_contains_undetermined (niter))\n+    return false;\n+\n+  /* Number of iterations not affine.  */\n+  if (!graphite_can_represent_expr (scop_entry, loop, outermost_loop, niter))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Store information needed by scopdet_* functions.  */\n+\n+struct scopdet_info\n+{\n+  /* Exit of the open scop would stop if the current BB is harmful.  */\n+  basic_block exit;\n+\n+  /* Where the next scop would start if the current BB is harmful.  */\n+  basic_block next;\n+\n+  /* The bb or one of its children contains open loop exits.  That means\n+     loop exit nodes that are not surrounded by a loop dominated by bb.  */\n+  bool exits;\n+\n+  /* The bb or one of its children contains only structures we can handle.  */\n+  bool difficult;\n+};\n+\n+static struct scopdet_info build_scops_1 (basic_block, loop_p,\n+\t\t\t\t\t  VEC (sd_region, heap) **, loop_p);\n+\n+/* Calculates BB infos. If bb is difficult we add valid SCoPs dominated by BB\n+   to SCOPS.  TYPE is the gbb_type of BB.  */\n+\n+static struct scopdet_info\n+scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n+\t\t\t  VEC (sd_region, heap) **scops, gbb_type type)\n+{\n+  loop_p loop = bb->loop_father;\n+  struct scopdet_info result;\n+  gimple stmt;\n+\n+  /* XXX: ENTRY_BLOCK_PTR could be optimized in later steps.  */\n+  basic_block entry_block = ENTRY_BLOCK_PTR;\n+  stmt = harmful_stmt_in_bb (entry_block, outermost_loop, bb);\n+  result.difficult = (stmt != NULL);\n+  result.exit = NULL;\n+\n+  switch (type)\n+    {\n+    case GBB_LAST:\n+      result.next = NULL;\n+      result.exits = false;\n+\n+      /* Mark bbs terminating a SESE region difficult, if they start\n+\t a condition.  */\n+      if (!single_succ_p (bb))\n+\tresult.difficult = true;\n+      else\n+\tresult.exit = single_succ (bb);\n+\n+      break;\n+\n+    case GBB_SIMPLE:\n+      result.next = single_succ (bb);\n+      result.exits = false;\n+      result.exit = single_succ (bb);\n+      break;\n+\n+    case GBB_LOOP_SING_EXIT_HEADER:\n+      {\n+\tVEC (sd_region, heap) *regions = VEC_alloc (sd_region, heap, 3);\n+\tstruct scopdet_info sinfo;\n+\tedge exit_e = single_exit (loop);\n+\n+\tsinfo = build_scops_1 (bb, outermost_loop, &regions, loop);\n+\n+\tif (!graphite_can_represent_loop (entry_block, outermost_loop, loop))\n+\t  result.difficult = true;\n+\n+\tresult.difficult |= sinfo.difficult;\n+\n+\t/* Try again with another loop level.  */\n+\tif (result.difficult\n+\t    && loop_depth (outermost_loop) + 1 == loop_depth (loop))\n+\t  {\n+\t    outermost_loop = loop;\n+\n+\t    VEC_free (sd_region, heap, regions);\n+\t    regions = VEC_alloc (sd_region, heap, 3);\n+\n+\t    sinfo = scopdet_basic_block_info (bb, outermost_loop, scops, type);\n+\n+\t    result = sinfo;\n+\t    result.difficult = true;\n+\n+\t    if (sinfo.difficult)\n+\t      move_sd_regions (&regions, scops);\n+\t    else\n+\t      {\n+\t\tsd_region open_scop;\n+\t\topen_scop.entry = bb;\n+\t\topen_scop.exit = exit_e->dest;\n+\t\tVEC_safe_push (sd_region, heap, *scops, &open_scop);\n+\t\tVEC_free (sd_region, heap, regions);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    result.exit = exit_e->dest;\n+\t    result.next = exit_e->dest;\n+\n+\t    /* If we do not dominate result.next, remove it.  It's either\n+\t       the EXIT_BLOCK_PTR, or another bb dominates it and will\n+\t       call the scop detection for this bb.  */\n+\t    if (!dominated_by_p (CDI_DOMINATORS, result.next, bb))\n+\t      result.next = NULL;\n+\n+\t    if (exit_e->src->loop_father != loop)\n+\t      result.next = NULL;\n+\n+\t    result.exits = false;\n+\n+\t    if (result.difficult)\n+\t      move_sd_regions (&regions, scops);\n+\t    else\n+\t      VEC_free (sd_region, heap, regions);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+    case GBB_LOOP_MULT_EXIT_HEADER:\n+      {\n+        /* XXX: For now we just do not join loops with multiple exits.  If the\n+           exits lead to the same bb it may be possible to join the loop.  */\n+        VEC (sd_region, heap) *regions = VEC_alloc (sd_region, heap, 3);\n+        VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+        edge e;\n+        int i;\n+\tbuild_scops_1 (bb, loop, &regions, loop);\n+\n+\t/* Scan the code dominated by this loop.  This means all bbs, that are\n+\t   are dominated by a bb in this loop, but are not part of this loop.\n+\n+\t   The easiest case:\n+\t     - The loop exit destination is dominated by the exit sources.\n+\n+\t   TODO: We miss here the more complex cases:\n+\t\t  - The exit destinations are dominated by another bb inside\n+\t\t    the loop.\n+\t\t  - The loop dominates bbs, that are not exit destinations.  */\n+        for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n+          if (e->src->loop_father == loop\n+\t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src))\n+\t    {\n+\t      if (loop_outer (outermost_loop))\n+\t\toutermost_loop = loop_outer (outermost_loop);\n+\n+\t      /* Pass loop_outer to recognize e->dest as loop header in\n+\t\t build_scops_1.  */\n+\t      if (e->dest->loop_father->header == e->dest)\n+\t\tbuild_scops_1 (e->dest, outermost_loop, &regions,\n+\t\t\t       loop_outer (e->dest->loop_father));\n+\t      else\n+\t\tbuild_scops_1 (e->dest, outermost_loop, &regions,\n+\t\t\t       e->dest->loop_father);\n+\t    }\n+\n+        result.next = NULL;\n+        result.exit = NULL;\n+        result.difficult = true;\n+        result.exits = false;\n+        move_sd_regions (&regions, scops);\n+        VEC_free (edge, heap, exits);\n+        break;\n+      }\n+    case GBB_COND_HEADER:\n+      {\n+\tVEC (sd_region, heap) *regions = VEC_alloc (sd_region, heap, 3);\n+\tstruct scopdet_info sinfo;\n+\tVEC (basic_block, heap) *dominated;\n+\tint i;\n+\tbasic_block dom_bb;\n+\tbasic_block last_exit = NULL;\n+\tedge e;\n+\tresult.exits = false;\n+\n+\t/* First check the successors of BB, and check if it is\n+\t   possible to join the different branches.  */\n+\tfor (i = 0; VEC_iterate (edge, bb->succs, i, e); i++)\n+\t  {\n+\t    /* Ignore loop exits.  They will be handled after the loop\n+\t       body.  */\n+\t    if (is_loop_exit (loop, e->dest))\n+\t      {\n+\t\tresult.exits = true;\n+\t\tcontinue;\n+\t      }\n+\n+\t    /* Do not follow edges that lead to the end of the\n+\t       conditions block.  For example, in\n+\n+               |   0\n+\t       |  /|\\\n+\t       | 1 2 |\n+\t       | | | |\n+\t       | 3 4 |\n+\t       |  \\|/\n+               |   6\n+\n+\t       the edge from 0 => 6.  Only check if all paths lead to\n+\t       the same node 6.  */\n+\n+\t    if (!single_pred_p (e->dest))\n+\t      {\n+\t\t/* Check, if edge leads directly to the end of this\n+\t\t   condition.  */\n+\t\tif (!last_exit)\n+\t\t  last_exit = e->dest;\n+\n+\t\tif (e->dest != last_exit)\n+\t\t  result.difficult = true;\n+\n+\t\tcontinue;\n+\t      }\n+\n+\t    if (!dominated_by_p (CDI_DOMINATORS, e->dest, bb))\n+\t      {\n+\t\tresult.difficult = true;\n+\t\tcontinue;\n+\t      }\n+\n+\t    sinfo = build_scops_1 (e->dest, outermost_loop, &regions, loop);\n+\n+\t    result.exits |= sinfo.exits;\n+\t    result.difficult |= sinfo.difficult;\n+\n+\t    /* Checks, if all branches end at the same point.\n+\t       If that is true, the condition stays joinable.\n+\t       Have a look at the example above.  */\n+\t    if (sinfo.exit)\n+\t      {\n+\t\tif (!last_exit)\n+\t\t  last_exit = sinfo.exit;\n+\n+\t\tif (sinfo.exit != last_exit)\n+\t\t  result.difficult = true;\n+\t      }\n+\t    else\n+\t      result.difficult = true;\n+\t  }\n+\n+\tif (!last_exit)\n+\t  result.difficult = true;\n+\n+\t/* Join the branches of the condition if possible.  */\n+\tif (!result.exits && !result.difficult)\n+\t  {\n+\t    /* Only return a next pointer if we dominate this pointer.\n+\t       Otherwise it will be handled by the bb dominating it.  */\n+\t    if (dominated_by_p (CDI_DOMINATORS, last_exit, bb)\n+\t\t&& last_exit != bb)\n+\t      result.next = last_exit;\n+\t    else\n+\t      result.next = NULL;\n+\n+\t    result.exit = last_exit;\n+\n+\t    VEC_free (sd_region, heap, regions);\n+\t    break;\n+\t  }\n+\n+\t/* Scan remaining bbs dominated by BB.  */\n+\tdominated = get_dominated_by (CDI_DOMINATORS, bb);\n+\n+\tfor (i = 0; VEC_iterate (basic_block, dominated, i, dom_bb); i++)\n+\t  {\n+\t    /* Ignore loop exits: they will be handled after the loop body.  */\n+\t    if (loop_depth (find_common_loop (loop, dom_bb->loop_father))\n+\t\t< loop_depth (loop))\n+\t      {\n+\t\tresult.exits = true;\n+\t\tcontinue;\n+\t      }\n+\n+\t    /* Ignore the bbs processed above.  */\n+\t    if (single_pred_p (dom_bb) && single_pred (dom_bb) == bb)\n+\t      continue;\n+\n+\t    if (loop_depth (loop) > loop_depth (dom_bb->loop_father))\n+\t      sinfo = build_scops_1 (dom_bb, outermost_loop, &regions,\n+\t\t\t\t     loop_outer (loop));\n+\t    else\n+\t      sinfo = build_scops_1 (dom_bb, outermost_loop, &regions, loop);\n+\n+\t    result.exits |= sinfo.exits;\n+\t    result.difficult = true;\n+\t    result.exit = NULL;\n+\t  }\n+\n+\tVEC_free (basic_block, heap, dominated);\n+\n+\tresult.next = NULL;\n+\tmove_sd_regions (&regions, scops);\n+\n+\tbreak;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return result;\n+}\n+\n+/* Starting from CURRENT we walk the dominance tree and add new sd_regions to\n+   SCOPS. The analyse if a sd_region can be handled is based on the value\n+   of OUTERMOST_LOOP. Only loops inside OUTERMOST loops may change.  LOOP\n+   is the loop in which CURRENT is handled.\n+\n+   TODO: These functions got a little bit big. They definitely should be cleaned\n+\t up.  */\n+\n+static struct scopdet_info\n+build_scops_1 (basic_block current, loop_p outermost_loop,\n+\t       VEC (sd_region, heap) **scops, loop_p loop)\n+{\n+  bool in_scop = false;\n+  sd_region open_scop;\n+  struct scopdet_info sinfo;\n+\n+  /* Initialize result.  */\n+  struct scopdet_info result;\n+  result.exits = false;\n+  result.difficult = false;\n+  result.next = NULL;\n+  result.exit = NULL;\n+  open_scop.entry = NULL;\n+  open_scop.exit = NULL;\n+  sinfo.exit = NULL;\n+\n+  /* Loop over the dominance tree.  If we meet a difficult bb, close\n+     the current SCoP.  Loop and condition header start a new layer,\n+     and can only be added if all bbs in deeper layers are simple.  */\n+  while (current != NULL)\n+    {\n+      sinfo = scopdet_basic_block_info (current, outermost_loop, scops,\n+\t\t\t\t\tget_bb_type (current, loop));\n+\n+      if (!in_scop && !(sinfo.exits || sinfo.difficult))\n+        {\n+\t  open_scop.entry = current;\n+\t  open_scop.exit = NULL;\n+          in_scop = true;\n+        }\n+      else if (in_scop && (sinfo.exits || sinfo.difficult))\n+        {\n+\t  open_scop.exit = current;\n+          VEC_safe_push (sd_region, heap, *scops, &open_scop);\n+          in_scop = false;\n+        }\n+\n+      result.difficult |= sinfo.difficult;\n+      result.exits |= sinfo.exits;\n+\n+      current = sinfo.next;\n+    }\n+\n+  /* Try to close open_scop, if we are still in an open SCoP.  */\n+  if (in_scop)\n+    {\n+      open_scop.exit = sinfo.exit;\n+      gcc_assert (open_scop.exit);\n+      VEC_safe_push (sd_region, heap, *scops, &open_scop);\n+    }\n+\n+  result.exit = sinfo.exit;\n+  return result;\n+}\n+\n+/* Checks if a bb is contained in REGION.  */\n+\n+static bool\n+bb_in_sd_region (basic_block bb, sd_region *region)\n+{\n+  return bb_in_region (bb, region->entry, region->exit);\n+}\n+\n+/* Returns the single entry edge of REGION, if it does not exits NULL.  */\n+\n+static edge\n+find_single_entry_edge (sd_region *region)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  edge entry = NULL;\n+\n+  FOR_EACH_EDGE (e, ei, region->entry->preds)\n+    if (!bb_in_sd_region (e->src, region))\n+      {\n+\tif (entry)\n+\t  {\n+\t    entry = NULL;\n+\t    break;\n+\t  }\n+\n+\telse\n+\t  entry = e;\n+      }\n+\n+  return entry;\n+}\n+\n+/* Returns the single exit edge of REGION, if it does not exits NULL.  */\n+\n+static edge\n+find_single_exit_edge (sd_region *region)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  edge exit = NULL;\n+\n+  FOR_EACH_EDGE (e, ei, region->exit->preds)\n+    if (bb_in_sd_region (e->src, region))\n+      {\n+\tif (exit)\n+\t  {\n+\t    exit = NULL;\n+\t    break;\n+\t  }\n+\n+\telse\n+\t  exit = e;\n+      }\n+\n+  return exit;\n+}\n+\n+/* Create a single entry edge for REGION.  */\n+\n+static void\n+create_single_entry_edge (sd_region *region)\n+{\n+  if (find_single_entry_edge (region))\n+    return;\n+\n+  /* There are multiple predecessors for bb_3\n+\n+  |  1  2\n+  |  | /\n+  |  |/\n+  |  3\t<- entry\n+  |  |\\\n+  |  | |\n+  |  4 ^\n+  |  | |\n+  |  |/\n+  |  5\n+\n+  There are two edges (1->3, 2->3), that point from outside into the region,\n+  and another one (5->3), a loop latch, lead to bb_3.\n+\n+  We split bb_3.\n+\n+  |  1  2\n+  |  | /\n+  |  |/\n+  |3.0\n+  |  |\\     (3.0 -> 3.1) = single entry edge\n+  |3.1 |  \t<- entry\n+  |  | |\n+  |  | |\n+  |  4 ^\n+  |  | |\n+  |  |/\n+  |  5\n+\n+  If the loop is part of the SCoP, we have to redirect the loop latches.\n+\n+  |  1  2\n+  |  | /\n+  |  |/\n+  |3.0\n+  |  |      (3.0 -> 3.1) = entry edge\n+  |3.1  \t<- entry\n+  |  |\\\n+  |  | |\n+  |  4 ^\n+  |  | |\n+  |  |/\n+  |  5  */\n+\n+  if (region->entry->loop_father->header != region->entry\n+      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t loop_latch_edge (region->entry->loop_father)->src,\n+\t\t\t region->exit))\n+    {\n+      edge forwarder = split_block_after_labels (region->entry);\n+      region->entry = forwarder->dest;\n+    }\n+  else\n+    /* This case is never executed, as the loop headers seem always to have a\n+       single edge pointing from outside into the loop.  */\n+    gcc_unreachable ();\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (find_single_entry_edge (region));\n+#endif\n+}\n+\n+/* Check if the sd_region, mentioned in EDGE, has no exit bb.  */\n+\n+static bool\n+sd_region_without_exit (edge e)\n+{\n+  sd_region *r = (sd_region *) e->aux;\n+\n+  if (r)\n+    return r->exit == NULL;\n+  else\n+    return false;\n+}\n+\n+/* Create a single exit edge for REGION.  */\n+\n+static void\n+create_single_exit_edge (sd_region *region)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  edge forwarder = NULL;\n+  basic_block exit;\n+\n+  if (find_single_exit_edge (region))\n+    return;\n+\n+  /* We create a forwarder bb (5) for all edges leaving this region\n+     (3->5, 4->5).  All other edges leading to the same bb, are moved\n+     to a new bb (6).  If these edges where part of another region (2->5)\n+     we update the region->exit pointer, of this region.\n+\n+     To identify which edge belongs to which region we depend on the e->aux\n+     pointer in every edge.  It points to the region of the edge or to NULL,\n+     if the edge is not part of any region.\n+\n+     1 2 3 4   \t1->5 no region, \t\t2->5 region->exit = 5,\n+      \\| |/    \t3->5 region->exit = NULL, \t4->5 region->exit = NULL\n+        5\t<- exit\n+\n+     changes to\n+\n+     1 2 3 4   \t1->6 no region, \t\t\t2->6 region->exit = 6,\n+     | | \\/\t3->5 no region,\t\t\t\t4->5 no region,\n+     | |  5\n+      \\| /\t5->6 region->exit = 6\n+\t6\n+\n+     Now there is only a single exit edge (5->6).  */\n+  exit = region->exit;\n+  region->exit = NULL;\n+  forwarder = make_forwarder_block (exit, &sd_region_without_exit, NULL);\n+\n+  /* Unmark the edges, that are no longer exit edges.  */\n+  FOR_EACH_EDGE (e, ei, forwarder->src->preds)\n+    if (e->aux)\n+      e->aux = NULL;\n+\n+  /* Mark the new exit edge.  */\n+  single_succ_edge (forwarder->src)->aux = region;\n+\n+  /* Update the exit bb of all regions, where exit edges lead to\n+     forwarder->dest.  */\n+  FOR_EACH_EDGE (e, ei, forwarder->dest->preds)\n+    if (e->aux)\n+      ((sd_region *) e->aux)->exit = forwarder->dest;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (find_single_exit_edge (region));\n+#endif\n+}\n+\n+/* Unmark the exit edges of all REGIONS.\n+   See comment in \"create_single_exit_edge\". */\n+\n+static void\n+unmark_exit_edges (VEC (sd_region, heap) *regions)\n+{\n+  int i;\n+  sd_region *s;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    FOR_EACH_EDGE (e, ei, s->exit->preds)\n+      e->aux = NULL;\n+}\n+\n+\n+/* Mark the exit edges of all REGIONS.\n+   See comment in \"create_single_exit_edge\". */\n+\n+static void\n+mark_exit_edges (VEC (sd_region, heap) *regions)\n+{\n+  int i;\n+  sd_region *s;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    FOR_EACH_EDGE (e, ei, s->exit->preds)\n+      if (bb_in_sd_region (e->src, s))\n+\te->aux = s;\n+}\n+\n+/* Create for all scop regions a single entry and a single exit edge.  */\n+\n+static void\n+create_sese_edges (VEC (sd_region, heap) *regions)\n+{\n+  int i;\n+  sd_region *s;\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    create_single_entry_edge (s);\n+\n+  mark_exit_edges (regions);\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    create_single_exit_edge (s);\n+\n+  unmark_exit_edges (regions);\n+\n+  fix_loop_structure (NULL);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_ssa (false);\n+#endif\n+}\n+\n+/* Create graphite SCoPs from an array of scop detection REGIONS.  */\n+\n+static void\n+build_graphite_scops (VEC (sd_region, heap) *regions,\n+\t\t      VEC (scop_p, heap) **scops)\n+{\n+  int i;\n+  sd_region *s;\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    {\n+      edge entry = find_single_entry_edge (s);\n+      edge exit = find_single_exit_edge (s);\n+      scop_p scop = new_scop (new_sese (entry, exit));\n+      VEC_safe_push (scop_p, heap, *scops, scop);\n+\n+      /* Are there overlapping SCoPs?  */\n+#ifdef ENABLE_CHECKING\n+\t{\n+\t  int j;\n+\t  sd_region *s2;\n+\n+\t  for (j = 0; VEC_iterate (sd_region, regions, j, s2); j++)\n+\t    if (s != s2)\n+\t      gcc_assert (!bb_in_sd_region (s->entry, s2));\n+\t}\n+#endif\n+    }\n+}\n+\n+/* Returns true when BB contains only close phi nodes.  */\n+\n+static bool\n+contains_only_close_phi_nodes (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Print statistics for SCOP to FILE.  */\n+\n+static void\n+print_graphite_scop_statistics (FILE* file, scop_p scop)\n+{\n+  long n_bbs = 0;\n+  long n_loops = 0;\n+  long n_stmts = 0;\n+  long n_conditions = 0;\n+  long n_p_bbs = 0;\n+  long n_p_loops = 0;\n+  long n_p_stmts = 0;\n+  long n_p_conditions = 0;\n+\n+  basic_block bb;\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      gimple_stmt_iterator psi;\n+      loop_p loop = bb->loop_father;\n+\n+      if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n+\tcontinue;\n+\n+      n_bbs++;\n+      n_p_bbs += bb->count;\n+\n+      if (VEC_length (edge, bb->succs) > 1)\n+\t{\n+\t  n_conditions++;\n+\t  n_p_conditions += bb->count;\n+\t}\n+\n+      for (psi = gsi_start_bb (bb); !gsi_end_p (psi); gsi_next (&psi))\n+\t{\n+\t  n_stmts++;\n+\t  n_p_stmts += bb->count;\n+\t}\n+\n+      if (loop->header == bb && loop_in_sese_p (loop, SCOP_REGION (scop)))\n+\t{\n+\t  n_loops++;\n+\t  n_p_loops += bb->count;\n+\t}\n+\n+    }\n+\n+  fprintf (file, \"\\nBefore limit_scops SCoP statistics (\");\n+  fprintf (file, \"BBS:%ld, \", n_bbs);\n+  fprintf (file, \"LOOPS:%ld, \", n_loops);\n+  fprintf (file, \"CONDITIONS:%ld, \", n_conditions);\n+  fprintf (file, \"STMTS:%ld)\\n\", n_stmts);\n+  fprintf (file, \"\\nBefore limit_scops SCoP profiling statistics (\");\n+  fprintf (file, \"BBS:%ld, \", n_p_bbs);\n+  fprintf (file, \"LOOPS:%ld, \", n_p_loops);\n+  fprintf (file, \"CONDITIONS:%ld, \", n_p_conditions);\n+  fprintf (file, \"STMTS:%ld)\\n\", n_p_stmts);\n+}\n+\n+/* Print statistics for SCOPS to FILE.  */\n+\n+static void\n+print_graphite_statistics (FILE* file, VEC (scop_p, heap) *scops)\n+{\n+  int i;\n+  scop_p scop;\n+\n+  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+    print_graphite_scop_statistics (file, scop);\n+}\n+\n+/* Version of free_scops special cased for limit_scops.  */\n+\n+static void\n+free_scops_1 (VEC (scop_p, heap) **scops)\n+{\n+  int i;\n+  scop_p scop;\n+\n+  for (i = 0; VEC_iterate (scop_p, *scops, i, scop); i++)\n+    {\n+      sese region = SCOP_REGION (scop);\n+      free (SESE_PARAMS_NAMES (region));\n+      SESE_PARAMS_NAMES (region) = 0;\n+    }\n+\n+  free_scops (*scops);\n+}\n+\n+/* We limit all SCoPs to SCoPs, that are completely surrounded by a loop.\n+\n+   Example:\n+\n+   for (i      |\n+     {         |\n+       for (j  |  SCoP 1\n+       for (k  |\n+     }         |\n+\n+   * SCoP frontier, as this line is not surrounded by any loop. *\n+\n+   for (l      |  SCoP 2\n+\n+   This is necessary as scalar evolution and parameter detection need a\n+   outermost loop to initialize parameters correctly.\n+\n+   TODO: FIX scalar evolution and parameter detection to allow more flexible\n+         SCoP frontiers.  */\n+\n+static void\n+limit_scops (VEC (scop_p, heap) **scops)\n+{\n+  VEC (sd_region, heap) *regions = VEC_alloc (sd_region, heap, 3);\n+\n+  int i;\n+  scop_p scop;\n+\n+  for (i = 0; VEC_iterate (scop_p, *scops, i, scop); i++)\n+    {\n+      int j;\n+      loop_p loop;\n+      sese region = SCOP_REGION (scop);\n+      build_scop_bbs (scop);\n+      build_sese_loop_nests (region);\n+\n+      for (j = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), j, loop); j++)\n+        if (!loop_in_sese_p (loop_outer (loop), region)\n+\t    && single_exit (loop))\n+          {\n+\t    sd_region open_scop;\n+\t    open_scop.entry = loop->header;\n+\t    open_scop.exit = single_exit (loop)->dest;\n+\n+\t    /* This is a hack on top of the limit_scops hack.  The\n+\t       limit_scops hack should disappear all together.  */\n+\t    if (single_succ_p (open_scop.exit)\n+\t\t&& contains_only_close_phi_nodes (open_scop.exit))\n+\t      open_scop.exit = single_succ_edge (open_scop.exit)->dest;\n+\n+\t    VEC_safe_push (sd_region, heap, regions, &open_scop);\n+\t  }\n+    }\n+\n+  free_scops_1 (scops);\n+  *scops = VEC_alloc (scop_p, heap, 3);\n+\n+  create_sese_edges (regions);\n+  build_graphite_scops (regions, scops);\n+  VEC_free (sd_region, heap, regions);\n+}\n+\n+/* Transforms LOOP to the canonical loop closed SSA form.  */\n+\n+static void\n+canonicalize_loop_closed_ssa (loop_p loop)\n+{\n+  edge e = single_exit (loop);\n+  basic_block bb;\n+\n+  if (!e || e->flags & EDGE_ABNORMAL)\n+    return;\n+\n+  bb = e->dest;\n+\n+  if (VEC_length (edge, bb->preds) == 1)\n+    split_block_after_labels (bb);\n+  else\n+    {\n+      gimple_stmt_iterator psi;\n+      basic_block close = split_edge (e);\n+\n+      e = single_succ_edge (close);\n+\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+\t{\n+\t  gimple phi = gsi_stmt (psi);\n+\t  unsigned i;\n+\n+\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\t    if (gimple_phi_arg_edge (phi, i) == e)\n+\t      {\n+\t\ttree res, arg = gimple_phi_arg_def (phi, i);\n+\t\tuse_operand_p use_p;\n+\t\tgimple close_phi;\n+\n+\t\tif (TREE_CODE (arg) != SSA_NAME)\n+\t\t  continue;\n+\n+\t\tclose_phi = create_phi_node (arg, close);\n+\t\tres = create_new_def_for (gimple_phi_result (close_phi),\n+\t\t\t\t\t  close_phi,\n+\t\t\t\t\t  gimple_phi_result_ptr (close_phi));\n+\t\tadd_phi_arg (close_phi, arg,\n+\t\t\t     gimple_phi_arg_edge (close_phi, 0),\n+\t\t\t     UNKNOWN_LOCATION);\n+\t\tuse_p = gimple_phi_arg_imm_use_ptr (phi, i);\n+\t\treplace_exp (use_p, res);\n+\t\tupdate_stmt (phi);\n+\t      }\n+\t}\n+    }\n+}\n+\n+/* Converts the current loop closed SSA form to a canonical form\n+   expected by the Graphite code generation.\n+\n+   The loop closed SSA form has the following invariant: a variable\n+   defined in a loop that is used outside the loop appears only in the\n+   phi nodes in the destination of the loop exit.  These phi nodes are\n+   called close phi nodes.\n+\n+   The canonical loop closed SSA form contains the extra invariants:\n+\n+   - when the loop contains only one exit, the close phi nodes contain\n+   only one argument.  That implies that the basic block that contains\n+   the close phi nodes has only one predecessor, that is a basic block\n+   in the loop.\n+\n+   - the basic block containing the close phi nodes does not contain\n+   other statements.\n+*/\n+\n+static void\n+canonicalize_loop_closed_ssa_form (void)\n+{\n+  loop_iterator li;\n+  loop_p loop;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    canonicalize_loop_closed_ssa (loop);\n+\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+  update_ssa (TODO_update_ssa);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n+}\n+\n+/* Find Static Control Parts (SCoP) in the current function and pushes\n+   them to SCOPS.  */\n+\n+void\n+build_scops (VEC (scop_p, heap) **scops)\n+{\n+  struct loop *loop = current_loops->tree_root;\n+  VEC (sd_region, heap) *regions = VEC_alloc (sd_region, heap, 3);\n+\n+  canonicalize_loop_closed_ssa_form ();\n+  build_scops_1 (single_succ (ENTRY_BLOCK_PTR), ENTRY_BLOCK_PTR->loop_father,\n+\t\t\t      &regions, loop);\n+  create_sese_edges (regions);\n+  build_graphite_scops (regions, scops);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    print_graphite_statistics (dump_file, *scops);\n+\n+  limit_scops (scops);\n+  VEC_free (sd_region, heap, regions);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nnumber of SCoPs: %d\\n\",\n+\t     VEC_length (scop_p, *scops));\n+}\n+\n+/* Pretty print all SCoPs in DOT format and mark them with different colors.\n+   If there are not enough colors, paint later SCoPs gray.\n+   Special nodes:\n+   - \"*\" after the node number: entry of a SCoP,\n+   - \"#\" after the node number: exit of a SCoP,\n+   - \"()\" entry or exit not part of SCoP.  */\n+\n+static void\n+dot_all_scops_1 (FILE *file, VEC (scop_p, heap) *scops)\n+{\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+  scop_p scop;\n+  const char* color;\n+  int i;\n+\n+  /* Disable debugging while printing graph.  */\n+  int tmp_dump_flags = dump_flags;\n+  dump_flags = 0;\n+\n+  fprintf (file, \"digraph all {\\n\");\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      int part_of_scop = false;\n+\n+      /* Use HTML for every bb label.  So we are able to print bbs\n+         which are part of two different SCoPs, with two different\n+         background colors.  */\n+      fprintf (file, \"%d [label=<\\n  <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" \",\n+                     bb->index);\n+      fprintf (file, \"CELLSPACING=\\\"0\\\">\\n\");\n+\n+      /* Select color for SCoP.  */\n+      for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+\t{\n+\t  sese region = SCOP_REGION (scop);\n+\t  if (bb_in_sese_p (bb, region)\n+\t      || (SESE_EXIT_BB (region) == bb)\n+\t      || (SESE_ENTRY_BB (region) == bb))\n+\t    {\n+\t      switch (i % 17)\n+\t\t{\n+\t\tcase 0: /* red */\n+\t\t  color = \"#e41a1c\";\n+\t\t  break;\n+\t\tcase 1: /* blue */\n+\t\t  color = \"#377eb8\";\n+\t\t  break;\n+\t\tcase 2: /* green */\n+\t\t  color = \"#4daf4a\";\n+\t\t  break;\n+\t\tcase 3: /* purple */\n+\t\t  color = \"#984ea3\";\n+\t\t  break;\n+\t\tcase 4: /* orange */\n+\t\t  color = \"#ff7f00\";\n+\t\t  break;\n+\t\tcase 5: /* yellow */\n+\t\t  color = \"#ffff33\";\n+\t\t  break;\n+\t\tcase 6: /* brown */\n+\t\t  color = \"#a65628\";\n+\t\t  break;\n+\t\tcase 7: /* rose */\n+\t\t  color = \"#f781bf\";\n+\t\t  break;\n+\t\tcase 8:\n+\t\t  color = \"#8dd3c7\";\n+\t\t  break;\n+\t\tcase 9:\n+\t\t  color = \"#ffffb3\";\n+\t\t  break;\n+\t\tcase 10:\n+\t\t  color = \"#bebada\";\n+\t\t  break;\n+\t\tcase 11:\n+\t\t  color = \"#fb8072\";\n+\t\t  break;\n+\t\tcase 12:\n+\t\t  color = \"#80b1d3\";\n+\t\t  break;\n+\t\tcase 13:\n+\t\t  color = \"#fdb462\";\n+\t\t  break;\n+\t\tcase 14:\n+\t\t  color = \"#b3de69\";\n+\t\t  break;\n+\t\tcase 15:\n+\t\t  color = \"#fccde5\";\n+\t\t  break;\n+\t\tcase 16:\n+\t\t  color = \"#bc80bd\";\n+\t\t  break;\n+\t\tdefault: /* gray */\n+\t\t  color = \"#999999\";\n+\t\t}\n+\n+\t      fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"%s\\\">\", color);\n+\n+\t      if (!bb_in_sese_p (bb, region))\n+\t\tfprintf (file, \" (\");\n+\n+\t      if (bb == SESE_ENTRY_BB (region)\n+\t\t  && bb == SESE_EXIT_BB (region))\n+\t\tfprintf (file, \" %d*# \", bb->index);\n+\t      else if (bb == SESE_ENTRY_BB (region))\n+\t\tfprintf (file, \" %d* \", bb->index);\n+\t      else if (bb == SESE_EXIT_BB (region))\n+\t\tfprintf (file, \" %d# \", bb->index);\n+\t      else\n+\t\tfprintf (file, \" %d \", bb->index);\n+\n+\t      if (!bb_in_sese_p (bb,region))\n+\t\tfprintf (file, \")\");\n+\n+\t      fprintf (file, \"</TD></TR>\\n\");\n+\t      part_of_scop  = true;\n+\t    }\n+\t}\n+\n+      if (!part_of_scop)\n+\t{\n+\t  fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"#ffffff\\\">\");\n+\t  fprintf (file, \" %d </TD></TR>\\n\", bb->index);\n+\t}\n+      fprintf (file, \"  </TABLE>>, shape=box, style=\\\"setlinewidth(0)\\\"]\\n\");\n+    }\n+\n+  FOR_ALL_BB (bb)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t      fprintf (file, \"%d -> %d;\\n\", bb->index, e->dest->index);\n+    }\n+\n+  fputs (\"}\\n\\n\", file);\n+\n+  /* Enable debugging again.  */\n+  dump_flags = tmp_dump_flags;\n+}\n+\n+/* Display all SCoPs using dotty.  */\n+\n+void\n+dot_all_scops (VEC (scop_p, heap) *scops)\n+{\n+  /* When debugging, enable the following code.  This cannot be used\n+     in production compilers because it calls \"system\".  */\n+#if 0\n+  int x;\n+  FILE *stream = fopen (\"/tmp/allscops.dot\", \"w\");\n+  gcc_assert (stream);\n+\n+  dot_all_scops_1 (stream, scops);\n+  fclose (stream);\n+\n+  x = system (\"dotty /tmp/allscops.dot\");\n+#else\n+  dot_all_scops_1 (stderr, scops);\n+#endif\n+}\n+\n+/* Display all SCoPs using dotty.  */\n+\n+void\n+dot_scop (scop_p scop)\n+{\n+  VEC (scop_p, heap) *scops = NULL;\n+\n+  if (scop)\n+    VEC_safe_push (scop_p, heap, scops, scop);\n+\n+  /* When debugging, enable the following code.  This cannot be used\n+     in production compilers because it calls \"system\".  */\n+#if 0\n+  {\n+    int x;\n+    FILE *stream = fopen (\"/tmp/allscops.dot\", \"w\");\n+    gcc_assert (stream);\n+\n+    dot_all_scops_1 (stream, scops);\n+    fclose (stream);\n+    x = system (\"dotty /tmp/allscops.dot\");\n+  }\n+#else\n+  dot_all_scops_1 (stderr, scops);\n+#endif\n+\n+  VEC_free (scop_p, heap, scops);\n+}\n+\n+#endif"}, {"sha": "740816d5ac434a1089a387f07e5246e67e0d9af5", "filename": "gcc/graphite-scop-detection.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-scop-detection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-scop-detection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,27 @@\n+/* Detection of Static Control Parts (SCoP) for Graphite.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n+   Tobias Grosser <grosser@fim.uni-passau.de>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+extern void build_scops (VEC (scop_p, heap) **);\n+extern void build_scop_bbs (scop_p);\n+extern int nb_reductions_in_loop (loop_p);\n+extern void dot_all_scops (VEC (scop_p, heap) *);\n+extern void dot_scop (scop_p);"}, {"sha": "e20992e9282e50c696b4b5a10a3de3894652362e", "filename": "gcc/graphite-sese-to-poly.c", "status": "added", "additions": 2089, "deletions": 0, "changes": 2089, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,2089 @@\n+/* Conversion of SESE regions to Polyhedra.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"sese.h\"\n+\n+#ifdef HAVE_cloog\n+#include \"cloog/cloog.h\"\n+#include \"ppl_c.h\"\n+#include \"graphite-ppl.h\"\n+#include \"graphite.h\"\n+#include \"graphite-poly.h\"\n+#include \"graphite-scop-detection.h\"\n+#include \"graphite-clast-to-gimple.h\"\n+#include \"graphite-sese-to-poly.h\"\n+\n+/* Check if VAR is used in a phi node, that is no loop header.  */\n+\n+static bool\n+var_used_in_not_loop_header_phi_node (tree var)\n+{\n+\n+  imm_use_iterator imm_iter;\n+  gimple stmt;\n+  bool result = false;\n+\n+  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, var)\n+    {\n+      basic_block bb = gimple_bb (stmt);\n+\n+      if (gimple_code (stmt) == GIMPLE_PHI\n+\t  && bb->loop_father->header != bb)\n+\tresult = true;\n+    }\n+\n+  return result;\n+}\n+\n+/* Returns the index of the phi argument corresponding to the initial\n+   value in the loop.  */\n+\n+static size_t\n+loop_entry_phi_arg (gimple phi)\n+{\n+  loop_p loop = gimple_bb (phi)->loop_father;\n+  size_t i;\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    if (!flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, i)->src))\n+      return i;\n+\n+  gcc_unreachable ();\n+  return 0;\n+}\n+\n+/* Removes a simple copy phi node \"RES = phi (INIT, RES)\" at position\n+   PSI by inserting on the loop ENTRY edge assignment \"RES = INIT\".  */\n+\n+static void\n+remove_simple_copy_phi (gimple_stmt_iterator *psi)\n+{\n+  gimple phi = gsi_stmt (*psi);\n+  tree res = gimple_phi_result (phi);\n+  size_t entry = loop_entry_phi_arg (phi);\n+  tree init = gimple_phi_arg_def (phi, entry);\n+  gimple stmt = gimple_build_assign (res, init);\n+  edge e = gimple_phi_arg_edge (phi, entry);\n+\n+  remove_phi_node (psi, false);\n+  gsi_insert_on_edge_immediate (e, stmt);\n+  SSA_NAME_DEF_STMT (res) = stmt;\n+}\n+\n+/* Removes an invariant phi node at position PSI by inserting on the\n+   loop ENTRY edge the assignment RES = INIT.  */\n+\n+static void\n+remove_invariant_phi (sese region, gimple_stmt_iterator *psi)\n+{\n+  gimple phi = gsi_stmt (*psi);\n+  loop_p loop = loop_containing_stmt (phi);\n+  tree res = gimple_phi_result (phi);\n+  tree scev = scalar_evolution_in_region (region, loop, res);\n+  size_t entry = loop_entry_phi_arg (phi);\n+  edge e = gimple_phi_arg_edge (phi, entry);\n+  tree var;\n+  gimple stmt;\n+  gimple_seq stmts;\n+  gimple_stmt_iterator gsi;\n+\n+  if (tree_contains_chrecs (scev, NULL))\n+    scev = gimple_phi_arg_def (phi, entry);\n+\n+  var = force_gimple_operand (scev, &stmts, true, NULL_TREE);\n+  stmt = gimple_build_assign (res, var);\n+  remove_phi_node (psi, false);\n+\n+  if (!stmts)\n+    stmts = gimple_seq_alloc ();\n+\n+  gsi = gsi_last (stmts);\n+  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  gsi_insert_seq_on_edge (e, stmts);\n+  gsi_commit_edge_inserts ();\n+  SSA_NAME_DEF_STMT (res) = stmt;\n+}\n+\n+/* Returns true when the phi node at PSI is of the form \"a = phi (a, x)\".  */\n+\n+static inline bool\n+simple_copy_phi_p (gimple phi)\n+{\n+  tree res;\n+\n+  if (gimple_phi_num_args (phi) != 2)\n+    return false;\n+\n+  res = gimple_phi_result (phi);\n+  return (res == gimple_phi_arg_def (phi, 0)\n+\t  || res == gimple_phi_arg_def (phi, 1));\n+}\n+\n+/* Returns true when the phi node at position PSI is a reduction phi\n+   node in REGION.  Otherwise moves the pointer PSI to the next phi to\n+   be considered.  */\n+\n+static bool\n+reduction_phi_p (sese region, gimple_stmt_iterator *psi)\n+{\n+  loop_p loop;\n+  tree scev;\n+  affine_iv iv;\n+  gimple phi = gsi_stmt (*psi);\n+  tree res = gimple_phi_result (phi);\n+\n+  if (!is_gimple_reg (res))\n+    {\n+      gsi_next (psi);\n+      return false;\n+    }\n+\n+  loop = loop_containing_stmt (phi);\n+\n+  if (simple_copy_phi_p (phi))\n+    {\n+      /* FIXME: PRE introduces phi nodes like these, for an example,\n+\t see id-5.f in the fortran graphite testsuite:\n+\n+\t # prephitmp.85_265 = PHI <prephitmp.85_258(33), prephitmp.85_265(18)>\n+      */\n+      remove_simple_copy_phi (psi);\n+      return false;\n+    }\n+\n+  /* Main induction variables with constant strides in LOOP are not\n+     reductions.  */\n+  if (simple_iv (loop, loop, res, &iv, true))\n+    {\n+      gsi_next (psi);\n+      return false;\n+    }\n+\n+  scev = scalar_evolution_in_region (region, loop, res);\n+  if (chrec_contains_undetermined (scev))\n+    return true;\n+\n+  if (evolution_function_is_invariant_p (scev, loop->num))\n+    {\n+      remove_invariant_phi (region, psi);\n+      return false;\n+    }\n+\n+  /* All the other cases are considered reductions.  */\n+  return true;\n+}\n+\n+/* Returns true when BB will be represented in graphite.  Return false\n+   for the basic blocks that contain code eliminated in the code\n+   generation pass: i.e. induction variables and exit conditions.  */\n+\n+static bool\n+graphite_stmt_p (sese region, basic_block bb,\n+\t\t VEC (data_reference_p, heap) *drs)\n+{\n+  gimple_stmt_iterator gsi;\n+  loop_p loop = bb->loop_father;\n+\n+  if (VEC_length (data_reference_p, drs) > 0)\n+    return true;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      switch (gimple_code (stmt))\n+        {\n+          /* Control flow expressions can be ignored, as they are\n+             represented in the iteration domains and will be\n+             regenerated by graphite.  */\n+\tcase GIMPLE_COND:\n+\tcase GIMPLE_GOTO:\n+\tcase GIMPLE_SWITCH:\n+\t  break;\n+\n+\tcase GIMPLE_ASSIGN:\n+\t  {\n+\t    tree var = gimple_assign_lhs (stmt);\n+\n+\t    /* We need these bbs to be able to construct the phi nodes.  */\n+\t    if (var_used_in_not_loop_header_phi_node (var))\n+\t      return true;\n+\n+\t    var = scalar_evolution_in_region (region, loop, var);\n+\t    if (chrec_contains_undetermined (var))\n+\t      return true;\n+\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  return true;\n+        }\n+    }\n+\n+  return false;\n+}\n+\n+/* Store the GRAPHITE representation of BB.  */\n+\n+static gimple_bb_p\n+new_gimple_bb (basic_block bb, VEC (data_reference_p, heap) *drs)\n+{\n+  struct gimple_bb *gbb;\n+\n+  gbb = XNEW (struct gimple_bb);\n+  bb->aux = gbb;\n+  GBB_BB (gbb) = bb;\n+  GBB_DATA_REFS (gbb) = drs;\n+  GBB_CONDITIONS (gbb) = NULL;\n+  GBB_CONDITION_CASES (gbb) = NULL;\n+  GBB_CLOOG_IV_TYPES (gbb) = NULL;\n+\n+  return gbb;\n+}\n+\n+/* Frees GBB.  */\n+\n+static void\n+free_gimple_bb (struct gimple_bb *gbb)\n+{\n+  if (GBB_CLOOG_IV_TYPES (gbb))\n+    htab_delete (GBB_CLOOG_IV_TYPES (gbb));\n+\n+  free_data_refs (GBB_DATA_REFS (gbb));\n+\n+  VEC_free (gimple, heap, GBB_CONDITIONS (gbb));\n+  VEC_free (gimple, heap, GBB_CONDITION_CASES (gbb));\n+  GBB_BB (gbb)->aux = 0;\n+  XDELETE (gbb);\n+}\n+\n+/* Deletes all gimple bbs in SCOP.  */\n+\n+static void\n+remove_gbbs_in_scop (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    free_gimple_bb (PBB_BLACK_BOX (pbb));\n+}\n+\n+/* Deletes all scops in SCOPS.  */\n+\n+void\n+free_scops (VEC (scop_p, heap) *scops)\n+{\n+  int i;\n+  scop_p scop;\n+\n+  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+    {\n+      remove_gbbs_in_scop (scop);\n+      free_sese (SCOP_REGION (scop));\n+      free_scop (scop);\n+    }\n+\n+  VEC_free (scop_p, heap, scops);\n+}\n+\n+/* Generates a polyhedral black box only if the bb contains interesting\n+   information.  */\n+\n+static void\n+try_generate_gimple_bb (scop_p scop, basic_block bb)\n+{\n+  VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 5);\n+  loop_p nest = outermost_loop_in_sese (SCOP_REGION (scop), bb);\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    graphite_find_data_references_in_stmt (nest, gsi_stmt (gsi), &drs);\n+\n+  if (!graphite_stmt_p (SCOP_REGION (scop), bb, drs))\n+    free_data_refs (drs);\n+  else\n+    new_poly_bb (scop, new_gimple_bb (bb, drs));\n+}\n+\n+/* Returns true if all predecessors of BB, that are not dominated by BB, are\n+   marked in MAP.  The predecessors dominated by BB are loop latches and will\n+   be handled after BB.  */\n+\n+static bool\n+all_non_dominated_preds_marked_p (basic_block bb, sbitmap map)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (!TEST_BIT (map, e->src->index)\n+\t&& !dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\treturn false;\n+\n+  return true;\n+}\n+\n+/* Compare the depth of two basic_block's P1 and P2.  */\n+\n+static int\n+compare_bb_depths (const void *p1, const void *p2)\n+{\n+  const_basic_block const bb1 = *(const_basic_block const*)p1;\n+  const_basic_block const bb2 = *(const_basic_block const*)p2;\n+  int d1 = loop_depth (bb1->loop_father);\n+  int d2 = loop_depth (bb2->loop_father);\n+\n+  if (d1 < d2)\n+    return 1;\n+\n+  if (d1 > d2)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Sort the basic blocks from DOM such that the first are the ones at\n+   a deepest loop level.  */\n+\n+static void\n+graphite_sort_dominated_info (VEC (basic_block, heap) *dom)\n+{\n+  size_t len = VEC_length (basic_block, dom);\n+\n+  qsort (VEC_address (basic_block, dom), len, sizeof (basic_block),\n+\t compare_bb_depths);\n+}\n+\n+/* Recursive helper function for build_scops_bbs.  */\n+\n+static void\n+build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n+{\n+  sese region = SCOP_REGION (scop);\n+  VEC (basic_block, heap) *dom;\n+\n+  if (TEST_BIT (visited, bb->index)\n+      || !bb_in_sese_p (bb, region))\n+    return;\n+\n+  try_generate_gimple_bb (scop, bb);\n+  SET_BIT (visited, bb->index);\n+\n+  dom = get_dominated_by (CDI_DOMINATORS, bb);\n+\n+  if (dom == NULL)\n+    return;\n+\n+  graphite_sort_dominated_info (dom);\n+\n+  while (!VEC_empty (basic_block, dom))\n+    {\n+      int i;\n+      basic_block dom_bb;\n+\n+      for (i = 0; VEC_iterate (basic_block, dom, i, dom_bb); i++)\n+\tif (all_non_dominated_preds_marked_p (dom_bb, visited))\n+\t  {\n+\t    build_scop_bbs_1 (scop, visited, dom_bb);\n+\t    VEC_unordered_remove (basic_block, dom, i);\n+\t    break;\n+\t  }\n+    }\n+\n+  VEC_free (basic_block, heap, dom);\n+}\n+\n+/* Gather the basic blocks belonging to the SCOP.  */\n+\n+void\n+build_scop_bbs (scop_p scop)\n+{\n+  sbitmap visited = sbitmap_alloc (last_basic_block);\n+  sese region = SCOP_REGION (scop);\n+\n+  sbitmap_zero (visited);\n+  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n+\n+  sbitmap_free (visited);\n+}\n+\n+/* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.\n+   We generate SCATTERING_DIMENSIONS scattering dimensions.\n+\n+   CLooG 0.15.0 and previous versions require, that all\n+   scattering functions of one CloogProgram have the same number of\n+   scattering dimensions, therefore we allow to specify it.  This\n+   should be removed in future versions of CLooG.\n+\n+   The scattering polyhedron consists of these dimensions: scattering,\n+   loop_iterators, parameters.\n+\n+   Example:\n+\n+   | scattering_dimensions = 5\n+   | used_scattering_dimensions = 3\n+   | nb_iterators = 1\n+   | scop_nb_params = 2\n+   |\n+   | Schedule:\n+   |   i\n+   | 4 5\n+   |\n+   | Scattering polyhedron:\n+   |\n+   | scattering: {s1, s2, s3, s4, s5}\n+   | loop_iterators: {i}\n+   | parameters: {p1, p2}\n+   |\n+   | s1  s2  s3  s4  s5  i   p1  p2  1\n+   | 1   0   0   0   0   0   0   0  -4  = 0\n+   | 0   1   0   0   0  -1   0   0   0  = 0\n+   | 0   0   1   0   0   0   0   0  -5  = 0  */\n+\n+static void\n+build_pbb_scattering_polyhedrons (ppl_Linear_Expression_t static_schedule,\n+\t\t\t\t  poly_bb_p pbb, int scattering_dimensions)\n+{\n+  int i;\n+  scop_p scop = PBB_SCOP (pbb);\n+  int nb_iterators = pbb_dim_iter_domain (pbb);\n+  int used_scattering_dimensions = nb_iterators * 2 + 1;\n+  int nb_params = scop_nb_params (scop);\n+  ppl_Coefficient_t c;\n+  ppl_dimension_type dim = scattering_dimensions + nb_iterators + nb_params;\n+  Value v;\n+\n+  gcc_assert (scattering_dimensions >= used_scattering_dimensions);\n+\n+  value_init (v);\n+  ppl_new_Coefficient (&c);\n+  ppl_new_C_Polyhedron_from_space_dimension\n+    (&PBB_TRANSFORMED_SCATTERING (pbb), dim, 0);\n+\n+  PBB_NB_SCATTERING_TRANSFORM (pbb) = scattering_dimensions;\n+\n+  for (i = 0; i < scattering_dimensions; i++)\n+    {\n+      ppl_Constraint_t cstr;\n+      ppl_Linear_Expression_t expr;\n+\n+      ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+      value_set_si (v, 1);\n+      ppl_assign_Coefficient_from_mpz_t (c, v);\n+      ppl_Linear_Expression_add_to_coefficient (expr, i, c);\n+\n+      /* Textual order inside this loop.  */\n+      if ((i % 2) == 0)\n+\t{\n+\t  ppl_Linear_Expression_coefficient (static_schedule, i / 2, c);\n+\t  ppl_Coefficient_to_mpz_t (c, v);\n+\t  value_oppose (v, v);\n+\t  ppl_assign_Coefficient_from_mpz_t (c, v);\n+\t  ppl_Linear_Expression_add_to_inhomogeneous (expr, c);\n+\t}\n+\n+      /* Iterations of this loop.  */\n+      else /* if ((i % 2) == 1) */\n+\t{\n+\t  int loop = (i - 1) / 2;\n+\n+\t  value_set_si (v, -1);\n+\t  ppl_assign_Coefficient_from_mpz_t (c, v);\n+\t  ppl_Linear_Expression_add_to_coefficient\n+\t    (expr, scattering_dimensions + loop, c);\n+\t}\n+\n+      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n+      ppl_Polyhedron_add_constraint (PBB_TRANSFORMED_SCATTERING (pbb), cstr);\n+      ppl_delete_Linear_Expression (expr);\n+      ppl_delete_Constraint (cstr);\n+    }\n+\n+  value_clear (v);\n+  ppl_delete_Coefficient (c);\n+\n+  ppl_new_C_Polyhedron_from_C_Polyhedron (&PBB_ORIGINAL_SCATTERING (pbb),\n+\t\t\t\t\t  PBB_TRANSFORMED_SCATTERING (pbb));\n+}\n+\n+/* Build for BB the static schedule.\n+\n+   The static schedule is a Dewey numbering of the abstract syntax\n+   tree: http://en.wikipedia.org/wiki/Dewey_Decimal_Classification\n+\n+   The following example informally defines the static schedule:\n+\n+   A\n+   for (i: ...)\n+     {\n+       for (j: ...)\n+         {\n+           B\n+           C\n+         }\n+\n+       for (k: ...)\n+         {\n+           D\n+           E\n+         }\n+     }\n+   F\n+\n+   Static schedules for A to F:\n+\n+     DEPTH\n+     0 1 2\n+   A 0\n+   B 1 0 0\n+   C 1 0 1\n+   D 1 1 0\n+   E 1 1 1\n+   F 2\n+*/\n+\n+static void\n+build_scop_scattering (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  gimple_bb_p previous_gbb = NULL;\n+  ppl_Linear_Expression_t static_schedule;\n+  ppl_Coefficient_t c;\n+  Value v;\n+\n+  value_init (v);\n+  ppl_new_Coefficient (&c);\n+  ppl_new_Linear_Expression (&static_schedule);\n+\n+  /* We have to start schedules at 0 on the first component and\n+     because we cannot compare_prefix_loops against a previous loop,\n+     prefix will be equal to zero, and that index will be\n+     incremented before copying.  */\n+  value_set_si (v, -1);\n+  ppl_assign_Coefficient_from_mpz_t (c, v);\n+  ppl_Linear_Expression_add_to_coefficient (static_schedule, 0, c);\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    {\n+      gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+      ppl_Linear_Expression_t common;\n+      int prefix;\n+      int nb_scat_dims = pbb_dim_iter_domain (pbb) * 2 + 1;\n+\n+      if (previous_gbb)\n+\tprefix = nb_common_loops (SCOP_REGION (scop), previous_gbb, gbb);\n+      else\n+\tprefix = 0;\n+\n+      previous_gbb = gbb;\n+      ppl_new_Linear_Expression_with_dimension (&common, prefix + 1);\n+      ppl_assign_Linear_Expression_from_Linear_Expression (common,\n+\t\t\t\t\t\t\t   static_schedule);\n+\n+      value_set_si (v, 1);\n+      ppl_assign_Coefficient_from_mpz_t (c, v);\n+      ppl_Linear_Expression_add_to_coefficient (common, prefix, c);\n+      ppl_assign_Linear_Expression_from_Linear_Expression (static_schedule,\n+\t\t\t\t\t\t\t   common);\n+\n+      build_pbb_scattering_polyhedrons (common, pbb, nb_scat_dims);\n+\n+      ppl_delete_Linear_Expression (common);\n+    }\n+\n+  value_clear (v);\n+  ppl_delete_Coefficient (c);\n+  ppl_delete_Linear_Expression (static_schedule);\n+}\n+\n+/* Add the value K to the dimension D of the linear expression EXPR.  */\n+\n+static void\n+add_value_to_dim (ppl_dimension_type d, ppl_Linear_Expression_t expr,\n+\t\t  Value k)\n+{\n+  Value val;\n+  ppl_Coefficient_t coef;\n+\n+  ppl_new_Coefficient (&coef);\n+  ppl_Linear_Expression_coefficient (expr, d, coef);\n+  value_init (val);\n+  ppl_Coefficient_to_mpz_t (coef, val);\n+\n+  value_addto (val, val, k);\n+\n+  ppl_assign_Coefficient_from_mpz_t (coef, val);\n+  ppl_Linear_Expression_add_to_coefficient (expr, d, coef);\n+  value_clear (val);\n+  ppl_delete_Coefficient (coef);\n+}\n+\n+/* In the context of scop S, scan E, the right hand side of a scalar\n+   evolution function in loop VAR, and translate it to a linear\n+   expression EXPR.  */\n+\n+static void\n+scan_tree_for_params_right_scev (sese s, tree e, int var,\n+\t\t\t\t ppl_Linear_Expression_t expr)\n+{\n+  if (expr)\n+    {\n+      loop_p loop = get_loop (var);\n+      ppl_dimension_type l = sese_loop_depth (s, loop) - 1;\n+      Value val;\n+\n+      /* Scalar evolutions should happen in the sese region.  */\n+      gcc_assert (sese_loop_depth (s, loop) > 0);\n+\n+      /* We can not deal with parametric strides like:\n+\n+      | p = parameter;\n+      |\n+      | for i:\n+      |   a [i * p] = ...   */\n+      gcc_assert (TREE_CODE (e) == INTEGER_CST);\n+\n+      value_init (val);\n+      value_set_si (val, int_cst_value (e));\n+      add_value_to_dim (l, expr, val);\n+      value_clear (val);\n+    }\n+}\n+\n+/* Scan the integer constant CST, and add it to the inhomogeneous part of the\n+   linear expression EXPR.  K is the multiplier of the constant.  */\n+\n+static void\n+scan_tree_for_params_int (tree cst, ppl_Linear_Expression_t expr, Value k)\n+{\n+  Value val;\n+  ppl_Coefficient_t coef;\n+  int v = int_cst_value (cst);\n+\n+  value_init (val);\n+  value_set_si (val, 0);\n+\n+  /* Necessary to not get \"-1 = 2^n - 1\". */\n+  if (v < 0)\n+    value_sub_int (val, val, -v);\n+  else\n+    value_add_int (val, val, v);\n+\n+  value_multiply (val, val, k);\n+  ppl_new_Coefficient (&coef);\n+  ppl_assign_Coefficient_from_mpz_t (coef, val);\n+  ppl_Linear_Expression_add_to_inhomogeneous (expr, coef);\n+  value_clear (val);\n+  ppl_delete_Coefficient (coef);\n+}\n+\n+/* Saves in NV at index I a new name for variable P.  */\n+\n+static void\n+save_var_name (char **nv, int i, tree p)\n+{\n+  const char *name = get_name (SSA_NAME_VAR (p));\n+\n+  if (name)\n+    {\n+      int len = strlen (name) + 16;\n+      nv[i] = XNEWVEC (char, len);\n+      snprintf (nv[i], len, \"%s_%d\", name, SSA_NAME_VERSION (p));\n+    }\n+  else\n+    {\n+      nv[i] = XNEWVEC (char, 16);\n+      snprintf (nv[i], 2 + 16, \"T_%d\", SSA_NAME_VERSION (p));\n+    }\n+}\n+\n+/* When parameter NAME is in REGION, returns its index in SESE_PARAMS.\n+   Otherwise returns -1.  */\n+\n+static inline int\n+parameter_index_in_region_1 (tree name, sese region)\n+{\n+  int i;\n+  tree p;\n+\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  for (i = 0; VEC_iterate (tree, SESE_PARAMS (region), i, p); i++)\n+    if (p == name)\n+      return i;\n+\n+  return -1;\n+}\n+\n+/* When the parameter NAME is in REGION, returns its index in\n+   SESE_PARAMS.  Otherwise this function inserts NAME in SESE_PARAMS\n+   and returns the index of NAME.  */\n+\n+static int\n+parameter_index_in_region (tree name, sese region)\n+{\n+  int i;\n+\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  i = parameter_index_in_region_1 (name, region);\n+  if (i != -1)\n+    return i;\n+\n+  gcc_assert (SESE_ADD_PARAMS (region));\n+\n+  i = VEC_length (tree, SESE_PARAMS (region));\n+  save_var_name (SESE_PARAMS_NAMES (region), i, name);\n+  save_clast_name_index (SESE_PARAMS_INDEX (region),\n+\t\t\t SESE_PARAMS_NAMES (region)[i], i);\n+  VEC_safe_push (tree, heap, SESE_PARAMS (region), name);\n+  return i;\n+}\n+\n+/* In the context of sese S, scan the expression E and translate it to\n+   a linear expression C.  When parsing a symbolic multiplication, K\n+   represents the constant multiplier of an expression containing\n+   parameters.  */\n+\n+static void\n+scan_tree_for_params (sese s, tree e, ppl_Linear_Expression_t c,\n+\t\t      Value k)\n+{\n+  if (e == chrec_dont_know)\n+    return;\n+\n+  switch (TREE_CODE (e))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      scan_tree_for_params_right_scev (s, CHREC_RIGHT (e),\n+\t\t\t\t       CHREC_VARIABLE (e), c);\n+      scan_tree_for_params (s, CHREC_LEFT (e), c, k);\n+      break;\n+\n+    case MULT_EXPR:\n+      if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n+\t{\n+\t  if (c)\n+\t    {\n+\t      Value val;\n+\t      gcc_assert (host_integerp (TREE_OPERAND (e, 1), 0));\n+\t      value_init (val);\n+\t      value_set_si (val, int_cst_value (TREE_OPERAND (e, 1)));\n+\t      value_multiply (val, val, k);\n+\t      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, val);\n+\t      value_clear (val);\n+\t    }\n+\t  else\n+\t    scan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n+\t}\n+      else\n+\t{\n+\t  if (c)\n+\t    {\n+\t      Value val;\n+\t      gcc_assert (host_integerp (TREE_OPERAND (e, 0), 0));\n+\t      value_init (val);\n+\t      value_set_si (val, int_cst_value (TREE_OPERAND (e, 0)));\n+\t      value_multiply (val, val, k);\n+\t      scan_tree_for_params (s, TREE_OPERAND (e, 1), c, val);\n+\t      value_clear (val);\n+\t    }\n+\t  else\n+\t    scan_tree_for_params (s, TREE_OPERAND (e, 1), c, k);\n+\t}\n+      break;\n+\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n+      scan_tree_for_params (s, TREE_OPERAND (e, 1), c, k);\n+      break;\n+\n+    case MINUS_EXPR:\n+      {\n+\tppl_Linear_Expression_t tmp_expr = NULL;\n+\n+        if (c)\n+\t  {\n+\t    ppl_dimension_type dim;\n+\t    ppl_Linear_Expression_space_dimension (c, &dim);\n+\t    ppl_new_Linear_Expression_with_dimension (&tmp_expr, dim);\n+\t  }\n+\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 1), tmp_expr, k);\n+\n+\tif (c)\n+\t  {\n+\t    ppl_subtract_Linear_Expression_from_Linear_Expression (c,\n+\t\t\t\t\t\t\t\t   tmp_expr);\n+\t    ppl_delete_Linear_Expression (tmp_expr);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+    case NEGATE_EXPR:\n+      {\n+\tppl_Linear_Expression_t tmp_expr = NULL;\n+\n+\tif (c)\n+\t  {\n+\t    ppl_dimension_type dim;\n+\t    ppl_Linear_Expression_space_dimension (c, &dim);\n+\t    ppl_new_Linear_Expression_with_dimension (&tmp_expr, dim);\n+\t  }\n+\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 0), tmp_expr, k);\n+\n+\tif (c)\n+\t  {\n+\t    ppl_subtract_Linear_Expression_from_Linear_Expression (c,\n+\t\t\t\t\t\t\t\t   tmp_expr);\n+\t    ppl_delete_Linear_Expression (tmp_expr);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+    case BIT_NOT_EXPR:\n+      {\n+\tppl_Linear_Expression_t tmp_expr = NULL;\n+\n+\tif (c)\n+\t  {\n+\t    ppl_dimension_type dim;\n+\t    ppl_Linear_Expression_space_dimension (c, &dim);\n+\t    ppl_new_Linear_Expression_with_dimension (&tmp_expr, dim);\n+\t  }\n+\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 0), tmp_expr, k);\n+\n+\tif (c)\n+\t  {\n+\t    ppl_Coefficient_t coef;\n+\t    Value minus_one;\n+\n+\t    ppl_subtract_Linear_Expression_from_Linear_Expression (c,\n+\t\t\t\t\t\t\t\t   tmp_expr);\n+\t    ppl_delete_Linear_Expression (tmp_expr);\n+\t    value_init (minus_one);\n+\t    value_set_si (minus_one, -1);\n+\t    ppl_new_Coefficient_from_mpz_t (&coef, minus_one);\n+\t    ppl_Linear_Expression_add_to_inhomogeneous (c, coef);\n+\t    value_clear (minus_one);\n+\t    ppl_delete_Coefficient (coef);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+    case SSA_NAME:\n+      {\n+\tppl_dimension_type p = parameter_index_in_region (e, s);\n+\n+\tif (c)\n+\t  {\n+\t    ppl_dimension_type dim;\n+\t    ppl_Linear_Expression_space_dimension (c, &dim);\n+\t    p += dim - sese_nb_params (s);\n+\t    add_value_to_dim (p, c, k);\n+\t  }\n+\tbreak;\n+      }\n+\n+    case INTEGER_CST:\n+      if (c)\n+\tscan_tree_for_params_int (e, c, k);\n+      break;\n+\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n+      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n+      break;\n+\n+   default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+/* Data structure for idx_record_params.  */\n+\n+struct irp_data\n+{\n+  struct loop *loop;\n+  sese region;\n+};\n+\n+/* For a data reference with an ARRAY_REF as its BASE, record the\n+   parameters occurring in IDX.  DTA is passed in as complementary\n+   information, and is used by the automatic walker function.  This\n+   function is a callback for for_each_index.  */\n+\n+static bool\n+idx_record_params (tree base, tree *idx, void *dta)\n+{\n+  struct irp_data *data = (struct irp_data *) dta;\n+\n+  if (TREE_CODE (base) != ARRAY_REF)\n+    return true;\n+\n+  if (TREE_CODE (*idx) == SSA_NAME)\n+    {\n+      tree scev;\n+      sese region = data->region;\n+      struct loop *loop = data->loop;\n+      Value one;\n+\n+      scev = scalar_evolution_in_region (region, loop, *idx);\n+\n+      value_init (one);\n+      value_set_si (one, 1);\n+      scan_tree_for_params (region, scev, NULL, one);\n+      value_clear (one);\n+    }\n+\n+  return true;\n+}\n+\n+/* Find parameters with respect to REGION in BB. We are looking in memory\n+   access functions, conditions and loop bounds.  */\n+\n+static void\n+find_params_in_bb (sese region, gimple_bb_p gbb)\n+{\n+  int i;\n+  data_reference_p dr;\n+  gimple stmt;\n+  loop_p loop = GBB_BB (gbb)->loop_father;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, GBB_DATA_REFS (gbb), i, dr); i++)\n+    {\n+      struct irp_data irp;\n+\n+      irp.loop = loop;\n+      irp.region = region;\n+      for_each_index (&dr->ref, idx_record_params, &irp);\n+    }\n+\n+  /* Find parameters in conditional statements.  */\n+  for (i = 0; VEC_iterate (gimple, GBB_CONDITIONS (gbb), i, stmt); i++)\n+    {\n+      Value one;\n+      tree lhs = scalar_evolution_in_region (region, loop,\n+\t\t\t\t\t     gimple_cond_lhs (stmt));\n+      tree rhs = scalar_evolution_in_region (region, loop,\n+\t\t\t\t\t     gimple_cond_rhs (stmt));\n+\n+      value_init (one);\n+      value_set_si (one, 1);\n+      scan_tree_for_params (region, lhs, NULL, one);\n+      scan_tree_for_params (region, rhs, NULL, one);\n+      value_clear (one);\n+    }\n+}\n+\n+/* Record the parameters used in the SCOP.  A variable is a parameter\n+   in a scop if it does not vary during the execution of that scop.  */\n+\n+static void\n+find_scop_parameters (scop_p scop)\n+{\n+  poly_bb_p pbb;\n+  unsigned i;\n+  sese region = SCOP_REGION (scop);\n+  struct loop *loop;\n+  Value one;\n+\n+  value_init (one);\n+  value_set_si (one, 1);\n+\n+  /* Find the parameters used in the loop bounds.  */\n+  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+    {\n+      tree nb_iters = number_of_latch_executions (loop);\n+\n+      if (!chrec_contains_symbols (nb_iters))\n+\tcontinue;\n+\n+      nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n+      scan_tree_for_params (region, nb_iters, NULL, one);\n+    }\n+\n+  value_clear (one);\n+\n+  /* Find the parameters used in data accesses.  */\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    find_params_in_bb (region, PBB_BLACK_BOX (pbb));\n+\n+  scop_set_nb_params (scop, sese_nb_params (region));\n+  SESE_ADD_PARAMS (region) = false;\n+}\n+\n+/* Returns a gimple_bb from BB.  */\n+\n+static inline gimple_bb_p\n+gbb_from_bb (basic_block bb)\n+{\n+  return (gimple_bb_p) bb->aux;\n+}\n+\n+/* Builds the constraint polyhedra for LOOP in SCOP.  OUTER_PH gives\n+   the constraints for the surrounding loops.  */\n+\n+static void\n+build_loop_iteration_domains (scop_p scop, struct loop *loop,\n+                              ppl_Polyhedron_t outer_ph, int nb)\n+\n+{\n+  int i;\n+  ppl_Polyhedron_t ph;\n+  tree nb_iters = number_of_latch_executions (loop);\n+  ppl_dimension_type dim = nb + 1 + scop_nb_params (scop);\n+  sese region = SCOP_REGION (scop);\n+\n+  {\n+    ppl_const_Constraint_System_t pcs;\n+    ppl_dimension_type *map\n+      = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);\n+\n+    ppl_new_C_Polyhedron_from_space_dimension (&ph, dim, 0);\n+    ppl_Polyhedron_get_constraints (outer_ph, &pcs);\n+    ppl_Polyhedron_add_constraints (ph, pcs);\n+\n+    for (i = 0; i < (int) nb; i++)\n+      map[i] = i;\n+    for (i = (int) nb; i < (int) dim - 1; i++)\n+      map[i] = i + 1;\n+    map[dim - 1] = nb;\n+\n+    ppl_Polyhedron_map_space_dimensions (ph, map, dim);\n+    free (map);\n+  }\n+\n+  /* 0 <= loop_i */\n+  {\n+    ppl_Constraint_t lb;\n+    ppl_Linear_Expression_t lb_expr;\n+\n+    ppl_new_Linear_Expression_with_dimension (&lb_expr, dim);\n+    ppl_set_coef (lb_expr, nb, 1);\n+    ppl_new_Constraint (&lb, lb_expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+    ppl_delete_Linear_Expression (lb_expr);\n+    ppl_Polyhedron_add_constraint (ph, lb);\n+    ppl_delete_Constraint (lb);\n+  }\n+\n+  if (TREE_CODE (nb_iters) == INTEGER_CST)\n+    {\n+      ppl_Constraint_t ub;\n+      ppl_Linear_Expression_t ub_expr;\n+\n+      ppl_new_Linear_Expression_with_dimension (&ub_expr, dim);\n+\n+      /* loop_i <= cst_nb_iters */\n+      ppl_set_coef (ub_expr, nb, -1);\n+      ppl_set_inhomogeneous_tree (ub_expr, nb_iters);\n+      ppl_new_Constraint (&ub, ub_expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+      ppl_Polyhedron_add_constraint (ph, ub);\n+      ppl_delete_Linear_Expression (ub_expr);\n+      ppl_delete_Constraint (ub);\n+    }\n+  else if (!chrec_contains_undetermined (nb_iters))\n+    {\n+      Value one;\n+      ppl_Constraint_t ub;\n+      ppl_Linear_Expression_t ub_expr;\n+\n+      value_init (one);\n+      value_set_si (one, 1);\n+      ppl_new_Linear_Expression_with_dimension (&ub_expr, dim);\n+      nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n+      scan_tree_for_params (SCOP_REGION (scop), nb_iters, ub_expr, one);\n+      value_clear (one);\n+\n+      /* loop_i <= expr_nb_iters */\n+      ppl_set_coef (ub_expr, nb, -1);\n+      ppl_new_Constraint (&ub, ub_expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+      ppl_Polyhedron_add_constraint (ph, ub);\n+      ppl_delete_Linear_Expression (ub_expr);\n+      ppl_delete_Constraint (ub);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  if (loop->inner && loop_in_sese_p (loop->inner, region))\n+    build_loop_iteration_domains (scop, loop->inner, ph, nb + 1);\n+\n+  if (nb != 0\n+      && loop->next\n+      && loop_in_sese_p (loop->next, region))\n+    build_loop_iteration_domains (scop, loop->next, outer_ph, nb);\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n+    ((ppl_Pointset_Powerset_C_Polyhedron_t *) &loop->aux, ph);\n+\n+  ppl_delete_Polyhedron (ph);\n+}\n+\n+/* Returns a linear expression for tree T evaluated in PBB.  */\n+\n+static ppl_Linear_Expression_t\n+create_linear_expr_from_tree (poly_bb_p pbb, tree t)\n+{\n+  Value one;\n+  ppl_Linear_Expression_t res;\n+  ppl_dimension_type dim;\n+  sese region = SCOP_REGION (PBB_SCOP (pbb));\n+  loop_p loop = GBB_BB (PBB_BLACK_BOX (pbb))->loop_father;\n+\n+  dim = pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);\n+  ppl_new_Linear_Expression_with_dimension (&res, dim);\n+\n+  t = scalar_evolution_in_region (region, loop, t);\n+  gcc_assert (!automatically_generated_chrec_p (t));\n+\n+  value_init (one);\n+  value_set_si (one, 1);\n+  scan_tree_for_params (region, t, res, one);\n+  value_clear (one);\n+\n+  return res;\n+}\n+\n+/* Returns the ppl constraint type from the gimple tree code CODE.  */\n+\n+static enum ppl_enum_Constraint_Type\n+ppl_constraint_type_from_tree_code (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    /* We do not support LT and GT to be able to work with C_Polyhedron.\n+       As we work on integer polyhedron \"a < b\" can be expressed by\n+       \"a + 1 <= b\".  */\n+    case LT_EXPR:\n+    case GT_EXPR:\n+      gcc_unreachable ();\n+\n+    case LE_EXPR:\n+      return PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL;\n+\n+    case GE_EXPR:\n+      return PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL;\n+\n+    case EQ_EXPR:\n+      return PPL_CONSTRAINT_TYPE_EQUAL;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Add conditional statement STMT to PS.  It is evaluated in PBB and\n+   CODE is used as the comparison operator.  This allows us to invert the\n+   condition or to handle inequalities.  */\n+\n+static void\n+add_condition_to_domain (ppl_Pointset_Powerset_C_Polyhedron_t ps, gimple stmt,\n+\t\t\t poly_bb_p pbb, enum tree_code code)\n+{\n+  Value v;\n+  ppl_Coefficient_t c;\n+  ppl_Linear_Expression_t left, right;\n+  ppl_Constraint_t cstr;\n+  enum ppl_enum_Constraint_Type type;\n+\n+  left = create_linear_expr_from_tree (pbb, gimple_cond_lhs (stmt));\n+  right = create_linear_expr_from_tree (pbb, gimple_cond_rhs (stmt));\n+\n+  /* If we have < or > expressions convert them to <= or >= by adding 1 to\n+     the left or the right side of the expression. */\n+  if (code == LT_EXPR)\n+    {\n+      value_init (v);\n+      value_set_si (v, 1);\n+      ppl_new_Coefficient (&c);\n+      ppl_assign_Coefficient_from_mpz_t (c, v);\n+      ppl_Linear_Expression_add_to_inhomogeneous (left, c);\n+      ppl_delete_Coefficient (c);\n+      value_clear (v);\n+\n+      code = LE_EXPR;\n+    }\n+  else if (code == GT_EXPR)\n+    {\n+      value_init (v);\n+      value_set_si (v, 1);\n+      ppl_new_Coefficient (&c);\n+      ppl_assign_Coefficient_from_mpz_t (c, v);\n+      ppl_Linear_Expression_add_to_inhomogeneous (right, c);\n+      ppl_delete_Coefficient (c);\n+      value_clear (v);\n+\n+      code = GE_EXPR;\n+    }\n+\n+  type = ppl_constraint_type_from_tree_code (code);\n+\n+  ppl_subtract_Linear_Expression_from_Linear_Expression (left, right);\n+\n+  ppl_new_Constraint (&cstr, left, type);\n+  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (ps, cstr);\n+\n+  ppl_delete_Constraint (cstr);\n+  ppl_delete_Linear_Expression (left);\n+  ppl_delete_Linear_Expression (right);\n+}\n+\n+/* Add conditional statement STMT to pbb.  CODE is used as the comparision\n+   operator.  This allows us to invert the condition or to handle\n+   inequalities.  */\n+\n+static void\n+add_condition_to_pbb (poly_bb_p pbb, gimple stmt, enum tree_code code)\n+{\n+  if (code == NE_EXPR)\n+    {\n+      ppl_Pointset_Powerset_C_Polyhedron_t left = PBB_DOMAIN (pbb);\n+      ppl_Pointset_Powerset_C_Polyhedron_t right;\n+      ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+\t(&right, left);\n+      add_condition_to_domain (left, stmt, pbb, LT_EXPR);\n+      add_condition_to_domain (right, stmt, pbb, GT_EXPR);\n+      ppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign (left,\n+\t\t\t\t\t\t\t       right);\n+      ppl_delete_Pointset_Powerset_C_Polyhedron (right);\n+    }\n+  else\n+    add_condition_to_domain (PBB_DOMAIN (pbb), stmt, pbb, code);\n+}\n+\n+/* Add conditions to the domain of PBB.  */\n+\n+static void\n+add_conditions_to_domain (poly_bb_p pbb)\n+{\n+  unsigned int i;\n+  gimple stmt;\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+  VEC (gimple, heap) *conditions = GBB_CONDITIONS (gbb);\n+\n+  if (VEC_empty (gimple, conditions))\n+    return;\n+\n+  for (i = 0; VEC_iterate (gimple, conditions, i, stmt); i++)\n+    switch (gimple_code (stmt))\n+      {\n+      case GIMPLE_COND:\n+\t  {\n+\t    enum tree_code code = gimple_cond_code (stmt);\n+\n+\t    /* The conditions for ELSE-branches are inverted.  */\n+\t    if (VEC_index (gimple, gbb->condition_cases, i) == NULL)\n+\t      code = invert_tree_comparison (code, false);\n+\n+\t    add_condition_to_pbb (pbb, stmt, code);\n+\t    break;\n+\t  }\n+\n+      case GIMPLE_SWITCH:\n+\t/* Switch statements are not supported right now - fall throught.  */\n+\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n+}\n+\n+/* Structure used to pass data to dom_walk.  */\n+\n+struct bsc\n+{\n+  VEC (gimple, heap) **conditions, **cases;\n+  sese region;\n+};\n+\n+/* Returns non NULL when BB has a single predecessor and the last\n+   statement of that predecessor is a COND_EXPR.  */\n+\n+static gimple\n+single_pred_cond (basic_block bb)\n+{\n+  if (single_pred_p (bb))\n+    {\n+      edge e = single_pred_edge (bb);\n+      basic_block pred = e->src;\n+      gimple stmt = last_stmt (pred);\n+\n+      if (stmt && gimple_code (stmt) == GIMPLE_COND)\n+\treturn stmt;\n+    }\n+  return NULL;\n+}\n+\n+/* Call-back for dom_walk executed before visiting the dominated\n+   blocks.  */\n+\n+static void\n+build_sese_conditions_before (struct dom_walk_data *dw_data,\n+\t\t\t      basic_block bb)\n+{\n+  struct bsc *data = (struct bsc *) dw_data->global_data;\n+  VEC (gimple, heap) **conditions = data->conditions;\n+  VEC (gimple, heap) **cases = data->cases;\n+  gimple_bb_p gbb = gbb_from_bb (bb);\n+  gimple stmt = single_pred_cond (bb);\n+\n+  if (!bb_in_sese_p (bb, data->region))\n+    return;\n+\n+  if (stmt)\n+    {\n+      edge e = single_pred_edge (bb);\n+\n+      VEC_safe_push (gimple, heap, *conditions, stmt);\n+\n+      if (e->flags & EDGE_TRUE_VALUE)\n+\tVEC_safe_push (gimple, heap, *cases, stmt);\n+      else\n+\tVEC_safe_push (gimple, heap, *cases, NULL);\n+    }\n+\n+  if (gbb)\n+    {\n+      GBB_CONDITIONS (gbb) = VEC_copy (gimple, heap, *conditions);\n+      GBB_CONDITION_CASES (gbb) = VEC_copy (gimple, heap, *cases);\n+    }\n+}\n+\n+/* Call-back for dom_walk executed after visiting the dominated\n+   blocks.  */\n+\n+static void\n+build_sese_conditions_after (struct dom_walk_data *dw_data,\n+\t\t\t     basic_block bb)\n+{\n+  struct bsc *data = (struct bsc *) dw_data->global_data;\n+  VEC (gimple, heap) **conditions = data->conditions;\n+  VEC (gimple, heap) **cases = data->cases;\n+\n+  if (!bb_in_sese_p (bb, data->region))\n+    return;\n+\n+  if (single_pred_cond (bb))\n+    {\n+      VEC_pop (gimple, *conditions);\n+      VEC_pop (gimple, *cases);\n+    }\n+}\n+\n+/* Record all conditions in REGION.  */\n+\n+static void\n+build_sese_conditions (sese region)\n+{\n+  struct dom_walk_data walk_data;\n+  VEC (gimple, heap) *conditions = VEC_alloc (gimple, heap, 3);\n+  VEC (gimple, heap) *cases = VEC_alloc (gimple, heap, 3);\n+  struct bsc data;\n+\n+  data.conditions = &conditions;\n+  data.cases = &cases;\n+  data.region = region;\n+\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children = build_sese_conditions_before;\n+  walk_data.after_dom_children = build_sese_conditions_after;\n+  walk_data.global_data = &data;\n+  walk_data.block_local_data_size = 0;\n+\n+  init_walk_dominator_tree (&walk_data);\n+  walk_dominator_tree (&walk_data, SESE_ENTRY_BB (region));\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  VEC_free (gimple, heap, conditions);\n+  VEC_free (gimple, heap, cases);\n+}\n+\n+/* Traverses all the GBBs of the SCOP and add their constraints to the\n+   iteration domains.  */\n+\n+static void\n+add_conditions_to_constraints (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    add_conditions_to_domain (pbb);\n+}\n+\n+/* Add constraints on the possible values of parameter P from the type\n+   of P.  */\n+\n+static void\n+add_param_constraints (scop_p scop, ppl_Polyhedron_t context, graphite_dim_t p)\n+{\n+  ppl_Constraint_t cstr;\n+  ppl_Linear_Expression_t le;\n+  tree parameter = VEC_index (tree, SESE_PARAMS (SCOP_REGION (scop)), p);\n+  tree type = TREE_TYPE (parameter);\n+  tree lb, ub;\n+\n+  /* Disabled until we fix CPU2006.  */\n+  return;\n+\n+  if (!INTEGRAL_TYPE_P (type))\n+    return;\n+\n+  lb = TYPE_MIN_VALUE (type);\n+  ub = TYPE_MAX_VALUE (type);\n+\n+  if (lb)\n+    {\n+      ppl_new_Linear_Expression_with_dimension (&le, scop_nb_params (scop));\n+      ppl_set_coef (le, p, -1);\n+      ppl_set_inhomogeneous_tree (le, lb);\n+      ppl_new_Constraint (&cstr, le, PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL);\n+      ppl_Polyhedron_add_constraint (context, cstr);\n+      ppl_delete_Linear_Expression (le);\n+      ppl_delete_Constraint (cstr);\n+    }\n+\n+  if (ub)\n+    {\n+      ppl_new_Linear_Expression_with_dimension (&le, scop_nb_params (scop));\n+      ppl_set_coef (le, p, -1);\n+      ppl_set_inhomogeneous_tree (le, ub);\n+      ppl_new_Constraint (&cstr, le, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+      ppl_Polyhedron_add_constraint (context, cstr);\n+      ppl_delete_Linear_Expression (le);\n+      ppl_delete_Constraint (cstr);\n+    }\n+}\n+\n+/* Build the context of the SCOP.  The context usually contains extra\n+   constraints that are added to the iteration domains that constrain\n+   some parameters.  */\n+\n+static void\n+build_scop_context (scop_p scop)\n+{\n+  ppl_Polyhedron_t context;\n+  graphite_dim_t p, n = scop_nb_params (scop);\n+\n+  ppl_new_C_Polyhedron_from_space_dimension (&context, n, 0);\n+\n+  for (p = 0; p < n; p++)\n+    add_param_constraints (scop, context, p);\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n+    (&SCOP_CONTEXT (scop), context);\n+\n+  ppl_delete_Polyhedron (context);\n+}\n+\n+/* Build the iteration domains: the loops belonging to the current\n+   SCOP, and that vary for the execution of the current basic block.\n+   Returns false if there is no loop in SCOP.  */\n+\n+static void\n+build_scop_iteration_domain (scop_p scop)\n+{\n+  struct loop *loop;\n+  sese region = SCOP_REGION (scop);\n+  int i;\n+  ppl_Polyhedron_t ph;\n+  poly_bb_p pbb;\n+\n+  ppl_new_C_Polyhedron_from_space_dimension (&ph, scop_nb_params (scop), 0);\n+\n+  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+    if (!loop_in_sese_p (loop_outer (loop), region))\n+      build_loop_iteration_domains (scop, loop, ph, 0);\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    if (gbb_loop (PBB_BLACK_BOX (pbb))->aux)\n+      ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+\t(&PBB_DOMAIN (pbb), (ppl_const_Pointset_Powerset_C_Polyhedron_t)\n+\t gbb_loop (PBB_BLACK_BOX (pbb))->aux);\n+    else\n+      ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n+\t(&PBB_DOMAIN (pbb), ph);\n+\n+  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+    if (loop->aux)\n+      {\n+\tppl_delete_Pointset_Powerset_C_Polyhedron\n+\t  ((ppl_Pointset_Powerset_C_Polyhedron_t) loop->aux);\n+\tloop->aux = NULL;\n+      }\n+\n+  ppl_delete_Polyhedron (ph);\n+}\n+\n+/* Add a constrain to the ACCESSES polyhedron for the alias set of\n+   data reference DR.  ACCESSP_NB_DIMS is the dimension of the\n+   ACCESSES polyhedron, DOM_NB_DIMS is the dimension of the iteration\n+   domain.  */\n+\n+static void\n+pdr_add_alias_set (ppl_Polyhedron_t accesses, data_reference_p dr,\n+\t\t   ppl_dimension_type accessp_nb_dims,\n+\t\t   ppl_dimension_type dom_nb_dims)\n+{\n+  ppl_Linear_Expression_t alias;\n+  ppl_Constraint_t cstr;\n+  int alias_set_num = 0;\n+\n+  if (dr->aux != NULL)\n+    {\n+      alias_set_num = *((int *)(dr->aux));\n+      free (dr->aux);\n+      dr->aux = NULL;\n+    }\n+\n+  ppl_new_Linear_Expression_with_dimension (&alias, accessp_nb_dims);\n+\n+  ppl_set_coef (alias, dom_nb_dims, 1);\n+  ppl_set_inhomogeneous (alias, -alias_set_num);\n+  ppl_new_Constraint (&cstr, alias, PPL_CONSTRAINT_TYPE_EQUAL);\n+  ppl_Polyhedron_add_constraint (accesses, cstr);\n+\n+  ppl_delete_Linear_Expression (alias);\n+  ppl_delete_Constraint (cstr);\n+}\n+\n+/* Add to ACCESSES polyhedron equalities defining the access functions\n+   to the memory.  ACCESSP_NB_DIMS is the dimension of the ACCESSES\n+   polyhedron, DOM_NB_DIMS is the dimension of the iteration domain.\n+   PBB is the poly_bb_p that contains the data reference DR.  */\n+\n+static void\n+pdr_add_memory_accesses (ppl_Polyhedron_t accesses, data_reference_p dr,\n+\t\t\t ppl_dimension_type accessp_nb_dims,\n+\t\t\t ppl_dimension_type dom_nb_dims,\n+\t\t\t poly_bb_p pbb)\n+{\n+  int i, nb_subscripts = DR_NUM_DIMENSIONS (dr);\n+  Value v;\n+  scop_p scop = PBB_SCOP (pbb);\n+  sese region = SCOP_REGION (scop);\n+\n+  value_init (v);\n+\n+  for (i = 0; i < nb_subscripts; i++)\n+    {\n+      ppl_Linear_Expression_t fn, access;\n+      ppl_Constraint_t cstr;\n+      ppl_dimension_type subscript = dom_nb_dims + 1 + i;\n+      tree afn = DR_ACCESS_FN (dr, nb_subscripts - 1 - i);\n+\n+      ppl_new_Linear_Expression_with_dimension (&fn, dom_nb_dims);\n+      ppl_new_Linear_Expression_with_dimension (&access, accessp_nb_dims);\n+\n+      value_set_si (v, 1);\n+      scan_tree_for_params (region, afn, fn, v);\n+      ppl_assign_Linear_Expression_from_Linear_Expression (access, fn);\n+\n+      ppl_set_coef (access, subscript, -1);\n+      ppl_new_Constraint (&cstr, access, PPL_CONSTRAINT_TYPE_EQUAL);\n+      ppl_Polyhedron_add_constraint (accesses, cstr);\n+\n+      ppl_delete_Linear_Expression (fn);\n+      ppl_delete_Linear_Expression (access);\n+      ppl_delete_Constraint (cstr);\n+    }\n+\n+  value_clear (v);\n+}\n+\n+/* Add constrains representing the size of the accessed data to the\n+   DATA_CONTAINER polyhedron.  ACCESSP_NB_DIMS is the dimension of the\n+   DATA_CONTAINER polyhedron, DOM_NB_DIMS is the dimension of the iteration\n+   domain.  */\n+\n+static void\n+pdr_add_data_dimensions (ppl_Polyhedron_t data_container, data_reference_p dr,\n+\t\t\t ppl_dimension_type accessp_nb_dims,\n+\t\t\t ppl_dimension_type dom_nb_dims)\n+{\n+  tree ref = DR_REF (dr);\n+  int i, nb_subscripts = DR_NUM_DIMENSIONS (dr);\n+  tree array_size;\n+  HOST_WIDE_INT elt_size;\n+\n+  array_size = TYPE_SIZE (TREE_TYPE (ref));\n+  if (array_size == NULL_TREE\n+      || TREE_CODE (array_size) != INTEGER_CST)\n+    return;\n+\n+  elt_size = int_cst_value (array_size);\n+\n+  for (i = nb_subscripts - 1; i >= 0; i--)\n+    {\n+      ppl_Linear_Expression_t expr;\n+      ppl_Constraint_t cstr;\n+      ppl_dimension_type subscript = dom_nb_dims + 1 + i;\n+\n+      /* 0 <= subscript */\n+      ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);\n+      ppl_set_coef (expr, subscript, 1);\n+      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+      ppl_Polyhedron_add_constraint (data_container, cstr);\n+      ppl_delete_Linear_Expression (expr);\n+      ppl_delete_Constraint (cstr);\n+\n+      ref = TREE_OPERAND (ref, 0);\n+      array_size = TYPE_SIZE (TREE_TYPE (ref));\n+      if (array_size == NULL_TREE\n+\t  || TREE_CODE (array_size) != INTEGER_CST)\n+\tbreak;\n+\n+      /* subscript <= array_size */\n+      ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);\n+      ppl_set_coef (expr, subscript, -1);\n+\n+      if (elt_size)\n+\tppl_set_inhomogeneous (expr, int_cst_value (array_size) / elt_size);\n+\n+      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n+      ppl_Polyhedron_add_constraint (data_container, cstr);\n+      ppl_delete_Linear_Expression (expr);\n+      ppl_delete_Constraint (cstr);\n+\n+      elt_size = int_cst_value (array_size);\n+    }\n+}\n+\n+/* Build data accesses for DR in PBB.  */\n+\n+static void\n+build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n+{\n+  ppl_Polyhedron_t accesses, data_container;\n+  ppl_Pointset_Powerset_C_Polyhedron_t accesses_ps, data_container_ps;\n+  ppl_dimension_type dom_nb_dims;\n+  ppl_dimension_type accessp_nb_dims;\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PBB_DOMAIN (pbb),\n+\t\t\t\t\t\t      &dom_nb_dims);\n+  accessp_nb_dims = dom_nb_dims + 1 + DR_NUM_DIMENSIONS (dr);\n+\n+  ppl_new_C_Polyhedron_from_space_dimension (&accesses, accessp_nb_dims, 0);\n+  ppl_new_C_Polyhedron_from_space_dimension (&data_container,\n+\t\t\t\t\t     accessp_nb_dims, 0);\n+\n+  pdr_add_alias_set (accesses, dr, accessp_nb_dims, dom_nb_dims);\n+  pdr_add_memory_accesses (accesses, dr, accessp_nb_dims, dom_nb_dims, pbb);\n+  pdr_add_data_dimensions (data_container, dr, accessp_nb_dims, dom_nb_dims);\n+\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&accesses_ps,\n+\t\t\t\t\t\t\t    accesses);\n+  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&data_container_ps,\n+\t\t\t\t\t\t\t    data_container);\n+  ppl_delete_Polyhedron (accesses);\n+  ppl_delete_Polyhedron (data_container);\n+  new_poly_dr (pbb, accesses_ps, data_container_ps,\n+\t       DR_IS_READ (dr) ? PDR_READ : PDR_WRITE, dr);\n+}\n+\n+/* Group each data reference in DRS with it's alias set num.  */\n+\n+static void\n+build_alias_set_for_drs (VEC (data_reference_p, heap) **drs)\n+{\n+  int num_vertex = VEC_length (data_reference_p, *drs);\n+  struct graph *g = new_graph (num_vertex);\n+  data_reference_p dr1, dr2;\n+  int i, j;\n+  int num_component;\n+  int *queue;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, *drs, i, dr1); i++)\n+    for (j = i+1; VEC_iterate (data_reference_p, *drs, j, dr2); j++)\n+      if (dr_may_alias_p (dr1, dr2))\n+\t{\n+\t  add_edge (g, i, j);\n+\t  add_edge (g, j, i);\n+\t}\n+\n+  queue = XNEWVEC (int, num_vertex);\n+  for (i = 0; i < num_vertex; i++)\n+    queue[i] = i;\n+\n+  num_component = graphds_dfs (g, queue, num_vertex, NULL, true, NULL);\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      data_reference_p dr = VEC_index (data_reference_p, *drs, i);\n+      dr->aux = XNEW (int);\n+      *((int *)(dr->aux)) = g->vertices[i].component + 1;\n+    }\n+\n+  free (queue);\n+  free_graph (g);\n+}\n+\n+/* Build the data references for PBB.  */\n+\n+static void\n+build_pbb_drs (poly_bb_p pbb)\n+{\n+  int j;\n+  data_reference_p dr;\n+  VEC (data_reference_p, heap) *gbb_drs = GBB_DATA_REFS (PBB_BLACK_BOX (pbb));\n+\n+  build_alias_set_for_drs (&gbb_drs);\n+\n+  for (j = 0; VEC_iterate (data_reference_p, gbb_drs, j, dr); j++)\n+    build_poly_dr (dr, pbb);\n+}\n+\n+/* Build data references in SCOP.  */\n+\n+static void\n+build_scop_drs (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    build_pbb_drs (pbb);\n+}\n+\n+/* Return a gsi at the position of the VAR definition.  */\n+\n+static gimple_stmt_iterator\n+gsi_for_ssa_name_def (tree var)\n+{\n+  gimple stmt;\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator psi;\n+\n+  gcc_assert (TREE_CODE (var) == SSA_NAME);\n+\n+  stmt = SSA_NAME_DEF_STMT (var);\n+  bb = gimple_bb (stmt);\n+\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    if (stmt == gsi_stmt (psi))\n+      return gsi_after_labels (bb);\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (stmt == gsi_stmt (gsi))\n+      {\n+\tgsi_next (&gsi);\n+\treturn gsi;\n+      }\n+\n+  gcc_unreachable ();\n+  return gsi;\n+}\n+\n+/* Insert the assignment \"RES := VAR\" just after the definition of VAR.  */\n+\n+static void\n+insert_out_of_ssa_copy (tree res, tree var)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_ssa_name_def (var);\n+  gimple stmt;\n+  gimple_seq stmts;\n+  gimple_stmt_iterator si;\n+\n+  var = force_gimple_operand (var, &stmts, true, NULL_TREE);\n+  stmt = gimple_build_assign (res, var);\n+  if (!stmts)\n+    stmts = gimple_seq_alloc ();\n+  si = gsi_last (stmts);\n+  gsi_insert_after (&si, stmt, GSI_NEW_STMT);\n+  gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n+}\n+\n+/* Insert on edge E the assignment \"RES := EXPR\".  */\n+\n+static void\n+insert_out_of_ssa_copy_on_edge (edge e, tree res, tree expr)\n+{\n+  gimple_stmt_iterator gsi;\n+  gimple_seq stmts;\n+  tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n+  gimple stmt = gimple_build_assign (res, var);\n+\n+  if (!stmts)\n+    stmts = gimple_seq_alloc ();\n+\n+  gsi = gsi_last (stmts);\n+  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+  gsi_insert_seq_on_edge (e, stmts);\n+  gsi_commit_edge_inserts ();\n+}\n+\n+/* Creates a zero dimension array of the same type as VAR.  */\n+\n+static tree\n+create_zero_dim_array (tree var)\n+{\n+  tree index_type = build_index_type (integer_zero_node);\n+  tree elt_type = TREE_TYPE (var);\n+  tree array_type = build_array_type (elt_type, index_type);\n+  tree base = create_tmp_var (array_type, \"Red\");\n+\n+  add_referenced_var (base);\n+\n+  return build4 (ARRAY_REF, elt_type, base, integer_zero_node, NULL_TREE,\n+\t\t NULL_TREE);\n+}\n+\n+/* Returns true when PHI is a loop close phi node.  */\n+\n+static bool\n+scalar_close_phi_node_p (gimple phi)\n+{\n+  gcc_assert (gimple_code (phi) == GIMPLE_PHI);\n+\n+  if (!is_gimple_reg (gimple_phi_result (phi)))\n+    return false;\n+\n+  return (gimple_phi_num_args (phi) == 1);\n+}\n+\n+/* Rewrite out of SSA the reduction phi node at PSI by creating a zero\n+   dimension array for it.  */\n+\n+static void\n+rewrite_close_phi_out_of_ssa (gimple_stmt_iterator *psi)\n+{\n+  gimple phi = gsi_stmt (*psi);\n+  tree res = gimple_phi_result (phi);\n+  tree var = SSA_NAME_VAR (res);\n+  tree zero_dim_array = create_zero_dim_array (var);\n+  gimple_stmt_iterator gsi = gsi_after_labels (gimple_bb (phi));\n+  gimple stmt = gimple_build_assign (res, zero_dim_array);\n+  tree arg = gimple_phi_arg_def (phi, 0);\n+\n+  insert_out_of_ssa_copy (zero_dim_array, arg);\n+\n+  remove_phi_node (psi, false);\n+  gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (res) = stmt;\n+}\n+\n+/* Rewrite out of SSA the reduction phi node at PSI by creating a zero\n+   dimension array for it.  */\n+\n+static void\n+rewrite_phi_out_of_ssa (gimple_stmt_iterator *psi)\n+{\n+  size_t i;\n+  gimple phi = gsi_stmt (*psi);\n+  basic_block bb = gimple_bb (phi);\n+  tree res = gimple_phi_result (phi);\n+  tree var = SSA_NAME_VAR (res);\n+  tree zero_dim_array = create_zero_dim_array (var);\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  gimple_seq stmts;\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+\n+      /* Try to avoid the insertion on edges as much as possible: this\n+\t would avoid the insertion of code on loop latch edges, making\n+\t the pattern matching of the vectorizer happy, or it would\n+\t avoid the insertion of useless basic blocks.  Note that it is\n+\t incorrect to insert out of SSA copies close by their\n+\t definition when they are more than two loop levels apart:\n+\t for example, starting from a double nested loop\n+\n+\t | a = ...\n+\t | loop_1\n+\t |  loop_2\n+\t |    b = phi (a, c)\n+\t |    c = ...\n+\t |  end_2\n+\t | end_1\n+\n+\t the following transform is incorrect\n+\n+\t | a = ...\n+\t | Red[0] = a\n+\t | loop_1\n+\t |  loop_2\n+\t |    b = Red[0]\n+\t |    c = ...\n+\t |    Red[0] = c\n+\t |  end_2\n+\t | end_1\n+\n+\t whereas inserting the copy on the incomming edge is correct\n+\n+\t | a = ...\n+\t | loop_1\n+\t |  Red[0] = a\n+\t |  loop_2\n+\t |    b = Red[0]\n+\t |    c = ...\n+\t |    Red[0] = c\n+\t |  end_2\n+\t | end_1\n+      */\n+      if (TREE_CODE (arg) == SSA_NAME\n+\t  && is_gimple_reg (arg)\n+\t  && gimple_bb (SSA_NAME_DEF_STMT (arg))\n+\t  && (flow_bb_inside_loop_p (bb->loop_father,\n+\t\t\t\t     gimple_bb (SSA_NAME_DEF_STMT (arg)))\n+\t      || flow_bb_inside_loop_p (loop_outer (bb->loop_father),\n+\t\t\t\t\tgimple_bb (SSA_NAME_DEF_STMT (arg)))))\n+\tinsert_out_of_ssa_copy (zero_dim_array, arg);\n+      else\n+\tinsert_out_of_ssa_copy_on_edge (gimple_phi_arg_edge (phi, i),\n+\t\t\t\t\tzero_dim_array, arg);\n+    }\n+\n+  var = force_gimple_operand (zero_dim_array, &stmts, true, NULL_TREE);\n+\n+  if (!stmts)\n+    stmts = gimple_seq_alloc ();\n+\n+  stmt = gimple_build_assign (res, var);\n+  remove_phi_node (psi, false);\n+  SSA_NAME_DEF_STMT (res) = stmt;\n+\n+  gsi = gsi_last (stmts);\n+  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+\n+  gsi = gsi_after_labels (bb);\n+  gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n+}\n+\n+/* Rewrite out of SSA all the reduction phi nodes of SCOP.  */\n+\n+static void\n+rewrite_reductions_out_of_ssa (scop_p scop)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator psi;\n+  sese region = SCOP_REGION (scop);\n+\n+  FOR_EACH_BB (bb)\n+    if (bb_in_region (bb, SESE_ENTRY_BB (region), SESE_EXIT_BB (region)))\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi);)\n+\t{\n+\t  if (scalar_close_phi_node_p (gsi_stmt (psi)))\n+\t    rewrite_close_phi_out_of_ssa (&psi);\n+\t  else if (reduction_phi_p (region, &psi))\n+\t    rewrite_phi_out_of_ssa (&psi);\n+\t}\n+\n+  update_ssa (TODO_update_ssa);\n+#ifdef ENABLE_CHECKING\n+  verify_ssa (false);\n+  verify_loop_closed_ssa ();\n+#endif\n+}\n+\n+/* Returns the number of pbbs that are in loops contained in SCOP.  */\n+\n+static int\n+nb_pbbs_in_loops (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  int res = 0;\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+    if (loop_in_sese_p (gbb_loop (PBB_BLACK_BOX (pbb)), SCOP_REGION (scop)))\n+      res++;\n+\n+  return res;\n+}\n+\n+/* Builds the polyhedral representation for a SESE region.  */\n+\n+bool\n+build_poly_scop (scop_p scop)\n+{\n+  sese region = SCOP_REGION (scop);\n+  rewrite_reductions_out_of_ssa (scop);\n+  build_scop_bbs (scop);\n+\n+  /* FIXME: This restriction is needed to avoid a problem in CLooG.\n+     Once CLooG is fixed, remove this guard.  Anyways, it makes no\n+     sense to optimize a scop containing only PBBs that do not belong\n+     to any loops.  */\n+  if (nb_pbbs_in_loops (scop) == 0)\n+    return false;\n+\n+  build_sese_loop_nests (region);\n+  build_sese_conditions (region);\n+  find_scop_parameters (scop);\n+\n+  build_scop_iteration_domain (scop);\n+  build_scop_context (scop);\n+\n+  add_conditions_to_constraints (scop);\n+  build_scop_scattering (scop);\n+  build_scop_drs (scop);\n+\n+  return true;\n+}\n+\n+/* Always return false.  Exercise the scop_to_clast function.  */\n+\n+void\n+check_poly_representation (scop_p scop)\n+{\n+#ifdef ENABLE_CHECKING\n+  cloog_prog_clast pc = scop_to_clast (scop);\n+  cloog_clast_free (pc.stmt);\n+  cloog_program_free (pc.prog);\n+#endif\n+}\n+#endif"}, {"sha": "d6df07f6ef564cf8dcfbb19a9d0a51f36149412f", "filename": "gcc/graphite-sese-to-poly.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,27 @@\n+/* Conversion of SESE regions to Polyhedra.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GRAPHITE_SESE_TO_POLY_H\n+#define GCC_GRAPHITE_SESE_TO_POLY_H\n+\n+bool build_poly_scop (scop_p);\n+void check_poly_representation (scop_p);\n+\n+#endif"}, {"sha": "25c5703ec71c7b474597ddc8d2062652b017f52d", "filename": "gcc/sese.c", "status": "added", "additions": 1386, "deletions": 0, "changes": 1386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,1386 @@\n+/* Single entry single exit control flow regions.\n+   Copyright (C) 2008, 2009  Free Software Foundation, Inc.\n+   Contributed by Jan Sjodin <jan.sjodin@amd.com> and\n+   Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"domwalk.h\"\n+#include \"value-prof.h\"\n+#include \"pointer-set.h\"\n+#include \"gimple.h\"\n+#include \"sese.h\"\n+\n+/* Print to stderr the element ELT.  */\n+\n+static void\n+debug_rename_elt (rename_map_elt elt)\n+{\n+  fprintf (stderr, \"(\");\n+  print_generic_expr (stderr, elt->old_name, 0);\n+  fprintf (stderr, \", \");\n+  print_generic_expr (stderr, elt->expr, 0);\n+  fprintf (stderr, \")\\n\");\n+}\n+\n+/* Helper function for debug_rename_map.  */\n+\n+static int\n+debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+{\n+  struct rename_map_elt_s *entry = (struct rename_map_elt_s *) *slot;\n+  debug_rename_elt (entry);\n+  return 1;\n+}\n+\n+/* Print to stderr all the elements of MAP.  */\n+\n+void\n+debug_rename_map (htab_t map)\n+{\n+  htab_traverse (map, debug_rename_map_1, NULL);\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+hashval_t\n+rename_map_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct rename_map_elt_s *) elt)->old_name);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+int\n+eq_rename_map_elts (const void *e1, const void *e2)\n+{\n+  const struct rename_map_elt_s *elt1 = (const struct rename_map_elt_s *) e1;\n+  const struct rename_map_elt_s *elt2 = (const struct rename_map_elt_s *) e2;\n+\n+  return (elt1->old_name == elt2->old_name);\n+}\n+\n+\f\n+\n+/* Print to stderr the element ELT.  */\n+\n+static void\n+debug_ivtype_elt (ivtype_map_elt elt)\n+{\n+  fprintf (stderr, \"(%s, \", elt->cloog_iv);\n+  print_generic_expr (stderr, elt->type, 0);\n+  fprintf (stderr, \")\\n\");\n+}\n+\n+/* Helper function for debug_ivtype_map.  */\n+\n+static int\n+debug_ivtype_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+{\n+  struct ivtype_map_elt_s *entry = (struct ivtype_map_elt_s *) *slot;\n+  debug_ivtype_elt (entry);\n+  return 1;\n+}\n+\n+/* Print to stderr all the elements of MAP.  */\n+\n+void\n+debug_ivtype_map (htab_t map)\n+{\n+  htab_traverse (map, debug_ivtype_map_1, NULL);\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+hashval_t\n+ivtype_map_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct ivtype_map_elt_s *) elt)->cloog_iv);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+int\n+eq_ivtype_map_elts (const void *e1, const void *e2)\n+{\n+  const struct ivtype_map_elt_s *elt1 = (const struct ivtype_map_elt_s *) e1;\n+  const struct ivtype_map_elt_s *elt2 = (const struct ivtype_map_elt_s *) e2;\n+\n+  return (elt1->cloog_iv == elt2->cloog_iv);\n+}\n+\n+\f\n+\n+/* Record LOOP as occuring in REGION.  */\n+\n+static void\n+sese_record_loop (sese region, loop_p loop)\n+{\n+  if (sese_contains_loop (region, loop))\n+    return;\n+\n+  bitmap_set_bit (SESE_LOOPS (region), loop->num);\n+  VEC_safe_push (loop_p, heap, SESE_LOOP_NEST (region), loop);\n+}\n+\n+/* Build the loop nests contained in REGION.  Returns true when the\n+   operation was successful.  */\n+\n+void\n+build_sese_loop_nests (sese region)\n+{\n+  unsigned i;\n+  basic_block bb;\n+  struct loop *loop0, *loop1;\n+\n+  FOR_EACH_BB (bb)\n+    if (bb_in_sese_p (bb, region))\n+      {\n+\tstruct loop *loop = bb->loop_father;\n+\n+\t/* Only add loops if they are completely contained in the SCoP.  */\n+\tif (loop->header == bb\n+\t    && bb_in_sese_p (loop->latch, region))\n+\t  sese_record_loop (region, loop);\n+      }\n+\n+  /* Make sure that the loops in the SESE_LOOP_NEST are ordered.  It\n+     can be the case that an inner loop is inserted before an outer\n+     loop.  To avoid this, semi-sort once.  */\n+  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop0); i++)\n+    {\n+      if (VEC_length (loop_p, SESE_LOOP_NEST (region)) == i + 1)\n+\tbreak;\n+\n+      loop1 = VEC_index (loop_p, SESE_LOOP_NEST (region), i + 1);\n+      if (loop0->num > loop1->num)\n+\t{\n+\t  VEC_replace (loop_p, SESE_LOOP_NEST (region), i, loop1);\n+\t  VEC_replace (loop_p, SESE_LOOP_NEST (region), i + 1, loop0);\n+\t}\n+    }\n+}\n+\n+/* For a USE in BB, if BB is outside REGION, mark the USE in the\n+   LIVEOUTS set.  */\n+\n+static void\n+sese_build_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n+\t\t\t tree use)\n+{\n+  unsigned ver;\n+  basic_block def_bb;\n+\n+  if (TREE_CODE (use) != SSA_NAME)\n+    return;\n+\n+  ver = SSA_NAME_VERSION (use);\n+  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n+\n+  if (!def_bb\n+      || !bb_in_sese_p (def_bb, region)\n+      || bb_in_sese_p (bb, region))\n+    return;\n+\n+  bitmap_set_bit (liveouts, ver);\n+}\n+\n+/* Marks for rewrite all the SSA_NAMES defined in REGION and that are\n+   used in BB that is outside of the REGION.  */\n+\n+static void\n+sese_build_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n+{\n+  gimple_stmt_iterator bsi;\n+  edge e;\n+  edge_iterator ei;\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n+      sese_build_liveouts_use (region, liveouts, bb,\n+\t\t\t       PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e));\n+\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    FOR_EACH_SSA_USE_OPERAND (use_p, gsi_stmt (bsi), iter, SSA_OP_ALL_USES)\n+      sese_build_liveouts_use (region, liveouts, bb, USE_FROM_PTR (use_p));\n+}\n+\n+/* Build the LIVEOUTS of REGION: the set of variables defined inside\n+   and used outside the REGION.  */\n+\n+static void\n+sese_build_liveouts (sese region, bitmap liveouts)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    sese_build_liveouts_bb (region, liveouts, bb);\n+}\n+\n+/* Builds a new SESE region from edges ENTRY and EXIT.  */\n+\n+sese\n+new_sese (edge entry, edge exit)\n+{\n+  sese region = XNEW (struct sese_s);\n+\n+  SESE_ENTRY (region) = entry;\n+  SESE_EXIT (region) = exit;\n+  SESE_LOOPS (region) = BITMAP_ALLOC (NULL);\n+  SESE_LOOP_NEST (region) = VEC_alloc (loop_p, heap, 3);\n+  SESE_ADD_PARAMS (region) = true;\n+  SESE_PARAMS (region) = VEC_alloc (tree, heap, 3);\n+  SESE_PARAMS_INDEX (region) = htab_create (10, clast_name_index_elt_info,\n+\t\t\t\t\t    eq_clast_name_indexes, free);\n+  SESE_PARAMS_NAMES (region) = XNEWVEC (char *, num_ssa_names);\n+\n+  return region;\n+}\n+\n+/* Deletes REGION.  */\n+\n+void\n+free_sese (sese region)\n+{\n+  if (SESE_LOOPS (region))\n+    SESE_LOOPS (region) = BITMAP_ALLOC (NULL);\n+\n+  VEC_free (tree, heap, SESE_PARAMS (region));\n+  VEC_free (loop_p, heap, SESE_LOOP_NEST (region)); \n+\n+  if (SESE_PARAMS_INDEX (region))\n+    htab_delete (SESE_PARAMS_INDEX (region));\n+\n+  /* Do not free SESE_PARAMS_NAMES: CLooG does that.  */\n+\n+  XDELETE (region);\n+}\n+\n+/* Add exit phis for USE on EXIT.  */\n+\n+static void\n+sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n+{\n+  gimple phi = create_phi_node (use, exit);\n+\n+  create_new_def_for (gimple_phi_result (phi), phi,\n+\t\t      gimple_phi_result_ptr (phi));\n+  add_phi_arg (phi, use, false_e, UNKNOWN_LOCATION);\n+  add_phi_arg (phi, use, true_e, UNKNOWN_LOCATION);\n+}\n+\n+/* Insert in the block BB phi nodes for variables defined in REGION\n+   and used outside the REGION.  The code generation moves REGION in\n+   the else clause of an \"if (1)\" and generates code in the then\n+   clause that is at this point empty:\n+\n+   | if (1)\n+   |   empty;\n+   | else\n+   |   REGION;\n+*/\n+\n+void\n+sese_insert_phis_for_liveouts (sese region, basic_block bb,\n+\t\t\t       edge false_e, edge true_e)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+  bitmap liveouts = BITMAP_ALLOC (NULL);\n+\n+  update_ssa (TODO_update_ssa);\n+\n+  sese_build_liveouts (region, liveouts);\n+  EXECUTE_IF_SET_IN_BITMAP (liveouts, 0, i, bi)\n+    sese_add_exit_phis_edge (bb, ssa_name (i), false_e, true_e);\n+  BITMAP_FREE (liveouts);\n+\n+  update_ssa (TODO_update_ssa);\n+}\n+\n+/* Get the definition of NAME before the SESE.  Keep track of the\n+   basic blocks that have been VISITED in a bitmap.  */\n+\n+static tree\n+get_vdef_before_sese (sese region, tree name, sbitmap visited)\n+{\n+  unsigned i;\n+  gimple def_stmt = SSA_NAME_DEF_STMT (name);\n+  basic_block def_bb = gimple_bb (def_stmt);\n+\n+  if (!def_bb || !bb_in_sese_p (def_bb, region))\n+    return name;\n+\n+  if (TEST_BIT (visited, def_bb->index))\n+    return NULL_TREE;\n+\n+  SET_BIT (visited, def_bb->index);\n+\n+  switch (gimple_code (def_stmt))\n+    {\n+    case GIMPLE_PHI:\n+      for (i = 0; i < gimple_phi_num_args (def_stmt); i++)\n+\t{\n+\t  tree arg = gimple_phi_arg_def (def_stmt, i);\n+\t  tree res = get_vdef_before_sese (region, arg, visited);\n+\t  if (res)\n+\t    return res;\n+\t}\n+      return NULL_TREE;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Adjust a virtual phi node PHI that is placed at the end of the\n+   generated code for SCOP:\n+\n+   | if (1)\n+   |   generated code from REGION;\n+   | else\n+   |   REGION;\n+\n+   The FALSE_E edge comes from the original code, TRUE_E edge comes\n+   from the code generated for the SCOP.  */\n+\n+static void\n+sese_adjust_vphi (sese region, gimple phi, edge true_e)\n+{\n+  unsigned i;\n+\n+  gcc_assert (gimple_phi_num_args (phi) == 2);\n+\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    if (gimple_phi_arg_edge (phi, i) == true_e)\n+      {\n+\ttree true_arg, false_arg, before_scop_arg;\n+\tsbitmap visited;\n+\n+\ttrue_arg = gimple_phi_arg_def (phi, i);\n+\tif (!SSA_NAME_IS_DEFAULT_DEF (true_arg))\n+\t  return;\n+\n+\tfalse_arg = gimple_phi_arg_def (phi, i == 0 ? 1 : 0);\n+\tif (SSA_NAME_IS_DEFAULT_DEF (false_arg))\n+\t  return;\n+\n+\tvisited = sbitmap_alloc (last_basic_block);\n+\tsbitmap_zero (visited);\n+\tbefore_scop_arg = get_vdef_before_sese (region, false_arg, visited);\n+\tgcc_assert (before_scop_arg != NULL_TREE);\n+\tSET_PHI_ARG_DEF (phi, i, before_scop_arg);\n+\tsbitmap_free (visited);\n+      }\n+}\n+\n+/* Returns the name associated to OLD_NAME in MAP.  */\n+\n+static tree\n+get_rename (htab_t map, tree old_name)\n+{\n+  struct rename_map_elt_s tmp;\n+  PTR *slot;\n+\n+  tmp.old_name = old_name;\n+  slot = htab_find_slot (map, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((rename_map_elt) *slot)->expr;\n+\n+  return old_name;\n+}\n+\n+/* Register in MAP the rename tuple (old_name, expr).  */\n+\n+void\n+set_rename (htab_t map, tree old_name, tree expr)\n+{\n+  struct rename_map_elt_s tmp;\n+  PTR *slot;\n+\n+  if (old_name == expr)\n+    return;\n+\n+  tmp.old_name = old_name;\n+  slot = htab_find_slot (map, &tmp, INSERT);\n+\n+  if (!slot)\n+    return;\n+\n+  if (*slot)\n+    free (*slot);\n+\n+  *slot = new_rename_map_elt (old_name, expr);\n+}\n+\n+/* Adjusts the phi nodes in the block BB for variables defined in\n+   SCOP_REGION and used outside the SCOP_REGION.  The code generation\n+   moves SCOP_REGION in the else clause of an \"if (1)\" and generates\n+   code in the then clause:\n+\n+   | if (1)\n+   |   generated code from REGION;\n+   | else\n+   |   REGION;\n+\n+   To adjust the phi nodes after the condition, the RENAME_MAP is\n+   used.  */\n+\n+void\n+sese_adjust_liveout_phis (sese region, htab_t rename_map, basic_block bb,\n+\t\t\t  edge false_e, edge true_e)\n+{\n+  gimple_stmt_iterator si;\n+\n+  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      unsigned i;\n+      unsigned false_i = 0;\n+      gimple phi = gsi_stmt (si);\n+\n+      if (!is_gimple_reg (PHI_RESULT (phi)))\n+\t{\n+\t  sese_adjust_vphi (region, phi, true_e);\n+\t  continue;\n+\t}\n+\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\tif (gimple_phi_arg_edge (phi, i) == false_e)\n+\t  {\n+\t    false_i = i;\n+\t    break;\n+\t  }\n+\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\tif (gimple_phi_arg_edge (phi, i) == true_e)\n+\t  {\n+\t    tree old_name = gimple_phi_arg_def (phi, false_i);\n+\t    tree expr = get_rename (rename_map, old_name);\n+\t    gimple_seq stmts;\n+\n+\t    gcc_assert (old_name != expr);\n+\n+\t    if (TREE_CODE (expr) != SSA_NAME\n+\t\t&& is_gimple_reg (old_name))\n+\t      {\n+\t\ttree type = TREE_TYPE (old_name);\n+\t\ttree var = create_tmp_var (type, \"var\");\n+\n+\t\texpr = build2 (MODIFY_EXPR, type, var, expr);\n+\t\texpr = force_gimple_operand (expr, &stmts, true, NULL);\n+\t\tgsi_insert_seq_on_edge_immediate (true_e, stmts);\n+\t      }\n+\n+\t    SET_PHI_ARG_DEF (phi, i, expr);\n+\t  }\n+    }\n+}\n+\n+/* Rename the SSA_NAMEs used in STMT and that appear in MAP.  */\n+\n+static void \n+rename_variables_in_stmt (gimple stmt, htab_t map, gimple_stmt_iterator *insert_gsi)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      tree expr = get_rename (map, use);\n+      tree type_use = TREE_TYPE (use);\n+      tree type_expr = TREE_TYPE (expr);\n+      gimple_seq stmts;\n+\n+      if (use == expr)\n+\tcontinue;\n+\n+      if (type_use != type_expr\n+\t  || (TREE_CODE (expr) != SSA_NAME\n+\t      && is_gimple_reg (use)))\n+\t{\n+\t  tree var = create_tmp_var (type_use, \"var\");\n+\n+\t  if (type_use != type_expr)\n+\t    expr = fold_convert (type_use, expr);\n+\n+\t  expr = build2 (MODIFY_EXPR, type_use, var, expr);\n+\t  expr = force_gimple_operand (expr, &stmts, true, NULL);\n+\t  gsi_insert_seq_before (insert_gsi, stmts, GSI_SAME_STMT);\n+\t}\n+\n+      replace_exp (use_p, expr);\n+    }\n+\n+  update_stmt (stmt);\n+}\n+\n+/* Returns true if NAME is a parameter of SESE.  */\n+\n+static bool\n+is_parameter (sese region, tree name)\n+{\n+  int i;\n+  tree p;\n+\n+  for (i = 0; VEC_iterate (tree, SESE_PARAMS (region), i, p); i++)\n+    if (p == name)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Returns true if NAME is an induction variable.  */\n+\n+static bool\n+is_iv (tree name)\n+{\n+  return gimple_code (SSA_NAME_DEF_STMT (name)) == GIMPLE_PHI;\n+}\n+\n+static void expand_scalar_variables_stmt (gimple, basic_block, sese,\n+\t\t\t\t\t  htab_t, gimple_stmt_iterator *);\n+static tree\n+expand_scalar_variables_expr (tree, tree, enum tree_code, tree, basic_block,\n+\t\t\t      sese, htab_t, gimple_stmt_iterator *);\n+\n+static tree\n+expand_scalar_variables_call (gimple stmt, basic_block bb, sese region,\n+\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n+{\n+  int i, nargs = gimple_call_num_args (stmt);\n+  VEC (tree, gc) *args = VEC_alloc (tree, gc, nargs);\n+  tree fn_type = TREE_TYPE (gimple_call_fn (stmt));\n+  tree fn = gimple_call_fndecl (stmt);\n+  tree call_expr, var, lhs;\n+  gimple call;\n+\n+  for (i = 0; i < nargs; i++)\n+    {\n+      tree arg = gimple_call_arg (stmt, i);\n+      tree t = TREE_TYPE (arg);\n+\n+      var = create_tmp_var (t, \"var\");\n+      arg = expand_scalar_variables_expr (t, arg, TREE_CODE (arg), NULL,\n+\t\t\t\t\t  bb, region, map, gsi);\n+      arg = build2 (MODIFY_EXPR, t, var, arg);\n+      arg = force_gimple_operand_gsi (gsi, arg, true, NULL,\n+\t\t\t\t      true, GSI_SAME_STMT);\n+      VEC_quick_push (tree, args, arg);\n+    }\n+\n+  lhs = gimple_call_lhs (stmt);\n+  var = create_tmp_var (TREE_TYPE (lhs), \"var\");\n+  call_expr = build_call_vec (fn_type, fn, args);\n+  call = gimple_build_call_from_tree (call_expr);\n+  var = make_ssa_name (var, call);\n+  gimple_call_set_lhs (call, var);\n+  gsi_insert_before (gsi, call, GSI_SAME_STMT);\n+\n+  return var;\n+}\n+\n+/* Copies at GSI all the scalar computations on which the ssa_name OP0\n+   depends on in the SESE: these are all the scalar variables used in\n+   the definition of OP0, that are defined outside BB and still in the\n+   SESE, i.e. not a parameter of the SESE.  The expression that is\n+   returned contains only induction variables from the generated code:\n+   MAP contains the induction variables renaming mapping, and is used\n+   to translate the names of induction variables.  */\n+\n+static tree\n+expand_scalar_variables_ssa_name (tree op0, basic_block bb,\n+\t\t\t\t  sese region, htab_t map, \n+\t\t\t\t  gimple_stmt_iterator *gsi)\n+{\n+  gimple def_stmt;\n+  tree new_op;\n+      \n+  if (is_parameter (region, op0)\n+      || is_iv (op0))\n+    return get_rename (map, op0);\n+      \n+  def_stmt = SSA_NAME_DEF_STMT (op0);\n+\n+  /* Check whether we already have a rename for OP0.  */\n+  new_op = get_rename (map, op0);\n+\n+  if (new_op != op0\n+      && gimple_bb (SSA_NAME_DEF_STMT (new_op)) == bb)\n+    return new_op;\n+      \n+  if (gimple_bb (def_stmt) == bb)\n+    {\n+      /* If the defining statement is in the basic block already\n+\t we do not need to create a new expression for it, we\n+\t only need to ensure its operands are expanded.  */\n+      expand_scalar_variables_stmt (def_stmt, bb, region, map, gsi);\n+      return new_op;\n+    }\n+  else\n+    {\n+      if (!gimple_bb (def_stmt)\n+\t  || !bb_in_sese_p (gimple_bb (def_stmt), region))\n+\treturn new_op;\n+\n+      switch (gimple_code (def_stmt))\n+\t{\n+\tcase GIMPLE_ASSIGN:\n+\t  {\n+\t    tree var0 = gimple_assign_rhs1 (def_stmt);\n+\t    enum tree_code subcode = gimple_assign_rhs_code (def_stmt);\n+\t    tree var1 = gimple_assign_rhs2 (def_stmt);\n+\t    tree type = gimple_expr_type (def_stmt);\n+\n+\t    return expand_scalar_variables_expr (type, var0, subcode, var1, bb,\n+\t\t\t\t\t\t region, map, gsi);\n+\t  }\n+\n+\tcase GIMPLE_CALL:\n+\t  return expand_scalar_variables_call (def_stmt, bb, region, map, gsi);\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  return new_op;\n+\t}\n+    }\n+}\n+\n+/* Copies at GSI all the scalar computations on which the expression\n+   OP0 CODE OP1 depends on in the SESE: these are all the scalar\n+   variables used in OP0 and OP1, defined outside BB and still defined\n+   in the SESE, i.e. not a parameter of the SESE.  The expression that\n+   is returned contains only induction variables from the generated\n+   code: MAP contains the induction variables renaming mapping, and is\n+   used to translate the names of induction variables.  */\n+\n+static tree\n+expand_scalar_variables_expr (tree type, tree op0, enum tree_code code, \n+\t\t\t      tree op1, basic_block bb, sese region, \n+\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n+{\n+  if (TREE_CODE_CLASS (code) == tcc_constant\n+      || TREE_CODE_CLASS (code) == tcc_declaration)\n+    return op0;\n+\n+  /* For data references we have to duplicate also its memory\n+     indexing.  */\n+  if (TREE_CODE_CLASS (code) == tcc_reference)\n+    {\n+      switch (code)\n+\t{\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n+\t  {\n+\t    tree op = TREE_OPERAND (op0, 0);\n+\t    tree res = expand_scalar_variables_expr\n+\t      (type, op, TREE_CODE (op), NULL, bb, region, map, gsi);\n+\t    return build1 (code, type, res);\n+\t  }\n+\n+\tcase INDIRECT_REF:\n+\t  {\n+\t    tree old_name = TREE_OPERAND (op0, 0);\n+\t    tree expr = expand_scalar_variables_ssa_name\n+\t      (old_name, bb, region, map, gsi);\n+\n+\t    if (TREE_CODE (expr) != SSA_NAME\n+\t\t&& is_gimple_reg (old_name))\n+\t      {\n+\t\ttree type = TREE_TYPE (old_name);\n+\t\ttree var = create_tmp_var (type, \"var\");\n+\n+\t\texpr = build2 (MODIFY_EXPR, type, var, expr);\n+\t\texpr = force_gimple_operand_gsi (gsi, expr, true, NULL,\n+\t\t\t\t\t\t true, GSI_SAME_STMT);\n+\t      }\n+\n+\t    return fold_build1 (code, type, expr);\n+\t  }\n+\n+\tcase ARRAY_REF:\n+\t  {\n+\t    tree op00 = TREE_OPERAND (op0, 0);\n+\t    tree op01 = TREE_OPERAND (op0, 1);\n+\t    tree op02 = TREE_OPERAND (op0, 2);\n+\t    tree op03 = TREE_OPERAND (op0, 3);\n+\t    tree base = expand_scalar_variables_expr\n+\t      (TREE_TYPE (op00), op00, TREE_CODE (op00), NULL, bb, region,\n+\t       map, gsi);\n+\t    tree subscript = expand_scalar_variables_expr\n+\t      (TREE_TYPE (op01), op01, TREE_CODE (op01), NULL, bb, region,\n+\t       map, gsi);\n+\n+\t    return build4 (ARRAY_REF, type, base, subscript, op02, op03);\n+\t  }\n+\n+\tdefault:\n+\t  /* The above cases should catch everything.  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n+    {\n+      tree op0_type = TREE_TYPE (op0);\n+      enum tree_code op0_code = TREE_CODE (op0);\n+      tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n+\t\t\t\t\t\t    NULL, bb, region, map, gsi);\n+  \n+      return fold_build1 (code, type, op0_expr);\n+    }\n+\n+  if (TREE_CODE_CLASS (code) == tcc_binary\n+      || TREE_CODE_CLASS (code) == tcc_comparison)\n+    {\n+      tree op0_type = TREE_TYPE (op0);\n+      enum tree_code op0_code = TREE_CODE (op0);\n+      tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n+\t\t\t\t\t\t    NULL, bb, region, map, gsi);\n+      tree op1_type = TREE_TYPE (op1);\n+      enum tree_code op1_code = TREE_CODE (op1);\n+      tree op1_expr = expand_scalar_variables_expr (op1_type, op1, op1_code,\n+\t\t\t\t\t\t    NULL, bb, region, map, gsi);\n+\n+      return fold_build2 (code, type, op0_expr, op1_expr);\n+    }\n+\n+  if (code == SSA_NAME)\n+    return expand_scalar_variables_ssa_name (op0, bb, region, map, gsi);\n+\n+  if (code == ADDR_EXPR)\n+    return op0;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Copies at the beginning of BB all the scalar computations on which\n+   STMT depends on in the SESE: these are all the scalar variables used\n+   in STMT, defined outside BB and still defined in the SESE, i.e. not a\n+   parameter of the SESE.  The expression that is returned contains\n+   only induction variables from the generated code: MAP contains the\n+   induction variables renaming mapping, and is used to translate the\n+   names of induction variables.  */\n+ \n+static void\n+expand_scalar_variables_stmt (gimple stmt, basic_block bb, sese region,\n+\t\t\t      htab_t map, gimple_stmt_iterator *gsi)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      tree type = TREE_TYPE (use);\n+      enum tree_code code = TREE_CODE (use);\n+      tree use_expr;\n+\n+      if (!is_gimple_reg (use))\n+\tcontinue;\n+\n+      /* Don't expand USE if we already have a rename for it.  */\n+      use_expr = get_rename (map, use);\n+      if (use_expr != use)\n+\tcontinue;\n+\n+      use_expr = expand_scalar_variables_expr (type, use, code, NULL, bb,\n+\t\t\t\t\t       region, map, gsi);\n+      use_expr = fold_convert (type, use_expr);\n+\n+      if (use_expr == use)\n+\tcontinue;\n+\n+      if (TREE_CODE (use_expr) != SSA_NAME)\n+\t{\n+\t  tree var = create_tmp_var (type, \"var\");\n+\n+\t  use_expr = build2 (MODIFY_EXPR, type, var, use_expr);\n+\t  use_expr = force_gimple_operand_gsi (gsi, use_expr, true, NULL,\n+\t\t\t\t\t       true, GSI_SAME_STMT);\n+\t}\n+\n+      replace_exp (use_p, use_expr);\n+    }\n+\n+  update_stmt (stmt);\n+}\n+\n+/* Copies at the beginning of BB all the scalar computations on which\n+   BB depends on in the SESE: these are all the scalar variables used\n+   in BB, defined outside BB and still defined in the SESE, i.e. not a\n+   parameter of the SESE.  The expression that is returned contains\n+   only induction variables from the generated code: MAP contains the\n+   induction variables renaming mapping, and is used to translate the\n+   names of induction variables.  */\n+\n+static void \n+expand_scalar_variables (basic_block bb, sese region, htab_t map)\n+{\n+  gimple_stmt_iterator gsi;\n+  \n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      expand_scalar_variables_stmt (stmt, bb, region, map, &gsi);\n+      gsi_next (&gsi);\n+    }\n+}\n+\n+/* Rename all the SSA_NAMEs from block BB according to the MAP.  */\n+\n+static void \n+rename_variables (basic_block bb, htab_t map)\n+{\n+  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator insert_gsi = gsi_start_bb (bb);\n+  \n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    rename_variables_in_stmt (gsi_stmt (gsi), map, &insert_gsi);\n+}\n+\n+/* Remove condition from BB.  */\n+\n+static void\n+remove_condition (basic_block bb)\n+{\n+  gimple last = last_stmt (bb);\n+\n+  if (last && gimple_code (last) == GIMPLE_COND)\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+      gsi_remove (&gsi, true);\n+    }\n+}\n+\n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag set.  */\n+\n+edge\n+get_true_edge_from_guard_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_TRUE_VALUE) \n+      return e;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag cleared.  */\n+\n+edge\n+get_false_edge_from_guard_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_TRUE_VALUE)) \n+      return e;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Returns true when NAME is defined in LOOP.  */\n+\n+static bool\n+defined_in_loop_p (tree name, loop_p loop)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (name);\n+\n+  return (gimple_bb (stmt)->loop_father == loop);\n+}\n+\n+/* Returns the gimple statement that uses NAME outside the loop it is\n+   defined in, returns NULL if there is no such loop close phi node.\n+   An invariant of the loop closed SSA form is that the only use of a\n+   variable, outside the loop it is defined in, is in the loop close\n+   phi node that just follows the loop.  */\n+\n+static gimple\n+alive_after_loop (tree name)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+  loop_p loop = gimple_bb (SSA_NAME_DEF_STMT (name))->loop_father;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n+    {\n+      gimple stmt = USE_STMT (use_p);\n+\n+      if (gimple_code (stmt) == GIMPLE_PHI\n+\t  && gimple_bb (stmt)->loop_father != loop)\n+\treturn stmt;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Return true if a close phi has not yet been inserted for the use of\n+   variable NAME on the single exit of LOOP.  */\n+\n+static bool\n+close_phi_not_yet_inserted_p (loop_p loop, tree name)\n+{\n+  gimple_stmt_iterator psi;\n+  basic_block bb = single_exit (loop)->dest;\n+\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    if (gimple_phi_arg_def (gsi_stmt (psi), 0) == name)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* A structure for passing parameters to add_loop_exit_phis.  */\n+\n+typedef struct alep {\n+  loop_p loop;\n+  VEC (rename_map_elt, heap) *new_renames;\n+} *alep_p;\n+\n+/* Helper function for htab_traverse in insert_loop_close_phis.  */\n+\n+static int\n+add_loop_exit_phis (void **slot, void *data)\n+{\n+  struct rename_map_elt_s *entry;\n+  alep_p a;\n+  loop_p loop;\n+  tree expr, new_name;\n+  bool def_in_loop_p, used_outside_p, need_close_phi_p;\n+  gimple old_close_phi;\n+\n+  if (!slot || !data)\n+    return 1;\n+\n+  entry = (struct rename_map_elt_s *) *slot;\n+  a = (alep_p) data;\n+  loop = a->loop;\n+  expr = entry->expr;\n+\n+  if (TREE_CODE (expr) != SSA_NAME)\n+    return 1;\n+\n+  new_name = expr;\n+  def_in_loop_p = defined_in_loop_p (new_name, loop);\n+  old_close_phi = alive_after_loop (entry->old_name);\n+  used_outside_p = (old_close_phi != NULL);\n+  need_close_phi_p = (def_in_loop_p && used_outside_p\n+\t\t      && close_phi_not_yet_inserted_p (loop, new_name));\n+\n+  /* Insert a loop close phi node.  */\n+  if (need_close_phi_p)\n+    {\n+      basic_block bb = single_exit (loop)->dest;\n+      gimple phi = create_phi_node (new_name, bb);\n+      tree new_res = create_new_def_for (gimple_phi_result (phi), phi,\n+\t\t\t\t\t gimple_phi_result_ptr (phi));\n+\n+      add_phi_arg (phi, new_name, single_pred_edge (bb), UNKNOWN_LOCATION);\n+      VEC_safe_push (rename_map_elt, heap, a->new_renames,\n+\t\t     new_rename_map_elt (gimple_phi_result (old_close_phi),\n+\t\t\t\t\t new_res));\n+    }\n+\n+  /* Remove the old rename from the map.  */\n+  if (def_in_loop_p && *slot)\n+    {\n+      free (*slot);\n+      *slot = NULL;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Traverses MAP and removes from it all the tuples (OLD, NEW) where\n+   NEW is defined in LOOP.  Inserts on the exit of LOOP the close phi\n+   node \"RES = phi (NEW)\" corresponding to \"OLD_RES = phi (OLD)\" in\n+   the original code.  Inserts in MAP the tuple (OLD_RES, RES).  */\n+\n+void\n+insert_loop_close_phis (htab_t map, loop_p loop)\n+{\n+  int i;\n+  struct alep a;\n+  rename_map_elt elt;\n+\n+  a.loop = loop;\n+  a.new_renames = VEC_alloc (rename_map_elt, heap, 3);\n+  update_ssa (TODO_update_ssa);\n+  htab_traverse (map, add_loop_exit_phis, &a);\n+  update_ssa (TODO_update_ssa);\n+\n+  for (i = 0; VEC_iterate (rename_map_elt, a.new_renames, i, elt); i++)\n+    {\n+      set_rename (map, elt->old_name, elt->expr);\n+      free (elt);\n+    }\n+\n+  VEC_free (rename_map_elt, heap, a.new_renames);\n+}\n+\n+/* Helper structure for htab_traverse in insert_guard_phis.  */\n+\n+struct igp {\n+  basic_block bb;\n+  edge true_edge, false_edge;\n+  htab_t before_guard;\n+};\n+\n+/* Return the default name that is before the guard.  */\n+\n+static tree\n+default_before_guard (htab_t before_guard, tree old_name)\n+{\n+  tree res = get_rename (before_guard, old_name);\n+\n+  if (res == old_name)\n+    {\n+      if (is_gimple_reg (res))\n+\treturn fold_convert (TREE_TYPE (res), integer_zero_node);\n+      return gimple_default_def (cfun, SSA_NAME_VAR (res));\n+    }\n+\n+  return res;\n+}\n+\n+/* Helper function for htab_traverse in insert_guard_phis.  */\n+\n+static int\n+add_guard_exit_phis (void **slot, void *s)\n+{\n+  struct rename_map_elt_s *entry = (struct rename_map_elt_s *) *slot;\n+  struct igp *i = (struct igp *) s;\n+  basic_block bb = i->bb;\n+  edge true_edge = i->true_edge;\n+  edge false_edge = i->false_edge;\n+  tree name1 = entry->expr;\n+  tree name2 = default_before_guard (i->before_guard, entry->old_name);\n+  gimple phi;\n+  tree res;\n+  gimple_seq stmts;\n+\n+  /* Nothing to be merged if the name before the guard is the same as\n+     the one after.  */\n+  if (name1 == name2)\n+    return 1;\n+\n+  if (TREE_TYPE (name1) != TREE_TYPE (name2))\n+    name1 = fold_convert (TREE_TYPE (name2), name1);\n+\n+  if (TREE_CODE (name1) != SSA_NAME\n+      && (TREE_CODE (name2) != SSA_NAME\n+\t  || is_gimple_reg (name2)))\n+    {\n+      tree type = TREE_TYPE (name2);\n+      tree var = create_tmp_var (type, \"var\");\n+\n+      name1 = build2 (MODIFY_EXPR, type, var, name1);\n+      name1 = force_gimple_operand (name1, &stmts, true, NULL);\n+      gsi_insert_seq_on_edge_immediate (true_edge, stmts);\n+    }\n+\n+  phi = create_phi_node (entry->old_name, bb);\n+  res = create_new_def_for (gimple_phi_result (phi), phi,\n+\t\t\t    gimple_phi_result_ptr (phi));\n+\n+  add_phi_arg (phi, name1, true_edge, UNKNOWN_LOCATION);\n+  add_phi_arg (phi, name2, false_edge, UNKNOWN_LOCATION);\n+\n+  entry->expr = res;\n+  *slot = entry;\n+  return 1;\n+}\n+\n+/* Iterate over RENAME_MAP and get tuples of the form (OLD, NAME1).\n+   If there is a correspondent tuple (OLD, NAME2) in BEFORE_GUARD,\n+   with NAME1 different than NAME2, then insert in BB the phi node:\n+   \n+   | RES = phi (NAME1 (on TRUE_EDGE), NAME2 (on FALSE_EDGE))\"\n+\n+   if there is no tuple for OLD in BEFORE_GUARD, insert\n+\n+   | RES = phi (NAME1 (on TRUE_EDGE),\n+   |            DEFAULT_DEFINITION of NAME1 (on FALSE_EDGE))\".\n+\n+   Finally register in RENAME_MAP the tuple (OLD, RES).  */\n+\n+void\n+insert_guard_phis (basic_block bb, edge true_edge, edge false_edge,\n+\t\t   htab_t before_guard, htab_t rename_map)\n+{\n+  struct igp i;\n+  i.bb = bb;\n+  i.true_edge = true_edge;\n+  i.false_edge = false_edge;\n+  i.before_guard = before_guard;\n+\n+  update_ssa (TODO_update_ssa);\n+  htab_traverse (rename_map, add_guard_exit_phis, &i);\n+  update_ssa (TODO_update_ssa);\n+}\n+\n+/* Create a duplicate of the basic block BB.  NOTE: This does not\n+   preserve SSA form.  */\n+\n+static void\n+graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n+{\n+  gimple_stmt_iterator gsi, gsi_tgt;\n+\n+  gsi_tgt = gsi_start_bb (new_bb);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      def_operand_p def_p;\n+      ssa_op_iter op_iter;\n+      int region;\n+      gimple stmt = gsi_stmt (gsi);\n+      gimple copy;\n+\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tcontinue;\n+\n+      /* Create a new copy of STMT and duplicate STMT's virtual\n+\t operands.  */\n+      copy = gimple_copy (stmt);\n+      gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n+      mark_sym_for_renaming (gimple_vop (cfun));\n+\n+      region = lookup_stmt_eh_region (stmt);\n+      if (region >= 0)\n+\tadd_stmt_to_eh_region (copy, region);\n+      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n+\n+      /* Create new names for all the definitions created by COPY and\n+\t add replacement mappings for each new name.  */\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, copy, op_iter, SSA_OP_ALL_DEFS)\n+\t{\n+\t  tree old_name = DEF_FROM_PTR (def_p);\n+\t  tree new_name = create_new_def_for (old_name, copy, def_p);\n+\t  set_rename (map, old_name, new_name);\n+\t}\n+    }\n+}\n+\n+/* Copies BB and includes in the copied BB all the statements that can\n+   be reached following the use-def chains from the memory accesses,\n+   and returns the next edge following this new block.  */\n+ \n+edge\n+copy_bb_and_scalar_dependences (basic_block bb, sese region,\n+\t\t\t\tedge next_e, htab_t map)\n+{\n+  basic_block new_bb = split_edge (next_e);\n+\n+  next_e = single_succ_edge (new_bb);\n+  graphite_copy_stmts_from_block (bb, new_bb, map);\n+  remove_condition (new_bb);\n+  remove_phi_nodes (new_bb);\n+  expand_scalar_variables (new_bb, region, map);\n+  rename_variables (new_bb, map);\n+\n+  return next_e;\n+}\n+\n+/* Returns the outermost loop in SCOP that contains BB.  */\n+\n+struct loop *\n+outermost_loop_in_sese (sese region, basic_block bb)\n+{\n+  struct loop *nest;\n+\n+  nest = bb->loop_father;\n+  while (loop_outer (nest)\n+\t && loop_in_sese_p (loop_outer (nest), region))\n+    nest = loop_outer (nest);\n+\n+  return nest;\n+}\n+\n+/* Sets the false region of an IF_REGION to REGION.  */\n+\n+void\n+if_region_set_false_region (ifsese if_region, sese region)\n+{\n+  basic_block condition = if_region_get_condition_block (if_region);\n+  edge false_edge = get_false_edge_from_guard_bb (condition);\n+  basic_block dummy = false_edge->dest;\n+  edge entry_region = SESE_ENTRY (region);\n+  edge exit_region = SESE_EXIT (region);\n+  basic_block before_region = entry_region->src;\n+  basic_block last_in_region = exit_region->src;\n+  void **slot = htab_find_slot_with_hash (current_loops->exits, exit_region,\n+\t\t\t\t\t  htab_hash_pointer (exit_region),\n+\t\t\t\t\t  NO_INSERT);\n+\n+  entry_region->flags = false_edge->flags;\n+  false_edge->flags = exit_region->flags;\n+\n+  redirect_edge_pred (entry_region, condition);\n+  redirect_edge_pred (exit_region, before_region);\n+  redirect_edge_pred (false_edge, last_in_region);\n+  redirect_edge_succ (false_edge, single_succ (dummy));\n+  delete_basic_block (dummy);\n+\n+  exit_region->flags = EDGE_FALLTHRU;\n+  recompute_all_dominators ();\n+\n+  SESE_EXIT (region) = false_edge;\n+  if_region->false_region = region;\n+\n+  if (slot)\n+    {\n+      struct loop_exit *loop_exit = GGC_CNEW (struct loop_exit);\n+\n+      memcpy (loop_exit, *((struct loop_exit **) slot), sizeof (struct loop_exit));\n+      htab_clear_slot (current_loops->exits, slot);\n+\n+      slot = htab_find_slot_with_hash (current_loops->exits, false_edge,\n+\t\t\t\t       htab_hash_pointer (false_edge),\n+\t\t\t\t       INSERT);\n+      loop_exit->e = false_edge;\n+      *slot = loop_exit;\n+      false_edge->src->loop_father->exits->next = loop_exit;\n+    }\n+}\n+\n+/* Creates an IFSESE with CONDITION on edge ENTRY.  */\n+\n+ifsese\n+create_if_region_on_edge (edge entry, tree condition)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  sese sese_region = GGC_NEW (struct sese_s);\n+  sese true_region = GGC_NEW (struct sese_s);\n+  sese false_region = GGC_NEW (struct sese_s);\n+  ifsese if_region = GGC_NEW (struct ifsese_s);\n+  edge exit = create_empty_if_region_on_edge (entry, condition);\n+\n+  if_region->region = sese_region;\n+  if_region->region->entry = entry;\n+  if_region->region->exit = exit;\n+\n+  FOR_EACH_EDGE (e, ei, entry->dest->succs)\n+    {\n+      if (e->flags & EDGE_TRUE_VALUE)\n+\t{\n+\t  true_region->entry = e;\n+\t  true_region->exit = single_succ_edge (e->dest);\n+\t  if_region->true_region = true_region;\n+\t}\n+      else if (e->flags & EDGE_FALSE_VALUE)\n+\t{\n+\t  false_region->entry = e;\n+\t  false_region->exit = single_succ_edge (e->dest);\n+\t  if_region->false_region = false_region;\n+\t}\n+    }\n+\n+  return if_region;\n+}\n+\n+/* Moves REGION in a condition expression:\n+   | if (1)\n+   |   ;\n+   | else\n+   |   REGION;\n+*/\n+\n+ifsese\n+move_sese_in_condition (sese region)\n+{\n+  basic_block pred_block = split_edge (SESE_ENTRY (region));\n+  ifsese if_region = NULL;\n+\n+  SESE_ENTRY (region) = single_succ_edge (pred_block);\n+  if_region = create_if_region_on_edge (single_pred_edge (pred_block), integer_one_node);\n+  if_region_set_false_region (if_region, region);\n+\n+  return if_region;\n+}\n+\n+/* Reset the loop->aux pointer for all loops in REGION.  */\n+\n+void\n+sese_reset_aux_in_loops (sese region)\n+{\n+  int i;\n+  loop_p loop;\n+\n+  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+    loop->aux = NULL;\n+}\n+\n+/* Returns the scalar evolution of T in REGION.  Every variable that\n+   is not defined in the REGION is considered a parameter.  */\n+\n+tree\n+scalar_evolution_in_region (sese region, loop_p loop, tree t)\n+{\n+  gimple def;\n+  struct loop *def_loop;\n+  basic_block before = block_before_sese (region);\n+\n+  if (TREE_CODE (t) != SSA_NAME\n+      || loop_in_sese_p (loop, region))\n+    return instantiate_scev (before, loop,\n+\t\t\t     analyze_scalar_evolution (loop, t));\n+\n+  if (!defined_in_sese_p (t, region))\n+    return t;\n+\n+  def = SSA_NAME_DEF_STMT (t);\n+  def_loop = loop_containing_stmt (def);\n+\n+  if (loop_in_sese_p (def_loop, region))\n+    {\n+      t = analyze_scalar_evolution (def_loop, t);\n+      def_loop = superloop_at_depth (def_loop, loop_depth (loop) + 1);\n+      t = compute_overall_effect_of_inner_loop (def_loop, t);\n+      return t;\n+    }\n+  else\n+    return instantiate_scev (before, loop, t);\n+}"}, {"sha": "ace63ba671967354f8e6328fca7d7f5bf2b60f1d", "filename": "gcc/sese.h", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2abae5f13adafd84ac3f4e2da2890da4515fd1fe/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "patch": "@@ -0,0 +1,475 @@\n+/* Single entry single exit control flow regions.\n+   Copyright (C) 2008, 2009  Free Software Foundation, Inc.\n+   Contributed by Jan Sjodin <jan.sjodin@amd.com> and\n+   Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SESE_H\n+#define GCC_SESE_H\n+\n+/* A Single Entry, Single Exit region is a part of the CFG delimited\n+   by two edges.  */\n+typedef struct sese_s\n+{\n+  /* Single ENTRY and single EXIT from the SESE region.  */\n+  edge entry, exit;\n+\n+  /* Parameters used within the SCOP.  */\n+  VEC (tree, heap) *params;\n+\n+  /* Used to quickly retrieve the index of a parameter in PARAMS.  */\n+  htab_t params_index;\n+\n+  /* Store the names of the parameters that are passed to CLooG.  */\n+  char **params_names;\n+\n+  /* Loops completely contained in the SCOP.  */\n+  bitmap loops;\n+  VEC (loop_p, heap) *loop_nest;\n+\n+  /* Are we allowed to add more params?  This is for debugging purpose.  We\n+     can only add new params before generating the bb domains, otherwise they\n+     become invalid.  */\n+  bool add_params;\n+} *sese;\n+\n+#define SESE_ENTRY(S) (S->entry)\n+#define SESE_ENTRY_BB(S) (S->entry->dest)\n+#define SESE_EXIT(S) (S->exit)\n+#define SESE_EXIT_BB(S) (S->exit->dest)\n+#define SESE_PARAMS(S) (S->params)\n+#define SESE_PARAMS_INDEX(S) (S->params_index)\n+#define SESE_PARAMS_NAMES(S) (S->params_names)\n+#define SESE_LOOPS(S) (S->loops)\n+#define SESE_LOOP_NEST(S) (S->loop_nest)\n+#define SESE_ADD_PARAMS(S) (S->add_params)\n+\n+extern sese new_sese (edge, edge);\n+extern void free_sese (sese);\n+extern void sese_insert_phis_for_liveouts (sese, basic_block, edge, edge);\n+extern void sese_adjust_liveout_phis (sese, htab_t, basic_block, edge, edge);\n+extern void build_sese_loop_nests (sese);\n+extern edge copy_bb_and_scalar_dependences (basic_block, sese, edge, htab_t);\n+extern struct loop *outermost_loop_in_sese (sese, basic_block);\n+extern void insert_loop_close_phis (htab_t, loop_p);\n+extern void insert_guard_phis (basic_block, edge, edge, htab_t, htab_t);\n+extern void sese_reset_aux_in_loops (sese);\n+extern tree scalar_evolution_in_region (sese, loop_p, tree);\n+\n+/* Check that SESE contains LOOP.  */\n+\n+static inline bool\n+sese_contains_loop (sese sese, struct loop *loop)\n+{\n+  return bitmap_bit_p (SESE_LOOPS (sese), loop->num);\n+}\n+\n+/* The number of parameters in REGION. */\n+\n+static inline unsigned\n+sese_nb_params (sese region)\n+{\n+  return VEC_length (tree, SESE_PARAMS (region));\n+}\n+\n+/* Checks whether BB is contained in the region delimited by ENTRY and\n+   EXIT blocks.  */\n+\n+static inline bool\n+bb_in_region (basic_block bb, basic_block entry, basic_block exit)\n+{\n+#ifdef ENABLE_CHECKING\n+  {\n+    edge e;\n+    edge_iterator ei;\n+\n+    /* Check that there are no edges coming in the region: all the\n+       predecessors of EXIT are dominated by ENTRY.  */\n+    FOR_EACH_EDGE (e, ei, exit->preds)\n+      dominated_by_p (CDI_DOMINATORS, e->src, entry);\n+ \n+    /* Check that there are no edges going out of the region: the\n+       entry is post-dominated by the exit.  FIXME: This cannot be\n+       checked right now as the CDI_POST_DOMINATORS are needed.  */\n+  }\n+#endif\n+\n+  return dominated_by_p (CDI_DOMINATORS, bb, entry)\n+\t && !(dominated_by_p (CDI_DOMINATORS, bb, exit)\n+\t      && !dominated_by_p (CDI_DOMINATORS, entry, exit));\n+}\n+\n+/* Checks whether BB is contained in the region delimited by ENTRY and\n+   EXIT blocks.  */\n+\n+static inline bool\n+bb_in_sese_p (basic_block bb, sese region)\n+{\n+  basic_block entry = SESE_ENTRY_BB (region);\n+  basic_block exit = SESE_EXIT_BB (region);\n+\n+  return bb_in_region (bb, entry, exit);\n+}\n+\n+/* Returns true when NAME is defined in REGION.  */\n+\n+static inline bool\n+defined_in_sese_p (tree name, sese region)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (name);\n+  basic_block bb = gimple_bb (stmt);\n+\n+  return bb && bb_in_sese_p (bb, region);\n+}\n+\n+/* Returns true when LOOP is in REGION.  */\n+\n+static inline bool \n+loop_in_sese_p (struct loop *loop, sese region)\n+{\n+  return (bb_in_sese_p (loop->header, region)\n+\t  && bb_in_sese_p (loop->latch, region));\n+}\n+\n+/* Returns the loop depth of LOOP in REGION.  The loop depth\n+   is the same as the normal loop depth, but limited by a region.\n+\n+   Example:\n+\n+   loop_0\n+     loop_1\n+       {\n+         S0 \n+            <- region start\n+         S1\n+\n+         loop_2\n+           S2\n+\n+         S3\n+            <- region end\n+       } \n+\n+    loop_0 does not exist in the region -> invalid\n+    loop_1 exists, but is not completely contained in the region -> depth 0\n+    loop_2 is completely contained -> depth 1  */\n+\n+static inline unsigned int\n+sese_loop_depth (sese region, loop_p loop)\n+{\n+  unsigned int depth = 0;\n+\n+  gcc_assert ((!loop_in_sese_p (loop, region)\n+\t       && (SESE_ENTRY_BB (region)->loop_father == loop\n+\t           || SESE_EXIT (region)->src->loop_father == loop))\n+              || loop_in_sese_p (loop, region));\n+\n+  while (loop_in_sese_p (loop, region))\n+    {\n+      depth++;\n+      loop = loop_outer (loop);\n+    }\n+\n+  return depth;\n+}\n+\n+/* Returns the block preceding the entry of a SESE.  */\n+\n+static inline basic_block\n+block_before_sese (sese sese)\n+{\n+  return SESE_ENTRY (sese)->src;\n+}\n+\n+/* Stores the INDEX in a vector for a given clast NAME.  */\n+\n+typedef struct clast_name_index {\n+  int index;\n+  const char *name;\n+} *clast_name_index_p;\n+\n+/* Returns a pointer to a new element of type clast_name_index_p built\n+   from NAME and INDEX.  */\n+\n+static inline clast_name_index_p\n+new_clast_name_index (const char *name, int index)\n+{\n+  clast_name_index_p res = XNEW (struct clast_name_index);\n+\n+  res->name = name;\n+  res->index = index;\n+  return res;\n+}\n+\n+/* For a given clast NAME, returns -1 if it does not correspond to any\n+   parameter, or otherwise, returns the index in the PARAMS or\n+   SCATTERING_DIMENSIONS vector.  */\n+\n+static inline int\n+clast_name_to_index (const char *name, htab_t index_table)\n+{\n+  struct clast_name_index tmp;\n+  PTR *slot;\n+\n+  tmp.name = name;\n+  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((struct clast_name_index *) *slot)->index;\n+\n+  return -1;\n+}\n+\n+/* Records in INDEX_TABLE the INDEX for NAME.  */\n+\n+static inline void\n+save_clast_name_index (htab_t index_table, const char *name, int index)\n+{\n+  struct clast_name_index tmp;\n+  PTR *slot;\n+\n+  tmp.name = name;\n+  slot = htab_find_slot (index_table, &tmp, INSERT);\n+\n+  if (slot)\n+    *slot = new_clast_name_index (name, index);\n+}\n+\n+/* Print to stderr the element ELT.  */\n+\n+static inline void\n+debug_clast_name_index (clast_name_index_p elt)\n+{\n+  fprintf (stderr, \"(index = %d, name = %s)\\n\", elt->index, elt->name);\n+}\n+\n+/* Helper function for debug_rename_map.  */\n+\n+static inline int\n+debug_clast_name_indexes_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+{\n+  struct clast_name_index *entry = (struct clast_name_index *) *slot;\n+  debug_clast_name_index (entry);\n+  return 1;\n+}\n+\n+/* Print to stderr all the elements of MAP.  */\n+\n+static inline void\n+debug_clast_name_indexes (htab_t map)\n+{\n+  htab_traverse (map, debug_clast_name_indexes_1, NULL);\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+static inline hashval_t\n+clast_name_index_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct clast_name_index *) elt)->name);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+static inline int\n+eq_clast_name_indexes (const void *e1, const void *e2)\n+{\n+  const struct clast_name_index *elt1 = (const struct clast_name_index *) e1;\n+  const struct clast_name_index *elt2 = (const struct clast_name_index *) e2;\n+\n+  return (elt1->name == elt2->name);\n+}\n+\n+\f\n+\n+/* A single entry single exit specialized for conditions.  */\n+\n+typedef struct ifsese_s {\n+  sese region;\n+  sese true_region;\n+  sese false_region;\n+} *ifsese;\n+\n+extern void if_region_set_false_region (ifsese, sese);\n+extern ifsese create_if_region_on_edge (edge, tree);\n+extern ifsese move_sese_in_condition (sese);\n+extern edge get_true_edge_from_guard_bb (basic_block);\n+extern edge get_false_edge_from_guard_bb (basic_block);\n+\n+static inline edge\n+if_region_entry (ifsese if_region)\n+{\n+  return SESE_ENTRY (if_region->region);\n+}\n+\n+static inline edge\n+if_region_exit (ifsese if_region)\n+{\n+  return SESE_EXIT (if_region->region);\n+}\n+\n+static inline basic_block\n+if_region_get_condition_block (ifsese if_region)\n+{\n+  return if_region_entry (if_region)->dest;\n+}\n+\n+/* Structure containing the mapping between the old names and the new\n+   names used after block copy in the new loop context.  */\n+typedef struct rename_map_elt_s\n+{\n+  tree old_name, expr;\n+} *rename_map_elt;\n+\n+DEF_VEC_P(rename_map_elt);\n+DEF_VEC_ALLOC_P (rename_map_elt, heap);\n+\n+extern void debug_rename_map (htab_t);\n+extern hashval_t rename_map_elt_info (const void *);\n+extern int eq_rename_map_elts (const void *, const void *);\n+extern void set_rename (htab_t, tree, tree);\n+\n+/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n+\n+static inline rename_map_elt\n+new_rename_map_elt (tree old_name, tree expr)\n+{\n+  rename_map_elt res;\n+  \n+  res = XNEW (struct rename_map_elt_s);\n+  res->old_name = old_name;\n+  res->expr = expr;\n+\n+  return res;\n+}\n+\n+/* Structure containing the mapping between the CLooG's induction\n+   variable and the type of the old induction variable.  */\n+typedef struct ivtype_map_elt_s\n+{\n+  tree type;\n+  const char *cloog_iv;\n+} *ivtype_map_elt;\n+\n+extern void debug_ivtype_map (htab_t);\n+extern hashval_t ivtype_map_elt_info (const void *);\n+extern int eq_ivtype_map_elts (const void *, const void *);\n+\n+/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n+\n+static inline ivtype_map_elt\n+new_ivtype_map_elt (const char *cloog_iv, tree type)\n+{\n+  ivtype_map_elt res;\n+  \n+  res = XNEW (struct ivtype_map_elt_s);\n+  res->cloog_iv = cloog_iv;\n+  res->type = type;\n+\n+  return res;\n+}\n+\n+/* Free and compute again all the dominators information.  */\n+\n+static inline void\n+recompute_all_dominators (void)\n+{\n+  mark_irreducible_loops ();\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+}\n+\n+typedef struct gimple_bb\n+{\n+  basic_block bb;\n+\n+  /* Lists containing the restrictions of the conditional statements\n+     dominating this bb.  This bb can only be executed, if all conditions\n+     are true.\n+ \n+     Example:\n+ \n+     for (i = 0; i <= 20; i++)\n+     {\n+       A\n+ \n+       if (2i <= 8)\n+         B\n+     }\n+ \n+     So for B there is an additional condition (2i <= 8).\n+ \n+     List of COND_EXPR and SWITCH_EXPR.  A COND_EXPR is true only if the\n+     corresponding element in CONDITION_CASES is not NULL_TREE.  For a\n+     SWITCH_EXPR the corresponding element in CONDITION_CASES is a\n+     CASE_LABEL_EXPR.  */\n+  VEC (gimple, heap) *conditions;\n+  VEC (gimple, heap) *condition_cases;\n+  VEC (data_reference_p, heap) *data_refs;\n+  htab_t cloog_iv_types;\n+} *gimple_bb_p;\n+\n+#define GBB_BB(GBB) GBB->bb\n+#define GBB_DATA_REFS(GBB) GBB->data_refs\n+#define GBB_CONDITIONS(GBB) GBB->conditions\n+#define GBB_CONDITION_CASES(GBB) GBB->condition_cases\n+#define GBB_CLOOG_IV_TYPES(GBB) GBB->cloog_iv_types\n+\n+/* Return the innermost loop that contains the basic block GBB.  */\n+\n+static inline struct loop *\n+gbb_loop (struct gimple_bb *gbb)\n+{\n+  return GBB_BB (gbb)->loop_father;\n+}\n+\n+/* Returns the gimple loop, that corresponds to the loop_iterator_INDEX.  \n+   If there is no corresponding gimple loop, we return NULL.  */\n+\n+static inline loop_p\n+gbb_loop_at_index (gimple_bb_p gbb, sese region, int index)\n+{\n+  loop_p loop = gbb_loop (gbb);\n+  int depth = sese_loop_depth (region, loop);\n+\n+  while (--depth > index)\n+    loop = loop_outer (loop);\n+\n+  gcc_assert (sese_contains_loop (region, loop));\n+\n+  return loop;\n+}\n+\n+/* The number of common loops in REGION for GBB1 and GBB2.  */\n+\n+static inline int\n+nb_common_loops (sese region, gimple_bb_p gbb1, gimple_bb_p gbb2)\n+{\n+  loop_p l1 = gbb_loop (gbb1);\n+  loop_p l2 = gbb_loop (gbb2);\n+  loop_p common = find_common_loop (l1, l2);\n+  \n+  return sese_loop_depth (region, common);\n+}\n+\n+extern void print_gimple_bb (FILE *, gimple_bb_p, int, int);\n+extern void debug_gbb (gimple_bb_p, int);\n+\n+#endif"}]}