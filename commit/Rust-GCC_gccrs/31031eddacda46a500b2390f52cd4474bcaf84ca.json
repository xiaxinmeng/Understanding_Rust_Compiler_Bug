{"sha": "31031eddacda46a500b2390f52cd4474bcaf84ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwMzFlZGRhY2RhNDZhNTAwYjIzOTBmNTJjZDQ0NzRiY2FmODRjYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-03T16:37:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-03T16:37:26Z"}, "message": "dummy commit before merge\n\nFrom-SVN: r18980", "tree": {"sha": "28111445709b1e369e559db59f8c46cf5b81a203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28111445709b1e369e559db59f8c46cf5b81a203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31031eddacda46a500b2390f52cd4474bcaf84ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31031eddacda46a500b2390f52cd4474bcaf84ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31031eddacda46a500b2390f52cd4474bcaf84ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31031eddacda46a500b2390f52cd4474bcaf84ca/comments", "author": null, "committer": null, "parents": [{"sha": "732dcb6f2a8254467d15cffc3cebf3467c4d010f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732dcb6f2a8254467d15cffc3cebf3467c4d010f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/732dcb6f2a8254467d15cffc3cebf3467c4d010f"}], "stats": {"total": 627, "additions": 408, "deletions": 219}, "files": [{"sha": "ade0f5ab5317b319df5548b82b828c23298c115c", "filename": "gcc/README.X11", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2FREADME.X11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2FREADME.X11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.X11?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -20,7 +20,7 @@ IF YOU THINK YOU MIGHT COMPILE X FOR SOLARIS 2, then you really don't\n need this patch: get /contrib/R5.SunOS5.patch.tar.Z from\n export.lcs.mit.edu instead.  It has everything you need to do the\n build for Solaris 2, sets you up to everything with GCC, and is\n-backward compatible with Sunos 4.*.  Get the the README\n+backward compatible with SunOS 4.*.  Get the the README\n (/contrib/R5.SunOS5.patch.README at export) for more info.\n \n If you see undefined symbols _dlopen, _dlsym, or _dlclose when linking"}, {"sha": "3e0e10a401fa4959205fe9260ce42201adb3b96a", "filename": "gcc/c-tree.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -177,7 +177,7 @@ extern tree convert_and_check\t\t\tPROTO((tree, tree));\n extern void overflow_warning\t\t\tPROTO((tree));\n extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n /* Read the rest of the current #-directive line.  */\n-extern char *get_directive_line                 STDIO_PROTO((FILE *));\n+extern char *get_directive_line                 PROTO((FILE *));\n /* Subroutine of build_binary_op, used for comparison operations.\n    See if the operands have both been converted from subword integer types\n    and, if so, perhaps change them both back to their original type.  */\n@@ -288,12 +288,9 @@ extern void pending_xref_error                  PROTO((void));\n extern void pop_c_function_context              PROTO((void));\n extern void pop_label_level                     PROTO((void));\n extern tree poplevel                            PROTO((int, int, int));\n-extern void print_lang_decl                     STDIO_PROTO((FILE *, tree,\n-\t\t\t\t\t\t\t     int));\n-extern void print_lang_identifier               STDIO_PROTO((FILE *, tree,\n-\t\t\t\t\t\t\t     int));\n-extern void print_lang_type                     STDIO_PROTO((FILE *, tree,\n-\t\t\t\t\t\t\t     int));\n+extern void print_lang_decl                     PROTO((FILE *, tree, int));\n+extern void print_lang_identifier               PROTO((FILE *, tree, int));\n+extern void print_lang_type                     PROTO((FILE *, tree, int));\n extern void push_c_function_context             PROTO((void));\n extern void push_label_level                    PROTO((void));\n extern void push_parm_decl                      PROTO((tree));"}, {"sha": "5269c5bae7e12e9460cbd209f61ca4ad5e8e9ed8", "filename": "gcc/cexp.y", "status": "modified", "additions": 104, "deletions": 64, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -29,29 +29,19 @@ Boston, MA 02111-1307, USA.\n #include <setjmp.h>\n /* #define YYDEBUG 1 */\n \n-/* The following symbols should be autoconfigured:\n-\tHAVE_STDLIB_H\n-\tSTDC_HEADERS\n-   In the mean time, we'll get by with approximations based\n-   on existing GCC configuration symbols.  */\n-\n-#ifdef POSIX\n-# ifndef HAVE_STDLIB_H\n-# define HAVE_STDLIB_H 1\n-# endif\n-# ifndef STDC_HEADERS\n-# define STDC_HEADERS 1\n-# endif\n-#endif /* defined (POSIX) */\n \n-#if STDC_HEADERS\n+#ifdef HAVE_STRING_H\n # include <string.h>\n #endif\n \n-#if HAVE_STDLIB_H || defined (MULTIBYTE_CHARS)\n+#ifdef HAVE_STDLIB_H\n # include <stdlib.h>\n #endif\n \n+#ifdef HAVE_LIMITS_H\n+# include <limits.h>\n+#endif\n+\n #ifdef MULTIBYTE_CHARS\n #include <locale.h>\n #endif\n@@ -87,18 +77,36 @@ struct arglist {\n #endif\n \n /* Find the largest host integer type and set its size and type.\n-   Don't blindly use `long'; on some crazy hosts it is shorter than `int'.  */\n+   Watch out: on some crazy hosts `long' is shorter than `int'.  */\n \n-#ifndef HOST_BITS_PER_WIDE_INT\n+#ifndef HOST_WIDE_INT\n+# if HAVE_INTTYPES_H\n+#  include <inttypes.h>\n+#  define HOST_WIDE_INT intmax_t\n+#  define unsigned_HOST_WIDE_INT uintmax_t\n+# else\n+#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)\n+#   define HOST_WIDE_INT int\n+#  else\n+#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG || ! (defined LONG_LONG_MAX || defined LLONG_MAX))\n+#   define HOST_WIDE_INT long\n+#  else\n+#   define HOST_WIDE_INT long long\n+#  endif\n+#  endif\n+# endif\n+#endif\n \n-#if HOST_BITS_PER_LONG > HOST_BITS_PER_INT\n-#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n-#define HOST_WIDE_INT long\n-#else\n-#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT\n-#define HOST_WIDE_INT int\n+#ifndef unsigned_HOST_WIDE_INT\n+#define unsigned_HOST_WIDE_INT unsigned HOST_WIDE_INT\n #endif\n \n+#ifndef CHAR_BIT\n+#define CHAR_BIT 8\n+#endif\n+\n+#ifndef HOST_BITS_PER_WIDE_INT\n+#define HOST_BITS_PER_WIDE_INT (CHAR_BIT * sizeof (HOST_WIDE_INT))\n #endif\n \n #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)\n@@ -137,11 +145,14 @@ struct arglist {\n \n #define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n \n-HOST_WIDE_INT parse_c_expression PROTO((char *));\n+HOST_WIDE_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n static void yyerror PROTO((char *)) __attribute__ ((noreturn));\n static HOST_WIDE_INT expression_value;\n+#ifdef TEST_EXP_READER\n+static int expression_signedp;\n+#endif\n \n static jmp_buf parse_return_error;\n \n@@ -152,6 +163,9 @@ static int keyword_parsing = 0;\n    This is a count, since unevaluated expressions can nest.  */\n static int skip_evaluation;\n \n+/* Nonzero means warn if undefined identifiers are evaluated.  */\n+static int warn_undef;\n+\n /* some external tables of character types */\n extern unsigned char is_idstart[], is_idchar[], is_space[];\n \n@@ -164,9 +178,6 @@ extern int traditional;\n /* Flag for -lang-c89.  */\n extern int c89;\n \n-/* Flag for -Wundef.  */\n-extern int warn_undef;\n-\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n@@ -199,17 +210,13 @@ extern int warn_undef;\n #define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n #endif\n \n-#if MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT\n-#define MAX_CHAR_TYPE_MASK (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE))\n-#else\n-#define MAX_CHAR_TYPE_MASK (~ (HOST_WIDE_INT) 0)\n-#endif\n+#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n+\t\t\t    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t\t    : ~ (HOST_WIDE_INT) 0)\n \n-#if MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT\n-#define MAX_WCHAR_TYPE_MASK (~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE))\n-#else\n-#define MAX_WCHAR_TYPE_MASK (~ (HOST_WIDE_INT) 0)\n-#endif\n+#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \\\n+\t\t\t     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n+\t\t\t     : ~ (HOST_WIDE_INT) 0)\n \n /* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n    Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n@@ -232,8 +239,8 @@ void pedwarn PRINTF_PROTO_1((char *, ...));\n void warning PRINTF_PROTO_1((char *, ...));\n \n static int parse_number PROTO((int));\n-static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned HOST_WIDE_INT));\n-static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned HOST_WIDE_INT));\n+static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n+static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));\n static void integer_overflow PROTO((void));\n \n /* `signedp' values */\n@@ -272,7 +279,12 @@ static void integer_overflow PROTO((void));\n %%\n \n start   :\texp1\n-\t\t{ expression_value = $1.value; }\n+\t\t{\n+\t\t  expression_value = $1.value;\n+#ifdef TEST_EXP_READER\n+\t\t  expression_signedp = $1.signedp;\n+#endif\n+\t\t}\n \t;\n \n /* Expressions, including the comma operator.  */\n@@ -324,7 +336,7 @@ exp\t:\texp '*' exp\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t* $3.value); }\n \t|\texp '/' exp\n \t\t\t{ if ($3.value == 0)\n@@ -341,7 +353,7 @@ exp\t:\texp '*' exp\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t/ $3.value); }\n \t|\texp '%' exp\n \t\t\t{ if ($3.value == 0)\n@@ -354,7 +366,7 @@ exp\t:\texp '*' exp\n \t\t\t  if ($$.signedp)\n \t\t\t    $$.value = $1.value % $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t% $3.value); }\n \t|\texp '+' exp\n \t\t\t{ $$.value = $1.value + $3.value;\n@@ -391,28 +403,28 @@ exp\t:\texp '*' exp\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value <= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t<= $3.value); }\n \t|\texp GEQ exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value >= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t>= $3.value); }\n \t|\texp '<' exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value < $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t< $3.value); }\n \t|\texp '>' exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value > $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t    $$.value = ((unsigned_HOST_WIDE_INT) $1.value\n \t\t\t\t\t> $3.value); }\n \t|\texp '&' exp\n \t\t\t{ $$.value = $1.value & $3.value;\n@@ -495,7 +507,7 @@ parse_number (olen)\n {\n   register char *p = lexptr;\n   register int c;\n-  register unsigned HOST_WIDE_INT n = 0, nd, max_over_base;\n+  register unsigned_HOST_WIDE_INT n = 0, nd, max_over_base;\n   register int base = 10;\n   register int len = olen;\n   register int overflow = 0;\n@@ -513,7 +525,7 @@ parse_number (olen)\n     }\n   }\n \n-  max_over_base = (unsigned HOST_WIDE_INT) -1 / base;\n+  max_over_base = (unsigned_HOST_WIDE_INT) -1 / base;\n \n   for (; len > 0; len--) {\n     c = *p++;\n@@ -684,7 +696,7 @@ yylex ()\n        It is mostly copied from c-lex.c.  */\n     {\n       register HOST_WIDE_INT result = 0;\n-      register num_chars = 0;\n+      register int num_chars = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n       int max_chars;\n       char *token_buffer;\n@@ -751,11 +763,11 @@ yylex ()\n \t\t      sizeof (\"__CHAR_UNSIGNED__\") - 1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & (~ (unsigned HOST_WIDE_INT) 0\n+\t      = result & (~ (unsigned_HOST_WIDE_INT) 0\n \t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~(~ (unsigned HOST_WIDE_INT) 0\n+\t      = result | ~(~ (unsigned_HOST_WIDE_INT) 0\n \t\t\t   >> (HOST_BITS_PER_WIDE_INT - num_bits));\n \t}\n       else\n@@ -962,7 +974,7 @@ parse_escape (string_ptr, result_mask)\n       }\n     case 'x':\n       {\n-\tregister unsigned HOST_WIDE_INT i = 0, overflow = 0;\n+\tregister unsigned_HOST_WIDE_INT i = 0, overflow = 0;\n \tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n@@ -1015,44 +1027,47 @@ integer_overflow ()\n static HOST_WIDE_INT\n left_shift (a, b)\n      struct constant *a;\n-     unsigned HOST_WIDE_INT b;\n+     unsigned_HOST_WIDE_INT b;\n {\n    /* It's unclear from the C standard whether shifts can overflow.\n       The following code ignores overflow; perhaps a C standard\n       interpretation ruling is needed.  */\n   if (b >= HOST_BITS_PER_WIDE_INT)\n     return 0;\n   else\n-    return (unsigned HOST_WIDE_INT) a->value << b;\n+    return (unsigned_HOST_WIDE_INT) a->value << b;\n }\n \n static HOST_WIDE_INT\n right_shift (a, b)\n      struct constant *a;\n-     unsigned HOST_WIDE_INT b;\n+     unsigned_HOST_WIDE_INT b;\n {\n   if (b >= HOST_BITS_PER_WIDE_INT)\n     return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;\n   else if (a->signedp)\n     return a->value >> b;\n   else\n-    return (unsigned HOST_WIDE_INT) a->value >> b;\n+    return (unsigned_HOST_WIDE_INT) a->value >> b;\n }\n \f\n /* This page contains the entry point to this file.  */\n \n /* Parse STRING as an expression, and complain if this fails\n-   to use up all of the contents of STRING.  */\n-/* STRING may contain '\\0' bytes; it is terminated by the first '\\n'\n-   outside a string constant, so that we can diagnose '\\0' properly.  */\n-/* We do not support C comments.  They should be removed before\n+   to use up all of the contents of STRING.\n+   STRING may contain '\\0' bytes; it is terminated by the first '\\n'\n+   outside a string constant, so that we can diagnose '\\0' properly.\n+   If WARN_UNDEFINED is nonzero, warn if undefined identifiers are evaluated.\n+   We do not support C comments.  They should be removed before\n    this function is called.  */\n \n HOST_WIDE_INT\n-parse_c_expression (string)\n+parse_c_expression (string, warn_undefined)\n      char *string;\n+     int warn_undefined;\n {\n   lexptr = string;\n+  warn_undef = warn_undefined;\n \n   /* if there is some sort of scanning error, just return 0 and assume\n      the parsing routine has printed an error message somewhere.\n@@ -1080,6 +1095,7 @@ int traditional;\n \n int main PROTO((int, char **));\n static void initialize_random_junk PROTO((void));\n+static void print_unsigned_host_wide_int PROTO((unsigned_HOST_WIDE_INT));\n \n /* Main program for testing purposes.  */\n int\n@@ -1089,6 +1105,7 @@ main (argc, argv)\n {\n   int n, c;\n   char buf[1024];\n+  unsigned_HOST_WIDE_INT u;\n \n   pedantic = 1 < argc;\n   traditional = 2 < argc;\n@@ -1104,12 +1121,35 @@ main (argc, argv)\n       n++;\n     if (c == EOF)\n       break;\n-    printf (\"parser returned %ld\\n\", (long) parse_c_expression (buf));\n+    parse_c_expression (buf, 1);\n+    printf (\"parser returned \");\n+    u = (unsigned_HOST_WIDE_INT) expression_value;\n+    if (expression_value < 0 && expression_signedp) {\n+      u = -u;\n+      printf (\"-\");\n+    }\n+    if (u == 0)\n+      printf (\"0\");\n+    else\n+      print_unsigned_host_wide_int (u);\n+    if (! expression_signedp)\n+      printf(\"u\");\n+    printf (\"\\n\");\n   }\n \n   return 0;\n }\n \n+static void\n+print_unsigned_host_wide_int (u)\n+     unsigned_HOST_WIDE_INT u;\n+{\n+  if (u) {\n+    print_unsigned_host_wide_int (u / 10);\n+    putchar ('0' + (int) (u % 10));\n+  }\n+}\n+\n /* table to tell if char can be part of a C identifier. */\n unsigned char is_idchar[256];\n /* table to tell if char can be first char of a c identifier. */"}, {"sha": "744490f9256e9236f52b44033a77d1ec688dfb7d", "filename": "gcc/convert.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,5 +1,5 @@\n /* Utility routines for data type conversion for GNU C.\n-   Copyright (C) 1987, 88, 91, 92, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 92, 94, 95, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU C.\n \n@@ -397,7 +397,10 @@ convert_to_integer (type, expr)\n \t\t\t\t      convert (type, TREE_OPERAND (expr, 2))));\n \t      }\n \t  }\n+\t  break;\n \n+\tdefault:\n+\t  break;\n \t}\n \n       return build1 (NOP_EXPR, type, expr);"}, {"sha": "9424b48f9850b6bc72c0e3696cf94867e22e4dde", "filename": "gcc/cpp.texi", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -881,6 +881,14 @@ This macro expands to the constant 1, to signify that this is ANSI\n Standard C@.  (Whether that is actually true depends on what C compiler\n will operate on the output from the preprocessor.)\n \n+On some hosts, system include files use a different convention, where\n+@samp{__STDC__} is normally 0, but is 1 if the user specifies strict\n+conformance to the C Standard.  The preprocessor follows the host convention\n+when processing system include files, but when processing user files it follows\n+the usual GNU C convention.\n+\n+This macro is not defined if the @samp{-traditional} option is used.\n+\n @item __STDC_VERSION__\n @findex __STDC_VERSION__\n This macro expands to the C Standard's version number,\n@@ -891,6 +899,8 @@ Like @samp{__STDC__}, whether this version number is accurate\n for the entire implementation depends on what C compiler\n will operate on the output from the preprocessor.\n \n+This macro is not defined if the @samp{-traditional} option is used.\n+\n @item __GNUC__\n @findex __GNUC__\n This macro is defined if and only if this is GNU C@.  This macro is\n@@ -2679,6 +2689,15 @@ Do not search for header files in the C++-specific standard directories,\n but do still search the other standard directories.\n (This option is used when building libg++.)\n \n+@item -remap\n+@findex -remap\n+When searching for a header file in a directory, remap file names if a\n+file named @file{header.gcc} exists in that directory.  This can be used\n+to work around limitations of file systems with file name restrictions.\n+The @file{header.gcc} file should contain a series of lines with two\n+tokens on each line: the first token is the name to map, and the second\n+token is the actual name to use.\n+\n @item -D @var{name}\n @findex -D\n Predefine @var{name} as a macro, with definition @samp{1}.\n@@ -2733,6 +2752,10 @@ predefined macros, and it outputs @emph{both} the @samp{#define}\n directives and the result of preprocessing.  Both kinds of output go to\n the standard output file.\n \n+@item -dI\n+@findex -dI\n+Output @samp{#include} directives in addition to the result of preprocessing.\n+\n @item -M [-MG]\n @findex -M\n Instead of outputting the result of preprocessing, output a rule"}, {"sha": "346ce44037d58d5b18300fb4c29b07f5e006f0cb", "filename": "gcc/cpplib.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -69,7 +69,7 @@ enum cpp_token {\n };\n \n #ifndef PARAMS\n-#ifdef __STDC\n+#ifdef __STDC__\n #define PARAMS(P) P\n #else\n #define PARAMS(P) ()\n@@ -94,7 +94,7 @@ extern void parse_goto_mark PARAMS((struct parse_marker *, cpp_reader *));\n extern void parse_move_mark PARAMS((struct parse_marker *, cpp_reader *));\n \n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n-extern enum cpp_token cpp_get_token PARAMS ((struct parse_marker *));\n+extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n extern void cpp_skip_hspace PARAMS((cpp_reader *));\n extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n \n@@ -179,7 +179,7 @@ struct cpp_reader {\n \n   /* A buffer used for both for cpp_get_token's output, and also internally. */\n   unsigned char *token_buffer;\n-  /* Alocated size of token_buffer.  CPP_RESERVE allocates space.  */\n+  /* Allocated size of token_buffer.  CPP_RESERVE allocates space.  */\n   int token_buffer_size;\n   /* End of the written part of token_buffer. */\n   unsigned char *limit;\n@@ -410,6 +410,10 @@ struct cpp_options {\n \n   char no_output;\n \n+  /* Nonzero means we should look for header.gcc files that remap file\n+     names.  */\n+  char remap;\n+\n   /* Nonzero means don't output line number information.  */\n \n   char no_line_commands;\n@@ -486,6 +490,10 @@ struct cpp_options {\n    where they are defined.  */\n   int debug_output;\n \n+  /* Nonzero means pass #include lines through to the output,\n+     even if they are ifdefed out.  */\n+  int dump_includes;\n+\n   /* Pending -D, -U and -A options, in reverse order. */\n   struct cpp_pending *pending;\n "}, {"sha": "7ac64c64437f374a2dd97e80e26d0989003296c0", "filename": "gcc/expmed.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1992,10 +1992,16 @@ synth_mult (alg_out, t, cost_limit)\n \n       for (w = 1; (w & t) != 0; w <<= 1)\n \t;\n-      if (w > 2\n-\t  /* Reject the case where t is 3.\n-\t     Thus we prefer addition in that case.  */\n-\t  && t != 3)\n+      /* If T was -1, then W will be zero after the loop.  This is another\n+\t case where T ends with ...111.  Handling this with (T + 1) and \n+\t subtract 1 produces slightly better code and results in algorithm\n+\t selection much faster than treating it like the ...0111 case\n+\t below.  */\n+      if (w == 0\n+\t  || (w > 2\n+\t      /* Reject the case where t is 3.\n+\t\t Thus we prefer addition in that case.  */\n+\t      && t != 3))\n \t{\n \t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n "}, {"sha": "93a8f2c5d0e8e21b3dfb1bc4d6b887f47637b867", "filename": "gcc/fixinc.ptx", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Ffixinc.ptx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Ffixinc.ptx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc.ptx?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -195,7 +195,7 @@ if [ \\! -z \"$file_to_fix\" ]; then\n   fi\n fi\n \n-# /usr/include/sys/mc_param.h has an embedded asm for the cpuid intruction\n+# /usr/include/sys/mc_param.h has an embedded asm for the cpuid instruction\n # on the P5. This is not used by anything else so we ifdef it out.\n file=sys/mc_param.h\n if [ -r ${LIB}/$file ]; then\n@@ -224,7 +224,7 @@ if [ \\! -z \"$file_to_fix\" ]; then\n   fi\n fi\n \n-# /usr/include/sys/mc_param.h has an embedded asm for the cpuid intruction\n+# /usr/include/sys/mc_param.h has an embedded asm for the cpuid instruction\n # on the P5. This is not used by anything else so we ifdef it out.\n file=sys/mc_param.h\n if [ -r ${LIB}/$file ]; then"}, {"sha": "55e1d4f6512fc64f1bf9922e277e6ba9e8565465", "filename": "gcc/floatlib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Ffloatlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Ffloatlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffloatlib.c?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -737,7 +737,7 @@ __divdf3 (double a1, double a2)\n    if (__dcmp(x1m1,x1m2,x2m1,x2m2) < 0) {\n \n    /* if x1's mantissa is less than x2's shift it left one and decrement */\n-   /* the exponent to accomodate the change in the mantissa              */\n+   /* the exponent to accommodate the change in the mantissa             */\n \n       x1m1 <<= 1;               /*                          */\n       bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */"}, {"sha": "02206960400f11a23b1d9c30627521526a98492c", "filename": "gcc/genmultilib", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fgenmultilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fgenmultilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmultilib?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,6 +1,6 @@\n #!/bin/sh \n # Generates multilib.h.\n-#   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n+#   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -243,7 +243,7 @@ echo \"NULL\"\n echo \"};\"\n \n # Output all of the matches now as option and that is the same as that, with\n-# a semicolan trailer.  Include all of the normal options as well.\n+# a semicolon trailer.  Include all of the normal options as well.\n # Note, the format of the matches is reversed compared\n # to what we want, so switch them around.\n echo \"\""}, {"sha": "c4adc30bbbac02416757dfc51f8d94b59ba9f847", "filename": "gcc/getopt.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fgetopt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fgetopt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgetopt.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,23 +1,23 @@\n /* Declarations for getopt.\n    Copyright (C) 1989,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n \n-NOTE: The canonical source of this file is maintained with the GNU C Library.\n-Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+   NOTE: The canonical source of this file is maintained with the GNU C Library.\n+   Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n \n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n \n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+   USA.  */\n \n #ifndef _GETOPT_H\n #define _GETOPT_H 1\n@@ -130,4 +130,4 @@ extern int _getopt_internal ();\n }\n #endif\n \n-#endif /* _GETOPT_H */\n+#endif /* getopt.h */"}, {"sha": "af8e681965740e72dbfd83c6238e705c94ffc964", "filename": "gcc/getopt1.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fgetopt1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fgetopt1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgetopt1.c?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,23 +1,23 @@\n /* getopt_long and getopt_long_only entry points for GNU getopt.\n    Copyright (C) 1987,88,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n \n-NOTE: The canonical source of this file is maintained with the GNU C Library.\n-Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n-\n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-USA.  */\n+   NOTE: The canonical source of this file is maintained with the GNU C Library.\n+   Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+   USA.  */\n \f\n #ifdef HAVE_CONFIG_H\n #include <config.h>"}, {"sha": "f9c1a6955179039a808423690f2a4b923c07a5a5", "filename": "gcc/halfpic.h", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fhalfpic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fhalfpic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,5 +1,5 @@\n /* OSF/rose half-pic support definitions.\n-   Copyright (C) 1992, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1996, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -20,24 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n #ifndef NO_HALF_PIC\n \n-/* Add prototype support.  */\n-/* ??? It would be nice to use gansidecl.h here but there's an extra\n-   complication with NO_STDIO_H that must be dealt with.  */\n-#ifndef PROTO\n-#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n-#define PROTO(ARGS) ARGS\n-#else\n-#define PROTO(ARGS) ()\n-#endif\n-#endif\n-\n-#if !defined(STDIO_PROTO) && !defined(NO_STDIO_H)\n-#ifndef BUFSIZ\n-#include <stdio.h>\n-#endif\n-\n-#define STDIO_PROTO(ARGS) PROTO(ARGS)\n-#endif\n+#include \"gansidecl.h\"\n \n #if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n union tree_node;\t\t/* forward reference */\n@@ -64,9 +47,8 @@ extern void half_pic_external PROTO((char *));\t\t\t/* declare object external */\n extern void half_pic_init PROTO((void));\t\t\t/* half_pic initialization */\n extern int  half_pic_address_p PROTO((struct rtx_def *));\t/* true if an address is half-pic */\n extern struct rtx_def *half_pic_ptr PROTO((struct rtx_def *));\t/* return RTX for half-pic pointer */\n-#ifdef STDIO_PROTO\n-extern void half_pic_finish STDIO_PROTO((FILE *));\t\t/* half_pic termination */\n-#endif\n+/* Can't use prototype since FILE isn't defined yet.  */\n+extern void half_pic_finish (/* FILE * */);\t\t/* half_pic termination */\n \n /* Macros to provide access to the half-pic stuff (so they can easily\n    be stubbed out.  */"}, {"sha": "7bcde83f9759914755c604de4e7f15b88c8a3127", "filename": "gcc/input.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,7 +1,6 @@\n /* Declarations for variables relating to reading the source file.\n    Used by parsers, lexical analyzers, and error message routines.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -37,6 +36,7 @@ struct file_stack\n     char *name;\n     struct file_stack *next;\n     int line;\n+    int indent_level;\n   };\n \n /* Stack of currently pending input files."}, {"sha": "a7d1968ae5a34c12d80d10d8aa92a39a23c12d34", "filename": "gcc/just-fixinc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fjust-fixinc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fjust-fixinc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjust-fixinc?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,5 +1,5 @@\n #!/bin/sh\n-# $Id: just-fixinc,v 1.1 1997/08/11 15:57:11 law Exp $\n+# $Id: just-fixinc,v 1.2 1998/04/03 16:35:58 law Exp $\n # This script exists for use after installing\n # the GCC binaries from a distribution tape/CD-ROM.\n # Use it *after* copying the directory of binaries"}, {"sha": "dc989f6eaef23af25b562c92959fd96deeaa7568", "filename": "gcc/listing", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Flisting", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Flisting", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flisting?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -32,7 +32,7 @@\n # mc68030  for Motorola 68030 (Sun-3, ..)\n # sparc    for SPARC (SUN-4, ..)\n # i386     for i386 (Sun i386, ...)\n-# i386-linux for i386 (Linux, ...)\n+# i386-gnu-linux for i386 (GNU/Linux, ...)\n \n # Guess what kind of objects we are creating and thus what type of assembler\n # symbols to look for\n@@ -62,7 +62,7 @@ cd $WD\n # MYSYS=mc68030\n # MYSYS=sparc\n # MYSYS=i386\n-# MYSYS=i386-linux\n+# MYSYS=i386-gnu-linux\n # MYSYS=`mach`  # this will work on Suns with SunOS > 4.0.0\n # MYSYS=elf\n # MYSYS=coff\n@@ -103,7 +103,7 @@ BEGIN {\n     line_delimiter = \",\";\n     line_offset = 0;\n   }\n-  else if (sys == \"mc68020\" || sys == \"mc68030\" || sys == \"i386-linux\") {\n+  else if (sys == \"mc68020\" || sys == \"mc68030\" || sys == \"i386-gnu-linux\") {\n     line_hint = \"^[ \\t]*\\.stabd.*\"\n     line_field = 3;\n     line_delimiter = \",\";"}, {"sha": "88af09b913e0536bdd1dee576f5bbdef31d95680", "filename": "gcc/machmode.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the\n    machine modes used in the the GNU compiler.\n-   Copyright (C) 1987, 1992, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1994, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -84,6 +84,8 @@ DEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, 12, 12, TFmode)   /* IEEE extended */\n DEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, 16, 16, VOIDmode)\n \n /* Complex modes.  */\n+DEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, 2, 1, HCmode)\n+DEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, 4, 2, SCmode)\n DEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, 8, 4, DCmode)\n DEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, 16, 8, XCmode)\n DEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, 24, 12, TCmode)"}, {"sha": "edebf022c1ef735e9c07cb91dbf1cc12932edbf6", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,5 +1,5 @@\n /* Read and manage MIPS symbol tables from object modules.\n-   Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1994, 1995, 1997 Free Software Foundation, Inc.\n    Contributed by hartzell@boulder.colorado.edu,\n    Rewritten by meissner@osf.org.\n \n@@ -20,13 +20,13 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#include \"config.h\"\n #include <stdio.h>\n #include <sys/types.h>\n #include <sys/file.h>\n #include <time.h>\n #include <fcntl.h>\n #include <errno.h>\n-#include \"config.h\"\n \n #ifdef index\n #undef index"}, {"sha": "fb66d0c95cb52de2cb92c67b8a22f593eac3f6bb", "filename": "gcc/obstack.c", "status": "modified", "additions": 129, "deletions": 32, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fobstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fobstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobstack.c?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,19 +1,29 @@\n /* obstack.c - subroutines used implicitly by object stack macros\n-   Copyright (C) 1988, 89, 90, 91, 92, 93, 94 Free Software Foundation, Inc.\n+   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n \n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n+   the C library, however.  The master source lives in /gd/gnu/lib.\n \n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   NOTE: The canonical source of this file is maintained with the GNU C Library.\n+   Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n \n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+   USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n \n #include \"obstack.h\"\n \n@@ -67,6 +77,28 @@ union fooround {long x; double d;};\n #define COPYING_UNIT int\n #endif\n \n+\n+/* The functions allocating more room by calling `obstack_chunk_alloc'\n+   jump to the handler pointed to by `obstack_alloc_failed_handler'.\n+   This variable by default points to the internal function\n+   `print_and_abort'.  */\n+#if defined (__STDC__) && __STDC__\n+static void print_and_abort (void);\n+void (*obstack_alloc_failed_handler) (void) = print_and_abort;\n+#else\n+static void print_and_abort ();\n+void (*obstack_alloc_failed_handler) () = print_and_abort;\n+#endif\n+\n+/* Exit value used when `print_and_abort' is used.  */\n+#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifndef EXIT_FAILURE\n+#define EXIT_FAILURE 1\n+#endif\n+int obstack_exit_failure = EXIT_FAILURE;\n+\n /* The non-GNU-C macros copy the obstack into this global variable\n    to avoid multiple evaluation.  */\n \n@@ -78,6 +110,20 @@ struct obstack *_obstack;\n    For free, do not use ?:, since some compilers, like the MIPS compilers,\n    do not allow (expr) ? void : void.  */\n \n+#if defined (__STDC__) && __STDC__\n+#define CALL_CHUNKFUN(h, size) \\\n+  (((h) -> use_extra_arg) \\\n+   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n+   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))\n+\n+#define CALL_FREEFUN(h, old_chunk) \\\n+  do { \\\n+    if ((h) -> use_extra_arg) \\\n+      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n+    else \\\n+      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \\\n+  } while (0)\n+#else\n #define CALL_CHUNKFUN(h, size) \\\n   (((h) -> use_extra_arg) \\\n    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n@@ -90,6 +136,7 @@ struct obstack *_obstack;\n     else \\\n       (*(void (*) ()) (h)->freefun) ((old_chunk)); \\\n   } while (0)\n+#endif\n \n \f\n /* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).\n@@ -106,13 +153,18 @@ _obstack_begin (h, size, alignment, chunkfun, freefun)\n      struct obstack *h;\n      int size;\n      int alignment;\n+#if defined (__STDC__) && __STDC__\n+     POINTER (*chunkfun) (long);\n+     void (*freefun) (void *);\n+#else\n      POINTER (*chunkfun) ();\n      void (*freefun) ();\n+#endif\n {\n   register struct _obstack_chunk *chunk; /* points to new chunk */\n \n   if (alignment == 0)\n-    alignment = DEFAULT_ALIGNMENT;\n+    alignment = (int) DEFAULT_ALIGNMENT;\n   if (size == 0)\n     /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n     {\n@@ -130,25 +182,27 @@ _obstack_begin (h, size, alignment, chunkfun, freefun)\n       size = 4096 - extra;\n     }\n \n+#if defined (__STDC__) && __STDC__\n+  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n+#else\n   h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n   h->freefun = freefun;\n+#endif\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n   h->use_extra_arg = 0;\n \n   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n   if (!chunk)\n-    {\n-      h->alloc_failed = 1;\n-      return 0;\n-    }\n-  h->alloc_failed = 0;\n+    (*obstack_alloc_failed_handler) ();\n   h->next_free = h->object_base = chunk->contents;\n   h->chunk_limit = chunk->limit\n     = (char *) chunk + h->chunk_size;\n   chunk->prev = 0;\n   /* The initial chunk now contains no empty object.  */\n   h->maybe_empty_object = 0;\n+  h->alloc_failed = 0;\n   return 1;\n }\n \n@@ -157,14 +211,19 @@ _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n      struct obstack *h;\n      int size;\n      int alignment;\n+#if defined (__STDC__) && __STDC__\n+     POINTER (*chunkfun) (POINTER, long);\n+     void (*freefun) (POINTER, POINTER);\n+#else\n      POINTER (*chunkfun) ();\n      void (*freefun) ();\n+#endif\n      POINTER arg;\n {\n   register struct _obstack_chunk *chunk; /* points to new chunk */\n \n   if (alignment == 0)\n-    alignment = DEFAULT_ALIGNMENT;\n+    alignment = (int) DEFAULT_ALIGNMENT;\n   if (size == 0)\n     /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n     {\n@@ -182,26 +241,28 @@ _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n       size = 4096 - extra;\n     }\n \n+#if defined(__STDC__) && __STDC__\n+  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n+#else\n   h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n   h->freefun = freefun;\n+#endif\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n   h->extra_arg = arg;\n   h->use_extra_arg = 1;\n \n   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n   if (!chunk)\n-    {\n-      h->alloc_failed = 1;\n-      return 0;\n-    }\n-  h->alloc_failed = 0;\n+    (*obstack_alloc_failed_handler) ();\n   h->next_free = h->object_base = chunk->contents;\n   h->chunk_limit = chunk->limit\n     = (char *) chunk + h->chunk_size;\n   chunk->prev = 0;\n   /* The initial chunk now contains no empty object.  */\n   h->maybe_empty_object = 0;\n+  h->alloc_failed = 0;\n   return 1;\n }\n \n@@ -219,9 +280,9 @@ _obstack_newchunk (h, length)\n   register struct _obstack_chunk *old_chunk = h->chunk;\n   register struct _obstack_chunk *new_chunk;\n   register long\tnew_size;\n-  register int obj_size = h->next_free - h->object_base;\n-  register int i;\n-  int already;\n+  register long obj_size = h->next_free - h->object_base;\n+  register long i;\n+  long already;\n \n   /* Compute size for new chunk.  */\n   new_size = (obj_size + length) + (obj_size >> 3) + 100;\n@@ -231,11 +292,7 @@ _obstack_newchunk (h, length)\n   /* Allocate and initialize the new chunk.  */\n   new_chunk = CALL_CHUNKFUN (h, new_size);\n   if (!new_chunk)\n-    {\n-      h->alloc_failed = 1;\n-      return;\n-    }\n-  h->alloc_failed = 0;\n+    (*obstack_alloc_failed_handler) ();\n   h->chunk = new_chunk;\n   new_chunk->prev = old_chunk;\n   new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n@@ -379,6 +436,39 @@ obstack_free (h, obj)\n     abort ();\n }\n \f\n+int\n+_obstack_memory_used (h)\n+     struct obstack *h;\n+{\n+  register struct _obstack_chunk* lp;\n+  register int nbytes = 0;\n+\n+  for (lp = h->chunk; lp != 0; lp = lp->prev)\n+    {\n+      nbytes += lp->limit - (char *) lp;\n+    }\n+  return nbytes;\n+}\n+\f\n+/* Define the error handler.  */\n+#ifndef _\n+# ifdef HAVE_LIBINTL_H\n+#  include <libintl.h>\n+#  ifndef _\n+#   define _(Str) gettext (Str)\n+#  endif\n+# else\n+#  define _(Str) (Str)\n+# endif\n+#endif\n+\n+static void\n+print_and_abort ()\n+{\n+  fputs (_(\"memory exhausted\\n\"), stderr);\n+  exit (obstack_exit_failure);\n+}\n+\f\n #if 0\n /* These are now turned off because the applications do not use it\n    and it uses bcopy via obstack_grow, which causes trouble on sysV.  */\n@@ -417,6 +507,13 @@ int (obstack_room) (obstack)\n   return obstack_room (obstack);\n }\n \n+int (obstack_make_room) (obstack, length)\n+     struct obstack *obstack;\n+     int length;\n+{\n+  return obstack_make_room (obstack, length);\n+}\n+\n void (obstack_grow) (obstack, pointer, length)\n      struct obstack *obstack;\n      POINTER pointer;"}, {"sha": "8918c8950b17e1175371b2f79b308eb6bd0ad7ad", "filename": "gcc/recog.h", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for interface to insn recognizer and insn-output.c.\n-   Copyright (C) 1987, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1996, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -20,37 +20,49 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"gansidecl.h\"\n \n-/* Recognize an insn and return its insn-code,\n-   which is the sequence number of the DEFINE_INSN that it matches.\n-   If the insn does not match, return -1.  */\n-\n-extern int recog_memoized PROTO((rtx));\n-\n-/* Determine whether a proposed change to an insn or MEM will make it\n-   invalid.  Make the change if not.  */\n-\n-extern int validate_change PROTO((rtx, rtx *, rtx, int));\n-\n-/* Apply a group of changes if valid.  */\n-\n-extern int apply_change_group PROTO((void));\n-\n-/* Return the number of changes so far in the current group.   */\n-\n-extern int num_validated_changes PROTO((void));\n-\n-/* Retract some changes.  */\n-\n-extern void cancel_changes PROTO((int));\n+extern void init_recog\t\t\tPROTO((void));\n+extern void init_recog_no_volatile\tPROTO((void));\n+extern int recog_memoized\t\tPROTO((rtx));\n+extern int check_asm_operands\t\tPROTO((rtx));\n+extern int validate_change\t\tPROTO((rtx, rtx *, rtx, int));\n+extern int apply_change_group\t\tPROTO((void));\n+extern int num_validated_changes\tPROTO((void));\n+extern void cancel_changes\t\tPROTO((int));\n+extern int constrain_operands\t\tPROTO((int, int));\n+extern int memory_address_p\t\tPROTO((enum machine_mode, rtx));\n+extern int strict_memory_address_p\tPROTO((enum machine_mode, rtx));\n+extern int validate_replace_rtx\t\tPROTO((rtx, rtx, rtx));\n+extern int reg_fits_class_p\t\tPROTO((rtx, enum reg_class, int,\n+\t\t\t\t\t       enum machine_mode));\n+extern rtx *find_single_use\t\tPROTO((rtx, rtx, rtx *));\n+\n+extern int general_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int address_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int register_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int scratch_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int immediate_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int const_int_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int cosnt_double_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int nonimmediate_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int nonmemory_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int push_operand\t\t\tPROTO((rtx, enum machine_mode));\n+extern int memory_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int indirect_operand\t\tPROTO((rtx, enum machine_mode));\n+extern int mode_independent_operand\tPROTO((rtx, enum machine_mode));\n+extern int comparison_operator\t\tPROTO((rtx, enum machine_mode));\n+\n+extern int offsettable_memref_p\t\tPROTO((rtx));\n+extern int offsettable_nonstrict_memref_p\tPROTO((rtx));\n+extern int offsettable_address_p\tPROTO((int, enum machine_mode, rtx));\n+extern int mode_dependent_address_p\tPROTO((rtx));\n+\n+extern int recog\t\t\tPROTO((rtx, rtx, int *));\n+extern void add_clobbers\t\tPROTO((rtx, int));\n+extern void insn_extract\t\tPROTO((rtx));\n \n /* Nonzero means volatile operands are recognized.  */\n-\n extern int volatile_ok;\n \n-/* Extract the operands from an insn that has been recognized.  */\n-\n-extern void insn_extract PROTO((rtx));\n-\n /* The following vectors hold the results from insn_extract.  */\n \n /* Indexed by N, gives value of operand N.  */"}, {"sha": "fe1dbfe6b7afcc06f1bd9e2fe7139bbc89bc01e5", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -29,6 +29,10 @@ Boston, MA 02111-1307, USA.  */\n #define REG_SIZE(R) \\\n   ((mode_size[(int) GET_MODE (R)] + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+#ifndef SMALL_REGISTER_CLASSES\n+#define SMALL_REGISTER_CLASSES 0\n+#endif\n+\n /* Maximum register number used in this function, plus one.  */\n \n extern int max_regno;"}, {"sha": "a78f4dd7e54db4d0a36e8ff52d4f39aa245d7af8", "filename": "gcc/texinfo.tex", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Ftexinfo.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31031eddacda46a500b2390f52cd4474bcaf84ca/gcc%2Ftexinfo.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftexinfo.tex?ref=31031eddacda46a500b2390f52cd4474bcaf84ca", "patch": "@@ -1,5 +1,5 @@\n %% TeX macros to handle Texinfo files.\n-%% $Id: texinfo.tex,v 1.1 1997/08/11 15:57:14 law Exp $\n+%% $Id: texinfo.tex,v 1.1.1.2 1998/01/14 19:38:23 law Exp $\n \n %  Copyright (C) 1985, 86, 88, 90, 91, 92, 93,\n %                94, 95, 96, 97 Free Software Foundation, Inc.\n@@ -36,7 +36,7 @@\n \n % This automatically updates the version number based on RCS.\n \\def\\deftexinfoversion$#1: #2 ${\\def\\texinfoversion{#2}}\n-\\deftexinfoversion$Revision: 1.1 $\n+\\deftexinfoversion$Revision: 1.1.1.2 $\n \\message{Loading texinfo package [Version \\texinfoversion]:}\n \n % If in a .fmt file, print the version number\n@@ -441,14 +441,11 @@\n % @. is an end-of-sentence period.\n \\def\\.{.\\spacefactor=3000 }\n \n-% @enddots{} is an end-of-sentence ellipsis.\n-\\gdef\\enddots{$\\mathinner{\\ldotp\\ldotp\\ldotp\\ldotp}$\\spacefactor=3000}\n-\n % @! is an end-of-sentence bang.\n-\\gdef\\!{!\\spacefactor=3000 }\n+\\def\\!{!\\spacefactor=3000 }\n \n % @? is an end-of-sentence query.\n-\\gdef\\?{?\\spacefactor=3000 }\n+\\def\\?{?\\spacefactor=3000 }\n \n % @w prevents a word break.  Without the \\leavevmode, @w at the\n % beginning of a paragraph, when TeX is still in vertical mode, would\n@@ -573,9 +570,27 @@\n \n \\let\\br = \\par\n \n-% @dots{}  output some dots\n+% @dots{} output an ellipsis using the current font.\n+% We do .5em per period so that it has the same spacing in a typewriter\n+% font as three actual period characters.\n+%\n+\\def\\dots{\\hbox to 1.5em{%\n+  \\hskip 0pt plus 0.25fil minus 0.25fil\n+  .\\hss.\\hss.%\n+  \\hskip 0pt plus 0.5fil minus 0.5fil\n+}}\n+\n+% @enddots{} is an end-of-sentence ellipsis.\n+% \n+\\def\\enddots{%\n+  \\hbox to 2em{%\n+    \\hskip 0pt plus 0.25fil minus 0.25fil\n+    .\\hss.\\hss.\\hss.%\n+    \\hskip 0pt plus 0.5fil minus 0.5fil\n+  }%\n+  \\spacefactor=3000\n+}\n \n-\\def\\dots{$\\ldots$}\n \n % @page    forces the start of a new page\n \n@@ -1236,7 +1251,7 @@\n   \\let\\tensf=\\titlesf \\let\\teni=\\titlei \\let\\tensy=\\titlesy\n   \\let\\tenttsl=\\titlettsl\n   \\resetmathfonts \\setleading{25pt}}\n-\\def\\titlefont#1{{\\titlefonts #1}}\n+\\def\\titlefont#1{{\\titlefonts\\rm #1}}\n \\def\\chapfonts{%\n   \\let\\tenrm=\\chaprm \\let\\tenit=\\chapit \\let\\tensl=\\chapsl\n   \\let\\tenbf=\\chapbf \\let\\tentt=\\chaptt \\let\\smallcaps=\\chapsc\n@@ -4617,7 +4632,7 @@\n % Check for and read epsf.tex up front.  If we read it only at @image\n % time, we might be inside a group, and then its definitions would get\n % undone and the next image would fail.\n-\\openin 1 = xepsf.tex\n+\\openin 1 = epsf.tex\n \\ifeof 1 \\else\n   \\closein 1\n   \\def\\epsfannounce{\\toks0 = }% do not bother showing banner"}]}