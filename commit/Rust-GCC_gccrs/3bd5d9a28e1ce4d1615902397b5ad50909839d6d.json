{"sha": "3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "node_id": "C_kwDOANBUbNoAKDNiZDVkOWEyOGUxY2U0ZDE2MTU5MDIzOTdiNWFkNTA5MDk4MzlkNmQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-10-17T15:14:36Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-10-17T15:14:36Z"}, "message": "c++ modules: streaming constexpr_fundef [PR101449]\n\nIt looks like we currently avoid streaming the RESULT_DECL and PARM_DECLs\nof a constexpr_fundef entry under the assumption that they're just copies\nof the DECL_RESULT and DECL_ARGUMENTS of the FUNCTION_DECL.  Thus we can\njust make new copies of DECL_RESULT and DECL_ARGUMENTS on stream in rather\nthan separately streaming them.\n\nBut the FUNCTION_DECL's DECL_RESULT and DECL_ARGUMENTS eventually get\ngenericized, whereas the constexpr_fundef entry consists of a copy of the\nFUNCTION_DECL's pre-GENERIC trees.  And notably during genericization we\nlower invisref parms (which entails changing their TREE_TYPE and setting\nDECL_BY_REFERENCE), the lowered form of which the constexpr evaluator\ndoesn't expect to see, and so this copying approach causes us to ICE for\nthe below testcase.\n\nThis patch fixes this by faithfully streaming the RESULT_DECL and\nPARM_DECLs of a constexpr_fundef entry, which seems to just work.\n\nNathan says[1]: Hm, the reason for the complexity was that I wanted to\nrecreate the tree graph where the fndecl came from one TU and the defn\ncame from another one -- we need the definition to refer to argument\ndecls from the already-read decl.  However, it seems that for constexpr\nfns here, that is not needed, resulting in a significant simplification.\n\n[1]: https://gcc.gnu.org/pipermail/gcc-patches/2022-October/603662.html\n\n\tPR c++/101449\n\ngcc/cp/ChangeLog:\n\n\t* module.cc (trees_out::write_function_def): Stream the\n\tparms and result of the constexpr_fundef entry.\n\t(trees_in::read_function_def): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/modules/cexpr-3_a.C: New test.\n\t* g++.dg/modules/cexpr-3_b.C: New test.", "tree": {"sha": "a7ae3a9dde391ea8d7aa3d3d71e4af0d9a0dcbb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7ae3a9dde391ea8d7aa3d3d71e4af0d9a0dcbb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/comments", "author": null, "committer": null, "parents": [{"sha": "01d7d459e433196b1faa4ee025a314266887fc59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d7d459e433196b1faa4ee025a314266887fc59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d7d459e433196b1faa4ee025a314266887fc59"}], "stats": {"total": 80, "additions": 29, "deletions": 51}, "files": [{"sha": "999ff3faafce4dcdf6e1e74340a9d45f3d5d8d45", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 8, "deletions": 51, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "patch": "@@ -11553,34 +11553,13 @@ trees_out::write_function_def (tree decl)\n   tree_node (DECL_FRIEND_CONTEXT (decl));\n \n   constexpr_fundef *cexpr = retrieve_constexpr_fundef (decl);\n-  int tag = 0;\n-  if (cexpr)\n-    {\n-      if (cexpr->result == error_mark_node)\n-\t/* We'll stream the RESULT_DECL naturally during the\n-\t   serialization.  We never need to fish it back again, so\n-\t   that's ok.  */\n-\ttag = 0;\n-      else\n-\ttag = insert (cexpr->result);\n-    }\n+\n   if (streaming_p ())\n+    u (cexpr != nullptr);\n+  if (cexpr)\n     {\n-      i (tag);\n-      if (tag)\n-\tdump (dumper::TREE)\n-\t  && dump (\"Constexpr:%d result %N\", tag, cexpr->result);\n-    }\n-  if (tag)\n-    {\n-      unsigned ix = 0;\n-      for (tree parm = cexpr->parms; parm; parm = DECL_CHAIN (parm), ix++)\n-\t{\n-\t  tag = insert (parm);\n-\t  if (streaming_p ())\n-\t    dump (dumper::TREE)\n-\t      && dump (\"Constexpr:%d parm:%u %N\", tag, ix, parm);\n-\t}\n+      chained_decls (cexpr->parms);\n+      tree_node (cexpr->result);\n       tree_node (cexpr->body);\n     }\n \n@@ -11613,32 +11592,10 @@ trees_in::read_function_def (tree decl, tree maybe_template)\n   tree maybe_dup = odr_duplicate (maybe_template, DECL_SAVED_TREE (decl));\n   bool installing = maybe_dup && !DECL_SAVED_TREE (decl);\n \n-  if (int wtag = i ())\n+  if (u ())\n     {\n-      int tag = 1;\n-      cexpr.result = error_mark_node;\n-\n-      cexpr.result = copy_decl (result);\n-      tag = insert (cexpr.result);\n-\n-      if (wtag != tag)\n-\tset_overrun ();\n-      dump (dumper::TREE)\n-\t&& dump (\"Constexpr:%d result %N\", tag, cexpr.result);\n-\n-      cexpr.parms = NULL_TREE;\n-      tree *chain = &cexpr.parms;\n-      unsigned ix = 0;\n-      for (tree parm = DECL_ARGUMENTS (maybe_dup ? maybe_dup : decl);\n-\t   parm; parm = DECL_CHAIN (parm), ix++)\n-\t{\n-\t  tree p = copy_decl (parm);\n-\t  tag = insert (p);\n-\t  dump (dumper::TREE)\n-\t    && dump (\"Constexpr:%d parm:%u %N\", tag, ix, p);\n-\t  *chain = p;\n-\t  chain = &DECL_CHAIN (p);\n-\t}\n+      cexpr.parms = chained_decls ();\n+      cexpr.result = tree_node ();\n       cexpr.body = tree_node ();\n       cexpr.decl = decl;\n     }"}, {"sha": "be24bb43a7b1d4d68d247db3f4a40ce8e3b48dec", "filename": "gcc/testsuite/g++.dg/modules/cexpr-3_a.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcexpr-3_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcexpr-3_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcexpr-3_a.C?ref=3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/101449\n+// { dg-additional-options -fmodules-ts }\n+// { dg-module-cmi pr101449 }\n+\n+export module pr101449;\n+\n+struct X {\n+  bool b = true;\n+  constexpr X() { }\n+  constexpr X(const X&) { }\n+};\n+\n+export constexpr X f() { return {}; }\n+export constexpr bool g(X x) { return x.b; }"}, {"sha": "cbf3be4fcab751db9c5599cfccc96df36c9b45c4", "filename": "gcc/testsuite/g++.dg/modules/cexpr-3_b.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcexpr-3_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd5d9a28e1ce4d1615902397b5ad50909839d6d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcexpr-3_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fcexpr-3_b.C?ref=3bd5d9a28e1ce4d1615902397b5ad50909839d6d", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/101449\n+// { dg-additional-options -fmodules-ts }\n+\n+import pr101449;\n+\n+static_assert(f().b);\n+static_assert(g(f()));"}]}