{"sha": "ffbc87965098c6c7e04dcb3007f248251bb4d62e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZiYzg3OTY1MDk4YzZjN2UwNGRjYjMwMDdmMjQ4MjUxYmI0ZDYyZQ==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2003-09-22T23:19:45Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2003-09-22T23:19:45Z"}, "message": "xtensa-protos.h: Convert to ISO C90.\n\n\t* config/xtensa/xtensa-protos.h: Convert to ISO C90.\n\t* config/xtensa/xtensa.c: Convert to ISO C90.  Minor formatting fixes.\n\nFrom-SVN: r71669", "tree": {"sha": "d2d2333e1b8754b0e40973b3bf03086cf3ca63f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2d2333e1b8754b0e40973b3bf03086cf3ca63f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffbc87965098c6c7e04dcb3007f248251bb4d62e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffbc87965098c6c7e04dcb3007f248251bb4d62e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffbc87965098c6c7e04dcb3007f248251bb4d62e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffbc87965098c6c7e04dcb3007f248251bb4d62e/comments", "author": null, "committer": null, "parents": [{"sha": "4d76fdaabceeee4f63b98c8ef3a1bad4831c2859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d76fdaabceeee4f63b98c8ef3a1bad4831c2859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d76fdaabceeee4f63b98c8ef3a1bad4831c2859"}], "stats": {"total": 567, "additions": 223, "deletions": 344}, "files": [{"sha": "a03deee37edc737a56b760e0194d7a998495c205", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffbc87965098c6c7e04dcb3007f248251bb4d62e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffbc87965098c6c7e04dcb3007f248251bb4d62e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffbc87965098c6c7e04dcb3007f248251bb4d62e", "patch": "@@ -1,3 +1,8 @@\n+2003-09-22  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa-protos.h: Convert to ISO C90.\n+\t* config/xtensa/xtensa.c: Convert to ISO C90.  Minor formatting fixes.\n+\n 2003-09-22  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mn10300/mn10300.md: Revert 2003-09-17's patch."}, {"sha": "9c37c41799168541a649b86d3dba7457b03f59af", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 73, "deletions": 75, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffbc87965098c6c7e04dcb3007f248251bb4d62e/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffbc87965098c6c7e04dcb3007f248251bb4d62e/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=ffbc87965098c6c7e04dcb3007f248251bb4d62e", "patch": "@@ -23,92 +23,90 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define __XTENSA_PROTOS_H__\n \n /* Functions to test whether an immediate fits in a given field. */\n-extern int xtensa_simm7 PARAMS ((int));\n-extern int xtensa_simm8 PARAMS ((int));\n-extern int xtensa_simm8x256 PARAMS ((int));\n-extern int xtensa_simm12b PARAMS ((int));\n-extern int xtensa_uimm8 PARAMS ((int));\n-extern int xtensa_uimm8x2 PARAMS ((int));\n-extern int xtensa_uimm8x4 PARAMS ((int));\n-extern int xtensa_ai4const PARAMS ((int));\n-extern int xtensa_lsi4x4 PARAMS ((int));\n-extern int xtensa_b4const PARAMS ((int));\n-extern int xtensa_b4constu PARAMS ((int));\n-extern int xtensa_tp7 PARAMS ((int));\n+extern int xtensa_simm7 (int);\n+extern int xtensa_simm8 (int);\n+extern int xtensa_simm8x256 (int);\n+extern int xtensa_simm12b (int);\n+extern int xtensa_uimm8 (int);\n+extern int xtensa_uimm8x2 (int);\n+extern int xtensa_uimm8x4 (int);\n+extern int xtensa_ai4const (int);\n+extern int xtensa_lsi4x4 (int);\n+extern int xtensa_b4const (int);\n+extern int xtensa_b4constu (int);\n+extern int xtensa_tp7 (int);\n \n /* Functions within xtensa.c that we reference.  */\n #ifdef RTX_CODE\n-extern int xt_true_regnum PARAMS ((rtx));\n-extern int add_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_operand PARAMS ((rtx, enum machine_mode));\n-extern int nonimmed_operand PARAMS ((rtx, enum machine_mode));\n-extern int mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int xtensa_valid_move PARAMS ((enum machine_mode, rtx *operands));\n-extern int mask_operand PARAMS ((rtx, enum machine_mode));\n-extern int extui_fldsz_operand PARAMS ((rtx, enum machine_mode));\n-extern int sext_operand PARAMS ((rtx, enum machine_mode));\n-extern int sext_fldsz_operand PARAMS ((rtx, enum machine_mode));\n-extern int lsbitnum_operand PARAMS ((rtx, enum machine_mode));\n-extern int branch_operand PARAMS ((rtx, enum machine_mode));\n-extern int ubranch_operand PARAMS ((rtx, enum machine_mode));\n-extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n-extern int move_operand PARAMS ((rtx, enum machine_mode));\n-extern int smalloffset_mem_p PARAMS ((rtx));\n-extern int constantpool_address_p PARAMS ((rtx));\n-extern int constantpool_mem_p PARAMS ((rtx));\n-extern int const_float_1_operand PARAMS ((rtx, enum machine_mode));\n-extern int fpmem_offset_operand PARAMS ((rtx, enum machine_mode));\n-extern void xtensa_extend_reg PARAMS ((rtx, rtx));\n-extern int branch_operator PARAMS ((rtx, enum machine_mode));\n-extern int ubranch_operator PARAMS ((rtx, enum machine_mode));\n-extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n-extern void xtensa_expand_conditional_branch PARAMS ((rtx *, enum rtx_code));\n-extern int xtensa_expand_conditional_move PARAMS ((rtx *, int));\n-extern int xtensa_expand_scc PARAMS ((rtx *));\n-extern int xtensa_expand_block_move PARAMS ((rtx *));\n-extern void xtensa_split_operand_pair PARAMS ((rtx *, enum machine_mode));\n-extern int xtensa_emit_move_sequence PARAMS ((rtx *, enum machine_mode));\n-extern bool xtensa_copy_incoming_a7 PARAMS ((rtx *, enum machine_mode));\n-extern void xtensa_emit_block_move PARAMS ((rtx *, rtx *, int));\n-extern void xtensa_expand_nonlocal_goto PARAMS ((rtx *));\n-extern void xtensa_emit_loop_end PARAMS ((rtx, rtx *));\n-extern char * xtensa_emit_call PARAMS ((int, rtx *));\n+extern int xt_true_regnum (rtx);\n+extern int add_operand (rtx, enum machine_mode);\n+extern int arith_operand (rtx, enum machine_mode);\n+extern int nonimmed_operand (rtx, enum machine_mode);\n+extern int mem_operand (rtx, enum machine_mode);\n+extern int xtensa_valid_move (enum machine_mode, rtx *);\n+extern int mask_operand (rtx, enum machine_mode);\n+extern int extui_fldsz_operand (rtx, enum machine_mode);\n+extern int sext_operand (rtx, enum machine_mode);\n+extern int sext_fldsz_operand (rtx, enum machine_mode);\n+extern int lsbitnum_operand (rtx, enum machine_mode);\n+extern int branch_operand (rtx, enum machine_mode);\n+extern int ubranch_operand (rtx, enum machine_mode);\n+extern int call_insn_operand (rtx, enum machine_mode);\n+extern int move_operand (rtx, enum machine_mode);\n+extern int smalloffset_mem_p (rtx);\n+extern int constantpool_address_p (rtx);\n+extern int constantpool_mem_p (rtx);\n+extern int const_float_1_operand (rtx, enum machine_mode);\n+extern int fpmem_offset_operand (rtx, enum machine_mode);\n+extern void xtensa_extend_reg (rtx, rtx);\n+extern int branch_operator (rtx, enum machine_mode);\n+extern int ubranch_operator (rtx, enum machine_mode);\n+extern int boolean_operator (rtx, enum machine_mode);\n+extern void xtensa_expand_conditional_branch (rtx *, enum rtx_code);\n+extern int xtensa_expand_conditional_move (rtx *, int);\n+extern int xtensa_expand_scc (rtx *);\n+extern int xtensa_expand_block_move (rtx *);\n+extern void xtensa_split_operand_pair (rtx *, enum machine_mode);\n+extern int xtensa_emit_move_sequence (rtx *, enum machine_mode);\n+extern bool xtensa_copy_incoming_a7 (rtx *, enum machine_mode);\n+extern void xtensa_emit_block_move (rtx *, rtx *, int);\n+extern void xtensa_expand_nonlocal_goto (rtx *);\n+extern void xtensa_emit_loop_end (rtx, rtx *);\n+extern char *xtensa_emit_call (int, rtx *);\n \n #ifdef TREE_CODE\n-extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));\n-extern void xtensa_va_start PARAMS ((tree, rtx));\n-extern rtx xtensa_va_arg PARAMS ((tree, tree));\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n+extern void xtensa_va_start (tree, rtx);\n+extern rtx xtensa_va_arg (tree, tree);\n #endif /* TREE_CODE */\n \n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void xtensa_output_literal\n-  PARAMS ((FILE *, rtx, enum machine_mode, int labelno));\n-extern rtx xtensa_return_addr PARAMS ((int, rtx));\n-extern rtx xtensa_builtin_saveregs PARAMS ((void));\n-extern enum reg_class xtensa_preferred_reload_class\n-  PARAMS ((rtx, enum reg_class, int));\n-extern enum reg_class xtensa_secondary_reload_class\n-  PARAMS ((enum reg_class, enum machine_mode, rtx, int));\n-extern int a7_overlap_mentioned_p PARAMS ((rtx x));\n+extern void print_operand (FILE *, rtx, int);\n+extern void print_operand_address (FILE *, rtx);\n+extern void xtensa_output_literal (FILE *, rtx, enum machine_mode, int);\n+extern rtx xtensa_return_addr (int, rtx);\n+extern rtx xtensa_builtin_saveregs (void);\n+extern enum reg_class xtensa_preferred_reload_class (rtx, enum reg_class, int);\n+extern enum reg_class xtensa_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t     enum machine_mode, rtx,\n+\t\t\t\t\t\t     int);\n+extern int a7_overlap_mentioned_p (rtx);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern void function_arg_advance\n-  PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree));\n-extern struct rtx_def * function_arg\n-  PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n-extern tree xtensa_build_va_list PARAMS ((void));\n+extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree);\n+extern struct rtx_def *function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t     tree, int);\n+extern tree xtensa_build_va_list (void);\n #endif /* TREE_CODE */\n \n-extern int xtensa_mask_immediate PARAMS ((int));\n-extern int xtensa_mem_offset PARAMS ((unsigned, enum machine_mode));\n-extern void xtensa_setup_frame_addresses PARAMS ((void));\n-extern int xtensa_dbx_register_number PARAMS ((int));\n-extern void override_options PARAMS ((void));\n-extern long compute_frame_size PARAMS ((int));\n-extern int xtensa_frame_pointer_required PARAMS ((void));\n-extern void xtensa_expand_prologue PARAMS ((void));\n-extern void order_regs_for_local_alloc PARAMS ((void));\n+extern int xtensa_mask_immediate (int);\n+extern int xtensa_mem_offset (unsigned, enum machine_mode);\n+extern void xtensa_setup_frame_addresses (void);\n+extern int xtensa_dbx_register_number (int);\n+extern void override_options (void);\n+extern long compute_frame_size (int);\n+extern int xtensa_frame_pointer_required (void);\n+extern void xtensa_expand_prologue (void);\n+extern void order_regs_for_local_alloc (void);\n \n #endif /* !__XTENSA_PROTOS_H__ */"}, {"sha": "86735f3364c0aa9ae942084184ca8124dbbb3332", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 145, "deletions": 269, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffbc87965098c6c7e04dcb3007f248251bb4d62e/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffbc87965098c6c7e04dcb3007f248251bb4d62e/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=ffbc87965098c6c7e04dcb3007f248251bb4d62e", "patch": "@@ -53,19 +53,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    arrays indexed by the test type, and not worry about the order\n    of EQ, NE, etc.  */\n \n-enum internal_test {\n-    ITEST_EQ,\n-    ITEST_NE,\n-    ITEST_GT,\n-    ITEST_GE,\n-    ITEST_LT,\n-    ITEST_LE,\n-    ITEST_GTU,\n-    ITEST_GEU,\n-    ITEST_LTU,\n-    ITEST_LEU,\n-    ITEST_MAX\n-  };\n+enum internal_test\n+{\n+  ITEST_EQ,\n+  ITEST_NE,\n+  ITEST_GT,\n+  ITEST_GE,\n+  ITEST_LT,\n+  ITEST_LE,\n+  ITEST_GTU,\n+  ITEST_GEU,\n+  ITEST_LTU,\n+  ITEST_LEU,\n+  ITEST_MAX\n+};\n \n /* Cached operands, and operator to compare for use in set/branch on\n    condition codes.  */\n@@ -189,21 +190,21 @@ enum reg_class xtensa_char_to_class[256] =\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n };\n \n-static int b4const_or_zero PARAMS ((int));\n-static enum internal_test map_test_to_internal_test PARAMS ((enum rtx_code));\n-static rtx gen_int_relational PARAMS ((enum rtx_code, rtx, rtx, int *));\n-static rtx gen_float_relational PARAMS ((enum rtx_code, rtx, rtx));\n-static rtx gen_conditional_move PARAMS ((rtx));\n-static rtx fixup_subreg_mem PARAMS ((rtx x));\n-static enum machine_mode xtensa_find_mode_for_size PARAMS ((unsigned));\n-static struct machine_function * xtensa_init_machine_status PARAMS ((void));\n-static void printx PARAMS ((FILE *, signed int));\n-static void xtensa_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static unsigned int xtensa_multibss_section_type_flags\n-  PARAMS ((tree, const char *, int)) ATTRIBUTE_UNUSED;\n-static void xtensa_select_rtx_section\n-  PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));\n-static bool xtensa_rtx_costs PARAMS ((rtx, int, int, int *));\n+static int b4const_or_zero (int);\n+static enum internal_test map_test_to_internal_test (enum rtx_code);\n+static rtx gen_int_relational (enum rtx_code, rtx, rtx, int *);\n+static rtx gen_float_relational (enum rtx_code, rtx, rtx);\n+static rtx gen_conditional_move (rtx);\n+static rtx fixup_subreg_mem (rtx);\n+static enum machine_mode xtensa_find_mode_for_size (unsigned);\n+static struct machine_function * xtensa_init_machine_status (void);\n+static void printx (FILE *, signed int);\n+static void xtensa_function_epilogue (FILE *, HOST_WIDE_INT);\n+static unsigned int xtensa_multibss_section_type_flags (tree, const char *,\n+\t\t\t\t\t\t\tint) ATTRIBUTE_UNUSED;\n+static void xtensa_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t       unsigned HOST_WIDE_INT);\n+static bool xtensa_rtx_costs (rtx, int, int, int *);\n \n static int current_function_arg_words;\n static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n@@ -240,8 +241,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n  */\n \n int\n-xtensa_b4constu (v)\n-     int v;\n+xtensa_b4constu (int v)\n {\n   switch (v)\n     {\n@@ -267,29 +267,25 @@ xtensa_b4constu (v)\n }\n \n int\n-xtensa_simm8x256 (v)\n-     int v;\n+xtensa_simm8x256 (int v)\n {\n   return (v & 255) == 0 && (v >= -32768 && v <= 32512);\n }\n \n int\n-xtensa_ai4const (v)\n-     int v;\n+xtensa_ai4const (int v)\n {\n   return (v == -1 || (v >= 1 && v <= 15));\n }\n \n int\n-xtensa_simm7 (v)\n-     int v;\n+xtensa_simm7 (int v)\n {\n   return v >= -32 && v <= 95;\n }\n \n int\n-xtensa_b4const (v)\n-     int v;\n+xtensa_b4const (int v)\n {\n   switch (v)\n     {\n@@ -315,50 +311,43 @@ xtensa_b4const (v)\n }\n \n int\n-xtensa_simm8 (v)\n-     int v;\n+xtensa_simm8 (int v)\n {\n   return v >= -128 && v <= 127;\n }\n \n int\n-xtensa_tp7 (v)\n-     int v;\n+xtensa_tp7 (int v)\n {\n   return (v >= 7 && v <= 22);\n }\n \n int\n-xtensa_lsi4x4 (v)\n-     int v;\n+xtensa_lsi4x4 (int v)\n {\n   return (v & 3) == 0 && (v >= 0 && v <= 60);\n }\n \n int\n-xtensa_simm12b (v)\n-     int v;\n+xtensa_simm12b (int v)\n {\n   return v >= -2048 && v <= 2047;\n }\n \n int\n-xtensa_uimm8 (v)\n-     int v;\n+xtensa_uimm8 (int v)\n {\n   return v >= 0 && v <= 255;\n }\n \n int\n-xtensa_uimm8x2 (v)\n-     int v;\n+xtensa_uimm8x2 (int v)\n {\n   return (v & 1) == 0 && (v >= 0 && v <= 510);\n }\n \n int\n-xtensa_uimm8x4 (v)\n-     int v;\n+xtensa_uimm8x4 (int v)\n {\n   return (v & 3) == 0 && (v >= 0 && v <= 1020);\n }\n@@ -368,8 +357,7 @@ xtensa_uimm8x4 (v)\n    works even when reg_renumber is not initialized.  */\n \n int\n-xt_true_regnum (x)\n-     rtx x;\n+xt_true_regnum (rtx x)\n {\n   if (GET_CODE (x) == REG)\n     {\n@@ -392,9 +380,7 @@ xt_true_regnum (x)\n \n \n int\n-add_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+add_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return (xtensa_simm8 (INTVAL (op)) || xtensa_simm8x256 (INTVAL (op)));\n@@ -404,9 +390,7 @@ add_operand (op, mode)\n \n \n int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return xtensa_simm8 (INTVAL (op));\n@@ -416,9 +400,7 @@ arith_operand (op, mode)\n \n \n int\n-nonimmed_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+nonimmed_operand (rtx op, enum machine_mode mode)\n {\n   /* We cannot use the standard nonimmediate_operand() predicate because\n      it includes constant pool memory operands.  */\n@@ -431,9 +413,7 @@ nonimmed_operand (op, mode)\n \n \n int\n-mem_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mem_operand (rtx op, enum machine_mode mode)\n {\n   /* We cannot use the standard memory_operand() predicate because\n      it includes constant pool memory operands.  */\n@@ -446,9 +426,7 @@ mem_operand (op, mode)\n \n \n int\n-xtensa_valid_move (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+xtensa_valid_move (enum machine_mode mode, rtx *operands)\n {\n   /* Either the destination or source must be a register, and the\n      MAC16 accumulator doesn't count.  */\n@@ -477,9 +455,7 @@ xtensa_valid_move (mode, operands)\n \n \n int\n-mask_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mask_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return xtensa_mask_immediate (INTVAL (op));\n@@ -489,19 +465,15 @@ mask_operand (op, mode)\n \n \n int\n-extui_fldsz_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+extui_fldsz_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT)\n \t  && xtensa_mask_immediate ((1 << INTVAL (op)) - 1));\n }\n \n \n int\n-sext_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+sext_operand (rtx op, enum machine_mode mode)\n {\n   if (TARGET_SEXT)\n     return nonimmed_operand (op, mode);\n@@ -510,18 +482,14 @@ sext_operand (op, mode)\n \n \n int\n-sext_fldsz_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+sext_fldsz_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT) && xtensa_tp7 (INTVAL (op) - 1));\n }\n \n \n int\n-lsbitnum_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+lsbitnum_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -534,8 +502,7 @@ lsbitnum_operand (op, mode)\n \n \n static int\n-b4const_or_zero (v)\n-     int v;\n+b4const_or_zero (int v)\n {\n   if (v == 0)\n     return TRUE;\n@@ -544,9 +511,7 @@ b4const_or_zero (v)\n \n \n int\n-branch_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+branch_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return b4const_or_zero (INTVAL (op));\n@@ -556,9 +521,7 @@ branch_operand (op, mode)\n \n \n int\n-ubranch_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+ubranch_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return xtensa_b4constu (INTVAL (op));\n@@ -568,9 +531,7 @@ ubranch_operand (op, mode)\n \n \n int\n-call_insn_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if ((GET_CODE (op) == REG)\n       && (op != arg_pointer_rtx)\n@@ -619,9 +580,7 @@ call_insn_operand (op, mode)\n \n \n int\n-move_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode)\n       || memory_operand (op, mode))\n@@ -659,8 +618,7 @@ move_operand (op, mode)\n \n \n int\n-smalloffset_mem_p (op)\n-     rtx op;\n+smalloffset_mem_p (rtx op)\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -682,8 +640,7 @@ smalloffset_mem_p (op)\n \n \n int\n-constantpool_address_p (addr)\n-     rtx addr;\n+constantpool_address_p (rtx addr)\n {\n   rtx sym = addr;\n \n@@ -713,8 +670,7 @@ constantpool_address_p (addr)\n \n \n int\n-constantpool_mem_p (op)\n-     rtx op;\n+constantpool_mem_p (rtx op)\n {\n   if (GET_CODE (op) == MEM)\n     return constantpool_address_p (XEXP (op, 0));\n@@ -725,9 +681,7 @@ constantpool_mem_p (op)\n /* Accept the floating point constant 1 in the appropriate mode.  */\n \n int\n-const_float_1_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_float_1_operand (rtx op, enum machine_mode mode)\n {\n   REAL_VALUE_TYPE d;\n   static REAL_VALUE_TYPE onedf;\n@@ -756,9 +710,7 @@ const_float_1_operand (op, mode)\n \n \n int\n-fpmem_offset_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+fpmem_offset_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return xtensa_mem_offset (INTVAL (op), SFmode);\n@@ -767,9 +719,7 @@ fpmem_offset_operand (op, mode)\n \n \n void\n-xtensa_extend_reg (dst, src)\n-     rtx dst;\n-     rtx src;\n+xtensa_extend_reg (rtx dst, rtx src)\n {\n   rtx temp = gen_reg_rtx (SImode);\n   rtx shift = GEN_INT (BITS_PER_WORD - GET_MODE_BITSIZE (GET_MODE (src)));\n@@ -784,9 +734,7 @@ xtensa_extend_reg (dst, src)\n \n \n int\n-branch_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+branch_operator (rtx x, enum machine_mode mode)\n {\n   if (GET_MODE (x) != mode)\n     return FALSE;\n@@ -806,9 +754,7 @@ branch_operator (x, mode)\n \n \n int\n-ubranch_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+ubranch_operator (rtx x, enum machine_mode mode)\n {\n   if (GET_MODE (x) != mode)\n     return FALSE;\n@@ -826,9 +772,7 @@ ubranch_operator (x, mode)\n \n \n int\n-boolean_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+boolean_operator (rtx x, enum machine_mode mode)\n {\n   if (GET_MODE (x) != mode)\n     return FALSE;\n@@ -846,8 +790,7 @@ boolean_operator (x, mode)\n \n \n int\n-xtensa_mask_immediate (v)\n-     int v;\n+xtensa_mask_immediate (int v)\n {\n #define MAX_MASK_SIZE 16\n   int mask_size;\n@@ -866,9 +809,7 @@ xtensa_mask_immediate (v)\n \n \n int\n-xtensa_mem_offset (v, mode)\n-     unsigned v;\n-     enum machine_mode mode;\n+xtensa_mem_offset (unsigned v, enum machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -898,11 +839,10 @@ xtensa_mem_offset (v, mode)\n }\n \n \n-/* Make normal rtx_code into something we can index from an array */\n+/* Make normal rtx_code into something we can index from an array.  */\n \n static enum internal_test\n-map_test_to_internal_test (test_code)\n-     enum rtx_code test_code;\n+map_test_to_internal_test (enum rtx_code test_code)\n {\n   enum internal_test test = ITEST_MAX;\n \n@@ -929,15 +869,15 @@ map_test_to_internal_test (test_code)\n    the comparison expression.  */\n \n static rtx\n-gen_int_relational (test_code, cmp0, cmp1, p_invert)\n-     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n-     rtx cmp0;\t\t\t/* first operand to compare */\n-     rtx cmp1;\t\t\t/* second operand to compare */\n-     int *p_invert;\t\t/* whether branch needs to reverse its test */\n+gen_int_relational (enum rtx_code test_code, /* relational test (EQ, etc) */\n+\t\t    rtx cmp0, /* first operand to compare */\n+\t\t    rtx cmp1, /* second operand to compare */\n+\t\t    int *p_invert /* whether branch needs to reverse test */)\n {\n-  struct cmp_info {\n+  struct cmp_info\n+  {\n     enum rtx_code test_code;\t/* test code to use in insn */\n-    int (*const_range_p) PARAMS ((int)); /* predicate function to check range */\n+    int (*const_range_p) (int);\t/* predicate function to check range */\n     int const_add;\t\t/* constant to add (convert LE -> LT) */\n     int reverse_regs;\t\t/* reverse registers in test */\n     int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n@@ -1028,12 +968,11 @@ gen_int_relational (test_code, cmp0, cmp1, p_invert)\n    the comparison expression.  */\n \n static rtx\n-gen_float_relational (test_code, cmp0, cmp1)\n-     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n-     rtx cmp0;\t\t\t/* first operand to compare */\n-     rtx cmp1;\t\t\t/* second operand to compare */\n+gen_float_relational (enum rtx_code test_code, /* relational test (EQ, etc) */\n+\t\t      rtx cmp0, /* first operand to compare */\n+\t\t      rtx cmp1 /* second operand to compare */)\n {\n-  rtx (*gen_fn) PARAMS ((rtx, rtx, rtx));\n+  rtx (*gen_fn) (rtx, rtx, rtx);\n   rtx brtmp;\n   int reverse_regs, invert;\n \n@@ -1065,9 +1004,7 @@ gen_float_relational (test_code, cmp0, cmp1)\n \n \n void\n-xtensa_expand_conditional_branch (operands, test_code)\n-     rtx *operands;\n-     enum rtx_code test_code;\n+xtensa_expand_conditional_branch (rtx *operands, enum rtx_code test_code)\n {\n   enum cmp_type type = branch_type;\n   rtx cmp0 = branch_cmp[0];\n@@ -1114,8 +1051,7 @@ xtensa_expand_conditional_branch (operands, test_code)\n \n \n static rtx\n-gen_conditional_move (cmp)\n-     rtx cmp;\n+gen_conditional_move (rtx cmp)\n {\n   enum rtx_code code = GET_CODE (cmp);\n   rtx op0 = branch_cmp[0];\n@@ -1188,12 +1124,10 @@ gen_conditional_move (cmp)\n \n \n int\n-xtensa_expand_conditional_move (operands, isflt)\n-    rtx *operands;\n-    int isflt;\n+xtensa_expand_conditional_move (rtx *operands, int isflt)\n {\n   rtx cmp;\n-  rtx (*gen_fn) PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+  rtx (*gen_fn) (rtx, rtx, rtx, rtx, rtx);\n \n   if (!(cmp = gen_conditional_move (operands[1])))\n     return 0;\n@@ -1214,13 +1148,12 @@ xtensa_expand_conditional_move (operands, isflt)\n \n \n int\n-xtensa_expand_scc (operands)\n-     rtx *operands;\n+xtensa_expand_scc (rtx *operands)\n {\n   rtx dest = operands[0];\n   rtx cmp = operands[1];\n   rtx one_tmp, zero_tmp;\n-  rtx (*gen_fn) PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+  rtx (*gen_fn) (rtx, rtx, rtx, rtx, rtx);\n \n   if (!(cmp = gen_conditional_move (cmp)))\n     return 0;\n@@ -1242,9 +1175,7 @@ xtensa_expand_scc (operands)\n    for the output, i.e., the input operands are twice as big as MODE.  */\n \n void\n-xtensa_split_operand_pair (operands, mode)\n-     rtx operands[4];\n-     enum machine_mode mode;\n+xtensa_split_operand_pair (rtx operands[4], enum machine_mode mode)\n {\n   switch (GET_CODE (operands[1]))\n     {\n@@ -1291,9 +1222,7 @@ xtensa_split_operand_pair (operands, mode)\n    normally.  */\n \n int\n-xtensa_emit_move_sequence (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n+xtensa_emit_move_sequence (rtx *operands, enum machine_mode mode)\n {\n   if (CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != CONSTANT_P_RTX\n@@ -1345,8 +1274,7 @@ xtensa_emit_move_sequence (operands, mode)\n \n \n static rtx\n-fixup_subreg_mem (x)\n-     rtx x;\n+fixup_subreg_mem (rtx x)\n {\n   if (GET_CODE (x) == SUBREG\n       && GET_CODE (SUBREG_REG (x)) == REG\n@@ -1373,9 +1301,7 @@ fixup_subreg_mem (x)\n    the scheduler away, we should avoid any problems.  */\n \n bool\n-xtensa_copy_incoming_a7 (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n+xtensa_copy_incoming_a7 (rtx *operands, enum machine_mode mode)\n {\n   if (a7_overlap_mentioned_p (operands[1])\n       && !cfun->machine->incoming_a7_copied)\n@@ -1441,8 +1367,7 @@ xtensa_copy_incoming_a7 (operands, mode)\n    operands[3] is the alignment */\n \n int\n-xtensa_expand_block_move (operands)\n-     rtx *operands;\n+xtensa_expand_block_move (rtx *operands)\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n@@ -1484,16 +1409,14 @@ xtensa_expand_block_move (operands)\n     temporary registers, store those N values, and repeat until the\n     complete block has been moved.  N=delay_slots+1 */\n \n-struct meminsnbuf {\n+struct meminsnbuf\n+{\n   char template[30];\n   rtx operands[2];\n };\n \n void\n-xtensa_emit_block_move (operands, tmpregs, delay_slots)\n-     rtx *operands;\n-     rtx *tmpregs;\n-     int delay_slots;\n+xtensa_emit_block_move (rtx *operands, rtx *tmpregs, int delay_slots)\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n@@ -1582,8 +1505,7 @@ xtensa_emit_block_move (operands, tmpregs, delay_slots)\n \n \n static enum machine_mode\n-xtensa_find_mode_for_size (item_size)\n-     unsigned item_size;\n+xtensa_find_mode_for_size (unsigned item_size)\n {\n   enum machine_mode mode, tmode;\n \n@@ -1614,8 +1536,7 @@ xtensa_find_mode_for_size (item_size)\n \n \n void\n-xtensa_expand_nonlocal_goto (operands)\n-     rtx *operands;\n+xtensa_expand_nonlocal_goto (rtx *operands)\n {\n   rtx goto_handler = operands[1];\n   rtx containing_fp = operands[3];\n@@ -1638,14 +1559,14 @@ xtensa_expand_nonlocal_goto (operands)\n \n \n static struct machine_function *\n-xtensa_init_machine_status ()\n+xtensa_init_machine_status (void)\n {\n   return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n \n void\n-xtensa_setup_frame_addresses ()\n+xtensa_setup_frame_addresses (void)\n {\n   /* Set flag to cause FRAME_POINTER_REQUIRED to be set.  */\n   cfun->machine->accesses_prev_frame = 1;\n@@ -1670,9 +1591,7 @@ xtensa_setup_frame_addresses ()\n    when the branch is taken.  */\n \n void\n-xtensa_emit_loop_end (insn, operands)\n-     rtx insn;\n-     rtx *operands;\n+xtensa_emit_loop_end (rtx insn, rtx *operands)\n {\n   char done = 0;\n \n@@ -1711,9 +1630,7 @@ xtensa_emit_loop_end (insn, operands)\n \n \n char *\n-xtensa_emit_call (callop, operands)\n-     int callop;\n-     rtx *operands;\n+xtensa_emit_call (int callop, rtx *operands)\n {\n   static char result[64];\n   rtx tgt = operands[callop];\n@@ -1732,8 +1649,7 @@ xtensa_emit_call (callop, operands)\n /* Return the stabs register number to use for 'regno'.  */\n \n int\n-xtensa_dbx_register_number (regno)\n-     int regno;\n+xtensa_dbx_register_number (int regno)\n {\n   int first = -1;\n \n@@ -1777,21 +1693,18 @@ xtensa_dbx_register_number (regno)\n /* Initialize CUMULATIVE_ARGS for a function.  */\n \n void\n-init_cumulative_args (cum, fntype, libname)\n-     CUMULATIVE_ARGS *cum;\t/* argument info to initialize */\n-     tree fntype ATTRIBUTE_UNUSED;\t/* tree ptr for function decl */\n-     rtx libname ATTRIBUTE_UNUSED;\t/* SYMBOL_REF of library name or 0 */\n+init_cumulative_args (CUMULATIVE_ARGS *cum,\n+\t\t      tree fntype ATTRIBUTE_UNUSED,\n+\t\t      rtx libname ATTRIBUTE_UNUSED)\n {\n   cum->arg_words = 0;\n }\n \n+\n /* Advance the argument to the next argument position.  */\n \n void\n-function_arg_advance (cum, mode, type)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type)\n {\n   int words, max;\n   int *arg_words;\n@@ -1811,14 +1724,12 @@ function_arg_advance (cum, mode, type)\n \n \n /* Return an RTL expression containing the register for the given mode,\n-   or 0 if the argument is to be passed on the stack.  */\n+   or 0 if the argument is to be passed on the stack.  INCOMING_P is non-zero\n+   if this is an incoming argument to the current function.  */\n \n rtx\n-function_arg (cum, mode, type, incoming_p)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int incoming_p;\t\t/* computing the incoming registers? */\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t      int incoming_p)\n {\n   int regbase, words, max;\n   int *arg_words;\n@@ -1871,7 +1782,7 @@ function_arg (cum, mode, type, incoming_p)\n \n \n void\n-override_options ()\n+override_options (void)\n {\n   int regno;\n   enum machine_mode mode;\n@@ -1982,11 +1893,9 @@ override_options ()\n */\n \n static void\n-printx (file, val)\n-     FILE *file;\n-     signed int val;\n+printx (FILE *file, signed int val)\n {\n-  /* print a hexadecimal value in a nice way */\n+  /* Print a hexadecimal value in a nice way.  */\n   if ((val > -0xa) && (val < 0xa))\n     fprintf (file, \"%d\", val);\n   else if (val < 0)\n@@ -1997,10 +1906,7 @@ printx (file, val)\n \n \n void\n-print_operand (file, x, letter)\n-     FILE *file;\t\t/* file to write to */\n-     rtx x;\t\t\t/* operand to print */\n-     int letter;\t\t/* %<letter> or 0 */\n+print_operand (FILE *file, rtx x, int letter)\n {\n   if (!x)\n     error (\"PRINT_OPERAND null pointer\");\n@@ -2146,9 +2052,7 @@ print_operand (file, x, letter)\n    reference whose address is ADDR.  ADDR is an RTL expression.  */\n \n void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   if (!addr)\n     error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n@@ -2204,11 +2108,7 @@ print_operand_address (file, addr)\n \n \n void\n-xtensa_output_literal (file, x, mode, labelno)\n-     FILE *file;\n-     rtx x;\n-     enum machine_mode mode;\n-     int labelno;\n+xtensa_output_literal (FILE *file, rtx x, enum machine_mode mode, int labelno)\n {\n   long value_long[2];\n   REAL_VALUE_TYPE r;\n@@ -2274,10 +2174,9 @@ xtensa_output_literal (file, x, mode, labelno)\n #define XTENSA_STACK_ALIGN(LOC) (((LOC) + STACK_BYTES-1) & ~(STACK_BYTES-1))\n \n long\n-compute_frame_size (size)\n-     int size;\t\t\t/* # of var. bytes allocated */\n+compute_frame_size (int size)\n {\n-  /* add space for the incoming static chain value */\n+  /* Add space for the incoming static chain value.  */\n   if (current_function_needs_context)\n     size += (1 * UNITS_PER_WORD);\n \n@@ -2290,7 +2189,7 @@ compute_frame_size (size)\n \n \n int\n-xtensa_frame_pointer_required ()\n+xtensa_frame_pointer_required (void)\n {\n   /* The code to expand builtin_frame_addr and builtin_return_addr\n      currently uses the hard_frame_pointer instead of frame_pointer.\n@@ -2305,7 +2204,7 @@ xtensa_frame_pointer_required ()\n \n \n void\n-xtensa_expand_prologue ()\n+xtensa_expand_prologue (void)\n {\n   HOST_WIDE_INT total_size;\n   rtx size_rtx;\n@@ -2379,18 +2278,15 @@ xtensa_expand_prologue ()\n /* Clear variables at function end.  */\n \n void\n-xtensa_function_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+xtensa_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t  HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   xtensa_current_frame_size = 0;\n }\n \n \n rtx\n-xtensa_return_addr (count, frame)\n-     int count;\n-     rtx frame;\n+xtensa_return_addr (int count, rtx frame)\n {\n   rtx result, retaddr;\n \n@@ -2428,7 +2324,7 @@ xtensa_return_addr (count, frame)\n    argument word N for N >= 6.  */\n \n tree\n-xtensa_build_va_list ()\n+xtensa_build_va_list (void)\n {\n   tree f_stk, f_reg, f_ndx, record, type_decl;\n \n@@ -2461,7 +2357,7 @@ xtensa_build_va_list ()\n    address of the saved registers.  */\n \n rtx\n-xtensa_builtin_saveregs ()\n+xtensa_builtin_saveregs (void)\n {\n   rtx gp_regs, dest;\n   int arg_words = current_function_arg_words;\n@@ -2499,9 +2395,7 @@ xtensa_builtin_saveregs ()\n    current function to fill in an initial va_list.  */\n \n void\n-xtensa_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n+xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n {\n   tree f_stk, stk;\n   tree f_reg, reg;\n@@ -2545,8 +2439,7 @@ xtensa_va_start (valist, nextarg)\n /* Implement `va_arg'.  */\n \n rtx\n-xtensa_va_arg (valist, type)\n-     tree valist, type;\n+xtensa_va_arg (tree valist, tree type)\n {\n   tree f_stk, stk;\n   tree f_reg, reg;\n@@ -2581,8 +2474,7 @@ xtensa_va_arg (valist, type)\n   /* First align __va_ndx to a double word boundary if necessary for this arg:\n \n      if (__alignof__ (TYPE) > 4)\n-       (AP).__va_ndx = (((AP).__va_ndx + 7) & -8)\n-  */\n+       (AP).__va_ndx = (((AP).__va_ndx + 7) & -8); */\n \n   if (TYPE_ALIGN (type) > BITS_PER_WORD)\n     {\n@@ -2599,8 +2491,7 @@ xtensa_va_arg (valist, type)\n   /* Increment __va_ndx to point past the argument:\n \n      orig_ndx = (AP).__va_ndx;\n-     (AP).__va_ndx += __va_size (TYPE);\n-  */\n+     (AP).__va_ndx += __va_size (TYPE); */\n \n   orig_ndx = gen_reg_rtx (SImode);\n   r = expand_expr (ndx, orig_ndx, SImode, EXPAND_NORMAL);\n@@ -2618,8 +2509,7 @@ xtensa_va_arg (valist, type)\n \n      if ((AP).__va_ndx <= __MAX_ARGS_IN_REGISTERS * 4\n          && !MUST_PASS_IN_STACK (type))\n-        __array = (AP).__va_reg;\n-  */\n+        __array = (AP).__va_reg; */\n \n   array = gen_reg_rtx (Pmode);\n \n@@ -2652,8 +2542,7 @@ xtensa_va_arg (valist, type)\n \t if (orig_ndx < __MAX_ARGS_IN_REGISTERS * 4)\n \t     (AP).__va_ndx = __MAX_ARGS_IN_REGISTERS * 4 + __va_size (TYPE);\n \t __array = (AP).__va_stk;\n-       }\n-  */\n+       } */\n \n   lab_false2 = gen_label_rtx ();\n   emit_cmp_and_jump_insns (orig_ndx,\n@@ -2684,8 +2573,7 @@ xtensa_va_arg (valist, type)\n \t\t\t\t: __va_size (TYPE))\n \n      The results are endian-dependent because values smaller than one word\n-     are aligned differently.\n-  */\n+     are aligned differently.  */\n \n   size = gen_reg_rtx (SImode);\n   emit_move_insn (size, va_size);\n@@ -2718,10 +2606,7 @@ xtensa_va_arg (valist, type)\n \n \n enum reg_class\n-xtensa_preferred_reload_class (x, class, isoutput)\n-     rtx x;\n-     enum reg_class class;\n-     int isoutput;\n+xtensa_preferred_reload_class (rtx x, enum reg_class class, int isoutput)\n {\n   if (!isoutput && CONSTANT_P (x) && GET_CODE (x) == CONST_DOUBLE)\n     return NO_REGS;\n@@ -2740,11 +2625,9 @@ xtensa_preferred_reload_class (x, class, isoutput)\n \n \n enum reg_class\n-xtensa_secondary_reload_class (class, mode, x, isoutput)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x;\n-     int isoutput;\n+xtensa_secondary_reload_class (enum reg_class class,\n+\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t       rtx x, int isoutput)\n {\n   int regno;\n \n@@ -2768,7 +2651,7 @@ xtensa_secondary_reload_class (class, mode, x, isoutput)\n \n \n void\n-order_regs_for_local_alloc ()\n+order_regs_for_local_alloc (void)\n {\n   if (!leaf_function_p ())\n     {\n@@ -2813,8 +2696,7 @@ order_regs_for_local_alloc ()\n    references to a7 (as opposed to hard_frame_pointer_rtx).  */\n \n int\n-a7_overlap_mentioned_p (x)\n-     rtx x;\n+a7_overlap_mentioned_p (rtx x)\n {\n   int i, j;\n   unsigned int x_regno;\n@@ -2863,10 +2745,7 @@ a7_overlap_mentioned_p (x)\n    name ends with \".bss\", add SECTION_BSS to the flags.  */\n \n static unsigned int\n-xtensa_multibss_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+xtensa_multibss_section_type_flags (tree decl, const char *name, int reloc)\n {\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n   const char *suffix;\n@@ -2889,23 +2768,20 @@ xtensa_multibss_section_type_flags (decl, name, reloc)\n /* The literal pool stays with the function.  */\n \n static void\n-xtensa_select_rtx_section (mode, x, align)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+xtensa_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   rtx x ATTRIBUTE_UNUSED,\n+\t\t\t   unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   function_section (current_function_decl);\n }\n \n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-xtensa_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+xtensa_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {"}]}