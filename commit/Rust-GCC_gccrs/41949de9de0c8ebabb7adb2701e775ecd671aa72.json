{"sha": "41949de9de0c8ebabb7adb2701e775ecd671aa72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE5NDlkZTlkZTBjOGViYWJiN2FkYjI3MDFlNzc1ZWNkNjcxYWE3Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-30T12:48:51Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-30T12:48:51Z"}, "message": "[11/n] PR85694: Apply pattern matching to pattern definition statements\n\nAlthough the first pattern match wins in the sense that no later\nfunction can match the *old* gimple statement, it still seems worth\nletting them match the *new* gimple statements, just like we would if\nthe original IR had included that sequence from the outset.\n\nThis is mostly true after the later patch for PR85694, where e.g. we\ncould recognise:\n\n   signed char a;\n   int ap = (int) a;\n   int res = ap * 3;\n\nas the pattern:\n\n   short ap' = (short) a;\n   short res = ap' * 3;     // S1: definition statement\n   int res = (int) res;     // S2: pattern statement\n\nand then apply the mult pattern to \"ap' * 3\".  The patch needs to\ncome first (without its own test cases) so that the main over-widening\npatch doesn't regress anything.\n\n2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* gimple-iterator.c (gsi_for_stmt): Add a new overload that takes\n\tthe containing gimple_seq *.\n\t* gimple-iterator.h (gsi_for_stmt): Declare it.\n\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern)\n\t(vect_recog_sad_pattern, vect_recog_widen_sum_pattern)\n\t(vect_recog_widen_shift_pattern, vect_recog_rotate_pattern)\n\t(vect_recog_vector_vector_shift_pattern, vect_recog_divmod_pattern)\n\t(vect_recog_mask_conversion_pattern): Remove STMT_VINFO_IN_PATTERN_P\n\tchecks.\n\t(vect_init_pattern_stmt, vect_set_pattern_stmt): New functions,\n\tsplit out from...\n\t(vect_mark_pattern_stmts): ...here.  Handle cases in which the\n\tstatement being replaced is part of an existing pattern\n\tdefinition sequence, inserting the new pattern statements before\n\tthe original one.\n\t(vect_pattern_recog_1): Don't return a bool.  If the statement\n\tis already part of a pattern, instead apply pattern matching\n\tto the pattern definition statements.  Don't clear the\n\tSTMT_VINFO_RELATED_STMT if is_pattern_stmt_p.\n\t(vect_pattern_recog): Don't break after the first match;\n\tcontinue processing the pattern definition statements instead.\n\tDon't bail out for STMT_VINFO_IN_PATTERN_P here.\n\nFrom-SVN: r262275", "tree": {"sha": "3894044c9c2a7faa377969c5901acdaa2d748efc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3894044c9c2a7faa377969c5901acdaa2d748efc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41949de9de0c8ebabb7adb2701e775ecd671aa72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41949de9de0c8ebabb7adb2701e775ecd671aa72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41949de9de0c8ebabb7adb2701e775ecd671aa72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41949de9de0c8ebabb7adb2701e775ecd671aa72/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b98e98a98c95029434200cdfc5ad87e204d79b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b98e98a98c95029434200cdfc5ad87e204d79b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b98e98a98c95029434200cdfc5ad87e204d79b4"}], "stats": {"total": 222, "additions": 146, "deletions": 76}, "files": [{"sha": "488ee3e154749b54287ca65e29a90594b60cfc1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41949de9de0c8ebabb7adb2701e775ecd671aa72", "patch": "@@ -1,3 +1,28 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gimple-iterator.c (gsi_for_stmt): Add a new overload that takes\n+\tthe containing gimple_seq *.\n+\t* gimple-iterator.h (gsi_for_stmt): Declare it.\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern)\n+\t(vect_recog_sad_pattern, vect_recog_widen_sum_pattern)\n+\t(vect_recog_widen_shift_pattern, vect_recog_rotate_pattern)\n+\t(vect_recog_vector_vector_shift_pattern, vect_recog_divmod_pattern)\n+\t(vect_recog_mask_conversion_pattern): Remove STMT_VINFO_IN_PATTERN_P\n+\tchecks.\n+\t(vect_init_pattern_stmt, vect_set_pattern_stmt): New functions,\n+\tsplit out from...\n+\t(vect_mark_pattern_stmts): ...here.  Handle cases in which the\n+\tstatement being replaced is part of an existing pattern\n+\tdefinition sequence, inserting the new pattern statements before\n+\tthe original one.\n+\t(vect_pattern_recog_1): Don't return a bool.  If the statement\n+\tis already part of a pattern, instead apply pattern matching\n+\tto the pattern definition statements.  Don't clear the\n+\tSTMT_VINFO_RELATED_STMT if is_pattern_stmt_p.\n+\t(vect_pattern_recog): Don't break after the first match;\n+\tcontinue processing the pattern definition statements instead.\n+\tDon't bail out for STMT_VINFO_IN_PATTERN_P here.\n+\n 2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (vect_reassociating_reduction_p): New function."}, {"sha": "c0131f3654cbdc5fd42ffabf560eea828efe9131", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=41949de9de0c8ebabb7adb2701e775ecd671aa72", "patch": "@@ -619,6 +619,18 @@ gsi_for_stmt (gimple *stmt)\n   return i;\n }\n \n+/* Get an iterator for STMT, which is known to belong to SEQ.  This is\n+   equivalent to starting at the beginning of SEQ and searching forward\n+   until STMT is found.  */\n+\n+gimple_stmt_iterator\n+gsi_for_stmt (gimple *stmt, gimple_seq *seq)\n+{\n+  gimple_stmt_iterator i = gsi_start_1 (seq);\n+  i.ptr = stmt;\n+  return i;\n+}\n+\n /* Finds iterator for PHI.  */\n \n gphi_iterator"}, {"sha": "e23d4b2c47c5b0660fca6ef1de347def80b3dd2c", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=41949de9de0c8ebabb7adb2701e775ecd671aa72", "patch": "@@ -79,6 +79,7 @@ extern void gsi_insert_after (gimple_stmt_iterator *, gimple *,\n \t\t\t      enum gsi_iterator_update);\n extern bool gsi_remove (gimple_stmt_iterator *, bool);\n extern gimple_stmt_iterator gsi_for_stmt (gimple *);\n+extern gimple_stmt_iterator gsi_for_stmt (gimple *, gimple_seq *);\n extern gphi_iterator gsi_for_phi (gphi *);\n extern void gsi_move_after (gimple_stmt_iterator *, gimple_stmt_iterator *);\n extern void gsi_move_before (gimple_stmt_iterator *, gimple_stmt_iterator *);"}, {"sha": "80793173e2dd438521681a8d257f41c45a2a4f76", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 108, "deletions": 76, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41949de9de0c8ebabb7adb2701e775ecd671aa72/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=41949de9de0c8ebabb7adb2701e775ecd671aa72", "patch": "@@ -60,6 +60,42 @@ vect_pattern_detected (const char *name, gimple *stmt)\n     }\n }\n \n+/* Associate pattern statement PATTERN_STMT with ORIG_STMT_INFO.\n+   Set its vector type to VECTYPE if it doesn't have one already.  */\n+\n+static void\n+vect_init_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n+\t\t\ttree vectype)\n+{\n+  stmt_vec_info pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n+  if (pattern_stmt_info == NULL)\n+    {\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt,\n+\t\t\t\t\t     orig_stmt_info->vinfo);\n+      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+    }\n+  gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt_info->stmt));\n+\n+  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = orig_stmt_info->stmt;\n+  STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n+    = STMT_VINFO_DEF_TYPE (orig_stmt_info);\n+  if (!STMT_VINFO_VECTYPE (pattern_stmt_info))\n+    STMT_VINFO_VECTYPE (pattern_stmt_info) = vectype;\n+}\n+\n+/* Set the pattern statement of ORIG_STMT_INFO to PATTERN_STMT.\n+   Also set the vector type of PATTERN_STMT to VECTYPE, if it doesn't\n+   have one already.  */\n+\n+static void\n+vect_set_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n+\t\t       tree vectype)\n+{\n+  STMT_VINFO_IN_PATTERN_P (orig_stmt_info) = true;\n+  STMT_VINFO_RELATED_STMT (orig_stmt_info) = pattern_stmt;\n+  vect_init_pattern_stmt (pattern_stmt, orig_stmt_info, vectype);\n+}\n+\n static inline void\n append_pattern_def_seq (stmt_vec_info stmt_info, gimple *stmt)\n {\n@@ -350,9 +386,6 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-    return NULL;\n-\n   if (!vect_reassociating_reduction_p (stmt_vinfo, PLUS_EXPR,\n \t\t\t\t       &oprnd0, &oprnd1))\n     return NULL;\n@@ -510,9 +543,6 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-    return NULL;\n-\n   tree plus_oprnd0, plus_oprnd1;\n   if (!vect_reassociating_reduction_p (stmt_vinfo, PLUS_EXPR,\n \t\t\t\t       &plus_oprnd0, &plus_oprnd1))\n@@ -1125,9 +1155,6 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n   tree var;\n   bool promotion;\n \n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-    return NULL;\n-\n   /* Look for the following pattern\n           DX = (TYPE) X;\n           sum_1 = DX + sum_0;\n@@ -1603,9 +1630,6 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n   if (!is_gimple_assign (last_stmt) || !vinfo_for_stmt (last_stmt))\n     return NULL;\n \n-  if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (last_stmt)))\n-    return NULL;\n-\n   if (gimple_assign_rhs_code (last_stmt) != LSHIFT_EXPR)\n     return NULL;\n \n@@ -1740,9 +1764,6 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n       return NULL;\n     }\n \n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-    return NULL;\n-\n   lhs = gimple_assign_lhs (last_stmt);\n   oprnd0 = gimple_assign_rhs1 (last_stmt);\n   type = TREE_TYPE (oprnd0);\n@@ -1985,9 +2006,6 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n       return NULL;\n     }\n \n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-    return NULL;\n-\n   lhs = gimple_assign_lhs (last_stmt);\n   oprnd0 = gimple_assign_rhs1 (last_stmt);\n   oprnd1 = gimple_assign_rhs2 (last_stmt);\n@@ -2486,9 +2504,6 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n       return NULL;\n     }\n \n-  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-    return NULL;\n-\n   oprnd0 = gimple_assign_rhs1 (last_stmt);\n   oprnd1 = gimple_assign_rhs2 (last_stmt);\n   itype = TREE_TYPE (oprnd0);\n@@ -3825,11 +3840,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Check for cond expression requiring mask conversion.  */\n   if (rhs_code == COND_EXPR)\n     {\n-      /* vect_recog_mixed_size_cond_pattern could apply.\n-\t Do nothing then.  */\n-      if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-\treturn NULL;\n-\n       vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n \n       if (TREE_CODE (rhs1) == SSA_NAME)\n@@ -4215,42 +4225,59 @@ static inline void\n vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n                          tree pattern_vectype)\n {\n-  stmt_vec_info pattern_stmt_info, def_stmt_info;\n   stmt_vec_info orig_stmt_info = vinfo_for_stmt (orig_stmt);\n-  vec_info *vinfo = orig_stmt_info->vinfo;\n-  gimple *def_stmt;\n+  gimple *def_seq = STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt_info);\n \n-  pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n-  if (pattern_stmt_info == NULL)\n+  bool old_pattern_p = is_pattern_stmt_p (orig_stmt_info);\n+  if (old_pattern_p)\n     {\n-      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n-      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+      /* We're replacing a statement in an existing pattern definition\n+\t sequence.  */\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"replacing earlier pattern \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, orig_stmt, 0);\n+\t}\n+\n+      /* To keep the book-keeping simple, just swap the lhs of the\n+\t old and new statements, so that the old one has a valid but\n+\t unused lhs.  */\n+      tree old_lhs = gimple_get_lhs (orig_stmt);\n+      gimple_set_lhs (orig_stmt, gimple_get_lhs (pattern_stmt));\n+      gimple_set_lhs (pattern_stmt, old_lhs);\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"with \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+\t}\n+\n+      /* Switch to the statement that ORIG replaces.  */\n+      orig_stmt_info\n+\t= vinfo_for_stmt (STMT_VINFO_RELATED_STMT (orig_stmt_info));\n+\n+      /* We shouldn't be replacing the main pattern statement.  */\n+      gcc_assert (STMT_VINFO_RELATED_STMT (orig_stmt_info) != orig_stmt);\n     }\n-  gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt));\n \n-  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = orig_stmt;\n-  STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n-    = STMT_VINFO_DEF_TYPE (orig_stmt_info);\n-  STMT_VINFO_VECTYPE (pattern_stmt_info) = pattern_vectype;\n-  STMT_VINFO_IN_PATTERN_P (orig_stmt_info) = true;\n-  STMT_VINFO_RELATED_STMT (orig_stmt_info) = pattern_stmt;\n-  if (gimple *def_seq = STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt_info))\n+  if (def_seq)\n     for (gimple_stmt_iterator si = gsi_start (def_seq);\n \t !gsi_end_p (si); gsi_next (&si))\n-      {\n-\tdef_stmt = gsi_stmt (si);\n-\tdef_stmt_info = vinfo_for_stmt (def_stmt);\n-\tif (def_stmt_info == NULL)\n-\t  {\n-\t    def_stmt_info = new_stmt_vec_info (def_stmt, vinfo);\n-\t    set_vinfo_for_stmt (def_stmt, def_stmt_info);\n-\t  }\n-\tgimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n-\tSTMT_VINFO_RELATED_STMT (def_stmt_info) = orig_stmt;\n-\tSTMT_VINFO_DEF_TYPE (def_stmt_info) = vect_internal_def;\n-\tif (STMT_VINFO_VECTYPE (def_stmt_info) == NULL_TREE)\n-\t  STMT_VINFO_VECTYPE (def_stmt_info) = pattern_vectype;\n-      }\n+      vect_init_pattern_stmt (gsi_stmt (si), orig_stmt_info, pattern_vectype);\n+\n+  if (old_pattern_p)\n+    {\n+      vect_init_pattern_stmt (pattern_stmt, orig_stmt_info, pattern_vectype);\n+\n+      /* Insert all the new pattern statements before the original one.  */\n+      gimple_seq *orig_def_seq = &STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt_info);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (orig_stmt, orig_def_seq);\n+      gsi_insert_seq_before_without_update (&gsi, def_seq, GSI_SAME_STMT);\n+      gsi_insert_before_without_update (&gsi, pattern_stmt, GSI_SAME_STMT);\n+    }\n+  else\n+    vect_set_pattern_stmt (pattern_stmt, orig_stmt_info, pattern_vectype);\n }\n \n /* Function vect_pattern_recog_1\n@@ -4271,7 +4298,7 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n    This function also does some bookkeeping, as explained in the documentation\n    for vect_recog_pattern.  */\n \n-static bool\n+static void\n vect_pattern_recog_1 (vect_recog_func *recog_func,\n \t\t      gimple_stmt_iterator si,\n \t\t      vec<gimple *> *stmts_to_replace)\n@@ -4282,6 +4309,20 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n   tree pattern_vectype;\n   int i;\n \n+  /* If this statement has already been replaced with pattern statements,\n+     leave the original statement alone, since the first match wins.\n+     Instead try to match against the definition statements that feed\n+     the main pattern statement.  */\n+  stmt_info = vinfo_for_stmt (stmt);\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\tvect_pattern_recog_1 (recog_func, gsi, stmts_to_replace);\n+      return;\n+    }\n+\n   stmts_to_replace->truncate (0);\n   stmts_to_replace->quick_push (stmt);\n   pattern_stmt = recog_func->fn (stmts_to_replace, &pattern_vectype);\n@@ -4294,9 +4335,10 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n \t   i++)\n \t{\n \t  stmt_info = vinfo_for_stmt (stmt);\n-\t  STMT_VINFO_RELATED_STMT (stmt_info) = NULL;\n+\t  if (!is_pattern_stmt_p (stmt_info))\n+\t    STMT_VINFO_RELATED_STMT (stmt_info) = NULL;\n \t}\n-      return false;\n+      return;\n     }\n \n   stmt = stmts_to_replace->last ();\n@@ -4344,7 +4386,7 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n       vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);\n     }\n \n-  return true;\n+  return;\n }\n \n \n@@ -4449,17 +4491,10 @@ vect_pattern_recog (vec_info *vinfo)\n \t{\n \t  basic_block bb = bbs[i];\n \t  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\t    {\n-\t      gimple *stmt = gsi_stmt (si);\n-\t      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t      if (stmt_info && STMT_VINFO_IN_PATTERN_P (stmt_info))\n-\t\tcontinue;\n-\t      /* Scan over all generic vect_recog_xxx_pattern functions.  */\n-\t      for (j = 0; j < NUM_PATTERNS; j++)\n-\t\tif (vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si,\n-\t\t\t\t\t  &stmts_to_replace))\n-\t\t  break;\n-\t    }\n+\t    /* Scan over all generic vect_recog_xxx_pattern functions.  */\n+\t    for (j = 0; j < NUM_PATTERNS; j++)\n+\t      vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si,\n+\t\t\t\t    &stmts_to_replace);\n \t}\n     }\n   else\n@@ -4470,16 +4505,13 @@ vect_pattern_recog (vec_info *vinfo)\n \t{\n \t  gimple *stmt = gsi_stmt (si);\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t  if (stmt_info\n-\t      && (!STMT_VINFO_VECTORIZABLE (stmt_info)\n-\t\t  || STMT_VINFO_IN_PATTERN_P (stmt_info)))\n+\t  if (stmt_info && !STMT_VINFO_VECTORIZABLE (stmt_info))\n \t    continue;\n \n \t  /* Scan over all generic vect_recog_xxx_pattern functions.  */\n \t  for (j = 0; j < NUM_PATTERNS; j++)\n-\t    if (vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si,\n-\t\t\t\t      &stmts_to_replace))\n-\t      break;\n+\t    vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si,\n+\t\t\t\t  &stmts_to_replace);\n \t}\n     }\n }"}]}