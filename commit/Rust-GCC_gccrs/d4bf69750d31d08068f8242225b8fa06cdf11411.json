{"sha": "d4bf69750d31d08068f8242225b8fa06cdf11411", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRiZjY5NzUwZDMxZDA4MDY4ZjgyNDIyMjViOGZhMDZjZGYxMTQxMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-01-02T21:38:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-01-02T21:38:56Z"}, "message": "gimple-fold.c (gimple_fold_builtin_strlen): Use set_strlen_range rather than set_range_info.\n\n\t* gimple-fold.c (gimple_fold_builtin_strlen): Use set_strlen_range\n\trather than set_range_info.\n\t* tree-ssa-strlen.c (set_strlen_range): Extracted from\n\tmaybe_set_strlen_range.  Handle potentially boundary crossing\n\tcases more conservatively.\n\t(maybe_set_strlen_range): Parts refactored into set_strlen_range.\n\tCall set_strlen_range.\n\t* tree-ssa-strlen.h (set_strlen_range): Add prototype.\n\n\t* gcc.dg/strlenopt-36.c: Update.\n\t* gcc.dg/strlenopt-45.c: Update.\n\t* gcc.c-torture/execute/strlen-5.c: New test.\n\t* gcc.c-torture/execute/strlen-6.c: New test.\n\t* gcc.c-torture/execute/strlen-7.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267531", "tree": {"sha": "bd9ca177fac5106370caa472164a9245fffa7ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd9ca177fac5106370caa472164a9245fffa7ab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4bf69750d31d08068f8242225b8fa06cdf11411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4bf69750d31d08068f8242225b8fa06cdf11411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4bf69750d31d08068f8242225b8fa06cdf11411", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4bf69750d31d08068f8242225b8fa06cdf11411/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec1faddf89cb8219c426418d7af772655d5ad40e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1faddf89cb8219c426418d7af772655d5ad40e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1faddf89cb8219c426418d7af772655d5ad40e"}], "stats": {"total": 1154, "additions": 926, "deletions": 228}, "files": [{"sha": "b4e2f25a2cc25a9efeb74205791c24d8ad7b46fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -1,6 +1,16 @@\n 2019-01-02  Martin Sebor  <msebor@redhat.com>\n             Jeff Law  <law@redhat.com>\n \n+\n+\t* gimple-fold.c (gimple_fold_builtin_strlen): Use set_strlen_range\n+\trather than set_range_info.\n+\t* tree-ssa-strlen.c (set_strlen_range): Extracted from\n+\tmaybe_set_strlen_range.  Handle potentially boundary crossing\n+\tcases more conservatively.\n+\t(maybe_set_strlen_range): Parts refactored into set_strlen_range.\n+\tCall set_strlen_range.\n+\t* tree-ssa-strlen.h (set_strlen_range): Add prototype.\n+\t\n \tPR middle-end/88663\n \t* gimple-fold.c (get_range_strlen): Update prototype to no longer\n \tneed the flexp argument."}, {"sha": "0bb4db5e160090b4e8e632d23a96a8625d05b56c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -3739,10 +3739,9 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n+  /* Set the strlen() range to [0, MAXLEN].  */\n   if (tree lhs = gimple_call_lhs (stmt))\n-    if (TREE_CODE (lhs) == SSA_NAME\n-\t&& INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-      set_range_info (lhs, VR_RANGE, minlen, maxlen);\n+    set_strlen_range (lhs, maxlen);\n \n   return false;\n }"}, {"sha": "1d5a8769faeb1da1a6eacacff6e7232096b16097", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -1,3 +1,12 @@\n+2019-01-02  Martin Sebor  <msebor@redhat.com>\n+            Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/strlenopt-36.c: Update.\n+\t* gcc.dg/strlenopt-45.c: Update.\n+\t* gcc.c-torture/execute/strlen-5.c: New test.\n+\t* gcc.c-torture/execute/strlen-6.c: New test.\n+\t* gcc.c-torture/execute/strlen-7.c: New test.\n+\n 2019-01-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR testsuite/87304"}, {"sha": "9af57d5ee394f1f329ee3f8daaec2a44d7b2c138", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-5.c", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-5.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -0,0 +1,653 @@\n+/* Test to verify that even strictly undefined strlen() calls with\n+   unterminated character arrays yield the \"expected\" results when\n+   the terminating nul is present in a subsequent suobobject.  */\n+\n+extern __SIZE_TYPE__ strlen (const char *);\n+\n+unsigned nfails;\n+\n+#define A(expr, N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *s = (expr);\t\t\t\t\t\\\n+    unsigned n = strlen (s);\t\t\t\t\t\\\n+    ((n == N)\t\t\t\t\t\t\t\\\n+     ? 0\t\t\t\t\t\t\t\\\n+     : (__builtin_printf (\"line %i: strlen (%s = \\\"%s\\\")\"\t\\\n+\t\t\t  \" == %u failed\\n\",\t\t\t\\\n+\t\t\t  __LINE__, #expr, s, N),\t\t\\\n+\t++nfails));\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+int idx;\n+\n+\n+const char ca[][4] = {\n+  { '1', '2', '3', '4' }, { '5' },\n+  { '1', '2', '3', '4' }, { '5', '6' },\n+  { '1', '2', '3', '4' }, { '5', '6', '7' },\n+  { '1', '2', '3', '4' }, { '5', '6', '7', '8' },\n+  { '9' }\n+};\n+\n+static void test_const_global_arrays (void)\n+{\n+  A (ca[0], 5);\n+  A (&ca[0][0], 5);\n+  A (&ca[0][1], 4);\n+  A (&ca[0][3], 2);\n+\n+  int i = 0;\n+  A (ca[i], 5);\n+  A (&ca[i][0], 5);\n+  A (&ca[i][1], 4);\n+  A (&ca[i][3], 2);\n+\n+  int j = i;\n+  A (&ca[i][i], 5);\n+  A (&ca[i][j + 1], 4);\n+  A (&ca[i][j + 2], 3);\n+\n+  A (&ca[idx][i], 5);\n+  A (&ca[idx][j + 1], 4);\n+  A (&ca[idx][j + 2], 3);\n+\n+  A (&ca[idx][idx], 5);\n+  A (&ca[idx][idx + 1], 4);\n+  A (&ca[idx][idx + 2], 3);\n+\n+  A (&ca[0][++j], 4);\n+  A (&ca[0][++j], 3);\n+  A (&ca[0][++j], 2);\n+\n+  if (j != 3)\n+    ++nfails;\n+}\n+\n+\n+static void test_const_local_arrays (void)\n+{\n+  const char a[][4] = {\n+    { '1', '2', '3', '4' }, { '5' },\n+    { '1', '2', '3', '4' }, { '5', '6' },\n+    { '1', '2', '3', '4' }, { '5', '6', '7' },\n+    { '1', '2', '3', '4' }, { '5', '6', '7', '8' },\n+    { '9' }\n+  };\n+\n+  A (a[0], 5);\n+  A (&a[0][0], 5);\n+  A (&a[0][1], 4);\n+  A (&a[0][3], 2);\n+\n+  int i = 0;\n+  A (a[i], 5);\n+  A (&a[i][0], 5);\n+  A (&a[i][1], 4);\n+  A (&a[i][3], 2);\n+\n+  int j = i;\n+  A (&a[i][i], 5);\n+  A (&a[i][j + 1], 4);\n+  A (&a[i][j + 2], 3);\n+\n+  A (&a[idx][i], 5);\n+  A (&a[idx][j + 1], 4);\n+  A (&a[idx][j + 2], 3);\n+\n+  A (&a[idx][idx], 5);\n+  A (&a[idx][idx + 1], 4);\n+  A (&a[idx][idx + 2], 3);\n+\n+  A (&a[0][++j], 4);\n+  A (&a[0][++j], 3);\n+  A (&a[0][++j], 2);\n+\n+  if (j != 3)\n+    ++nfails;\n+}\n+\n+\n+char va[][4] = {\n+  { '1', '2', '3', '4' }, { '5' },\n+  { '1', '2', '3', '4' }, { '5', '6' },\n+  { '1', '2', '3', '4' }, { '5', '6', '7' },\n+  { '1', '2', '3', '4' }, { '5', '6', '7', '8' },\n+  { '9' }\n+};\n+\n+static void test_nonconst_global_arrays (void)\n+{\n+  {\n+    A (va[0], 5);\n+    A (&va[0][0], 5);\n+    A (&va[0][1], 4);\n+    A (&va[0][3], 2);\n+\n+    int i = 0;\n+    A (va[i], 5);\n+    A (&va[i][0], 5);\n+    A (&va[i][1], 4);\n+    A (&va[i][3], 2);\n+\n+    int j = i;\n+    A (&va[i][i], 5);\n+    A (&va[i][j + 1], 4);\n+    A (&va[i][j + 2], 3);\n+\n+    A (&va[idx][i], 5);\n+    A (&va[idx][j + 1], 4);\n+    A (&va[idx][j + 2], 3);\n+\n+    A (&va[idx][idx], 5);\n+    A (&va[idx][idx + 1], 4);\n+    A (&va[idx][idx + 2], 3);\n+  }\n+\n+  {\n+    A (va[2], 6);\n+    A (&va[2][0], 6);\n+    A (&va[2][1], 5);\n+    A (&va[2][3], 3);\n+\n+    int i = 2;\n+    A (va[i], 6);\n+    A (&va[i][0], 6);\n+    A (&va[i][1], 5);\n+    A (&va[i][3], 3);\n+\n+    int j = i - 1;\n+    A (&va[i][j - 1], 6);\n+    A (&va[i][j], 5);\n+    A (&va[i][j + 1], 4);\n+\n+    A (&va[idx + 2][i - 1], 5);\n+    A (&va[idx + 2][j], 5);\n+    A (&va[idx + 2][j + 1], 4);\n+  }\n+\n+  int j = 0;\n+\n+  A (&va[0][++j], 4);\n+  A (&va[0][++j], 3);\n+  A (&va[0][++j], 2);\n+\n+  if (j != 3)\n+    ++nfails;\n+}\n+\n+\n+static void test_nonconst_local_arrays (void)\n+{\n+  char a[][4] = {\n+    { '1', '2', '3', '4' }, { '5' },\n+    { '1', '2', '3', '4' }, { '5', '6' },\n+    { '1', '2', '3', '4' }, { '5', '6', '7' },\n+    { '1', '2', '3', '4' }, { '5', '6', '7', '8' },\n+    { '9' }\n+  };\n+\n+  A (a[0], 5);\n+  A (&a[0][0], 5);\n+  A (&a[0][1], 4);\n+  A (&a[0][3], 2);\n+\n+  int i = 0;\n+  A (a[i], 5);\n+  A (&a[i][0], 5);\n+  A (&a[i][1], 4);\n+  A (&a[i][3], 2);\n+\n+  int j = i;\n+  A (&a[i][i], 5);\n+  A (&a[i][j + 1], 4);\n+  A (&a[i][j + 2], 3);\n+\n+  A (&a[idx][i], 5);\n+  A (&a[idx][j + 1], 4);\n+  A (&a[idx][j + 2], 3);\n+\n+  A (&a[idx][idx], 5);\n+  A (&a[idx][idx + 1], 4);\n+  A (&a[idx][idx + 2], 3);\n+\n+  A (&a[0][++j], 4);\n+  A (&a[0][++j], 3);\n+  A (&a[0][++j], 2);\n+\n+  if (j != 3)\n+    ++nfails;\n+}\n+\n+\n+struct MemArrays { char a[4], b[4]; };\n+\n+const struct MemArrays cma[] = {\n+  { { '1', '2', '3', '4' }, { '5' } },\n+  { { '1', '2', '3', '4' }, { '5', '6' } },\n+  { { '1', '2', '3', '4' }, { '5', '6' } },\n+  { { '1', '2', '3', '4' }, { '5', '6', '7' } },\n+  { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },\n+  { { '9' }, { '\\0' } }\n+};\n+\n+static void test_const_global_member_arrays (void)\n+{\n+  {\n+    A (cma[0].a, 5);\n+    A (&cma[0].a[0], 5);\n+    A (&cma[0].a[1], 4);\n+    A (&cma[0].a[2], 3);\n+\n+    int i = 0;\n+    A (cma[i].a, 5);\n+    A (&cma[i].a[0], 5);\n+    A (&cma[i].a[1], 4);\n+    A (&cma[i].a[2], 3);\n+\n+    int j = i;\n+    A (&cma[i].a[j], 5);\n+    A (&cma[i].a[j + 1], 4);\n+    A (&cma[i].a[j + 2], 3);\n+\n+    A (&cma[idx].a[i], 5);\n+    A (&cma[idx].a[j + 1], 4);\n+    A (&cma[idx].a[j + 2], 3);\n+\n+    A (&cma[idx].a[idx], 5);\n+    A (&cma[idx].a[idx + 1], 4);\n+    A (&cma[idx].a[idx + 2], 3);\n+  }\n+\n+  {\n+    A (cma[1].a, 6);\n+    A (&cma[1].a[0], 6);\n+    A (&cma[1].a[1], 5);\n+    A (&cma[1].a[2], 4);\n+\n+    int i = 1;\n+    A (cma[i].a, 6);\n+    A (&cma[i].a[0], 6);\n+    A (&cma[i].a[1], 5);\n+    A (&cma[i].a[2], 4);\n+\n+    int j = i - 1;\n+    A (&cma[i].a[j], 6);\n+    A (&cma[i].a[j + 1], 5);\n+    A (&cma[i].a[j + 2], 4);\n+\n+    A (&cma[idx + 1].a[j], 6);\n+    A (&cma[idx + 1].a[j + 1], 5);\n+    A (&cma[idx + 1].a[j + 2], 4);\n+\n+    A (&cma[idx + 1].a[idx], 6);\n+    A (&cma[idx + 1].a[idx + 1], 5);\n+    A (&cma[idx + 1].a[idx + 2], 4);\n+  }\n+\n+  {\n+    A (cma[4].a, 9);\n+    A (&cma[4].a[0], 9);\n+    A (&cma[4].a[1], 8);\n+    A (&cma[4].b[0], 5);\n+\n+    int i = 4;\n+    A (cma[i].a, 9);\n+    A (&cma[i].a[0], 9);\n+    A (&cma[i].a[1], 8);\n+    A (&cma[i].b[0], 5);\n+\n+    int j = i - 1;\n+    A (&cma[i].a[j], 6);\n+    A (&cma[i].a[j + 1], 5);\n+    A (&cma[i].b[j - 2], 4);\n+\n+    A (&cma[idx + 4].a[j], 6);\n+    A (&cma[idx + 4].a[j + 1], 5);\n+    A (&cma[idx + 4].b[j - 2], 4);\n+\n+    A (&cma[idx + 4].a[idx], 9);\n+    A (&cma[idx + 4].a[idx + 1], 8);\n+    A (&cma[idx + 4].b[idx + 1], 4);\n+  }\n+}\n+\n+\n+static void test_const_local_member_arrays (void)\n+{\n+  const struct MemArrays ma[] = {\n+    { { '1', '2', '3', '4' }, { '5' } },\n+    { { '1', '2', '3', '4' }, { '5', '6' } },\n+    { { '1', '2', '3', '4' }, { '5', '6' } },\n+    { { '1', '2', '3', '4' }, { '5', '6', '7' } },\n+    { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },\n+    { { '9' }, { '\\0' } }\n+  };\n+\n+  {\n+    A (ma[0].a, 5);\n+    A (&ma[0].a[0], 5);\n+    A (&ma[0].a[1], 4);\n+    A (&ma[0].a[2], 3);\n+\n+    int i = 0;\n+    A (ma[i].a, 5);\n+    A (&ma[i].a[0], 5);\n+    A (&ma[i].a[1], 4);\n+    A (&ma[i].a[2], 3);\n+\n+    int j = i;\n+    A (&ma[i].a[j], 5);\n+    A (&ma[i].a[j + 1], 4);\n+    A (&ma[i].a[j + 2], 3);\n+\n+    A (&ma[idx].a[i], 5);\n+    A (&ma[idx].a[j + 1], 4);\n+    A (&ma[idx].a[j + 2], 3);\n+\n+    A (&ma[idx].a[idx], 5);\n+    A (&ma[idx].a[idx + 1], 4);\n+    A (&ma[idx].a[idx + 2], 3);\n+  }\n+\n+  {\n+    A (ma[1].a, 6);\n+    A (&ma[1].a[0], 6);\n+    A (&ma[1].a[1], 5);\n+    A (&ma[1].a[2], 4);\n+\n+    int i = 1;\n+    A (ma[i].a, 6);\n+    A (&ma[i].a[0], 6);\n+    A (&ma[i].a[1], 5);\n+    A (&ma[i].a[2], 4);\n+\n+    int j = i - 1;\n+    A (&ma[i].a[j], 6);\n+    A (&ma[i].a[j + 1], 5);\n+    A (&ma[i].a[j + 2], 4);\n+\n+    A (&ma[idx + 1].a[j], 6);\n+    A (&ma[idx + 1].a[j + 1], 5);\n+    A (&ma[idx + 1].a[j + 2], 4);\n+\n+    A (&ma[idx + 1].a[idx], 6);\n+    A (&ma[idx + 1].a[idx + 1], 5);\n+    A (&ma[idx + 1].a[idx + 2], 4);\n+  }\n+\n+  {\n+    A (ma[4].a, 9);\n+    A (&ma[4].a[0], 9);\n+    A (&ma[4].a[1], 8);\n+    A (&ma[4].b[0], 5);\n+\n+    int i = 4;\n+    A (ma[i].a, 9);\n+    A (&ma[i].a[0], 9);\n+    A (&ma[i].a[1], 8);\n+    A (&ma[i].b[0], 5);\n+\n+    int j = i - 1;\n+    A (&ma[i].a[j], 6);\n+    A (&ma[i].a[j + 1], 5);\n+    A (&ma[i].b[j - 2], 4);\n+\n+    A (&ma[idx + 4].a[j], 6);\n+    A (&ma[idx + 4].a[j + 1], 5);\n+    A (&ma[idx + 4].b[j - 2], 4);\n+\n+    A (&ma[idx + 4].a[idx], 9);\n+    A (&ma[idx + 4].a[idx + 1], 8);\n+    A (&ma[idx + 4].b[idx + 1], 4);\n+  }\n+}\n+\n+struct MemArrays vma[] = {\n+  { { '1', '2', '3', '4' }, { '5' } },\n+  { { '1', '2', '3', '4' }, { '5', '6' } },\n+  { { '1', '2', '3', '4' }, { '5', '6' } },\n+  { { '1', '2', '3', '4' }, { '5', '6', '7' } },\n+  { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },\n+  { { '9' }, { '\\0' } }\n+};\n+\n+static void test_nonconst_global_member_arrays (void)\n+{\n+  {\n+    A (vma[0].a, 5);\n+    A (&vma[0].a[0], 5);\n+    A (&vma[0].a[1], 4);\n+    A (&vma[0].a[2], 3);\n+\n+    int i = 0;\n+    A (vma[i].a, 5);\n+    A (&vma[i].a[0], 5);\n+    A (&vma[i].a[1], 4);\n+    A (&vma[i].a[2], 3);\n+\n+    int j = i;\n+    A (&vma[i].a[j], 5);\n+    A (&vma[i].a[j + 1], 4);\n+    A (&vma[i].a[j + 2], 3);\n+\n+    A (&vma[idx].a[i], 5);\n+    A (&vma[idx].a[j + 1], 4);\n+    A (&vma[idx].a[j + 2], 3);\n+\n+    A (&vma[idx].a[idx], 5);\n+    A (&vma[idx].a[idx + 1], 4);\n+    A (&vma[idx].a[idx + 2], 3);\n+  }\n+\n+  {\n+    A (vma[1].a, 6);\n+    A (&vma[1].a[0], 6);\n+    A (&vma[1].a[1], 5);\n+    A (&vma[1].a[2], 4);\n+\n+    int i = 1;\n+    A (vma[i].a, 6);\n+    A (&vma[i].a[0], 6);\n+    A (&vma[i].a[1], 5);\n+    A (&vma[i].a[2], 4);\n+\n+    int j = i - 1;\n+    A (&vma[i].a[j], 6);\n+    A (&vma[i].a[j + 1], 5);\n+    A (&vma[i].a[j + 2], 4);\n+\n+    A (&vma[idx + 1].a[j], 6);\n+    A (&vma[idx + 1].a[j + 1], 5);\n+    A (&vma[idx + 1].a[j + 2], 4);\n+\n+    A (&vma[idx + 1].a[idx], 6);\n+    A (&vma[idx + 1].a[idx + 1], 5);\n+    A (&vma[idx + 1].a[idx + 2], 4);\n+  }\n+\n+  {\n+    A (vma[4].a, 9);\n+    A (&vma[4].a[0], 9);\n+    A (&vma[4].a[1], 8);\n+    A (&vma[4].b[0], 5);\n+\n+    int i = 4;\n+    A (vma[i].a, 9);\n+    A (&vma[i].a[0], 9);\n+    A (&vma[i].a[1], 8);\n+    A (&vma[i].b[0], 5);\n+\n+    int j = i - 1;\n+    A (&vma[i].a[j], 6);\n+    A (&vma[i].a[j + 1], 5);\n+    A (&vma[i].b[j - 2], 4);\n+\n+    A (&vma[idx + 4].a[j], 6);\n+    A (&vma[idx + 4].a[j + 1], 5);\n+    A (&vma[idx + 4].b[j - 2], 4);\n+\n+    A (&vma[idx + 4].a[idx], 9);\n+    A (&vma[idx + 4].a[idx + 1], 8);\n+    A (&vma[idx + 4].b[idx + 1], 4);\n+  }\n+}\n+\n+\n+static void test_nonconst_local_member_arrays (void)\n+{\n+  struct MemArrays ma[] = {\n+    { { '1', '2', '3', '4' }, { '5' } },\n+    { { '1', '2', '3', '4' }, { '5', '6' } },\n+    { { '1', '2', '3', '4' }, { '5', '6' } },\n+    { { '1', '2', '3', '4' }, { '5', '6', '7' } },\n+    { { '1', '2', '3', '4' }, { '5', '6', '7', '8' } },\n+    { { '9' }, { '\\0' } }\n+  };\n+\n+  {\n+    A (ma[0].a, 5);\n+    A (&ma[0].a[0], 5);\n+    A (&ma[0].a[1], 4);\n+    A (&ma[0].a[2], 3);\n+\n+    int i = 0;\n+    A (ma[i].a, 5);\n+    A (&ma[i].a[0], 5);\n+    A (&ma[i].a[1], 4);\n+    A (&ma[i].a[2], 3);\n+\n+    int j = i;\n+    A (&ma[i].a[j], 5);\n+    A (&ma[i].a[j + 1], 4);\n+    A (&ma[i].a[j + 2], 3);\n+\n+    A (&ma[idx].a[i], 5);\n+    A (&ma[idx].a[j + 1], 4);\n+    A (&ma[idx].a[j + 2], 3);\n+\n+    A (&ma[idx].a[idx], 5);\n+    A (&ma[idx].a[idx + 1], 4);\n+    A (&ma[idx].a[idx + 2], 3);\n+  }\n+\n+  {\n+    A (ma[1].a, 6);\n+    A (&ma[1].a[0], 6);\n+    A (&ma[1].a[1], 5);\n+    A (&ma[1].a[2], 4);\n+\n+    int i = 1;\n+    A (ma[i].a, 6);\n+    A (&ma[i].a[0], 6);\n+    A (&ma[i].a[1], 5);\n+    A (&ma[i].a[2], 4);\n+\n+    int j = i - 1;\n+    A (&ma[i].a[j], 6);\n+    A (&ma[i].a[j + 1], 5);\n+    A (&ma[i].a[j + 2], 4);\n+\n+    A (&ma[idx + 1].a[j], 6);\n+    A (&ma[idx + 1].a[j + 1], 5);\n+    A (&ma[idx + 1].a[j + 2], 4);\n+\n+    A (&ma[idx + 1].a[idx], 6);\n+    A (&ma[idx + 1].a[idx + 1], 5);\n+    A (&ma[idx + 1].a[idx + 2], 4);\n+  }\n+\n+  {\n+    A (ma[4].a, 9);\n+    A (&ma[4].a[0], 9);\n+    A (&ma[4].a[1], 8);\n+    A (&ma[4].b[0], 5);\n+\n+    int i = 4;\n+    A (ma[i].a, 9);\n+    A (&ma[i].a[0], 9);\n+    A (&ma[i].a[1], 8);\n+    A (&ma[i].b[0], 5);\n+\n+    int j = i - 1;\n+    A (&ma[i].a[j], 6);\n+    A (&ma[i].a[j + 1], 5);\n+    A (&ma[i].b[j - 2], 4);\n+\n+    A (&ma[idx + 4].a[j], 6);\n+    A (&ma[idx + 4].a[j + 1], 5);\n+    A (&ma[idx + 4].b[j - 2], 4);\n+\n+    A (&ma[idx + 4].a[idx], 9);\n+    A (&ma[idx + 4].a[idx + 1], 8);\n+    A (&ma[idx + 4].b[idx + 1], 4);\n+  }\n+}\n+\n+\n+union UnionMemberArrays\n+{\n+  struct { char a[4], b[4]; } a;\n+  struct { char a[8]; } c;\n+};\n+\n+const union UnionMemberArrays cu = {\n+  { { '1', '2', '3', '4' }, { '5', } }\n+};\n+\n+static void test_const_union_member_arrays (void)\n+{\n+  A (cu.a.a, 5);\n+  A (cu.a.b, 1);\n+  A (cu.c.a, 5);\n+\n+  const union UnionMemberArrays clu = {\n+    { { '1', '2', '3', '4' }, { '5', '6' } }\n+  };\n+\n+  A (clu.a.a, 6);\n+  A (clu.a.b, 2);\n+  A (clu.c.a, 6);\n+}\n+\n+\n+union UnionMemberArrays vu = {\n+  { { '1', '2', '3', '4' }, { '5', '6' } }\n+};\n+\n+static void test_nonconst_union_member_arrays (void)\n+{\n+  A (vu.a.a, 6);\n+  A (vu.a.b, 2);\n+  A (vu.c.a, 6);\n+\n+  union UnionMemberArrays lvu = {\n+    { { '1', '2', '3', '4' }, { '5', '6', '7' } }\n+  };\n+\n+  A (lvu.a.a, 7);\n+  A (lvu.a.b, 3);\n+  A (lvu.c.a, 7);\n+}\n+\n+\n+int main (void)\n+{\n+  test_const_global_arrays ();\n+  test_const_local_arrays ();\n+\n+  test_nonconst_global_arrays ();\n+  test_nonconst_local_arrays ();\n+\n+  test_const_global_member_arrays ();\n+  test_const_local_member_arrays ();\n+\n+  test_nonconst_global_member_arrays ();\n+  test_nonconst_local_member_arrays ();\n+\n+  test_const_union_member_arrays ();\n+  test_nonconst_union_member_arrays ();\n+\n+  if (nfails)\n+    __builtin_abort ();\n+}"}, {"sha": "1df5b21f6164f75b82ee0e6ccadaadfaa40850df", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-6.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-6.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -0,0 +1,113 @@\n+/* Test to verify that strlen() calls with conditional expressions\n+   and unterminated arrays or pointers to such things as arguments\n+   are evaluated without making assumptions about array sizes.  */\n+\n+extern __SIZE_TYPE__ strlen (const char *);\n+\n+unsigned nfails;\n+\n+#define A(expr, N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *_s = (expr);\t\t\t\t\t\\\n+    unsigned _n = strlen (_s);\t\t\t\t\t\\\n+    ((_n == N)\t\t\t\t\t\t\t\\\n+     ? 0\t\t\t\t\t\t\t\\\n+     : (__builtin_printf (\"line %i: strlen ((%s) = (\\\"%s\\\"))\"\t\\\n+\t\t\t  \" == %u failed\\n\",\t\t\t\\\n+\t\t\t  __LINE__, #expr, _s, N),\t\t\\\n+\t++nfails));\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+volatile int i0 = 0;\n+\n+const char ca[2][3] = { \"12\" };\n+const char cb[2][3] = { { '1', '2', '3', }, { '4' } };\n+\n+char va[2][3] = { \"123\" };\n+char vb[2][3] = { { '1', '2', '3', }, { '4', '5' } };\n+\n+const char *s = \"123456\";\n+\n+\n+static void test_binary_cond_expr_global (void)\n+{\n+  A (i0 ? \"1\" : ca[0], 2);\n+  A (i0 ? ca[0] : \"123\", 3);\n+\n+  /* The call to strlen (cb[0]) is strictly undefined because the array\n+     isn't nul-terminated.  This test verifies that the strlen range\n+     optimization doesn't assume that the argument is necessarily nul\n+     terminated.\n+     Ditto for strlen (vb[0]).  */\n+  A (i0 ? \"1\" : cb[0], 4);              /* GCC 8.2 failure */\n+  A (i0 ? cb[0] : \"12\", 2);\n+\n+  A (i0 ? \"1\" : va[0], 3);              /* GCC 8.2 failure */\n+  A (i0 ? va[0] : \"1234\", 4);\n+\n+  A (i0 ? \"1\" : vb[0], 5);              /* GCC 8.2 failure */\n+  A (i0 ? vb[0] : \"12\", 2);\n+}\n+\n+\n+static void test_binary_cond_expr_local (void)\n+{\n+  const char lca[2][3] = { \"12\" };\n+  const char lcb[2][3] = { { '1', '2', '3', }, { '4' } };\n+\n+  char lva[2][3] = { \"123\" };\n+  char lvb[2][3] = { { '1', '2', '3', }, { '4', '5' } };\n+\n+  /* Also undefined as above.  */\n+  A (i0 ? \"1\" : lca[0], 2);\n+  A (i0 ? lca[0] : \"123\", 3);\n+\n+  A (i0 ? \"1\" : lcb[0], 4);             /* GCC 8.2 failure */\n+  A (i0 ? lcb[0] : \"12\", 2);\n+\n+  A (i0 ? \"1\" : lva[0], 3);             /* GCC 8.2 failure */\n+  A (i0 ? lva[0] : \"1234\", 4);\n+\n+  A (i0 ? \"1\" : lvb[0], 5);             /* GCC 8.2 failure */\n+  A (i0 ? lvb[0] : \"12\", 2);\n+}\n+\n+\n+static void test_ternary_cond_expr (void)\n+{\n+  /* Also undefined.  */\n+  A (i0 == 0 ? s : i0 == 1 ? vb[0] : \"123\", 6);\n+  A (i0 == 0 ? vb[0] : i0 == 1 ? s : \"123\", 5);\n+  A (i0 == 0 ? \"123\" : i0 == 1 ? s : vb[0], 3);\n+}\n+\n+\n+const char (*pca)[3] = &ca[0];\n+const char (*pcb)[3] = &cb[0];\n+\n+char (*pva)[3] = &va[0];\n+char (*pvb)[3] = &vb[0];\n+\n+static void test_binary_cond_expr_arrayptr (void)\n+{\n+  /* Also undefined.  */\n+  A (i0 ? *pca : *pcb, 4);              /* GCC 8.2 failure */\n+  A (i0 ? *pcb : *pca, 2);\n+\n+  A (i0 ? *pva : *pvb, 5);              /* GCC 8.2 failure */\n+  A (i0 ? *pvb : *pva, 3);\n+}\n+\n+\n+int main (void)\n+{\n+  test_binary_cond_expr_global ();\n+  test_binary_cond_expr_local ();\n+\n+  test_ternary_cond_expr ();\n+  test_binary_cond_expr_arrayptr ();\n+\n+  if (nfails)\n+    __builtin_abort ();\n+}"}, {"sha": "884db6547ad01ec62bb9708089fd3d320a64ac74", "filename": "gcc/testsuite/gcc.c-torture/execute/strlen-7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstrlen-7.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -0,0 +1,37 @@\n+/* Test to verify that a strlen() call with a pointer to a dynamic type\n+   doesn't make assumptions based on the static type of the original\n+   pointer.  See g++.dg/init/strlen.C for the corresponding C++ test.  */\n+\n+struct A { int i; char a[1]; void (*p)(); };\n+struct B { char a[sizeof (struct A) - __builtin_offsetof (struct A, a)]; };\n+\n+__attribute__ ((noipa)) void\n+init (char *d, const char *s)\n+{\n+  __builtin_strcpy (d, s);\n+}\n+\n+struct B b;\n+\n+__attribute__ ((noipa)) void\n+test_dynamic_type (struct A *p)\n+{\n+  /* The following call is undefined because it writes past the end\n+     of the p->a subobject, but the corresponding GIMPLE considers\n+     it valid and there's apparently no way to distinguish invalid\n+     cases from ones like it that might be valid.  If/when GIMPLE\n+     changes to make this possible this test can be removed.  */\n+  char *q = (char*)__builtin_memcpy (p->a, &b, sizeof b);\n+\n+  init (q, \"foobar\");\n+\n+  if (6 != __builtin_strlen (q))\n+    __builtin_abort();\n+}\n+\n+int main (void)\n+{\n+  struct A *p = (struct A*)__builtin_malloc (sizeof *p);\n+  test_dynamic_type (p);\n+  return 0;\n+}"}, {"sha": "56e59a431a49c668b9e9b3e97fbb709363c852c0", "filename": "gcc/testsuite/gcc.dg/strlenopt-36.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-36.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -9,23 +9,6 @@ extern char a7[7], a6[6], a5[5], a4[4], a3[3], a2[2], a1[1];\n extern char a0[0];   /* Intentionally not tested here.  */\n extern char ax[];    /* Same.  */\n \n-struct MemArrays {\n-  char a7[7], a6[6], a5[5], a4[4], a3[3], a2[2], a1[1];\n-  char a0[0];   /* Not tested here.  */\n-};\n-\n-struct NestedMemArrays {\n-  struct { char a7[7]; } ma7;\n-  struct { char a6[6]; } ma6;\n-  struct { char a5[5]; } ma5;\n-  struct { char a4[4]; } ma4;\n-  struct { char a3[3]; } ma3;\n-  struct { char a2[2]; } ma2;\n-  struct { char a1[1]; } ma1;\n-  struct { char a0[0]; } ma0;\n-  char last;\n-};\n-\n extern void failure_on_line (int);\n \n #define TEST_FAIL(line)\t\t\t\t\t\\\n@@ -51,36 +34,4 @@ void test_array (void)\n     T (strlen (a1) == 0);  */\n }\n \n-void test_memarray (struct MemArrays *ma)\n-{\n-  T (strlen (ma->a7) < sizeof ma->a7);\n-  T (strlen (ma->a6) < sizeof ma->a6);\n-  T (strlen (ma->a5) < sizeof ma->a5);\n-  T (strlen (ma->a4) < sizeof ma->a4);\n-  T (strlen (ma->a3) < sizeof ma->a3);\n-\n-  /* The following two calls are folded too early which defeats\n-     the strlen() optimization.\n-  T (strlen (ma->a2) == 1);\n-  T (strlen (ma->a1) == 0);  */\n-}\n-\n-/* Verify that the range of strlen(A) of a last struct member is\n-   set even when the array is the sole member of a struct as long\n-   as the struct itself is a member of another struct.  The converse\n-   is tested in stlenopt-37.c.  */\n-void test_nested_memarray (struct NestedMemArrays *ma)\n-{\n-  T (strlen (ma->ma7.a7) < sizeof ma->ma7.a7);\n-  T (strlen (ma->ma6.a6) < sizeof ma->ma6.a6);\n-  T (strlen (ma->ma5.a5) < sizeof ma->ma5.a5);\n-  T (strlen (ma->ma4.a4) < sizeof ma->ma4.a4);\n-  T (strlen (ma->ma3.a3) < sizeof ma->ma3.a3);\n-\n-  /* The following two calls are folded too early which defeats\n-     the strlen() optimization.\n-  T (strlen (ma->ma2.a2) == 1);\n-  T (strlen (ma->ma1.a1) == 0);  */\n-}\n-\n /* { dg-final { scan-tree-dump-not \"failure_on_line\" \"optimized\" } } */"}, {"sha": "31c1e538f6ff28470d3f739d320159294c44ccca", "filename": "gcc/testsuite/gcc.dg/strlenopt-45.c", "status": "modified", "additions": 17, "deletions": 121, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-45.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -2,7 +2,7 @@\n    Test to verify that strnlen built-in expansion works correctly\n    in the absence of tree strlen optimization.\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+   { dg-options \"-O2 -Wall -Wno-stringop-overflow -fdump-tree-optimized\" } */\n \n #include \"strlenopt.h\"\n \n@@ -85,143 +85,39 @@ void elim_strnlen_arr_cst (void)\n   ELIM (strnlen (a3_7[0], 1) < 2);\n   ELIM (strnlen (a3_7[0], 2) < 3);\n   ELIM (strnlen (a3_7[0], 3) < 4);\n-  ELIM (strnlen (a3_7[0], 9) < 8);\n-  ELIM (strnlen (a3_7[0], PTRDIFF_MAX) < 8);\n-  ELIM (strnlen (a3_7[0], SIZE_MAX) < 8);\n-  ELIM (strnlen (a3_7[0], -1) < 8);\n+  ELIM (strnlen (a3_7[0], 9) <= 9);\n+  ELIM (strnlen (a3_7[0], PTRDIFF_MAX) <= sizeof a3_7);\n+  ELIM (strnlen (a3_7[0], SIZE_MAX) <= sizeof a3_7);\n+  ELIM (strnlen (a3_7[0], -1) <= sizeof a3_7);\n \n   ELIM (strnlen (a3_7[2], 0) == 0);\n   ELIM (strnlen (a3_7[2], 1) < 2);\n   ELIM (strnlen (a3_7[2], 2) < 3);\n   ELIM (strnlen (a3_7[2], 3) < 4);\n-  ELIM (strnlen (a3_7[2], 9) < 8);\n-  ELIM (strnlen (a3_7[2], PTRDIFF_MAX) < 8);\n-  ELIM (strnlen (a3_7[2], SIZE_MAX) < 8);\n-  ELIM (strnlen (a3_7[2], -1) < 8);\n+  ELIM (strnlen (a3_7[2], 9) <= 9);\n+  ELIM (strnlen (a3_7[2], PTRDIFF_MAX) < sizeof a3_7);\n+  ELIM (strnlen (a3_7[2], SIZE_MAX) < sizeof a3_7);\n+  ELIM (strnlen (a3_7[2], -1) < sizeof a3_7);\n \n   ELIM (strnlen ((char*)a3_7, 0) == 0);\n   ELIM (strnlen ((char*)a3_7, 1) < 2);\n   ELIM (strnlen ((char*)a3_7, 2) < 3);\n   ELIM (strnlen ((char*)a3_7, 3) < 4);\n   ELIM (strnlen ((char*)a3_7, 9) < 10);\n   ELIM (strnlen ((char*)a3_7, 19) < 20);\n-  ELIM (strnlen ((char*)a3_7, 21) < 22);\n-  ELIM (strnlen ((char*)a3_7, 23) < 22);\n-  ELIM (strnlen ((char*)a3_7, PTRDIFF_MAX) < 22);\n-  ELIM (strnlen ((char*)a3_7, SIZE_MAX) < 22);\n-  ELIM (strnlen ((char*)a3_7, -1) < 22);\n+  ELIM (strnlen ((char*)a3_7, 21) <= sizeof a3_7);\n+  ELIM (strnlen ((char*)a3_7, 23) <= sizeof a3_7);\n+  ELIM (strnlen ((char*)a3_7, PTRDIFF_MAX) <= sizeof a3_7);\n+  ELIM (strnlen ((char*)a3_7, SIZE_MAX) <= sizeof a3_7);\n+  ELIM (strnlen ((char*)a3_7, -1) <= sizeof a3_7);\n \n   ELIM (strnlen (ax, 0) == 0);\n   ELIM (strnlen (ax, 1) < 2);\n   ELIM (strnlen (ax, 2) < 3);\n   ELIM (strnlen (ax, 9) < 10);\n-  ELIM (strnlen (a3, PTRDIFF_MAX) <= PTRDIFF_MAX);\n-  ELIM (strnlen (a3, SIZE_MAX) < PTRDIFF_MAX);\n-  ELIM (strnlen (a3, -1) < PTRDIFF_MAX);\n-}\n-\n-struct MemArrays\n-{\n-  char c;\n-  char a0[0];\n-  char a1[1];\n-  char a3[3];\n-  char a5[5];\n-  char a3_7[3][7];\n-  char ax[1];\n-};\n-\n-void elim_strnlen_memarr_cst (struct MemArrays *p, int i)\n-{\n-  ELIM (strnlen (&p->c, 0) == 0);\n-  ELIM (strnlen (&p->c, 1) < 2);\n-  ELIM (strnlen (&p->c, 9) == 0);\n-  ELIM (strnlen (&p->c, PTRDIFF_MAX) == 0);\n-  ELIM (strnlen (&p->c, SIZE_MAX) == 0);\n-  ELIM (strnlen (&p->c, -1) == 0);\n-\n-  /* Other accesses to internal zero-length arrays are undefined.  */\n-  ELIM (strnlen (p->a0, 0) == 0);\n-\n-  ELIM (strnlen (p->a1, 0) == 0);\n-  ELIM (strnlen (p->a1, 1) < 2);\n-  ELIM (strnlen (p->a1, 9) == 0);\n-  ELIM (strnlen (p->a1, PTRDIFF_MAX) == 0);\n-  ELIM (strnlen (p->a1, SIZE_MAX) == 0);\n-  ELIM (strnlen (p->a1, -1) == 0);\n-\n-  ELIM (strnlen (p->a3, 0) == 0);\n-  ELIM (strnlen (p->a3, 1) < 2);\n-  ELIM (strnlen (p->a3, 2) < 3);\n-  ELIM (strnlen (p->a3, 3) < 4);\n-  ELIM (strnlen (p->a3, 9) < 4);\n-  ELIM (strnlen (p->a3, PTRDIFF_MAX) < 4);\n-  ELIM (strnlen (p->a3, SIZE_MAX) < 4);\n-  ELIM (strnlen (p->a3, -1) < 4);\n-\n-  ELIM (strnlen (p[i].a3, 0) == 0);\n-  ELIM (strnlen (p[i].a3, 1) < 2);\n-  ELIM (strnlen (p[i].a3, 2) < 3);\n-  ELIM (strnlen (p[i].a3, 3) < 4);\n-  ELIM (strnlen (p[i].a3, 9) < 4);\n-  ELIM (strnlen (p[i].a3, PTRDIFF_MAX) < 4);\n-  ELIM (strnlen (p[i].a3, SIZE_MAX) < 4);\n-  ELIM (strnlen (p[i].a3, -1) < 4);\n-\n-  ELIM (strnlen (p->a3_7[0], 0) == 0);\n-  ELIM (strnlen (p->a3_7[0], 1) < 2);\n-  ELIM (strnlen (p->a3_7[0], 2) < 3);\n-  ELIM (strnlen (p->a3_7[0], 3) < 4);\n-  ELIM (strnlen (p->a3_7[0], 9) < 8);\n-  ELIM (strnlen (p->a3_7[0], PTRDIFF_MAX) < 8);\n-  ELIM (strnlen (p->a3_7[0], SIZE_MAX) < 8);\n-  ELIM (strnlen (p->a3_7[0], -1) < 8);\n-\n-  ELIM (strnlen (p->a3_7[2], 0) == 0);\n-  ELIM (strnlen (p->a3_7[2], 1) < 2);\n-  ELIM (strnlen (p->a3_7[2], 2) < 3);\n-  ELIM (strnlen (p->a3_7[2], 3) < 4);\n-  ELIM (strnlen (p->a3_7[2], 9) < 8);\n-  ELIM (strnlen (p->a3_7[2], PTRDIFF_MAX) < 8);\n-  ELIM (strnlen (p->a3_7[2], SIZE_MAX) < 8);\n-  ELIM (strnlen (p->a3_7[2], -1) < 8);\n-\n-  ELIM (strnlen (p->a3_7[i], 0) == 0);\n-  ELIM (strnlen (p->a3_7[i], 1) < 2);\n-  ELIM (strnlen (p->a3_7[i], 2) < 3);\n-  ELIM (strnlen (p->a3_7[i], 3) < 4);\n-\n-#if 0\n-  /* This is tranformed into strnlen ((char*)p + offsetof (a3_7[i]), N)\n-     which makes it impssible to determine the size of the array.  */\n-  ELIM (strnlen (p->a3_7[i], 9) < 8);\n-  ELIM (strnlen (p->a3_7[i], PTRDIFF_MAX) < 8);\n-  ELIM (strnlen (p->a3_7[i], SIZE_MAX) < 8);\n-  ELIM (strnlen (p->a3_7[i], -1) < 8);\n-#else\n-  ELIM (strnlen (p->a3_7[i], 9) < 10);\n-  ELIM (strnlen (p->a3_7[i], 19) < 20);\n-#endif\n-\n-  ELIM (strnlen ((char*)p->a3_7, 0) == 0);\n-  ELIM (strnlen ((char*)p->a3_7, 1) < 2);\n-  ELIM (strnlen ((char*)p->a3_7, 2) < 3);\n-  ELIM (strnlen ((char*)p->a3_7, 3) < 4);\n-  ELIM (strnlen ((char*)p->a3_7, 9) < 10);\n-  ELIM (strnlen ((char*)p->a3_7, 19) < 20);\n-  ELIM (strnlen ((char*)p->a3_7, 21) < 22);\n-  ELIM (strnlen ((char*)p->a3_7, 23) < 22);\n-  ELIM (strnlen ((char*)p->a3_7, PTRDIFF_MAX) < 22);\n-  ELIM (strnlen ((char*)p->a3_7, SIZE_MAX) < 22);\n-  ELIM (strnlen ((char*)p->a3_7, -1) < 22);\n-\n-  ELIM (strnlen (p->ax, 0) == 0);\n-  ELIM (strnlen (p->ax, 1) < 2);\n-  ELIM (strnlen (p->ax, 2) < 3);\n-  ELIM (strnlen (p->ax, 9) < 10);\n-  ELIM (strnlen (p->a3, PTRDIFF_MAX) <= PTRDIFF_MAX);\n-  ELIM (strnlen (p->a3, SIZE_MAX) < PTRDIFF_MAX);\n-  ELIM (strnlen (p->a3, -1) < PTRDIFF_MAX);\n+  ELIM (strnlen (ax, PTRDIFF_MAX) < PTRDIFF_MAX);\n+  ELIM (strnlen (ax, SIZE_MAX) < PTRDIFF_MAX);\n+  ELIM (strnlen (ax, -1) < PTRDIFF_MAX);\n }\n \n "}, {"sha": "55fba88e0f4f7377735d54bb6a79388c90435f15", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 84, "deletions": 55, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -1121,67 +1121,23 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n   update_stmt (last.stmt);\n }\n \n-/* For an LHS that is an SSA_NAME and for strlen() or strnlen() argument\n-   SRC, set LHS range info to [0, min (N, BOUND)] if SRC refers to\n-   a character array A[N] with unknown length bounded by N, and for\n-   strnlen(), by min (N, BOUND).  */\n-\n-static tree\n-maybe_set_strlen_range (tree lhs, tree src, tree bound)\n+/* For an LHS that is an SSA_NAME that is the result of a strlen()\n+   call, or when BOUND is non-null, of a strnlen() call, set LHS\n+   range info to [0, min (MAX, BOUND)] when the range includes more\n+   than one value and return LHS.  Otherwise, when the range\n+   [MIN, MAX] is such that MIN == MAX, return the tree representation\n+   of (MIN). The latter allows callers to fold suitable strnlen() calls\n+   to constants.  */\n+\n+tree\n+set_strlen_range (tree lhs, wide_int max, tree bound /* = NULL_TREE */)\n {\n   if (TREE_CODE (lhs) != SSA_NAME\n       || !INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n     return NULL_TREE;\n \n-  if (TREE_CODE (src) == SSA_NAME)\n-    {\n-      gimple *def = SSA_NAME_DEF_STMT (src);\n-      if (is_gimple_assign (def)\n-\t  && gimple_assign_rhs_code (def) == ADDR_EXPR)\n-\tsrc = gimple_assign_rhs1 (def);\n-    }\n-\n-  wide_int max = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n   wide_int min = wi::zero (max.get_precision ());\n \n-  if (TREE_CODE (src) == ADDR_EXPR)\n-    {\n-      /* The last array member of a struct can be bigger than its size\n-\t suggests if it's treated as a poor-man's flexible array member.  */\n-      src = TREE_OPERAND (src, 0);\n-      bool src_is_array = TREE_CODE (TREE_TYPE (src)) == ARRAY_TYPE;\n-      if (src_is_array\n-\t  && TREE_CODE (src) != MEM_REF\n-\t  && !array_at_struct_end_p (src))\n-\t{\n-\t  tree type = TREE_TYPE (src);\n-\t  if (tree size = TYPE_SIZE_UNIT (type))\n-\t    if (size && TREE_CODE (size) == INTEGER_CST)\n-\t      max = wi::to_wide (size);\n-\n-\t  /* For strlen() the upper bound above is equal to\n-\t     the longest string that can be stored in the array\n-\t     (i.e., it accounts for the terminating nul.  For\n-\t     strnlen() bump up the maximum by one since the array\n-\t     need not be nul-terminated.  */\n-\t  if (!bound && max != 0)\n-\t    --max;\n-\t}\n-      else\n-\t{\n-\t  if (TREE_CODE (src) == COMPONENT_REF && !src_is_array)\n-\t    src = TREE_OPERAND (src, 1);\n-\t  if (DECL_P (src))\n-\t    {\n-\t      /* Handle the unlikely case of strlen (&c) where c is some\n-\t\t variable.  */\n-\t      if (tree size = DECL_SIZE_UNIT (src))\n-\t\tif (TREE_CODE (size) == INTEGER_CST)\n-\t\t  max = wi::to_wide (size);\n-\t    }\n-\t}\n-    }\n-\n   if (bound)\n     {\n       /* For strnlen, adjust MIN and MAX as necessary.  If the bound\n@@ -1205,7 +1161,7 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n \t    {\n \t      /* For a bound in a known range, adjust the range determined\n \t\t above as necessary.  For a bound in some anti-range or\n-\t\t in an unknown range, use the range determined above.  */\n+\t\t in an unknown range, use the range determined by callers.  */\n \t      if (wi::ltu_p (minbound, min))\n \t\tmin = minbound;\n \t      if (wi::ltu_p (maxbound, max))\n@@ -1221,6 +1177,79 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n   return lhs;\n }\n \n+/* For an LHS that is an SSA_NAME and for strlen() or strnlen() argument\n+   SRC, set LHS range info to [0, min (N, BOUND)] if SRC refers to\n+   a character array A[N] with unknown length bounded by N, and for\n+   strnlen(), by min (N, BOUND).  */\n+\n+static tree\n+maybe_set_strlen_range (tree lhs, tree src, tree bound)\n+{\n+  if (TREE_CODE (lhs) != SSA_NAME\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (src) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (src);\n+      if (is_gimple_assign (def)\n+\t  && gimple_assign_rhs_code (def) == ADDR_EXPR)\n+\tsrc = gimple_assign_rhs1 (def);\n+    }\n+\n+  /* The longest string is PTRDIFF_MAX - 1 bytes including the final\n+     NUL so that the difference between a pointer to just past it and\n+     one to its beginning is positive.  */\n+  wide_int max = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node)) - 2;\n+\n+  if (TREE_CODE (src) == ADDR_EXPR)\n+    {\n+      /* The last array member of a struct can be bigger than its size\n+\t suggests if it's treated as a poor-man's flexible array member.  */\n+      src = TREE_OPERAND (src, 0);\n+      if (TREE_CODE (src) != MEM_REF\n+\t  && !array_at_struct_end_p (src))\n+\t{\n+\t  tree type = TREE_TYPE (src);\n+\t  tree size = TYPE_SIZE_UNIT (type);\n+\t  if (size\n+\t      && TREE_CODE (size) == INTEGER_CST\n+\t      && !integer_zerop (size))\n+\t    {\n+\t      /* Even though such uses of strlen would be undefined,\n+\t\t avoid relying on arrays of arrays in case some genius\n+\t\t decides to call strlen on an unterminated array element\n+\t\t that's followed by a terminated one.  Likewise, avoid\n+\t\t assuming that a struct array member is necessarily\n+\t\t nul-terminated (the nul may be in the member that\n+\t\t follows).  In those cases, assume that the length\n+\t\t of the string stored in such an array is bounded\n+\t\t by the size of the enclosing object if one can be\n+\t\t determined.  */\n+\t      tree base = get_base_address (src);\n+\t      if (VAR_P (base))\n+\t\t{\n+\t\t  if (tree size = DECL_SIZE_UNIT (base))\n+\t\t    if (size\n+\t\t\t&& TREE_CODE (size) == INTEGER_CST\n+\t\t\t&& TREE_CODE (TREE_TYPE (base)) != POINTER_TYPE)\n+\t\t      max = wi::to_wide (size);\n+\t\t}\n+\t    }\n+\n+\t  /* For strlen() the upper bound above is equal to\n+\t     the longest string that can be stored in the array\n+\t     (i.e., it accounts for the terminating nul.  For\n+\t     strnlen() bump up the maximum by one since the array\n+\t     need not be nul-terminated.  */\n+\t  if (!bound && max != 0)\n+\t    --max;\n+\t}\n+    }\n+\n+  return set_strlen_range (lhs, max, bound);\n+}\n+\n /* Handle a strlen call.  If strlen of the argument is known, replace\n    the strlen call with the known value, otherwise remember that strlen\n    of the argument is stored in the lhs SSA_NAME.  */"}, {"sha": "0b68465eb2babcc84c92874139de3dd973a36696", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bf69750d31d08068f8242225b8fa06cdf11411/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=d4bf69750d31d08068f8242225b8fa06cdf11411", "patch": "@@ -23,5 +23,6 @@\n \n extern bool is_strlen_related_p (tree, tree);\n extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree);\n+extern tree set_strlen_range (tree, wide_int, tree = NULL_TREE);\n \n #endif   // GCC_TREE_SSA_STRLEN_H"}]}