{"sha": "cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RiNGI3YWEyZjdhNmUzYjQzN2MwZDk5ZTIzZjhlNDAyYjhlZWI3ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-11-14T19:53:28Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-11-14T19:53:28Z"}, "message": "rs6000-c.c (is_float128_p): New helper function.\n\n[gcc]\n2017-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-c.c (is_float128_p): New helper function.\n\t(rs6000_builtin_type_compatible): Treat _Float128 and long double\n\tas being compatible if -mabi=ieeelongdouble.\n\t* config/rs6000/rs6000-builtin.def (BU_FLOAT128_HW_1): New macros\n\tto setup float128 built-ins with hardware support.\n\t(BU_FLOAT128_HW_2): Likewise.\n\t(BU_FLOAT128_HW_3): Likewise.\n\t(BU_FLOAT128_HW_VSX_1): Likewise.\n\t(BU_FLOAT128_HW_VSX_2): Likewise.\n\t(scalar_extract_expq): Change float128 built-in functions to\n\taccommodate having both KFmode and TFmode functions.  Use the\n\tKFmode variant as the default.\n\t(scalar_extract_sigq): Likewise.\n\t(scalar_test_neg_qp): Likewise.\n\t(scalar_insert_exp_q): Likewise.\n\t(scalar_insert_exp_qp): Likewise.\n\t(scalar_test_data_class_qp): Likewise.\n\t(sqrtf128_round_to_odd): Delete processing the round to odd\n\tbuilt-in functions as special built-in functions, and define them\n\tas float128 built-ins.  Use the KFmode variant as the default.\n\t(truncf128_round_to_odd): Likewise.\n\t(addf128_round_to_odd): Likewise.\n\t(subf128_round_to_odd): Likewise.\n\t(mulf128_round_to_odd): Likewise.\n\t(divf128_round_to_odd): Likewise.\n\t(fmaf128_round_to_odd): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add\n\tsupport for KFmode and TFmode xststdcqp calls.\n\t(rs6000_expand_builtin): If long double is IEEE 128-bit floating\n\tpoint, switch the built-in handlers for the get/set float128\n\texponent, get float128 mantissa, float128 test built-ins, and the\n\tfloat128 round to odd built-in functions.  Eliminate creating the\n\tfloat128 round to odd built-in functions as special built-ins.\n\t(rs6000_init_builtins): Eliminate special creation of the float128\n\tround to odd built-in functions.\n\t* config/rs6000/vsx.md (xsxexpqp_<mode>): Change float128 built-in\n\tfunction insns to support both TFmode and KFmode variants.\n\t(xsxsigqp_<mode>): Likewise.\n\t(xsiexpqpf_<mode>): Likewise.\n\t(xsiexpqp_<mode>): Likewise.\n\t(xststdcqp_<mode>): Likewise.\n\t(xststdcnegqp_<mode>): Likewise.\n\t(xststdcqp_<mode>): Likewise.\n\n[gcc/testsuite]\n2017-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/float128-hw4.c: New test.\n\nFrom-SVN: r254740", "tree": {"sha": "039f139325377ed0f00197f1097cf35c2d7d889c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/039f139325377ed0f00197f1097cf35c2d7d889c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/comments", "author": null, "committer": null, "parents": [{"sha": "9684f222a6f15caa6949b8a075d531f824e324e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9684f222a6f15caa6949b8a075d531f824e324e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9684f222a6f15caa6949b8a075d531f824e324e1"}], "stats": {"total": 456, "additions": 325, "deletions": 131}, "files": [{"sha": "0acc10027a10c7fef0e3ff0023fa993ca40a9f00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -1,3 +1,49 @@\n+2017-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-c.c (is_float128_p): New helper function.\n+\t(rs6000_builtin_type_compatible): Treat _Float128 and long double\n+\tas being compatible if -mabi=ieeelongdouble.\n+\t* config/rs6000/rs6000-builtin.def (BU_FLOAT128_HW_1): New macros\n+\tto setup float128 built-ins with hardware support.\n+\t(BU_FLOAT128_HW_2): Likewise.\n+\t(BU_FLOAT128_HW_3): Likewise.\n+\t(BU_FLOAT128_HW_VSX_1): Likewise.\n+\t(BU_FLOAT128_HW_VSX_2): Likewise.\n+\t(scalar_extract_expq): Change float128 built-in functions to\n+\taccommodate having both KFmode and TFmode functions.  Use the\n+\tKFmode variant as the default.\n+\t(scalar_extract_sigq): Likewise.\n+\t(scalar_test_neg_qp): Likewise.\n+\t(scalar_insert_exp_q): Likewise.\n+\t(scalar_insert_exp_qp): Likewise.\n+\t(scalar_test_data_class_qp): Likewise.\n+\t(sqrtf128_round_to_odd): Delete processing the round to odd\n+\tbuilt-in functions as special built-in functions, and define them\n+\tas float128 built-ins.  Use the KFmode variant as the default.\n+\t(truncf128_round_to_odd): Likewise.\n+\t(addf128_round_to_odd): Likewise.\n+\t(subf128_round_to_odd): Likewise.\n+\t(mulf128_round_to_odd): Likewise.\n+\t(divf128_round_to_odd): Likewise.\n+\t(fmaf128_round_to_odd): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add\n+\tsupport for KFmode and TFmode xststdcqp calls.\n+\t(rs6000_expand_builtin): If long double is IEEE 128-bit floating\n+\tpoint, switch the built-in handlers for the get/set float128\n+\texponent, get float128 mantissa, float128 test built-ins, and the\n+\tfloat128 round to odd built-in functions.  Eliminate creating the\n+\tfloat128 round to odd built-in functions as special built-ins.\n+\t(rs6000_init_builtins): Eliminate special creation of the float128\n+\tround to odd built-in functions.\n+\t* config/rs6000/vsx.md (xsxexpqp_<mode>): Change float128 built-in\n+\tfunction insns to support both TFmode and KFmode variants.\n+\t(xsxsigqp_<mode>): Likewise.\n+\t(xsiexpqpf_<mode>): Likewise.\n+\t(xsiexpqp_<mode>): Likewise.\n+\t(xststdcqp_<mode>): Likewise.\n+\t(xststdcnegqp_<mode>): Likewise.\n+\t(xststdcqp_<mode>): Likewise.\n+\n 2017-11-14  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa-threadupdate.c (compute_path_counts): Remove"}, {"sha": "6842c1225281c7a4563e4039ecd94e5eae87ad33", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -909,6 +909,51 @@\n \t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n \n+/* Built-in functions for IEEE 128-bit hardware floating point.  IEEE 128-bit\n+   hardware requires p9-vector and 64-bit operation.  These functions use just\n+   __builtin_ as the prefix.  */\n+#define BU_FLOAT128_HW_1(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_1 (FLOAT128_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_FLOAT128_HW,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_FLOAT128_HW_2(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_2 (FLOAT128_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_FLOAT128_HW,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_FLOAT128_HW_3(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_3 (FLOAT128_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_\" NAME,\t\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_FLOAT128_HW,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+/* Built-in functions for IEEE 128-bit hardware floating point.  These\n+   functions use __builtin_vsx_ as the prefix.  */\n+#define BU_FLOAT128_HW_VSX_1(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_1 (P9V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_FLOAT128_HW,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_FLOAT128_HW_VSX_2(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_2 (P9V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_FLOAT128_HW,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #endif\n \n \f\n@@ -2064,10 +2109,10 @@ BU_P9V_OVERLOAD_3 (RLMI,\t\"rlmi\")\n BU_P9V_64BIT_VSX_1 (VSEEDP,\t\"scalar_extract_exp\",\tCONST,\txsxexpdp)\n BU_P9V_64BIT_VSX_1 (VSESDP,\t\"scalar_extract_sig\",\tCONST,\txsxsigdp)\n \n-BU_P9V_64BIT_VSX_1 (VSEEQP,\t\"scalar_extract_expq\",\tCONST,\txsxexpqp)\n-BU_P9V_64BIT_VSX_1 (VSESQP,\t\"scalar_extract_sigq\",\tCONST,\txsxsigqp)\n+BU_FLOAT128_HW_VSX_1 (VSEEQP,\t\"scalar_extract_expq\",\tCONST,\txsxexpqp_kf)\n+BU_FLOAT128_HW_VSX_1 (VSESQP,\t\"scalar_extract_sigq\",\tCONST,\txsxsigqp_kf)\n \n-BU_P9V_VSX_1 (VSTDCNQP,\t\"scalar_test_neg_qp\",\tCONST,\txststdcnegqp)\n+BU_FLOAT128_HW_VSX_1 (VSTDCNQP, \"scalar_test_neg_qp\",\tCONST,\txststdcnegqp_kf)\n BU_P9V_VSX_1 (VSTDCNDP,\t\"scalar_test_neg_dp\",\tCONST,\txststdcnegdp)\n BU_P9V_VSX_1 (VSTDCNSP,\t\"scalar_test_neg_sp\",\tCONST,\txststdcnegsp)\n \n@@ -2083,15 +2128,15 @@ BU_P9V_VSX_1 (XXBRH_V8HI,\t\"xxbrh_v8hi\",\tCONST,\tp9_xxbrh_v8hi)\n BU_P9V_64BIT_VSX_2 (VSIEDP,\t\"scalar_insert_exp\",\tCONST,\txsiexpdp)\n BU_P9V_64BIT_VSX_2 (VSIEDPF,\t\"scalar_insert_exp_dp\",\tCONST,\txsiexpdpf)\n \n-BU_P9V_64BIT_VSX_2 (VSIEQP,\t\"scalar_insert_exp_q\",\tCONST,\txsiexpqp)\n-BU_P9V_64BIT_VSX_2 (VSIEQPF,\t\"scalar_insert_exp_qp\",\tCONST,\txsiexpqpf)\n+BU_FLOAT128_HW_VSX_2 (VSIEQP,\t\"scalar_insert_exp_q\",\tCONST,\txsiexpqp_kf)\n+BU_FLOAT128_HW_VSX_2 (VSIEQPF,\t\"scalar_insert_exp_qp\",\tCONST,\txsiexpqpf_kf)\n \n BU_P9V_VSX_2 (VSCEDPGT,\t\"scalar_cmp_exp_dp_gt\",\tCONST,\txscmpexpdp_gt)\n BU_P9V_VSX_2 (VSCEDPLT,\t\"scalar_cmp_exp_dp_lt\",\tCONST,\txscmpexpdp_lt)\n BU_P9V_VSX_2 (VSCEDPEQ,\t\"scalar_cmp_exp_dp_eq\",\tCONST,\txscmpexpdp_eq)\n BU_P9V_VSX_2 (VSCEDPUO,\t\"scalar_cmp_exp_dp_unordered\",\tCONST,\txscmpexpdp_unordered)\n \n-BU_P9V_VSX_2 (VSTDCQP,\t\"scalar_test_data_class_qp\",\tCONST,\txststdcqp)\n+BU_FLOAT128_HW_VSX_2 (VSTDCQP, \"scalar_test_data_class_qp\",\tCONST,\txststdcqp_kf)\n BU_P9V_VSX_2 (VSTDCDP,\t\"scalar_test_data_class_dp\",\tCONST,\txststdcdp)\n BU_P9V_VSX_2 (VSTDCSP,\t\"scalar_test_data_class_sp\",\tCONST,\txststdcsp)\n \n@@ -2173,6 +2218,16 @@ BU_P9V_VSX_2 (VEXTRACT4B,   \"vextract4b\",\tCONST,\tvextract4b)\n BU_P9V_VSX_3 (VINSERT4B,    \"vinsert4b\",\tCONST,\tvinsert4b)\n BU_P9V_VSX_3 (VINSERT4B_DI, \"vinsert4b_di\",\tCONST,\tvinsert4b_di)\n \n+/* Hardware IEEE 128-bit floating point round to odd instrucitons added in ISA\n+   3.0 (power9).  */\n+BU_FLOAT128_HW_1 (SQRTF128_ODD,  \"sqrtf128_round_to_odd\",  FP, sqrtkf2_odd)\n+BU_FLOAT128_HW_1 (TRUNCF128_ODD, \"truncf128_round_to_odd\", FP, trunckfdf2_odd)\n+BU_FLOAT128_HW_2 (ADDF128_ODD,   \"addf128_round_to_odd\",   FP, addkf3_odd)\n+BU_FLOAT128_HW_2 (SUBF128_ODD,   \"subf128_round_to_odd\",   FP, subkf3_odd)\n+BU_FLOAT128_HW_2 (MULF128_ODD,   \"mulf128_round_to_odd\",   FP, mulkf3_odd)\n+BU_FLOAT128_HW_2 (DIVF128_ODD,   \"divf128_round_to_odd\",   FP, divkf3_odd)\n+BU_FLOAT128_HW_3 (FMAF128_ODD,   \"fmaf128_round_to_odd\",   FP, fmakf4_odd)\n+\n /* 3 argument vector functions returning void, treated as SPECIAL,\n    added in ISA 3.0 (power9).  */\n BU_P9V_64BIT_AV_X (STXVL,\t\"stxvl\",\tMISC)\n@@ -2497,34 +2552,6 @@ BU_SPECIAL_X (RS6000_BUILTIN_CPU_IS, \"__builtin_cpu_is\",\n BU_SPECIAL_X (RS6000_BUILTIN_CPU_SUPPORTS, \"__builtin_cpu_supports\",\n \t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n \n-BU_SPECIAL_X (FLOAT128_BUILTIN_SQRTF128_ODD,\n-\t      \"__builtin_sqrtf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n-BU_SPECIAL_X (FLOAT128_BUILTIN_TRUNCF128_ODD,\n-\t      \"__builtin_truncf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n-BU_SPECIAL_X (FLOAT128_BUILTIN_ADDF128_ODD,\n-\t      \"__builtin_addf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n-BU_SPECIAL_X (FLOAT128_BUILTIN_SUBF128_ODD,\n-\t      \"__builtin_subf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n-BU_SPECIAL_X (FLOAT128_BUILTIN_MULF128_ODD,\n-\t      \"__builtin_mulf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n-BU_SPECIAL_X (FLOAT128_BUILTIN_DIVF128_ODD,\n-\t      \"__builtin_divf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n-BU_SPECIAL_X (FLOAT128_BUILTIN_FMAF128_ODD,\n-\t      \"__builtin_fmaf128_round_to_odd\",\n-\t      RS6000_BTM_FLOAT128_HW, RS6000_BTC_MISC)\n-\n /* Darwin CfString builtin.  */\n BU_SPECIAL_X (RS6000_BUILTIN_CFSTRING, \"__builtin_cfstring\", RS6000_BTM_ALWAYS,\n \t      RS6000_BTC_MISC)"}, {"sha": "ef21ba32e7aed5cf253bf5b26fd144d92a52f8cb", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -5759,11 +5759,21 @@ rs6000_builtin_type (int id)\n   return id < 0 ? build_pointer_type (t) : t;\n }\n \n-/* Check whether the type of an argument, T, is compatible with a\n-   type ID stored into a struct altivec_builtin_types.  Integer\n-   types are considered compatible; otherwise, the language hook\n-   lang_hooks.types_compatible_p makes the decision.  */\n+/* Check whether the type of an argument, T, is compatible with a type ID\n+   stored into a struct altivec_builtin_types.  Integer types are considered\n+   compatible; otherwise, the language hook lang_hooks.types_compatible_p makes\n+   the decision.  Also allow long double and _Float128 to be compatible if\n+   -mabi=ieeelongdouble.  */\n \n+static inline bool\n+is_float128_p (tree t)\n+{\n+  return (t == float128_type_node\n+\t  || (TARGET_IEEEQUAD\n+\t      && TARGET_LONG_DOUBLE_128\n+\t      && t == long_double_type_node));\n+}\n+  \n static inline bool\n rs6000_builtin_type_compatible (tree t, int id)\n {\n@@ -5773,6 +5783,9 @@ rs6000_builtin_type_compatible (tree t, int id)\n     return false;\n   if (INTEGRAL_TYPE_P (t) && INTEGRAL_TYPE_P (builtin_type))\n     return true;\n+  else if (TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n+\t   && is_float128_p (t) && is_float128_p (builtin_type))\n+    return true;\n   else\n     return lang_hooks.types_compatible_p (t, builtin_type);\n }"}, {"sha": "ab01998c1526f73e410a6aa7d79e0a7e53a7fb7e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 39, "deletions": 72, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -14084,7 +14084,8 @@ rs6000_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n \t  return CONST0_RTX (tmode);\n \t}\n     }\n-  else if (icode == CODE_FOR_xststdcqp\n+  else if (icode == CODE_FOR_xststdcqp_kf\n+\t   || icode == CODE_FOR_xststdcqp_tf\n \t   || icode == CODE_FOR_xststdcdp\n \t   || icode == CODE_FOR_xststdcsp\n \t   || icode == CODE_FOR_xvtstdcdp\n@@ -16701,10 +16702,37 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   bool success;\n   HOST_WIDE_INT mask = rs6000_builtin_info[uns_fcode].mask;\n   bool func_valid_p = ((rs6000_builtin_mask & mask) == mask);\n+  enum insn_code icode = rs6000_builtin_info[uns_fcode].icode;\n+\n+  /* We have two different modes (KFmode, TFmode) that are the IEEE 128-bit\n+     floating point type, depending on whether long double is the IBM extended\n+     double (KFmode) or long double is IEEE 128-bit (TFmode).  It is simpler if\n+     we only define one variant of the built-in function, and switch the code\n+     when defining it, rather than defining two built-ins and using the\n+     overload table in rs6000-c.c to switch between the two.  */\n+  if (FLOAT128_IEEE_P (TFmode))\n+    switch (icode)\n+      {\n+      default:\n+\tbreak;\n+\n+      case CODE_FOR_sqrtkf2_odd:\ticode = CODE_FOR_sqrttf2_odd;\tbreak;\n+      case CODE_FOR_trunckfdf2_odd:\ticode = CODE_FOR_trunctfdf2_odd; break;\n+      case CODE_FOR_addkf3_odd:\t\ticode = CODE_FOR_addtf3_odd;\tbreak;\n+      case CODE_FOR_subkf3_odd:\t\ticode = CODE_FOR_subtf3_odd;\tbreak;\n+      case CODE_FOR_mulkf3_odd:\t\ticode = CODE_FOR_multf3_odd;\tbreak;\n+      case CODE_FOR_divkf3_odd:\t\ticode = CODE_FOR_divtf3_odd;\tbreak;\n+      case CODE_FOR_fmakf4_odd:\t\ticode = CODE_FOR_fmatf4_odd;\tbreak;\n+      case CODE_FOR_xsxexpqp_kf:\ticode = CODE_FOR_xsxexpqp_tf;\tbreak;\n+      case CODE_FOR_xsxsigqp_kf:\ticode = CODE_FOR_xsxsigqp_tf;\tbreak;\n+      case CODE_FOR_xststdcnegqp_kf:\ticode = CODE_FOR_xststdcnegqp_tf; break;\n+      case CODE_FOR_xsiexpqp_kf:\ticode = CODE_FOR_xsiexpqp_tf;\tbreak;\n+      case CODE_FOR_xsiexpqpf_kf:\ticode = CODE_FOR_xsiexpqpf_tf;\tbreak;\n+      case CODE_FOR_xststdcqp_kf:\ticode = CODE_FOR_xststdcqp_tf;\tbreak;\n+      }\n \n   if (TARGET_DEBUG_BUILTIN)\n     {\n-      enum insn_code icode = rs6000_builtin_info[uns_fcode].icode;\n       const char *name1 = rs6000_builtin_info[uns_fcode].name;\n       const char *name2 = (icode != CODE_FOR_nothing)\n \t\t\t   ? get_insn_name ((int) icode)\n@@ -16780,48 +16808,13 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case RS6000_BUILTIN_CPU_SUPPORTS:\n       return cpu_expand_builtin (fcode, exp, target);\n \n-    case FLOAT128_BUILTIN_SQRTF128_ODD:\n-      return rs6000_expand_unop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t ? CODE_FOR_sqrttf2_odd\n-\t\t\t\t\t : CODE_FOR_sqrtkf2_odd, exp, target);\n-\n-    case FLOAT128_BUILTIN_TRUNCF128_ODD:\n-      return rs6000_expand_unop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t ? CODE_FOR_trunctfdf2_odd\n-\t\t\t\t\t : CODE_FOR_trunckfdf2_odd, exp, target);\n-\n-    case FLOAT128_BUILTIN_ADDF128_ODD:\n-      return rs6000_expand_binop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t  ? CODE_FOR_addtf3_odd\n-\t\t\t\t\t  : CODE_FOR_addkf3_odd, exp, target);\n-\n-    case FLOAT128_BUILTIN_SUBF128_ODD:\n-      return rs6000_expand_binop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t  ? CODE_FOR_subtf3_odd\n-\t\t\t\t\t  : CODE_FOR_subkf3_odd, exp, target);\n-\n-    case FLOAT128_BUILTIN_MULF128_ODD:\n-      return rs6000_expand_binop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t  ? CODE_FOR_multf3_odd\n-\t\t\t\t\t  : CODE_FOR_mulkf3_odd, exp, target);\n-\n-    case FLOAT128_BUILTIN_DIVF128_ODD:\n-      return rs6000_expand_binop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t  ? CODE_FOR_divtf3_odd\n-\t\t\t\t\t  : CODE_FOR_divkf3_odd, exp, target);\n-\n-    case FLOAT128_BUILTIN_FMAF128_ODD:\n-      return rs6000_expand_ternop_builtin (TARGET_IEEEQUAD\n-\t\t\t\t\t   ? CODE_FOR_fmatf4_odd\n-\t\t\t\t\t   : CODE_FOR_fmakf4_odd, exp, target);\n-\n     case ALTIVEC_BUILTIN_MASK_FOR_LOAD:\n     case ALTIVEC_BUILTIN_MASK_FOR_STORE:\n       {\n-\tint icode = (BYTES_BIG_ENDIAN ? (int) CODE_FOR_altivec_lvsr_direct\n+\tint icode2 = (BYTES_BIG_ENDIAN ? (int) CODE_FOR_altivec_lvsr_direct\n \t\t     : (int) CODE_FOR_altivec_lvsl_direct);\n-\tmachine_mode tmode = insn_data[icode].operand[0].mode;\n-\tmachine_mode mode = insn_data[icode].operand[1].mode;\n+\tmachine_mode tmode = insn_data[icode2].operand[0].mode;\n+\tmachine_mode mode = insn_data[icode2].operand[1].mode;\n \ttree arg;\n \trtx op, addr, pat;\n \n@@ -16843,10 +16836,10 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n \tif (target == 0\n \t    || GET_MODE (target) != tmode\n-\t    || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\t    || ! (*insn_data[icode2].operand[0].predicate) (target, tmode))\n \t  target = gen_reg_rtx (tmode);\n \n-\tpat = GEN_FCN (icode) (target, op);\n+\tpat = GEN_FCN (icode2) (target, op);\n \tif (!pat)\n \t  return 0;\n \temit_insn (pat);\n@@ -16904,25 +16897,25 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   d = bdesc_1arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_unop_builtin (d->icode, exp, target);\n+      return rs6000_expand_unop_builtin (icode, exp, target);\n \n   /* Handle simple binary operations.  */\n   d = bdesc_2arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_binop_builtin (d->icode, exp, target);\n+      return rs6000_expand_binop_builtin (icode, exp, target);\n \n   /* Handle simple ternary operations.  */\n   d = bdesc_3arg;\n   for (i = 0; i < ARRAY_SIZE  (bdesc_3arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_ternop_builtin (d->icode, exp, target);\n+      return rs6000_expand_ternop_builtin (icode, exp, target);\n \n   /* Handle simple no-argument operations. */\n   d = bdesc_0arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_0arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_zeroop_builtin (d->icode, target);\n+      return rs6000_expand_zeroop_builtin (icode, target);\n \n   gcc_unreachable ();\n }\n@@ -17193,32 +17186,6 @@ rs6000_init_builtins (void)\n   def_builtin (\"__builtin_cpu_is\", ftype, RS6000_BUILTIN_CPU_IS);\n   def_builtin (\"__builtin_cpu_supports\", ftype, RS6000_BUILTIN_CPU_SUPPORTS);\n \n-  ftype = build_function_type_list (ieee128_float_type_node,\n-\t\t\t\t    ieee128_float_type_node, NULL_TREE);\n-  def_builtin (\"__builtin_sqrtf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_SQRTF128_ODD);\n-  def_builtin (\"__builtin_truncf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_TRUNCF128_ODD);\n-\n-  ftype = build_function_type_list (ieee128_float_type_node,\n-\t\t\t\t    ieee128_float_type_node,\n-\t\t\t\t    ieee128_float_type_node, NULL_TREE);\n-  def_builtin (\"__builtin_addf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_ADDF128_ODD);\n-  def_builtin (\"__builtin_subf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_SUBF128_ODD);\n-  def_builtin (\"__builtin_mulf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_MULF128_ODD);\n-  def_builtin (\"__builtin_divf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_DIVF128_ODD);\n-\n-  ftype = build_function_type_list (ieee128_float_type_node,\n-\t\t\t\t    ieee128_float_type_node,\n-\t\t\t\t    ieee128_float_type_node,\n-\t\t\t\t    ieee128_float_type_node, NULL_TREE);\n-  def_builtin (\"__builtin_fmaf128_round_to_odd\", ftype,\n-\t       FLOAT128_BUILTIN_FMAF128_ODD);\n-\n   /* AIX libm provides clog as __clog.  */\n   if (TARGET_XCOFF &&\n       (tdecl = builtin_decl_explicit (BUILT_IN_CLOG)) != NULL_TREE)"}, {"sha": "e48d4b3df7890948c97df3bc75a3def67a3c6ed5", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -4068,9 +4068,9 @@\n ;; ISA 3.0 Binary Floating-Point Support\n \n ;; VSX Scalar Extract Exponent Quad-Precision\n-(define_insn \"xsxexpqp\"\n+(define_insn \"xsxexpqp_<mode>\"\n   [(set (match_operand:DI 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:DI [(match_operand:KF 1 \"altivec_register_operand\" \"v\")]\n+\t(unspec:DI [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")]\n \t UNSPEC_VSX_SXEXPDP))]\n   \"TARGET_P9_VECTOR\"\n   \"xsxexpqp %0,%1\"\n@@ -4086,9 +4086,9 @@\n   [(set_attr \"type\" \"integer\")])\n \n ;; VSX Scalar Extract Significand Quad-Precision\n-(define_insn \"xsxsigqp\"\n+(define_insn \"xsxsigqp_<mode>\"\n   [(set (match_operand:TI 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:TI [(match_operand:KF 1 \"altivec_register_operand\" \"v\")]\n+\t(unspec:TI [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")]\n \t UNSPEC_VSX_SXSIG))]\n   \"TARGET_P9_VECTOR\"\n   \"xsxsigqp %0,%1\"\n@@ -4104,20 +4104,21 @@\n   [(set_attr \"type\" \"integer\")])\n \n ;; VSX Scalar Insert Exponent Quad-Precision Floating Point Argument\n-(define_insn \"xsiexpqpf\"\n-  [(set (match_operand:KF 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:KF [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n-\t\t    (match_operand:DI 2 \"altivec_register_operand\" \"v\")]\n+(define_insn \"xsiexpqpf_<mode>\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:IEEE128\n+\t [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t  (match_operand:DI 2 \"altivec_register_operand\" \"v\")]\n \t UNSPEC_VSX_SIEXPQP))]\n   \"TARGET_P9_VECTOR\"\n   \"xsiexpqp %0,%1,%2\"\n   [(set_attr \"type\" \"vecmove\")])\n \n ;; VSX Scalar Insert Exponent Quad-Precision\n-(define_insn \"xsiexpqp\"\n-  [(set (match_operand:KF 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:KF [(match_operand:TI 1 \"altivec_register_operand\" \"v\")\n-\t\t    (match_operand:DI 2 \"altivec_register_operand\" \"v\")]\n+(define_insn \"xsiexpqp_<mode>\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:IEEE128 [(match_operand:TI 1 \"altivec_register_operand\" \"v\")\n+\t\t\t (match_operand:DI 2 \"altivec_register_operand\" \"v\")]\n \t UNSPEC_VSX_SIEXPQP))]\n   \"TARGET_P9_VECTOR\"\n   \"xsiexpqp %0,%1,%2\"\n@@ -4176,11 +4177,11 @@\n ;;   (Has side effect of setting the lt bit if operand 1 is negative,\n ;;    setting the eq bit if any of the conditions tested by operand 2\n ;;    are satisfied, and clearing the gt and undordered bits to zero.)\n-(define_expand \"xststdcqp\"\n+(define_expand \"xststdcqp_<mode>\"\n   [(set (match_dup 3)\n \t(compare:CCFP\n-\t (unspec:KF\n-\t  [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n+\t (unspec:IEEE128\n+\t  [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n \t   (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n \t  UNSPEC_VSX_STSTDC)\n \t (const_int 0)))\n@@ -4214,11 +4215,11 @@\n })\n \n ;; The VSX Scalar Test Negative Quad-Precision\n-(define_expand \"xststdcnegqp\"\n+(define_expand \"xststdcnegqp_<mode>\"\n   [(set (match_dup 2)\n \t(compare:CCFP\n-\t (unspec:KF\n-\t  [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n+\t (unspec:IEEE128\n+\t  [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n \t   (const_int 0)]\n \t  UNSPEC_VSX_STSTDC)\n \t (const_int 0)))\n@@ -4248,11 +4249,12 @@\n   operands[3] = CONST0_RTX (SImode);\n })\n \n-(define_insn \"*xststdcqp\"\n+(define_insn \"*xststdcqp_<mode>\"\n   [(set (match_operand:CCFP 0 \"\" \"=y\")\n \t(compare:CCFP\n-\t (unspec:KF [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n-\t\t     (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n+\t (unspec:IEEE128\n+\t  [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t   (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n \t  UNSPEC_VSX_STSTDC)\n \t (const_int 0)))]\n   \"TARGET_P9_VECTOR\""}, {"sha": "ec43496dfd3c86dfdd4552a1a92e6cd7788e9637", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-hw4.c: New test.\n+\n 2017-11-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* lib/target-supports.exp (check_effective_target_pie): Adapt"}, {"sha": "be5d0d6eef4fa5497e2fb09f10058da205d4570d", "filename": "gcc/testsuite/gcc.target/powerpc/float128-hw4.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw4.c?ref=cdb4b7aa2f7a6e3b437c0d99e23f8e402b8eeb7d", "patch": "@@ -0,0 +1,135 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mpower9-vector -O2 -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* Insure that the ISA 3.0 IEEE 128-bit floating point built-in functions can\n+   be used with long double when the default is IEEE 128-bit.  */\n+\n+#ifndef TYPE\n+#define TYPE long double\n+#endif\n+\n+unsigned int\n+get_double_exponent (double a)\n+{\n+  return __builtin_vec_scalar_extract_exp (a);\n+}\n+\n+unsigned int\n+get_float128_exponent (TYPE a)\n+{\n+  return __builtin_vec_scalar_extract_exp (a);\n+}\n+\n+unsigned long\n+get_double_mantissa (double a)\n+{\n+  return __builtin_vec_scalar_extract_sig (a);\n+}\n+\n+__uint128_t\n+get_float128_mantissa (TYPE a)\n+{\n+  return __builtin_vec_scalar_extract_sig (a);\n+}\n+\n+double\n+set_double_exponent_ulong (unsigned long a, unsigned long e)\n+{\n+  return __builtin_vec_scalar_insert_exp (a, e);\n+}\n+\n+TYPE\n+set_float128_exponent_uint128 (__uint128_t a, unsigned long e)\n+{\n+  return __builtin_vec_scalar_insert_exp (a, e);\n+}\n+\n+double\n+set_double_exponent_double (double a, unsigned long e)\n+{\n+  return __builtin_vec_scalar_insert_exp (a, e);\n+}\n+\n+TYPE\n+set_float128_exponent_float128 (TYPE a, __uint128_t e)\n+{\n+  return __builtin_vec_scalar_insert_exp (a, e);\n+}\n+\n+TYPE\n+sqrt_odd (TYPE a)\n+{\n+  return __builtin_sqrtf128_round_to_odd (a);\n+}\n+\n+double\n+trunc_odd (TYPE a)\n+{\n+  return __builtin_truncf128_round_to_odd (a);\n+}\n+\n+TYPE\n+add_odd (TYPE a, TYPE b)\n+{\n+  return __builtin_addf128_round_to_odd (a, b);\n+}\n+\n+TYPE\n+sub_odd (TYPE a, TYPE b)\n+{\n+  return __builtin_subf128_round_to_odd (a, b);\n+}\n+\n+TYPE\n+mul_odd (TYPE a, TYPE b)\n+{\n+  return __builtin_mulf128_round_to_odd (a, b);\n+}\n+\n+TYPE\n+div_odd (TYPE a, TYPE b)\n+{\n+  return __builtin_divf128_round_to_odd (a, b);\n+}\n+\n+TYPE\n+fma_odd (TYPE a, TYPE b, TYPE c)\n+{\n+  return __builtin_fmaf128_round_to_odd (a, b, c);\n+}\n+\n+TYPE\n+fms_odd (TYPE a, TYPE b, TYPE c)\n+{\n+  return __builtin_fmaf128_round_to_odd (a, b, -c);\n+}\n+\n+TYPE\n+nfma_odd (TYPE a, TYPE b, TYPE c)\n+{\n+  return -__builtin_fmaf128_round_to_odd (a, b, c);\n+}\n+\n+TYPE\n+nfms_odd (TYPE a, TYPE b, TYPE c)\n+{\n+  return -__builtin_fmaf128_round_to_odd (a, b, -c);\n+}\n+\n+/* { dg-final { scan-assembler \t   {\\mxsiexpdp\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsiexpqp\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsxexpdp\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsxexpqp\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsxsigdp\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsxsigqp\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsaddqpo\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsdivqpo\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsmaddqpo\\M}  } } */\n+/* { dg-final { scan-assembler \t   {\\mxsmsubqpo\\M}  } } */\n+/* { dg-final { scan-assembler \t   {\\mxsmulqpo\\M}   } } */\n+/* { dg-final { scan-assembler \t   {\\mxsnmaddqpo\\M} } } */\n+/* { dg-final { scan-assembler \t   {\\mxsnmsubqpo\\M} } } */\n+/* { dg-final { scan-assembler \t   {\\mxssqrtqpo\\M}  } } */\n+/* { dg-final { scan-assembler \t   {\\mxssubqpo\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mbl\\M}         } } */"}]}