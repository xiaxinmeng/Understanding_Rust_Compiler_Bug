{"sha": "b50d17a1482fcdbb9823b5028c585b02ef247dea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUwZDE3YTE0ODJmY2RiYjk4MjNiNTAyOGM1ODViMDJlZjI0N2RlYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T01:48:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T01:48:03Z"}, "message": "(store_expr): Use expr_size value, not size_int.\n\n(store_constructor): Handle case of variable position and allow it to contain\na PLACEHOLDER_EXPR.\n(get_inner_reference): Make a WITH_RECORD_EXPR if required.\n(expand_expr, case PLACEHOLDER_EXPR, WITH_RECORD_EXPR): New cases.\n(expand_expr, case ARRAY_REF): Make WITH_RECORD_EXPR expressions when needed.\n\nFrom-SVN: r5584", "tree": {"sha": "89940908e87ee737e504c1609dd92229ab3055a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89940908e87ee737e504c1609dd92229ab3055a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b50d17a1482fcdbb9823b5028c585b02ef247dea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b50d17a1482fcdbb9823b5028c585b02ef247dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b50d17a1482fcdbb9823b5028c585b02ef247dea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b50d17a1482fcdbb9823b5028c585b02ef247dea/comments", "author": null, "committer": null, "parents": [{"sha": "7ef1fbd7aa2fa6c0ac22cecf9e11b283f8f823f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef1fbd7aa2fa6c0ac22cecf9e11b283f8f823f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ef1fbd7aa2fa6c0ac22cecf9e11b283f8f823f7"}], "stats": {"total": 108, "additions": 90, "deletions": 18}, "files": [{"sha": "a0a6ba8af68cdb77e7bd6a9856495f4bc59eaada", "filename": "gcc/expr.c", "status": "modified", "additions": 90, "deletions": 18, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b50d17a1482fcdbb9823b5028c585b02ef247dea/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b50d17a1482fcdbb9823b5028c585b02ef247dea/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b50d17a1482fcdbb9823b5028c585b02ef247dea", "patch": "@@ -2628,9 +2628,7 @@ store_expr (exp, target, want_value)\n \t      /* Compute the size of the data to copy from the string.  */\n \t      tree copy_size\n \t\t= size_binop (MIN_EXPR,\n-\t\t\t      size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t\t  TYPE_SIZE (TREE_TYPE (exp)),\n-\t\t\t\t\t  size_int (BITS_PER_UNIT)),\n+\t\t\t      make_tree (sizetype, size),\n \t\t\t      convert (sizetype,\n \t\t\t\t       build_int_2 (TREE_STRING_LENGTH (exp), 0)));\n \t      rtx copy_size_rtx = expand_expr (copy_size, NULL_RTX,\n@@ -2756,8 +2754,10 @@ store_constructor (exp, target)\n \t  register tree field = TREE_PURPOSE (elt);\n \t  register enum machine_mode mode;\n \t  int bitsize;\n-\t  int bitpos;\n+\t  int bitpos = 0;\n \t  int unsignedp;\n+\t  tree pos, constant = 0, offset = 0;\n+\t  rtx to_rtx = target;\n \n \t  /* Just ignore missing fields.\n \t     We cleared the whole structure, above,\n@@ -2771,13 +2771,40 @@ store_constructor (exp, target)\n \t  if (DECL_BIT_FIELD (field))\n \t    mode = VOIDmode;\n \n-\t  if (TREE_CODE (DECL_FIELD_BITPOS (field)) != INTEGER_CST)\n-\t    /* ??? This case remains to be written.  */\n-\t    abort ();\n+\t  pos = DECL_FIELD_BITPOS (field);\n+\t  if (TREE_CODE (pos) == INTEGER_CST)\n+\t    constant = pos;\n+\t  else if (TREE_CODE (pos) == PLUS_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (pos, 1)) == INTEGER_CST)\n+\t    constant = TREE_OPERAND (pos, 1), offset = TREE_OPERAND (pos, 0);\n+\t  else\n+\t    offset = pos;\n \n-\t  bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  if (constant)\n+\t    bitpos = TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\n+\t  if (offset)\n+\t    {\n+\t      rtx offset_rtx;\n+\n+\t      if (contains_placeholder_p (offset))\n+\t\toffset = build (WITH_RECORD_EXPR, sizetype,\n+\t\t\t\toffset, exp);\n+\n+\t      offset = size_binop (FLOOR_DIV_EXPR, offset,\n+\t\t\t\t   size_int (BITS_PER_UNIT));\n \n-\t  store_field (target, bitsize, bitpos, mode, TREE_VALUE (elt),\n+\t      offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n+\t      if (GET_CODE (to_rtx) != MEM)\n+\t\tabort ();\n+\n+\t      to_rtx\n+\t\t= change_address (to_rtx, VOIDmode,\n+\t\t\t\t  gen_rtx (PLUS, Pmode, XEXP (to_rtx, 0),\n+\t\t\t\t\t   force_reg (Pmode, offset_rtx)));\n+\t    }\n+\n+\t  store_field (to_rtx, bitsize, bitpos, mode, TREE_VALUE (elt),\n \t\t       /* The alignment of TARGET is\n \t\t\t  at least what its type requires.  */\n \t\t       VOIDmode, 0,\n@@ -3023,6 +3050,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n      int *punsignedp;\n      int *pvolatilep;\n {\n+  tree orig_exp = exp;\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n   tree offset = integer_zero_node;\n@@ -3163,14 +3191,11 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n   if (integer_zerop (offset))\n     offset = 0;\n \n+  if (offset != 0 && contains_placeholder_p (offset))\n+    offset = build (WITH_RECORD_EXPR, sizetype, offset, orig_exp);\n+\n   *pmode = mode;\n   *poffset = offset;\n-#if 0\n-  /* We aren't finished fixing the callers to really handle nonzero offset.  */\n-  if (offset != 0)\n-    abort ();\n-#endif\n-\n   return exp;\n }\n \f\n@@ -3512,6 +3537,9 @@ expand_expr (exp, target, tmode, modifier)\n      enum machine_mode tmode;\n      enum expand_modifier modifier;\n {\n+  /* Chain of pending expressions for PLACEHOLDER_EXPR to replace.\n+     This is static so it will be accessible to our recursive callees.  */\n+  static tree placeholder_list = 0;\n   register rtx op0, op1, temp;\n   tree type = TREE_TYPE (exp);\n   int unsignedp = TREE_UNSIGNED (type);\n@@ -3547,7 +3575,9 @@ expand_expr (exp, target, tmode, modifier)\n \n   /* If we are going to ignore this result, we need only do something\n      if there is a side-effect somewhere in the expression.  If there\n-     is, short-circuit the most common cases here.  */\n+     is, short-circuit the most common cases here.  Note that we must\n+     not call expand_expr with anything but const0_rtx in case this\n+     is an initial expansion of a size that contains a PLACEHOLDER_EXPR.  */\n \n   if (ignore)\n     {\n@@ -3846,6 +3876,40 @@ expand_expr (exp, target, tmode, modifier)\n \n       return SAVE_EXPR_RTL (exp);\n \n+    case PLACEHOLDER_EXPR:\n+      /* If there is an object on the head of the placeholder list,\n+\t see if some object in it's references is of type TYPE.  For\n+\t further information, see tree.def.  */\n+      if (placeholder_list)\n+\t{\n+\t  tree object;\n+\n+\t  for (object = TREE_PURPOSE (placeholder_list);\n+\t       TREE_TYPE (object) != type\n+\t       && (TREE_CODE_CLASS (TREE_CODE (object)) == 'r'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (object) == '1'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (object) == '2'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (object) == 'e'))));\n+\t       object = TREE_OPERAND (object, 0))\n+\t    ;\n+\n+\t  if (object && TREE_TYPE (object))\n+\t    return expand_expr (object, original_target, tmode, modifier);\n+\t}\n+\n+      /* We can't find the object or there was a missing WITH_RECORD_EXPR.  */\n+      abort ();\n+\n+    case WITH_RECORD_EXPR:\n+      /* Put the object on the placeholder list, expand our first operand,\n+\t and pop the list.  */\n+      placeholder_list = tree_cons (TREE_OPERAND (exp, 1), NULL_TREE,\n+\t\t\t\t    placeholder_list);\n+      target = expand_expr (TREE_OPERAND (exp, 0), original_target,\n+\t\t\t    tmode, modifier);\n+      placeholder_list = TREE_CHAIN (placeholder_list);\n+      return target;\n+\n     case EXIT_EXPR:\n       expand_exit_loop_if_false (NULL_PTR,\n \t\t\t\t invert_truthvalue (TREE_OPERAND (exp, 0)));\n@@ -4017,6 +4081,10 @@ expand_expr (exp, target, tmode, modifier)\n \ttree index_type = TREE_TYPE (index);\n \tint i;\n \n+\tif (TREE_CODE (low_bound) != INTEGER_CST\n+\t    && contains_placeholder_p (low_bound))\n+\t  low_bound = build (WITH_RECORD_EXPR, sizetype, low_bound, exp);\n+\n \t/* Optimize the special-case of a zero lower bound.\n \n \t   We convert the low_bound to sizetype to avoid some problems\n@@ -4050,12 +4118,17 @@ expand_expr (exp, target, tmode, modifier)\n \t    tree array_adr = build1 (ADDR_EXPR,\n \t\t\t\t     build_pointer_type (variant_type), array);\n \t    tree elt;\n+\t    tree size = size_in_bytes (type);\n \n \t    /* Convert the integer argument to a type the same size as a\n \t       pointer so the multiply won't overflow spuriously.  */\n \t    if (TYPE_PRECISION (index_type) != POINTER_SIZE)\n \t      index = convert (type_for_size (POINTER_SIZE, 0), index);\n \n+\t    if (TREE_CODE (size) != INTEGER_CST\n+\t\t&& contains_placeholder_p (size))\n+\t      size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n+\n \t    /* Don't think the address has side effects\n \t       just because the array does.\n \t       (In some cases the address might have side effects,\n@@ -4069,8 +4142,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t       array_adr,\n \t\t\t\t       fold (build (MULT_EXPR,\n \t\t\t\t\t\t    TYPE_POINTER_TO (variant_type),\n-\t\t\t\t\t\t    index,\n-\t\t\t\t\t\t    size_in_bytes (type))))));\n+\t\t\t\t\t\t    index, size)))));\n \n \t    /* Volatility, etc., of new expression is same as old\n \t       expression.  */"}]}