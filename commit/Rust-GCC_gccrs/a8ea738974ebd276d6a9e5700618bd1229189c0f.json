{"sha": "a8ea738974ebd276d6a9e5700618bd1229189c0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlYTczODk3NGViZDI3NmQ2YTllNTcwMDYxOGJkMTIyOTE4OWMwZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-02-27T14:30:19Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-02-27T14:30:19Z"}, "message": "locale_facets.tcc (num_get<>::_M_extract_float, [...]): If appropriate, call reserve on the __tmp_gruping string.\n\n2004-02-27  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float,\n\tnum_get<>::_M_extract_int, money_get<>::_M_extract): If appropriate,\n\tcall reserve on the __tmp_gruping string.\n\t(num_get<>::_M_extract_float): Don't append unnecessarily a\n\tchar() to the returned string.\n\t* include/bits/locale_facets.tcc: Trivial reformattings.\n\nFrom-SVN: r78565", "tree": {"sha": "ecd7b2682c312adc5b8e1b6a3ca3e78e25f3cd2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd7b2682c312adc5b8e1b6a3ca3e78e25f3cd2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8ea738974ebd276d6a9e5700618bd1229189c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ea738974ebd276d6a9e5700618bd1229189c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ea738974ebd276d6a9e5700618bd1229189c0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ea738974ebd276d6a9e5700618bd1229189c0f/comments", "author": null, "committer": null, "parents": [{"sha": "53c428d012a474c3c8c345537b508db30f2db15e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53c428d012a474c3c8c345537b508db30f2db15e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53c428d012a474c3c8c345537b508db30f2db15e"}], "stats": {"total": 73, "additions": 49, "deletions": 24}, "files": [{"sha": "343c898f8c9edab04e48deebd010ab43526599c4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ea738974ebd276d6a9e5700618bd1229189c0f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ea738974ebd276d6a9e5700618bd1229189c0f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a8ea738974ebd276d6a9e5700618bd1229189c0f", "patch": "@@ -1,3 +1,12 @@\n+2004-02-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float,\n+\tnum_get<>::_M_extract_int, money_get<>::_M_extract): If appropriate,\n+\tcall reserve on the __tmp_gruping string.\n+\t(num_get<>::_M_extract_float): Don't append unnecessarily a\n+\tchar() to the returned string.\n+\t* include/bits/locale_facets.tcc: Trivial reformattings.\n+\n 2004-02-27  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.h (money_get<>::_M_extract):"}, {"sha": "353d601ca04152315a1666016e1223c6773a1ca7", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ea738974ebd276d6a9e5700618bd1229189c0f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ea738974ebd276d6a9e5700618bd1229189c0f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=a8ea738974ebd276d6a9e5700618bd1229189c0f", "patch": "@@ -219,9 +219,11 @@ namespace std\n       bool __found_dec = false;\n       bool __found_sci = false;\n       string __found_grouping;\n+      if (__lc->_M_use_grouping)\n+\t__found_grouping.reserve(32);\n       int __sep_pos = 0;\n       bool __e;\n-      const char_type* __p;\n+      const char_type* __q;\n       while (__beg != __end)\n         {\n \t  // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n@@ -265,9 +267,9 @@ namespace std\n \t      else\n \t\tbreak;\n \t    }\n-          else if (__p = __traits_type::find(__lit + _S_izero, 10, __c))\n+          else if (__q = __traits_type::find(__lit + _S_izero, 10, __c))\n \t    {\n-\t      __xtrc += _S_atoms_in[__p - __lit];\n+\t      __xtrc += _S_atoms_in[__q - __lit];\n \t      __found_mantissa = true;\n \t      ++__sep_pos;\n \t      ++__beg;\n@@ -283,7 +285,8 @@ namespace std\n \t      // Remove optional plus or minus sign, if they exist.\n \t      if (++__beg != __end)\n \t\t{\n-\t\t  const bool __plus = __traits_type::eq(*__beg, __lit[_S_iplus]);\n+\t\t  const bool __plus = __traits_type::eq(*__beg,\n+\t\t\t\t\t\t\t__lit[_S_iplus]);\n \t\t  if (__plus || __traits_type::eq(*__beg, __lit[_S_iminus]))\n \t\t    {\n \t\t      __xtrc += __plus ? _S_atoms_in[_S_iplus]\n@@ -311,7 +314,6 @@ namespace std\n         }\n \n       // Finish up.\n-      __xtrc += char();\n       if (__beg == __end)\n         __err |= ios_base::eofbit;\n       return __beg;\n@@ -332,7 +334,8 @@ namespace std\n \tconst _CharT* __lit = __lc->_M_atoms_in;\n \n \t// NB: Iff __basefield == 0, __base can change based on contents.\n-\tconst ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+\tconst ios_base::fmtflags __basefield = __io.flags()\n+\t                                       & ios_base::basefield;\n \tconst bool __oct = __basefield == ios_base::oct;\n \tint __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);\n \n@@ -395,11 +398,13 @@ namespace std\n \n \t// Extract.\n \tstring __found_grouping;\n+\tif (__lc->_M_use_grouping)\n+\t  __found_grouping.reserve(32);\n \tint __sep_pos = 0;\n \tbool __overflow = false;\n \t_ValueT __result = 0;\n \tconst char_type* __lit_zero = __lit + _S_izero;\n-\tconst char_type* __p;\n+\tconst char_type* __q;\n \tif (__negative)\n \t  {\n \t    const _ValueT __min = numeric_limits<_ValueT>::min() / __base;\n@@ -426,16 +431,17 @@ namespace std\n \t\t  }\n \t\telse if (__traits_type::eq(__c, __lc->_M_decimal_point))\n \t\t  break;\n-\t\telse if (__p = __traits_type::find(__lit_zero, __len, __c))\n+\t\telse if (__q = __traits_type::find(__lit_zero, __len, __c))\n \t\t  {\n-\t\t    int __digit = __p - __lit_zero;\n+\t\t    int __digit = __q - __lit_zero;\n \t\t    if (__digit > 15)\n \t\t      __digit -= 6;\n \t\t    if (__result < __min)\n \t\t      __overflow = true;\n \t\t    else\n \t\t      {\n-\t\t\tconst _ValueT __new_result = __result * __base - __digit;\n+\t\t\tconst _ValueT __new_result = __result * __base\n+\t\t\t                             - __digit;\n \t\t\t__overflow |= __new_result > __result;\n \t\t\t__result = __new_result;\n \t\t\t++__sep_pos;\n@@ -469,16 +475,17 @@ namespace std\n \t\t  }\n \t\telse if (__traits_type::eq(__c, __lc->_M_decimal_point))\n \t\t  break;\n-\t\telse if (__p = __traits_type::find(__lit_zero, __len, __c))\n+\t\telse if (__q = __traits_type::find(__lit_zero, __len, __c))\n \t\t  {\n-\t\t    int __digit = __p - __lit_zero;\n+\t\t    int __digit = __q - __lit_zero;\n \t\t    if (__digit > 15)\n \t\t      __digit -= 6;\n \t\t    if (__result > __max)\n \t\t      __overflow = true;\n \t\t    else\n \t\t      {\n-\t\t\tconst _ValueT __new_result = __result * __base + __digit;\n+\t\t\tconst _ValueT __new_result = __result * __base\n+\t\t\t                             + __digit;\n \t\t\t__overflow |= __new_result < __result;\n \t\t\t__result = __new_result;\n \t\t\t++__sep_pos;\n@@ -497,7 +504,8 @@ namespace std\n \t    // Add the ending grouping.\n \t    __found_grouping += static_cast<char>(__sep_pos);\n \n-\t    if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size,\n+\t    if (!std::__verify_grouping(__lc->_M_grouping,\n+\t\t\t\t\t__lc->_M_grouping_size,\n \t\t\t\t\t__found_grouping))\n \t      __err |= ios_base::failbit;\n \t  }\n@@ -890,8 +898,9 @@ namespace std\n   template<typename _CharT, typename _OutIter>\n     void\n     num_put<_CharT, _OutIter>::\n-    _M_group_float(const char* __grouping, size_t __grouping_size, _CharT __sep,\n-\t\t   const _CharT* __p, _CharT* __new, _CharT* __cs, int& __len) const\n+    _M_group_float(const char* __grouping, size_t __grouping_size,\n+\t\t   _CharT __sep, const _CharT* __p, _CharT* __new,\n+\t\t   _CharT* __cs, int& __len) const\n     {\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 282. What types does numpunct grouping refer to?\n@@ -1061,8 +1070,9 @@ namespace std\n \t  const streamsize __w = __io.width();\n \t  if (__w > static_cast<streamsize>(__len))\n \t    {\n-\t      _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n-\t\t\t\t\t\t\t\t   * __w));\n+\t      _CharT* __cs\n+\t\t= static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)\n+\t\t\t\t\t\t\t* __w));\n \t      _M_pad(__fill, __w, __io, __cs, __name, __len);\n \t      __name = __cs;\n \t    }\n@@ -1120,8 +1130,10 @@ namespace std\n            const void* __v) const\n     {\n       const ios_base::fmtflags __flags = __io.flags();\n-      const ios_base::fmtflags __fmt = ~(ios_base::showpos | ios_base::basefield\n-\t\t\t\t\t | ios_base::uppercase | ios_base::internal);\n+      const ios_base::fmtflags __fmt = ~(ios_base::showpos\n+\t\t\t\t\t | ios_base::basefield\n+\t\t\t\t\t | ios_base::uppercase\n+\t\t\t\t\t | ios_base::internal);\n       __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));\n \n       __s = _M_insert_int(__s, __io, __fill,\n@@ -1186,6 +1198,8 @@ namespace std\n \tbool __long_sign = false;\n \t// String of grouping info from thousands_sep plucked from __units.\n \tstring __grouping_tmp;\n+\tif (__lc->_M_use_grouping)\n+\t  __grouping_tmp.reserve(32);\n \t// Marker for thousands_sep position.\n \tint __sep_pos = 0;\n \t// If input iterator is in a valid state.\n@@ -1274,9 +1288,10 @@ namespace std\n \t\t      __sep_pos = 0;\n \t\t      __testdecfound = true;\n \t\t    }\n-\t\t  else if (*__beg == __lc->_M_thousands_sep && !__testdecfound)\n+\t\t  else if (__lc->_M_use_grouping\n+\t\t\t   && *__beg == __lc->_M_thousands_sep)\n \t\t    {\n-\t\t      if (__lc->_M_grouping_size)\n+\t\t      if (!__testdecfound)\n \t\t\t{\n \t\t\t  // Mark position for later analysis.\n \t\t\t  __grouping_tmp += static_cast<char>(__sep_pos);\n@@ -2146,8 +2161,9 @@ namespace std\n       // NB: This size is arbitrary. Should this be a data member,\n       // initialized at construction?\n       const size_t __maxlen = 64;\n-      char_type* __res = static_cast<char_type*>(__builtin_alloca(sizeof(char_type)\n-\t\t\t\t\t\t\t\t  * __maxlen));\n+      char_type* __res =\n+\tstatic_cast<char_type*>(__builtin_alloca(sizeof(char_type)\n+\t\t\t\t\t\t * __maxlen));\n \n       // NB: In IEE 1003.1-200x, and perhaps other locale models, it\n       // is possible that the format character will be longer than one"}]}