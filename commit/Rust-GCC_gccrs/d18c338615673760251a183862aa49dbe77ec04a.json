{"sha": "d18c338615673760251a183862aa49dbe77ec04a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE4YzMzODYxNTY3Mzc2MDI1MWExODM4NjJhYTQ5ZGJlNzdlYzA0YQ==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2003-12-01T07:23:28Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-12-01T07:23:28Z"}, "message": "re PR libffi/13221 (libffi's closure couldn't pass sequence of char and/or short arguments.)\n\n2003-12-01  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\tPR other/13221\n\t* testsuite/libffi.call/cls_multi_sshort.c: New test case.\n\t* testsuite/libffi.call/cls_multi_sshortchar.c: Likewise.\n\t* testsuite/libffi.call/cls_multi_uchar.c: Likewise.\n\t* testsuite/libffi.call/cls_multi_schar.c: Likewise.\n\t* testsuite/libffi.call/cls_multi_ushortchar.c: Likewise.\n\t* testsuite/libffi.call/cls_multi_ushort.c: Likewise.\n\n\t* testsuite/libffi.special/unwindtest.cc: Cosmetics.\n\nFrom-SVN: r74093", "tree": {"sha": "977e5f227b7888ddc159489a95bcc4a49b5fe9dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/977e5f227b7888ddc159489a95bcc4a49b5fe9dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d18c338615673760251a183862aa49dbe77ec04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18c338615673760251a183862aa49dbe77ec04a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18c338615673760251a183862aa49dbe77ec04a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18c338615673760251a183862aa49dbe77ec04a/comments", "author": null, "committer": null, "parents": [{"sha": "e82407b5bb381e6940f8d4f1a4c218146acc1524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82407b5bb381e6940f8d4f1a4c218146acc1524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82407b5bb381e6940f8d4f1a4c218146acc1524"}], "stats": {"total": 539, "additions": 538, "deletions": 1}, "files": [{"sha": "8d0fa81dc636c9434af924a4fd9c3722ce11ebee", "filename": "libffi/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -1,3 +1,15 @@\n+2003-12-01  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\tPR other/13221\n+\t* testsuite/libffi.call/cls_multi_sshort.c: New test case.\n+\t* testsuite/libffi.call/cls_multi_sshortchar.c: Likewise.\n+\t* testsuite/libffi.call/cls_multi_uchar.c: Likewise.\n+\t* testsuite/libffi.call/cls_multi_schar.c: Likewise.\n+\t* testsuite/libffi.call/cls_multi_ushortchar.c: Likewise.\n+\t* testsuite/libffi.call/cls_multi_ushort.c: Likewise.\n+\n+\t* testsuite/libffi.special/unwindtest.cc: Cosmetics.\n+\n 2003-11-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* testsuite/libffi.call/ffitest.h: Include <fcntl.h>."}, {"sha": "6457336661fc7497e8e48e2a25fe7db9e14c867c", "filename": "libffi/testsuite/libffi.call/cls_multi_schar.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_schar.c?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -0,0 +1,81 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck passing of multiple signed char values.\n+   Limitations:\tnone.\n+   PR:\t\tPR13221.\n+   Originator:\t<hos@tamanegi.org> 20031129  */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+signed char test_func_fn(signed char a1, signed char a2)\n+{\n+  signed char result;\n+\n+  result = a1 + a2;\n+\n+  printf(\"%d %d: %d\\n\", a1, a2, result);\n+\n+  return result;\n+\n+}\n+\n+static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  signed char a1, a2;\n+\n+  a1 = *(signed char *)avals[0];\n+  a2 = *(signed char *)avals[1];\n+\n+  *(ffi_arg *)rval = test_func_fn(a1, a2);\n+\n+}\n+\n+typedef signed char (*test_type)(signed char, signed char);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void * args_dbl[3];\n+  ffi_type * cl_arg_types[3];\n+  ffi_arg res_call;\n+  signed char a, b, res_closure;\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  a = 2;\n+  b = 125;\n+\n+  args_dbl[0] = &a;\n+  args_dbl[1] = &b;\n+  args_dbl[3] = NULL;\n+\n+  cl_arg_types[0] = &ffi_type_schar;\n+  cl_arg_types[1] = &ffi_type_schar;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,\n+\t\t     &ffi_type_schar, cl_arg_types) == FFI_OK);\n+\n+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);\n+  /* { dg-output \"2 125: 127\" } */\n+  printf(\"res: %d\\n\", res_call);\n+  /* { dg-output \"\\nres: 127\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+\n+  res_closure = (*((test_type)pcl))(2, 125);\n+  /* { dg-output \"\\n2 125: 127\" } */\n+  printf(\"res: %d\\n\", res_closure);\n+  /* { dg-output \"\\nres: 127\" } */\n+\n+  exit(0);\n+}"}, {"sha": "eaa15d8cdc13707148934774d11ddf8e43981ea0", "filename": "libffi/testsuite/libffi.call/cls_multi_sshort.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshort.c?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -0,0 +1,81 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck passing of multiple signed short values.\n+   Limitations:\tnone.\n+   PR:\t\tPR13221.\n+   Originator:\t<andreast@gcc.gnu.org> 20031129  */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+signed short test_func_fn(signed short a1, signed short a2)\n+{\n+  signed short result;\n+\n+  result = a1 + a2;\n+\n+  printf(\"%d %d: %d\\n\", a1, a2, result);\n+\n+  return result;\n+\n+}\n+\n+static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  signed short a1, a2;\n+\n+  a1 = *(signed short *)avals[0];\n+  a2 = *(signed short *)avals[1];\n+\n+  *(ffi_arg *)rval = test_func_fn(a1, a2);\n+\n+}\n+\n+typedef signed short (*test_type)(signed short, signed short);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void * args_dbl[3];\n+  ffi_type * cl_arg_types[3];\n+  ffi_arg res_call;\n+  unsigned short a, b, res_closure;\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  a = 2;\n+  b = 32765;\n+\n+  args_dbl[0] = &a;\n+  args_dbl[1] = &b;\n+  args_dbl[3] = NULL;\n+\n+  cl_arg_types[0] = &ffi_type_sshort;\n+  cl_arg_types[1] = &ffi_type_sshort;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,\n+\t\t     &ffi_type_sshort, cl_arg_types) == FFI_OK);\n+\n+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);\n+  /* { dg-output \"2 32765: 32767\" } */\n+  printf(\"res: %d\\n\", res_call);\n+  /* { dg-output \"\\nres: 32767\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+\n+  res_closure = (*((test_type)pcl))(2, 32765);\n+  /* { dg-output \"\\n2 32765: 32767\" } */\n+  printf(\"res: %d\\n\", res_closure);\n+  /* { dg-output \"\\nres: 32767\" } */\n+\n+  exit(0);\n+}"}, {"sha": "ae5ce7f72a4411e2660d226966e0bbf03f0ee264", "filename": "libffi/testsuite/libffi.call/cls_multi_sshortchar.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshortchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshortchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_sshortchar.c?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -0,0 +1,93 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck passing of multiple signed short/char values.\n+   Limitations:\tnone.\n+   PR:\t\tPR13221.\n+   Originator:\t<andreast@gcc.gnu.org> 20031129  */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+signed short test_func_fn(signed char a1, signed short a2,\n+\t\t\t  signed char a3, signed short a4)\n+{\n+  signed short result;\n+\n+  result = a1 + a2 + a3 + a4;\n+\n+  printf(\"%d %d %d %d: %d\\n\", a1, a2, a3, a4, result);\n+\n+  return result;\n+\n+}\n+\n+static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  signed char a1, a3;\n+  signed short a2, a4;\n+\n+  a1 = *(signed char *)avals[0];\n+  a2 = *(signed short *)avals[1];\n+  a3 = *(signed char *)avals[2];\n+  a4 = *(signed short *)avals[3];\n+\n+  *(ffi_arg *)rval = test_func_fn(a1, a2, a3, a4);\n+\n+}\n+\n+typedef signed short (*test_type)(signed char, signed short,\n+\t\t\t\t  signed char, signed short);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void * args_dbl[5];\n+  ffi_type * cl_arg_types[5];\n+  ffi_arg res_call;\n+  signed char a, c;\n+  signed short b, d, res_closure;\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  a = 1;\n+  b = 32765;\n+  c = 127;\n+  d = -128;\n+\n+  args_dbl[0] = &a;\n+  args_dbl[1] = &b;\n+  args_dbl[2] = &c;\n+  args_dbl[3] = &d;\n+  args_dbl[4] = NULL;\n+\n+  cl_arg_types[0] = &ffi_type_schar;\n+  cl_arg_types[1] = &ffi_type_sshort;\n+  cl_arg_types[2] = &ffi_type_schar;\n+  cl_arg_types[3] = &ffi_type_sshort;\n+  cl_arg_types[4] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,\n+\t\t     &ffi_type_sshort, cl_arg_types) == FFI_OK);\n+\n+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);\n+  /* { dg-output \"1 32765 127 -128: 32765\" } */\n+  printf(\"res: %d\\n\", res_call);\n+  /* { dg-output \"\\nres: 32765\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+\n+  res_closure = (*((test_type)pcl))(1, 32765, 127, -128);\n+  /* { dg-output \"\\n1 32765 127 -128: 32765\" } */\n+  printf(\"res: %d\\n\", res_closure);\n+  /* { dg-output \"\\nres: 32765\" } */\n+\n+  exit(0);\n+}"}, {"sha": "0b00bc3ff41c4e21ce7efda02c560cf2bb594e27", "filename": "libffi/testsuite/libffi.call/cls_multi_uchar.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_uchar.c?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -0,0 +1,96 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck passing of multiple unsigned char values.\n+   Limitations:\tnone.\n+   PR:\t\tPR13221.\n+   Originator:\t<andreast@gcc.gnu.org> 20031129  */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+unsigned char test_func_fn(unsigned char a1, unsigned char a2,\n+\t\t\t   unsigned char a3, unsigned char a4)\n+{\n+  unsigned char result;\n+\n+  result = a1 + a2 + a3 + a4;\n+\n+  printf(\"%d %d %d %d: %d\\n\", a1, a2, a3, a4, result);\n+\n+  return result;\n+\n+}\n+\n+static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  unsigned char a1, a2, a3, a4;\n+\n+  a1 = *(unsigned char *)avals[0];\n+  a2 = *(unsigned char *)avals[1];\n+  a3 = *(unsigned char *)avals[2];\n+  a4 = *(unsigned char *)avals[3];\n+\n+  *(ffi_arg *)rval = test_func_fn(a1, a2, a3, a4);\n+\n+}\n+\n+typedef unsigned char (*test_type)(unsigned char, unsigned char,\n+\t\t\t\t   unsigned char, unsigned char);\n+void test_func(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  printf(\"%d %d %d %d\\n\", *(unsigned char *)avals[0],\n+\t *(unsigned char *)avals[1], *(unsigned char *)avals[2],\n+\t *(unsigned char *)avals[3]);\n+}\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void * args_dbl[5];\n+  ffi_type * cl_arg_types[5];\n+  ffi_arg res_call;\n+  unsigned char a, b, c, d, res_closure;\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  a = 1;\n+  b = 2;\n+  c = 127;\n+  d = 125;\n+\n+  args_dbl[0] = &a;\n+  args_dbl[1] = &b;\n+  args_dbl[2] = &c;\n+  args_dbl[3] = &d;\n+  args_dbl[4] = NULL;\n+\n+  cl_arg_types[0] = &ffi_type_uchar;\n+  cl_arg_types[1] = &ffi_type_uchar;\n+  cl_arg_types[2] = &ffi_type_uchar;\n+  cl_arg_types[3] = &ffi_type_uchar;\n+  cl_arg_types[4] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,\n+\t\t     &ffi_type_uchar, cl_arg_types) == FFI_OK);\n+\n+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);\n+  /* { dg-output \"1 2 127 125: 255\" } */\n+  printf(\"res: %d\\n\", res_call);\n+  /* { dg-output \"\\nres: 255\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+\n+  res_closure = (*((test_type)pcl))(1, 2, 127, 125);\n+  /* { dg-output \"\\n1 2 127 125: 255\" } */\n+  printf(\"res: %d\\n\", res_closure);\n+  /* { dg-output \"\\nres: 255\" } */\n+\n+  exit(0);\n+}"}, {"sha": "e6ae9aa0755002b65380e69078450c4936b238c6", "filename": "libffi/testsuite/libffi.call/cls_multi_ushort.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushort.c?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -0,0 +1,81 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck passing of multiple unsigned short values.\n+   Limitations:\tnone.\n+   PR:\t\tPR13221.\n+   Originator:\t<andreast@gcc.gnu.org> 20031129  */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+unsigned short test_func_fn(unsigned short a1, unsigned short a2)\n+{\n+  unsigned short result;\n+\n+  result = a1 + a2;\n+\n+  printf(\"%d %d: %d\\n\", a1, a2, result);\n+\n+  return result;\n+\n+}\n+\n+static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  unsigned short a1, a2;\n+\n+  a1 = *(unsigned short *)avals[0];\n+  a2 = *(unsigned short *)avals[1];\n+\n+  *(ffi_arg *)rval = test_func_fn(a1, a2);\n+\n+}\n+\n+typedef unsigned short (*test_type)(unsigned short, unsigned short);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void * args_dbl[3];\n+  ffi_type * cl_arg_types[3];\n+  ffi_arg res_call;\n+  unsigned short a, b, res_closure;\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  a = 2;\n+  b = 32765;\n+\n+  args_dbl[0] = &a;\n+  args_dbl[1] = &b;\n+  args_dbl[3] = NULL;\n+\n+  cl_arg_types[0] = &ffi_type_ushort;\n+  cl_arg_types[1] = &ffi_type_ushort;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2,\n+\t\t     &ffi_type_ushort, cl_arg_types) == FFI_OK);\n+\n+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);\n+  /* { dg-output \"2 32765: 32767\" } */\n+  printf(\"res: %d\\n\", res_call);\n+  /* { dg-output \"\\nres: 32767\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+\n+  res_closure = (*((test_type)pcl))(2, 32765);\n+  /* { dg-output \"\\n2 32765: 32767\" } */\n+  printf(\"res: %d\\n\", res_closure);\n+  /* { dg-output \"\\nres: 32767\" } */\n+\n+  exit(0);\n+}"}, {"sha": "2458fc531904a7fafad8a96b2849bc1980e66644", "filename": "libffi/testsuite/libffi.call/cls_multi_ushortchar.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushortchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushortchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_multi_ushortchar.c?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -0,0 +1,93 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck passing of multiple unsigned short/char values.\n+   Limitations:\tnone.\n+   PR:\t\tPR13221.\n+   Originator:\t<andreast@gcc.gnu.org> 20031129  */\n+\n+/* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+unsigned short test_func_fn(unsigned char a1, unsigned short a2,\n+\t\t\t    unsigned char a3, unsigned short a4)\n+{\n+  unsigned short result;\n+\n+  result = a1 + a2 + a3 + a4;\n+\n+  printf(\"%d %d %d %d: %d\\n\", a1, a2, a3, a4, result);\n+\n+  return result;\n+\n+}\n+\n+static void test_func_gn(ffi_cif *cif, void *rval, void **avals, void *data)\n+{\n+  unsigned char a1, a3;\n+  unsigned short a2, a4;\n+\n+  a1 = *(unsigned char *)avals[0];\n+  a2 = *(unsigned short *)avals[1];\n+  a3 = *(unsigned char *)avals[2];\n+  a4 = *(unsigned short *)avals[3];\n+\n+  *(ffi_arg *)rval = test_func_fn(a1, a2, a3, a4);\n+\n+}\n+\n+typedef unsigned short (*test_type)(unsigned char, unsigned short,\n+\t\t\t\t   unsigned char, unsigned short);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void * args_dbl[5];\n+  ffi_type * cl_arg_types[5];\n+  ffi_arg res_call;\n+  unsigned char a, c;\n+  unsigned short b, d, res_closure;\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  a = 1;\n+  b = 2;\n+  c = 127;\n+  d = 128;\n+\n+  args_dbl[0] = &a;\n+  args_dbl[1] = &b;\n+  args_dbl[2] = &c;\n+  args_dbl[3] = &d;\n+  args_dbl[4] = NULL;\n+\n+  cl_arg_types[0] = &ffi_type_uchar;\n+  cl_arg_types[1] = &ffi_type_ushort;\n+  cl_arg_types[2] = &ffi_type_uchar;\n+  cl_arg_types[3] = &ffi_type_ushort;\n+  cl_arg_types[4] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,\n+\t\t     &ffi_type_ushort, cl_arg_types) == FFI_OK);\n+\n+  ffi_call(&cif, FFI_FN(test_func_fn), &res_call, args_dbl);\n+  /* { dg-output \"1 2 127 128: 258\" } */\n+  printf(\"res: %d\\n\", res_call);\n+  /* { dg-output \"\\nres: 258\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, test_func_gn, NULL)  == FFI_OK);\n+\n+  res_closure = (*((test_type)pcl))(1, 2, 127, 128);\n+  /* { dg-output \"\\n1 2 127 128: 258\" } */\n+  printf(\"res: %d\\n\", res_closure);\n+  /* { dg-output \"\\nres: 258\" } */\n+\n+  exit(0);\n+}"}, {"sha": "4fec44ceebc9bef920e37503e9820eeadf71300a", "filename": "libffi/testsuite/libffi.special/unwindtest.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d18c338615673760251a183862aa49dbe77ec04a/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc?ref=d18c338615673760251a183862aa49dbe77ec04a", "patch": "@@ -56,7 +56,7 @@ int main (void)\n   ffi_type * cl_arg_types[17];\n   int res;\n #ifdef USING_MMAP\n-  pcl = (ffi_closure*) allocate_mmap (sizeof(ffi_closure));\n+  pcl = (ffi_closure *) allocate_mmap (sizeof(ffi_closure));\n #else\n   pcl = &cl;\n #endif"}]}