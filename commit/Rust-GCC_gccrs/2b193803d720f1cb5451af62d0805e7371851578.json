{"sha": "2b193803d720f1cb5451af62d0805e7371851578", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxOTM4MDNkNzIwZjFjYjU0NTFhZjYyZDA4MDVlNzM3MTg1MTU3OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-10-31T23:48:19Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-10-31T23:48:19Z"}, "message": "runtime: If no split stacks, allocate stacks using mmap on 64-bit systems.\n\n    \n    When not using split stacks, libgo allocate large stacks for each\n    goroutine.  On a 64-bit system, libgo allocates a maximum of 128G for\n    the Go heap, and allocates 4M for each stack.  When the stacks are\n    allocated from the Go heap, the result is that a program can only create\n    32K goroutines, which is not enough for an active Go server.  This patch\n    changes libgo to allocate the stacks using mmap directly, rather than\n    allocating them out of the Go heap.  This change is only done for 64-bit\n    systems when not using split stacks.  When using split stacks, the\n    stacks are allocated using mmap directly anyhow.  On a 32-bit system,\n    there is no maximum size for the Go heap, or, rather, the maximum size\n    is the available address space anyhow.\n    \n    Reviewed-on: https://go-review.googlesource.com/16531\n\nFrom-SVN: r229636", "tree": {"sha": "9c767b63079e2f30d1689cd0eade8669a97ec459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c767b63079e2f30d1689cd0eade8669a97ec459"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b193803d720f1cb5451af62d0805e7371851578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b193803d720f1cb5451af62d0805e7371851578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b193803d720f1cb5451af62d0805e7371851578", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b193803d720f1cb5451af62d0805e7371851578/comments", "author": null, "committer": null, "parents": [{"sha": "da235df878ef89ef944328af97cafed56987c8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da235df878ef89ef944328af97cafed56987c8a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da235df878ef89ef944328af97cafed56987c8a2"}], "stats": {"total": 19, "additions": 16, "deletions": 3}, "files": [{"sha": "d2c9492b54d41c2dafe8eb31a86a9a00da266476", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b193803d720f1cb5451af62d0805e7371851578/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b193803d720f1cb5451af62d0805e7371851578/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2b193803d720f1cb5451af62d0805e7371851578", "patch": "@@ -1,4 +1,4 @@\n-17cc10f7fb07e3f37448feaeb416b52618ae8bbb\n+1c1f226662a6c84eae83f8aaec3d4503e70be843\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c25a21731abf00f9c2c93b8b4548837bde3e9508", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b193803d720f1cb5451af62d0805e7371851578/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b193803d720f1cb5451af62d0805e7371851578/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=2b193803d720f1cb5451af62d0805e7371851578", "patch": "@@ -2250,11 +2250,24 @@ runtime_malg(int32 stacksize, byte** ret_stack, size_t* ret_stacksize)\n \t\t__splitstack_block_signals_context(&newg->stack_context[0],\n \t\t\t\t\t\t   &dont_block_signals, nil);\n #else\n-\t\t*ret_stack = runtime_mallocgc(stacksize, 0, FlagNoProfiling|FlagNoGC);\n+                // In 64-bit mode, the maximum Go allocation space is\n+                // 128G.  Our stack size is 4M, which only permits 32K\n+                // goroutines.  In order to not limit ourselves,\n+                // allocate the stacks out of separate memory.  In\n+                // 32-bit mode, the Go allocation space is all of\n+                // memory anyhow.\n+\t\tif(sizeof(void*) == 8) {\n+\t\t\tvoid *p = runtime_SysAlloc(stacksize, &mstats.other_sys);\n+\t\t\tif(p == nil)\n+\t\t\t\truntime_throw(\"runtime: cannot allocate memory for goroutine stack\");\n+\t\t\t*ret_stack = (byte*)p;\n+\t\t} else {\n+\t\t\t*ret_stack = runtime_mallocgc(stacksize, 0, FlagNoProfiling|FlagNoGC);\n+\t\t\truntime_xadd(&runtime_stacks_sys, stacksize);\n+\t\t}\n \t\t*ret_stacksize = stacksize;\n \t\tnewg->gcinitial_sp = *ret_stack;\n \t\tnewg->gcstack_size = stacksize;\n-\t\truntime_xadd(&runtime_stacks_sys, stacksize);\n #endif\n \t}\n \treturn newg;"}]}