{"sha": "9b2f0394a02119a605017481a138bb10b5624077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIyZjAzOTRhMDIxMTlhNjA1MDE3NDgxYTEzOGJiMTBiNTYyNDA3Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-02-15T01:27:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-02-15T01:27:47Z"}, "message": "re PR c++/54922 ([C++11][DR 1359] constexpr constructors require initialization of all union members)\n\n\tPR c++/54922\n\t* semantics.c (build_anon_member_initialization): New.\n\t(build_data_member_initialization): Use it.\n\nFrom-SVN: r196070", "tree": {"sha": "efb25f5a1b2be2eb69f70d34b12439f42f8aeecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efb25f5a1b2be2eb69f70d34b12439f42f8aeecb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b2f0394a02119a605017481a138bb10b5624077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2f0394a02119a605017481a138bb10b5624077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2f0394a02119a605017481a138bb10b5624077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2f0394a02119a605017481a138bb10b5624077/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b24cd3d1f8ab5ad45bafdfd4af0f5805c4788ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24cd3d1f8ab5ad45bafdfd4af0f5805c4788ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24cd3d1f8ab5ad45bafdfd4af0f5805c4788ca2"}], "stats": {"total": 137, "additions": 131, "deletions": 6}, "files": [{"sha": "9033b51df281e50b28f8bcab67973b9013f97944", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9b2f0394a02119a605017481a138bb10b5624077", "patch": "@@ -1,5 +1,9 @@\n 2013-02-14  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/54922\n+\t* semantics.c (build_anon_member_initialization): New.\n+\t(build_data_member_initialization): Use it.\n+\n \tPR c++/55003\n \t* decl.c (cp_finish_decl): Force instantiation of an\n \tauto static data member."}, {"sha": "28b4b7912735ab0ac3b9c0a02f55f1aafb7563a8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9b2f0394a02119a605017481a138bb10b5624077", "patch": "@@ -5815,6 +5815,59 @@ is_valid_constexpr_fn (tree fun, bool complain)\n   return ret;\n }\n \n+/* Subroutine of build_data_member_initialization.  MEMBER is a COMPONENT_REF\n+   for a member of an anonymous aggregate, INIT is the initializer for that\n+   member, and VEC_OUTER is the vector of constructor elements for the class\n+   whose constructor we are processing.  Add the initializer to the vector\n+   and return true to indicate success.  */\n+\n+static bool\n+build_anon_member_initialization (tree member, tree init,\n+\t\t\t\t  vec<constructor_elt, va_gc> **vec_outer)\n+{\n+  /* MEMBER presents the relevant fields from the inside out, but we need\n+     to build up the initializer from the outside in so that we can reuse\n+     previously built CONSTRUCTORs if this is, say, the second field in an\n+     anonymous struct.  So we use a vec as a stack.  */\n+  vec<tree> fields;\n+  fields.create (2);\n+  do\n+    {\n+      fields.safe_push (TREE_OPERAND (member, 1));\n+      member = TREE_OPERAND (member, 0);\n+    }\n+  while (ANON_AGGR_TYPE_P (TREE_TYPE (member)));\n+\n+  /* VEC has the constructor elements vector for the context of FIELD.\n+     If FIELD is an anonymous aggregate, we will push inside it.  */\n+  vec<constructor_elt, va_gc> **vec = vec_outer;\n+  tree field;\n+  while (field = fields.pop(),\n+\t ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+    {\n+      tree ctor;\n+      /* If there is already an outer constructor entry for the anonymous\n+\t aggregate FIELD, use it; otherwise, insert one.  */\n+      if (vec_safe_is_empty (*vec)\n+\t  || (*vec)->last().index != field)\n+\t{\n+\t  ctor = build_constructor (TREE_TYPE (field), NULL);\n+\t  CONSTRUCTOR_APPEND_ELT (*vec, field, ctor);\n+\t}\n+      else\n+\tctor = (*vec)->last().value;\n+      vec = &CONSTRUCTOR_ELTS (ctor);\n+    }\n+\n+  /* Now we're at the innermost field, the one that isn't an anonymous\n+     aggregate.  Add its initializer to the CONSTRUCTOR and we're done.  */\n+  gcc_assert (fields.is_empty());\n+  fields.release ();\n+  CONSTRUCTOR_APPEND_ELT (*vec, field, init);\n+\n+  return true;\n+}\n+\n /* Subroutine of  build_constexpr_constructor_member_initializers.\n    The expression tree T represents a data member initialization\n    in a (constexpr) constructor definition.  Build a pairing of\n@@ -5901,12 +5954,21 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n     }\n   if (TREE_CODE (member) == ADDR_EXPR)\n     member = TREE_OPERAND (member, 0);\n-  if (TREE_CODE (member) == COMPONENT_REF\n-      /* If we're initializing a member of a subaggregate, it's a vtable\n-\t pointer.  Leave it as COMPONENT_REF so we remember the path to get\n-\t to the vfield.  */\n-      && TREE_CODE (TREE_OPERAND (member, 0)) != COMPONENT_REF)\n-    member = TREE_OPERAND (member, 1);\n+  if (TREE_CODE (member) == COMPONENT_REF)\n+    {\n+      tree aggr = TREE_OPERAND (member, 0);\n+      if (TREE_CODE (aggr) != COMPONENT_REF)\n+\t/* Normal member initialization.  */\n+\tmember = TREE_OPERAND (member, 1);\n+      else if (ANON_AGGR_TYPE_P (TREE_TYPE (aggr)))\n+\t/* Initializing a member of an anonymous union.  */\n+\treturn build_anon_member_initialization (member, init, vec);\n+      else\n+\t/* We're initializing a vtable pointer in a base.  Leave it as\n+\t   COMPONENT_REF so we remember the path to get to the vfield.  */\n+\tgcc_assert (TREE_TYPE (member) == vtbl_ptr_type_node);\n+    }\n+\n   CONSTRUCTOR_APPEND_ELT (*vec, member, init);\n   return true;\n }"}, {"sha": "a8d6b8d3ea69382cafca807f1678eecad3ed885a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-union4.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union4.C?ref=9b2f0394a02119a605017481a138bb10b5624077", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/54922\n+// { dg-do compile { target c++11 } }\n+\n+struct nullable_int\n+{\n+  bool init_;\n+  union {\n+    unsigned char for_value_init;\n+    int value_;\n+  };\n+\n+  constexpr nullable_int() : init_(false), for_value_init() {}\n+};\n+\n+#define SA(X) static_assert(X,#X)\n+\n+constexpr nullable_int n;\n+SA((n.for_value_init == 0));"}, {"sha": "e8e678d3ecaf8acae8b4825eaf5abfd54f697edf", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-union5.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2f0394a02119a605017481a138bb10b5624077/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union5.C?ref=9b2f0394a02119a605017481a138bb10b5624077", "patch": "@@ -0,0 +1,41 @@\n+// PR c++/54922\n+// { dg-options \"-std=c++11 -pedantic\" }\n+\n+#define SA(X) static_assert(X,#X)\n+\n+struct A\n+{\n+  union {\n+    union {\n+      union {\n+\tunsigned char i;\n+\tint j;\n+      };\n+    };\n+  };\n+\n+  constexpr A() : i(42) {}\n+};\n+\n+constexpr A a;\n+SA((a.i == 42));\n+\n+struct B\n+{\n+  struct {\n+    int h;\n+    struct {\n+      union {\n+\tunsigned char i;\n+\tint j;\n+      };\n+      int k;\n+    };\t\t\t\t// { dg-warning \"anonymous struct\" }\n+  };\t\t\t\t// { dg-warning \"anonymous struct\" }\n+  int l;\n+\n+  constexpr B(): h(1), i(2), k(3), l(4) {}\n+};\n+\n+constexpr B b;\n+SA((b.h == 1 && b.i == 2 && b.k == 3 && b.l == 4));"}]}