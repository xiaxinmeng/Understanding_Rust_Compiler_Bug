{"sha": "298d6f60996d885b092748404528b60159a359ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk4ZDZmNjA5OTZkODg1YjA5Mjc0ODQwNDUyOGI2MDE1OWEzNTljYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-12T07:48:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-12T07:48:13Z"}, "message": "cp-tree.h (IDENTIFIER_CTOR_OR_DTOR_P): New macro.\n\n\t* cp-tree.h (IDENTIFIER_CTOR_OR_DTOR_P): New macro.\n\t(cp_tree_index): Add CPTI_PUSH_EXCEPTION_IDENTIFIER.\n\t(cp_push_exception_identifier): New macro.\n\t(DECL_COMPLETE_DESTRUCTOR_P): New macro.\n\t(DECL_BASE_DESTRUCTOR_P): Likewise.\n\t(DECL_DELETING_DESTRUCTOR_P): Likewise.\n\t(get_vtbl_decl_for_binfo): Fix formatting.\n\t(in_charge_arg_for_name): New macro.\n\t(maybe_build_cleanup_and_delete): Remove declaration.\n\t* call.c (build_field_call): Use IDENTIFIER_CTOR_OR_DTOR_P.\n\t(in_charge_arg_for_name): New function.\n\t(build_new_method_call): Use it.  Handle cloned destructors.\n\t(build_clone): Don't make the base constructor virtual.\n\tAutomatically defer generated functions.\n\t(clone_function_decl): Handle destructors, too.\n\t(clone_constructors_and_destructors): Likewise.\n\t(create_vtable_ptr): Don't create a vtable entry for a cloned\n\tfunction.\n\t* decl.c (predefined_identifier): Add ctor_or_dtor_p.\n\t(initialize_predefined_identifiers): Update appropriately.\n\t(finish_destructor_body): Simplify.\n\t(maybe_build_cleanup_and_delete): Remove.\n\t* except.c (expand_throw): Handle new-ABI destructors.\n\t* init.c (expand_cleanup_for_base): Use base_dtor_identifier.\n\t(build_dtor_call): New function.\n\t(build_delete): Use it.  Simplify.\n\t* optimize.c (maybe_clone_body): Handle destructors.\n\t* search.c (lookup_field_queue_p): Use IDENTIFIER_CTOR_OR_DTOR_P.\n\nFrom-SVN: r33096", "tree": {"sha": "1607e4b03e19e5a1a352f78d3cd7ac33ece46c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1607e4b03e19e5a1a352f78d3cd7ac33ece46c16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/298d6f60996d885b092748404528b60159a359ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298d6f60996d885b092748404528b60159a359ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/298d6f60996d885b092748404528b60159a359ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/298d6f60996d885b092748404528b60159a359ca/comments", "author": null, "committer": null, "parents": [{"sha": "1ba82fb2c46478e543fee347651fc167fef2ccdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba82fb2c46478e543fee347651fc167fef2ccdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ba82fb2c46478e543fee347651fc167fef2ccdb"}], "stats": {"total": 449, "additions": 295, "deletions": 154}, "files": [{"sha": "8ebc5ae217ff0b921b65f3e2201751aed6f090f4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -1,3 +1,40 @@\n+2000-04-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (IDENTIFIER_CTOR_OR_DTOR_P): New macro.\n+\t(cp_tree_index): Add CPTI_PUSH_EXCEPTION_IDENTIFIER.\n+\t(cp_push_exception_identifier): New macro.\n+\t(DECL_COMPLETE_DESTRUCTOR_P): New macro.\n+\t(DECL_BASE_DESTRUCTOR_P): Likewise.\n+\t(DECL_DELETING_DESTRUCTOR_P): Likewise.\n+\t(get_vtbl_decl_for_binfo): Fix formatting.\n+\t(in_charge_arg_for_name): New macro.\n+\t(maybe_build_cleanup_and_delete): Remove declaration.\n+\t* call.c (build_field_call): Use IDENTIFIER_CTOR_OR_DTOR_P.\n+\t(in_charge_arg_for_name): New function.\n+\t(build_new_method_call): Use it.  Handle cloned destructors.\n+\t(build_clone): Don't make the base constructor virtual.\n+\tAutomatically defer generated functions.\n+\t(clone_function_decl): Handle destructors, too.\n+\t(clone_constructors_and_destructors): Likewise.\n+\t(create_vtable_ptr): Don't create a vtable entry for a cloned\n+\tfunction.\n+\t* decl.c (predefined_identifier): Add ctor_or_dtor_p.\n+\t(initialize_predefined_identifiers): Update appropriately.\n+\t(finish_destructor_body): Simplify.\n+\t(maybe_build_cleanup_and_delete): Remove.\n+\t* except.c (expand_throw): Handle new-ABI destructors.\n+\t* init.c (expand_cleanup_for_base): Use base_dtor_identifier.\n+\t(build_dtor_call): New function.\n+\t(build_delete): Use it.  Simplify.\n+\t* optimize.c (maybe_clone_body): Handle destructors.\n+\t* search.c (lookup_field_queue_p): Use IDENTIFIER_CTOR_OR_DTOR_P.\n+\t\n+\t* exception.cc (cleanup_fn): New typedef.\n+\t(CALL_CLEANUP): New macro.\n+\t(cp_eh_info): Use them.\n+\t(__cp_push_exception): Likewise.\n+\t(__cp_pop_exception): Likewise.\n+\t\n 2000-04-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (cp_tree_index): Add CPTI_DTOR_IDENTIFIER."}, {"sha": "1ffbf60290eb7b1fbbaa42e6f4e4aacfa6e891ea", "filename": "gcc/cp/call.c", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -130,7 +130,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n {\n   tree field, instance;\n \n-  if (name == ctor_identifier || name == dtor_identifier)\n+  if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     return NULL_TREE;\n \n   /* Speed up the common case.  */\n@@ -4172,6 +4172,29 @@ build_over_call (cand, args, flags)\n   return convert_from_reference (fn);\n }\n \n+/* Returns the value to use for the in-charge parameter when making a\n+   call to a function with the indicated NAME.  */\n+\n+tree\n+in_charge_arg_for_name (name)\n+     tree name;\n+{\n+  if (name == base_ctor_identifier\n+      || name == base_dtor_identifier)\n+    return integer_zero_node;\n+  else if (name == complete_ctor_identifier)\n+    return integer_one_node;\n+  else if (name == complete_dtor_identifier)\n+    return integer_two_node;\n+  else if (name == deleting_dtor_identifier)\n+    return integer_three_node;\n+\n+  /* This function should only be called with one of the names listed\n+     above.  */\n+  my_friendly_abort (20000411);\n+  return NULL_TREE;\n+}\n+\n static tree\n build_new_method_call (instance, name, args, basetype_path, flags)\n      tree instance, name, args, basetype_path;\n@@ -4253,30 +4276,30 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n   /* Callers should explicitly indicate whether they want to construct\n      the complete object or just the part without virtual bases.  */\n   my_friendly_assert (name != ctor_identifier, 20000408);\n+  /* Similarly for destructors.  */\n+  my_friendly_assert (name != dtor_identifier, 20000408);\n \n-  if (name == complete_ctor_identifier \n-      || name == base_ctor_identifier)\n+  if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n-      pretty_name = constructor_name (basetype);\n+      int constructor_p;\n+\n+      constructor_p = (name == complete_ctor_identifier\n+\t\t       || name == base_ctor_identifier);\n+      pretty_name = (constructor_p \n+\t\t     ? constructor_name (basetype) : dtor_identifier);\n \n       if (!flag_new_abi)\n \t{\n \t  /* Add the in-charge parameter as an implicit first argument.  */\n-\t  if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t    {\n-\t      tree in_charge;\n-\n-\t      if (name == complete_ctor_identifier)\n-\t\tin_charge = integer_one_node;\n-\t      else\n-\t\tin_charge = integer_zero_node;\n-\n-\t      args = tree_cons (NULL_TREE, in_charge, args);\n-\t    }\n+\t  if (!constructor_p\n+\t      || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t    args = tree_cons (NULL_TREE,\n+\t\t\t      in_charge_arg_for_name (name),\n+\t\t\t      args);\n \n \t  /* We want to call the normal constructor function under the\n \t     old ABI.  */\n-\t  name = ctor_identifier;\n+\t  name = constructor_p ? ctor_identifier : dtor_identifier;\n \t}\n     }\n   else"}, {"sha": "f0a84f83221e6fa1a8036541392c6c516234c5bd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -3883,6 +3883,14 @@ build_clone (fn, name)\n   /* And it hasn't yet been deferred.  */\n   DECL_DEFERRED_FN (clone) = 0;\n \n+  /* The base-class destructor is not virtual.  */\n+  if (name == base_dtor_identifier)\n+    {\n+      DECL_VIRTUAL_P (clone) = 0;\n+      if (TREE_CODE (clone) != TEMPLATE_DECL)\n+\tDECL_VINDEX (clone) = NULL_TREE;\n+    }\n+\n   /* If there was an in-charge paramter, drop it from the function\n      type.  */\n   if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n@@ -3948,6 +3956,8 @@ build_clone (fn, name)\n       DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n       DECL_TI_TEMPLATE (result) = clone;\n     }\n+  else if (DECL_DEFERRED_FN (fn))\n+    defer_fn (clone);\n \n   return clone;\n }\n@@ -3963,8 +3973,10 @@ clone_function_decl (fn, update_method_vec_p)\n {\n   tree clone;\n \n-  if (DECL_CONSTRUCTOR_P (fn))\n+  if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn))\n     {\n+      /* For each constructor, we need two variants: an in-charge version\n+\t and a not-in-charge version.  */\n       clone = build_clone (fn, complete_ctor_identifier);\n       if (update_method_vec_p)\n \tadd_method (DECL_CONTEXT (clone), NULL, clone);\n@@ -3973,8 +3985,22 @@ clone_function_decl (fn, update_method_vec_p)\n \tadd_method (DECL_CONTEXT (clone), NULL, clone);\n     }\n   else\n-    /* We don't do destructors yet.  */\n-    my_friendly_abort (20000411);\n+    {\n+      my_friendly_assert (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn), 20000411);\n+\n+      /* For each destructor, we need two variants: an in-charge\n+\t version, a not-in-charge version, and an in-charge deleting\n+\t version.  */\n+      clone = build_clone (fn, complete_dtor_identifier);\n+      if (update_method_vec_p)\n+\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+      clone = build_clone (fn, deleting_dtor_identifier);\n+      if (update_method_vec_p)\n+\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+      clone = build_clone (fn, base_dtor_identifier);\n+      if (update_method_vec_p)\n+\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+    }\n }\n \n /* For each of the constructors and destructors in T, create an\n@@ -3995,12 +4021,10 @@ clone_constructors_and_destructors (t)\n   if (!CLASSTYPE_METHOD_VEC (t))\n     return;\n \n-  /* For each constructor, we need two variants: an in-charge version\n-     and a not-in-charge version.  */\n   for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n     clone_function_decl (OVL_CURRENT (fns), /*update_method_vec_p=*/1);\n-\n-  /* For now, we don't do the destructors.  */\n+  for (fns = CLASSTYPE_DESTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+    clone_function_decl (OVL_CURRENT (fns), /*update_method_vec_p=*/1);\n }\n \n /* Remove all zero-width bit-fields from T.  */\n@@ -4130,7 +4154,8 @@ create_vtable_ptr (t, empty_p, vfuns_p,\n   /* Loop over the virtual functions, adding them to our various\n      vtables.  */\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n-    if (DECL_VINDEX (fn))\n+    if (DECL_VINDEX (fn) \n+\t&& !(flag_new_abi && DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn)))\n       add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n \t\t\t    vfuns_p, fn, t);\n "}, {"sha": "a0e6d8a49bc65f22062e980ad1f202093818ad50", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -66,6 +66,7 @@ Boston, MA 02111-1307, USA.  */\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n       SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n+      IDENTIFIER_CTOR_OR_DTOR_P (in IDENTIFIER_NODE)\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n@@ -482,6 +483,11 @@ struct tree_srcloc\n               OPERATOR_TYPENAME_FORMAT,\t\t\t\\\n \t      strlen (OPERATOR_TYPENAME_FORMAT)))\n \n+/* Nonzero if this identifier is the name of a constructor or\n+   destructor.  */\n+#define IDENTIFIER_CTOR_OR_DTOR_P(NODE) \\\n+  TREE_LANG_FLAG_3 (NODE)\n+\n /* Nonzero means reject anything that ISO standard C++ forbids.  */\n extern int pedantic;\n \n@@ -571,6 +577,7 @@ enum cp_tree_index\n     CPTI_PFN_IDENTIFIER,\n     CPTI_PFN_OR_DELTA2_IDENTIFIER,\n     CPTI_VPTR_IDENTIFIER,\n+    CPTI_PUSH_EXCEPTION_IDENTIFIER,\n \n     CPTI_LANG_NAME_C,\n     CPTI_LANG_NAME_CPLUSPLUS,\n@@ -682,6 +689,9 @@ extern tree cp_global_trees[CPTI_MAX];\n #define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n #define pfn_or_delta2_identifier        cp_global_trees[CPTI_PFN_OR_DELTA2_IDENTIFIER]\n #define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n+/* The name of the function to call to push an exception onto the\n+   exception stack.  */\n+#define cp_push_exception_identifier    cp_global_trees[CPTI_PUSH_EXCEPTION_IDENTIFIER]\n \n #define lang_name_c                     cp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus             cp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n@@ -1963,6 +1973,24 @@ struct lang_decl\n #define DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P(NODE)\t\t\t\\\n   (DECL_DESTRUCTOR_P (NODE) && !DECL_CLONED_FUNCTION_P (NODE))\n \n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n+   object.  */\n+#define DECL_COMPLETE_DESTRUCTOR_P(NODE)\t\t\\\n+  (DECL_DESTRUCTOR_P (NODE) \t\t\t\t\\\n+   && DECL_NAME (NODE) == complete_dtor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a base\n+   object.  */\n+#define DECL_BASE_DESTRUCTOR_P(NODE)\t\t\\\n+  (DECL_DESTRUCTOR_P (NODE)\t\t\t\\\n+   && DECL_NAME (NODE) == base_dtor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n+   object.  */\n+#define DECL_DELETING_DESTRUCTOR_P(NODE)\t\t\\\n+  (DECL_DESTRUCTOR_P (NODE) \t\t\t\t\\\n+   && DECL_NAME (NODE) == deleting_dtor_identifier)\n+\n /* Nonzero if NODE (a FUNCTION_DECL) is a cloned constructor or\n    destructor.  */\n #define DECL_CLONED_FUNCTION_P(NODE) \\\n@@ -3761,7 +3789,8 @@ extern void unreverse_member_declarations       PARAMS ((tree));\n extern void invalidate_class_lookup_cache       PARAMS ((void));\n extern void maybe_note_name_used_in_class       PARAMS ((tree, tree));\n extern void note_name_declared_in_class         PARAMS ((tree, tree));\n-extern tree get_vtbl_decl_for_binfo           PARAMS ((tree));\n+extern tree get_vtbl_decl_for_binfo             PARAMS ((tree));\n+extern tree in_charge_arg_for_name              PARAMS ((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n@@ -3898,7 +3927,6 @@ extern tree finish_function\t\t\tPARAMS ((int));\n extern tree start_method\t\t\tPARAMS ((tree, tree, tree));\n extern tree finish_method\t\t\tPARAMS ((tree));\n extern void hack_incomplete_structures\t\tPARAMS ((tree));\n-extern tree maybe_build_cleanup_and_delete\tPARAMS ((tree));\n extern tree maybe_build_cleanup\t\t\tPARAMS ((tree));\n extern void cplus_expand_expr_stmt\t\tPARAMS ((tree));\n extern void finish_stmt\t\t\t\tPARAMS ((void));"}, {"sha": "cfb4618dc6e930335e7ea011da3f93d627b2f3de", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 44, "deletions": 60, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -6045,6 +6045,8 @@ typedef struct predefined_identifier\n   const char *name;\n   /* The place where the IDENTIFIER_NODE should be stored.  */\n   tree *node;\n+  /* Non-zero if this is the name of a constructor or destructor.  */\n+  int ctor_or_dtor_p;\n } predefined_identifier;\n \n /* Create all the predefined identifiers.  */\n@@ -6056,30 +6058,35 @@ initialize_predefined_identifiers ()\n \n   /* A table of identifiers to create at startup.  */\n   static predefined_identifier predefined_identifiers[] = {\n-    { \"C++\", &lang_name_cplusplus },\n-    { \"C\", &lang_name_c },\n-    { \"Java\", &lang_name_java },\n-    { CTOR_NAME, &ctor_identifier },\n-    { \"__base_ctor\", &base_ctor_identifier },\n-    { \"__comp_ctor\", &complete_ctor_identifier },\n-    { DTOR_NAME, &dtor_identifier },\n-    { \"__comp_dtor\", &complete_dtor_identifier },\n-    { \"__base_dtor\", &base_dtor_identifier },\n-    { \"__deleting_dtor\", &deleting_dtor_identifier },\n-    { VTABLE_DELTA2_NAME, &delta2_identifier },\n-    { VTABLE_DELTA_NAME, &delta_identifier },\n-    { IN_CHARGE_NAME, &in_charge_identifier },\n-    { VTABLE_INDEX_NAME, &index_identifier },\n-    { \"nelts\", &nelts_identifier },\n-    { THIS_NAME, &this_identifier },\n-    { VTABLE_PFN_NAME, &pfn_identifier },\n-    { \"__pfn_or_delta2\", &pfn_or_delta2_identifier },\n-    { \"_vptr\", &vptr_identifier },\n-    { NULL, NULL }\n+    { \"C++\", &lang_name_cplusplus, 0 },\n+    { \"C\", &lang_name_c, 0 },\n+    { \"Java\", &lang_name_java, 0 },\n+    { CTOR_NAME, &ctor_identifier, 1 },\n+    { \"__base_ctor\", &base_ctor_identifier, 1 },\n+    { \"__comp_ctor\", &complete_ctor_identifier, 1 },\n+    { DTOR_NAME, &dtor_identifier, 1 },\n+    { \"__comp_dtor\", &complete_dtor_identifier, 1 },\n+    { \"__base_dtor\", &base_dtor_identifier, 1 },\n+    { \"__deleting_dtor\", &deleting_dtor_identifier, 1 },\n+    { VTABLE_DELTA2_NAME, &delta2_identifier, 0 },\n+    { VTABLE_DELTA_NAME, &delta_identifier, 0 },\n+    { IN_CHARGE_NAME, &in_charge_identifier, 0 },\n+    { VTABLE_INDEX_NAME, &index_identifier, 0 },\n+    { \"nelts\", &nelts_identifier, 0 },\n+    { THIS_NAME, &this_identifier, 0 },\n+    { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n+    { \"__pfn_or_delta2\", &pfn_or_delta2_identifier, 0 },\n+    { \"_vptr\", &vptr_identifier, 0 },\n+    { \"__cp_push_exception\", &cp_push_exception_identifier, 0 },\n+    { NULL, NULL, 0 }\n   };\n \n   for (pid = predefined_identifiers; pid->name; ++pid)\n-    *pid->node = get_identifier (pid->name);\n+    {\n+      *pid->node = get_identifier (pid->name);\n+      if (pid->ctor_or_dtor_p)\n+\tIDENTIFIER_CTOR_OR_DTOR_P (*pid->node) = 1;\n+    }\n }\n \n /* Create the predefined scalar types of C,\n@@ -13811,9 +13818,9 @@ static void\n finish_destructor_body ()\n {\n   tree compound_stmt;\n-  tree in_charge;\n   tree virtual_size;\n   tree exprstmt;\n+  tree if_stmt;\n \n   /* Create a block to contain all the extra code.  */\n   compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n@@ -13831,16 +13838,9 @@ finish_destructor_body ()\n      will set the flag again.  */\n   TYPE_HAS_DESTRUCTOR (current_class_type) = 0;\n \n-  /* These are two cases where we cannot delegate deletion.  */\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)\n-      || TYPE_GETS_REG_DELETE (current_class_type))\n-    in_charge = integer_zero_node;\n-  else\n-    in_charge = current_in_charge_parm;\n-\n   exprstmt = build_delete (current_class_type,\n \t\t\t   current_class_ref,\n-\t\t\t   in_charge,\n+\t\t\t   integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL,\n \t\t\t   0);\n \n@@ -13873,8 +13873,8 @@ finish_destructor_body ()\n \t\t     TYPE_BINFO (current_class_type));\n \t\t  finish_expr_stmt\n \t\t    (build_scoped_method_call\n-\t\t     (current_class_ref, vb, dtor_identifier,\n-\t\t      build_tree_list (NULL_TREE, integer_zero_node)));\n+\t\t     (current_class_ref, vb, complete_dtor_identifier,\n+\t\t      NULL_TREE));\n \t\t}\n \t      vbases = TREE_CHAIN (vbases);\n \t    }\n@@ -13897,24 +13897,18 @@ finish_destructor_body ()\n      only defines placement deletes we don't do anything here.  So we\n      pass LOOKUP_SPECULATIVELY; delete_sanity will complain for us if\n      they ever try to delete one of these.  */\n-  if (TYPE_GETS_REG_DELETE (current_class_type)\n-      || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-    {\n-      tree if_stmt;\n-\n-      exprstmt = build_op_delete_call\n-\t(DELETE_EXPR, current_class_ptr, virtual_size,\n-\t LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n-\n-      if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t  current_in_charge_parm,\n-\t\t\t\t  integer_one_node),\n-\t\t\t   if_stmt);\n-      finish_expr_stmt (exprstmt);\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n-    }\n+  exprstmt = build_op_delete_call\n+    (DELETE_EXPR, current_class_ptr, virtual_size,\n+     LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n+\n+  if_stmt = begin_if_stmt ();\n+  finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t      current_in_charge_parm,\n+\t\t\t      integer_one_node),\n+\t\t       if_stmt);\n+  finish_expr_stmt (exprstmt);\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt ();\n \n   /* Close the block we started above.  */\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n@@ -14559,16 +14553,6 @@ maybe_build_cleanup_1 (decl, auto_delete)\n   return 0;\n }\n \n-/* If DECL is of a type which needs a cleanup, build that cleanup\n-   here.  The cleanup does free the storage with a call to delete.  */\n-\n-tree\n-maybe_build_cleanup_and_delete (decl)\n-     tree decl;\n-{\n-  return maybe_build_cleanup_1 (decl, integer_three_node);\n-}\n-\n /* If DECL is of a type which needs a cleanup, build that cleanup\n    here.  The cleanup does not free the storage with a call a delete.  */\n "}, {"sha": "dba1466eea02cd7f41021eb1531aeedd90463e41", "filename": "gcc/cp/except.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -888,14 +888,20 @@ expand_throw (exp)\n       /* First, decay it.  */\n       exp = decay_conversion (exp);\n \n-      /* cleanup_type is void (*)(void *, int),\n-\t the internal type of a destructor. */\n+      /* The CLEANUP_TYPE is the internal type of a destructor.  Under\n+\t the old ABI, destructors are two-argument functions; under\n+\t the new ABI they take only one argument.  */\n       if (cleanup_type == NULL_TREE)\n-\tcleanup_type = build_pointer_type\n-\t  (build_function_type\n-\t   (void_type_node, tree_cons\n-\t    (NULL_TREE, ptr_type_node, tree_cons\n-\t     (NULL_TREE, integer_type_node, void_list_node))));\n+\t{\n+\t  tree arg_types;\n+\t  \n+\t  arg_types = void_list_node;\n+\t  if (!flag_new_abi)\n+\t    arg_types = tree_cons (NULL_TREE, integer_type_node, arg_types);\n+\t  arg_types = tree_cons (NULL_TREE, ptr_type_node, arg_types);\n+\t  cleanup_type = (build_pointer_type \n+\t\t\t  (build_function_type (void_type_node, arg_types)));\n+\t}\n \n       if (TYPE_PTR_P (TREE_TYPE (exp)))\n \tthrow_type = build_eh_type_type (TREE_TYPE (exp));\n@@ -949,7 +955,10 @@ expand_throw (exp)\n \t  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n \t    {\n \t      cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n-\t\t\t\t\t dtor_identifier, 0);\n+\t\t\t\t\t (flag_new_abi\n+\t\t\t\t\t  ? complete_dtor_identifier\n+\t\t\t\t\t  : dtor_identifier),\n+\t\t\t\t\t 0);\n \t      cleanup = TREE_VALUE (cleanup);\n \t      mark_used (cleanup);\n \t      mark_addressable (cleanup);\n@@ -970,7 +979,7 @@ expand_throw (exp)\n \t  TREE_TYPE (cleanup) = cleanup_type;\n \t}\n \n-      fn = get_identifier (\"__cp_push_exception\");\n+      fn = cp_push_exception_identifier;\n       if (IDENTIFIER_GLOBAL_VALUE (fn))\n \tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n       else"}, {"sha": "3f61b3ed66a73cd5e6787570524a72360133cc00", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -78,6 +78,21 @@ std::unexpected ()\n   __unexpected_func ();\n }\n \n+/* The type of a function called to clean up an exception object.\n+   (These will be destructors.)  Under the old ABI, these take a\n+   second argument (the `in-charge' argument), that indicates whether\n+   or not do delete the object, and whether or not to destroy virtual\n+   bases.  Under the new ABI, there is no second argument.  */\n+#if !defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100\n+typedef void (*cleanup_fn)(void *, int);\n+/* The `2' is the value for the in-charge parameter that indicates\n+   that virtual bases should be destroyed.  */\n+#define CALL_CLEANUP(FN, THIS) FN (THIS, 2)\n+#else\n+typedef void (*cleanup_fn)(void *);\n+#define CALL_CLEANUP(FN, THIS) FN (THIS)\n+#endif\n+\n /* C++-specific state about the current exception.\n    This must match init_exception_processing().\n \n@@ -90,7 +105,7 @@ struct cp_eh_info\n   __eh_info eh_info;\n   void *value;\n   void *type;\n-  void (*cleanup)(void *, int);\n+  cleanup_fn cleanup;\n   bool caught;\n   cp_eh_info *next;\n   long handlers;\n@@ -202,7 +217,7 @@ __cplus_type_matcher (__eh_info *info_, void *match_info,\n    Used by expand_throw().  */\n \n extern \"C\" void\n-__cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n+__cp_push_exception (void *value, void *type, cleanup_fn cleanup)\n {\n   cp_eh_info *p = (cp_eh_info *) __eh_alloc (sizeof (cp_eh_info));\n \n@@ -251,8 +266,8 @@ __cp_pop_exception (cp_eh_info *p)\n   *q = p->next;\n \n   if (p->cleanup)\n-    /* 2 is a magic value for destructors; see build_delete().  */\n-    p->cleanup (p->original_value, 2);  // value may have been adjusted.\n+    // value may have been adjusted.\n+    CALL_CLEANUP (p->cleanup, p->original_value);\n \n   if (! __is_pointer (p->type))\n     __eh_free (p->original_value);  // value may have been adjusted."}, {"sha": "11549c24a7a37e6ca1f21883ecd32283b8a8a21a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 73, "deletions": 44, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -51,6 +51,7 @@ static tree get_temp_regvar PARAMS ((tree, tree));\n static tree dfs_initialize_vtbl_ptrs PARAMS ((tree, void *));\n static tree build_new_1\tPARAMS ((tree));\n static tree get_cookie_size PARAMS ((tree));\n+static tree build_dtor_call PARAMS ((tree, tree, int));\n \n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n@@ -713,8 +714,7 @@ expand_cleanup_for_base (binfo, flag)\n \n   /* Call the destructor.  */\n   expr = (build_scoped_method_call\n-\t  (current_class_ref, binfo, dtor_identifier,\n-\t   build_tree_list (NULL_TREE, integer_zero_node)));\n+\t  (current_class_ref, binfo, base_dtor_identifier, NULL_TREE));\n   if (flag)\n     expr = fold (build (COND_EXPR, void_type_node,\n \t\t\ttruthvalue_conversion (flag),\n@@ -2963,6 +2963,71 @@ build_x_delete (addr, which_delete, virtual_size)\n   return build_op_delete_call (code, addr, virtual_size, flags, NULL_TREE);\n }\n \n+/* Call the destructor for EXP using the IN_CHARGE parameter.  FLAGS\n+   are as for build_delete.  */\n+\n+static tree\n+build_dtor_call (exp, in_charge, flags)\n+     tree exp;\n+     tree in_charge;\n+     int flags;\n+{\n+  tree name = NULL_TREE;\n+  tree call1;\n+  tree call2;\n+  tree call3;\n+  tree result;\n+\n+  /* First, try to figure out statically which function to call.  */\n+  in_charge = fold (in_charge);\n+  if (tree_int_cst_equal (in_charge, integer_zero_node))\n+    name = base_dtor_identifier;\n+  else if (tree_int_cst_equal (in_charge, integer_one_node))\n+    name = deleting_dtor_identifier;\n+  else if (tree_int_cst_equal (in_charge, integer_two_node))\n+    name = complete_dtor_identifier;\n+  if (name)\n+    {\n+      if (!binfo)\n+\treturn build_method_call (exp, name, NULL_TREE, NULL_TREE, flags);\n+      else\n+\treturn build_scoped_method_call (exp, binfo, name, NULL_TREE);\n+    }\n+\n+  /* If that didn't work, build the various alternatives.  */\n+  if (!binfo)\n+    {\n+      call1 = build_method_call (exp, complete_dtor_identifier,\n+\t\t\t\t NULL_TREE, NULL_TREE, flags);\n+      call2 = build_method_call (exp, deleting_dtor_identifier,\n+\t\t\t\t NULL_TREE, NULL_TREE, flags);\n+      call3 = build_method_call (exp, base_dtor_identifier,\n+\t\t\t\t NULL_TREE, NULL_TREE, flags);\n+    }\n+  else\n+    {\n+      call1 = build_scoped_method_call (exp, binfo, \n+\t\t\t\t\tcomplete_dtor_identifier, NULL_TREE);\n+      call2 = build_scoped_method_call (exp, binfo, \n+\t\t\t\t\tdeleting_dtor_identifier, NULL_TREE);\n+      call3 = build_scoped_method_call (exp, binfo, \n+\t\t\t\t\tbase_dtor_identifier, NULL_TREE);\n+    }\n+\n+  /* Build the conditionals.  */\n+  result = build (COND_EXPR, void_type_node,\n+\t\t  fold (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t       in_charge, integer_two_node)),\n+\t\t  call1,\n+\t\t  call3);\n+  result = build (COND_EXPR, void_type_node,\n+\t\t  fold (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t       in_charge, integer_one_node)),\n+\t\t  call2,\n+\t\t  result);\n+  return result;\n+}\n+\n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n    ADDR is an expression which yields the store to be destroyed.\n    AUTO_DELETE is nonzero if a call to DELETE should be made or not.\n@@ -3084,10 +3149,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       else\n \tpassed_auto_delete = auto_delete;\n \n-      expr = build_method_call\n-\t(ref, dtor_identifier, build_tree_list (NULL_TREE, passed_auto_delete),\n-\t NULL_TREE, flags);\n-\n+      expr = build_dtor_call (ref, passed_auto_delete, NULL_TREE, flags);\n       if (do_delete)\n \texpr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n \n@@ -3111,59 +3173,26 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (type);\n       tree base_binfo = n_baseclasses > 0 ? TREE_VEC_ELT (binfos, 0) : NULL_TREE;\n       tree exprstmt = NULL_TREE;\n-      tree parent_auto_delete = auto_delete;\n-      tree cond;\n \n       /* Set this again before we call anything, as we might get called\n \t recursively.  */\n       TYPE_HAS_DESTRUCTOR (type) = 1;\n \n       /* If we have member delete or vbases, we call delete in\n \t finish_function.  */\n-      if (auto_delete == integer_zero_node)\n-\tcond = NULL_TREE;\n-      else if (base_binfo == NULL_TREE\n-\t       || TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n-\t{\n-\t  cond = build (COND_EXPR, void_type_node,\n-\t\t\tbuild (BIT_AND_EXPR, integer_type_node, auto_delete, integer_one_node),\n-\t\t\tbuild_builtin_delete_call (addr),\n-\t\t\tvoid_zero_node);\n-\t}\n-      else\n-\tcond = NULL_TREE;\n-\n-      if (cond)\n-\texprstmt = build_tree_list (NULL_TREE, cond);\n-\n-      if (base_binfo\n-\t  && ! TREE_VIA_VIRTUAL (base_binfo)\n-\t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n-\t{\n-\t  tree this_auto_delete;\n-\n-\t  if (BINFO_OFFSET_ZEROP (base_binfo))\n-\t    this_auto_delete = parent_auto_delete;\n-\t  else\n-\t    this_auto_delete = integer_zero_node;\n-\n-\t  expr = build_scoped_method_call\n-\t    (ref, base_binfo, dtor_identifier,\n-\t     build_tree_list (NULL_TREE, this_auto_delete));\n-\t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n-\t}\n+      my_friendly_assert (auto_delete == integer_zero_node, 20000411);\n \n       /* Take care of the remaining baseclasses.  */\n-      for (i = 1; i < n_baseclasses; i++)\n+      for (i = 0; i < n_baseclasses; i++)\n \t{\n \t  base_binfo = TREE_VEC_ELT (binfos, i);\n \t  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))\n \t      || TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n \n-\t  expr = build_scoped_method_call\n-\t    (ref, base_binfo, dtor_identifier,\n-\t     build_tree_list (NULL_TREE, integer_zero_node));\n+\t  expr = build_scoped_method_call (ref, base_binfo,\n+\t\t\t\t\t   base_dtor_identifier,\n+\t\t\t\t\t   NULL_TREE);\n \n \t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}"}, {"sha": "5c78950af35885507b27a81eb4eab47983a4e346", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -804,10 +804,6 @@ maybe_clone_body (fn)\n       && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n     return 0;\n \n-  /* We don't yet handle destructors.  */\n-  if (DECL_DESTRUCTOR_P (fn))\n-    return 0;\n-\n   /* We know that any clones immediately follow FN in the TYPE_METHODS\n      list.  */\n   for (clone = TREE_CHAIN (fn);\n@@ -850,12 +846,7 @@ maybe_clone_body (fn)\n \t  if (DECL_HAS_IN_CHARGE_PARM_P (fn) && parmno == 1)\n \t    {\n \t      tree in_charge;\n-\n-\t      if (DECL_COMPLETE_CONSTRUCTOR_P (clone))\n-\t\tin_charge = integer_one_node;\n-\t      else\n-\t\tin_charge = integer_zero_node;\n-\n+\t      in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n \t      splay_tree_insert (id.decl_map,\n \t\t\t\t (splay_tree_key) parm,\n \t\t\t\t (splay_tree_key) in_charge);"}, {"sha": "197a6adaf8e938e53daec3293ddb99e2b248184c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/298d6f60996d885b092748404528b60159a359ca/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=298d6f60996d885b092748404528b60159a359ca", "patch": "@@ -1337,7 +1337,7 @@ lookup_field_queue_p (binfo, data)\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n \n   /* Don't look for constructors or destructors in base classes.  */\n-  if (lfi->name == ctor_identifier || lfi->name == dtor_identifier)\n+  if (IDENTIFIER_CTOR_OR_DTOR_P (lfi->name))\n     return NULL_TREE;\n \n   /* If this base class is hidden by the best-known value so far, we"}]}