{"sha": "008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4YTExY2M3MDcxMGM2ZTQzYThiYjZiZTZmOGI2ZTE3OWU0ZWRlNw==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2017-11-10T17:14:28Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2017-11-10T17:14:28Z"}, "message": "re PR target/82641 (Unable to enable crc32 for a certain function with target attribute on ARM (aarch32))\n\n2017-11-10  Tamar Christina  <tamar.christina@arm.com>\n\n\tPR target/82641\n\t* config/arm/arm.c\n\t(arm_option_override): Refactor.\n\t(arm_option_reconfigure_globals): New.\n\t(arm_options_perform_arch_sanity_checks): New.\n\t* config/arm/arm-protos.h (arm_option_reconfigure_globals): New prototype.\n\t(arm_options_perform_arch_sanity_checks): Likewise\n\nFrom-SVN: r254632", "tree": {"sha": "74752f112b4206c8232b82d498c4a3a1f6a0ac0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74752f112b4206c8232b82d498c4a3a1f6a0ac0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd764269a16bdf66160c7272c9340afd57e654fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd764269a16bdf66160c7272c9340afd57e654fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd764269a16bdf66160c7272c9340afd57e654fa"}], "stats": {"total": 293, "additions": 161, "deletions": 132}, "files": [{"sha": "c721337653d59e17dbb2066f39bc95364a9330de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "patch": "@@ -1,3 +1,13 @@\n+2017-11-10  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/82641\n+\t* config/arm/arm.c\n+\t(arm_option_override): Refactor.\n+\t(arm_option_reconfigure_globals): New.\n+\t(arm_options_perform_arch_sanity_checks): New.\n+\t* config/arm/arm-protos.h (arm_option_reconfigure_globals): New prototype.\n+\t(arm_options_perform_arch_sanity_checks): Likewise\n+\n 2017-11-10  Pat Haugen  <pthaugen@us.ibm.com>\n \n \t* rs6000/power9.md (power9-qpdiv): Correct DFU pipe usage."}, {"sha": "10c96390ea6cc584a5bb055096ff1aef6871507c", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "patch": "@@ -224,6 +224,8 @@ extern tree arm_valid_target_attribute_tree (tree, struct gcc_options *,\n extern void arm_configure_build_target (struct arm_build_target *,\n \t\t\t\t\tstruct cl_target_option *,\n \t\t\t\t\tstruct gcc_options *, bool);\n+extern void arm_option_reconfigure_globals (void);\n+extern void arm_options_perform_arch_sanity_checks (void);\n extern void arm_pr_long_calls (struct cpp_reader *);\n extern void arm_pr_no_long_calls (struct cpp_reader *);\n extern void arm_pr_long_calls_off (struct cpp_reader *);"}, {"sha": "db99303f3fb7a2196f48358e74fa4d98f31f045e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 149, "deletions": 132, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008a11cc70710c6e43a8bb6be6f8b6e179e4ede7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=008a11cc70710c6e43a8bb6be6f8b6e179e4ede7", "patch": "@@ -3335,8 +3335,9 @@ arm_option_override (void)\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n \n-  sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", arm_active_target.arch_pp_name);\n-  arm_base_arch = arm_active_target.base_arch;\n+  /* Initialize boolean versions of the architectural flags, for use\n+     in the arm.md file and for enabling feature flags.  */\n+  arm_option_reconfigure_globals ();\n \n   arm_tune = arm_active_target.tune_core;\n   tune_flags = arm_active_target.tune_flags;\n@@ -3346,16 +3347,6 @@ arm_option_override (void)\n   if (TARGET_APCS_FRAME)\n     flag_shrink_wrap = false;\n \n-  /* BPABI targets use linker tricks to allow interworking on cores\n-     without thumb support.  */\n-  if (TARGET_INTERWORK\n-      && !TARGET_BPABI\n-      && !bitmap_bit_p (arm_active_target.isa, isa_bit_thumb))\n-    {\n-      warning (0, \"target CPU does not support interworking\" );\n-      target_flags &= ~MASK_INTERWORK;\n-    }\n-\n   if (TARGET_APCS_STACK && !TARGET_APCS_FRAME)\n     {\n       warning (0, \"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n@@ -3371,43 +3362,6 @@ arm_option_override (void)\n   if (TARGET_APCS_REENT)\n     warning (0, \"APCS reentrant code not supported.  Ignored\");\n \n-  /* Initialize boolean versions of the architectural flags, for use\n-     in the arm.md file.  */\n-  arm_arch3m = bitmap_bit_p (arm_active_target.isa, isa_bit_armv3m);\n-  arm_arch4 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv4);\n-  arm_arch4t = arm_arch4 && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n-  arm_arch5 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv5);\n-  arm_arch5e = bitmap_bit_p (arm_active_target.isa, isa_bit_armv5e);\n-  arm_arch5te = arm_arch5e\n-    && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n-  arm_arch6 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv6);\n-  arm_arch6k = bitmap_bit_p (arm_active_target.isa, isa_bit_armv6k);\n-  arm_arch_notm = bitmap_bit_p (arm_active_target.isa, isa_bit_notm);\n-  arm_arch6m = arm_arch6 && !arm_arch_notm;\n-  arm_arch7 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv7);\n-  arm_arch7em = bitmap_bit_p (arm_active_target.isa, isa_bit_armv7em);\n-  arm_arch8 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8);\n-  arm_arch8_1 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_1);\n-  arm_arch8_2 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_2);\n-  arm_arch_thumb1 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n-  arm_arch_thumb2 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb2);\n-  arm_arch_xscale = bitmap_bit_p (arm_active_target.isa, isa_bit_xscale);\n-  arm_arch_iwmmxt = bitmap_bit_p (arm_active_target.isa, isa_bit_iwmmxt);\n-  arm_arch_iwmmxt2 = bitmap_bit_p (arm_active_target.isa, isa_bit_iwmmxt2);\n-  arm_arch_thumb_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_tdiv);\n-  arm_arch_arm_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_adiv);\n-  arm_arch_crc = bitmap_bit_p (arm_active_target.isa, isa_bit_crc32);\n-  arm_arch_cmse = bitmap_bit_p (arm_active_target.isa, isa_bit_cmse);\n-  arm_fp16_inst = bitmap_bit_p (arm_active_target.isa, isa_bit_fp16);\n-  arm_arch_lpae = bitmap_bit_p (arm_active_target.isa, isa_bit_lpae);\n-  if (arm_fp16_inst)\n-    {\n-      if (arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n-\terror (\"selected fp16 options are incompatible\");\n-      arm_fp16_format = ARM_FP16_FORMAT_IEEE;\n-    }\n-\n-\n   /* Set up some tuning parameters.  */\n   arm_ld_sched = (tune_flags & TF_LDSCHED) != 0;\n   arm_tune_strongarm = (tune_flags & TF_STRONG) != 0;\n@@ -3416,86 +3370,11 @@ arm_option_override (void)\n   arm_tune_cortex_a9 = (arm_tune == TARGET_CPU_cortexa9) != 0;\n   arm_m_profile_small_mul = (tune_flags & TF_SMALLMUL) != 0;\n \n-  /* And finally, set up some quirks.  */\n-  arm_arch_no_volatile_ce\n-    = bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_volatile_ce);\n-  arm_arch6kz = arm_arch6k && bitmap_bit_p (arm_active_target.isa,\n-\t\t\t\t\t    isa_bit_quirk_armv6kz);\n-\n-  /* V5 code we generate is completely interworking capable, so we turn off\n-     TARGET_INTERWORK here to avoid many tests later on.  */\n-\n-  /* XXX However, we must pass the right pre-processor defines to CPP\n-     or GLD can get confused.  This is a hack.  */\n-  if (TARGET_INTERWORK)\n-    arm_cpp_interwork = 1;\n-\n-  if (arm_arch5)\n-    target_flags &= ~MASK_INTERWORK;\n-\n-  if (TARGET_IWMMXT && !ARM_DOUBLEWORD_ALIGN)\n-    error (\"iwmmxt requires an AAPCS compatible ABI for proper operation\");\n-\n-  if (TARGET_IWMMXT_ABI && !TARGET_IWMMXT)\n-    error (\"iwmmxt abi requires an iwmmxt capable cpu\");\n-\n-  /* If soft-float is specified then don't use FPU.  */\n-  if (TARGET_SOFT_FLOAT)\n-    arm_fpu_attr = FPU_NONE;\n-  else\n-    arm_fpu_attr = FPU_VFP;\n-\n-  if (TARGET_AAPCS_BASED)\n-    {\n-      if (TARGET_CALLER_INTERWORKING)\n-\terror (\"AAPCS does not support -mcaller-super-interworking\");\n-      else\n-\tif (TARGET_CALLEE_INTERWORKING)\n-\t  error (\"AAPCS does not support -mcallee-super-interworking\");\n-    }\n-\n-  /* __fp16 support currently assumes the core has ldrh.  */\n-  if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)\n-    sorry (\"__fp16 and no ldrh\");\n-\n-  if (TARGET_AAPCS_BASED)\n-    {\n-      if (arm_abi == ARM_ABI_IWMMXT)\n-\tarm_pcs_default = ARM_PCS_AAPCS_IWMMXT;\n-      else if (TARGET_HARD_FLOAT_ABI)\n-\t{\n-\t  arm_pcs_default = ARM_PCS_AAPCS_VFP;\n-\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv2))\n-\t    error (\"-mfloat-abi=hard: selected processor lacks an FPU\");\n-\t}\n-      else\n-\tarm_pcs_default = ARM_PCS_AAPCS;\n-    }\n-  else\n-    {\n-      if (arm_float_abi == ARM_FLOAT_ABI_HARD)\n-\tsorry (\"-mfloat-abi=hard and VFP\");\n-\n-      if (arm_abi == ARM_ABI_APCS)\n-\tarm_pcs_default = ARM_PCS_APCS;\n-      else\n-\tarm_pcs_default = ARM_PCS_ATPCS;\n-    }\n-\n   /* For arm2/3 there is no need to do any scheduling if we are doing\n      software floating-point.  */\n   if (TARGET_SOFT_FLOAT && (tune_flags & TF_NO_MODE32))\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n \n-  /* Use the cp15 method if it is available.  */\n-  if (target_thread_pointer == TP_AUTO)\n-    {\n-      if (arm_arch6k && !TARGET_THUMB1)\n-\ttarget_thread_pointer = TP_CP15;\n-      else\n-\ttarget_thread_pointer = TP_SOFT;\n-    }\n-\n   /* Override the default structure alignment for AAPCS ABI.  */\n   if (!global_options_set.x_arm_structure_size_boundary)\n     {\n@@ -3669,14 +3548,6 @@ arm_option_override (void)\n   if (target_slow_flash_data || target_pure_code)\n     arm_disable_literal_pool = true;\n \n-  if (use_cmse && !arm_arch_cmse)\n-    error (\"target CPU does not support ARMv8-M Security Extensions\");\n-\n-  /* We don't clear D16-D31 VFP registers for cmse_nonsecure_call functions\n-     and ARMv8-M Baseline and Mainline do not allow such configuration.  */\n-  if (use_cmse && LAST_VFP_REGNUM > LAST_LO_VFP_REGNUM)\n-    error (\"ARMv8-M Security Extensions incompatible with selected FPU\");\n-\n   /* Disable scheduling fusion by default if it's not armv7 processor\n      or doesn't prefer ldrd/strd.  */\n   if (flag_schedule_fusion == 2\n@@ -3686,6 +3557,7 @@ arm_option_override (void)\n   /* Need to remember initial options before they are overriden.  */\n   init_optimize = build_optimization_node (&global_options);\n \n+  arm_options_perform_arch_sanity_checks ();\n   arm_option_override_internal (&global_options, &global_options_set);\n   arm_option_check_internal (&global_options);\n   arm_option_params_internal ();\n@@ -3701,6 +3573,151 @@ arm_option_override (void)\n   thumb_flipper = TARGET_THUMB;\n }\n \n+\n+/* Reconfigure global status flags from the active_target.isa.  */\n+void\n+arm_option_reconfigure_globals (void)\n+{\n+  sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", arm_active_target.arch_pp_name);\n+  arm_base_arch = arm_active_target.base_arch;\n+\n+  /* Initialize boolean versions of the architectural flags, for use\n+     in the arm.md file.  */\n+  arm_arch3m = bitmap_bit_p (arm_active_target.isa, isa_bit_armv3m);\n+  arm_arch4 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv4);\n+  arm_arch4t = arm_arch4 && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n+  arm_arch5 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv5);\n+  arm_arch5e = bitmap_bit_p (arm_active_target.isa, isa_bit_armv5e);\n+  arm_arch5te = arm_arch5e\n+    && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n+  arm_arch6 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv6);\n+  arm_arch6k = bitmap_bit_p (arm_active_target.isa, isa_bit_armv6k);\n+  arm_arch_notm = bitmap_bit_p (arm_active_target.isa, isa_bit_notm);\n+  arm_arch6m = arm_arch6 && !arm_arch_notm;\n+  arm_arch7 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv7);\n+  arm_arch7em = bitmap_bit_p (arm_active_target.isa, isa_bit_armv7em);\n+  arm_arch8 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8);\n+  arm_arch8_1 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_1);\n+  arm_arch8_2 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_2);\n+  arm_arch_thumb1 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n+  arm_arch_thumb2 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb2);\n+  arm_arch_xscale = bitmap_bit_p (arm_active_target.isa, isa_bit_xscale);\n+  arm_arch_iwmmxt = bitmap_bit_p (arm_active_target.isa, isa_bit_iwmmxt);\n+  arm_arch_iwmmxt2 = bitmap_bit_p (arm_active_target.isa, isa_bit_iwmmxt2);\n+  arm_arch_thumb_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_tdiv);\n+  arm_arch_arm_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_adiv);\n+  arm_arch_crc = bitmap_bit_p (arm_active_target.isa, isa_bit_crc32);\n+  arm_arch_cmse = bitmap_bit_p (arm_active_target.isa, isa_bit_cmse);\n+  arm_fp16_inst = bitmap_bit_p (arm_active_target.isa, isa_bit_fp16);\n+  arm_arch_lpae = bitmap_bit_p (arm_active_target.isa, isa_bit_lpae);\n+  if (arm_fp16_inst)\n+    {\n+      if (arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n+\terror (\"selected fp16 options are incompatible\");\n+      arm_fp16_format = ARM_FP16_FORMAT_IEEE;\n+    }\n+\n+  /* And finally, set up some quirks.  */\n+  arm_arch_no_volatile_ce\n+    = bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_volatile_ce);\n+  arm_arch6kz = arm_arch6k && bitmap_bit_p (arm_active_target.isa,\n+\t\t\t\t\t    isa_bit_quirk_armv6kz);\n+\n+  /* Use the cp15 method if it is available.  */\n+  if (target_thread_pointer == TP_AUTO)\n+    {\n+      if (arm_arch6k && !TARGET_THUMB1)\n+\ttarget_thread_pointer = TP_CP15;\n+      else\n+\ttarget_thread_pointer = TP_SOFT;\n+    }\n+}\n+\n+/* Perform some validation between the desired architecture and the rest of the\n+   options.  */\n+void\n+arm_options_perform_arch_sanity_checks (void)\n+{\n+  /* V5 code we generate is completely interworking capable, so we turn off\n+     TARGET_INTERWORK here to avoid many tests later on.  */\n+\n+  /* XXX However, we must pass the right pre-processor defines to CPP\n+     or GLD can get confused.  This is a hack.  */\n+  if (TARGET_INTERWORK)\n+    arm_cpp_interwork = 1;\n+\n+  if (arm_arch5)\n+    target_flags &= ~MASK_INTERWORK;\n+\n+  if (TARGET_IWMMXT && !ARM_DOUBLEWORD_ALIGN)\n+    error (\"iwmmxt requires an AAPCS compatible ABI for proper operation\");\n+\n+  if (TARGET_IWMMXT_ABI && !TARGET_IWMMXT)\n+    error (\"iwmmxt abi requires an iwmmxt capable cpu\");\n+\n+  /* BPABI targets use linker tricks to allow interworking on cores\n+     without thumb support.  */\n+  if (TARGET_INTERWORK\n+      && !TARGET_BPABI\n+      && !bitmap_bit_p (arm_active_target.isa, isa_bit_thumb))\n+    {\n+      warning (0, \"target CPU does not support interworking\" );\n+      target_flags &= ~MASK_INTERWORK;\n+    }\n+\n+  /* If soft-float is specified then don't use FPU.  */\n+  if (TARGET_SOFT_FLOAT)\n+    arm_fpu_attr = FPU_NONE;\n+  else\n+    arm_fpu_attr = FPU_VFP;\n+\n+  if (TARGET_AAPCS_BASED)\n+    {\n+      if (TARGET_CALLER_INTERWORKING)\n+\terror (\"AAPCS does not support -mcaller-super-interworking\");\n+      else\n+\tif (TARGET_CALLEE_INTERWORKING)\n+\t  error (\"AAPCS does not support -mcallee-super-interworking\");\n+    }\n+\n+  /* __fp16 support currently assumes the core has ldrh.  */\n+  if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)\n+    sorry (\"__fp16 and no ldrh\");\n+\n+  if (use_cmse && !arm_arch_cmse)\n+    error (\"target CPU does not support ARMv8-M Security Extensions\");\n+\n+  /* We don't clear D16-D31 VFP registers for cmse_nonsecure_call functions\n+     and ARMv8-M Baseline and Mainline do not allow such configuration.  */\n+  if (use_cmse && LAST_VFP_REGNUM > LAST_LO_VFP_REGNUM)\n+    error (\"ARMv8-M Security Extensions incompatible with selected FPU\");\n+\n+\n+  if (TARGET_AAPCS_BASED)\n+    {\n+      if (arm_abi == ARM_ABI_IWMMXT)\n+\tarm_pcs_default = ARM_PCS_AAPCS_IWMMXT;\n+      else if (TARGET_HARD_FLOAT_ABI)\n+\t{\n+\t  arm_pcs_default = ARM_PCS_AAPCS_VFP;\n+\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv2))\n+\t    error (\"-mfloat-abi=hard: selected processor lacks an FPU\");\n+\t}\n+      else\n+\tarm_pcs_default = ARM_PCS_AAPCS;\n+    }\n+  else\n+    {\n+      if (arm_float_abi == ARM_FLOAT_ABI_HARD)\n+\tsorry (\"-mfloat-abi=hard and VFP\");\n+\n+      if (arm_abi == ARM_ABI_APCS)\n+\tarm_pcs_default = ARM_PCS_APCS;\n+      else\n+\tarm_pcs_default = ARM_PCS_ATPCS;\n+    }\n+}\n+\n static void\n arm_add_gc_roots (void)\n {"}]}