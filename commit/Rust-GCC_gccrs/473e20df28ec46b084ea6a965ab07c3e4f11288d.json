{"sha": "473e20df28ec46b084ea6a965ab07c3e4f11288d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczZTIwZGYyOGVjNDZiMDg0ZWE2YTk2NWFiMDdjM2U0ZjExMjg4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-23T08:10:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-23T08:10:49Z"}, "message": "[multiple changes]\n\n2012-07-23  Vincent Celier  <celier@adacore.com>\n\n\t* g-spitbo.adb (Substr (String)): Return full string and do not\n\traise exception when Start is 1 and Len is exactly the length\n\tof the string parameter.\n\t* g-spitbo.ads: Fix spelling error in the name of exception\n\tIndex_Error.\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par.adb: new subprogram Get_Aspect_Specifications.\n\t* par-ch6.adb (P_Subprogram): handle subprogram bodies with aspect\n\tspecifications.\n\t* par-ch13.adb (Get_Aspect_Specifications): extracted from\n\tP_Aspect_Specifications. Collect aspect specifications in some\n\tlegal context, but do not attach them to any declaration. Used\n\twhen parsing subprogram declarations or bodies that include\n\taspect specifications.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): If aspects are\n\tpresent, analyze them, or reject them if the subprogram as a\n\tprevious spec.\n\n2012-07-23  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* gnat_ugn.texi: Omit section on other platforms/runtimes support\n\tin gnattest for vms version.\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tHandle properly aspects that can be specified on a subprogram\n\tbody: CPU, Priority, and Interrupt_Priority.\n\n2012-07-23  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.ads: Switch definition of Constant_Reference_Type\n\tand Empty_List.\n\n2012-07-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb (Process_Decisions.Output_Header): For the guard\n\ton an alternative in a SELECT statement, use the First_Sloc\n\tof the guard expression (not its topmost sloc) as the decision\n\tlocation, because this is what is referenced by dominance markers.\n\n2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Requires_Hooking): Examine the original expression\n\tof an object declaration node because a function call that\n\treturns on the secondary stack may have been rewritten into\n\tsomething else.\n\n2012-07-23  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension_Has_Etype): For identifier, propagate\n\tdimension when entity is a non-dimensionless constant.\n\t(Analyze_Dimension_Object_Declaration): Propagate\n\tdimension from the expression to the entity when type is a\n\tdimensioned type and object is a constant.\n\n2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Old): if the prefix\n\tis not an entity name, expand at once so that code generated by\n\tthe expansion of the prefix is not generated before the constant\n\tthat captures the old value is properly inserted and analyzed.\n\n2012-07-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch9.adb (Ensure_Statement_Present): Mark generated NULL\n\tstatement as Comes_From_Source so that GIGI does not eliminate it.\n\nFrom-SVN: r189773", "tree": {"sha": "5d36d9c533d985f4983be828c3fca8d2fc01639f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d36d9c533d985f4983be828c3fca8d2fc01639f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473e20df28ec46b084ea6a965ab07c3e4f11288d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473e20df28ec46b084ea6a965ab07c3e4f11288d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473e20df28ec46b084ea6a965ab07c3e4f11288d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473e20df28ec46b084ea6a965ab07c3e4f11288d/comments", "author": null, "committer": null, "parents": [{"sha": "219d9cc7f963eff43f67b2a8df11190c5c41610d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/219d9cc7f963eff43f67b2a8df11190c5c41610d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/219d9cc7f963eff43f67b2a8df11190c5c41610d"}], "stats": {"total": 744, "additions": 482, "deletions": 262}, "files": [{"sha": "eda6cbb64ecde4aeb79ebcd2b4d9dc6de8e0abaa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -1,3 +1,75 @@\n+2012-07-23  Vincent Celier  <celier@adacore.com>\n+\n+\t* g-spitbo.adb (Substr (String)): Return full string and do not\n+\traise exception when Start is 1 and Len is exactly the length\n+\tof the string parameter.\n+\t* g-spitbo.ads: Fix spelling error in the name of exception\n+\tIndex_Error.\n+\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par.adb: new subprogram Get_Aspect_Specifications.\n+\t* par-ch6.adb (P_Subprogram): handle subprogram bodies with aspect\n+\tspecifications.\n+\t* par-ch13.adb (Get_Aspect_Specifications): extracted from\n+\tP_Aspect_Specifications. Collect aspect specifications in some\n+\tlegal context, but do not attach them to any declaration. Used\n+\twhen parsing subprogram declarations or bodies that include\n+\taspect specifications.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): If aspects are\n+\tpresent, analyze them, or reject them if the subprogram as a\n+\tprevious spec.\n+\n+2012-07-23  Vasiliy Fofanov  <fofanov@adacore.com>\n+\n+\t* gnat_ugn.texi: Omit section on other platforms/runtimes support\n+\tin gnattest for vms version.\n+\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tHandle properly aspects that can be specified on a subprogram\n+\tbody: CPU, Priority, and Interrupt_Priority.\n+\n+2012-07-23  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.ads: Switch definition of Constant_Reference_Type\n+\tand Empty_List.\n+\n+2012-07-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb (Process_Decisions.Output_Header): For the guard\n+\ton an alternative in a SELECT statement, use the First_Sloc\n+\tof the guard expression (not its topmost sloc) as the decision\n+\tlocation, because this is what is referenced by dominance markers.\n+\n+2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Requires_Hooking): Examine the original expression\n+\tof an object declaration node because a function call that\n+\treturns on the secondary stack may have been rewritten into\n+\tsomething else.\n+\n+2012-07-23  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension_Has_Etype): For identifier, propagate\n+\tdimension when entity is a non-dimensionless constant.\n+\t(Analyze_Dimension_Object_Declaration): Propagate\n+\tdimension from the expression to the entity when type is a\n+\tdimensioned type and object is a constant.\n+\n+2012-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Old): if the prefix\n+\tis not an entity name, expand at once so that code generated by\n+\tthe expansion of the prefix is not generated before the constant\n+\tthat captures the old value is properly inserted and analyzed.\n+\n+2012-07-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch9.adb (Ensure_Statement_Present): Mark generated NULL\n+\tstatement as Comes_From_Source so that GIGI does not eliminate it.\n+\n 2012-07-23  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch12.adb (Insert_Freeze_Node_For_Instance): Inst is now"}, {"sha": "67ff3af8f4826ef070e950d5fdb368540874a5cd", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -307,6 +307,9 @@ private\n       Node : Count_Type := 0;\n    end record;\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is null record;\n+\n    procedure Read\n      (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor);\n@@ -323,7 +326,4 @@ private\n \n    No_Element : constant Cursor := (Node => 0);\n \n-   type Constant_Reference_Type\n-      (Element : not null access constant Element_Type) is null record;\n-\n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "6483c7e339d67e4bba298af741a7462ea1e433a1", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -4369,12 +4369,16 @@ package body Exp_Ch7 is\n          function Requires_Hooking return Boolean is\n          begin\n             --  The context is either a procedure or function call or an object\n-            --  declaration initialized by a function call. In all these cases,\n-            --  the calls might raise an exception.\n+            --  declaration initialized by a function call. Note that in the\n+            --  latter case, a function call that returns on the secondary\n+            --  stack is usually rewritten into something else. Its proper\n+            --  detection requires examination of the original initialization\n+            --  expression.\n \n             return Nkind (N) in N_Subprogram_Call\n-               or else (Nkind (N) = N_Object_Declaration\n-                         and then Nkind (Expression (N)) = N_Function_Call);\n+              or else (Nkind (N) = N_Object_Declaration\n+                         and then Nkind (Original_Node (Expression (N))) =\n+                                    N_Function_Call);\n          end Requires_Hooking;\n \n          --  Local variables"}, {"sha": "29306043dcb0239e47cabbede21240beeb5e373a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -5484,11 +5484,19 @@ package body Exp_Ch9 is\n    ------------------------------\n \n    procedure Ensure_Statement_Present (Loc : Source_Ptr; Alt : Node_Id) is\n+      Stmt : Node_Id;\n    begin\n       if Opt.Suppress_Control_Flow_Optimizations\n         and then Is_Empty_List (Statements (Alt))\n       then\n-         Set_Statements (Alt, New_List (Make_Null_Statement (Loc)));\n+         Stmt := Make_Null_Statement (Loc);\n+\n+         --  Mark NULL statement as coming from source so that it is not\n+         --  eliminated by GIGI.\n+\n+         Set_Comes_From_Source (Stmt, True);\n+\n+         Set_Statements (Alt, New_List (Stmt));\n       end if;\n    end Ensure_Statement_Present;\n "}, {"sha": "22677149ee1bf035d5ee918902b577dbdbd03262", "filename": "gcc/ada/g-spitbo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fg-spitbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fg-spitbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spitbo.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2010, AdaCore                     --\n+--                     Copyright (C) 1998-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -305,7 +305,7 @@ package body GNAT.Spitbol is\n    begin\n       if Start > Str'Length then\n          raise Index_Error;\n-      elsif Start + Len > Str'Length then\n+      elsif Start + Len - 1 > Str'Length then\n          raise Length_Error;\n       else\n          return"}, {"sha": "e97bb62d03388caea258227fb542e28bd44868df", "filename": "gcc/ada/g-spitbo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fg-spitbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fg-spitbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spitbo.ads?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1997-2010, AdaCore                     --\n+--                     Copyright (C) 1997-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -180,7 +180,7 @@ package GNAT.Spitbol is\n    --  Returns the substring starting at the given character position (which\n    --  is always counted from the start of the string, regardless of bounds,\n    --  e.g. 2 means starting with the second character of the string), and\n-   --  with the length (Len) given. Indexing_Error is raised if the starting\n+   --  with the length (Len) given. Index_Error is raised if the starting\n    --  position is out of range, and Length_Error is raised if Len is too long.\n \n    function Trim (Str : VString) return VString;"}, {"sha": "e440ed517ed47780f033a565038f57903901712a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -487,7 +487,9 @@ Creating Unit Tests Using gnattest\n * Tagged Types Substitutability Testing::\n * Testing with Contracts::\n * Additional Tests::\n+@ifclear vms\n * Support for other platforms/run-times::\n+@end ifclear\n * Current Limitations::\n \n Other Utility Programs\n@@ -18107,7 +18109,9 @@ is installed at its default location.\n * Tagged Types Substitutability Testing::\n * Testing with Contracts::\n * Additional Tests::\n+@ifclear vms\n * Support for other platforms/run-times::\n+@end ifclear\n * Current Limitations::\n @end menu\n \n@@ -18621,6 +18625,7 @@ gnatmake -Pmixing/test_driver.gpr\n mixing/test_runner\n @end smallexample\n \n+@ifclear vms\n @node Support for other platforms/run-times\n @section Support for other platforms/run-times\n \n@@ -18641,6 +18646,7 @@ the ZFP run-time library:\n @smallexample\n powerpc-elf-gnattest -Psimple.gpr -XPLATFORM=powerpc-elf -XRUNTIME=zfp\n @end smallexample\n+@end ifclear\n \n @node Current Limitations\n @section Current Limitations"}, {"sha": "2a257f5d7dee61b7efd58ff2928f0aac16ace8cc", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 246, "deletions": 226, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -132,6 +132,251 @@ package body Ch13 is\n       return Result;\n    end Aspect_Specifications_Present;\n \n+   -------------------------------\n+   -- Get_Aspect_Specifications --\n+   -------------------------------\n+\n+   function Get_Aspect_Specifications\n+     (Semicolon : Boolean := True) return List_Id\n+   is\n+      Aspects : List_Id;\n+      Aspect  : Node_Id;\n+      A_Id    : Aspect_Id;\n+      OK      : Boolean;\n+\n+   begin\n+      Aspects := Empty_List;\n+\n+      --  Check if aspect specification present\n+\n+      if not Aspect_Specifications_Present then\n+         if Semicolon then\n+            TF_Semicolon;\n+         end if;\n+\n+         return Aspects;\n+      end if;\n+\n+      Scan; -- past WITH\n+      Aspects := Empty_List;\n+\n+      loop\n+         OK := True;\n+\n+         if Token /= Tok_Identifier then\n+            Error_Msg_SC (\"aspect identifier expected\");\n+\n+            if Semicolon then\n+               Resync_Past_Semicolon;\n+            end if;\n+\n+            return Aspects;\n+         end if;\n+\n+         --  We have an identifier (which should be an aspect identifier)\n+\n+         A_Id := Get_Aspect_Id (Token_Name);\n+         Aspect :=\n+           Make_Aspect_Specification (Token_Ptr,\n+             Identifier => Token_Node);\n+\n+         --  No valid aspect identifier present\n+\n+         if A_Id = No_Aspect then\n+            Error_Msg_SC (\"aspect identifier expected\");\n+\n+            --  Check bad spelling\n+\n+            for J in Aspect_Id loop\n+               if Is_Bad_Spelling_Of (Token_Name, Aspect_Names (J)) then\n+                  Error_Msg_Name_1 := Aspect_Names (J);\n+                  Error_Msg_SC -- CODEFIX\n+                    (\"\\possible misspelling of%\");\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            Scan; -- past incorrect identifier\n+\n+            if Token = Tok_Apostrophe then\n+               Scan; -- past '\n+               Scan; -- past presumably CLASS\n+            end if;\n+\n+            if Token = Tok_Arrow then\n+               Scan; -- Past arrow\n+               Set_Expression (Aspect, P_Expression);\n+               OK := False;\n+\n+            elsif Token = Tok_Comma then\n+               OK := False;\n+\n+            else\n+               if Semicolon then\n+                  Resync_Past_Semicolon;\n+               end if;\n+\n+               return Aspects;\n+            end if;\n+\n+         --  OK aspect scanned\n+\n+         else\n+            Scan; -- past identifier\n+\n+            --  Check for 'Class present\n+\n+            if Token = Tok_Apostrophe then\n+               if not Class_Aspect_OK (A_Id) then\n+                  Error_Msg_Node_1 := Identifier (Aspect);\n+                  Error_Msg_SC (\"aspect& does not permit attribute here\");\n+                  Scan; -- past apostrophe\n+                  Scan; -- past presumed CLASS\n+                  OK := False;\n+\n+               else\n+                  Scan; -- past apostrophe\n+\n+                  if Token /= Tok_Identifier\n+                    or else Token_Name /= Name_Class\n+                  then\n+                     Error_Msg_SC (\"Class attribute expected here\");\n+                     OK := False;\n+\n+                     if Token = Tok_Identifier then\n+                        Scan; -- past identifier not CLASS\n+                     end if;\n+\n+                  else\n+                     Scan; -- past CLASS\n+                     Set_Class_Present (Aspect);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            --  Test case of missing aspect definition\n+\n+            if Token = Tok_Comma\n+              or else Token = Tok_Semicolon\n+            then\n+               if Aspect_Argument (A_Id) /= Optional then\n+                  Error_Msg_Node_1 := Identifier (Aspect);\n+                  Error_Msg_AP (\"aspect& requires an aspect definition\");\n+                  OK := False;\n+               end if;\n+\n+            elsif not Semicolon and then Token /= Tok_Arrow then\n+               if Aspect_Argument (A_Id) /= Optional then\n+\n+                  --  The name or expression may be there, but the arrow is\n+                  --  missing. Skip to the end of the declaration.\n+\n+                  T_Arrow;\n+                  Resync_To_Semicolon;\n+               end if;\n+\n+            --  Here we have an aspect definition\n+\n+            else\n+               if Token = Tok_Arrow then\n+                  Scan; -- past arrow\n+               else\n+                  T_Arrow;\n+                  OK := False;\n+               end if;\n+\n+               if Aspect_Argument (A_Id) = Name then\n+                  Set_Expression (Aspect, P_Name);\n+               else\n+                  Set_Expression (Aspect, P_Expression);\n+               end if;\n+            end if;\n+\n+            --  If OK clause scanned, add it to the list\n+\n+            if OK then\n+               Append (Aspect, Aspects);\n+            end if;\n+\n+            if Token = Tok_Comma then\n+               Scan; -- past comma\n+               goto Continue;\n+\n+            --  Recognize the case where a comma is missing between two\n+            --  aspects, issue an error and proceed with next aspect.\n+\n+            elsif Token = Tok_Identifier\n+              and then Get_Aspect_Id (Token_Name) /= No_Aspect\n+            then\n+               declare\n+                  Scan_State : Saved_Scan_State;\n+\n+               begin\n+                  Save_Scan_State (Scan_State);\n+                  Scan; -- past identifier\n+\n+                  if Token = Tok_Arrow then\n+                     Restore_Scan_State (Scan_State);\n+                     Error_Msg_AP -- CODEFIX\n+                       (\"|missing \"\",\"\"\");\n+                     goto Continue;\n+\n+                  else\n+                     Restore_Scan_State (Scan_State);\n+                  end if;\n+               end;\n+\n+            --  Recognize the case where a semicolon was mistyped for a comma\n+            --  between two aspects, issue an error and proceed with next\n+            --  aspect.\n+\n+            elsif Token = Tok_Semicolon then\n+               declare\n+                  Scan_State : Saved_Scan_State;\n+\n+               begin\n+                  Save_Scan_State (Scan_State);\n+                  Scan; -- past semicolon\n+\n+                  if Token = Tok_Identifier\n+                    and then Get_Aspect_Id (Token_Name) /= No_Aspect\n+                  then\n+                     Scan; -- past identifier\n+\n+                     if Token = Tok_Arrow then\n+                        Restore_Scan_State (Scan_State);\n+                        Error_Msg_SC -- CODEFIX\n+                          (\"|\"\";\"\" should be \"\",\"\"\");\n+                        Scan; -- past semicolon\n+                        goto Continue;\n+\n+                     else\n+                        Restore_Scan_State (Scan_State);\n+                     end if;\n+\n+                  else\n+                     Restore_Scan_State (Scan_State);\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Must be terminator character\n+\n+            if Semicolon then\n+               T_Semicolon;\n+            end if;\n+\n+            exit;\n+\n+         <<Continue>>\n+            null;\n+         end if;\n+      end loop;\n+\n+      return Aspects;\n+\n+   end Get_Aspect_Specifications;\n+\n    --------------------------------------------\n    -- 13.1  Representation Clause (also I.7) --\n    --------------------------------------------\n@@ -397,244 +642,19 @@ package body Ch13 is\n       Semicolon : Boolean := True)\n    is\n       Aspects : List_Id;\n-      Aspect  : Node_Id;\n-      A_Id    : Aspect_Id;\n-      OK      : Boolean;\n       Ptr     : Source_Ptr;\n \n    begin\n-      --  Check if aspect specification present\n-\n-      if not Aspect_Specifications_Present then\n-         if Semicolon then\n-            TF_Semicolon;\n-         end if;\n-\n-         return;\n-      end if;\n \n       --  Aspect Specification is present\n \n       Ptr := Token_Ptr;\n-      Scan; -- past WITH\n \n       --  Here we have an aspect specification to scan, note that we don't\n       --  set the flag till later, because it may turn out that we have no\n       --  valid aspects in the list.\n \n-      Aspects := Empty_List;\n-      loop\n-         OK := True;\n-\n-         if Token /= Tok_Identifier then\n-            Error_Msg_SC (\"aspect identifier expected\");\n-\n-            if Semicolon then\n-               Resync_Past_Semicolon;\n-            end if;\n-\n-            return;\n-         end if;\n-\n-         --  We have an identifier (which should be an aspect identifier)\n-\n-         A_Id := Get_Aspect_Id (Token_Name);\n-         Aspect :=\n-           Make_Aspect_Specification (Token_Ptr,\n-             Identifier => Token_Node);\n-\n-         --  No valid aspect identifier present\n-\n-         if A_Id = No_Aspect then\n-            Error_Msg_SC (\"aspect identifier expected\");\n-\n-            --  Check bad spelling\n-\n-            for J in Aspect_Id loop\n-               if Is_Bad_Spelling_Of (Token_Name, Aspect_Names (J)) then\n-                  Error_Msg_Name_1 := Aspect_Names (J);\n-                  Error_Msg_SC -- CODEFIX\n-                    (\"\\possible misspelling of%\");\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            Scan; -- past incorrect identifier\n-\n-            if Token = Tok_Apostrophe then\n-               Scan; -- past '\n-               Scan; -- past presumably CLASS\n-            end if;\n-\n-            if Token = Tok_Arrow then\n-               Scan; -- Past arrow\n-               Set_Expression (Aspect, P_Expression);\n-               OK := False;\n-\n-            elsif Token = Tok_Comma then\n-               OK := False;\n-\n-            else\n-               if Semicolon then\n-                  Resync_Past_Semicolon;\n-               end if;\n-\n-               return;\n-            end if;\n-\n-         --  OK aspect scanned\n-\n-         else\n-            Scan; -- past identifier\n-\n-            --  Check for 'Class present\n-\n-            if Token = Tok_Apostrophe then\n-               if not Class_Aspect_OK (A_Id) then\n-                  Error_Msg_Node_1 := Identifier (Aspect);\n-                  Error_Msg_SC (\"aspect& does not permit attribute here\");\n-                  Scan; -- past apostrophe\n-                  Scan; -- past presumed CLASS\n-                  OK := False;\n-\n-               else\n-                  Scan; -- past apostrophe\n-\n-                  if Token /= Tok_Identifier\n-                    or else Token_Name /= Name_Class\n-                  then\n-                     Error_Msg_SC (\"Class attribute expected here\");\n-                     OK := False;\n-\n-                     if Token = Tok_Identifier then\n-                        Scan; -- past identifier not CLASS\n-                     end if;\n-\n-                  else\n-                     Scan; -- past CLASS\n-                     Set_Class_Present (Aspect);\n-                  end if;\n-               end if;\n-            end if;\n-\n-            --  Test case of missing aspect definition\n-\n-            if Token = Tok_Comma\n-              or else Token = Tok_Semicolon\n-            then\n-               if Aspect_Argument (A_Id) /= Optional then\n-                  Error_Msg_Node_1 := Identifier (Aspect);\n-                  Error_Msg_AP (\"aspect& requires an aspect definition\");\n-                  OK := False;\n-               end if;\n-\n-            elsif not Semicolon and then Token /= Tok_Arrow then\n-               if Aspect_Argument (A_Id) /= Optional then\n-\n-                  --  The name or expression may be there, but the arrow is\n-                  --  missing. Skip to the end of the declaration.\n-\n-                  T_Arrow;\n-                  Resync_To_Semicolon;\n-               end if;\n-\n-            --  Here we have an aspect definition\n-\n-            else\n-               if Token = Tok_Arrow then\n-                  Scan; -- past arrow\n-               else\n-                  T_Arrow;\n-                  OK := False;\n-               end if;\n-\n-               if Aspect_Argument (A_Id) = Name then\n-                  Set_Expression (Aspect, P_Name);\n-               else\n-                  Set_Expression (Aspect, P_Expression);\n-               end if;\n-            end if;\n-\n-            --  If OK clause scanned, add it to the list\n-\n-            if OK then\n-               Append (Aspect, Aspects);\n-            end if;\n-\n-            if Token = Tok_Comma then\n-               Scan; -- past comma\n-               goto Continue;\n-\n-            --  Recognize the case where a comma is missing between two\n-            --  aspects, issue an error and proceed with next aspect.\n-\n-            elsif Token = Tok_Identifier\n-              and then Get_Aspect_Id (Token_Name) /= No_Aspect\n-            then\n-               declare\n-                  Scan_State : Saved_Scan_State;\n-\n-               begin\n-                  Save_Scan_State (Scan_State);\n-                  Scan; -- past identifier\n-\n-                  if Token = Tok_Arrow then\n-                     Restore_Scan_State (Scan_State);\n-                     Error_Msg_AP -- CODEFIX\n-                       (\"|missing \"\",\"\"\");\n-                     goto Continue;\n-\n-                  else\n-                     Restore_Scan_State (Scan_State);\n-                  end if;\n-               end;\n-\n-            --  Recognize the case where a semicolon was mistyped for a comma\n-            --  between two aspects, issue an error and proceed with next\n-            --  aspect.\n-\n-            elsif Token = Tok_Semicolon then\n-               declare\n-                  Scan_State : Saved_Scan_State;\n-\n-               begin\n-                  Save_Scan_State (Scan_State);\n-                  Scan; -- past semicolon\n-\n-                  if Token = Tok_Identifier\n-                    and then Get_Aspect_Id (Token_Name) /= No_Aspect\n-                  then\n-                     Scan; -- past identifier\n-\n-                     if Token = Tok_Arrow then\n-                        Restore_Scan_State (Scan_State);\n-                        Error_Msg_SC -- CODEFIX\n-                          (\"|\"\";\"\" should be \"\",\"\"\");\n-                        Scan; -- past semicolon\n-                        goto Continue;\n-\n-                     else\n-                        Restore_Scan_State (Scan_State);\n-                     end if;\n-\n-                  else\n-                     Restore_Scan_State (Scan_State);\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Must be terminator character\n-\n-            if Semicolon then\n-               T_Semicolon;\n-            end if;\n-\n-            exit;\n-\n-         <<Continue>>\n-            null;\n-         end if;\n-      end loop;\n+      Aspects := Get_Aspect_Specifications (Semicolon);\n \n       --  Here if aspects present\n "}, {"sha": "a05e79b51d6ddc56998da77c7f221de2c757825d", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -154,6 +154,7 @@ package body Ch6 is\n    function P_Subprogram (Pf_Flags : Pf_Rec) return Node_Id is\n       Specification_Node : Node_Id;\n       Name_Node          : Node_Id;\n+      Aspects            : List_Id;\n       Fpart_List         : List_Id;\n       Fpart_Sloc         : Source_Ptr;\n       Result_Not_Null    : Boolean := False;\n@@ -186,6 +187,8 @@ package body Ch6 is\n       Scope.Table (Scope.Last).Ecol := Start_Column;\n       Scope.Table (Scope.Last).Lreq := False;\n \n+      Aspects := Empty_List;\n+\n       --  Ada 2005: Scan leading NOT OVERRIDING indicator\n \n       if Token = Tok_Not then\n@@ -810,6 +813,16 @@ package body Ch6 is\n                     New_Node (N_Subprogram_Body, Sloc (Specification_Node));\n                   Set_Specification (Body_Node, Specification_Node);\n \n+                  --  If aspects are present, the specification is parsed as\n+                  --  a subprogram declaration, and we jump here after seeing\n+                  --  the keyword IS. Attach asspects previously collected to\n+                  --  the body.\n+\n+                  if Is_Non_Empty_List (Aspects) then\n+                     Set_Parent (Aspects, Body_Node);\n+                     Set_Aspect_Specifications (Body_Node, Aspects);\n+                  end if;\n+\n                   --  In SPARK, a HIDE directive can be placed at the beginning\n                   --  of a subprogram implementation, thus hiding the\n                   --  subprogram body from SPARK tool-set. No violation of the\n@@ -841,7 +854,24 @@ package body Ch6 is\n          Decl_Node :=\n            New_Node (N_Subprogram_Declaration, Sloc (Specification_Node));\n          Set_Specification (Decl_Node, Specification_Node);\n-         P_Aspect_Specifications (Decl_Node);\n+         Aspects := Get_Aspect_Specifications (Semicolon => False);\n+\n+         --  Aspects may be present on a subprogram body. The source parsed\n+         --  so far is that of its specification, go parse the body and attach\n+         --  the collected aspects, if any, to the body.\n+\n+         if Token = Tok_Is then\n+            Scan;\n+            goto Subprogram_Body;\n+\n+         else\n+            if Is_Non_Empty_List (Aspects) then\n+               Set_Parent (Aspects, Decl_Node);\n+               Set_Aspect_Specifications (Decl_Node, Aspects);\n+            end if;\n+\n+            TF_Semicolon;\n+         end if;\n \n          --  If this is a context in which a subprogram body is permitted,\n          --  set active SIS entry in case (see section titled \"Handling"}, {"sha": "892aac86bfd2d8e0145ce7e9c33bb90f961e2007", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -876,6 +876,12 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  for aspects so it does not matter whether the aspect specifications\n       --  are terminated by semicolon or some other character.\n \n+      function Get_Aspect_Specifications\n+        (Semicolon : Boolean := True) return List_Id;\n+      --  Parse a list of aspects but do not attach them to a declaration node.\n+      --  Subsidiary to the following procedure. Used when parsing a subprogram\n+      --  specification that may be a declaration or a body.\n+\n       procedure P_Aspect_Specifications\n         (Decl      : Node_Id;\n          Semicolon : Boolean := True);"}, {"sha": "fd1d887284f3227330ac5d141288d2d5212a502e", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n+with Errout;   use Errout;\n with Lib;      use Lib;\n with Lib.Util; use Lib.Util;\n with Namet;    use Namet;\n@@ -495,13 +496,15 @@ package body Par_SCO is\n                --  levels (through the pragma argument association) to get to\n                --  the pragma node itself. For the guard on a select\n                --  alternative, we do not have access to the token location\n-               --  for the WHEN, so we use the sloc of the condition itself.\n+               --  for the WHEN, so we use the first sloc of the condition\n+               --  itself (note: we use First_Sloc, not Sloc, because this is\n+               --  what is referenced by dominance markers).\n \n                if Nkind_In (Parent (N), N_Accept_Alternative,\n                                         N_Delay_Alternative,\n                                         N_Terminate_Alternative)\n                then\n-                  Loc := Sloc (N);\n+                  Loc := First_Sloc (N);\n                else\n                   Loc := Sloc (Parent (Parent (N)));\n                end if;"}, {"sha": "e1abe5a048d98345ea311fc9e9d8c186e36d0652", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -4026,14 +4026,15 @@ package body Sem_Attr is\n          --  an entity in the enclosing subprogram. If it is a component of\n          --  a formal its expansion might generate actual subtypes that may\n          --  be referenced in an inner context, and which must be elaborated\n-         --  within the subprogram itself. As a result we create a\n-         --  declaration for it and insert it at the start of the enclosing\n-         --  subprogram. This is properly an expansion activity but it has\n-         --  to be performed now to prevent out-of-order issues.\n-\n-         if Nkind (P) = N_Selected_Component\n-           and then Has_Discriminants (Etype (Prefix (P)))\n-         then\n+         --  within the subprogram itself. If the prefix includes a function\n+         --  call it may involve finalization actions that should only be\n+         --  inserted when the attribute has been rewritten as a declarations.\n+         --  As a result, if the prefix is not a simple name we create a\n+         --  declaration for it now,  and insert it at the start of the\n+         --  enclosing subprogram. This is properly an expansion activity but\n+         --  it has to be performed now to prevent out-of-order issues.\n+\n+         if not Is_Entity_Name (P) then\n             P_Type := Base_Type (P_Type);\n             Set_Etype (N, P_Type);\n             Set_Etype (P, P_Type);"}, {"sha": "df61549e13754e8da5ded426b0678cce519acad4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -1150,17 +1150,14 @@ package body Sem_Ch13 is\n                     Aspect_Bit_Order            |\n                     Aspect_Component_Size       |\n                     Aspect_Constant_Indexing    |\n-                    Aspect_CPU                  |\n                     Aspect_Default_Iterator     |\n                     Aspect_Dispatching_Domain   |\n                     Aspect_External_Tag         |\n                     Aspect_Input                |\n-                    Aspect_Interrupt_Priority   |\n                     Aspect_Iterator_Element     |\n                     Aspect_Machine_Radix        |\n                     Aspect_Object_Size          |\n                     Aspect_Output               |\n-                    Aspect_Priority             |\n                     Aspect_Read                 |\n                     Aspect_Scalar_Storage_Order |\n                     Aspect_Size                 |\n@@ -1341,6 +1338,29 @@ package body Sem_Ch13 is\n                             Make_Identifier (Loc, P_Name));\n                   end;\n \n+               --  The following three aspects can be specified for a\n+               --  subprogram body, in which case we generate pragmas for them\n+               --  and insert them ahead of local declarations, rather than\n+               --  after the body.\n+\n+               when Aspect_CPU                |\n+                    Aspect_Interrupt_Priority |\n+                    Aspect_Priority           =>\n+                  if Nkind (N) = N_Subprogram_Body then\n+                     Aitem :=\n+                       Make_Pragma (Loc,\n+                         Pragma_Argument_Associations =>\n+                           New_List (Relocate_Node (Expr)),\n+                         Pragma_Identifier            =>\n+                           Make_Identifier (Sloc (Id), Chars (Id)));\n+                  else\n+                     Aitem :=\n+                       Make_Attribute_Definition_Clause (Loc,\n+                         Name       => Ent,\n+                         Chars      => Chars (Id),\n+                         Expression => Relocate_Node (Expr));\n+                  end if;\n+\n                when Aspect_Warnings =>\n \n                   --  Construct the pragma\n@@ -1725,7 +1745,8 @@ package body Sem_Ch13 is\n \n             --  In the context of a compilation unit, we directly put the\n             --  pragma in the Pragmas_After list of the\n-            --  N_Compilation_Unit_Aux node. No delay is required here.\n+            --  N_Compilation_Unit_Aux node (No delay is required here)\n+            --  except for aspects on a subprogram body (see below).\n \n             if Nkind (Parent (N)) = N_Compilation_Unit\n               and then (Present (Aitem) or else Is_Boolean_Aspect (Aspect))\n@@ -1757,11 +1778,25 @@ package body Sem_Ch13 is\n                      end if;\n                   end if;\n \n-                  if No (Pragmas_After (Aux)) then\n-                     Set_Pragmas_After (Aux, Empty_List);\n+                  --  If the aspect is on a subprogram body (relevant aspects\n+                  --  are Inline and Priority), add the pragma in front of\n+                  --  the declarations.\n+\n+                  if Nkind (N) = N_Subprogram_Body then\n+                     if No (Declarations (N)) then\n+                        Set_Declarations (N, New_List);\n+                     end if;\n+\n+                     Prepend (Aitem, Declarations (N));\n+\n+                  else\n+                     if No (Pragmas_After (Aux)) then\n+                        Set_Pragmas_After (Aux, Empty_List);\n+                     end if;\n+\n+                     Append (Aitem, Pragmas_After (Aux));\n                   end if;\n \n-                  Append (Aitem, Pragmas_After (Aux));\n                   goto Continue;\n                end;\n             end if;\n@@ -3243,10 +3278,11 @@ package body Sem_Ch13 is\n \n             if From_Aspect_Specification (N) then\n                if not (Is_Protected_Type (U_Ent)\n-                        or else Is_Task_Type (U_Ent))\n+                        or else Is_Task_Type (U_Ent)\n+                        or else Ekind (U_Ent) = E_Procedure)\n                then\n                   Error_Msg_N\n-                    (\"Priority can only be defined for task and protected\" &\n+                    (\"Priority can only be defined for task and protected \" &\n                      \"object\",\n                      Nam);\n "}, {"sha": "5f061616ee3e409743b6d2897469f23c75378553", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -2504,6 +2504,19 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n+      --  Ada 2012 aspects may appear in a subprogram body, but only if there\n+      --  is no previous spec.\n+\n+      if Has_Aspects (N) then\n+         if Present (Corresponding_Spec (N)) then\n+            Error_Msg_N\n+              (\"aspect specifications must appear in subprogram declaration\",\n+                N);\n+         else\n+            Analyze_Aspect_Specifications (N, Body_Id);\n+         end if;\n+      end if;\n+\n       --  Previously we scanned the body to look for nested subprograms, and\n       --  rejected an inline directive if nested subprograms were present,\n       --  because the back-end would generate conflicting symbols for the"}, {"sha": "3d0e1dd348d323d4fc78507b77d124ede6fb04e5", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473e20df28ec46b084ea6a965ab07c3e4f11288d/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=473e20df28ec46b084ea6a965ab07c3e4f11288d", "patch": "@@ -1617,6 +1617,14 @@ package body Sem_Dim is\n \n       if Exists (Dims_Of_Etyp) then\n          Set_Dimensions (N, Dims_Of_Etyp);\n+\n+      --  Propagation of the dimensions from the entity for identifier whose\n+      --  entity is a non-dimensionless consant.\n+\n+      elsif Nkind (N) = N_Identifier\n+        and then Exists (Dimensions_Of (Entity (N)))\n+      then\n+         Set_Dimensions (N, Dimensions_Of (Entity (N)));\n       end if;\n \n       --  Removal of dimensions in expression\n@@ -1692,15 +1700,28 @@ package body Sem_Dim is\n       if Present (Expr) then\n          Dim_Of_Expr := Dimensions_Of (Expr);\n \n-         --  case when expression is not a literal and when dimensions of the\n+         --  Case when expression is not a literal and when dimensions of the\n          --  expression and of the type mismatch\n \n          if not Nkind_In (Original_Node (Expr),\n                              N_Real_Literal,\n                              N_Integer_Literal)\n            and then Dim_Of_Expr /= Dim_Of_Etyp\n          then\n-            Error_Dim_Msg_For_Object_Declaration (N, Etyp, Expr);\n+            --  Propagate the dimension from the expression to the object\n+            --  entity when the object is a constant whose type is a\n+            --  dimensioned type.\n+\n+            if Constant_Present (N)\n+              and then not Exists (Dim_Of_Etyp)\n+            then\n+               Set_Dimensions (Id, Dim_Of_Expr);\n+\n+            --  Otherwise, issue an error message\n+\n+            else\n+               Error_Dim_Msg_For_Object_Declaration (N, Etyp, Expr);\n+            end if;\n          end if;\n \n          --  Removal of dimensions in expression"}]}