{"sha": "37d41553c0da489e399559baca2e3affaeda13c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdkNDE1NTNjMGRhNDg5ZTM5OTU1OWJhY2EyZTNhZmZhZWRhMTNjMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-01-07T00:46:28Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-01-07T00:46:28Z"}, "message": "Character.java (SIZE, [...]): New fields from Classpath.\n\n\t* java/lang/Character.java (SIZE, MAX_CACHE, charCache,\n\tMIN_SURROGATE, MAX_SURROGATE): New fields from Classpath.\n\t(MIN_HIGH_SURROGATE, MAX_HIGH_SURROGATE, MIN_LOW_SURROGATE,\n\tMAX_LOW_SURROGATE): Javadoc fixes.\n\t(valueOf, reverseBytes, isHighSurrogate, isLowSurrogate,\n\tisSurrogatePair, toCodePoint, codePointAt, codePointBefore): New\n\tmethods from Classpath.\n\t* java/lang/String.java (codePointAt, codePointBefore,\n\tcodePointCount, contains, replace): New methods from Classpath.\n\t(contentEquals): Declare.\n\t* java/lang/natString.cc (contentEquals): New method.\n\nFrom-SVN: r109445", "tree": {"sha": "81b09ce77cc017aa1cefb4f34cac3d128da8a7fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b09ce77cc017aa1cefb4f34cac3d128da8a7fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37d41553c0da489e399559baca2e3affaeda13c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d41553c0da489e399559baca2e3affaeda13c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37d41553c0da489e399559baca2e3affaeda13c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37d41553c0da489e399559baca2e3affaeda13c1/comments", "author": null, "committer": null, "parents": [{"sha": "2b15cf3b5076c3c460d710c013d186d3365bf516", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b15cf3b5076c3c460d710c013d186d3365bf516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b15cf3b5076c3c460d710c013d186d3365bf516"}], "stats": {"total": 434, "additions": 426, "deletions": 8}, "files": [{"sha": "a5c5c40c65469530c79e2688e06c9c776efe6a91", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=37d41553c0da489e399559baca2e3affaeda13c1", "patch": "@@ -1,3 +1,17 @@\n+2006-01-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/Character.java (SIZE, MAX_CACHE, charCache,\n+\tMIN_SURROGATE, MAX_SURROGATE): New fields from Classpath.\n+\t(MIN_HIGH_SURROGATE, MAX_HIGH_SURROGATE, MIN_LOW_SURROGATE,\n+\tMAX_LOW_SURROGATE): Javadoc fixes.\n+\t(valueOf, reverseBytes, isHighSurrogate, isLowSurrogate,\n+\tisSurrogatePair, toCodePoint, codePointAt, codePointBefore): New\n+\tmethods from Classpath.\n+\t* java/lang/String.java (codePointAt, codePointBefore,\n+\tcodePointCount, contains, replace): New methods from Classpath.\n+\t(contentEquals): Declare.\n+\t* java/lang/natString.cc (contentEquals): New method.\n+\n 2005-12-26  Anthony Green  <green@redhat.com>\n \n \t* gnu/java/nio/SocketChannelImpl.java (read): Compute the right amount"}, {"sha": "3cb73d0cbba67ca04e7e4b001f1b234159211583", "filename": "libjava/java/lang/Character.java", "status": "modified", "additions": 269, "deletions": 6, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2Fjava%2Flang%2FCharacter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2Fjava%2Flang%2FCharacter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCharacter.java?ref=37d41553c0da489e399559baca2e3affaeda13c1", "patch": "@@ -1,5 +1,5 @@\n /* java.lang.Character -- Wrapper class for char, and Unicode subsets\n-   Copyright (C) 1998, 1999, 2001, 2002, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -1039,6 +1039,18 @@ else if (ch > b.end)\n    */\n   public static final Class TYPE = VMClassLoader.getPrimitiveClass('C');\n \n+  /**\n+   * The number of bits needed to represent a <code>char</code>.\n+   * @since 1.5\n+   */\n+  public static final int SIZE = 16;\n+\n+  // This caches some Character values, and is used by boxing\n+  // conversions via valueOf().  We must cache at least 0..127;\n+  // this constant controls how much we actually cache.\n+  private static final int MAX_CACHE = 127;\n+  private static Character[] charCache = new Character[MAX_CACHE + 1];\n+\n   /**\n    * Lu = Letter, Uppercase (Informative).\n    *\n@@ -1434,33 +1446,47 @@ else if (ch > b.end)\n \n \n   /**\n-   * Minimum high surrrogate code in UTF-16 encoding.\n+   * Minimum high surrogate code in UTF-16 encoding.\n    *\n    * @since 1.5\n    */\n   public static final char MIN_HIGH_SURROGATE = '\\ud800';\n \n   /**\n-   * Maximum high surrrogate code in UTF-16 encoding.\n+   * Maximum high surrogate code in UTF-16 encoding.\n    *\n    * @since 1.5\n    */\n   public static final char MAX_HIGH_SURROGATE = '\\udbff';\n  \n   /**\n-   * Minimum low surrrogate code in UTF-16 encoding.\n+   * Minimum low surrogate code in UTF-16 encoding.\n    *\n    * @since 1.5\n    */\n   public static final char MIN_LOW_SURROGATE = '\\udc00';\n \n   /**\n-   * Maximum low surrrogate code in UTF-16 encoding.\n+   * Maximum low surrogate code in UTF-16 encoding.\n    *\n    * @since 1.5\n    */\n   public static final char MAX_LOW_SURROGATE = '\\udfff';\n \n+  /**\n+   * Minimum surrogate code in UTF-16 encoding.\n+   *\n+   * @since 1.5\n+   */\n+  public static final char MIN_SURROGATE = MIN_HIGH_SURROGATE;\n+\n+  /**\n+   * Maximum low surrogate code in UTF-16 encoding.\n+   *\n+   * @since 1.5\n+   */\n+  public static final char MAX_SURROGATE = MAX_LOW_SURROGATE;\n+\n   /**\n    * Grabs an attribute offset from the Unicode attribute database. The lower\n    * 5 bits are the character type, the next 2 bits are flags, and the top\n@@ -2212,6 +2238,37 @@ public int compareTo(Object o)\n     return compareTo((Character) o);\n   }\n \n+  /**\n+   * Returns an <code>Character</code> object wrapping the value.\n+   * In contrast to the <code>Character</code> constructor, this method\n+   * will cache some values.  It is used by boxing conversion.\n+   *\n+   * @param val the value to wrap\n+   * @return the <code>Character</code>\n+   * \n+   * @since 1.5\n+   */\n+  public static Character valueOf(char val)\n+  {\n+    if (val > MAX_CACHE)\n+      return new Character(val);\n+    synchronized (charCache)\n+      {\n+    if (charCache[val - MIN_VALUE] == null)\n+      charCache[val - MIN_VALUE] = new Character(val);\n+    return charCache[val - MIN_VALUE];\n+      }\n+  }\n+\n+  /**\n+   * Reverse the bytes in val.\n+   * @since 1.5\n+   */\n+  public static char reverseBytes(char val)\n+  {\n+    return (char) (((val >> 8) & 0xff) | ((val << 8) & 0xff00));\n+  }\n+\n   /**\n    * Converts a unicode code point to a UTF-16 representation of that\n    * code point.\n@@ -2280,7 +2337,7 @@ public static int toChars(int codePoint, char[] dst, int dstIndex)\n    * Return number of 16-bit characters required to represent the given\n    * code point.\n    *\n-   * @param codePoint a uncode code point\n+   * @param codePoint a unicode code point\n    *\n    * @return 2 if codePoint >= 0x10000, 1 otherwise.\n    *\n@@ -2325,4 +2382,210 @@ public static boolean isValidCodePoint(int codePoint)\n   {\n     return codePoint >= MIN_CODE_POINT && codePoint <= MAX_CODE_POINT;\n   }\n+\n+  /**\n+   * Return true if the given character is a high surrogate.\n+   * @param ch the character\n+   * @return true if the character is a high surrogate character\n+   *\n+   * @since 1.5\n+   */\n+  public static boolean isHighSurrogate(char ch)\n+  {\n+    return ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE;\n+  }\n+\n+  /**\n+   * Return true if the given character is a low surrogate.\n+   * @param ch the character\n+   * @return true if the character is a low surrogate character\n+   *\n+   * @since 1.5\n+   */\n+  public static boolean isLowSurrogate(char ch)\n+  {\n+    return ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE;\n+  }\n+\n+  /**\n+   * Return true if the given characters compose a surrogate pair.\n+   * This is true if the first character is a high surrogate and the\n+   * second character is a low surrogate.\n+   * @param ch1 the first character\n+   * @param ch2 the first character\n+   * @return true if the characters compose a surrogate pair\n+   *\n+   * @since 1.5\n+   */\n+  public static boolean isSurrogatePair(char ch1, char ch2)\n+  {\n+    return isHighSurrogate(ch1) && isLowSurrogate(ch2);\n+  }\n+\n+  /**\n+   * Given a valid surrogate pair, this returns the corresponding\n+   * code point.\n+   * @param high the high character of the pair\n+   * @param low the low character of the pair\n+   * @return the corresponding code point\n+   *\n+   * @since 1.5\n+   */\n+  public static int toCodePoint(char high, char low)\n+  {\n+    return ((high - MIN_HIGH_SURROGATE) << 10) + (low - MIN_LOW_SURROGATE);\n+  }\n+\n+  /**\n+   * Get the code point at the specified index in the CharSequence.\n+   * This is like CharSequence#charAt(int), but if the character is\n+   * the start of a surrogate pair, and there is a following\n+   * character, and this character completes the pair, then the\n+   * corresponding supplementary code point is returned.  Otherwise,\n+   * the character at the index is returned.\n+   *\n+   * @param sequence the CharSequence\n+   * @param index the index of the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public static int codePointAt(CharSequence sequence, int index)\n+  {\n+    int len = sequence.length();\n+    if (index < 0 || index >= len)\n+      throw new IndexOutOfBoundsException();\n+    char high = sequence.charAt(index);\n+    if (! isHighSurrogate(high) || ++index >= len)\n+      return high;\n+    char low = sequence.charAt(index);\n+    if (! isLowSurrogate(low))\n+      return high;\n+    return toCodePoint(high, low);\n+  }\n+\n+  /**\n+   * Get the code point at the specified index in the CharSequence.\n+   * If the character is the start of a surrogate pair, and there is a\n+   * following character, and this character completes the pair, then\n+   * the corresponding supplementary code point is returned.\n+   * Otherwise, the character at the index is returned.\n+   *\n+   * @param chars the character array in which to look\n+   * @param index the index of the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public static int codePointAt(char[] chars, int index)\n+  {\n+    return codePointAt(chars, index, chars.length);\n+  }\n+\n+  /**\n+   * Get the code point at the specified index in the CharSequence.\n+   * If the character is the start of a surrogate pair, and there is a\n+   * following character within the specified range, and this\n+   * character completes the pair, then the corresponding\n+   * supplementary code point is returned.  Otherwise, the character\n+   * at the index is returned.\n+   *\n+   * @param chars the character array in which to look\n+   * @param index the index of the codepoint to get, starting at 0\n+   * @param limit the limit past which characters should not be examined\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;=\n+   * limit, or if limit is negative or &gt;= the length of the array\n+   * @since 1.5\n+   */\n+  public static int codePointAt(char[] chars, int index, int limit)\n+  {\n+    if (index < 0 || index >= limit || limit < 0 || limit >= chars.length)\n+      throw new IndexOutOfBoundsException();\n+    char high = chars[index];\n+    if (! isHighSurrogate(high) || ++index >= limit)\n+      return high;\n+    char low = chars[index];\n+    if (! isLowSurrogate(low))\n+      return high;\n+    return toCodePoint(high, low);\n+  }\n+\n+  /**\n+   * Get the code point before the specified index.  This is like\n+   * #codePointAt(char[], int), but checks the characters at\n+   * <code>index-1</code> and <code>index-2</code> to see if they form\n+   * a supplementary code point.  If they do not, the character at\n+   * <code>index-1</code> is returned.\n+   *\n+   * @param chars the character array\n+   * @param index the index just past the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public static int codePointBefore(char[] chars, int index)\n+  {\n+    return codePointBefore(chars, index, 1);\n+  }\n+\n+  /**\n+   * Get the code point before the specified index.  This is like\n+   * #codePointAt(char[], int), but checks the characters at\n+   * <code>index-1</code> and <code>index-2</code> to see if they form\n+   * a supplementary code point.  If they do not, the character at\n+   * <code>index-1</code> is returned.  The start parameter is used to\n+   * limit the range of the array which may be examined.\n+   *\n+   * @param chars the character array\n+   * @param index the index just past the codepoint to get, starting at 0\n+   * @param start the index before which characters should not be examined\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is &gt; start or &gt;\n+   * the length of the array, or if limit is negative or &gt;= the\n+   * length of the array\n+   * @since 1.5\n+   */\n+  public static int codePointBefore(char[] chars, int index, int start)\n+  {\n+    if (index < start || index > chars.length\n+\t|| start < 0 || start >= chars.length)\n+      throw new IndexOutOfBoundsException();\n+    --index;\n+    char low = chars[index];\n+    if (! isLowSurrogate(low) || --index < start)\n+      return low;\n+    char high = chars[index];\n+    if (! isHighSurrogate(high))\n+      return low;\n+    return toCodePoint(high, low);\n+  }\n+\n+  /**\n+   * Get the code point before the specified index.  This is like\n+   * #codePointAt(CharSequence, int), but checks the characters at\n+   * <code>index-1</code> and <code>index-2</code> to see if they form\n+   * a supplementary code point.  If they do not, the character at\n+   * <code>index-1</code> is returned.\n+   *\n+   * @param sequence the CharSequence\n+   * @param index the index just past the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public static int codePointBefore(CharSequence sequence, int index)\n+  {\n+    int len = sequence.length();\n+    if (index < 1 || index > len)\n+      throw new IndexOutOfBoundsException();\n+    --index;\n+    char low = sequence.charAt(index);\n+    if (! isLowSurrogate(low) || --index < 0)\n+      return low;\n+    char high = sequence.charAt(index);\n+    if (! isHighSurrogate(high))\n+      return low;\n+    return toCodePoint(high, low);\n+  }\n } // class Character"}, {"sha": "3e0bfbee89d27e725c95397a3288a016a6723136", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=37d41553c0da489e399559baca2e3affaeda13c1", "patch": "@@ -1,5 +1,5 @@\n /* String.java -- immutable character sequences; the object of string literals\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -454,6 +454,40 @@ public int length()\n    */\n   public native char charAt(int index);\n \n+  /**\n+   * Get the code point at the specified index.  This is like #charAt(int),\n+   * but if the character is the start of a surrogate pair, and the\n+   * following character completes the pair, then the corresponding\n+   * supplementary code point is returned.\n+   * @param index the index of the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   * @since 1.5\n+   */\n+  public synchronized int codePointAt(int index)\n+  {\n+    // Use the CharSequence overload as we get better range checking\n+    // this way.\n+    return Character.codePointAt(this, index);\n+  }\n+\n+  /**\n+   * Get the code point before the specified index.  This is like\n+   * #codePointAt(int), but checks the characters at <code>index-1</code> and\n+   * <code>index-2</code> to see if they form a supplementary code point.\n+   * @param index the index just past the codepoint to get, starting at 0\n+   * @return the codepoint at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @since 1.5\n+   */\n+  public synchronized int codePointBefore(int index)\n+  {\n+    // Use the CharSequence overload as we get better range checking\n+    // this way.\n+    return Character.codePointBefore(this, index);\n+  }\n+\n   /**\n    * Copies characters from this String starting at a specified start index,\n    * ending at a specified stop index, to a character array starting at\n@@ -565,6 +599,18 @@ public byte[] getBytes()\n    */\n   public native boolean contentEquals(StringBuffer buffer);\n \n+  /**\n+   * Compares the given CharSequence to this String. This is true if\n+   * the CharSequence has the same content as this String at this\n+   * moment.\n+   *\n+   * @param seq the CharSequence to compare to\n+   * @return true if CharSequence has the same character sequence\n+   * @throws NullPointerException if the given CharSequence is null\n+   * @since 1.5\n+   */\n+  public native boolean contentEquals(CharSequence seq);\n+\n   /**\n    * Compares a String to this String, ignoring case. This does not handle\n    * multi-character capitalization exceptions; instead the comparison is\n@@ -1259,6 +1305,88 @@ public static String valueOf(double d)\n    */\n   public native String intern();\n \n+  /**\n+   * Return the number of code points between two indices in the\n+   * <code>String</code>.  An unpaired surrogate counts as a\n+   * code point for this purpose.  Characters outside the indicated\n+   * range are not examined, even if the range ends in the middle of a\n+   * surrogate pair.\n+   *\n+   * @param start the starting index\n+   * @param end one past the ending index\n+   * @return the number of code points\n+   * @since 1.5\n+   */\n+  public synchronized int codePointCount(int start, int end)\n+  {\n+    if (start < 0 || end >= count || start > end)\n+      throw new StringIndexOutOfBoundsException();\n+\n+    int count = 0;\n+    while (start < end)\n+      {\n+\tchar base = charAt(start);\n+\tif (base < Character.MIN_HIGH_SURROGATE\n+\t    || base > Character.MAX_HIGH_SURROGATE\n+\t    || start == end\n+\t    || start == count\n+\t    || charAt(start + 1) < Character.MIN_LOW_SURROGATE\n+\t    || charAt(start + 1) > Character.MAX_LOW_SURROGATE)\n+\t  {\n+\t    // Nothing.\n+\t  }\n+\telse\n+\t  {\n+\t    // Surrogate pair.\n+\t    ++start;\n+\t  }\n+\t++start;\n+\t++count;\n+      }\n+    return count;\n+  }\n+\n+  /**\n+   * Returns true iff this String contains the sequence of Characters\n+   * described in s.\n+   * @param s the CharSequence\n+   * @return true iff this String contains s\n+   *\n+   * @since 1.5\n+   */\n+  public boolean contains (CharSequence s)\n+  {\n+    return this.indexOf(s.toString()) != -1;\n+  }\n+\n+  /**\n+   * Returns a string that is this string with all instances of the sequence\n+   * represented by <code>target</code> replaced by the sequence in \n+   * <code>replacement</code>.\n+   * @param target the sequence to be replaced\n+   * @param replacement the sequence used as the replacement\n+   * @return the string constructed as above\n+   */\n+  public String replace (CharSequence target, CharSequence replacement)\n+  {\n+    String targetString = target.toString();\n+    String replaceString = replacement.toString();\n+    int targetLength = target.length();\n+    int replaceLength = replacement.length();\n+    \n+    int startPos = this.indexOf(targetString);\n+    StringBuilder result = new StringBuilder(this);    \n+    while (startPos != -1)\n+      {\n+        // Replace the target with the replacement\n+        result.replace(startPos, startPos + targetLength, replaceString);\n+\n+        // Search for a new occurrence of the target\n+        startPos = result.indexOf(targetString, startPos + replaceLength);\n+      }\n+    return result.toString();\n+  }\n+\n \n   private native void init(char[] chars, int offset, int count,\n \t\t\t   boolean dont_copy);"}, {"sha": "3f630812d5ef478db610f70ed568cbbbf68b4244", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37d41553c0da489e399559baca2e3affaeda13c1/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=37d41553c0da489e399559baca2e3affaeda13c1", "patch": "@@ -1,6 +1,6 @@\n // natString.cc - Implementation of java.lang.String native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -15,6 +15,7 @@ details.  */\n \n #include <gcj/cni.h>\n #include <java/lang/Character.h>\n+#include <java/lang/CharSequence.h>\n #include <java/lang/String.h>\n #include <java/lang/IndexOutOfBoundsException.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n@@ -564,6 +565,18 @@ java::lang::String::contentEquals(java::lang::StringBuffer* buffer)\n   return true;\n }\n \n+jboolean\n+java::lang::String::contentEquals(java::lang::CharSequence *seq)\n+{\n+  if (seq->length() != count)\n+    return false;\n+  jchar *value = JvGetStringChars(this);\n+  for (int i = 0; i < count; ++i)\n+    if (value[i] != seq->charAt(i))\n+      return false;\n+  return true;\n+}\n+\n jchar\n java::lang::String::charAt(jint i)\n {"}]}