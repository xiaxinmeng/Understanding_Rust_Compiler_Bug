{"sha": "3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjNTc1ZmZkYmJmOWY3NmYyZjg0NThjY2IzNTFlZmQ1ZDY3YTk2Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-03-08T01:38:27Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-03-08T01:38:27Z"}, "message": "calls.c: Fix comment formatting.\n\n\t* calls.c: Fix comment formatting.\n\t* cfgloopanal.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* combine.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* ggc-common.c: Likewise.\n\t* langhooks.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* loop.c: Likewise.\n\t* ra-build.c: Likewise.\n\t* sbitmap.c: Likewise.\n\t* toplev.c: Likewise.\n\nFrom-SVN: r63966", "tree": {"sha": "ac6eaf9720b1013a5b3dc4f6abec3d7ed67daa1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac6eaf9720b1013a5b3dc4f6abec3d7ed67daa1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/comments", "author": null, "committer": null, "parents": [{"sha": "89d11511b0e8ce513e042c75131f6e15529ddf24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d11511b0e8ce513e042c75131f6e15529ddf24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d11511b0e8ce513e042c75131f6e15529ddf24"}], "stats": {"total": 61, "additions": 38, "deletions": 23}, "files": [{"sha": "b398572ba39dd519947a3df320f560113fbac1f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -1,3 +1,18 @@\n+2003-03-07  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* calls.c: Fix comment formatting.\n+\t* cfgloopanal.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* langhooks.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* ra-build.c: Likewise.\n+\t* sbitmap.c: Likewise.\n+\t* toplev.c: Likewise.\n+\n 2003-03-07  James E Wilson  <wilson@tuliptree.org>\n \n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* config/sh/sh.h (HARD_REGNO_NREGS): Round up the XD register count."}, {"sha": "cab6571f328b40694467a529f77c1ecda7fbbd28", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -2572,7 +2572,7 @@ expand_call (exp, target, ignore)\n \t  if (try_tail_recursion)\n \t    actparms = tree_cons (NULL_TREE, args[i].tree_value, actparms);\n \t}\n-      /* Do the same for the function address if it is an expression. */\n+      /* Do the same for the function address if it is an expression.  */\n       if (!fndecl)\n         addr = fix_unsafe_tree (addr);\n       /* Expanding one of those dangerous arguments could have added"}, {"sha": "0843a006acbc080bfe10135b244c307bcc84183d", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -214,7 +214,7 @@ invariant_rtx_wrto_regs_p_helper (expr, invariant_regs)\n     }\n }\n \n-/* Checks that EXPR is invariant provided that INVARIANT_REGS are invariant. */\n+/* Checks that EXPR is invariant provided that INVARIANT_REGS are invariant.  */\n static bool\n invariant_rtx_wrto_regs_p (expr, invariant_regs)\n      rtx expr;\n@@ -278,7 +278,7 @@ simple_condition_p (loop, condition, invariant_regs, desc)\n       return true;\n     }\n \n-  /* Check the other operand. */\n+  /* Check the other operand.  */\n   if (!invariant_rtx_wrto_regs_p (op1, invariant_regs))\n     return false;\n   if (!REG_P (op0))\n@@ -494,7 +494,7 @@ constant_iterations (desc, niter, may_be_zero)\n    These cases needs to be either cared by copying the loop test in the front\n    of loop or keeping the test in first iteration of loop.\n    \n-   When INIT/LIM are set, they are used instead of var/lim of DESC. */\n+   When INIT/LIM are set, they are used instead of var/lim of DESC.  */\n rtx\n count_loop_iterations (desc, init, lim)\n      struct loop_desc *desc;\n@@ -578,7 +578,7 @@ count_loop_iterations (desc, init, lim)\n   if (stride != const1_rtx)\n     {\n       /* Number of iterations is now (EXP + STRIDE - 1 / STRIDE),\n-\t but we need to take care for overflows.   */\n+\t but we need to take care for overflows.  */\n \n       mod = simplify_gen_binary (UMOD, GET_MODE (desc->var), exp, stride);\n \n@@ -719,7 +719,7 @@ simple_loop_exit_p (loops, loop, exit_edge, invariant_regs, single_set_regs, des\n   desc->var_alts = variable_initial_values (e, desc->var);\n   desc->lim_alts = variable_initial_values (e, desc->lim);\n \n-  /* Number of iterations. */\n+  /* Number of iterations.  */\n   if (!count_loop_iterations (desc, NULL, NULL))\n     return false;\n   desc->const_iter ="}, {"sha": "70926f2ab7d3595f44c196ec4f64c48dce9921c4", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -875,7 +875,7 @@ loop_delete_branch_edge (e, really_delete)\n   else\n     {\n       /* Cannot happen -- we are using this only to remove an edge\n-\t from branch. */\n+\t from branch.  */\n       abort ();\n     }\n \n@@ -1411,7 +1411,7 @@ create_preheader (loop, dom, flags)\n \n   add_to_dominance_info (dom, fallthru->dest);\n   \n-  /* Redirect edges. */\n+  /* Redirect edges.  */\n   for (e = dummy->pred; e; e = e->pred_next)\n     {\n       src = e->src;"}, {"sha": "00e5fe8d1ba9765440a1bbbc780cc0eaebb58f78", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -4193,7 +4193,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n          = (float_truncate:SF foo:DF). \n \n          (float_truncate:DF (float_extend:XF foo:SF)) \n-         = (float_extend:SF foo:DF). */\n+         = (float_extend:SF foo:DF).  */\n       if ((GET_CODE (XEXP (x, 0)) == FLOAT_TRUNCATE\n \t   && flag_unsafe_math_optimizations)\n \t  || GET_CODE (XEXP (x, 0)) == FLOAT_EXTEND)"}, {"sha": "c2aa5b11d35d2fbc5918ee13f619b6084b5a2525", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -12755,7 +12755,7 @@ output_indirect_string (h, v)\n \n \n /* Clear the marks for a die and its children.\n-   Be cool if the mark isn't set. */\n+   Be cool if the mark isn't set.  */\n \n static void\n prune_unmark_dies (die)\n@@ -12829,7 +12829,7 @@ prune_unused_types_mark (die, dokids)\n       for (c = die->die_child; c; c = c->die_sib)\n \t{\n \t  /* If this is an array type, we need to make sure our\n-\t     kids get marked, even if they're types. */\n+\t     kids get marked, even if they're types.  */\n \t  if (die->die_tag == DW_TAG_array_type)\n \t    prune_unused_types_mark (c, 1);\n \t  else"}, {"sha": "8e12d56ee805f30de74397ad7e1daed66be791ac", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -694,7 +694,7 @@ ggc_min_heapsize_heuristic()\n   /* Adjust for rlimits.  */\n   min_heap_kbytes = ggc_rlimit_bound (min_heap_kbytes);\n \n-  min_heap_kbytes /= 1024; /* convert to Kbytes. */\n+  min_heap_kbytes /= 1024; /* convert to Kbytes.  */\n   \n   /* The heuristic is RAM/8, with a lower bound of 4M and an upper\n      bound of 128M (when RAM >= 1GB).  */"}, {"sha": "7f5753dcdb0dbd8e3032d885285b105a890e7698", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -450,7 +450,7 @@ lhd_expr_size (exp)\n }\n \n /* lang_hooks.decls.final_write_globals: perform final processing on\n-   global variables. */\n+   global variables.  */\n void\n write_global_declarations ()\n {"}, {"sha": "55899a97c49d324d7a3172f7822270f2e8440347", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -346,7 +346,7 @@ decide_peel_completely (loops, loop, flags)\n       return;\n     }\n \n-  /* npeel = number of iterations to peel. */\n+  /* npeel = number of iterations to peel.  */\n   npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS) / loop->ninsns;\n   if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n     npeel = PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES);\n@@ -974,7 +974,7 @@ decide_peel_simple (loops, loop, flags)\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \";; Considering simply peeling loop\\n\");\n \n-  /* npeel = number of iterations to peel. */\n+  /* npeel = number of iterations to peel.  */\n   npeel = PARAM_VALUE (PARAM_MAX_PEELED_INSNS) / loop->ninsns;\n   if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_PEEL_TIMES))\n     npeel = PARAM_VALUE (PARAM_MAX_PEEL_TIMES);"}, {"sha": "7a8185d4bad37178d9953dd6b7048463ca5b4f03", "filename": "gcc/loop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -225,7 +225,7 @@ struct movable\n   unsigned int is_equiv : 1;\t/* 1 means a REG_EQUIV is present on INSN.  */\n   unsigned int insert_temp : 1;  /* 1 means we copy to a new pseudo and replace\n \t\t\t\t    the original insn with a copy from that\n-\t\t\t\t    pseudo, rather than deleting it. */\n+\t\t\t\t    pseudo, rather than deleting it.  */\n   struct movable *match;\t/* First entry for same value */\n   struct movable *forces;\t/* An insn that must be moved if this is */\n   struct movable *next;\n@@ -846,7 +846,7 @@ scan_loop (loop, flags)\n \t\t;\n \t      /* Don't move the source and add a reg-to-reg copy with -Os\n \t\t (this certainly increases size) or if the source is\n-\t\t already a reg (the motion will gain nothing). */\n+\t\t already a reg (the motion will gain nothing).  */\n \t      else if (insert_temp \n \t\t       && (optimize_size || GET_CODE (SET_SRC (set)) == REG\n \t\t\t   || (CONSTANT_P (SET_SRC (set))\n@@ -1977,7 +1977,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t      if (m->insert_temp)\n \t\t\t{\n \t\t\t  /* Replace the original insn with a move from\n-\t\t\t     our newly created temp. */\n+\t\t\t     our newly created temp.  */\n \t\t\t  start_sequence ();\n     \t\t\t  emit_move_insn (m->set_dest, newreg);\n \t\t\t  seq = get_insns ();\n@@ -2221,7 +2221,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t{\n \t\t\t  rtx seq;\n \t\t\t  /* Replace the original insn with a move from\n-\t\t\t     our newly created temp. */\n+\t\t\t     our newly created temp.  */\n \t\t\t  start_sequence ();\n     \t\t\t  emit_move_insn (m->set_dest, newreg);\n \t\t\t  seq = get_insns ();"}, {"sha": "ffb5c9b46ae68a84e7e4c860e071a581cd9bdb9f", "filename": "gcc/ra-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -1729,7 +1729,7 @@ compare_and_free_webs (link)\n \t      && (web1->num_uses != web2->num_uses\n \t          || web1->num_defs != web2->num_defs))\n \t  /* Similarly, if the framepointer was unreferenced originally\n-\t     but we added spills, these fields may not match. */\n+\t     but we added spills, these fields may not match.  */\n \t  || (web1->type != PRECOLORED\n                && web1->crosses_call != web2->crosses_call)\n \t  || (web1->type != PRECOLORED"}, {"sha": "ce60ca8a78335b150386267d3ba070281582845b", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -94,7 +94,7 @@ sbitmap_resize (bmap, n_elms, def)\n     }\n   else if (n_elms < bmap->n_bits)\n     {\n-      /* Clear the surplus bits in the last word. */\n+      /* Clear the surplus bits in the last word.  */\n       last_bit = n_elms % SBITMAP_ELT_BITS;\n       if (last_bit)\n \tbmap->elms[size - 1]"}, {"sha": "9d6899d808a082947d0cf60005d065046e6a584e", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3dc575ffdbbf9f76f2f8458ccb351efd5d67a96b", "patch": "@@ -1967,7 +1967,7 @@ wrapup_global_declarations (vec, len)\n       decl = vec[i];\n \n       /* We're not deferring this any longer.  Assignment is\n-\t conditional to avoid needlessly dirtying PCH pages. */\n+\t conditional to avoid needlessly dirtying PCH pages.  */\n       if (DECL_DEFER_OUTPUT (decl) != 0)\n \tDECL_DEFER_OUTPUT (decl) = 0;\n \n@@ -3542,7 +3542,7 @@ rest_of_compilation (decl)\n       open_dump_file (DFI_bbro, decl);\n \n       /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-\t splitting possibly introduced more crossjumping opportunities. */\n+\t splitting possibly introduced more crossjumping opportunities.  */\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n \t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n "}]}