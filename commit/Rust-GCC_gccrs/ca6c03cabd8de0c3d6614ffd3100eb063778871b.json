{"sha": "ca6c03cabd8de0c3d6614ffd3100eb063778871b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2YzAzY2FiZDhkZTBjM2Q2NjE0ZmZkMzEwMGViMDYzNzc4ODcxYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-25T15:26:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-25T15:26:55Z"}, "message": "Makefile.in (cfgrtl.o): Add.\n\n\t* Makefile.in (cfgrtl.o): Add.\n\t* basic-block.h (alloc_block, alloc_aux_for_block, alloc_aux_for_blocks,\n\tfree_aux_for_block, alloc_aux_for_edge, alloc_aux_for_edges,\n\tfree_aux_for_edge): Declare.\n\t* cfg.c\n\t(HAVE_return): Undefine.\n\t* basic-block.h (alloc_block, alloc_aux_for_block, alloc_aux_for_blocks,\n\tfree_aux_for_block, alloc_aux_for_edge, alloc_aux_for_edges,\n\tfree_aux_for_edge): New global functions.\n\t(first_delete_block): New static variable.\n\t(init_flow): Clear first_delete_block.\n\t(basic_block_for_insn, label_value_list, tail_recursion_label_list,\n\t can_delete_note_p, can_delete_label_p, commit_one_edge_insertion,\n\t try_redirect_by_replacing_jump, last_loop_beg_note,\n\t back_edge_of_syntactic_loop_p, force_nonfallthru_and_redirect,\n\t delete_insn, delete_insn_chain, create_basic_block_structure,\n\t create_basic_block, flow_delete_block, compute_bb_for_insn,\n\t free_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n\t set_block_for_new_insns, split_block, merge_blocks_nomove,\n\t block_label, try_redirect_by_replacing_jump, last_loop_beg_note,\n\t redirect_edge_and_branch, force_nonfallthru_and_redirect,\n\t force_nonfallthru, redirect_edge_and_branch_force, tidy_fallthru_edge,\n\t tidy_fallthru_edges, split_edge, insert_insn_on_edge,\n\t commit_one_edge_insertion, commit_edge_insertions, dump_bb, debug_bb,\n\t debug_bb_n, print_rtl_with_bb, verify_flow_info, purge_dead_edges,\n\t purge_all_dead_edges): Move to ....\n\t* cfgrtl.c: New file; .... Here.\n\n\t* bb-reorder.c (fixup_reorder_chain): Use alloc_aux_for_block.\n\t(reroder_basic_block): Use alloc_aux_for_blocks.\n\t* predict.c (estimate_bb_frequencies): Likewise; use\n\talloc_aux_for_edges.\n\t* profile.c (compute_branch_probabilities): Likewise.\n\t(branch_prob): Likewise.\n\t* reg-stack.c (reg_to_stack): Likewise.\n\n\t* emit-rtl.c (emit_insns_after): Never return NULL.\n\n\t* basic-block.h (set_block_for_new_insns): Delete.\n\t* cfgrtl.c (set_block_for_new_insns): Delete.\n\n\t* cfgcleanup.c (try_optimize_cfg): Add fake exit edges for noreturn\n\tcalls when crossjumping.\n\n\t* cfgcleanup.c (try_simplify_condjump): Cleanup invert_jump call.\n\t* unroll.c (copy_loop_body): Use delete_insn.\n\n\t* final.c (final, final_scan_insn): Use delete_insn/delete_note.\n\t* function.c (fixup_var_refs_insn, fixup_var_refs_1,\n\tkeep_stack_depressed): Likewise.\n\t* gcse.c (cprop_cc0_jump): Likewise.\n\t* local-alloc.c (update_equiv_regs): Likewise.\n\t* loop.c (scan_loop, loop_delete_insns): Likewise.\n\t* regmove.c (try_auto_increment, fixup_match_1): Likewise.\n\t* reload1.c (reload, calculate_needs_all_insns, reload_as_needed,\n\tdelete_output_reload, delete_address_reloads_1,\n\treload_cse_delete_noop_set, reload_combine, reload_cse_move2add):\n\tLikewise.\n\t* sibcall.c (replace_call_placeholder): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\nFrom-SVN: r45807", "tree": {"sha": "c24462f2a137fa697fa16cd37b541df560a461cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c24462f2a137fa697fa16cd37b541df560a461cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca6c03cabd8de0c3d6614ffd3100eb063778871b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6c03cabd8de0c3d6614ffd3100eb063778871b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca6c03cabd8de0c3d6614ffd3100eb063778871b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6c03cabd8de0c3d6614ffd3100eb063778871b/comments", "author": null, "committer": null, "parents": [{"sha": "21e1b5f1e05d3118f2e534373ecee20b690c17ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e1b5f1e05d3118f2e534373ecee20b690c17ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e1b5f1e05d3118f2e534373ecee20b690c17ab"}], "stats": {"total": 4432, "additions": 2287, "deletions": 2145}, "files": [{"sha": "6b434277309bea712bfd9e3c66a01bbc2ec0e517", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -1,3 +1,66 @@\n+Tue Sep 25 17:13:56 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (cfgrtl.o): Add.\n+\t* basic-block.h (alloc_block, alloc_aux_for_block, alloc_aux_for_blocks,\n+\tfree_aux_for_block, alloc_aux_for_edge, alloc_aux_for_edges,\n+\tfree_aux_for_edge): Declare.\n+\t* cfg.c\n+\t(HAVE_return): Undefine.\n+\t* basic-block.h (alloc_block, alloc_aux_for_block, alloc_aux_for_blocks,\n+\tfree_aux_for_block, alloc_aux_for_edge, alloc_aux_for_edges,\n+\tfree_aux_for_edge): New global functions.\n+\t(first_delete_block): New static variable.\n+\t(init_flow): Clear first_delete_block.\n+\t(basic_block_for_insn, label_value_list, tail_recursion_label_list,\n+\t can_delete_note_p, can_delete_label_p, commit_one_edge_insertion,\n+\t try_redirect_by_replacing_jump, last_loop_beg_note,\n+\t back_edge_of_syntactic_loop_p, force_nonfallthru_and_redirect,\n+\t delete_insn, delete_insn_chain, create_basic_block_structure,\n+\t create_basic_block, flow_delete_block, compute_bb_for_insn,\n+\t free_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n+\t set_block_for_new_insns, split_block, merge_blocks_nomove,\n+\t block_label, try_redirect_by_replacing_jump, last_loop_beg_note,\n+\t redirect_edge_and_branch, force_nonfallthru_and_redirect,\n+\t force_nonfallthru, redirect_edge_and_branch_force, tidy_fallthru_edge,\n+\t tidy_fallthru_edges, split_edge, insert_insn_on_edge,\n+\t commit_one_edge_insertion, commit_edge_insertions, dump_bb, debug_bb,\n+\t debug_bb_n, print_rtl_with_bb, verify_flow_info, purge_dead_edges,\n+\t purge_all_dead_edges): Move to ....\n+\t* cfgrtl.c: New file; .... Here.\n+\n+\t* bb-reorder.c (fixup_reorder_chain): Use alloc_aux_for_block.\n+\t(reroder_basic_block): Use alloc_aux_for_blocks.\n+\t* predict.c (estimate_bb_frequencies): Likewise; use\n+\talloc_aux_for_edges.\n+\t* profile.c (compute_branch_probabilities): Likewise.\n+\t(branch_prob): Likewise.\n+\t* reg-stack.c (reg_to_stack): Likewise.\n+\n+\t* emit-rtl.c (emit_insns_after): Never return NULL.\n+\n+\t* basic-block.h (set_block_for_new_insns): Delete.\n+\t* cfgrtl.c (set_block_for_new_insns): Delete.\n+\n+\t* cfgcleanup.c (try_optimize_cfg): Add fake exit edges for noreturn\n+\tcalls when crossjumping.\n+\n+\t* cfgcleanup.c (try_simplify_condjump): Cleanup invert_jump call.\n+\t* unroll.c (copy_loop_body): Use delete_insn.\n+\n+\t* final.c (final, final_scan_insn): Use delete_insn/delete_note.\n+\t* function.c (fixup_var_refs_insn, fixup_var_refs_1,\n+\tkeep_stack_depressed): Likewise.\n+\t* gcse.c (cprop_cc0_jump): Likewise.\n+\t* local-alloc.c (update_equiv_regs): Likewise.\n+\t* loop.c (scan_loop, loop_delete_insns): Likewise.\n+\t* regmove.c (try_auto_increment, fixup_match_1): Likewise.\n+\t* reload1.c (reload, calculate_needs_all_insns, reload_as_needed,\n+\tdelete_output_reload, delete_address_reloads_1,\n+\treload_cse_delete_noop_set, reload_combine, reload_cse_move2add):\n+\tLikewise.\n+\t* sibcall.c (replace_call_placeholder): Likewise.\n+\t* cse.c (cse_insn): Likewise.\n+\n 2001-09-25  Bernd Schmidt  <bernds@redhat.com>\n \n \tFrom Graham Stott  <grahams@redhat.com>"}, {"sha": "5cc264cba2949e6ac9740adf9fe6b9addff4c31e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -747,7 +747,7 @@ OBJS =\t\t\t\t\t\t\t\t\t\\\n  sdbout.o sibcall.o simplify-rtx.o splay-tree.o ssa.o ssa-ccp.o         \\\n  ssa-dce.o stmt.o stor-layout.o stringpool.o timevar.o toplev.o tree.o  \\\n  unroll.o varasm.o varray.o version.o xcoffout.o cfg.o cfganal.o\t\\\n- cfgbuild.o cfgcleanup.o cfgloop.o        \\\n+ cfgbuild.o cfgcleanup.o cfgloop.o cfgrtl.o        \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = main.o libbackend.a\n@@ -1497,6 +1497,9 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h insn-config.h\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H)\n+cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h insn-config.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n+   function.h except.h $(GGC_H) $(TM_P_H)\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(GGC_H)\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h insn-config.h \\"}, {"sha": "9b215c532230178ced1a5d52bc1a903a20cabd98", "filename": "gcc/basic-block.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -291,7 +291,6 @@ extern void compute_bb_for_insn\t\tPARAMS ((int));\n extern void free_bb_for_insn\t\tPARAMS ((void));\n extern void update_bb_for_insn\t\tPARAMS ((basic_block));\n extern void set_block_for_insn\t\tPARAMS ((rtx, basic_block));\n-extern void set_block_for_new_insns\tPARAMS ((rtx, basic_block));\n \n extern void free_basic_block_vars\tPARAMS ((int));\n \n@@ -630,6 +629,7 @@ extern void debug_regset\t\tPARAMS ((regset));\n extern void allocate_reg_life_data      PARAMS ((void));\n extern void allocate_bb_life_data\tPARAMS ((void));\n extern void expunge_block\t\tPARAMS ((basic_block));\n+extern basic_block alloc_block\t\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n extern void delete_noop_moves\t\tPARAMS ((rtx));\n extern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n@@ -645,6 +645,12 @@ extern void flow_nodes_print\t\tPARAMS ((const char *, const sbitmap,\n \t\t\t\t\t\t FILE *));\n extern void flow_edge_list_print\tPARAMS ((const char *, const edge *,\n \t\t\t\t\t\t int, FILE *));\n+extern void alloc_aux_for_block\t\tPARAMS ((basic_block, int));\n+extern void alloc_aux_for_blocks\tPARAMS ((int));\n+extern void free_aux_for_blocks\t\tPARAMS ((void));\n+extern void alloc_aux_for_edge\t\tPARAMS ((edge, int));\n+extern void alloc_aux_for_edges\t\tPARAMS ((int));\n+extern void free_aux_for_edges\t\tPARAMS ((void));\n \n /* This function is always defined so it can be called from the\n    debugger, and it is declared extern so we don't get warnings about"}, {"sha": "aa303158dc12bd8c9bf80b4b82f4e24a7d224b3c", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -660,7 +660,7 @@ fixup_reorder_chain ()\n \n       if (nb)\n \t{\n-\t  nb->aux = xmalloc (sizeof (struct reorder_block_def));\n+\t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n \t  RBI (nb)->eff_head = nb->head;\n \t  RBI (nb)->eff_end = NEXT_INSN (nb->end);\n \t  RBI (nb)->scope = RBI (bb)->scope;\n@@ -1327,15 +1327,11 @@ void\n reorder_basic_blocks ()\n {\n   scope_forest_info forest;\n-  int i;\n \n   if (n_basic_blocks <= 1)\n     return;\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n-\n-  EXIT_BLOCK_PTR->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+  alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n \n   build_scope_forest (&forest);\n   remove_scope_notes ();\n@@ -1356,10 +1352,7 @@ reorder_basic_blocks ()\n   free_scope_forest (&forest);\n   reorder_blocks ();\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    free (BASIC_BLOCK (i)->aux);\n-\n-  free (EXIT_BLOCK_PTR->aux);\n+  free_aux_for_blocks ();\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();"}, {"sha": "932b7e32c019a29459e7ef1bf2ab1965cfb60346", "filename": "gcc/cfg.c", "status": "modified", "additions": 221, "deletions": 1967, "changes": 2188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -21,35 +21,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* This file contains low level functions to manipulate with CFG and analyze it.\n    All other modules should not transform the datastructure directly and use\n-   abstraction instead.  The file is supposed to be ordered bottom-up.\n+   abstraction instead.  The file is supposed to be ordered bottom-up and should\n+   not contain any code depdendent on particular intermediate language (RTL or trees)\n \n    Available functionality:\n      - Initialization/deallocation\n \t init_flow, clear_edges\n-     - CFG aware instruction chain manipulation\n-\t delete_insn, delete_insn_chain\n-     - Basic block manipulation\n-\t create_basic_block, flow_delete_block, split_block, merge_blocks_nomove\n-     - Infrastructure to determine quickly basic block for instruction.\n-\t compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n-\t set_block_for_new_insns\n+     - Low level basic block manipulation\n+\t alloc_block, expunge_block\n      - Edge manipulation\n \t make_edge, make_single_succ_edge, cached_make_edge, remove_edge\n \t - Low level edge redirection (without updating instruction chain)\n \t     redirect_edge_succ, redirect_edge_succ_nodup, redirect_edge_pred\n-\t - High level edge redirection (with updating and optimizing instruction\n-\t   chain)\n-\t     block_label, redirect_edge_and_branch,\n-\t     redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n-      - Edge splitting and commiting to edges\n-\t  split_edge, insert_insn_on_edge, commit_edge_insertions\n-      - Dumpipng and debugging\n-\t  dump_flow_info, debug_flow_info, dump_edge_info, dump_bb, debug_bb,\n-\t  debug_bb_n, print_rtl_with_bb\n-      - Consistency checking\n-\t  verify_flow_info\n-      - CFG updating after constant propagation\n-\t  purge_dead_edges, purge_all_dead_edges\n+     - Dumpipng and debugging\n+\t dump_flow_info, debug_flow_info, dump_edge_info\n+     - Allocation of AUX fields for basic blocks\n+\t alloc_aux_for_blocks, free_aux_for_blocks, alloc_aux_for_block\n  */\n \f\n #include \"config.h\"\n@@ -67,13 +54,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"obstack.h\"\n \n-\n-/* Stubs in case we haven't got a return insn.  */\n-#ifndef HAVE_return\n-#define HAVE_return 0\n-#define gen_return() NULL_RTX\n-#endif\n-\n /* The obstack on which the flow graph components are allocated.  */\n \n struct obstack flow_obstack;\n@@ -90,6 +70,7 @@ int n_edges;\n /* First edge in the deleted edges chain.  */\n \n edge first_deleted_edge;\n+static basic_block first_deleted_block;\n \n /* The basic block array.  */\n \n@@ -135,25 +116,7 @@ struct basic_block_def entry_exit_blocks[2]\n   }\n };\n \n-/* The basic block structure for every insn, indexed by uid.  */\n-\n-varray_type basic_block_for_insn;\n-\n-/* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n-/* ??? Should probably be using LABEL_NUSES instead.  It would take a\n-   bit of surgery to be able to use or co-opt the routines in jump.  */\n-\n-rtx label_value_list;\n-rtx tail_recursion_label_list;\n-\n void debug_flow_info\t\t\tPARAMS ((void));\n-static int can_delete_note_p\t\tPARAMS ((rtx));\n-static int can_delete_label_p\t\tPARAMS ((rtx));\n-static void commit_one_edge_insertion\tPARAMS ((edge));\n-static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n-static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n-static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n-static basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n \f\n /* Called once at intialization time.  */\n \n@@ -163,6 +126,7 @@ init_flow ()\n   static int initialized;\n \n   first_deleted_edge = 0;\n+  first_deleted_block = 0;\n   n_edges = 0;\n \n   if (!initialized)\n@@ -200,247 +164,24 @@ clear_edges ()\n     abort ();\n }\n \f\n-/* Return true if NOTE is not one of the ones that must be kept paired,\n-   so that we may simply delete them.  */\n-\n-static int\n-can_delete_note_p (note)\n-     rtx note;\n-{\n-  return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n-\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK);\n-}\n-\n-/* True if a given label can be deleted.  */\n-\n-static int\n-can_delete_label_p (label)\n-     rtx label;\n-{\n-  rtx x;\n-\n-  if (LABEL_PRESERVE_P (label))\n-    return 0;\n-\n-  for (x = forced_labels; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return 0;\n-  for (x = label_value_list; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return 0;\n-  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return 0;\n-\n-  /* User declared labels must be preserved.  */\n-  if (LABEL_NAME (label) != 0)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-/* Delete INSN by patching it out.  Return the next insn.  */\n-\n-rtx\n-delete_insn (insn)\n-     rtx insn;\n-{\n-  rtx next = NEXT_INSN (insn);\n-  rtx note;\n-  bool really_delete = true;\n-\n-  if (GET_CODE (insn) == CODE_LABEL)\n-    {\n-      /* Some labels can't be directly removed from the INSN chain, as they\n-         might be references via variables, constant pool etc. \n-         Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n-      if (! can_delete_label_p (insn))\n-\t{\n-\t  const char *name = LABEL_NAME (insn);\n-\n-\t  really_delete = false;\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n-\t  NOTE_SOURCE_FILE (insn) = name;\n-\t}\n-      remove_node_from_expr_list (insn, &nonlocal_goto_handler_labels);\n-    }\n-\n-  if (really_delete)\n-    {\n-      remove_insn (insn);\n-      INSN_DELETED_P (insn) = 1;\n-    }\n-\n-  /* If deleting a jump, decrement the use count of the label.  Deleting\n-     the label itself should happen in the normal course of block merging.  */\n-  if (GET_CODE (insn) == JUMP_INSN\n-      && JUMP_LABEL (insn)\n-      && GET_CODE (JUMP_LABEL (insn)) == CODE_LABEL)\n-    LABEL_NUSES (JUMP_LABEL (insn))--;\n-\n-  /* Also if deleting an insn that references a label.  */\n-  else if ((note = find_reg_note (insn, REG_LABEL, NULL_RTX)) != NULL_RTX\n-\t   && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n-    LABEL_NUSES (XEXP (note, 0))--;\n-\n-  if (GET_CODE (insn) == JUMP_INSN\n-      && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n-    {\n-      rtx pat = PATTERN (insn);\n-      int diff_vec_p = GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC;\n-      int len = XVECLEN (pat, diff_vec_p);\n-      int i;\n-\n-      for (i = 0; i < len; i++)\n-\tLABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n-    }\n-\n-  return next;\n-}\n-\n-/* Unlink a chain of insns between START and FINISH, leaving notes\n-   that must be paired.  */\n-\n-void\n-delete_insn_chain (start, finish)\n-     rtx start, finish;\n-{\n-  /* Unchain the insns one by one.  It would be quicker to delete all\n-     of these with a single unchaining, rather than one at a time, but\n-     we need to keep the NOTE's.  */\n-\n-  rtx next;\n-\n-  while (1)\n-    {\n-      next = NEXT_INSN (start);\n-      if (GET_CODE (start) == NOTE && !can_delete_note_p (start))\n-\t;\n-      else\n-\tnext = delete_insn (start);\n-\n-      if (start == finish)\n-\tbreak;\n-      start = next;\n-    }\n-}\n-\f\n-/* Create a new basic block consisting of the instructions between\n-   HEAD and END inclusive.  This function is designed to allow fast\n-   BB construction - reuses the note and basic block struct\n-   in BB_NOTE, if any and do not grow BASIC_BLOCK chain and should\n-   be used directly only by CFG construction code.\n-   END can be NULL in to create new empty basic block before HEAD.\n-   Both END and HEAD can be NULL to create basic block at the end of\n-   INSN chain.  */\n+/* Allocate memory for basic_block.  */\n \n basic_block\n-create_basic_block_structure (index, head, end, bb_note)\n-     int index;\n-     rtx head, end, bb_note;\n+alloc_block ()\n {\n   basic_block bb;\n \n-  if (bb_note\n-      && ! RTX_INTEGRATED_P (bb_note)\n-      && (bb = NOTE_BASIC_BLOCK (bb_note)) != NULL\n-      && bb->aux == NULL)\n+  if (first_deleted_block)\n     {\n-      /* If we found an existing note, thread it back onto the chain.  */\n-\n-      rtx after;\n-\n-      if (GET_CODE (head) == CODE_LABEL)\n-\tafter = head;\n-      else\n-\t{\n-\t  after = PREV_INSN (head);\n-\t  head = bb_note;\n-\t}\n-\n-      if (after != bb_note && NEXT_INSN (after) != bb_note)\n-\treorder_insns (bb_note, bb_note, after);\n+      bb = first_deleted_block;\n+      first_deleted_block = (basic_block) bb->succ;\n+      bb->succ = NULL;\n     }\n   else\n     {\n-      /* Otherwise we must create a note and a basic block structure.\n-\t Since we allow basic block structs in rtl, give the struct\n-\t the same lifetime by allocating it off the function obstack\n-\t rather than using malloc.  */\n-\n       bb = (basic_block) obstack_alloc (&flow_obstack, sizeof (*bb));\n       memset (bb, 0, sizeof (*bb));\n-\n-      if (!head && !end)\n-\t{\n-\t  head = end = bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK,\n-\t\t\t\t\t\t  get_last_insn ());\n-\t}\n-      else if (GET_CODE (head) == CODE_LABEL && end)\n-\t{\n-\t  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, head);\n-\t  if (head == end)\n-\t    end = bb_note;\n-\t}\n-      else\n-\t{\n-\t  bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK, head);\n-\t  head = bb_note;\n-\t  if (!end)\n-\t    end = head;\n-\t}\n-      NOTE_BASIC_BLOCK (bb_note) = bb;\n-    }\n-\n-  /* Always include the bb note in the block.  */\n-  if (NEXT_INSN (end) == bb_note)\n-    end = bb_note;\n-\n-  bb->head = head;\n-  bb->end = end;\n-  bb->index = index;\n-  BASIC_BLOCK (index) = bb;\n-  if (basic_block_for_insn)\n-    update_bb_for_insn (bb);\n-\n-  /* Tag the block so that we know it has been used when considering\n-     other basic block notes.  */\n-  bb->aux = bb;\n-\n-  return bb;\n-}\n-\n-/* Create new basic block consisting of instructions in between HEAD and\n-   END and place it to the BB chain at possition INDEX.\n-   END can be NULL in to create new empty basic block before HEAD.\n-   Both END and HEAD can be NULL to create basic block at the end of\n-   INSN chain.  */\n-\n-basic_block\n-create_basic_block (index, head, end)\n-     int index;\n-     rtx head, end;\n-{\n-  basic_block bb;\n-  int i;\n-\n-  /* Place the new block just after the block being split.  */\n-  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-\n-  /* Some parts of the compiler expect blocks to be number in\n-     sequential order so insert the new block immediately after the\n-     block being split..  */\n-  for (i = n_basic_blocks - 1; i > index; --i)\n-    {\n-      basic_block tmp = BASIC_BLOCK (i - 1);\n-      BASIC_BLOCK (i) = tmp;\n-      tmp->index = i;\n     }\n-\n-  bb = create_basic_block_structure (index, head, end, NULL);\n-  bb->aux = NULL;\n   return bb;\n }\n \n@@ -464,180 +205,8 @@ expunge_block (b)\n   b->index = -3;\n   basic_block_info->num_elements--;\n   n_basic_blocks--;\n-}\n-\n-/* Delete the insns in a (non-live) block.  We physically delete every\n-   non-deleted-note insn, and update the flow graph appropriately.\n-\n-   Return nonzero if we deleted an exception handler.  */\n-\n-/* ??? Preserving all such notes strikes me as wrong.  It would be nice\n-   to post-process the stream to remove empty blocks, loops, ranges, etc.  */\n-\n-int\n-flow_delete_block (b)\n-     basic_block b;\n-{\n-  int deleted_handler = 0;\n-  rtx insn, end, tmp;\n-\n-  /* If the head of this block is a CODE_LABEL, then it might be the\n-     label for an exception handler which can't be reached.\n-\n-     We need to remove the label from the exception_handler_label list\n-     and remove the associated NOTE_INSN_EH_REGION_BEG and\n-     NOTE_INSN_EH_REGION_END notes.  */\n-\n-  insn = b->head;\n-\n-  never_reached_warning (insn);\n-\n-  if (GET_CODE (insn) == CODE_LABEL)\n-    maybe_remove_eh_handler (insn);\n-\n-  /* Include any jump table following the basic block.  */\n-  end = b->end;\n-  if (GET_CODE (end) == JUMP_INSN\n-      && (tmp = JUMP_LABEL (end)) != NULL_RTX\n-      && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n-      && GET_CODE (tmp) == JUMP_INSN\n-      && (GET_CODE (PATTERN (tmp)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC))\n-    end = tmp;\n-\n-  /* Include any barrier that may follow the basic block.  */\n-  tmp = next_nonnote_insn (end);\n-  if (tmp && GET_CODE (tmp) == BARRIER)\n-    end = tmp;\n-\n-  /* Selectively delete the entire chain.  */\n-  b->head = NULL;\n-  delete_insn_chain (insn, end);\n-\n-  /* Remove the edges into and out of this block.  Note that there may\n-     indeed be edges in, if we are removing an unreachable loop.  */\n-  while (b->pred != NULL)\n-    remove_edge (b->pred);\n-  while (b->succ != NULL)\n-    remove_edge (b->succ);\n-\n-  b->pred = NULL;\n-  b->succ = NULL;\n-\n-  /* Remove the basic block from the array, and compact behind it.  */\n-  expunge_block (b);\n-\n-  return deleted_handler;\n-}\n-\f\n-/* Records the basic block struct in BB_FOR_INSN, for every instruction\n-   indexed by INSN_UID.  MAX is the size of the array.  */\n-\n-void\n-compute_bb_for_insn (max)\n-     int max;\n-{\n-  int i;\n-\n-  if (basic_block_for_insn)\n-    VARRAY_FREE (basic_block_for_insn);\n-  VARRAY_BB_INIT (basic_block_for_insn, max, \"basic_block_for_insn\");\n-\n-  for (i = 0; i < n_basic_blocks; ++i)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      rtx insn, end;\n-\n-      end = bb->end;\n-      insn = bb->head;\n-      while (1)\n-\t{\n-\t  int uid = INSN_UID (insn);\n-\t  if (uid < max)\n-\t    VARRAY_BB (basic_block_for_insn, uid) = bb;\n-\t  if (insn == end)\n-\t    break;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n-}\n-\n-/* Release the basic_block_for_insn array.  */\n-\n-void\n-free_bb_for_insn ()\n-{\n-  if (basic_block_for_insn)\n-    VARRAY_FREE (basic_block_for_insn);\n-  basic_block_for_insn = 0;\n-}\n-\n-/* Update insns block within BB.  */\n-\n-void\n-update_bb_for_insn (bb)\n-     basic_block bb;\n-{\n-  rtx insn;\n-\n-  if (! basic_block_for_insn)\n-    return;\n-\n-  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n-    {\n-      set_block_for_insn (insn, bb);\n-\n-      if (insn == bb->end)\n-\tbreak;\n-    }\n-}\n-\n-/* Record INSN's block as BB.  */\n-\n-void\n-set_block_for_insn (insn, bb)\n-     rtx insn;\n-     basic_block bb;\n-{\n-  size_t uid = INSN_UID (insn);\n-  if (uid >= basic_block_for_insn->num_elements)\n-    {\n-      int new_size;\n-\n-      /* Add one-eighth the size so we don't keep calling xrealloc.  */\n-      new_size = uid + (uid + 7) / 8;\n-\n-      VARRAY_GROW (basic_block_for_insn, new_size);\n-    }\n-  VARRAY_BB (basic_block_for_insn, uid) = bb;\n-}\n-\n-/* When a new insn has been inserted into an existing block, it will\n-   sometimes emit more than a single insn. This routine will set the\n-   block number for the specified insn, and look backwards in the insn\n-   chain to see if there are any other uninitialized insns immediately\n-   previous to this one, and set the block number for them too.  */\n-\n-void\n-set_block_for_new_insns (insn, bb)\n-     rtx insn;\n-     basic_block bb;\n-{\n-  set_block_for_insn (insn, bb);\n-\n-  /* Scan the previous instructions setting the block number until we find\n-     an instruction that has the block number set, or we find a note\n-     of any kind.  */\n-  for (insn = PREV_INSN (insn); insn != NULL_RTX; insn = PREV_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == NOTE)\n-\tbreak;\n-      if ((unsigned) INSN_UID (insn) >= basic_block_for_insn->num_elements\n-\t  || BLOCK_FOR_INSN (insn) == 0)\n-\tset_block_for_insn (insn, bb);\n-      else\n-\tbreak;\n-    }\n+  b->succ = (edge) first_deleted_block;\n+  first_deleted_block = (basic_block) b;\n }\n \f\n /* Create an edge connecting SRC and DST with FLAGS optionally using\n@@ -837,998 +406,121 @@ redirect_edge_pred (e, new_pred)\n   e->src = new_pred;\n }\n \f\n-/* Split a block BB after insn INSN creating a new fallthru edge.\n-   Return the new edge.  Note that to keep other parts of the compiler happy,\n-   this function renumbers all the basic blocks so that the new\n-   one has a number one greater than the block split.  */\n-\n-edge\n-split_block (bb, insn)\n-     basic_block bb;\n-     rtx insn;\n+void\n+dump_flow_info (file)\n+     FILE *file;\n {\n-  basic_block new_bb;\n-  edge new_edge;\n-  edge e;\n+  register int i;\n+  static const char * const reg_class_names[] = REG_CLASS_NAMES;\n+\n+  fprintf (file, \"%d registers.\\n\", max_regno);\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (REG_N_REFS (i))\n+      {\n+\tenum reg_class class, altclass;\n+\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n+\tif (REG_BASIC_BLOCK (i) >= 0)\n+\t  fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n+\tif (REG_N_SETS (i))\n+\t  fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n+\t\t   (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n+\tif (REG_USERVAR_P (regno_reg_rtx[i]))\n+\t  fprintf (file, \"; user var\");\n+\tif (REG_N_DEATHS (i) != 1)\n+\t  fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n+\tif (REG_N_CALLS_CROSSED (i) == 1)\n+\t  fprintf (file, \"; crosses 1 call\");\n+\telse if (REG_N_CALLS_CROSSED (i))\n+\t  fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n+\tif (PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n+\t  fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+\tclass = reg_preferred_class (i);\n+\taltclass = reg_alternate_class (i);\n+\tif (class != GENERAL_REGS || altclass != ALL_REGS)\n+\t  {\n+\t    if (altclass == ALL_REGS || class == ALL_REGS)\n+\t      fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t    else if (altclass == NO_REGS)\n+\t      fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n+\t    else\n+\t      fprintf (file, \"; pref %s, else %s\",\n+\t\t       reg_class_names[(int) class],\n+\t\t       reg_class_names[(int) altclass]);\n+\t  }\n+\tif (REG_POINTER (regno_reg_rtx[i]))\n+\t  fprintf (file, \"; pointer\");\n+\tfprintf (file, \".\\n\");\n+      }\n+\n+  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      register basic_block bb = BASIC_BLOCK (i);\n+      register edge e;\n+\n+      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count \",\n+\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth);\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n+      fprintf (file, \", freq %i.\\n\", bb->frequency);\n \n-  /* There is no point splitting the block after its end.  */\n-  if (bb->end == insn)\n-    return 0;\n+      fprintf (file, \"Predecessors: \");\n+      for (e = bb->pred; e; e = e->pred_next)\n+\tdump_edge_info (file, e, 0);\n \n-  /* Create the new basic block.  */\n-  new_bb = create_basic_block (bb->index + 1, NEXT_INSN (insn), bb->end);\n-  new_bb->count = bb->count;\n-  new_bb->frequency = bb->frequency;\n-  new_bb->loop_depth = bb->loop_depth;\n-  bb->end = insn;\n+      fprintf (file, \"\\nSuccessors: \");\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tdump_edge_info (file, e, 1);\n \n-  /* Redirect the outgoing edges.  */\n-  new_bb->succ = bb->succ;\n-  bb->succ = NULL;\n-  for (e = new_bb->succ; e; e = e->succ_next)\n-    e->src = new_bb;\n+      fprintf (file, \"\\nRegisters live at start:\");\n+      dump_regset (bb->global_live_at_start, file);\n \n-  new_edge = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n+      fprintf (file, \"\\nRegisters live at end:\");\n+      dump_regset (bb->global_live_at_end, file);\n \n-  if (bb->global_live_at_start)\n-    {\n-      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n-\n-      /* We now have to calculate which registers are live at the end\n-\t of the split basic block and at the start of the new basic\n-\t block.  Start with those registers that are known to be live\n-\t at the end of the original basic block and get\n-\t propagate_block to determine which registers are live.  */\n-      COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_end);\n-      propagate_block (new_bb, new_bb->global_live_at_start, NULL, NULL, 0);\n-      COPY_REG_SET (bb->global_live_at_end,\n-\t\t    new_bb->global_live_at_start);\n+      putc ('\\n', file);\n     }\n \n-  return new_edge;\n+  putc ('\\n', file);\n }\n \n-/* Blocks A and B are to be merged into a single block A.  The insns\n-   are already contiguous, hence `nomove'.  */\n+void\n+debug_flow_info ()\n+{\n+  dump_flow_info (stderr);\n+}\n \n void\n-merge_blocks_nomove (a, b)\n-     basic_block a, b;\n+dump_edge_info (file, e, do_succ)\n+     FILE *file;\n+     edge e;\n+     int do_succ;\n {\n-  edge e;\n-  rtx b_head, b_end, a_end;\n-  rtx del_first = NULL_RTX, del_last = NULL_RTX;\n-  int b_empty = 0;\n-\n-  /* If there was a CODE_LABEL beginning B, delete it.  */\n-  b_head = b->head;\n-  b_end = b->end;\n-  if (GET_CODE (b_head) == CODE_LABEL)\n-    {\n-      /* Detect basic blocks with nothing but a label.  This can happen\n-\t in particular at the end of a function.  */\n-      if (b_head == b_end)\n-\tb_empty = 1;\n-      del_first = del_last = b_head;\n-      b_head = NEXT_INSN (b_head);\n-    }\n+  basic_block side = (do_succ ? e->dest : e->src);\n+\n+  if (side == ENTRY_BLOCK_PTR)\n+    fputs (\" ENTRY\", file);\n+  else if (side == EXIT_BLOCK_PTR)\n+    fputs (\" EXIT\", file);\n+  else\n+    fprintf (file, \" %d\", side->index);\n+\n+  if (e->probability)\n+    fprintf (file, \" [%.1f%%] \", e->probability * 100.0 / REG_BR_PROB_BASE);\n \n-  /* Delete the basic block note.  */\n-  if (NOTE_INSN_BASIC_BLOCK_P (b_head))\n+  if (e->count)\n     {\n-      if (b_head == b_end)\n-\tb_empty = 1;\n-      if (! del_last)\n-\tdel_first = b_head;\n-      del_last = b_head;\n-      b_head = NEXT_INSN (b_head);\n+      fprintf (file, \" count:\");\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) e->count);\n     }\n \n-  /* If there was a jump out of A, delete it.  */\n-  a_end = a->end;\n-  if (GET_CODE (a_end) == JUMP_INSN)\n+  if (e->flags)\n     {\n-      rtx prev;\n-\n-      for (prev = PREV_INSN (a_end); ; prev = PREV_INSN (prev))\n-\tif (GET_CODE (prev) != NOTE\n-\t    || NOTE_LINE_NUMBER (prev) == NOTE_INSN_BASIC_BLOCK\n-\t    || prev == a->head)\n-\t  break;\n-\n-      del_first = a_end;\n-\n-#ifdef HAVE_cc0\n-      /* If this was a conditional jump, we need to also delete\n-\t the insn that set cc0.  */\n-      if (only_sets_cc0_p (prev))\n-\t{\n-\t  rtx tmp = prev;\n-\t  prev = prev_nonnote_insn (prev);\n-\t  if (!prev)\n-\t    prev = a->head;\n-\t  del_first = tmp;\n-\t}\n-#endif\n-\n-      a_end = PREV_INSN (del_first);\n-    }\n-  else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n-    del_first = NEXT_INSN (a_end);\n-\n-  /* Normally there should only be one successor of A and that is B, but\n-     partway though the merge of blocks for conditional_execution we'll\n-     be merging a TEST block with THEN and ELSE successors.  Free the\n-     whole lot of them and hope the caller knows what they're doing.  */\n-  while (a->succ)\n-    remove_edge (a->succ);\n-\n-  /* Adjust the edges out of B for the new owner.  */\n-  for (e = b->succ; e; e = e->succ_next)\n-    e->src = a;\n-  a->succ = b->succ;\n-\n-  /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n-  b->pred = b->succ = NULL;\n-\n-  expunge_block (b);\n-\n-  /* Delete everything marked above as well as crap that might be\n-     hanging out between the two blocks.  */\n-  delete_insn_chain (del_first, del_last);\n-\n-  /* Reassociate the insns of B with A.  */\n-  if (!b_empty)\n-    {\n-      rtx x = a_end;\n-      if (basic_block_for_insn)\n-\t{\n-\t  BLOCK_FOR_INSN (x) = a;\n-\t  while (x != b_end)\n-\t    {\n-\t      x = NEXT_INSN (x);\n-\t      BLOCK_FOR_INSN (x) = a;\n-\t    }\n-\t}\n-      a_end = b_end;\n-    }\n-  a->end = a_end;\n-}\n-\f\n-/* Return label in the head of basic block.  Create one if it doesn't exist.  */\n-\n-rtx\n-block_label (block)\n-     basic_block block;\n-{\n-  if (block == EXIT_BLOCK_PTR)\n-    return NULL_RTX;\n-  if (GET_CODE (block->head) != CODE_LABEL)\n-    {\n-      block->head = emit_label_before (gen_label_rtx (), block->head);\n-      if (basic_block_for_insn)\n-\tset_block_for_insn (block->head, block);\n-    }\n-  return block->head;\n-}\n-\n-/* Attempt to perform edge redirection by replacing possibly complex jump\n-   instruction by unconditional jump or removing jump completely.\n-   This can apply only if all edges now point to the same block.\n-\n-   The parameters and return values are equivalent to redirect_edge_and_branch.\n- */\n-\n-static bool\n-try_redirect_by_replacing_jump (e, target)\n-     edge e;\n-     basic_block target;\n-{\n-  basic_block src = e->src;\n-  rtx insn = src->end, kill_from;\n-  edge tmp;\n-  rtx set;\n-  int fallthru = 0;\n-\n-  /* Verify that all targets will be TARGET.  */\n-  for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n-    if (tmp->dest != target && tmp != e)\n-      break;\n-  if (tmp || !onlyjump_p (insn))\n-    return false;\n-\n-  /* Avoid removing branch with side effects.  */\n-  set = single_set (insn);\n-  if (!set || side_effects_p (set))\n-    return false;\n-\n-  /* In case we zap a conditional jump, we'll need to kill\n-     the cc0 setter too.  */\n-  kill_from = insn;\n-#ifdef HAVE_cc0\n-  if (reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n-    kill_from = PREV_INSN (insn);\n-#endif\n-\n-  /* See if we can create the fallthru edge.  */\n-  if (can_fallthru (src, target))\n-    {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n-      fallthru = 1;\n-\n-      /* Selectivly unlink whole insn chain.  */\n-      delete_insn_chain (kill_from, PREV_INSN (target->head));\n-    }\n-  /* If this already is simplejump, redirect it.  */\n-  else if (simplejump_p (insn))\n-    {\n-      if (e->dest == target)\n-\treturn false;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n-\t\t INSN_UID (insn), e->dest->index, target->index);\n-      redirect_jump (insn, block_label (target), 0);\n-    }\n-  /* Or replace possibly complicated jump insn by simple jump insn.  */\n-  else\n-    {\n-      rtx target_label = block_label (target);\n-      rtx barrier;\n-\n-      emit_jump_insn_after (gen_jump (target_label), kill_from);\n-      JUMP_LABEL (src->end) = target_label;\n-      LABEL_NUSES (target_label)++;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n-\t\t INSN_UID (insn), INSN_UID (src->end));\n-\n-      delete_insn_chain (kill_from, insn);\n-\n-      barrier = next_nonnote_insn (src->end);\n-      if (!barrier || GET_CODE (barrier) != BARRIER)\n-\temit_barrier_after (src->end);\n-    }\n-\n-  /* Keep only one edge out and set proper flags.  */\n-  while (src->succ->succ_next)\n-    remove_edge (src->succ);\n-  e = src->succ;\n-  if (fallthru)\n-    e->flags = EDGE_FALLTHRU;\n-  else\n-    e->flags = 0;\n-  e->probability = REG_BR_PROB_BASE;\n-  e->count = src->count;\n-\n-  /* We don't want a block to end on a line-number note since that has\n-     the potential of changing the code between -g and not -g.  */\n-  while (GET_CODE (e->src->end) == NOTE\n-\t && NOTE_LINE_NUMBER (e->src->end) >= 0)\n-    delete_insn (e->src->end);\n-\n-  if (e->dest != target)\n-    redirect_edge_succ (e, target);\n-  return true;\n-}\n-\n-/* Return last loop_beg note appearing after INSN, before start of next\n-   basic block.  Return INSN if there are no such notes.\n-\n-   When emmiting jump to redirect an fallthru edge, it should always\n-   appear after the LOOP_BEG notes, as loop optimizer expect loop to\n-   eighter start by fallthru edge or jump following the LOOP_BEG note\n-   jumping to the loop exit test.  */\n-\n-static rtx\n-last_loop_beg_note (insn)\n-     rtx insn;\n-{\n-  rtx last = insn;\n-  insn = NEXT_INSN (insn);\n-  while (insn && GET_CODE (insn) == NOTE\n-\t && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n-    {\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\tlast = insn;\n-      insn = NEXT_INSN (insn);\n-    }\n-  return last;\n-}\n-\n-/* Attempt to change code to redirect edge E to TARGET.\n-   Don't do that on expense of adding new instructions or reordering\n-   basic blocks.\n-\n-   Function can be also called with edge destionation equivalent to the\n-   TARGET.  Then it should try the simplifications and do nothing if\n-   none is possible.\n-\n-   Return true if transformation suceeded.  We still return flase in case\n-   E already destinated TARGET and we didn't managed to simplify instruction\n-   stream.  */\n-\n-bool\n-redirect_edge_and_branch (e, target)\n-     edge e;\n-     basic_block target;\n-{\n-  rtx tmp;\n-  rtx old_label = e->dest->head;\n-  basic_block src = e->src;\n-  rtx insn = src->end;\n-\n-  if (e->flags & EDGE_COMPLEX)\n-    return false;\n-\n-  if (try_redirect_by_replacing_jump (e, target))\n-    return true;\n-  /* Do this fast path late, as we want above code to simplify for cases\n-     where called on single edge leaving basic block containing nontrivial\n-     jump insn.  */\n-  else if (e->dest == target)\n-    return false;\n-\n-  /* We can only redirect non-fallthru edges of jump insn.  */\n-  if (e->flags & EDGE_FALLTHRU)\n-    return false;\n-  if (GET_CODE (insn) != JUMP_INSN)\n-    return false;\n-\n-  /* Recognize a tablejump and adjust all matching cases.  */\n-  if ((tmp = JUMP_LABEL (insn)) != NULL_RTX\n-      && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n-      && GET_CODE (tmp) == JUMP_INSN\n-      && (GET_CODE (PATTERN (tmp)) == ADDR_VEC\n-\t  || GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC))\n-    {\n-      rtvec vec;\n-      int j;\n-      rtx new_label = block_label (target);\n-\n-      if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n-\tvec = XVEC (PATTERN (tmp), 0);\n-      else\n-\tvec = XVEC (PATTERN (tmp), 1);\n-\n-      for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n-\tif (XEXP (RTVEC_ELT (vec, j), 0) == old_label)\n-\t  {\n-\t    RTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (Pmode, new_label);\n-\t    --LABEL_NUSES (old_label);\n-\t    ++LABEL_NUSES (new_label);\n-\t  }\n-\n-      /* Handle casesi dispatch insns */\n-      if ((tmp = single_set (insn)) != NULL\n-\t  && SET_DEST (tmp) == pc_rtx\n-\t  && GET_CODE (SET_SRC (tmp)) == IF_THEN_ELSE\n-\t  && GET_CODE (XEXP (SET_SRC (tmp), 2)) == LABEL_REF\n-\t  && XEXP (XEXP (SET_SRC (tmp), 2), 0) == old_label)\n-\t{\n-\t  XEXP (SET_SRC (tmp), 2) = gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t       new_label);\n-\t  --LABEL_NUSES (old_label);\n-\t  ++LABEL_NUSES (new_label);\n-\t}\n-    }\n-  else\n-    {\n-      /* ?? We may play the games with moving the named labels from\n-\t one basic block to the other in case only one computed_jump is\n-\t available.  */\n-      if (computed_jump_p (insn))\n-\treturn false;\n-\n-      /* A return instruction can't be redirected.  */\n-      if (returnjump_p (insn))\n-\treturn false;\n-\n-      /* If the insn doesn't go where we think, we're confused.  */\n-      if (JUMP_LABEL (insn) != old_label)\n-\tabort ();\n-      redirect_jump (insn, block_label (target), 0);\n-    }\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Edge %i->%i redirected to %i\\n\",\n-\t     e->src->index, e->dest->index, target->index);\n-  if (e->dest != target)\n-    redirect_edge_succ_nodup (e, target);\n-  return true;\n-}\n-\n-/* Like force_nonfallthru bellow, but additionally performs redirection\n-   Used by redirect_edge_and_branch_force.  */\n-\n-static basic_block\n-force_nonfallthru_and_redirect (e, target)\n-     edge e;\n-     basic_block target;\n-{\n-  basic_block jump_block, new_bb = NULL;\n-  rtx note;\n-  edge new_edge;\n-\n-  if (e->flags & EDGE_ABNORMAL)\n-    abort ();\n-  if (!(e->flags & EDGE_FALLTHRU))\n-    abort ();\n-  if (e->src->succ->succ_next)\n-    {\n-      /* Create the new structures.  */\n-      note = last_loop_beg_note (e->src->end);\n-      jump_block = create_basic_block (e->src->index + 1, NEXT_INSN (note), NULL);\n-      jump_block->count = e->count;\n-      jump_block->frequency = EDGE_FREQUENCY (e);\n-      jump_block->loop_depth = target->loop_depth;\n-\n-      if (target->global_live_at_start)\n-\t{\n-\t  jump_block->global_live_at_start =\n-\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-\t  jump_block->global_live_at_end =\n-\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-\t  COPY_REG_SET (jump_block->global_live_at_start,\n-\t\t\ttarget->global_live_at_start);\n-\t  COPY_REG_SET (jump_block->global_live_at_end,\n-\t\t\ttarget->global_live_at_start);\n-\t}\n-\n-      /* Wire edge in.  */\n-      new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n-      new_edge->probability = e->probability;\n-      new_edge->count = e->count;\n-\n-      /* Redirect old edge.  */\n-      redirect_edge_pred (e, jump_block);\n-      e->probability = REG_BR_PROB_BASE;\n-\n-      new_bb = jump_block;\n-    }\n-  else\n-    jump_block = e->src;\n-  e->flags &= ~EDGE_FALLTHRU;\n-  if (target == EXIT_BLOCK_PTR)\n-    {\n-      if (HAVE_return)\n-\temit_jump_insn_after (gen_return (), jump_block->end);\n-      else\n-\tabort ();\n-    }\n-  else\n-    {\n-      rtx label = block_label (target);\n-      emit_jump_insn_after (gen_jump (label), jump_block->end);\n-      JUMP_LABEL (jump_block->end) = label;\n-      LABEL_NUSES (label)++;\n-    }\n-  emit_barrier_after (jump_block->end);\n-  redirect_edge_succ_nodup (e, target);\n-\n-  return new_bb;\n-}\n-\n-/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction\n-   (and possibly create new basic block) to make edge non-fallthru.\n-   Return newly created BB or NULL if none.  */\n-basic_block\n-force_nonfallthru (e)\n-     edge e;\n-{\n-  return force_nonfallthru_and_redirect (e, e->dest);\n-}\n-\n-/* Redirect edge even at the expense of creating new jump insn or\n-   basic block.  Return new basic block if created, NULL otherwise.\n-   Abort if converison is impossible.  */\n-\n-basic_block\n-redirect_edge_and_branch_force (e, target)\n-     edge e;\n-     basic_block target;\n-{\n-  basic_block new_bb;\n-\n-  if (redirect_edge_and_branch (e, target))\n-    return NULL;\n-  if (e->dest == target)\n-    return NULL;\n-\n-  /* In case the edge redirection failed, try to force it to be non-fallthru\n-     and redirect newly created simplejump.  */\n-  new_bb = force_nonfallthru_and_redirect (e, target);\n-  return new_bb;\n-}\n-\n-/* The given edge should potentially be a fallthru edge.  If that is in\n-   fact true, delete the jump and barriers that are in the way.  */\n-\n-void\n-tidy_fallthru_edge (e, b, c)\n-     edge e;\n-     basic_block b, c;\n-{\n-  rtx q;\n-\n-  /* ??? In a late-running flow pass, other folks may have deleted basic\n-     blocks by nopping out blocks, leaving multiple BARRIERs between here\n-     and the target label. They ought to be chastized and fixed.\n-\n-     We can also wind up with a sequence of undeletable labels between\n-     one block and the next.\n-\n-     So search through a sequence of barriers, labels, and notes for\n-     the head of block C and assert that we really do fall through.  */\n-\n-  if (next_real_insn (b->end) != next_real_insn (PREV_INSN (c->head)))\n-    return;\n-\n-  /* Remove what will soon cease being the jump insn from the source block.\n-     If block B consisted only of this single jump, turn it into a deleted\n-     note.  */\n-  q = b->end;\n-  if (GET_CODE (q) == JUMP_INSN\n-      && onlyjump_p (q)\n-      && (any_uncondjump_p (q)\n-\t  || (b->succ == e && e->succ_next == NULL)))\n-    {\n-#ifdef HAVE_cc0\n-      /* If this was a conditional jump, we need to also delete\n-\t the insn that set cc0.  */\n-      if (any_condjump_p (q) && only_sets_cc0_p (PREV_INSN (q)))\n-\tq = PREV_INSN (q);\n-#endif\n-\n-      q = PREV_INSN (q);\n-\n-      /* We don't want a block to end on a line-number note since that has\n-\t the potential of changing the code between -g and not -g.  */\n-      while (GET_CODE (q) == NOTE && NOTE_LINE_NUMBER (q) >= 0)\n-\tq = PREV_INSN (q);\n-    }\n-\n-  /* Selectively unlink the sequence.  */\n-  if (q != PREV_INSN (c->head))\n-    delete_insn_chain (NEXT_INSN (q), PREV_INSN (c->head));\n-\n-  e->flags |= EDGE_FALLTHRU;\n-}\n-\n-/* Fix up edges that now fall through, or rather should now fall through\n-   but previously required a jump around now deleted blocks.  Simplify\n-   the search by only examining blocks numerically adjacent, since this\n-   is how find_basic_blocks created them.  */\n-\n-void\n-tidy_fallthru_edges ()\n-{\n-  int i;\n-\n-  for (i = 1; i < n_basic_blocks; ++i)\n-    {\n-      basic_block b = BASIC_BLOCK (i - 1);\n-      basic_block c = BASIC_BLOCK (i);\n-      edge s;\n-\n-      /* We care about simple conditional or unconditional jumps with\n-\t a single successor.\n-\n-\t If we had a conditional branch to the next instruction when\n-\t find_basic_blocks was called, then there will only be one\n-\t out edge for the block which ended with the conditional\n-\t branch (since we do not create duplicate edges).\n-\n-\t Furthermore, the edge will be marked as a fallthru because we\n-\t merge the flags for the duplicate edges.  So we do not want to\n-\t check that the edge is not a FALLTHRU edge.  */\n-      if ((s = b->succ) != NULL\n-\t  && ! (s->flags & EDGE_COMPLEX)\n-\t  && s->succ_next == NULL\n-\t  && s->dest == c\n-\t  /* If the jump insn has side effects, we can't tidy the edge.  */\n-\t  && (GET_CODE (b->end) != JUMP_INSN\n-\t      || onlyjump_p (b->end)))\n-\ttidy_fallthru_edge (s, b, c);\n-    }\n-}\n-\f\n-/* Helper function for split_edge.  Return true in case edge BB2 to BB1\n-   is back edge of syntactic loop.  */\n-\n-static bool\n-back_edge_of_syntactic_loop_p (bb1, bb2)\n-\tbasic_block bb1, bb2;\n-{\n-  rtx insn;\n-  int count = 0;\n-\n-  if (bb1->index > bb2->index)\n-    return false;\n-\n-  if (bb1->index == bb2->index)\n-    return true;\n-\n-  for (insn = bb1->end; insn != bb2->head && count >= 0;\n-       insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE)\n-      {\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t  count++;\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t  count--;\n-      }\n-\n-  return count >= 0;\n-}\n-\n-/* Split a (typically critical) edge.  Return the new block.\n-   Abort on abnormal edges.\n-\n-   ??? The code generally expects to be called on critical edges.\n-   The case of a block ending in an unconditional jump to a\n-   block with multiple predecessors is not handled optimally.  */\n-\n-basic_block\n-split_edge (edge_in)\n-     edge edge_in;\n-{\n-  basic_block bb;\n-  edge edge_out;\n-  rtx before;\n-\n-  /* Abnormal edges cannot be split.  */\n-  if ((edge_in->flags & EDGE_ABNORMAL) != 0)\n-    abort ();\n-\n-  /* We are going to place the new block in front of edge destination.\n-     Avoid existence of fallthru predecesors.  */\n-  if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n-    {\n-      edge e;\n-      for (e = edge_in->dest->pred; e; e = e->pred_next)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n-\n-      if (e)\n-\tforce_nonfallthru (e);\n-    }\n-\n-  /* Create the basic block note.\n-\n-     Where we place the note can have a noticable impact on the generated\n-     code.  Consider this cfg:\n-\n-\t\t        E\n-\t\t\t|\n-\t\t\t0\n-\t\t       / \\\n-\t\t   +->1-->2--->E\n-                   |  |\n-\t\t   +--+\n-\n-      If we need to insert an insn on the edge from block 0 to block 1,\n-      we want to ensure the instructions we insert are outside of any\n-      loop notes that physically sit between block 0 and block 1.  Otherwise\n-      we confuse the loop optimizer into thinking the loop is a phony.  */\n-\n-  if (edge_in->dest != EXIT_BLOCK_PTR\n-      && PREV_INSN (edge_in->dest->head)\n-      && GET_CODE (PREV_INSN (edge_in->dest->head)) == NOTE\n-      && NOTE_LINE_NUMBER (PREV_INSN (edge_in->dest->head)) == NOTE_INSN_LOOP_BEG\n-      && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n-    before = PREV_INSN (edge_in->dest->head);\n-  else if (edge_in->dest != EXIT_BLOCK_PTR)\n-    before = edge_in->dest->head;\n-  else\n-    before = NULL_RTX;\n-\n-  bb = create_basic_block (edge_in->dest == EXIT_BLOCK_PTR ? n_basic_blocks\n-\t\t\t   : edge_in->dest->index, before, NULL);\n-  bb->count = edge_in->count;\n-  bb->frequency = EDGE_FREQUENCY (edge_in);\n-\n-  /* ??? This info is likely going to be out of date very soon.  */\n-  if (edge_in->dest->global_live_at_start)\n-    {\n-      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n-      COPY_REG_SET (bb->global_live_at_start, edge_in->dest->global_live_at_start);\n-      COPY_REG_SET (bb->global_live_at_end, edge_in->dest->global_live_at_start);\n-    }\n-\n-  edge_out = make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n-\n-  /* For non-fallthry edges, we must adjust the predecessor's\n-     jump instruction to target our new block.  */\n-  if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n-    {\n-      if (!redirect_edge_and_branch (edge_in, bb))\n-\tabort ();\n-    }\n-  else\n-    redirect_edge_succ (edge_in, bb);\n-\n-  return bb;\n-}\n-\n-/* Queue instructions for insertion on an edge between two basic blocks.\n-   The new instructions and basic blocks (if any) will not appear in the\n-   CFG until commit_edge_insertions is called.  */\n-\n-void\n-insert_insn_on_edge (pattern, e)\n-     rtx pattern;\n-     edge e;\n-{\n-  /* We cannot insert instructions on an abnormal critical edge.\n-     It will be easier to find the culprit if we die now.  */\n-  if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n-    abort ();\n-\n-  if (e->insns == NULL_RTX)\n-    start_sequence ();\n-  else\n-    push_to_sequence (e->insns);\n-\n-  emit_insn (pattern);\n-\n-  e->insns = get_insns ();\n-  end_sequence ();\n-}\n-\n-/* Update the CFG for the instructions queued on edge E.  */\n-\n-static void\n-commit_one_edge_insertion (e)\n-     edge e;\n-{\n-  rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;\n-  basic_block bb;\n-\n-  /* Pull the insns off the edge now since the edge might go away.  */\n-  insns = e->insns;\n-  e->insns = NULL_RTX;\n-\n-  /* Figure out where to put these things.  If the destination has\n-     one predecessor, insert there.  Except for the exit block.  */\n-  if (e->dest->pred->pred_next == NULL\n-      && e->dest != EXIT_BLOCK_PTR)\n-    {\n-      bb = e->dest;\n-\n-      /* Get the location correct wrt a code label, and \"nice\" wrt\n-\t a basic block note, and before everything else.  */\n-      tmp = bb->head;\n-      if (GET_CODE (tmp) == CODE_LABEL)\n-\ttmp = NEXT_INSN (tmp);\n-      if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n-\ttmp = NEXT_INSN (tmp);\n-      if (tmp == bb->head)\n-\tbefore = tmp;\n-      else\n-\tafter = PREV_INSN (tmp);\n-    }\n-\n-  /* If the source has one successor and the edge is not abnormal,\n-     insert there.  Except for the entry block.  */\n-  else if ((e->flags & EDGE_ABNORMAL) == 0\n-\t   && e->src->succ->succ_next == NULL\n-\t   && e->src != ENTRY_BLOCK_PTR)\n-    {\n-      bb = e->src;\n-      /* It is possible to have a non-simple jump here.  Consider a target\n-\t where some forms of unconditional jumps clobber a register.  This\n-\t happens on the fr30 for example.\n-\n-\t We know this block has a single successor, so we can just emit\n-\t the queued insns before the jump.  */\n-      if (GET_CODE (bb->end) == JUMP_INSN)\n-\t{\n-\t  before = bb->end;\n-\t  while (GET_CODE (PREV_INSN (before)) == NOTE\n-\t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) == NOTE_INSN_LOOP_BEG)\n-\t    before = PREV_INSN (before);\n-\t}\n-      else\n-\t{\n-\t  /* We'd better be fallthru, or we've lost track of what's what.  */\n-\t  if ((e->flags & EDGE_FALLTHRU) == 0)\n-\t    abort ();\n-\n-\t  after = bb->end;\n-\t}\n-    }\n-\n-  /* Otherwise we must split the edge.  */\n-  else\n-    {\n-      bb = split_edge (e);\n-      after = bb->end;\n-    }\n-\n-  /* Now that we've found the spot, do the insertion.  */\n-\n-  if (before)\n-    {\n-      emit_insns_before (insns, before);\n-      last = prev_nonnote_insn (before);\n-    }\n-  else\n-    last = emit_insns_after (insns, after);\n-\n-  if (returnjump_p (last))\n-    {\n-      /* ??? Remove all outgoing edges from BB and add one for EXIT.\n-         This is not currently a problem because this only happens\n-\t for the (single) epilogue, which already has a fallthru edge\n-\t to EXIT.  */\n-\n-      e = bb->succ;\n-      if (e->dest != EXIT_BLOCK_PTR\n-\t  || e->succ_next != NULL\n-\t  || (e->flags & EDGE_FALLTHRU) == 0)\n-\tabort ();\n-      e->flags &= ~EDGE_FALLTHRU;\n-\n-      emit_barrier_after (last);\n-\n-      if (before)\n-\tdelete_insn (before);\n-    }\n-  else if (GET_CODE (last) == JUMP_INSN)\n-    abort ();\n-  find_sub_basic_blocks (bb);\n-}\n-\n-/* Update the CFG for all queued instructions.  */\n-\n-void\n-commit_edge_insertions ()\n-{\n-  int i;\n-  basic_block bb;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  i = -1;\n-  bb = ENTRY_BLOCK_PTR;\n-  while (1)\n-    {\n-      edge e, next;\n-\n-      for (e = bb->succ; e; e = next)\n-\t{\n-\t  next = e->succ_next;\n-\t  if (e->insns)\n-\t    commit_one_edge_insertion (e);\n-\t}\n-\n-      if (++i >= n_basic_blocks)\n-\tbreak;\n-      bb = BASIC_BLOCK (i);\n-    }\n-}\n-\f\n-void\n-dump_flow_info (file)\n-     FILE *file;\n-{\n-  register int i;\n-  static const char * const reg_class_names[] = REG_CLASS_NAMES;\n-\n-  fprintf (file, \"%d registers.\\n\", max_regno);\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (REG_N_REFS (i))\n-      {\n-\tenum reg_class class, altclass;\n-\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n-\tif (REG_BASIC_BLOCK (i) >= 0)\n-\t  fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n-\tif (REG_N_SETS (i))\n-\t  fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n-\t\t   (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n-\tif (REG_USERVAR_P (regno_reg_rtx[i]))\n-\t  fprintf (file, \"; user var\");\n-\tif (REG_N_DEATHS (i) != 1)\n-\t  fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n-\tif (REG_N_CALLS_CROSSED (i) == 1)\n-\t  fprintf (file, \"; crosses 1 call\");\n-\telse if (REG_N_CALLS_CROSSED (i))\n-\t  fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n-\tif (PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n-\t  fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n-\tclass = reg_preferred_class (i);\n-\taltclass = reg_alternate_class (i);\n-\tif (class != GENERAL_REGS || altclass != ALL_REGS)\n-\t  {\n-\t    if (altclass == ALL_REGS || class == ALL_REGS)\n-\t      fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n-\t    else if (altclass == NO_REGS)\n-\t      fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n-\t    else\n-\t      fprintf (file, \"; pref %s, else %s\",\n-\t\t       reg_class_names[(int) class],\n-\t\t       reg_class_names[(int) altclass]);\n-\t  }\n-\tif (REG_POINTER (regno_reg_rtx[i]))\n-\t  fprintf (file, \"; pointer\");\n-\tfprintf (file, \".\\n\");\n-      }\n-\n-  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      register basic_block bb = BASIC_BLOCK (i);\n-      register edge e;\n-\n-      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count \",\n-\t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth);\n-      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n-      fprintf (file, \", freq %i.\\n\", bb->frequency);\n-\n-      fprintf (file, \"Predecessors: \");\n-      for (e = bb->pred; e; e = e->pred_next)\n-\tdump_edge_info (file, e, 0);\n-\n-      fprintf (file, \"\\nSuccessors: \");\n-      for (e = bb->succ; e; e = e->succ_next)\n-\tdump_edge_info (file, e, 1);\n-\n-      fprintf (file, \"\\nRegisters live at start:\");\n-      dump_regset (bb->global_live_at_start, file);\n-\n-      fprintf (file, \"\\nRegisters live at end:\");\n-      dump_regset (bb->global_live_at_end, file);\n-\n-      putc ('\\n', file);\n-    }\n-\n-  putc ('\\n', file);\n-}\n-\n-void\n-debug_flow_info ()\n-{\n-  dump_flow_info (stderr);\n-}\n-\n-void\n-dump_edge_info (file, e, do_succ)\n-     FILE *file;\n-     edge e;\n-     int do_succ;\n-{\n-  basic_block side = (do_succ ? e->dest : e->src);\n-\n-  if (side == ENTRY_BLOCK_PTR)\n-    fputs (\" ENTRY\", file);\n-  else if (side == EXIT_BLOCK_PTR)\n-    fputs (\" EXIT\", file);\n-  else\n-    fprintf (file, \" %d\", side->index);\n-\n-  if (e->probability)\n-    fprintf (file, \" [%.1f%%] \", e->probability * 100.0 / REG_BR_PROB_BASE);\n-\n-  if (e->count)\n-    {\n-      fprintf (file, \" count:\");\n-      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) e->count);\n-    }\n-\n-  if (e->flags)\n-    {\n-      static const char * const bitnames[] = {\n-\t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"\n-      };\n-      int comma = 0;\n-      int i, flags = e->flags;\n+      static const char * const bitnames[] = {\n+\t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"\n+      };\n+      int comma = 0;\n+      int i, flags = e->flags;\n \n       fputc (' ', file);\n       fputc ('(', file);\n@@ -1849,584 +541,146 @@ dump_edge_info (file, e, do_succ)\n     }\n }\n \f\n-/* Print out one basic block with live information at start and end.  */\n-\n-void\n-dump_bb (bb, outf)\n-     basic_block bb;\n-     FILE *outf;\n-{\n-  rtx insn;\n-  rtx last;\n-  edge e;\n+/* Simple routies to easilly allocate AUX fields of basic blocks.  */\n+static struct obstack block_aux_obstack;\n+static void *first_block_aux_obj = 0;\n+static struct obstack edge_aux_obstack;\n+static void *first_edge_aux_obj = 0;\n \n-  fprintf (outf, \";; Basic block %d, loop depth %d, count \",\n-\t   bb->index, bb->loop_depth);\n-  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n-  putc ('\\n', outf);\n-\n-  fputs (\";; Predecessors: \", outf);\n-  for (e = bb->pred; e; e = e->pred_next)\n-    dump_edge_info (outf, e, 0);\n-  putc ('\\n', outf);\n-\n-  fputs (\";; Registers live at start:\", outf);\n-  dump_regset (bb->global_live_at_start, outf);\n-  putc ('\\n', outf);\n-\n-  for (insn = bb->head, last = NEXT_INSN (bb->end);\n-       insn != last;\n-       insn = NEXT_INSN (insn))\n-    print_rtl_single (outf, insn);\n-\n-  fputs (\";; Registers live at end:\", outf);\n-  dump_regset (bb->global_live_at_end, outf);\n-  putc ('\\n', outf);\n-\n-  fputs (\";; Successors: \", outf);\n-  for (e = bb->succ; e; e = e->succ_next)\n-    dump_edge_info (outf, e, 1);\n-  putc ('\\n', outf);\n-}\n+/* Allocate an memory block of SIZE as BB->aux.  The obstack must\n+   be first initialized by alloc_aux_for_blocks.  */\n \n-void\n-debug_bb (bb)\n+inline void\n+alloc_aux_for_block (bb, size)\n      basic_block bb;\n+     int size;\n {\n-  dump_bb (bb, stderr);\n-}\n-\n-void\n-debug_bb_n (n)\n-     int n;\n-{\n-  dump_bb (BASIC_BLOCK (n), stderr);\n+  /* Verify that aux field is clear.  */\n+  if (bb->aux || !first_block_aux_obj)\n+    abort ();\n+  bb->aux = obstack_alloc (&block_aux_obstack, size);\n+  memset (bb->aux, 0, size);\n }\n \n-/* Like print_rtl, but also print out live information for the start of each\n-   basic block.  */\n+/* Initialize the block_aux_obstack and if SIZE is nonzero, call\n+   alloc_aux_for_block for each basic block.  */\n \n void\n-print_rtl_with_bb (outf, rtx_first)\n-     FILE *outf;\n-     rtx rtx_first;\n+alloc_aux_for_blocks (size)\n+     int size;\n {\n-  register rtx tmp_rtx;\n+  static int initialized;\n \n-  if (rtx_first == 0)\n-    fprintf (outf, \"(nil)\\n\");\n-  else\n+  if (!initialized)\n     {\n-      int i;\n-      enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n-      int max_uid = get_max_uid ();\n-      basic_block *start = (basic_block *)\n-\txcalloc (max_uid, sizeof (basic_block));\n-      basic_block *end = (basic_block *)\n-\txcalloc (max_uid, sizeof (basic_block));\n-      enum bb_state *in_bb_p = (enum bb_state *)\n-\txcalloc (max_uid, sizeof (enum bb_state));\n-\n-      for (i = n_basic_blocks - 1; i >= 0; i--)\n-\t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n-\t  rtx x;\n-\n-\t  start[INSN_UID (bb->head)] = bb;\n-\t  end[INSN_UID (bb->end)] = bb;\n-\t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n-\t    {\n-\t      enum bb_state state = IN_MULTIPLE_BB;\n-\t      if (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n-\t\tstate = IN_ONE_BB;\n-\t      in_bb_p[INSN_UID (x)] = state;\n-\n-\t      if (x == bb->end)\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-      for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n-\t{\n-\t  int did_output;\n-\t  basic_block bb;\n-\n-\t  if ((bb = start[INSN_UID (tmp_rtx)]) != NULL)\n-\t    {\n-\t      fprintf (outf, \";; Start of basic block %d, registers live:\",\n-\t\t       bb->index);\n-\t      dump_regset (bb->global_live_at_start, outf);\n-\t      putc ('\\n', outf);\n-\t    }\n-\n-\t  if (in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB\n-\t      && GET_CODE (tmp_rtx) != NOTE\n-\t      && GET_CODE (tmp_rtx) != BARRIER)\n-\t    fprintf (outf, \";; Insn is not within a basic block\\n\");\n-\t  else if (in_bb_p[INSN_UID (tmp_rtx)] == IN_MULTIPLE_BB)\n-\t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");\n-\n-\t  did_output = print_rtl_single (outf, tmp_rtx);\n-\n-\t  if ((bb = end[INSN_UID (tmp_rtx)]) != NULL)\n-\t    {\n-\t      fprintf (outf, \";; End of basic block %d, registers live:\\n\",\n-\t\t       bb->index);\n-\t      dump_regset (bb->global_live_at_end, outf);\n-\t      putc ('\\n', outf);\n-\t    }\n-\n-\t  if (did_output)\n-\t    putc ('\\n', outf);\n-\t}\n-\n-      free (start);\n-      free (end);\n-      free (in_bb_p);\n+      gcc_obstack_init (&block_aux_obstack);\n+      initialized = 1;\n     }\n-\n-  if (current_function_epilogue_delay_list != 0)\n+  /* Check whether AUX data are still allocated.  */\n+  else if (first_block_aux_obj)\n+    abort ();\n+  first_block_aux_obj = (char *) obstack_alloc (&block_aux_obstack, 0);\n+  if (size)\n     {\n-      fprintf (outf, \"\\n;; Insns in epilogue delay list:\\n\\n\");\n-      for (tmp_rtx = current_function_epilogue_delay_list; tmp_rtx != 0;\n-\t   tmp_rtx = XEXP (tmp_rtx, 1))\n-\tprint_rtl_single (outf, XEXP (tmp_rtx, 0));\n+      int i;\n+      for (i = 0; i < n_basic_blocks; i++)\n+\talloc_aux_for_block (BASIC_BLOCK (i), size);\n+      alloc_aux_for_block (ENTRY_BLOCK_PTR, size);\n+      alloc_aux_for_block (EXIT_BLOCK_PTR, size);\n     }\n }\n-\f\n-/* Verify the CFG consistency.  This function check some CFG invariants and\n-   aborts when something is wrong.  Hope that this function will help to\n-   convert many optimization passes to preserve CFG consistent.\n-\n-   Currently it does following checks:\n-\n-   - test head/end pointers\n-   - overlapping of basic blocks\n-   - edge list correctness\n-   - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n-   - tails of basic blocks (ensure that boundary is necesary)\n-   - scans body of the basic block for JUMP_INSN, CODE_LABEL\n-     and NOTE_INSN_BASIC_BLOCK\n-   - check that all insns are in the basic blocks\n-   (except the switch handling code, barriers and notes)\n-   - check that all returns are followed by barriers\n-\n-   In future it can be extended check a lot of other stuff as well\n-   (reachability of basic blocks, life information, etc. etc.).  */\n+\n+/* Free data allocated in block_aux_obstack and clear AUX pointers\n+   of all blocks.  */\n \n void\n-verify_flow_info ()\n+free_aux_for_blocks ()\n {\n-  const int max_uid = get_max_uid ();\n-  const rtx rtx_first = get_insns ();\n-  rtx last_head = get_last_insn ();\n-  basic_block *bb_info, *last_visited;\n-  size_t *edge_checksum;\n-  rtx x;\n-  int i, last_bb_num_seen, num_bb_notes, err = 0;\n-\n-  bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n-  last_visited = (basic_block *) xcalloc (n_basic_blocks + 2,\n-\t\t\t\t\t  sizeof (basic_block));\n-  edge_checksum = (size_t *) xcalloc (n_basic_blocks + 2, sizeof (size_t));\n-\n-  for (i = n_basic_blocks - 1; i >= 0; i--)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      rtx head = bb->head;\n-      rtx end = bb->end;\n-\n-      /* Verify the end of the basic block is in the INSN chain.  */\n-      for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n-\tif (x == end)\n-\t  break;\n-      if (!x)\n-\t{\n-\t  error (\"End insn %d for block %d not found in the insn stream.\",\n-\t\t INSN_UID (end), bb->index);\n-\t  err = 1;\n-\t}\n+  int i;\n \n-      /* Work backwards from the end to the head of the basic block\n-\t to verify the head is in the RTL chain.  */\n-      for (; x != NULL_RTX; x = PREV_INSN (x))\n-\t{\n-\t  /* While walking over the insn chain, verify insns appear\n-\t     in only one basic block and initialize the BB_INFO array\n-\t     used by other passes.  */\n-\t  if (bb_info[INSN_UID (x)] != NULL)\n-\t    {\n-\t      error (\"Insn %d is in multiple basic blocks (%d and %d)\",\n-\t\t     INSN_UID (x), bb->index, bb_info[INSN_UID (x)]->index);\n-\t      err = 1;\n-\t    }\n-\t  bb_info[INSN_UID (x)] = bb;\n-\n-\t  if (x == head)\n-\t    break;\n-\t}\n-      if (!x)\n-\t{\n-\t  error (\"Head insn %d for block %d not found in the insn stream.\",\n-\t\t INSN_UID (head), bb->index);\n-\t  err = 1;\n-\t}\n+  if (!first_block_aux_obj)\n+    abort ();\n+  obstack_free (&block_aux_obstack, first_block_aux_obj);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BASIC_BLOCK (i)->aux = NULL;\n+  ENTRY_BLOCK_PTR->aux = NULL;\n+  EXIT_BLOCK_PTR->aux = NULL;\n+  first_block_aux_obj = NULL;\n+}\n \n-      last_head = x;\n-    }\n+/* Allocate an memory edge of SIZE as BB->aux.  The obstack must\n+   be first initialized by alloc_aux_for_edges.  */\n \n-  /* Now check the basic blocks (boundaries etc.) */\n-  for (i = n_basic_blocks - 1; i >= 0; i--)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      int has_fallthru = 0;\n-      edge e;\n+inline void\n+alloc_aux_for_edge (e, size)\n+     edge e;\n+     int size;\n+{\n+  /* Verify that aux field is clear.  */\n+  if (e->aux || !first_edge_aux_obj)\n+    abort ();\n+  e->aux = obstack_alloc (&edge_aux_obstack, size);\n+  memset (e->aux, 0, size);\n+}\n \n-      e = bb->succ;\n-      while (e)\n-\t{\n-\t  if (last_visited [e->dest->index + 2] == bb)\n-\t    {\n-\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n-\t\t     e->src->index, e->dest->index);\n-\t      err = 1;\n-\t    }\n-\t  last_visited [e->dest->index + 2] = bb;\n-\n-\t  if (e->flags & EDGE_FALLTHRU)\n-\t    has_fallthru = 1;\n-\n-\t  if ((e->flags & EDGE_FALLTHRU)\n-\t      && e->src != ENTRY_BLOCK_PTR\n-\t      && e->dest != EXIT_BLOCK_PTR)\n-\t    {\n-\t      rtx insn;\n-\t      if (e->src->index + 1 != e->dest->index)\n-\t\t{\n-\t\t    error (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n-\t\t\t   e->src->index, e->dest->index);\n-\t\t    err = 1;\n-\t\t}\n-\t      else\n-\t\tfor (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n-\t\t     insn = NEXT_INSN (insn))\n-\t\t  if (GET_CODE (insn) == BARRIER || INSN_P (insn))\n-\t\t    {\n-\t\t      error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n-\t\t\t     e->src->index, e->dest->index);\n-\t\t      fatal_insn (\"Wrong insn in the fallthru edge\", insn);\n-\t\t      err = 1;\n-\t\t    }\n-\t    }\n-\t  if (e->src != bb)\n-\t    {\n-\t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n-\t\t     bb->index);\n-\t      fprintf (stderr, \"Predecessor: \");\n-\t      dump_edge_info (stderr, e, 0);\n-\t      fprintf (stderr, \"\\nSuccessor: \");\n-\t      dump_edge_info (stderr, e, 1);\n-\t      fprintf (stderr, \"\\n\");\n-\t      err = 1;\n-\t    }\n-\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n-\t  e = e->succ_next;\n-\t}\n-      if (!has_fallthru)\n-\t{\n-\t  rtx insn = bb->end;\n-\n-\t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n-\t  for (insn = bb->end; GET_CODE (insn) != BARRIER;\n-\t       insn = NEXT_INSN (insn))\n-\t    if (!insn\n-\t\t|| (GET_CODE (insn) == NOTE\n-\t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n-\t\t{\n-\t\t  error (\"Missing barrier after block %i\", bb->index);\n-\t\t  err = 1;\n-\t\t}\n-\t}\n+/* Initialize the edge_aux_obstack and if SIZE is nonzero, call\n+   alloc_aux_for_edge for each basic edge.  */\n \n-      e = bb->pred;\n-      while (e)\n-\t{\n-\t  if (e->dest != bb)\n-\t    {\n-\t      error (\"Basic block %d pred edge is corrupted\", bb->index);\n-\t      fputs (\"Predecessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 0);\n-\t      fputs (\"\\nSuccessor: \", stderr);\n-\t      dump_edge_info (stderr, e, 1);\n-\t      fputc ('\\n', stderr);\n-\t      err = 1;\n-\t    }\n-\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n-\t  e = e->pred_next;\n-\t}\n-       for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n-\t if (basic_block_for_insn && BLOCK_FOR_INSN (x) != bb)\n-\t   {\n-\t     debug_rtx (x);\n-\t     if (! BLOCK_FOR_INSN (x))\n-\t       error (\"Insn %d is inside basic block %d but block_for_insn is NULL\",\n-\t\t      INSN_UID (x), bb->index);\n-\t     else\n-\t       error (\"Insn %d is inside basic block %d but block_for_insn is %i\",\n-\t\t      INSN_UID (x), bb->index, BLOCK_FOR_INSN (x)->index);\n-\t     err = 1;\n-\t   }\n-\n-      /* OK pointers are correct.  Now check the header of basic\n-         block.  It ought to contain optional CODE_LABEL followed\n-\t by NOTE_BASIC_BLOCK.  */\n-      x = bb->head;\n-      if (GET_CODE (x) == CODE_LABEL)\n-\t{\n-\t  if (bb->end == x)\n-\t    {\n-\t      error (\"NOTE_INSN_BASIC_BLOCK is missing for block %d\",\n-\t\t     bb->index);\n-\t      err = 1;\n-\t    }\n-\t  x = NEXT_INSN (x);\n-\t}\n-      if (!NOTE_INSN_BASIC_BLOCK_P (x) || NOTE_BASIC_BLOCK (x) != bb)\n-\t{\n-\t  error (\"NOTE_INSN_BASIC_BLOCK is missing for block %d\",\n-\t\t bb->index);\n-\t  err = 1;\n-\t}\n+void\n+alloc_aux_for_edges (size)\n+     int size;\n+{\n+  static int initialized;\n \n-      if (bb->end == x)\n-\t{\n-\t  /* Do checks for empty blocks here */\n-\t}\n-      else\n-\t{\n-\t  x = NEXT_INSN (x);\n-\t  while (x)\n-\t    {\n-\t      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\t\t{\n-\t\t  error (\"NOTE_INSN_BASIC_BLOCK %d in the middle of basic block %d\",\n-\t\t\t INSN_UID (x), bb->index);\n-\t\t  err = 1;\n-\t\t}\n-\n-\t      if (x == bb->end)\n-\t\tbreak;\n-\n-\t      if (GET_CODE (x) == JUMP_INSN\n-\t\t  || GET_CODE (x) == CODE_LABEL\n-\t\t  || GET_CODE (x) == BARRIER)\n-\t\t{\n-\t\t  error (\"In basic block %d:\", bb->index);\n-\t\t  fatal_insn (\"Flow control insn inside a basic block\", x);\n-\t\t}\n-\n-\t      x = NEXT_INSN (x);\n-\t    }\n-\t}\n+  if (!initialized)\n+    {\n+      gcc_obstack_init (&edge_aux_obstack);\n+      initialized = 1;\n     }\n-\n-  /* Complete edge checksumming for ENTRY and EXIT.  */\n-  {\n-    edge e;\n-    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n-      edge_checksum[e->dest->index + 2] += (size_t) e;\n-    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n-      edge_checksum[e->dest->index + 2] -= (size_t) e;\n-  }\n-\n-  for (i = -2; i < n_basic_blocks; ++i)\n-    if (edge_checksum[i + 2])\n-      {\n-\terror (\"Basic block %i edge lists are corrupted\", i);\n-\terr = 1;\n-      }\n-\n-  last_bb_num_seen = -1;\n-  num_bb_notes = 0;\n-  x = rtx_first;\n-  while (x)\n+  /* Check whether AUX data are still allocated.  */\n+  else if (first_edge_aux_obj)\n+    abort ();\n+  first_edge_aux_obj = (char *) obstack_alloc (&edge_aux_obstack, 0);\n+  if (size)\n     {\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\t{\n-\t  basic_block bb = NOTE_BASIC_BLOCK (x);\n-\t  num_bb_notes++;\n-\t  if (bb->index != last_bb_num_seen + 1)\n-\t    internal_error (\"Basic blocks not numbered consecutively.\");\n-\n-\t  last_bb_num_seen = bb->index;\n-\t}\n-\n-      if (!bb_info[INSN_UID (x)])\n+      int i;\n+      for (i = -1; i < n_basic_blocks; i++)\n \t{\n-\t  switch (GET_CODE (x))\n-\t    {\n-\t    case BARRIER:\n-\t    case NOTE:\n-\t      break;\n-\n-\t    case CODE_LABEL:\n-\t      /* An addr_vec is placed outside any block block.  */\n-\t      if (NEXT_INSN (x)\n-\t\t  && GET_CODE (NEXT_INSN (x)) == JUMP_INSN\n-\t\t  && (GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_DIFF_VEC\n-\t\t      || GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_VEC))\n-\t\t{\n-\t\t  x = NEXT_INSN (x);\n-\t\t}\n-\n-\t      /* But in any case, non-deletable labels can appear anywhere.  */\n-\t      break;\n-\n-\t    default:\n-\t      fatal_insn (\"Insn outside basic block\", x);\n-\t    }\n+\t  basic_block bb;\n+\t  edge e;\n+\n+\t  if (i >= 0)\n+\t    bb = BASIC_BLOCK (i);\n+\t  else\n+\t    bb = ENTRY_BLOCK_PTR;\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    alloc_aux_for_edge (e, size);\n \t}\n-\n-      if (INSN_P (x)\n-\t  && GET_CODE (x) == JUMP_INSN\n-\t  && returnjump_p (x) && ! condjump_p (x)\n-\t  && ! (NEXT_INSN (x) && GET_CODE (NEXT_INSN (x)) == BARRIER))\n-\t    fatal_insn (\"Return not followed by barrier\", x);\n-\n-      x = NEXT_INSN (x);\n     }\n-\n-  if (num_bb_notes != n_basic_blocks)\n-    internal_error\n-      (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n-       num_bb_notes, n_basic_blocks);\n-\n-  if (err)\n-    internal_error (\"verify_flow_info failed.\");\n-\n-  /* Clean up.  */\n-  free (bb_info);\n-  free (last_visited);\n-  free (edge_checksum);\n }\n-\f\n-/* Assume that the preceeding pass has possibly eliminated jump instructions\n-   or converted the unconditional jumps.  Eliminate the edges from CFG.\n-   Return true if any edges are eliminated.  */\n \n-bool\n-purge_dead_edges (bb)\n-     basic_block bb;\n+/* Free data allocated in edge_aux_obstack and clear AUX pointers\n+   of all edges.  */\n+\n+void\n+free_aux_for_edges ()\n {\n-  edge e, next;\n-  rtx insn = bb->end;\n-  bool purged = false;\n+  int i;\n \n-  if (GET_CODE (insn) == JUMP_INSN && !simplejump_p (insn))\n-    return false;\n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (!first_edge_aux_obj)\n+    abort ();\n+  obstack_free (&edge_aux_obstack, first_edge_aux_obj);\n+  for (i = -1; i < n_basic_blocks; i++)\n     {\n-      rtx note;\n-      edge b,f;\n-      /* We do care only about conditional jumps and simplejumps.  */\n-      if (!any_condjump_p (insn)\n-\t  && !returnjump_p (insn)\n-\t  && !simplejump_p (insn))\n-\treturn false;\n-      for (e = bb->succ; e; e = next)\n-\t{\n-\t  next = e->succ_next;\n-\n-\t  /* Check purposes we can have edge.  */\n-\t  if ((e->flags & EDGE_FALLTHRU)\n-\t      && any_condjump_p (insn))\n-\t    continue;\n-\t  if (e->dest != EXIT_BLOCK_PTR\n-\t      && e->dest->head == JUMP_LABEL (insn))\n-\t    continue;\n-\t  if (e->dest == EXIT_BLOCK_PTR\n-\t      && returnjump_p (insn))\n-\t    continue;\n-\t  purged = true;\n-\t  remove_edge (e);\n-\t}\n-      if (!bb->succ || !purged)\n-\treturn false;\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"Purged edges from bb %i\\n\", bb->index);\n-      if (!optimize)\n-\treturn purged;\n-\n-      /* Redistribute probabilities.  */\n-      if (!bb->succ->succ_next)\n-\t{\n-\t  bb->succ->probability = REG_BR_PROB_BASE;\n-\t  bb->succ->count = bb->count;\n-        }\n-      else\n-\t{\n-\t  note = find_reg_note (insn, REG_BR_PROB, NULL);\n-\t  if (!note)\n-\t    return purged;\n-\t  b = BRANCH_EDGE (bb);\n-\t  f = FALLTHRU_EDGE (bb);\n-\t  b->probability = INTVAL (XEXP (note, 0));\n-\t  f->probability = REG_BR_PROB_BASE - b->probability;\n-\t  b->count = bb->count * b->probability / REG_BR_PROB_BASE;\n-\t  f->count = bb->count * f->probability / REG_BR_PROB_BASE;\n-\t}\n-      return purged;\n-    }\n-\n-  /* Cleanup abnormal edges caused by throwing insns that have been\n-     eliminated.  */\n-  if (! can_throw_internal (bb->end))\n-    for (e = bb->succ; e; e = next)\n-      {\n-\tnext = e->succ_next;\n-\tif (e->flags & EDGE_EH)\n-\t  {\n-\t    remove_edge (e);\n-\t    purged = true;\n-\t  }\n-      }\n+      basic_block bb;\n+      edge e;\n \n-  /* If we don't see a jump insn, we don't know exactly why the block would\n-     have been broken at this point.  Look for a simple, non-fallthru edge,\n-     as these are only created by conditional branches.  If we find such an\n-     edge we know that there used to be a jump here and can then safely\n-     remove all non-fallthru edges.  */\n-  for (e = bb->succ; e && (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU));\n-       e = e->succ_next);\n-  if (!e)\n-    return purged;\n-  for (e = bb->succ; e; e = next)\n-    {\n-      next = e->succ_next;\n-      if (!(e->flags & EDGE_FALLTHRU))\n-\tremove_edge (e), purged = true;\n+      if (i >= 0)\n+\tbb = BASIC_BLOCK (i);\n+      else\n+\tbb = ENTRY_BLOCK_PTR;\n+      for (e = bb->succ; e; e = e->succ_next)\n+\te->aux = NULL;\n     }\n-  if (!bb->succ || bb->succ->succ_next)\n-    abort ();\n-  bb->succ->probability = REG_BR_PROB_BASE;\n-  bb->succ->count = bb->count;\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n-\t     bb->index);\n-  return purged;\n-}\n-\n-/* Search all basic blocks for potentionally dead edges and purge them.\n-\n-   Return true ifif some edge has been elliminated.\n- */\n-\n-bool\n-purge_all_dead_edges ()\n-{\n-  int i, purged = false;\n-  for (i = 0; i < n_basic_blocks; i++)\n-    purged |= purge_dead_edges (BASIC_BLOCK (i));\n-  return purged;\n+  first_edge_aux_obj = NULL;\n }"}, {"sha": "a9a8ec16c2cee7bfbd328fa445dfe4b3e148daf2", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -106,14 +106,9 @@ try_simplify_condjump (cbranch_block)\n   if (!can_fallthru (jump_block, cbranch_dest_block))\n     return false;\n \n-  /* Invert the conditional branch.  Prevent jump.c from deleting\n-     \"unreachable\" instructions.  */\n-  LABEL_NUSES (JUMP_LABEL (cbranch_insn))++;\n-  if (!invert_jump (cbranch_insn, block_label (jump_dest_block), 1))\n-    {\n-      LABEL_NUSES (JUMP_LABEL (cbranch_insn))--;\n-      return false;\n-    }\n+  /* Invert the conditional branch.  */\n+  if (!invert_jump (cbranch_insn, block_label (jump_dest_block), 0))\n+    return false;\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Simplifying condjump %i around jump %i\\n\",\n@@ -1054,6 +1049,9 @@ try_optimize_cfg (mode)\n   bool changed;\n   int iterations = 0;\n \n+  if (mode & CLEANUP_CROSSJUMP)\n+    add_noreturn_fake_exit_edges ();\n+\n   /* Attempt to merge blocks as made possible by edge removal.  If a block\n      has only one successor, and the successor has only one predecessor,\n      they may be combined.  */\n@@ -1184,6 +1182,10 @@ try_optimize_cfg (mode)\n       changed_overall |= changed;\n     }\n   while (changed);\n+\n+  if (mode & CLEANUP_CROSSJUMP)\n+    remove_fake_edges ();\n+\n   return changed_overall;\n }\n \f"}, {"sha": "953ff80dc83464992e3518374e3f81b0944fc6e5", "filename": "gcc/cfgrtl.c", "status": "added", "additions": 1928, "deletions": 0, "changes": 1928, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -0,0 +1,1928 @@\n+/* Control flow graph manipulation code for GNU compiler.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This file contains low level functions to manipulate with CFG and analyze it\n+   that are aware of RTL intermediate language.\n+\n+   Available functionality:\n+     - CFG aware instruction chain manipulation\n+\t delete_insn, delete_insn_chain\n+     - Basic block manipulation\n+\t create_basic_block, flow_delete_block, split_block, merge_blocks_nomove\n+     - Infrastructure to determine quickly basic block for instruction.\n+\t compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n+     - Edge redirection with updating and optimizing instruction chain\n+\t     block_label, redirect_edge_and_branch,\n+\t     redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n+     - Edge splitting and commiting to edges\n+\t  split_edge, insert_insn_on_edge, commit_edge_insertions\n+     - Dumpipng and debugging\n+\t  print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n+     - Consistency checking\n+\t  verify_flow_info\n+     - CFG updating after constant propagation\n+\t  purge_dead_edges, purge_all_dead_edges\n+ */\n+\f\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"regs.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"except.h\"\n+#include \"toplev.h\"\n+#include \"tm_p.h\"\n+#include \"obstack.h\"\n+\n+/* Stubs in case we haven't got a return insn.  */\n+#ifndef HAVE_return\n+#define HAVE_return 0\n+#define gen_return() NULL_RTX\n+#endif\n+\n+/* The basic block structure for every insn, indexed by uid.  */\n+\n+varray_type basic_block_for_insn;\n+\n+/* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n+/* ??? Should probably be using LABEL_NUSES instead.  It would take a\n+   bit of surgery to be able to use or co-opt the routines in jump.  */\n+\n+rtx label_value_list;\n+rtx tail_recursion_label_list;\n+\n+static int can_delete_note_p\t\tPARAMS ((rtx));\n+static int can_delete_label_p\t\tPARAMS ((rtx));\n+static void commit_one_edge_insertion\tPARAMS ((edge));\n+static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n+static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n+static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n+static basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n+\f\n+/* Return true if NOTE is not one of the ones that must be kept paired,\n+   so that we may simply delete them.  */\n+\n+static int\n+can_delete_note_p (note)\n+     rtx note;\n+{\n+  return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n+\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK);\n+}\n+\n+/* True if a given label can be deleted.  */\n+\n+static int\n+can_delete_label_p (label)\n+     rtx label;\n+{\n+  rtx x;\n+\n+  if (LABEL_PRESERVE_P (label))\n+    return 0;\n+\n+  for (x = forced_labels; x; x = XEXP (x, 1))\n+    if (label == XEXP (x, 0))\n+      return 0;\n+  for (x = label_value_list; x; x = XEXP (x, 1))\n+    if (label == XEXP (x, 0))\n+      return 0;\n+  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n+    if (label == XEXP (x, 0))\n+      return 0;\n+\n+  /* User declared labels must be preserved.  */\n+  if (LABEL_NAME (label) != 0)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Delete INSN by patching it out.  Return the next insn.  */\n+\n+rtx\n+delete_insn (insn)\n+     rtx insn;\n+{\n+  rtx next = NEXT_INSN (insn);\n+  rtx note;\n+  bool really_delete = true;\n+\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    {\n+      /* Some labels can't be directly removed from the INSN chain, as they\n+         might be references via variables, constant pool etc. \n+         Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n+      if (! can_delete_label_p (insn))\n+\t{\n+\t  const char *name = LABEL_NAME (insn);\n+\n+\t  really_delete = false;\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n+\t  NOTE_SOURCE_FILE (insn) = name;\n+\t}\n+      remove_node_from_expr_list (insn, &nonlocal_goto_handler_labels);\n+    }\n+\n+  if (really_delete)\n+    {\n+      remove_insn (insn);\n+      INSN_DELETED_P (insn) = 1;\n+    }\n+\n+  /* If deleting a jump, decrement the use count of the label.  Deleting\n+     the label itself should happen in the normal course of block merging.  */\n+  if (GET_CODE (insn) == JUMP_INSN\n+      && JUMP_LABEL (insn)\n+      && GET_CODE (JUMP_LABEL (insn)) == CODE_LABEL)\n+    LABEL_NUSES (JUMP_LABEL (insn))--;\n+\n+  /* Also if deleting an insn that references a label.  */\n+  else if ((note = find_reg_note (insn, REG_LABEL, NULL_RTX)) != NULL_RTX\n+\t   && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n+    LABEL_NUSES (XEXP (note, 0))--;\n+\n+  if (GET_CODE (insn) == JUMP_INSN\n+      && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+    {\n+      rtx pat = PATTERN (insn);\n+      int diff_vec_p = GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC;\n+      int len = XVECLEN (pat, diff_vec_p);\n+      int i;\n+\n+      for (i = 0; i < len; i++)\n+\tLABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n+    }\n+\n+  return next;\n+}\n+\n+/* Unlink a chain of insns between START and FINISH, leaving notes\n+   that must be paired.  */\n+\n+void\n+delete_insn_chain (start, finish)\n+     rtx start, finish;\n+{\n+  /* Unchain the insns one by one.  It would be quicker to delete all\n+     of these with a single unchaining, rather than one at a time, but\n+     we need to keep the NOTE's.  */\n+\n+  rtx next;\n+\n+  while (1)\n+    {\n+      next = NEXT_INSN (start);\n+      if (GET_CODE (start) == NOTE && !can_delete_note_p (start))\n+\t;\n+      else\n+\tnext = delete_insn (start);\n+\n+      if (start == finish)\n+\tbreak;\n+      start = next;\n+    }\n+}\n+\f\n+/* Create a new basic block consisting of the instructions between\n+   HEAD and END inclusive.  This function is designed to allow fast\n+   BB construction - reuses the note and basic block struct\n+   in BB_NOTE, if any and do not grow BASIC_BLOCK chain and should\n+   be used directly only by CFG construction code.\n+   END can be NULL in to create new empty basic block before HEAD.\n+   Both END and HEAD can be NULL to create basic block at the end of\n+   INSN chain.  */\n+\n+basic_block\n+create_basic_block_structure (index, head, end, bb_note)\n+     int index;\n+     rtx head, end, bb_note;\n+{\n+  basic_block bb;\n+\n+  if (bb_note\n+      && ! RTX_INTEGRATED_P (bb_note)\n+      && (bb = NOTE_BASIC_BLOCK (bb_note)) != NULL\n+      && bb->aux == NULL)\n+    {\n+      /* If we found an existing note, thread it back onto the chain.  */\n+\n+      rtx after;\n+\n+      if (GET_CODE (head) == CODE_LABEL)\n+\tafter = head;\n+      else\n+\t{\n+\t  after = PREV_INSN (head);\n+\t  head = bb_note;\n+\t}\n+\n+      if (after != bb_note && NEXT_INSN (after) != bb_note)\n+\treorder_insns (bb_note, bb_note, after);\n+    }\n+  else\n+    {\n+      /* Otherwise we must create a note and a basic block structure.  */\n+\n+      bb = alloc_block ();\n+\n+      if (!head && !end)\n+\t{\n+\t  head = end = bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK,\n+\t\t\t\t\t\t  get_last_insn ());\n+\t}\n+      else if (GET_CODE (head) == CODE_LABEL && end)\n+\t{\n+\t  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, head);\n+\t  if (head == end)\n+\t    end = bb_note;\n+\t}\n+      else\n+\t{\n+\t  bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK, head);\n+\t  head = bb_note;\n+\t  if (!end)\n+\t    end = head;\n+\t}\n+      NOTE_BASIC_BLOCK (bb_note) = bb;\n+    }\n+\n+  /* Always include the bb note in the block.  */\n+  if (NEXT_INSN (end) == bb_note)\n+    end = bb_note;\n+\n+  bb->head = head;\n+  bb->end = end;\n+  bb->index = index;\n+  BASIC_BLOCK (index) = bb;\n+  if (basic_block_for_insn)\n+    update_bb_for_insn (bb);\n+\n+  /* Tag the block so that we know it has been used when considering\n+     other basic block notes.  */\n+  bb->aux = bb;\n+\n+  return bb;\n+}\n+\n+/* Create new basic block consisting of instructions in between HEAD and\n+   END and place it to the BB chain at possition INDEX.\n+   END can be NULL in to create new empty basic block before HEAD.\n+   Both END and HEAD can be NULL to create basic block at the end of\n+   INSN chain.  */\n+\n+basic_block\n+create_basic_block (index, head, end)\n+     int index;\n+     rtx head, end;\n+{\n+  basic_block bb;\n+  int i;\n+\n+  /* Place the new block just after the block being split.  */\n+  VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+\n+  /* Some parts of the compiler expect blocks to be number in\n+     sequential order so insert the new block immediately after the\n+     block being split..  */\n+  for (i = n_basic_blocks - 1; i > index; --i)\n+    {\n+      basic_block tmp = BASIC_BLOCK (i - 1);\n+      BASIC_BLOCK (i) = tmp;\n+      tmp->index = i;\n+    }\n+\n+  bb = create_basic_block_structure (index, head, end, NULL);\n+  bb->aux = NULL;\n+  return bb;\n+}\n+\f\n+/* Delete the insns in a (non-live) block.  We physically delete every\n+   non-deleted-note insn, and update the flow graph appropriately.\n+\n+   Return nonzero if we deleted an exception handler.  */\n+\n+/* ??? Preserving all such notes strikes me as wrong.  It would be nice\n+   to post-process the stream to remove empty blocks, loops, ranges, etc.  */\n+\n+int\n+flow_delete_block (b)\n+     basic_block b;\n+{\n+  int deleted_handler = 0;\n+  rtx insn, end, tmp;\n+\n+  /* If the head of this block is a CODE_LABEL, then it might be the\n+     label for an exception handler which can't be reached.\n+\n+     We need to remove the label from the exception_handler_label list\n+     and remove the associated NOTE_INSN_EH_REGION_BEG and\n+     NOTE_INSN_EH_REGION_END notes.  */\n+\n+  insn = b->head;\n+\n+  never_reached_warning (insn);\n+\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    maybe_remove_eh_handler (insn);\n+\n+  /* Include any jump table following the basic block.  */\n+  end = b->end;\n+  if (GET_CODE (end) == JUMP_INSN\n+      && (tmp = JUMP_LABEL (end)) != NULL_RTX\n+      && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n+      && GET_CODE (tmp) == JUMP_INSN\n+      && (GET_CODE (PATTERN (tmp)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC))\n+    end = tmp;\n+\n+  /* Include any barrier that may follow the basic block.  */\n+  tmp = next_nonnote_insn (end);\n+  if (tmp && GET_CODE (tmp) == BARRIER)\n+    end = tmp;\n+\n+  /* Selectively delete the entire chain.  */\n+  b->head = NULL;\n+  delete_insn_chain (insn, end);\n+\n+  /* Remove the edges into and out of this block.  Note that there may\n+     indeed be edges in, if we are removing an unreachable loop.  */\n+  while (b->pred != NULL)\n+    remove_edge (b->pred);\n+  while (b->succ != NULL)\n+    remove_edge (b->succ);\n+\n+  b->pred = NULL;\n+  b->succ = NULL;\n+\n+  /* Remove the basic block from the array, and compact behind it.  */\n+  expunge_block (b);\n+\n+  return deleted_handler;\n+}\n+\f\n+/* Records the basic block struct in BB_FOR_INSN, for every instruction\n+   indexed by INSN_UID.  MAX is the size of the array.  */\n+\n+void\n+compute_bb_for_insn (max)\n+     int max;\n+{\n+  int i;\n+\n+  if (basic_block_for_insn)\n+    VARRAY_FREE (basic_block_for_insn);\n+  VARRAY_BB_INIT (basic_block_for_insn, max, \"basic_block_for_insn\");\n+\n+  for (i = 0; i < n_basic_blocks; ++i)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx insn, end;\n+\n+      end = bb->end;\n+      insn = bb->head;\n+      while (1)\n+\t{\n+\t  int uid = INSN_UID (insn);\n+\t  if (uid < max)\n+\t    VARRAY_BB (basic_block_for_insn, uid) = bb;\n+\t  if (insn == end)\n+\t    break;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+}\n+\n+/* Release the basic_block_for_insn array.  */\n+\n+void\n+free_bb_for_insn ()\n+{\n+  if (basic_block_for_insn)\n+    VARRAY_FREE (basic_block_for_insn);\n+  basic_block_for_insn = 0;\n+}\n+\n+/* Update insns block within BB.  */\n+\n+void\n+update_bb_for_insn (bb)\n+     basic_block bb;\n+{\n+  rtx insn;\n+\n+  if (! basic_block_for_insn)\n+    return;\n+\n+  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+    {\n+      set_block_for_insn (insn, bb);\n+\n+      if (insn == bb->end)\n+\tbreak;\n+    }\n+}\n+\n+/* Record INSN's block as BB.  */\n+\n+void\n+set_block_for_insn (insn, bb)\n+     rtx insn;\n+     basic_block bb;\n+{\n+  size_t uid = INSN_UID (insn);\n+  if (uid >= basic_block_for_insn->num_elements)\n+    {\n+      int new_size;\n+\n+      /* Add one-eighth the size so we don't keep calling xrealloc.  */\n+      new_size = uid + (uid + 7) / 8;\n+\n+      VARRAY_GROW (basic_block_for_insn, new_size);\n+    }\n+  VARRAY_BB (basic_block_for_insn, uid) = bb;\n+}\n+\f\n+/* Split a block BB after insn INSN creating a new fallthru edge.\n+   Return the new edge.  Note that to keep other parts of the compiler happy,\n+   this function renumbers all the basic blocks so that the new\n+   one has a number one greater than the block split.  */\n+\n+edge\n+split_block (bb, insn)\n+     basic_block bb;\n+     rtx insn;\n+{\n+  basic_block new_bb;\n+  edge new_edge;\n+  edge e;\n+\n+  /* There is no point splitting the block after its end.  */\n+  if (bb->end == insn)\n+    return 0;\n+\n+  /* Create the new basic block.  */\n+  new_bb = create_basic_block (bb->index + 1, NEXT_INSN (insn), bb->end);\n+  new_bb->count = bb->count;\n+  new_bb->frequency = bb->frequency;\n+  new_bb->loop_depth = bb->loop_depth;\n+  bb->end = insn;\n+\n+  /* Redirect the outgoing edges.  */\n+  new_bb->succ = bb->succ;\n+  bb->succ = NULL;\n+  for (e = new_bb->succ; e; e = e->succ_next)\n+    e->src = new_bb;\n+\n+  new_edge = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);\n+\n+  if (bb->global_live_at_start)\n+    {\n+      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n+\n+      /* We now have to calculate which registers are live at the end\n+\t of the split basic block and at the start of the new basic\n+\t block.  Start with those registers that are known to be live\n+\t at the end of the original basic block and get\n+\t propagate_block to determine which registers are live.  */\n+      COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_end);\n+      propagate_block (new_bb, new_bb->global_live_at_start, NULL, NULL, 0);\n+      COPY_REG_SET (bb->global_live_at_end,\n+\t\t    new_bb->global_live_at_start);\n+    }\n+\n+  return new_edge;\n+}\n+\n+/* Blocks A and B are to be merged into a single block A.  The insns\n+   are already contiguous, hence `nomove'.  */\n+\n+void\n+merge_blocks_nomove (a, b)\n+     basic_block a, b;\n+{\n+  edge e;\n+  rtx b_head, b_end, a_end;\n+  rtx del_first = NULL_RTX, del_last = NULL_RTX;\n+  int b_empty = 0;\n+\n+  /* If there was a CODE_LABEL beginning B, delete it.  */\n+  b_head = b->head;\n+  b_end = b->end;\n+  if (GET_CODE (b_head) == CODE_LABEL)\n+    {\n+      /* Detect basic blocks with nothing but a label.  This can happen\n+\t in particular at the end of a function.  */\n+      if (b_head == b_end)\n+\tb_empty = 1;\n+      del_first = del_last = b_head;\n+      b_head = NEXT_INSN (b_head);\n+    }\n+\n+  /* Delete the basic block note.  */\n+  if (NOTE_INSN_BASIC_BLOCK_P (b_head))\n+    {\n+      if (b_head == b_end)\n+\tb_empty = 1;\n+      if (! del_last)\n+\tdel_first = b_head;\n+      del_last = b_head;\n+      b_head = NEXT_INSN (b_head);\n+    }\n+\n+  /* If there was a jump out of A, delete it.  */\n+  a_end = a->end;\n+  if (GET_CODE (a_end) == JUMP_INSN)\n+    {\n+      rtx prev;\n+\n+      for (prev = PREV_INSN (a_end); ; prev = PREV_INSN (prev))\n+\tif (GET_CODE (prev) != NOTE\n+\t    || NOTE_LINE_NUMBER (prev) == NOTE_INSN_BASIC_BLOCK\n+\t    || prev == a->head)\n+\t  break;\n+\n+      del_first = a_end;\n+\n+#ifdef HAVE_cc0\n+      /* If this was a conditional jump, we need to also delete\n+\t the insn that set cc0.  */\n+      if (only_sets_cc0_p (prev))\n+\t{\n+\t  rtx tmp = prev;\n+\t  prev = prev_nonnote_insn (prev);\n+\t  if (!prev)\n+\t    prev = a->head;\n+\t  del_first = tmp;\n+\t}\n+#endif\n+\n+      a_end = PREV_INSN (del_first);\n+    }\n+  else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n+    del_first = NEXT_INSN (a_end);\n+\n+  /* Normally there should only be one successor of A and that is B, but\n+     partway though the merge of blocks for conditional_execution we'll\n+     be merging a TEST block with THEN and ELSE successors.  Free the\n+     whole lot of them and hope the caller knows what they're doing.  */\n+  while (a->succ)\n+    remove_edge (a->succ);\n+\n+  /* Adjust the edges out of B for the new owner.  */\n+  for (e = b->succ; e; e = e->succ_next)\n+    e->src = a;\n+  a->succ = b->succ;\n+\n+  /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n+  b->pred = b->succ = NULL;\n+\n+  expunge_block (b);\n+\n+  /* Delete everything marked above as well as crap that might be\n+     hanging out between the two blocks.  */\n+  delete_insn_chain (del_first, del_last);\n+\n+  /* Reassociate the insns of B with A.  */\n+  if (!b_empty)\n+    {\n+      rtx x = a_end;\n+      if (basic_block_for_insn)\n+\t{\n+\t  BLOCK_FOR_INSN (x) = a;\n+\t  while (x != b_end)\n+\t    {\n+\t      x = NEXT_INSN (x);\n+\t      BLOCK_FOR_INSN (x) = a;\n+\t    }\n+\t}\n+      a_end = b_end;\n+    }\n+  a->end = a_end;\n+}\n+\f\n+/* Return label in the head of basic block.  Create one if it doesn't exist.  */\n+\n+rtx\n+block_label (block)\n+     basic_block block;\n+{\n+  if (block == EXIT_BLOCK_PTR)\n+    return NULL_RTX;\n+  if (GET_CODE (block->head) != CODE_LABEL)\n+    {\n+      block->head = emit_label_before (gen_label_rtx (), block->head);\n+      if (basic_block_for_insn)\n+\tset_block_for_insn (block->head, block);\n+    }\n+  return block->head;\n+}\n+\n+/* Attempt to perform edge redirection by replacing possibly complex jump\n+   instruction by unconditional jump or removing jump completely.\n+   This can apply only if all edges now point to the same block.\n+\n+   The parameters and return values are equivalent to redirect_edge_and_branch.\n+ */\n+\n+static bool\n+try_redirect_by_replacing_jump (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  basic_block src = e->src;\n+  rtx insn = src->end, kill_from;\n+  edge tmp;\n+  rtx set;\n+  int fallthru = 0;\n+\n+  /* Verify that all targets will be TARGET.  */\n+  for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n+    if (tmp->dest != target && tmp != e)\n+      break;\n+  if (tmp || !onlyjump_p (insn))\n+    return false;\n+\n+  /* Avoid removing branch with side effects.  */\n+  set = single_set (insn);\n+  if (!set || side_effects_p (set))\n+    return false;\n+\n+  /* In case we zap a conditional jump, we'll need to kill\n+     the cc0 setter too.  */\n+  kill_from = insn;\n+#ifdef HAVE_cc0\n+  if (reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n+    kill_from = PREV_INSN (insn);\n+#endif\n+\n+  /* See if we can create the fallthru edge.  */\n+  if (can_fallthru (src, target))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n+      fallthru = 1;\n+\n+      /* Selectivly unlink whole insn chain.  */\n+      delete_insn_chain (kill_from, PREV_INSN (target->head));\n+    }\n+  /* If this already is simplejump, redirect it.  */\n+  else if (simplejump_p (insn))\n+    {\n+      if (e->dest == target)\n+\treturn false;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n+\t\t INSN_UID (insn), e->dest->index, target->index);\n+      redirect_jump (insn, block_label (target), 0);\n+    }\n+  /* Or replace possibly complicated jump insn by simple jump insn.  */\n+  else\n+    {\n+      rtx target_label = block_label (target);\n+      rtx barrier;\n+\n+      emit_jump_insn_after (gen_jump (target_label), kill_from);\n+      JUMP_LABEL (src->end) = target_label;\n+      LABEL_NUSES (target_label)++;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n+\t\t INSN_UID (insn), INSN_UID (src->end));\n+\n+      delete_insn_chain (kill_from, insn);\n+\n+      barrier = next_nonnote_insn (src->end);\n+      if (!barrier || GET_CODE (barrier) != BARRIER)\n+\temit_barrier_after (src->end);\n+    }\n+\n+  /* Keep only one edge out and set proper flags.  */\n+  while (src->succ->succ_next)\n+    remove_edge (src->succ);\n+  e = src->succ;\n+  if (fallthru)\n+    e->flags = EDGE_FALLTHRU;\n+  else\n+    e->flags = 0;\n+  e->probability = REG_BR_PROB_BASE;\n+  e->count = src->count;\n+\n+  /* We don't want a block to end on a line-number note since that has\n+     the potential of changing the code between -g and not -g.  */\n+  while (GET_CODE (e->src->end) == NOTE\n+\t && NOTE_LINE_NUMBER (e->src->end) >= 0)\n+    delete_insn (e->src->end);\n+\n+  if (e->dest != target)\n+    redirect_edge_succ (e, target);\n+  return true;\n+}\n+\n+/* Return last loop_beg note appearing after INSN, before start of next\n+   basic block.  Return INSN if there are no such notes.\n+\n+   When emmiting jump to redirect an fallthru edge, it should always\n+   appear after the LOOP_BEG notes, as loop optimizer expect loop to\n+   eighter start by fallthru edge or jump following the LOOP_BEG note\n+   jumping to the loop exit test.  */\n+\n+static rtx\n+last_loop_beg_note (insn)\n+     rtx insn;\n+{\n+  rtx last = insn;\n+  insn = NEXT_INSN (insn);\n+  while (insn && GET_CODE (insn) == NOTE\n+\t && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n+    {\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\tlast = insn;\n+      insn = NEXT_INSN (insn);\n+    }\n+  return last;\n+}\n+\n+/* Attempt to change code to redirect edge E to TARGET.\n+   Don't do that on expense of adding new instructions or reordering\n+   basic blocks.\n+\n+   Function can be also called with edge destionation equivalent to the\n+   TARGET.  Then it should try the simplifications and do nothing if\n+   none is possible.\n+\n+   Return true if transformation suceeded.  We still return flase in case\n+   E already destinated TARGET and we didn't managed to simplify instruction\n+   stream.  */\n+\n+bool\n+redirect_edge_and_branch (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  rtx tmp;\n+  rtx old_label = e->dest->head;\n+  basic_block src = e->src;\n+  rtx insn = src->end;\n+\n+  if (e->flags & EDGE_COMPLEX)\n+    return false;\n+\n+  if (try_redirect_by_replacing_jump (e, target))\n+    return true;\n+  /* Do this fast path late, as we want above code to simplify for cases\n+     where called on single edge leaving basic block containing nontrivial\n+     jump insn.  */\n+  else if (e->dest == target)\n+    return false;\n+\n+  /* We can only redirect non-fallthru edges of jump insn.  */\n+  if (e->flags & EDGE_FALLTHRU)\n+    return false;\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    return false;\n+\n+  /* Recognize a tablejump and adjust all matching cases.  */\n+  if ((tmp = JUMP_LABEL (insn)) != NULL_RTX\n+      && (tmp = NEXT_INSN (tmp)) != NULL_RTX\n+      && GET_CODE (tmp) == JUMP_INSN\n+      && (GET_CODE (PATTERN (tmp)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC))\n+    {\n+      rtvec vec;\n+      int j;\n+      rtx new_label = block_label (target);\n+\n+      if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n+\tvec = XVEC (PATTERN (tmp), 0);\n+      else\n+\tvec = XVEC (PATTERN (tmp), 1);\n+\n+      for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n+\tif (XEXP (RTVEC_ELT (vec, j), 0) == old_label)\n+\t  {\n+\t    RTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (Pmode, new_label);\n+\t    --LABEL_NUSES (old_label);\n+\t    ++LABEL_NUSES (new_label);\n+\t  }\n+\n+      /* Handle casesi dispatch insns */\n+      if ((tmp = single_set (insn)) != NULL\n+\t  && SET_DEST (tmp) == pc_rtx\n+\t  && GET_CODE (SET_SRC (tmp)) == IF_THEN_ELSE\n+\t  && GET_CODE (XEXP (SET_SRC (tmp), 2)) == LABEL_REF\n+\t  && XEXP (XEXP (SET_SRC (tmp), 2), 0) == old_label)\n+\t{\n+\t  XEXP (SET_SRC (tmp), 2) = gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t       new_label);\n+\t  --LABEL_NUSES (old_label);\n+\t  ++LABEL_NUSES (new_label);\n+\t}\n+    }\n+  else\n+    {\n+      /* ?? We may play the games with moving the named labels from\n+\t one basic block to the other in case only one computed_jump is\n+\t available.  */\n+      if (computed_jump_p (insn))\n+\treturn false;\n+\n+      /* A return instruction can't be redirected.  */\n+      if (returnjump_p (insn))\n+\treturn false;\n+\n+      /* If the insn doesn't go where we think, we're confused.  */\n+      if (JUMP_LABEL (insn) != old_label)\n+\tabort ();\n+      redirect_jump (insn, block_label (target), 0);\n+    }\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Edge %i->%i redirected to %i\\n\",\n+\t     e->src->index, e->dest->index, target->index);\n+  if (e->dest != target)\n+    redirect_edge_succ_nodup (e, target);\n+  return true;\n+}\n+\n+/* Like force_nonfallthru bellow, but additionally performs redirection\n+   Used by redirect_edge_and_branch_force.  */\n+\n+static basic_block\n+force_nonfallthru_and_redirect (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  basic_block jump_block, new_bb = NULL;\n+  rtx note;\n+  edge new_edge;\n+\n+  if (e->flags & EDGE_ABNORMAL)\n+    abort ();\n+  if (!(e->flags & EDGE_FALLTHRU))\n+    abort ();\n+  if (e->src->succ->succ_next)\n+    {\n+      /* Create the new structures.  */\n+      note = last_loop_beg_note (e->src->end);\n+      jump_block = create_basic_block (e->src->index + 1, NEXT_INSN (note), NULL);\n+      jump_block->count = e->count;\n+      jump_block->frequency = EDGE_FREQUENCY (e);\n+      jump_block->loop_depth = target->loop_depth;\n+\n+      if (target->global_live_at_start)\n+\t{\n+\t  jump_block->global_live_at_start =\n+\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  jump_block->global_live_at_end =\n+\t    OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+\t  COPY_REG_SET (jump_block->global_live_at_start,\n+\t\t\ttarget->global_live_at_start);\n+\t  COPY_REG_SET (jump_block->global_live_at_end,\n+\t\t\ttarget->global_live_at_start);\n+\t}\n+\n+      /* Wire edge in.  */\n+      new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n+      new_edge->probability = e->probability;\n+      new_edge->count = e->count;\n+\n+      /* Redirect old edge.  */\n+      redirect_edge_pred (e, jump_block);\n+      e->probability = REG_BR_PROB_BASE;\n+\n+      new_bb = jump_block;\n+    }\n+  else\n+    jump_block = e->src;\n+  e->flags &= ~EDGE_FALLTHRU;\n+  if (target == EXIT_BLOCK_PTR)\n+    {\n+      if (HAVE_return)\n+\temit_jump_insn_after (gen_return (), jump_block->end);\n+      else\n+\tabort ();\n+    }\n+  else\n+    {\n+      rtx label = block_label (target);\n+      emit_jump_insn_after (gen_jump (label), jump_block->end);\n+      JUMP_LABEL (jump_block->end) = label;\n+      LABEL_NUSES (label)++;\n+    }\n+  emit_barrier_after (jump_block->end);\n+  redirect_edge_succ_nodup (e, target);\n+\n+  return new_bb;\n+}\n+\n+/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction\n+   (and possibly create new basic block) to make edge non-fallthru.\n+   Return newly created BB or NULL if none.  */\n+basic_block\n+force_nonfallthru (e)\n+     edge e;\n+{\n+  return force_nonfallthru_and_redirect (e, e->dest);\n+}\n+\n+/* Redirect edge even at the expense of creating new jump insn or\n+   basic block.  Return new basic block if created, NULL otherwise.\n+   Abort if converison is impossible.  */\n+\n+basic_block\n+redirect_edge_and_branch_force (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  basic_block new_bb;\n+\n+  if (redirect_edge_and_branch (e, target))\n+    return NULL;\n+  if (e->dest == target)\n+    return NULL;\n+\n+  /* In case the edge redirection failed, try to force it to be non-fallthru\n+     and redirect newly created simplejump.  */\n+  new_bb = force_nonfallthru_and_redirect (e, target);\n+  return new_bb;\n+}\n+\n+/* The given edge should potentially be a fallthru edge.  If that is in\n+   fact true, delete the jump and barriers that are in the way.  */\n+\n+void\n+tidy_fallthru_edge (e, b, c)\n+     edge e;\n+     basic_block b, c;\n+{\n+  rtx q;\n+\n+  /* ??? In a late-running flow pass, other folks may have deleted basic\n+     blocks by nopping out blocks, leaving multiple BARRIERs between here\n+     and the target label. They ought to be chastized and fixed.\n+\n+     We can also wind up with a sequence of undeletable labels between\n+     one block and the next.\n+\n+     So search through a sequence of barriers, labels, and notes for\n+     the head of block C and assert that we really do fall through.  */\n+\n+  if (next_real_insn (b->end) != next_real_insn (PREV_INSN (c->head)))\n+    return;\n+\n+  /* Remove what will soon cease being the jump insn from the source block.\n+     If block B consisted only of this single jump, turn it into a deleted\n+     note.  */\n+  q = b->end;\n+  if (GET_CODE (q) == JUMP_INSN\n+      && onlyjump_p (q)\n+      && (any_uncondjump_p (q)\n+\t  || (b->succ == e && e->succ_next == NULL)))\n+    {\n+#ifdef HAVE_cc0\n+      /* If this was a conditional jump, we need to also delete\n+\t the insn that set cc0.  */\n+      if (any_condjump_p (q) && only_sets_cc0_p (PREV_INSN (q)))\n+\tq = PREV_INSN (q);\n+#endif\n+\n+      q = PREV_INSN (q);\n+\n+      /* We don't want a block to end on a line-number note since that has\n+\t the potential of changing the code between -g and not -g.  */\n+      while (GET_CODE (q) == NOTE && NOTE_LINE_NUMBER (q) >= 0)\n+\tq = PREV_INSN (q);\n+    }\n+\n+  /* Selectively unlink the sequence.  */\n+  if (q != PREV_INSN (c->head))\n+    delete_insn_chain (NEXT_INSN (q), PREV_INSN (c->head));\n+\n+  e->flags |= EDGE_FALLTHRU;\n+}\n+\n+/* Fix up edges that now fall through, or rather should now fall through\n+   but previously required a jump around now deleted blocks.  Simplify\n+   the search by only examining blocks numerically adjacent, since this\n+   is how find_basic_blocks created them.  */\n+\n+void\n+tidy_fallthru_edges ()\n+{\n+  int i;\n+\n+  for (i = 1; i < n_basic_blocks; ++i)\n+    {\n+      basic_block b = BASIC_BLOCK (i - 1);\n+      basic_block c = BASIC_BLOCK (i);\n+      edge s;\n+\n+      /* We care about simple conditional or unconditional jumps with\n+\t a single successor.\n+\n+\t If we had a conditional branch to the next instruction when\n+\t find_basic_blocks was called, then there will only be one\n+\t out edge for the block which ended with the conditional\n+\t branch (since we do not create duplicate edges).\n+\n+\t Furthermore, the edge will be marked as a fallthru because we\n+\t merge the flags for the duplicate edges.  So we do not want to\n+\t check that the edge is not a FALLTHRU edge.  */\n+      if ((s = b->succ) != NULL\n+\t  && ! (s->flags & EDGE_COMPLEX)\n+\t  && s->succ_next == NULL\n+\t  && s->dest == c\n+\t  /* If the jump insn has side effects, we can't tidy the edge.  */\n+\t  && (GET_CODE (b->end) != JUMP_INSN\n+\t      || onlyjump_p (b->end)))\n+\ttidy_fallthru_edge (s, b, c);\n+    }\n+}\n+\f\n+/* Helper function for split_edge.  Return true in case edge BB2 to BB1\n+   is back edge of syntactic loop.  */\n+\n+static bool\n+back_edge_of_syntactic_loop_p (bb1, bb2)\n+\tbasic_block bb1, bb2;\n+{\n+  rtx insn;\n+  int count = 0;\n+\n+  if (bb1->index > bb2->index)\n+    return false;\n+\n+  if (bb1->index == bb2->index)\n+    return true;\n+\n+  for (insn = bb1->end; insn != bb2->head && count >= 0;\n+       insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE)\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t  count++;\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t  count--;\n+      }\n+\n+  return count >= 0;\n+}\n+\n+/* Split a (typically critical) edge.  Return the new block.\n+   Abort on abnormal edges.\n+\n+   ??? The code generally expects to be called on critical edges.\n+   The case of a block ending in an unconditional jump to a\n+   block with multiple predecessors is not handled optimally.  */\n+\n+basic_block\n+split_edge (edge_in)\n+     edge edge_in;\n+{\n+  basic_block bb;\n+  edge edge_out;\n+  rtx before;\n+\n+  /* Abnormal edges cannot be split.  */\n+  if ((edge_in->flags & EDGE_ABNORMAL) != 0)\n+    abort ();\n+\n+  /* We are going to place the new block in front of edge destination.\n+     Avoid existence of fallthru predecesors.  */\n+  if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n+    {\n+      edge e;\n+      for (e = edge_in->dest->pred; e; e = e->pred_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  break;\n+\n+      if (e)\n+\tforce_nonfallthru (e);\n+    }\n+\n+  /* Create the basic block note.\n+\n+     Where we place the note can have a noticable impact on the generated\n+     code.  Consider this cfg:\n+\n+\t\t        E\n+\t\t\t|\n+\t\t\t0\n+\t\t       / \\\n+\t\t   +->1-->2--->E\n+                   |  |\n+\t\t   +--+\n+\n+      If we need to insert an insn on the edge from block 0 to block 1,\n+      we want to ensure the instructions we insert are outside of any\n+      loop notes that physically sit between block 0 and block 1.  Otherwise\n+      we confuse the loop optimizer into thinking the loop is a phony.  */\n+\n+  if (edge_in->dest != EXIT_BLOCK_PTR\n+      && PREV_INSN (edge_in->dest->head)\n+      && GET_CODE (PREV_INSN (edge_in->dest->head)) == NOTE\n+      && NOTE_LINE_NUMBER (PREV_INSN (edge_in->dest->head)) == NOTE_INSN_LOOP_BEG\n+      && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n+    before = PREV_INSN (edge_in->dest->head);\n+  else if (edge_in->dest != EXIT_BLOCK_PTR)\n+    before = edge_in->dest->head;\n+  else\n+    before = NULL_RTX;\n+\n+  bb = create_basic_block (edge_in->dest == EXIT_BLOCK_PTR ? n_basic_blocks\n+\t\t\t   : edge_in->dest->index, before, NULL);\n+  bb->count = edge_in->count;\n+  bb->frequency = EDGE_FREQUENCY (edge_in);\n+\n+  /* ??? This info is likely going to be out of date very soon.  */\n+  if (edge_in->dest->global_live_at_start)\n+    {\n+      bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      COPY_REG_SET (bb->global_live_at_start, edge_in->dest->global_live_at_start);\n+      COPY_REG_SET (bb->global_live_at_end, edge_in->dest->global_live_at_start);\n+    }\n+\n+  edge_out = make_single_succ_edge (bb, edge_in->dest, EDGE_FALLTHRU);\n+\n+  /* For non-fallthry edges, we must adjust the predecessor's\n+     jump instruction to target our new block.  */\n+  if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n+    {\n+      if (!redirect_edge_and_branch (edge_in, bb))\n+\tabort ();\n+    }\n+  else\n+    redirect_edge_succ (edge_in, bb);\n+\n+  return bb;\n+}\n+\n+/* Queue instructions for insertion on an edge between two basic blocks.\n+   The new instructions and basic blocks (if any) will not appear in the\n+   CFG until commit_edge_insertions is called.  */\n+\n+void\n+insert_insn_on_edge (pattern, e)\n+     rtx pattern;\n+     edge e;\n+{\n+  /* We cannot insert instructions on an abnormal critical edge.\n+     It will be easier to find the culprit if we die now.  */\n+  if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n+    abort ();\n+\n+  if (e->insns == NULL_RTX)\n+    start_sequence ();\n+  else\n+    push_to_sequence (e->insns);\n+\n+  emit_insn (pattern);\n+\n+  e->insns = get_insns ();\n+  end_sequence ();\n+}\n+\n+/* Update the CFG for the instructions queued on edge E.  */\n+\n+static void\n+commit_one_edge_insertion (e)\n+     edge e;\n+{\n+  rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;\n+  basic_block bb;\n+\n+  /* Pull the insns off the edge now since the edge might go away.  */\n+  insns = e->insns;\n+  e->insns = NULL_RTX;\n+\n+  /* Figure out where to put these things.  If the destination has\n+     one predecessor, insert there.  Except for the exit block.  */\n+  if (e->dest->pred->pred_next == NULL\n+      && e->dest != EXIT_BLOCK_PTR)\n+    {\n+      bb = e->dest;\n+\n+      /* Get the location correct wrt a code label, and \"nice\" wrt\n+\t a basic block note, and before everything else.  */\n+      tmp = bb->head;\n+      if (GET_CODE (tmp) == CODE_LABEL)\n+\ttmp = NEXT_INSN (tmp);\n+      if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n+\ttmp = NEXT_INSN (tmp);\n+      if (tmp == bb->head)\n+\tbefore = tmp;\n+      else\n+\tafter = PREV_INSN (tmp);\n+    }\n+\n+  /* If the source has one successor and the edge is not abnormal,\n+     insert there.  Except for the entry block.  */\n+  else if ((e->flags & EDGE_ABNORMAL) == 0\n+\t   && e->src->succ->succ_next == NULL\n+\t   && e->src != ENTRY_BLOCK_PTR)\n+    {\n+      bb = e->src;\n+      /* It is possible to have a non-simple jump here.  Consider a target\n+\t where some forms of unconditional jumps clobber a register.  This\n+\t happens on the fr30 for example.\n+\n+\t We know this block has a single successor, so we can just emit\n+\t the queued insns before the jump.  */\n+      if (GET_CODE (bb->end) == JUMP_INSN)\n+\t{\n+\t  before = bb->end;\n+\t  while (GET_CODE (PREV_INSN (before)) == NOTE\n+\t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) == NOTE_INSN_LOOP_BEG)\n+\t    before = PREV_INSN (before);\n+\t}\n+      else\n+\t{\n+\t  /* We'd better be fallthru, or we've lost track of what's what.  */\n+\t  if ((e->flags & EDGE_FALLTHRU) == 0)\n+\t    abort ();\n+\n+\t  after = bb->end;\n+\t}\n+    }\n+\n+  /* Otherwise we must split the edge.  */\n+  else\n+    {\n+      bb = split_edge (e);\n+      after = bb->end;\n+    }\n+\n+  /* Now that we've found the spot, do the insertion.  */\n+\n+  if (before)\n+    {\n+      emit_insns_before (insns, before);\n+      last = prev_nonnote_insn (before);\n+    }\n+  else\n+    last = emit_insns_after (insns, after);\n+\n+  if (returnjump_p (last))\n+    {\n+      /* ??? Remove all outgoing edges from BB and add one for EXIT.\n+         This is not currently a problem because this only happens\n+\t for the (single) epilogue, which already has a fallthru edge\n+\t to EXIT.  */\n+\n+      e = bb->succ;\n+      if (e->dest != EXIT_BLOCK_PTR\n+\t  || e->succ_next != NULL\n+\t  || (e->flags & EDGE_FALLTHRU) == 0)\n+\tabort ();\n+      e->flags &= ~EDGE_FALLTHRU;\n+\n+      emit_barrier_after (last);\n+\n+      if (before)\n+\tdelete_insn (before);\n+    }\n+  else if (GET_CODE (last) == JUMP_INSN)\n+    abort ();\n+  find_sub_basic_blocks (bb);\n+}\n+\n+/* Update the CFG for all queued instructions.  */\n+\n+void\n+commit_edge_insertions ()\n+{\n+  int i;\n+  basic_block bb;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+\n+  i = -1;\n+  bb = ENTRY_BLOCK_PTR;\n+  while (1)\n+    {\n+      edge e, next;\n+\n+      for (e = bb->succ; e; e = next)\n+\t{\n+\t  next = e->succ_next;\n+\t  if (e->insns)\n+\t    commit_one_edge_insertion (e);\n+\t}\n+\n+      if (++i >= n_basic_blocks)\n+\tbreak;\n+      bb = BASIC_BLOCK (i);\n+    }\n+}\n+\f\n+/* Print out one basic block with live information at start and end.  */\n+\n+void\n+dump_bb (bb, outf)\n+     basic_block bb;\n+     FILE *outf;\n+{\n+  rtx insn;\n+  rtx last;\n+  edge e;\n+\n+  fprintf (outf, \";; Basic block %d, loop depth %d, count \",\n+\t   bb->index, bb->loop_depth);\n+  fprintf (outf, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) bb->count);\n+  putc ('\\n', outf);\n+\n+  fputs (\";; Predecessors: \", outf);\n+  for (e = bb->pred; e; e = e->pred_next)\n+    dump_edge_info (outf, e, 0);\n+  putc ('\\n', outf);\n+\n+  fputs (\";; Registers live at start:\", outf);\n+  dump_regset (bb->global_live_at_start, outf);\n+  putc ('\\n', outf);\n+\n+  for (insn = bb->head, last = NEXT_INSN (bb->end);\n+       insn != last;\n+       insn = NEXT_INSN (insn))\n+    print_rtl_single (outf, insn);\n+\n+  fputs (\";; Registers live at end:\", outf);\n+  dump_regset (bb->global_live_at_end, outf);\n+  putc ('\\n', outf);\n+\n+  fputs (\";; Successors: \", outf);\n+  for (e = bb->succ; e; e = e->succ_next)\n+    dump_edge_info (outf, e, 1);\n+  putc ('\\n', outf);\n+}\n+\n+void\n+debug_bb (bb)\n+     basic_block bb;\n+{\n+  dump_bb (bb, stderr);\n+}\n+\n+void\n+debug_bb_n (n)\n+     int n;\n+{\n+  dump_bb (BASIC_BLOCK (n), stderr);\n+}\n+\f\n+/* Like print_rtl, but also print out live information for the start of each\n+   basic block.  */\n+\n+void\n+print_rtl_with_bb (outf, rtx_first)\n+     FILE *outf;\n+     rtx rtx_first;\n+{\n+  register rtx tmp_rtx;\n+\n+  if (rtx_first == 0)\n+    fprintf (outf, \"(nil)\\n\");\n+  else\n+    {\n+      int i;\n+      enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n+      int max_uid = get_max_uid ();\n+      basic_block *start = (basic_block *)\n+\txcalloc (max_uid, sizeof (basic_block));\n+      basic_block *end = (basic_block *)\n+\txcalloc (max_uid, sizeof (basic_block));\n+      enum bb_state *in_bb_p = (enum bb_state *)\n+\txcalloc (max_uid, sizeof (enum bb_state));\n+\n+      for (i = n_basic_blocks - 1; i >= 0; i--)\n+\t{\n+\t  basic_block bb = BASIC_BLOCK (i);\n+\t  rtx x;\n+\n+\t  start[INSN_UID (bb->head)] = bb;\n+\t  end[INSN_UID (bb->end)] = bb;\n+\t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n+\t    {\n+\t      enum bb_state state = IN_MULTIPLE_BB;\n+\t      if (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n+\t\tstate = IN_ONE_BB;\n+\t      in_bb_p[INSN_UID (x)] = state;\n+\n+\t      if (x == bb->end)\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n+\t{\n+\t  int did_output;\n+\t  basic_block bb;\n+\n+\t  if ((bb = start[INSN_UID (tmp_rtx)]) != NULL)\n+\t    {\n+\t      fprintf (outf, \";; Start of basic block %d, registers live:\",\n+\t\t       bb->index);\n+\t      dump_regset (bb->global_live_at_start, outf);\n+\t      putc ('\\n', outf);\n+\t    }\n+\n+\t  if (in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB\n+\t      && GET_CODE (tmp_rtx) != NOTE\n+\t      && GET_CODE (tmp_rtx) != BARRIER)\n+\t    fprintf (outf, \";; Insn is not within a basic block\\n\");\n+\t  else if (in_bb_p[INSN_UID (tmp_rtx)] == IN_MULTIPLE_BB)\n+\t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");\n+\n+\t  did_output = print_rtl_single (outf, tmp_rtx);\n+\n+\t  if ((bb = end[INSN_UID (tmp_rtx)]) != NULL)\n+\t    {\n+\t      fprintf (outf, \";; End of basic block %d, registers live:\\n\",\n+\t\t       bb->index);\n+\t      dump_regset (bb->global_live_at_end, outf);\n+\t      putc ('\\n', outf);\n+\t    }\n+\n+\t  if (did_output)\n+\t    putc ('\\n', outf);\n+\t}\n+\n+      free (start);\n+      free (end);\n+      free (in_bb_p);\n+    }\n+\n+  if (current_function_epilogue_delay_list != 0)\n+    {\n+      fprintf (outf, \"\\n;; Insns in epilogue delay list:\\n\\n\");\n+      for (tmp_rtx = current_function_epilogue_delay_list; tmp_rtx != 0;\n+\t   tmp_rtx = XEXP (tmp_rtx, 1))\n+\tprint_rtl_single (outf, XEXP (tmp_rtx, 0));\n+    }\n+}\n+\f\n+/* Verify the CFG consistency.  This function check some CFG invariants and\n+   aborts when something is wrong.  Hope that this function will help to\n+   convert many optimization passes to preserve CFG consistent.\n+\n+   Currently it does following checks:\n+\n+   - test head/end pointers\n+   - overlapping of basic blocks\n+   - edge list correctness\n+   - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)\n+   - tails of basic blocks (ensure that boundary is necesary)\n+   - scans body of the basic block for JUMP_INSN, CODE_LABEL\n+     and NOTE_INSN_BASIC_BLOCK\n+   - check that all insns are in the basic blocks\n+   (except the switch handling code, barriers and notes)\n+   - check that all returns are followed by barriers\n+\n+   In future it can be extended check a lot of other stuff as well\n+   (reachability of basic blocks, life information, etc. etc.).  */\n+\n+void\n+verify_flow_info ()\n+{\n+  const int max_uid = get_max_uid ();\n+  const rtx rtx_first = get_insns ();\n+  rtx last_head = get_last_insn ();\n+  basic_block *bb_info, *last_visited;\n+  size_t *edge_checksum;\n+  rtx x;\n+  int i, last_bb_num_seen, num_bb_notes, err = 0;\n+\n+  bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n+  last_visited = (basic_block *) xcalloc (n_basic_blocks + 2,\n+\t\t\t\t\t  sizeof (basic_block));\n+  edge_checksum = (size_t *) xcalloc (n_basic_blocks + 2, sizeof (size_t));\n+\n+  for (i = n_basic_blocks - 1; i >= 0; i--)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx head = bb->head;\n+      rtx end = bb->end;\n+\n+      /* Verify the end of the basic block is in the INSN chain.  */\n+      for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n+\tif (x == end)\n+\t  break;\n+      if (!x)\n+\t{\n+\t  error (\"End insn %d for block %d not found in the insn stream.\",\n+\t\t INSN_UID (end), bb->index);\n+\t  err = 1;\n+\t}\n+\n+      /* Work backwards from the end to the head of the basic block\n+\t to verify the head is in the RTL chain.  */\n+      for (; x != NULL_RTX; x = PREV_INSN (x))\n+\t{\n+\t  /* While walking over the insn chain, verify insns appear\n+\t     in only one basic block and initialize the BB_INFO array\n+\t     used by other passes.  */\n+\t  if (bb_info[INSN_UID (x)] != NULL)\n+\t    {\n+\t      error (\"Insn %d is in multiple basic blocks (%d and %d)\",\n+\t\t     INSN_UID (x), bb->index, bb_info[INSN_UID (x)]->index);\n+\t      err = 1;\n+\t    }\n+\t  bb_info[INSN_UID (x)] = bb;\n+\n+\t  if (x == head)\n+\t    break;\n+\t}\n+      if (!x)\n+\t{\n+\t  error (\"Head insn %d for block %d not found in the insn stream.\",\n+\t\t INSN_UID (head), bb->index);\n+\t  err = 1;\n+\t}\n+\n+      last_head = x;\n+    }\n+\n+  /* Now check the basic blocks (boundaries etc.) */\n+  for (i = n_basic_blocks - 1; i >= 0; i--)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      int has_fallthru = 0;\n+      edge e;\n+\n+      e = bb->succ;\n+      while (e)\n+\t{\n+\t  if (last_visited [e->dest->index + 2] == bb)\n+\t    {\n+\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n+\t      err = 1;\n+\t    }\n+\t  last_visited [e->dest->index + 2] = bb;\n+\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    has_fallthru = 1;\n+\n+\t  if ((e->flags & EDGE_FALLTHRU)\n+\t      && e->src != ENTRY_BLOCK_PTR\n+\t      && e->dest != EXIT_BLOCK_PTR)\n+\t    {\n+\t      rtx insn;\n+\t      if (e->src->index + 1 != e->dest->index)\n+\t\t{\n+\t\t    error (\"verify_flow_info: Incorrect blocks for fallthru %i->%i\",\n+\t\t\t   e->src->index, e->dest->index);\n+\t\t    err = 1;\n+\t\t}\n+\t      else\n+\t\tfor (insn = NEXT_INSN (e->src->end); insn != e->dest->head;\n+\t\t     insn = NEXT_INSN (insn))\n+\t\t  if (GET_CODE (insn) == BARRIER || INSN_P (insn))\n+\t\t    {\n+\t\t      error (\"verify_flow_info: Incorrect fallthru %i->%i\",\n+\t\t\t     e->src->index, e->dest->index);\n+\t\t      fatal_insn (\"Wrong insn in the fallthru edge\", insn);\n+\t\t      err = 1;\n+\t\t    }\n+\t    }\n+\t  if (e->src != bb)\n+\t    {\n+\t      error (\"verify_flow_info: Basic block %d succ edge is corrupted\",\n+\t\t     bb->index);\n+\t      fprintf (stderr, \"Predecessor: \");\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fprintf (stderr, \"\\nSuccessor: \");\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fprintf (stderr, \"\\n\");\n+\t      err = 1;\n+\t    }\n+\t  edge_checksum[e->dest->index + 2] += (size_t) e;\n+\t  e = e->succ_next;\n+\t}\n+      if (!has_fallthru)\n+\t{\n+\t  rtx insn = bb->end;\n+\n+\t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n+\t  for (insn = bb->end; GET_CODE (insn) != BARRIER;\n+\t       insn = NEXT_INSN (insn))\n+\t    if (!insn\n+\t\t|| (GET_CODE (insn) == NOTE\n+\t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n+\t\t{\n+\t\t  error (\"Missing barrier after block %i\", bb->index);\n+\t\t  err = 1;\n+\t\t}\n+\t}\n+\n+      e = bb->pred;\n+      while (e)\n+\t{\n+\t  if (e->dest != bb)\n+\t    {\n+\t      error (\"Basic block %d pred edge is corrupted\", bb->index);\n+\t      fputs (\"Predecessor: \", stderr);\n+\t      dump_edge_info (stderr, e, 0);\n+\t      fputs (\"\\nSuccessor: \", stderr);\n+\t      dump_edge_info (stderr, e, 1);\n+\t      fputc ('\\n', stderr);\n+\t      err = 1;\n+\t    }\n+\t  edge_checksum[e->dest->index + 2] -= (size_t) e;\n+\t  e = e->pred_next;\n+\t}\n+       for (x = bb->head; x != NEXT_INSN (bb->end); x = NEXT_INSN (x))\n+\t if (basic_block_for_insn && BLOCK_FOR_INSN (x) != bb)\n+\t   {\n+\t     debug_rtx (x);\n+\t     if (! BLOCK_FOR_INSN (x))\n+\t       error (\"Insn %d is inside basic block %d but block_for_insn is NULL\",\n+\t\t      INSN_UID (x), bb->index);\n+\t     else\n+\t       error (\"Insn %d is inside basic block %d but block_for_insn is %i\",\n+\t\t      INSN_UID (x), bb->index, BLOCK_FOR_INSN (x)->index);\n+\t     err = 1;\n+\t   }\n+\n+      /* OK pointers are correct.  Now check the header of basic\n+         block.  It ought to contain optional CODE_LABEL followed\n+\t by NOTE_BASIC_BLOCK.  */\n+      x = bb->head;\n+      if (GET_CODE (x) == CODE_LABEL)\n+\t{\n+\t  if (bb->end == x)\n+\t    {\n+\t      error (\"NOTE_INSN_BASIC_BLOCK is missing for block %d\",\n+\t\t     bb->index);\n+\t      err = 1;\n+\t    }\n+\t  x = NEXT_INSN (x);\n+\t}\n+      if (!NOTE_INSN_BASIC_BLOCK_P (x) || NOTE_BASIC_BLOCK (x) != bb)\n+\t{\n+\t  error (\"NOTE_INSN_BASIC_BLOCK is missing for block %d\",\n+\t\t bb->index);\n+\t  err = 1;\n+\t}\n+\n+      if (bb->end == x)\n+\t{\n+\t  /* Do checks for empty blocks here */\n+\t}\n+      else\n+\t{\n+\t  x = NEXT_INSN (x);\n+\t  while (x)\n+\t    {\n+\t      if (NOTE_INSN_BASIC_BLOCK_P (x))\n+\t\t{\n+\t\t  error (\"NOTE_INSN_BASIC_BLOCK %d in the middle of basic block %d\",\n+\t\t\t INSN_UID (x), bb->index);\n+\t\t  err = 1;\n+\t\t}\n+\n+\t      if (x == bb->end)\n+\t\tbreak;\n+\n+\t      if (GET_CODE (x) == JUMP_INSN\n+\t\t  || GET_CODE (x) == CODE_LABEL\n+\t\t  || GET_CODE (x) == BARRIER)\n+\t\t{\n+\t\t  error (\"In basic block %d:\", bb->index);\n+\t\t  fatal_insn (\"Flow control insn inside a basic block\", x);\n+\t\t}\n+\n+\t      x = NEXT_INSN (x);\n+\t    }\n+\t}\n+    }\n+\n+  /* Complete edge checksumming for ENTRY and EXIT.  */\n+  {\n+    edge e;\n+    for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+      edge_checksum[e->dest->index + 2] += (size_t) e;\n+    for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+      edge_checksum[e->dest->index + 2] -= (size_t) e;\n+  }\n+\n+  for (i = -2; i < n_basic_blocks; ++i)\n+    if (edge_checksum[i + 2])\n+      {\n+\terror (\"Basic block %i edge lists are corrupted\", i);\n+\terr = 1;\n+      }\n+\n+  last_bb_num_seen = -1;\n+  num_bb_notes = 0;\n+  x = rtx_first;\n+  while (x)\n+    {\n+      if (NOTE_INSN_BASIC_BLOCK_P (x))\n+\t{\n+\t  basic_block bb = NOTE_BASIC_BLOCK (x);\n+\t  num_bb_notes++;\n+\t  if (bb->index != last_bb_num_seen + 1)\n+\t    internal_error (\"Basic blocks not numbered consecutively.\");\n+\n+\t  last_bb_num_seen = bb->index;\n+\t}\n+\n+      if (!bb_info[INSN_UID (x)])\n+\t{\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case BARRIER:\n+\t    case NOTE:\n+\t      break;\n+\n+\t    case CODE_LABEL:\n+\t      /* An addr_vec is placed outside any block block.  */\n+\t      if (NEXT_INSN (x)\n+\t\t  && GET_CODE (NEXT_INSN (x)) == JUMP_INSN\n+\t\t  && (GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_DIFF_VEC\n+\t\t      || GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_VEC))\n+\t\t{\n+\t\t  x = NEXT_INSN (x);\n+\t\t}\n+\n+\t      /* But in any case, non-deletable labels can appear anywhere.  */\n+\t      break;\n+\n+\t    default:\n+\t      fatal_insn (\"Insn outside basic block\", x);\n+\t    }\n+\t}\n+\n+      if (INSN_P (x)\n+\t  && GET_CODE (x) == JUMP_INSN\n+\t  && returnjump_p (x) && ! condjump_p (x)\n+\t  && ! (NEXT_INSN (x) && GET_CODE (NEXT_INSN (x)) == BARRIER))\n+\t    fatal_insn (\"Return not followed by barrier\", x);\n+\n+      x = NEXT_INSN (x);\n+    }\n+\n+  if (num_bb_notes != n_basic_blocks)\n+    internal_error\n+      (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n+       num_bb_notes, n_basic_blocks);\n+\n+  if (err)\n+    internal_error (\"verify_flow_info failed.\");\n+\n+  /* Clean up.  */\n+  free (bb_info);\n+  free (last_visited);\n+  free (edge_checksum);\n+}\n+\f\n+/* Assume that the preceeding pass has possibly eliminated jump instructions\n+   or converted the unconditional jumps.  Eliminate the edges from CFG.\n+   Return true if any edges are eliminated.  */\n+\n+bool\n+purge_dead_edges (bb)\n+     basic_block bb;\n+{\n+  edge e, next;\n+  rtx insn = bb->end;\n+  bool purged = false;\n+\n+  if (GET_CODE (insn) == JUMP_INSN && !simplejump_p (insn))\n+    return false;\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    {\n+      rtx note;\n+      edge b,f;\n+      /* We do care only about conditional jumps and simplejumps.  */\n+      if (!any_condjump_p (insn)\n+\t  && !returnjump_p (insn)\n+\t  && !simplejump_p (insn))\n+\treturn false;\n+      for (e = bb->succ; e; e = next)\n+\t{\n+\t  next = e->succ_next;\n+\n+\t  /* Check purposes we can have edge.  */\n+\t  if ((e->flags & EDGE_FALLTHRU)\n+\t      && any_condjump_p (insn))\n+\t    continue;\n+\t  if (e->dest != EXIT_BLOCK_PTR\n+\t      && e->dest->head == JUMP_LABEL (insn))\n+\t    continue;\n+\t  if (e->dest == EXIT_BLOCK_PTR\n+\t      && returnjump_p (insn))\n+\t    continue;\n+\t  purged = true;\n+\t  remove_edge (e);\n+\t}\n+      if (!bb->succ || !purged)\n+\treturn false;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Purged edges from bb %i\\n\", bb->index);\n+      if (!optimize)\n+\treturn purged;\n+\n+      /* Redistribute probabilities.  */\n+      if (!bb->succ->succ_next)\n+\t{\n+\t  bb->succ->probability = REG_BR_PROB_BASE;\n+\t  bb->succ->count = bb->count;\n+        }\n+      else\n+\t{\n+\t  note = find_reg_note (insn, REG_BR_PROB, NULL);\n+\t  if (!note)\n+\t    return purged;\n+\t  b = BRANCH_EDGE (bb);\n+\t  f = FALLTHRU_EDGE (bb);\n+\t  b->probability = INTVAL (XEXP (note, 0));\n+\t  f->probability = REG_BR_PROB_BASE - b->probability;\n+\t  b->count = bb->count * b->probability / REG_BR_PROB_BASE;\n+\t  f->count = bb->count * f->probability / REG_BR_PROB_BASE;\n+\t}\n+      return purged;\n+    }\n+\n+  /* Cleanup abnormal edges caused by throwing insns that have been\n+     eliminated.  */\n+  if (! can_throw_internal (bb->end))\n+    for (e = bb->succ; e; e = next)\n+      {\n+\tnext = e->succ_next;\n+\tif (e->flags & EDGE_EH)\n+\t  {\n+\t    remove_edge (e);\n+\t    purged = true;\n+\t  }\n+      }\n+\n+  /* If we don't see a jump insn, we don't know exactly why the block would\n+     have been broken at this point.  Look for a simple, non-fallthru edge,\n+     as these are only created by conditional branches.  If we find such an\n+     edge we know that there used to be a jump here and can then safely\n+     remove all non-fallthru edges.  */\n+  for (e = bb->succ; e && (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU));\n+       e = e->succ_next);\n+  if (!e)\n+    return purged;\n+  for (e = bb->succ; e; e = next)\n+    {\n+      next = e->succ_next;\n+      if (!(e->flags & EDGE_FALLTHRU))\n+\tremove_edge (e), purged = true;\n+    }\n+  if (!bb->succ || bb->succ->succ_next)\n+    abort ();\n+  bb->succ->probability = REG_BR_PROB_BASE;\n+  bb->succ->count = bb->count;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Purged non-fallthru edges from bb %i\\n\",\n+\t     bb->index);\n+  return purged;\n+}\n+\n+/* Search all basic blocks for potentionally dead edges and purge them.\n+\n+   Return true ifif some edge has been elliminated.\n+ */\n+\n+bool\n+purge_all_dead_edges ()\n+{\n+  int i, purged = false;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    purged |= purge_dead_edges (BASIC_BLOCK (i));\n+  return purged;\n+}"}, {"sha": "f33df26338297272c42dfed5b200cbbaba12de86", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -3528,7 +3528,7 @@ emit_insns_after (first, after)\n     abort ();\n \n   if (!first)\n-    return first;\n+    return after;\n \n   if (basic_block_for_insn\n       && (unsigned int)INSN_UID (after) < basic_block_for_insn->num_elements"}, {"sha": "dd8266af25696b55ae00f025fb2132a6901213a7", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -1972,8 +1972,7 @@ final (first, file, optimize, prescan)\n \t\t     && NOTE_LINE_NUMBER (insn) == NOTE_LINE_NUMBER (last)\n \t\t     && NOTE_SOURCE_FILE (insn) == NOTE_SOURCE_FILE (last)))\n \t      {\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t\tdelete_note (insn);\n \t\tcontinue;\n \t      }\n \t    last = insn;\n@@ -2719,9 +2718,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t       (It would not be recognized.)  */\n \t    if (SET_SRC (body) == pc_rtx)\n \t      {\n-\t\tPUT_CODE (insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t        delete_insn (insn);\n \t\tbreak;\n \t      }\n \t    else if (GET_CODE (SET_SRC (body)) == RETURN)\n@@ -2780,11 +2777,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t\t  else if (result == 2)\n \t\t    INSN_CODE (insn) = -1;\n \t\t  if (SET_DEST (set) == SET_SRC (set))\n-\t\t    {\n-\t\t      PUT_CODE (insn, NOTE);\n-\t\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t\t    }\n+\t\t    delete_insn (insn);\n \t\t}\n \t\tbreak;\n \n@@ -2902,10 +2895,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t\t prev = PREV_INSN (prev))\n \t      {\n \t\tif (GET_CODE (prev) == NOTE)\n-\t\t  {\n-\t\t    NOTE_LINE_NUMBER (prev) = NOTE_INSN_DELETED;\n-\t\t    NOTE_SOURCE_FILE (prev) = 0;\n-\t\t  }\n+\t\t  delete_insn (prev);\t/* Use delete_note.  */\n \t      }\n \n \t    return prev;"}, {"sha": "c6fa510ef4059c501035bd22aae9a138c0f5c283", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -1719,11 +1719,7 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n \t\t     find_reg_note (XEXP (note, 0), REG_RETVAL,\n \t\t\t\t    NULL_RTX));\n \n-      /* In unoptimized compilation, we shouldn't call delete_insn\n-\t except in jump.c doing warnings.  */\n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (insn) = 0;\n+      delete_insn (insn);\n     }\n \n   /* The insn to load VAR from a home in the arglist\n@@ -1744,11 +1740,7 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n \t\t   && SET_DEST (prev_set) == SET_SRC (set)\n \t\t   && rtx_equal_p (SET_SRC (prev_set), var))))\n     {\n-      /* In unoptimized compilation, we shouldn't call delete_insn\n-\t except in jump.c doing warnings.  */\n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (insn) = 0;\n+      delete_insn (insn);\n     }\n   else\n     {\n@@ -2360,9 +2352,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t  REG_NOTES (insn) = REG_NOTES (last);\n \t\tPATTERN (insn) = PATTERN (last);\n \n-\t\tPUT_CODE (last, NOTE);\n-\t\tNOTE_LINE_NUMBER (last) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (last) = 0;\n+\t\tdelete_insn (last);\n \t      }\n \t    else\n \t      PATTERN (insn) = pat;\n@@ -2405,9 +2395,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t  REG_NOTES (insn) = REG_NOTES (last);\n \t\tPATTERN (insn) = PATTERN (last);\n \n-\t\tPUT_CODE (last, NOTE);\n-\t\tNOTE_LINE_NUMBER (last) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (last) = 0;\n+\t\tdelete_insn (last);\n \t      }\n \t    else\n \t      PATTERN (insn) = pat;\n@@ -7154,9 +7142,7 @@ keep_stack_depressed (seq)\n \t    sp_modified_unknown = 1;\n \n \t  /* Don't allow the SP modification to happen.  */\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  delete_insn (insn);\n \t}\n       else if (reg_referenced_p (stack_pointer_rtx, PATTERN (insn)))\n \t{"}, {"sha": "e5b6e4aef7ef1e0ca9c1bf7081b4011559cc4738", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -4102,9 +4102,7 @@ cprop_cc0_jump (bb, insn, reg_used, src)\n     return 0;\n \n   /* If we succeeded, delete the cc0 setter.  */\n-  PUT_CODE (insn, NOTE);\n-  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-  NOTE_SOURCE_FILE (insn) = 0;\n+  delete_insn (insn);\n \n   return 1;\n  }"}, {"sha": "e0e8d812e653132f404a18d41d9842a894047ea9", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -1107,9 +1107,7 @@ update_equiv_regs ()\n \t\t      remove_death (regno, insn);\n \t\t      REG_N_REFS (regno) = 0;\n \t\t      REG_FREQ (regno) = 0;\n-\t\t      PUT_CODE (equiv_insn, NOTE);\n-\t\t      NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n-\t\t      NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t      delete_insn (equiv_insn);\n \t\t      \n \t\t      reg_equiv[regno].init_insns\n \t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n@@ -1128,9 +1126,7 @@ update_equiv_regs ()\n \t\t\t otherwise eliminate_regs_in_insn will abort.  */\n \t\t      INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n \n-\t\t      PUT_CODE (equiv_insn, NOTE);\n-\t\t      NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n-\t\t      NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t      delete_insn (equiv_insn);\n \n \t\t      XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n "}, {"sha": "601828a666d19e5cdb9378e23c585ed6ee91de92", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -807,9 +807,7 @@ scan_loop (loop, flags)\n \t\t    = replace_rtx (REG_NOTES (regs->array[regno].single_usage),\n \t\t\t\t   SET_DEST (set), copy_rtx (SET_SRC (set)));\n \n-\t\t  PUT_CODE (p, NOTE);\n-\t\t  NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (p) = 0;\n+\t\t  delete_insn (p);\n \t\t  regs->array[regno].set_in_loop = 0;\n \t\t  continue;\n \t\t}\n@@ -9340,11 +9338,10 @@ loop_delete_insns (first, last)\n {\n   while (1)\n     {\n-      PUT_CODE (first, NOTE);\n-      NOTE_LINE_NUMBER (first) = NOTE_INSN_DELETED;\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \", deleting init_insn (%d)\",\n \t\t INSN_UID (first));\n+      delete_insn (first);\n \n       /* If this was the LAST instructions we're supposed to delete,\n \t we're done.  */"}, {"sha": "e15df721cd78074d412db0f9b91ab0af6fdd5822", "filename": "gcc/predict.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -832,9 +832,6 @@ static void\n estimate_bb_frequencies (loops)\n      struct loops *loops;\n {\n-  block_info bi;\n-  edge_info ei;\n-  int edgenum = 0;\n   int i;\n   double freq_max = 0;\n \n@@ -891,8 +888,8 @@ estimate_bb_frequencies (loops)\n   ENTRY_BLOCK_PTR->succ->probability = REG_BR_PROB_BASE;\n \n   /* Set up block info for each basic block.  */\n-  bi = (block_info) xcalloc ((n_basic_blocks + 2), sizeof (*bi));\n-  ei = (edge_info) xcalloc ((n_edges), sizeof (*ei));\n+  alloc_aux_for_blocks (sizeof (struct block_info_def));\n+  alloc_aux_for_edges (sizeof (struct edge_info_def));\n   for (i = -2; i < n_basic_blocks; i++)\n     {\n       edge e;\n@@ -904,14 +901,10 @@ estimate_bb_frequencies (loops)\n \tbb = EXIT_BLOCK_PTR;\n       else\n \tbb = BASIC_BLOCK (i);\n-      bb->aux = bi + i + 2;\n       BLOCK_INFO (bb)->tovisit = 0;\n       for (e = bb->succ; e; e = e->succ_next)\n-\t{\n-\t  e->aux = ei + edgenum, edgenum++;\n-\t  EDGE_INFO (e)->back_edge_prob = ((double) e->probability\n-\t\t\t\t\t   / REG_BR_PROB_BASE);\n-\t}\n+\tEDGE_INFO (e)->back_edge_prob = ((double) e->probability\n+\t\t\t\t\t / REG_BR_PROB_BASE);\n     }\n   /* First compute probabilities locally for each loop from innermost\n      to outermost to examine probabilities for back edges.  */\n@@ -940,6 +933,6 @@ estimate_bb_frequencies (loops)\n \t\t       + 0.5);\n     }\n \n-  free (ei);\n-  free (bi);\n+  free_aux_for_blocks ();\n+  free_aux_for_edges ();\n }"}, {"sha": "44cd15d063eb9670f8219bfce9cbedde4a71e5cd", "filename": "gcc/profile.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -217,18 +217,15 @@ compute_branch_probabilities ()\n   int hist_br_prob[20];\n   int num_never_executed;\n   int num_branches;\n-  struct bb_info *bb_infos;\n \n   /* Attach extra info block to each bb.  */\n \n-  bb_infos = (struct bb_info *)\n-    xcalloc (n_basic_blocks + 2, sizeof (struct bb_info));\n+  alloc_aux_for_blocks (sizeof (struct bb_info));\n   for (i = 0; i < n_basic_blocks + 2; i++)\n     {\n       basic_block bb = GCOV_INDEX_TO_BB (i);\n       edge e;\n \n-      bb->aux = &bb_infos[i];\n       for (e = bb->succ; e; e = e->succ_next)\n \tif (!EDGE_INFO (e)->ignore)\n \t  BB_INFO (bb)->succ_count++;\n@@ -496,7 +493,7 @@ compute_branch_probabilities ()\n       fputc ('\\n', rtl_dump_file);\n     }\n \n-  free (bb_infos);\n+  free_aux_for_blocks ();\n }\n \n /* Instrument and/or analyze program behavior based on program flow graph.\n@@ -520,7 +517,6 @@ branch_prob ()\n {\n   int i;\n   int num_edges, ignored_edges;\n-  struct edge_info *edge_infos;\n   struct edge_list *el;\n \n   /* Start of a function.  */\n@@ -612,15 +608,13 @@ branch_prob ()\n \n   el = create_edge_list ();\n   num_edges = NUM_EDGES (el);\n-  edge_infos = (struct edge_info *)\n-    xcalloc (num_edges, sizeof (struct edge_info));\n+  alloc_aux_for_edges (sizeof (struct edge_info));\n \n   ignored_edges = 0;\n   for (i = 0 ; i < num_edges ; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n       e->count = 0;\n-      e->aux = &edge_infos[i];\n \n       /* Mark edges we've replaced by fake edges above as ignored.  */\n       if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n@@ -803,7 +797,7 @@ branch_prob ()\n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);\n \n-  free (edge_infos);\n+  free_aux_for_edges ();\n   free_edge_list (el);\n }\n \f\n@@ -904,6 +898,11 @@ find_spanning_tree (el)\n \t  union_groups (e->src, e->dest);\n \t}\n     }\n+\n+  EXIT_BLOCK_PTR->aux = NULL;\n+  ENTRY_BLOCK_PTR->aux = NULL;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BASIC_BLOCK (i)->aux = NULL;\n }\n \f\n /* Perform file-level initialization for branch-prob processing.  */"}, {"sha": "2b39b71d7bcf0de30336fce3f187719f1035a38a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -420,7 +420,6 @@ reg_to_stack (first, file)\n {\n   int i;\n   int max_uid;\n-  block_info bi;\n \n   /* Clean up previous run.  */\n   if (stack_regs_mentioned_data)\n@@ -449,18 +448,16 @@ reg_to_stack (first, file)\n   mark_dfs_back_edges ();\n \n   /* Set up block info for each basic block.  */\n-  bi = (block_info) xcalloc ((n_basic_blocks + 1), sizeof (*bi));\n+  alloc_aux_for_blocks (sizeof (struct block_info_def));\n   for (i = n_basic_blocks - 1; i >= 0; --i)\n     {\n       edge e;\n       basic_block bb = BASIC_BLOCK (i);\n-      bb->aux = bi + i;\n       for (e = bb->pred; e; e=e->pred_next)\n \tif (!(e->flags & EDGE_DFS_BACK)\n \t    && e->src != ENTRY_BLOCK_PTR)\n \t  BLOCK_INFO (bb)->predecesors++;\n     }\n-  EXIT_BLOCK_PTR->aux = bi + n_basic_blocks;\n \n   /* Create the replacement registers up front.  */\n   for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -500,7 +497,7 @@ reg_to_stack (first, file)\n \n   convert_regs (file);\n \n-  free (bi);\n+  free_aux_for_blocks ();\n }\n \f\n /* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the"}, {"sha": "8e2f315611f52c143dbab079083987cc5046df49", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -148,11 +148,7 @@ try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n \t\t    = gen_rtx_EXPR_LIST (REG_INC,\n \t\t\t\t\t reg, REG_NOTES (insn));\n \t\t  if (! inc_insn_set)\n-\t\t    {\n-\t\t      PUT_CODE (inc_insn, NOTE);\n-\t\t      NOTE_LINE_NUMBER (inc_insn) = NOTE_INSN_DELETED;\n-\t\t      NOTE_SOURCE_FILE (inc_insn) = 0;\n-\t\t    }\n+\t\t    delete_insn (inc_insn);\n \t\t  return 1;\n \t\t}\n \t    }\n@@ -1895,9 +1891,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t  rtx notes = REG_NOTES (insn);\n \n \t  emit_insn_after_with_line_notes (pat, PREV_INSN (p), insn);\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  delete_insn (insn);\n \t  /* emit_insn_after_with_line_notes has no\n \t     return value, so search for the new insn.  */\n \t  insn = p;\n@@ -1949,9 +1943,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t  if (q && set2 && SET_DEST (set2) == src && CONSTANT_P (SET_SRC (set2))\n \t      && validate_change (insn, &SET_SRC (set), XEXP (note, 0), 0))\n \t    {\n-\t      PUT_CODE (q, NOTE);\n-\t      NOTE_LINE_NUMBER (q) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (q) = 0;\n+\t      delete_insn (q);\n \t      REG_N_SETS (REGNO (src))--;\n \t      REG_N_CALLS_CROSSED (REGNO (src)) -= num_calls2;\n \t      REG_LIVE_LENGTH (REGNO (src)) -= s_length2;"}, {"sha": "820843257a28dc07caa02b6f4a838a45bfec24ee", "filename": "gcc/reload1.c", "status": "modified", "additions": 14, "deletions": 60, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -1263,7 +1263,6 @@ reload (first, global)\n   /* Free all the insn_chain structures at once.  */\n   obstack_free (&reload_obstack, reload_startobj);\n   unused_insn_chains = 0;\n-  compute_bb_for_insn (get_max_uid ());\n   fixup_abnormal_edges ();\n \n   return failure;\n@@ -1465,9 +1464,7 @@ calculate_needs_all_insns (global)\n \t\t  && GET_CODE (SET_SRC (set)) == REG\n \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t  delete_insn (insn);\n \t\t  /* Delete it from the reload chain */\n \t\t  if (chain->prev)\n \t\t    chain->prev->next = next;\n@@ -1851,17 +1848,9 @@ delete_caller_save_insns ()\n \t  struct insn_chain *next = c->next;\n \t  rtx insn = c->insn;\n \n-\t  if (insn == BLOCK_HEAD (c->block))\n-\t    BLOCK_HEAD (c->block) = NEXT_INSN (insn);\n-\t  if (insn == BLOCK_END (c->block))\n-\t    BLOCK_END (c->block) = PREV_INSN (insn);\n \t  if (c == reload_insn_chain)\n \t    reload_insn_chain = next;\n-\n-\t  if (NEXT_INSN (insn) != 0)\n-\t    PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n-\t  if (PREV_INSN (insn) != 0)\n-\t    NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n+\t  delete_insn (insn);\n \n \t  if (next)\n \t    next->prev = c->prev;\n@@ -3908,9 +3897,7 @@ reload_as_needed (live_known)\n \t\t    {\n \t\t      error_for_asm (insn,\n \t\t\t\t     \"`asm' operand requires impossible reload\");\n-\t\t      PUT_CODE (p, NOTE);\n-\t\t      NOTE_SOURCE_FILE (p) = 0;\n-\t\t      NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n+\t\t      delete_insn (p);\n \t\t    }\n \t    }\n \n@@ -6941,8 +6928,6 @@ emit_reload_insns (chain)\n   rtx insn = chain->insn;\n \n   register int j;\n-  rtx following_insn = NEXT_INSN (insn);\n-  rtx before_insn = PREV_INSN (insn);\n \n   CLEAR_HARD_REG_SET (reg_reloaded_died);\n \n@@ -7018,19 +7003,10 @@ emit_reload_insns (chain)\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n-      emit_insns_before (outaddr_address_reload_insns[j], following_insn);\n-      emit_insns_before (output_address_reload_insns[j], following_insn);\n-      emit_insns_before (output_reload_insns[j], following_insn);\n-      emit_insns_before (other_output_reload_insns[j], following_insn);\n-    }\n-\n-  /* Keep basic block info up to date.  */\n-  if (n_basic_blocks)\n-    {\n-      if (BLOCK_HEAD (chain->block) == insn)\n-\tBLOCK_HEAD (chain->block) = NEXT_INSN (before_insn);\n-      if (BLOCK_END (chain->block) == insn)\n-\tBLOCK_END (chain->block) = PREV_INSN (following_insn);\n+      rtx x = emit_insns_after (outaddr_address_reload_insns[j], insn);\n+      x = emit_insns_after (output_address_reload_insns[j], x);\n+      x = emit_insns_after (output_reload_insns[j], x);\n+      emit_insns_after (other_output_reload_insns[j], x);\n     }\n \n   /* For all the spill regs newly reloaded in this instruction,\n@@ -7669,9 +7645,7 @@ delete_output_reload (insn, j, last_reload_reg)\n \t      /* Some other ref remains; just delete the output reload we\n \t\t know to be dead.  */\n \t      delete_address_reloads (output_reload_insn, insn);\n-\t      PUT_CODE (output_reload_insn, NOTE);\n-\t      NOTE_SOURCE_FILE (output_reload_insn) = 0;\n-\t      NOTE_LINE_NUMBER (output_reload_insn) = NOTE_INSN_DELETED;\n+\t      delete_insn (output_reload_insn);\n \t      return;\n \t    }\n \t}\n@@ -7686,9 +7660,7 @@ delete_output_reload (insn, j, last_reload_reg)\n \t      delete_address_reloads (i2, insn);\n \t      /* This might be a basic block head,\n \t\t thus don't use delete_insn.  */\n-\t      PUT_CODE (i2, NOTE);\n-\t      NOTE_SOURCE_FILE (i2) = 0;\n-\t      NOTE_LINE_NUMBER (i2) = NOTE_INSN_DELETED;\n+\t      delete_insn (i2);\n \t    }\n \t  if (GET_CODE (i2) == CODE_LABEL\n \t      || GET_CODE (i2) == JUMP_INSN)\n@@ -7701,9 +7673,7 @@ delete_output_reload (insn, j, last_reload_reg)\n       alter_reg (REGNO (reg), -1);\n     }\n   delete_address_reloads (output_reload_insn, insn);\n-  PUT_CODE (output_reload_insn, NOTE);\n-  NOTE_SOURCE_FILE (output_reload_insn) = 0;\n-  NOTE_LINE_NUMBER (output_reload_insn) = NOTE_INSN_DELETED;\n+  delete_insn (output_reload_insn);\n \n }\n \n@@ -7852,10 +7822,7 @@ delete_address_reloads_1 (dead_insn, x, current_insn)\n     }\n   delete_address_reloads_1 (prev, SET_SRC (set), current_insn);\n   reg_reloaded_contents[REGNO (dst)] = -1;\n-  /* Can't use delete_insn here because PREV might be a basic block head.  */\n-  PUT_CODE (prev, NOTE);\n-  NOTE_LINE_NUMBER (prev) = NOTE_INSN_DELETED;\n-  NOTE_SOURCE_FILE (prev) = 0;\n+  delete_insn (prev);\n }\n \f\n /* Output reload-insns to reload VALUE into RELOADREG.\n@@ -8026,11 +7993,7 @@ reload_cse_delete_noop_set (insn, value)\n       REG_NOTES (insn) = NULL_RTX;\n     }\n   else\n-    {\n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (insn) = 0;\n-    }\n+    delete_insn (insn);\n }\n \n /* See whether a single set SET is a noop.  */\n@@ -8782,9 +8745,7 @@ reload_combine ()\n \t\t  rtx *np;\n \n \t\t  /* Delete the reg-reg addition.  */\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t  delete_insn (insn);\n \n \t\t  if (reg_state[regno].offset != const0_rtx)\n \t\t    /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n@@ -9226,14 +9187,7 @@ reload_cse_move2add (first)\n \t\t\t  = validate_change (next, &PATTERN (next),\n \t\t\t\t\t     gen_add2_insn (reg, new_src), 0);\n \t\t      if (success)\n-\t\t\t{\n-\t\t\t  /* INSN might be the first insn in a basic block\n-\t\t\t     if the preceding insn is a conditional jump\n-\t\t\t     or a possible-throwing call.  */\n-\t\t\t  PUT_CODE (insn, NOTE);\n-\t\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t\t}\n+\t\t\tdelete_insn (insn);\n \t\t      insn = next;\n \t\t      reg_mode[regno] = GET_MODE (reg);\n \t\t      reg_offset[regno] = sext_for_mode (GET_MODE (reg),"}, {"sha": "4e979cd6b38427e1df41ac66d49b545652247ec5", "filename": "gcc/sibcall.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -555,9 +555,7 @@ replace_call_placeholder (insn, use)\n     LABEL_PRESERVE_P (XEXP (PATTERN (insn), 3)) = 0;\n   \n   /* \"Delete\" the placeholder insn.  */\n-  PUT_CODE (insn, NOTE);\n-  NOTE_SOURCE_FILE (insn) = 0;\n-  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+  remove_insn (insn);\n }\n \n /* Given a (possibly empty) set of potential sibling or tail recursion call"}, {"sha": "c0fe373fdfbccc5f2ca98d61938b008e99bea6aa", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6c03cabd8de0c3d6614ffd3100eb063778871b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=ca6c03cabd8de0c3d6614ffd3100eb063778871b", "patch": "@@ -2154,14 +2154,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t      /* If this is now a no-op, delete it.  */\n \t      if (map->last_pc_value == pc_rtx)\n \t\t{\n-\t\t  /* Don't let delete_insn delete the label referenced here,\n-\t\t     because we might possibly need it later for some other\n-\t\t     instruction in the loop.  */\n-\t\t  if (JUMP_LABEL (copy))\n-\t\t    LABEL_NUSES (JUMP_LABEL (copy))++;\n-\t\t  delete_related_insns (copy);\n-\t\t  if (JUMP_LABEL (copy))\n-\t\t    LABEL_NUSES (JUMP_LABEL (copy))--;\n+\t\t  delete_insn (copy);\n \t\t  copy = 0;\n \t\t}\n \t      else"}]}