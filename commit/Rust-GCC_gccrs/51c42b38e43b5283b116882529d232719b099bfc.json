{"sha": "51c42b38e43b5283b116882529d232719b099bfc", "node_id": "C_kwDOANBUbNoAKDUxYzQyYjM4ZTQzYjUyODNiMTE2ODgyNTI5ZDIzMjcxOWIwOTliZmM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-02T15:19:51Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-02T15:19:51Z"}, "message": "libstdc++: Fix laziness of __and/or/not_\n\nr13-2230-g390f94eee1ae69 redefined the internal logical operator traits\n__and_, __or_ and __not_ as alias templates that directly resolve to\ntrue_type or false_type.  But it turns out using an alias template here\ncauses the traits to be less lazy than before because we now compute the\nlogical result immediately upon _specialization_ of the trait, and not\nlater upon _completion_ of the specialization.\n\nSo for example, in\n\n  using type = __and_<A, __not_<B>>;\n\nwe now compute the conjunction and thus instantiate A even though we're\nin a context that doesn't require completion of the __and_.  What's\nworse is that we also compute the inner negation and thus instantiate B\n(for the same reason), independent of the __and_ and the value of A!\nThus the traits are now less lazy and composable than before.\n\nFortunately, the fix is cheap and straightforward: redefine these traits\nas class templates instead of as alias templates so that computation of\nthe logical result is triggered by completion, not by specialization.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (__or_, __and_, __not_): Redefine as a\n\tclass template instead of as an alias template.\n\t* testsuite/20_util/logical_traits/requirements/short_circuit.cc:\n\tAdd more tests for conjunction and disjunction.  Add corresponding\n\ttests for __and_ and __or_.", "tree": {"sha": "a6f7798576181332772fd734822dd47473ec880b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6f7798576181332772fd734822dd47473ec880b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51c42b38e43b5283b116882529d232719b099bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c42b38e43b5283b116882529d232719b099bfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51c42b38e43b5283b116882529d232719b099bfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c42b38e43b5283b116882529d232719b099bfc/comments", "author": null, "committer": null, "parents": [{"sha": "67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b6d1be0623de1a8aa32fe249bfa0129c55b11a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b6d1be0623de1a8aa32fe249bfa0129c55b11a"}], "stats": {"total": 41, "additions": 38, "deletions": 3}, "files": [{"sha": "be9f2955539540b82d0489482579f253ef52efb8", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c42b38e43b5283b116882529d232719b099bfc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c42b38e43b5283b116882529d232719b099bfc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=51c42b38e43b5283b116882529d232719b099bfc", "patch": "@@ -168,13 +168,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // to either true_type or false_type which allows for a more efficient\n   // implementation that avoids recursive class template instantiation.\n   template<typename... _Bn>\n-    using __or_ = decltype(__detail::__or_fn<_Bn...>(0));\n+    struct __or_\n+    : decltype(__detail::__or_fn<_Bn...>(0))\n+    { };\n \n   template<typename... _Bn>\n-    using __and_ = decltype(__detail::__and_fn<_Bn...>(0));\n+    struct __and_\n+    : decltype(__detail::__and_fn<_Bn...>(0))\n+    { };\n \n   template<typename _Pp>\n-    using __not_ = __bool_constant<!bool(_Pp::value)>;\n+    struct __not_\n+    : __bool_constant<!bool(_Pp::value)>\n+    { };\n   /// @endcond\n \n #if __cplusplus >= 201703L"}, {"sha": "ff90f8a47c318c9af7d04f4bbd9bb9bf35de7992", "filename": "libstdc++-v3/testsuite/20_util/logical_traits/requirements/short_circuit.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c42b38e43b5283b116882529d232719b099bfc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Flogical_traits%2Frequirements%2Fshort_circuit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c42b38e43b5283b116882529d232719b099bfc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Flogical_traits%2Frequirements%2Fshort_circuit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Flogical_traits%2Frequirements%2Fshort_circuit.cc?ref=51c42b38e43b5283b116882529d232719b099bfc", "patch": "@@ -14,6 +14,10 @@ static_assert(!std::conjunction_v<std::false_type, invalid>);\n static_assert(!std::conjunction_v<std::false_type, invalid, invalid>);\n static_assert(!std::conjunction_v<std::true_type, std::false_type, invalid>);\n static_assert(!std::conjunction_v<std::true_type, std::false_type, invalid, invalid>);\n+static_assert(!std::conjunction_v<std::false_type,\n+\t\t\t\t  std::conjunction<invalid>,\n+\t\t\t\t  std::disjunction<invalid>,\n+\t\t\t\t  std::negation<invalid>>);\n \n // [meta.logical]/8: For a specialization disjunction<B_1, ..., B_n>, if\n // there is a template type argument B_i for which bool(B_i::value) is true,\n@@ -24,3 +28,28 @@ static_assert(std::disjunction_v<std::true_type, invalid>);\n static_assert(std::disjunction_v<std::true_type, invalid, invalid>);\n static_assert(std::disjunction_v<std::false_type, std::true_type, invalid>);\n static_assert(std::disjunction_v<std::false_type, std::true_type, invalid, invalid>);\n+static_assert(std::disjunction_v<std::true_type,\n+\t\t\t\t std::conjunction<invalid>,\n+\t\t\t\t std::disjunction<invalid>,\n+\t\t\t\t std::negation<invalid>>);\n+\n+#if __GLIBCXX__\n+// Also test the corresponding internal traits __and_, __or_ and __not_.\n+static_assert(!std::__and_v<std::false_type, invalid>);\n+static_assert(!std::__and_v<std::false_type, invalid, invalid>);\n+static_assert(!std::__and_v<std::true_type, std::false_type, invalid>);\n+static_assert(!std::__and_v<std::true_type, std::false_type, invalid, invalid>);\n+static_assert(!std::__and_v<std::false_type,\n+\t\t\t    std::__and_<invalid>,\n+\t\t\t    std::__or_<invalid>,\n+\t\t\t    std::__not_<invalid>>);\n+\n+static_assert(std::__or_v<std::true_type, invalid>);\n+static_assert(std::__or_v<std::true_type, invalid, invalid>);\n+static_assert(std::__or_v<std::false_type, std::true_type, invalid>);\n+static_assert(std::__or_v<std::false_type, std::true_type, invalid, invalid>);\n+static_assert(std::__or_v<std::true_type,\n+\t\t\t  std::__and_<invalid>,\n+\t\t\t  std::__or_<invalid>,\n+\t\t\t  std::__not_<invalid>>);\n+#endif"}]}