{"sha": "01e54ef86f407385b0f2bb7afb5748f0db31bce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFlNTRlZjg2ZjQwNzM4NWIwZjJiYjdhZmI1NzQ4ZjBkYjMxYmNlOA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-08-02T14:23:38Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-08-02T14:23:38Z"}, "message": "re PR rtl-optimization/57963 (LRA S/390: esa mode failure memcpy-chk)\n\n2013-08-02  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/57963\n\t* lra-constraints.c (reverse_equiv_p, contains_reloaded_insn_p):\n\tNew.\n\t(lra_constraints): Use them.\n\nFrom-SVN: r201438", "tree": {"sha": "a8d03ad274dd5b88c91925649ec285612f10e96a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8d03ad274dd5b88c91925649ec285612f10e96a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01e54ef86f407385b0f2bb7afb5748f0db31bce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e54ef86f407385b0f2bb7afb5748f0db31bce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01e54ef86f407385b0f2bb7afb5748f0db31bce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e54ef86f407385b0f2bb7afb5748f0db31bce8/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e2fd7ca74819ba4db334430582c163a3efeaada4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2fd7ca74819ba4db334430582c163a3efeaada4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2fd7ca74819ba4db334430582c163a3efeaada4"}], "stats": {"total": 56, "additions": 48, "deletions": 8}, "files": [{"sha": "94a65d2bdb57b2298261c593f3ac100355cfce60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e54ef86f407385b0f2bb7afb5748f0db31bce8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e54ef86f407385b0f2bb7afb5748f0db31bce8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01e54ef86f407385b0f2bb7afb5748f0db31bce8", "patch": "@@ -1,3 +1,10 @@\n+2013-08-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/57963\n+\t* lra-constraints.c (reverse_equiv_p, contains_reloaded_insn_p):\n+\tNew.\n+\t(lra_constraints): Use them.\n+\n 2013-08-02  Sofiane Naci  <sofiane.naci@arm.com>\n \n \t* config/arm/types.md (define_attr \"type\"): Add \"load_acq\" and \"store_rel\"."}, {"sha": "ced02a4135605e6bfa70ae8553a03ce8c46e77ff", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e54ef86f407385b0f2bb7afb5748f0db31bce8/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e54ef86f407385b0f2bb7afb5748f0db31bce8/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=01e54ef86f407385b0f2bb7afb5748f0db31bce8", "patch": "@@ -3600,6 +3600,40 @@ init_insn_rhs_dead_pseudo_p (int regno)\n   return false;\n }\n \n+/* Return TRUE if REGNO has a reverse equivalence.  The equivalence is\n+   reverse only if we have one init insn with given REGNO as a\n+   source.  */\n+static bool\n+reverse_equiv_p (int regno)\n+{\n+  rtx insns, set;\n+\n+  if ((insns = ira_reg_equiv[regno].init_insns) == NULL_RTX)\n+    return false;\n+  if (! INSN_P (XEXP (insns, 0))\n+      || XEXP (insns, 1) != NULL_RTX)\n+    return false;\n+  if ((set = single_set (XEXP (insns, 0))) == NULL_RTX)\n+    return false;\n+  return REG_P (SET_SRC (set)) && (int) REGNO (SET_SRC (set)) == regno;\n+}\n+\n+/* Return TRUE if REGNO was reloaded in an equivalence init insn.  We\n+   call this function only for non-reverse equivalence.  */\n+static bool\n+contains_reloaded_insn_p (int regno)\n+{\n+  rtx set;\n+  rtx list = ira_reg_equiv[regno].init_insns;\n+\n+  for (; list != NULL_RTX; list = XEXP (list, 1))\n+    if ((set = single_set (XEXP (list, 0))) == NULL_RTX\n+\t|| ! REG_P (SET_DEST (set))\n+\t|| (int) REGNO (SET_DEST (set)) != regno)\n+      return true;\n+  return false;\n+}\n+\n /* Entry function of LRA constraint pass.  Return true if the\n    constraint pass did change the code.\t */\n bool\n@@ -3643,7 +3677,6 @@ lra_constraints (bool first_p)\n \telse if ((x = get_equiv_substitution (reg)) != reg)\n \t  {\n \t    bool pseudo_p = contains_reg_p (x, false, false);\n-\t    rtx set, insns;\n \n \t    /* After RTL transformation, we can not guarantee that\n \t       pseudo in the substitution was not reloaded which might\n@@ -3675,13 +3708,13 @@ lra_constraints (bool first_p)\n \t\t   removed the insn.  When the equiv can be a\n \t\t   constant, the right hand side of the init insn can\n \t\t   be a pseudo.  */\n-\t\t|| (! ((insns = ira_reg_equiv[i].init_insns) != NULL_RTX\n-\t\t       && INSN_P (XEXP (insns, 0))\n-\t\t       && XEXP (insns, 1) == NULL_RTX\n-\t\t       && (set = single_set (XEXP (insns, 0))) != NULL_RTX\n-\t\t       && REG_P (SET_SRC (set))\n-\t\t       && (int) REGNO (SET_SRC (set)) == i)\n-\t\t    && init_insn_rhs_dead_pseudo_p (i))\n+\t\t|| (! reverse_equiv_p (i)\n+\t\t    && (init_insn_rhs_dead_pseudo_p (i)\n+\t\t\t/* If we reloaded the pseudo in an equivalence\n+\t\t\t   init insn, we can not remove the equiv init\n+\t\t\t   insns and the init insns might write into\n+\t\t\t   const memory in this case.  */\n+\t\t\t|| contains_reloaded_insn_p (i)))\n \t\t/* Prevent access beyond equivalent memory for\n \t\t   paradoxical subregs.  */\n \t\t|| (MEM_P (x)"}]}