{"sha": "4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNmZDkzNzQ2MjQyZGM2ZTczZjRmYTcxNTIwYmIzNjFhMmQ2ZGU0YQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-27T07:11:48Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Testing some more algorithmic changes\n\nFixed syntax errors", "tree": {"sha": "3d664542f2ac5b07cd4a535b3fe3cfab93c99d59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d664542f2ac5b07cd4a535b3fe3cfab93c99d59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cfd93746242dc6e73f4fa71520bb361a2d6de4a/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fbc20189d0a9648c2ab6f4f9a7cf0bd82e73186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fbc20189d0a9648c2ab6f4f9a7cf0bd82e73186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fbc20189d0a9648c2ab6f4f9a7cf0bd82e73186"}], "stats": {"total": 491, "additions": 389, "deletions": 102}, "files": [{"sha": "286d7a4c2c8c3126841be985f9fa0c39a1b5ead1", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 379, "deletions": 102, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cfd93746242dc6e73f4fa71520bb361a2d6de4a/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cfd93746242dc6e73f4fa71520bb361a2d6de4a/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "patch": "@@ -546,19 +546,15 @@ Parser<ManagedTokenSource>::parse_simple_path ()\n \n   // get location if not gotten already\n   if (locus == Linemap::unknown_location ())\n-    {\n-      locus = segment.get_locus ();\n-    }\n+    locus = segment.get_locus ();\n \n   std::vector<AST::SimplePathSegment> segments;\n \n   // Return empty vector if first, actually required segment is an error\n   if (segment.is_error ())\n-    {\n-      return AST::SimplePath::create_empty ();\n-    }\n+    return AST::SimplePath::create_empty ();\n \n-  segments.push_back (segment);\n+  segments.push_back (std::move (segment));\n \n   // Parse all other simple path segments\n   while (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION)\n@@ -570,10 +566,9 @@ Parser<ManagedTokenSource>::parse_simple_path ()\n \n       // Return path as currently constructed if segment in error state.\n       if (new_segment.is_error ())\n-\t{\n-\t  break;\n-\t}\n-      segments.push_back (new_segment);\n+\tbreak;\n+\n+      segments.push_back (std::move (new_segment));\n     }\n \n   // DEBUG: check for any empty segments\n@@ -2203,9 +2198,9 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n    * top two then try parse :: - if fails, one of top two. Next is deciding\n    * character for top two. */\n \n-  // Thus, parsing smaller parts of use tree may require feeding into function\n-  // via parameters (or could handle all in this single function because other\n-  // use tree types aren't recognised) as separate in the spec\n+  /* Thus, parsing smaller parts of use tree may require feeding into function\n+   * via parameters (or could handle all in this single function because other\n+   * use tree types aren't recognised as separate in the spec) */\n \n   // TODO: I think this function is too complex, probably should split it\n \n@@ -2546,7 +2541,7 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n   fprintf (stderr, \"skipped left angle in generic param\\n\");\n \n   std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n-    = parse_generic_params ();\n+    = parse_generic_params (is_right_angle_tok);\n \n   // DEBUG:\n   fprintf (stderr,\n@@ -2579,12 +2574,12 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n   fprintf (stderr,\n \t   \"starting to parse generic params (inside angle brackets)\\n\");\n \n-  // HACK: used to retain attribute data if a lifetime param is tentatively\n-  // parsed but it turns out to be type param\n+  /* HACK: used to retain attribute data if a lifetime param is tentatively\n+   * parsed but it turns out to be type param */\n   AST::Attribute parsed_outer_attr = AST::Attribute::create_empty ();\n \n-  // HACK: generic params always in angle brackets with current syntax, so have\n-  // that as end char\n+  /* HACK: generic params always in angle brackets with current syntax, so have\n+   * that as end char */\n   const_TokenPtr t = lexer.peek_token ();\n   // parse lifetime params\n   while (!is_right_angle_tok (t->get_id ()))\n@@ -2618,7 +2613,8 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t{\n \t  lexer.skip_token ();\n \t  // parse required bounds\n-\t  lifetime_bounds = parse_lifetime_bounds ();\n+\t  lifetime_bounds = parse_lifetime_bounds (\n+\t    [] (TokenId id) { return is_right_angle_tok (id) || id == COMMA; });\n \t}\n \n       std::unique_ptr<AST::LifetimeParam> param (\n@@ -2752,6 +2748,163 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n   return generic_params;\n }\n \n+/* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n+ * always parse_generic_params_in_angles is what is wanted. */\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<std::unique_ptr<AST::GenericParam> >\n+Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n+{\n+  std::vector<std::unique_ptr<AST::GenericParam> > generic_params;\n+\n+  /* can't parse lifetime and type params separately due to lookahead issues\n+   * thus, parse them all here */\n+\n+  /* HACK: used to retain attribute data if a lifetime param is tentatively\n+   * parsed but it turns out to be type param */\n+  AST::Attribute parsed_outer_attr = AST::Attribute::create_empty ();\n+\n+  const_TokenPtr t = lexer.peek_token ();\n+  // parse lifetime params\n+  while (!is_end_token (t->get_id ()))\n+    {\n+      // HACK: reimpl of lifetime param parsing\n+      AST::Attribute outer_attr = parse_outer_attribute ();\n+\n+      // move attribute outward if type param\n+      if (lexer.peek_token ()->get_id () != LIFETIME)\n+\t{\n+\t  parsed_outer_attr = std::move (outer_attr);\n+\t  break;\n+\t}\n+\n+      Location locus = lexer.peek_token ()->get_locus ();\n+      AST::Lifetime lifetime = parse_lifetime ();\n+\n+      // parse optional bounds\n+      std::vector<AST::Lifetime> lifetime_bounds;\n+      if (lexer.peek_token ()->get_id () == COLON)\n+\t{\n+\t  lexer.skip_token ();\n+\t  // parse required bounds\n+\t  lifetime_bounds = parse_lifetime_bounds ([is_end_token] (TokenId id) {\n+\t    return is_end_token (id) || id == COMMA;\n+\t  });\n+\t}\n+\n+      std::unique_ptr<AST::LifetimeParam> param (\n+\tnew AST::LifetimeParam (std::move (lifetime), locus,\n+\t\t\t\tstd::move (lifetime_bounds),\n+\t\t\t\tstd::move (outer_attr)));\n+      generic_params.push_back (std::move (param));\n+\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\tbreak;\n+\n+      lexer.skip_token ();\n+      t = lexer.peek_token ();\n+    }\n+\n+  // parse type params (reimpl required for first one but not others)\n+  if (!is_end_token (lexer.peek_token ()->get_id ())\n+      && !parsed_outer_attr.is_empty ())\n+    {\n+      // reimpl as type param definitely exists\n+      const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n+      if (ident_tok == nullptr)\n+\t{\n+\t  rust_error_at (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"failed to parse identifier in type param in generic params\");\n+\t  return {};\n+\t}\n+      Identifier ident = ident_tok->get_str ();\n+\n+      // parse optional bounds\n+      std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+      if (lexer.peek_token ()->get_id () == COLON)\n+\t{\n+\t  lexer.skip_token ();\n+\n+\t  // parse optional type param bounds\n+\t  type_param_bounds = parse_type_param_bounds ();\n+\t}\n+\n+      // parse optional type\n+      std::unique_ptr<AST::Type> type = nullptr;\n+      if (lexer.peek_token ()->get_id () == EQUAL)\n+\t{\n+\t  lexer.skip_token ();\n+\n+\t  // parse required type\n+\t  type = parse_type ();\n+\t  if (type == nullptr)\n+\t    {\n+\t      rust_error_at (\n+\t\tlexer.peek_token ()->get_locus (),\n+\t\t\"failed to parse type in type param in generic params\");\n+\t      return {};\n+\t    }\n+\t}\n+\n+      std::unique_ptr<AST::TypeParam> param (\n+\tnew AST::TypeParam (std::move (ident), ident_tok->get_locus (),\n+\t\t\t    std::move (type_param_bounds), std::move (type),\n+\t\t\t    std::move (parsed_outer_attr)));\n+      generic_params.push_back (std::move (param));\n+\n+      // handle comma\n+      if (lexer.peek_token ()->get_id () == COMMA)\n+\tlexer.skip_token ();\n+    }\n+\n+  // parse rest of type params - reimpl due to right angle tokens\n+  t = lexer.peek_token ();\n+  while (!is_end_token (t->get_id ()))\n+    {\n+      std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n+\n+      if (type_param == nullptr)\n+\t{\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse type param in generic params\");\n+\t  return {};\n+\t}\n+\n+      generic_params.push_back (std::move (type_param));\n+\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\tbreak;\n+\n+      // skip commas, including trailing commas\n+      lexer.skip_token ();\n+      t = lexer.peek_token ();\n+    }\n+\n+  // old code\n+  /*\n+  // parse lifetime params (optional), allowed to end with a trailing comma\n+  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params\n+    = parse_lifetime_params();\n+  if (!lifetime_params.empty()) {\n+      // C++11 code:\n+      generic_params.insert(generic_params.end(),\n+\tstd::make_move_iterator(lifetime_params.begin()),\n+\tstd::make_move_iterator(lifetime_params.end()));\n+  }\n+\n+  // parse type params (optional)\n+  std::vector<std::unique_ptr<AST::TypeParam>> type_params =\n+  parse_type_params(); if (!type_params.empty()) {\n+      // C++11 code:\n+      generic_params.insert(generic_params.end(),\n+\tstd::make_move_iterator(type_params.begin()),\n+\tstd::make_move_iterator(type_params.end()));\n+  }*/\n+\n+  return generic_params;\n+}\n+\n /* Parses lifetime generic parameters (pointers). Will also consume any trailing\n  * comma. No extra checks for end token. */\n template <typename ManagedTokenSource>\n@@ -2801,8 +2954,8 @@ Parser<ManagedTokenSource>::parse_lifetime_params (EndTokenPred is_end_token)\n \n       if (lifetime_param.is_error ())\n \t{\n-\t  // TODO: is it worth throwing away all lifetime params just because\n-\t  // one failed?\n+\t  /* TODO: is it worth throwing away all lifetime params just because\n+\t   * one failed? */\n \t  rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t\t \"failed to parse lifetime param in lifetime params\");\n \t  return {};\n@@ -2898,7 +3051,8 @@ Parser<ManagedTokenSource>::parse_lifetime_params_objs (\n /* Parses a sequence of a certain grammar rule in object form (not pointer or\n  * smart pointer), delimited by commas and ending when 'is_end_token' is\n  * satisfied (templated). Will also consume any trailing comma.\n- * TODO: is this best solution? implements most of the same algorithm. */\n+ * FIXME: this cannot be used due to member function pointer problems (i.e.\n+ * parsing_function cannot be specified properly) */\n template <typename ManagedTokenSource>\n template <typename ParseFunction, typename EndTokenPred>\n auto\n@@ -2960,6 +3114,7 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n     {\n       // parse lifetime bounds\n       lifetime_bounds = parse_lifetime_bounds ();\n+      // TODO: have end token passed in?\n     }\n \n   return AST::LifetimeParam (std::move (lifetime), lifetime_tok->get_locus (),\n@@ -2974,8 +3129,7 @@ Parser<ManagedTokenSource>::parse_type_params ()\n {\n   std::vector<std::unique_ptr<AST::TypeParam> > type_params;\n \n-  // TODO: think of better control structure than infinite loop with break on\n-  // failure?\n+  // infinite loop with break on failure as no info on ending token\n   while (true)\n     {\n       std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n@@ -2989,16 +3143,46 @@ Parser<ManagedTokenSource>::parse_type_params ()\n       type_params.push_back (std::move (type_param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n+\tbreak;\n+\n+      // skip commas, including trailing commas\n+      lexer.skip_token ();\n+    }\n+\n+  return type_params;\n+}\n+\n+// Parses type generic parameters. Will also consume any trailing comma.\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<std::unique_ptr<AST::TypeParam> >\n+Parser<ManagedTokenSource>::parse_type_params (EndTokenPred is_end_token)\n+{\n+  std::vector<std::unique_ptr<AST::TypeParam> > type_params;\n+\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n+    {\n+      std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n+\n+      if (type_param == nullptr)\n \t{\n-\t  break;\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse type param in type params\");\n+\t  return {};\n \t}\n+\n+      type_params.push_back (std::move (type_param));\n+\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\tbreak;\n+\n       // skip commas, including trailing commas\n       lexer.skip_token ();\n     }\n \n   return type_params;\n-  // TODO: this shares most code with parse_lifetime_params - good place to use\n-  // template?\n+  /* TODO: this shares most code with parse_lifetime_params - good place to use\n+   * template (i.e. parse_non_ptr_sequence if doable) */\n }\n \n /* Parses a single type (generic) parameter, not including commas. May change to\n@@ -3244,6 +3428,7 @@ Parser<ManagedTokenSource>::parse_lifetime_where_clause_item ()\n     }\n \n   std::vector<AST::Lifetime> lifetime_bounds = parse_lifetime_bounds ();\n+  // TODO: have end token passed in?\n \n   return std::unique_ptr<AST::LifetimeWhereClauseItem> (\n     new AST::LifetimeWhereClauseItem (std::move (lifetime),\n@@ -3303,10 +3488,7 @@ Parser<ManagedTokenSource>::parse_for_lifetimes ()\n \n   /* cannot specify end token due to parsing problems with '>' tokens being\n    * nested */\n-  //params = parse_lifetime_params_objs (is_right_angle_tok);\n-  params = parse_non_ptr_sequence (\n-    parse_lifetime_param, is_right_angle_tok,\n-    \"failed to parse lifetime param in lifetime params\");\n+  params = parse_lifetime_params_objs (is_right_angle_tok);\n \n   if (!skip_generics_right_angle ())\n     {\n@@ -3335,34 +3517,74 @@ Parser<ManagedTokenSource>::parse_type_param_bounds ()\n   // quick exit if null\n   if (initial_bound == nullptr)\n     {\n-      // error? type param bounds must have at least one term, but are bounds\n-      // optional?\n+      /* error? type param bounds must have at least one term, but are bounds\n+       * optional? */\n       return type_param_bounds;\n     }\n-\n   type_param_bounds.push_back (std::move (initial_bound));\n \n-  // TODO think of better control structure than infinite loop\n-  while (true)\n+  while (lexer.peek_token ()->get_id () == PLUS)\n     {\n-      // Quick exit for no more bounds\n-      if (lexer.peek_token ()->get_id () != PLUS)\n+      lexer.skip_token ();\n+\n+      std::unique_ptr<AST::TypeParamBound> bound = parse_type_param_bound ();\n+      if (bound == nullptr)\n \t{\n+\t  /* not an error: bound is allowed to be null as trailing plus is\n+\t   * allowed */\n \t  return type_param_bounds;\n \t}\n+\n+      type_param_bounds.push_back (std::move (bound));\n+    }\n+\n+  type_param_bounds.shrink_to_fit ();\n+  return type_param_bounds;\n+}\n+\n+// Parses type parameter bounds in where clause or generic arguments, with end\n+// token handling.\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<std::unique_ptr<AST::TypeParamBound> >\n+Parser<ManagedTokenSource>::parse_type_param_bounds (EndTokenPred is_end_token)\n+{\n+  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+\n+  std::unique_ptr<AST::TypeParamBound> initial_bound\n+    = parse_type_param_bound ();\n+\n+  // quick exit if null\n+  if (initial_bound == nullptr)\n+    {\n+      /* error? type param bounds must have at least one term, but are bounds\n+       * optional? */\n+      return type_param_bounds;\n+    }\n+  type_param_bounds.push_back (std::move (initial_bound));\n+\n+  while (lexer.peek_token ()->get_id () == PLUS)\n+    {\n       lexer.skip_token ();\n \n+      // break if end token character\n+      if (is_end_token (lexer.peek_token ()->get_id ()))\n+\tbreak;\n+\n       std::unique_ptr<AST::TypeParamBound> bound = parse_type_param_bound ();\n       if (bound == nullptr)\n \t{\n-\t  // not an error: bound is allowed to be null as trailing plus is\n-\t  // allowed\n-\t  return type_param_bounds;\n+\t  // TODO how wise is it to ditch all bounds if only one failed?\n+\t  rust_error_at (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"failed to parse type param bound in type param bounds\");\n+\t  return {};\n \t}\n \n       type_param_bounds.push_back (std::move (bound));\n     }\n \n+  type_param_bounds.shrink_to_fit ();\n   return type_param_bounds;\n }\n \n@@ -3451,29 +3673,60 @@ Parser<ManagedTokenSource>::parse_lifetime_bounds ()\n {\n   std::vector<AST::Lifetime> lifetime_bounds;\n \n-  // TODO: think of better control structure\n   while (true)\n     {\n       AST::Lifetime lifetime = parse_lifetime ();\n \n       // quick exit for parsing failure\n       if (lifetime.is_error ())\n-\t{\n-\t  return lifetime_bounds;\n-\t}\n+\tbreak;\n \n       lifetime_bounds.push_back (std::move (lifetime));\n \n-      // plus is maybe required - spec defines it poorly, so assuming not\n-      // required\n+      /* plus is maybe not allowed at end - spec defines it weirdly, so assuming\n+       * allowed at end */\n       if (lexer.peek_token ()->get_id () != PLUS)\n+\tbreak;\n+\n+      lexer.skip_token ();\n+    }\n+\n+  lifetime_bounds.shrink_to_fit ();\n+  return lifetime_bounds;\n+}\n+\n+// Parses lifetime bounds, with added check for ending token.\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<AST::Lifetime>\n+Parser<ManagedTokenSource>::parse_lifetime_bounds (EndTokenPred is_end_token)\n+{\n+  std::vector<AST::Lifetime> lifetime_bounds;\n+\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n+    {\n+      AST::Lifetime lifetime = parse_lifetime ();\n+\n+      if (lifetime.is_error ())\n \t{\n-\t  return lifetime_bounds;\n+\t  /* TODO: is it worth throwing away all lifetime bound info just\n+\t   * because one failed? */\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse lifetime in lifetime bounds\");\n+\t  return {};\n \t}\n \n+      lifetime_bounds.push_back (std::move (lifetime));\n+\n+      /* plus is maybe not allowed at end - spec defines it weirdly, so assuming\n+       * allowed at end */\n+      if (lexer.peek_token ()->get_id () != PLUS)\n+\tbreak;\n+\n       lexer.skip_token ();\n     }\n \n+  lifetime_bounds.shrink_to_fit ();\n   return lifetime_bounds;\n }\n \n@@ -3871,7 +4124,8 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n     }\n \n   // parse actual enum variant definitions\n-  std::vector<std::unique_ptr<AST::EnumItem> > enum_items = parse_enum_items ();\n+  std::vector<std::unique_ptr<AST::EnumItem> > enum_items\n+    = parse_enum_items ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n   if (!skip_token (RIGHT_CURLY))\n     {\n@@ -3896,47 +4150,72 @@ Parser<ManagedTokenSource>::parse_enum_items ()\n \n   // Return empty item list if no field there\n   if (initial_item == nullptr)\n-    {\n-      return items;\n-    }\n+    return items;\n \n   items.push_back (std::move (initial_item));\n \n-  // maybe think of a better control structure here - do-while with an initial\n-  // error state? basically, loop through item list until can't find any more\n-  // params\n-  while (true)\n+  while (lexer.peek_token ()->get_id () == COMMA)\n     {\n-      if (lexer.peek_token ()->get_id () != COMMA)\n+      lexer.skip_token ();\n+\n+      std::unique_ptr<AST::EnumItem> item = parse_enum_item ();\n+      if (item == nullptr)\n \t{\n+\t  // this would occur with a trailing comma, which is allowed\n \t  break;\n \t}\n \n-      // skip comma if applies\n+      items.push_back (std::move (item));\n+    }\n+\n+  return items;\n+\n+  /* TODO: use template if doable (parse_non_ptr_sequence) */\n+}\n+\n+// Parses the enum variants inside an enum definiton.\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<std::unique_ptr<AST::EnumItem> >\n+Parser<ManagedTokenSource>::parse_enum_items (EndTokenPred is_end_tok)\n+{\n+  std::vector<std::unique_ptr<AST::EnumItem> > items;\n+\n+  std::unique_ptr<AST::EnumItem> initial_item = parse_enum_item ();\n+\n+  // Return empty item list if no field there\n+  if (initial_item == nullptr)\n+    return items;\n+\n+  items.push_back (std::move (initial_item));\n+\n+  while (lexer.peek_token ()->get_id () == COMMA)\n+    {\n       lexer.skip_token ();\n \n-      std::unique_ptr<AST::EnumItem> item = parse_enum_item ();\n+      if (is_end_tok (lexer.peek_token ()->get_id ()))\n+\tbreak;\n \n-      if (item != nullptr)\n-\t{\n-\t  items.push_back (std::move (item));\n-\t}\n-      else\n+      std::unique_ptr<AST::EnumItem> item = parse_enum_item ();\n+      if (item == nullptr)\n \t{\n-\t  // this would occur with a trailing comma, which is allowed\n-\t  break;\n+\t  /* TODO should this ignore all successfully parsed enum items just\n+\t   * because one failed? */\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse enum item in enum items\");\n+\t  return {};\n \t}\n+\n+      items.push_back (std::move (item));\n     }\n \n-  // TODO: does this need move?\n   return items;\n \n-  // TODO: shares virtually all code with function params, tuple and struct\n-  // fields - templates?\n+  /* TODO: use template if doable (parse_non_ptr_sequence) */\n }\n \n-// Parses a single enum variant item in an enum definition. Does not parse\n-// commas.\n+/* Parses a single enum variant item in an enum definition. Does not parse\n+ * commas. */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::EnumItem>\n Parser<ManagedTokenSource>::parse_enum_item ()\n@@ -4016,11 +4295,12 @@ std::unique_ptr<AST::Union>\n Parser<ManagedTokenSource>::parse_union (\n   AST::Visibility vis, std::vector<AST::Attribute> outer_attrs)\n {\n-  // hack - \"weak keyword\" by finding identifier called \"union\" (lookahead in\n-  // item switch)\n-  Location locus = lexer.peek_token ()->get_locus ();\n-  // skip union \"identifier\"\n-  skip_token (IDENTIFIER);\n+  /* hack - \"weak keyword\" by finding identifier called \"union\" (lookahead in\n+   * item switch) */\n+  const_TokenPtr union_keyword = expect_token (IDENTIFIER);\n+  rust_assert (union_keyword->get_str () == \"union\");\n+  Location locus = union_keyword->get_locus ();\n+  lexer.skip_token ();\n \n   // parse actual union name\n   const_TokenPtr union_name_tok = expect_token (IDENTIFIER);\n@@ -4044,8 +4324,8 @@ Parser<ManagedTokenSource>::parse_union (\n       return nullptr;\n     }\n \n-  // parse union inner items as \"struct fields\" because hey, syntax reuse. Spec\n-  // said so.\n+  /* parse union inner items as \"struct fields\" because hey, syntax reuse. Spec\n+   * said so. */\n   std::vector<AST::StructField> union_fields = parse_struct_fields ();\n \n   if (!skip_token (RIGHT_CURLY))\n@@ -4070,8 +4350,8 @@ Parser<ManagedTokenSource>::parse_const_item (\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (CONST);\n \n-  // get constant identifier - this is either a proper identifier or the _\n-  // wildcard\n+  /* get constant identifier - this is either a proper identifier or the _\n+   * wildcard */\n   const_TokenPtr ident_tok = lexer.peek_token ();\n   // make default identifier the underscore wildcard one\n   std::string ident (\"_\");\n@@ -4206,8 +4486,9 @@ Parser<ManagedTokenSource>::parse_trait (\n     {\n       lexer.skip_token ();\n \n-      // TODO: does this need move?\n-      type_param_bounds = parse_type_param_bounds ();\n+      type_param_bounds = parse_type_param_bounds (\n+\t[] (TokenId id) { return id == WHERE || id == LEFT_CURLY; });\n+      // type_param_bounds = parse_type_param_bounds ();\n     }\n \n   // parse where clause (if it exists)\n@@ -4229,11 +4510,10 @@ Parser<ManagedTokenSource>::parse_trait (\n \n       if (trait_item == nullptr)\n \t{\n-\t  // TODO: this is probably an error as next character should equal\n-\t  // RIGHT_CURLY\n-\t  break;\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse trait item in trait\");\n+\t  return nullptr;\n \t}\n-\n       trait_items.push_back (std::move (trait_item));\n \n       t = lexer.peek_token ();\n@@ -4435,7 +4715,9 @@ Parser<ManagedTokenSource>::parse_trait_type (\n       lexer.skip_token ();\n \n       // parse optional type param bounds\n-      bounds = parse_type_param_bounds ();\n+      bounds\n+\t= parse_type_param_bounds ([] (TokenId id) { return id == SEMICOLON; });\n+      // bounds = parse_type_param_bounds ();\n     }\n \n   if (!skip_token (SEMICOLON))\n@@ -4582,11 +4864,10 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n \n \t  if (impl_item == nullptr)\n \t    {\n-\t      // TODO: this is probably an error as next character should equal\n-\t      // RIGHT_CURLY\n-\t      fprintf (stderr, \"impl item is null and next char wasn't \"\n-\t\t\t       \"RIGHT_CURLY - probably an error\");\n-\t      break;\n+\t      rust_error_at (\n+\t\tlexer.peek_token ()->get_locus (),\n+\t\t\"failed to parse inherent impl item in inherent impl\");\n+\t      return nullptr;\n \t    }\n \n \t  impl_items.push_back (std::move (impl_item));\n@@ -4652,13 +4933,9 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n \n \t  if (impl_item == nullptr)\n \t    {\n-\t      // DEBUG\n-\t      fprintf (stderr, \"break out of parsing trait impl items (due to \"\n-\t\t\t       \"parse giving null)\\n\");\n-\n-\t      // TODO: this is probably an error as next character should equal\n-\t      // RIGHT_CURLY\n-\t      break;\n+\t      rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t     \"failed to parse trait impl item in trait impl\");\n+\t      return nullptr;\n \t    }\n \n \t  impl_items.push_back (std::move (impl_item));\n@@ -4765,8 +5042,8 @@ Parser<ManagedTokenSource>::parse_inherent_impl_item ()\n       return parse_inherent_impl_function_or_method (\n \tAST::Visibility::create_error (), std::move (outer_attrs));\n     case CONST:\n-      // lookahead to resolve production - could be function/method or const\n-      // item\n+      /* lookahead to resolve production - could be function/method or const\n+       * item */\n       t = lexer.peek_token (1);\n \n       switch (t->get_id ())"}, {"sha": "b2de05e5a29eac05ae1f71498df5d5102e86e1c8", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cfd93746242dc6e73f4fa71520bb361a2d6de4a/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cfd93746242dc6e73f4fa71520bb361a2d6de4a/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "patch": "@@ -149,6 +149,8 @@ template <typename ManagedTokenSource> class Parser\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params_in_angles ();\n   std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params (EndTokenPred is_end_token);\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params (EndTokenPred is_end_token);\n@@ -159,6 +161,8 @@ template <typename ManagedTokenSource> class Parser\n   auto parse_non_ptr_sequence (ParseFunction parsing_function, EndTokenPred is_end_token, std::string error_msg = \"failed to parse generic param in generic params\") -> std::vector<decltype(parsing_function ())>;\n   AST::LifetimeParam parse_lifetime_param ();\n   std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params (EndTokenPred is_end_token);\n   std::unique_ptr<AST::TypeParam> parse_type_param ();\n   std::vector<AST::FunctionParam> parse_function_params ();\n   AST::FunctionParam parse_function_param ();\n@@ -170,10 +174,14 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TypeBoundWhereClauseItem>\n   parse_type_bound_where_clause_item ();\n   std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds (EndTokenPred is_end_token);\n   std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds ();\n   std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n   std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n   std::vector<AST::Lifetime> parse_lifetime_bounds ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::Lifetime> parse_lifetime_bounds (EndTokenPred is_end_token);\n   AST::Lifetime parse_lifetime ();\n   std::unique_ptr<AST::TypeAlias>\n   parse_type_alias (AST::Visibility vis,\n@@ -187,6 +195,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Enum>\n   parse_enum (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items (EndTokenPred is_end_token);\n   std::unique_ptr<AST::EnumItem> parse_enum_item ();\n   std::unique_ptr<AST::Union>\n   parse_union (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);"}]}