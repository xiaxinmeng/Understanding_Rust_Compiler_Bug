{"sha": "aaf46c35d38b85342076e6c07f9a13afd598a38d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFmNDZjMzVkMzhiODUzNDIwNzZlNmMwN2Y5YTEzYWZkNTk4YTM4ZA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2017-08-15T23:42:23Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2017-08-15T23:42:23Z"}, "message": "Limit SH strncmp inline expansion (PR target/78460).\n\nGCC mainline built for sh4-linux-gnu runs out of memory building a\nglibc test, which calls strncmp with very large constant size\nargument, resulting in the SH inline strncmp expansion trying to\ninline a fully unrolled expansion of strncmp for that size.\n\nThis patch limits that fully unrolled expansion to the case of less\nthan 32 bytes.  This is explicitly *not* trying to be optimal in any\nway (very likely a lower threshold makes sense), just to limit enough\nto avoid the out-of-memory issue in the glibc testsuite.\n\nI have *not* run the GCC testsuite for SH.  I have verified that this\nallows the glibc testsuite to build OK, with both GCC mainline and GCC\n7 branch (and that the included test builds quickly with patched GCC,\nruns out of memory with unpatched GCC).\n\n\tPR target/78460\n\tPR target/67712\ngcc:\n\t* config/sh/sh-mem.cc (sh_expand_cmpnstr): Only unroll for\n\tconstant count if that count is less than 32.\n\ngcc/testsuite:\n\t* gcc.c-torture/compile/string-large-1.c: New test.\n\nFrom-SVN: r251108", "tree": {"sha": "01bb4b9c7a8279f28e5be23b7a59629bf0c42da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01bb4b9c7a8279f28e5be23b7a59629bf0c42da9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaf46c35d38b85342076e6c07f9a13afd598a38d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf46c35d38b85342076e6c07f9a13afd598a38d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaf46c35d38b85342076e6c07f9a13afd598a38d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf46c35d38b85342076e6c07f9a13afd598a38d/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b789c7f5aa91ef23d8b41e564cc30cc87b77d4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b789c7f5aa91ef23d8b41e564cc30cc87b77d4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b789c7f5aa91ef23d8b41e564cc30cc87b77d4c"}], "stats": {"total": 136, "additions": 134, "deletions": 2}, "files": [{"sha": "14fc3dbe3e0c67d0fe586f5b8aceb84c6d753575", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aaf46c35d38b85342076e6c07f9a13afd598a38d", "patch": "@@ -1,3 +1,10 @@\n+2017-08-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR target/78460\n+\tPR target/67712\n+\t* config/sh/sh-mem.cc (sh_expand_cmpnstr): Only unroll for\n+\tconstant count if that count is less than 32.\n+\n 2017-08-15  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.c (execute): Emit friendlier message if inferior is killed"}, {"sha": "8fce97999214a07ac0e689a938f47b4eb81bcc42", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=aaf46c35d38b85342076e6c07f9a13afd598a38d", "patch": "@@ -349,12 +349,13 @@ sh_expand_cmpnstr (rtx *operands)\n \n   rtx len = copy_to_mode_reg (SImode, operands[3]);\n   int constp = CONST_INT_P (operands[3]);\n+  HOST_WIDE_INT bytes = constp ? INTVAL (operands[3]) : 0;\n \n   const unsigned int addr1_alignment = MEM_ALIGN (operands[1]) / BITS_PER_UNIT;\n   const unsigned int addr2_alignment = MEM_ALIGN (operands[2]) / BITS_PER_UNIT;\n \n   /* Loop on a register count.  */\n-  if (constp)\n+  if (constp && bytes >= 0 && bytes < 32)\n     {\n       rtx tmp0 = gen_reg_rtx (SImode);\n       rtx tmp3 = gen_reg_rtx (SImode);\n@@ -363,7 +364,6 @@ sh_expand_cmpnstr (rtx *operands)\n       rtx_code_label *L_loop_long = gen_label_rtx ();\n       rtx_code_label *L_end_loop_long = gen_label_rtx ();\n \n-      int bytes = INTVAL (operands[3]);\n       int witers = bytes / 4;\n \n       if (witers > 1)"}, {"sha": "835a8f4af81ea4404ec982320209de2a58e74d68", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aaf46c35d38b85342076e6c07f9a13afd598a38d", "patch": "@@ -1,3 +1,9 @@\n+2017-08-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR target/78460\n+\tPR target/67712\n+\t* gcc.c-torture/compile/string-large-1.c: New test.\n+\n 2017-08-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/81790"}, {"sha": "ddac0d57e166c1b50663171cf8adee5663295b6c", "filename": "gcc/testsuite/gcc.c-torture/compile/string-large-1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fstring-large-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf46c35d38b85342076e6c07f9a13afd598a38d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fstring-large-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fstring-large-1.c?ref=aaf46c35d38b85342076e6c07f9a13afd598a38d", "patch": "@@ -0,0 +1,119 @@\n+/* Test built-in string functions with large sizes.  PR 78460.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define SIZE1 ((size_t) -1)\n+#define SIZE2 (SIZE1 >> 1)\n+#define SIZE3 ((unsigned int) -1)\n+#define SIZE4 (SIZE3 >> 1)\n+\n+volatile int v1, v2, v3, v4;\n+void *volatile vp1, *volatile vp2, *volatile vp3, *volatile vp4;\n+\n+void\n+test_memchr (const void *a, int b)\n+{\n+  vp1 = __builtin_memchr (a, b, SIZE1);\n+  vp2 = __builtin_memchr (a, b, SIZE2);\n+  vp3 = __builtin_memchr (a, b, SIZE3);\n+  vp4 = __builtin_memchr (a, b, SIZE4);\n+}\n+\n+void\n+test_memcmp (const void *a, const void *b)\n+{\n+  v1 = __builtin_memcmp (a, b, SIZE1);\n+  v2 = __builtin_memcmp (a, b, SIZE2);\n+  v3 = __builtin_memcmp (a, b, SIZE3);\n+  v4 = __builtin_memcmp (a, b, SIZE4);\n+}\n+\n+void\n+test_memcpy (void *a, const void *b)\n+{\n+  vp1 = __builtin_memcpy (a, b, SIZE1);\n+  vp2 = __builtin_memcpy (a, b, SIZE2);\n+  vp3 = __builtin_memcpy (a, b, SIZE3);\n+  vp4 = __builtin_memcpy (a, b, SIZE4);\n+}\n+\n+void\n+test_memmove (void *a, const void *b)\n+{\n+  vp1 = __builtin_memmove (a, b, SIZE1);\n+  vp2 = __builtin_memmove (a, b, SIZE2);\n+  vp3 = __builtin_memmove (a, b, SIZE3);\n+  vp4 = __builtin_memmove (a, b, SIZE4);\n+}\n+\n+void\n+test_mempcpy (void *a, const void *b)\n+{\n+  vp1 = __builtin_mempcpy (a, b, SIZE1);\n+  vp2 = __builtin_mempcpy (a, b, SIZE2);\n+  vp3 = __builtin_mempcpy (a, b, SIZE3);\n+  vp4 = __builtin_mempcpy (a, b, SIZE4);\n+}\n+\n+void\n+test_memset (void *a, int b)\n+{\n+  vp1 = __builtin_memset (a, b, SIZE1);\n+  vp2 = __builtin_memset (a, b, SIZE2);\n+  vp3 = __builtin_memset (a, b, SIZE3);\n+  vp4 = __builtin_memset (a, b, SIZE4);\n+}\n+\n+void\n+test_stpncpy (char *a, const char *b)\n+{\n+  vp1 = __builtin_stpncpy (a, b, SIZE1);\n+  vp2 = __builtin_stpncpy (a, b, SIZE2);\n+  vp3 = __builtin_stpncpy (a, b, SIZE3);\n+  vp4 = __builtin_stpncpy (a, b, SIZE4);\n+}\n+\n+void\n+test_strndup (const char *a)\n+{\n+  vp1 = __builtin_strndup (a, SIZE1);\n+  vp2 = __builtin_strndup (a, SIZE2);\n+  vp3 = __builtin_strndup (a, SIZE3);\n+  vp4 = __builtin_strndup (a, SIZE4);\n+}\n+\n+void\n+test_strncasecmp (const char *a, const char *b)\n+{\n+  v1 = __builtin_strncasecmp (a, b, SIZE1);\n+  v2 = __builtin_strncasecmp (a, b, SIZE2);\n+  v3 = __builtin_strncasecmp (a, b, SIZE3);\n+  v4 = __builtin_strncasecmp (a, b, SIZE4);\n+}\n+\n+void\n+test_strncat (char *a, const char *b)\n+{\n+  vp1 = __builtin_strncat (a, b, SIZE1);\n+  vp2 = __builtin_strncat (a, b, SIZE2);\n+  vp3 = __builtin_strncat (a, b, SIZE3);\n+  vp4 = __builtin_strncat (a, b, SIZE4);\n+}\n+\n+void\n+test_strncmp (const char *a, const char *b)\n+{\n+  v1 = __builtin_strncmp (a, b, SIZE1);\n+  v2 = __builtin_strncmp (a, b, SIZE2);\n+  v3 = __builtin_strncmp (a, b, SIZE3);\n+  v4 = __builtin_strncmp (a, b, SIZE4);\n+}\n+\n+void\n+test_strncpy (char *a, const char *b)\n+{\n+  vp1 = __builtin_strncpy (a, b, SIZE1);\n+  vp2 = __builtin_strncpy (a, b, SIZE2);\n+  vp3 = __builtin_strncpy (a, b, SIZE3);\n+  vp4 = __builtin_strncpy (a, b, SIZE4);\n+}"}]}