{"sha": "488105156156c30e3085258c9077bf2cfbdb34dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4MTA1MTU2MTU2YzMwZTMwODUyNThjOTA3N2JmMmNmYmRiMzRkZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-21T20:38:47Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-21T20:38:47Z"}, "message": "calls.c: Use rtx_insn\n\ngcc/\n2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n\n\t* calls.c (emit_call_1): Strengthen local \"call_insn\" from rtx to\n\trtx_insn *.\n\t(internal_arg_pointer_exp_state): Likewise for field \"scan_start\".\n\t(internal_arg_pointer_based_exp_scan): Likewise for locals \"insn\",\n\t\"scan_start\".\n\t(load_register_parameters): Likewise for local \"before_arg\".\n\t(check_sibcall_argument_overlap): Likewise for param \"insn\".\n\t(expand_call): Likewise for locals \"normal_call_insns\",\n\t\"tail_call_insns\", \"insns\", \"before_call\", \"after_args\",\n\t\"before_arg\", \"last\", \"prev\".  Strengthen one of the \"last\" from\n\trtx to rtx_call_insn *.\n\t(fixup_tail_calls): Strengthen local \"insn\" from rtx to\n\trtx_insn *.\n\t(emit_library_call_value_1): Likewise for locals \"before_call\" and\n\t\"last\".\n\nFrom-SVN: r214289", "tree": {"sha": "01919d0f014f77c7b33c2abf81188db67484e954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01919d0f014f77c7b33c2abf81188db67484e954"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/488105156156c30e3085258c9077bf2cfbdb34dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488105156156c30e3085258c9077bf2cfbdb34dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/488105156156c30e3085258c9077bf2cfbdb34dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488105156156c30e3085258c9077bf2cfbdb34dd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58f4cf2afec0de32dc9f051e189779d19bc72777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f4cf2afec0de32dc9f051e189779d19bc72777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58f4cf2afec0de32dc9f051e189779d19bc72777"}], "stats": {"total": 65, "additions": 43, "deletions": 22}, "files": [{"sha": "bfafe4c4151bfa4d18bad1bd989c640e31cd8ccf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488105156156c30e3085258c9077bf2cfbdb34dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488105156156c30e3085258c9077bf2cfbdb34dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=488105156156c30e3085258c9077bf2cfbdb34dd", "patch": "@@ -1,3 +1,21 @@\n+2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* calls.c (emit_call_1): Strengthen local \"call_insn\" from rtx to\n+\trtx_insn *.\n+\t(internal_arg_pointer_exp_state): Likewise for field \"scan_start\".\n+\t(internal_arg_pointer_based_exp_scan): Likewise for locals \"insn\",\n+\t\"scan_start\".\n+\t(load_register_parameters): Likewise for local \"before_arg\".\n+\t(check_sibcall_argument_overlap): Likewise for param \"insn\".\n+\t(expand_call): Likewise for locals \"normal_call_insns\",\n+\t\"tail_call_insns\", \"insns\", \"before_call\", \"after_args\",\n+\t\"before_arg\", \"last\", \"prev\".  Strengthen one of the \"last\" from\n+\trtx to rtx_call_insn *.\n+\t(fixup_tail_calls): Strengthen local \"insn\" from rtx to\n+\trtx_insn *.\n+\t(emit_library_call_value_1): Likewise for locals \"before_call\" and\n+\t\"last\".\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* builtins.c (expand_builtin_longjmp): Strengthen locals \"insn\""}, {"sha": "9144653e274d292f5dfa1fcbb136358f0522a6c9", "filename": "gcc/calls.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488105156156c30e3085258c9077bf2cfbdb34dd/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488105156156c30e3085258c9077bf2cfbdb34dd/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=488105156156c30e3085258c9077bf2cfbdb34dd", "patch": "@@ -153,7 +153,7 @@ static rtx emit_library_call_value_1 (int, rtx, rtx, enum libcall_type,\n \t\t\t\t      enum machine_mode, int, va_list);\n static int special_function_p (const_tree, int);\n static int check_sibcall_argument_overlap_1 (rtx);\n-static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n+static int check_sibcall_argument_overlap (rtx_insn *, struct arg_data *, int);\n \n static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n \t\t\t\t\t\t      unsigned int);\n@@ -261,7 +261,8 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t     cumulative_args_t args_so_far ATTRIBUTE_UNUSED)\n {\n   rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n-  rtx call_insn, call, funmem;\n+  rtx_insn *call_insn;\n+  rtx call, funmem;\n   int already_popped = 0;\n   HOST_WIDE_INT n_popped\n     = targetm.calls.return_pops_args (fndecl, funtype, stack_size);\n@@ -1687,7 +1688,7 @@ static struct\n {\n   /* Last insn that has been scanned by internal_arg_pointer_based_exp_scan,\n      or NULL_RTX if none has been scanned yet.  */\n-  rtx scan_start;\n+  rtx_insn *scan_start;\n   /* Vector indexed by REGNO - FIRST_PSEUDO_REGISTER, recording if a pseudo is\n      based on crtl->args.internal_arg_pointer.  The element is NULL_RTX if the\n      pseudo isn't based on it, a CONST_INT offset if the pseudo is based on it\n@@ -1706,7 +1707,7 @@ static rtx internal_arg_pointer_based_exp (rtx, bool);\n static void\n internal_arg_pointer_based_exp_scan (void)\n {\n-  rtx insn, scan_start = internal_arg_pointer_exp_state.scan_start;\n+  rtx_insn *insn, *scan_start = internal_arg_pointer_exp_state.scan_start;\n \n   if (scan_start == NULL_RTX)\n     insn = get_insns ();\n@@ -1872,7 +1873,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t  int partial = args[i].partial;\n \t  int nregs;\n \t  int size = 0;\n-\t  rtx before_arg = get_last_insn ();\n+\t  rtx_insn *before_arg = get_last_insn ();\n \t  /* Set non-negative if we must move a word at a time, even if\n \t     just one word (e.g, partial == 4 && mode == DFmode).  Set\n \t     to -1 if we just use a normal move insn.  This value can be\n@@ -2103,7 +2104,8 @@ check_sibcall_argument_overlap_1 (rtx x)\n    slots, zero otherwise.  */\n \n static int\n-check_sibcall_argument_overlap (rtx insn, struct arg_data *arg, int mark_stored_args_map)\n+check_sibcall_argument_overlap (rtx_insn *insn, struct arg_data *arg,\n+\t\t\t\tint mark_stored_args_map)\n {\n   int low, high;\n \n@@ -2194,9 +2196,9 @@ expand_call (tree exp, rtx target, int ignore)\n   /* RTX for the function to be called.  */\n   rtx funexp;\n   /* Sequence of insns to perform a normal \"call\".  */\n-  rtx normal_call_insns = NULL_RTX;\n+  rtx_insn *normal_call_insns = NULL;\n   /* Sequence of insns to perform a tail \"call\".  */\n-  rtx tail_call_insns = NULL_RTX;\n+  rtx_insn *tail_call_insns = NULL;\n   /* Data type of the function.  */\n   tree funtype;\n   tree type_arg_types;\n@@ -2662,8 +2664,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t recursion call can be ignored if we indeed use the tail\n \t call expansion.  */\n       saved_pending_stack_adjust save;\n-      rtx insns;\n-      rtx before_call, next_arg_reg, after_args;\n+      rtx_insn *insns, *before_call, *after_args;\n+      rtx next_arg_reg;\n \n       if (pass == 0)\n \t{\n@@ -3032,7 +3034,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t{\n \t  if (args[i].reg == 0 || args[i].pass_on_stack)\n \t    {\n-\t      rtx before_arg = get_last_insn ();\n+\t      rtx_insn *before_arg = get_last_insn ();\n \n \t      /* We don't allow passing huge (> 2^30 B) arguments\n \t         by value.  It would cause an overflow later on.  */\n@@ -3072,7 +3074,7 @@ expand_call (tree exp, rtx target, int ignore)\n \tfor (i = 0; i < num_actuals; i++)\n \t  if (args[i].partial != 0 && ! args[i].pass_on_stack)\n \t    {\n-\t      rtx before_arg = get_last_insn ();\n+\t      rtx_insn *before_arg = get_last_insn ();\n \n \t      if (store_one_arg (&args[i], argblock, flags,\n \t\t\t\t adjusted_args_size.var != 0,\n@@ -3159,7 +3161,8 @@ expand_call (tree exp, rtx target, int ignore)\n \n       if (flag_use_caller_save)\n \t{\n-\t  rtx last, datum = NULL_RTX;\n+\t  rtx_call_insn *last;\n+\t  rtx datum = NULL_RTX;\n \t  if (fndecl != NULL_TREE)\n \t    {\n \t      datum = XEXP (DECL_RTL (fndecl), 0);\n@@ -3196,7 +3199,7 @@ expand_call (tree exp, rtx target, int ignore)\n       if (pass && (flags & ECF_MALLOC))\n \t{\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n-\t  rtx last, insns;\n+\t  rtx_insn *last, *insns;\n \n \t  /* The return value from a malloc-like function is a pointer.  */\n \t  if (TREE_CODE (rettype) == POINTER_TYPE)\n@@ -3227,7 +3230,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t     immediately after the CALL_INSN.  Some ports emit more\n \t     than just a CALL_INSN above, so we must search for it here.  */\n \n-\t  rtx last = get_last_insn ();\n+\t  rtx_insn *last = get_last_insn ();\n \t  while (!CALL_P (last))\n \t    {\n \t      last = PREV_INSN (last);\n@@ -3375,7 +3378,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n       if (old_stack_level)\n \t{\n-\t  rtx prev = get_last_insn ();\n+\t  rtx_insn *prev = get_last_insn ();\n \n \t  emit_stack_restore (SAVE_BLOCK, old_stack_level);\n \t  stack_pointer_delta = old_stack_pointer_delta;\n@@ -3451,7 +3454,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    }\n \n \t  sbitmap_free (stored_args_map);\n-\t  internal_arg_pointer_exp_state.scan_start = NULL_RTX;\n+\t  internal_arg_pointer_exp_state.scan_start = NULL;\n \t  internal_arg_pointer_exp_state.cache.release ();\n \t}\n       else\n@@ -3467,7 +3470,7 @@ expand_call (tree exp, rtx target, int ignore)\n       /* If something prevents making this a sibling call,\n \t zero out the sequence.  */\n       if (sibcall_failure)\n-\ttail_call_insns = NULL_RTX;\n+\ttail_call_insns = NULL;\n       else\n \tbreak;\n     }\n@@ -3504,7 +3507,7 @@ expand_call (tree exp, rtx target, int ignore)\n void\n fixup_tail_calls (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n@@ -3612,7 +3615,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   int flags;\n   int reg_parm_stack_space = 0;\n   int needed;\n-  rtx before_call;\n+  rtx_insn *before_call;\n   tree tfom;\t\t\t/* type_for_mode (outmode, 0) */\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -4205,7 +4208,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       /* The barrier note must be emitted\n \t immediately after the CALL_INSN.  Some ports emit more than\n \t just a CALL_INSN above, so we must search for it here.  */\n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n       while (!CALL_P (last))\n \t{\n \t  last = PREV_INSN (last);\n@@ -4220,7 +4223,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      and LCT_RETURNS_TWICE, cannot perform non-local gotos.  */\n   if (flags & ECF_NOTHROW)\n     {\n-      rtx last = get_last_insn ();\n+      rtx_insn *last = get_last_insn ();\n       while (!CALL_P (last))\n \t{\n \t  last = PREV_INSN (last);"}]}