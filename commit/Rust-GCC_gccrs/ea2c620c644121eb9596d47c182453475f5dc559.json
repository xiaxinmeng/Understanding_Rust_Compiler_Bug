{"sha": "ea2c620c644121eb9596d47c182453475f5dc559", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEyYzYyMGM2NDQxMjFlYjk1OTZkNDdjMTgyNDUzNDc1ZjVkYzU1OQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-02-18T00:52:51Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-02-18T00:52:51Z"}, "message": "cfgloop.c, [...]: Fix comment typos.\n\n\t* cfgloop.c, config/alpha/alpha.c, config/bfin/bfin.c,\n\tconfig/i386/athlon.md, config/ia64/ia64.md,\n\tconfig/rs6000/rs6000.c, config/s390/s390.c, config/spu/spu.md,\n\tdf-problems.c, df.h, fold-const.c, ipa-cp.c, ipa-inline.c,\n\tipa-prop.h, see.c, struct-equiv.c, tree-inline.c,\n\ttree-ssa-loop-niter.c, tree-vect-analyze.c,\n\ttree-vect-transform.c: Fix comment typos.\n\nFrom-SVN: r122080", "tree": {"sha": "b38a0a5dbb19ac45ec4d154b015e6872d5aa49c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b38a0a5dbb19ac45ec4d154b015e6872d5aa49c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea2c620c644121eb9596d47c182453475f5dc559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea2c620c644121eb9596d47c182453475f5dc559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea2c620c644121eb9596d47c182453475f5dc559", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea2c620c644121eb9596d47c182453475f5dc559/comments", "author": null, "committer": null, "parents": [{"sha": "aabd86cb158b3da3e02f060cae2b3adc0dbda6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabd86cb158b3da3e02f060cae2b3adc0dbda6dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aabd86cb158b3da3e02f060cae2b3adc0dbda6dc"}], "stats": {"total": 60, "additions": 35, "deletions": 25}, "files": [{"sha": "a91d42fc56bb095679dd0cc3a9f6a0ebf6cf8157", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1,3 +1,13 @@\n+2007-02-18  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* cfgloop.c, config/alpha/alpha.c, config/bfin/bfin.c,\n+\tconfig/i386/athlon.md, config/ia64/ia64.md,\n+\tconfig/rs6000/rs6000.c, config/s390/s390.c, config/spu/spu.md,\n+\tdf-problems.c, df.h, fold-const.c, ipa-cp.c, ipa-inline.c,\n+\tipa-prop.h, see.c, struct-equiv.c, tree-inline.c,\n+\ttree-ssa-loop-niter.c, tree-vect-analyze.c,\n+\ttree-vect-transform.c: Fix comment typos.\n+\n 2007-02-17  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* sched-deps.c (find_insn_list): Remove."}, {"sha": "62ee79c6cd167275039d05a1fc7f9c5b7d536a60", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -701,7 +701,7 @@ disambiguate_multiple_latches (struct loop *loop)\n {\n   edge e;\n \n-  /* We eliminate the mutiple latches by splitting the header to the forwarder\n+  /* We eliminate the multiple latches by splitting the header to the forwarder\n      block F and the rest R, and redirecting the edges.  There are two cases:\n \n      1) If there is a latch edge E that corresponds to a subloop (we guess"}, {"sha": "e0ece7561b83ada71deb3458de409f53a60d4521", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -4434,7 +4434,7 @@ emit_insxl (enum machine_mode mode, rtx op1, rtx op2)\n   return ret;\n }\n \n-/* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation\n+/* Expand an atomic fetch-and-operate pattern.  CODE is the binary operation\n    to perform.  MEM is the memory on which to operate.  VAL is the second \n    operand of the binary operator.  BEFORE and AFTER are optional locations to\n    return the value of MEM either before of after the operation.  SCRATCH is"}, {"sha": "e71305a7eb003d4e2d0c2af2f0398f58d7513c56", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1537,7 +1537,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n    For args passed entirely in registers or entirely in memory, zero.\n \n    Refer VDSP C Compiler manual, our ABI.\n-   First 3 words are in registers. So, if a an argument is larger\n+   First 3 words are in registers. So, if an argument is larger\n    than the registers available, it will span the register and\n    stack.   */\n "}, {"sha": "04b1e1e2d348e5bb45e0c6ff596a6aeec3327296", "filename": "gcc/config/i386/athlon.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fi386%2Fathlon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fi386%2Fathlon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fathlon.md?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -603,7 +603,7 @@\n \t\t\t \"athlon-direct,athlon-fploadk8,athlon-fstore\")\n ;; On AMDFAM10 all double, single and integer packed and scalar SSEx data\n ;; loads  generated are direct path, latency of 2 and do not use any FP\n-;; executions units. No seperate entries for movlpx/movhpx loads, which\n+;; executions units. No separate entries for movlpx/movhpx loads, which\n ;; are direct path, latency of 4 and use the FADD/FMUL FP execution units,\n ;; as they will not be generated.\n (define_insn_reservation \"athlon_sseld_amdfam10\" 2\n@@ -637,7 +637,7 @@\n \t\t\t \"athlon-direct,(athlon-fpsched+athlon-agu),(athlon-fstore+athlon-store)\")\n ;; On AMDFAM10 all double, single and integer packed SSEx data stores\n ;; generated are all double path, latency of 2 and use the FSTORE FP\n-;; execution unit. No entries seperate for movupx/movdqu, which are\n+;; execution unit. No entries separate for movupx/movdqu, which are\n ;; vector path, latency of 3 and use the FSTORE*2 FP execution unit,\n ;; as they will not be generated.\n (define_insn_reservation \"athlon_ssest_amdfam10\" 2"}, {"sha": "23a297478680e5e1fc91b9bf18aac930a5fe26ff", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -476,7 +476,7 @@\n \n ;; Define register predicate prefix.\n ;; We can generate speculative loads only for general and fp registers - this\n-;; is constrainted in ia64.c: ia64_speculate_insn ().\n+;; is constrained in ia64.c: ia64_speculate_insn ().\n (define_mode_attr reg_pred_prefix [(BI \"gr\") (QI \"gr\") (HI \"gr\") (SI \"gr\") (DI \"grfr\") (SF \"grfr\") (DF \"grfr\") (XF \"fr\") (TI \"fr\")])\n \n (define_mode_attr ld_class [(BI \"ld\") (QI \"ld\") (HI \"ld\") (SI \"ld\") (DI \"ld,fld\") (SF \"fld,ld\") (DF \"fld,ld\") (XF \"fld\") (TI \"fldp\")])"}, {"sha": "3835a9a592815ca280230bd18111078178a4f0b9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -12705,7 +12705,7 @@ emit_store_conditional (enum machine_mode mode, rtx res, rtx mem, rtx val)\n   emit_insn (fn (res, mem, val));\n }\n \n-/* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation\n+/* Expand an atomic fetch-and-operate pattern.  CODE is the binary operation\n    to perform.  MEM is the memory on which to operate.  VAL is the second\n    operand of the binary operator.  BEFORE and AFTER are optional locations to\n    return the value of MEM either before of after the operation.  SCRATCH is"}, {"sha": "1ef4510b15bc4cf89852317b738bc31aa4a89567", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -4228,7 +4228,7 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx ne\n }\n \n /* Expand an atomic operation CODE of mode MODE.  MEM is the memory location\n-   and VAL the value to play with.  If AFTER is true then store the the value\n+   and VAL the value to play with.  If AFTER is true then store the value\n    MEM holds after the operation, if AFTER is false then store the value MEM\n    holds before the operation.  If TARGET is zero then discard that value, else\n    store it to TARGET.  */"}, {"sha": "523ecec57983dda1b013ebb3da6c56a6328d7133", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -56,7 +56,7 @@\n     \"pipe0, fp, nothing*5\")\n \n ;; The behavior of the double precision is that both pipes stall\n-;; for 6 cycles and the the rest of the operation pipelines for\n+;; for 6 cycles and the rest of the operation pipelines for\n ;; 7 cycles.  The simplest way to model this is to simply ignore\n ;; the 6 cyle stall.\n (define_insn_reservation \"FPD\" 7 (eq_attr \"type\" \"fpd\")"}, {"sha": "ec80bf74f774c04189e7ff02e73b802c628e2ef9", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1968,7 +1968,7 @@ df_ur_init (struct dataflow *dflow, bitmap all_blocks)\n }\n \n \n-/* Or in the stack regs, hard regs and early clobber regs into the the\n+/* Or in the stack regs, hard regs and early clobber regs into the\n    ur_in sets of all of the blocks.  */\n \n static void\n@@ -2550,7 +2550,7 @@ df_urec_init (struct dataflow *dflow, bitmap all_blocks)\n }\n \n \n-/* Or in the stack regs, hard regs and early clobber regs into the the\n+/* Or in the stack regs, hard regs and early clobber regs into the\n    ur_in sets of all of the blocks.  */\n \n static void"}, {"sha": "6c538b28d4e1ff4af5a76068df85fa2a18b85517", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -562,7 +562,7 @@ struct df_urec_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n   bitmap earlyclobber;  /* The set of registers that are referenced\n-\t\t\t   with an an early clobber mode.  */\n+\t\t\t   with an early clobber mode.  */\n   /* Kill and gen are defined as in the UR problem.  */\n   bitmap kill;\n   bitmap gen;"}, {"sha": "951de4098d70fe2c242d01e3c1ef963560e31a6c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -8860,8 +8860,8 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n     }\n \n   /* If this is a comparison of complex values and both sides\n-     are COMPLEX_CST, do the comparision by parts to fold the\n-     comparision.  */\n+     are COMPLEX_CST, do the comparison by parts to fold the\n+     comparison.  */\n   if ((code == EQ_EXPR || code == NE_EXPR)\n       && TREE_CODE (TREE_TYPE (arg0)) == COMPLEX_TYPE\n       && TREE_CODE (arg0) == COMPLEX_CST"}, {"sha": "bd533bfea67657077ab663fa150e75db758efc57", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -65,7 +65,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    arguments\n    of the callsite. There are three types of values :\n    Formal - the caller's formal parameter is passed as an actual argument.\n-   Constant - a constant is passed as a an actual argument.\n+   Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n    \n    In order to compute the jump functions, we need the modify information for "}, {"sha": "67ca5fdee2474ea075d077f15cbe04ba52270534", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1345,7 +1345,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t    continue;\n \t  }\n \t/* When the function body would grow and inlining the function won't\n-\t   elliminate the need for offline copy of the function, don't inline.\n+\t   eliminate the need for offline copy of the function, don't inline.\n \t */\n \tif (mode == INLINE_SIZE\n \t    && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)"}, {"sha": "482b6e39b07e3e476d08e0f5a748ed44a0c6b49f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -29,7 +29,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n /* A jump function for a callsite represents the values passed as actual \n    arguments of the callsite. There are three main types of values :\n    Formal - the caller's formal parameter is passed as an actual argument.\n-   Constant - a constant is passed as a an actual argument.\n+   Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n    Integer and real constants are represented as CONST_IPATYPE and Fortran \n    constants are represented as CONST_IPATYPE_REF.  */"}, {"sha": "5263d20f852ddcfce9f05a7320badaa2adc551b1", "filename": "gcc/see.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -3170,7 +3170,7 @@ see_store_reference_and_extension (rtx ref_insn, rtx se_insn,\n \n    A definition is relevant if its root has\n    ((entry_type == SIGN_EXTENDED_DEF) || (entry_type == ZERO_EXTENDED_DEF)) and\n-   his source_mode is not narrower then the the roots source_mode.\n+   his source_mode is not narrower then the roots source_mode.\n \n    Return the number of relevant defs or negative number if something bad had\n    happened and the optimization should be aborted.  */"}, {"sha": "ce3efcdb56dc9a10e0a36865752b405cd8a3b22c", "filename": "gcc/struct-equiv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -344,7 +344,7 @@ note_local_live (struct equiv_info *info, rtx x, rtx y, int rvalue)\n   return x_change;\n }\n \n-/* Check if *XP is equivalent to Y.  Until an an unreconcilable difference is\n+/* Check if *XP is equivalent to Y.  Until an unreconcilable difference is\n    found, use in-group changes with validate_change on *XP to make register\n    assignments agree.  It is the (not necessarily direct) callers\n    responsibility to verify / confirm / cancel these changes, as appropriate.\n@@ -570,7 +570,7 @@ rtx_equiv_p (rtx *xp, rtx y, int rvalue, struct equiv_info *info)\n \t  return false;\n \tx_dest1 = XEXP (x, 0);\n \t/* validate_change might have changed the destination.  Put it back\n-\t   so that we can do a proper match for its role a an input.  */\n+\t   so that we can do a proper match for its role as an input.  */\n \tXEXP (x, 0) = x_dest0;\n \tif (!rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 1, info))\n \t  return false;"}, {"sha": "27d985ea1394f48fd9e382fd85c066ed7fe65009", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -2288,7 +2288,7 @@ init_inline_once (void)\n   /* Estimating time for call is difficult, since we have no idea what the\n      called function does.  In the current uses of eni_time_weights,\n      underestimating the cost does less harm than overestimating it, so\n-     we choose a rather small walue here.  */\n+     we choose a rather small value here.  */\n   eni_time_weights.call_cost = 10;\n   eni_time_weights.div_mod_cost = 10;\n   eni_time_weights.switch_cost = 4;"}, {"sha": "56ef2e90e8cb4524fa59e70e75a014586177af73", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1060,7 +1060,7 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n     return false;\n \n   /* We don't want to see undefined signed overflow warnings while\n-     computing the nmber of iterations.  */\n+     computing the number of iterations.  */\n   fold_defer_overflow_warnings ();\n \n   iv0.base = expand_simple_operations (iv0.base);"}, {"sha": "7b3f4c8fd6fe86a33088c060cd23c5f67d365a4a", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1438,7 +1438,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         can make all data references satisfy vect_supportable_dr_alignment.\n         If so, update data structures as needed and return true.  Note that\n         at this time vect_supportable_dr_alignment is known to return false\n-        for a a misaligned write.\n+        for a misaligned write.\n \n      B) If peeling wasn't possible and there is a data reference with an\n         unknown misalignment that does not satisfy vect_supportable_dr_alignment\n@@ -1812,7 +1812,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t{\n \t  /* Skip same data-refs. In case that two or more stmts share data-ref\n \t     (supported only for loads), we vectorize only the first stmt, and\n-\t     the rest get their vectorized loads from the the first one.  */\n+\t     the rest get their vectorized loads from the first one.  */\n \t  if (!tree_int_cst_compare (DR_INIT (data_ref),\n \t\t\t\t     DR_INIT (STMT_VINFO_DATA_REF (\n \t\t\t\t\t\t      vinfo_for_stmt (next)))))"}, {"sha": "07c077329a3b28adf706e6a6eef5b71b6fed2f03", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea2c620c644121eb9596d47c182453475f5dc559/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=ea2c620c644121eb9596d47c182453475f5dc559", "patch": "@@ -1073,7 +1073,7 @@ get_initial_def_for_reduction (tree stmt, tree init_val, tree *scalar_def)\n    REDUCTION_PHI is the phi-node that carries the reduction computation.\n \n    This function:\n-   1. Creates the reduction def-use cycle: sets the the arguments for \n+   1. Creates the reduction def-use cycle: sets the arguments for \n       REDUCTION_PHI:\n       The loop-entry argument is the vectorized initial-value of the reduction.\n       The loop-latch argument is VECT_DEF - the vector of partial sums."}]}