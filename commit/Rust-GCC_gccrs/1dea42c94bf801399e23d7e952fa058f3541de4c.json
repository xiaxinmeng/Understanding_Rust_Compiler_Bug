{"sha": "1dea42c94bf801399e23d7e952fa058f3541de4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRlYTQyYzk0YmY4MDEzOTllMjNkN2U5NTJmYTA1OGYzNTQxZGU0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-04-29T22:40:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-04-29T22:40:07Z"}, "message": "compiler: Consider multi-result calls in escape analysis.\n\nWhen building connection graphs between objects, the analysis\nonly handled calls of the form `call(...)` or `var := call(...)`.\nFunctions with multiple results being used e.g. `var, _ = call(...)`\nwere not analyzed, causing some escaping variables to be marked as\nnon-escaping.\n\nFrom-SVN: r222598", "tree": {"sha": "32052a5b2324b3645095c963ed6bcc8b0b5bc8dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32052a5b2324b3645095c963ed6bcc8b0b5bc8dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dea42c94bf801399e23d7e952fa058f3541de4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dea42c94bf801399e23d7e952fa058f3541de4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dea42c94bf801399e23d7e952fa058f3541de4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dea42c94bf801399e23d7e952fa058f3541de4c/comments", "author": null, "committer": null, "parents": [{"sha": "67b68b8139ca4e45c8948642cd6678159ae51311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b68b8139ca4e45c8948642cd6678159ae51311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b68b8139ca4e45c8948642cd6678159ae51311"}], "stats": {"total": 162, "additions": 132, "deletions": 30}, "files": [{"sha": "1acd29cd70a3c589a8c8c3a04648554ecc489f81", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 132, "deletions": 30, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dea42c94bf801399e23d7e952fa058f3541de4c/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dea42c94bf801399e23d7e952fa058f3541de4c/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=1dea42c94bf801399e23d7e952fa058f3541de4c", "patch": "@@ -989,21 +989,21 @@ Build_connection_graphs::variable(Named_object* var)\n \t      Named_object* lhs_no = this->resolve_var_reference(assn->lhs());\n \t      Named_object* rhs_no = this->resolve_var_reference(assn->rhs());\n \n-\t      if (assn->rhs()->is_composite_literal()\n-\t\t  || assn->rhs()->heap_expression() != NULL)\n-\t\tthis->handle_composite_literal(var, assn->rhs());\n-\t      else if (assn->rhs()->call_result_expression() != NULL)\n+\t      Expression* rhs = assn->rhs();\n+\t      if (rhs->is_composite_literal()\n+\t\t  || rhs->heap_expression() != NULL)\n+\t\tthis->handle_composite_literal(var, rhs);\n+\n+\t      if (rhs->call_result_expression() != NULL)\n \t\t{\n \t\t  // V's initialization will be a call result if\n \t\t  // V, V1 := call(VAR).\n \t\t  // There are no useful edges to make from V, but we want\n \t\t  // to make sure we handle the call that references VAR.\n-\t\t  Expression* call =\n-\t\t    assn->rhs()->call_result_expression()->call();\n-\t\t  this->handle_call(var, call);\n+\t\t  rhs = rhs->call_result_expression()->call();\n \t\t}\n-\t      else if (assn->rhs()->call_expression() != NULL)\n-\t\tthis->handle_call(var, assn->rhs());\n+\t      if (rhs->call_expression() != NULL)\n+\t\tthis->handle_call(var, rhs);\n \n \t      // If there is no standalone variable on the rhs, this could be a\n \t      // binary expression, which isn't interesting for analysis or a\n@@ -1038,8 +1038,12 @@ Build_connection_graphs::variable(Named_object* var)\n \t    break;\n \n \t  case Statement::STATEMENT_EXPRESSION:\n-\t    this->handle_call(var,\n-\t    \t\t      p->statement->expression_statement()->expr());\n+\t    {\n+\t      Expression* call = p->statement->expression_statement()->expr();\n+\t      if (call->call_result_expression() != NULL)\n+\t\tcall = call->call_result_expression()->call();\n+\t      this->handle_call(var, call);\n+\t    }\n \t    break;\n \n \t  case Statement::STATEMENT_GO:\n@@ -1064,10 +1068,17 @@ Build_connection_graphs::variable(Named_object* var)\n \t      else if (cond->binary_expression() != NULL)\n \t\t{\n \t\t  Binary_expression* comp = cond->binary_expression();\n-\t\t  if (comp->left()->call_expression() != NULL)\n-\t\t    this->handle_call(var, comp->left());\n-\t\t  if (comp->right()->call_expression() != NULL)\n-\t\t    this->handle_call(var, comp->right());\n+\t\t  Expression* left = comp->left();\n+\t\t  Expression* right = comp->right();\n+\n+\t\t  if (left->call_result_expression() != NULL)\n+\t\t    left = left->call_result_expression()->call();\n+\t\t  if (left->call_expression() != NULL)\n+\t\t    this->handle_call(var, left);\n+\t\t  if (right->call_result_expression() != NULL)\n+\t\t    right = right->call_result_expression()->call();\n+\t\t  if (right->call_expression() != NULL)\n+\t\t    this->handle_call(var, right);\n \t\t}\n \t    }\n \t    break;\n@@ -1092,16 +1103,10 @@ Build_connection_graphs::variable(Named_object* var)\n \t\t  // composite literal.\n \t\t  this->handle_composite_literal(decl_no, init);\n \t\t}\n-\t      else if (init->call_result_expression() != NULL)\n-\t\t{\n-\t\t  // V's initialization will be a call result if\n-\t\t  // V, V1 := call(VAR).\n-\t\t  // There's no useful edges to make from V or V1, but we want\n-\t\t  // to make sure we handle the call that references VAR.\n-\t\t  Expression* call = init->call_result_expression()->call();\n-\t\t  this->handle_call(var, call);\n-\t\t}\n-\t      else if (init->call_expression() != NULL)\n+\n+\t      if (init->call_result_expression() != NULL)\n+\t\tinit = init->call_result_expression()->call();\n+\t      if (init->call_expression() != NULL)\n \t\tthis->handle_call(var, init);\n \t    }\n \t    break;\n@@ -1148,18 +1153,46 @@ Build_connection_graphs::statement(Block*, size_t*, Statement* s)\n       if (lhs_no == NULL)\n \tbreak;\n \n-      if (assn->rhs()->func_expression() != NULL)\n+      Expression* rhs = assn->rhs();\n+      if (rhs->temporary_reference_expression() != NULL)\n+\trhs = rhs->temporary_reference_expression()->statement()->init();\n+      if (rhs == NULL)\n+\tbreak;\n+\n+      if (rhs->call_result_expression() != NULL)\n+\trhs = rhs->call_result_expression()->call();\n+      if (rhs->call_expression() != NULL)\n+\t{\n+\t  // It's not clear what variables we are trying to find references to\n+\t  // so just use the arguments to this call.\n+\t  Expression_list* args = rhs->call_expression()->args();\n+\t  if (args == NULL)\n+\t    break;\n+\n+\t  for (Expression_list::const_iterator p = args->begin();\n+\t       p != args->end();\n+\t       ++p)\n+\t    {\n+\t      Named_object* no = this->resolve_var_reference(*p);\n+\t      if (no != NULL) {\n+\t\tNode* lhs_node = this->gogo_->add_connection_node(lhs_no);\n+\t\tNode* rhs_node = this->gogo_->add_connection_node(no);\n+\t\tlhs_node->add_edge(rhs_node);\n+\t      }\n+\t    }\n+\n+\t  this->handle_call(lhs_no, rhs);\n+\t}\n+      else if (rhs->func_expression() != NULL)\n \t{\n \t  Node* lhs_node = this->gogo_->add_connection_node(lhs_no);\n-\t  Named_object* fn = assn->rhs()->func_expression()->named_object();\n+\t  Named_object* fn = rhs->func_expression()->named_object();\n \t  Node* fn_node = this->gogo_->add_connection_node(fn);\n \t  lhs_node->add_edge(fn_node);\n \t}\n-      else if (assn->rhs()->call_expression() != NULL)\n-\tthis->handle_call(lhs_no, assn->rhs()->call_expression());\n       else\n \t{\n-\t  Named_object* rhs_no = this->resolve_var_reference(assn->rhs());\n+\t  Named_object* rhs_no = this->resolve_var_reference(rhs);\n \t  if (rhs_no != NULL)\n \t    {\n \t      Node* lhs_node = this->gogo_->add_connection_node(lhs_no);\n@@ -1188,6 +1221,8 @@ Build_connection_graphs::statement(Block*, size_t*, Statement* s)\n   case Statement::STATEMENT_EXPRESSION:\n     {\n       Expression* expr = s->expression_statement()->expr();\n+      if (expr->call_result_expression() != NULL)\n+\texpr = expr->call_result_expression()->call();\n       if (expr->call_expression() != NULL)\n \t{\n \t  // It's not clear what variables we are trying to find references to\n@@ -1208,6 +1243,73 @@ Build_connection_graphs::statement(Block*, size_t*, Statement* s)\n     }\n     break;\n \n+  case Statement::STATEMENT_GO:\n+  case Statement::STATEMENT_DEFER:\n+    {\n+      // Any variable referenced via a go or defer statement escapes to\n+      // a different goroutine.\n+      Expression* call = s->thunk_statement()->call();\n+      if (call->call_expression() != NULL)\n+\t{\n+\t  // It's not clear what variables we are trying to find references to\n+\t  // so just use the arguments to this call.\n+\t  Expression_list* args = call->call_expression()->args();\n+\t  if (args == NULL)\n+\t    break;\n+\n+\t  for (Expression_list::const_iterator p = args->begin();\n+\t       p != args->end();\n+\t       ++p)\n+\t    {\n+\t      Named_object* no = this->resolve_var_reference(*p);\n+\t      if (no != NULL)\n+\t\tthis->handle_call(no, call);\n+\t    }\n+\t}\n+    }\n+    break;\n+\n+  case Statement::STATEMENT_VARIABLE_DECLARATION:\n+    {\n+      Variable_declaration_statement* decl =\n+\ts->variable_declaration_statement();\n+      Named_object* decl_no = decl->var();\n+      Variable* v = decl_no->var_value();\n+\n+      Expression* init = v->init();\n+      if (init == NULL)\n+\tbreak;\n+\n+      if (init->is_composite_literal()\n+\t  || init->heap_expression() != NULL)\n+\t{\n+\t  // Create edges between DECL_NO and each named object in the\n+\t  // composite literal.\n+\t  this->handle_composite_literal(decl_no, init);\n+\t}\n+\n+      if (init->call_result_expression() != NULL)\n+\tinit = init->call_result_expression()->call();\n+      if (init->call_expression() != NULL)\n+\t{\n+\t  // It's not clear what variables we are trying to find references to\n+\t  // so just use the arguments to this call.\n+\t  Expression_list* args = init->call_expression()->args();\n+\t  if (args == NULL)\n+\t    break;\n+\n+\t  for (Expression_list::const_iterator p = args->begin();\n+\t       p != args->end();\n+\t       ++p)\n+\t    {\n+\t      Named_object* no = this->resolve_var_reference(*p);\n+\t      if (no != NULL)\n+\t\tthis->handle_call(no, init);\n+\t    }\n+\t}\n+    }\n+    break;\n+\n   default:\n     break;\n   }"}]}