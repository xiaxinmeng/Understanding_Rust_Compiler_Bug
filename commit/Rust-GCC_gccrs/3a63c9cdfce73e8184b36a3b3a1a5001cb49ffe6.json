{"sha": "3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E2M2M5Y2RmY2U3M2U4MTg0YjM2YTNiM2ExYTUwMDFjYjQ5ZmZlNg==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2008-10-15T16:48:13Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-10-15T16:48:13Z"}, "message": "forward_list: New.\n\n2008-10-15  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* include/std/forward_list: New.\n\t* include/bits/forward_list.h: Likewise.\n\t* include/bits/forward_list.tcc: Likewise.\n\t* include/precompiled/stdc++.h: Modified to include forward_list.\n\t* include/Makefile.am: Add forward_list, forward_list.h, and\n\tforward_list.tcc.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/23_containers/forward_list/modifiers/1.cc: New.\n\t* testsuite/23_containers/forward_list/modifiers/2.cc: Likewise.\n\t* testsuite/23_containers/forward_list/modifiers/3.cc: Likewise.\n\t* testsuite/23_containers/forward_list/modifiers/4.cc: Likewise.\n\t* testsuite/23_containers/forward_list/modifiers/5.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/1.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/2.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/3.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/4.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/5.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/6.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/7.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/8.cc: Likewise.\n\t* testsuite/23_containers/forward_list/cons/9.cc: Likewise.\n\t* testsuite/23_containers/forward_list/requirements/1.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/1.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/2.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/3.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/4.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/5.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/6.cc: Likewise.\n\t* testsuite/23_containers/forward_list/operations/7.cc: Likewise.\n\t* testsuite/23_containers/forward_list/capacity/1.cc: Likewise.\n\t* testsuite/23_containers/forward_list/comparable.cc: Likewise.\n\t* testsuite/23_containers/forward_list/moveable.cc: Likewise.\n\t* testsuite/23_containers/headers/forward_list/synopsis.cc: Likewise.\n\t* testsuite/17_intro/headers/c++200x/all_multiple_inclusion.cc: Update.\n\t* testsuite/17_intro/headers/c++200x/all: Likewise.\n\nFrom-SVN: r141146", "tree": {"sha": "f4e168d347de01f5a0c1999ad2ee49786cac002b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4e168d347de01f5a0c1999ad2ee49786cac002b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "21c74256c36074cd3bab4895079977ab11672789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c74256c36074cd3bab4895079977ab11672789", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c74256c36074cd3bab4895079977ab11672789"}], "stats": {"total": 3445, "additions": 3444, "deletions": 1}, "files": [{"sha": "7d653fec328c57d3817860196710cd9778d7a178", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -1,3 +1,41 @@\n+2008-10-15  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* include/std/forward_list: New.\n+\t* include/bits/forward_list.h: Likewise.\n+\t* include/bits/forward_list.tcc: Likewise.\n+\t* include/precompiled/stdc++.h: Modified to include forward_list.\n+\t* include/Makefile.am: Add forward_list, forward_list.h, and\n+\tforward_list.tcc.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/23_containers/forward_list/modifiers/1.cc: New.\n+\t* testsuite/23_containers/forward_list/modifiers/2.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/modifiers/3.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/modifiers/4.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/modifiers/5.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/1.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/2.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/3.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/4.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/5.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/6.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/7.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/8.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/cons/9.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/requirements/1.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/1.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/2.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/3.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/4.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/5.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/6.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/operations/7.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/capacity/1.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/comparable.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/moveable.cc: Likewise.\n+\t* testsuite/23_containers/headers/forward_list/synopsis.cc: Likewise.\n+\t* testsuite/17_intro/headers/c++200x/all_multiple_inclusion.cc: Update.\n+\t* testsuite/17_intro/headers/c++200x/all: Likewise.\n+\n 2008-10-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/bits/stl_list.h (_List_node<>::_List_node<>(_Args&&...)):"}, {"sha": "0d19a45576c338092722aab086a992fd0eb636a2", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -36,6 +36,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n+\t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n \t${std_srcdir}/functional \\\n \t${std_srcdir}/iomanip \\\n@@ -87,6 +88,8 @@ bits_headers = \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n+\t${bits_srcdir}/forward_list.h \\\n+\t${bits_srcdir}/forward_list.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n \t${bits_srcdir}/functional_hash.h \\"}, {"sha": "e17ec3a508fbd9a0d6947737d1582de3e87252f1", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -302,6 +302,7 @@ std_headers = \\\n \t${std_srcdir}/complex \\\n \t${std_srcdir}/condition_variable \\\n \t${std_srcdir}/deque \\\n+\t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\\n \t${std_srcdir}/functional \\\n \t${std_srcdir}/iomanip \\\n@@ -353,6 +354,8 @@ bits_headers = \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n+\t${bits_srcdir}/forward_list.h \\\n+\t${bits_srcdir}/forward_list.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n \t${bits_srcdir}/functional_hash.h \\"}, {"sha": "8e5a6b0a72c195ccdadfabbd88938175e8d55714", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "added", "additions": 1342, "deletions": 0, "changes": 1342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,1342 @@\n+// <forward_list.h> -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file forward_list.h\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_FORWARD_LIST_H\n+#define _GLIBCXX_FORWARD_LIST_H 1\n+\n+#pragma GCC system_header\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#else\n+\n+#include <memory>\n+#include <initializer_list>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  /**\n+   *  @brief  A helper basic node class for @forward_list.\n+   *          This is just a linked list with nothing inside it.\n+   *          There are purely list shuffling utility methods here.\n+   */\n+  struct _Fwd_list_node_base\n+  {\n+    _Fwd_list_node_base() : _M_next(0) { }\n+\n+    _Fwd_list_node_base* _M_next;\n+\n+    static void\n+    swap(_Fwd_list_node_base& __x, _Fwd_list_node_base& __y)\n+    { std::swap(__x._M_next, __y._M_next); }\n+\n+    void\n+    _M_transfer_after(_Fwd_list_node_base* __bbegin,\n+                      _Fwd_list_node_base* __bend)\n+    {\n+      _Fwd_list_node_base* __keep = __bbegin->_M_next;\n+      if (__bend)\n+        {\n+          __bbegin->_M_next = __bend->_M_next;\n+          __bend->_M_next = this->_M_next;\n+        }\n+      else\n+        __bbegin->_M_next = 0;\n+      this->_M_next = __keep;\n+    }\n+\n+    void\n+    _M_transfer_after(_Fwd_list_node_base* __bbegin)\n+    {\n+      _Fwd_list_node_base* __bend = __bbegin;\n+      while (__bend && __bend->_M_next)\n+        __bend = __bend->_M_next;\n+      _M_transfer_after(__bbegin, __bend);\n+    }\n+\n+    void\n+    _M_reverse_after()\n+    {\n+      _Fwd_list_node_base* __tail = this->_M_next;\n+      if (! __tail)\n+        return;\n+      while (_Fwd_list_node_base* __temp = __tail->_M_next)\n+        {\n+          _Fwd_list_node_base* __keep = this->_M_next;\n+          this->_M_next = __temp;\n+          __tail->_M_next = __temp->_M_next;\n+          this->_M_next->_M_next = __keep;\n+        }\n+    }\n+  };\n+\n+  /**\n+   *  @brief  A helper node class for @forward_list.\n+   *          This is just a linked list with a data value in each node.\n+   *          There is a sorting utility method.\n+   */\n+  template<typename _Tp>\n+    struct _Fwd_list_node : public _Fwd_list_node_base\n+    {\n+      template<typename... _Args>\n+        _Fwd_list_node(_Args&&... __args)\n+        : _Fwd_list_node_base(), _M_value(std::forward<_Args>(__args)...) { }\n+\n+      template<typename _Comp>\n+        void\n+        _M_sort_after(_Comp __comp);\n+\n+      _Tp _M_value;\n+    };\n+\n+  /**\n+   *   @brief A forward_list::iterator.\n+   * \n+   *   All the functions are op overloads.\n+   */\n+  template<typename _Tp>\n+    struct _Fwd_list_iterator\n+    {\n+      typedef _Fwd_list_iterator<_Tp>           _Self;\n+      typedef _Fwd_list_node<_Tp>               _Node;\n+\n+      typedef _Tp                               value_type;\n+      typedef _Tp*                              pointer;\n+      typedef _Tp&                              reference;\n+      typedef ptrdiff_t                         difference_type;\n+      typedef std::forward_iterator_tag         iterator_category;\n+\n+      _Fwd_list_iterator() : _M_node() { }\n+\n+      explicit\n+      _Fwd_list_iterator(_Fwd_list_node_base* __n) : _M_node(__n) { }\n+\n+      reference\n+      operator*() const\n+      { return static_cast<_Node*>(this->_M_node)->_M_value; }\n+\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Node*>(this->_M_node)->_M_value; }\n+\n+      _Self&\n+      operator++()\n+      {\n+        this->_M_node = this->_M_node->_M_next;\n+        return *this;\n+      }\n+\n+      _Self\n+      operator++(int)\n+      {\n+        _Self __tmp(*this);\n+        this->_M_node = this->_M_node->_M_next;\n+        return __tmp;\n+      }\n+\n+      bool\n+      operator==(const _Self& __x) const\n+      { return this->_M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return this->_M_node != __x._M_node; }\n+\n+      const _Self&\n+      _M_next() const\n+      {\n+        if (_M_node)\n+          return _Fwd_list_iterator(this->_M_node->_M_next);\n+        else\n+          return _Fwd_list_iterator(0);\n+      }\n+\n+      _Fwd_list_node_base* _M_node;\n+    };\n+\n+  /**\n+   *   @brief A forward_list::const_iterator.\n+   * \n+   *   All the functions are op overloads.\n+   */\n+  template<typename _Tp>\n+    struct _Fwd_list_const_iterator\n+    {\n+      typedef _Fwd_list_const_iterator<_Tp>     _Self;\n+      typedef const _Fwd_list_node<_Tp>         _Node;\n+      typedef _Fwd_list_iterator<_Tp>           iterator;\n+\n+      typedef _Tp                               value_type;\n+      typedef const _Tp*                        pointer;\n+      typedef const _Tp&                        reference;\n+      typedef ptrdiff_t                         difference_type;\n+      typedef std::forward_iterator_tag         iterator_category;\n+\n+      _Fwd_list_const_iterator() : _M_node() { }\n+\n+      explicit\n+      _Fwd_list_const_iterator(const _Fwd_list_node_base* __n)\n+      : _M_node(__n) { }\n+\n+      _Fwd_list_const_iterator(const iterator& __iter)\n+      : _M_node(__iter._M_node) { }\n+\n+      reference\n+      operator*() const\n+      { return static_cast<_Node*>(this->_M_node)->_M_value; }\n+\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Node*>(this->_M_node)->_M_value; }\n+\n+      _Self&\n+      operator++()\n+      {\n+        this->_M_node = this->_M_node->_M_next;\n+        return *this;\n+      }\n+\n+      _Self\n+      operator++(int)\n+      {\n+        _Self __tmp(*this);\n+        this->_M_node = this->_M_node->_M_next;\n+        return __tmp;\n+      }\n+\n+      bool\n+      operator==(const _Self& __x) const\n+      { return this->_M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return this->_M_node != __x._M_node; }\n+\n+      const _Self&\n+      _M_next() const\n+      {\n+        if (this->_M_node)\n+          return _Fwd_list_const_iterator(this->_M_node->_M_next);\n+        else\n+          return _Fwd_list_const_iterator(0);\n+      }\n+\n+      const _Fwd_list_node_base* _M_node;\n+    };\n+\n+  /**\n+   *  @brief  Forward list iterator equality comparison.\n+   */\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const _Fwd_list_iterator<_Tp>& __x,\n+               const _Fwd_list_const_iterator<_Tp>& __y)\n+    { return __x._M_node == __y._M_node; }\n+\n+  /**\n+   *  @brief  Forward list iterator inequality comparison.\n+   */\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const _Fwd_list_iterator<_Tp>& __x,\n+               const _Fwd_list_const_iterator<_Tp>& __y)\n+    { return __x._M_node != __y._M_node; }\n+\n+  /**\n+   *  @brief  Base class for @forward_list.\n+   */\n+  template<typename _Tp, typename _Alloc>\n+    struct _Fwd_list_base\n+    {\n+    protected:\n+      typedef typename _Alloc::template rebind<_Fwd_list_node<_Tp>>::other\n+        _Node_alloc_type;\n+\n+      struct _Fwd_list_impl \n+      : public _Node_alloc_type\n+      {\n+\t_Fwd_list_node_base _M_head;\n+\n+\t_Fwd_list_impl()\n+\t: _Node_alloc_type(), _M_head()\n+\t{ }\n+\n+\texplicit\n+        _Fwd_list_impl(const _Node_alloc_type& __a)\n+\t: _Node_alloc_type(__a), _M_head()\n+\t{ }\n+      };\n+\n+      _Fwd_list_impl _M_impl;\n+\n+    public:\n+      typedef _Alloc                          allocator_type;\n+      typedef _Fwd_list_iterator<_Tp>         iterator;\n+      typedef _Fwd_list_const_iterator<_Tp>   const_iterator;\n+\n+      typedef _Fwd_list_node<_Tp>             _Node;\n+\n+      _Node_alloc_type&\n+      _M_get_Node_allocator()\n+      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }\n+\n+      const _Node_alloc_type&\n+      _M_get_Node_allocator() const\n+      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return this->_M_get_Node_allocator(); }\n+\n+      _Fwd_list_base()\n+      : _M_impl()\n+      { this->_M_impl._M_head._M_next = 0; }\n+\n+      _Fwd_list_base(const allocator_type& __a)\n+      : _M_impl(__a)\n+      { this->_M_impl._M_head._M_next = 0; }\n+\n+      _Fwd_list_base(const _Fwd_list_base& __lst, const _Alloc& __a);\n+\n+      _Fwd_list_base(_Fwd_list_base&& __lst, const _Alloc& __a)\n+      : _M_impl(__a)\n+      { _Fwd_list_node_base::swap(this->_M_impl._M_head,\n+                                  __lst._M_impl._M_head); }\n+\n+      _Fwd_list_base(_Fwd_list_base&& __lst)\n+      : _M_impl(__lst._M_get_Node_allocator())\n+      { _Fwd_list_node_base::swap(this->_M_impl._M_head,\n+                                  __lst._M_impl._M_head); }\n+\n+      ~_Fwd_list_base()\n+      { _M_erase_after(&_M_impl._M_head, 0); }\n+\n+    protected:\n+\n+      _Node*\n+      _M_get_node()\n+      { return _M_get_Node_allocator().allocate(1); }\n+\n+      template<typename... _Args>\n+        _Node*\n+        _M_create_node(_Args&&... __args)\n+        {\n+          _Node* __node = this->_M_get_node();\n+          try\n+            {\n+              _M_get_Node_allocator().construct(__node,\n+\t\t\t\t\t\tstd::forward<_Args>(__args)...);\n+              __node->_M_next = 0;\n+            }\n+          catch(...)\n+            {\n+              this->_M_put_node(__node);\n+              __throw_exception_again;\n+            }\n+          return __node;\n+        }\n+\n+      template<typename... _Args>\n+        void\n+        _M_insert_after(const_iterator __pos, _Args&&... __args)\n+        {\n+          _Fwd_list_node_base* __to\n+            = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+          _Node* __thing = _M_create_node(std::forward<_Args>(__args)...);\n+          __thing->_M_next = __to->_M_next;\n+          __to->_M_next = __thing;\n+        }\n+\n+      void\n+      _M_put_node(_Node* __p)\n+      { _M_get_Node_allocator().deallocate(__p, 1); }\n+\n+      _Fwd_list_node_base*\n+      _M_erase_after(_Fwd_list_node_base* __pos);\n+\n+      _Fwd_list_node_base*\n+      _M_erase_after(_Fwd_list_node_base* __pos,\n+                     _Fwd_list_node_base* __last);\n+    };\n+\n+  /**\n+   *  @brief A standard container with linear time access to elements,\n+   *  and fixed time insertion/deletion at any point in the sequence.\n+   *\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#67\">sequence</a>, including the\n+   *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n+   *  %exception of @c at and @c operator[].\n+   *\n+   *  This is a @e singly @e linked %list.  Traversal up the\n+   *  %list requires linear time, but adding and removing elements (or\n+   *  @e nodes) is done in constant time, regardless of where the\n+   *  change takes place.  Unlike std::vector and std::deque,\n+   *  random-access iterators are not provided, so subscripting ( @c\n+   *  [] ) access is not allowed.  For algorithms which only need\n+   *  sequential access, this lack makes no difference.\n+   *\n+   *  Also unlike the other standard containers, std::forward_list provides\n+   *  specialized algorithms %unique to linked lists, such as\n+   *  splicing, sorting, and in-place reversal.\n+   *\n+   *  A couple points on memory allocation for forward_list<Tp>:\n+   *\n+   *  First, we never actually allocate a Tp, we allocate\n+   *  Fwd_list_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure\n+   *  that after elements from %forward_list<X,Alloc1> are spliced into\n+   *  %forward_list<X,Alloc2>, destroying the memory of the second %list is a\n+   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.\n+   */\n+  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n+    class forward_list : private _Fwd_list_base<_Tp, _Alloc>\n+    {\n+    private:\n+      typedef _Fwd_list_base<_Tp, _Alloc>       _Base;\n+      typedef _Fwd_list_node<_Tp>               _Node;\n+\n+    public:\n+      // types:\n+      typedef typename _Alloc::reference        reference;\n+      typedef typename _Alloc::const_reference  const_reference;\n+      typedef _Fwd_list_iterator<_Tp>           iterator;\n+      typedef _Fwd_list_const_iterator<_Tp>     const_iterator;\n+      typedef std::size_t                       size_type;\n+      typedef std::ptrdiff_t                    difference_type;\n+      typedef _Tp                               value_type;\n+      typedef typename _Base::allocator_type    allocator_type;\n+      typedef typename _Alloc::pointer          pointer;\n+      typedef typename _Alloc::const_pointer    const_pointer;\n+\n+      // 23.2.3.1 construct/copy/destroy:\n+\n+      /**\n+       *  @brief  Creates a %forward_list with no elements.\n+       *  @param  al  An allocator object.\n+       */\n+      explicit\n+      forward_list(const _Alloc& __al = _Alloc())\n+      : _Base(__al)\n+      { }\n+\n+      /**\n+       *  @brief  Copy constructor with allocator argument.\n+       *  @param  list  Input list to copy.\n+       *  @param  al    An allocator object.\n+       */\n+      forward_list(const forward_list& __list, const _Alloc& __al)\n+      : _Base(__list, __al)\n+      { }\n+\n+      /**\n+       *  @brief  Move constructor with allocator argument.\n+       *  @param  list  Input list to move.\n+       *  @param  al    An allocator object.\n+       */\n+      forward_list(forward_list&& __list, const _Alloc& __al)\n+      : _Base(std::forward<_Base>(__list), __al)\n+      { }\n+\n+      /**\n+       *  @brief  Creates a %forward_list with copies of the default element\n+       *          type.\n+       *  @param  n  The number of elements to initially create.\n+       *\n+       *  This constructor fills the %forward_list with @a n copies of\n+       *  the default value.\n+       */\n+      explicit\n+      forward_list(size_type __n);\n+\n+      /**\n+       *  @brief  Creates a %forward_list with copies of an exemplar element.\n+       *  @param  n      The number of elements to initially create.\n+       *  @param  value  An element to copy.\n+       *  @param  al     An allocator object.\n+       *\n+       *  This constructor fills the %forward_list with @a n copies of @a\n+       *  value.\n+       */\n+      forward_list(size_type __n, const _Tp& __value,\n+                   const _Alloc& __al = _Alloc());\n+\n+      /**\n+       *  @brief  Builds a %forward_list from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *  @param  al     An allocator object.\n+       *\n+       *  Create a %forward_list consisting of copies of the elements from\n+       *  [@a first,@a last).  This is linear in N (where N is\n+       *  distance(@a first,@a last)).\n+       */\n+      template<typename _InputIterator>\n+        forward_list(_InputIterator __first, _InputIterator __last,\n+\t\t     const _Alloc& __al = _Alloc());\n+\n+      /**\n+       *  @brief  The %forward_list copy constructor.\n+       *  @param  list  A %forward_list of identical element and allocator\n+       *                types.\n+       *\n+       *  The newly-created %forward_list uses a copy of the allocation\n+       *  object used by @a list.\n+       */\n+      forward_list(const forward_list& __list);\n+\n+      /**\n+       *  @brief  The %forward_list move constructor.\n+       *  @param  list  A %forward_list of identical element and allocator\n+       *                types.\n+       *\n+       *  The newly-created %forward_list contains the exact contents of @a\n+       *  forward_list. The contents of @a list are a valid, but unspecified\n+       *  %forward_list.\n+       */\n+      forward_list(forward_list&& __list)\n+      : _Base(std::forward<_Base>(__list)) { }\n+\n+      /**\n+       *  @brief  Builds a %forward_list from an initializer_list\n+       *  @param  il  An initializer_list of value_type.\n+       *  @param  al  An allocator object.\n+       *\n+       *  Create a %forward_list consisting of copies of the elements\n+       *  in the initializer_list @a il.  This is linear in il.size().\n+       */\n+      forward_list(std::initializer_list<_Tp> __il,\n+                   const _Alloc& __al = _Alloc());\n+\n+      /**\n+       *  @brief  The forward_list dtor.\n+       */\n+      ~forward_list()\n+      { _M_erase_after(&this->_M_impl._M_head, 0); }\n+\n+      /**\n+       *  @brief  The %forward_list assignment operator.\n+       *  @param  list  A %forward_list of identical element and allocator\n+       *                types.\n+       *\n+       *  All the elements of @a list are copied, but unlike the copy\n+       *  constructor, the allocator object is not copied.\n+       */\n+      forward_list&\n+      operator=(const forward_list& __list);\n+\n+      /**\n+       *  @brief  The %forward_list move assignment operator.\n+       *  @param  list  A %forward_list of identical element and allocator\n+       *                types.\n+       *\n+       *  The contents of @a list are moved into this %forward_list\n+       *  (without copying). @a list is a valid, but unspecified\n+       *  %forward_list\n+       */\n+      forward_list&\n+      operator=(forward_list&& __list)\n+      {\n+        if (&__list != this)\n+          {\n+            this->clear();\n+            this->swap(__list);\n+          }\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief  The %forward_list initializer list assignment operator.\n+       *  @param  il  An initializer_list of value_type.\n+       *\n+       *  Replace the contents of the %forward_list with copies of the\n+       *  elements in the initializer_list @a il.  This is linear in\n+       *  il.size().\n+       */\n+      forward_list\n+      operator=(std::initializer_list<_Tp> __il)\n+      {\n+        assign(__il);\n+        return *this;\n+      }\n+\n+      /**\n+       *  @brief  Assigns a range to a %forward_list.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function fills a %forward_list with copies of the elements\n+       *  in the range [@a first,@a last).\n+       *\n+       *  Note that the assignment completely changes the %forward_list and\n+       *  that the resulting %forward_list's size is the same as the number\n+       *  of elements assigned.  Old data may be lost.\n+       */\n+      template<typename InputIterator>\n+        void\n+        assign(InputIterator __first, InputIterator __last)\n+        {\n+          clear();\n+          insert_after(cbefore_begin(), __first, __last);\n+        }\n+\n+      /**\n+       *  @brief  Assigns a given value to a %forward_list.\n+       *  @param  n  Number of elements to be assigned.\n+       *  @param  val  Value to be assigned.\n+       *\n+       *  This function fills a %forward_list with @a n copies of the given\n+       *  value.  Note that the assignment completely changes the\n+       *  %forward_list and that the resulting %forward_list's size is the\n+       *  same as the number of elements assigned.  Old data may be lost.\n+       */\n+      void\n+      assign(size_type __n, const _Tp& __val)\n+      {\n+        clear();\n+        insert_after(cbefore_begin(), __n, __val);\n+      }\n+\n+      /**\n+       *  @brief  Assigns an initializer_list to a %forward_list.\n+       *  @param  il  An initializer_list of value_type.\n+       *\n+       *  Replace the contents of the %forward_list with copies of the\n+       *  elements in the initializer_list @a il.  This is linear in\n+       *  il.size().\n+       */\n+      void\n+      assign(std::initializer_list<_Tp> __il)\n+      {\n+        clear();\n+        insert_after(cbefore_begin(), __il);\n+      }\n+\n+      /// Get a copy of the memory allocation object.\n+      allocator_type\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n+\n+      // 23.2.3.2 iterators:\n+\n+      /**\n+       *  Returns a read/write iterator that points before the first element\n+       *  in the %forward_list.  Iteration is done in ordinary element order.\n+       */\n+      iterator\n+      before_begin()\n+      { return iterator(&this->_M_impl._M_head); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points before the\n+       *  first element in the %forward_list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      before_begin() const\n+      { return const_iterator(&this->_M_impl._M_head); }\n+\n+      /**\n+       *  Returns a read/write iterator that points to the first element\n+       *  in the %forward_list.  Iteration is done in ordinary element order.\n+       */\n+      iterator\n+      begin()\n+      { return iterator(this->_M_impl._M_head._M_next); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the first\n+       *  element in the %forward_list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      begin() const\n+      { return const_iterator(this->_M_impl._M_head._M_next); }\n+\n+      /**\n+       *  Returns a read/write iterator that points one past the last\n+       *  element in the %forward_list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      iterator\n+      end()\n+      { return iterator(0); }\n+\n+      /**\n+       *  Returns a read-only iterator that points one past the last\n+       *  element in the %forward_list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      end() const\n+      { return const_iterator(0); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points to the\n+       *  first element in the %forward_list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(this->_M_impl._M_head._M_next); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points before the\n+       *  first element in the %forward_list.  Iteration is done in ordinary\n+       *  element order.\n+       */\n+      const_iterator\n+      cbefore_begin() const\n+      { return const_iterator(&this->_M_impl._M_head); }\n+\n+      /**\n+       *  Returns a read-only (constant) iterator that points one past\n+       *  the last element in the %forward_list.  Iteration is done in\n+       *  ordinary element order.\n+       */\n+      const_iterator\n+      cend() const\n+      { return const_iterator(0); }\n+\n+      /**\n+       *  Returns true if the %forward_list is empty.  (Thus begin() would\n+       *  equal end().)\n+       */\n+      bool\n+      empty() const\n+      { return this->_M_impl._M_head._M_next == 0; }\n+\n+      /**\n+       *  Returns the largest possible size of %forward_list.\n+       */\n+      size_type\n+      max_size() const\n+      { return _Alloc().max_size(); }\n+\n+      // 23.2.3.3 element access:\n+\n+      /**\n+       *  Returns a read/write reference to the data at the first\n+       *  element of the %forward_list.\n+       */\n+      reference\n+      front()\n+      {\n+        _Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+        return __front->_M_value;\n+      }\n+\n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %forward_list.\n+       */\n+      const_reference\n+      front() const\n+      {\n+        _Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+        return __front->_M_value;\n+      }\n+\n+      // 23.2.3.4 modi\ufb01ers:\n+\n+      /**\n+       *  @brief  Constructs object in %forward_list at the front of the\n+       *          list.\n+       *  @param  args  Arguments.\n+       *\n+       *  This function will insert an object of type Tp constructed\n+       *  with Tp(std::forward<Args>(args)...) at the front of the list\n+       *  Due to the nature of a %forward_list this operation can\n+       *  be done in constant time, and does not invalidate iterators\n+       *  and references.\n+       */\n+      template<typename... _Args>\n+      void\n+      emplace_front(_Args&&... __args)\n+      { _M_insert_after(cbefore_begin(), std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief  Add data to the front of the %forward_list.\n+       *  @param  val  Data to be added.\n+       *\n+       *  This is a typical stack operation.  The function creates an\n+       *  element at the front of the %forward_list and assigns the given\n+       *  data to it.  Due to the nature of a %forward_list this operation\n+       *  can be done in constant time, and does not invalidate iterators\n+       *  and references.\n+       */\n+      void\n+      push_front(const _Tp& __val)\n+      { _M_insert_after(cbefore_begin(), __val); }\n+\n+      /**\n+       *\n+       */\n+      void\n+      push_front(_Tp&& __val)\n+      { _M_insert_after(cbefore_begin(), std::move(__val)); }\n+\n+      /**\n+       *  @brief  Removes first element.\n+       *\n+       *  This is a typical stack operation.  It shrinks the %forward_list\n+       *  by one.  Due to the nature of a %forward_list this operation can\n+       *  be done in constant time, and only invalidates iterators/references\n+       *  to the element being removed.\n+       *\n+       *  Note that no data is returned, and if the first element's data\n+       *  is needed, it should be retrieved before pop_front() is\n+       *  called.\n+       */\n+      void\n+      pop_front()\n+      { _M_erase_after(&this->_M_impl._M_head); }\n+\n+      /**\n+       *  @brief  Constructs object in %forward_list after the specified\n+       *          iterator.\n+       *  @param  pos  A const_iterator into the %forward_list.\n+       *  @param  args  Arguments.\n+       *  @return  An iterator that points to the inserted data.\n+       *\n+       *  This function will insert an object of type T constructed\n+       *  with T(std::forward<Args>(args)...) after the specified\n+       *  location.  Due to the nature of a %forward_list this operation can\n+       *  be done in constant time, and does not invalidate iterators\n+       *  and references.\n+       */\n+      template<typename... _Args>\n+      iterator\n+      emplace_after(const_iterator __pos, _Args&&... __args)\n+      { _M_insert_after(__pos, std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief  Inserts given value into %forward_list after specified\n+       *          iterator.\n+       *  @param  pos  An iterator into the %forward_list.\n+       *  @param  val  Data to be inserted.\n+       *  @return  An iterator that points to the inserted data.\n+       *\n+       *  This function will insert a copy of the given value after\n+       *  the specified location.  Due to the nature of a %forward_list this\n+       *  operation can be done in constant time, and does not\n+       *  invalidate iterators and references.\n+       */\n+      iterator\n+      insert_after(const_iterator __pos, const _Tp& __val)\n+      {\n+        _Fwd_list_node_base* __to\n+          = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+        _Node* __thing = _M_create_node(__val);\n+        __thing->_M_next = __to->_M_next;\n+        __to->_M_next = __thing;\n+        return iterator(__to->_M_next);\n+      }\n+\n+      /**\n+       *\n+       */\n+      iterator\n+      insert_after(const_iterator __pos, _Tp&& __val)\n+      {\n+        _Fwd_list_node_base* __to\n+          = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+        _Node* __thing = _M_create_node(std::move(__val));\n+        __thing->_M_next = __to->_M_next;\n+        __to->_M_next = __thing;\n+        return iterator(__to->_M_next);\n+      }\n+\n+      /**\n+       *  @brief  Inserts a number of copies of given data into the\n+       *          %forward_list.\n+       *  @param  pos  An iterator into the %forward_list.\n+       *  @param  n  Number of elements to be inserted.\n+       *  @param  val  Data to be inserted.\n+       *\n+       *  This function will insert a specified number of copies of the\n+       *  given data after the location specified by @a pos.\n+       *\n+       *  This operation is linear in the number of elements inserted and\n+       *  does not invalidate iterators and references.\n+       */\n+      void\n+      insert_after(const_iterator __pos,\n+                   size_type __n, const _Tp& __val);\n+\n+      /**\n+       *  @brief  Inserts a range into the %forward_list.\n+       *  @param  position  An iterator into the %forward_list.\n+       *  @param  first  An input iterator.\n+       *  @param  last   An input iterator.\n+       *\n+       *  This function will insert copies of the data in the range [@a\n+       *  first,@a last) into the %forward_list after the location specified\n+       *  by @a pos.\n+       *\n+       *  This operation is linear in the number of elements inserted and\n+       *  does not invalidate iterators and references.\n+       */\n+      template<typename _InputIterator>\n+        void\n+        insert_after(const_iterator __pos,\n+                     _InputIterator __first, _InputIterator __last);\n+\n+      /**\n+       *  @brief  Inserts the contents of an initializer_list into\n+       *          %forward_list after the specified iterator.\n+       *  @param  pos  An iterator into the %forward_list.\n+       *  @param  il  An initializer_list of value_type.\n+       *\n+       *  This function will insert copies of the data in the\n+       *  initializer_list @a il into the %forward_list before the location\n+       *  specified by @a pos.\n+       *\n+       *  This operation is linear in the number of elements inserted and\n+       *  does not invalidate iterators and references.\n+       */\n+      void\n+      insert_after(const_iterator __pos, std::initializer_list<_Tp> __il);\n+\n+      /**\n+       *  @brief  Removes the element pointed to by the iterator following\n+       *          @c pos.\n+       *  @param  pos  Iterator pointing to element to be erased.\n+       *  @return  An iterator pointing to the next element (or end()).\n+       *\n+       *  This function will erase the element at the given position and\n+       *  thus shorten the %forward_list by one.\n+       *\n+       *  Due to the nature of a %forward_list this operation can be done\n+       *  in constant time, and only invalidates iterators/references to\n+       *  the element being removed.  The user is also cautioned that\n+       *  this function only erases the element, and that if the element\n+       *  is itself a pointer, the pointed-to memory is not touched in\n+       *  any way.  Managing the pointer is the user's responsibility.\n+       */\n+      iterator\n+      erase_after(const_iterator __pos)\n+      {\n+        _Fwd_list_node_base* __tmp\n+          = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+        if (__tmp)\n+          return iterator(_Base::_M_erase_after(__tmp));\n+        else\n+          return end();\n+      }\n+\n+      /**\n+       *  @brief  Remove a range of elements.\n+       *  @param  pos  Iterator pointing before the first element to be\n+       *               erased.\n+       *  @param  last  Iterator pointing to one past the last element to be\n+       *                erased.\n+       *  @return  An iterator pointing to the element pointed to by @a last\n+       *           prior to erasing (or end()).\n+       *\n+       *  This function will erase the elements in the range @a\n+       *  (pos,last) and shorten the %forward_list accordingly.\n+       *\n+       *  This operation is linear time in the size of the range and only\n+       *  invalidates iterators/references to the element being removed.\n+       *  The user is also cautioned that this function only erases the\n+       *  elements, and that if the elements themselves are pointers, the\n+       *  pointed-to memory is not touched in any way.  Managing the pointer\n+       *  is the user's responsibility.\n+       */\n+      iterator\n+      erase_after(const_iterator __pos, iterator __last)\n+      {\n+        _Fwd_list_node_base* __tmp\n+          = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+        return iterator(_M_erase_after(__tmp, __last._M_node));\n+      }\n+\n+      /**\n+       *  @brief  Swaps data with another %forward_list.\n+       *  @param  list  A %forward_list of the same element and allocator\n+       *                types.\n+       *\n+       *  This exchanges the elements between two lists in constant\n+       *  time.  Note that the global std::swap() function is\n+       *  specialized such that std::swap(l1,l2) will feed to this\n+       *  function.\n+       */\n+      void\n+      swap(forward_list&& __list)\n+      { _Fwd_list_node_base::swap(this->_M_impl._M_head,\n+                                  __list._M_impl._M_head); }\n+\n+      /**\n+       *  @brief Resizes the %forward_list to the specified number of\n+       *         elements.\n+       *  @param sz Number of elements the %forward_list should contain.\n+       *\n+       *  This function will %resize the %forward_list to the specified\n+       *  number of elements.  If the number is smaller than the\n+       *  %forward_list's current size the %forward_list is truncated,\n+       *  otherwise the %forward_list is extended and new elements are\n+       *  populated with given data.\n+       */\n+      void\n+      resize(size_type __sz)\n+      { resize(__sz, _Tp(0)); }\n+\n+      /**\n+       *  @brief Resizes the %forward_list to the specified number of\n+       *         elements.\n+       *  @param sz Number of elements the %forward_list should contain.\n+       *  @param val Data with which new elements should be populated.\n+       *\n+       *  This function will %resize the %forward_list to the specified\n+       *  number of elements.  If the number is smaller than the\n+       *  %forward_list's current size the %forward_list is truncated,\n+       *  otherwise the %forward_list is extended and new elements are\n+       *  populated with given data.\n+       */\n+      void\n+      resize(size_type __sz, value_type __val);\n+\n+      /**\n+       *  @brief  Erases all the elements.\n+       *\n+       *  Note that this function only erases\n+       *  the elements, and that if the elements themselves are\n+       *  pointers, the pointed-to memory is not touched in any way.\n+       *  Managing the pointer is the user's responsibility.\n+       */\n+      void\n+      clear()\n+      { _M_erase_after(&this->_M_impl._M_head, 0); }\n+\n+      // 23.2.3.5 forward_list operations:\n+\n+      /**\n+       *  @brief  Insert contents of another %forward_list.\n+       *  @param  pos  Iterator referencing the element to insert after.\n+       *  @param  list  Source list.\n+       *\n+       *  The elements of @a list are inserted in constant time after\n+       *  the element referenced by @a pos.  @a list becomes an empty\n+       *  list.\n+       *\n+       *  Requires this != @a x.\n+       */\n+      void\n+      splice_after(const_iterator __pos,\n+                   forward_list&& __list)\n+      {\n+        if (!__list.empty() && &__list != this)\n+          {\n+            _Fwd_list_node_base* __tmp\n+              = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+            const_iterator __before = __list.cbefore_begin();\n+            __tmp->_M_transfer_after(const_cast<_Fwd_list_node_base* const>\n+\t\t\t\t     (__before._M_node));\n+          }\n+      }\n+\n+      /**\n+       *  @brief  Insert element from another %forward_list.\n+       *  @param  pos  Iterator referencing the element to insert after.\n+       *  @param  list  Source list.\n+       *  @param  it  Iterator referencing the element before the element\n+       *              to move.\n+       *\n+       *  Removes the element in list @a list referenced by @a i and\n+       *  inserts it into the current list after @a pos.\n+       */\n+      void\n+      splice_after(const_iterator __pos,\n+                   forward_list&& __list,\n+                   const_iterator __it)\n+      { this->splice_after(__pos, __list, __it, __it._M_next()); }\n+\n+      /**\n+       *  @brief  Insert range from another %forward_list.\n+       *  @param  pos  Iterator referencing the element to insert after.\n+       *  @param  list  Source list.\n+       *  @param  before  Iterator referencing before the start of range\n+       *                  in list.\n+       *  @param  last  Iterator referencing the end of range in list.\n+       *\n+       *  Removes elements in the range (before,last) and inserts them\n+       *  after @a pos in constant time.\n+       *\n+       *  Undefined if @a pos is in (before,last).\n+       */\n+      void\n+      splice_after(const_iterator __pos,\n+                   forward_list&& __list,\n+                   const_iterator __before,\n+                   const_iterator __last)\n+      {\n+        _Fwd_list_node_base* __tmp\n+          = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+        __tmp->_M_transfer_after(const_cast<_Fwd_list_node_base* const>\n+\t\t\t\t (__before._M_node),\n+\t\t\t\t const_cast<_Fwd_list_node_base* const>\n+\t\t\t\t (__last._M_node));\n+      }\n+\n+      /**\n+       *  @brief  Remove all elements equal to value.\n+       *  @param  val  The value to remove.\n+       *\n+       *  Removes every element in the list equal to @a value.\n+       *  Remaining elements stay in list order.  Note that this\n+       *  function only erases the elements, and that if the elements\n+       *  themselves are pointers, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's\n+       *  responsibility.\n+       */\n+      void\n+      remove(const _Tp& __val);\n+\n+      /**\n+       *  @brief  Remove all elements satisfying a predicate.\n+       *  @param  pred  Unary predicate function or object.\n+       *\n+       *  Removes every element in the list for which the predicate\n+       *  returns true.  Remaining elements stay in list order.  Note\n+       *  that this function only erases the elements, and that if the\n+       *  elements themselves are pointers, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibility.\n+       */\n+      template<typename _Pred>\n+        void\n+        remove_if(_Pred __pred);\n+\n+      /**\n+       *  @brief  Remove consecutive duplicate elements.\n+       *\n+       *  For each consecutive set of elements with the same value,\n+       *  remove all but the first one.  Remaining elements stay in\n+       *  list order.  Note that this function only erases the\n+       *  elements, and that if the elements themselves are pointers,\n+       *  the pointed-to memory is not touched in any way.  Managing\n+       *  the pointer is the user's responsibility.\n+       */\n+      void\n+      unique();\n+\n+      /**\n+       *  @brief  Remove consecutive elements satisfying a predicate.\n+       *  @param  binary_pred  Binary predicate function or object.\n+       *\n+       *  For each consecutive set of elements [first,last) that\n+       *  satisfy predicate(first,i) where i is an iterator in\n+       *  [first,last), remove all but the first one.  Remaining\n+       *  elements stay in list order.  Note that this function only\n+       *  erases the elements, and that if the elements themselves are\n+       *  pointers, the pointed-to memory is not touched in any way.\n+       *  Managing the pointer is the user's responsibility.\n+       */\n+      template<typename _BinPred>\n+        void\n+        unique(_BinPred __binary_pred);\n+\n+      /**\n+       *  @brief  Merge sorted lists.\n+       *  @param  list  Sorted list to merge.\n+       *\n+       *  Assumes that both @a list and this list are sorted according to\n+       *  operator<().  Merges elements of @a list into this list in\n+       *  sorted order, leaving @a list empty when complete.  Elements in\n+       *  this list precede elements in @a list that are equal.\n+       */\n+      void\n+      merge(forward_list&& __list)\n+      { this->merge(__list, std::less<_Tp>()); }\n+\n+      /**\n+       *  @brief  Merge sorted lists according to comparison function.\n+       *  @param  list  Sorted list to merge.\n+       *  @param  comp Comparison function defining sort order.\n+       *\n+       *  Assumes that both @a list and this list are sorted according to\n+       *  comp.  Merges elements of @a list into this list\n+       *  in sorted order, leaving @a list empty when complete.  Elements\n+       *  in this list precede elements in @a list that are equivalent\n+       *  according to comp().\n+       */\n+      template<typename _Comp>\n+        void\n+        merge(forward_list&& __list, _Comp __comp);\n+\n+      /**\n+       *  @brief  Sort the elements of the list.\n+       *\n+       *  Sorts the elements of this list in NlogN time.  Equivalent\n+       *  elements remain in list order.\n+       */\n+      void\n+      sort()\n+      {\n+        _Node* __tmp = static_cast<_Node*>(&this->_M_impl._M_head);\n+        __tmp->_M_sort_after(std::less<_Tp>());\n+      }\n+\n+      /**\n+       *  @brief  Sort the forward_list using a comparison function.\n+       *\n+       *  Sorts the elements of this list in NlogN time.  Equivalent\n+       *  elements remain in list order.\n+       */\n+      template<typename _Comp>\n+        void\n+        sort(_Comp __comp)\n+\t{\n+\t  _Node* __tmp = static_cast<_Node*>(&this->_M_impl._M_head);\n+\t  __tmp->_M_sort_after(__comp);\n+\t}\n+\n+      /**\n+       *  @brief  Reverse the elements in list.\n+       *\n+       *  Reverse the order of elements in the list in linear time.\n+       */\n+      void\n+      reverse()\n+      { this->_M_impl._M_head._M_reverse_after(); }\n+    };\n+\n+  /**\n+   *  @brief  Forward list equality comparison.\n+   *  @param  lx  A %forward_list\n+   *  @param  ly  A %forward_list of the same type as @a lx.\n+   *  @return  True iff the size and elements of the forward lists are equal.\n+   *\n+   *  This is an equivalence relation.  It is linear in the size of the\n+   *  forward lists.  Deques are considered equivalent if corresponding\n+   *  elements compare equal.\n+   */\n+  template<typename _Tp, typename _Alloc>\n+    bool\n+    operator==(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    {\n+      //  We don't have size() so we need to walk through both lists\n+      //  making sure both iterators are valid.\n+      typename std::forward_list<_Tp, _Alloc>::const_iterator __ix\n+        = __lx.cbegin();\n+      typename std::forward_list<_Tp, _Alloc>::const_iterator __iy\n+        = __ly.cbegin();\n+      while (__ix != __lx.cend() && __iy != __ly.cend())\n+        {\n+          if (*__ix != *__iy)\n+            return false;\n+          ++__ix;\n+          ++__iy;\n+        }\n+      if (__ix == __lx.cend() && __iy == __ly.cend())\n+        return true;\n+      else\n+        return false;\n+    }\n+\n+  /**\n+   *  @brief  Forward list ordering relation.\n+   *  @param  lx  A %forward_list.\n+   *  @param  ly  A %forward_list of the same type as @a lx.\n+   *  @return  True iff @a lx is lexicographically less than @a ly.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  forward lists.  The elements must be comparable with @c <.\n+   *\n+   *  See std::lexicographical_compare() for how the determination is made.\n+   */\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const forward_list<_Tp, _Alloc>& __lx,\n+              const forward_list<_Tp, _Alloc>& __ly)\n+    { return std::lexicographical_compare(__lx.cbegin(), __lx.cend(),\n+  \t\t\t\t\t  __ly.cbegin(), __ly.cend()); }\n+\n+  /// Based on operator==\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return ! (__lx == __ly); }\n+\n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const forward_list<_Tp, _Alloc>& __lx,\n+              const forward_list<_Tp, _Alloc>& __ly)\n+    { return (__ly < __lx); }\n+\n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return ! (__lx < __ly); }\n+\n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return ! (__ly < __lx); }\n+\n+  /// See std::forward_list::forward_swap().\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(forward_list<_Tp, _Alloc>& __lx,\n+         forward_list<_Tp, _Alloc>& __ly)\n+    { __lx.swap(__ly); }\n+\n+  /// See std::forward_list::forward_swap().\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(forward_list<_Tp, _Alloc>&& __lx,\n+         forward_list<_Tp, _Alloc>& __ly)\n+    { __lx.swap(__ly); }\n+\n+  /// See std::forward_list::forward_swap().\n+  template<typename _Tp, typename _Alloc>\n+    inline void \n+    swap(forward_list<_Tp, _Alloc>& __lx,\n+         forward_list<_Tp, _Alloc>&& __ly)\n+    { __lx.swap(__ly); }\n+\n+_GLIBCXX_END_NAMESPACE // namespace std\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n+#endif // _GLIBCXX_FORWARD_LIST_H"}, {"sha": "7a3a3d0bedaa02cac75417e3e05da19ee7309518", "filename": "libstdc++-v3/include/bits/forward_list.tcc", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,468 @@\n+// <forward_list.tcc> -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file forward_list.tcc\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _FORWARD_LIST_TCC\n+#define _FORWARD_LIST_TCC 1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+ /**\n+  *  @brief  Sort the singly linked list starting after this node.\n+  *          This node is assumed to be an empty head node (of type\n+  *          _Fwd_list_node_base).\n+  */\n+  template<typename _Tp>\n+    template<typename _Comp>\n+      void\n+      _Fwd_list_node<_Tp>::\n+      _M_sort_after(_Comp __comp)\n+      {\n+\t// If `next' is 0, return immediately.\n+\t_Fwd_list_node* __list = static_cast<_Fwd_list_node*>(this->_M_next);\n+\tif (!__list)\n+\t  return;\n+\n+\tunsigned long __insize = 1;\n+\n+\twhile (1)\n+\t  {\n+\t    _Fwd_list_node* __p = __list;\n+\t    __list = 0;\n+\t    _Fwd_list_node* __tail = 0;\n+\n+\t    // Count number of merges we do in this pass.\n+\t    unsigned long __nmerges = 0;\n+\n+\t    while (__p)\n+\t      {\n+\t\t++__nmerges;\n+\t\t// There exists a merge to be done.\n+\t\t// Step `insize' places along from p.\n+\t\t_Fwd_list_node* __q = __p;\n+\t\tunsigned long __psize = 0;\n+\t\tfor (unsigned long __i = 0; __i < __insize; ++__i)\n+\t\t  {\n+\t\t    ++__psize;\n+\t\t    __q = static_cast<_Fwd_list_node*>(__q->_M_next);\n+\t\t    if (!__q)\n+\t\t      break;\n+\t\t  }\n+\n+\t\t// If q hasn't fallen off end, we have two lists to merge.\n+\t\tunsigned long __qsize = __insize;\n+\n+\t\t// Now we have two lists; merge them.\n+\t\twhile (__psize > 0 || (__qsize > 0 && __q))\n+\t\t  {\n+\t\t    // Decide whether next node of merge comes from p or q.\n+\t\t    _Fwd_list_node<_Tp>* __e;\n+\t\t    if (__psize == 0)\n+\t\t      {\n+\t\t\t// p is empty; e must come from q.\n+\t\t\t__e = __q;\n+\t\t\t__q = static_cast<_Fwd_list_node*>(__q->_M_next);\n+\t\t\t--__qsize;\n+\t\t      }\n+\t\t    else if (__qsize == 0 || !__q)\n+\t\t      {\n+\t\t\t// q is empty; e must come from p.\n+\t\t\t__e = __p;\n+\t\t\t__p = static_cast<_Fwd_list_node*>(__p->_M_next);\n+\t\t\t--__psize;\n+\t\t      }\n+\t\t    else if (__comp(__p->_M_value, __q->_M_value))\n+\t\t      {\n+\t\t\t// First node of p is lower; e must come from p.\n+\t\t\t__e = __p;\n+\t\t\t__p = static_cast<_Fwd_list_node*>(__p->_M_next);\n+\t\t\t--__psize;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t// First node of q is lower; e must come from q.\n+\t\t\t__e = __q;\n+\t\t\t__q = static_cast<_Fwd_list_node*>(__q->_M_next);\n+\t\t\t--__qsize;\n+\t\t      }\n+\n+\t\t    // Add the next node to the merged list.\n+\t\t    if (__tail)\n+\t\t      __tail->_M_next = __e;\n+\t\t    else\n+\t\t      __list = __e;\n+\t\t    __tail = __e;\n+\t\t  }\n+\n+\t\t// Now p has stepped `insize' places along, and q has too.\n+\t\t__p = __q;\n+\t      }\n+\t    __tail->_M_next = 0;\n+\n+\t    // If we have done only one merge, we're finished.\n+\t    // Allow for nmerges == 0, the empty list case.\n+\t    if (__nmerges <= 1)\n+\t      {\n+\t\tthis->_M_next = __list;\n+\t\treturn;\n+\t      }\n+\n+\t    // Otherwise repeat, merging lists twice the size.\n+\t    __insize *= 2;\n+\t  }\n+      }\n+ \n+  template<typename _Tp, typename _Alloc>\n+    _Fwd_list_base<_Tp, _Alloc>::\n+    _Fwd_list_base(const _Fwd_list_base& __lst, const _Alloc& __a)\n+    : _M_impl(__a)\n+    {\n+      this->_M_impl._M_head._M_next = 0;\n+      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+      _Node* __curr = static_cast<_Node*>(__lst._M_impl._M_head._M_next);\n+      while (__curr)\n+\t{\n+\t  __to->_M_next = _M_create_node(__curr->_M_value);\n+\t  __to = __to->_M_next;\n+\t  __curr = static_cast<_Node*>(__curr->_M_next);\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    _Fwd_list_node_base*\n+    _Fwd_list_base<_Tp, _Alloc>::\n+    _M_erase_after(_Fwd_list_node_base* __pos)\n+    {\n+      _Node* __curr = static_cast<_Node*>(__pos->_M_next);\n+      if (__curr)\n+\t{\n+\t  _Fwd_list_node_base* __next = __curr->_M_next;\n+\t  __pos->_M_next = __next;\n+\t  _M_get_Node_allocator().destroy(__curr);\n+\t  _M_put_node(__curr);\n+\t}\n+      return __pos;\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    _Fwd_list_node_base*\n+    _Fwd_list_base<_Tp, _Alloc>::\n+    _M_erase_after(_Fwd_list_node_base* __pos, _Fwd_list_node_base* __last)\n+    {\n+      _Node* __curr = static_cast<_Node*>(__pos->_M_next);\n+      while (__curr)\n+\t{\n+\t  _Node* __temp = __curr;\n+\t  __curr = static_cast<_Node*>(__curr->_M_next);\n+\t  _M_get_Node_allocator().destroy(__temp);\n+\t  _M_put_node(__temp);\n+\t  __pos->_M_next = __curr;\n+\t  if (__temp == __last)\n+\t    break;\n+\t}\n+      return __pos;\n+    }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    forward_list<_Tp, _Alloc>::\n+    forward_list(size_type __n)\n+    : _Base()\n+    {\n+      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+      for (size_type __i = 0; __i < __n; ++__i)\n+\t{\n+\t  __to->_M_next = _M_create_node(_Tp());\n+\t  __to = __to->_M_next;\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    forward_list<_Tp, _Alloc>::\n+    forward_list(size_type __n, const _Tp& __value, const _Alloc& __al)\n+    : _Base(__al)\n+    {\n+      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+      for (size_type __i = 0; __i < __n; ++__i)\n+\t{\n+\t  __to->_M_next = _M_create_node(__value);\n+\t  __to = __to->_M_next;\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _InputIterator>\n+      forward_list<_Tp, _Alloc>::\n+      forward_list(_InputIterator __first, _InputIterator __last,\n+                   const _Alloc& __al)\n+      : _Base(__al)\n+      {\n+        _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+        _InputIterator __curr = __first;\n+        while (__curr != __last)\n+          {\n+            __to->_M_next = _M_create_node(*__curr);\n+            __to = __to->_M_next;\n+            ++__curr;\n+          }\n+      }\n+\n+  template<typename _Tp, typename _Alloc>\n+    forward_list<_Tp, _Alloc>::\n+    forward_list(const forward_list& __list)\n+    : _Base(__list._M_get_Node_allocator())\n+    {\n+      const _Fwd_list_node_base* __from = &__list._M_impl._M_head;\n+      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+      while (__from->_M_next != 0)\n+\t{\n+\t  const _Node* __temp = static_cast<_Node*>(__from->_M_next);\n+\t  __to->_M_next = _M_create_node(__temp->_M_value);\n+\t  __from = __from->_M_next;\n+\t  __to = __to->_M_next;\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    forward_list<_Tp, _Alloc>::\n+    forward_list(std::initializer_list<_Tp> __il, const _Alloc& __al)\n+    : _Base(__al)\n+    {\n+      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+      for (const _Tp* __item = __il.begin();\n+\t   __item != __il.end(); ++__item)\n+\t{\n+\t  __to->_M_next = _M_create_node(*__item);\n+\t  __to = __to->_M_next;\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    forward_list<_Tp, _Alloc>&\n+    forward_list<_Tp, _Alloc>::\n+    operator=(const forward_list& __list)\n+    {\n+      if (&__list != this)\n+\t{\n+\t  iterator __prev1 = before_begin();\n+\t  iterator __curr1 = begin();\n+\t  iterator __last1 = end();\n+\t  const_iterator __first2 = __list.cbegin();\n+\t  const_iterator __last2 = __list.cend();\n+\t  while (__curr1 != __last1 && __first2 != __last2)\n+\t    {\n+\t      *__curr1 = *__first2;\n+\t      ++__prev1;\n+\t      ++__curr1;\n+\t      ++__first2;\n+\t    }\n+\t  if (__first2 == __last2)\n+\t    erase_after(__prev1, __last1);\n+\t  else\n+\t    insert_after(__prev1, __first2, __last2);\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    forward_list<_Tp, _Alloc>::\n+    insert_after(const_iterator __pos,\n+\t\t size_type __n, const _Tp& __val)\n+    {\n+      _Fwd_list_node_base* __to\n+\t= const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+      _Fwd_list_node_base* __keep = __to->_M_next;\n+      for (size_type __i = 0; __i < __n; ++__i)\n+\t{\n+\t  __to->_M_next = _M_create_node(__val);\n+\t  __to = __to->_M_next;\n+\t}\n+      __to->_M_next = __keep;\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _InputIterator>\n+      void\n+      forward_list<_Tp, _Alloc>::\n+      insert_after(const_iterator __pos,\n+\t\t   _InputIterator __first, _InputIterator __last)\n+      {\n+\t_Fwd_list_node_base* __to\n+\t  = const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+\t_Fwd_list_node_base* __keep = __to->_M_next;\n+\t_InputIterator __curr = __first;\n+\twhile (__curr != __last)\n+\t  {\n+\t    __to->_M_next = _M_create_node(*__curr);\n+\t    __to = __to->_M_next;\n+\t    ++__curr;\n+\t  }\n+\t__to->_M_next = __keep;\n+      }\n+\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    forward_list<_Tp, _Alloc>::\n+    insert_after(const_iterator __pos, std::initializer_list<_Tp> __il)\n+    {\n+      _Fwd_list_node_base* __to\n+\t= const_cast<_Fwd_list_node_base* const>(__pos._M_node);\n+      _Fwd_list_node_base* __keep = __to->_M_next;\n+      const _Tp* __item = __il.begin();\n+      while (__item != __il.end())\n+\t{\n+\t  __to->_M_next = _M_create_node(*__item);\n+\t  __to = __to->_M_next;\n+\t  ++__item;\n+\t}\n+      __to->_M_next = __keep;\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    forward_list<_Tp, _Alloc>::\n+    resize(size_type __sz, value_type __val)\n+    {\n+      iterator __k = before_begin();\n+\n+      size_type __len = 0;\n+      while (__k._M_next() != end() && __len < __sz)\n+\t{\n+\t  ++__k;\n+\t  ++__len;\n+\t}\n+      if (__len == __sz)\n+\terase_after(__k, end());\n+      else\n+\tinsert_after(__k, __sz - __len, __val);\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    forward_list<_Tp, _Alloc>::\n+    remove(const _Tp& __val)\n+    {\n+      _Node* __curr = static_cast<_Node*>(&this->_M_impl._M_head);\n+      while (_Node* __temp = static_cast<_Node*>(__curr->_M_next))\n+\t{\n+\t  if (__temp->_M_value == __val)\n+\t    _M_erase_after(__curr);\n+\t  else\n+\t    __curr = static_cast<_Node*>(__curr->_M_next);\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _Pred>\n+      void\n+      forward_list<_Tp, _Alloc>::\n+      remove_if(_Pred __pred)\n+      {\n+\t_Node* __curr = static_cast<_Node*>(&this->_M_impl._M_head);\n+\twhile (_Node* __temp = static_cast<_Node*>(__curr->_M_next))\n+\t  {\n+\t    if (__pred(__temp->_M_value))\n+\t      _M_erase_after(__curr);\n+\t    else\n+\t      __curr = static_cast<_Node*>(__curr->_M_next);\n+\t  }\n+      }\n+\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    forward_list<_Tp, _Alloc>::\n+    unique()\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      if (__first == __last)\n+\treturn;\n+      iterator __next = __first;\n+      while (++__next != __last)\n+\t{\n+\t  if (*__first == *__next)\n+\t    erase_after(__first);\n+\t  else\n+\t    __first = __next;\n+\t  __next = __first;\n+\t}\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _BinPred>\n+      void\n+      forward_list<_Tp, _Alloc>::\n+      unique(_BinPred __binary_pred)\n+      {\n+        iterator __first = begin();\n+        iterator __last = end();\n+        if (__first == __last)\n+\treturn;\n+        iterator __next = __first;\n+        while (++__next != __last)\n+\t{\n+\t  if (__binary_pred(*__first, *__next))\n+              erase_after(__first);\n+\t  else\n+\t    __first = __next;\n+\t  __next = __first;\n+\t}\n+      }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template<typename _Comp>\n+      void\n+      forward_list<_Tp, _Alloc>::\n+      merge(forward_list&& __list, _Comp __comp)\n+      {\n+        _Fwd_list_node_base* __node = &this->_M_impl._M_head;\n+        while (__node->_M_next && __list._M_impl._M_head._M_next)\n+          {\n+            if (__comp(static_cast<_Node*>\n+\t\t       (__list._M_impl._M_head._M_next)->_M_value,\n+                       static_cast<_Node*>\n+\t\t       (__node->_M_next)->_M_value))\n+              __node->_M_transfer_after(&__list._M_impl._M_head,\n+                                        __list._M_impl._M_head._M_next);\n+            __node = __node->_M_next;\n+          }\n+        if (__list._M_impl._M_head._M_next)\n+          {\n+            __node->_M_next = __list._M_impl._M_head._M_next;\n+            __list._M_impl._M_head._M_next = 0;\n+          }\n+      }\n+\n+_GLIBCXX_END_NAMESPACE // namespace std\n+\n+#endif /* _FORWARD_LIST_TCC */\n+"}, {"sha": "33037300fd32f33a436e50b46c6c2d895b723158", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -1,6 +1,7 @@\n // C++ includes used for precompiling -*- C++ -*-\n \n-// Copyright (C) 2003, 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -99,6 +100,7 @@\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <array>\n #include <chrono>\n+#include <forward_list>\n #include <random>\n #include <ratio>\n #include <regex>"}, {"sha": "7905007d481102ecb3648489d078b1f8ca1fb347", "filename": "libstdc++-v3/include/std/forward_list", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,51 @@\n+// <forward_list> -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file forward_list\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_FORWARD_LIST\n+#define _GLIBCXX_FORWARD_LIST 1\n+\n+#pragma GCC system_header\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#else\n+\n+#include <bits/forward_list.h>\n+\n+#ifndef _GLIBCXX_EXPORT_TEMPLATE\n+# include <bits/forward_list.tcc>\n+#endif\n+\n+#endif // __GXX_EXPERIMENTAL_CXX0X__\n+\n+#endif // _GLIBCXX_FORWARD_LIST"}, {"sha": "1ad6d360f32334320603e2f250ed0cfb3800d185", "filename": "libstdc++-v3/testsuite/17_intro/headers/c++200x/all.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fall.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -100,6 +100,7 @@\n #include <condition_variable>\n #include <deque>\n #include <exception>\n+#include <forward_list>\n #include <fstream>\n #include <functional>\n #include <iomanip>"}, {"sha": "8008f8867bd9424be952eb90d102e0005d5dce2e", "filename": "libstdc++-v3/testsuite/17_intro/headers/c++200x/all_multiple_inclusion.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fall_multiple_inclusion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fall_multiple_inclusion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fheaders%2Fc%2B%2B200x%2Fall_multiple_inclusion.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -98,6 +98,7 @@\n #include <condition_variable>\n #include <deque>\n #include <exception>\n+#include <forward_list>\n #include <fstream>\n #include <functional>\n #include <iomanip>\n@@ -213,6 +214,7 @@\n #include <condition_variable>\n #include <deque>\n #include <exception>\n+#include <forward_list>\n #include <fstream>\n #include <functional>\n #include <iomanip>"}, {"sha": "1489f9b9da537faad3d85189b22fc0af39bd3944", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/capacity/1.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcapacity%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcapacity%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcapacity%2F1.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list capacity [lib.forward_list.capacity]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following.\n+//\n+void\n+test01()\n+{\n+  std::forward_list<double> fld;\n+  VERIFY(fld.empty() == true);\n+\n+  fld.push_front(1.0);\n+  VERIFY(fld.empty() == false);\n+\n+  fld.resize(0);\n+  VERIFY(fld.empty() == true);\n+\n+  VERIFY(fld.max_size() == fld.get_allocator().max_size());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3ccfa3570407e2417e68ccd898295e7873fed535", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcomparable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcomparable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcomparable.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on list (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+int main()\n+{\n+  std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  std::forward_list<double> b = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\n+\n+  VERIFY((a == b) == false);\n+  VERIFY((a <  b) == true);\n+  VERIFY((a != b) == true);\n+  VERIFY((a >  b) == false);\n+  VERIFY((a >= b) == false);\n+  VERIFY((a <= b) == true);\n+\n+  VERIFY((b == a) == false);\n+  VERIFY((b <  a) == false);\n+  VERIFY((b != a) == true);\n+  VERIFY((b >  a) == true);\n+  VERIFY((b >= a) == true);\n+  VERIFY((b <= a) == false);\n+\n+  return 0;\n+}"}, {"sha": "4bb5501055cd34f8beaf77ee74b8cfd437a66242", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/1.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F1.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Default construction\n+void\n+test01()\n+{\n+  std::forward_list<double> fld;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "44c1318462ced46cc3d49559a177bac005f54f15", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/2.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F2.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Construction from iterator range\n+//   Copy construction with allocator\n+void\n+test01()\n+{\n+  const int ni = 10;\n+  int i[ni] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  std::forward_list<int> flccin(i, i+ni);\n+  std::forward_list<int> flcc(flccin, std::allocator<int>());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f09c884e1d7fdfb9f4ca7bc0ec16bbebd1d693ce", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/3.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F3.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Move construction with allocator\n+void\n+test01()\n+{\n+  const int ni = 10;\n+  int i[ni] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  std::forward_list<int> flmc(std::forward_list<int>(i, i+ni), std::allocator<int>());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7cb33913442a69924e95f841950167355c312303", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/4.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F4.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Construction from given number of default item\n+void\n+test01()\n+{\n+  std::forward_list<double> flvd(10);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2a4540ce64f59fb0a48781b7b1b571c3000fbb80", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/5.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F5.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Construction from given number of given item\n+void\n+test01()\n+{\n+  std::forward_list<float> flv(10, 5.0F);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6210c0c8cdcd41d1724ec42590070062dd2862c6", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/6.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F6.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Construction from iterator range\n+void\n+test01()\n+{\n+  const int ni = 10;\n+  int i[ni] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  std::forward_list<int> fl(i, i+ni);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2338db28cdc979502ac14b846e753e2ddf310414", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/7.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F7.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Copy construction\n+void\n+test01()\n+{\n+  const int ni = 10;\n+  int i[ni] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  std::forward_list<int> fl(i, i+ni);\n+  std::forward_list<int> flc(fl);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "daac89dafcbe77199e8ce09d170e66344e8b4169", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/8.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F8.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   Move construction\n+void\n+test01()\n+{\n+  const int ni = 10;\n+  int i[ni] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  std::forward_list<int> fl(i, i+ni);\n+  std::forward_list<int> flm(std::move(fl));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1470d8117d170d4e0fa0733084f62b2544d4e837", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cons/9.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcons%2F9.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following.\n+//   Construction from initializer list\n+void\n+test01()\n+{\n+  std::forward_list<double> flil({1.0, 2.0, 3.0, 4.0, 5.0});\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3498c6efacd3e3048a6af08e2f401fd7caeeb369", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/modifiers/1.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F1.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+#include <array>\n+\n+bool test __attribute__((unused)) = true;\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, std::array<double, 3> & c)\n+  : type(t), coord(c) { }\n+  char getType() const { return type; }\n+private:\n+  char type;\n+  std::array<double, 3> coord;\n+};\n+\n+// This test verifies the following.\n+//   emplace_front\n+//   pop_front\n+//   emplace_after\n+void\n+test01()\n+{\n+  std::forward_list<PathPoint> path;\n+  std::array<double, 3> coord1 = { { 0.0, 1.0, 2.0 } };\n+  path.emplace_front('a', coord1);\n+\n+  std::forward_list<PathPoint>::const_iterator pos = path.cbegin();\n+\n+  std::array<double, 3> coord2 = { { 3.0, 4.0, 5.0 } };\n+  path.emplace_after(pos, 'b', coord2);\n+\n+  VERIFY(path.front().getType() == 'a');\n+\n+  path.pop_front();\n+\n+  VERIFY(path.front().getType() == 'b');\n+\n+  path.pop_front();\n+\n+  VERIFY(path.empty() == true);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9d79b22986b2c68d800b9bcdd65cd508ca043191", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/modifiers/2.cc", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F2.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,135 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+#include <string>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   insert_after single item\n+//   before_begin iterator\n+void\n+test01()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  fl.insert_after(fl.before_begin(), 42);\n+  VERIFY(fl.front() == 42);\n+}\n+\n+// This test verifies the following:\n+void\n+test02()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbegin();\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  // Note: Calling l.insert_after(pos, 5, 42); without the long five\n+  // gets resolved to the iterator range version and fails to compile!\n+  fl.insert_after(pos, 5L, 42);\n+  VERIFY(*pos == 1);\n+\n+  ++pos;\n+  VERIFY(*pos == 42);\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  VERIFY(*pos == 42);\n+}\n+\n+// This test verifies the following:\n+void\n+test03()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbegin();\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  int i[3] = {666, 777, 888};\n+  fl.insert_after(pos, i, i+3);\n+  VERIFY(*pos == 1);\n+\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  VERIFY(*pos == 888);\n+  ++pos;\n+  VERIFY(*pos == 2);\n+}\n+\n+// This test verifies the following:\n+void\n+test04()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbegin();\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  fl.insert_after(pos, {-1, -2, -3, -4, -5});\n+  VERIFY(*pos == 1);\n+\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  VERIFY(*pos == -3);\n+}\n+\n+// This test verifies the following:\n+void\n+test05()\n+{\n+  std::forward_list<std::string> fl({\"AAA\", \"BBB\", \"CCC\"});\n+\n+  std::forward_list<std::string>::const_iterator pos = fl.cbegin();\n+  ++pos;\n+  VERIFY(*pos == \"BBB\");\n+\n+  std::string x( \"XXX\" );\n+  fl.insert_after(pos, std::move(x));\n+  VERIFY(*pos == \"BBB\");\n+  ++pos;\n+  VERIFY(*pos == \"XXX\");\n+  ++pos;\n+  VERIFY(*pos == \"CCC\");\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "027dd18be97b7cd6659fdbaa30f0ffc14ba83d76", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/modifiers/3.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F3.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,83 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   cbegin\n+//   erase_after one iterator\n+//   pos is useable and points to current element\n+void\n+test01()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbegin();\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  std::forward_list<int>::iterator next = fl.erase_after(pos);\n+  VERIFY(*next == 1);\n+\n+  VERIFY(*pos == 1);\n+  ++pos;\n+  VERIFY(*pos == 3);\n+}\n+\n+// This test verifies the following:\n+//   cbegin\n+//   erase_after iterator range\n+//   pos is useable and points to current element\n+void\n+test02()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbegin();\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  std::forward_list<int>::iterator stop = fl.begin();\n+  ++stop;\n+  ++stop;\n+  ++stop;\n+  ++stop;\n+  VERIFY(*stop == 4);\n+\n+  std::forward_list<int>::iterator next = fl.erase_after(pos, stop);\n+  VERIFY(*next == 1);\n+\n+  VERIFY(*pos == 1);\n+  ++pos;\n+  VERIFY(*pos == 5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "9f9f8c65c8bc147672f7f6a8d1cc31740404c483", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/modifiers/4.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F4.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   swap\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1({0, 1, 2, 3, 4, 5});\n+  std::forward_list<int> fl2({666, 777, 888});\n+\n+  fl1.swap(fl2);\n+\n+  VERIFY(fl1.front() == 666);\n+  VERIFY(fl2.front() == 0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "17ad9297447fabb1f57a704fcf1ba4a524bb1024", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/modifiers/5.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmodifiers%2F5.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   clear\n+void\n+test01()\n+{\n+  std::forward_list<int> fl({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  VERIFY(fl.empty() == false);\n+\n+  fl.clear();\n+\n+  VERIFY(fl.empty() == true);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3ca95fdf0139883d88bf87741cfb1c3a507b1839", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/moveable.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fmoveable.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// NOTE: This makes use of the fact that we know how moveable\n+// is implemented on list (via swap). If the implementation changed\n+// this test may begin to fail.\n+\n+#include <forward_list>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+int main()\n+{\n+  std::forward_list<int> a, b;\n+  a.push_front(1);\n+\n+  b = std::move(a);\n+  VERIFY(b.empty() == false);\n+  VERIFY(*b.begin() == 1);\n+  VERIFY(a.empty() == true);\n+\n+  std::forward_list<int> c(std::move(b));\n+  VERIFY(c.empty() == false);\n+  (*c.begin() == 1 );\n+  VERIFY( b.empty() == true );\n+\n+  return 0;\n+}"}, {"sha": "71dc27cde95db93e9c64e545f1ff21722c5acb5f", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/1.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F1.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,107 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  std::forward_list<double>::const_iterator posa = a.cbefore_begin();\n+\n+  std::forward_list<double> x = {666.0, 777.0, 888.0};\n+\n+  a.splice_after(posa, x);\n+\n+  ++posa;\n+  VERIFY(*posa == 666.0);\n+\n+  VERIFY(x.empty() == true);\n+}\n+\n+// This test verifies the following:\n+//   \n+void\n+test02()\n+{\n+  std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  std::forward_list<double>::const_iterator posa = a.cbefore_begin();\n+  ++posa;\n+  VERIFY(*posa == 0.0);\n+\n+  std::forward_list<double> y = {10.0, 11.0, 12.0, 13.0, 14.0, 15.0};\n+  std::forward_list<double>::const_iterator befy = y.cbefore_begin();\n+  ++befy;\n+  VERIFY(*befy == 10.0);\n+  std::forward_list<double>::const_iterator endy = befy;\n+  ++endy;\n+  ++endy;\n+  ++endy;\n+  ++endy;\n+  VERIFY(*endy == 14.0);\n+\n+  a.splice_after(posa, y, befy, endy);\n+  VERIFY(*posa == 0.0);\n+\n+  VERIFY(*befy == 10.0);\n+  ++befy;\n+  VERIFY(*befy == 15.0);\n+}\n+\n+// This test verifies the following:\n+//   \n+void\n+test03()\n+{\n+  std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  std::forward_list<double>::const_iterator posa = a.cbefore_begin();\n+  ++posa;\n+  ++posa;\n+  VERIFY(*posa == 1.0);\n+\n+  std::forward_list<double> z = {42.0, 43.0, 44.0};\n+  std::forward_list<double>::const_iterator posz = z.begin();\n+  VERIFY(*posz == 42.0);\n+\n+  a.splice_after(posa, z, posz);\n+  VERIFY(*posa == 1.0);\n+  ++posa;\n+  VERIFY(*posa == 43.0);\n+\n+  VERIFY(*posz == 42.0);\n+  ++posz;\n+  VERIFY(*posz == 44.0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "bbd51af1202437fb60841af0c4d2bbb45cd806e6", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/2.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F2.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   remove\n+void\n+test01()\n+{\n+  std::forward_list<int> fl ={0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  fl.remove(7);\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbefore_begin();\n+  for (std::size_t i = 0; i < 7; ++i)\n+    ++pos;\n+  VERIFY(*pos == 6);\n+\n+  ++pos;\n+  VERIFY(*pos == 8);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c5bbb8a0ca174a46ad1472534bc7e9dd0fe4e651", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/3.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F3.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+#include <algorithm>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   remove_if\n+void\n+test01()\n+{\n+  std::forward_list<int> fl ={0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  fl.remove_if(std::bind2nd(std::less<int>(),5));\n+\n+  std::forward_list<int>::const_iterator pos = fl.cbegin();\n+  VERIFY(*pos == 5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "35e5bf8e21d7113635d8dbb80a4a064daeadd892", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/4.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F4.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,78 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   unique\n+void\n+test01()\n+{\n+  std::forward_list<int> fl = {99, 5, 99, 6, -5, 666, 777, 888,\n+                               42, 42, 42, 42, 42, 7, 0, 0, 0, 9, 9, 9};\n+\n+  fl.unique();\n+\n+  std::forward_list<int> fl2 = {99, 5, 99, 6, -5, 666, 777, 888, 42, 7, 0, 9};\n+  VERIFY(fl == fl2);\n+}\n+\n+//  Test comparison predicate.\n+template<typename Num>\n+  class Mod\n+  {\n+  public:\n+    Mod(const Num & mod)\n+      {\n+        m = mod;\n+      }\n+    bool operator()(const Num i, const Num j)\n+      {\n+        return i%m == j%m;\n+      }\n+  private:\n+    Num m;\n+  };\n+\n+// This test verifies the following:\n+//   unique with predicate\n+void\n+test02()\n+{\n+  std::forward_list<int> fl = {99, 5, 99, 6, -5, 666, 777, 888, 42, 7, 0, 9};\n+\n+  fl.unique(Mod<int>(111));\n+\n+  std::forward_list<int> fl2 = {99, 5, 99, 6, -5, 666, 42, 7, 0, 9};\n+  VERIFY(fl == fl2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "a75b91d9cc87529253a05040e89f7c6d21bdefce", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/5.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F5.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  std::forward_list<double> b = {1.0, 2.0, 3.0, 4.0, 4.0, 5.0};\n+\n+  a.merge(b);\n+\n+  std::forward_list<double> r = {0.0, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0,\n+                                 4.0, 4.0, 4.0, 5.0};\n+\n+  VERIFY(a == r);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "dc6268bb329f05b69d8261435a00901b1293468c", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/6.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F6.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,84 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+//  Comparison functor.\n+template<typename Num>\n+  class Comp\n+  {\n+  public:\n+    Comp(const Num & num)\n+      {\n+        n = num;\n+      }\n+    bool operator()(const Num i, const Num j)\n+      {\n+        return (n * i) < (n * j);\n+      }\n+  private:\n+    Num n;\n+  };\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  const unsigned int n = 13;\n+  int order[][n] = {\n+    { 0,1,2,3,4,5,6,7,8,9,10,11,12 },\n+    { 6,2,8,4,11,1,12,7,3,9,5,0,10 },\n+    { 12,11,10,9,8,7,6,5,4,3,2,1,0 },\n+  };\n+  std::forward_list<int> sorted(order[0], order[0] + n);\n+\n+  for (unsigned int i = 0; i < sizeof(order)/sizeof(*order); ++i)\n+    {\n+      std::forward_list<int> head(order[i], order[i] + n);\n+\n+      head.sort();\n+\n+      VERIFY(head == sorted);\n+    }\n+\n+  std::forward_list<int> reversed(order[2], order[2] + n);\n+  for (unsigned int i = 0; i < sizeof(order)/sizeof(*order); ++i)\n+    {\n+      std::forward_list<int> head(order[i], order[i] + n);\n+\n+      Comp<int> comp(-1);\n+      head.sort( comp );\n+\n+      VERIFY(head == reversed);\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a51ce77eab5ee2c83506554d5fb0e120f54a0ba9", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/operations/7.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Foperations%2F7.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,55 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+#include <algorithm>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  const unsigned int n = 13;\n+  int order[n] = {0,1,2,3,4,5,6,7,8,9,10,11,12};\n+\n+  std::forward_list<int> fl(order, order + n);\n+\n+  std::forward_list<int> fl2;\n+  for (std::size_t i = 0; i < n; ++i)\n+    fl2.push_front(order[i]);\n+\n+  fl.reverse();\n+\n+  VERIFY(std::lexicographical_compare(fl.begin(), fl.end(),\n+                                      fl2.begin(), fl2.end()) == false);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "40f8ad1d39f6aebd2f31a97573925cf149a5eeb1", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/requirements/1.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Frequirements%2F1.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,70 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// A nontrivial type.\n+template<typename T>\n+  struct A { };\n+\n+// Another nontrivial type\n+struct B { };\n+\n+// A nontrivial type convertible from an int\n+struct C\n+{\n+  C(int i) : i_(i) { }\n+  bool operator==(const C& rhs) { return i_ == rhs.i_; }\n+  int i_;\n+};\n+\n+// This test verifies the following.\n+//\n+void\n+test01()\n+{\n+  std::forward_list< A<B> > lst;\n+  VERIFY(lst.begin() == lst.end());\n+  VERIFY(std::distance(lst.begin(), lst.end()) == 0);\n+\n+  // check type definitions -- will fail compile if missing\n+  typedef std::forward_list< A<B> >::reference              reference;\n+  typedef std::forward_list< A<B> >::const_reference        const_reference;\n+  typedef std::forward_list< A<B> >::iterator               iterator;\n+  typedef std::forward_list< A<B> >::const_iterator         const_iterator;\n+  typedef std::forward_list< A<B> >::size_type              size_type;\n+  typedef std::forward_list< A<B> >::difference_type        difference_type;\n+  typedef std::forward_list< A<B> >::value_type             value_type;\n+  typedef std::forward_list< A<B> >::allocator_type         allocator_type;\n+  typedef std::forward_list< A<B> >::pointer                pointer;\n+  typedef std::forward_list< A<B> >::const_pointer          const_pointer;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "339982cf155983d3ec8cbdae89c8532f99439ecd", "filename": "libstdc++-v3/testsuite/23_containers/headers/forward_list/synopsis.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fheaders%2Fforward_list%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fheaders%2Fforward_list%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fheaders%2Fforward_list%2Fsynopsis.cc?ref=3a63c9cdfce73e8184b36a3b3a1a5001cb49ffe6", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <forward_list>\n+\n+namespace std {\n+  template <class T, class Allocator> class forward_list;\n+\n+  template <class T, class Allocator>\n+  bool operator==(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>&);\n+\n+  template <class T, class Allocator>\n+  bool operator< (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>&);\n+\n+  template <class T, class Allocator>\n+    bool operator!=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>&);\n+\n+  template <class T, class Allocator>\n+    bool operator> (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>&);\n+\n+  template <class T, class Allocator>\n+    bool operator>=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>&);\n+\n+  template <class T, class Allocator>\n+    bool operator<=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>&);\n+\n+  template <class T, class Allocator>\n+    void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y);\n+\n+  template <class T, class Allocator>\n+    void swap(forward_list<T,Allocator>&& x, forward_list<T,Allocator>& y);\n+\n+  template <class T, class Allocator>\n+    void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>&& y);\n+}"}]}