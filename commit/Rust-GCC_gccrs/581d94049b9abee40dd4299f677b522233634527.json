{"sha": "581d94049b9abee40dd4299f677b522233634527", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxZDk0MDQ5YjlhYmVlNDBkZDQyOTlmNjc3YjUyMjIzMzYzNDUyNw==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-11-10T01:14:48Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-11-10T01:14:48Z"}, "message": "pa.h (STARTING_FRAME_OFFSET): Change offset for TARGET_64BIT to 16.\n\n\t* pa.h (STARTING_FRAME_OFFSET): Change offset for TARGET_64BIT to 16.\n\t* config.gcc (hppa*64*-*-linux*): Shorten lines in tm_file define.\n\t(hppa*64*-*-hpux11*): Likewise.  Use elfos.h with gas.\n\t* pa.c (output_millicode_call): Use symbol difference rather than\n\t$PIC_pcrel$0 when using HP assembler.\n\t* pa64-hpux.h (TARGET_GAS): Define to 1 or 0 depending on whether or\n\tnot elfos.h (i.e., gas) is being used.\n\t(ASM_FILE_START, STRING_ASM_OP, TEXT_SECTION_ASM_OP,\n\tDATA_SECTION_ASM_OP, BSS_SECTION_ASM_OP, ASM_OUTPUT_ALIGNED_COMMON,\n\tASM_OUTPUT_ALIGNED_LOCAL, GLOBAL_ASM_OP, ASM_DECLARE_FUNCTION_NAME,\n\tASM_OUTPUT_EXTERNAL, ASM_OUTPUT_EXTERNAL_LIBCALL,\n\tASM_OUTPUT_INTERNAL_LABEL, ASM_GENERATE_INTERNAL_LABEL): Define when\n\tusing elfos.h.\n\t(TARGET_ASM_GLOBALIZE_LABEL): Undefine when using elfos.h.\n\t(DWARF2_ASM_LINE_DEBUG_INFO): Delete.\n\t(ASM_FILE_START): Add standard .SPACE and .SUBSPA defines when not\n\tusing elfos.h.\n\t(TEXT_SECTION_ASM_OP, READONLY_DATA_SECTION_ASM_OP, DATA_SECTION_ASM_OP,\n\tBSS_SECTION_ASM_OP): New HP style defines when not using elfos.h.\n\t(TARGET_ASM_NAMED_SECTION, MAKE_DECL_ONE_ONLY, ASM_WEAKEN_LABEL):\n\tDon't define when not using elfos.h.\n\t(ASM_DECLARE_RESULT): Don't define.\n\t* doc/install.texi (hppa*-hp-hpux*): Remove statement that HP assembler\n\tdoesn't work on hppa64-hp-hpux11.\n\t(hppa*-hp-hpux11): Update.\n\nFrom-SVN: r58967", "tree": {"sha": "731f82cc4922f49ff87766098efe98a476530fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/731f82cc4922f49ff87766098efe98a476530fc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/581d94049b9abee40dd4299f677b522233634527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581d94049b9abee40dd4299f677b522233634527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581d94049b9abee40dd4299f677b522233634527", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581d94049b9abee40dd4299f677b522233634527/comments", "author": null, "committer": null, "parents": [{"sha": "f7aa343f421a90fa4b83885ee526fe1626604def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7aa343f421a90fa4b83885ee526fe1626604def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7aa343f421a90fa4b83885ee526fe1626604def"}], "stats": {"total": 315, "additions": 236, "deletions": 79}, "files": [{"sha": "e07c1c0c67aa48009bea49864f7bcc27be3f2fe7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d94049b9abee40dd4299f677b522233634527/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d94049b9abee40dd4299f677b522233634527/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=581d94049b9abee40dd4299f677b522233634527", "patch": "@@ -1,3 +1,32 @@\n+2002-11-09  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* pa.h (STARTING_FRAME_OFFSET): Change offset for TARGET_64BIT to 16.\n+\n+\t* config.gcc (hppa*64*-*-linux*): Shorten lines in tm_file define.\n+\t(hppa*64*-*-hpux11*): Likewise.  Use elfos.h with gas.\n+\t* pa.c (output_millicode_call): Use symbol difference rather than\n+\t$PIC_pcrel$0 when using HP assembler.\n+\t* pa64-hpux.h (TARGET_GAS): Define to 1 or 0 depending on whether or\n+\tnot elfos.h (i.e., gas) is being used.\n+\t(ASM_FILE_START, STRING_ASM_OP, TEXT_SECTION_ASM_OP,\n+\tDATA_SECTION_ASM_OP, BSS_SECTION_ASM_OP, ASM_OUTPUT_ALIGNED_COMMON,\n+\tASM_OUTPUT_ALIGNED_LOCAL, GLOBAL_ASM_OP, ASM_DECLARE_FUNCTION_NAME,\n+\tASM_OUTPUT_EXTERNAL, ASM_OUTPUT_EXTERNAL_LIBCALL,\n+\tASM_OUTPUT_INTERNAL_LABEL, ASM_GENERATE_INTERNAL_LABEL): Define when\n+\tusing elfos.h.\n+\t(TARGET_ASM_GLOBALIZE_LABEL): Undefine when using elfos.h.\n+\t(DWARF2_ASM_LINE_DEBUG_INFO): Delete.\n+\t(ASM_FILE_START): Add standard .SPACE and .SUBSPA defines when not\n+\tusing elfos.h.\n+\t(TEXT_SECTION_ASM_OP, READONLY_DATA_SECTION_ASM_OP, DATA_SECTION_ASM_OP,\n+\tBSS_SECTION_ASM_OP): New HP style defines when not using elfos.h.\n+\t(TARGET_ASM_NAMED_SECTION, MAKE_DECL_ONE_ONLY, ASM_WEAKEN_LABEL):\n+\tDon't define when not using elfos.h.\n+\t(ASM_DECLARE_RESULT): Don't define.\n+\t* doc/install.texi (hppa*-hp-hpux*): Remove statement that HP assembler\n+\tdoesn't work on hppa64-hp-hpux11.\n+\t(hppa*-hp-hpux11): Update.\n+\n 2002-11-09  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config/mips/netbsd.h (SUBTARGET_ASM_SPEC): Don't pass -KPIC"}, {"sha": "27bff5229efd36d872a3c15efc1cf83ed3892319", "filename": "gcc/config.gcc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=581d94049b9abee40dd4299f677b522233634527", "patch": "@@ -733,8 +733,8 @@ h8300-*-*)\n \t;;\n hppa*64*-*-linux* | parisc*64*-*-linux*)\n \ttarget_cpu_default=\"(MASK_PA_11 | MASK_PA_20)\"\n-\ttm_file=\"pa/pa64-start.h ${tm_file} dbxelf.h elfos.h svr4.h linux.h pa/pa-linux.h \\\n-\t\t pa/pa64-regs.h pa/pa-64.h pa/pa64-linux.h\"\n+\ttm_file=\"pa/pa64-start.h ${tm_file} dbxelf.h elfos.h svr4.h linux.h \\\n+\t\t pa/pa-linux.h pa/pa64-regs.h pa/pa-64.h pa/pa64-linux.h\"\n \ttmake_file=pa/t-linux64\n \tgas=yes gnu_ld=yes\n \t;;\n@@ -867,7 +867,16 @@ hppa1.0-*-hpux10*)\n \t;;\n hppa*64*-*-hpux11*)\n \txm_defines=POSIX\n-\ttm_file=\"pa/pa64-start.h ${tm_file} pa/pa64-regs.h pa/long_double.h pa/elf.h pa/pa-hpux.h pa/pa-hpux11.h pa/pa-64.h pa/pa64-hpux.h\"\n+\tif test x$gas = xyes\n+\tthen\n+\t\ttm_file=\"pa/pa64-start.h ${tm_file} dbxelf.h elfos.h  \\\n+\t\t\t pa/pa64-regs.h pa/long_double.h pa/pa-hpux.h \\\n+\t\t\t pa/pa-hpux11.h pa/pa-64.h pa/pa64-hpux.h\"\n+\telse\n+\t\ttm_file=\"pa/pa64-start.h ${tm_file} dbxelf.h pa/elf.h \\\n+\t\t\t pa/pa64-regs.h pa/long_double.h pa/pa-hpux.h \\\n+\t\t\t pa/pa-hpux11.h pa/pa-64.h pa/pa64-hpux.h\"\n+\tfi\n \ttmake_file=\"pa/t-pa64 pa/t-pa-hpux\"\n \txmake_file=\"pa/x-ada\"\n \ttarget_cpu_default=\"(MASK_PA_11|MASK_PA_20|MASK_GAS)\""}, {"sha": "034a647e9bac03de3a7526908ba25c1e1d05ed65", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=581d94049b9abee40dd4299f677b522233634527", "patch": "@@ -6238,8 +6238,21 @@ output_millicode_call (insn, call_dest)\n \t     loaded objects.  Using a pc-relative sequence also avoids\n \t     problems related to the implicit use of the gp register.  */\n \t  output_asm_insn (\"b,l .+8,%%r1\", xoperands);\n-\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n+\n+\t  if (TARGET_GAS)\n+\t    {\n+\t      output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      xoperands[1] = gen_label_rtx ();\n+\t      output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+\t      output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n+\t    }\n+\n \t  output_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n \t}\n       else if (TARGET_PORTABLE_RUNTIME)\n@@ -6269,24 +6282,23 @@ output_millicode_call (insn, call_dest)\n \t}\n       else\n \t{\n+\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t  output_asm_insn (\"addi 16,%%r1,%%r31\", xoperands);\n+\n \t  if (TARGET_SOM || !TARGET_GAS)\n \t    {\n \t      /* The HP assembler can generate relocations for the\n \t\t difference of two symbols.  GAS can do this for a\n \t\t millicode symbol but not an arbitrary external\n \t\t symbol when generating SOM output.  */\n \t      xoperands[1] = gen_label_rtx ();\n-\t      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t      output_asm_insn (\"addi 16,%%r1,%%r31\", xoperands);\n \t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n \t      output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n \t      output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n \t    }\n \t  else\n \t    {\n-\t      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t      output_asm_insn (\"addi 16,%%r1,%%r31\", xoperands);\n \t      output_asm_insn (\"addil L'%0-$PIC_pcrel$0+8,%%r1\", xoperands);\n \t      output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+12(%%r1),%%r1\",\n \t\t\t       xoperands);"}, {"sha": "d01aedf0bff0803b731cb3761039537f9314f92c", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=581d94049b9abee40dd4299f677b522233634527", "patch": "@@ -672,8 +672,10 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 8\n+   of the first local allocated.  The start of the locals must lie on\n+   a STACK_BOUNDARY or else the frame size of leaf functions will not\n+   be zero.  */\n+#define STARTING_FRAME_OFFSET (TARGET_64BIT ? 16 : 8)\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by."}, {"sha": "1966a40420fccdb520567454ac0a96b2c7f6c8c6", "filename": "gcc/config/pa/pa64-hpux.h", "status": "modified", "additions": 151, "deletions": 56, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d94049b9abee40dd4299f677b522233634527/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=581d94049b9abee40dd4299f677b522233634527", "patch": "@@ -72,50 +72,165 @@ Boston, MA 02111-1307, USA.  */\n #define MD_STARTFILE_PREFIX_1 \"/opt/langtools/lib/pa20_64/\"\n #endif\n \n-/* hpux11 has the new HP assembler.  It's still lousy, but it's a whole lot\n-   better than the assembler shipped with older versions of hpux.  */\n-#undef NEW_HP_ASSEMBLER\n-#define NEW_HP_ASSEMBLER 1\n+/* Due to limitations in the target structure, it isn't currently possible\n+   to dynamically switch between the GNU and HP assemblers.  */\n+#undef TARGET_GAS\n+\n+/* Configure selects the standard ELFOS defines for use with GAS.  */\n+#ifdef USING_ELFOS_H\n+\n+/* We are using GAS.  */\n+#define TARGET_GAS 1\n \n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE) \\\n-do {  \\\n-     if (TARGET_64BIT) \\\n-       fputs(\"\\t.LEVEL 2.0w\\n\", FILE); \\\n-     else if (TARGET_PA_20) \\\n-       fputs(\"\\t.LEVEL 2.0\\n\", FILE); \\\n-     else if (TARGET_PA_11) \\\n-       fputs(\"\\t.LEVEL 1.1\\n\", FILE); \\\n-     else \\\n-       fputs(\"\\t.LEVEL 1.0\\n\", FILE); \\\n-     if (profile_flag)\\\n-       fprintf (FILE, \"\\t.IMPORT _mcount, CODE\\n\");\\\n-     if (write_symbols != NO_DEBUG) \\\n-       output_file_directive ((FILE), main_input_filename); \\\n-   } while (0)\n+do {\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 2.0w\\n\", FILE);\t\t\t\t\\\n+  else if (TARGET_PA_20)\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 2.0\\n\", FILE);\t\t\t\t\\\n+  else if (TARGET_PA_11)\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 1.1\\n\", FILE);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 1.0\\n\", FILE);\t\t\t\t\\\n+  if (profile_flag)\t\t\t\t\t\t\\\n+    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, \"_mcount\", \"function\");\t\\\n+  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      output_file_directive ((FILE), main_input_filename);\t\\\n+      fputs (\"\\t.version\\t\\\"01.01\\\"\\n\", FILE);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how we output a null terminated string.  */\n+#undef STRING_ASM_OP\n+#define STRING_ASM_OP\t\"\\t.stringz\\t\"\n+\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\"\n+#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss\"\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  bss_section ();\t\t\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fputs (\"\\t.comm \", (FILE));\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"%d\\n\", MAX ((SIZE), ((ALIGN) / BITS_PER_UNIT)));\t\\\n+} while (0)\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  bss_section ();\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.align %d\\n\", ((ALIGN) / BITS_PER_UNIT));\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\n\\t.block %d\\n\", (SIZE));\t\t\t\t\\\n+} while (0)\n+\n+/* The define in pa.h doesn't work with the alias attribute.  The\n+   default is ok with the following define for GLOBAL_ASM_OP.  */\n+#undef TARGET_ASM_GLOBALIZE_LABEL\n+\n+/* This is how we globalize a label.  */\n+#define GLOBAL_ASM_OP\t\"\\t.globl\\t\"\n+\n+/* Hacked version from elfos.h that doesn't output a label.  */\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\t\\\n+  ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\\\n+} while (0)\n+\n+/* The type of external references must be set correctly for the\n+   dynamic loader to work correctly.  This is equivalent to the\n+   HP assembler's .IMPORT directive but relates more directly to\n+   ELF object file types.  */\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  int save_referenced;\t\t\t\t\t\t\t\\\n+  save_referenced = TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL));\\\n+  if (FUNCTION_NAME_P (NAME))\t\t\t\t\t\t\\\n+    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\t\\\n+  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)) = save_referenced;\\\n+} while (0)\n+\n+/* We need set the type for external libcalls.  Also note that not all\n+   libcall names are passed to targetm.encode_section_info (e.g., __main).\n+   Thus, we also have to do the section encoding if it hasn't been done\n+   already.  */\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (!FUNCTION_NAME_P (XSTR (FUN, 0)))\t\t\t\t\\\n+    hppa_encode_label (FUN);\t\t\t\t\t\\\n+  ASM_OUTPUT_TYPE_DIRECTIVE (FILE, XSTR (FUN, 0), \"function\");\t\\\n+} while (0)\n+\n+/* We need to use the HP style for internal labels.  */\n+#undef  ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\\\n+  fprintf (FILE, \"%c$%s%04d\\n\", (PREFIX)[0], (PREFIX) + 1, NUM)\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf (LABEL, \"*%c$%s%04ld\", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))\n+\n+#else /* USING_ELFOS_H */\n+\n+/* We are not using GAS.  */\n+#define TARGET_GAS 0\n+\n+/* HPUX 11 has the \"new\" HP assembler.  It's still lousy, but it's a whole\n+   lot better than the assembler shipped with older versions of hpux.\n+   However, it doesn't support weak symbols and is a bad fit with ELF.  */\n+#undef NEW_HP_ASSEMBLER\n+#define NEW_HP_ASSEMBLER 1\n \n /* It looks like DWARF2 will be the easiest debug format to handle on this\n    platform.  */\n-#define OBJECT_FORMAT_ELF\n #define DWARF2_DEBUGGING_INFO 1\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-/* This isn't quite ready yet.  I'm seeing it mess up some line\n-   tables.  For example, we're getting lines starting/ending at\n-   impossible addresses.  */\n-#define DWARF2_ASM_LINE_DEBUG_INFO 1\n \n+/* This target uses the ELF object file format.  */\n+#define OBJECT_FORMAT_ELF\n \n-/* The rest of this file is copied from the generic svr4.h.  One day we\n-   would like to simply include svr4.h instead of copying all these\n-   definitions.  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 2.0w\\n\", FILE);\t\t\t\t\\\n+  else if (TARGET_PA_20)\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 2.0\\n\", FILE);\t\t\t\t\\\n+  else if (TARGET_PA_11)\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 1.1\\n\", FILE);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    fputs(\"\\t.LEVEL 1.0\\n\", FILE);\t\t\t\t\\\n+  fputs(\"\\t.SPACE $PRIVATE$,SORT=16\\n\\\n+\\t.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31\\n\\\n+\\t.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82\\n\\\n+\\t.SPACE $TEXT$,SORT=8\\n\\\n+\\t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\\n\\\n+\\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\\n\", FILE);\t\\\n+  if (profile_flag)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.IMPORT _mcount, CODE\\n\");\t\t\\\n+  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n+    output_file_directive ((FILE), main_input_filename);\t\\\n+} while (0)\n \n-#define READONLY_DATA_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP \"\\t.SUBSPA $CODE$\\n\"\n+#undef READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP \"\\t.SUBSPA $LIT$\\n\"\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP \"\\t.SUBSPA $DATA$\\n\"\n+#undef BSS_SECTION_ASM_OP\n+#define BSS_SECTION_ASM_OP \"\\t.SUBSPA $BSS$\\n\"\n \n-/* On svr4, we *do* have support for the .init and .fini sections, and we\n-   can put stuff in there to be executed before and after `main'.  We let\n-   crtstuff.c and other files know this by defining the following symbols.\n-   The definitions say how to change sections to the .init and .fini\n-   sections.  This is the same for all known svr4 assemblers.  */\n+#endif /* USING_ELFOS_H */\n \n /* For the time being, we aren't using init sections.  `P' relocations\n    are currently used for function references.  However, P relocations are\n@@ -124,10 +239,9 @@ do {  \\\n    weak symbols in crtbegin.o (e.g., __register_frame_info).  Possibly\n    Q relocations might avoid this problem but the GNU assembler doesn't\n    support them.  */\n-#if 0\n-#define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n-#define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini\"\n-#else\n+#undef INIT_SECTION_ASM_OP\n+#undef FINI_SECTION_ASM_OP\n+\n #define EH_FRAME_IN_DATA_SECTION 1\n \n #undef ENDFILE_SPEC\n@@ -144,32 +258,13 @@ do {  \\\n    of running ldd, but unfortunately the options are different for\n    the two linkers.  */\n #define LDD_SUFFIX \"/usr/ccs/bin/ldd\"\n+\n /* Skip to first '>' then advance to '/' at the beginning of the filename.  */\n #define PARSE_LDD_OUTPUT(PTR)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   while (*PTR != '>') PTR++;\t\t\t\t\t\\\n   while (*PTR != '/') PTR++;\t\t\t\t\t\\\n } while (0)\n-#endif\n-\n-/* Switch into a generic section.  */\n-#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n-\n-#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-\n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n-       fputc ('\\n', FILE); } while (0)\n-\n-/* Write the extra assembler code needed to declare a function's result.\n-   Most svr4 assemblers don't require any special declaration of the\n-   result value, but there are exceptions.  */\n-\n-#ifndef ASM_DECLARE_RESULT\n-#define ASM_DECLARE_RESULT(FILE, RESULT)\n-#endif\n \n /* If using HP ld do not call pxdb.  Use size as a program that does nothing\n    and returns 0.  /bin/true cannot be used because it is a script without"}, {"sha": "b0828e8e8e60be2ff00c9f2371ed3c1acbb10c86", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d94049b9abee40dd4299f677b522233634527/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d94049b9abee40dd4299f677b522233634527/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=581d94049b9abee40dd4299f677b522233634527", "patch": "@@ -2059,8 +2059,7 @@ longer a multiple of 2 bytes.\n \n We @emph{highly} recommend using gas/binutils 2.8 or newer on all hppa\n platforms; you may encounter a variety of problems when using the HP\n-assembler.  The HP assembler does not work with the @samp{hppa64-hp-hpux11*}\n-port.\n+assembler.\n \n Specifically, @option{-g} does not work on HP-UX (since that system\n uses a peculiar debugging format which GCC does not know about), unless you\n@@ -2162,16 +2161,27 @@ compile GCC 3.0 and up.  Refer to @uref{binaries.html,,binaries} for\n information about obtaining precompiled GCC binaries for HP-UX.\n \n GNU binutils 2.13 or later is recommended with the 64-bit port.\n-The HP assembler is not supported.  It is @emph{highly} recommended\n-that the GNU linker be used as well.  Either binutils must be built\n-prior to gcc, or a binary distribution of gcc or binutils must be\n-obtained for the initial builds.  When starting with a HP compiler,\n-it is preferable to use the ANSI compiler as the bundled compiler\n-only supports traditional C.  Bootstrapping with the bundled compiler\n-is tested infrequently and problems often arise because of the subtle\n-differences in semantics between traditional and ISO C.  There also\n-have been problems reported with various binary distributions.  This\n-port still is undergoing significant development.\n+The HP assembler has many limitations and is not recommended.  For\n+example, it does not support weak symbols or alias definitions.\n+As a result, explicit template instantiations are required when\n+using C++.  Either the HP or GNU linker can be used but it may be\n+necessary to use the GNU linker when dwarf2 exception support is\n+implemented.\n+\n+There are several possible approaches to building the distribution.\n+Binutils can be built first using the HP tools.  Then, the GCC\n+distribution can be built.  The second approach is to build GCC\n+first using the HP tools, then build binutils, then rebuild GCC.\n+There have been problems with various binary distributions, so\n+it is best not to start from a binary distribution.\n+\n+When starting with a HP compiler, it is preferable to use the ANSI\n+compiler as the bundled compiler only supports traditional C.\n+Bootstrapping with the bundled compiler is tested infrequently and\n+problems often arise because of the subtle differences in semantics\n+between traditional and ISO C.\n+\n+This port still is undergoing significant development.\n \n @html\n <hr />"}]}