{"sha": "a0b8b1b736253f14044ba9d87cb435426915a90b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBiOGIxYjczNjI1M2YxNDA0NGJhOWQ4N2NiNDM1NDI2OTE1YTkwYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-02-27T10:41:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-02-27T10:41:10Z"}, "message": "ada-tree.h (TYPE_PACKED_ARRAY_TYPE_P): Add checking.\n\n\t* gcc-interface/ada-tree.h (TYPE_PACKED_ARRAY_TYPE_P): Add checking.\n\t(TYPE_BY_REFERENCE_P): New flag.\n\t(TYPE_IS_BY_REFERENCE_P): New macro.\n\t(TYPE_DUMMY_P): Add checking and remove VOID_TYPE.\n\t(TYPE_IS_DUMMY_P): Adjust for above change.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use TYPE_BY_REFERENCE_P\n\tand TYPE_IS_BY_REFERENCE_P instead of TREE_ADDRESSABLE.\n\t(gnat_to_gnu_param): Likewise.\n\t(maybe_pad_type): Likewise.\n\t(make_type_from_size): Use TYPE_IS_PACKED_ARRAY_TYPE_P.\n\t* gcc-interface/misc.c (must_pass_by_ref): Use TYPE_IS_BY_REFERENCE_P\n\tinstead of TREE_ADDRESSABLE.\n\t* gcc-interface/trans.c (finalize_nrv): Likewise.\n\t(call_to_gnu): Likewise.  Do not create a temporary for return values\n\twith by-reference type here.\n\t(gnat_to_gnu): Test TYPE_IS_DUMMY_P instead of TYPE_DUMMY_P.\n\t(gnat_gimplify_expr) <ADDR_EXPR>: Don't do anything for non-constant\n\tCONSTRUCTORs and calls.\n\t* gcc-interface/utils.c (make_dummy_type): Get the equivalent type of\n\tthe underlying type and use it throughout.  Use TYPE_IS_BY_REFERENCE_P\n\tinstead of TREE_ADDRESSABLE.\n\t* gcc-interface/utils2.c (build_cond_expr): Deal with by-reference\n\ttypes explicitly.\n\nFrom-SVN: r184594", "tree": {"sha": "bf702654748c8ce1cea4e17b381a5fe5c9856517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf702654748c8ce1cea4e17b381a5fe5c9856517"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0b8b1b736253f14044ba9d87cb435426915a90b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b8b1b736253f14044ba9d87cb435426915a90b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0b8b1b736253f14044ba9d87cb435426915a90b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b8b1b736253f14044ba9d87cb435426915a90b/comments", "author": null, "committer": null, "parents": [{"sha": "184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184d436af490f910a2cbed4b6f40a4b9bc6b76c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184d436af490f910a2cbed4b6f40a4b9bc6b76c2"}], "stats": {"total": 193, "additions": 139, "deletions": 54}, "files": [{"sha": "38d58f30d5da284faef402e7dc01189e3b7497ef", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -1,3 +1,29 @@\n+2012-02-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_PACKED_ARRAY_TYPE_P): Add checking.\n+\t(TYPE_BY_REFERENCE_P): New flag.\n+\t(TYPE_IS_BY_REFERENCE_P): New macro.\n+\t(TYPE_DUMMY_P): Add checking and remove VOID_TYPE.\n+\t(TYPE_IS_DUMMY_P): Adjust for above change.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use TYPE_BY_REFERENCE_P\n+\tand TYPE_IS_BY_REFERENCE_P instead of TREE_ADDRESSABLE.\n+\t(gnat_to_gnu_param): Likewise.\n+\t(maybe_pad_type): Likewise.\n+\t(make_type_from_size): Use TYPE_IS_PACKED_ARRAY_TYPE_P.\n+\t* gcc-interface/misc.c (must_pass_by_ref): Use TYPE_IS_BY_REFERENCE_P\n+\tinstead of TREE_ADDRESSABLE.\n+\t* gcc-interface/trans.c (finalize_nrv): Likewise.\n+\t(call_to_gnu): Likewise.  Do not create a temporary for return values\n+\twith by-reference type here.\n+\t(gnat_to_gnu): Test TYPE_IS_DUMMY_P instead of TYPE_DUMMY_P.\n+\t(gnat_gimplify_expr) <ADDR_EXPR>: Don't do anything for non-constant\n+\tCONSTRUCTORs and calls.\n+\t* gcc-interface/utils.c (make_dummy_type): Get the equivalent type of\n+\tthe underlying type and use it throughout.  Use TYPE_IS_BY_REFERENCE_P\n+\tinstead of TREE_ADDRESSABLE.\n+\t* gcc-interface/utils2.c (build_cond_expr): Deal with by-reference\n+\ttypes explicitly.\n+\n 2012-02-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Revert previous"}, {"sha": "9a48ed75b4530f16f02fec5574b15cf8711a1cc6", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -80,7 +80,8 @@ do {\t\t\t\t\t\t\t \\\n /* For integral types and array types, nonzero if this is a packed array type\n    used for bit-packed types.  Such types should not be extended to a larger\n    size or validated against a specified size.  */\n-#define TYPE_PACKED_ARRAY_TYPE_P(NODE) TYPE_LANG_FLAG_0 (NODE)\n+#define TYPE_PACKED_ARRAY_TYPE_P(NODE) \\\n+  TYPE_LANG_FLAG_0 (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n \n #define TYPE_IS_PACKED_ARRAY_TYPE_P(NODE) \\\n   ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \\\n@@ -108,6 +109,21 @@ do {\t\t\t\t\t\t\t \\\n    front-end.  */\n #define TYPE_EXTRA_SUBTYPE_P(NODE) TYPE_LANG_FLAG_2 (INTEGER_TYPE_CHECK (NODE))\n \n+/* Nonzero for an aggregate type if this is a by-reference type.  We also\n+   set this on an ENUMERAL_TYPE that is dummy.  */\n+#define TYPE_BY_REFERENCE_P(NODE)\t\t\t\t       \\\n+  TYPE_LANG_FLAG_2 (TREE_CHECK5 (NODE, RECORD_TYPE, UNION_TYPE,\t       \\\n+\t\t\t\t ARRAY_TYPE, UNCONSTRAINED_ARRAY_TYPE, \\\n+\t\t\t\t ENUMERAL_TYPE))\n+\n+#define TYPE_IS_BY_REFERENCE_P(NODE)\t\t    \\\n+  ((TREE_CODE (NODE) == RECORD_TYPE\t\t    \\\n+    || TREE_CODE (NODE) == UNION_TYPE\t\t    \\\n+    || TREE_CODE (NODE) == ARRAY_TYPE\t\t    \\\n+    || TREE_CODE (NODE) == UNCONSTRAINED_ARRAY_TYPE \\\n+    || TREE_CODE (NODE) == ENUMERAL_TYPE)\t    \\\n+   && TYPE_BY_REFERENCE_P (NODE))\n+\n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n    type for an object whose type includes its template in addition to\n    its value (only true for RECORD_TYPE).  */\n@@ -144,13 +160,15 @@ do {\t\t\t\t\t\t\t \\\n #define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \\\n   TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))\n \n-/* For VOID_TYPE, ENUMERAL_TYPE, UNION_TYPE, and RECORD_TYPE, nonzero if this\n-   is a dummy type, made to correspond to a private or incomplete type.  */\n-#define TYPE_DUMMY_P(NODE) TYPE_LANG_FLAG_4 (NODE)\n+/* For RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE, nonzero if this is a dummy\n+   type, made to correspond to a private or incomplete type.  */\n+#define TYPE_DUMMY_P(NODE) \\\n+  TYPE_LANG_FLAG_4 (TREE_CHECK3 (NODE, RECORD_TYPE, UNION_TYPE, ENUMERAL_TYPE))\n \n-#define TYPE_IS_DUMMY_P(NODE) \\\n-  ((TREE_CODE (NODE) == VOID_TYPE || TREE_CODE (NODE) == RECORD_TYPE\t\\\n-    || TREE_CODE (NODE) == UNION_TYPE || TREE_CODE (NODE) == ENUMERAL_TYPE) \\\n+#define TYPE_IS_DUMMY_P(NODE)\t\t  \\\n+  ((TREE_CODE (NODE) == RECORD_TYPE\t  \\\n+    || TREE_CODE (NODE) == UNION_TYPE\t  \\\n+    || TREE_CODE (NODE) == ENUMERAL_TYPE) \\\n    && TYPE_DUMMY_P (NODE))\n \n /* For an INTEGER_TYPE, nonzero if TYPE_ACTUAL_BOUNDS is present.  */\n@@ -167,7 +185,7 @@ do {\t\t\t\t\t\t\t \\\n /* True if TYPE can alias any other types.  */\n #define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n \n-/* In an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the\n+/* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the\n    template and the object.\n \n    ??? We also put this on an ENUMERAL_TYPE that is dummy.  Technically,"}, {"sha": "e47aca4a53e99dfe17c8da0cf176dfcd482b57fe", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -4144,7 +4144,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      return_by_invisi_ref_p = true;\n \n \t    /* Likewise, if the return type is itself By_Reference.  */\n-\t    else if (TREE_ADDRESSABLE (gnu_return_type))\n+\t    else if (TYPE_IS_BY_REFERENCE_P (gnu_return_type))\n \t      return_by_invisi_ref_p = true;\n \n \t    /* If the type is a padded type and the underlying type would not\n@@ -4673,10 +4673,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  || Is_Class_Wide_Equivalent_Type (gnat_entity))\n \tTYPE_ALIGN_OK (gnu_type) = 1;\n \n-      /* If the type is passed by reference, objects of this type must be\n-\t fully addressable and cannot be copied.  */\n-      if (Is_By_Reference_Type (gnat_entity))\n-\tTREE_ADDRESSABLE (gnu_type) = 1;\n+      /* Record whether the type is passed by reference.  */\n+      if (!VOID_TYPE_P (gnu_type) && Is_By_Reference_Type (gnat_entity))\n+\tTYPE_BY_REFERENCE_P (gnu_type) = 1;\n \n       /* ??? Don't set the size for a String_Literal since it is either\n \t confirming or we don't handle it properly (if the low bound is\n@@ -5621,7 +5620,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n \t parameters whose type isn't by-ref and for which the mechanism hasn't\n \t been forced to by-ref are restrict-qualified in the C sense.  */\n       bool restrict_p\n-\t= !TREE_ADDRESSABLE (gnu_param_type) && mech != By_Reference;\n+\t= !TYPE_IS_BY_REFERENCE_P (gnu_param_type) && mech != By_Reference;\n       gnu_param_type = build_reference_type (gnu_param_type);\n       if (restrict_p)\n \tgnu_param_type\n@@ -6653,7 +6652,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (align != 0\n       && RECORD_OR_UNION_TYPE_P (type)\n       && TYPE_MODE (type) == BLKmode\n-      && !TREE_ADDRESSABLE (type)\n+      && !TYPE_BY_REFERENCE_P (type)\n       && TREE_CODE (orig_size) == INTEGER_CST\n       && !TREE_OVERFLOW (orig_size)\n       && compare_tree_int (orig_size, MAX_FIXED_MODE_SIZE) <= 0\n@@ -8353,7 +8352,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \n       /* Only do something if the type is not a packed array type and\n \t doesn't already have the proper size.  */\n-      if (TYPE_PACKED_ARRAY_TYPE_P (type)\n+      if (TYPE_IS_PACKED_ARRAY_TYPE_P (type)\n \t  || (TYPE_PRECISION (type) == size && biased_p == for_biased))\n \tbreak;\n "}, {"sha": "08ca5bb92b33df693332bb2fc021e47243b6accd", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -624,7 +624,7 @@ must_pass_by_ref (tree gnu_type)\n      and does not produce compatibility problems with C, since C does\n      not have such objects.  */\n   return (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n-\t  || TREE_ADDRESSABLE (gnu_type)\n+\t  || TYPE_IS_BY_REFERENCE_P (gnu_type)\n \t  || (TYPE_SIZE (gnu_type)\n \t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n }"}, {"sha": "eebe2a9a9012c13b8594800f4527a488f5fefc38", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -2654,7 +2654,7 @@ establish_gnat_vms_condition_handler (void)\n    on the C++ optimization of the same name.  The main difference is that\n    we disregard any semantical considerations when applying it here, the\n    counterpart being that we don't try to apply it to semantically loaded\n-   return types, i.e. types with the TREE_ADDRESSABLE flag set.\n+   return types, i.e. types with the TYPE_BY_REFERENCE_P flag set.\n \n    We consider a function body of the following GENERIC form:\n \n@@ -3012,7 +3012,7 @@ finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other, Node_Id gnat_ret)\n \n   /* We shouldn't be applying the optimization to return types that we aren't\n      allowed to manipulate freely.  */\n-  gcc_assert (!TREE_ADDRESSABLE (TREE_TYPE (TREE_TYPE (fndecl))));\n+  gcc_assert (!TYPE_IS_BY_REFERENCE_P (TREE_TYPE (TREE_TYPE (fndecl))));\n \n   /* Prune the candidates that are referenced by other return values.  */\n   data.nrv = nrv;\n@@ -3656,8 +3656,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  parameters.\n \n        2. There is no target and this is not an object declaration, and the\n-\t  return type is by-reference or has variable size, because in these\n-\t  cases the gimplifier cannot create the temporary.\n+\t  return type has variable size, because in these cases the gimplifier\n+\t  cannot create the temporary.\n \n        3. There is a target and it is a slice or an array with fixed size,\n \t  and the return type has variable size, because the gimplifier\n@@ -3669,8 +3669,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       && ((!gnu_target && TYPE_CI_CO_LIST (gnu_subprog_type))\n \t  || (!gnu_target\n \t      && Nkind (Parent (gnat_node)) != N_Object_Declaration\n-\t      && (TREE_ADDRESSABLE (gnu_result_type)\n-\t\t  || TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST))\n+\t      && TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST)\n \t  || (gnu_target\n \t      && (TREE_CODE (gnu_target) == ARRAY_RANGE_REF\n \t\t  || (TREE_CODE (TREE_TYPE (gnu_target)) == ARRAY_TYPE\n@@ -3740,7 +3739,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    ;\n \n \t  /* If the type is passed by reference, a copy is not allowed.  */\n-\t  else if (TREE_ADDRESSABLE (gnu_formal_type))\n+\t  else if (TYPE_IS_BY_REFERENCE_P (gnu_formal_type))\n \t    post_error (\"misaligned actual cannot be passed by reference\",\n \t\t        gnat_actual);\n \n@@ -6786,12 +6785,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t : NULL_TREE;\n \t    tree gnu_target_desig_type = TREE_TYPE (gnu_target_type);\n \n-\t    if ((TYPE_DUMMY_P (gnu_target_desig_type)\n+\t    if ((TYPE_IS_DUMMY_P (gnu_target_desig_type)\n \t\t || get_alias_set (gnu_target_desig_type) != 0)\n \t\t&& (!POINTER_TYPE_P (gnu_source_type)\n-\t\t    || (TYPE_DUMMY_P (gnu_source_desig_type)\n-\t\t\t!= TYPE_DUMMY_P (gnu_target_desig_type))\n-\t\t    || (TYPE_DUMMY_P (gnu_source_desig_type)\n+\t\t    || (TYPE_IS_DUMMY_P (gnu_source_desig_type)\n+\t\t\t!= TYPE_IS_DUMMY_P (gnu_target_desig_type))\n+\t\t    || (TYPE_IS_DUMMY_P (gnu_source_desig_type)\n \t\t\t&& gnu_source_desig_type != gnu_target_desig_type)\n \t\t    || !alias_sets_conflict_p\n \t\t\t(get_alias_set (gnu_source_desig_type),\n@@ -6820,12 +6819,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    tree gnu_target_array_type\n \t      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_target_type)));\n \n-\t    if ((TYPE_DUMMY_P (gnu_target_array_type)\n+\t    if ((TYPE_IS_DUMMY_P (gnu_target_array_type)\n \t\t || get_alias_set (gnu_target_array_type) != 0)\n \t\t&& (!TYPE_IS_FAT_POINTER_P (gnu_source_type)\n-\t\t    || (TYPE_DUMMY_P (gnu_source_array_type)\n-\t\t\t!= TYPE_DUMMY_P (gnu_target_array_type))\n-\t\t    || (TYPE_DUMMY_P (gnu_source_array_type)\n+\t\t    || (TYPE_IS_DUMMY_P (gnu_source_array_type)\n+\t\t\t!= TYPE_IS_DUMMY_P (gnu_target_array_type))\n+\t\t    || (TYPE_IS_DUMMY_P (gnu_source_array_type)\n \t\t\t&& gnu_source_array_type != gnu_target_array_type)\n \t\t    || !alias_sets_conflict_p\n \t\t\t(get_alias_set (gnu_source_array_type),\n@@ -7334,23 +7333,6 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t  return GS_ALL_DONE;\n \t}\n \n-      /* Otherwise, if we are taking the address of a non-constant CONSTRUCTOR\n-\t or of a call, explicitly create the local temporary.  That's required\n-\t if the type is passed by reference.  */\n-      if (TREE_CODE (op) == CONSTRUCTOR || TREE_CODE (op) == CALL_EXPR)\n-\t{\n-\t  tree mod, new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n-\t  TREE_ADDRESSABLE (new_var) = 1;\n-\t  gimple_add_tmp_var (new_var);\n-\n-\t  mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, op);\n-\t  gimplify_and_add (mod, pre_p);\n-\n-\t  TREE_OPERAND (expr, 0) = new_var;\n-\t  recompute_tree_invariant_for_addr_expr (expr);\n-\t  return GS_ALL_DONE;\n-\t}\n-\n       return GS_UNHANDLED;\n \n     case VIEW_CONVERT_EXPR:"}, {"sha": "33d11ef3fe2c6f8a59fc9ac031a36a5d1242d901", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -291,7 +291,7 @@ make_dummy_type (Entity_Id gnat_type)\n \n   /* If there is an equivalent type, get its underlying type.  */\n   if (Present (gnat_underlying))\n-    gnat_underlying = Underlying_Type (gnat_underlying);\n+    gnat_underlying = Gigi_Equivalent_Type (Underlying_Type (gnat_underlying));\n \n   /* If there was no equivalent type (can only happen when just annotating\n      types) or underlying type, go back to the original type.  */\n@@ -311,8 +311,8 @@ make_dummy_type (Entity_Id gnat_type)\n   TYPE_DUMMY_P (gnu_type) = 1;\n   TYPE_STUB_DECL (gnu_type)\n     = create_type_stub_decl (TYPE_NAME (gnu_type), gnu_type);\n-  if (Is_By_Reference_Type (gnat_type))\n-    TREE_ADDRESSABLE (gnu_type) = 1;\n+  if (Is_By_Reference_Type (gnat_underlying))\n+    TYPE_BY_REFERENCE_P (gnu_type) = 1;\n \n   SET_DUMMY_NODE (gnat_underlying, gnu_type);\n "}, {"sha": "332d73062eea2b7547c9c9144e5748229267d353", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -1554,8 +1554,9 @@ build_cond_expr (tree result_type, tree condition_operand,\n \n   /* If the result type is unconstrained, take the address of the operands and\n      then dereference the result.  Likewise if the result type is passed by\n-     reference, but this is natively handled in the gimplifier.  */\n+     reference, because creating a temporary of this type is not allowed.  */\n   if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n+      || TYPE_IS_BY_REFERENCE_P (result_type)\n       || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type)))\n     {\n       result_type = build_pointer_type (result_type);"}, {"sha": "f008afc59e7ac6aae62080496743d3191d7a4b07", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -1,3 +1,8 @@\n+2012-02-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/aggr19.adb: New test.\n+\t* gnat.dg/aggr19_pkg.ad[sb]: New helper.\n+\n 2012-02-26  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/49263"}, {"sha": "a88cc1fb51e0ee936e6929265718969deafd0d99", "filename": "gcc/testsuite/gnat.dg/aggr19.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19.adb?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -0,0 +1,14 @@\n+-- { dg-do run }\n+\n+with Aggr19_Pkg; use Aggr19_Pkg;\n+\n+procedure Aggr19 is\n+  C : Rec5\n+    := (Ent => (Kind => Two, Node => (L => (D => True, Pos => 1 )), I => 0));\n+  A : Rec5 := C;\n+begin\n+  Proc (A);\n+  if A /= C then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "d59da8945e29f2e3a09bce7cd2f333e77aeeee08", "filename": "gcc/testsuite/gnat.dg/aggr19_pkg.adb", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19_pkg.adb?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -0,0 +1,8 @@\n+package body Aggr19_Pkg is\n+\n+  procedure Proc (Pool : in out Rec5) is\n+  begin\n+    Pool.Ent := (Kind => Two, Node => Pool.Ent.Node, I => 0);\n+  end;\n+\n+end ;"}, {"sha": "4f98a4d30d87f938a7b50dbc8910589aac1c3e9c", "filename": "gcc/testsuite/gnat.dg/aggr19_pkg.ads", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0b8b1b736253f14044ba9d87cb435426915a90b/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faggr19_pkg.ads?ref=a0b8b1b736253f14044ba9d87cb435426915a90b", "patch": "@@ -0,0 +1,32 @@\n+package Aggr19_Pkg is\n+\n+  type Rec1 (D : Boolean := False) is record\n+    case D is\n+      when False => null;\n+      when True => Pos : Integer;\n+    end case;\n+  end record;\n+\n+  type Rec2 is record\n+    L : Rec1;\n+  end record;\n+\n+  type Rec3 is tagged null record;\n+\n+  type Enum is (One, Two, Three);\n+\n+  type Rec4 (Kind : Enum := One) is record\n+    Node : Rec2;\n+    case Kind is\n+      when One => R : Rec3;\n+      when Others => I : Integer;\n+    end case;\n+  end record;\n+\n+  type Rec5 is record\n+    Ent : Rec4;\n+  end record;\n+\n+  procedure Proc (Pool : in out Rec5);\n+\n+end Aggr19_Pkg;"}]}