{"sha": "a7e3698d81844438d339a957ba4fe7ead0ee2357", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlMzY5OGQ4MTg0NDQzOGQzMzlhOTU3YmE0ZmU3ZWFkMGVlMjM1Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-06T19:29:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-06T19:29:01Z"}, "message": "df-core.c (df_set_blocks): Use bitmap_head instead of bitmap.\n\n\t* df-core.c (df_set_blocks): Use bitmap_head instead of bitmap.\n\t(df_compact_blocks): Likewise.\n\t* df.h (struct df): Turn hardware_regs_used,\n\tregular_block_artificial_uses, eh_block_artificial_uses,\n\tinsns_to_delete, insns_to_rescan, insns_to_notes_rescan into\n\tbitmap_head.\n\t* df-problems.c (df_lr_local_compute, df_lr_confluence_0,\n\tdf_byte_lr_alloc, df_simulate_fixup_sets): Update.\n\t* df-scan.c (df_scan_free_internal, df_scan_alloc, df_scan_start_dump,\n\tdf_scan_blocks, df_insn_delete, df_insn_rescan,\n\tdf_insn_rescan_debug_internal, df_insn_rescan_all,\n\tdf_process_deferred_rescans, df_process_deferred_rescans,\n\tdf_notes_rescan, df_get_call_refs, df_get_call_refs,\n\tregs_invalidated_by_call_regset, df_get_call_refs, df_bb_refs_collect,\n\tdf_record_entry_block_defs, df_record_exit_block_uses,\n\tdf_update_exit_block_uses, df_bb_verify, df_entry_block_bitmap_verify,\n\tdf_scan_verify): Update.\n\nFrom-SVN: r160348", "tree": {"sha": "33762169b920df538a949d4040921754532aa165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33762169b920df538a949d4040921754532aa165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e3698d81844438d339a957ba4fe7ead0ee2357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e3698d81844438d339a957ba4fe7ead0ee2357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e3698d81844438d339a957ba4fe7ead0ee2357", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e3698d81844438d339a957ba4fe7ead0ee2357/comments", "author": null, "committer": null, "parents": [{"sha": "e62b90b403f1e528aef8dc5042e45f921b365cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62b90b403f1e528aef8dc5042e45f921b365cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62b90b403f1e528aef8dc5042e45f921b365cf8"}], "stats": {"total": 322, "additions": 181, "deletions": 141}, "files": [{"sha": "4403b7245ee4dc11c37b7fb7c32e47528740724c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -1,3 +1,23 @@\n+2010-05-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df-core.c (df_set_blocks): Use bitmap_head instead of bitmap.\n+\t(df_compact_blocks): Likewise.\n+\t* df.h (struct df): Turn hardware_regs_used,\n+\tregular_block_artificial_uses, eh_block_artificial_uses,\n+\tinsns_to_delete, insns_to_rescan, insns_to_notes_rescan into\n+\tbitmap_head.\n+\t* df-problems.c (df_lr_local_compute, df_lr_confluence_0,\n+\tdf_byte_lr_alloc, df_simulate_fixup_sets): Update.\n+\t* df-scan.c (df_scan_free_internal, df_scan_alloc, df_scan_start_dump,\n+\tdf_scan_blocks, df_insn_delete, df_insn_rescan,\n+\tdf_insn_rescan_debug_internal, df_insn_rescan_all,\n+\tdf_process_deferred_rescans, df_process_deferred_rescans,\n+\tdf_notes_rescan, df_get_call_refs, df_get_call_refs,\n+\tregs_invalidated_by_call_regset, df_get_call_refs, df_bb_refs_collect,\n+\tdf_record_entry_block_defs, df_record_exit_block_uses,\n+\tdf_update_exit_block_uses, df_bb_verify, df_entry_block_bitmap_verify,\n+\tdf_scan_verify): Update.\n+\n 2010-05-25  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/44188"}, {"sha": "67e5632e6cb1f9d933a4d0e5f21570ee283b98c1", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -2367,7 +2367,13 @@ cleanup_cfg (int mode)\n \t    break;\n \t  else if ((mode & CLEANUP_CROSSJUMP)\n \t\t   && crossjumps_occured)\n-\t    run_fast_dce ();\n+\t    {\n+\t      /* Fast DCE is expensive, we really want to be sure we don't\n+\t\t re-run it just because crossjumping cascade.  */\n+\t      while (try_optimize_cfg (mode))\n+\t\tdelete_unreachable_blocks ();\n+\t      run_fast_dce ();\n+\t    }\n \t}\n       else\n \tbreak;"}, {"sha": "38a5b307e7ba948b8385bd2b817eda04938297ea", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -960,8 +960,8 @@ fast_dce (bool byte_level)\n      df_simulate_fixup_sets has the disadvantage of calling\n      bb_has_eh_pred once per insn, so we cache the information\n      here.  */\n-  bitmap au = df->regular_block_artificial_uses;\n-  bitmap au_eh = df->eh_block_artificial_uses;\n+  bitmap au = &df->regular_block_artificial_uses;\n+  bitmap au_eh = &df->eh_block_artificial_uses;\n   int i;\n \n   prescan_insns_for_dce (true);"}, {"sha": "8c4b79bca775ee76bf571904edd593a16ae9cf72", "filename": "gcc/df-core.c", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -504,8 +504,9 @@ df_set_blocks (bitmap blocks)\n \t  /* This block is called to change the focus from one subset\n \t     to another.  */\n \t  int p;\n-\t  bitmap diff = BITMAP_ALLOC (&df_bitmap_obstack);\n-\t  bitmap_and_compl (diff, df->blocks_to_analyze, blocks);\n+\t  bitmap_head diff;\n+\t  bitmap_initialize (&diff, &df_bitmap_obstack);\n+\t  bitmap_and_compl (&diff, df->blocks_to_analyze, blocks);\n \t  for (p = 0; p < df->num_problems_defined; p++)\n \t    {\n \t      struct dataflow *dflow = df->problems_in_order[p];\n@@ -516,7 +517,7 @@ df_set_blocks (bitmap blocks)\n \t\t  bitmap_iterator bi;\n \t\t  unsigned int bb_index;\n \n-\t\t  EXECUTE_IF_SET_IN_BITMAP (diff, 0, bb_index, bi)\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (&diff, 0, bb_index, bi)\n \t\t    {\n \t\t      basic_block bb = BASIC_BLOCK (bb_index);\n \t\t      if (bb)\n@@ -532,34 +533,34 @@ df_set_blocks (bitmap blocks)\n \t\t}\n \t    }\n \n-\t  BITMAP_FREE (diff);\n+\t   bitmap_clear (&diff);\n \t}\n       else\n \t{\n \t  /* This block of code is executed to change the focus from\n \t     the entire function to a subset.  */\n-\t  bitmap blocks_to_reset = NULL;\n+\t  bitmap_head blocks_to_reset;\n+\t  bool initialized = false;\n \t  int p;\n \t  for (p = 0; p < df->num_problems_defined; p++)\n \t    {\n \t      struct dataflow *dflow = df->problems_in_order[p];\n \t      if (dflow->optional_p && dflow->problem->reset_fun)\n \t\t{\n-\t\t  if (!blocks_to_reset)\n+\t\t  if (!initialized)\n \t\t    {\n \t\t      basic_block bb;\n-\t\t      blocks_to_reset =\n-\t\t\tBITMAP_ALLOC (&df_bitmap_obstack);\n+\t\t      bitmap_initialize (&blocks_to_reset, &df_bitmap_obstack);\n \t\t      FOR_ALL_BB(bb)\n \t\t\t{\n-\t\t\t  bitmap_set_bit (blocks_to_reset, bb->index);\n+\t\t\t  bitmap_set_bit (&blocks_to_reset, bb->index);\n \t\t\t}\n \t\t    }\n-\t\t  dflow->problem->reset_fun (blocks_to_reset);\n+\t\t  dflow->problem->reset_fun (&blocks_to_reset);\n \t\t}\n \t    }\n-\t  if (blocks_to_reset)\n-\t    BITMAP_FREE (blocks_to_reset);\n+\t  if (initialized)\n+\t    bitmap_clear (&blocks_to_reset);\n \n \t  df->blocks_to_analyze = BITMAP_ALLOC (&df_bitmap_obstack);\n \t}\n@@ -1401,9 +1402,10 @@ df_compact_blocks (void)\n   basic_block bb;\n   void **problem_temps;\n   int size = last_basic_block * sizeof (void *);\n-  bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head tmp;\n   problem_temps = XNEWVAR (void *, size);\n \n+  bitmap_initialize (&tmp, &df_bitmap_obstack);\n   for (p = 0; p < df->num_problems_defined; p++)\n     {\n       struct dataflow *dflow = df->problems_in_order[p];\n@@ -1412,17 +1414,17 @@ df_compact_blocks (void)\n \t dflow problem.  */\n       if (dflow->out_of_date_transfer_functions)\n \t{\n-\t  bitmap_copy (tmp, dflow->out_of_date_transfer_functions);\n+\t  bitmap_copy (&tmp, dflow->out_of_date_transfer_functions);\n \t  bitmap_clear (dflow->out_of_date_transfer_functions);\n-\t  if (bitmap_bit_p (tmp, ENTRY_BLOCK))\n+\t  if (bitmap_bit_p (&tmp, ENTRY_BLOCK))\n \t    bitmap_set_bit (dflow->out_of_date_transfer_functions, ENTRY_BLOCK);\n-\t  if (bitmap_bit_p (tmp, EXIT_BLOCK))\n+\t  if (bitmap_bit_p (&tmp, EXIT_BLOCK))\n \t    bitmap_set_bit (dflow->out_of_date_transfer_functions, EXIT_BLOCK);\n \n \t  i = NUM_FIXED_BLOCKS;\n \t  FOR_EACH_BB (bb)\n \t    {\n-\t      if (bitmap_bit_p (tmp, bb->index))\n+\t      if (bitmap_bit_p (&tmp, bb->index))\n \t\tbitmap_set_bit (dflow->out_of_date_transfer_functions, i);\n \t      i++;\n \t    }\n@@ -1463,22 +1465,22 @@ df_compact_blocks (void)\n \n   if (df->blocks_to_analyze)\n     {\n-      if (bitmap_bit_p (tmp, ENTRY_BLOCK))\n+      if (bitmap_bit_p (&tmp, ENTRY_BLOCK))\n \tbitmap_set_bit (df->blocks_to_analyze, ENTRY_BLOCK);\n-      if (bitmap_bit_p (tmp, EXIT_BLOCK))\n+      if (bitmap_bit_p (&tmp, EXIT_BLOCK))\n \tbitmap_set_bit (df->blocks_to_analyze, EXIT_BLOCK);\n-      bitmap_copy (tmp, df->blocks_to_analyze);\n+      bitmap_copy (&tmp, df->blocks_to_analyze);\n       bitmap_clear (df->blocks_to_analyze);\n       i = NUM_FIXED_BLOCKS;\n       FOR_EACH_BB (bb)\n \t{\n-\t  if (bitmap_bit_p (tmp, bb->index))\n+\t  if (bitmap_bit_p (&tmp, bb->index))\n \t    bitmap_set_bit (df->blocks_to_analyze, i);\n \t  i++;\n \t}\n     }\n \n-  BITMAP_FREE (tmp);\n+  bitmap_clear (&tmp);\n \n   free (problem_temps);\n "}, {"sha": "2c76d011c23fbc540889c489c8d3030ae69d1a6f", "filename": "gcc/df-problems.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -925,10 +925,10 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n-  bitmap_clear (df->hardware_regs_used);\n+  bitmap_clear (&df->hardware_regs_used);\n \n   /* The all-important stack pointer must always be live.  */\n-  bitmap_set_bit (df->hardware_regs_used, STACK_POINTER_REGNUM);\n+  bitmap_set_bit (&df->hardware_regs_used, STACK_POINTER_REGNUM);\n \n   /* Before reload, there are a few registers that must be forced\n      live everywhere -- which might not already be the case for\n@@ -937,20 +937,20 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n     {\n       /* Any reference to any pseudo before reload is a potential\n \t reference of the frame pointer.  */\n-      bitmap_set_bit (df->hardware_regs_used, FRAME_POINTER_REGNUM);\n+      bitmap_set_bit (&df->hardware_regs_used, FRAME_POINTER_REGNUM);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n       /* Pseudos with argument area equivalences may require\n \t reloading via the argument pointer.  */\n       if (fixed_regs[ARG_POINTER_REGNUM])\n-\tbitmap_set_bit (df->hardware_regs_used, ARG_POINTER_REGNUM);\n+\tbitmap_set_bit (&df->hardware_regs_used, ARG_POINTER_REGNUM);\n #endif\n \n       /* Any constant, or pseudo with constant equivalences, may\n \t require reloading from memory using the pic register.  */\n       if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n \t  && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n-\tbitmap_set_bit (df->hardware_regs_used, PIC_OFFSET_TABLE_REGNUM);\n+\tbitmap_set_bit (&df->hardware_regs_used, PIC_OFFSET_TABLE_REGNUM);\n     }\n \n   EXECUTE_IF_SET_IN_BITMAP (df_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n@@ -995,7 +995,7 @@ df_lr_confluence_0 (basic_block bb)\n {\n   bitmap op1 = &df_lr_get_bb_info (bb->index)->out;\n   if (bb != EXIT_BLOCK_PTR)\n-    bitmap_copy (op1, df->hardware_regs_used);\n+    bitmap_copy (op1, &df->hardware_regs_used);\n }\n \n \n@@ -1015,7 +1015,7 @@ df_lr_confluence_n (edge e)\n   else\n     bitmap_ior_into (op1, op2);\n \n-  bitmap_ior_into (op1, df->hardware_regs_used);\n+  bitmap_ior_into (op1, &df->hardware_regs_used);\n }\n \n \n@@ -2547,7 +2547,7 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n     }\n \n   df_byte_lr_expand_bitmap (&problem_data->hardware_regs_used,\n-\t\t\t    df->hardware_regs_used);\n+\t\t\t    &df->hardware_regs_used);\n   df_byte_lr_expand_bitmap (&problem_data->invalidated_by_call,\n \t\t\t    regs_invalidated_by_call_regset);\n \n@@ -3979,9 +3979,9 @@ df_simulate_fixup_sets (basic_block bb, bitmap live)\n   /* These regs are considered always live so if they end up dying\n      because of some def, we need to bring the back again.  */\n   if (bb_has_eh_pred (bb))\n-    bitmap_ior_into (live, df->eh_block_artificial_uses);\n+    bitmap_ior_into (live, &df->eh_block_artificial_uses);\n   else\n-    bitmap_ior_into (live, df->regular_block_artificial_uses);\n+    bitmap_ior_into (live, &df->regular_block_artificial_uses);\n }\n \n "}, {"sha": "8bb2ac06b1bcd7126a6005c01a6bf099f2631ed6", "filename": "gcc/df-scan.c", "status": "modified", "additions": 112, "deletions": 100, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -257,14 +257,14 @@ df_scan_free_internal (void)\n   df_scan->block_info = NULL;\n   df_scan->block_info_size = 0;\n \n-  BITMAP_FREE (df->hardware_regs_used);\n-  BITMAP_FREE (df->regular_block_artificial_uses);\n-  BITMAP_FREE (df->eh_block_artificial_uses);\n+  bitmap_clear (&df->hardware_regs_used);\n+  bitmap_clear (&df->regular_block_artificial_uses);\n+  bitmap_clear (&df->eh_block_artificial_uses);\n   BITMAP_FREE (df->entry_block_defs);\n   BITMAP_FREE (df->exit_block_uses);\n-  BITMAP_FREE (df->insns_to_delete);\n-  BITMAP_FREE (df->insns_to_rescan);\n-  BITMAP_FREE (df->insns_to_notes_rescan);\n+  bitmap_clear (&df->insns_to_delete);\n+  bitmap_clear (&df->insns_to_rescan);\n+  bitmap_clear (&df->insns_to_notes_rescan);\n \n   free_alloc_pool (df_scan->block_pool);\n   free_alloc_pool (problem_data->ref_base_pool);\n@@ -392,14 +392,14 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n       bb_info->artificial_uses = NULL;\n     }\n \n-  df->hardware_regs_used = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n-  df->regular_block_artificial_uses = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n-  df->eh_block_artificial_uses = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n+  bitmap_initialize (&df->hardware_regs_used, &problem_data->reg_bitmaps);\n+  bitmap_initialize (&df->regular_block_artificial_uses, &problem_data->reg_bitmaps);\n+  bitmap_initialize (&df->eh_block_artificial_uses, &problem_data->reg_bitmaps);\n   df->entry_block_defs = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n   df->exit_block_uses = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n-  df->insns_to_delete = BITMAP_ALLOC (&problem_data->insn_bitmaps);\n-  df->insns_to_rescan = BITMAP_ALLOC (&problem_data->insn_bitmaps);\n-  df->insns_to_notes_rescan = BITMAP_ALLOC (&problem_data->insn_bitmaps);\n+  bitmap_initialize (&df->insns_to_delete, &problem_data->insn_bitmaps);\n+  bitmap_initialize (&df->insns_to_rescan, &problem_data->insn_bitmaps);\n+  bitmap_initialize (&df->insns_to_notes_rescan, &problem_data->insn_bitmaps);\n   df_scan->optional_p = false;\n }\n \n@@ -437,11 +437,11 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n   fprintf (file, \";;  invalidated by call \\t\");\n   df_print_regset (file, regs_invalidated_by_call_regset);\n   fprintf (file, \";;  hardware regs used \\t\");\n-  df_print_regset (file, df->hardware_regs_used);\n+  df_print_regset (file, &df->hardware_regs_used);\n   fprintf (file, \";;  regular block artificial uses \\t\");\n-  df_print_regset (file, df->regular_block_artificial_uses);\n+  df_print_regset (file, &df->regular_block_artificial_uses);\n   fprintf (file, \";;  eh block artificial uses \\t\");\n-  df_print_regset (file, df->eh_block_artificial_uses);\n+  df_print_regset (file, &df->eh_block_artificial_uses);\n   fprintf (file, \";;  entry block defs \\t\");\n   df_print_regset (file, df->entry_block_defs);\n   fprintf (file, \";;  exit block uses \\t\");\n@@ -682,11 +682,11 @@ df_scan_blocks (void)\n   df->def_info.ref_order = DF_REF_ORDER_NO_TABLE;\n   df->use_info.ref_order = DF_REF_ORDER_NO_TABLE;\n \n-  df_get_regular_block_artificial_uses (df->regular_block_artificial_uses);\n-  df_get_eh_block_artificial_uses (df->eh_block_artificial_uses);\n+  df_get_regular_block_artificial_uses (&df->regular_block_artificial_uses);\n+  df_get_eh_block_artificial_uses (&df->eh_block_artificial_uses);\n \n-  bitmap_ior_into (df->eh_block_artificial_uses,\n-\t\t   df->regular_block_artificial_uses);\n+  bitmap_ior_into (&df->eh_block_artificial_uses,\n+\t\t   &df->regular_block_artificial_uses);\n \n   /* ENTRY and EXIT blocks have special defs/uses.  */\n   df_get_entry_block_def_set (df->entry_block_defs);\n@@ -1140,9 +1140,9 @@ df_insn_delete (basic_block bb, unsigned int uid)\n     {\n       if (insn_info)\n \t{\n-\t  bitmap_clear_bit (df->insns_to_rescan, uid);\n-\t  bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n-\t  bitmap_set_bit (df->insns_to_delete, uid);\n+\t  bitmap_clear_bit (&df->insns_to_rescan, uid);\n+\t  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n+\t  bitmap_set_bit (&df->insns_to_delete, uid);\n \t}\n       if (dump_file)\n \tfprintf (dump_file, \"deferring deletion of insn with uid = %d.\\n\", uid);\n@@ -1152,9 +1152,9 @@ df_insn_delete (basic_block bb, unsigned int uid)\n   if (dump_file)\n     fprintf (dump_file, \"deleting insn with uid = %d.\\n\", uid);\n \n-  bitmap_clear_bit (df->insns_to_delete, uid);\n-  bitmap_clear_bit (df->insns_to_rescan, uid);\n-  bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_delete, uid);\n+  bitmap_clear_bit (&df->insns_to_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n   if (insn_info)\n     {\n       struct df_scan_problem_data *problem_data\n@@ -1257,9 +1257,9 @@ df_insn_rescan (rtx insn)\n       if (dump_file)\n \tfprintf (dump_file, \"deferring rescan insn with uid = %d.\\n\", uid);\n \n-      bitmap_clear_bit (df->insns_to_delete, uid);\n-      bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n-      bitmap_set_bit (df->insns_to_rescan, INSN_UID (insn));\n+      bitmap_clear_bit (&df->insns_to_delete, uid);\n+      bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n+      bitmap_set_bit (&df->insns_to_rescan, INSN_UID (insn));\n       return false;\n     }\n \n@@ -1268,9 +1268,9 @@ df_insn_rescan (rtx insn)\n   collection_rec.eq_use_vec = VEC_alloc (df_ref, stack, 32);\n   collection_rec.mw_vec = VEC_alloc (df_mw_hardreg_ptr, stack, 32);\n \n-  bitmap_clear_bit (df->insns_to_delete, uid);\n-  bitmap_clear_bit (df->insns_to_rescan, uid);\n-  bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_delete, uid);\n+  bitmap_clear_bit (&df->insns_to_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n   if (insn_info)\n     {\n       int luid;\n@@ -1337,9 +1337,9 @@ df_insn_rescan_debug_internal (rtx insn)\n   if (dump_file)\n     fprintf (dump_file, \"deleting debug_insn with uid = %d.\\n\", uid);\n \n-  bitmap_clear_bit (df->insns_to_delete, uid);\n-  bitmap_clear_bit (df->insns_to_rescan, uid);\n-  bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_delete, uid);\n+  bitmap_clear_bit (&df->insns_to_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n \n   if (!insn_info->defs)\n     return false;\n@@ -1384,7 +1384,9 @@ df_insn_rescan_all (void)\n   basic_block bb;\n   bitmap_iterator bi;\n   unsigned int uid;\n-  bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head tmp;\n+\n+  bitmap_initialize (&tmp, &df_bitmap_obstack);\n \n   if (df->changeable_flags & DF_NO_INSN_RESCAN)\n     {\n@@ -1398,18 +1400,18 @@ df_insn_rescan_all (void)\n       defer_insn_rescan = true;\n     }\n \n-  bitmap_copy (tmp, df->insns_to_delete);\n-  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n+  bitmap_copy (&tmp, &df->insns_to_delete);\n+  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n \tdf_insn_delete (NULL, uid);\n     }\n \n-  BITMAP_FREE (tmp);\n-  bitmap_clear (df->insns_to_delete);\n-  bitmap_clear (df->insns_to_rescan);\n-  bitmap_clear (df->insns_to_notes_rescan);\n+  bitmap_clear (&tmp);\n+  bitmap_clear (&df->insns_to_delete);\n+  bitmap_clear (&df->insns_to_rescan);\n+  bitmap_clear (&df->insns_to_notes_rescan);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -1436,7 +1438,9 @@ df_process_deferred_rescans (void)\n   bool defer_insn_rescan = false;\n   bitmap_iterator bi;\n   unsigned int uid;\n-  bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head tmp;\n+\n+  bitmap_initialize (&tmp, &df_bitmap_obstack);\n \n   if (df->changeable_flags & DF_NO_INSN_RESCAN)\n     {\n@@ -1453,24 +1457,24 @@ df_process_deferred_rescans (void)\n   if (dump_file)\n     fprintf (dump_file, \"starting the processing of deferred insns\\n\");\n \n-  bitmap_copy (tmp, df->insns_to_delete);\n-  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n+  bitmap_copy (&tmp, &df->insns_to_delete);\n+  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n \tdf_insn_delete (NULL, uid);\n     }\n \n-  bitmap_copy (tmp, df->insns_to_rescan);\n-  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n+  bitmap_copy (&tmp, &df->insns_to_rescan);\n+  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n \tdf_insn_rescan (insn_info->insn);\n     }\n \n-  bitmap_copy (tmp, df->insns_to_notes_rescan);\n-  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, uid, bi)\n+  bitmap_copy (&tmp, &df->insns_to_notes_rescan);\n+  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, uid, bi)\n     {\n       struct df_insn_info *insn_info = DF_INSN_UID_SAFE_GET (uid);\n       if (insn_info)\n@@ -1480,10 +1484,10 @@ df_process_deferred_rescans (void)\n   if (dump_file)\n     fprintf (dump_file, \"ending the processing of deferred insns\\n\");\n \n-  BITMAP_FREE (tmp);\n-  bitmap_clear (df->insns_to_delete);\n-  bitmap_clear (df->insns_to_rescan);\n-  bitmap_clear (df->insns_to_notes_rescan);\n+  bitmap_clear (&tmp);\n+  bitmap_clear (&df->insns_to_delete);\n+  bitmap_clear (&df->insns_to_rescan);\n+  bitmap_clear (&df->insns_to_notes_rescan);\n \n   if (no_insn_rescan)\n     df_set_flags (DF_NO_INSN_RESCAN);\n@@ -2194,16 +2198,16 @@ df_notes_rescan (rtx insn)\n \t  insn_info->mw_hardregs = df_null_mw_rec;\n \t}\n \n-      bitmap_clear_bit (df->insns_to_delete, uid);\n+      bitmap_clear_bit (&df->insns_to_delete, uid);\n       /* If the insn is set to be rescanned, it does not need to also\n \t be notes rescanned.  */\n-      if (!bitmap_bit_p (df->insns_to_rescan, uid))\n-\tbitmap_set_bit (df->insns_to_notes_rescan, INSN_UID (insn));\n+      if (!bitmap_bit_p (&df->insns_to_rescan, uid))\n+\tbitmap_set_bit (&df->insns_to_notes_rescan, INSN_UID (insn));\n       return;\n     }\n \n-  bitmap_clear_bit (df->insns_to_delete, uid);\n-  bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n+  bitmap_clear_bit (&df->insns_to_delete, uid);\n+  bitmap_clear_bit (&df->insns_to_notes_rescan, uid);\n \n   if (insn_info)\n     {\n@@ -3452,13 +3456,15 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n   bool is_sibling_call;\n   unsigned int i;\n   df_ref def;\n-  bitmap defs_generated = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head defs_generated;\n+\n+  bitmap_initialize (&defs_generated, &df_bitmap_obstack);\n \n   /* Do not generate clobbers for registers that are the result of the\n      call.  This causes ordering problems in the chain building code\n      depending on which def is seen first.  */\n   for (i = 0; VEC_iterate (df_ref, collection_rec->def_vec, i, def); ++i)\n-    bitmap_set_bit (defs_generated, DF_REF_REGNO (def));\n+    bitmap_set_bit (&defs_generated, DF_REF_REGNO (def));\n \n   /* Record the registers used to pass arguments, and explicitly\n      noted as clobbered.  */\n@@ -3474,7 +3480,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n \t    {\n \t      unsigned int regno = REGNO (XEXP (XEXP (note, 0), 0));\n-\t      if (!bitmap_bit_p (defs_generated, regno))\n+\t      if (!bitmap_bit_p (&defs_generated, regno))\n \t\tdf_defs_record (collection_rec, XEXP (note, 0), bb,\n \t\t\t\tinsn_info, flags);\n \t    }\n@@ -3508,7 +3514,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n   EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, ui, bi)\n     {\n       if (!global_regs[ui]\n-\t  && (!bitmap_bit_p (defs_generated, ui))\n+\t  && (!bitmap_bit_p (&defs_generated, ui))\n \t  && (!is_sibling_call\n \t      || !bitmap_bit_p (df->exit_block_uses, ui)\n \t      || refers_to_regno_p (ui, ui+1,\n@@ -3519,7 +3525,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t\t       -1, -1, VOIDmode);\n     }\n \n-  BITMAP_FREE (defs_generated);\n+  bitmap_clear (&defs_generated);\n   return;\n }\n \n@@ -3670,8 +3676,8 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       bitmap_iterator bi;\n       unsigned int regno;\n       bitmap au = bb_has_eh_pred (bb)\n-\t? df->eh_block_artificial_uses\n-\t: df->regular_block_artificial_uses;\n+\t? &df->eh_block_artificial_uses\n+\t: &df->regular_block_artificial_uses;\n \n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n \t{\n@@ -3993,13 +3999,14 @@ df_record_entry_block_defs (bitmap entry_block_defs)\n void\n df_update_entry_block_defs (void)\n {\n-  bitmap refs = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head refs;\n   bool changed = false;\n \n-  df_get_entry_block_def_set (refs);\n+  bitmap_initialize (&refs, &df_bitmap_obstack);\n+  df_get_entry_block_def_set (&refs);\n   if (df->entry_block_defs)\n     {\n-      if (!bitmap_equal_p (df->entry_block_defs, refs))\n+      if (!bitmap_equal_p (df->entry_block_defs, &refs))\n \t{\n \t  struct df_scan_bb_info *bb_info = df_scan_get_bb_info (ENTRY_BLOCK);\n \t  df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n@@ -4012,17 +4019,18 @@ df_update_entry_block_defs (void)\n     {\n       struct df_scan_problem_data *problem_data\n \t= (struct df_scan_problem_data *) df_scan->problem_data;\n+\tgcc_unreachable ();\n       df->entry_block_defs = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n       changed = true;\n     }\n \n   if (changed)\n     {\n-      df_record_entry_block_defs (refs);\n-      bitmap_copy (df->entry_block_defs, refs);\n+      df_record_entry_block_defs (&refs);\n+      bitmap_copy (df->entry_block_defs, &refs);\n       df_set_bb_dirty (BASIC_BLOCK (ENTRY_BLOCK));\n     }\n-  BITMAP_FREE (refs);\n+  bitmap_clear (&refs);\n }\n \n \n@@ -4165,13 +4173,14 @@ df_record_exit_block_uses (bitmap exit_block_uses)\n void\n df_update_exit_block_uses (void)\n {\n-  bitmap refs = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head refs;\n   bool changed = false;\n \n-  df_get_exit_block_use_set (refs);\n+  bitmap_initialize (&refs, &df_bitmap_obstack);\n+  df_get_exit_block_use_set (&refs);\n   if (df->exit_block_uses)\n     {\n-      if (!bitmap_equal_p (df->exit_block_uses, refs))\n+      if (!bitmap_equal_p (df->exit_block_uses, &refs))\n \t{\n \t  struct df_scan_bb_info *bb_info = df_scan_get_bb_info (EXIT_BLOCK);\n \t  df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n@@ -4184,17 +4193,18 @@ df_update_exit_block_uses (void)\n     {\n       struct df_scan_problem_data *problem_data\n \t= (struct df_scan_problem_data *) df_scan->problem_data;\n+\tgcc_unreachable ();\n       df->exit_block_uses = BITMAP_ALLOC (&problem_data->reg_bitmaps);\n       changed = true;\n     }\n \n   if (changed)\n     {\n-      df_record_exit_block_uses (refs);\n-      bitmap_copy (df->exit_block_uses, refs);\n+      df_record_exit_block_uses (&refs);\n+      bitmap_copy (df->exit_block_uses,& refs);\n       df_set_bb_dirty (BASIC_BLOCK (EXIT_BLOCK));\n     }\n-  BITMAP_FREE (refs);\n+  bitmap_clear (&refs);\n }\n \n static bool initialized = false;\n@@ -4550,24 +4560,25 @@ df_bb_verify (basic_block bb)\n static bool\n df_entry_block_bitmap_verify (bool abort_if_fail)\n {\n-  bitmap entry_block_defs = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head entry_block_defs;\n   bool is_eq;\n \n-  df_get_entry_block_def_set (entry_block_defs);\n+  bitmap_initialize (&entry_block_defs, &df_bitmap_obstack);\n+  df_get_entry_block_def_set (&entry_block_defs);\n \n-  is_eq = bitmap_equal_p (entry_block_defs, df->entry_block_defs);\n+  is_eq = bitmap_equal_p (&entry_block_defs, df->entry_block_defs);\n \n   if (!is_eq && abort_if_fail)\n     {\n       print_current_pass (stderr);\n       fprintf (stderr, \"entry_block_defs = \");\n-      df_print_regset (stderr, entry_block_defs);\n+      df_print_regset (stderr, &entry_block_defs);\n       fprintf (stderr, \"df->entry_block_defs = \");\n       df_print_regset (stderr, df->entry_block_defs);\n       gcc_assert (0);\n     }\n \n-  BITMAP_FREE (entry_block_defs);\n+  bitmap_clear (&entry_block_defs);\n \n   return is_eq;\n }\n@@ -4579,24 +4590,25 @@ df_entry_block_bitmap_verify (bool abort_if_fail)\n static bool\n df_exit_block_bitmap_verify (bool abort_if_fail)\n {\n-  bitmap exit_block_uses = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_head exit_block_uses;\n   bool is_eq;\n \n-  df_get_exit_block_use_set (exit_block_uses);\n+  bitmap_initialize (&exit_block_uses, &df_bitmap_obstack);\n+  df_get_exit_block_use_set (&exit_block_uses);\n \n-  is_eq = bitmap_equal_p (exit_block_uses, df->exit_block_uses);\n+  is_eq = bitmap_equal_p (&exit_block_uses, df->exit_block_uses);\n \n   if (!is_eq && abort_if_fail)\n     {\n       print_current_pass (stderr);\n       fprintf (stderr, \"exit_block_uses = \");\n-      df_print_regset (stderr, exit_block_uses);\n+      df_print_regset (stderr, &exit_block_uses);\n       fprintf (stderr, \"df->exit_block_uses = \");\n       df_print_regset (stderr, df->exit_block_uses);\n       gcc_assert (0);\n     }\n \n-  BITMAP_FREE (exit_block_uses);\n+  bitmap_clear (&exit_block_uses);\n \n   return is_eq;\n }\n@@ -4610,8 +4622,8 @@ df_scan_verify (void)\n {\n   unsigned int i;\n   basic_block bb;\n-  bitmap regular_block_artificial_uses;\n-  bitmap eh_block_artificial_uses;\n+  bitmap_head regular_block_artificial_uses;\n+  bitmap_head eh_block_artificial_uses;\n \n   if (!df)\n     return;\n@@ -4632,23 +4644,23 @@ df_scan_verify (void)\n   /* (2) There are various bitmaps whose value may change over the\n      course of the compilation.  This step recomputes them to make\n      sure that they have not slipped out of date.  */\n-  regular_block_artificial_uses = BITMAP_ALLOC (&df_bitmap_obstack);\n-  eh_block_artificial_uses = BITMAP_ALLOC (&df_bitmap_obstack);\n+  bitmap_initialize (&regular_block_artificial_uses, &df_bitmap_obstack);\n+  bitmap_initialize (&eh_block_artificial_uses, &df_bitmap_obstack);\n \n-  df_get_regular_block_artificial_uses (regular_block_artificial_uses);\n-  df_get_eh_block_artificial_uses (eh_block_artificial_uses);\n+  df_get_regular_block_artificial_uses (&regular_block_artificial_uses);\n+  df_get_eh_block_artificial_uses (&eh_block_artificial_uses);\n \n-  bitmap_ior_into (eh_block_artificial_uses,\n-\t\t   regular_block_artificial_uses);\n+  bitmap_ior_into (&eh_block_artificial_uses,\n+\t\t   &regular_block_artificial_uses);\n \n   /* Check artificial_uses bitmaps didn't change. */\n-  gcc_assert (bitmap_equal_p (regular_block_artificial_uses,\n-\t\t\t      df->regular_block_artificial_uses));\n-  gcc_assert (bitmap_equal_p (eh_block_artificial_uses,\n-\t\t\t      df->eh_block_artificial_uses));\n+  gcc_assert (bitmap_equal_p (&regular_block_artificial_uses,\n+\t\t\t      &df->regular_block_artificial_uses));\n+  gcc_assert (bitmap_equal_p (&eh_block_artificial_uses,\n+\t\t\t      &df->eh_block_artificial_uses));\n \n-  BITMAP_FREE (regular_block_artificial_uses);\n-  BITMAP_FREE (eh_block_artificial_uses);\n+  bitmap_clear (&regular_block_artificial_uses);\n+  bitmap_clear (&eh_block_artificial_uses);\n \n   /* Verify entry block and exit block. These only verify the bitmaps,\n      the refs are verified in df_bb_verify.  */"}, {"sha": "98bf0847be0cb46226e5f7bfe8c6a2a246cb08e3", "filename": "gcc/df.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e3698d81844438d339a957ba4fe7ead0ee2357/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=a7e3698d81844438d339a957ba4fe7ead0ee2357", "patch": "@@ -564,22 +564,22 @@ struct df\n \n   int num_problems_defined;\n \n-  bitmap hardware_regs_used;     /* The set of hardware registers used.  */\n+  bitmap_head hardware_regs_used;     /* The set of hardware registers used.  */\n   /* The set of hard regs that are in the artificial uses at the end\n      of a regular basic block.  */\n-  bitmap regular_block_artificial_uses;\n+  bitmap_head regular_block_artificial_uses;\n   /* The set of hard regs that are in the artificial uses at the end\n      of a basic block that has an EH pred.  */\n-  bitmap eh_block_artificial_uses;\n+  bitmap_head eh_block_artificial_uses;\n   /* The set of hardware registers live on entry to the function.  */\n   bitmap entry_block_defs;\n   bitmap exit_block_uses;        /* The set of hardware registers used in exit block.  */\n \n   /* Insns to delete, rescan or reprocess the notes at next\n      df_rescan_all or df_process_deferred_rescans. */\n-  bitmap insns_to_delete;\n-  bitmap insns_to_rescan;\n-  bitmap insns_to_notes_rescan;\n+  bitmap_head insns_to_delete;\n+  bitmap_head insns_to_rescan;\n+  bitmap_head insns_to_notes_rescan;\n   int *postorder;                /* The current set of basic blocks\n                                     in reverse postorder.  */\n   int *postorder_inverted;       /* The current set of basic blocks"}]}