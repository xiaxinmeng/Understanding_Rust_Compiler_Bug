{"sha": "0533d788e5a1cfee22b813adc87afa9f44c688c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUzM2Q3ODhlNWExY2ZlZTIyYjgxM2FkYzg3YWZhOWY0NGM2ODhjMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-02T02:13:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-02T02:13:53Z"}, "message": "class.c (build_vtable): Don't return a value.\n\n\t* class.c (build_vtable): Don't return a value.  Don't rebuild\n\tvtables for bases that have already been handled.\n\t(prepare_fresh_vtable): Don't rebuild vtables for bases that have\n\talready been handled.\n\t(modify_one_vtable): Adjust accordingly.\n\t(fixup_vtable_deltas1): Likewise.\n\t(finish_struct_1): Likewise.\n\nFrom-SVN: r31161", "tree": {"sha": "8fb9bf7e9dc53b9203c4fee3ddcdf7c16e265df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fb9bf7e9dc53b9203c4fee3ddcdf7c16e265df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0533d788e5a1cfee22b813adc87afa9f44c688c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0533d788e5a1cfee22b813adc87afa9f44c688c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0533d788e5a1cfee22b813adc87afa9f44c688c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0533d788e5a1cfee22b813adc87afa9f44c688c0/comments", "author": null, "committer": null, "parents": [{"sha": "4485c55bfda1b1cc8698c1b9601d1e5b2d1f902d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4485c55bfda1b1cc8698c1b9601d1e5b2d1f902d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4485c55bfda1b1cc8698c1b9601d1e5b2d1f902d"}], "stats": {"total": 96, "additions": 47, "deletions": 49}, "files": [{"sha": "eb51cc2303f85ea78e20e5c1b79b208a50a56f1c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0533d788e5a1cfee22b813adc87afa9f44c688c0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0533d788e5a1cfee22b813adc87afa9f44c688c0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0533d788e5a1cfee22b813adc87afa9f44c688c0", "patch": "@@ -1,3 +1,13 @@\n+2000-01-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (build_vtable): Don't return a value.  Don't rebuild\n+\tvtables for bases that have already been handled.\n+\t(prepare_fresh_vtable): Don't rebuild vtables for bases that have\n+\talready been handled.\n+\t(modify_one_vtable): Adjust accordingly.\n+\t(fixup_vtable_deltas1): Likewise.\n+\t(finish_struct_1): Likewise.\n+\n 2000-01-01  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* call.c (build_new_method_call): Also check destructors."}, {"sha": "dfe1a1565869c694aa801aba5ab293d9eb824d43", "filename": "gcc/cp/class.c", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0533d788e5a1cfee22b813adc87afa9f44c688c0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0533d788e5a1cfee22b813adc87afa9f44c688c0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0533d788e5a1cfee22b813adc87afa9f44c688c0", "patch": "@@ -82,7 +82,7 @@ static tree get_vtable_name PROTO((tree));\n static tree get_derived_offset PROTO((tree, tree));\n static tree get_basefndecls PROTO((tree, tree));\n static void set_rtti_entry PROTO((tree, tree, tree));\n-static tree build_vtable PROTO((tree, tree));\n+static void build_vtable PROTO((tree, tree));\n static void prepare_fresh_vtable PROTO((tree, tree));\n static void fixup_vtable_deltas1 PROTO((tree, tree));\n static void fixup_vtable_deltas PROTO((tree, int, tree));\n@@ -695,7 +695,7 @@ set_rtti_entry (virtuals, offset, type)\n    approximation that it is the same as the one which is the head of\n    the association list.  */\n \n-static tree\n+static void\n build_vtable (binfo, type)\n      tree binfo, type;\n {\n@@ -706,6 +706,11 @@ build_vtable (binfo, type)\n     {\n       tree offset;\n \n+      if (BINFO_NEW_VTABLE_MARKED (binfo))\n+\t/* We have already created a vtable for this base, so there's\n+\t   no need to do it again.  */\n+\treturn;\n+\n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n       decl = build_lang_decl (VAR_DECL, name, \n \t\t\t      TREE_TYPE (BINFO_VTABLE (binfo)));\n@@ -752,7 +757,6 @@ build_vtable (binfo, type)\n \n   binfo = TYPE_BINFO (type);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n-  return decl;\n }\n \n /* Give TYPE a new virtual function table which is initialized\n@@ -787,6 +791,11 @@ prepare_fresh_vtable (binfo, for_type)\n   joiner = JOINER;\n #endif\n \n+  if (BINFO_NEW_VTABLE_MARKED (binfo))\n+    /* We already created a vtable for this base.  There's no need to\n+       do it again.  */\n+    return;\n+\n   basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (binfo));\n \n   buf2 = TYPE_ASSEMBLER_NAME_STRING (basetype);\n@@ -2414,15 +2423,9 @@ modify_one_vtable (binfo, t, fndecl)\n   if (flag_rtti)\n     {\n       if (binfo == TYPE_BINFO (t))\n-\t{\n-\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), t);\n-\t}\n+\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), t);\n       else\n-\t{\n-\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t    prepare_fresh_vtable (binfo, t);\n-\t}\n+\tprepare_fresh_vtable (binfo, t);\n     }\n   if (fndecl == NULL_TREE)\n     return;\n@@ -2462,22 +2465,16 @@ modify_one_vtable (binfo, t, fndecl)\n \t  this_offset = ssize_binop (MINUS_EXPR, offset, base_offset);\n \n \t  if (binfo == TYPE_BINFO (t))\n-\t    {\n-\t      /* In this case, it is *type*'s vtable we are modifying.\n-\t\t We start with the approximation that it's vtable is that\n-\t\t of the immediate base class.  */\n-\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-\t    }\n+\t    /* In this case, it is *type*'s vtable we are modifying.\n+\t       We start with the approximation that it's vtable is\n+\t       that of the immediate base class.  */\n+\t      build_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n \t  else\n-\t    {\n-\t      /* This is our very own copy of `basetype' to play with.\n-\t\t Later, we will fill in all the virtual functions\n-\t\t that override the virtual functions in these base classes\n-\t\t which are not defined by the current type.  */\n-\t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t\tprepare_fresh_vtable (binfo, t);\n-\t    }\n+\t    /* This is our very own copy of `basetype' to play with.\n+\t       Later, we will fill in all the virtual functions that\n+\t       override the virtual functions in these base classes\n+\t       which are not defined by the current type.  */\n+\t    prepare_fresh_vtable (binfo, t);\n \n #ifdef NOTQUITE\n \t  cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n@@ -2558,22 +2555,17 @@ fixup_vtable_deltas1 (binfo, t)\n \t    {\n \t      /* Make sure we can modify the derived association with immunity.  */\n \t      if (binfo == TYPE_BINFO (t))\n-\t\t{\n-\t\t  /* In this case, it is *type*'s vtable we are modifying.\n-\t\t     We start with the approximation that it's vtable is that\n-\t\t     of the immediate base class.  */\n-\t\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-\t\t}\n+\t\t/* In this case, it is *type*'s vtable we are modifying.\n+\t\t   We start with the approximation that it's vtable is that\n+\t\t   of the immediate base class.  */\n+\t\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n \t      else\n-\t\t{\n-\t\t  /* This is our very own copy of `basetype' to play with.\n-\t\t     Later, we will fill in all the virtual functions\n-\t\t     that override the virtual functions in these base classes\n-\t\t     which are not defined by the current type.  */\n-\t\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t\t    prepare_fresh_vtable (binfo, t);\n-\t\t}\n+\t\t/* This is our very own copy of `basetype' to play\n+\t\t   with.  Later, we will fill in all the virtual\n+\t\t   functions that override the virtual functions in\n+\t\t   these base classes which are not defined by the\n+\t\t   current type.  */\n+\t\tprepare_fresh_vtable (binfo, t);\n \n \t      modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n \t\t\t\t   this_offset,\n@@ -4405,14 +4397,10 @@ finish_struct_1 (t)\n \t    }\n \t  build_vtable (NULL_TREE, t);\n \t}\n-      else\n-\t{\n-\t  /* Here we know enough to change the type of our virtual\n-\t     function table, but we will wait until later this function.  */\n-\n-\t  if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n-\t    build_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n-\t}\n+      else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n+\t/* Here we know enough to change the type of our virtual\n+\t   function table, but we will wait until later this function.  */\n+\tbuild_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n \n       /* If this type has basetypes with constructors, then those\n \t constructors might clobber the virtual function table.  But"}]}