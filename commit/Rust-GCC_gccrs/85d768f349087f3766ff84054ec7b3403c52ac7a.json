{"sha": "85d768f349087f3766ff84054ec7b3403c52ac7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVkNzY4ZjM0OTA4N2YzNzY2ZmY4NDA1NGVjN2IzNDAzYzUyYWM3YQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2013-02-08T10:13:37Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2013-02-08T10:13:37Z"}, "message": "re PR target/54222 ([avr] Implement fixed-point support)\n\ngcc/\n\tPR target/54222\n\t* config/avr/avr.md (unspec) <UNSPEC_ROUND>: Add.\n\t* config/avr/avr-fixed.md (ALL4QA, ALL124QA): New mode iterators.\n\t(round<mode>3, round<mode>3_const): New expanders for fixed-mode.\n\t(*round<mode>3.libgcc): New insns for fixed-modes.\n\t* config/avr/builtins.def (ABSxx): Use a non-NULL LIBNAME.\n\t(ROUNDxx, COUNTLSxx, BITSxx, xxBITS): New DEF_BUILTINs.\n\t(ROUNDFX, COUNTLSFX, ABSFX): New DEF_BUILTINs.\n\t* config/avr/stdfix.h (absFX, bitsFX, FXbits): Remove inline\n\timplementations.  Define to __builtin_avr_absFX,\n\t__builtin_avr_bitsFX, __builtin_avr_FXbits, respectively.\n\t(roundFX, countlsFX): Define to __builtin_avr_roundFX,\n\t__builtin_avr_countlsFX, respectively.\n\t* config/avr/avr-c.c (target.h): Include it.\n\t(enum avr_builtin_id): New enum.\n\t(avr_resolve_overloaded_builtin): New static function.\n\t(avr_register_target_pragmas): Use it to set\n\ttargetm.resolve_overloaded_builtin.\n\t* config/avr/avr.c (avr_init_builtins): Supply myriads of local\n\ttree nodes used by DEF_BUILTIN.\n\t(avr_expand_builtin) <AVR_BUILTIN_ROUNDxx>: Sanity-check them.\n\t(avr_fold_builtin) <AVR_BUILTIN_BITSxx>: Fold to VIEW_COVERT_EXPR.\n\t<AVR_BUILTIN_xxBITS>: Same.\n\t\nlibgcc/\n\tPR target/54222\n\t* config/avr/lib2funcs.c: New C sources for modules for libgcc.a.\n\t* config/avr/lib2-object.mk: New iterator to build objects from it.\n\t* config/avr/t-avr: Iterate lib2-object.mk to build objects from\n\tlib2funcs.c.\n\t(LIB2FUNCS_EXCLUDE): Add _clrsbdi2.\n\t(LIB1ASMFUNCS): Add: _ssabs_1, _mask1, _ret, _roundqq3, _rounduqq3,\n\t_round_s2, _round_u2, _round_2_const, _addmask_2, _round_s4,\n\t_round_u4, _round_4_const, _addmask_4, _round_x8, _rounddq3\n\t_roundudq3, _roundda3 _rounduda3, _roundta3 _rounduta3.\n\t* config/avr/lib1funcs-fixed.S: Implement them.\n\ngcc/testsuite/\n\tPR target/54222\n\t* gcc.target/avr/torture/builtins-4-roundfx.c: New test.\n\t* gcc.target/avr/torture/builtins-5-countlsfx.c: New test.\n\nFrom-SVN: r195878", "tree": {"sha": "c41ab849c5ffa4c56a753d5d4502a23fdc14617d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c41ab849c5ffa4c56a753d5d4502a23fdc14617d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85d768f349087f3766ff84054ec7b3403c52ac7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d768f349087f3766ff84054ec7b3403c52ac7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d768f349087f3766ff84054ec7b3403c52ac7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d768f349087f3766ff84054ec7b3403c52ac7a/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "661bc682bcb87f5faa709f9bcd1679874f6652f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661bc682bcb87f5faa709f9bcd1679874f6652f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661bc682bcb87f5faa709f9bcd1679874f6652f6"}], "stats": {"total": 2317, "additions": 1931, "deletions": 386}, "files": [{"sha": "38173e97a1c0c7abe9c73a2ed5b6c3110f6b6152", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -1,3 +1,29 @@\n+2013-02-08  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/54222\n+\t* config/avr/avr.md (unspec) <UNSPEC_ROUND>: Add.\n+\t* config/avr/avr-fixed.md (ALL4QA, ALL124QA): New mode iterators.\n+\t(round<mode>3, round<mode>3_const): New expanders for fixed-mode.\n+\t(*round<mode>3.libgcc): New insns for fixed-modes.\n+\t* config/avr/builtins.def (ABSxx): Use a non-NULL LIBNAME.\n+\t(ROUNDxx, COUNTLSxx, BITSxx, xxBITS): New DEF_BUILTINs.\n+\t(ROUNDFX, COUNTLSFX, ABSFX): New DEF_BUILTINs.\n+\t* config/avr/stdfix.h (absFX, bitsFX, FXbits): Remove inline\n+\timplementations.  Define to __builtin_avr_absFX,\n+\t__builtin_avr_bitsFX, __builtin_avr_FXbits, respectively.\n+\t(roundFX, countlsFX): Define to __builtin_avr_roundFX,\n+\t__builtin_avr_countlsFX, respectively.\n+\t* config/avr/avr-c.c (target.h): Include it.\n+\t(enum avr_builtin_id): New enum.\n+\t(avr_resolve_overloaded_builtin): New static function.\n+\t(avr_register_target_pragmas): Use it to set\n+\ttargetm.resolve_overloaded_builtin.\n+\t* config/avr/avr.c (avr_init_builtins): Supply myriads of local\n+\ttree nodes used by DEF_BUILTIN.\n+\t(avr_expand_builtin) <AVR_BUILTIN_ROUNDxx>: Sanity-check them.\n+\t(avr_fold_builtin) <AVR_BUILTIN_BITSxx>: Fold to VIEW_COVERT_EXPR.\n+\t<AVR_BUILTIN_xxBITS>: Same.\n+\n 2013-02-08  Richard Biener  <rguenther@suse.de>\n \n \t* cfgloop.c (verify_loop_structure): Properly handle"}, {"sha": "4e64405a3516063b49d2bc8ebbd59905e52e1739", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -26,10 +26,226 @@\n #include \"tm_p.h\"\n #include \"cpplib.h\"\n #include \"tree.h\"\n+#include \"target.h\"\n #include \"c-family/c-common.h\"\n #include \"langhooks.h\"\n \n \n+/* IDs for all the AVR builtins.  */\n+\n+enum avr_builtin_id\n+  {\n+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, CODE, LIBNAME)  \\\n+    AVR_BUILTIN_ ## NAME,\n+#include \"builtins.def\"\n+#undef DEF_BUILTIN\n+\n+    AVR_BUILTIN_COUNT\n+  };\n+\n+\n+/* Implement `TARGET_RESOLVE_OVERLOADED_PLUGIN'.  */\n+\n+static tree\n+avr_resolve_overloaded_builtin (unsigned int iloc, tree fndecl, void *vargs)\n+{\n+  tree type0, type1, fold = NULL_TREE;\n+  enum avr_builtin_id id = AVR_BUILTIN_COUNT;\n+  location_t loc = (location_t) iloc;\n+  vec<tree, va_gc> &args = * (vec<tree, va_gc>*) vargs;\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    default:\n+      break;\n+\n+    case AVR_BUILTIN_ABSFX:\n+      if (args.length() != 1)\n+        {\n+          error_at (loc, \"%qs expects 1 argument but %d given\",\n+                    \"absfx\", (int) args.length());\n+\n+          fold = error_mark_node;\n+          break;\n+        }\n+\n+      type0 = TREE_TYPE (args[0]);\n+\n+      if (!FIXED_POINT_TYPE_P (type0))\n+        {\n+          error_at (loc, \"%qs expects a fixed-point value as argument\",\n+                    \"absfx\");\n+\n+          fold = error_mark_node;\n+        }\n+\n+      switch (TYPE_MODE (type0))\n+        {\n+        case QQmode: id = AVR_BUILTIN_ABSHR; break;\n+        case HQmode: id = AVR_BUILTIN_ABSR; break;\n+        case SQmode: id = AVR_BUILTIN_ABSLR; break;\n+        case DQmode: id = AVR_BUILTIN_ABSLLR; break;\n+\n+        case HAmode: id = AVR_BUILTIN_ABSHK; break;\n+        case SAmode: id = AVR_BUILTIN_ABSK; break;\n+        case DAmode: id = AVR_BUILTIN_ABSLK; break;\n+        case TAmode: id = AVR_BUILTIN_ABSLLK; break;\n+\n+        case UQQmode:\n+        case UHQmode:\n+        case USQmode:\n+        case UDQmode:\n+        case UHAmode:\n+        case USAmode:\n+        case UDAmode:\n+        case UTAmode:\n+          warning_at (loc, 0, \"using %qs with unsigned type has no effect\",\n+                      \"absfx\");\n+          return args[0];\n+\n+        default:\n+          error_at (loc, \"no matching fixed-point overload found for %qs\",\n+                    \"absfx\");\n+\n+          fold = error_mark_node;\n+          break;\n+        }\n+\n+      fold = targetm.builtin_decl (id, true);\n+\n+      if (fold != error_mark_node)\n+        fold = build_function_call_vec (loc, fold, &args, NULL);\n+\n+      break; // absfx\n+\n+    case AVR_BUILTIN_ROUNDFX:\n+      if (args.length() != 2)\n+        {\n+          error_at (loc, \"%qs expects 2 arguments but %d given\",\n+                    \"roundfx\", (int) args.length());\n+\n+          fold = error_mark_node;\n+          break;\n+        }\n+\n+      type0 = TREE_TYPE (args[0]);\n+      type1 = TREE_TYPE (args[1]);\n+\n+      if (!FIXED_POINT_TYPE_P (type0))\n+        {\n+          error_at (loc, \"%qs expects a fixed-point value as first argument\",\n+                    \"roundfx\");\n+\n+          fold = error_mark_node;\n+        }\n+\n+      if (!INTEGRAL_TYPE_P (type1))\n+        {\n+          error_at (loc, \"%qs expects an integer value as second argument\",\n+                    \"roundfx\");\n+\n+          fold = error_mark_node;\n+        }\n+\n+      switch (TYPE_MODE (type0))\n+        {\n+        case QQmode: id = AVR_BUILTIN_ROUNDHR; break;\n+        case HQmode: id = AVR_BUILTIN_ROUNDR; break;\n+        case SQmode: id = AVR_BUILTIN_ROUNDLR; break;\n+        case DQmode: id = AVR_BUILTIN_ROUNDLLR; break;\n+\n+        case UQQmode: id = AVR_BUILTIN_ROUNDUHR; break;\n+        case UHQmode: id = AVR_BUILTIN_ROUNDUR; break;\n+        case USQmode: id = AVR_BUILTIN_ROUNDULR; break;\n+        case UDQmode: id = AVR_BUILTIN_ROUNDULLR; break;\n+\n+        case HAmode: id = AVR_BUILTIN_ROUNDHK; break;\n+        case SAmode: id = AVR_BUILTIN_ROUNDK; break;\n+        case DAmode: id = AVR_BUILTIN_ROUNDLK; break;\n+        case TAmode: id = AVR_BUILTIN_ROUNDLLK; break;\n+\n+        case UHAmode: id = AVR_BUILTIN_ROUNDUHK; break;\n+        case USAmode: id = AVR_BUILTIN_ROUNDUK; break;\n+        case UDAmode: id = AVR_BUILTIN_ROUNDULK; break;\n+        case UTAmode: id = AVR_BUILTIN_ROUNDULLK; break;\n+\n+        default:\n+          error_at (loc, \"no matching fixed-point overload found for %qs\",\n+                    \"roundfx\");\n+\n+          fold = error_mark_node;\n+          break;\n+        }\n+\n+      fold = targetm.builtin_decl (id, true);\n+\n+      if (fold != error_mark_node)\n+        fold = build_function_call_vec (loc, fold, &args, NULL);\n+\n+      break; // roundfx\n+\n+    case AVR_BUILTIN_COUNTLSFX:\n+      if (args.length() != 1)\n+        {\n+          error_at (loc, \"%qs expects 1 argument but %d given\",\n+                    \"countlsfx\", (int) args.length());\n+\n+          fold = error_mark_node;\n+          break;\n+        }\n+\n+      type0 = TREE_TYPE (args[0]);\n+\n+      if (!FIXED_POINT_TYPE_P (type0))\n+        {\n+          error_at (loc, \"%qs expects a fixed-point value as first argument\",\n+                    \"countlsfx\");\n+\n+          fold = error_mark_node;\n+        }\n+\n+      switch (TYPE_MODE (type0))\n+        {\n+        case QQmode: id = AVR_BUILTIN_COUNTLSHR; break;\n+        case HQmode: id = AVR_BUILTIN_COUNTLSR; break;\n+        case SQmode: id = AVR_BUILTIN_COUNTLSLR; break;\n+        case DQmode: id = AVR_BUILTIN_COUNTLSLLR; break;\n+\n+        case UQQmode: id = AVR_BUILTIN_COUNTLSUHR; break;\n+        case UHQmode: id = AVR_BUILTIN_COUNTLSUR; break;\n+        case USQmode: id = AVR_BUILTIN_COUNTLSULR; break;\n+        case UDQmode: id = AVR_BUILTIN_COUNTLSULLR; break;\n+\n+        case HAmode: id = AVR_BUILTIN_COUNTLSHK; break;\n+        case SAmode: id = AVR_BUILTIN_COUNTLSK; break;\n+        case DAmode: id = AVR_BUILTIN_COUNTLSLK; break;\n+        case TAmode: id = AVR_BUILTIN_COUNTLSLLK; break;\n+\n+        case UHAmode: id = AVR_BUILTIN_COUNTLSUHK; break;\n+        case USAmode: id = AVR_BUILTIN_COUNTLSUK; break;\n+        case UDAmode: id = AVR_BUILTIN_COUNTLSULK; break;\n+        case UTAmode: id = AVR_BUILTIN_COUNTLSULLK; break;\n+\n+        default:\n+          error_at (loc, \"no matching fixed-point overload found for %qs\",\n+                    \"countlsfx\");\n+\n+          fold = error_mark_node;\n+          break;\n+        }\n+\n+      fold = targetm.builtin_decl (id, true);\n+\n+      if (fold != error_mark_node)\n+        fold = build_function_call_vec (loc, fold, &args, NULL);\n+\n+      break; // countlsfx\n+    }\n+\n+  return fold;\n+}\n+  \n+\n /* Implement `REGISTER_TARGET_PRAGMAS'.  */\n \n void\n@@ -49,6 +265,8 @@ avr_register_target_pragmas (void)\n       if (!ADDR_SPACE_GENERIC_P (i))\n         c_register_addr_space (avr_addrspace[i].name, avr_addrspace[i].id);\n     }\n+\n+  targetm.resolve_overloaded_builtin = avr_resolve_overloaded_builtin;\n }\n \n "}, {"sha": "7d9b525ef6cfc06edec53b63990a1b7ba3714321", "filename": "gcc/config/avr/avr-fixed.md", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr-fixed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr-fixed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-fixed.md?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -24,14 +24,16 @@\n (define_mode_iterator ALL1Q  [QQ UQQ])\n (define_mode_iterator ALL2Q  [HQ UHQ])\n (define_mode_iterator ALL2A  [HA UHA])\n-(define_mode_iterator ALL2QA [HQ UHQ\n-                              HA UHA])\n (define_mode_iterator ALL4A  [SA USA])\n+(define_mode_iterator ALL2QA [HQ UHQ HA UHA])\n+(define_mode_iterator ALL4QA [SQ USQ SA USA])\n+(define_mode_iterator ALL124QA [ QQ   HQ  HA  SA  SQ\n+                                UQQ  UHQ UHA USA USQ])\n \n (define_mode_iterator ALL2S [HQ HA])\n (define_mode_iterator ALL4S [SA SQ])\n-(define_mode_iterator ALL24S  [    HQ   HA  SA  SQ])\n-(define_mode_iterator ALL124S [ QQ HQ   HA  SA  SQ])\n+(define_mode_iterator ALL24S  [     HQ  HA  SA  SQ])\n+(define_mode_iterator ALL124S [ QQ  HQ  HA  SA  SQ])\n (define_mode_iterator ALL124U [UQQ UHQ UHA USA USQ])\n \n ;;; Conversions\n@@ -396,3 +398,131 @@\n   \"%~call __<code><mode>3\"\n   [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n+\n+\n+;******************************************************************************\n+;** Rounding\n+;******************************************************************************\n+\n+;; \"roundqq3\"  \"rounduqq3\"\n+;; \"roundhq3\"  \"rounduhq3\"  \"roundha3\"  \"rounduha3\"\n+;; \"roundsq3\"  \"roundusq3\"  \"roundsa3\"  \"roundusa3\"\n+(define_expand \"round<mode>3\"\n+  [(set (match_dup 4)\n+        (match_operand:ALL124QA 1 \"register_operand\" \"\"))\n+   (set (reg:QI 24)\n+        (match_dup 5))\n+   (parallel [(set (match_dup 3)\n+                   (unspec:ALL124QA [(match_dup 4)\n+                                     (reg:QI 24)] UNSPEC_ROUND))\n+              (clobber (match_dup 4))])\n+   (set (match_operand:ALL124QA 0 \"register_operand\" \"\")\n+        (match_dup 3))\n+   (use (match_operand:HI 2 \"nonmemory_operand\" \"\"))]\n+  \"\"\n+  {\n+    if (CONST_INT_P (operands[2])\n+        && !(optimize_size\n+             && 4 == GET_MODE_SIZE (<MODE>mode)))\n+      {\n+        emit_insn (gen_round<mode>3_const (operands[0], operands[1], operands[2]));\n+        DONE;\n+      }\n+\n+    // Input and output of the libgcc function\n+    const unsigned int regno_in[]  = { -1, 22, 22, -1, 18 };\n+    const unsigned int regno_out[] = { -1, 24, 24, -1, 22 };\n+\n+    operands[3] = gen_rtx_REG (<MODE>mode, regno_out[(size_t) GET_MODE_SIZE (<MODE>mode)]);\n+    operands[4] = gen_rtx_REG (<MODE>mode,  regno_in[(size_t) GET_MODE_SIZE (<MODE>mode)]);\n+    operands[5] = simplify_gen_subreg (QImode, force_reg (HImode, operands[2]), HImode, 0);\n+    // $2 is no more needed, but is referenced for expand.\n+    operands[2] = const0_rtx;\n+  })\n+\n+;; Expand rounding with known rounding points inline so that the addend / mask\n+;; will be consumed by operation with immediate operands and there is no\n+;; need for a shift with variable offset.\n+\n+;; \"roundqq3_const\"  \"rounduqq3_const\"\n+;; \"roundhq3_const\"  \"rounduhq3_const\"  \"roundha3_const\"  \"rounduha3_const\"\n+;; \"roundsq3_const\"  \"roundusq3_const\"  \"roundsa3_const\"  \"roundusa3_const\"\n+(define_expand \"round<mode>3_const\"\n+  [(parallel [(match_operand:ALL124QA 0 \"register_operand\" \"\")\n+              (match_operand:ALL124QA 1 \"register_operand\" \"\")\n+              (match_operand:HI 2 \"const_int_operand\" \"\")])]\n+  \"\"\n+  {\n+    // The rounding point RP is $2.  The smallest fractional\n+    // bit that is not cleared by the rounding is 2^(-RP).\n+\n+    enum machine_mode imode = int_mode_for_mode (<MODE>mode);\n+    int fbit = (int) GET_MODE_FBIT (<MODE>mode);\n+\n+    // Add-Saturate  1/2 * 2^(-RP)\n+\n+    double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (operands[2]));\n+    rtx x_add = const_fixed_from_double_int (i_add, <MODE>mode);\n+\n+    if (SIGNED_FIXED_POINT_MODE_P (<MODE>mode))\n+      emit_move_insn (operands[0],\n+                      gen_rtx_SS_PLUS (<MODE>mode, operands[1], x_add));\n+    else\n+      emit_move_insn (operands[0],\n+                      gen_rtx_US_PLUS (<MODE>mode, operands[1], x_add));\n+\n+    // Keep  all bits from RP and higher:   ... 2^(-RP)\n+    // Clear all bits from RP+1 and lower:              2^(-RP-1) ...\n+    // Rounding point                           ^^^^^^^\n+    // Added above                                      ^^^^^^^^^\n+\n+    rtx xreg = simplify_gen_subreg (imode, operands[0], <MODE>mode, 0);\n+    rtx xmask = immed_double_int_const (-i_add - i_add, imode);\n+\n+    if (SImode == imode)\n+      emit_insn (gen_andsi3 (xreg, xreg, xmask));\n+    else if (HImode == imode)\n+      emit_insn (gen_andhi3 (xreg, xreg, xmask));\n+    else if (QImode == imode)\n+      emit_insn (gen_andqi3 (xreg, xreg, xmask));\n+    else\n+      gcc_unreachable();\n+\n+    DONE;\n+  })\n+\n+\n+;; \"*roundqq3.libgcc\"  \"*rounduqq3.libgcc\"\n+(define_insn \"*round<mode>3.libgcc\"\n+  [(set (reg:ALL1Q 24)\n+        (unspec:ALL1Q [(reg:ALL1Q 22)\n+                       (reg:QI 24)] UNSPEC_ROUND))\n+   (clobber (reg:ALL1Q 22))]\n+  \"\"\n+  \"%~call __round<mode>3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; \"*roundhq3.libgcc\"  \"*rounduhq3.libgcc\"\n+;; \"*roundha3.libgcc\"  \"*rounduha3.libgcc\"\n+(define_insn \"*round<mode>3.libgcc\"\n+  [(set (reg:ALL2QA 24)\n+        (unspec:ALL2QA [(reg:ALL2QA 22)\n+                        (reg:QI 24)] UNSPEC_ROUND))\n+   (clobber (reg:ALL2QA 22))]\n+  \"\"\n+  \"%~call __round<mode>3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; \"*roundsq3.libgcc\"  \"*roundusq3.libgcc\"\n+;; \"*roundsa3.libgcc\"  \"*roundusa3.libgcc\"\n+(define_insn \"*round<mode>3.libgcc\"\n+  [(set (reg:ALL4QA 22)\n+        (unspec:ALL4QA [(reg:ALL4QA 18)\n+                        (reg:QI 24)] UNSPEC_ROUND))\n+   (clobber (reg:ALL4QA 18))]\n+  \"\"\n+  \"%~call __round<mode>3\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])"}, {"sha": "0f1d2c1647a785efbaa82d6be201ef05751ddba8", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 179, "deletions": 25, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -11489,32 +11489,118 @@ avr_init_builtins (void)\n                                 const_memx_ptr_type_node,\n                                 NULL);\n \n-  tree hr_ftype_hr\n-    = build_function_type_list (short_fract_type_node,\n-                                short_fract_type_node, NULL);\n-  tree r_ftype_r\n-    = build_function_type_list (fract_type_node,\n-                                fract_type_node, NULL);\n-  tree lr_ftype_lr\n-    = build_function_type_list (long_fract_type_node,\n-                                long_fract_type_node, NULL);\n-  tree llr_ftype_llr\n-    = build_function_type_list (long_long_fract_type_node,\n-                                long_long_fract_type_node, NULL);\n-\n-  tree hk_ftype_hk\n-    = build_function_type_list (short_accum_type_node,\n-                                short_accum_type_node, NULL);\n-  tree k_ftype_k\n-    = build_function_type_list (accum_type_node,\n-                                accum_type_node, NULL);\n-  tree lk_ftype_lk\n-    = build_function_type_list (long_accum_type_node,\n-                                long_accum_type_node, NULL);\n-  tree llk_ftype_llk\n-    = build_function_type_list (long_long_accum_type_node,\n-                                long_long_accum_type_node, NULL);\n+#define ITYP(T)                                                         \\\n+  lang_hooks.types.type_for_size (TYPE_PRECISION (T), TYPE_UNSIGNED (T))\n   \n+#define FX_FTYPE_FX(fx)                                                 \\\n+  tree fx##r_ftype_##fx##r                                              \\\n+    = build_function_type_list (node_##fx##r, node_##fx##r, NULL);      \\\n+  tree fx##k_ftype_##fx##k                                              \\\n+    = build_function_type_list (node_##fx##k, node_##fx##k, NULL)\n+\n+#define FX_FTYPE_FX_INT(fx)                                             \\\n+  tree fx##r_ftype_##fx##r_int                                          \\\n+    = build_function_type_list (node_##fx##r, node_##fx##r,             \\\n+                                integer_type_node, NULL);               \\\n+  tree fx##k_ftype_##fx##k_int                                          \\\n+    = build_function_type_list (node_##fx##k, node_##fx##k,             \\\n+                                integer_type_node, NULL)\n+  \n+#define INT_FTYPE_FX(fx)                                                \\\n+  tree int_ftype_##fx##r                                                \\\n+    = build_function_type_list (integer_type_node, node_##fx##r, NULL); \\\n+  tree int_ftype_##fx##k                                                \\\n+    = build_function_type_list (integer_type_node, node_##fx##k, NULL)\n+\n+#define INTX_FTYPE_FX(fx)                                               \\\n+  tree int##fx##r_ftype_##fx##r                                         \\\n+    = build_function_type_list (ITYP (node_##fx##r), node_##fx##r, NULL); \\\n+  tree int##fx##k_ftype_##fx##k                                         \\\n+    = build_function_type_list (ITYP (node_##fx##k), node_##fx##k, NULL)\n+\n+#define FX_FTYPE_INTX(fx)                                               \\\n+  tree fx##r_ftype_int##fx##r                                           \\\n+    = build_function_type_list (node_##fx##r, ITYP (node_##fx##r), NULL); \\\n+  tree fx##k_ftype_int##fx##k                                           \\\n+    = build_function_type_list (node_##fx##k, ITYP (node_##fx##k), NULL)\n+\n+  tree node_hr = short_fract_type_node;\n+  tree node_r = fract_type_node;\n+  tree node_lr = long_fract_type_node;\n+  tree node_llr = long_long_fract_type_node;\n+\n+  tree node_uhr = unsigned_short_fract_type_node;\n+  tree node_ur = unsigned_fract_type_node;\n+  tree node_ulr = unsigned_long_fract_type_node;\n+  tree node_ullr = unsigned_long_long_fract_type_node;\n+\n+  tree node_hk = short_accum_type_node;\n+  tree node_k = accum_type_node;\n+  tree node_lk = long_accum_type_node;\n+  tree node_llk = long_long_accum_type_node;\n+\n+  tree node_uhk = unsigned_short_accum_type_node;\n+  tree node_uk = unsigned_accum_type_node;\n+  tree node_ulk = unsigned_long_accum_type_node;\n+  tree node_ullk = unsigned_long_long_accum_type_node;\n+\n+\n+  /* For absfx builtins.  */\n+\n+  FX_FTYPE_FX (h);\n+  FX_FTYPE_FX ();\n+  FX_FTYPE_FX (l);\n+  FX_FTYPE_FX (ll);\n+\n+  /* For roundfx builtins.  */\n+\n+  FX_FTYPE_FX_INT (h);\n+  FX_FTYPE_FX_INT ();\n+  FX_FTYPE_FX_INT (l);\n+  FX_FTYPE_FX_INT (ll);\n+\n+  FX_FTYPE_FX_INT (uh);\n+  FX_FTYPE_FX_INT (u);\n+  FX_FTYPE_FX_INT (ul);\n+  FX_FTYPE_FX_INT (ull);\n+\n+  /* For countlsfx builtins.  */\n+\n+  INT_FTYPE_FX (h);\n+  INT_FTYPE_FX ();\n+  INT_FTYPE_FX (l);\n+  INT_FTYPE_FX (ll);\n+\n+  INT_FTYPE_FX (uh);\n+  INT_FTYPE_FX (u);\n+  INT_FTYPE_FX (ul);\n+  INT_FTYPE_FX (ull);\n+\n+  /* For bitsfx builtins.  */\n+\n+  INTX_FTYPE_FX (h);\n+  INTX_FTYPE_FX ();\n+  INTX_FTYPE_FX (l);\n+  INTX_FTYPE_FX (ll);\n+\n+  INTX_FTYPE_FX (uh);\n+  INTX_FTYPE_FX (u);\n+  INTX_FTYPE_FX (ul);\n+  INTX_FTYPE_FX (ull);\n+\n+  /* For fxbits builtins.  */\n+\n+  FX_FTYPE_INTX (h);\n+  FX_FTYPE_INTX ();\n+  FX_FTYPE_INTX (l);\n+  FX_FTYPE_INTX (ll);\n+\n+  FX_FTYPE_INTX (uh);\n+  FX_FTYPE_INTX (u);\n+  FX_FTYPE_INTX (ul);\n+  FX_FTYPE_INTX (ull);\n+\n+\n #define DEF_BUILTIN(NAME, N_ARGS, TYPE, CODE, LIBNAME)                  \\\n   {                                                                     \\\n     int id = AVR_BUILTIN_ ## NAME;                                      \\\n@@ -11647,7 +11733,50 @@ avr_expand_builtin (tree exp, rtx target,\n                    \" as first argument\", bname);\n             return target;\n           }\n+\n+        break;\n       }\n+\n+    case AVR_BUILTIN_ROUNDHR:   case AVR_BUILTIN_ROUNDUHR:\n+    case AVR_BUILTIN_ROUNDR:    case AVR_BUILTIN_ROUNDUR:\n+    case AVR_BUILTIN_ROUNDLR:   case AVR_BUILTIN_ROUNDULR:\n+    case AVR_BUILTIN_ROUNDLLR:  case AVR_BUILTIN_ROUNDULLR:\n+\n+    case AVR_BUILTIN_ROUNDHK:   case AVR_BUILTIN_ROUNDUHK:\n+    case AVR_BUILTIN_ROUNDK:    case AVR_BUILTIN_ROUNDUK:\n+    case AVR_BUILTIN_ROUNDLK:   case AVR_BUILTIN_ROUNDULK:\n+    case AVR_BUILTIN_ROUNDLLK:  case AVR_BUILTIN_ROUNDULLK:\n+\n+      /* Warn about odd rounding.  Rounding points >= FBIT will have\n+         no effect.  */\n+      \n+      if (TREE_CODE (CALL_EXPR_ARG (exp, 1)) != INTEGER_CST)\n+        break;\n+\n+      int rbit = (int) TREE_INT_CST_LOW (CALL_EXPR_ARG (exp, 1));\n+\n+      if (rbit >= (int) GET_MODE_FBIT (mode))\n+        {\n+          warning (OPT_Wextra, \"rounding to %d bits has no effect for \"\n+                   \"fixed-point value with %d fractional bits\",\n+                   rbit, GET_MODE_FBIT (mode));\n+\n+          return expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, mode,\n+                              EXPAND_NORMAL);\n+        }\n+      else if (rbit <= - (int) GET_MODE_IBIT (mode))\n+        {\n+          warning (0, \"rounding result will always be 0\");\n+          return CONST0_RTX (mode);\n+        }\n+\n+      /* The rounding points RP satisfies now:  -IBIT < RP < FBIT.\n+\n+         TR 18037 only specifies results for  RP > 0.  However, the\n+         remaining cases of  -IBIT < RP <= 0  can easily be supported\n+         without any additional overhead.  */\n+\n+      break; /* round */\n     }\n \n   /* No fold found and no insn:  Call support function from libgcc.  */\n@@ -11736,6 +11865,31 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n \n       return avr_fold_absfx (arg[0]);\n \n+    case AVR_BUILTIN_BITSHR:    case AVR_BUILTIN_HRBITS:\n+    case AVR_BUILTIN_BITSHK:    case AVR_BUILTIN_HKBITS:\n+    case AVR_BUILTIN_BITSUHR:   case AVR_BUILTIN_UHRBITS:\n+    case AVR_BUILTIN_BITSUHK:   case AVR_BUILTIN_UHKBITS:\n+\n+    case AVR_BUILTIN_BITSR:     case AVR_BUILTIN_RBITS:\n+    case AVR_BUILTIN_BITSK:     case AVR_BUILTIN_KBITS:\n+    case AVR_BUILTIN_BITSUR:    case AVR_BUILTIN_URBITS:\n+    case AVR_BUILTIN_BITSUK:    case AVR_BUILTIN_UKBITS:\n+\n+    case AVR_BUILTIN_BITSLR:    case AVR_BUILTIN_LRBITS:\n+    case AVR_BUILTIN_BITSLK:    case AVR_BUILTIN_LKBITS:\n+    case AVR_BUILTIN_BITSULR:   case AVR_BUILTIN_ULRBITS:\n+    case AVR_BUILTIN_BITSULK:   case AVR_BUILTIN_ULKBITS:\n+\n+    case AVR_BUILTIN_BITSLLR:   case AVR_BUILTIN_LLRBITS:\n+    case AVR_BUILTIN_BITSLLK:   case AVR_BUILTIN_LLKBITS:\n+    case AVR_BUILTIN_BITSULLR:  case AVR_BUILTIN_ULLRBITS:\n+    case AVR_BUILTIN_BITSULLK:  case AVR_BUILTIN_ULLKBITS:\n+\n+      gcc_assert (TYPE_PRECISION (val_type)\n+                  == TYPE_PRECISION (TREE_TYPE (arg[0])));\n+\n+      return build1 (VIEW_CONVERT_EXPR, val_type, arg[0]);\n+\n     case AVR_BUILTIN_INSERT_BITS:\n       {\n         tree tbits = arg[1];"}, {"sha": "e9f5d038f1f4bcd73b03ef25044501329cf35ca1", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -68,6 +68,7 @@\n    UNSPEC_COPYSIGN\n    UNSPEC_IDENTITY\n    UNSPEC_INSERT_BITS\n+   UNSPEC_ROUND\n    ])\n \n (define_c_enum \"unspecv\""}, {"sha": "ce444abae74115a700f9b7aec87f6ada98964461", "filename": "gcc/config/avr/builtins.def", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fbuiltins.def?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -61,12 +61,109 @@ DEF_BUILTIN (FLASH_SEGMENT, 1, char_ftype_const_memx_ptr, flash_segment, NULL)\n \n /* 7.18a.6.2 The fixed-point absolute value functions. */\n \n-DEF_BUILTIN (ABSHR,   1, hr_ftype_hr,   ssabsqq2, NULL)\n-DEF_BUILTIN (ABSR,    1, r_ftype_r,     ssabshq2, NULL)\n-DEF_BUILTIN (ABSLR,   1, lr_ftype_lr,   ssabssq2, NULL)\n-DEF_BUILTIN (ABSLLR,  1, llr_ftype_llr, nothing, \"__ssabsdq2\") // GCC extension\n-\n-DEF_BUILTIN (ABSHK,   1, hk_ftype_hk,   ssabsha2, NULL)\n-DEF_BUILTIN (ABSK,    1, k_ftype_k,     ssabssa2, NULL)\n-DEF_BUILTIN (ABSLK,  -1, lk_ftype_lk,   nothing, \"__ssabsda2\")\n-DEF_BUILTIN (ABSLLK, -1, llk_ftype_llk, nothing, \"__ssabsta2\") // GCC extension\n+DEF_BUILTIN (ABSHR,   1, hr_ftype_hr,   ssabsqq2, \"__ssabs_1\")\n+DEF_BUILTIN (ABSR,    1, r_ftype_r,     ssabshq2, \"__ssabs_2\")\n+DEF_BUILTIN (ABSLR,   1, lr_ftype_lr,   ssabssq2, \"__ssabs_4\")\n+DEF_BUILTIN (ABSLLR, -1, llr_ftype_llr, nothing,  \"__ssabsdq2\") // GCC extension\n+\n+DEF_BUILTIN (ABSHK,   1, hk_ftype_hk,   ssabsha2, \"__ssabs_2\")\n+DEF_BUILTIN (ABSK,    1, k_ftype_k,     ssabssa2, \"__ssabs_4\")\n+DEF_BUILTIN (ABSLK,  -1, lk_ftype_lk,   nothing,  \"__ssabsda2\")\n+DEF_BUILTIN (ABSLLK, -1, llk_ftype_llk, nothing,  \"__ssabsta2\") // GCC extension\n+\n+/* 7.18a.6.3 The fixed-point round functions. */\n+\n+DEF_BUILTIN (ROUNDHR,    2, hr_ftype_hr_int,     roundqq3,  \"__roundhr\")\n+DEF_BUILTIN (ROUNDR,     2, r_ftype_r_int,       roundhq3,  \"__roundr\")\n+DEF_BUILTIN (ROUNDLR,    2, lr_ftype_lr_int,     roundsq3,  \"__roundlr\")\n+DEF_BUILTIN (ROUNDLLR,  -1, llr_ftype_llr_int,   nothing,   \"__rounddq3\") // GCC extension\n+\n+DEF_BUILTIN (ROUNDUHR,   2, uhr_ftype_uhr_int,   rounduqq3, \"__rounduhr\")\n+DEF_BUILTIN (ROUNDUR,    2, ur_ftype_ur_int,     rounduhq3, \"__roundur\")\n+DEF_BUILTIN (ROUNDULR,   2, ulr_ftype_ulr_int,   roundusq3, \"__roundulr\")\n+DEF_BUILTIN (ROUNDULLR, -1, ullr_ftype_ullr_int, nothing,   \"__roundudq3\") // GCC extension\n+\n+DEF_BUILTIN (ROUNDHK,    2, hk_ftype_hk_int,     roundha3,  \"__roundhk\")\n+DEF_BUILTIN (ROUNDK,     2, k_ftype_k_int,       roundsa3,  \"__roundk\")\n+DEF_BUILTIN (ROUNDLK,   -1, lk_ftype_lk_int,     nothing,   \"__roundda3\")\n+DEF_BUILTIN (ROUNDLLK,  -1, llk_ftype_llk_int,   nothing,   \"__roundta3\") // GCC extension\n+\n+DEF_BUILTIN (ROUNDUHK,   2, uhk_ftype_uhk_int,   rounduha3, \"__rounduhk\")\n+DEF_BUILTIN (ROUNDUK,    2, uk_ftype_uk_int,     roundusa3, \"__rounduk\")\n+DEF_BUILTIN (ROUNDULK,  -1, ulk_ftype_ulk_int,   nothing,   \"__rounduda3\")\n+DEF_BUILTIN (ROUNDULLK, -1, ullk_ftype_ullk_int, nothing,   \"__rounduta3\") // GCC extension\n+\n+/* 7.18a.6.4 The fixed-point bit countls functions. */\n+\n+DEF_BUILTIN (COUNTLSHR,   -1, int_ftype_hr,   nothing, \"__countlsqi2\")\n+DEF_BUILTIN (COUNTLSR,    -1, int_ftype_r,    nothing, \"__countlshi2\")\n+DEF_BUILTIN (COUNTLSLR,   -1, int_ftype_lr,   nothing, \"__countlssi2\")\n+DEF_BUILTIN (COUNTLSLLR,  -1, int_ftype_llr,  nothing, \"__countlsdi2\") // GCC extension\n+\n+DEF_BUILTIN (COUNTLSUHR,  -1, int_ftype_uhr,  nothing, \"__countlsuqi2\")\n+DEF_BUILTIN (COUNTLSUR,   -1, int_ftype_ur,   nothing, \"__countlsuhi2\")\n+DEF_BUILTIN (COUNTLSULR,  -1, int_ftype_ulr,  nothing, \"__countlsusi2\")\n+DEF_BUILTIN (COUNTLSULLR, -1, int_ftype_ullr, nothing, \"__countlsudi2\") // GCC extension\n+\n+DEF_BUILTIN (COUNTLSHK,   -1, int_ftype_hk,   nothing, \"__countlshi2\")\n+DEF_BUILTIN (COUNTLSK,    -1, int_ftype_k,    nothing, \"__countlssi2\")\n+DEF_BUILTIN (COUNTLSLK,   -1, int_ftype_lk,   nothing, \"__countlsdi2\")\n+DEF_BUILTIN (COUNTLSLLK,  -1, int_ftype_llk,  nothing, \"__countlsdi2\") // GCC extension\n+\n+DEF_BUILTIN (COUNTLSUHK,  -1, int_ftype_uhk,  nothing, \"__countlsuhi2\")\n+DEF_BUILTIN (COUNTLSUK,   -1, int_ftype_uk,   nothing, \"__countlsusi2\")\n+DEF_BUILTIN (COUNTLSULK,  -1, int_ftype_ulk,  nothing, \"__countlsudi2\")\n+DEF_BUILTIN (COUNTLSULLK, -1, int_ftype_ullk, nothing, \"__countlsudi2\") // GCC extension\n+\n+/* 7.18a.6.5 The bitwise fixed-point to integer conversion functions. */\n+\n+DEF_BUILTIN (BITSHR,   -1,   inthr_ftype_hr,   nothing, \"__ret\")\n+DEF_BUILTIN (BITSR,    -1,    intr_ftype_r,    nothing, \"__ret\")\n+DEF_BUILTIN (BITSLR,   -1,   intlr_ftype_lr,   nothing, \"__ret\")\n+DEF_BUILTIN (BITSLLR,  -1,  intllr_ftype_llr,  nothing, \"__ret\") // GCC extension\n+\n+DEF_BUILTIN (BITSUHR,  -1,  intuhr_ftype_uhr,  nothing, \"__ret\")\n+DEF_BUILTIN (BITSUR,   -1,   intur_ftype_ur,   nothing, \"__ret\")\n+DEF_BUILTIN (BITSULR,  -1,  intulr_ftype_ulr,  nothing, \"__ret\")\n+DEF_BUILTIN (BITSULLR, -1, intullr_ftype_ullr, nothing, \"__ret\") // GCC extension\n+\n+DEF_BUILTIN (BITSHK,   -1,   inthk_ftype_hk,   nothing, \"__ret\")\n+DEF_BUILTIN (BITSK,    -1,    intk_ftype_k,    nothing, \"__ret\")\n+DEF_BUILTIN (BITSLK,   -1,   intlk_ftype_lk,   nothing, \"__ret\")\n+DEF_BUILTIN (BITSLLK,  -1,  intllk_ftype_llk,  nothing, \"__ret\") // GCC extension\n+\n+DEF_BUILTIN (BITSUHK,  -1,  intuhk_ftype_uhk,  nothing, \"__ret\")\n+DEF_BUILTIN (BITSUK,   -1,   intuk_ftype_uk,   nothing, \"__ret\")\n+DEF_BUILTIN (BITSULK,  -1,  intulk_ftype_ulk,  nothing, \"__ret\")\n+DEF_BUILTIN (BITSULLK, -1, intullk_ftype_ullk, nothing, \"__ret\") // GCC extension\n+\n+\n+/* 7.18a.6.6 The bitwise integer to fixed-point conversion functions. */\n+\n+DEF_BUILTIN (  HRBITS, -1,   hr_ftype_inthr,   nothing, \"__ret\")\n+DEF_BUILTIN (   RBITS, -1,    r_ftype_intr,    nothing, \"__ret\")\n+DEF_BUILTIN (  LRBITS, -1,   lr_ftype_intlr,   nothing, \"__ret\")\n+DEF_BUILTIN ( LLRBITS, -1,  llr_ftype_intllr,  nothing, \"__ret\") // GCC extension\n+\n+DEF_BUILTIN ( UHRBITS, -1,  uhr_ftype_intuhr,  nothing, \"__ret\")\n+DEF_BUILTIN (  URBITS, -1,   ur_ftype_intur,   nothing, \"__ret\")\n+DEF_BUILTIN ( ULRBITS, -1,  ulr_ftype_intulr,  nothing, \"__ret\")\n+DEF_BUILTIN (ULLRBITS, -1, ullr_ftype_intullr, nothing, \"__ret\") // GCC extension\n+\n+DEF_BUILTIN (  HKBITS, -1,   hk_ftype_inthk,   nothing, \"__ret\")\n+DEF_BUILTIN (   KBITS, -1,    k_ftype_intk,    nothing, \"__ret\")\n+DEF_BUILTIN (  LKBITS, -1,   lk_ftype_intlk,   nothing, \"__ret\")\n+DEF_BUILTIN ( LLKBITS, -1,  llk_ftype_intllk,  nothing, \"__ret\") // GCC extension\n+\n+DEF_BUILTIN ( UHKBITS, -1,  uhk_ftype_intuhk,  nothing, \"__ret\")\n+DEF_BUILTIN (  UKBITS, -1,   uk_ftype_intuk,   nothing, \"__ret\")\n+DEF_BUILTIN ( ULKBITS, -1,  ulk_ftype_intulk,  nothing, \"__ret\")\n+DEF_BUILTIN (ULLKBITS, -1, ullk_ftype_intullk, nothing, \"__ret\") // GCC extension\n+\n+/* Overloaded */\n+\n+/* 7.18a.6.7  Type-generic fixed-point functions. */\n+\n+DEF_BUILTIN (ABSFX,     -1, void_ftype_void /* dummy */, nothing, NULL)\n+DEF_BUILTIN (ROUNDFX,   -1, void_ftype_void /* dummy */, nothing, NULL)\n+DEF_BUILTIN (COUNTLSFX, -1, void_ftype_void /* dummy */, nothing, NULL)"}, {"sha": "afcacdfb079c560db8b8794dc0bdbcb5f1c13511", "filename": "gcc/config/avr/stdfix.h", "status": "modified", "additions": 137, "deletions": 340, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Fstdfix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Fconfig%2Favr%2Fstdfix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fstdfix.h?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -35,10 +35,6 @@\n \n #include <stdfix-gcc.h>\n \n-#define _GCC_TYPEPUN(A, B)                      \\\n-  __builtin_memcpy (&A, &B, sizeof (A))\n-\n-/* 7.18a.6  The fixed-point intrinsic functions.  */\n \n #if __SIZEOF_INT__ == 2\n \n@@ -66,8 +62,7 @@ typedef long long unsigned int uint_ulk_t;\n typedef long long int int_llk_t;\n typedef long long unsigned int uint_ullk_t;\n \n-#else /* __SIZEOF_INT__ = 1 (for -mint8) */\n-\n+#elif __SIZEOF_INT__ == 1  /*  -mint8  */\n \n typedef signed char int_hr_t;\n typedef unsigned char uint_uhr_t;\n@@ -84,356 +79,158 @@ typedef long long unsigned int uint_ulr_t;\n typedef long long int int_k_t;\n typedef long long unsigned int uint_uk_t;\n \n-#endif /* __SIZEOF_INT__ == 2 */\n+#endif /* __SIZEOF_INT__ == 1, 2 */\n+\n+\n+/* 7.18a.6  The fixed-point intrinsic functions.  */\n \n \n-/* 7.18a.6.2 The fixed-point absolute value functions. */\n+/* 7.18a.6.2  The fixed-point absolute value functions.  */\n+\n+#define abshr __builtin_avr_abshr\n+#define absr  __builtin_avr_absr\n+#define abslr __builtin_avr_abslr\n+\n+#define abshk __builtin_avr_abshk\n+#define absk  __builtin_avr_absk\n+\n+#if __SIZEOF_INT__ == 2\n+\n+#define abslk  __builtin_avr_abslk\n+#define absllr __builtin_avr_absllr  /* GCC Extension */\n+#define absllk __builtin_avr_absllk  /* GCC Extension */\n \n-/* short fract (hr): abshr */\n+#endif /* sizeof (int) == 2 */\n \n-static __inline__ __attribute__((__always_inline__))\n-short fract abshr (const short fract __q)\n-{\n-  return __builtin_avr_abshr (__q);\n-}\n \n-/* fract (r): absr */\n+/* 7.18a.6.3  The fixed-point round functions.  */\n \n-static __inline__ __attribute__((__always_inline__))\n-fract absr (const fract __q)\n-{\n-  return __builtin_avr_absr (__q);\n-}\n+/* The Embedded-C paper specifies results only for rounding points\n \n-/* long fract (lr): abslr */\n+       0 < RP < FBIT\n+  \n+   As an extension, the following functions work as expected\n+   with rounding points\n \n-static __inline__ __attribute__((__always_inline__))\n-long fract abslr (const long fract __q)\n-{\n-  return __builtin_avr_abslr (__q);\n-}\n+       -IBIT < RP < FBIT\n+ \n+   For example, rounding an accum with a rounding point of -1 will\n+   result in an even integer value.  */\n \n-/* short accum (hk): abshk */\n+#define roundhr  __builtin_avr_roundhr\n+#define roundr   __builtin_avr_roundr\n+#define roundlr  __builtin_avr_roundlr\n \n-static __inline__ __attribute__((__always_inline__))\n-short accum abshk (const short accum __q)\n-{\n-  return __builtin_avr_abshk (__q);\n-}\n+#define rounduhr __builtin_avr_rounduhr\n+#define roundur  __builtin_avr_roundur\n+#define roundulr __builtin_avr_roundulr\n \n-/* accum (k): absk */\n+#define roundhk  __builtin_avr_roundhk\n+#define roundk   __builtin_avr_roundk\n \n-static __inline__ __attribute__((__always_inline__))\n-accum absk (const accum __q)\n-{\n-  return __builtin_avr_absk (__q);\n-}\n+#define rounduhk __builtin_avr_rounduhk\n+#define rounduk  __builtin_avr_rounduk\n \n #if __SIZEOF_INT__ == 2\n \n-/* long long fract (llr): absllr */\n-\n-static __inline__ __attribute__((__always_inline__))\n-long long fract absllr (const long long fract __q) /* GCC extension */\n-{\n-  return __builtin_avr_absllr (__q);\n-}\n-\n-/* long accum (lk): abslk */\n-\n-static __inline__ __attribute__((__always_inline__))\n-long accum abslk (const long accum __q)\n-{\n-  return __builtin_avr_abslk (__q);\n-}\n-\n-/* long long accum (llk): absllk */\n-\n-static __inline__ __attribute__((__always_inline__))\n-long long accum absllk (const long long accum __q) /* GCC extension */\n-{\n-  return __builtin_avr_absllk (__q);\n-}\n-\n-#endif /* __SIZEOF_INT__ == 2 */\n-\n-\n-/* 7.18a.6.5 The bitwise fixed-point to integer conversion functions. */\n-/* 7.18a.6.6 The bitwise integer to fixed-point conversion functions. */\n-\n-/* short fract (hr): bitshr, bitsuhr, hrbits, uhrbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_hr_t bitshr (const short fract __q)\n-{\n-  int_hr_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_uhr_t bitsuhr (const unsigned short fract __q)\n-{\n-  uint_uhr_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-short fract hrbits (const int_hr_t __i)\n-{\n-  short fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned short fract uhrbits (const uint_uhr_t __i)\n-{\n-  unsigned short fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-/* fract (r): bitsr, bitsur, rbits, urbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_r_t bitsr (const fract __q)\n-{\n-  int_r_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_ur_t bitsur (const unsigned fract __q)\n-{\n-  uint_ur_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-fract rbits (const int_r_t __i)\n-{\n-  fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned fract urbits (const uint_ur_t __i)\n-{\n-  unsigned fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-/* long fract (lr): bitslr, bitsulr, lrbits, ulrbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_lr_t bitslr (const long fract __q)\n-{\n-  int_lr_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_ulr_t bitsulr (const unsigned long fract __q)\n-{\n-  uint_ulr_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-long fract lrbits (const int_lr_t __i)\n-{\n-  long fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned long fract ulrbits (const uint_ulr_t __i)\n-{\n-  unsigned long fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-/* short accum (hk): bitshk, bitsuhk, hkbits, uhkbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_hk_t bitshk (const short accum __q)\n-{\n-  int_hk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_uhk_t bitsuhk (const unsigned short accum __q)\n-{\n-  uint_uhk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-short accum hkbits (const int_hk_t __i)\n-{\n-  short accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned short accum uhkbits (const uint_uhk_t __i)\n-{\n-  unsigned short accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-/* accum (k): bitsk, bitsuk, kbits, ukbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_k_t bitsk (const accum __q)\n-{\n-  int_k_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_uk_t bitsuk (const unsigned accum __q)\n-{\n-  uint_uk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-accum kbits (const int_k_t __i)\n-{\n-  accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned accum ukbits (const uint_uk_t __i)\n-{\n-  unsigned accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n+#define roundlk   __builtin_avr_roundlk\n+#define roundulk  __builtin_avr_roundulk\n+#define roundllr  __builtin_avr_roundllr  /* GCC Extension */\n+#define roundullr __builtin_avr_roundullr /* GCC Extension */\n+#define roundllk  __builtin_avr_roundllk  /* GCC Extension */\n+#define roundullk __builtin_avr_roundullk /* GCC Extension */\n+\n+#endif /* sizeof (int) == 2 */\n+\n+\n+/* 7.18a.6.4  The fixed-point bit countls functions.  */\n+\n+#define countlshr  __builtin_avr_countlshr\n+#define countlsr   __builtin_avr_countlsr\n+#define countlslr  __builtin_avr_countlslr\n+\n+#define countlsuhr __builtin_avr_countlsuhr\n+#define countlsur  __builtin_avr_countlsur\n+#define countlsulr __builtin_avr_countlsulr\n+\n+#define countlshk  __builtin_avr_countlshk\n+#define countlsk   __builtin_avr_countlsk\n+\n+#define countlsuhk __builtin_avr_countlsuhk\n+#define countlsuk  __builtin_avr_countlsuk\n \n #if __SIZEOF_INT__ == 2\n \n-/* long long fract (llr): bitsllr, bitsullr, llrbits, ullrbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_llr_t bitsllr (const long long fract __q)\n-{\n-  int_llr_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_ullr_t bitsullr (const unsigned long long fract __q)\n-{\n-  uint_ullr_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-long long fract llrbits (const int_llr_t __i)\n-{\n-  long long fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned long long fract ullrbits (const uint_ullr_t __i)\n-{\n-  unsigned long long fract __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-/* long accum (lk): bitslk, bitsulk, lkbits, ulkbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_lk_t bitslk (const long accum __q)\n-{\n-  int_lk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_ulk_t bitsulk (const unsigned long accum __q)\n-{\n-  uint_ulk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-long accum lkbits (const int_lk_t __i)\n-{\n-  long accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned long accum ulkbits (const uint_ulk_t __i)\n-{\n-  unsigned long accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-/* long long accum (llk): bitsllk, bitsullk, llkbits, ullkbits */\n-\n-static __inline__ __attribute__((__always_inline__))\n-int_llk_t bitsllk (const long long accum __q)\n-{\n-  int_llk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-uint_ullk_t bitsullk (const unsigned long long accum __q)\n-{\n-  uint_ullk_t __result;\n-  _GCC_TYPEPUN (__result, __q);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-long long accum llkbits (const int_llk_t __i)\n-{\n-  long long accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-static __inline__ __attribute__((__always_inline__))\n-unsigned long long accum ullkbits (const uint_ullk_t __i)\n-{\n-  unsigned long long accum __result;\n-  _GCC_TYPEPUN (__result, __i);\n-  return __result;\n-}\n-\n-#endif /* __SIZEOF_INT__ == 2 */\n+#define countlslk   __builtin_avr_countlslk\n+#define countlsulk  __builtin_avr_countlsulk\n+#define countlsllr  __builtin_avr_countlsllr  /* GCC Extension */\n+#define countlsullr __builtin_avr_countlsullr /* GCC Extension */\n+#define countlsllk  __builtin_avr_countlsllk  /* GCC Extension */\n+#define countlsullk __builtin_avr_countlsullk /* GCC Extension */\n+\n+#endif /* sizeof (int) == 2 */\n+\n+\n+/* 7.18a.6.5  The bitwise fixed-point to integer conversion functions. */\n+\n+#define bitshr  __builtin_avr_bitshr\n+#define bitsr   __builtin_avr_bitsr\n+#define bitslr  __builtin_avr_bitslr\n+\n+#define bitsuhr __builtin_avr_bitsuhr\n+#define bitsur  __builtin_avr_bitsur\n+#define bitsulr __builtin_avr_bitsulr\n+\n+#define bitshk  __builtin_avr_bitshk\n+#define bitsk   __builtin_avr_bitsk\n+\n+#define bitsuhk __builtin_avr_bitsuhk\n+#define bitsuk  __builtin_avr_bitsuk\n+\n+#if __SIZEOF_INT__ == 2\n+\n+#define bitslk   __builtin_avr_bitslk\n+#define bitsulk  __builtin_avr_bitsulk\n+#define bitsllr  __builtin_avr_bitsllr  /* GCC Extension */\n+#define bitsullr __builtin_avr_bitsullr /* GCC Extension */\n+#define bitsllk  __builtin_avr_bitsllk  /* GCC Extension */\n+#define bitsullk __builtin_avr_bitsullk /* GCC Extension */\n+\n+#endif /* sizeof (int) == 2 */\n+\n+\n+/* 7.18a.6.6  The bitwise integer to fixed-point conversion functions. */\n+\n+#define hrbits  __builtin_avr_hrbits\n+#define rbits   __builtin_avr_rbits\n+#define lrbits  __builtin_avr_lrbits\n+\n+#define uhrbits __builtin_avr_uhrbits\n+#define urbits  __builtin_avr_urbits\n+#define ulrbits __builtin_avr_ulrbits\n+\n+#define hkbits  __builtin_avr_hkbits\n+#define kbits   __builtin_avr_kbits\n+\n+#define uhkbits __builtin_avr_uhkbits\n+#define ukbits  __builtin_avr_ukbits\n+\n+#if __SIZEOF_INT__ == 2\n+\n+#define lkbits   __builtin_avr_lkbits\n+#define ulkbits  __builtin_avr_ulkbits\n+#define llrbits  __builtin_avr_llrbits  /* GCC Extension */\n+#define ullrbits __builtin_avr_ullrbits /* GCC Extension */\n+#define llkbits  __builtin_avr_llkbits  /* GCC Extension */\n+#define ullkbits __builtin_avr_ullkbits /* GCC Extension */\n+\n+#endif /* sizeof (int) == 2 */\n+\n+\n+/* 7.18a.6.7  Type-generic fixed-point functions.  */\n+\n+#define absfx     __builtin_avr_absfx\n+#define roundfx   __builtin_avr_roundfx\n+#define countlsfx __builtin_avr_countlsfx\n+\n #endif /* _AVRGCC_STDFIX_H */"}, {"sha": "c12303dab8c98762fd1e49a3b485571345bc069e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -1,3 +1,9 @@\n+2013-02-08  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/54222\n+\t* gcc.target/avr/torture/builtins-4-roundfx.c: New test.\n+\t* gcc.target/avr/torture/builtins-5-countlsfx.c: New test.\n+\n 2013-02-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/56241"}, {"sha": "6ad0775553a09a31c9b5bb94a4d6cf10d147af46", "filename": "gcc/testsuite/gcc.target/avr/torture/builtins-4-roundfx.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-4-roundfx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-4-roundfx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-4-roundfx.c?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -0,0 +1,161 @@\n+/* { dg-options \"-std=gnu99\" } */\n+/* { dg-do run } */\n+\n+#include <stdfix.h>\n+\n+extern void abort (void);\n+\n+typedef short _Fract fx_hr_t;\n+typedef _Fract fx_r_t;\n+typedef long _Fract fx_lr_t;\n+typedef long long _Fract fx_llr_t;\n+\n+typedef unsigned short _Fract fx_uhr_t;\n+typedef unsigned _Fract fx_ur_t;\n+typedef unsigned long _Fract fx_ulr_t;\n+typedef unsigned long long _Fract fx_ullr_t;\n+\n+typedef short _Accum fx_hk_t;\n+typedef _Accum fx_k_t;\n+typedef long _Accum fx_lk_t;\n+typedef long long _Accum fx_llk_t;\n+\n+typedef unsigned short _Accum fx_uhk_t;\n+typedef unsigned _Accum fx_uk_t;\n+typedef unsigned long _Accum fx_ulk_t;\n+typedef unsigned long long _Accum fx_ullk_t;\n+\n+\n+typedef unsigned char int_uhr_t;\n+typedef unsigned int int_ur_t;\n+typedef unsigned long int_ulr_t;\n+typedef unsigned long long int_ullr_t;\n+\n+typedef unsigned int int_uhk_t;\n+typedef unsigned long int_uk_t;\n+typedef unsigned long long int_ulk_t;\n+typedef unsigned long long int_ullk_t;\n+\n+\n+#define DEFTEST1(T,FX)                              \\\n+  T test1_##FX (T x, int rp)                        \\\n+  {                                                 \\\n+    return round##FX (x, rp);                       \\\n+  }                                                 \\\n+                                                    \\\n+  unsigned T test1_u##FX (unsigned T x, int rp)     \\\n+  {                                                 \\\n+    return roundu##FX (x, rp);                      \\\n+  }\n+\n+DEFTEST1 (short fract, hr)\n+DEFTEST1 (fract, r)\n+DEFTEST1 (long fract, lr)\n+DEFTEST1 (long long fract, llr)\n+\n+DEFTEST1 (short accum, hk)\n+DEFTEST1 (accum, k)\n+\n+DEFTEST1 (long accum, lk)\n+DEFTEST1 (long long accum, llk)\n+\n+\n+#define TEST2(FX, RP, VAL, ROUND)                                    \\\n+  {                                                                  \\\n+    if (round##FX (FX##bits (VAL), RP) != FX##bits (ROUND))          \\\n+      abort();                                                       \\\n+    fx_##FX##_t (*f)(fx_##FX##_t,int) = round##FX;                   \\\n+    asm (\"\" : \"+r\" (f));                                             \\\n+    if (f (FX##bits (VAL), RP) != FX##bits (ROUND))                  \\\n+      abort();                                                       \\\n+  }\n+\n+static void test2hr (void)\n+{\n+  TEST2 (hr, 1, 0x7f, 0x40);\n+  TEST2 (hr, 2, 0x7f, 0b1100000);\n+  TEST2 (hr, 3, 0x7f, 0b1110000);\n+  TEST2 (hr, 4, 0x7f, 0b1111000);\n+\n+  TEST2 (uhr, 1, 0x7f, 0x80);\n+  TEST2 (uhr, 2, 0x7f, 0x80);\n+  TEST2 (uhr, 3, 0x7f, 0x80);\n+  TEST2 (uhr, 4, 0x7f, 0x80);\n+}\n+\n+void test2k (void)\n+{\n+  TEST2 (k, 1, 0x7fffffff, 0x7fff8000 | 0b100000000000000);\n+  TEST2 (k, 2, 0x7fffffff, 0x7fff8000 | 0b110000000000000);\n+  TEST2 (k, 3, 0x7fffffff, 0x7fff8000 | 0b111000000000000);\n+  TEST2 (k, 4, 0x7fffffff, 0x7fff8000 | 0b111100000000000);\n+\n+  TEST2 (uk, 1, 0x7fffffff, 1ul << 31);\n+  TEST2 (uk, 2, 0x7fffffff, 1ul << 31);\n+  TEST2 (uk, 3, 0x7fffffff, 1ul << 31);\n+  TEST2 (uk, 4, 0x7fffffff, 1ul << 31);\n+}\n+\n+#define DEFTEST3(FX, FBIT)                            \\\n+  void test3##FX (void)                               \\\n+  {                                                   \\\n+    TEST2 (FX, FBIT-1, 0b01100, 0b01100);             \\\n+    TEST2 (FX, FBIT-2, 0b01100, 0b01100);             \\\n+    TEST2 (FX, FBIT-3, 0b01100, 0b10000);             \\\n+    TEST2 (FX, FBIT-4, 0b01100, 0b10000);             \\\n+    TEST2 (FX, FBIT-5, 0b01100, 0);                   \\\n+                                                      \\\n+    if (FX##bits ((int_##FX##_t) -1) > 0)             \\\n+      return;                                         \\\n+                                                      \\\n+    TEST2 (FX, FBIT-1, -0b01100, -0b01100);           \\\n+    TEST2 (FX, FBIT-2, -0b01100, -0b01100);           \\\n+    TEST2 (FX, FBIT-3, -0b01100, -0b01000);           \\\n+    TEST2 (FX, FBIT-4, -0b01100, -0b10000);           \\\n+    TEST2 (FX, FBIT-5, -0b01100, -0b00000);           \\\n+    }\n+\n+DEFTEST3 (hr, SFRACT_FBIT)\n+DEFTEST3 (r, FRACT_FBIT)\n+DEFTEST3 (lr, LFRACT_FBIT)\n+\n+DEFTEST3 (uhr, USFRACT_FBIT)\n+DEFTEST3 (ur, UFRACT_FBIT)\n+DEFTEST3 (ulr, ULFRACT_FBIT)\n+\n+DEFTEST3 (hk, SACCUM_FBIT)\n+DEFTEST3 (k, ACCUM_FBIT)\n+DEFTEST3 (lk, LACCUM_FBIT)\n+DEFTEST3 (llk, LLACCUM_FBIT)\n+\n+DEFTEST3 (uhk, USACCUM_FBIT)\n+DEFTEST3 (uk, UACCUM_FBIT)\n+DEFTEST3 (ulk, ULACCUM_FBIT)\n+DEFTEST3 (ullk, ULLACCUM_FBIT)\n+\n+int main (void)\n+{\n+  test2hr();\n+  test2k();\n+\n+  test3hr();\n+  test3r();\n+  test3lr();\n+\n+  test3uhr();\n+  test3ur();\n+  test3ulr();\n+\n+  test3hk();\n+  test3k();\n+  test3lk();\n+  test3llk();\n+\n+  test3uhk();\n+  test3uk();\n+  test3ulk();\n+  test3ullk();\n+\n+  return 0;\n+}\n+"}, {"sha": "b0ff5e3d48a43719493a06edd3e7e223390d66b7", "filename": "gcc/testsuite/gcc.target/avr/torture/builtins-5-countlsfx.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-5-countlsfx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-5-countlsfx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fbuiltins-5-countlsfx.c?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-options \"-std=gnu99\" } */\n+/* { dg-do run } */\n+\n+#include <stdfix.h>\n+\n+extern void abort (void);\n+\n+#define DEFTEST1(T,FX)                              \\\n+  int test1_##FX (T x)                              \\\n+  {                                                 \\\n+    return countls##FX (x);                         \\\n+  }                                                 \\\n+                                                    \\\n+  int test1_u##FX (unsigned T x)                    \\\n+  {                                                 \\\n+    return countlsu##FX (x);                        \\\n+  }\n+\n+DEFTEST1 (short fract, hr)\n+DEFTEST1 (fract, r)\n+DEFTEST1 (long fract, lr)\n+DEFTEST1 (long long fract, llr)\n+\n+DEFTEST1 (short accum, hk)\n+DEFTEST1 (accum, k)\n+DEFTEST1 (long accum, lk)\n+DEFTEST1 (long long accum, llk)\n+\n+\n+#define TEST2P(FX, VAL, DD)                                             \\\n+  {                                                                     \\\n+    if (countls##FX (FX##bits (VAL)) != 8 * sizeof (0##FX) - DD)        \\\n+      abort();                                                          \\\n+                                                                        \\\n+    if (countlsu##FX (u##FX##bits (VAL)) != 8 * sizeof (0u##FX) + 1 - DD) \\\n+      abort();                                                          \\\n+  }\n+\n+\n+#define TEST2M(FX, VAL, DD)                                             \\\n+  {                                                                     \\\n+    if (countls##FX (FX##bits (VAL)) != 8 * sizeof (0##FX) - (DD))      \\\n+      abort();                                                          \\\n+                                                                        \\\n+    if (countlsu##FX (u##FX##bits (VAL)) != 0)                          \\\n+      abort();                                                          \\\n+  }\n+\n+\n+#define TEST2PX(VAL, DD)                        \\\n+  TEST2P (hr, VAL, DD);                         \\\n+  TEST2P (r,  VAL, DD);                         \\\n+  TEST2P (lr, VAL, DD);                         \\\n+                                                \\\n+  TEST2P (hk, VAL, DD);                         \\\n+  TEST2P (k,  VAL, DD);                         \\\n+  TEST2P (lk, VAL, DD);                         \\\n+  TEST2P (llk, VAL, DD)\n+\n+#define TEST2MX(VAL, DD)                        \\\n+  TEST2M (hr, VAL,  DD);                        \\\n+  TEST2M (r,  VAL,  DD);                        \\\n+  TEST2M (lr, VAL,  DD);                        \\\n+                                                \\\n+  TEST2M (hk,  VAL, DD);                        \\\n+  TEST2M (k,   VAL, DD);                        \\\n+  TEST2M (lk,  VAL, DD);                        \\\n+  TEST2M (llk, VAL, DD)\n+\n+\n+int main (void)\n+{\n+  TEST2PX (1, 2);\n+  TEST2PX (2, 3);\n+  TEST2PX (3, 3);\n+  \n+  TEST2MX (-1, 1);\n+  TEST2MX (-2, 2);\n+  TEST2MX (-3, 3);\n+  \n+  return 0;\n+}"}, {"sha": "13fc01dd31d0568d2006670a2ccf67b7b3ef75fe", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -1,3 +1,17 @@\n+2013-02-08  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/54222\n+\t* config/avr/lib2funcs.c: New C sources for modules for libgcc.a.\n+\t* config/avr/lib2-object.mk: New iterator to build objects from it.\n+\t* config/avr/t-avr: Iterate lib2-object.mk to build objects from\n+\tlib2funcs.c.\n+\t(LIB2FUNCS_EXCLUDE): Add _clrsbdi2.\n+\t(LIB1ASMFUNCS): Add: _ssabs_1, _mask1, _ret, _roundqq3, _rounduqq3,\n+\t_round_s2, _round_u2, _round_2_const, _addmask_2, _round_s4,\n+\t_round_u4, _round_4_const, _addmask_4, _round_x8, _rounddq3\n+\t_roundudq3, _roundda3 _rounduda3, _roundta3 _rounduta3.\n+\t* config/avr/lib1funcs-fixed.S: Implement them.\n+\n 2013-02-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years."}, {"sha": "92d8eaf44f520087f61b2b907e6f7eb947ab10d8", "filename": "libgcc/config/avr/lib1funcs-fixed.S", "status": "modified", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -957,6 +957,28 @@ ENDF __udivusa3\n #undef  r_divHH\n #undef  r_cnt\n \n+\f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Saturation, 1 Byte\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; First Argument and Return Register\n+#define A0  24\n+\n+#if defined (L_ssabs_1)\n+DEFUN __ssabs_1\n+    sbrs    A0, 7\n+    ret\n+    neg     A0\n+    sbrc    A0,7\n+    dec     A0\n+    ret\n+ENDF __ssabs_1\n+#endif /* L_ssabs_1 */\n+\n+#undef A0\n+\n+\n \f\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Saturation, 2 Bytes\n@@ -1176,3 +1198,509 @@ ENDF __sssub_8\n #undef B5\n #undef B6\n #undef B7\n+\n+\f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Rounding Helpers\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+#ifdef L_mask1\n+\n+#define AA 24\n+#define CC 25\n+\n+;; R25 = 1 << (R24 & 7)\n+;; CC  = 1 << (AA  & 7)\n+;; Clobbers: None\n+DEFUN __mask1\n+    ;; CC = 2 ^ AA.1\n+    ldi     CC, 1 << 2\n+    sbrs    AA, 1\n+    ldi     CC, 1 << 0\n+    ;; CC *= 2 ^ AA.0\n+    sbrc    AA, 0\n+    lsl     CC\n+    ;; CC *= 2 ^ AA.2\n+    sbrc    AA, 2\n+    swap    CC\n+    ret\n+ENDF __mask1\n+\n+#undef AA\n+#undef CC\n+#endif /* L_mask1 */\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The rounding point. Any bits smaller than\n+;; 2^{-RP} will be cleared.\n+#define RP R24\n+\n+#define A0 22\n+#define A1 A0 + 1\n+\n+#define C0 24\n+#define C1 C0 + 1\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Rounding, 1 Byte\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+#ifdef L_roundqq3\n+\n+;; R24 = round (R22, R24)\n+;; Clobbers: R22, __tmp_reg__\n+DEFUN  __roundqq3\n+    mov     __tmp_reg__, C1\n+    subi    RP, __QQ_FBIT__ - 1\n+    neg     RP\n+    ;; R25 = 1 << RP  (Total offset is FBIT-1 - RP)\n+    XCALL   __mask1\n+    mov     C0, C1\n+    ;; Add-Saturate 2^{-RP-1}\n+    add     A0, C0\n+    brvc 0f\n+    ldi     A0, 0x7f\n+0:  ;; Mask out bits beyond RP\n+    lsl     C0\n+    neg     C0\n+    and     C0, A0\n+    mov     C1, __tmp_reg__\n+    ret\n+ENDF  __roundqq3\n+#endif /* L_roundqq3 */\n+\n+#ifdef L_rounduqq3\n+\n+;; R24 = round (R22, R24)\n+;; Clobbers: R22, __tmp_reg__\n+DEFUN  __rounduqq3\n+    mov     __tmp_reg__, C1\n+    subi    RP, __UQQ_FBIT__ - 1\n+    neg     RP\n+    ;; R25 = 1 << RP  (Total offset is FBIT-1 - RP)\n+    XCALL   __mask1\n+    mov     C0, C1\n+    ;; Add-Saturate 2^{-RP-1}\n+    add     A0, C0\n+    brcc 0f\n+    ldi     A0, 0xff\n+0:  ;; Mask out bits beyond RP\n+    lsl     C0\n+    neg     C0\n+    and     C0, A0\n+    mov     C1, __tmp_reg__\n+    ret\n+ENDF  __rounduqq3\n+#endif /* L_rounduqq3 */\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Rounding, 2 Bytes\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+#ifdef L_addmask_2\n+\n+;; [ R25:R24 =  1 << (R24 & 15)\n+;;   R23:R22 += 1 << (R24 & 15) ]\n+;; SREG is set according to the addition\n+DEFUN __addmask_2\n+    ;; R25 = 1 << (R24 & 7)\n+    XCALL   __mask1\n+    cpi     RP, 1 << 3\n+    sbc     C0, C0\n+    ;; Swap C0 and C1 if RP.3 was set\n+    and     C0, C1\n+    eor     C1, C0\n+    ;; Finally, add the power-of-two:  A[] += C[]\n+    add     A0, C0\n+    adc     A1, C1\n+    ret\n+ENDF  __addmask_2\n+#endif /* L_addmask_2 */\n+\n+#ifdef L_round_s2\n+\n+;; R25:R24 = round (R23:R22, R24)\n+;; Clobbers: R23, R22\n+DEFUN  __roundhq3\n+    subi    RP, __HQ_FBIT__ - __HA_FBIT__\n+ENDF   __roundhq3\n+DEFUN  __roundha3\n+    subi    RP, __HA_FBIT__ - 1\n+    neg     RP\n+    ;; [ R25:R24  = 1 << (FBIT-1 - RP)\n+    ;;   R23:R22 += 1 << (FBIT-1 - RP) ]\n+    XCALL   __addmask_2\n+    XJMP    __round_s2_const\n+ENDF  __roundha3\n+\n+#endif /* L_round_s2 */\n+\n+#ifdef L_round_u2\n+\n+;; R25:R24 = round (R23:R22, R24)\n+;; Clobbers: R23, R22\n+DEFUN  __rounduhq3\n+    subi    RP, __UHQ_FBIT__ - __UHA_FBIT__\n+ENDF   __rounduhq3\n+DEFUN  __rounduha3\n+    subi    RP, __UHA_FBIT__ - 1\n+    neg     RP\n+    ;; [ R25:R24  = 1 << (FBIT-1 - RP)\n+    ;;   R23:R22 += 1 << (FBIT-1 - RP) ]\n+    XCALL   __addmask_2\n+    XJMP    __round_u2_const \n+ENDF  __rounduha3\n+\n+#endif /* L_round_u2 */\n+\n+\n+#ifdef L_round_2_const\n+\n+;; Helpers for 2 byte wide rounding\n+\n+DEFUN  __round_s2_const\n+    brvc 2f\n+    ldi     A1, 0x7f\n+    rjmp 1f\n+    ;; FALLTHRU (Barrier)\n+ENDF  __round_s2_const\n+\n+DEFUN __round_u2_const\n+    brcc 2f\n+    ldi     A1, 0xff\n+1:\n+    ldi     A0, 0xff\n+2:\n+    ;; Saturation is performed now.\n+    ;; Currently, we have C[] = 2^{-RP-1}\n+    ;; C[] = 2^{-RP}\n+    lsl     C0\n+    rol     C1\n+    ;;      \n+    NEG2    C0\n+    ;; Clear the bits beyond the rounding point.\n+    and     C0, A0\n+    and     C1, A1\n+    ret\n+ENDF  __round_u2_const\n+\n+#endif /* L_round_2_const */\n+\n+#undef A0\n+#undef A1\n+#undef C0\n+#undef C1\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Rounding, 4 Bytes\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+#define A0 18\n+#define A1 A0 + 1\n+#define A2 A0 + 2\n+#define A3 A0 + 3\n+\n+#define C0 22\n+#define C1 C0 + 1\n+#define C2 C0 + 2\n+#define C3 C0 + 3\n+\n+#ifdef L_addmask_4\n+\n+;; [ R25:R22 =  1 << (R24 & 31)\n+;;   R21:R18 += 1 << (R24 & 31) ]\n+;; SREG is set according to the addition\n+DEFUN __addmask_4\n+    ;; R25 = 1 << (R24 & 7)\n+    XCALL   __mask1\n+    cpi     RP, 1 << 4\n+    sbc     C0, C0\n+    sbc     C1, C1\n+    ;; Swap C2 with C3 if RP.3 is not set\n+    cpi     RP, 1 << 3\n+    sbc     C2, C2\n+    and     C2, C3\n+    eor     C3, C2\n+    ;; Swap C3:C2 with C1:C0 if RP.4 is not set\n+    and     C0, C2  $  eor     C2, C0\n+    and     C1, C3  $  eor     C3, C1\n+    ;; Finally, add the power-of-two:  A[] += C[]\n+    add     A0, C0\n+    adc     A1, C1\n+    adc     A2, C2\n+    adc     A3, C3\n+    ret\n+ENDF  __addmask_4\n+#endif /* L_addmask_4 */\n+\n+#ifdef L_round_s4\n+\n+;; R25:R22 = round (R21:R18, R24)\n+;; Clobbers: R18...R21\n+DEFUN  __roundsq3\n+    subi    RP, __SQ_FBIT__ - __SA_FBIT__\n+ENDF   __roundsq3\n+DEFUN  __roundsa3\n+    subi    RP, __SA_FBIT__ - 1\n+    neg     RP\n+    ;; [ R25:R22  = 1 << (FBIT-1 - RP)\n+    ;;   R21:R18 += 1 << (FBIT-1 - RP) ]\n+    XCALL   __addmask_4\n+    XJMP    __round_s4_const\n+ENDF  __roundsa3\n+\n+#endif /* L_round_s4 */\n+\n+#ifdef L_round_u4\n+\n+;; R25:R22 = round (R21:R18, R24)\n+;; Clobbers: R18...R21\n+DEFUN  __roundusq3\n+    subi    RP, __USQ_FBIT__ - __USA_FBIT__\n+ENDF   __roundusq3\n+DEFUN  __roundusa3\n+    subi    RP, __USA_FBIT__ - 1\n+    neg     RP\n+    ;; [ R25:R22  = 1 << (FBIT-1 - RP)\n+    ;;   R21:R18 += 1 << (FBIT-1 - RP) ]\n+    XCALL   __addmask_4\n+    XJMP    __round_u4_const \n+ENDF  __roundusa3\n+\n+#endif /* L_round_u4 */\n+\n+\n+#ifdef L_round_4_const\n+\n+;; Helpers for 4 byte wide rounding\n+\n+DEFUN  __round_s4_const\n+    brvc 2f\n+    ldi     A3, 0x7f\n+    rjmp 1f\n+    ;; FALLTHRU (Barrier)\n+ENDF  __round_s4_const\n+\n+DEFUN __round_u4_const\n+    brcc 2f\n+    ldi     A3, 0xff\n+1:\n+    ldi     A2, 0xff\n+    ldi     A1, 0xff\n+    ldi     A0, 0xff\n+2:\n+    ;; Saturation is performed now.\n+    ;; Currently, we have C[] = 2^{-RP-1}\n+    ;; C[] = 2^{-RP}\n+    lsl     C0\n+    rol     C1\n+    rol     C2\n+    rol     C3\n+    XCALL   __negsi2\n+    ;; Clear the bits beyond the rounding point.\n+    and     C0, A0\n+    and     C1, A1\n+    and     C2, A2\n+    and     C3, A3\n+    ret\n+ENDF  __round_u4_const\n+\n+#endif /* L_round_4_const */\n+\n+#undef A0\n+#undef A1\n+#undef A2\n+#undef A3\n+#undef C0\n+#undef C1\n+#undef C2\n+#undef C3\n+\n+#undef RP\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Rounding, 8 Bytes\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+#define RP     16\n+#define FBITm1 31\n+\n+#define C0 18\n+#define C1 C0 + 1\n+#define C2 C0 + 2\n+#define C3 C0 + 3\n+#define C4 C0 + 4\n+#define C5 C0 + 5\n+#define C6 C0 + 6\n+#define C7 C0 + 7\n+\n+#define A0 16\n+#define A1 17\n+#define A2 26\n+#define A3 27\n+#define A4 28\n+#define A5 29\n+#define A6 30\n+#define A7 31\n+\n+\n+#ifdef L_rounddq3\n+;; R25:R18 = round (R25:R18, R16)\n+;; Clobbers: ABI\n+DEFUN  __rounddq3\n+    ldi     FBITm1, __DQ_FBIT__ - 1\n+    clt\n+    XJMP    __round_x8\n+ENDF  __rounddq3\n+#endif /* L_rounddq3 */\n+\n+#ifdef L_roundudq3\n+;; R25:R18 = round (R25:R18, R16)\n+;; Clobbers: ABI\n+DEFUN  __roundudq3\n+    ldi     FBITm1, __UDQ_FBIT__ - 1\n+    set\n+    XJMP    __round_x8\n+ENDF  __roundudq3\n+#endif /* L_roundudq3 */\n+\n+#ifdef L_roundda3\n+;; R25:R18 = round (R25:R18, R16)\n+;; Clobbers: ABI\n+DEFUN  __roundda3\n+    ldi     FBITm1, __DA_FBIT__ - 1\n+    clt\n+    XJMP    __round_x8\n+ENDF  __roundda3\n+#endif /* L_roundda3 */\n+\n+#ifdef L_rounduda3\n+;; R25:R18 = round (R25:R18, R16)\n+;; Clobbers: ABI\n+DEFUN  __rounduda3\n+    ldi     FBITm1, __UDA_FBIT__ - 1\n+    set\n+    XJMP    __round_x8\n+ENDF  __rounduda3\n+#endif /* L_rounduda3 */\n+\n+#ifdef L_roundta3\n+;; R25:R18 = round (R25:R18, R16)\n+;; Clobbers: ABI\n+DEFUN  __roundta3\n+    ldi     FBITm1, __TA_FBIT__ - 1\n+    clt\n+    XJMP    __round_x8\n+ENDF  __roundta3\n+#endif /* L_roundta3 */\n+\n+#ifdef L_rounduta3\n+;; R25:R18 = round (R25:R18, R16)\n+;; Clobbers: ABI\n+DEFUN  __rounduta3\n+    ldi     FBITm1, __UTA_FBIT__ - 1\n+    set\n+    XJMP    __round_x8\n+ENDF  __rounduta3\n+#endif /* L_rounduta3 */\n+\n+\n+#ifdef L_round_x8\n+DEFUN __round_x8\n+    push r16\n+    push r17\n+    push r28\n+    push r29\n+    ;; Compute log2 of addend from rounding point\n+    sub     RP, FBITm1\n+    neg     RP\n+    ;; Move input to work register A[]\n+    push    C0\n+    mov     A1, C1\n+    wmov    A2, C2\n+    wmov    A4, C4\n+    wmov    A6, C6\n+    ;; C[] = 1 << (FBIT-1 - RP)\n+    XCALL   __clr_8\n+    inc     C0\n+    XCALL   __ashldi3\n+    pop     A0\n+    ;; A[] += C[]\n+    add     A0, C0\n+    adc     A1, C1\n+    adc     A2, C2\n+    adc     A3, C3\n+    adc     A4, C4\n+    adc     A5, C5\n+    adc     A6, C6\n+    adc     A7, C7\n+    brts    1f\n+    ;; Signed\n+    brvc    3f\n+    ;; Signed overflow: A[] = 0x7f...\n+    brvs    2f\n+1:  ;; Unsigned\n+    brcc    3f\n+    ;; Unsigned overflow: A[] = 0xff...\n+2:  ldi     A7, 0xff\n+    ldi     A6, 0xff\n+    wmov    A0, A6\n+    wmov    A2, A6\n+    wmov    A4, A6\n+    bld     A7, 7\n+3:\n+    ;;  C[] = -C[] - C[]\n+    push    A0\n+    ldi     r16, 1\n+    XCALL   __ashldi3\n+    pop     A0\n+    XCALL   __negdi2\n+    ;; Clear the bits beyond the rounding point.\n+    and     C0, A0\n+    and     C1, A1\n+    and     C2, A2\n+    and     C3, A3\n+    and     C4, A4\n+    and     C5, A5\n+    and     C6, A6\n+    and     C7, A7\n+    ;; Epilogue\n+    pop r29\n+    pop r28\n+    pop r17\n+    pop r16\n+    ret\n+ENDF  __round_x8\n+\n+#endif /* L_round_x8 */\n+\n+#undef A0\n+#undef A1\n+#undef A2\n+#undef A3\n+#undef A4\n+#undef A5\n+#undef A6\n+#undef A7\n+\n+#undef C0\n+#undef C1\n+#undef C2\n+#undef C3\n+#undef C4\n+#undef C5\n+#undef C6\n+#undef C7\n+\n+#undef RP\n+#undef FBITm1\n+\n+\n+;; Supply implementations / symbols for the bit-banging functions\n+;; __builtin_avr_bitsfx and __builtin_avr_fxbits\n+#ifdef L_ret\n+DEFUN __ret\n+    ret\n+ENDF  __ret\n+#endif /* L_ret */"}, {"sha": "0a406d580a5e36e38e4f13a3acea9d716355b932", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -1684,12 +1684,12 @@ DEFUN  __divdi3_moddi3\n \n ENDF __divdi3_moddi3\n \n+#endif /* L_divdi3 */\n+\n #undef R_cnt\n #undef SS\n #undef NN\n \n-#endif /* L_divdi3 */\n-\n .section .text.libgcc, \"ax\", @progbits\n \n #define TT __tmp_reg__"}, {"sha": "6a9e04de0f75bf0d969ea3c5d0b904bb9fde78b7", "filename": "libgcc/config/avr/lib2-object.mk", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib2-object.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib2-object.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib2-object.mk?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -0,0 +1,23 @@\n+# This file is included several times in a row, once for each element of\n+# $(iter-items).  On each inclusion, we advance $o to the next element.\n+# $(iter-labels) and $(iter-flags) are also advanced.\n+# This works similar to $(srcdir)/siditi-object.mk.\n+\n+o := $(firstword $(iter-items))\n+iter-items := $(filter-out $o,$(iter-items))\n+\n+$o-label := $(firstword $(iter-labels))\n+iter-labels := $(wordlist 2,$(words $(iter-labels)),$(iter-labels))\n+\n+$o-flag := $(firstword $(iter-flags))\n+iter-flags := $(wordlist 2,$(words $(iter-flags)),$(iter-flags))\n+\n+$o$(objext): %$(objext): $(srcdir)/config/avr/lib2funcs.c\n+\t$(gcc_compile) -DL_$($*-label) -DL_LABEL=$($*-label) $($*-flag) \\\n+\t\t-c $< $(vis_hide)\n+\n+ifeq ($(enable_shared),yes)\n+$(o)_s$(objext): %_s$(objext): $(srcdir)/config/avr/lib2funcs.c\n+\t$(gcc_s_compile) -DL_$($*-label) -DL_LABEL=$($*-label) $($*-flag) \\\n+\t\t-c $<\n+endif"}, {"sha": "83f2e23fb05f13d4859b1a0d90159f1c8f95c818", "filename": "libgcc/config/avr/lib2funcs.c", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib2funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Flib2funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib2funcs.c?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -0,0 +1,226 @@\n+/* Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* This file supplies implementations for some AVR-specific builtin\n+   functions so that code like the following works as expected:\n+\n+   int (*f (void))(_Fract)\n+   {\n+       return __builtin_avr_countlsr;\n+   }\n+\n+   In this specific case, the generated code is:\n+\n+   f:\n+       ldi r24,lo8(gs(__countlsHI))\n+       ldi r25,hi8(gs(__countlsHI))\n+       ret\n+*/\n+\n+/* Map fixed-point suffix to the corresponding fixed-point type.  */\n+\n+typedef short _Fract fx_hr_t;\n+typedef _Fract fx_r_t;\n+typedef long _Fract fx_lr_t;\n+typedef long long _Fract fx_llr_t;\n+\n+typedef unsigned short _Fract fx_uhr_t;\n+typedef unsigned _Fract fx_ur_t;\n+typedef unsigned long _Fract fx_ulr_t;\n+typedef unsigned long long _Fract fx_ullr_t;\n+\n+typedef short _Accum fx_hk_t;\n+typedef _Accum fx_k_t;\n+typedef long _Accum fx_lk_t;\n+typedef long long _Accum fx_llk_t;\n+\n+typedef unsigned short _Accum fx_uhk_t;\n+typedef unsigned _Accum fx_uk_t;\n+typedef unsigned long _Accum fx_ulk_t;\n+typedef unsigned long long _Accum fx_ullk_t;\n+\n+/* Map fixed-point suffix to the corresponding natural integer type.  */\n+\n+typedef char int_hr_t;\n+typedef int int_r_t;\n+typedef long int_lr_t;\n+typedef long long int_llr_t;\n+\n+typedef unsigned char int_uhr_t;\n+typedef unsigned int int_ur_t;\n+typedef unsigned long int_ulr_t;\n+typedef unsigned long long int_ullr_t;\n+\n+typedef int int_hk_t;\n+typedef long int_k_t;\n+typedef long long int_lk_t;\n+typedef long long int_llk_t;\n+\n+typedef unsigned int int_uhk_t;\n+typedef unsigned long int_uk_t;\n+typedef unsigned long long int_ulk_t;\n+typedef unsigned long long int_ullk_t;\n+\n+/* Map mode to the corresponding integer type.  */\n+\n+typedef char int_qi_t;\n+typedef int int_hi_t;\n+typedef long int_si_t;\n+typedef long long int_di_t;\n+\n+typedef unsigned char uint_qi_t;\n+typedef unsigned int uint_hi_t;\n+typedef unsigned long uint_si_t;\n+typedef unsigned long long uint_di_t;\n+\n+\n+\f\n+/************************************************************************/\n+\n+/* Supply implementations / symbols for __builtin_roundFX ASM_NAME.  */\n+\n+#ifdef L_round\n+\n+#define ROUND1(FX)                              \\\n+  ROUND2 (FX)\n+\n+#define ROUND2(FX)                                                      \\\n+  extern fx_## FX ##_t __round## FX (fx_## FX ##_t x, int rpoint);      \\\n+                                                                        \\\n+  fx_## FX ##_t                                                         \\\n+  __round## FX (fx_## FX ##_t x, int rpoint)                            \\\n+  {                                                                     \\\n+    return __builtin_avr_round ##FX (x, rpoint);                        \\\n+  }\n+\n+ROUND1(L_LABEL)\n+\n+#endif /* L_round */\n+\n+\n+\f\n+/*********************************************************************/\n+\n+/* Implement some count-leading-redundant-sign-bits to be used with\n+   coundlsFX implementation.  */\n+\n+#ifdef L__clrsbqi\n+extern int __clrsbqi2 (char x);\n+\n+int\n+__clrsbqi2 (char x)\n+{\n+  int ret;\n+\n+  if (x < 0)\n+    x = ~x;\n+\n+  if (x == 0)\n+    return 8 * sizeof (x) -1;\n+\n+  ret = __builtin_clz (x << 8);\n+  return ret - 1;\n+}\n+#endif /* L__clrsbqi */\n+\n+\n+#ifdef L__clrsbdi\n+extern int __clrsbdi2 (long long x);\n+\n+int\n+__clrsbdi2 (long long x)\n+{\n+  int ret;\n+\n+  if (x < 0LL)\n+    x = ~x;\n+\n+  if (x == 0LL)\n+    return 8 * sizeof (x) -1;\n+\n+  ret = __builtin_clzll ((unsigned long long) x);\n+  return ret - 1;\n+}\n+#endif /* L__clrsbdi */\n+\n+\n+\f\n+/*********************************************************************/\n+\n+/* Supply implementations / symbols for __builtin_avr_countlsFX.  */\n+\n+/* Signed */\n+\n+#ifdef L_countls\n+\n+#define COUNTLS1(MM)                            \\\n+  COUNTLS2 (MM)\n+\n+#define COUNTLS2(MM)                                                    \\\n+  extern int __countls## MM ##2 (int_## MM ##_t);                       \\\n+  extern int __clrsb## MM ##2 (int_## MM ##_t);                         \\\n+                                                                        \\\n+  int                                                                   \\\n+  __countls## MM ##2 (int_## MM ##_t x)                                 \\\n+  {                                                                     \\\n+    if (x == 0)                                                         \\\n+      return __INT8_MAX__;                                              \\\n+                                                                        \\\n+    return __clrsb## MM ##2 (x);                                        \\\n+  }\n+\n+COUNTLS1(L_LABEL)\n+\n+#endif /* L_countls */\n+\n+/* Unsigned */\n+\n+#ifdef L_countlsu\n+\n+#define clz_qi2 __builtin_clz /* unused, avoid warning */\n+#define clz_hi2 __builtin_clz\n+#define clz_si2 __builtin_clzl\n+#define clz_di2 __builtin_clzll\n+\n+#define COUNTLS1(MM)                            \\\n+  COUNTLS2 (MM)\n+\n+#define COUNTLS2(MM)                                                    \\\n+  extern int __countlsu## MM ##2 (uint_## MM ##_t);                     \\\n+                                                                        \\\n+  int                                                                   \\\n+  __countlsu## MM ##2 (uint_## MM ##_t x)                               \\\n+  {                                                                     \\\n+    if (x == 0)                                                         \\\n+      return __INT8_MAX__;                                              \\\n+                                                                        \\\n+    if (sizeof (x) == 1)                                                \\\n+      return clz_hi2 (x << 8);                                          \\\n+    else                                                                \\\n+      return clz_## MM ##2 (x);                                         \\\n+  }\n+\n+COUNTLS1(L_LABEL)\n+\n+#endif /* L_countlsu */"}, {"sha": "a4b8113e02e3822e94bf141f00a742a39bfd4968", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 88, "deletions": 6, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d768f349087f3766ff84054ec7b3403c52ac7a/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=85d768f349087f3766ff84054ec7b3403c52ac7a", "patch": "@@ -75,13 +75,24 @@ LIB1ASMFUNCS += \\\n \t_divsa3 _udivusa3 \\\n \t_clr_8 \\\n \t_ssneg_2 _ssneg_4 _ssneg_8 \\\n-\t_ssabs_2 _ssabs_4 _ssabs_8 \\\n+\t_ssabs_1 _ssabs_2 _ssabs_4 _ssabs_8 \\\n \t_ssadd_8 _sssub_8 \\\n-\t_usadd_8 _ussub_8\n+\t_usadd_8 _ussub_8 \\\n+\t_mask1 _ret \\\n+\t_roundqq3 _rounduqq3 \\\n+\t_round_s2 _round_u2 _round_2_const _addmask_2 \\\n+\t_round_s4 _round_u4 _round_4_const _addmask_4 \\\n+\t_round_x8 \\\n+\t_rounddq3 _roundudq3 \\\n+\t_roundda3 _rounduda3 \\\n+\t_roundta3 _rounduta3 \\\n+\n \n LIB2FUNCS_EXCLUDE = \\\n \t_moddi3 _umoddi3 \\\n-\t_clz\n+\t_clz \\\n+\t_clrsbdi2 \\\n+\n \n # We do not have the DF type.\n # Most of the C functions in libgcc2 use almost all registers,\n@@ -106,13 +117,84 @@ ifeq ($(enable_shared),yes)\n libgcc-s-objects += $(patsubst %,%_s$(objext),$(hiintfuncs16))\n endif\n \n-\n-# Filter out supported conversions from fixed-bit.c\n-# Also filter out TQ and UTQ.\n+###\n \n conv_XY=$(conv)$(mode1)$(mode2)\n func_X=$(func)$(mode)\n \n+# Compile C functions from lib2funcs.c and add them to libgcc.a.\n+#\n+# Some functions which are not performance.critical are more convenient\n+# to implement in C than in assembler.  Most of them serve as implementation\n+# for AVR-specific builtins in the case where the address of a builtin\n+# function is taken or if there is no insn that implements the builtin.\n+#\n+# We don't use LIB2ADD because we want to iterate over the source for\n+# different modes, fixed-point suffixes, etc.  See iter-labels and L_LABEL.\n+# iter-label will get one more underscore in order to avoid too short\n+# labels like -DLk and we use -DL_k instead.\n+\n+# Build roundFX functions from lib2funcs.c\n+\n+round_suffix :=  hr r lr uhr ur ulr  \\\n+\t\t hk k    uhk uk \n+round_funcs  := $(foreach func,_round,\\\n+\t\t$(foreach mode,$(round_suffix),$(func_X)))\n+\n+iter-items  := $(round_funcs)\n+iter-labels := $(round_suffix)\n+iter-flags  := $(patsubst %,-DL_round,$(iter-items))\n+\n+include $(srcdir)/empty.mk $(patsubst %,$(srcdir)/config/avr/lib2-object.mk,$(iter-items))\n+\n+libgcc-objects += $(patsubst %,%$(objext),$(round_funcs))\n+\n+# Build clrsbXX functions from lib2funcs.c\n+\n+clrsb_modes := qi di\n+clrsb_funcs := $(foreach func,_clrsb,\\\n+\t       $(foreach mode,$(clrsb_modes),$(func_X)))\n+\n+iter-items  := $(clrsb_funcs)\n+iter-labels := $(clrsb_funcs)\n+iter-flags  := $(patsubst %,-DL_clrsb,$(iter-items))\n+\n+include $(srcdir)/empty.mk $(patsubst %,$(srcdir)/config/avr/lib2-object.mk,$(iter-items))\n+\n+libgcc-objects += $(patsubst %,%$(objext),$(clrsb_funcs))\n+\n+# Build signed countlsFX functions from lib2funcs.c\n+\n+countls_modes := qi hi si di\n+countls_funcs := $(foreach func,_countls,\\\n+\t\t $(foreach mode,$(countls_modes),$(func_X)))\n+\n+iter-items  := $(countls_funcs)\n+iter-labels := $(countls_modes)\n+iter-flags  := $(patsubst %,-DL_countls,$(iter-items))\n+\n+include $(srcdir)/empty.mk $(patsubst %,$(srcdir)/config/avr/lib2-object.mk,$(iter-items))\n+\n+libgcc-objects += $(patsubst %,%$(objext),$(countls_funcs))\n+\n+# Build unsigned countlsFX functions from lib2funcs.c\n+\n+countlsu_modes := qi hi si di\n+countlsu_funcs := $(foreach func,_countlsu,\\\n+\t\t  $(foreach mode,$(countlsu_modes),$(func_X)))\n+\n+iter-items  := $(countlsu_funcs)\n+iter-labels := $(countlsu_modes)\n+iter-flags  := $(patsubst %,-DL_countlsu,$(iter-items))\n+\n+include $(srcdir)/empty.mk $(patsubst %,$(srcdir)/config/avr/lib2-object.mk,$(iter-items))\n+\n+libgcc-objects += $(patsubst %,%$(objext),$(countlsu_funcs))\n+\n+\n+# Filter out supported conversions from fixed-bit.c\n+# Also filter out TQ and UTQ.\n+\n # Conversions supported by the compiler\n \n convf_modes =\t QI UQI QQ UQQ \\"}]}