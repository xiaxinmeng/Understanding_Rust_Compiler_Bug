{"sha": "e5d70561615053783f54a504b3bafa6aa31d9e0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVkNzA1NjE2MTUwNTM3ODNmNTRhNTA0YjNiYWZhNmFhMzFkOWUwZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T19:55:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T19:55:08Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1467", "tree": {"sha": "32200ebab1d858a9eda1a7bd927dffb946b9935e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32200ebab1d858a9eda1a7bd927dffb946b9935e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5d70561615053783f54a504b3bafa6aa31d9e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d70561615053783f54a504b3bafa6aa31d9e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5d70561615053783f54a504b3bafa6aa31d9e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5d70561615053783f54a504b3bafa6aa31d9e0d/comments", "author": null, "committer": null, "parents": [{"sha": "3245eea08ab719267d7f74ffba7043130dde8478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3245eea08ab719267d7f74ffba7043130dde8478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3245eea08ab719267d7f74ffba7043130dde8478"}], "stats": {"total": 127, "additions": 74, "deletions": 53}, "files": [{"sha": "3c018e50504c707648f75eb6ca09474502d470d8", "filename": "gcc/calls.c", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d70561615053783f54a504b3bafa6aa31d9e0d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d70561615053783f54a504b3bafa6aa31d9e0d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e5d70561615053783f54a504b3bafa6aa31d9e0d", "patch": "@@ -264,8 +264,8 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n      rtx use_insns;\n      int is_const;\n {\n-  rtx stack_size_rtx = gen_rtx (CONST_INT, VOIDmode, stack_size);\n-  rtx struct_value_size_rtx = gen_rtx (CONST_INT, VOIDmode, struct_value_size);\n+  rtx stack_size_rtx = GEN_INT (stack_size);\n+  rtx struct_value_size_rtx = GEN_INT (struct_value_size);\n   rtx call_insn;\n   int already_popped = 0;\n \n@@ -280,8 +280,7 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n   if (HAVE_call_pop && HAVE_call_value_pop\n       && (RETURN_POPS_ARGS (funtype, stack_size) > 0 || stack_size == 0))\n     {\n-      rtx n_pop = gen_rtx (CONST_INT, VOIDmode, \n-\t\t\t   RETURN_POPS_ARGS (funtype, stack_size));\n+      rtx n_pop = GEN_INT (RETURN_POPS_ARGS (funtype, stack_size));\n       rtx pat;\n \n       /* If this subroutine pops its own args, record that in the call insn\n@@ -346,7 +345,7 @@ emit_call_1 (funexp, funtype, stack_size, struct_value_size, next_arg_reg,\n       if (!already_popped)\n \temit_insn (gen_rtx (CLOBBER, VOIDmode, stack_pointer_rtx));\n       stack_size -= RETURN_POPS_ARGS (funtype, stack_size);\n-      stack_size_rtx = gen_rtx (CONST_INT, VOIDmode, stack_size);\n+      stack_size_rtx = GEN_INT (stack_size);\n     }\n \n   if (stack_size != 0)\n@@ -652,13 +651,12 @@ expand_call (exp, target, ignore)\n #endif\n \t\t  start_sequence ();\n \t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n-\t\t  allocate_dynamic_stack_space (gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t\t adjust),\n-\t\t\t\t\t\t0, BITS_PER_UNIT);\n+\t\t  allocate_dynamic_stack_space (GEN_INT (adjust),\n+\t\t\t\t\t\tNULL_RTX, BITS_PER_UNIT);\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \t\t  emit_insns_before (seq, NEXT_INSN (before_call));\n-\t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n+\t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n \t\t}\n \t    }\n #endif\n@@ -767,7 +765,7 @@ expand_call (exp, target, ignore)\n   push_temp_slots ();\n \n   /* Start updating where the next arg would go.  */\n-  INIT_CUMULATIVE_ARGS (args_so_far, funtype, 0);\n+  INIT_CUMULATIVE_ARGS (args_so_far, funtype, NULL_PTR);\n \n   /* If struct_value_rtx is 0, it means pass the address\n      as if it were an extra parameter.  */\n@@ -877,18 +875,18 @@ expand_call (exp, target, ignore)\n \t    {\n \t      /* This is a variable-sized object.  Make space on the stack\n \t\t for it.  */\n-\t      rtx size_rtx = expand_expr (size_in_bytes (type), 0,\n+\t      rtx size_rtx = expand_expr (size_in_bytes (type), NULL_RTX,\n \t\t\t\t\t  VOIDmode, 0);\n \n \t      if (old_stack_level == 0)\n \t\t{\n-\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n+\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n \t\t  old_pending_adj = pending_stack_adjust;\n \t\t  pending_stack_adjust = 0;\n \t\t}\n \n \t      copy = gen_rtx (MEM, BLKmode,\n-\t\t\t      allocate_dynamic_stack_space (size_rtx, 0,\n+\t\t\t      allocate_dynamic_stack_space (size_rtx, NULL_RTX,\n \t\t\t\t\t\t\t    TYPE_ALIGN (type)));\n \t    }\n \t  else\n@@ -1122,7 +1120,7 @@ expand_call (exp, target, ignore)\n \t    && calls_alloca (args[i].tree_value)))\n       {\n \targs[i].initial_value = args[i].value\n-\t  = expand_expr (args[i].tree_value, 0, VOIDmode, 0);\n+\t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n \tpreserve_temp_slots (args[i].value);\n \tfree_temp_slots ();\n \n@@ -1143,7 +1141,7 @@ expand_call (exp, target, ignore)\n     {\n       if (old_stack_level == 0)\n \t{\n-\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n+\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n \t  old_pending_adj = pending_stack_adjust;\n \t  pending_stack_adjust = 0;\n #ifdef ACCUMULATE_OUTGOING_ARGS\n@@ -1235,7 +1233,7 @@ expand_call (exp, target, ignore)\n       if (needed == 0)\n \targblock = virtual_outgoing_args_rtx;\n       else\n-\targblock = push_block (gen_rtx (CONST_INT, VOIDmode, needed), 0, 0);\n+\targblock = push_block (GEN_INT (needed), 0, 0);\n \n       /* We only really need to call `copy_to_reg' in the case where push\n \t insns are going to be used to pass ARGBLOCK to a function\n@@ -1255,14 +1253,13 @@ expand_call (exp, target, ignore)\n   if (stack_arg_under_construction)\n     {\n #if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n-      rtx push_size = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       reg_parm_stack_space + args_size.constant);\n+      rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n #else\n-      rtx push_size = gen_rtx (CONST_INT, VOIDmode, args_size.constant);\n+      rtx push_size = GEN_INT (args_size.constant);\n #endif\n       if (old_stack_level == 0)\n \t{\n-\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n+\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n \t  old_pending_adj = pending_stack_adjust;\n \t  pending_stack_adjust = 0;\n \t  /* stack_arg_under_construction says whether a stack arg is\n@@ -1275,7 +1272,7 @@ expand_call (exp, target, ignore)\n \t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n \t  highest_outgoing_arg_in_use = 0;\n \t}\n-      allocate_dynamic_stack_space (push_size, 0, BITS_PER_UNIT);\n+      allocate_dynamic_stack_space (push_size, NULL_RTX, BITS_PER_UNIT);\n     }\n   /* If argument evaluation might modify the stack pointer, copy the\n      address of the argument list to a register.  */\n@@ -1334,9 +1331,8 @@ expand_call (exp, target, ignore)\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n-    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t(args_size.constant\n-\t\t\t\t - original_args_size.constant)));\n+    anti_adjust_stack (GEN_INT (args_size.constant\n+\t\t\t\t- original_args_size.constant));\n #endif\n #endif\n \n@@ -1352,7 +1348,7 @@ expand_call (exp, target, ignore)\n   else\n     /* Generate an rtx (probably a pseudo-register) for the address.  */\n     {\n-      funexp = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+      funexp = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n       free_temp_slots ();\t/* FUNEXP can't be BLKmode */\n       emit_queue ();\n     }\n@@ -1379,7 +1375,8 @@ expand_call (exp, target, ignore)\n \n \tif (args[i].value == 0)\n \t  {\n-\t    args[i].value = expand_expr (args[i].tree_value, 0, VOIDmode, 0);\n+\t    args[i].value = expand_expr (args[i].tree_value, NULL_RTX,\n+\t\t\t\t\t VOIDmode, 0);\n \t    preserve_temp_slots (args[i].value);\n \t    free_temp_slots ();\n \n@@ -1428,7 +1425,7 @@ expand_call (exp, target, ignore)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 1);\n \t  emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t   gen_rtx (CONST_INT, VOIDmode, num_to_save),\n+\t\t\t   GEN_INT (num_to_save),\n \t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n \t}\n       else\n@@ -1464,9 +1461,8 @@ expand_call (exp, target, ignore)\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)\n-    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t(args_size.constant\n-\t\t\t\t - original_args_size.constant)));\n+    anti_adjust_stack (GEN_INT (args_size.constant\n+\t\t\t\t- original_args_size.constant));\n #endif\n #endif\n \n@@ -1475,15 +1471,16 @@ expand_call (exp, target, ignore)\n      passed in registers.  */\n #if ! defined(ALLOCATE_OUTGOING_ARGS) && defined(OUTGOING_REG_PARM_STACK_SPACE)\n   if (must_preallocate == 0 && reg_parm_stack_space > 0)\n-    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode, reg_parm_stack_space));\n+    anti_adjust_stack (GEN_INT (reg_parm_stack_space));\n #endif\n \n   /* Pass the function the address in which to return a structure value.  */\n   if (structure_value_addr && ! structure_value_addr_parm)\n     {\n       emit_move_insn (struct_value_rtx,\n \t\t      force_reg (Pmode,\n-\t\t\t\t force_operand (structure_value_addr, 0)));\n+\t\t\t\t force_operand (structure_value_addr,\n+\t\t\t\t\t\tNULL_RTX)));\n       if (GET_CODE (struct_value_rtx) == REG)\n \t{\n \t  push_to_sequence (use_insns);\n@@ -1675,7 +1672,7 @@ expand_call (exp, target, ignore)\n \n   if (old_stack_level)\n     {\n-      emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n+      emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n       pending_stack_adjust = old_pending_adj;\n #ifdef ACCUMULATE_OUTGOING_ARGS\n       stack_arg_under_construction = old_stack_arg_under_construction;\n@@ -1699,9 +1696,8 @@ expand_call (exp, target, ignore)\n \t    emit_move_insn (stack_area, save_area);\n \t  else\n \t    emit_block_move (stack_area, validize_mem (save_area),\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t      high_to_save - low_to_save + 1,\n-\t\t\t\t      PARM_BOUNDARY / BITS_PER_UNIT));\n+\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n \t}\n #endif\n \t  \n@@ -1719,8 +1715,7 @@ expand_call (exp, target, ignore)\n \t      emit_move_insn (stack_area, args[i].save_area);\n \t    else\n \t      emit_block_move (stack_area, validize_mem (args[i].save_area),\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\targs[i].size.constant),\n+\t\t\t       GEN_INT (args[i].size.constant),\n \t\t\t       PARM_BOUNDARY / BITS_PER_UNIT);\n \t  }\n \n@@ -1734,7 +1729,7 @@ expand_call (exp, target, ignore)\n      for non-local gotos. */\n \n   if (may_be_alloca && nonlocal_goto_handler_slot != 0)\n-    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n+    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n \n   pop_temp_slots ();\n \n@@ -1861,8 +1856,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \t      arg->save_area = assign_stack_temp (BLKmode,\n \t\t\t\t\t\t  arg->size.constant, 1);\n \t      emit_block_move (validize_mem (arg->save_area), stack_area,\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\targ->size.constant),\n+\t\t\t       GEN_INT (arg->size.constant),\n \t\t\t       PARM_BOUNDARY / BITS_PER_UNIT);\n \t    }\n \t  else\n@@ -1916,7 +1910,8 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n       if (arg->pass_on_stack)\n \tstack_arg_under_construction++;\n #endif\n-      arg->value = expand_expr (pval, partial ? 0 : arg->stack, VOIDmode, 0);\n+      arg->value = expand_expr (pval, partial ? NULL_RTX : arg->stack,\n+\t\t\t\tVOIDmode, 0);\n #ifdef ACCUMULATE_OUTGOING_ARGS\n       if (arg->pass_on_stack)\n \tstack_arg_under_construction--;\n@@ -1994,7 +1989,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \t     emit_push_insn for BLKmode is careful to avoid it.  */\n \t  excess = (arg->size.constant - TREE_INT_CST_LOW (size)\n \t\t    + partial * UNITS_PER_WORD);\n-\t  size_rtx = expand_expr (size, 0, VOIDmode, 0);\n+\t  size_rtx = expand_expr (size, NULL_RTX, VOIDmode, 0);\n \t}\n \n       emit_push_insn (arg->value, TYPE_MODE (TREE_TYPE (pval)),"}, {"sha": "209fbf3df0010d8866e44052c3d203e2e6b2e7be", "filename": "gcc/tree.h", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5d70561615053783f54a504b3bafa6aa31d9e0d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5d70561615053783f54a504b3bafa6aa31d9e0d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e5d70561615053783f54a504b3bafa6aa31d9e0d", "patch": "@@ -117,6 +117,16 @@ typedef union tree_node *tree;\n \n #define NULL_TREE (tree) NULL\n \n+/* Define a generic NULL if one hasn't already been defined.  */\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR (char *) NULL\n+#endif\n+\n /* Every kind of tree node starts with this structure,\n    so all nodes have these fields.\n \n@@ -312,28 +322,32 @@ struct tree_common\n \f\n /* Define additional fields and accessors for nodes representing constants.  */\n \n-/* In an INTEGER_CST node.  These two together make a 64 bit integer.\n-   If the data type is signed, the value is sign-extended to 64 bits\n+/* In an INTEGER_CST node.  These two together make a 2-word integer.\n+   If the data type is signed, the value is sign-extended to 2 words\n    even though not all of them may really be in use.\n-   In an unsigned constant shorter than 64 bits, the extra bits are 0.  */\n+   In an unsigned constant shorter than 2 words, the extra bits are 0.  */\n #define TREE_INT_CST_LOW(NODE) ((NODE)->int_cst.int_cst_low)\n #define TREE_INT_CST_HIGH(NODE) ((NODE)->int_cst.int_cst_high)\n \n #define INT_CST_LT(A, B)  \\\n (TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\t\t\\\n  || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\t\\\n-     && ((unsigned) TREE_INT_CST_LOW (A) < (unsigned) TREE_INT_CST_LOW (B))))\n+     && ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (A)\t\t\\\n+\t < (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (B))))\n \n #define INT_CST_LT_UNSIGNED(A, B)  \\\n-((unsigned) TREE_INT_CST_HIGH (A) < (unsigned) TREE_INT_CST_HIGH (B)\t  \\\n- || ((unsigned) TREE_INT_CST_HIGH (A) == (unsigned) TREE_INT_CST_HIGH (B) \\\n-     && ((unsigned) TREE_INT_CST_LOW (A) < (unsigned) TREE_INT_CST_LOW (B))))\n+(((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n+  < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n+ || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n+      == (unsigned HOST_WIDE_INT ) TREE_INT_CST_HIGH (B)) \\\n+     && (((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (A)\t\\\n+\t  < (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (B)))))\n \n struct tree_int_cst\n {\n   char common[sizeof (struct tree_common)];\n-  long int_cst_low;\n-  long int_cst_high;\n+  HOST_WIDE_INT int_cst_low;\n+  HOST_WIDE_INT int_cst_high;\n };\n \n /* In REAL_CST, STRING_CST, COMPLEX_CST nodes, and CONSTRUCTOR nodes,\n@@ -856,6 +870,15 @@ union tree_node\n #define CONSTRUCTOR_NAME_FORMAT \"_GLOBAL_.I.%s\"\n #endif\n \f\n+/* The following functions accept a wide integer argument.  Rather than\n+   having to cast on every function call, we use a macro instead, that is\n+   defined here and in rtl.h.  */\n+\n+#ifndef exact_log2\n+#define exact_log2(N) exact_log2_wide ((HOST_WIDE_INT) (N))\n+#define floor_log2(N) floor_log2_wide ((HOST_WIDE_INT) (N))\n+#endif\n+\n extern char *oballoc ();\n extern char *permalloc ();\n extern char *savealloc ();\n@@ -890,7 +913,10 @@ extern tree get_identifier ();\n \n /* Construct various types of nodes.  */\n \n-extern tree build_int_2 ();\n+#define build_int_2(LO,HI)  \\\n+  build_int_2_wide ((HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))\n+\n+extern tree build_int_2_wide ();\n extern tree build_real ();\n extern tree build_real_from_string ();\n extern tree build_real_from_int_cst ();"}]}