{"sha": "b78e0ce28b32a1b89886219c557506aeae6caffc", "node_id": "C_kwDOANBUbNoAKGI3OGUwY2UyOGIzMmExYjg5ODg2MjE5YzU1NzUwNmFlYWU2Y2FmZmM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-03-24T20:37:13Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-03-27T17:50:31Z"}, "message": "libstdc++: Define std::expected for C++23 (P0323R12)\n\nBecause this adds a new class template called std::unexpected, we have\nto stop declaring the std::unexpected() function (which was deprecated\nin C++11 and removed in C++17).\n\nlibstdc++-v3/ChangeLog:\n\n\t* doc/doxygen/user.cfg.in: Add new header.\n\t* include/Makefile.am: Likewise.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Add new header.\n\t* include/std/version (__cpp_lib_expected): Define.\n\t* libsupc++/exception [__cplusplus > 202002] (unexpected)\n\t(unexpected_handler, set_unexpected): Do not declare for C++23.\n\t* include/std/expected: New file.\n\t* testsuite/20_util/expected/assign.cc: New test.\n\t* testsuite/20_util/expected/cons.cc: New test.\n\t* testsuite/20_util/expected/illformed_neg.cc: New test.\n\t* testsuite/20_util/expected/observers.cc: New test.\n\t* testsuite/20_util/expected/requirements.cc: New test.\n\t* testsuite/20_util/expected/swap.cc: New test.\n\t* testsuite/20_util/expected/synopsis.cc: New test.\n\t* testsuite/20_util/expected/unexpected.cc: New test.\n\t* testsuite/20_util/expected/version.cc: New test.", "tree": {"sha": "8c5b093cdb25333a6b26608b418a38dd8033b82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c5b093cdb25333a6b26608b418a38dd8033b82f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b78e0ce28b32a1b89886219c557506aeae6caffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78e0ce28b32a1b89886219c557506aeae6caffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78e0ce28b32a1b89886219c557506aeae6caffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78e0ce28b32a1b89886219c557506aeae6caffc/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2906412ada87a4bdd6410060bc18a2c53c419b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2906412ada87a4bdd6410060bc18a2c53c419b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2906412ada87a4bdd6410060bc18a2c53c419b7"}], "stats": {"total": 2316, "additions": 2315, "deletions": 1}, "files": [{"sha": "85955f883909186a434d25129c13b1133fb634a5", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -858,6 +858,7 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/concepts \\\n                          include/condition_variable \\\n                          include/deque \\\n+                         include/expected \\\n                          include/filesystem \\\n                          include/forward_list \\\n                          include/fstream \\"}, {"sha": "77eea7d61e8c3086be278faac0e9ee5facba2bc4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -42,6 +42,7 @@ std_headers = \\\n \t${std_srcdir}/coroutine \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n+\t${std_srcdir}/expected \\\n \t${std_srcdir}/filesystem \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\"}, {"sha": "01bf3e0eb32c68a906393a3785e7348524fa8e3a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -400,6 +400,7 @@ std_headers = \\\n \t${std_srcdir}/coroutine \\\n \t${std_srcdir}/deque \\\n \t${std_srcdir}/execution \\\n+\t${std_srcdir}/expected \\\n \t${std_srcdir}/filesystem \\\n \t${std_srcdir}/forward_list \\\n \t${std_srcdir}/fstream \\"}, {"sha": "6d6d2ad7c4c159af2359353ce36d8f0291aa8dee", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -153,5 +153,6 @@\n #endif\n \n #if __cplusplus > 202002L\n+#include <expected>\n #include <spanstream>\n #endif"}, {"sha": "39d07cda4a9551d540c4bf7061b159ba257121b5", "filename": "libstdc++-v3/include/std/expected", "status": "added", "additions": 1240, "deletions": 0, "changes": 1240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexpected?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,1240 @@\n+// <expected> -*- C++ -*-\n+\n+// Copyright The GNU Toolchain Authors\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/expected\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPECTED\n+#define _GLIBCXX_EXPECTED\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 202002L && __cpp_concepts >= 202002L\n+\n+#include <initializer_list>\n+#include <bits/exception.h>\t// exception\n+#include <bits/stl_construct.h>\t// construct_at\n+#include <bits/utility.h>\t// in_place_t\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @defgroup expected_values Expected values\n+   * @addtogroup utilities\n+   * @since C++23\n+   * @{\n+   */\n+\n+#define __cpp_lib_expected 202202L\n+\n+  /// Discriminated union that holds an expected value or an error value.\n+  /**\n+   * @since C++23\n+   */\n+  template<typename _Tp, typename _Er>\n+    class expected;\n+\n+  /// Wrapper type used to pass an error value to a `std::expected`.\n+  /**\n+   * @since C++23\n+   */\n+  template<typename _Er>\n+    class unexpected;\n+\n+  /// Exception thrown by std::expected when the value() is not present.\n+  /**\n+   * @since C++23\n+   */\n+  template<typename _Er>\n+    class bad_expected_access;\n+\n+  template<>\n+    class bad_expected_access<void> : public exception\n+    {\n+    protected:\n+      bad_expected_access() noexcept { }\n+      bad_expected_access(const bad_expected_access&) = default;\n+      bad_expected_access(bad_expected_access&&) = default;\n+      bad_expected_access& operator=(const bad_expected_access&) = default;\n+      bad_expected_access& operator=(bad_expected_access&&) = default;\n+      ~bad_expected_access() = default;\n+\n+    public:\n+\n+      [[nodiscard]]\n+      const char*\n+      what() const noexcept override\n+      { return \"bad access to std::expected without expected value\"; }\n+    };\n+\n+  template<typename _Er>\n+    class bad_expected_access : public bad_expected_access<void> {\n+    public:\n+      explicit\n+      bad_expected_access(_Er __e) : _M_val(__e) { }\n+\n+      // XXX const char* what() const noexcept override;\n+\n+      [[nodiscard]]\n+      _Er&\n+      error() & noexcept\n+      { return _M_val; }\n+\n+      [[nodiscard]]\n+      const _Er&\n+      error() const & noexcept\n+      { return _M_val; }\n+\n+      [[nodiscard]]\n+      _Er&&\n+      error() && noexcept\n+      { return std::move(_M_val); }\n+\n+      [[nodiscard]]\n+      const _Er&&\n+      error() const && noexcept\n+      { return std::move(_M_val); }\n+\n+    private:\n+      _Er _M_val;\n+    };\n+\n+  /// Tag type for constructing unexpected values in a std::expected\n+  /**\n+   * @since C++23\n+   */\n+  struct unexpect_t\n+  {\n+    explicit unexpect_t() = default;\n+  };\n+\n+  /// Tag for constructing unexpected values in a std::expected\n+  /**\n+   * @since C++23\n+   */\n+  inline constexpr unexpect_t unexpect{};\n+\n+/// @cond undoc\n+namespace __expected\n+{\n+  template<typename _Tp>\n+    constexpr bool __is_expected = false;\n+  template<typename _Tp, typename _Er>\n+    constexpr bool __is_expected<expected<_Tp, _Er>> = true;\n+\n+  template<typename _Tp>\n+    constexpr bool __is_unexpected = false;\n+  template<typename _Tp>\n+    constexpr bool __is_unexpected<unexpected<_Tp>> = true;\n+\n+  template<typename _Er>\n+    concept __can_be_unexpected\n+      = is_object_v<_Er> && (!is_array_v<_Er>)\n+\t  && (!__expected::__is_unexpected<_Er>)\n+\t  && (!is_const_v<_Er>) && (!is_volatile_v<_Er>);\n+}\n+/// @endcond\n+\n+  template<typename _Er>\n+    class unexpected\n+    {\n+      static_assert( __expected::__can_be_unexpected<_Er> );\n+\n+    public:\n+      constexpr unexpected(const unexpected&) = default;\n+      constexpr unexpected(unexpected&&) = default;\n+\n+      template<typename _Err = _Er>\n+\trequires (!is_same_v<remove_cvref_t<_Err>, unexpected>)\n+\t  && (!is_same_v<remove_cvref_t<_Err>, in_place_t>)\n+\t  && is_constructible_v<_Er, _Err>\n+\tconstexpr explicit\n+\tunexpected(_Err&& __e)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Err>)\n+\t: _M_val(std::forward<_Err>(__e))\n+\t{ }\n+\n+      template<typename... _Args>\n+\trequires is_constructible_v<_Er, _Args...>\n+\tconstexpr explicit\n+\tunexpected(in_place_t, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Args...>)\n+\t: _M_val(std::forward<_Args>(__args)...)\n+\t{ }\n+\n+      template<typename _Up, typename... _Args>\n+\trequires is_constructible_v<_Er, initializer_list<_Up>&, _Args...>\n+\tconstexpr explicit\n+\tunexpected(in_place_t, initializer_list<_Up> __il, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Er, initializer_list<_Up>&,\n+\t\t\t\t\t    _Args...>)\n+\t: _M_val(__il, std::forward<_Args>(__args)...)\n+\t{ }\n+\n+      constexpr unexpected& operator=(const unexpected&) = default;\n+      constexpr unexpected& operator=(unexpected&&) = default;\n+\n+\n+      [[nodiscard]]\n+      constexpr const _Er&\n+      error() const & noexcept { return _M_val; }\n+\n+      [[nodiscard]]\n+      constexpr _Er&\n+      error() & noexcept { return _M_val; }\n+\n+      [[nodiscard]]\n+      constexpr const _Er&&\n+      error() const && noexcept { return std::move(_M_val); }\n+\n+      [[nodiscard]]\n+      constexpr _Er&&\n+      error() && noexcept { return std::move(_M_val); }\n+\n+      constexpr void\n+      swap(unexpected& __other) noexcept(is_nothrow_swappable_v<_Er>)\n+      {\n+\tstatic_assert( is_swappable_v<_Er> );\n+\tusing std::swap;\n+\tswap(_M_val, __other._M_val);\n+      }\n+\n+      template<typename _Err>\n+\t[[nodiscard]]\n+\tfriend constexpr bool\n+\toperator==(const unexpected& __x, const unexpected<_Err>& __y)\n+\t{ return __x._M_val == __y.error(); }\n+\n+      friend constexpr void\n+      swap(unexpected& __x, unexpected& __y)\n+      noexcept(noexcept(__x.swap(__y)))\n+      requires requires {__x.swap(__y);}\n+      { __x.swap(__y); }\n+\n+    private:\n+      _Er _M_val;\n+    };\n+\n+  template<typename _Er> unexpected(_Er) -> unexpected<_Er>;\n+\n+/// @cond undoc\n+namespace __expected\n+{\n+  template<typename _Tp>\n+    struct _Guard\n+    {\n+      static_assert( is_nothrow_move_constructible_v<_Tp> );\n+\n+      constexpr explicit\n+      _Guard(_Tp& __x)\n+      : _M_guarded(__builtin_addressof(__x)), _M_tmp(std::move(__x)) // nothrow\n+      { std::destroy_at(_M_guarded); }\n+\n+      constexpr\n+      ~_Guard()\n+      {\n+\tif (_M_guarded) [[unlikely]]\n+\t  std::construct_at(_M_guarded, std::move(_M_tmp));\n+      }\n+\n+      _Guard(const _Guard&) = delete;\n+      _Guard& operator=(const _Guard&) = delete;\n+\n+      constexpr _Tp&&\n+      release() noexcept\n+      {\n+\t_M_guarded = nullptr;\n+\treturn std::move(_M_tmp);\n+      }\n+\n+    private:\n+      _Tp* _M_guarded;\n+      _Tp _M_tmp;\n+    };\n+\n+  // reinit-expected helper from [expected.object.assign]\n+  template<typename _Tp, typename _Up, typename _Vp>\n+    constexpr void\n+    __reinit(_Tp* __newval, _Up* __oldval, _Vp&& __arg)\n+    noexcept(is_nothrow_constructible_v<_Tp, _Vp>)\n+    {\n+      if constexpr (is_nothrow_constructible_v<_Tp, _Vp>)\n+\t{\n+\t  std::destroy_at(__oldval);\n+\t  std::construct_at(__newval, std::forward<_Vp>(__arg));\n+\t}\n+      else if constexpr (is_nothrow_move_constructible_v<_Tp>)\n+\t{\n+\t  _Tp __tmp(std::forward<_Vp>(__arg)); // might throw\n+\t  std::destroy_at(__oldval);\n+\t  std::construct_at(__newval, std::move(__tmp));\n+\t}\n+      else\n+\t{\n+\t  _Guard<_Up> __guard(*__oldval);\n+\t  std::construct_at(__newval, std::forward<_Vp>(__arg)); // might throw\n+\t  __guard.release();\n+\t}\n+    }\n+}\n+/// @endcond\n+\n+  template<typename _Tp, typename _Er>\n+    class expected\n+    {\n+      static_assert( ! is_reference_v<_Tp> );\n+      static_assert( ! is_function_v<_Tp> );\n+      static_assert( ! is_same_v<remove_cv_t<_Tp>, in_place_t> );\n+      static_assert( ! is_same_v<remove_cv_t<_Tp>, unexpect_t> );\n+      static_assert( ! __expected::__is_unexpected<remove_cv_t<_Tp>> );\n+      static_assert( __expected::__can_be_unexpected<_Er> );\n+\n+      template<typename _Up, typename _Err, typename _Unex = unexpected<_Er>>\n+\tstatic constexpr bool __cons_from_expected\n+\t  = __or_v<is_constructible<_Tp, expected<_Up, _Err>&>,\n+\t\t   is_constructible<_Tp, expected<_Up, _Err>>,\n+\t\t   is_constructible<_Tp, const expected<_Up, _Err>&>,\n+\t\t   is_constructible<_Tp, const expected<_Up, _Err>>,\n+\t\t   is_convertible<expected<_Up, _Err>&, _Tp>,\n+\t\t   is_convertible<expected<_Up, _Err>, _Tp>,\n+\t\t   is_convertible<const expected<_Up, _Err>&, _Tp>,\n+\t\t   is_convertible<const expected<_Up, _Err>, _Tp>,\n+\t\t   is_constructible<_Unex, expected<_Up, _Err>&>,\n+\t\t   is_constructible<_Unex, expected<_Up, _Err>>,\n+\t\t   is_constructible<_Unex, const expected<_Up, _Err>&>,\n+\t\t   is_constructible<_Unex, const expected<_Up, _Err>>\n+\t\t  >;\n+\n+      template<typename _Up, typename _Err>\n+\tconstexpr static bool __explicit_conv\n+\t  = __or_v<__not_<is_convertible<_Up, _Tp>>,\n+\t\t   __not_<is_convertible<_Err, _Er>>\n+\t\t  >;\n+\n+    public:\n+      using value_type = _Tp;\n+      using error_type = _Er;\n+      using unexpected_type = unexpected<_Er>;\n+\n+      template<typename _Up>\n+\tusing rebind = expected<_Up, error_type>;\n+\n+      constexpr\n+      expected()\n+      noexcept(is_nothrow_default_constructible_v<_Tp>)\n+      requires is_default_constructible_v<_Tp>\n+      : _M_val(), _M_has_value(true)\n+      { }\n+\n+      expected(const expected&) = default;\n+\n+      constexpr\n+      expected(const expected& __x)\n+      noexcept(__and_v<is_nothrow_copy_constructible<_Tp>,\n+\t\t       is_nothrow_copy_constructible<_Er>>)\n+      requires is_copy_constructible_v<_Tp> && is_copy_constructible_v<_Er>\n+      && (!is_trivially_copy_constructible_v<_Tp>\n+\t  || !is_trivially_copy_constructible_v<_Er>)\n+      : _M_invalid(), _M_has_value(__x._M_has_value)\n+      {\n+\tif (_M_has_value)\n+\t  std::construct_at(__builtin_addressof(_M_val), __x._M_val);\n+\telse\n+\t  std::construct_at(__builtin_addressof(_M_unex), __x._M_unex);\n+      }\n+\n+      expected(expected&&) = default;\n+\n+      constexpr\n+      expected(expected&& __x)\n+      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t       is_nothrow_move_constructible<_Er>>)\n+      requires is_move_constructible_v<_Tp> && is_move_constructible_v<_Er>\n+      && (!is_trivially_move_constructible_v<_Tp>\n+\t  || !is_trivially_move_constructible_v<_Er>)\n+      : _M_invalid(), _M_has_value(__x._M_has_value)\n+      {\n+\tif (_M_has_value)\n+\t  std::construct_at(__builtin_addressof(_M_val),\n+\t\t\t    std::move(__x)._M_val);\n+\telse\n+\t  std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t    std::move(__x)._M_unex);\n+      }\n+\n+      template<typename _Up, typename _Gr>\n+\trequires is_constructible_v<_Tp, const _Up&>\n+\t      && is_constructible_v<_Er, const _Gr&>\n+\t      && (!__cons_from_expected<_Up, _Gr>)\n+\tconstexpr explicit(__explicit_conv<const _Up&, const _Gr&>)\n+\texpected(const expected<_Up, _Gr>& __x)\n+\tnoexcept(__and_v<is_nothrow_constructible<_Tp, const _Up&>,\n+\t\t\t is_nothrow_constructible<_Er, const _Gr&>>)\n+\t: _M_invalid(), _M_has_value(__x._M_has_value)\n+\t{\n+\t  if (_M_has_value)\n+\t    std::construct_at(__builtin_addressof(_M_val), __x._M_val);\n+\t  else\n+\t    std::construct_at(__builtin_addressof(_M_unex), __x._M_unex);\n+\t}\n+\n+      template<typename _Up, typename _Gr>\n+\trequires is_constructible_v<_Tp, _Up>\n+\t      && is_constructible_v<_Er, _Gr>\n+\t      && (!__cons_from_expected<_Up, _Gr>)\n+\tconstexpr explicit(__explicit_conv<_Up, _Gr>)\n+\texpected(expected<_Up, _Gr>&& __x)\n+\tnoexcept(__and_v<is_nothrow_constructible<_Tp, _Up>,\n+\t\t\t is_nothrow_constructible<_Er, _Gr>>)\n+\t: _M_invalid(), _M_has_value(__x._M_has_value)\n+\t{\n+\t  if (_M_has_value)\n+\t    std::construct_at(__builtin_addressof(_M_val),\n+\t\t\t      std::move(__x)._M_val);\n+\t  else\n+\t    std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t      std::move(__x)._M_unex);\n+\t}\n+\n+      template<typename _Up = _Tp>\n+\trequires (!is_same_v<remove_cvref_t<_Up>, expected>)\n+\t  && (!is_same_v<remove_cvref_t<_Up>, in_place_t>)\n+\t  && (!__expected::__is_unexpected<remove_cvref_t<_Up>>)\n+\t  && is_constructible_v<_Tp, _Up>\n+\tconstexpr explicit(!is_convertible_v<_Up, _Tp>)\n+\texpected(_Up&& __v)\n+\tnoexcept(is_nothrow_constructible_v<_Tp, _Up>)\n+\t: _M_val(std::forward<_Up>(__v)), _M_has_value(true)\n+\t{ }\n+\n+      template<typename _Gr = _Er>\n+\trequires is_constructible_v<_Er, const _Gr&>\n+\tconstexpr explicit(!is_convertible_v<const _Gr&, _Er>)\n+\texpected(const unexpected<_Gr>& __u)\n+\tnoexcept(is_nothrow_constructible_v<_Er, const _Gr&>)\n+\t: _M_unex(__u.error()), _M_has_value(false)\n+\t{ }\n+\n+      template<typename _Gr = _Er>\n+\trequires is_constructible_v<_Er, _Gr>\n+\tconstexpr explicit(!is_convertible_v<_Gr, _Er>)\n+\texpected(unexpected<_Gr>&& __u)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Gr>)\n+\t: _M_unex(std::move(__u).error()), _M_has_value(false)\n+\t{ }\n+\n+      template<typename... _Args>\n+\trequires is_constructible_v<_Tp, _Args...>\n+\tconstexpr explicit\n+\texpected(in_place_t, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Tp, _Args...>)\n+\t: _M_val(std::forward<_Args>(__args)...), _M_has_value(true)\n+\t{ }\n+\n+      template<typename _Up, typename... _Args>\n+\trequires is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>\n+\tconstexpr explicit\n+\texpected(in_place_t, initializer_list<_Up> __il, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Tp, initializer_list<_Up>&,\n+\t\t\t\t\t    _Args...>)\n+\t: _M_val(__il, std::forward<_Args>(__args)...), _M_has_value(true)\n+\t{ }\n+\n+      template<typename... _Args>\n+\trequires is_constructible_v<_Er, _Args...>\n+\tconstexpr explicit\n+\texpected(unexpect_t, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Args...>)\n+\t: _M_unex(std::forward<_Args>(__args)...), _M_has_value(false)\n+\t{ }\n+\n+      template<typename _Up, typename... _Args>\n+\trequires is_constructible_v<_Er, initializer_list<_Up>&, _Args...>\n+\tconstexpr explicit\n+\texpected(unexpect_t, initializer_list<_Up> __il, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Er, initializer_list<_Up>&,\n+\t\t\t\t\t    _Args...>)\n+\t: _M_unex(__il, std::forward<_Args>(__args)...), _M_has_value(false)\n+\t{ }\n+\n+      constexpr ~expected() = default;\n+\n+      constexpr ~expected()\n+      requires (!is_trivially_destructible_v<_Tp>)\n+\t    || (!is_trivially_destructible_v<_Er>)\n+      {\n+\tif (_M_has_value)\n+\t  std::destroy_at(__builtin_addressof(_M_val));\n+\telse\n+\t  std::destroy_at(__builtin_addressof(_M_unex));\n+      }\n+\n+      // assignment\n+\n+      expected& operator=(const expected&) = delete;\n+\n+      constexpr expected&\n+      operator=(const expected& __x)\n+      noexcept(__and_v<is_nothrow_copy_constructible<_Tp>,\n+\t\t       is_nothrow_copy_constructible<_Er>,\n+\t\t       is_nothrow_copy_assignable<_Tp>,\n+\t\t       is_nothrow_copy_assignable<_Er>>)\n+      requires is_copy_assignable_v<_Tp> && is_copy_constructible_v<_Tp>\n+\t    && is_copy_assignable_v<_Er> && is_copy_constructible_v<_Er>\n+\t    && (is_nothrow_move_constructible_v<_Tp>\n+\t\t|| is_nothrow_move_constructible_v<_Er>)\n+      {\n+\tif (__x._M_has_value)\n+\t  this->_M_assign_val(__x._M_val);\n+\telse\n+\t  this->_M_assign_unex(__x._M_unex);\n+\treturn *this;\n+      }\n+\n+      constexpr expected&\n+      operator=(expected&& __x)\n+      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t       is_nothrow_move_constructible<_Er>,\n+\t\t       is_nothrow_move_assignable<_Tp>,\n+\t\t       is_nothrow_move_assignable<_Er>>)\n+      requires is_move_assignable_v<_Tp> && is_move_constructible_v<_Tp>\n+\t    && is_move_assignable_v<_Er> && is_move_constructible_v<_Er>\n+\t    && (is_nothrow_move_constructible_v<_Tp>\n+\t\t|| is_nothrow_move_constructible_v<_Er>)\n+      {\n+\tif (__x._M_has_value)\n+\t  _M_assign_val(std::move(__x._M_val));\n+\telse\n+\t  _M_assign_unex(std::move(__x._M_unex));\n+\treturn *this;\n+      }\n+\n+      template<typename _Up = _Tp>\n+\trequires (!is_same_v<expected, remove_cvref_t<_Up>>)\n+\t      && (!__expected::__is_unexpected<remove_cvref_t<_Up>>)\n+\t      && is_constructible_v<_Tp, _Up> && is_assignable_v<_Tp&, _Up>\n+\t      && (is_nothrow_constructible_v<_Tp, _Up>\n+\t\t  || is_nothrow_move_constructible_v<_Tp>\n+\t\t  || is_nothrow_move_constructible_v<_Er>)\n+\tconstexpr expected&\n+\toperator=(_Up&& __v)\n+\t{\n+\t  _M_assign_val(std::forward<_Up>(__v));\n+\t  return *this;\n+\t}\n+\n+      template<typename _Gr>\n+\trequires is_constructible_v<_Er, const _Gr&>\n+\t      && is_assignable_v<_Er&, const _Gr&>\n+\t      && (is_nothrow_constructible_v<_Er, const _Gr&>\n+\t\t  || is_nothrow_move_constructible_v<_Tp>\n+\t\t  || is_nothrow_move_constructible_v<_Er>)\n+\tconstexpr expected&\n+\toperator=(const unexpected<_Gr>& __e)\n+\t{\n+\t  _M_assign_unex(__e.error());\n+\t  return *this;\n+\t}\n+\n+      template<typename _Gr>\n+\trequires is_constructible_v<_Er, _Gr>\n+\t      && is_assignable_v<_Er&, _Gr>\n+\t      && (is_nothrow_constructible_v<_Er, _Gr>\n+\t\t  || is_nothrow_move_constructible_v<_Tp>\n+\t\t  || is_nothrow_move_constructible_v<_Er>)\n+\tconstexpr expected&\n+\toperator=(unexpected<_Gr>&& __e)\n+\t{\n+\t  _M_assign_unex(std::move(__e).error());\n+\t  return *this;\n+\t}\n+\n+      // modifiers\n+\n+      template<typename... _Args>\n+\trequires is_nothrow_constructible_v<_Tp, _Args...>\n+\tconstexpr _Tp&\n+\templace(_Args&&... __args) noexcept\n+\t{\n+\t  if (_M_has_value)\n+\t    std::destroy_at(__builtin_addressof(_M_val));\n+\t  else\n+\t    {\n+\t      std::destroy_at(__builtin_addressof(_M_unex));\n+\t      _M_has_value = true;\n+\t    }\n+\t  std::construct_at(__builtin_addressof(_M_val),\n+\t\t\t    std::forward<_Args>(__args)...);\n+\t  return _M_val;\n+\t}\n+\n+      template<typename _Up, typename... _Args>\n+\trequires is_nothrow_constructible_v<_Tp, initializer_list<_Up>&,\n+\t\t\t\t\t    _Args...>\n+\tconstexpr _Tp&\n+\templace(initializer_list<_Up> __il, _Args&&... __args) noexcept\n+\t{\n+\t  if (_M_has_value)\n+\t    std::destroy_at(__builtin_addressof(_M_val));\n+\t  else\n+\t    {\n+\t      std::destroy_at(__builtin_addressof(_M_unex));\n+\t      _M_has_value = true;\n+\t    }\n+\t  std::construct_at(__builtin_addressof(_M_val),\n+\t\t\t    __il, std::forward<_Args>(__args)...);\n+\t  return _M_val;\n+\t}\n+\n+      // swap\n+      constexpr void\n+      swap(expected& __x)\n+      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t       is_nothrow_move_constructible<_Er>,\n+\t\t       is_nothrow_swappable<_Tp&>,\n+\t\t       is_nothrow_swappable<_Er&>>)\n+      requires is_swappable_v<_Tp> && is_swappable_v<_Er>\n+\t    && is_move_constructible_v<_Tp>\n+\t    && is_move_constructible_v<_Er>\n+\t    && (is_nothrow_move_constructible_v<_Tp>\n+\t\t|| is_nothrow_move_constructible_v<_Er>)\n+      {\n+\tif (_M_has_value)\n+\t  {\n+\t    if (__x._M_has_value)\n+\t      {\n+\t\tusing std::swap;\n+\t\tswap(_M_val, __x._M_val);\n+\t      }\n+\t    else\n+\t      this->_M_swap_val_unex(__x);\n+\t  }\n+\telse\n+\t  {\n+\t    if (__x._M_has_value)\n+\t      __x._M_swap_val_unex(*this);\n+\t    else\n+\t      {\n+\t\tusing std::swap;\n+\t\tswap(_M_unex, __x._M_unex);\n+\t      }\n+\t  }\n+      }\n+\n+      // observers\n+\n+      [[nodiscard]]\n+      constexpr const _Tp*\n+      operator->() const noexcept\n+      {\n+\t__glibcxx_assert(_M_has_value);\n+\treturn __builtin_addressof(_M_val);\n+      }\n+\n+      [[nodiscard]]\n+      constexpr _Tp*\n+      operator->() noexcept\n+      {\n+\t__glibcxx_assert(_M_has_value);\n+\treturn __builtin_addressof(_M_val);\n+      }\n+\n+      [[nodiscard]]\n+      constexpr const _Tp&\n+      operator*() const & noexcept\n+      {\n+\t__glibcxx_assert(_M_has_value);\n+\treturn _M_val;\n+      }\n+\n+      [[nodiscard]]\n+      constexpr _Tp&\n+      operator*() & noexcept\n+      {\n+\t__glibcxx_assert(_M_has_value);\n+\treturn _M_val;\n+      }\n+\n+      [[nodiscard]]\n+      constexpr const _Tp&&\n+      operator*() const && noexcept\n+      {\n+\t__glibcxx_assert(_M_has_value);\n+\treturn std::move(_M_val);\n+      }\n+\n+      [[nodiscard]]\n+      constexpr _Tp&&\n+      operator*() && noexcept\n+      {\n+\t__glibcxx_assert(_M_has_value);\n+\treturn std::move(_M_val);\n+      }\n+\n+      [[nodiscard]]\n+      constexpr explicit\n+      operator bool() const noexcept { return _M_has_value; }\n+\n+      [[nodiscard]]\n+      constexpr bool has_value() const noexcept { return _M_has_value; }\n+\n+      constexpr const _Tp&\n+      value() const &\n+      {\n+\tif (_M_has_value) [[likely]]\n+\t  return _M_val;\n+\t_GLIBCXX_THROW_OR_ABORT(bad_expected_access<_Er>(_M_unex));\n+      }\n+\n+      constexpr _Tp&\n+      value() &\n+      {\n+\tif (_M_has_value) [[likely]]\n+\t  return _M_val;\n+\t_GLIBCXX_THROW_OR_ABORT(bad_expected_access<_Er>(_M_unex));\n+      }\n+\n+      constexpr const _Tp&&\n+      value() const &&\n+      {\n+\tif (_M_has_value) [[likely]]\n+\t  return std::move(_M_val);\n+\t_GLIBCXX_THROW_OR_ABORT(bad_expected_access<_Er>(\n+\t\t\t\t  std::move(_M_unex)));\n+      }\n+\n+      constexpr _Tp&&\n+      value() &&\n+      {\n+\tif (_M_has_value) [[likely]]\n+\t  return std::move(_M_val);\n+\t_GLIBCXX_THROW_OR_ABORT(bad_expected_access<_Er>(\n+\t\t\t\t  std::move(_M_unex)));\n+      }\n+\n+      constexpr const _Er&\n+      error() const & noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn _M_unex;\n+      }\n+\n+      constexpr _Er&\n+      error() & noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn _M_unex;\n+      }\n+\n+      constexpr const _Er&&\n+      error() const && noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn std::move(_M_unex);\n+      }\n+\n+      constexpr _Er&&\n+      error() && noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn std::move(_M_unex);\n+      }\n+\n+      template<typename _Up>\n+\tconstexpr _Tp\n+\tvalue_or(_Up&& __v) const &\n+\tnoexcept(__and_v<is_nothrow_copy_constructible<_Tp>,\n+\t\t\t is_nothrow_convertible<_Up, _Tp>>)\n+\t{\n+\t  static_assert( is_copy_constructible_v<_Tp> );\n+\t  static_assert( is_convertible_v<_Up, _Tp> );\n+\n+\t  if (_M_has_value)\n+\t    return _M_val;\n+\t  return static_cast<_Tp>(std::forward<_Up>(__v));\n+\t}\n+\n+      template<typename _Up>\n+\tconstexpr _Tp\n+\tvalue_or(_Up&& __v) &&\n+\tnoexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n+\t\t\t is_nothrow_convertible<_Up, _Tp>>)\n+\t{\n+\t  static_assert( is_move_constructible_v<_Tp> );\n+\t  static_assert( is_convertible_v<_Up, _Tp> );\n+\n+\t  if (_M_has_value)\n+\t    return std::move(_M_val);\n+\t  return static_cast<_Tp>(std::forward<_Up>(__v));\n+\t}\n+\n+      // equality operators\n+\n+      template<typename _Up, typename _Er2>\n+\trequires (!is_void_v<_Up>)\n+\tfriend constexpr bool\n+\toperator==(const expected& __x, const expected<_Up, _Er2>& __y)\n+\tnoexcept(noexcept(bool(*__x == *__y))\n+\t\t  && noexcept(bool(__x.error() == __y.error())))\n+\t{\n+\t  if (__x.has_value())\n+\t    return __y.has_value() && bool(*__x == *__y);\n+\t  else\n+\t    return !__y.has_value() && bool(__x.error() == __y.error());\n+\t}\n+\n+      template<typename _Up>\n+\tfriend constexpr bool\n+\toperator==(const expected& __x, const _Up& __v)\n+\tnoexcept(noexcept(bool(*__x == __v)))\n+\t{ return __x.has_value() && bool(*__x == __v); }\n+\n+      template<typename _Er2>\n+\tfriend constexpr bool\n+\toperator==(const expected& __x, const unexpected<_Er2>& __e)\n+\tnoexcept(noexcept(bool(__x.error() == __e.error())))\n+\t{ return !__x.has_value() && bool(__x.error() == __e.error()); }\n+\n+      friend constexpr void\n+      swap(expected& __x, expected& __y)\n+      noexcept(noexcept(__x.swap(__y)))\n+      requires requires {__x.swap(__y);}\n+      { __x.swap(__y); }\n+\n+    private:\n+      template<typename, typename> friend class expected;\n+\n+      template<typename _Vp>\n+\tconstexpr void\n+\t_M_assign_val(_Vp&& __v)\n+\t{\n+\t  if (_M_has_value)\n+\t    _M_val = std::forward<_Vp>(__v);\n+\t  else\n+\t    {\n+\t      __expected::__reinit(__builtin_addressof(_M_val),\n+\t\t\t\t   __builtin_addressof(_M_unex),\n+\t\t\t\t   std::forward<_Vp>(__v));\n+\t      _M_has_value = true;\n+\t    }\n+\t}\n+\n+      template<typename _Vp>\n+\tconstexpr void\n+\t_M_assign_unex(_Vp&& __v)\n+\t{\n+\t  if (_M_has_value)\n+\t    {\n+\t      __expected::__reinit(__builtin_addressof(_M_unex),\n+\t\t\t\t   __builtin_addressof(_M_val),\n+\t\t\t\t   std::forward<_Vp>(__v));\n+\t      _M_has_value = false;\n+\t    }\n+\t  else\n+\t    _M_unex = std::forward<_Vp>(__v);\n+\t}\n+\n+      // Swap two expected objects when only one has a value.\n+      // Precondition: this->_M_has_value && !__rhs._M_has_value\n+      constexpr void\n+      _M_swap_val_unex(expected& __rhs)\n+      noexcept(__and_v<is_nothrow_move_constructible<_Er>,\n+\t\t       is_nothrow_move_constructible<_Tp>>)\n+      {\n+\tif constexpr (is_nothrow_move_constructible_v<_Er>)\n+\t  {\n+\t    __expected::_Guard<_Er> __guard(__rhs._M_unex);\n+\t    std::construct_at(__builtin_addressof(__rhs._M_val),\n+\t\t\t      std::move(_M_val)); // might throw\n+\t    __rhs._M_has_value = true;\n+\t    std::destroy_at(__builtin_addressof(_M_val));\n+\t    std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t      __guard.release());\n+\t    _M_has_value = false;\n+\t  }\n+\telse\n+\t  {\n+\t    __expected::_Guard<_Tp> __guard(__rhs._M_val);\n+\t    std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t      std::move(__rhs._M_unex)); // might throw\n+\t    _M_has_value = false;\n+\t    std::destroy_at(__builtin_addressof(__rhs._M_unex));\n+\t    std::construct_at(__builtin_addressof(__rhs._M_val),\n+\t\t\t      __guard.release());\n+\t    __rhs._M_has_value = true;\n+\t  }\n+      }\n+\n+      union {\n+\tstruct { } _M_invalid;\n+\t_Tp _M_val;\n+\t_Er _M_unex;\n+      };\n+\n+      bool _M_has_value;\n+    };\n+\n+  // Partial specialization for std::expected<cv void, E>\n+  template<typename _Tp, typename _Er> requires is_void_v<_Tp>\n+    class expected<_Tp, _Er>\n+    {\n+      static_assert( __expected::__can_be_unexpected<_Er> );\n+\n+      template<typename _Up, typename _Err, typename _Unex = unexpected<_Er>>\n+\tstatic constexpr bool __cons_from_expected\n+\t  = __or_v<is_constructible<_Unex, expected<_Up, _Err>&>,\n+\t\t   is_constructible<_Unex, expected<_Up, _Err>>,\n+\t\t   is_constructible<_Unex, const expected<_Up, _Err>&>,\n+\t\t   is_constructible<_Unex, const expected<_Up, _Err>>\n+\t\t  >;\n+\n+    public:\n+      using value_type = _Tp;\n+      using error_type = _Er;\n+      using unexpected_type = unexpected<_Er>;\n+\n+      template<typename _Up>\n+\tusing rebind = expected<_Up, error_type>;\n+\n+      constexpr\n+      expected() noexcept\n+      : _M_void(), _M_has_value(true)\n+      { }\n+\n+      expected(const expected&) = default;\n+\n+      constexpr\n+      expected(const expected& __x)\n+      noexcept(is_nothrow_copy_constructible_v<_Er>)\n+      requires is_copy_constructible_v<_Er>\n+\t    && (!is_trivially_copy_constructible_v<_Er>)\n+      : _M_void(), _M_has_value(__x._M_has_value)\n+      {\n+\tif (!_M_has_value)\n+\t  std::construct_at(__builtin_addressof(_M_unex), __x._M_unex);\n+      }\n+\n+      expected(expected&&) = default;\n+\n+      constexpr\n+      expected(expected&& __x)\n+      noexcept(is_nothrow_move_constructible_v<_Er>)\n+      requires is_move_constructible_v<_Er>\n+\t    && (!is_trivially_move_constructible_v<_Er>)\n+      : _M_void(), _M_has_value(__x._M_has_value)\n+      {\n+\tif (!_M_has_value)\n+\t  std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t    std::move(__x)._M_unex);\n+      }\n+\n+      template<typename _Up, typename _Gr>\n+\trequires is_void_v<_Up>\n+\t      && is_constructible_v<_Er, const _Gr&>\n+\t      && (!__cons_from_expected<_Up, _Gr>)\n+\tconstexpr explicit(!is_convertible_v<const _Gr&, _Er>)\n+\texpected(const expected<_Up, _Gr>& __x)\n+\tnoexcept(is_nothrow_constructible_v<_Er, const _Gr&>)\n+\t: _M_void(), _M_has_value(__x._M_has_value)\n+\t{\n+\t  if (!_M_has_value)\n+\t    std::construct_at(__builtin_addressof(_M_unex), __x._M_unex);\n+\t}\n+\n+      template<typename _Up, typename _Gr>\n+\trequires is_void_v<_Tp>\n+\t      && is_constructible_v<_Er, const _Gr&>\n+\t      && (!__cons_from_expected<_Up, _Gr>)\n+\tconstexpr explicit(!is_convertible_v<_Gr, _Er>)\n+\texpected(expected<_Up, _Gr>&& __x)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Gr>)\n+\t: _M_void(), _M_has_value(__x._M_has_value)\n+\t{\n+\t  if (!_M_has_value)\n+\t    std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t      std::move(__x)._M_unex);\n+\t}\n+\n+      template<typename _Gr = _Er>\n+\trequires is_constructible_v<_Er, const _Gr&>\n+\tconstexpr explicit(!is_convertible_v<const _Gr&, _Er>)\n+\texpected(const unexpected<_Gr>& __u)\n+\tnoexcept(is_nothrow_constructible_v<_Er, const _Gr&>)\n+\t: _M_unex(__u.error()), _M_has_value(false)\n+\t{ }\n+\n+      template<typename _Gr = _Er>\n+\trequires is_constructible_v<_Er, _Gr>\n+\tconstexpr explicit(!is_convertible_v<_Gr, _Er>)\n+\texpected(unexpected<_Gr>&& __u)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Gr>)\n+\t: _M_unex(std::move(__u).error()), _M_has_value(false)\n+\t{ }\n+\n+      template<typename... _Args>\n+\tconstexpr explicit\n+\texpected(in_place_t) noexcept\n+\t: expected()\n+\t{ }\n+\n+      template<typename... _Args>\n+\trequires is_constructible_v<_Er, _Args...>\n+\tconstexpr explicit\n+\texpected(unexpect_t, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Er, _Args...>)\n+\t: _M_unex(std::forward<_Args>(__args)...), _M_has_value(false)\n+\t{ }\n+\n+      template<typename _Up, typename... _Args>\n+\trequires is_constructible_v<_Er, initializer_list<_Up>&, _Args...>\n+\tconstexpr explicit\n+\texpected(unexpect_t, initializer_list<_Up> __il, _Args&&... __args)\n+\tnoexcept(is_nothrow_constructible_v<_Er, initializer_list<_Up>&,\n+\t\t\t\t\t    _Args...>)\n+\t: _M_unex(__il, std::forward<_Args>(__args)...), _M_has_value(false)\n+\t{ }\n+\n+      constexpr ~expected() = default;\n+\n+      constexpr ~expected() requires (!is_trivially_destructible_v<_Er>)\n+      {\n+\tif (!_M_has_value)\n+\t  std::destroy_at(__builtin_addressof(_M_unex));\n+      }\n+\n+      // assignment\n+\n+      expected& operator=(const expected&) = delete;\n+\n+      constexpr expected&\n+      operator=(const expected& __x)\n+      noexcept(__and_v<is_nothrow_copy_constructible<_Er>,\n+\t\t       is_nothrow_copy_assignable<_Er>>)\n+      requires is_copy_constructible_v<_Er>\n+\t    && is_copy_assignable_v<_Er>\n+      {\n+\tif (__x._M_has_value)\n+\t  emplace();\n+\telse\n+\t  _M_assign_unex(__x._M_unex);\n+\treturn *this;\n+      }\n+\n+      constexpr expected&\n+      operator=(expected&& __x)\n+      noexcept(__and_v<is_nothrow_move_constructible<_Er>,\n+\t\t       is_nothrow_move_assignable<_Er>>)\n+      requires is_move_constructible_v<_Er>\n+\t    && is_move_assignable_v<_Er>\n+      {\n+\tif (__x._M_has_value)\n+\t  emplace();\n+\telse\n+\t  _M_assign_unex(std::move(__x._M_unex));\n+\treturn *this;\n+      }\n+\n+      template<typename _Gr>\n+\trequires is_constructible_v<_Er, const _Gr&>\n+\t      && is_assignable_v<_Er&, const _Gr&>\n+\tconstexpr expected&\n+\toperator=(const unexpected<_Gr>& __e)\n+\t{\n+\t  _M_assign_unex(__e.error());\n+\t  return *this;\n+\t}\n+\n+      template<typename _Gr>\n+\trequires is_constructible_v<_Er, _Gr>\n+\t      && is_assignable_v<_Er&, _Gr>\n+\tconstexpr expected&\n+\toperator=(unexpected<_Gr>&& __e)\n+\t{\n+\t  _M_assign_unex(std::move(__e.error()));\n+\t  return *this;\n+\t}\n+\n+      // modifiers\n+\n+      constexpr void\n+      emplace() noexcept\n+      {\n+\tif (!_M_has_value)\n+\t  {\n+\t    std::destroy_at(__builtin_addressof(_M_unex));\n+\t    _M_has_value = true;\n+\t  }\n+      }\n+\n+      // swap\n+      constexpr void\n+      swap(expected& __x)\n+      noexcept(__and_v<is_nothrow_swappable<_Er&>,\n+\t\t       is_nothrow_move_constructible<_Er>>)\n+      requires is_swappable_v<_Er> && is_move_constructible_v<_Er>\n+      {\n+\tif (_M_has_value)\n+\t  {\n+\t    if (!__x._M_has_value)\n+\t      {\n+\t\tstd::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t\t  std::move(__x._M_unex)); // might throw\n+\t\tstd::destroy_at(__builtin_addressof(__x._M_unex));\n+\t\t__x._M_has_value = true;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (__x._M_has_value)\n+\t      {\n+\t\tstd::construct_at(__builtin_addressof(__x._M_unex),\n+\t\t\t\t  std::move(_M_unex)); // might throw\n+\t\tstd::destroy_at(__builtin_addressof(_M_unex));\n+\t\t_M_has_value = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\tusing std::swap;\n+\t\tswap(_M_unex, __x._M_unex);\n+\t      }\n+\t  }\n+      }\n+\n+      // observers\n+\n+      [[nodiscard]]\n+      constexpr explicit\n+      operator bool() const noexcept { return _M_has_value; }\n+\n+      [[nodiscard]]\n+      constexpr bool has_value() const noexcept { return _M_has_value; }\n+\n+      constexpr void\n+      operator*() const noexcept { __glibcxx_assert(_M_has_value); }\n+\n+      constexpr void\n+      value() const&\n+      {\n+\tif (_M_has_value) [[likely]]\n+\t  return;\n+\t_GLIBCXX_THROW_OR_ABORT(bad_expected_access<_Er>(_M_unex));\n+      }\n+\n+      constexpr void\n+      value() &&\n+      {\n+\tif (_M_has_value) [[likely]]\n+\t  return;\n+\t_GLIBCXX_THROW_OR_ABORT(bad_expected_access<_Er>(std::move(_M_unex)));\n+      }\n+\n+      constexpr const _Er&\n+      error() const & noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn _M_unex;\n+      }\n+\n+      constexpr _Er&\n+      error() & noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn _M_unex;\n+      }\n+\n+      constexpr const _Er&&\n+      error() const && noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn std::move(_M_unex);\n+      }\n+\n+      constexpr _Er&&\n+      error() && noexcept\n+      {\n+\t__glibcxx_assert(!_M_has_value);\n+\treturn std::move(_M_unex);\n+      }\n+\n+      // equality operators\n+\n+      template<typename _Up, typename _Er2>\n+\trequires is_void_v<_Up>\n+\tfriend constexpr bool\n+\toperator==(const expected& __x, const expected<_Up, _Er2>& __y)\n+\tnoexcept(noexcept(bool(__x.error() == __y.error())))\n+\t{\n+\t  if (__x.has_value())\n+\t    return __y.has_value();\n+\t  else\n+\t    return !__y.has_value() && bool(__x.error() == __y.error());\n+\t}\n+\n+      template<typename _Er2>\n+\tfriend constexpr bool\n+\toperator==(const expected& __x, const unexpected<_Er2>& __e)\n+\tnoexcept(noexcept(bool(__x.error() == __e.error())))\n+\t{ return !__x.has_value() && bool(__x.error() == __e.error()); }\n+\n+      friend constexpr void\n+      swap(expected& __x, expected& __y)\n+      noexcept(noexcept(__x.swap(__y)))\n+      requires requires { __x.swap(__y); }\n+      { __x.swap(__y); }\n+\n+    private:\n+      template<typename, typename> friend class expected;\n+\n+      template<typename _Vp>\n+\tconstexpr void\n+\t_M_assign_unex(_Vp&& __v)\n+\t{\n+\t  if (_M_has_value)\n+\t    {\n+\t      std::construct_at(__builtin_addressof(_M_unex),\n+\t\t\t\tstd::forward<_Vp>(__v));\n+\t      _M_has_value = false;\n+\t    }\n+\t  else\n+\t    _M_unex = std::forward<_Vp>(__v);\n+\t}\n+\n+\n+      union {\n+\tstruct { } _M_void;\n+\t_Er _M_unex;\n+      };\n+\n+      bool _M_has_value;\n+    };\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++23\n+#endif // _GLIBCXX_EXPECTED"}, {"sha": "7dbac23f22d248793b5a73b95a23e218eddb55fd", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -306,6 +306,7 @@\n \n #if _GLIBCXX_HOSTED\n #define __cpp_lib_adaptor_iterator_pair_constructor 202106L\n+#define __cpp_lib_expected 202202L\n #define __cpp_lib_invoke_r 202106L\n #define __cpp_lib_ios_noreplace 202200L\n #if __cpp_lib_concepts"}, {"sha": "ae2b0dd7f78d6d22b8dfc196b62b7578ccad9868", "filename": "libstdc++-v3/libsupc++/exception", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -79,7 +79,7 @@ namespace std\n    *  abandoned for any reason.  It can also be called by the user.  */\n   void terminate() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__noreturn__));\n \n-#if __cplusplus < 201703L || _GLIBCXX_USE_DEPRECATED\n+#if __cplusplus < 201703L || (__cplusplus <= 202002L && _GLIBCXX_USE_DEPRECATED)\n   /// If you write a replacement %unexpected handler, it must be of this type.\n   typedef void (*_GLIBCXX11_DEPRECATED unexpected_handler) ();\n "}, {"sha": "bbf5b900f4cdc6894774f6bb0e6d42cb9e19aea4", "filename": "libstdc++-v3/testsuite/20_util/expected/assign.cc", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fassign.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,321 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+\n+int dtor_count;\n+constexpr void reset_dtor_count()\n+{\n+  if (!std::is_constant_evaluated())\n+    dtor_count = 0;\n+}\n+constexpr void inc_dtor_count()\n+{\n+  if (!std::is_constant_evaluated())\n+    ++dtor_count;\n+}\n+constexpr bool check_dtor_count(int c)\n+{\n+  if (std::is_constant_evaluated())\n+    return true;\n+  return dtor_count == c;\n+}\n+\n+struct X\n+{\n+  constexpr X(int i, int j = 0) noexcept : n(i+j) { }\n+  constexpr X(std::initializer_list<int> l, void*) noexcept : n(l.size()) { }\n+\n+  constexpr X(const X&) = default;\n+  constexpr X(X&& x) noexcept : n(x.n) { x.n = -1; }\n+\n+  constexpr X& operator=(const X&) = default;\n+  constexpr X& operator=(X&& x) noexcept { n = x.n; x.n = -1; return *this; }\n+\n+  constexpr ~X()\n+  {\n+    inc_dtor_count();\n+  }\n+\n+  constexpr bool operator==(const X&) const = default;\n+  constexpr bool operator==(int i) const { return n == i; }\n+\n+  int n;\n+};\n+\n+constexpr bool\n+test_copy(bool = true)\n+{\n+  reset_dtor_count();\n+\n+  std::expected<int, int> e1(1), e2(2), e3(std::unexpect, 3);\n+\n+  e1 = e1;\n+  e1 = e2; // T = T\n+  VERIFY( e1.value() == e2.value() );\n+  e1 = e3; // T = E\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == e3.error() );\n+  e1 = e3; // E = E\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == e3.error() );\n+  e1 = e2; // E = T\n+  VERIFY( e1.value() == e2.value() );\n+\n+  e1 = std::move(e1);\n+  e1 = std::move(e2); // T = T\n+  VERIFY( e1.value() == e2.value() );\n+  e1 = std::move(e3); // T = E\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == e3.error() );\n+  e1 = std::move(e3); // E = E\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == e3.error() );\n+  e1 = std::move(e2); // E = T\n+  VERIFY( e1.value() == e2.value() );\n+\n+  std::expected<X, X> x1(1), x2(2), x3(std::unexpect, 3);\n+\n+  x1 = x1;\n+\n+  x1 = x2; // T = T\n+  VERIFY( check_dtor_count(0) );\n+  VERIFY( x1.value() == x2.value() );\n+  x1 = x3; // T = E\n+  VERIFY( check_dtor_count(1) );\n+  VERIFY( ! x1.has_value() );\n+  x1 = x3; // E = E\n+  VERIFY( check_dtor_count(1) );\n+  VERIFY( ! x1.has_value() );\n+  x1 = x2; // E = T\n+  VERIFY( check_dtor_count(2) );\n+  VERIFY( x1.value() == x2.value() );\n+\n+  reset_dtor_count();\n+\n+  x1 = std::move(x1);\n+  VERIFY( x1.value() == -1 );\n+\n+  x1 = std::move(x2); // T = T\n+  VERIFY( check_dtor_count(0) );\n+  VERIFY( x1.value() == 2 );\n+  VERIFY( x2.value() == -1 );\n+  x1 = std::move(x3); // T = E\n+  VERIFY( check_dtor_count(1) );\n+  VERIFY( ! x1.has_value() );\n+  VERIFY( x1.error() == 3 );\n+  VERIFY( x3.error() == -1 );\n+  x3.error().n = 33;\n+  x1 = std::move(x3); // E = E\n+  VERIFY( check_dtor_count(1) );\n+  VERIFY( ! x1.has_value() );\n+  VERIFY( x1.error() == 33 );\n+  VERIFY( x3.error() == -1 );\n+  x2.value().n = 22;\n+  x1 = std::move(x2); // E = T\n+  VERIFY( check_dtor_count(2) );\n+  VERIFY( x1.value() == 22 );\n+  VERIFY( x2.value() == -1 );\n+\n+  std::expected<void, int> ev1, ev2, ev3(std::unexpect, 3);\n+\n+  ev1 = ev2; // T = T\n+  VERIFY( ev1.has_value() );\n+  ev1 = ev3; // T = E\n+  VERIFY( ! ev1.has_value() );\n+  VERIFY( ev1.error() == ev3.error() );\n+  ev1 = ev3; // E = E\n+  VERIFY( ! ev1.has_value() );\n+  VERIFY( ev1.error() == ev3.error() );\n+  ev1 = ev2; // E = T\n+  VERIFY( ev1.has_value() );\n+\n+  reset_dtor_count();\n+  std::expected<void, X> xv1, xv2, xv3(std::unexpect, 3);\n+\n+  xv1 = std::move(xv2); // T = T\n+  VERIFY( check_dtor_count(0) );\n+  VERIFY( xv1.has_value() );\n+  xv1 = std::move(xv3); // T = E\n+  VERIFY( check_dtor_count(0) );\n+  VERIFY( ! xv1.has_value() );\n+  VERIFY( xv1.error() == 3 );\n+  VERIFY( xv3.error() == -1 );\n+  xv3.error().n = 33;\n+  xv1 = std::move(xv3); // E = E\n+  VERIFY( check_dtor_count(0) );\n+  VERIFY( xv1.error() == 33 );\n+  VERIFY( xv3.error() == -1 );\n+  xv1 = std::move(xv2); // E = T\n+  VERIFY( check_dtor_count(1) );\n+  VERIFY( xv1.has_value() );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_converting(bool = true)\n+{\n+  std::expected<int, int> e1(1);\n+  std::expected<unsigned, long> e2(2U), e3(std::unexpect, 3L);\n+  e1 = e2;\n+  VERIFY( e1.value() == e2.value() );\n+  e1 = e3;\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == e3.error() );\n+  e1 = e2;\n+  VERIFY( e1.value() == e2.value() );\n+\n+  e1 = std::move(e3);\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == e3.error() );\n+  e1 = std::move(e2);\n+  VERIFY( e1.value() == e2.value() );\n+\n+  std::expected<void, int> ev4;\n+  std::expected<const void, long> ev5(std::unexpect, 5);\n+  ev4 = ev5;\n+  VERIFY( ! ev4.has_value() );\n+  VERIFY( ev4.error() == 5 );\n+  ev4 = std::expected<volatile void, unsigned>();\n+  VERIFY( ev4.has_value() );\n+  ev4 = std::move(ev5);\n+  VERIFY( ! ev4.has_value() );\n+  VERIFY( ev4.error() == 5 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_unexpected(bool = true)\n+{\n+  reset_dtor_count();\n+\n+  std::expected<X, int> e1(0);\n+\n+  e1 = std::unexpected<int>(5);\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == 5 );\n+  VERIFY( check_dtor_count(1) );\n+\n+  e1 = std::unexpected<int>(6);\n+  VERIFY( check_dtor_count(1) );\n+\n+  std::expected<int, X> e2;\n+\n+  std::unexpected<X> x(std::in_place, 1, 2);\n+  e2 = x;\n+  VERIFY( check_dtor_count(1) );\n+\n+  e2 = 1;\n+  VERIFY( e2.value() == 1 );\n+  VERIFY( check_dtor_count(2) );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_emplace(bool = true)\n+{\n+  reset_dtor_count();\n+\n+  std::expected<int, int> e1(1);\n+  e1.emplace(2);\n+  VERIFY( e1.value() == 2 );\n+\n+  std::expected<void, int> ev2;\n+  ev2.emplace();\n+  VERIFY( ev2.has_value() );\n+\n+  std::expected<X, int> e3(std::in_place, 0, 0);\n+\n+  e3.emplace({1,2,3}, nullptr);\n+  VERIFY( e3.value() == 3 );\n+  VERIFY( check_dtor_count(1) );\n+\n+  e3.emplace(2, 2);\n+  VERIFY( e3.value() == 4 );\n+  VERIFY( check_dtor_count(2) );\n+\n+  std::expected<int, X> ev4(std::unexpect, 4);\n+\n+  ev4.emplace(5);\n+  VERIFY( ev4.value() == 5 );\n+  VERIFY( check_dtor_count(3) );\n+\n+  ev4.emplace(6);\n+  VERIFY( ev4.value() == 6 );\n+  VERIFY( check_dtor_count(3) );\n+\n+  return true;\n+}\n+\n+void\n+test_exception_safety()\n+{\n+  struct CopyThrows\n+  {\n+    CopyThrows(int i) noexcept : x(i) { }\n+    CopyThrows(const CopyThrows&) { throw 1; }\n+    CopyThrows(CopyThrows&&) = default;\n+    CopyThrows& operator=(const CopyThrows&) = default;\n+    CopyThrows& operator=(CopyThrows&&) = default;\n+    int x;\n+\n+    bool operator==(int i) const { return x == i; }\n+  };\n+\n+  struct MoveThrows\n+  {\n+    MoveThrows(int i) noexcept : x(i) { }\n+    MoveThrows(const MoveThrows&) = default;\n+    MoveThrows(MoveThrows&&) { throw 1L; }\n+    MoveThrows& operator=(const MoveThrows&) = default;\n+    MoveThrows& operator=(MoveThrows&&) = default;\n+    int x;\n+\n+    bool operator==(int i) const { return x == i; }\n+  };\n+\n+  std::expected<CopyThrows, MoveThrows> c(std::unexpect, 1);\n+\n+  // operator=(U&&)\n+  try {\n+    CopyThrows x(2);\n+    c = x;\n+    VERIFY( false );\n+  } catch (int) {\n+    VERIFY( ! c.has_value() );\n+    VERIFY( c.error() == 1 );\n+  }\n+\n+  c = CopyThrows(2);\n+\n+  try {\n+    c = std::unexpected<MoveThrows>(3);\n+    VERIFY( false );\n+  } catch (long) {\n+    VERIFY( c.value() == 2 );\n+  }\n+}\n+\n+int main(int argc, char**)\n+{\n+  bool non_constant = argc == 1; // force non-constant evaluation\n+\n+  static_assert( test_copy() );\n+  test_copy(non_constant);\n+  static_assert( test_converting() );\n+  test_converting(non_constant);\n+  static_assert( test_unexpected() );\n+  test_unexpected(non_constant);\n+  static_assert( test_emplace() );\n+  test_emplace(non_constant);\n+\n+  test_exception_safety();\n+\n+  // Ensure the non-constexpr tests actually ran:\n+  VERIFY( dtor_count != 0 );\n+}"}, {"sha": "1fe5b7bf4d11ad26fad2d7be9bc6ffcd75dc4184", "filename": "libstdc++-v3/testsuite/20_util/expected/cons.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fcons.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,175 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_default()\n+{\n+  std::expected<int, int> e;\n+  VERIFY( e.has_value() );\n+  VERIFY( *e == 0 );\n+\n+  std::expected<void, int> ev;\n+  VERIFY( ev.has_value() );\n+  VERIFY( (ev.value(), true) );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_val()\n+{\n+  std::expected<int, int> e1(1);\n+  VERIFY( e1.has_value() );\n+  VERIFY( *e1 == 1 );\n+\n+  std::expected<int, int> e2(std::in_place, 2);\n+  VERIFY( e2.has_value() );\n+  VERIFY( *e2 == 2 );\n+\n+  struct X\n+  {\n+    constexpr X(std::initializer_list<int> l, void*) : n(l.size()) { }\n+    int n;\n+  };\n+\n+  std::expected<X, int> e3(X{{1, 2, 3}, nullptr});\n+  VERIFY( e3.has_value() );\n+  VERIFY( e3->n == 3 );\n+\n+  std::expected<X, int> e4(std::in_place, {1, 2, 3, 4}, nullptr);\n+  VERIFY( e4.has_value() );\n+  VERIFY( e4->n == 4 );\n+\n+  std::expected<void, int> ev(std::in_place);\n+  VERIFY( ev.has_value() );\n+  VERIFY( (ev.value(), true) );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_err()\n+{\n+  std::expected<int, int> e1(std::unexpected<int>(1));\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == 1 );\n+\n+  const std::unexpected<int> u2(2);\n+  std::expected<int, int> e2(u2);\n+  VERIFY( ! e2.has_value() );\n+  VERIFY( e2.error() == 2 );\n+\n+  std::expected<int, int> e3(std::unexpect, 3);\n+  VERIFY( ! e3.has_value() );\n+  VERIFY( e3.error() == 3 );\n+\n+  struct X\n+  {\n+    constexpr X(int i, int j) : n(i+j) { }\n+    constexpr X(std::initializer_list<int> l, void*) : n(l.size()) { }\n+    int n;\n+  };\n+\n+  std::expected<int, X> e4(std::unexpect, 1, 3);\n+  VERIFY( ! e4.has_value() );\n+  VERIFY( e4.error().n == 4 );\n+\n+  std::expected<int, X> e5(std::unexpect, {1, 2, 3, 4, 5}, nullptr);\n+  VERIFY( ! e5.has_value() );\n+  VERIFY( e5.error().n == 5 );\n+\n+  std::expected<const void, int> ev1(std::unexpected<int>(1));\n+  VERIFY( ! ev1.has_value() );\n+  VERIFY( ev1.error() == 1 );\n+\n+  std::expected<volatile void, int> ev2(u2);\n+  VERIFY( ! ev2.has_value() );\n+  VERIFY( ev2.error() == 2 );\n+\n+  std::expected<const volatile void, int> ev3(std::unexpect, 3);\n+  VERIFY( ! ev3.has_value() );\n+  VERIFY( ev3.error() == 3 );\n+\n+  std::expected<void, X> ev4(std::unexpect, 1, 3);\n+  VERIFY( ! ev4.has_value() );\n+  VERIFY( ev4.error().n == 4 );\n+\n+  std::expected<void, X> ev5(std::unexpect, {1, 2, 3, 4, 5}, nullptr);\n+  VERIFY( ! ev5.has_value() );\n+  VERIFY( ev5.error().n == 5 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_copy()\n+{\n+  std::expected<int, int> e1(1);\n+  std::expected<int, int> e2(e1);\n+  VERIFY( e2.value() == 1 );\n+  std::expected<int, int> e3(std::move(e2));\n+  VERIFY( e2.value() == 1 );\n+  VERIFY( e3.value() == 1 );\n+  std::expected<short, short> e4(e1);\n+  VERIFY( e4.value() == 1 );\n+  std::expected<short, short> e5(std::move(e4));\n+  VERIFY( e4.value() == 1 );\n+  VERIFY( e5.value() == 1 );\n+\n+  std::expected<int, int> u1(std::unexpect, 2);\n+  std::expected<int, int> u2(u1);\n+  VERIFY( ! u2.has_value() );\n+  VERIFY( u2.error() == 2 );\n+  std::expected<int, int> u3(std::move(u2));\n+  VERIFY( ! u3.has_value() );\n+  VERIFY( u3.error() == 2 );\n+  std::expected<short, short> u4(u1);\n+  VERIFY( ! u4.has_value() );\n+  VERIFY( u4.error() == 2 );\n+  std::expected<short, short> u5(std::move(u4));\n+  VERIFY( ! u5.has_value() );\n+  VERIFY( u5.error() == 2 );\n+\n+  std::expected<void, int> ev1;\n+  std::expected<void, int> ev2(ev1);\n+  VERIFY( ev2.has_value() );\n+  std::expected<void, int> ev3(std::move(ev2));\n+  VERIFY( ev2.has_value() );\n+  VERIFY( ev3.has_value() );\n+  std::expected<volatile void, short> ev4(ev1);\n+  VERIFY( ev4.has_value() );\n+  std::expected<const void, short> ev5(std::move(ev4));\n+  VERIFY( ev4.has_value() );\n+  VERIFY( ev5.has_value() );\n+\n+  std::expected<void, int> uv1(std::unexpect, 2);\n+  std::expected<void, int> uv2(uv1);\n+  VERIFY( ! uv2.has_value() );\n+  VERIFY( uv2.error() == 2 );\n+  std::expected<void, int> uv3(std::move(uv2));\n+  VERIFY( ! uv3.has_value() );\n+  VERIFY( uv3.error() == 2 );\n+  std::expected<const void, short> uv4(uv1);\n+  VERIFY( ! uv4.has_value() );\n+  VERIFY( uv4.error() == 2 );\n+  std::expected<volatile void, short> uv5(std::move(uv4));\n+  VERIFY( ! uv5.has_value() );\n+  VERIFY( uv5.error() == 2 );\n+\n+  return true;\n+}\n+\n+int main()\n+{\n+  test_default();\n+  static_assert( test_default() );\n+  test_val();\n+  static_assert( test_val() );\n+  test_err();\n+  static_assert( test_err() );\n+  test_copy();\n+  static_assert( test_copy() );\n+}"}, {"sha": "921306bc667c8391e3d7582086dab46c8bd23ca3", "filename": "libstdc++-v3/testsuite/20_util/expected/illformed_neg.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fillformed_neg.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,67 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <expected>\n+\n+void\n+test_unexpected()\n+{\n+  int i[2]{};\n+\n+  // std::unexpected<E> is ill-formed if E is a non-object type,\n+\n+  std::unexpected<int&> ref(i[0]); // { dg-error \"here\" }\n+  std::unexpected<void()> func(test_unexpected); // { dg-error \"here\" }\n+  // { dg-error \"no matching function for call to\" \"\" { target *-*-* } 0 }\n+  // { dg-error \"invalidly declared function type\" \"\" { target *-*-* } 0 }\n+\n+  // an array type,\n+  std::unexpected<int[2]> array(i); // { dg-error \"here\" }\n+\n+  // a specialization of std::unexpected,\n+  std::unexpected<int> u(1);\n+  std::unexpected<std::unexpected<int>> nested(u); // { dg-error \"here\" }\n+\t\t\t\t\t\t   //\n+  // or a cv-qualified type.\n+  std::unexpected<const int> c_int(1); // { dg-error \"here\" }\n+  std::unexpected<volatile int> v_int(1); // { dg-error \"here\" }\n+}\n+\n+void\n+test_expected_value()\n+{\n+  // std::expected<T, E> is ill-formed if T is a reference type,\n+  std::expected<int&, int> ref(std::unexpect); // { dg-error \"here\" }\n+  //  { dg-error \"reference type\" \"\" { target *-*-* } 0 }\n+\n+  // a function type,\n+  std::expected<void(), int> func(std::unexpect); // { dg-error \"here\" }\n+  //  { dg-error \"returning a function\" \"\" { target *-*-* } 0 }\n+\t\t\t\t\t\t //\n+  // possibly cv-qualified types in_place_t,\n+  std::expected<std::in_place_t, int> tag(std::unexpect); // { dg-error \"here\" }\n+  std::expected<const std::in_place_t, int> ctag(std::unexpect); // { dg-error \"here\" }\n+  // unexpect_t,\n+  std::expected<std::unexpect_t, int> utag(std::unexpect); // { dg-error \"here\" }\n+  std::expected<const std::unexpect_t, int> cutag(std::unexpect); // { dg-error \"here\" }\n+  // or a specialization of unexpected.\n+  std::expected<std::unexpected<int>, int> unex(std::in_place, 1); // { dg-error \"here\" }\n+  std::expected<const std::unexpected<int>, int> cunex(std::in_place, 1); // { dg-error \"here\" }\n+}\n+\n+void\n+test_expected_error()\n+{\n+\n+  // std::expected<T, E> is ill-formed if std::unexpected<E> would be\n+  // ill-formed. Test the same types as in test_unexpected().\n+\n+  std::expected<int, int&> ref; // { dg-error \"here\" }\n+  std::expected<int, void()> func; // { dg-error \"here\" }\n+  std::expected<int, int[2]> array; // { dg-error \"here\" }\n+  std::expected<int, std::unexpected<int>> nested; // { dg-error \"here\" }\n+  std::expected<int, const int> c_int; // { dg-error \"here\" }\n+  std::expected<int, volatile int> v_int; // { dg-error \"here\" }\n+}\n+\n+// { dg-prune-output \"static assertion failed\" }"}, {"sha": "e76ca3780266e97a1b07ca198550ace6737c8810", "filename": "libstdc++-v3/testsuite/20_util/expected/observers.cc", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fobservers.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,209 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <expected>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  constexpr int f() & { return 1; }\n+  constexpr int f() const & { return 2; }\n+  constexpr int f() && { return 3; }\n+  constexpr int f() const && { return 4; }\n+};\n+\n+constexpr bool\n+test_arrow()\n+{\n+  std::expected<X, int> e1;\n+  VERIFY( e1->f() == 1 );\n+  const auto& e2 = e1;\n+  VERIFY( e2->f() == 2 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_star()\n+{\n+  std::expected<X, int> e1;\n+  VERIFY( (*e1).f() == 1 );\n+  VERIFY( std::move(*e1).f() == 3 );\n+  const auto& e2 = e1;\n+  VERIFY( (*e2).f() == 2 );\n+  VERIFY( std::move(*e2).f() == 4 );\n+\n+  std::expected<void, int> v;\n+  *v;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_has_value()\n+{\n+  std::expected<int, int> e;\n+  VERIFY( e.has_value() );\n+  VERIFY( e );\n+  e = std::unexpected(1);\n+  VERIFY( ! e.has_value() );\n+  VERIFY( ! e );\n+\n+  std::expected<void, int> v;\n+  VERIFY( v.has_value() );\n+  VERIFY( v );\n+  v = std::unexpected(1);\n+  VERIFY( ! v.has_value() );\n+  VERIFY( ! v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_value()\n+{\n+  std::expected<X, int> e1;\n+\n+  VERIFY( e1.value().f() == 1 );\n+  VERIFY( std::move(e1).value().f() == 3 );\n+  const auto& e2 = e1;\n+  VERIFY( e2.value().f() == 2 );\n+  VERIFY( std::move(e2).value().f() == 4 );\n+\n+  std::expected<void, int> v1;\n+  v1.value();\n+  std::move(v1).value();\n+\n+  return true;\n+}\n+\n+void\n+test_value_throw()\n+{\n+  std::expected<int, int> e1 = std::unexpected(9);\n+\n+  try {\n+    e1.value();\n+    VERIFY( false );\n+  } catch (const std::bad_expected_access<int>& e) {\n+    VERIFY( e.error() == 9 );\n+  }\n+  try {\n+    std::move(e1).value();\n+    VERIFY( false );\n+  } catch (const std::bad_expected_access<int>& e) {\n+    VERIFY( e.error() == 9 );\n+  }\n+\n+  const auto& e2 = e1;\n+  try {\n+    e2.value();\n+    VERIFY( false );\n+  } catch (const std::bad_expected_access<int>& e) {\n+    VERIFY( e.error() == 9 );\n+  }\n+  try {\n+    std::move(e2).value();\n+    VERIFY( false );\n+  } catch (const std::bad_expected_access<int>& e) {\n+    VERIFY( e.error() == 9 );\n+  }\n+\n+  std::expected<void, int> v1 = std::unexpected(8);\n+  try {\n+    v1.value();\n+    VERIFY( false );\n+  } catch (const std::bad_expected_access<int>& e) {\n+    VERIFY( e.error() == 8 );\n+  }\n+  try {\n+    std::move(v1).value();\n+    VERIFY( false );\n+  } catch (const std::bad_expected_access<int>& e) {\n+    VERIFY( e.error() == 8 );\n+  }\n+}\n+\n+constexpr bool\n+test_error()\n+{\n+  std::expected<int, X> e1(std::unexpect);\n+\n+  VERIFY( e1.error().f() == 1 );\n+  VERIFY( std::move(e1).error().f() == 3 );\n+  const auto& e2 = e1;\n+  VERIFY( e2.error().f() == 2 );\n+  VERIFY( std::move(e2).error().f() == 4 );\n+\n+  std::expected<void, X> v1(std::unexpect);\n+\n+  VERIFY( v1.error().f() == 1 );\n+  VERIFY( std::move(v1).error().f() == 3 );\n+  const auto& v2 = v1;\n+  VERIFY( v2.error().f() == 2 );\n+  VERIFY( std::move(v2).error().f() == 4 );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test_value_or()\n+{\n+  struct Movable\n+  {\n+    constexpr Movable(int i) : x(i) { }\n+    constexpr Movable(const Movable&) = default;\n+    constexpr Movable(Movable&& m) : x(m.x) { m.x = -1; }\n+    int x;\n+\n+    constexpr bool operator==(int i) const { return x == i; }\n+  };\n+\n+  std::expected<Movable, int> e1(1);\n+\n+  Movable m2(2);\n+  VERIFY( e1.value_or(2) == 1 );\n+  VERIFY( e1.value_or(m2) == 1 );\n+  VERIFY( e1.value_or(std::move(m2)) == 1 );\n+  VERIFY( m2 == 2 );\n+\n+  VERIFY( std::move(e1).value_or(m2) == 1 );\n+  VERIFY( *e1 == -1 ); // moved\n+  VERIFY( m2 == 2 );\n+\n+  e1 = std::unexpected(3);\n+  VERIFY( e1.value_or(m2) == 2 );\n+  VERIFY( m2 == 2 );\n+  VERIFY( std::move(e1).value_or(m2) == 2 );\n+  VERIFY( m2 == 2 );\n+\n+  VERIFY( e1.value_or(std::move(m2)) == 2 );\n+  VERIFY( m2 == -1 );\n+\n+  m2.x = 4;\n+  VERIFY( std::move(e1).value_or(std::move(m2)) == 4 );\n+  VERIFY( m2 == -1 );\n+\n+  VERIFY( e1.value_or(5) == 5 );\n+  VERIFY( std::move(e1).value_or(6) == 6 );\n+\n+  return true;\n+}\n+\n+int main()\n+{\n+  static_assert( test_arrow() );\n+  test_arrow();\n+  static_assert( test_star() );\n+  test_star();\n+  static_assert( test_has_value() );\n+  test_has_value();\n+  static_assert( test_value() );\n+  test_value();\n+  test_value_throw();\n+  static_assert( test_error() );\n+  test_error();\n+  static_assert( test_value_or() );\n+  test_value_or();\n+}"}, {"sha": "485aa338679c19aa56e0248a1f447d30e218b5a0", "filename": "libstdc++-v3/testsuite/20_util/expected/requirements.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Frequirements.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,129 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <expected>\n+#include <type_traits>\n+\n+// Default construction\n+\n+template<typename T, typename E>\n+  constexpr bool default_constructible\n+    = std::is_default_constructible_v<std::expected<T, E>>;\n+\n+struct A { A(int); };\n+\n+static_assert( default_constructible< int,  int > );\n+static_assert( default_constructible< A,    int > == false );\n+static_assert( default_constructible< int,  A   > );\n+static_assert( default_constructible< A,    A   > == false );\n+static_assert( default_constructible< int,  A   > );\n+static_assert( default_constructible< void, int > );\n+\n+// Destruction\n+\n+template<typename T, typename E>\n+  constexpr bool trivially_destructible\n+    = std::is_trivially_destructible_v<std::expected<T, E>>;\n+\n+struct B { ~B(); };\n+\n+static_assert( trivially_destructible< int,  int > );\n+static_assert( trivially_destructible< B,    int > == false );\n+static_assert( trivially_destructible< int,  B   > == false );\n+static_assert( trivially_destructible< B,    B   > == false );\n+static_assert( trivially_destructible< void, int > );\n+static_assert( trivially_destructible< void, B   > == false );\n+\n+enum Result { No, Yes, NoThrow, Trivial };\n+\n+// Copy construction\n+\n+template<typename T, typename E>\n+  constexpr Result copy_constructible\n+    = std::is_trivially_copy_constructible_v<std::expected<T, E>> ? Trivial\n+    : std::is_copy_constructible_v<std::expected<T, E>> ? Yes\n+    : No;\n+\n+struct C { C(const C&); };\n+struct D { D(D&&); };\n+\n+static_assert( copy_constructible< int,  int > == Trivial );\n+static_assert( copy_constructible< C,    C   > == Yes );\n+static_assert( copy_constructible< C,    int > == Yes );\n+static_assert( copy_constructible< int,  C   > == Yes );\n+static_assert( copy_constructible< int,  D   > == No );\n+static_assert( copy_constructible< D,    int > == No );\n+static_assert( copy_constructible< D,    D   > == No );\n+static_assert( copy_constructible< void, int > == Trivial );\n+static_assert( copy_constructible< void, C   > == Yes );\n+static_assert( copy_constructible< void, D   > == No );\n+\n+// Move construction\n+\n+template<typename T, typename E>\n+  constexpr Result move_constructible\n+    = std::is_trivially_move_constructible_v<std::expected<T, E>> ? Trivial\n+    : std::is_nothrow_move_constructible_v<std::expected<T, E>> ? NoThrow\n+    : std::is_move_constructible_v<std::expected<T, E>> ? Yes\n+    : No;\n+\n+struct E { E(E&&) noexcept; };\n+\n+static_assert( move_constructible< int,  int > == Trivial );\n+static_assert( move_constructible< C,    C   > == Yes );\n+static_assert( move_constructible< C,    int > == Yes );\n+static_assert( move_constructible< int,  C   > == Yes );\n+static_assert( move_constructible< D,    D   > == Yes );\n+static_assert( move_constructible< D,    int > == Yes );\n+static_assert( move_constructible< int,  D   > == Yes );\n+static_assert( move_constructible< E,    E   > == NoThrow );\n+static_assert( move_constructible< E,    int > == NoThrow );\n+static_assert( move_constructible< int,  E   > == NoThrow );\n+static_assert( move_constructible< void, int > == Trivial );\n+static_assert( move_constructible< void, C   > == Yes );\n+static_assert( move_constructible< void, D   > == Yes );\n+static_assert( move_constructible< void, E   > == NoThrow );\n+\n+// Copy assignment\n+\n+template<typename T, typename E>\n+  constexpr bool copy_assignable\n+    = std::is_copy_assignable_v<std::expected<T, E>>;\n+\n+struct F { F(F&&); F& operator=(const F&); }; // not copy-constructible\n+struct G { G(const G&); G(G&&); G& operator=(const G&); }; // throwing move\n+\n+static_assert( copy_assignable< int,  int > );\n+static_assert( copy_assignable< F,    int > == false );\n+static_assert( copy_assignable< int,  F   > == false );\n+static_assert( copy_assignable< F,    F   > == false );\n+static_assert( copy_assignable< G,    int > );\n+static_assert( copy_assignable< int,  G   > );\n+static_assert( copy_assignable< G,    G   > == false );\n+static_assert( copy_assignable< void, int > );\n+static_assert( copy_assignable< void, F > == false );\n+static_assert( copy_assignable< void, G > );\n+\n+// Move assignment\n+\n+template<typename T, typename E>\n+  constexpr bool move_assignable\n+    = std::is_move_assignable_v<std::expected<T, E>>;\n+\n+static_assert( move_assignable< int,  int > );\n+static_assert( move_assignable< F,    int > );\n+static_assert( move_assignable< int,  F   > );\n+static_assert( move_assignable< F,    F   > == false );\n+static_assert( move_assignable< G,    int > );\n+static_assert( move_assignable< int,  G   > );\n+static_assert( move_assignable< G,    G   > == false );\n+static_assert( move_assignable< void, int > );\n+static_assert( move_assignable< void, F > );\n+static_assert( move_assignable< void, G > );\n+\n+// QoI properties\n+static_assert( sizeof(std::expected<char, unsigned char>) == 2 );\n+static_assert( sizeof(std::expected<void, char>) == 2 );\n+static_assert( sizeof(std::expected<void*, char>) == 2 * __alignof(void*) );\n+static_assert( alignof(std::expected<void, char>) == 1 );\n+static_assert( alignof(std::expected<void*, char>) == alignof(void*) );"}, {"sha": "1b3b8c5f4e87f0d537146faaa24704c625379c40", "filename": "libstdc++-v3/testsuite/20_util/expected/swap.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fswap.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test_swap()\n+{\n+  std::expected<int, int> e1(1), e2(2);\n+  std::expected<int, int> e3(std::unexpect, 3), e4(std::unexpect, 4);\n+\n+  swap(e1, e2);\n+  VERIFY( e1.value() == 2 );\n+  VERIFY( e2.value() == 1 );\n+  swap(e1, e3);\n+  VERIFY( ! e1.has_value() );\n+  VERIFY( e1.error() == 3 );\n+  VERIFY( e3.value() == 2 );\n+  swap(e1, e3);\n+  VERIFY( ! e3.has_value() );\n+  VERIFY( e1.value() == 2 );\n+  VERIFY( e3.error() == 3 );\n+  swap(e3, e4);\n+  VERIFY( ! e3.has_value() );\n+  VERIFY( ! e4.has_value() );\n+  VERIFY( e3.error() == 4 );\n+  VERIFY( e4.error() == 3 );\n+\n+  std::expected<int, int> v1(1), v2(2);\n+  std::expected<int, int> v3(std::unexpect, 3), v4(std::unexpect, 4);\n+\n+  swap(v1, v2);\n+  VERIFY( v1.value() == 2 );\n+  VERIFY( v2.value() == 1 );\n+  swap(v1, v3);\n+  VERIFY( ! v1.has_value() );\n+  VERIFY( v1.error() == 3 );\n+  VERIFY( v3.value() == 2 );\n+  swap(v1, v3);\n+  VERIFY( ! v3.has_value() );\n+  VERIFY( v1.value() == 2 );\n+  VERIFY( v3.error() == 3 );\n+  swap(v3, v4);\n+  VERIFY( ! v3.has_value() );\n+  VERIFY( ! v4.has_value() );\n+  VERIFY( v3.error() == 4 );\n+  VERIFY( v4.error() == 3 );\n+\n+  return true;\n+}\n+\n+int main()\n+{\n+  static_assert( test_swap() );\n+  test_swap();\n+}"}, {"sha": "304bae93ebd0237c3599f56bf1e4c51ad36fc5c6", "filename": "libstdc++-v3/testsuite/20_util/expected/synopsis.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fsynopsis.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <expected>\n+\n+#ifndef __cpp_lib_expected\n+# error \"Feature-test macro for expected missing in <expected>\"\n+#elif __cpp_lib_expected != 202202L\n+# error \"Feature-test macro for expected has wrong value in <expected>\"\n+#endif\n+\n+namespace std\n+{\n+  template<class E> class unexpected;\n+  template<class E> class bad_expected_access;\n+  template<> class bad_expected_access<void>;\n+  struct unexpect_t;\n+  extern inline const unexpect_t unexpect;\n+  template<class T, class E> class expected;\n+  template<class T, class E> requires is_void_v<T> class expected<T, E>;\n+}"}, {"sha": "d4cbeadf674afd60705a42215e71016d56b23b4a", "filename": "libstdc++-v3/testsuite/20_util/expected/unexpected.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Funexpected.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Funexpected.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Funexpected.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <expected>\n+#include <testsuite_hooks.h>\n+\n+static_assert( sizeof(std::unexpected<char>) == 1 );\n+\n+constexpr bool\n+test()\n+{\n+  std::unexpected<int> u1(1);\n+  VERIFY( u1.error() == 1 );\n+\n+  std::unexpected<int> u2(std::in_place, 2);\n+  VERIFY( u2.error() == 2 );\n+\n+  struct X\n+  {\n+    constexpr X(int i, int j) : n(i+j) { }\n+    constexpr X(std::initializer_list<int> l, void*) : n(l.size()) { }\n+\n+    constexpr X(const X&) = default;\n+    constexpr X(X&& x) :n(x.n) { x.n = -1; }\n+\n+    constexpr X& operator=(const X&) = default;\n+    constexpr X& operator=(X&& x) { n = x.n; x.n = -1; return *this; }\n+\n+    constexpr bool operator==(const X&) const = default;\n+    constexpr bool operator==(int i) const { return n == i; }\n+\n+    int n;\n+  };\n+\n+  std::unexpected<X> u3(std::in_place, 2, 1);\n+  VERIFY( u3.error() == 3 );\n+\n+  std::unexpected<X> u4(std::in_place, {1,2,3,4}, nullptr);\n+  VERIFY( u4.error() == 4 );\n+\n+  std::unexpected<X> u5(u4);\n+  VERIFY( u5.error() == 4 );\n+  VERIFY( u4.error() == 4 );\n+\n+  std::unexpected<X> u6(std::move(u4));\n+  VERIFY( u6.error() == 4 );\n+  VERIFY( u4.error() == -1 );\n+\n+  u6 = u3;\n+  VERIFY( u6.error() == 3 );\n+  VERIFY( u3.error() == 3 );\n+\n+  u5 = std::move(u3);\n+  VERIFY( u5.error() == 3 );\n+  VERIFY( u3.error() == -1 );\n+\n+  u5.swap(u3);\n+  VERIFY( u3.error() == 3 );\n+  VERIFY( u5.error() == -1 );\n+\n+  swap(u5, u3);\n+  VERIFY( u5.error() == 3 );\n+  VERIFY( u3.error() == -1 );\n+\n+  VERIFY( u1 == u1 );\n+  VERIFY( u1 != u2 );\n+  VERIFY( u3 == u4 );\n+\n+  // CTAD\n+  std::unexpected u7(1L);\n+  static_assert( std::is_same_v<decltype(u7), std::unexpected<long>> );\n+\n+  return true;\n+}\n+\n+int main()\n+{\n+  static_assert( test() );\n+  test();\n+}"}, {"sha": "78dc61ef55d019cb92d640d5625f6e255ff19ce6", "filename": "libstdc++-v3/testsuite/20_util/expected/version.cc", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78e0ce28b32a1b89886219c557506aeae6caffc/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fexpected%2Fversion.cc?ref=b78e0ce28b32a1b89886219c557506aeae6caffc", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do preprocess { target c++23 } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_expected\n+# error \"Feature-test macro for expected missing in <version>\"\n+#elif __cpp_lib_expected != 202202L\n+# error \"Feature-test macro for expected has wrong value in <version>\"\n+#endif"}]}