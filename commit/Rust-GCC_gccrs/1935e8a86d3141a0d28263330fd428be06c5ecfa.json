{"sha": "1935e8a86d3141a0d28263330fd428be06c5ecfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzNWU4YTg2ZDMxNDFhMGQyODI2MzMzMGZkNDI4YmUwNmM1ZWNmYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-04-14T02:28:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-04-14T02:28:46Z"}, "message": "basic-block.h (REG_BASIC_BLOCK): Use VEC instead of VARRAY.\n\n\t* basic-block.h (REG_BASIC_BLOCK): Use VEC instead of VARRAY.\n\t* flow.c (reg_n_info): Change the type to\n\tVEC(reg_info_p,heap) *.\n\t* regclass.c (allocate_reg_info, free_reg_info): Use VEC\n\tinstead of VARRAY.\n\t* regs.h (reg_info_p): New.\n\t(REG_N_REFS, REG_FREQ, REG_N_SETS, REG_N_DEATHS,\n\tREG_N_CALLS_CROSSED, REG_N_THROWING_CALLS_CROSSED,\n\tREG_LIVE_LENGTH, REGNO_FIRST_UID, REGNO_LAST_UID): Use VEC\n\tinstead of VARRAY.\n\nFrom-SVN: r112942", "tree": {"sha": "17efbc0a6f42d3bc2e77211baecf71bc557f15d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17efbc0a6f42d3bc2e77211baecf71bc557f15d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1935e8a86d3141a0d28263330fd428be06c5ecfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1935e8a86d3141a0d28263330fd428be06c5ecfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1935e8a86d3141a0d28263330fd428be06c5ecfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1935e8a86d3141a0d28263330fd428be06c5ecfa/comments", "author": null, "committer": null, "parents": [{"sha": "062e124a4c940665698d4d596d1327c741854f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062e124a4c940665698d4d596d1327c741854f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062e124a4c940665698d4d596d1327c741854f83"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "9baf93ddca73e1858e1d98da3a80e3eb1614ac77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1935e8a86d3141a0d28263330fd428be06c5ecfa", "patch": "@@ -1,3 +1,16 @@\n+2006-04-14  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* basic-block.h (REG_BASIC_BLOCK): Use VEC instead of VARRAY.\n+\t* flow.c (reg_n_info): Change the type to\n+\tVEC(reg_info_p,heap) *.\n+\t* regclass.c (allocate_reg_info, free_reg_info): Use VEC\n+\tinstead of VARRAY.\n+\t* regs.h (reg_info_p): New.\n+\t(REG_N_REFS, REG_FREQ, REG_N_SETS, REG_N_DEATHS,\n+\tREG_N_CALLS_CROSSED, REG_N_THROWING_CALLS_CROSSED,\n+\tREG_LIVE_LENGTH, REGNO_FIRST_UID, REGNO_LAST_UID): Use VEC\n+\tinstead of VARRAY.\n+\n 2006-04-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* params.def (PARAM_MAX_SCHED_READY_INSNS): New parameter,"}, {"sha": "1d41a00c63193cd663206b262180dd8164f1e1e6", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=1935e8a86d3141a0d28263330fd428be06c5ecfa", "patch": "@@ -460,7 +460,8 @@ extern bitmap_obstack reg_obstack;\n #define REG_BLOCK_UNKNOWN -1\n #define REG_BLOCK_GLOBAL -2\n \n-#define REG_BASIC_BLOCK(N) (VARRAY_REG (reg_n_info, N)->basic_block)\n+#define REG_BASIC_BLOCK(N)\t\t\t\t\\\n+  (VEC_index (reg_info_p, reg_n_info, N)->basic_block)\n \f\n /* Stuff for recording basic block info.  */\n "}, {"sha": "4913102a8f59ee583ada0360847804300ad2a573", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=1935e8a86d3141a0d28263330fd428be06c5ecfa", "patch": "@@ -182,7 +182,7 @@ int max_regno;\n \n /* Indexed by n, giving various register information */\n \n-varray_type reg_n_info;\n+VEC(reg_info_p,heap) *reg_n_info;\n \n /* Regset of regs live when calls to `setjmp'-like functions happen.  */\n /* ??? Does this exist only for the setjmp-clobbered warning message?  */"}, {"sha": "8a0bab19026da50a25824c5674eef9dce0382b10", "filename": "gcc/regclass.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=1935e8a86d3141a0d28263330fd428be06c5ecfa", "patch": "@@ -2176,13 +2176,28 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n \n       if (!reg_n_info)\n \t{\n-\t  VARRAY_REG_INIT (reg_n_info, regno_allocated, \"reg_n_info\");\n+\t  reg_n_info = VEC_alloc (reg_info_p, heap, regno_allocated);\n+\t  VEC_safe_grow (reg_info_p, heap, reg_n_info, regno_allocated);\n+\t  memset (VEC_address (reg_info_p, reg_n_info), 0,\n+\t\t  sizeof (reg_info_p) * regno_allocated);\n \t  renumber = xmalloc (size_renumber);\n \t  reg_pref_buffer = XNEWVEC (struct reg_pref, regno_allocated);\n \t}\n       else\n \t{\n-\t  VARRAY_GROW (reg_n_info, regno_allocated);\n+\t  size_t old_length = VEC_length (reg_info_p, reg_n_info);\n+\t  if (old_length < regno_allocated)\n+\t    {\n+\t      reg_info_p *addr;\n+\t      VEC_safe_grow (reg_info_p, heap, reg_n_info, regno_allocated);\n+\t      addr = VEC_address (reg_info_p, reg_n_info);\n+\t      memset (&addr[old_length], 0,\n+\t\t      sizeof (reg_info_p) * (regno_allocated - old_length));\n+\t    }\n+\t  else if (regno_allocated < old_length)\n+\t    {\n+\t      VEC_truncate (reg_info_p, reg_n_info, regno_allocated);\n+\t    }\n \n \t  if (new_p)\t\t/* If we're zapping everything, no need to realloc.  */\n \t    {\n@@ -2238,7 +2253,8 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n \n \t  for (i = min_index+local_min; i <= max; i++)\n \t    {\n-\t      VARRAY_REG (reg_n_info, i) = &reg_data->data[i-min_index];\n+\t      VEC_replace (reg_info_p, reg_n_info, i,\n+\t\t\t   &reg_data->data[i-min_index]);\n \t      REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN;\n \t      renumber[i] = -1;\n \t      reg_pref_buffer[i].prefclass = (char) NO_REGS;\n@@ -2265,7 +2281,7 @@ free_reg_info (void)\n       struct reg_info_data *reg_data;\n       struct reg_info_data *reg_next;\n \n-      VARRAY_FREE (reg_n_info);\n+      VEC_free (reg_info_p, heap, reg_n_info);\n       for (reg_data = reg_info_head; reg_data; reg_data = reg_next)\n \t{\n \t  reg_next = reg_data->next;"}, {"sha": "ee074b9ed1bed325dfa4f22da85d2739327170fd", "filename": "gcc/regs.h", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1935e8a86d3141a0d28263330fd428be06c5ecfa/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=1935e8a86d3141a0d28263330fd428be06c5ecfa", "patch": "@@ -65,15 +65,20 @@ typedef struct reg_info_def\n   int basic_block;\t\t/* # of basic blocks (REG n) is used in */\n } reg_info;\n \n-extern varray_type reg_n_info;\n+typedef reg_info *reg_info_p;\n+\n+DEF_VEC_P(reg_info_p);\n+DEF_VEC_ALLOC_P(reg_info_p,heap);\n+\n+extern VEC(reg_info_p,heap) *reg_n_info;\n \n /* Indexed by n, gives number of times (REG n) is used or set.  */\n \n-#define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)\n+#define REG_N_REFS(N) (VEC_index (reg_info_p, reg_n_info, N)->refs)\n \n /* Estimate frequency of references to register N.  */\n \n-#define REG_FREQ(N) (VARRAY_REG (reg_n_info, N)->freq)\n+#define REG_FREQ(N) (VEC_index (reg_info_p, reg_n_info, N)->freq)\n \n /* The weights for each insn varries from 0 to REG_FREQ_BASE.\n    This constant does not need to be high, as in infrequently executed\n@@ -97,15 +102,15 @@ extern varray_type reg_n_info;\n    ??? both regscan and flow allocate space for this.  We should settle\n    on just copy.  */\n \n-#define REG_N_SETS(N) (VARRAY_REG (reg_n_info, N)->sets)\n+#define REG_N_SETS(N) (VEC_index (reg_info_p, reg_n_info, N)->sets)\n \n /* Indexed by N, gives number of insns in which register N dies.\n    Note that if register N is live around loops, it can die\n    in transitions between basic blocks, and that is not counted here.\n    So this is only a reliable indicator of how many regions of life there are\n    for registers that are contained in one basic block.  */\n \n-#define REG_N_DEATHS(N) (VARRAY_REG (reg_n_info, N)->deaths)\n+#define REG_N_DEATHS(N) (VEC_index (reg_info_p, reg_n_info, N)->deaths)\n \n /* Get the number of consecutive words required to hold pseudo-reg N.  */\n \n@@ -124,13 +129,14 @@ extern varray_type reg_n_info;\n \n /* Indexed by N, gives number of CALL_INSNS across which (REG n) is live.  */\n \n-#define REG_N_CALLS_CROSSED(N) (VARRAY_REG (reg_n_info, N)->calls_crossed)\n+#define REG_N_CALLS_CROSSED(N)\t\t\t\t\t\\\n+  (VEC_index (reg_info_p, reg_n_info, N)->calls_crossed)\n \n /* Indexed by N, gives number of CALL_INSNS that may throw, across which\n    (REG n) is live.  */\n \n #define REG_N_THROWING_CALLS_CROSSED(N) \\\n-  (VARRAY_REG (reg_n_info, N)->throw_calls_crossed)\n+  (VEC_index (reg_info_p, reg_n_info, N)->throw_calls_crossed)\n \n /* Total number of instructions at which (REG n) is live.\n    The larger this is, the less priority (REG n) gets for\n@@ -147,7 +153,8 @@ extern varray_type reg_n_info;\n    is not required.  global.c makes an allocno for this but does\n    not try to assign a hard register to it.  */\n \n-#define REG_LIVE_LENGTH(N) (VARRAY_REG (reg_n_info, N)->live_length)\n+#define REG_LIVE_LENGTH(N)\t\t\t\t\\\n+  (VEC_index (reg_info_p, reg_n_info, N)->live_length)\n \n /* Vector of substitutions of register numbers,\n    used to map pseudo regs into hardware regs.\n@@ -182,15 +189,15 @@ extern enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n    It is sometimes adjusted for subsequent changes during loop,\n    but not adjusted by cse even if cse invalidates it.  */\n \n-#define REGNO_FIRST_UID(N) (VARRAY_REG (reg_n_info, N)->first_uid)\n+#define REGNO_FIRST_UID(N) (VEC_index (reg_info_p, reg_n_info, N)->first_uid)\n \n /* Vector indexed by regno; gives uid of last insn using that reg.\n    This is computed by reg_scan for use by cse and loop.\n    It is sometimes adjusted for subsequent changes during loop,\n    but not adjusted by cse even if cse invalidates it.\n    This is harmless since cse won't scan through a loop end.  */\n \n-#define REGNO_LAST_UID(N) (VARRAY_REG (reg_n_info, N)->last_uid)\n+#define REGNO_LAST_UID(N) (VEC_index (reg_info_p, reg_n_info, N)->last_uid)\n \n /* List made of EXPR_LIST rtx's which gives pairs of pseudo registers\n    that have to go in the same hard reg.  */"}]}