{"sha": "027dbed8279f0312e8d01852728c5d8141ca5e33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI3ZGJlZDgyNzlmMDMxMmU4ZDAxODUyNzI4YzVkODE0MWNhNWUzMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T13:27:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T13:27:26Z"}, "message": "[multiple changes]\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting.\n\n2010-10-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* einfo.ads (Next_Girder_Discriminant): Remove obsolete description for\n\tremoved routine.\n\n2010-10-21  Nicolas Roche  <roche@adacore.com>\n\n\t* gnatmem.adb, memroot.adb, memroot.ads, gmem.c,\n\tgcc-interface/Makefile.in: Remove gnatmem specific files.\n\nFrom-SVN: r165776", "tree": {"sha": "96940349bc3bb4fbb4ffd73c99640cb61bed0a1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96940349bc3bb4fbb4ffd73c99640cb61bed0a1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/027dbed8279f0312e8d01852728c5d8141ca5e33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/027dbed8279f0312e8d01852728c5d8141ca5e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/027dbed8279f0312e8d01852728c5d8141ca5e33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/027dbed8279f0312e8d01852728c5d8141ca5e33/comments", "author": null, "committer": null, "parents": [{"sha": "8e4dac80b578697fae3e3cdfaad081bcffa0fa60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4dac80b578697fae3e3cdfaad081bcffa0fa60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4dac80b578697fae3e3cdfaad081bcffa0fa60"}], "stats": {"total": 1808, "additions": 28, "deletions": 1780}, "files": [{"sha": "1770e471716c692293a0b56e69d653bc7da7583f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=027dbed8279f0312e8d01852728c5d8141ca5e33", "patch": "@@ -1,3 +1,17 @@\n+2010-10-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting.\n+\n+2010-10-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* einfo.ads (Next_Girder_Discriminant): Remove obsolete description for\n+\tremoved routine.\n+\n+2010-10-21  Nicolas Roche  <roche@adacore.com>\n+\n+\t* gnatmem.adb, memroot.adb, memroot.ads, gmem.c,\n+\tgcc-interface/Makefile.in: Remove gnatmem specific files.\n+\n 2010-10-21  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_res.adb, exp_ch13.adb: Minor reformatting."}, {"sha": "1d3c9cb0f11f14a3e590c8e80bbb386e8fa92bb3", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=027dbed8279f0312e8d01852728c5d8141ca5e33", "patch": "@@ -3055,12 +3055,6 @@ package Einfo is\n --       Empty if there are no more formals. The list returned includes\n --       all the extra formals (see description of Extra_Formal field)\n \n---    Next_Girder_Discriminant (synthesized)\n---       Applies to discriminants. Set only for a discriminant returned by\n---       a call to First/Next_Girder_Discriminant. Returns next girder\n---       discriminant, if there are more (see complete description in\n---       First_Girder_Discriminant), or Empty if there are no more.\n-\n --    Next_Index (synthesized)\n --       Applies to array types and subtypes and to string types and\n --       subtypes. Yields the next index. The first index is obtained by"}, {"sha": "31693bc253421425a1aeadd4eb3682578d41ffd1", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=027dbed8279f0312e8d01852728c5d8141ca5e33", "patch": "@@ -2756,7 +2756,6 @@ errno.o   : errno.c\n exit.o    : adaint.h exit.c\n expect.o  : expect.c\n final.o   : final.c\n-gmem.o    : gmem.c\n link.o    : link.c\n mkdir.o   : mkdir.c\n socket.o  : socket.c gsocket.h"}, {"sha": "12c3c0a82ea5f5f2c80ecf0c193d7c046216a51b", "filename": "gcc/ada/gmem.c", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=8e4dac80b578697fae3e3cdfaad081bcffa0fa60", "patch": "@@ -1,217 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                            GNATMEM COMPONENTS                            *\n- *                                                                          *\n- *                                 G M E M                                  *\n- *                                                                          *\n- *                          C Implementation File                           *\n- *                                                                          *\n- *         Copyright (C) 2000-2009, Free Software Foundation, Inc.          *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * You should have received a copy of the GNU General Public License and    *\n- * a copy of the GCC Runtime Library Exception along with this program;     *\n- * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    *\n- * <http://www.gnu.org/licenses/>.                                          *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/*  This unit reads the allocation tracking log produced by augmented\n-    __gnat_malloc and __gnat_free procedures (see file memtrack.adb) and\n-    provides GNATMEM tool with gdb-compliant output. The output is\n-    processed by GNATMEM to detect dynamic memory allocation errors.\n-\n-    See GNATMEM section in GNAT User's Guide for more information.\n-\n-    NOTE: This capability is currently supported on the following targets:\n-\n-      DEC Unix\n-      GNU/Linux x86\n-      Solaris (sparc and x86) (*)\n-      Windows 98/95/NT (x86)\n-      Alpha OpenVMS\n-\n-    (*) on these targets, the compilation must be done with -funwind-tables to\n-    be able to build the stack backtrace.\n-\n-*/\n-\n-#ifdef VMS\n-#include <string.h>\n-#define xstrdup32(S)  strcpy ((__char_ptr32) _malloc32 (strlen (S) + 1), S)\n-#else\n-#define xstrdup32(S) S\n-#endif\n-\n-#include <stdio.h>\n-\n-static FILE *gmemfile;\n-\n-/* tb_len is the number of call level supported by this module */\n-#define tb_len 200\n-static void * tracebk [tb_len];\n-static int cur_tb_len, cur_tb_pos;\n-\n-#define LOG_EOF   '*'\n-#define LOG_ALLOC 'A'\n-#define LOG_DEALL 'D'\n-\n-struct struct_storage_elmt {\n-  char   Elmt;\n-  void * Address;\n-  size_t Size;\n-  long long Timestamp;\n-};\n-\n-static void\n-__gnat_convert_addresses (void *addrs[], int n_addrs, void *buf, int *len);\n-/* Place in BUF a string representing the symbolic translation of N_ADDRS raw\n-   addresses provided in ADDRS.  LEN is filled with the result length.\n-\n-   This is a GNAT specific interface to the libaddr2line convert_addresses\n-   routine.  The latter examines debug info from a provided executable file\n-   name to perform the translation into symbolic form of an input sequence of\n-   raw binary addresses.  It attempts to open the file from the provided name\n-   \"as is\", so an absolute path must be provided to ensure the file is\n-   always found.  We compute this name once, at initialization time.  */\n-\n-static const char * exename = 0;\n-\n-extern void convert_addresses (const char * , void *[], int, void *, int *);\n-extern char  *__gnat_locate_exec_on_path (char *);\n-/* ??? Both of these extern functions are prototyped in adaint.h, which\n-   also refers to \"time_t\" hence needs complex extra header inclusions to\n-   be satisfied on every target.  */\n-\n-static void\n-__gnat_convert_addresses (void *addrs[], int n_addrs, void *buf, int *len)\n-{\n-  if (exename != 0)\n-    convert_addresses (exename, addrs, n_addrs, buf, len);\n-  else\n-    *len = 0;\n-}\n-\n-/* reads backtrace information from gmemfile placing them in tracebk\n-   array. cur_tb_len is the size of this array\n-*/\n-\n-static void\n-gmem_read_backtrace (void)\n-{\n-  fread (&cur_tb_len, sizeof (int), 1, gmemfile);\n-  fread (tracebk, sizeof (void *), cur_tb_len, gmemfile);\n-  cur_tb_pos = 0;\n-}\n-\n-/* initialize gmem feature from the dumpname file. It returns t0 timestamp\n-   if the dumpname has been generated by GMEM (instrumented malloc/free)\n-   and 0 if not.\n-*/\n-\n-long long __gnat_gmem_initialize (char *dumpname)\n-{\n-  char header [10];\n-  long long t0;\n-\n-  gmemfile = fopen (dumpname, \"rb\");\n-  fread (header, 10, 1, gmemfile);\n-\n-  /* check for GMEM magic-tag */\n-  if (memcmp (header, \"GMEM DUMP\\n\", 10))\n-    {\n-      fclose (gmemfile);\n-      return 0;\n-    }\n-\n-  fread (&t0, sizeof (long long), 1, gmemfile);\n-\n-  return t0;\n-}\n-\n-/* initialize addr2line library */\n-\n-void __gnat_gmem_a2l_initialize (char *exearg)\n-{\n-  /* Resolve the executable filename to use in later invocations of\n-     the libaddr2line symbolization service. Ensure that on VMS\n-     exename is allocated in 32 bit memory for compatibility\n-     with libaddr2line. */\n-  exename = xstrdup32 (__gnat_locate_exec_on_path (exearg));\n-}\n-\n-/* Read next allocation of deallocation information from the GMEM file and\n-   write an alloc/free information in buf to be processed by gnatmem */\n-\n-void\n-__gnat_gmem_read_next (struct struct_storage_elmt *buf)\n-{\n-  void *addr;\n-  size_t size;\n-  int j;\n-\n-  j = fgetc (gmemfile);\n-  if (j == EOF)\n-    {\n-      fclose (gmemfile);\n-      buf->Elmt = LOG_EOF;\n-    }\n-  else\n-    {\n-      switch (j)\n-        {\n-          case 'A' :\n-            buf->Elmt = LOG_ALLOC;\n-            fread (&(buf->Address), sizeof (void *), 1, gmemfile);\n-            fread (&(buf->Size), sizeof (size_t), 1, gmemfile);\n-            fread (&(buf->Timestamp), sizeof (long long), 1, gmemfile);\n-            break;\n-          case 'D' :\n-            buf->Elmt = LOG_DEALL;\n-            fread (&(buf->Address), sizeof (void *), 1, gmemfile);\n-            fread (&(buf->Timestamp), sizeof (long long), 1, gmemfile);\n-            break;\n-          default:\n-            puts (\"GNATMEM dump file corrupt\");\n-            __gnat_os_exit (1);\n-        }\n-\n-      gmem_read_backtrace ();\n-    }\n-}\n-\n-/* Read the next frame from the current traceback, and move the cursor to the\n-   next frame */\n-\n-void __gnat_gmem_read_next_frame (void** addr)\n-{\n-  if (cur_tb_pos >= cur_tb_len) {\n-    *addr = NULL;\n-  } else {\n-    *addr = (void*)*(tracebk + cur_tb_pos);\n-    ++cur_tb_pos;\n-  }\n-}\n-\n-/* Converts addr into a symbolic traceback, and stores the result in buf\n-   with a format suitable for gnatmem */\n-\n-void __gnat_gmem_symbolic (void * addr, char* buf, int* length)\n-{\n-  void * addresses [] = { addr };\n-\n-  __gnat_convert_addresses (addresses, 1, buf, length);\n-}"}, {"sha": "d6ac07834a9d249d371e6394ccb2b1bb75548e1f", "filename": "gcc/ada/gnatmem.adb", "status": "removed", "additions": 0, "deletions": 815, "changes": 815, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fgnatmem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fgnatmem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmem.adb?ref=8e4dac80b578697fae3e3cdfaad081bcffa0fa60", "patch": "@@ -1,815 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              G N A T M E M                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 1997-2008, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  GNATMEM is a utility that tracks memory leaks. It is based on a simple\n---  idea:\n-\n---      - Read the allocation log generated by the application linked using\n---        instrumented memory allocation and deallocation (see memtrack.adb for\n---        this circuitry). To get access to this functionality, the application\n---        must be relinked with library libgmem.a:\n-\n---            $ gnatmake my_prog -largs -lgmem\n-\n---        The running my_prog will produce a file named gmem.out that will be\n---        parsed by gnatmem.\n-\n---      - Record a reference to the allocated memory on each allocation call\n-\n---      - Suppress this reference on deallocation\n-\n---      - At the end of the program, remaining references are potential leaks.\n---        sort them out the best possible way in order to locate the root of\n---        the leak.\n-\n---   This capability is not supported on all platforms, please refer to\n---   memtrack.adb for further information.\n-\n---   In order to help finding out the real leaks,  the notion of \"allocation\n---   root\" is defined. An allocation root is a specific point in the program\n---   execution generating memory allocation where data is collected (such as\n---   number of allocations, amount of memory allocated, high water mark, etc.)\n-\n-with Ada.Float_Text_IO;\n-with Ada.Integer_Text_IO;\n-with Ada.Text_IO;             use Ada.Text_IO;\n-\n-with System;                  use System;\n-with System.Storage_Elements; use System.Storage_Elements;\n-\n-with GNAT.Command_Line;       use GNAT.Command_Line;\n-with GNAT.Heap_Sort_G;\n-with GNAT.OS_Lib;             use GNAT.OS_Lib;\n-with GNAT.HTable;             use GNAT.HTable;\n-\n-with Gnatvsn; use Gnatvsn;\n-with Memroot; use Memroot;\n-\n-procedure Gnatmem is\n-\n-   package Int_IO renames Ada.Integer_Text_IO;\n-\n-   ------------------------\n-   -- Other Declarations --\n-   ------------------------\n-\n-   type Storage_Elmt is record\n-      Elmt : Character;\n-      --  *  = End of log file\n-      --  A  = found a ALLOC mark in the log\n-      --  D  = found a DEALL mark in the log\n-\n-      Address : Integer_Address;\n-      Size    : Storage_Count;\n-      Timestamp : Duration;\n-   end record;\n-   --  This type is used to read heap operations from the log file.\n-   --  Elmt contains the type of the operation, which can be either\n-   --  allocation, deallocation, or a special mark indicating the\n-   --  end of the log file. Address is used to store address on the\n-   --  heap where a chunk was allocated/deallocated, size is only\n-   --  for A event and contains size of the allocation, and Timestamp\n-   --  is the clock value at the moment of allocation\n-\n-   Log_Name : String_Access;\n-   --  Holds the name of the heap operations log file\n-\n-   Program_Name : String_Access;\n-   --  Holds the name of the user executable\n-\n-   function Read_Next return Storage_Elmt;\n-   --  Reads next dynamic storage operation from the log file\n-\n-   function Mem_Image (X : Storage_Count) return String;\n-   --  X is a size in storage_element. Returns a value\n-   --  in Megabytes, Kilobytes or Bytes as appropriate.\n-\n-   procedure Process_Arguments;\n-   --  Read command line arguments\n-\n-   procedure Usage;\n-   --  Prints out the option help\n-\n-   function Gmem_Initialize (Dumpname : String) return Boolean;\n-   --  Opens the file represented by Dumpname and prepares it for\n-   --  work. Returns False if the file does not have the correct format, True\n-   --  otherwise.\n-\n-   procedure Gmem_A2l_Initialize (Exename : String);\n-   --  Initialises the convert_addresses interface by supplying it with\n-   --  the name of the executable file Exename\n-\n-   -----------------------------------\n-   -- HTable address --> Allocation --\n-   -----------------------------------\n-\n-   type Allocation is record\n-      Root : Root_Id;\n-      Size : Storage_Count;\n-   end record;\n-\n-   type Address_Range is range 0 .. 4097;\n-   function H (A : Integer_Address) return Address_Range;\n-   No_Alloc : constant Allocation := (No_Root_Id, 0);\n-\n-   package Address_HTable is new GNAT.HTable.Simple_HTable (\n-     Header_Num => Address_Range,\n-     Element    => Allocation,\n-     No_Element => No_Alloc,\n-     Key        => Integer_Address,\n-     Hash       => H,\n-     Equal      => \"=\");\n-\n-   BT_Depth   : Integer := 1;\n-\n-   --  Some global statistics\n-\n-   Global_Alloc_Size : Storage_Count := 0;\n-   --  Total number of bytes allocated during the lifetime of a program\n-\n-   Global_High_Water_Mark : Storage_Count := 0;\n-   --  Largest amount of storage ever in use during the lifetime\n-\n-   Global_Nb_Alloc : Integer := 0;\n-   --  Total number of allocations\n-\n-   Global_Nb_Dealloc : Integer := 0;\n-   --  Total number of deallocations\n-\n-   Nb_Root : Integer := 0;\n-   --  Total number of allocation roots\n-\n-   Nb_Wrong_Deall : Integer := 0;\n-   --  Total number of wrong deallocations (i.e. without matching alloc)\n-\n-   Minimum_Nb_Leaks : Integer := 1;\n-   --  How many unfreed allocs should be in a root for it to count as leak\n-\n-   T0 : Duration := 0.0;\n-   --  The moment at which memory allocation routines initialized (should\n-   --  be pretty close to the moment the program started since there are\n-   --  always some allocations at RTL elaboration\n-\n-   Tmp_Alloc     : Allocation;\n-   Dump_Log_Mode : Boolean := False;\n-   Quiet_Mode    : Boolean := False;\n-\n-   ------------------------------\n-   -- Allocation Roots Sorting --\n-   ------------------------------\n-\n-   Sort_Order : String (1 .. 3) := \"nwh\";\n-   --  This is the default order in which sorting criteria will be applied\n-   --  n -  Total number of unfreed allocations\n-   --  w -  Final watermark\n-   --  h -  High watermark\n-\n-   --------------------------------\n-   -- GMEM functionality binding --\n-   --------------------------------\n-\n-   ---------------------\n-   -- Gmem_Initialize --\n-   ---------------------\n-\n-   function Gmem_Initialize (Dumpname : String) return Boolean is\n-      function Initialize (Dumpname : System.Address) return Duration;\n-      pragma Import (C, Initialize, \"__gnat_gmem_initialize\");\n-\n-      S : aliased String := Dumpname & ASCII.NUL;\n-\n-   begin\n-      T0 := Initialize (S'Address);\n-      return T0 > 0.0;\n-   end Gmem_Initialize;\n-\n-   -------------------------\n-   -- Gmem_A2l_Initialize --\n-   -------------------------\n-\n-   procedure Gmem_A2l_Initialize (Exename : String) is\n-      procedure A2l_Initialize (Exename : System.Address);\n-      pragma Import (C, A2l_Initialize, \"__gnat_gmem_a2l_initialize\");\n-\n-      S : aliased String := Exename & ASCII.NUL;\n-\n-   begin\n-      A2l_Initialize (S'Address);\n-   end Gmem_A2l_Initialize;\n-\n-   ---------------\n-   -- Read_Next --\n-   ---------------\n-\n-   function Read_Next return Storage_Elmt is\n-      procedure Read_Next (buf : System.Address);\n-      pragma Import (C, Read_Next, \"__gnat_gmem_read_next\");\n-\n-      S : Storage_Elmt;\n-\n-   begin\n-      Read_Next (S'Address);\n-      return S;\n-   end Read_Next;\n-\n-   -------\n-   -- H --\n-   -------\n-\n-   function H (A : Integer_Address) return Address_Range is\n-   begin\n-      return Address_Range (A mod Integer_Address (Address_Range'Last));\n-   end H;\n-\n-   ---------------\n-   -- Mem_Image --\n-   ---------------\n-\n-   function Mem_Image (X : Storage_Count) return String is\n-      Ks   : constant Storage_Count := X / 1024;\n-      Megs : constant Storage_Count := Ks / 1024;\n-      Buff : String (1 .. 7);\n-\n-   begin\n-      if Megs /= 0 then\n-         Ada.Float_Text_IO.Put (Buff, Float (X) / 1024.0 / 1024.0, 2, 0);\n-         return Buff & \" Megabytes\";\n-\n-      elsif Ks /= 0 then\n-         Ada.Float_Text_IO.Put (Buff, Float (X) / 1024.0, 2, 0);\n-         return Buff & \" Kilobytes\";\n-\n-      else\n-         Ada.Integer_Text_IO.Put (Buff (1 .. 4), Integer (X));\n-         return Buff (1 .. 4) & \" Bytes\";\n-      end if;\n-   end Mem_Image;\n-\n-   -----------\n-   -- Usage --\n-   -----------\n-\n-   procedure Usage is\n-   begin\n-      New_Line;\n-      Put (\"GNATMEM \");\n-      Put_Line (Gnat_Version_String);\n-      Put_Line (\"Copyright 1997-2007, Free Software Foundation, Inc.\");\n-      New_Line;\n-\n-      Put_Line (\"Usage: gnatmem switches [depth] exename\");\n-      New_Line;\n-      Put_Line (\"  depth    backtrace depth to take into account, default is\"\n-                & Integer'Image (BT_Depth));\n-      Put_Line (\"  exename  the name of the executable to be analyzed\");\n-      New_Line;\n-      Put_Line (\"Switches:\");\n-      Put_Line (\"  -b n     same as depth parameter\");\n-      Put_Line (\"  -i file  read the allocation log from specific file\");\n-      Put_Line (\"           default is gmem.out in the current directory\");\n-      Put_Line (\"  -m n     masks roots with less than n leaks, default is 1\");\n-      Put_Line (\"           specify 0 to see even released allocation roots\");\n-      Put_Line (\"  -q       quiet, minimum output\");\n-      Put_Line (\"  -s order sort allocation roots according to an order of\");\n-      Put_Line (\"           sort criteria\");\n-      GNAT.OS_Lib.OS_Exit (1);\n-   end Usage;\n-\n-   -----------------------\n-   -- Process_Arguments --\n-   -----------------------\n-\n-   procedure Process_Arguments is\n-   begin\n-      --  Parse the options first\n-\n-      loop\n-         case Getopt (\"b: dd m: i: q s:\") is\n-            when ASCII.NUL => exit;\n-\n-            when 'b' =>\n-               begin\n-                  BT_Depth := Natural'Value (Parameter);\n-               exception\n-                  when Constraint_Error =>\n-                     Usage;\n-               end;\n-\n-            when 'd' =>\n-               Dump_Log_Mode := True;\n-\n-            when 'm' =>\n-               begin\n-                  Minimum_Nb_Leaks := Natural'Value (Parameter);\n-               exception\n-                  when Constraint_Error =>\n-                     Usage;\n-               end;\n-\n-            when 'i' =>\n-               Log_Name := new String'(Parameter);\n-\n-            when 'q' =>\n-               Quiet_Mode := True;\n-\n-            when 's' =>\n-               declare\n-                  S : constant String (Sort_Order'Range) := Parameter;\n-               begin\n-                  for J in Sort_Order'Range loop\n-                     if S (J) = 'n' or else\n-                        S (J) = 'w' or else\n-                        S (J) = 'h'\n-                     then\n-                        Sort_Order (J) := S (J);\n-                     else\n-                        Put_Line (\"Invalid sort criteria string.\");\n-                        GNAT.OS_Lib.OS_Exit (1);\n-                     end if;\n-                  end loop;\n-               end;\n-\n-            when others =>\n-               null;\n-         end case;\n-      end loop;\n-\n-      --  Set default log file if -i hasn't been specified\n-\n-      if Log_Name = null then\n-         Log_Name := new String'(\"gmem.out\");\n-      end if;\n-\n-      --  Get the optional backtrace length and program name\n-\n-      declare\n-         Str1 : constant String := GNAT.Command_Line.Get_Argument;\n-         Str2 : constant String := GNAT.Command_Line.Get_Argument;\n-\n-      begin\n-         if Str1 = \"\" then\n-            Usage;\n-         end if;\n-\n-         if Str2 = \"\" then\n-            Program_Name := new String'(Str1);\n-         else\n-            BT_Depth := Natural'Value (Str1);\n-            Program_Name := new String'(Str2);\n-         end if;\n-\n-      exception\n-         when Constraint_Error =>\n-            Usage;\n-      end;\n-\n-      --  Ensure presence of executable suffix in Program_Name\n-\n-      declare\n-         Suffix : String_Access := Get_Executable_Suffix;\n-         Tmp    : String_Access;\n-\n-      begin\n-         if Suffix.all /= \"\"\n-           and then\n-             Program_Name.all\n-              (Program_Name.all'Last - Suffix.all'Length + 1 ..\n-                               Program_Name.all'Last) /= Suffix.all\n-         then\n-            Tmp := new String'(Program_Name.all & Suffix.all);\n-            Free (Program_Name);\n-            Program_Name := Tmp;\n-         end if;\n-\n-         Free (Suffix);\n-\n-         --  Search the executable on the path. If not found in the PATH, we\n-         --  default to the current directory. Otherwise, libaddr2line will\n-         --  fail with an error:\n-\n-         --     (null): Bad address\n-\n-         Tmp := Locate_Exec_On_Path (Program_Name.all);\n-\n-         if Tmp = null then\n-            Tmp := new String'('.' & Directory_Separator & Program_Name.all);\n-         end if;\n-\n-         Free (Program_Name);\n-         Program_Name := Tmp;\n-      end;\n-\n-      if not Is_Regular_File (Log_Name.all) then\n-         Put_Line (\"Couldn't find \" & Log_Name.all);\n-         GNAT.OS_Lib.OS_Exit (1);\n-      end if;\n-\n-      if not Gmem_Initialize (Log_Name.all) then\n-         Put_Line (\"File \" & Log_Name.all & \" is not a gnatmem log file\");\n-         GNAT.OS_Lib.OS_Exit (1);\n-      end if;\n-\n-      if not Is_Regular_File (Program_Name.all) then\n-         Put_Line (\"Couldn't find \" & Program_Name.all);\n-      end if;\n-\n-      Gmem_A2l_Initialize (Program_Name.all);\n-\n-   exception\n-      when GNAT.Command_Line.Invalid_Switch =>\n-         Ada.Text_IO.Put_Line (\"Invalid switch : \"\n-                               & GNAT.Command_Line.Full_Switch);\n-         Usage;\n-   end Process_Arguments;\n-\n-   --  Local variables\n-\n-   Cur_Elmt : Storage_Elmt;\n-   Buff     : String (1 .. 16);\n-\n---  Start of processing for Gnatmem\n-\n-begin\n-   Process_Arguments;\n-\n-   if Dump_Log_Mode then\n-      Put_Line (\"Full dump of dynamic memory operations history\");\n-      Put_Line (\"----------------------------------------------\");\n-\n-      declare\n-         function CTime (Clock : Address) return Address;\n-         pragma Import (C, CTime, \"ctime\");\n-\n-         Int_T0     : Integer := Integer (T0);\n-         CTime_Addr : constant Address := CTime (Int_T0'Address);\n-\n-         Buffer : String (1 .. 30);\n-         for Buffer'Address use CTime_Addr;\n-\n-      begin\n-         Put_Line (\"Log started at T0 =\" & Duration'Image (T0) & \" (\"\n-                   & Buffer (1 .. 24) & \")\");\n-      end;\n-   end if;\n-\n-   --  Main loop analysing the data generated by the instrumented routines.\n-   --  For each allocation, the backtrace is kept and stored in a htable\n-   --  whose entry is the address. For each deallocation, we look for the\n-   --  corresponding allocation and cancel it.\n-\n-   Main : loop\n-      Cur_Elmt := Read_Next;\n-\n-      case Cur_Elmt.Elmt is\n-         when '*' =>\n-            exit Main;\n-\n-         when 'A' =>\n-\n-            --  Read the corresponding back trace\n-\n-            Tmp_Alloc.Root := Read_BT (BT_Depth);\n-\n-            if Quiet_Mode then\n-\n-               if Nb_Alloc (Tmp_Alloc.Root) = 0 then\n-                  Nb_Root := Nb_Root + 1;\n-               end if;\n-\n-               Set_Nb_Alloc (Tmp_Alloc.Root, Nb_Alloc (Tmp_Alloc.Root) + 1);\n-               Address_HTable.Set (Cur_Elmt.Address, Tmp_Alloc);\n-\n-            elsif Cur_Elmt.Size > 0 then\n-\n-               --  Update global counters if the allocated size is meaningful\n-\n-               Global_Alloc_Size := Global_Alloc_Size + Cur_Elmt.Size;\n-               Global_Nb_Alloc   := Global_Nb_Alloc + 1;\n-\n-               if Global_High_Water_Mark < Global_Alloc_Size then\n-                  Global_High_Water_Mark := Global_Alloc_Size;\n-               end if;\n-\n-               --  Update the number of allocation root if this is a new one\n-\n-               if Nb_Alloc (Tmp_Alloc.Root) = 0 then\n-                  Nb_Root := Nb_Root + 1;\n-               end if;\n-\n-               --  Update allocation root specific counters\n-\n-               Set_Alloc_Size (Tmp_Alloc.Root,\n-                 Alloc_Size (Tmp_Alloc.Root) + Cur_Elmt.Size);\n-\n-               Set_Nb_Alloc (Tmp_Alloc.Root, Nb_Alloc (Tmp_Alloc.Root) + 1);\n-\n-               if High_Water_Mark (Tmp_Alloc.Root) <\n-                                               Alloc_Size (Tmp_Alloc.Root)\n-               then\n-                  Set_High_Water_Mark (Tmp_Alloc.Root,\n-                    Alloc_Size (Tmp_Alloc.Root));\n-               end if;\n-\n-               --  Associate this allocation root to the allocated address\n-\n-               Tmp_Alloc.Size := Cur_Elmt.Size;\n-               Address_HTable.Set (Cur_Elmt.Address, Tmp_Alloc);\n-\n-            end if;\n-\n-         when 'D' =>\n-\n-            --  Get the corresponding Dealloc_Size and Root\n-\n-            Tmp_Alloc := Address_HTable.Get (Cur_Elmt.Address);\n-\n-            if Tmp_Alloc.Root = No_Root_Id then\n-\n-               --  There was no prior allocation at this address, something is\n-               --  very wrong. Mark this allocation root as problematic.\n-\n-               Tmp_Alloc.Root := Read_BT (BT_Depth);\n-\n-               if Nb_Alloc (Tmp_Alloc.Root) = 0 then\n-                  Set_Nb_Alloc (Tmp_Alloc.Root, Nb_Alloc (Tmp_Alloc.Root) - 1);\n-                  Nb_Wrong_Deall := Nb_Wrong_Deall + 1;\n-               end if;\n-\n-            else\n-               --  Update global counters\n-\n-               if not Quiet_Mode then\n-                  Global_Alloc_Size := Global_Alloc_Size - Tmp_Alloc.Size;\n-               end if;\n-\n-               Global_Nb_Dealloc   := Global_Nb_Dealloc + 1;\n-\n-               --  Update allocation root specific counters\n-\n-               if not Quiet_Mode then\n-                  Set_Alloc_Size (Tmp_Alloc.Root,\n-                    Alloc_Size (Tmp_Alloc.Root) - Tmp_Alloc.Size);\n-               end if;\n-\n-               Set_Nb_Alloc (Tmp_Alloc.Root, Nb_Alloc (Tmp_Alloc.Root) - 1);\n-\n-               --  Update the number of allocation root if this one disappears\n-\n-               if Nb_Alloc (Tmp_Alloc.Root) = 0\n-                 and then Minimum_Nb_Leaks > 0 then\n-                  Nb_Root := Nb_Root - 1;\n-               end if;\n-\n-               --  Deassociate the deallocated address\n-\n-               Address_HTable.Remove (Cur_Elmt.Address);\n-            end if;\n-\n-         when others =>\n-            raise Program_Error;\n-      end case;\n-\n-      if Dump_Log_Mode then\n-         case Cur_Elmt.Elmt is\n-            when 'A' =>\n-               Put (\"ALLOC\");\n-               Int_IO.Put (Buff (1 .. 16), Integer (Cur_Elmt.Address), 16);\n-               Put (Buff);\n-               Int_IO.Put (Buff (1 .. 8), Integer (Cur_Elmt.Size));\n-               Put (Buff (1 .. 8) & \" bytes at moment T0 +\");\n-               Put_Line (Duration'Image (Cur_Elmt.Timestamp - T0));\n-\n-            when 'D' =>\n-               Put (\"DEALL\");\n-               Int_IO.Put (Buff (1 .. 16), Integer (Cur_Elmt.Address), 16);\n-               Put (Buff);\n-               Put_Line (\" at moment T0 +\"\n-                         & Duration'Image (Cur_Elmt.Timestamp - T0));\n-            when others =>\n-               raise Program_Error;\n-         end case;\n-\n-         Print_BT (Tmp_Alloc.Root);\n-      end if;\n-\n-   end loop Main;\n-\n-   --  Print out general information about overall allocation\n-\n-   if not Quiet_Mode then\n-      Put_Line (\"Global information\");\n-      Put_Line (\"------------------\");\n-\n-      Put      (\"   Total number of allocations        :\");\n-      Ada.Integer_Text_IO.Put (Global_Nb_Alloc, 4);\n-      New_Line;\n-\n-      Put      (\"   Total number of deallocations      :\");\n-      Ada.Integer_Text_IO.Put (Global_Nb_Dealloc, 4);\n-      New_Line;\n-\n-      Put_Line (\"   Final Water Mark (non freed mem)   :\"\n-        & Mem_Image (Global_Alloc_Size));\n-      Put_Line (\"   High Water Mark                    :\"\n-        & Mem_Image (Global_High_Water_Mark));\n-      New_Line;\n-   end if;\n-\n-   --  Print out the back traces corresponding to potential leaks in order\n-   --  greatest number of non-deallocated allocations.\n-\n-   Print_Back_Traces : declare\n-      type Root_Array is array (Natural range <>) of Root_Id;\n-      type Access_Root_Array is access Root_Array;\n-\n-      Leaks        : constant Access_Root_Array :=\n-                       new Root_Array (0 .. Nb_Root);\n-      Leak_Index   : Natural := 0;\n-\n-      Bogus_Dealls : constant Access_Root_Array :=\n-                       new Root_Array (1 .. Nb_Wrong_Deall);\n-      Deall_Index  : Natural := 0;\n-      Nb_Alloc_J   : Natural := 0;\n-\n-      procedure Move (From : Natural; To : Natural);\n-      function Lt (Op1, Op2 : Natural) return Boolean;\n-      package Root_Sort is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         Leaks (To) := Leaks (From);\n-      end Move;\n-\n-      --------\n-      -- Lt --\n-      --------\n-\n-      function Lt (Op1, Op2 : Natural) return Boolean is\n-\n-         function Apply_Sort_Criterion (S : Character) return Integer;\n-         --  Applies a specific sort criterion; returns -1, 0 or 1 if Op1 is\n-         --  smaller than, equal, or greater than Op2 according to criterion.\n-\n-         --------------------------\n-         -- Apply_Sort_Criterion --\n-         --------------------------\n-\n-         function Apply_Sort_Criterion (S : Character) return Integer is\n-            LOp1, LOp2 : Integer;\n-\n-         begin\n-            case S is\n-               when 'n' =>\n-                  LOp1 := Nb_Alloc (Leaks (Op1));\n-                  LOp2 := Nb_Alloc (Leaks (Op2));\n-\n-               when 'w' =>\n-                  LOp1 := Integer (Alloc_Size (Leaks (Op1)));\n-                  LOp2 := Integer (Alloc_Size (Leaks (Op2)));\n-\n-               when 'h' =>\n-                  LOp1 := Integer (High_Water_Mark (Leaks (Op1)));\n-                  LOp2 := Integer (High_Water_Mark (Leaks (Op2)));\n-\n-               when others =>\n-                  return 0;  --  Can't actually happen\n-            end case;\n-\n-            if LOp1 < LOp2 then\n-               return -1;\n-            elsif LOp1 > LOp2 then\n-               return 1;\n-            else\n-               return 0;\n-            end if;\n-\n-         exception\n-            when Constraint_Error =>\n-               return 0;\n-         end Apply_Sort_Criterion;\n-\n-         --  Local Variables\n-\n-         Result : Integer;\n-\n-      --  Start of processing for Lt\n-\n-      begin\n-         for S in Sort_Order'Range loop\n-            Result := Apply_Sort_Criterion (Sort_Order (S));\n-            if Result = -1 then\n-               return False;\n-            elsif Result = 1 then\n-               return True;\n-            end if;\n-         end loop;\n-         return False;\n-      end Lt;\n-\n-   --  Start of processing for Print_Back_Traces\n-\n-   begin\n-      --  Transfer all the relevant Roots in the Leaks and a Bogus_Deall arrays\n-\n-      Tmp_Alloc.Root := Get_First;\n-      while Tmp_Alloc.Root /= No_Root_Id loop\n-         if Nb_Alloc (Tmp_Alloc.Root) = 0 and then Minimum_Nb_Leaks > 0 then\n-            null;\n-\n-         elsif Nb_Alloc (Tmp_Alloc.Root) < 0  then\n-            Deall_Index := Deall_Index + 1;\n-            Bogus_Dealls (Deall_Index) := Tmp_Alloc.Root;\n-\n-         else\n-            Leak_Index := Leak_Index + 1;\n-            Leaks (Leak_Index) := Tmp_Alloc.Root;\n-         end if;\n-\n-         Tmp_Alloc.Root := Get_Next;\n-      end loop;\n-\n-      --  Print out wrong deallocations\n-\n-      if Nb_Wrong_Deall > 0 then\n-         Put_Line    (\"Releasing deallocated memory at :\");\n-         if not Quiet_Mode then\n-            Put_Line (\"--------------------------------\");\n-         end if;\n-\n-         for J in  1 .. Bogus_Dealls'Last loop\n-            Print_BT (Bogus_Dealls (J), Short => Quiet_Mode);\n-            New_Line;\n-         end loop;\n-      end if;\n-\n-      --  Print out all allocation Leaks\n-\n-      if Leak_Index > 0 then\n-\n-         --  Sort the Leaks so that potentially important leaks appear first\n-\n-         Root_Sort.Sort (Leak_Index);\n-\n-         for J in  1 .. Leak_Index loop\n-            Nb_Alloc_J := Nb_Alloc (Leaks (J));\n-\n-            if Nb_Alloc_J >= Minimum_Nb_Leaks then\n-               if Quiet_Mode then\n-                  if Nb_Alloc_J = 1 then\n-                     Put_Line (\" 1 leak at :\");\n-                  else\n-                     Put_Line (Integer'Image (Nb_Alloc_J) & \" leaks at :\");\n-                  end if;\n-\n-               else\n-                  Put_Line (\"Allocation Root #\" & Integer'Image (J));\n-                  Put_Line (\"-------------------\");\n-\n-                  Put      (\" Number of non freed allocations    :\");\n-                  Ada.Integer_Text_IO.Put (Nb_Alloc_J, 4);\n-                  New_Line;\n-\n-                  Put_Line\n-                    (\" Final Water Mark (non freed mem)   :\"\n-                     & Mem_Image (Alloc_Size (Leaks (J))));\n-\n-                  Put_Line\n-                    (\" High Water Mark                    :\"\n-                     & Mem_Image (High_Water_Mark (Leaks (J))));\n-\n-                  Put_Line (\" Backtrace                          :\");\n-               end if;\n-\n-               Print_BT (Leaks (J), Short => Quiet_Mode);\n-               New_Line;\n-            end if;\n-         end loop;\n-      end if;\n-   end Print_Back_Traces;\n-end Gnatmem;"}, {"sha": "3aae5c4db984230b4d941b2a92df106825271c75", "filename": "gcc/ada/memroot.adb", "status": "removed", "additions": 0, "deletions": 615, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fmemroot.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fmemroot.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemroot.adb?ref=8e4dac80b578697fae3e3cdfaad081bcffa0fa60", "patch": "@@ -1,615 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              M E M R O O T                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 1997-2008, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with GNAT.Table;\n-with GNAT.HTable; use GNAT.HTable;\n-with Ada.Text_IO; use Ada.Text_IO;\n-\n-package body Memroot is\n-\n-   Main_Name_Id : Name_Id;\n-   --  The constant \"main\" where we should stop the backtraces\n-\n-   -------------\n-   -- Name_Id --\n-   -------------\n-\n-   package Chars is new GNAT.Table (\n-     Table_Component_Type => Character,\n-     Table_Index_Type     => Integer,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 10_000,\n-     Table_Increment      => 100);\n-   --  The actual character container for names\n-\n-   type Name is  record\n-      First, Last : Integer;\n-   end record;\n-\n-   package Names is new GNAT.Table (\n-     Table_Component_Type => Name,\n-     Table_Index_Type     => Name_Id,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => 400,\n-     Table_Increment      => 100);\n-\n-   type Name_Range is range 1 .. 1023;\n-\n-   function Name_Eq (N1, N2 : Name) return Boolean;\n-   --  compare 2 names\n-\n-   function H (N : Name) return Name_Range;\n-\n-   package Name_HTable is new GNAT.HTable.Simple_HTable (\n-     Header_Num => Name_Range,\n-     Element    => Name_Id,\n-     No_Element => No_Name_Id,\n-     Key        => Name,\n-     Hash       => H,\n-     Equal      => Name_Eq);\n-\n-   --------------\n-   -- Frame_Id --\n-   --------------\n-\n-   type Frame is record\n-      Name, File, Line : Name_Id;\n-   end record;\n-\n-   function Image\n-     (F       : Frame_Id;\n-      Max_Fil : Integer;\n-      Max_Lin : Integer;\n-      Short   : Boolean := False) return String;\n-   --  Returns an image for F containing the file name, the Line number,\n-   --  and if 'Short' is not true, the subprogram name. When possible, spaces\n-   --  are inserted between the line number and the subprogram name in order\n-   --  to align images of the same frame. Alignment is computed with Max_Fil\n-   --  & Max_Lin representing the max number of character in a filename or\n-   --  length in a given frame.\n-\n-   package Frames is new GNAT.Table (\n-     Table_Component_Type => Frame,\n-     Table_Index_Type     => Frame_Id,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 400,\n-     Table_Increment      => 100);\n-\n-   type Frame_Range is range 1 .. 10000;\n-   function H (N : Integer_Address) return Frame_Range;\n-\n-   package Frame_HTable is new GNAT.HTable.Simple_HTable (\n-     Header_Num => Frame_Range,\n-     Element    => Frame_Id,\n-     No_Element => No_Frame_Id,\n-     Key        => Integer_Address,\n-     Hash       => H,\n-     Equal      => \"=\");\n-\n-   -------------\n-   -- Root_Id --\n-   -------------\n-\n-   type Root is  record\n-     First, Last     : Integer;\n-     Nb_Alloc        : Integer;\n-     Alloc_Size      : Storage_Count;\n-     High_Water_Mark : Storage_Count;\n-   end record;\n-\n-   package Frames_In_Root is new GNAT.Table (\n-     Table_Component_Type => Frame_Id,\n-     Table_Index_Type     => Integer,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 400,\n-     Table_Increment      => 100);\n-\n-   package Roots is new GNAT.Table (\n-     Table_Component_Type => Root,\n-     Table_Index_Type     => Root_Id,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 200,\n-     Table_Increment      => 100);\n-   type Root_Range is range 1 .. 513;\n-\n-   function Root_Eq (N1, N2 : Root) return Boolean;\n-   function H     (B : Root)     return Root_Range;\n-\n-   package Root_HTable is new GNAT.HTable.Simple_HTable (\n-     Header_Num => Root_Range,\n-     Element    => Root_Id,\n-     No_Element => No_Root_Id,\n-     Key        => Root,\n-     Hash       => H,\n-     Equal      => Root_Eq);\n-\n-   ----------------\n-   -- Alloc_Size --\n-   ----------------\n-\n-   function Alloc_Size (B : Root_Id) return Storage_Count is\n-   begin\n-      return Roots.Table (B).Alloc_Size;\n-   end Alloc_Size;\n-\n-   -----------------\n-   -- Enter_Frame --\n-   -----------------\n-\n-   function Enter_Frame\n-     (Addr : System.Address;\n-      Name : Name_Id;\n-      File : Name_Id;\n-      Line : Name_Id)\n-      return Frame_Id\n-   is\n-   begin\n-      Frames.Increment_Last;\n-      Frames.Table (Frames.Last) := Frame'(Name, File, Line);\n-\n-      Frame_HTable.Set (To_Integer (Addr), Frames.Last);\n-      return Frames.Last;\n-   end Enter_Frame;\n-\n-   ----------------\n-   -- Enter_Name --\n-   ----------------\n-\n-   function Enter_Name (S : String) return Name_Id is\n-      Old_L : constant Integer := Chars.Last;\n-      Len   : constant Integer := S'Length;\n-      F     : constant Integer := Chars.Allocate (Len);\n-      Res   : Name_Id;\n-\n-   begin\n-      Chars.Table (F .. F + Len - 1) := Chars.Table_Type (S);\n-      Names.Increment_Last;\n-      Names.Table (Names.Last) := Name'(F, F + Len - 1);\n-      Res := Name_HTable.Get (Names.Table (Names.Last));\n-\n-      if Res /= No_Name_Id then\n-         Names.Decrement_Last;\n-         Chars.Set_Last (Old_L);\n-         return Res;\n-\n-      else\n-         Name_HTable.Set (Names.Table (Names.Last), Names.Last);\n-         return Names.Last;\n-      end if;\n-   end Enter_Name;\n-\n-   ----------------\n-   -- Enter_Root --\n-   ----------------\n-\n-   function Enter_Root (Fr : Frame_Array) return Root_Id is\n-      Old_L : constant Integer  := Frames_In_Root.Last;\n-      Len   : constant Integer  := Fr'Length;\n-      F     : constant Integer  := Frames_In_Root.Allocate (Len);\n-      Res   : Root_Id;\n-\n-   begin\n-      Frames_In_Root.Table (F .. F + Len - 1) :=\n-        Frames_In_Root.Table_Type (Fr);\n-      Roots.Increment_Last;\n-      Roots.Table (Roots.Last) := Root'(F, F + Len - 1, 0, 0, 0);\n-      Res := Root_HTable.Get (Roots.Table (Roots.Last));\n-\n-      if Res /= No_Root_Id then\n-         Frames_In_Root.Set_Last (Old_L);\n-         Roots.Decrement_Last;\n-         return Res;\n-\n-      else\n-         Root_HTable.Set (Roots.Table (Roots.Last), Roots.Last);\n-         return Roots.Last;\n-      end if;\n-   end Enter_Root;\n-\n-   ---------------\n-   -- Frames_Of --\n-   ---------------\n-\n-   function Frames_Of (B : Root_Id) return Frame_Array is\n-   begin\n-      return Frame_Array (\n-        Frames_In_Root.Table (Roots.Table (B).First .. Roots.Table (B).Last));\n-   end Frames_Of;\n-\n-   ---------------\n-   -- Get_First --\n-   ---------------\n-\n-   function Get_First return Root_Id is\n-   begin\n-      return  Root_HTable.Get_First;\n-   end Get_First;\n-\n-   --------------\n-   -- Get_Next --\n-   --------------\n-\n-   function Get_Next return Root_Id is\n-   begin\n-      return Root_HTable.Get_Next;\n-   end Get_Next;\n-\n-   -------\n-   -- H --\n-   -------\n-\n-   function H (B : Root) return Root_Range is\n-\n-      type Uns is mod 2 ** 32;\n-\n-      function Rotate_Left (Value : Uns; Amount : Natural) return Uns;\n-      pragma Import (Intrinsic, Rotate_Left);\n-\n-      Tmp : Uns := 0;\n-\n-   begin\n-      for J in B.First .. B.Last loop\n-         Tmp := Rotate_Left (Tmp, 1) + Uns (Frames_In_Root.Table (J));\n-      end loop;\n-\n-      return Root_Range'First\n-        + Root_Range'Base (Tmp mod Root_Range'Range_Length);\n-   end H;\n-\n-   function H (N : Name) return Name_Range is\n-      function H is new Hash (Name_Range);\n-\n-   begin\n-      return H (String (Chars.Table (N.First .. N.Last)));\n-   end H;\n-\n-   function H (N : Integer_Address) return Frame_Range is\n-   begin\n-      return Frame_Range (1 + N mod Frame_Range'Range_Length);\n-   end H;\n-\n-   ---------------------\n-   -- High_Water_Mark --\n-   ---------------------\n-\n-   function High_Water_Mark (B : Root_Id) return Storage_Count is\n-   begin\n-      return Roots.Table (B).High_Water_Mark;\n-   end High_Water_Mark;\n-\n-   -----------\n-   -- Image --\n-   -----------\n-\n-   function Image (N : Name_Id) return String is\n-      Nam : Name renames Names.Table (N);\n-\n-   begin\n-      return String (Chars.Table (Nam.First .. Nam.Last));\n-   end Image;\n-\n-   function Image\n-     (F       : Frame_Id;\n-      Max_Fil : Integer;\n-      Max_Lin : Integer;\n-      Short   : Boolean := False) return String\n-   is\n-      Fram : Frame renames Frames.Table (F);\n-      Fil  : Name renames Names.Table (Fram.File);\n-      Lin  : Name renames Names.Table (Fram.Line);\n-      Nam  : Name renames Names.Table (Fram.Name);\n-\n-      Fil_Len  : constant Integer := Fil.Last - Fil.First + 1;\n-      Lin_Len  : constant Integer := Lin.Last - Lin.First + 1;\n-\n-      use type Chars.Table_Type;\n-\n-      Spaces : constant String (1 .. 80) := (1 .. 80 => ' ');\n-\n-      Result : constant String :=\n-        String (Chars.Table (Fil.First .. Fil.Last))\n-        & ':'\n-        & String (Chars.Table (Lin.First .. Lin.Last));\n-   begin\n-      if Short then\n-         return Result;\n-      else\n-         return Result\n-           & Spaces (1 .. 1 + Max_Fil - Fil_Len + Max_Lin - Lin_Len)\n-           & String (Chars.Table (Nam.First .. Nam.Last));\n-      end if;\n-   end Image;\n-\n-   -------------\n-   -- Name_Eq --\n-   -------------\n-\n-   function Name_Eq (N1, N2 : Name) return Boolean is\n-      use type Chars.Table_Type;\n-   begin\n-      return\n-        Chars.Table (N1.First .. N1.Last) = Chars.Table (N2.First .. N2.Last);\n-   end Name_Eq;\n-\n-   --------------\n-   -- Nb_Alloc --\n-   --------------\n-\n-   function Nb_Alloc (B : Root_Id) return Integer is\n-   begin\n-      return Roots.Table (B).Nb_Alloc;\n-   end Nb_Alloc;\n-\n-   --------------\n-   -- Print_BT --\n-   --------------\n-\n-   procedure Print_BT (B  : Root_Id; Short : Boolean := False) is\n-      Max_Col_Width : constant := 35;\n-      --  Largest filename length for which backtraces will be\n-      --  properly aligned. Frames containing longer names won't be\n-      --  truncated but they won't be properly aligned either.\n-\n-      F : constant Frame_Array := Frames_Of (B);\n-\n-      Max_Fil : Integer;\n-      Max_Lin : Integer;\n-\n-   begin\n-      Max_Fil := 0;\n-      Max_Lin := 0;\n-\n-      for J in F'Range loop\n-         declare\n-            Fram : Frame renames Frames.Table (F (J));\n-            Fil  : Name renames Names.Table (Fram.File);\n-            Lin  : Name renames Names.Table (Fram.Line);\n-\n-         begin\n-            Max_Fil := Integer'Max (Max_Fil, Fil.Last - Fil.First + 1);\n-            Max_Lin := Integer'Max (Max_Lin, Lin.Last - Lin.First + 1);\n-         end;\n-      end loop;\n-\n-      Max_Fil := Integer'Min (Max_Fil, Max_Col_Width);\n-\n-      for J in F'Range loop\n-         Put (\"   \");\n-         Put_Line (Image (F (J), Max_Fil, Max_Lin, Short));\n-      end loop;\n-   end Print_BT;\n-\n-   -------------\n-   -- Read_BT --\n-   -------------\n-\n-   function Read_BT (BT_Depth : Integer) return Root_Id is\n-      Max_Line : constant Integer := 500;\n-      Curs1    : Integer;\n-      Curs2    : Integer;\n-      Line     : String (1 .. Max_Line);\n-      Last     : Integer := 0;\n-      Frames   : Frame_Array (1 .. BT_Depth);\n-      F        : Integer := Frames'First;\n-      Nam      : Name_Id;\n-      Fil      : Name_Id;\n-      Lin      : Name_Id;\n-      Add      : System.Address;\n-      Int_Add  : Integer_Address;\n-      Fr       : Frame_Id;\n-      Main_Found : Boolean := False;\n-      pragma Warnings (Off, Line);\n-\n-      procedure Find_File;\n-      pragma Inline (Find_File);\n-      --  Position Curs1 and Curs2 so that Line (Curs1 .. Curs2) contains\n-      --  the file name. The file name may not be on the current line since\n-      --  a frame may be printed on more than one line when there is a lot\n-      --  of parameters or names are long, so this subprogram can read new\n-      --  lines of input.\n-\n-      procedure Find_Line;\n-      pragma Inline (Find_Line);\n-      --  Position Curs1 and Curs2 so that Line (Curs1 .. Curs2) contains\n-      --  the line number.\n-\n-      procedure Find_Name;\n-      pragma Inline (Find_Name);\n-      --  Position Curs1 and Curs2 so that Line (Curs1 .. Curs2) contains\n-      --  the subprogram name.\n-\n-      function Skip_To_Space (Pos : Integer) return Integer;\n-      pragma Inline (Skip_To_Space);\n-      --  Scans Line starting with position Pos, returning the position\n-      --  immediately before the first space, or the value of Last if no\n-      --  spaces were found\n-\n-      ---------------\n-      -- Find_File --\n-      ---------------\n-\n-      procedure Find_File is\n-      begin\n-         --  Skip \" at \"\n-\n-         Curs1 := Curs2 + 5;\n-         Curs2 := Last;\n-\n-         --  Scan backwards from end of line until ':' is encountered\n-\n-         for J in reverse Curs1 .. Last loop\n-            if Line (J) = ':' then\n-               Curs2 := J - 1;\n-            end if;\n-         end loop;\n-      end Find_File;\n-\n-      ---------------\n-      -- Find_Line --\n-      ---------------\n-\n-      procedure Find_Line is\n-      begin\n-         Curs1 := Curs2 + 2;\n-         Curs2 := Last;\n-\n-         --  Check for Curs1 too large. Should never happen with non-corrupt\n-         --  output. If it does happen, just reset it to the highest value.\n-\n-         if Curs1 > Last then\n-            Curs1 := Last;\n-         end if;\n-      end Find_Line;\n-\n-      ---------------\n-      -- Find_Name --\n-      ---------------\n-\n-      procedure Find_Name is\n-      begin\n-         --  Skip the address value and \" in \"\n-\n-         Curs1 := Skip_To_Space (1) + 5;\n-         Curs2 := Skip_To_Space (Curs1);\n-      end Find_Name;\n-\n-      -------------------\n-      -- Skip_To_Space --\n-      -------------------\n-\n-      function Skip_To_Space (Pos : Integer) return Integer is\n-      begin\n-         for Cur in Pos .. Last loop\n-            if Line (Cur) = ' ' then\n-               return Cur - 1;\n-            end if;\n-         end loop;\n-\n-         return Last;\n-      end Skip_To_Space;\n-\n-      procedure Gmem_Read_Next_Frame (Addr : out System.Address);\n-      pragma Import (C, Gmem_Read_Next_Frame, \"__gnat_gmem_read_next_frame\");\n-      --  Read the next frame in the current traceback. Addr is set to 0 if\n-      --  there are no more addresses in this traceback. The pointer is moved\n-      --  to the next frame.\n-\n-      procedure Gmem_Symbolic\n-        (Addr : System.Address; Buf : String; Last : out Natural);\n-      pragma Import (C, Gmem_Symbolic, \"__gnat_gmem_symbolic\");\n-      --  Get the symbolic traceback for Addr. Note: we cannot use\n-      --  GNAT.Tracebacks.Symbolic, since the latter will only work with the\n-      --  current executable.\n-      --\n-      --  \"__gnat_gmem_symbolic\" will work with the executable whose name is\n-      --  given in gnat_argv[0], as initialized by Gnatmem.Gmem_A21_Initialize.\n-\n-   --  Start of processing for Read_BT\n-\n-   begin\n-      while F <= BT_Depth and then not Main_Found loop\n-         Gmem_Read_Next_Frame (Add);\n-         Int_Add := To_Integer (Add);\n-         exit when Int_Add = 0;\n-\n-         Fr := Frame_HTable.Get (Int_Add);\n-\n-         if Fr = No_Frame_Id then\n-            Gmem_Symbolic (Add, Line, Last);\n-            Last := Last - 1; -- get rid of the trailing line-feed\n-            Find_Name;\n-\n-            --  Skip the __gnat_malloc frame itself\n-\n-            if Line (Curs1 .. Curs2) /= \"<__gnat_malloc>\" then\n-               Nam := Enter_Name (Line (Curs1 .. Curs2));\n-               Main_Found := (Nam = Main_Name_Id);\n-\n-               Find_File;\n-               Fil := Enter_Name (Line (Curs1 .. Curs2));\n-               Find_Line;\n-               Lin := Enter_Name (Line (Curs1 .. Curs2));\n-\n-               Frames (F) := Enter_Frame (Add, Nam, Fil, Lin);\n-               F := F + 1;\n-            end if;\n-\n-         else\n-            Frames (F) := Fr;\n-            Main_Found := (Memroot.Frames.Table (Fr).Name = Main_Name_Id);\n-            F := F + 1;\n-         end if;\n-      end loop;\n-\n-      return Enter_Root (Frames (1 .. F - 1));\n-   end Read_BT;\n-\n-   -------------\n-   -- Root_Eq --\n-   -------------\n-\n-   function Root_Eq (N1, N2 : Root) return Boolean is\n-      use type Frames_In_Root.Table_Type;\n-\n-   begin\n-      return\n-        Frames_In_Root.Table (N1.First .. N1.Last)\n-          = Frames_In_Root.Table (N2.First .. N2.Last);\n-   end Root_Eq;\n-\n-   --------------------\n-   -- Set_Alloc_Size --\n-   --------------------\n-\n-   procedure Set_Alloc_Size (B : Root_Id; V : Storage_Count) is\n-   begin\n-      Roots.Table (B).Alloc_Size := V;\n-   end Set_Alloc_Size;\n-\n-   -------------------------\n-   -- Set_High_Water_Mark --\n-   -------------------------\n-\n-   procedure Set_High_Water_Mark (B : Root_Id; V : Storage_Count) is\n-   begin\n-      Roots.Table (B).High_Water_Mark := V;\n-   end Set_High_Water_Mark;\n-\n-   ------------------\n-   -- Set_Nb_Alloc --\n-   ------------------\n-\n-   procedure Set_Nb_Alloc (B : Root_Id; V : Integer) is\n-   begin\n-      Roots.Table (B).Nb_Alloc := V;\n-   end Set_Nb_Alloc;\n-\n-begin\n-   --  Initialize name for No_Name_ID\n-\n-   Names.Increment_Last;\n-   Names.Table (Names.Last) := Name'(1, 0);\n-   Main_Name_Id := Enter_Name (\"main\");\n-end Memroot;"}, {"sha": "484b6217378e4ae540797b1dee7219800b3336b2", "filename": "gcc/ada/memroot.ads", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fmemroot.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dac80b578697fae3e3cdfaad081bcffa0fa60/gcc%2Fada%2Fmemroot.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemroot.ads?ref=8e4dac80b578697fae3e3cdfaad081bcffa0fa60", "patch": "@@ -1,109 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              M E M R O O T                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 1997-2008, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package offers basic types that deal with gdb backtraces related\n---  to memory allocation. A memory root (root_id) is a backtrace\n---  referencing the actual point of allocation along with counters\n---  recording various information concerning allocation at this root.\n-\n---  A back trace is composed of Frames (Frame_Id) which themselves are\n---  nothing else than a subprogram call at a source location which can be\n---  represented by three strings: subprogram name, file name and line\n---  number. All the needed strings are entered in a table and referenced\n---  through a Name_Id in order to avoid duplication.\n-\n-with System.Storage_Elements; use System.Storage_Elements;\n-\n-package Memroot is\n-\n-   --  Simple abstract type for names. A name is a sequence of letters\n-\n-   type Name_Id is new Natural;\n-   No_Name_Id : constant Name_Id := 0;\n-\n-   function Enter_Name (S : String) return Name_Id;\n-   function Image      (N : Name_Id) return String;\n-\n-   --  Simple abstract type for a backtrace frame. A frame is composed by\n-   --  a subprogram name, a file name and a line reference.\n-\n-   type Frame_Id is new Natural;\n-   No_Frame_Id : constant Frame_Id := 0;\n-\n-   function Enter_Frame\n-     (Addr : System.Address;\n-      Name : Name_Id;\n-      File : Name_Id;\n-      Line : Name_Id)\n-      return Frame_Id;\n-\n-   type Frame_Array is array (Natural range <>) of Frame_Id;\n-\n-   --  Simple abstract type for an allocation root. It is composed by a set\n-   --  of frames, the number of allocation, the total size of allocated\n-   --  memory, and the high water mark.  An iterator is also provided to\n-   --  iterate over all the entered allocation roots.\n-\n-   type Root_Id is new Natural;\n-   No_Root_Id : constant Root_Id := 0;\n-\n-   function Read_BT (BT_Depth : Integer) return Root_Id;\n-   --  Reads a backtrace whose maximum frame number is given by\n-   --  BT_Depth and returns the corresponding Allocation root.\n-\n-   function Enter_Root  (Fr : Frame_Array) return Root_Id;\n-   --  Create an allocation root from the frames that compose it\n-\n-   function Frames_Of   (B  : Root_Id) return Frame_Array;\n-   --  Retrieves the Frames of the root's backtrace\n-\n-   procedure Print_BT (B  : Root_Id; Short : Boolean := False);\n-   --  Prints on standard out the backtrace associated with the root B\n-   --  When Short is set to True, only the filename & line info is printed.\n-   --  When it is set to false, the subprogram name is also printed.\n-\n-   function Get_First return Root_Id;\n-   function Get_Next  return Root_Id;\n-   --  Iterator to iterate over roots\n-\n-   procedure Set_Nb_Alloc (B : Root_Id; V : Integer);\n-   function      Nb_Alloc (B : Root_Id) return Integer;\n-   --  Access and modify the number of allocation counter associated with\n-   --  this allocation root. If the value is negative, it means that this is\n-   --  not an allocation root but a deallocation root (this can only happen\n-   --  in erroneous situations where there are more frees than allocations).\n-\n-   procedure Set_Alloc_Size (B : Root_Id; V : Storage_Count);\n-   function      Alloc_Size (B : Root_Id) return Storage_Count;\n-   --  Access and modify the total allocated memory counter associated with\n-   --  this allocation root.\n-\n-   procedure Set_High_Water_Mark (B : Root_Id; V : Storage_Count);\n-   function  High_Water_Mark     (B : Root_Id) return Storage_Count;\n-   --  Access and modify the high water mark associated with this\n-   --  allocation root. The high water mark is the maximum value, over\n-   --  time, of the Alloc_Size.\n-\n-end Memroot;"}, {"sha": "f0e4c497debd74d96414ba300fa6354c68f0bcc3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/027dbed8279f0312e8d01852728c5d8141ca5e33/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=027dbed8279f0312e8d01852728c5d8141ca5e33", "patch": "@@ -9607,9 +9607,8 @@ package body Sem_Ch3 is\n          --  on the partial view. Make them visible to component declarations.\n \n          declare\n-            D    : Entity_Id;\n-            --  Discriminant on T (full view) referencing expression on partial\n-            --  view.\n+            D : Entity_Id;\n+            --  Discriminant on T (full view) referencing expr on partial view\n \n             Prev_D : Entity_Id;\n             --  Entity of corresponding discriminant on partial view\n@@ -9619,10 +9618,10 @@ package body Sem_Ch3 is\n             --  syntactic copy on full view (which has been checked for\n             --  conformance with partial view), only used here to post error\n             --  message.\n+\n          begin\n-            D := First_Discriminant (T);\n+            D     := First_Discriminant (T);\n             New_D := First (Discriminant_Specifications (N));\n-\n             while Present (D) loop\n                Prev_D := Current_Entity (D);\n                Set_Current_Entity (D);\n@@ -9639,8 +9638,7 @@ package body Sem_Ch3 is\n                     and then not Error_Posted (Expression (Parent (D)))\n                then\n                   Error_Msg_N\n-                    (\"discriminants of tagged type \"\n-                     & \"cannot have defaults\",\n+                    (\"discriminants of tagged type cannot have defaults\",\n                      Expression (New_D));\n                end if;\n \n@@ -10765,7 +10763,7 @@ package body Sem_Ch3 is\n             Next_Elmt (E);\n          end loop;\n \n-         --  The corresponding_Discriminant mechanism is incomplete, because\n+         --  The Corresponding_Discriminant mechanism is incomplete, because\n          --  the correspondence between new and old discriminants is not one\n          --  to one: one new discriminant can constrain several old ones. In\n          --  that case, scan sequentially the stored_constraint, the list of\n@@ -16387,16 +16385,15 @@ package body Sem_Ch3 is\n                   Expression (Discr));\n \n             elsif Is_Tagged_Type (Current_Scope)\n-                    and then Comes_From_Source (N)\n+              and then Comes_From_Source (N)\n             then\n-               --  Note: see also similar test in Check_Or_Process_\n-               --  Discriminants, to handle the (illegal) case of the\n-               --  completion of an untagged view with discriminants\n-               --  with defaults by a tagged full view. We skip the check if\n-               --  Discr does not come from source to account for the case of\n-               --  an untagged derived type providing defaults for a renamed\n-               --  discriminant from a private nontagged ancestor with a tagged\n-               --  full view (ACATS B460006).\n+               --  Note: see similar test in Check_Or_Process_Discriminants, to\n+               --  handle the (illegal) case of the completion of an untagged\n+               --  view with discriminants with defaults by a tagged full view.\n+               --  We skip the check if Discr does not come from source to\n+               --  account for the case of an untagged derived type providing\n+               --  defaults for a renamed discriminant from a private nontagged\n+               --  ancestor with a tagged full view (ACATS B460006).\n \n                Error_Msg_N\n                  (\"discriminants of tagged type cannot have defaults\","}]}