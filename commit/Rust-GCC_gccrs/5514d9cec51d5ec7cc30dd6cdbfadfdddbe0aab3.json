{"sha": "5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "node_id": "C_kwDOANBUbNoAKDU1MTRkOWNlYzUxZDVlYzdjYzMwZGQ2Y2RiZmFkZmRkZGJlMGFhYjM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-16T15:18:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-16T15:18:49Z"}, "message": "Merge #801\n\n801: operator overloading r=philberty a=philberty\n\nThis change adds operator overloading by following how the C++ front-end\r\ndoes it. We are relying on GCC to inline the operator overloads which does\r\noccur once optimizations are enabled. It also brings back the desurgared\r\ncompound assignment expression (e2b761b13e6ccd3a7af4100183bb13e32b5b0da0)\r\nfor lang_items such as add_assign. You can find more information on how the algorithm works in:\r\n\r\n- c47d5cbdee9b701fb7753b44530fcb51f80b20fa \r\n- a7fb60bb626f7b936bf117636db777a5f0df30c9 \r\n\r\nThese were refactored in: 0f74fe23c6d602c257ba94b2522bd9d6a594609e\r\n\r\nFixes #249\r\n\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "55051cad7f474f411d79ca1e86cc23d63138716d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55051cad7f474f411d79ca1e86cc23d63138716d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhk8vZCRBK7hj4Ov3rIwAAQ6gIAC0WNRHX7CUxwmCBRqNXSZQc\nSTuzvBD3hGVoiD8nrsw+ZskuCD9yrRUT0TIRianwscM5nvHsNpTPbQXUT664iBCl\n7kBjdHDhjbDPEJoxPzHvztSA62tqFits0CQUtHT8icxF/cVBRIC+g1xwOPR9J98Z\nkG2LsF6jxk5828fcAoM5ArbH0nK23XIDOJgyADQmoq8RA9RUDwJzu7QYAgbZnB/N\nzhmsPx/ziKdkOW7uuXMRMUiR0nGn/INPEqDiCNxRy+Ijt65RrwAObifCDpK3oq0A\npJMgKMQutSZGAK+xhu8vrj13JXVEXFoqleli0EB4G7IlBmOCWyQmahoB3vbNSWE=\n=fpjN\n-----END PGP SIGNATURE-----\n", "payload": "tree 55051cad7f474f411d79ca1e86cc23d63138716d\nparent dcd758595f646a480947265ccc9833fdd3976b75\nparent 6d1333ef46cba6ed9e1ace817f9cc649b7f7a1df\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637075929 +0000\ncommitter GitHub <noreply@github.com> 1637075929 +0000\n\nMerge #801\n\n801: operator overloading r=philberty a=philberty\n\nThis change adds operator overloading by following how the C++ front-end\r\ndoes it. We are relying on GCC to inline the operator overloads which does\r\noccur once optimizations are enabled. It also brings back the desurgared\r\ncompound assignment expression (e2b761b13e6ccd3a7af4100183bb13e32b5b0da0)\r\nfor lang_items such as add_assign. You can find more information on how the algorithm works in:\r\n\r\n- c47d5cbdee9b701fb7753b44530fcb51f80b20fa \r\n- a7fb60bb626f7b936bf117636db777a5f0df30c9 \r\n\r\nThese were refactored in: 0f74fe23c6d602c257ba94b2522bd9d6a594609e\r\n\r\nFixes #249\r\n\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd758595f646a480947265ccc9833fdd3976b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcd758595f646a480947265ccc9833fdd3976b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcd758595f646a480947265ccc9833fdd3976b75"}, {"sha": "6d1333ef46cba6ed9e1ace817f9cc649b7f7a1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1333ef46cba6ed9e1ace817f9cc649b7f7a1df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1333ef46cba6ed9e1ace817f9cc649b7f7a1df"}], "stats": {"total": 1805, "additions": 1491, "deletions": 314}, "files": [{"sha": "f3302c2e3fb6861694fb512c932a51fbd30ffe7b", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -90,6 +90,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-base62.o \\\n+    rust/rust-compile-expr.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "05779e7be0ba640ebd41fae87e140dfb4585d448", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -542,6 +542,13 @@ struct Attribute\n class AttrInput\n {\n public:\n+  enum AttrInputType\n+  {\n+    LITERAL,\n+    META_ITEM,\n+    TOKEN_TREE,\n+  };\n+\n   virtual ~AttrInput () {}\n \n   // Unique pointer custom clone function\n@@ -564,6 +571,8 @@ class AttrInput\n   // Returns whether attr input has been parsed to meta item syntax.\n   virtual bool is_meta_item () const = 0;\n \n+  virtual AttrInputType get_attr_input_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual AttrInput *clone_attr_input_impl () const = 0;\n@@ -650,6 +659,11 @@ class AttrInputMetaItemContainer : public AttrInput\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::META_ITEM;\n+  }\n+\n   // Clones this object.\n   std::unique_ptr<AttrInputMetaItemContainer>\n   clone_attr_input_meta_item_container () const\n@@ -767,6 +781,11 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   }\n \n   bool is_meta_item () const override { return false; }\n+\n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::TOKEN_TREE;\n+  }\n };\n \n /* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to"}, {"sha": "3463f5a2f1cac2dabe5e27ff6d86adb518b11ce3", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -102,13 +102,7 @@ class LiteralExpr : public ExprWithoutBlock\n // Literal expression attribute body (non-macro attribute)\n class AttrInputLiteral : public AttrInput\n {\n-  // Literal expression WITHOUT SUFFIX\n-  // std::unique_ptr<LiteralExpr> literal_expr;\n-  LiteralExpr\n-    literal_expr; // as not using polymorphic behaviour, doesn't require pointer\n-  // TODO: will require pointer if LiteralExpr is changed to have subclassing\n-\n-  // TODO: should this store location data?\n+  LiteralExpr literal_expr;\n \n public:\n   AttrInputLiteral (LiteralExpr lit_expr) : literal_expr (std::move (lit_expr))\n@@ -127,6 +121,13 @@ class AttrInputLiteral : public AttrInput\n \n   bool is_meta_item () const override { return false; }\n \n+  LiteralExpr &get_literal () { return literal_expr; }\n+\n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::LITERAL;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "594cfffb4982e394d845da6bd44daaf1ce77e08a", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -0,0 +1,394 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+      translated = resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t\t      expr.get_lhs (), expr.get_rhs ());\n+      return;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  fncontext fn = ctx->peek_fn ();\n+\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_left_expr ().get (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_right_expr ().get (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\t  expr.get_expr_type ());\n+      auto compound_assignment\n+\t= resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t     expr.get_left_expr ().get (),\n+\t\t\t\t     expr.get_right_expr ().get ());\n+      auto assignment\n+\t= ctx->get_backend ()->expression_statement (fn.fndecl,\n+\t\t\t\t\t\t     compound_assignment);\n+      ctx->add_statement (assignment);\n+\n+      return;\n+    }\n+\n+  auto operator_expr\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+  Bstatement *assignment\n+    = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, operator_expr,\n+\t\t\t\t\t\t expr.get_locus ());\n+  ctx->add_statement (assignment);\n+}\n+\n+void\n+CompileExpr::visit (HIR::NegationExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto negated_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::NegationOperatorToLangItem (op);\n+      translated\n+\t= resolve_operator_overload (lang_item_type, expr, negated_expr,\n+\t\t\t\t     nullptr, expr.get_expr ().get (), nullptr);\n+      return;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n+}\n+\n+Bexpression *\n+CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t\tTyTy::BaseType *receiver,\n+\t\t\t\t\tTyTy::FnType *fntype,\n+\t\t\t\t\tBexpression *receiver_ref,\n+\t\t\t\t\tstd::vector<HIR::Expr *> &arguments,\n+\t\t\t\t\tLocation expr_locus)\n+{\n+  size_t offs = 0;\n+  const Resolver::TraitItemReference *ref = nullptr;\n+  for (auto &bound : dyn->get_object_items ())\n+    {\n+      const Resolver::TraitItemReference *item = bound.first;\n+      auto t = item->get_tyty ();\n+      rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n+      auto ft = static_cast<TyTy::FnType *> (t);\n+\n+      if (ft->get_id () == fntype->get_id ())\n+\t{\n+\t  ref = item;\n+\t  break;\n+\t}\n+      offs++;\n+    }\n+\n+  if (ref == nullptr)\n+    return ctx->get_backend ()->error_expression ();\n+\n+  // get any indirection sorted out\n+  if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      auto indirect_ty = r->get_base ();\n+      Btype *indrect_compiled_tyty\n+\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n+\n+      Bexpression *indirect\n+\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n+\t\t\t\t\t\t    receiver_ref, true,\n+\t\t\t\t\t\t    expr_locus);\n+      receiver_ref = indirect;\n+    }\n+\n+  // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+  Bexpression *self_argument\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t    expr_locus);\n+\n+  // access the vtable for the fn\n+  Bexpression *fn_vtable_access\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n+\t\t\t\t\t\t    expr_locus);\n+\n+  // cast it to the correct fntype\n+  Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  Bexpression *fn_convert_expr\n+    = ctx->get_backend ()->convert_expression (expected_fntype,\n+\t\t\t\t\t       fn_vtable_access, expr_locus);\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  bool is_address_taken = false;\n+  Bstatement *ret_var_stmt = nullptr;\n+  Bvariable *fn_convert_expr_tmp\n+    = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n+\t\t\t\t\t       expected_fntype, fn_convert_expr,\n+\t\t\t\t\t       is_address_taken, expr_locus,\n+\t\t\t\t\t       &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+\n+  std::vector<Bexpression *> args;\n+  args.push_back (self_argument);\n+  for (auto &argument : arguments)\n+    {\n+      Bexpression *compiled_expr = CompileExpr::Compile (argument, ctx);\n+      args.push_back (compiled_expr);\n+    }\n+\n+  Bexpression *fn_expr\n+    = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n+\n+  return ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n+\t\t\t\t\t       nullptr, expr_locus);\n+}\n+\n+Bexpression *\n+CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t\t     TyTy::BaseType *receiver,\n+\t\t\t\t     HIR::PathIdentSegment &segment,\n+\t\t\t\t     Analysis::NodeMapping expr_mappings,\n+\t\t\t\t     Location expr_locus)\n+{\n+  // lookup compiled functions since it may have already been compiled\n+  Bfunction *fn = nullptr;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+    {\n+      return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+    }\n+\n+  // Now we can try and resolve the address since this might be a forward\n+  // declared function, generic function which has not be compiled yet or\n+  // its an not yet trait bound function\n+  HIR::ImplItem *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_implitem (expr_mappings.get_crate_num (),\n+\t\t\t\t\t\t ref, nullptr);\n+  if (resolved_item != nullptr)\n+    {\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n+\t\t\t\t\t\t true);\n+\n+      return CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n+\t\t\t\t\t       true, fntype);\n+    }\n+\n+  // it might be resolved to a trait item\n+  HIR::TraitItem *trait_item = ctx->get_mappings ()->lookup_hir_trait_item (\n+    expr_mappings.get_crate_num (), ref);\n+  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+    trait_item->get_mappings ().get_hirid ());\n+\n+  Resolver::TraitReference *trait_ref\n+    = &Resolver::TraitReference::error_node ();\n+  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+    trait->get_mappings ().get_defid (), &trait_ref);\n+  rust_assert (ok);\n+\n+  // the type resolver can only resolve type bounds to their trait\n+  // item so its up to us to figure out if this path should resolve\n+  // to an trait-impl-block-item or if it can be defaulted to the\n+  // trait-impl-item's definition\n+\n+  auto root = receiver->get_root ();\n+  std::vector<Resolver::PathProbeCandidate> candidates\n+    = Resolver::PathProbeType::Probe (root, segment, true, false, true);\n+\n+  if (candidates.size () == 0)\n+    {\n+      // this means we are defaulting back to the trait_item if\n+      // possible\n+      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+      bool ok = trait_ref->lookup_hir_trait_item (*trait_item, &trait_item_ref);\n+      rust_assert (ok);\t\t\t\t    // found\n+      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+      // FIXME Optional means it has a definition and an associated\n+      // block which can be a default implementation, if it does not\n+      // contain an implementation we should actually return\n+      // error_mark_node\n+\n+      return CompileTraitItem::Compile (receiver,\n+\t\t\t\t\ttrait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\tctx, fntype, true, expr_locus);\n+    }\n+  else\n+    {\n+      std::vector<Resolver::Adjustment> adjustments;\n+      Resolver::PathProbeCandidate *candidate\n+\t= Resolver::MethodResolution::Select (candidates, root, adjustments);\n+\n+      // FIXME this will be a case to return error_mark_node, there is\n+      // an error scenario where a Trait Foo has a method Bar, but this\n+      // receiver does not implement this trait or has an incompatible\n+      // implementation and we should just return error_mark_node\n+      rust_assert (candidate != nullptr);\n+      rust_assert (candidate->is_impl_candidate ());\n+\n+      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (receiver, impl_item, ctx,\n+\t\t\t\t\t\t true);\n+\n+      return CompileInherentImplItem::Compile (receiver, impl_item, ctx, true,\n+\t\t\t\t\t       fntype);\n+    }\n+}\n+\n+Bexpression *\n+CompileExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n+  Bexpression *lhs, Bexpression *rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n+{\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  rust_assert (is_op_overload);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  bool ok = ctx->get_resolver ()->lookup_resolved_name (\n+    expr.get_mappings ().get_nodeid (), &resolved_node_id);\n+  rust_assert (ok);\n+\n+  // reverse lookup\n+  HirId ref;\n+  ok = ctx->get_mappings ()->lookup_node_to_hir (\n+    expr.get_mappings ().get_crate_num (), resolved_node_id, &ref);\n+  rust_assert (ok);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      if (rhs_expr != nullptr) // can be null for negation_expr (unary ones)\n+\targuments.push_back (rhs_expr);\n+\n+      return compile_dyn_dispatch_call (dyn, receiver, fntype, lhs, arguments,\n+\t\t\t\t\texpr.get_locus ());\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathIdentSegment segment_name (\n+    Analysis::RustLangItem::ToString (lang_item_type));\n+  Bexpression *fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  // FIXME refactor this out\n+  Bexpression *self = lhs;\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self\n+\t    = ctx->get_backend ()->address_expression (self,\n+\t\t\t\t\t\t       lhs_expr->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  Btype *expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self\n+\t    = ctx->get_backend ()->indirect_expression (expected_type, self,\n+\t\t\t\t\t\t\ttrue, /* known_valid*/\n+\t\t\t\t\t\t\tlhs_expr->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<Bexpression *> args;\n+  args.push_back (self); // adjusted self\n+  if (rhs != nullptr)\t // can be null for negation_expr (unary ones)\n+    args.push_back (rhs);\n+\n+  auto fncontext = ctx->peek_fn ();\n+  return ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t       nullptr, expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "b4079f7e4acd4cd89835a734cf6b36c34cb2d9bc", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -388,6 +388,8 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (assignment);\n   }\n \n+  void visit (HIR::CompoundAssignmentExpr &expr) override;\n+\n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n     Bexpression *array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n@@ -448,17 +450,7 @@ class CompileExpr : public HIRCompileBase\n       constructor.push_back (translated_expr);\n   }\n \n-  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t       location);\n-  }\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n \n   void visit (HIR::ComparisonExpr &expr) override\n   {\n@@ -482,15 +474,7 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->lazy_boolean_expression (op, lhs, rhs, location);\n   }\n \n-  void visit (HIR::NegationExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto negated_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n-  }\n+  void visit (HIR::NegationExpr &expr) override;\n \n   void visit (HIR::TypeCastExpr &expr) override\n   {\n@@ -999,6 +983,26 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t\t  expr.get_locus ());\n   }\n \n+protected:\n+  Bexpression *compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t\t  TyTy::BaseType *receiver,\n+\t\t\t\t\t  TyTy::FnType *fntype,\n+\t\t\t\t\t  Bexpression *receiver_ref,\n+\t\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n+\t\t\t\t\t  Location expr_locus);\n+\n+  Bexpression *resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t\t       HIR::PathIdentSegment &segment,\n+\t\t\t\t       Analysis::NodeMapping expr_mappings,\n+\t\t\t\t       Location expr_locus);\n+\n+  Bexpression *\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExpr &expr, Bexpression *lhs,\n+\t\t\t     Bexpression *rhs, HIR::Expr *lhs_expr,\n+\t\t\t     HIR::Expr *rhs_expr);\n+\n private:\n   CompileExpr (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)"}, {"sha": "e53993a8cbe98a7efb2e807eeadf3d1a6d0eb218", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 10, "deletions": 209, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -242,220 +242,21 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       const TyTy::DynamicObjectType *dyn\n \t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n \n-      size_t offs = 0;\n-      const Resolver::TraitItemReference *ref = nullptr;\n-      for (auto &bound : dyn->get_object_items ())\n-\t{\n-\t  const Resolver::TraitItemReference *item = bound.first;\n-\t  auto t = item->get_tyty ();\n-\t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n-\t  auto ft = static_cast<TyTy::FnType *> (t);\n-\n-\t  if (ft->get_id () == fntype->get_id ())\n-\t    {\n-\t      ref = item;\n-\t      break;\n-\t    }\n-\t  offs++;\n-\t}\n-\n-      if (ref == nullptr)\n-\t{\n-\t  translated = ctx->get_backend ()->error_expression ();\n-\t  return;\n-\t}\n-\n-      // get any indirection sorted out\n-      auto receiver_ref = self;\n-      if (receiver->get_kind () == TyTy::TypeKind::REF)\n-\t{\n-\t  TyTy::ReferenceType *r\n-\t    = static_cast<TyTy::ReferenceType *> (receiver);\n-\t  auto indirect_ty = r->get_base ();\n-\t  Btype *indrect_compiled_tyty\n-\t    = TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-\t  Bexpression *indirect\n-\t    = ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t\treceiver_ref, true,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\t  receiver_ref = indirect;\n-\t}\n+      std::vector<HIR::Expr *> arguments;\n+      for (auto &arg : expr.get_arguments ())\n+\targuments.push_back (arg.get ());\n \n-      // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n-      Bexpression *self_argument\n-\t= ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\n-      // access the vtable for the fn\n-      Bexpression *fn_vtable_access\n-\t= ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\n-      // cast it to the correct fntype\n-      Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n-      Bexpression *fn_convert_expr\n-\t= ctx->get_backend ()->convert_expression (expected_fntype,\n-\t\t\t\t\t\t   fn_vtable_access,\n-\t\t\t\t\t\t   expr.get_locus ());\n-\n-      fncontext fnctx = ctx->peek_fn ();\n-      Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-      bool is_address_taken = false;\n-      Bstatement *ret_var_stmt = nullptr;\n-\n-      Bvariable *fn_convert_expr_tmp = ctx->get_backend ()->temporary_variable (\n-\tfnctx.fndecl, enclosing_scope, expected_fntype, fn_convert_expr,\n-\tis_address_taken, expr.get_locus (), &ret_var_stmt);\n-      ctx->add_statement (ret_var_stmt);\n-\n-      std::vector<Bexpression *> args;\n-      args.push_back (self_argument);\n-      for (auto &argument : expr.get_arguments ())\n-\t{\n-\t  Bexpression *compiled_expr\n-\t    = CompileExpr::Compile (argument.get (), ctx);\n-\t  args.push_back (compiled_expr);\n-\t}\n-\n-      Bexpression *fn_expr\n-\t= ctx->get_backend ()->var_expression (fn_convert_expr_tmp,\n-\t\t\t\t\t       expr.get_locus ());\n-\n-      translated\n-\t= ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n       return;\n     }\n \n-  // address of compiled function\n-  Bexpression *fn_expr = ctx->get_backend ()->error_expression ();\n-\n   // lookup compiled functions since it may have already been compiled\n-  Bfunction *fn = nullptr;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-    {\n-      fn_expr\n-\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n-    }\n-  else\n-    {\n-      // Now we can try and resolve the address since this might be a forward\n-      // declared function, generic function which has not be compiled yet or\n-      // its an not yet trait bound function\n-      HIR::ImplItem *resolved_item = ctx->get_mappings ()->lookup_hir_implitem (\n-\texpr.get_mappings ().get_crate_num (), ref, nullptr);\n-      if (resolved_item == nullptr)\n-\t{\n-\t  // it might be resolved to a trait item\n-\t  HIR::TraitItem *trait_item\n-\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n-\t      expr.get_mappings ().get_crate_num (), ref);\n-\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n-\t    trait_item->get_mappings ().get_hirid ());\n-\n-\t  Resolver::TraitReference *trait_ref\n-\t    = &Resolver::TraitReference::error_node ();\n-\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n-\t    trait->get_mappings ().get_defid (), &trait_ref);\n-\t  rust_assert (ok);\n-\n-\t  // the type resolver can only resolve type bounds to their trait\n-\t  // item so its up to us to figure out if this path should resolve\n-\t  // to an trait-impl-block-item or if it can be defaulted to the\n-\t  // trait-impl-item's definition\n-\n-\t  auto root = receiver->get_root ();\n-\t  std::vector<Resolver::PathProbeCandidate> candidates\n-\t    = Resolver::PathProbeType::Probe (\n-\t      root, expr.get_method_name ().get_segment (), true, false, true);\n-\n-\t  if (candidates.size () == 0)\n-\t    {\n-\t      // this means we are defaulting back to the trait_item if\n-\t      // possible\n-\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n-\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n-\t\t\t\t\t\t\t  &trait_item_ref);\n-\t      rust_assert (ok);\t\t\t\t    // found\n-\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n-\n-\t      // FIXME Optional means it has a definition and an associated\n-\t      // block which can be a default implementation, if it does not\n-\t      // contain an implementation we should actually return\n-\t      // error_mark_node\n-\n-\t      TyTy::BaseType *self_type = nullptr;\n-\t      if (!ctx->get_tyctx ()->lookup_type (\n-\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t    &self_type))\n-\t\t{\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"failed to resolve type for self param\");\n-\t\t  return;\n-\t\t}\n-\n-\t      fn_expr = CompileTraitItem::Compile (\n-\t\tself_type, trait_item_ref->get_hir_trait_item (), ctx, fntype,\n-\t\ttrue, expr.get_locus ());\n-\t    }\n-\t  else\n-\t    {\n-\t      std::vector<Resolver::Adjustment> adjustments;\n-\t      Resolver::PathProbeCandidate *candidate\n-\t\t= Resolver::MethodResolution::Select (candidates, root,\n-\t\t\t\t\t\t      adjustments);\n-\n-\t      // FIXME this will be a case to return error_mark_node, there is\n-\t      // an error scenario where a Trait Foo has a method Bar, but this\n-\t      // receiver does not implement this trait or has an incompatible\n-\t      // implementation and we should just return error_mark_node\n-\t      rust_assert (candidate != nullptr);\n-\t      rust_assert (candidate->is_impl_candidate ());\n-\n-\t      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n-\n-\t      TyTy::BaseType *self_type = nullptr;\n-\t      if (!ctx->get_tyctx ()->lookup_type (\n-\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t    &self_type))\n-\t\t{\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"failed to resolve type for self param\");\n-\t\t  return;\n-\t\t}\n-\n-\t      if (!fntype->has_subsititions_defined ())\n-\t\tfn_expr\n-\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t      true);\n-\t      else\n-\t\tfn_expr\n-\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t      true, fntype);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  TyTy::BaseType *self_type = nullptr;\n-\t  if (!ctx->get_tyctx ()->lookup_type (\n-\t\texpr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"failed to resolve type for self param\");\n-\t      return;\n-\t    }\n-\n-\t  if (!fntype->has_subsititions_defined ())\n-\t    fn_expr\n-\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t\t  true);\n-\t  else\n-\t    fn_expr\n-\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t\t  true, fntype);\n-\t}\n-    }\n+  HIR::PathExprSegment method_name = expr.get_method_name ();\n+  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+  Bexpression *fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n \n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;"}, {"sha": "f36096b44efc548c11446e7265ecf10ea21cfd94", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -452,11 +452,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t       expr.get_locus ());\n   }\n \n-  /* Compound assignment expression is compiled away. */\n   void visit (AST::CompoundAssignmentExpr &expr) override\n   {\n-    /* First we need to find the corresponding arithmetic or logical operator.\n-     */\n     ArithmeticOrLogicalOperator op;\n     switch (expr.get_expr_type ())\n       {\n@@ -503,15 +500,10 @@ class ASTLoweringExpr : public ASTLoweringBase\n     Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    HIR::Expr *operator_expr\n-      = new HIR::ArithmeticOrLogicalExpr (mapping, asignee_expr->clone_expr (),\n-\t\t\t\t\t  std::unique_ptr<HIR::Expr> (value),\n-\t\t\t\t\t  op, expr.get_locus ());\n-    translated\n-      = new HIR::AssignmentExpr (mapping,\n-\t\t\t\t std::unique_ptr<HIR::Expr> (asignee_expr),\n-\t\t\t\t std::unique_ptr<HIR::Expr> (operator_expr),\n-\t\t\t\t expr.get_locus ());\n+\n+    translated = new HIR::CompoundAssignmentExpr (\n+      mapping, std::unique_ptr<HIR::Expr> (asignee_expr),\n+      std::unique_ptr<HIR::Expr> (value), op, expr.get_locus ());\n   }\n \n   void visit (AST::StructExprStruct &struct_expr) override"}, {"sha": "65a49213986968e4afda2789f0586988d344a917", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -613,29 +613,6 @@ class ASTLoweringItem : public ASTLoweringBase\n     if (trait.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (trait.get_generic_params ());\n-\n-\tfor (auto &generic_param : generic_params)\n-\t  {\n-\t    switch (generic_param->get_kind ())\n-\t      {\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  const HIR::TypeParam &t\n-\t\t    = static_cast<const HIR::TypeParam &> (*generic_param);\n-\n-\t\t  if (t.has_type ())\n-\t\t    {\n-\t\t      // see https://github.com/rust-lang/rust/issues/36887\n-\t\t      rust_error_at (\n-\t\t\tt.get_locus (),\n-\t\t\t\"defaults for type parameters are not allowed here\");\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t  }\n       }\n \n     std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;"}, {"sha": "901feda5e316790ccc1df271fcbee575ce0357cb", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 74, "deletions": 5, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -666,6 +666,80 @@ class AssignmentExpr : public OperatorExpr\n   }\n };\n \n+class CompoundAssignmentExpr : public OperatorExpr\n+{\n+public:\n+  using ExprType = ArithmeticOrLogicalOperator;\n+\n+private:\n+  // Note: overloading trait specified in comments\n+  ExprType expr_type;\n+  std::unique_ptr<Expr> right_expr;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprType get_expr_type () const { return expr_type; }\n+\n+  // Use pointers in constructor to enable polymorphism\n+  CompoundAssignmentExpr (Analysis::NodeMapping mappings,\n+\t\t\t  std::unique_ptr<Expr> value_to_assign_to,\n+\t\t\t  std::unique_ptr<Expr> value_to_assign,\n+\t\t\t  ExprType expr_kind, Location locus)\n+    : OperatorExpr (std::move (mappings), std::move (value_to_assign_to),\n+\t\t    AST::AttrVec (), locus),\n+      expr_type (expr_kind), right_expr (std::move (value_to_assign))\n+  {}\n+  // outer attributes not allowed\n+\n+  // Have clone in copy constructor\n+  CompoundAssignmentExpr (CompoundAssignmentExpr const &other)\n+    : OperatorExpr (other), expr_type (other.expr_type),\n+      right_expr (other.right_expr->clone_expr ())\n+  {}\n+\n+  // Overload assignment operator to clone\n+  CompoundAssignmentExpr &operator= (CompoundAssignmentExpr const &other)\n+  {\n+    OperatorExpr::operator= (other);\n+    // main_or_left_expr = other.main_or_left_expr->clone_expr();\n+    right_expr = other.right_expr->clone_expr ();\n+    expr_type = other.expr_type;\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CompoundAssignmentExpr (CompoundAssignmentExpr &&other) = default;\n+  CompoundAssignmentExpr &operator= (CompoundAssignmentExpr &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n+\n+  void visit_lhs (HIRVisitor &vis) { main_or_left_expr->accept_vis (vis); }\n+  void visit_rhs (HIRVisitor &vis) { right_expr->accept_vis (vis); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  CompoundAssignmentExpr *clone_expr_without_block_impl () const override\n+  {\n+    return new CompoundAssignmentExpr (*this);\n+  }\n+};\n+\n // Expression in parentheses (i.e. like literally just any 3 + (2 * 6))\n class GroupedExpr : public ExprWithoutBlock\n {\n@@ -1635,18 +1709,13 @@ class MethodCallExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> receiver;\n   PathExprSegment method_name;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  /*inline std::vector<std::unique_ptr<Expr>> get_params() const {\n-      return params;\n-  }*/\n-\n   MethodCallExpr (Analysis::NodeMapping mappings,\n \t\t  std::unique_ptr<Expr> call_receiver,\n \t\t  PathExprSegment method_path,"}, {"sha": "843e32ca1af6f558954468b7cbfd6b29fc5f5f47", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -1315,6 +1315,67 @@ AssignmentExpr::as_string () const\n \t + \"::\" + get_mappings ().as_string ();\n }\n \n+std::string\n+CompoundAssignmentExpr::as_string () const\n+{\n+  std::string operator_str;\n+  operator_str.reserve (1);\n+\n+  // get operator string\n+  switch (expr_type)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      operator_str = \"+\";\n+      break;\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      operator_str = \"-\";\n+      break;\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      operator_str = \"*\";\n+      break;\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+      operator_str = \"/\";\n+      break;\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      operator_str = \"%\";\n+      break;\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      operator_str = \"&\";\n+      break;\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      operator_str = \"|\";\n+      break;\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      operator_str = \"^\";\n+      break;\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      operator_str = \"<<\";\n+      break;\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      operator_str = \">>\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  operator_str += \"=\";\n+\n+  std::string str (\"CompoundAssignmentExpr: \");\n+  if (main_or_left_expr == nullptr || right_expr == nullptr)\n+    {\n+      str += \"error. this is probably a parsing failure.\";\n+    }\n+  else\n+    {\n+      str += \"\\n left: \" + main_or_left_expr->as_string ();\n+      str += \"\\n right: \" + right_expr->as_string ();\n+      str += \"\\n operator: \" + operator_str;\n+    }\n+\n+  return str;\n+}\n+\n std::string\n AsyncBlockExpr::as_string () const\n {\n@@ -3818,6 +3879,12 @@ AssignmentExpr::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n+void\n+CompoundAssignmentExpr::accept_vis (HIRVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n void\n GroupedExpr::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "ea125d9d082f53cb9e82454cfc59ac6f05bf480a", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -47,6 +47,7 @@ class HIRVisitor\n   virtual void visit (LazyBooleanExpr &expr) = 0;\n   virtual void visit (TypeCastExpr &expr) = 0;\n   virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n   virtual void visit (GroupedExpr &expr) = 0;\n   virtual void visit (ArrayElemsValues &elems) = 0;\n   virtual void visit (ArrayElemsCopied &elems) = 0;"}, {"sha": "e0494d702eb25cb10e6477be09fdc5b72543824a", "filename": "gcc/rust/lint/rust-lint-marklive-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -53,7 +53,7 @@ class MarkLiveBase : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "bcf792b98626b766e7ba9f028c358b5f84863399", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -186,6 +186,12 @@ class MarkLive : public MarkLiveBase\n     expr.visit_rhs (*this);\n   }\n \n+  void visit (HIR::CompoundAssignmentExpr &expr) override\n+  {\n+    expr.visit_lhs (*this);\n+    expr.visit_rhs (*this);\n+  }\n+\n   void visit (HIR::IfExpr &expr) override\n   {\n     expr.get_if_condition ()->accept_vis (*this);"}, {"sha": "d362fe431de4676553de4e58e1e592614ff780e8", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -75,6 +75,13 @@ class VerifyAsignee : public ResolverBase\n       }\n   }\n \n+  void visit (AST::DereferenceExpr &expr) override\n+  {\n+    expr.get_dereferenced_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::PathInExpression &expr) override { ok = true; }\n+\n private:\n   VerifyAsignee (NodeId parent) : ResolverBase (parent), ok (false) {}\n "}, {"sha": "db347551e846f6ddbafd87b19d6d238bf39cb3c8", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -68,6 +68,47 @@ class Adjustment\n   const TyTy::BaseType *expected;\n };\n \n+class Adjuster\n+{\n+public:\n+  Adjuster (const TyTy::BaseType *ty) : base (ty) {}\n+\n+  TyTy::BaseType *adjust_type (std::vector<Adjustment> adjustments)\n+  {\n+    TyTy::BaseType *ty = base->clone ();\n+    for (auto &adjustment : adjustments)\n+      {\n+\tswitch (adjustment.get_type ())\n+\t  {\n+\t  case Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n+\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n+\t\t\t\t\t  Mutability::Imm);\n+\t    break;\n+\n+\t  case Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n+\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n+\t\t\t\t\t  Mutability::Mut);\n+\t    break;\n+\n+\t  case Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t    // FIXME this really needs to support deref lang-item operator\n+\t    // overloads\n+\t    rust_assert (ty->get_kind () == TyTy::TypeKind::REF);\n+\t    const TyTy::ReferenceType *rr\n+\t      = static_cast<const TyTy::ReferenceType *> (ty);\n+\t    ty = rr->get_base ();\n+\t    break;\n+\t  }\n+      }\n+    return ty;\n+  }\n+\n+private:\n+  const TyTy::BaseType *base;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "0b4105324249558611dac8c33d477d77f6ea7626", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -56,7 +56,7 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "0c618d32e0161d0e7496ac17b309e86d79722a9e", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -119,9 +119,10 @@ class PathProbeType : public TypeCheckBase\n   static std::vector<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n-\t bool probe_bounds, bool ignore_mandatory_trait_items)\n+\t bool probe_bounds, bool ignore_mandatory_trait_items,\n+\t DefId specific_trait_id = UNKNOWN_DEFID)\n   {\n-    PathProbeType probe (receiver, segment_name);\n+    PathProbeType probe (receiver, segment_name, specific_trait_id);\n     if (probe_impls)\n       {\n \tif (receiver->get_kind () == TyTy::TypeKind::ADT)\n@@ -145,6 +146,13 @@ class PathProbeType : public TypeCheckBase\n \tfor (auto &candidate : probed_bounds)\n \t  {\n \t    const TraitReference *trait_ref = candidate.first;\n+\t    if (specific_trait_id != UNKNOWN_DEFID)\n+\t      {\n+\t\tif (trait_ref->get_mappings ().get_defid ()\n+\t\t    != specific_trait_id)\n+\t\t  continue;\n+\t      }\n+\n \t    HIR::ImplBlock *impl = candidate.second;\n \t    probe.process_associated_trait_for_candidates (\n \t      trait_ref, impl, ignore_mandatory_trait_items);\n@@ -154,6 +162,13 @@ class PathProbeType : public TypeCheckBase\n     for (const TyTy::TypeBoundPredicate &predicate :\n \t receiver->get_specified_bounds ())\n       {\n+\tconst TraitReference *trait_ref = predicate.get ();\n+\tif (specific_trait_id != UNKNOWN_DEFID)\n+\t  {\n+\t    if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t      continue;\n+\t  }\n+\n \tprobe.process_predicate_for_candidates (predicate,\n \t\t\t\t\t\tignore_mandatory_trait_items);\n       }\n@@ -221,6 +236,9 @@ class PathProbeType : public TypeCheckBase\n protected:\n   void process_enum_item_for_candiates (const TyTy::ADTType *adt)\n   {\n+    if (specific_trait_id != UNKNOWN_DEFID)\n+      return;\n+\n     TyTy::VariantDef *v;\n     if (!adt->lookup_variant (search.as_string (), &v))\n       return;\n@@ -385,9 +403,9 @@ class PathProbeType : public TypeCheckBase\n \n protected:\n   PathProbeType (const TyTy::BaseType *receiver,\n-\t\t const HIR::PathIdentSegment &query)\n+\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id)\n     : TypeCheckBase (), receiver (receiver), search (query),\n-      current_impl (nullptr)\n+      current_impl (nullptr), specific_trait_id (specific_trait_id)\n   {}\n \n   std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n@@ -427,6 +445,7 @@ class PathProbeType : public TypeCheckBase\n   const HIR::PathIdentSegment &search;\n   std::vector<PathProbeCandidate> candidates;\n   HIR::ImplBlock *current_impl;\n+  DefId specific_trait_id;\n };\n \n class ReportMultipleCandidateError : private TypeCheckBase\n@@ -507,7 +526,8 @@ class PathProbeImplTrait : public PathProbeType\n   PathProbeImplTrait (const TyTy::BaseType *receiver,\n \t\t      const HIR::PathIdentSegment &query,\n \t\t      const TraitReference *trait_reference)\n-    : PathProbeType (receiver, query), trait_reference (trait_reference)\n+    : PathProbeType (receiver, query, UNKNOWN_DEFID),\n+      trait_reference (trait_reference)\n   {}\n \n   const TraitReference *trait_reference;"}, {"sha": "b2deb91045f332bdc1817ccb385e4c4257db2ad4", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -116,7 +116,7 @@ TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n   // need to get the return type from this\n   TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (item_tyty);\n   auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-  context->push_return_type (expected_ret_tyty);\n+  context->push_return_type (TypeCheckContextItem (&func), expected_ret_tyty);\n \n   auto block_expr_ty\n     = TypeCheckExpr::Resolve (func.get_block_expr ().get (), false);"}, {"sha": "54591ce9fffe7dc873dd2f9cc9f2327e873581ac", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-trait-ref.h\"\n+#include \"rust-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -206,6 +207,31 @@ class TraitResolver : public TypeCheckBase\n     // loop of trying to resolve traits as required by the types\n     tref->on_resolved ();\n \n+    // does this have any lang-item attributes?\n+    for (auto &attr : trait_reference->get_outer_attrs ())\n+      {\n+\tbool is_lang_item = attr.get_path ().as_string ().compare (\"lang\") == 0\n+\t\t\t    && attr.has_attr_input ()\n+\t\t\t    && attr.get_attr_input ().get_attr_input_type ()\n+\t\t\t\t == AST::AttrInput::AttrInputType::LITERAL;\n+\tif (is_lang_item)\n+\t  {\n+\t    auto &literal\n+\t      = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+\t    const auto &lang_item_type_str\n+\t      = literal.get_literal ().as_string ();\n+\t    auto lang_item_type\n+\t      = Analysis::RustLangItem::Parse (lang_item_type_str);\n+\t    if (lang_item_type == Analysis::RustLangItem::ItemType::UNKNOWN)\n+\t      {\n+\t\trust_error_at (attr.get_locus (), \"unknown lang item\");\n+\t\treturn tref;\n+\t      }\n+\t    mappings->insert_lang_item (\n+\t      lang_item_type, trait_reference->get_mappings ().get_defid ());\n+\t  }\n+      }\n+\n     return tref;\n   }\n "}, {"sha": "52dea212170b94abe075dcbd2b97aa7557c4c271", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -58,7 +58,7 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "99696aec3fb3b15cf9e21a59548d98e80e531f09", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 249, "deletions": 7, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -470,6 +470,39 @@ class TypeCheckExpr : public TypeCheckBase\n       result->clone ());\n   }\n \n+  void visit (HIR::CompoundAssignmentExpr &expr) override\n+  {\n+    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get (), false);\n+\n+    // we dont care about the result of the unify from a compound assignment\n+    // since this is a unit-type expr\n+    auto result = lhs->unify (rhs);\n+    if (result->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    auto lang_item_type\n+      = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\texpr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+    if (operator_overloaded)\n+      return;\n+\n+    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+    bool valid = valid_lhs && valid_rhs;\n+    if (!valid)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"cannot apply this operator to types %s and %s\",\n+\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+\treturn;\n+      }\n+  }\n+\n   void visit (HIR::IdentifierExpr &expr) override\n   {\n     NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n@@ -699,6 +732,13 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n+    auto lang_item_type\n+      = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+    if (operator_overloaded)\n+      return;\n+\n     bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n     bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n     bool valid = valid_lhs && valid_rhs;\n@@ -711,8 +751,6 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     infered = lhs->unify (rhs);\n-    infered->append_reference (lhs->get_ref ());\n-    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::ComparisonExpr &expr) override\n@@ -736,24 +774,31 @@ class TypeCheckExpr : public TypeCheckBase\n     // we expect the lhs and rhs must be bools at this point\n     TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n     lhs = elhs.unify (lhs);\n-    if (lhs == nullptr || lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n     TyTy::BoolType rlhs (expr.get_mappings ().get_hirid ());\n     rhs = elhs.unify (rhs);\n-    if (lhs == nullptr || lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n     infered = lhs->unify (rhs);\n-    infered->append_reference (lhs->get_ref ());\n-    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::NegationExpr &expr) override\n   {\n     auto negated_expr_ty\n       = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n \n+    // check for operator overload\n+    auto lang_item_type = Analysis::RustLangItem::NegationOperatorToLangItem (\n+      expr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, negated_expr_ty,\n+\t\t\t\t   nullptr);\n+    if (operator_overloaded)\n+      return;\n+\n     // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n     switch (expr.get_expr_type ())\n       {\n@@ -1174,6 +1219,203 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = expr_to_convert->cast (tyty_to_convert_to);\n   }\n \n+protected:\n+  bool\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExpr &expr, TyTy::BaseType *lhs,\n+\t\t\t     TyTy::BaseType *rhs)\n+  {\n+    // in order to probe of the correct type paths we need the root type, which\n+    // strips any references\n+    const TyTy::BaseType *root = lhs->get_root ();\n+\n+    // look up lang item for arithmetic type\n+    std::vector<PathProbeCandidate> candidates;\n+    std::string associated_item_name\n+      = Analysis::RustLangItem::ToString (lang_item_type);\n+    DefId respective_lang_item_id = UNKNOWN_DEFID;\n+    bool lang_item_defined\n+      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+    // probe for the lang-item\n+    if (lang_item_defined)\n+      {\n+\tbool receiver_is_type_param\n+\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !receiver_is_generic;\n+\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n+\n+\tcandidates = PathProbeType::Probe (\n+\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+      }\n+\n+    // autoderef\n+    std::vector<Adjustment> adjustments;\n+    PathProbeCandidate *resolved_candidate\n+      = MethodResolution::Select (candidates, lhs, adjustments);\n+\n+    // is this the case we are recursive\n+    // handle the case where we are within the impl block for this lang_item\n+    // otherwise we end up with a recursive operator overload such as the i32\n+    // operator overload trait\n+    if (lang_item_defined && resolved_candidate != nullptr)\n+      {\n+\tTypeCheckContextItem &fn_context = context->peek_context ();\n+\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+\t  {\n+\t    auto &impl_item = fn_context.get_impl_item ();\n+\t    HIR::ImplBlock *parent = impl_item.first;\n+\t    HIR::Function *fn = impl_item.second;\n+\n+\t    if (parent->has_trait_ref ()\n+\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n+\t      {\n+\t\tTraitReference *trait_reference\n+\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t\tif (!trait_reference->is_error ())\n+\t\t  {\n+\t\t    TyTy::BaseType *lookup = nullptr;\n+\t\t    bool ok\n+\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t\t    rust_assert (ok);\n+\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t\t    rust_assert (fntype->is_method ());\n+\n+\t\t    Adjuster adj (lhs);\n+\t\t    TyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n+\n+\t\t    bool is_lang_item_impl\n+\t\t      = trait_reference->get_mappings ().get_defid ()\n+\t\t\t== respective_lang_item_id;\n+\t\t    bool self_is_lang_item_self\n+\t\t      = fntype->get_self_type ()->is_equal (*adjusted);\n+\t\t    bool recursive_operator_overload\n+\t\t      = is_lang_item_impl && self_is_lang_item_self;\n+\n+\t\t    lang_item_defined = !recursive_operator_overload;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n+    if (!lang_item_defined || !have_implementation_for_lang_item)\n+      {\n+\t// no operator overload exists for this\n+\treturn false;\n+      }\n+\n+    // now its just like a method-call-expr\n+    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+    // store the adjustments for code-generation to know what to do\n+    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\tstd::move (adjustments));\n+\n+    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate->is_impl_candidate ()\n+\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t      .get_nodeid ();\n+\n+    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::BaseType *lookup = lookup_tyty;\n+    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (fn->is_method ());\n+\n+    if (root->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+\tif (adt->has_substitutions () && fn->needs_substitution ())\n+\t  {\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ()->get_root ();\n+\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    const TyTy::ADTType *self_adt\n+\t      = static_cast<const TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // type check the arguments if required\n+    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+    if (rhs == nullptr)\n+      {\n+\trust_assert (type->num_params () == 1);\n+      }\n+    else\n+      {\n+\trust_assert (type->num_params () == 2);\n+\tauto fnparam = type->param_at (1);\n+\tfnparam.second->unify (rhs); // typecheck the rhs\n+      }\n+\n+    // get the return type\n+    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n+\n+    // store the expected fntype\n+    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n+\n+    // return the result of the function back\n+    infered = function_ret_tyty;\n+\n+    return true;\n+  }\n+\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),\n@@ -1253,7 +1495,7 @@ class TypeCheckExpr : public TypeCheckBase\n   Location root_array_expr_locus;\n \n   bool inside_loop;\n-};\n+}; // namespace Resolver\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "64853f5d013dc888276d27096ca125f39140538c", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -310,9 +310,10 @@ class TypeCheckImplItem : public TypeCheckBase\n public:\n   using Rust::Resolver::TypeCheckBase::visit;\n \n-  static void Resolve (HIR::ImplItem *item, TyTy::BaseType *self)\n+  static void Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n+\t\t       TyTy::BaseType *self)\n   {\n-    TypeCheckImplItem resolver (self);\n+    TypeCheckImplItem resolver (parent, self);\n     item->accept_vis (resolver);\n   }\n \n@@ -336,7 +337,8 @@ class TypeCheckImplItem : public TypeCheckBase\n     // need to get the return type from this\n     TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n     auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n+    context->push_return_type (TypeCheckContextItem (parent, &function),\n+\t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n@@ -346,8 +348,11 @@ class TypeCheckImplItem : public TypeCheckBase\n   }\n \n protected:\n-  TypeCheckImplItem (TyTy::BaseType *self) : TypeCheckBase (), self (self) {}\n+  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self)\n+    : TypeCheckBase (), parent (parent), self (self)\n+  {}\n \n+  HIR::ImplBlock *parent;\n   TyTy::BaseType *self;\n };\n \n@@ -357,11 +362,12 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n public:\n   static const TraitItemReference &\n-  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n+  Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n \t   TraitReference &trait_reference,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    TypeCheckImplItemWithTrait resolver (self, trait_reference, substitutions);\n+    TypeCheckImplItemWithTrait resolver (parent, self, trait_reference,\n+\t\t\t\t\t substitutions);\n     item->accept_vis (resolver);\n     return resolver.resolved_trait_item;\n   }\n@@ -514,9 +520,10 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n private:\n   TypeCheckImplItemWithTrait (\n-    TyTy::BaseType *self, TraitReference &trait_reference,\n+    HIR::ImplBlock *parent, TyTy::BaseType *self,\n+    TraitReference &trait_reference,\n     std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-    : TypeCheckImplItem (self), trait_reference (trait_reference),\n+    : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n       resolved_trait_item (TraitItemReference::error_node ()),\n       substitutions (substitutions)\n   {"}, {"sha": "cc102dff63877533e5600392442b3d3e11f0256d", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -118,11 +118,12 @@ class TypeCheckItem : public TypeCheckBase\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n \tif (!is_trait_impl_block)\n-\t  TypeCheckImplItem::Resolve (impl_item.get (), self);\n+\t  TypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n \telse\n \t  {\n \t    auto &trait_item_ref\n-\t      = TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n+\t      = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n+\t\t\t\t\t\t     impl_item.get (), self,\n \t\t\t\t\t\t     *trait_reference,\n \t\t\t\t\t\t     substitutions);\n \t    trait_item_refs.push_back (trait_item_ref);\n@@ -210,7 +211,8 @@ class TypeCheckItem : public TypeCheckBase\n     // need to get the return type from this\n     TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n     auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n+    context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);"}, {"sha": "fb0e04758212c2d40631ad5ca7fe8c03f4e8ad4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -424,7 +424,8 @@ class TypeCheckStmt : public TypeCheckBase\n \n     TyTy::FnType *resolved_fn_type = fnType;\n     auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n+    context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);"}, {"sha": "f078df6abd298c0d9c061190e96e104d48d40729", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -51,7 +51,7 @@ class SimpleHirVisitor : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "1add4faa59ae1aba9a1d8a2425d14e9a505329a2", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -28,6 +28,68 @@\n namespace Rust {\n namespace Resolver {\n \n+class TypeCheckContextItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ITEM,\n+    IMPL_ITEM,\n+    TRAIT_ITEM,\n+  };\n+\n+  TypeCheckContextItem (HIR::Function *item)\n+    : type (ItemType::ITEM), item (item)\n+  {}\n+\n+  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item)\n+    : type (ItemType::IMPL_ITEM), item (impl_block, item)\n+  {}\n+\n+  TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n+    : type (ItemType::TRAIT_ITEM), item (trait_item)\n+  {}\n+\n+  ItemType get_type () const { return type; }\n+\n+  HIR::Function *get_item ()\n+  {\n+    rust_assert (get_type () == ItemType::ITEM);\n+    return item.item;\n+  }\n+\n+  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ()\n+  {\n+    rust_assert (get_type () == ItemType::IMPL_ITEM);\n+    return item.impl_item;\n+  };\n+\n+  HIR::TraitItemFunc *get_trait_item ()\n+  {\n+    rust_assert (get_type () == ItemType::TRAIT_ITEM);\n+    return item.trait_item;\n+  }\n+\n+private:\n+  union Item\n+  {\n+    HIR::Function *item;\n+    std::pair<HIR::ImplBlock *, HIR::Function *> impl_item;\n+    HIR::TraitItemFunc *trait_item;\n+\n+    Item (HIR::Function *item) : item (item) {}\n+\n+    Item (HIR::ImplBlock *impl_block, HIR::Function *item)\n+      : impl_item ({impl_block, item})\n+    {}\n+\n+    Item (HIR::TraitItemFunc *trait_item) : trait_item (trait_item) {}\n+  };\n+\n+  ItemType type;\n+  Item item;\n+};\n+\n class TypeCheckContext\n {\n public:\n@@ -49,7 +111,9 @@ class TypeCheckContext\n   bool lookup_type_by_node_id (NodeId ref, HirId *id);\n \n   TyTy::BaseType *peek_return_type ();\n-  void push_return_type (TyTy::BaseType *return_type);\n+  TypeCheckContextItem &peek_context ();\n+  void push_return_type (TypeCheckContextItem item,\n+\t\t\t TyTy::BaseType *return_type);\n   void pop_return_type ();\n \n   void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n@@ -232,13 +296,32 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_operator_overload (HirId id, TyTy::FnType *call_site)\n+  {\n+    auto it = operator_overloads.find (id);\n+    rust_assert (it == operator_overloads.end ());\n+\n+    operator_overloads[id] = call_site;\n+  }\n+\n+  bool lookup_operator_overload (HirId id, TyTy::FnType **call)\n+  {\n+    auto it = operator_overloads.find (id);\n+    if (it == operator_overloads.end ())\n+      return false;\n+\n+    *call = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n   std::map<NodeId, HirId> node_id_refs;\n   std::map<HirId, TyTy::BaseType *> resolved;\n   std::vector<std::unique_ptr<TyTy::BaseType>> builtins;\n-  std::vector<TyTy::BaseType *> return_type_stack;\n+  std::vector<std::pair<TypeCheckContextItem, TyTy::BaseType *>>\n+    return_type_stack;\n   std::vector<TyTy::BaseType *> loop_type_stack;\n   std::map<DefId, TraitReference> trait_context;\n   std::map<HirId, TyTy::BaseType *> receiver_context;\n@@ -253,6 +336,9 @@ class TypeCheckContext\n   // adjustment mappings\n   std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n \n+  // operator overloads\n+  std::map<HirId, TyTy::FnType *> operator_overloads;\n+\n   // variants\n   std::map<HirId, HirId> variants;\n };"}, {"sha": "31f8ae571cbd63ce3492b422434e597cfebe684b", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -122,13 +122,14 @@ TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n TyTy::BaseType *\n TypeCheckContext::peek_return_type ()\n {\n-  return return_type_stack.back ();\n+  return return_type_stack.back ().second;\n }\n \n void\n-TypeCheckContext::push_return_type (TyTy::BaseType *return_type)\n+TypeCheckContext::push_return_type (TypeCheckContextItem item,\n+\t\t\t\t    TyTy::BaseType *return_type)\n {\n-  return_type_stack.push_back (return_type);\n+  return_type_stack.push_back ({std::move (item), return_type});\n }\n \n void\n@@ -137,5 +138,11 @@ TypeCheckContext::pop_return_type ()\n   return_type_stack.pop_back ();\n }\n \n+TypeCheckContextItem &\n+TypeCheckContext::peek_context ()\n+{\n+  return return_type_stack.back ().first;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "4f8c3899a338e0ee75ae6674fec4b305d67e5005", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 197, "deletions": 4, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -23,13 +23,185 @@\n #include \"rust-location.h\"\n #include \"rust-mapping-common.h\"\n #include \"rust-canonical-path.h\"\n-\n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n+#include \"operator.h\"\n \n namespace Rust {\n namespace Analysis {\n \n+// https://github.com/rust-lang/rust/blob/master/library/core/src/ops/arith.rs\n+class RustLangItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ADD,\n+    SUBTRACT,\n+    MULTIPLY,\n+    DIVIDE,\n+    REMAINDER,\n+\n+    NEGATION,\n+    NOT,\n+\n+    ADD_ASSIGN,\n+    SUB_ASSIGN,\n+    MUL_ASSIGN,\n+    DIV_ASSIGN,\n+    REM_ASSIGN,\n+\n+    UNKNOWN,\n+  };\n+\n+  static ItemType Parse (const std::string &item)\n+  {\n+    if (item.compare (\"add\") == 0)\n+      {\n+\treturn ItemType::ADD;\n+      }\n+    else if (item.compare (\"sub\") == 0)\n+      {\n+\treturn ItemType::SUBTRACT;\n+      }\n+    else if (item.compare (\"mul\") == 0)\n+      {\n+\treturn ItemType::MULTIPLY;\n+      }\n+    else if (item.compare (\"div\") == 0)\n+      {\n+\treturn ItemType::DIVIDE;\n+      }\n+    else if (item.compare (\"rem\") == 0)\n+      {\n+\treturn ItemType::REMAINDER;\n+      }\n+    else if (item.compare (\"neg\") == 0)\n+      {\n+\treturn ItemType::NEGATION;\n+      }\n+    else if (item.compare (\"not\") == 0)\n+      {\n+\treturn ItemType::NOT;\n+      }\n+    else if (item.compare (\"add_assign\") == 0)\n+      {\n+\treturn ItemType::ADD_ASSIGN;\n+      }\n+    else if (item.compare (\"sub_assign\") == 0)\n+      {\n+\treturn ItemType::SUB_ASSIGN;\n+      }\n+    else if (item.compare (\"mul_assign\") == 0)\n+      {\n+\treturn ItemType::MUL_ASSIGN;\n+      }\n+    else if (item.compare (\"div_assign\") == 0)\n+      {\n+\treturn ItemType::DIV_ASSIGN;\n+      }\n+    else if (item.compare (\"rem_assign\") == 0)\n+      {\n+\treturn ItemType::REM_ASSIGN;\n+      }\n+\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static std::string ToString (ItemType type)\n+  {\n+    switch (type)\n+      {\n+      case ADD:\n+\treturn \"add\";\n+      case SUBTRACT:\n+\treturn \"sub\";\n+      case MULTIPLY:\n+\treturn \"mul\";\n+      case DIVIDE:\n+\treturn \"div\";\n+      case REMAINDER:\n+\treturn \"rem\";\n+      case NEGATION:\n+\treturn \"neg\";\n+      case NOT:\n+\treturn \"not\";\n+      case ADD_ASSIGN:\n+\treturn \"add_assign\";\n+      case SUB_ASSIGN:\n+\treturn \"sub_assign\";\n+      case MUL_ASSIGN:\n+\treturn \"mul_assign\";\n+      case DIV_ASSIGN:\n+\treturn \"div_assign\";\n+      case REM_ASSIGN:\n+\treturn \"rem_assign\";\n+\n+      case UNKNOWN:\n+\tbreak;\n+      }\n+    return \"<UNKNOWN>\";\n+  }\n+\n+  static ItemType OperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUBTRACT;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MULTIPLY;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIVIDE;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REMAINDER;\n+\n+      default:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType\n+  CompoundAssignmentOperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD_ASSIGN;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUB_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MUL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIV_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REM_ASSIGN;\n+\n+      default:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType NegationOperatorToLangItem (NegationOperator op)\n+  {\n+    switch (op)\n+      {\n+      case NegationOperator::NEGATE:\n+\treturn ItemType::NEGATION;\n+      case NegationOperator::NOT:\n+\treturn ItemType::NOT;\n+\n+      default:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+};\n+\n class NodeMapping\n {\n public:\n@@ -237,9 +409,9 @@ class Mappings\n     const Resolver::CanonicalPath *p = nullptr;\n     if (lookup_canonical_path (crate, id, &p))\n       {\n-\t// if we have already stored a canonical path this is ok so long as this\n-\t// new path is equal or is smaller that the existing one but in that\n-\t// case we ignore it.\n+\t// if we have already stored a canonical path this is ok so long as\n+\t// this new path is equal or is smaller that the existing one but in\n+\t// that case we ignore it.\n \tif (p->is_equal (path))\n \t  return;\n \telse\n@@ -267,6 +439,24 @@ class Mappings\n     return true;\n   }\n \n+  void insert_lang_item (RustLangItem::ItemType item_type, DefId id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    rust_assert (it == lang_item_mappings.end ());\n+\n+    lang_item_mappings[item_type] = id;\n+  }\n+\n+  bool lookup_lang_item (RustLangItem::ItemType item_type, DefId *id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    if (it == lang_item_mappings.end ())\n+      return false;\n+\n+    *id = it->second;\n+    return true;\n+  }\n+\n private:\n   Mappings ();\n \n@@ -304,6 +494,9 @@ class Mappings\n     hirGenericParamMappings;\n   std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n \n+  // this maps the lang=<item_type> to DefId mappings\n+  std::map<RustLangItem::ItemType, DefId> lang_item_mappings;\n+\n   // canonical paths\n   std::map<CrateNum, std::map<NodeId, const Resolver::CanonicalPath> > paths;\n "}, {"sha": "e52b3947980bb77c7b646741c246a12068cc5b40", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_1.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, other: i32) -> i32 {\n+        let res = self + other;\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = 1 + 2;\n+\n+    0\n+}"}, {"sha": "9d5615d13814d882d04493145447adaf0a9dc8a0", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_2.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Foo(i32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        let res = Foo(self.0 + other.0);\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res.0);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}, {"sha": "bd99b50a4fd567cd2e7028a231520791952b4c19", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_3.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-output \"3\\n3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, other: i32) -> i32 {\n+        let res = self + other;\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res);\n+        }\n+\n+        res\n+    }\n+}\n+\n+struct Foo(i32);\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        let res = Foo(self.0 + other.0);\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res.0);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}, {"sha": "eca19de309ad139fdf48daa11cd6d9dd94299203", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_4.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_4.rs?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-output \"neg\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"neg\"]\n+pub trait Neg {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn neg(self) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Neg::neg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl Neg for i32 {\n+    type Output = i32;\n+\n+    fn neg(self) -> i32 {\n+        unsafe {\n+            let a = \"neg\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+        -self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a: i32 = 1;\n+    let _b = -a;\n+\n+    0\n+}"}, {"sha": "ffdc8c23280429b160ced272373dd93136ee75ea", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_5.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_5.rs?ref=5514d9cec51d5ec7cc30dd6cdbfadfdddbe0aab3", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-output \"not\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"not\"]\n+pub trait Not {\n+    type Output;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn not(self) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Not::not.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl Not for i32 {\n+    type Output = i32;\n+\n+    fn not(self) -> i32 {\n+        unsafe {\n+            let a = \"not\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+        !self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a: i32 = 1;\n+    let _b = !a;\n+\n+    0\n+}"}]}