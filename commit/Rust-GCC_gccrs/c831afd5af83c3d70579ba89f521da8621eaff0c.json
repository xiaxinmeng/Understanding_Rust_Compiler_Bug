{"sha": "c831afd5af83c3d70579ba89f521da8621eaff0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgzMWFmZDVhZjgzYzNkNzA1NzliYTg5ZjUyMWRhODYyMWVhZmYwYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-14T21:27:16Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-14T21:27:16Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r488", "tree": {"sha": "b7bd08d4cbf677cca649d944ece81498f4f9e69c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7bd08d4cbf677cca649d944ece81498f4f9e69c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c831afd5af83c3d70579ba89f521da8621eaff0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c831afd5af83c3d70579ba89f521da8621eaff0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c831afd5af83c3d70579ba89f521da8621eaff0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c831afd5af83c3d70579ba89f521da8621eaff0c/comments", "author": null, "committer": null, "parents": [{"sha": "3cfd4ab5097a922295f14f75cef931f03d0a7a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfd4ab5097a922295f14f75cef931f03d0a7a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cfd4ab5097a922295f14f75cef931f03d0a7a07"}], "stats": {"total": 157, "additions": 51, "deletions": 106}, "files": [{"sha": "0a199e8720cb7cc06957eabab352a4256c2498f2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 51, "deletions": 106, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c831afd5af83c3d70579ba89f521da8621eaff0c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c831afd5af83c3d70579ba89f521da8621eaff0c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c831afd5af83c3d70579ba89f521da8621eaff0c", "patch": "@@ -86,6 +86,7 @@ extern rtx gen_cmpsi ();\n extern rtx gen_jump ();\n \n extern char   call_used_regs[];\n+extern char  *asm_file_name;\n extern FILE  *asm_out_file;\n extern tree   current_function_decl;\n extern char **save_argv;\n@@ -118,9 +119,6 @@ int sym_lineno = 0;\n    handle .files inside of functions.  */\n int inside_function = 0;\n \n-/* Global half-pic flag.  */\n-int flag_half_pic;\n-\n /* Files to separate the text and the data output, so that all of the data\n    can be emitted before the text, which will mean that the assembler will\n    generate smaller code, based on the global pointer.  */\n@@ -147,7 +145,7 @@ char *current_function_file = \"\";\n    within a function.  */\n int file_in_function_warning = FALSE;\n \n-/* Whether to supress issuing .loc's because the user attempted\n+/* Whether to suppress issuing .loc's because the user attempted\n    to change the filename within a function.  */\n int ignore_line_number = FALSE;\n \n@@ -208,6 +206,10 @@ struct mips_frame_info current_frame_info;\n /* Zero structure to initialize current_frame_info.  */\n struct mips_frame_info zero_frame_info;\n \n+/* Temporary filename used to buffer .text until end of program\n+   for -mgpopt.  */\n+static char *temp_filename;\n+\n /* List of all MIPS punctuation characters used by print_operand.  */\n char mips_print_operand_punct[256];\n \n@@ -517,7 +519,6 @@ simple_memory_operand (op, mode)\n      enum machine_mode mode;\n {\n   rtx addr, plus0, plus1;\n-  int offset = 0;\n \n   /* Eliminate non-memory operations */\n   if (GET_CODE (op) != MEM)\n@@ -568,17 +569,19 @@ simple_memory_operand (op, mode)\n       if (mips_section_threshold == 0 || !optimize || !TARGET_GP_OPT)\n \treturn FALSE;\n \n-      addr = eliminate_constant_term (addr, &offset);\n-      if (GET_CODE (op) != SYMBOL_REF)\n-\treturn FALSE;\n+      {\n+\trtx offset = const0_rtx;\n+\taddr = eliminate_constant_term (addr, &offset);\n+\tif (GET_CODE (op) != SYMBOL_REF)\n+\t  return FALSE;\n \n+\t/* let's be paranoid.... */\n+\tif (INTVAL (offset) < 0 || INTVAL (offset) > 0xffff)\n+\t  return FALSE;\n+      }\n       /* fall through */\n \n     case SYMBOL_REF:\n-      /* let's be paranoid.... */\n-      if (offset < 0 || offset > 0xffff)\n-\treturn FALSE;\n-\n       return SYMBOL_REF_FLAG (addr);\n #endif\n     }\n@@ -772,7 +775,7 @@ mips_fill_delay_slot (ret, type, operands, cur_insn)\n \n \f\n /* Determine whether a memory reference takes one (based off of the GP pointer),\n-   two (normal), or three (label + reg) instructins, and bump the appropriate\n+   two (normal), or three (label + reg) instructions, and bump the appropriate\n    counter for -mstats.  */\n \n void\n@@ -1068,7 +1071,7 @@ mips_move_1word (operands, insn, unsignedp)\n \t  if (TARGET_STATS)\n \t    mips_count_memory_refs (op1, 1);\n \n-\t  if (flag_half_pic && !mips_constant_address_p (op1))\n+\t  if (HALF_PIC_P () && CONSTANT_P (op1) && HALF_PIC_ADDRESS_P (op1))\n \t    {\n \t      delay = DELAY_LOAD;\n \t      ret = \"la\\t%0,%a1\\t\\t# pic reference\";\n@@ -1390,14 +1393,12 @@ mips_move_2words (operands, insn)\n \n \f\n /* Provide the costs of an addressing mode that contains ADDR.\n-   If ADDR is not a valid address, its cost is irrelavent.  */\n+   If ADDR is not a valid address, its cost is irrelevant.  */\n \n int\n mips_address_cost (addr)\n      rtx addr;\n {\n-  int offset;\n-\n   switch (GET_CODE (addr))\n     {\n     case LO_SUM:\n@@ -1408,17 +1409,18 @@ mips_address_cost (addr)\n       return 2;\n \n     case CONST:\n-      offset = 0;\n-      addr = eliminate_constant_term (addr, &offset);\n-      if (GET_CODE (addr) == LABEL_REF)\n-\treturn 2;\n-\n-      if (GET_CODE (addr) != SYMBOL_REF)\n-\treturn 4;\n+      {\n+\trtx offset = const0_rtx;\n+\taddr = eliminate_constant_term (addr, &offset);\n+\tif (GET_CODE (addr) == LABEL_REF)\n+\t  return 2;\n \n-      if (offset < -32768 || offset > 32767)\n-\treturn 2;\n+\tif (GET_CODE (addr) != SYMBOL_REF)\n+\t  return 4;\n \n+\tif (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\n+\t  return 2;\n+      }\n       /* fall through */\n \n     case SYMBOL_REF:\n@@ -1459,59 +1461,6 @@ mips_address_cost (addr)\n   return 4;\n }\n \n-\f\n-/* A C expression that is 1 if the RTX ADDR is a constant which is a\n-   valid address.  On most machines, this can be defined as\n-   `CONSTANT_P (ADDR)', but a few machines are more restrictive in\n-   which constant addresses are supported.\n-\n-   `CONSTANT_P' accepts integer-values expressions whose values are\n-   not explicitly known, such as `symbol_ref', `label_ref', and\n-   `high' expressions and `const' arithmetic expressions, in\n-   addition to `const_int' and `const_double' expressions.  */\n-\n-int\n-mips_constant_address_p (addr)\n-     rtx addr;\n-{\n-  int offset;\n-  char *name;\n-\n-  if (!CONSTANT_P (addr))\n-    return FALSE;\n-\n-  /* For -mpic-extern, don't allow any reference to an external in\n-     normal code.  Force it to be PIC-ized.  */\n-\n-  if (flag_half_pic)\n-    {\n-      switch (GET_CODE (addr))\n-\t{\n-\tcase CONST:\n-\t  addr = eliminate_constant_term (addr, &offset);\n-\t  if (GET_CODE (addr) != SYMBOL_REF)\n-\t    return FALSE;\n-\n-\t  /* fall through */\n-\n-\tcase SYMBOL_REF:\n-\t  name = XSTR (addr, 0);\n-\n-\t  /* Skip '*' that appears in front of labels and such.  */\n-\t  if (name[0] == '*')\n-\t    name++;\n-\n-\t  /* Internally generated labels are not pic.  */\n-\t  if (name[0] == '$' && name[1] == 'L')\n-\t    return TRUE;\n-\n-\t  return FALSE;\n-\t}\n-    }\n-\n-  return TRUE;\n-}\n-\n \f\n /* Emit the common code for doing conditional branches.\n    operand[0] is the label to jump to.\n@@ -1683,7 +1632,7 @@ block_move_load_store (dest_reg, src_reg, p_bytes, p_offset, align)\n   enum machine_mode mode;\t/* mode to use for load/store */\n   rtx reg;\t\t\t/* temporary register */\n   rtx src_addr;\t\t\t/* source address */\n-  rtx dest_addr;\t\t/* destintation address */\n+  rtx dest_addr;\t\t/* destination address */\n   rtx (*load_func)();\t\t/* function to generate load insn */\n   rtx (*store_func)();\t\t/* function to generate destination insn */\n \n@@ -1918,8 +1867,8 @@ expand_block_move (operands)\n     return;\n \n   /* Move the address into scratch registers.  */\n-  dest_reg = copy_to_reg (XEXP (operands[0], 0));\n-  src_reg  = copy_to_reg (XEXP (operands[1], 0));\n+  dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));\n+  src_reg  = copy_addr_to_reg (XEXP (operands[1], 0));\n \n   if (TARGET_MEMCPY)\n     block_move_call (dest_reg, src_reg, bytes_rtx);\n@@ -2437,7 +2386,7 @@ override_options ()\n \n   /* Tell halfpic.c that we have half-pic code if we do.  */\n   if (TARGET_HALF_PIC)\n-    flag_half_pic = TRUE;\n+    HALF_PIC_INIT ();\n \n   /* -mrnames says to use the MIPS software convention for register\n      names instead of the hardware names (ie, a0 instead of $4).\n@@ -2468,7 +2417,7 @@ override_options ()\n     }\n #endif\n \n-  /* Set up the classificaiton arrays now.  */\n+  /* Set up the classification arrays now.  */\n   mips_rtx_classify[(int)PLUS]  = CLASS_ADD_OP;\n   mips_rtx_classify[(int)MINUS] = CLASS_ADD_OP;\n   mips_rtx_classify[(int)DIV]   = CLASS_DIVMOD_OP;\n@@ -2528,7 +2477,7 @@ override_options ()\n      At present, restrict ints from being in FP registers, because reload\n      is a little enthusiastic about storing extra values in FP registers,\n      and this is not good for things like OS kernels.  Also, due to the\n-     manditory delay, it is as fast to load from cached memory as to move\n+     mandatory delay, it is as fast to load from cached memory as to move\n      from the FP register.  */\n \n   for (mode = VOIDmode;\n@@ -2576,16 +2525,20 @@ mips_debugger_offset (addr, offset)\n      rtx addr;\n      int offset;\n {\n-  int offset2 = 0;\n+  rtx offset2 = const0_rtx;\n   rtx reg = eliminate_constant_term (addr, &offset2);\n \n   if (!offset)\n-    offset = offset2;\n+    offset = INTVAL (offset2);\n \n   if (reg == stack_pointer_rtx)\n-    offset = offset - ((!current_frame_info.initialized)\n-\t\t       ? compute_frame_size (get_frame_size ())\n-\t\t       : current_frame_info.total_size);\n+    {\n+      int frame_size = (!current_frame_info.initialized)\n+\t\t\t\t? compute_frame_size (get_frame_size ())\n+\t\t\t\t: current_frame_info.total_size;\n+\n+      offset = offset - frame_size;\n+    }\n \n   /* Any other register is, we hope, either the frame pointer,\n      or a pseudo equivalent to the frame pointer.  (Assign_parms\n@@ -2976,7 +2929,6 @@ mips_output_external (file, decl, name)\n static FILE *\n make_temp_file ()\n {\n-  char *temp_filename;\n   FILE *stream;\n   char *base = getenv (\"TMPDIR\");\n   int len;\n@@ -3159,9 +3111,11 @@ mips_asm_file_end (file)\n       for (p = extern_head; p != 0; p = p->next)\n \t{\n \t  name_tree = get_identifier (p->name);\n-\t  if (!TREE_ADDRESSABLE (name_tree))\n+\n+\t  /* Positively ensure only one .extern for any given symbol.  */\n+\t  if (! TREE_ASM_WRITTEN (name_tree))\n \t    {\n-\t      TREE_ADDRESSABLE (name_tree) = 1;\n+\t      TREE_ASM_WRITTEN (name_tree) = 1;\n \t      fputs (\"\\t.extern\\t\", file);\n \t      assemble_name (file, p->name);\n \t      fprintf (file, \", %d\\n\", p->size);\n@@ -3171,17 +3125,17 @@ mips_asm_file_end (file)\n       fprintf (file, \"\\n\\t.text\\n\");\n       rewind (asm_out_text_file);\n       if (ferror (asm_out_text_file))\n-\tfatal_io_error (\"write of text assembly file in mips_asm_file_end\");\n+\tfatal_io_error (temp_filename);\n \n       while ((len = fread (buffer, 1, sizeof (buffer), asm_out_text_file)) > 0)\n \tif (fwrite (buffer, 1, len, file) != len)\n-\t  pfatal_with_name (\"write of final assembly file in mips_asm_file_end\");\n+\t  pfatal_with_name (asm_file_name);\n \n       if (len < 0)\n-\tpfatal_with_name (\"read of text assembly file in mips_asm_file_end\");\n+\tpfatal_with_name (temp_filename);\n \n       if (fclose (asm_out_text_file) != 0)\n-\tpfatal_with_name (\"close of tempfile in mips_asm_file_end\");\n+\tpfatal_with_name (temp_filename);\n     }\n }\n \n@@ -3841,12 +3795,3 @@ null_epilogue ()\n \n   return (compute_frame_size (get_frame_size ())) == 0;\n }\n-\n-\f\n-/* Encode in a declaration whether or not it is half-pic.  */\n-\n-void\n-half_pic_encode_section_info (decl)\n-     tree decl;\n-{\n-}"}]}