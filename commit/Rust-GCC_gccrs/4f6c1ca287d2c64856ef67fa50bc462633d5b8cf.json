{"sha": "4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY2YzFjYTI4N2QyYzY0ODU2ZWY2N2ZhNTBiYzQ2MjYzM2Q1YjhjZg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-01T20:18:19Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-01T20:37:57Z"}, "message": "c++: Missing SFINAE with inaccessible static data member [PR90880]\n\nThis is a missing SFINAE issue when verifying the accessibility of a\nstatic data member.\n\nThe cause is that check_accessibility_of_qualified_id unconditionally\npasses tf_warning_or_error to perform_or_defer_access_check, even when\ncalled from tsubst_qualified_id(..., complain=tf_none).\n\nThis patch fixes this by plumbing 'complain' from tsubst_qualified_id\nthrough check_accessibility_of_qualified_id to reach\nperform_or_defer_access_check, and by giving\ncheck_accessibility_of_qualified_id the appropriate return value.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/90880\n\t* cp-tree.h (check_accessibility_of_qualified_id): Add\n\ttsubst_flags_t parameter and change return type to bool.\n\t* parser.c (cp_parser_lookup_name): Pass tf_warning_to_error to\n\tcheck_accessibility_of_qualified_id.\n\t* pt.c (tsubst_qualified_id): Return error_mark_node if\n\tcheck_accessibility_of_qualified_id returns false.\n\t* semantics.c (check_accessibility_of_qualified_id): Add\n\tcomplain parameter.  Pass complain instead of\n\ttf_warning_or_error to perform_or_defer_access_check.  Return\n\ttrue unless perform_or_defer_access_check returns false.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/90880\n\t* g++.dg/template/sfinae29.C: New test.", "tree": {"sha": "24cfe5a8dd12327815e4d4e7566b6e0b7d2dcd9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24cfe5a8dd12327815e4d4e7566b6e0b7d2dcd9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/comments", "author": null, "committer": null, "parents": [{"sha": "30da2906ac521749aef8260fc1d942e62073f19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30da2906ac521749aef8260fc1d942e62073f19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30da2906ac521749aef8260fc1d942e62073f19d"}], "stats": {"total": 72, "additions": 61, "deletions": 11}, "files": [{"sha": "5f2db010cb2b1b2f47a772dc3317a49e59dd86a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -1,3 +1,17 @@\n+2020-05-01  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/90880\n+\t* cp-tree.h (check_accessibility_of_qualified_id): Add\n+\ttsubst_flags_t parameter and change return type to bool.\n+\t* parser.c (cp_parser_lookup_name): Pass tf_warning_to_error to\n+\tcheck_accessibility_of_qualified_id.\n+\t* pt.c (tsubst_qualified_id): Return error_mark_node if\n+\tcheck_accessibility_of_qualified_id returns false.\n+\t* semantics.c (check_accessibility_of_qualified_id): Add\n+\tcomplain parameter.  Pass complain instead of\n+\ttf_warning_or_error to perform_or_defer_access_check.  Return\n+\ttrue unless perform_or_defer_access_check returns false.\n+\n 2020-05-01  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94885"}, {"sha": "c4b81428e143c69c647483098da7e53b165a5fc7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -7258,7 +7258,7 @@ extern bool expand_or_defer_fn_1\t\t(tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n extern void add_typedef_to_current_template_for_access_check (tree, tree,\n \t\t\t\t\t\t\t      location_t);\n-extern void check_accessibility_of_qualified_id (tree, tree, tree);\n+extern bool check_accessibility_of_qualified_id (tree, tree, tree, tsubst_flags_t);\n extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t bool, bool, tsubst_flags_t);\n extern void simplify_aggr_init_expr\t\t(tree *);"}, {"sha": "337f22d2784074f3d03cc99e8fc9ade8d7693f39", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -28394,7 +28394,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n      During an explicit instantiation, access is not checked at all,\n      as per [temp.explicit].  */\n   if (DECL_P (decl))\n-    check_accessibility_of_qualified_id (decl, object_type, parser->scope);\n+    check_accessibility_of_qualified_id (decl, object_type, parser->scope,\n+\t\t\t\t\t tf_warning_or_error);\n \n   maybe_record_typedef_use (decl);\n "}, {"sha": "8106c25a2d98e599906f01671055c3a7af6fc772", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -16180,8 +16180,9 @@ tsubst_qualified_id (tree qualified_id, tree args,\n \n   if (DECL_P (expr))\n     {\n-      check_accessibility_of_qualified_id (expr, /*object_type=*/NULL_TREE,\n-\t\t\t\t\t   scope);\n+      if (!check_accessibility_of_qualified_id (expr, /*object_type=*/NULL_TREE,\n+\t\t\t\t\t\tscope, complain))\n+\treturn error_mark_node;\n       /* Remember that there was a reference to this entity.  */\n       if (!mark_used (expr, complain) && !(complain & tf_error))\n \treturn error_mark_node;"}, {"sha": "4d1592ab0d2f3960b298941e7318aece4789411d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -2028,12 +2028,14 @@ add_typedef_to_current_template_for_access_check (tree typedef_decl,\n    an error message if it is not accessible.  If OBJECT_TYPE is\n    non-NULL, we have just seen `x->' or `x.' and OBJECT_TYPE is the\n    type of `*x', or `x', respectively.  If the DECL was named as\n-   `A::B' then NESTED_NAME_SPECIFIER is `A'.  */\n+   `A::B' then NESTED_NAME_SPECIFIER is `A'.  Return value is like\n+   perform_access_checks above.  */\n \n-void\n+bool\n check_accessibility_of_qualified_id (tree decl,\n \t\t\t\t     tree object_type,\n-\t\t\t\t     tree nested_name_specifier)\n+\t\t\t\t     tree nested_name_specifier,\n+\t\t\t\t     tsubst_flags_t complain)\n {\n   tree scope;\n   tree qualifying_type = NULL_TREE;\n@@ -2050,13 +2052,13 @@ check_accessibility_of_qualified_id (tree decl,\n \n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)\n-    return;\n+    return true;\n \n   /* Determine the SCOPE of DECL.  */\n   scope = context_for_name_lookup (decl);\n   /* If the SCOPE is not a type, then DECL is not a member.  */\n   if (!TYPE_P (scope))\n-    return;\n+    return true;\n   /* Compute the scope through which DECL is being accessed.  */\n   if (object_type\n       /* OBJECT_TYPE might not be a class type; consider:\n@@ -2097,8 +2099,10 @@ check_accessibility_of_qualified_id (tree decl,\n \t or similar in a default argument value.  */\n       && CLASS_TYPE_P (qualifying_type)\n       && !dependent_type_p (qualifying_type))\n-    perform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl,\n-\t\t\t\t   decl, tf_warning_or_error);\n+    return perform_or_defer_access_check (TYPE_BINFO (qualifying_type), decl,\n+\t\t\t\t\t  decl, complain);\n+\n+  return true;\n }\n \n /* EXPR is the result of a qualified-id.  The QUALIFYING_CLASS was the"}, {"sha": "176aa117904b3e27cc73454630d73b2cf1cd2798", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -1,3 +1,8 @@\n+2020-05-01  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/90880\n+\t* g++.dg/template/sfinae29.C: New test.\n+\n 2020-05-01  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94885"}, {"sha": "0ccaea8593d9d578a0287cd5ee293328f269da8d", "filename": "gcc/testsuite/g++.dg/template/sfinae29.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c1ca287d2c64856ef67fa50bc462633d5b8cf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae29.C?ref=4f6c1ca287d2c64856ef67fa50bc462633d5b8cf", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/90880\n+// { dg-do compile { target c++11 } }\n+\n+template <typename T, typename = void>\n+struct status\n+{ static const bool value = false; };\n+\n+template <typename T>\n+struct status<T, decltype((void)T::member)>\n+{ static const bool value = true; };\n+\n+struct s1{int member;};\n+struct s2{int _member;};\n+\n+class c1{int member;};\n+class c2{int _member;};\n+\n+void\n+foo()\n+{\n+  static_assert(status<s1>::value, \"has member\");\n+  static_assert(!status<s2>::value, \"has no member\");\n+  static_assert(!status<c1>::value, \"has inaccessible member\");\n+  static_assert(!status<c2>::value, \"has no member\");\n+}"}]}