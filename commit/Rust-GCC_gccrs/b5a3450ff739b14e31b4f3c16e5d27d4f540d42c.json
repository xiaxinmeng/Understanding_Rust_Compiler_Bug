{"sha": "b5a3450ff739b14e31b4f3c16e5d27d4f540d42c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVhMzQ1MGZmNzM5YjE0ZTMxYjRmM2MxNmU1ZDI3ZDRmNTQwZDQyYw==", "commit": {"author": {"name": "Richard Frith-Macdonald", "email": "rfm@gnu.org", "date": "2011-05-25T18:54:40Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-05-25T18:54:40Z"}, "message": "In libobjc/: 2011-05-25 Richard Frith-Macdonald <rfm@gnu.org> David Ayers <ayers@fsfe.org>\n\nIn libobjc/:\n2011-05-25  Richard Frith-Macdonald <rfm@gnu.org>\n\t    David Ayers  <ayers@fsfe.org>\n\n\tPR libobjc/38037\n\t* sendmsg.c: Include objc/hash.h.\n\t(get_implementation): New function, mostly with code from get_imp\n\tupdated to support the new +initialize dispatch table logic.\n\t(get_imp): Use get_implementation.\n\t(__objc_responds_to): Updated to support the new +initialize\n\tdispatch table logic.\n\t(class_respondsToSelector): Likewise.\n\t(objc_msg_lookup): Use get_implementation.\n\t(__objc_init_install_dtable): Removed.\n\t(__objc_install_methods_in_dtable): Updated arguments.\n\t(__objc_install_dispatch_table_for_class): Renamed to\n\t__objc_install_dtable_for_class and updated to support the new\n\t+initialize dispatch table logic.\n\t(__objc_update_dispatch_table_for_class): Updated to support the\n\tnew +initialize dispatch table logic.\n\t(__objc_forward): Call get_implementation instead of get_imp.\n\t(prepared_dtable_table): New.\n\t(__objc_prepare_dtable_for_class): New.\t\n\t(__objc_prepared_dtable_for_class): New.\n\t(__objc_get_prepared_imp): New.\n\t(__objc_install_prepared_dtable_for_class): New.\n\nCo-Authored-By: David Ayers <ayers@fsfe.org>\n\nFrom-SVN: r174221", "tree": {"sha": "d5003b409f0b36b5352537e57004be8d3bde3e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5003b409f0b36b5352537e57004be8d3bde3e2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c/comments", "author": {"login": "rfm", "id": 4929621, "node_id": "MDQ6VXNlcjQ5Mjk2MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/4929621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rfm", "html_url": "https://github.com/rfm", "followers_url": "https://api.github.com/users/rfm/followers", "following_url": "https://api.github.com/users/rfm/following{/other_user}", "gists_url": "https://api.github.com/users/rfm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rfm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rfm/subscriptions", "organizations_url": "https://api.github.com/users/rfm/orgs", "repos_url": "https://api.github.com/users/rfm/repos", "events_url": "https://api.github.com/users/rfm/events{/privacy}", "received_events_url": "https://api.github.com/users/rfm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "deaf34a90b437dc0e1e461c9ad36014491df5080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deaf34a90b437dc0e1e461c9ad36014491df5080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deaf34a90b437dc0e1e461c9ad36014491df5080"}], "stats": {"total": 617, "additions": 412, "deletions": 205}, "files": [{"sha": "865af33c6779f28d0f81570043b13f0b19f9fff6", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=b5a3450ff739b14e31b4f3c16e5d27d4f540d42c", "patch": "@@ -1,3 +1,29 @@\n+2011-05-25  Richard Frith-Macdonald <rfm@gnu.org>\n+\t    David Ayers  <ayers@fsfe.org>\n+\n+\tPR libobjc/38037\n+\t* sendmsg.c: Include objc/hash.h.\n+\t(get_implementation): New function, mostly with code from get_imp\n+\tupdated to support the new +initialize dispatch table logic.\n+\t(get_imp): Use get_implementation.\n+\t(__objc_responds_to): Updated to support the new +initialize\n+\tdispatch table logic.\n+\t(class_respondsToSelector): Likewise.\n+\t(objc_msg_lookup): Use get_implementation.\n+\t(__objc_init_install_dtable): Removed.\n+\t(__objc_install_methods_in_dtable): Updated arguments.\n+\t(__objc_install_dispatch_table_for_class): Renamed to\n+\t__objc_install_dtable_for_class and updated to support the new\n+\t+initialize dispatch table logic.\n+\t(__objc_update_dispatch_table_for_class): Updated to support the\n+\tnew +initialize dispatch table logic.\n+\t(__objc_forward): Call get_implementation instead of get_imp.\n+\t(prepared_dtable_table): New.\n+\t(__objc_prepare_dtable_for_class): New.\t\n+\t(__objc_prepared_dtable_for_class): New.\n+\t(__objc_get_prepared_imp): New.\n+\t(__objc_install_prepared_dtable_for_class): New.\n+\t\n 2011-05-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR libobjc/48177"}, {"sha": "c11a791cef0b62a8afc7f15c9e155fc441297009", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 386, "deletions": 205, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a3450ff739b14e31b4f3c16e5d27d4f540d42c/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=b5a3450ff739b14e31b4f3c16e5d27d4f540d42c", "patch": "@@ -41,6 +41,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc/thr.h\"\n #include \"objc-private/module-abi-8.h\"\n #include \"objc-private/runtime.h\"\n+#include \"objc-private/hash.h\"\n #include \"objc-private/sarray.h\"\n #include \"objc-private/selector.h\" /* For sel_is_mapped() */\n #include \"runtime-info.h\"\n@@ -75,10 +76,14 @@ IMP (*__objc_msg_forward2) (id, SEL) = NULL;\n /* Send +initialize to class.  */\n static void __objc_send_initialize (Class);\n \n-static void __objc_install_dispatch_table_for_class (Class);\n+/* Forward declare some functions */\n+static void __objc_install_dtable_for_class (Class cls);\n+static void __objc_prepare_dtable_for_class (Class cls);\n+static void __objc_install_prepared_dtable_for_class (Class cls);\n \n-/* Forward declare some functions.  */\n-static void __objc_init_install_dtable (id, SEL);\n+static struct sarray *__objc_prepared_dtable_for_class (Class cls);\n+static IMP __objc_get_prepared_imp (Class cls,SEL sel);\n+  \n \n /* Various forwarding functions that are used based upon the\n    return type for the selector.\n@@ -117,7 +122,7 @@ __objc_get_forward_imp (id rcv, SEL sel)\n     {\n       IMP result;\n       if ((result = __objc_msg_forward (sel)) != NULL) \n-        return result;\n+\treturn result;\n     }\n \n   /* In all other cases, use the default forwarding functions built\n@@ -210,7 +215,7 @@ __objc_resolve_instance_method (Class class, SEL sel)\n \t{\n \t  objc_mutex_lock (__objc_runtime_mutex);\n \t  if (class->class_pointer->dtable == __objc_uninstalled_dtable)\n-\t    __objc_install_dispatch_table_for_class (class->class_pointer);\n+\t    __objc_install_dtable_for_class (class->class_pointer);\n \t  objc_mutex_unlock (__objc_runtime_mutex);\n \t}\n       resolveMethodIMP = sarray_get_safe (class->class_pointer->dtable,\n@@ -231,8 +236,94 @@ __objc_resolve_instance_method (Class class, SEL sel)\n   return NULL;\n }\n \n-/* Given a class and selector, return the selector's\n-   implementation.  */\n+/* Given a CLASS and selector, return the implementation corresponding\n+   to the method of the selector.\n+\n+   If CLASS is a class, the instance method is returned.\n+   If CLASS is a meta class, the class method is returned.\n+\n+   Since this requires the dispatch table to be installed, this function\n+   will implicitly invoke +initialize for CLASS if it hasn't been\n+   invoked yet.  This also insures that +initialize has been invoked\n+   when the returned implementation is called directly.\n+\n+   The forwarding hooks require the receiver as an argument (if they are to\n+   perform dynamic lookup in proxy objects etc), so this function has a\n+   receiver argument to be used with those hooks.  */\n+static inline\n+IMP\n+get_implementation (id receiver, Class class, SEL sel)\n+{\n+  void *res;\n+\n+  if (class->dtable == __objc_uninstalled_dtable)\n+    {\n+      /* The dispatch table needs to be installed.  */\n+      objc_mutex_lock (__objc_runtime_mutex);\n+\n+      /* Double-checked locking pattern: Check\n+\t __objc_uninstalled_dtable again in case another thread\n+\t installed the dtable while we were waiting for the lock\n+\t to be released.  */\n+      if (class->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  __objc_install_dtable_for_class (class);\n+\t}\n+\n+      /* If the dispatch table is not yet installed,\n+\twe are still in the process of executing +initialize.\n+\tBut the implementation pointer should be available\n+\tin the prepared ispatch table if it exists at all.  */\n+      if (class->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  assert (__objc_prepared_dtable_for_class (class) != 0);\n+\t  res = __objc_get_prepared_imp (class, sel);\n+\t}\n+      else\n+\t{\n+\t  res = 0;\n+\t}\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+      /* Call ourselves with the installed dispatch table and get\n+\t the real method.  */\n+      if (!res)\n+\tres = get_implementation (receiver, class, sel);\n+    }\n+  else\n+    {\n+      /* The dispatch table has been installed.  */\n+      res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n+      if (res == 0)\n+\t{\n+\t  /* The dispatch table has been installed, and the method\n+\t     is not in the dispatch table.  So the method just\n+\t     doesn't exist for the class.  */\n+\n+\t  /* Try going through the +resolveClassMethod: or\n+\t     +resolveInstanceMethod: process.  */\n+\t  if (CLS_ISMETA (class))\n+\t    {\n+\t      /* We have the meta class, but we need to invoke the\n+\t\t +resolveClassMethod: method on the class.  So, we\n+\t\t need to obtain the class from the meta class,\n+\t\t which we do using the fact that both the class\n+\t\t and the meta-class have the same name.  */\n+\t      Class realClass = objc_lookUpClass (class->name);\n+\t      if (realClass)\n+\t\tres = __objc_resolve_class_method (realClass, sel);\n+\t    }\n+\t  else\n+\t    res = __objc_resolve_instance_method (class, sel);\n+\n+\t  if (res == 0)\n+\t    {\n+\t      res = __objc_get_forward_imp (receiver, sel);\n+\t    }\n+\t}\n+    }\n+  return res;\n+}\n+\n inline\n IMP\n get_imp (Class class, SEL sel)\n@@ -248,70 +339,7 @@ get_imp (Class class, SEL sel)\n   void *res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n   if (res == 0)\n     {\n-      /* Not a valid method.  */\n-      if (class->dtable == __objc_uninstalled_dtable)\n-\t{\n-\t  /* The dispatch table needs to be installed.  */\n-\t  objc_mutex_lock (__objc_runtime_mutex);\n-\n-\t   /* Double-checked locking pattern: Check\n-\t      __objc_uninstalled_dtable again in case another thread\n-\t      installed the dtable while we were waiting for the lock\n-\t      to be released.  */\n-         if (class->dtable == __objc_uninstalled_dtable)\n-           {\n-             __objc_install_dispatch_table_for_class (class);\n-           }\n-\n-\t  objc_mutex_unlock (__objc_runtime_mutex);\n-\t  /* Call ourselves with the installed dispatch table and get\n-\t     the real method.  */\n-\t  res = get_imp (class, sel);\n-\t}\n-      else\n-\t{\n-\t  /* The dispatch table has been installed.  */\n-\n-         /* Get the method from the dispatch table (we try to get it\n-\t    again in case another thread has installed the dtable just\n-\t    after we invoked sarray_get_safe, but before we checked\n-\t    class->dtable == __objc_uninstalled_dtable).  */\n-\t  res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n-\t  if (res == 0)\n-\t    {\n-\t      /* The dispatch table has been installed, and the method\n-\t\t is not in the dispatch table.  So the method just\n-\t\t doesn't exist for the class.  */\n-\n-\t      /* Try going through the +resolveClassMethod: or\n-\t\t +resolveInstanceMethod: process.  */\n-\t      if (CLS_ISMETA (class))\n-\t\t{\n-\t\t  /* We have the meta class, but we need to invoke the\n-\t\t     +resolveClassMethod: method on the class.  So, we\n-\t\t     need to obtain the class from the meta class,\n-\t\t     which we do using the fact that both the class\n-\t\t     and the meta-class have the same name.  */\n-\t\t  Class realClass = objc_lookUpClass (class->name);\n-\t\t  if (realClass)\n-\t\t    res = __objc_resolve_class_method (realClass, sel);\n-\t\t}\n-\t      else\n-\t\tres = __objc_resolve_instance_method (class, sel);\n-\n-\t      if (res == 0)\n-\t\t{\n-\t\t  /* If that fails, then return the forwarding\n-\t\t     implementation.  We don't know the receiver (only\n-\t\t     its class), so we have to pass 'nil' as the first\n-\t\t     argument.  Passing the class as first argument is\n-\t\t     wrong because the class is not the receiver; it\n-\t\t     can result in us calling a class method when we\n-\t\t     want an instance method of the same name.  */\n-\t\t  res = __objc_get_forward_imp (nil, sel);\n-\t\t}\n-\t    }\n-\t}\n+      res = get_implementation(nil, class, sel);\n     }\n   return res;\n }\n@@ -337,51 +365,78 @@ method_get_imp (struct objc_method * method)\n \n /* Query if an object can respond to a selector, returns YES if the\n    object implements the selector otherwise NO.  Does not check if the\n-   method can be forwarded.  */\n+   method can be forwarded.\n+   Since this requires the dispatch table to installed, this function\n+   will implicitly invoke +initialize for the class of OBJECT if it\n+   hasn't been invoked yet.  */\n inline\n BOOL\n __objc_responds_to (id object, SEL sel)\n {\n   void *res;\n+  struct sarray *dtable;\n \n-  /* Install dispatch table if need be.  */\n-  if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n+  /* Install dispatch table if need be */\n+  dtable = object->class_pointer->dtable;\n+  if (dtable == __objc_uninstalled_dtable)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n       if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n-\t{\n-\t  __objc_install_dispatch_table_for_class (object->class_pointer);\n-\t}\n+        __objc_install_dtable_for_class (object->class_pointer);\n+\n+      /* If the dispatch table is not yet installed,\n+         we are still in the process of executing +initialize.\n+         Yet the dispatch table should be available.  */\n+      if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n+        {\n+          dtable = __objc_prepared_dtable_for_class (object->class_pointer);\n+          assert (dtable);\n+        }\n+      else\n+        dtable = object->class_pointer->dtable;\n+\n       objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n   /* Get the method from the dispatch table.  */\n-  res = sarray_get_safe (object->class_pointer->dtable, (size_t) sel->sel_id);\n-  return (res != 0);\n+  res = sarray_get_safe (dtable, (size_t) sel->sel_id);\n+  return (res != 0) ? YES : NO;\n }\n \n BOOL\n class_respondsToSelector (Class class_, SEL selector)\n {\n+  struct sarray *dtable;\n   void *res;\n \n   if (class_ == Nil  ||  selector == NULL)\n     return NO;\n \n   /* Install dispatch table if need be.  */\n-  if (class_->dtable == __objc_uninstalled_dtable)\n+  dtable = class_->dtable;\n+  if (dtable == __objc_uninstalled_dtable)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n       if (class_->dtable == __objc_uninstalled_dtable)\n \t{\n-\t  __objc_install_dispatch_table_for_class (class_);\n+\t  __objc_install_dtable_for_class (class_);\n \t}\n+      /* If the dispatch table is not yet installed,\n+         we are still in the process of executing +initialize.\n+         Yet the dispatch table should be available.  */\n+      if (class_->dtable == __objc_uninstalled_dtable)\n+        {\n+          dtable = __objc_prepared_dtable_for_class (class_);\n+          assert (dtable);\n+        }\n+      else\n+        dtable = class_->dtable;\n       objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n   /* Get the method from the dispatch table.  */\n-  res = sarray_get_safe (class_->dtable, (size_t) selector->sel_id);\n-  return (res != 0);\n+  res = sarray_get_safe (dtable, (size_t) selector->sel_id);\n+  return (res != 0) ? YES : NO;\n }\n \n /* This is the lookup function.  All entries in the table are either a\n@@ -394,48 +449,15 @@ objc_msg_lookup (id receiver, SEL op)\n   IMP result;\n   if (receiver)\n     {\n+      /* First try a quick lookup assuming the dispatch table exists.  */\n       result = sarray_get_safe (receiver->class_pointer->dtable, \n \t\t\t\t(sidx)op->sel_id);\n       if (result == 0)\n \t{\n-\t  /* Not a valid method.  */\n-\t  if (receiver->class_pointer->dtable == __objc_uninstalled_dtable)\n-\t    {\n-\t      /* The dispatch table needs to be installed.  This\n-\t\t happens on the very first method call to the\n-\t\t class.  */\n-\t      __objc_init_install_dtable (receiver, op);\n-\n-\t      /* Get real method for this in newly installed\n-\t\t dtable.  */\n-\t      result = get_imp (receiver->class_pointer, op);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The dispatch table has been installed.  Check again\n-\t\t if the method exists (just in case the dispatch table\n-\t\t has been installed by another thread after we did the\n-\t\t previous check that the method exists).  */\n-\t      result = sarray_get_safe (receiver->class_pointer->dtable,\n-\t\t\t\t\t(sidx)op->sel_id);\n-\t      if (result == 0)\n-\t\t{\n-\t\t  /* Try going through the +resolveClassMethod: or\n-\t\t     +resolveInstanceMethod: process.  */\n-\t\t  if (CLS_ISMETA (receiver->class_pointer))\n-\t\t    result = __objc_resolve_class_method ((Class)receiver, op);\n-\t\t  else\n-\t\t    result = __objc_resolve_instance_method (receiver->class_pointer,\n-\t\t\t\t\t\t\t     op);\n-\n-\t\t  if (result == 0)\n-\t\t    {\n-\t\t      /* If the method still just doesn't exist for\n-\t\t\t the class, attempt to forward the method.  */\n-\t\t      result = __objc_get_forward_imp (receiver, op);\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  /* Not found ... call get_implementation () to install the dispatch\n+             table and call +initialize as required, providing the method\n+\t     implementation or a forwarding function */\n+\t  result = get_implementation (receiver, receiver->class_pointer, op);\n \t}\n       return result;\n     }\n@@ -485,47 +507,6 @@ __objc_init_dispatch_tables ()\n   selector_resolveInstanceMethod  =sel_registerName (\"resolveInstanceMethod:\");\n }\n \n-/* This function is called by objc_msg_lookup when the dispatch table\n-   needs to be installed; thus it is called once for each class,\n-   namely when the very first message is sent to it.  */\n-static void\n-__objc_init_install_dtable (id receiver, SEL op __attribute__ ((__unused__)))\n-{\n-  objc_mutex_lock (__objc_runtime_mutex);\n-  \n-  /* This may happen, if the programmer has taken the address of a\n-     method before the dtable was initialized... too bad for him!  */\n-  if (receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n-    {\n-      objc_mutex_unlock (__objc_runtime_mutex);\n-      return;\n-    }\n-  \n-  if (CLS_ISCLASS (receiver->class_pointer))\n-    {\n-      /* receiver is an ordinary object.  */\n-      assert (CLS_ISCLASS (receiver->class_pointer));\n-\n-      /* Install instance methods table.  */\n-      __objc_install_dispatch_table_for_class (receiver->class_pointer);\n-\n-      /* Call +initialize -- this will in turn install the factory\n-\t dispatch table if not already done. :-)  */\n-      __objc_send_initialize (receiver->class_pointer);\n-    }\n-  else\n-    {\n-      /* receiver is a class object.  */\n-      assert (CLS_ISCLASS ((Class)receiver));\n-      assert (CLS_ISMETA (receiver->class_pointer));\n-\n-      /* Install real dtable for factory methods.  */\n-      __objc_install_dispatch_table_for_class (receiver->class_pointer);\n-\n-      __objc_send_initialize ((Class)receiver);\n-    }\n-  objc_mutex_unlock (__objc_runtime_mutex);\n-}\n \n /* Install dummy table for class which causes the first message to\n    that class (or instances hereof) to be initialized properly.  */\n@@ -544,6 +525,9 @@ __objc_send_initialize (Class class)\n   assert (CLS_ISCLASS (class));\n   assert (! CLS_ISMETA (class));\n \n+  /* class_add_method_list/__objc_update_dispatch_table_for_class\n+     may have reset the dispatch table.  The canonical way to insure\n+     that we send +initialize just once, is this flag.  */\n   if (! CLS_ISINITIALIZED (class))\n     {\n       DEBUG_PRINTF (\"+initialize: need to initialize class '%s'\\n\", class->name);\n@@ -606,76 +590,54 @@ __objc_send_initialize (Class class)\n    guaranteed about what method will be used.  Assumes that\n    __objc_runtime_mutex is locked down.  */\n static void\n-__objc_install_methods_in_dtable (Class class, struct objc_method_list * method_list)\n+__objc_install_methods_in_dtable (struct sarray *dtable, struct objc_method_list * method_list)\n {\n   int i;\n   \n   if (! method_list)\n     return;\n   \n   if (method_list->method_next)\n-    __objc_install_methods_in_dtable (class, method_list->method_next);\n+    __objc_install_methods_in_dtable (dtable, method_list->method_next);\n   \n   for (i = 0; i < method_list->method_count; i++)\n     {\n       struct objc_method * method = &(method_list->method_list[i]);\n-      sarray_at_put_safe (class->dtable,\n+      sarray_at_put_safe (dtable,\n \t\t\t  (sidx) method->method_name->sel_id,\n \t\t\t  method->method_imp);\n     }\n }\n \n-/* Assumes that __objc_runtime_mutex is locked down.  */\n-static void\n-__objc_install_dispatch_table_for_class (Class class)\n-{\n-  Class super;\n-\n-  /* If the class has not yet had its class links resolved, we must\n-     re-compute all class links.  */\n-  if (! CLS_ISRESOLV (class))\n-    __objc_resolve_class_links ();\n-\n-  DEBUG_PRINTF (\"__objc_install_dispatch_table_for_class (%s)\\n\", class->name);\n-  \n-  super = class->super_class;\n-\n-  if (super != 0 && (super->dtable == __objc_uninstalled_dtable))\n-    __objc_install_dispatch_table_for_class (super);\n-\n-  /* Allocate dtable if necessary.  */\n-  if (super == 0)\n-    {\n-      objc_mutex_lock (__objc_runtime_mutex);\n-      class->dtable = sarray_new (__objc_selector_max_index, 0);\n-      objc_mutex_unlock (__objc_runtime_mutex);\n-    }\n-  else\n-    class->dtable = sarray_lazy_copy (super->dtable);\n-\n-  __objc_install_methods_in_dtable (class, class->methods);\n-}\n-\n void\n __objc_update_dispatch_table_for_class (Class class)\n {\n   Class next;\n   struct sarray *arr;\n \n-  /* Not yet installed -- skip it.  */\n-  if (class->dtable == __objc_uninstalled_dtable) \n-    return;\n-\n-  DEBUG_PRINTF (\" _objc_update_dispatch_table_for_class (%s)\\n\", class->name);\n+  DEBUG_PRINTF (\" _objc_update_dtable_for_class (%s)\\n\", class->name);\n \n   objc_mutex_lock (__objc_runtime_mutex);\n \n+  /* not yet installed -- skip it unless in +initialize */\n+  if (class->dtable == __objc_uninstalled_dtable) \n+    {\n+      if (__objc_prepared_dtable_for_class (class))\n+\t{\n+\t  /* There is a prepared table so we must be initialising this\n+\t     class ... we must re-do the table preparation. */\n+\t  __objc_prepare_dtable_for_class (class);\n+\t}\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+      return;\n+    }\n+\n   arr = class->dtable;\n   __objc_install_premature_dtable (class); /* someone might require it... */\n   sarray_free (arr);\t\t\t   /* release memory */\n   \n   /* Could have been lazy...  */\n-  __objc_install_dispatch_table_for_class (class); \n+  __objc_install_dtable_for_class (class); \n \n   if (class->subclass_list)\t/* Traverse subclasses.  */\n     for (next = class->subclass_list; next; next = next->sibling_class)\n@@ -995,7 +957,7 @@ __objc_forward (id object, SEL sel, arglist_t args)\n \n   if (__objc_responds_to (object, frwd_sel))\n     {\n-      imp = get_imp (object->class_pointer, frwd_sel);\n+      imp = get_implementation (object, object->class_pointer, frwd_sel);\n       return (*imp) (object, frwd_sel, sel, args);\n     }\n \n@@ -1004,7 +966,7 @@ __objc_forward (id object, SEL sel, arglist_t args)\n   err_sel = sel_get_any_uid (\"doesNotRecognize:\");\n   if (__objc_responds_to (object, err_sel))\n     {\n-      imp = get_imp (object->class_pointer, err_sel);\n+      imp = get_implementation (object, object->class_pointer, err_sel);\n       return (*imp) (object, err_sel, sel);\n     }\n   \n@@ -1024,7 +986,7 @@ __objc_forward (id object, SEL sel, arglist_t args)\n     err_sel = sel_get_any_uid (\"error:\");\n     if (__objc_responds_to (object, err_sel))\n       {\n-\timp = get_imp (object->class_pointer, err_sel);\n+\timp = get_implementation (object, object->class_pointer, err_sel);\n \treturn (*imp) (object, sel_get_any_uid (\"error:\"), msg);\n       }\n \n@@ -1074,3 +1036,222 @@ objc_get_uninstalled_dtable (void)\n {\n   return __objc_uninstalled_dtable;\n }\n+\n+static cache_ptr prepared_dtable_table = 0;\n+\n+/* This function is called by:\n+   objc_msg_lookup, get_imp and __objc_responds_to\n+   (and the dispatch table installation functions themselves)\n+   to install a dispatch table for a class.\n+\n+   If CLS is a class, it installs instance methods.\n+   If CLS is a meta class, it installs class methods.\n+\n+   In either case +initialize is invoked for the corresponding class.\n+\n+   The implementation must insure that the dispatch table is not\n+   installed until +initialize completes.  Otherwise it opens a\n+   potential race since the installation of the dispatch table is\n+   used as gate in regular method dispatch and we need to guarantee\n+   that +initialize is the first method invoked an that no other\n+   thread my dispatch messages to the class before +initialize\n+   completes.\n+ */\n+static void\n+__objc_install_dtable_for_class (Class cls)\n+{\n+  /* If the class has not yet had its class links resolved, we must \n+     re-compute all class links */\n+  if (! CLS_ISRESOLV (cls))\n+    __objc_resolve_class_links ();\n+\n+  /* Make sure the super class has its dispatch table installed\n+     or is at least preparing.\n+     We do not need to send initialize for the super class since\n+     __objc_send_initialize will insure that.\n+   */\n+  if (cls->super_class\n+    && cls->super_class->dtable == __objc_uninstalled_dtable\n+    && !__objc_prepared_dtable_for_class (cls->super_class))\n+    {\n+      __objc_install_dtable_for_class (cls->super_class);\n+      /* The superclass initialisation may have also initialised the\n+         current class, in which case there is no more to do. */\n+      if (cls->dtable != __objc_uninstalled_dtable)\n+\t{\n+\t  return;\n+\t}\n+    }\n+\n+  /* We have already been prepared but +initialize hasn't completed.\n+     The +initialize implementation is probably sending 'self' messages.\n+     We rely on _objc_get_prepared_imp to retrieve the implementation\n+     pointers.  */\n+  if (__objc_prepared_dtable_for_class (cls))\n+    {\n+      return;\n+    }\n+\n+  /* We have this function cache the implementation pointers\n+     for _objc_get_prepared_imp but the dispatch table won't\n+     be initilized until __objc_send_initialize completes.  */\n+  __objc_prepare_dtable_for_class (cls);\n+\n+  /* We may have already invoked +initialize but \n+     __objc_update_dispatch_table_for_class  invoked by\n+     class_add_method_list may have reset dispatch table.  */\n+\n+  /* Call +initialize.\n+     If we are a real class, we are installing instance methods.\n+     If we are a meta class, we are installing class methods.\n+     The __objc_send_initialize itself will insure that the message\n+     is called only once per class.  */\n+  if (CLS_ISCLASS (cls))\n+    __objc_send_initialize (cls);\n+  else\n+    {\n+      /* Retreive the class from the meta class.  */\n+      Class c = objc_lookup_class (cls->name);\n+      assert (CLS_ISMETA (cls));\n+      assert (c);\n+      __objc_send_initialize (c);\n+    }\n+\n+  /* We install the dispatch table correctly when +initialize completed.  */\n+  __objc_install_prepared_dtable_for_class (cls);\n+}\n+\n+/* Builds the dispatch table for the class CLS and stores\n+   it in a place where it can be retrieved by\n+   __objc_get_prepared_imp until __objc_install_prepared_dtable_for_class\n+   installs it into the class.\n+   The dispatch table should not be installed into the class until\n+   +initialize has completed.  */\n+static void\n+__objc_prepare_dtable_for_class (Class cls)\n+{\n+  struct sarray *dtable;\n+  struct sarray *super_dtable;\n+\n+  /* This table could be initialized in init.c. \n+     We can not use the class name since\n+     the class maintains the instance methods and\n+     the meta class maintains the the class methods yet\n+     both share the same name.  \n+     Classes should be unique in any program.  */\n+  if (! prepared_dtable_table)\n+    prepared_dtable_table \n+      = objc_hash_new(32,\n+\t\t      (hash_func_type) objc_hash_ptr,\n+\t\t      (compare_func_type) objc_compare_ptrs);\n+\n+  /* If the class has not yet had its class links resolved, we must \n+     re-compute all class links */\n+  if (! CLS_ISRESOLV (cls))\n+    __objc_resolve_class_links ();\n+\n+  assert (cls);\n+  assert (cls->dtable == __objc_uninstalled_dtable);\n+\n+  /* If there is already a prepared dtable for this class, we must replace\n+     it with a new version (since there must have been methods added to or\n+     otherwise modified in the class while executing +initialize, and the\n+     table needs to be recomputed.  */\n+  dtable = __objc_prepared_dtable_for_class (cls);\n+  if (0 != dtable)\n+    {\n+      objc_hash_remove (prepared_dtable_table, cls);\n+      sarray_free (dtable);\n+    }\n+\n+  /* Now prepare the dtable for population.  */\n+  assert (cls != cls->super_class);\n+  if (cls->super_class)\n+    {\n+      /* Inherit the method list from the super class.\n+         Yet the super class may still be initializing\n+\t in the case when a class cluster sub class initializes\n+\t its super classes.  */\n+      if (cls->super_class->dtable == __objc_uninstalled_dtable)\n+\t__objc_install_dtable_for_class (cls->super_class);\n+\n+      super_dtable = cls->super_class->dtable;\n+      /* If the dispatch table is not yet installed,\n+\t we are still in the process of executing +initialize.\n+\t Yet the dispatch table should be available.  */\n+      if (super_dtable == __objc_uninstalled_dtable)\n+\tsuper_dtable = __objc_prepared_dtable_for_class (cls->super_class);\n+\n+      assert (super_dtable);\n+      dtable = sarray_lazy_copy (super_dtable);\n+    }\n+  else\n+    dtable = sarray_new (__objc_selector_max_index, 0);\n+\n+  __objc_install_methods_in_dtable (dtable, cls->methods);\n+\n+  objc_hash_add (&prepared_dtable_table,\n+\t\t cls,\n+\t\t dtable);\n+}\n+\n+/* This wrapper only exists to allow an easy replacement of\n+   the lookup implementation and it is expected that the compiler\n+   will optimize it away.  */\n+static struct sarray *\n+__objc_prepared_dtable_for_class (Class cls)\n+{\n+  struct sarray *dtable = 0;\n+  assert (cls);\n+  if (prepared_dtable_table)\n+    dtable = objc_hash_value_for_key (prepared_dtable_table, cls);\n+  /* dtable my be nil, \n+     since we call this to check whether we are currently preparing\n+     before we start preparing.  */\n+  return dtable;\n+}\n+\n+/* Helper function for messages sent to CLS or implementation pointers\n+   retrieved from CLS during +initialize before the dtable is installed.\n+   When a class implicitly initializes another class which in turn\n+   implicitly invokes methods in this class, before the implementation of\n+   +initialize of CLS completes, this returns the expected implementation.\n+   Forwarding remains the responsibility of objc_msg_lookup.\n+   This function should only be called under the global lock.\n+ */\n+static IMP\n+__objc_get_prepared_imp (Class cls,SEL sel)\n+{\n+  struct sarray *dtable;\n+  IMP imp;\n+\n+  assert (cls);\n+  assert (sel);\n+  assert (cls->dtable == __objc_uninstalled_dtable);\n+  dtable = __objc_prepared_dtable_for_class (cls);\n+\n+  assert (dtable);\n+  assert (dtable != __objc_uninstalled_dtable);\n+  imp = sarray_get_safe (dtable, (size_t) sel->sel_id);\n+\n+  /* imp may be Nil if the method does not exist and we\n+     may fallback to the forwarding implementation later.  */\n+  return imp;  \n+}\n+\n+/* When this function is called +initialize should be completed.\n+   So now we are safe to install the dispatch table for the\n+   class so that they become available for other threads\n+   that may be waiting in the lock.\n+ */\n+static void\n+__objc_install_prepared_dtable_for_class (Class cls)\n+{\n+  assert (cls);\n+  assert (cls->dtable == __objc_uninstalled_dtable);\n+  cls->dtable = __objc_prepared_dtable_for_class (cls);\n+\n+  assert (cls->dtable);\n+  assert (cls->dtable != __objc_uninstalled_dtable);\n+  objc_hash_remove (prepared_dtable_table, cls);\n+}"}]}