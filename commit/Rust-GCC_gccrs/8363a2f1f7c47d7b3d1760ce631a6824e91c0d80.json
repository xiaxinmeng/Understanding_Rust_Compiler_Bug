{"sha": "8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM2M2EyZjFmN2M0N2Q3YjNkMTc2MGNlNjMxYTY4MjRlOTFjMGQ4MA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2019-05-08T11:37:45Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2019-05-08T11:37:45Z"}, "message": "re PR tree-optimization/90078 (ICE with deep templates caused by overflow)\n\n\tPR tree-optimization/90078\n\t* tree-ssa-loop-ivopts.c (INFTY): Increase value for infinite cost.\n\t(struct comp_cost): Promote type of members to int64_t.\n\t(infinite_cost): Don't set complexity in initialization.\n\t(comp_cost::operator +,-,+=,-+,/=,*=): Assert when cost computation\n\toverflows to infinite_cost.\n\t(adjust_setup_cost): Promote type of parameter and cost computation\n\tto int64_t.\n\t(struct ainc_cost_data, struct iv_ca): Promote type of member to\n\tint64_t.\n\t(get_scaled_computation_cost_at, determine_iv_cost): Promote type of\n\tcost computation to int64_t.\n\t(determine_group_iv_costs, iv_ca_dump, find_optimal_iv_set): Use\n\tint64_t's format specifier in dump.\n\n\tgcc/testsuite\n\t* g++.dg/tree-ssa/pr90078.C: New test.\n\nFrom-SVN: r271008", "tree": {"sha": "d461e0f136c5998e3bd723cd0f6ac69f29170b61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d461e0f136c5998e3bd723cd0f6ac69f29170b61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/comments", "author": null, "committer": null, "parents": [{"sha": "98d8f142132ac670da2dc99cce530048343ab948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d8f142132ac670da2dc99cce530048343ab948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d8f142132ac670da2dc99cce530048343ab948"}], "stats": {"total": 278, "additions": 253, "deletions": 25}, "files": [{"sha": "08b37f27d45b0173219a7b24102b9adb4340c755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "patch": "@@ -1,3 +1,21 @@\n+2019-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90078\n+\t* tree-ssa-loop-ivopts.c (inttypes.h): Include new header file.\n+\t(INFTY): Increase the value for infinite cost.\n+\t(struct comp_cost): Promote type of members to int64_t.\n+\t(infinite_cost): Don't set complexity in initialization.\n+\t(comp_cost::operator +,-,+=,-+,/=,*=): Assert when cost computation\n+\toverflows to infinite_cost.\n+\t(adjust_setup_cost): Promote type of parameter and cost computation\n+\tto int64_t.\n+\t(struct ainc_cost_data, struct iv_ca): Promote type of member to\n+\tint64_t.\n+\t(get_scaled_computation_cost_at, determine_iv_cost): Promote type of\n+\tcost computation to int64_t.\n+\t(determine_group_iv_costs, iv_ca_dump, find_optimal_iv_set): Use\n+\tint64_t's format specifier in dump.\n+\n 2019-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n \n \tPR tree-optimization/90240"}, {"sha": "3042f825ff81825015a164db5dd6ca96e3c938f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "patch": "@@ -1,3 +1,8 @@\n+2018-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\tPR tree-optimization/90078\n+\t* g++.dg/tree-ssa/pr90078.C: New test.\n+\n 2018-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n \n \tPR tree-optimization/90240"}, {"sha": "e36f50e9d8aaed5e02634457fbb2fbbe8ea03e80", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr90078.C", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90078.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90078.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90078.C?ref=8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "patch": "@@ -0,0 +1,199 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++14 -O2 -ftemplate-depth=1000000\" }\n+\n+template <class T, int Dim0, int Dim1, int Dim2> struct Tensor3;\n+template <class A, class T, int Dim0, int Dim1, int Dim2, char i, char j,\n+          char k>\n+struct Tensor3_Expr;\n+\n+template <class T, int Dim0, int Dim1, int Dim2, int Dim3> struct Tensor4;\n+template <class A, class T, int Dim0, int Dim1, int Dim2, int Dim3, char i,\n+          char j, char k, char l>\n+struct Tensor4_Expr;\n+\n+template <char i, int Dim> struct Index\n+{};\n+template <const int N> struct Number\n+{\n+  Number(){};\n+  operator int() const { return N; }\n+};\n+\n+template <class T, int Tensor_Dim0, int Tensor_Dim1, int Tensor_Dim2>\n+struct Tensor3\n+{\n+  T data[Tensor_Dim0][Tensor_Dim1][Tensor_Dim2];\n+\n+  T operator()(const int N1, const int N2, const int N3) const\n+  {\n+    return data[N1][N2][N3];\n+  }\n+\n+  template <char i, char j, char k, int Dim0, int Dim1, int Dim2>\n+  Tensor3_Expr<const Tensor3<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2>, T,\n+               Dim0, Dim1, Dim2, i, j, k>\n+  operator()(const Index<i, Dim0>, const Index<j, Dim1>,\n+             const Index<k, Dim2>) const\n+  {\n+    return Tensor3_Expr<const Tensor3<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2>,\n+                        T, Dim0, Dim1, Dim2, i, j, k>(*this);\n+  }\n+};\n+\n+template <class A, class T, int Dim0, int Dim1, int Dim2, char i, char j,\n+          char k>\n+struct Tensor3_Expr\n+{\n+  A iter;\n+\n+  Tensor3_Expr(const A &a) : iter(a) {}\n+  T operator()(const int N1, const int N2, const int N3) const\n+  {\n+    return iter(N1, N2, N3);\n+  }\n+};\n+\n+template <class A, class T, int Tensor_Dim0, int Tensor_Dim1, int Tensor_Dim2,\n+          int Dim0, int Dim1, int Dim2, char i, char j, char k>\n+struct Tensor3_Expr<Tensor3<A, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2>, T, Dim0,\n+                   Dim1, Dim2, i, j, k>\n+{\n+  Tensor3<A, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2> &iter;\n+\n+  Tensor3_Expr(Tensor3<A, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2> &a) : iter(a)\n+  {}\n+  T operator()(const int N1, const int N2, const int N3) const\n+  {\n+    return iter(N1, N2, N3);\n+  }\n+};\n+\n+template <class A, class B, class T, class U, int Dim0, int Dim1, int Dim23,\n+          int Dim4, int Dim5, char i, char j, char k, char l, char m>\n+struct Tensor3_times_Tensor3_21\n+{\n+  Tensor3_Expr<A, T, Dim0, Dim1, Dim23, i, j, k> iterA;\n+  Tensor3_Expr<B, U, Dim23, Dim4, Dim5, k, l, m> iterB;\n+\n+  template <int CurrentDim>\n+  T eval(const int N1, const int N2, const int N3, const int N4,\n+         const Number<CurrentDim> &) const\n+  {\n+    return iterA(N1, N2, CurrentDim - 1) * iterB(CurrentDim - 1, N3, N4)\n+           + eval(N1, N2, N3, N4, Number<CurrentDim - 1>());\n+  }\n+  T eval(const int N1, const int N2, const int N3, const int N4,\n+         const Number<1> &) const\n+  {\n+    return iterA(N1, N2, 0) * iterB(0, N3, N4);\n+  }\n+\n+  Tensor3_times_Tensor3_21(\n+    const Tensor3_Expr<A, T, Dim0, Dim1, Dim23, i, j, k> &a,\n+    const Tensor3_Expr<B, U, Dim23, Dim4, Dim5, k, l, m> &b)\n+      : iterA(a), iterB(b)\n+  {}\n+  T operator()(const int &N1, const int &N2, const int &N3,\n+               const int &N4) const\n+  {\n+    return eval(N1, N2, N3, N4, Number<Dim23>());\n+  }\n+};\n+\n+template <class A, class B, class T, class U, int Dim0, int Dim1, int Dim23,\n+          int Dim4, int Dim5, char i, char j, char k, char l, char m>\n+Tensor4_Expr<Tensor3_times_Tensor3_21<A, B, T, U, Dim0, Dim1, Dim23, Dim4,\n+                                      Dim5, i, j, k, l, m>,\n+             T, Dim0, Dim1, Dim4, Dim5, i, j, l, m>\n+operator*(const Tensor3_Expr<A, T, Dim0, Dim1, Dim23, i, j, k> &a,\n+          const Tensor3_Expr<B, U, Dim23, Dim4, Dim5, k, l, m> &b)\n+{\n+  using TensorExpr = Tensor3_times_Tensor3_21<A, B, T, U, Dim0, Dim1, Dim23,\n+                                              Dim4, Dim5, i, j, k, l, m>;\n+  return Tensor4_Expr<TensorExpr, T, Dim0, Dim1, Dim4, Dim5, i, j, l, m>(\n+    TensorExpr(a, b));\n+};\n+\n+template <class T, int Tensor_Dim0, int Tensor_Dim1, int Tensor_Dim2,\n+          int Tensor_Dim3>\n+struct Tensor4\n+{\n+  T data[Tensor_Dim0][Tensor_Dim1][Tensor_Dim2][Tensor_Dim3];\n+\n+  Tensor4() {}\n+  T &operator()(const int N1, const int N2, const int N3, const int N4)\n+  {\n+    return data[N1][N2][N3][N4];\n+  }\n+\n+  template <char i, char j, char k, char l, int Dim0, int Dim1, int Dim2,\n+            int Dim3>\n+  Tensor4_Expr<Tensor4<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2, Tensor_Dim3>,\n+               T, Dim0, Dim1, Dim2, Dim3, i, j, k, l>\n+  operator()(const Index<i, Dim0>, const Index<j, Dim1>, const Index<k, Dim2>,\n+             const Index<l, Dim3>)\n+  {\n+    return Tensor4_Expr<\n+      Tensor4<T, Tensor_Dim0, Tensor_Dim1, Tensor_Dim2, Tensor_Dim3>, T, Dim0,\n+      Dim1, Dim2, Dim3, i, j, k, l>(*this);\n+  };\n+};\n+\n+template <class A, class T, int Dim0, int Dim1, int Dim2, int Dim3, char i,\n+          char j, char k, char l>\n+struct Tensor4_Expr\n+{\n+  A iter;\n+\n+  Tensor4_Expr(const A &a) : iter(a) {}\n+  T operator()(const int N1, const int N2, const int N3, const int N4) const\n+  {\n+    return iter(N1, N2, N3, N4);\n+  }\n+};\n+\n+template <class A, class T, int Dim0, int Dim1, int Dim2, int Dim3, char i,\n+          char j, char k, char l>\n+struct Tensor4_Expr<Tensor4<A, Dim0, Dim1, Dim2, Dim3>, T, Dim0, Dim1, Dim2,\n+                   Dim3, i, j, k, l>\n+{\n+  Tensor4<A, Dim0, Dim1, Dim2, Dim3> &iter;\n+\n+  Tensor4_Expr(Tensor4<A, Dim0, Dim1, Dim2, Dim3> &a) : iter(a) {}\n+  T operator()(const int N1, const int N2, const int N3, const int N4) const\n+  {\n+    return iter(N1, N2, N3, N4);\n+  }\n+\n+  template <class B, class U, int Dim1_0, int Dim1_1, int Dim1_2, int Dim1_3,\n+            char i_1, char j_1, char k_1, char l_1>\n+  auto &operator=(const Tensor4_Expr<B, U, Dim1_0, Dim1_1, Dim1_2, Dim1_3, i_1,\n+                                     j_1, k_1, l_1> &rhs)\n+  {\n+    for(int ii = 0; ii < Dim0; ++ii)\n+      for(int jj = 0; jj < Dim1; ++jj)\n+        for(int kk = 0; kk < Dim2; ++kk)\n+          for(int ll = 0; ll < Dim3; ++ll)\n+            {\n+              iter(ii, jj, kk, ll) = rhs(ii, jj, kk, ll);\n+            }\n+    return *this;\n+  }\n+};\n+\n+int main()\n+{\n+  Tensor3<float, 100, 100, 1000> t1;\n+  Tensor3<float, 1000, 100, 100> t2;\n+\n+  Index<'l', 100> l;\n+  Index<'m', 100> m;\n+  Index<'k', 1000> k;\n+  Index<'n', 100> n;\n+  Index<'o', 100> o;\n+\n+  Tensor4<float, 100, 100, 100, 100> res;\n+  res(l, m, n, o) = t1(l, m, k) * t2(k, n, o);\n+  return 0;\n+}\n+"}, {"sha": "9864b59ccfcf17fddd232719a43349c085a3aaf2", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8363a2f1f7c47d7b3d1760ce631a6824e91c0d80/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8363a2f1f7c47d7b3d1760ce631a6824e91c0d80", "patch": "@@ -114,7 +114,7 @@ along with GCC; see the file COPYING3.  If not see\n    interface between the GIMPLE and RTL worlds.  */\n \n /* The infinite cost.  */\n-#define INFTY 10000000\n+#define INFTY 1000000000\n \n /* Returns the expected number of loop iterations for LOOP.\n    The average trip count is computed from profile data if it\n@@ -180,7 +180,7 @@ struct comp_cost\n   comp_cost (): cost (0), complexity (0), scratch (0)\n   {}\n \n-  comp_cost (int cost, unsigned complexity, int scratch = 0)\n+  comp_cost (int64_t cost, unsigned complexity, int64_t scratch = 0)\n     : cost (cost), complexity (complexity), scratch (scratch)\n   {}\n \n@@ -220,16 +220,16 @@ struct comp_cost\n   /* Returns true if COST1 is smaller or equal than COST2.  */\n   friend bool operator<= (comp_cost cost1, comp_cost cost2);\n \n-  int cost;\t\t/* The runtime cost.  */\n+  int64_t cost;\t\t/* The runtime cost.  */\n   unsigned complexity;  /* The estimate of the complexity of the code for\n \t\t\t   the computation (in no concrete units --\n \t\t\t   complexity field should be larger for more\n \t\t\t   complex expressions and addressing modes).  */\n-  int scratch;\t\t/* Scratch used during cost computation.  */\n+  int64_t scratch;\t/* Scratch used during cost computation.  */\n };\n \n static const comp_cost no_cost;\n-static const comp_cost infinite_cost (INFTY, INFTY, INFTY);\n+static const comp_cost infinite_cost (INFTY, 0, INFTY);\n \n bool\n comp_cost::infinite_cost_p ()\n@@ -243,6 +243,7 @@ operator+ (comp_cost cost1, comp_cost cost2)\n   if (cost1.infinite_cost_p () || cost2.infinite_cost_p ())\n     return infinite_cost;\n \n+  gcc_assert (cost1.cost + cost2.cost < infinite_cost.cost);\n   cost1.cost += cost2.cost;\n   cost1.complexity += cost2.complexity;\n \n@@ -256,6 +257,7 @@ operator- (comp_cost cost1, comp_cost cost2)\n     return infinite_cost;\n \n   gcc_assert (!cost2.infinite_cost_p ());\n+  gcc_assert (cost1.cost - cost2.cost < infinite_cost.cost);\n \n   cost1.cost -= cost2.cost;\n   cost1.complexity -= cost2.complexity;\n@@ -276,6 +278,7 @@ comp_cost::operator+= (HOST_WIDE_INT c)\n   if (infinite_cost_p ())\n     return *this;\n \n+  gcc_assert (this->cost + c < infinite_cost.cost);\n   this->cost += c;\n \n   return *this;\n@@ -287,6 +290,7 @@ comp_cost::operator-= (HOST_WIDE_INT c)\n   if (infinite_cost_p ())\n     return *this;\n \n+  gcc_assert (this->cost - c < infinite_cost.cost);\n   this->cost -= c;\n \n   return *this;\n@@ -295,6 +299,7 @@ comp_cost::operator-= (HOST_WIDE_INT c)\n comp_cost\n comp_cost::operator/= (HOST_WIDE_INT c)\n {\n+  gcc_assert (c != 0);\n   if (infinite_cost_p ())\n     return *this;\n \n@@ -309,6 +314,7 @@ comp_cost::operator*= (HOST_WIDE_INT c)\n   if (infinite_cost_p ())\n     return *this;\n \n+  gcc_assert (this->cost * c < infinite_cost.cost);\n   this->cost *= c;\n \n   return *this;\n@@ -638,7 +644,7 @@ struct iv_ca\n   comp_cost cand_use_cost;\n \n   /* Total cost of candidates.  */\n-  unsigned cand_cost;\n+  int64_t cand_cost;\n \n   /* Number of times each invariant variable is used.  */\n   unsigned *n_inv_var_uses;\n@@ -4025,16 +4031,16 @@ get_computation_at (struct loop *loop, gimple *at,\n    if we're optimizing for speed, amortize it over the per-iteration cost.\n    If ROUND_UP_P is true, the result is round up rather than to zero when\n    optimizing for speed.  */\n-static unsigned\n-adjust_setup_cost (struct ivopts_data *data, unsigned cost,\n+static int64_t\n+adjust_setup_cost (struct ivopts_data *data, int64_t cost,\n \t\t   bool round_up_p = false)\n {\n   if (cost == INFTY)\n     return cost;\n   else if (optimize_loop_for_speed_p (data->current_loop))\n     {\n-      HOST_WIDE_INT niters = avg_loop_niter (data->current_loop);\n-      return ((HOST_WIDE_INT) cost + (round_up_p ? niters - 1 : 0)) / niters;\n+      int64_t niters = (int64_t) avg_loop_niter (data->current_loop);\n+      return (cost + (round_up_p ? niters - 1 : 0)) / niters;\n     }\n   else\n     return cost;\n@@ -4305,7 +4311,7 @@ enum ainc_type\n \n struct ainc_cost_data\n {\n-  unsigned costs[AINC_NONE];\n+  int64_t costs[AINC_NONE];\n };\n \n static comp_cost\n@@ -4566,12 +4572,12 @@ get_scaled_computation_cost_at (ivopts_data *data, gimple *at, comp_cost cost)\n       if (scale_factor == 1)\n \treturn cost;\n \n-      int scaled_cost\n+      int64_t scaled_cost\n \t= cost.scratch + (cost.cost - cost.scratch) * scale_factor;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Scaling cost based on bb prob \"\n-\t\t \"by %2.2f: %d (scratch: %d) -> %d\\n\",\n+\tfprintf (dump_file, \"Scaling cost based on bb prob by %2.2f: \"\n+\t\t \"%\" PRId64 \" (scratch: %\" PRId64 \") -> %\" PRId64 \"\\n\",\n \t\t 1.0f * scale_factor, cost.cost, cost.scratch, scaled_cost);\n \n       cost.cost = scaled_cost;\n@@ -5539,7 +5545,7 @@ determine_group_iv_costs (struct ivopts_data *data)\n \t\t  || group->cost_map[j].cost.infinite_cost_p ())\n \t\tcontinue;\n \n-\t      fprintf (dump_file, \"  %d\\t%d\\t%d\\t\",\n+\t      fprintf (dump_file, \"  %d\\t%\" PRId64 \"\\t%d\\t\",\n \t\t       group->cost_map[j].cand->id,\n \t\t       group->cost_map[j].cost.cost,\n \t\t       group->cost_map[j].cost.complexity);\n@@ -5569,7 +5575,7 @@ static void\n determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n {\n   comp_cost cost_base;\n-  unsigned cost, cost_step;\n+  int64_t cost, cost_step;\n   tree base;\n \n   gcc_assert (cand->iv != NULL);\n@@ -6139,21 +6145,21 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n   unsigned i;\n   comp_cost cost = iv_ca_cost (ivs);\n \n-  fprintf (file, \"  cost: %d (complexity %d)\\n\", cost.cost,\n+  fprintf (file, \"  cost: %\" PRId64 \" (complexity %d)\\n\", cost.cost,\n \t   cost.complexity);\n-  fprintf (file, \"  cand_cost: %d\\n  cand_group_cost: %d (complexity %d)\\n\",\n-\t   ivs->cand_cost, ivs->cand_use_cost.cost,\n-\t   ivs->cand_use_cost.complexity);\n+  fprintf (file, \"  cand_cost: %\" PRId64 \"\\n  cand_group_cost: \"\n+\t   \"%\" PRId64 \" (complexity %d)\\n\", ivs->cand_cost,\n+\t   ivs->cand_use_cost.cost, ivs->cand_use_cost.complexity);\n   bitmap_print (file, ivs->cands, \"  candidates: \",\"\\n\");\n \n   for (i = 0; i < ivs->upto; i++)\n     {\n       struct iv_group *group = data->vgroups[i];\n       struct cost_pair *cp = iv_ca_cand_for_group (ivs, group);\n       if (cp)\n-        fprintf (file, \"   group:%d --> iv_cand:%d, cost=(%d,%d)\\n\",\n-\t\t group->id, cp->cand->id, cp->cost.cost,\n-\t\t cp->cost.complexity);\n+        fprintf (file, \"   group:%d --> iv_cand:%d, cost=(\"\n+\t\t \"%\" PRId64 \",%d)\\n\", group->id, cp->cand->id,\n+\t\t cp->cost.cost, cp->cost.complexity);\n       else\n \tfprintf (file, \"   group:%d --> ??\\n\", group->id);\n     }\n@@ -6751,9 +6757,9 @@ find_optimal_iv_set (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Original cost %d (complexity %d)\\n\\n\",\n+      fprintf (dump_file, \"Original cost %\" PRId64 \" (complexity %d)\\n\\n\",\n \t       origcost.cost, origcost.complexity);\n-      fprintf (dump_file, \"Final cost %d (complexity %d)\\n\\n\",\n+      fprintf (dump_file, \"Final cost %\" PRId64 \" (complexity %d)\\n\\n\",\n \t       cost.cost, cost.complexity);\n     }\n "}]}