{"sha": "a9cc90612480809d385676473e02bae1c1c87bd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljYzkwNjEyNDgwODA5ZDM4NTY3NjQ3M2UwMmJhZTFjMWM4N2JkMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-18T01:31:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-18T01:31:12Z"}, "message": "sched.c (canon_rtx): Recursively look for equivalences; look for expressions equivalent to MEMs.\n\n        * sched.c (canon_rtx): Recursively look for equivalences;\n        look for expressions equivalent to MEMs.\n        (true_dependence): Canonicalize inputs before operating\n        on their values.\n        (anti_dependence, output_dependence): Likewise.\n\n        * jump.c (follow_jumps): Don't follow an unconditional jump\n        that is not a simple_jump.\n\nFrom-SVN: r10793", "tree": {"sha": "1af946c443b754dbc8559aeb991357748bbeba1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1af946c443b754dbc8559aeb991357748bbeba1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9cc90612480809d385676473e02bae1c1c87bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9cc90612480809d385676473e02bae1c1c87bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9cc90612480809d385676473e02bae1c1c87bd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9cc90612480809d385676473e02bae1c1c87bd0/comments", "author": null, "committer": null, "parents": [{"sha": "c0bd9b243917331de29afdab528eedd8f607a8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bd9b243917331de29afdab528eedd8f607a8eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0bd9b243917331de29afdab528eedd8f607a8eb"}], "stats": {"total": 23, "additions": 21, "deletions": 2}, "files": [{"sha": "2fd8be52cb282d0f96076d2d36dbf2ad0017792b", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9cc90612480809d385676473e02bae1c1c87bd0/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9cc90612480809d385676473e02bae1c1c87bd0/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=a9cc90612480809d385676473e02bae1c1c87bd0", "patch": "@@ -3054,7 +3054,8 @@ follow_jumps (label)\n        (depth < 10\n \t&& (insn = next_active_insn (value)) != 0\n \t&& GET_CODE (insn) == JUMP_INSN\n-\t&& (JUMP_LABEL (insn) != 0 || GET_CODE (PATTERN (insn)) == RETURN)\n+\t&& ((JUMP_LABEL (insn) != 0 && simplejump_p (insn))\n+\t    || GET_CODE (PATTERN (insn)) == RETURN)\n \t&& (next = NEXT_INSN (insn))\n \t&& GET_CODE (next) == BARRIER);\n        depth++)"}, {"sha": "2be6f9d83faa0bcf2a119d2504e979db3445141c", "filename": "gcc/sched.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9cc90612480809d385676473e02bae1c1c87bd0/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9cc90612480809d385676473e02bae1c1c87bd0/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=a9cc90612480809d385676473e02bae1c1c87bd0", "patch": "@@ -371,9 +371,11 @@ static rtx\n canon_rtx (x)\n      rtx x;\n {\n+  /* Recursively look for equivalences.  */\n   if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       && REGNO (x) <= reg_known_value_size)\n-    return reg_known_value[REGNO (x)];\n+    return reg_known_value[REGNO (x)] == x\n+      ? x : canon_rtx (reg_known_value[REGNO (x)]);\n   else if (GET_CODE (x) == PLUS)\n     {\n       rtx x0 = canon_rtx (XEXP (x, 0));\n@@ -390,6 +392,16 @@ canon_rtx (x)\n \t  return gen_rtx (PLUS, GET_MODE (x), x0, x1);\n \t}\n     }\n+  /* This gives us much better alias analysis when called from\n+     the loop optimizer.   Note we want to leave the original\n+     MEM alone, but need to return the canonicalized MEM with\n+     all the flags with their original values.  */\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      rtx copy = copy_rtx (x);\n+      XEXP (copy, 0) = canon_rtx (XEXP (copy, 0));\n+      x = copy;\n+    }\n   return x;\n }\n \n@@ -825,6 +837,8 @@ true_dependence (mem, x)\n      both an unchanging read and an unchanging write.  This won't handle all\n      cases optimally, but the possible performance loss should be\n      negligible.  */\n+  x = canon_rtx (x);\n+  mem = canon_rtx (mem);\n   if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n@@ -849,6 +863,8 @@ anti_dependence (mem, x)\n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n      have occurred somewhere before MEM.  */\n+  x = canon_rtx (x);\n+  mem = canon_rtx (mem);\n   if (RTX_UNCHANGING_P (mem))\n     return 0;\n \n@@ -870,6 +886,8 @@ output_dependence (mem, x)\n      rtx mem;\n      rtx x;\n {\n+  x = canon_rtx (x);\n+  mem = canon_rtx (mem);\n   return ((MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n \t  || (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n \t\t\t\t  SIZE_FOR_MODE (x), XEXP (x, 0), 0)"}]}