{"sha": "a1aff58fb98dcba080629c73933b51850d1f0e1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhZmY1OGZiOThkY2JhMDgwNjI5YzczOTMzYjUxODUwZDFmMGUxZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-01-19T23:58:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-01-19T23:58:19Z"}, "message": "re PR lto/45375 ([meta-bug] Issues with building Mozilla (i.e. Firefox) with LTO)\n\n\n\tPR lto/45375\n\t* i386.c (gate): Check flag_expensive_optimizations and\n\toptimize_size.\n\t(ix86_option_override_internal): Drop optimize_size condition\n\ton MASK_ACCUMULATE_OUTGOING_ARGS, MASK_VZEROUPPER,\n\tMASK_AVX256_SPLIT_UNALIGNED_LOAD, MASK_AVX256_SPLIT_UNALIGNED_STORE,\n\tMASK_PREFER_AVX128.\n\t(ix86_avx256_split_vector_move_misalign,\n\tix86_avx256_split_vector_move_misalign): Check optimize_insn_for_speed.\n\t* sse.md (all uses of TARGET_PREFER_AVX128): Add\n\toptimize_insn_for_speed_p check.\n\nFrom-SVN: r219871", "tree": {"sha": "72fbc4d3f5794930073c7c41b7d2842308a510c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72fbc4d3f5794930073c7c41b7d2842308a510c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1aff58fb98dcba080629c73933b51850d1f0e1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1aff58fb98dcba080629c73933b51850d1f0e1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1aff58fb98dcba080629c73933b51850d1f0e1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1aff58fb98dcba080629c73933b51850d1f0e1e/comments", "author": null, "committer": null, "parents": [{"sha": "0c84d521a9fe232a30c7fe638a4af21bc7c10c91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c84d521a9fe232a30c7fe638a4af21bc7c10c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c84d521a9fe232a30c7fe638a4af21bc7c10c91"}], "stats": {"total": 72, "additions": 42, "deletions": 30}, "files": [{"sha": "9a76dd70a129404bc6c878947789a06f2ff37278", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aff58fb98dcba080629c73933b51850d1f0e1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aff58fb98dcba080629c73933b51850d1f0e1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1aff58fb98dcba080629c73933b51850d1f0e1e", "patch": "@@ -1,3 +1,17 @@\n+2015-01-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/45375\n+\t* i386.c (gate): Check flag_expensive_optimizations and\n+\toptimize_size.\n+\t(ix86_option_override_internal): Drop optimize_size condition\n+\ton MASK_ACCUMULATE_OUTGOING_ARGS, MASK_VZEROUPPER,\n+\tMASK_AVX256_SPLIT_UNALIGNED_LOAD, MASK_AVX256_SPLIT_UNALIGNED_STORE,\n+\tMASK_PREFER_AVX128.\n+\t(ix86_avx256_split_vector_move_misalign,\n+\tix86_avx256_split_vector_move_misalign): Check optimize_insn_for_speed.\n+\t* sse.md (all uses of TARGET_PREFER_AVX128): Add\n+\toptimize_insn_for_speed_p check.\n+\n 2015-01-19  Matthew Fortune  <matthew.fortune@imgtec.com>\n \n \t* config/mips/mips.h (FP_ASM_SPEC): New define."}, {"sha": "ef1b2883cad873dcf1620fd30a0ecfa2f7ce9128", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aff58fb98dcba080629c73933b51850d1f0e1e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aff58fb98dcba080629c73933b51850d1f0e1e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a1aff58fb98dcba080629c73933b51850d1f0e1e", "patch": "@@ -2578,7 +2578,9 @@ class pass_insert_vzeroupper : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return TARGET_AVX && !TARGET_AVX512F && TARGET_VZEROUPPER;\n+      return TARGET_AVX && !TARGET_AVX512F\n+\t     && TARGET_VZEROUPPER && flag_expensive_optimizations\n+\t     && !optimize_size;\n     }\n \n   virtual unsigned int execute (function *)\n@@ -3874,6 +3876,8 @@ ix86_option_override_internal (bool main_args_p,\n     }\n \n   ix86_tune_cost = processor_target_table[ix86_tune].cost;\n+  /* TODO: ix86_cost should be chosen at instruction or function granuality\n+     so for cold code we use size_cost even in !optimize_size compilation.  */\n   if (opts->x_optimize_size)\n     ix86_cost = &ix86_size_cost;\n   else\n@@ -4113,8 +4117,7 @@ ix86_option_override_internal (bool main_args_p,\n       }\n \n   if (ix86_tune_features [X86_TUNE_ACCUMULATE_OUTGOING_ARGS]\n-      && !(opts_set->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)\n-      && !opts->x_optimize_size)\n+      && !(opts_set->x_target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))\n     opts->x_target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n \n   /* If stack probes are required, the space used for large function\n@@ -4244,26 +4247,19 @@ ix86_option_override_internal (bool main_args_p,\n #endif\n    }\n \n-  /* When not opts->x_optimize for size, enable vzeroupper optimization for\n-     TARGET_AVX with -fexpensive-optimizations and split 32-byte\n-     AVX unaligned load/store.  */\n-  if (!opts->x_optimize_size)\n-    {\n-      if (flag_expensive_optimizations\n-\t  && !(opts_set->x_target_flags & MASK_VZEROUPPER))\n-\topts->x_target_flags |= MASK_VZEROUPPER;\n-      if (!ix86_tune_features[X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL]\n-\t  && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n-\topts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n-      if (!ix86_tune_features[X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL]\n-\t  && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n-\topts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;\n-      /* Enable 128-bit AVX instruction generation\n-         for the auto-vectorizer.  */\n-      if (TARGET_AVX128_OPTIMAL\n-\t  && !(opts_set->x_target_flags & MASK_PREFER_AVX128))\n-\topts->x_target_flags |= MASK_PREFER_AVX128;\n-    }\n+  if (!(opts_set->x_target_flags & MASK_VZEROUPPER))\n+    opts->x_target_flags |= MASK_VZEROUPPER;\n+  if (!ix86_tune_features[X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL]\n+      && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n+    opts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n+  if (!ix86_tune_features[X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL]\n+      && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n+    opts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;\n+  /* Enable 128-bit AVX instruction generation\n+     for the auto-vectorizer.  */\n+  if (TARGET_AVX128_OPTIMAL\n+      && !(opts_set->x_target_flags & MASK_PREFER_AVX128))\n+    opts->x_target_flags |= MASK_PREFER_AVX128;\n \n   if (opts->x_ix86_recip_name)\n     {\n@@ -17469,7 +17465,8 @@ ix86_avx256_split_vector_move_misalign (rtx op0, rtx op1)\n \n   if (MEM_P (op1))\n     {\n-      if (TARGET_AVX256_SPLIT_UNALIGNED_LOAD)\n+      if (TARGET_AVX256_SPLIT_UNALIGNED_LOAD\n+\t  && optimize_insn_for_speed_p ())\n \t{\n \t  rtx r = gen_reg_rtx (mode);\n \t  m = adjust_address (op1, mode, 0);\n@@ -17489,7 +17486,8 @@ ix86_avx256_split_vector_move_misalign (rtx op0, rtx op1)\n     }\n   else if (MEM_P (op0))\n     {\n-      if (TARGET_AVX256_SPLIT_UNALIGNED_STORE)\n+      if (TARGET_AVX256_SPLIT_UNALIGNED_STORE\n+\t  && optimize_insn_for_speed_p ())\n \t{\n \t  m = adjust_address (op0, mode, 0);\n \t  emit_insn (extract (m, op1, const0_rtx));"}, {"sha": "ee2d93bdbcba45a6d7ca890f4dda166ab2fbf787", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1aff58fb98dcba080629c73933b51850d1f0e1e/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1aff58fb98dcba080629c73933b51850d1f0e1e/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=a1aff58fb98dcba080629c73933b51850d1f0e1e", "patch": "@@ -5434,7 +5434,7 @@\n {\n   rtx tmp0, tmp1;\n \n-  if (TARGET_AVX && !TARGET_PREFER_AVX128)\n+  if (TARGET_AVX && !TARGET_PREFER_AVX128 && optimize_insn_for_speed_p ())\n     {\n       tmp0 = gen_reg_rtx (V4DFmode);\n       tmp1 = force_reg (V2DFmode, operands[1]);\n@@ -5496,7 +5496,7 @@\n {\n   rtx tmp0, tmp1, tmp2;\n \n-  if (TARGET_AVX && !TARGET_PREFER_AVX128)\n+  if (TARGET_AVX && !TARGET_PREFER_AVX128 && optimize_insn_for_speed_p ())\n     {\n       tmp0 = gen_reg_rtx (V4DFmode);\n       tmp1 = force_reg (V2DFmode, operands[1]);\n@@ -5593,7 +5593,7 @@\n {\n   rtx tmp0, tmp1, tmp2;\n \n-  if (TARGET_AVX && !TARGET_PREFER_AVX128)\n+  if (TARGET_AVX && !TARGET_PREFER_AVX128 && optimize_insn_for_speed_p ())\n     {\n       tmp0 = gen_reg_rtx (V4DFmode);\n       tmp1 = force_reg (V2DFmode, operands[1]);\n@@ -14472,7 +14472,7 @@\n   rtx tmp0, tmp1;\n \n   if (<MODE>mode == V2DFmode\n-      && TARGET_AVX && !TARGET_PREFER_AVX128)\n+      && TARGET_AVX && !TARGET_PREFER_AVX128 && optimize_insn_for_speed_p ())\n     {\n       rtx tmp2 = gen_reg_rtx (V4DFmode);\n \n@@ -14579,7 +14579,7 @@\n   rtx tmp0, tmp1;\n \n   if (<MODE>mode == V2DFmode\n-      && TARGET_AVX && !TARGET_PREFER_AVX128)\n+      && TARGET_AVX && !TARGET_PREFER_AVX128 && optimize_insn_for_speed_p ())\n     {\n       rtx tmp2 = gen_reg_rtx (V4DFmode);\n "}]}