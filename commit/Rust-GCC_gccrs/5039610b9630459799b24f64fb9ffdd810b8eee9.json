{"sha": "5039610b9630459799b24f64fb9ffdd810b8eee9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAzOTYxMGI5NjMwNDU5Nzk5YjI0ZjY0ZmI5ZmZkZDgxMGI4ZWVlOQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-02-15T23:50:49Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-02-15T23:50:49Z"}, "message": "tree.h (enum tree_code_class): Add tcc_vl_exp.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* tree.h (enum tree_code_class): Add tcc_vl_exp.\n\t(VL_EXP_CLASS_P): New.\n\t(TREE_OPERAND_CHECK): Use TREE_OPERAND_LENGTH instead of\n\tTREE_CODE_LENGTH.\n\t(TREE_OPERAND_CHECK_CODE): Likewise.\n\t(GIMPLE_STMT_OPERAND_CHECK): Likewise.\n\t(TREE_RTL_OPERAND_CHECK): Likewise.\n\t(tree_operand_check_failed): Make second parameter the whole tree\n\tinstead of its code.  Fixed callers.\n\t(VL_EXP_CHECK): New.\n\t(TREE_OPERAND_LENGTH): New.\n\t(VL_EXP_OPERAND_LENGTH): New.\n\t(CALL_EXPR_FN): New.\n\t(CALL_EXPR_STATIC_CHAIN): New.\n\t(CALL_EXPR_ARGS): New.\n\t(CALL_EXPR_ARG): New.\n\t(call_expr_nargs): New.\n\t(CALL_EXPR_ARGP): New.\n\t(build_nt_call_list): Declare.\n\t(build_vl_exp_stat): Declare.\n\t(build_vl_exp): New.\n\t(build_call_list): Declare.\n\t(build_call_nary): Declare.\n\t(build_call_valist): Declare.\n\t(build_call_array): Declare.\n\t(call_expr_arg): Declare.\n\t(call_expr_argp): Declare.\n\t(call_expr_arglist): Declare.\n\t(fold_build_call_list): Declare.\n\t(fold_build_call_list_initializer): Declare.\n\t(fold_call_expr): Declare to replace fold_builtin.\n\t(fold_builtin_fputs): Update to agree with modified definition.\n\t(fold_builtin_strcpy): Likewise.\n\t(fold_builtin_strncpy): Likewise.\n\t(fold_builtin_memory_chk): Likewise.\n\t(fold_builtin_stxcpy_chk): Likewise.\n\t(fold_builtin_strncpy_chk): Likewise.\n\t(fold_builtin_next_arg): Likewise.\n\t(fold_build_call_expr): Declare.\n\t(fold_builtin_call_list): Declare.\n\t(fold_builtin_call_valist): Declare.\n\t(build_call_expr): Declare.\n\t(validate_arglist): Update to agree with modified definition.\n\t(tree_operand_length): New.\n\t(call_expr_arg_iterator): New.\n\t(init_call_expr_arg_iterator): New.\n\t(next_call_expr_arg): New.\n\t(first_call_expr_arg): New.\n\t(more_call_expr_args_p): New.\n\t(FOR_EACH_CALL_EXPR_ARG): New.\n\n\t* tree.c (tree_code_class_string): Add entries for tcc_vl_exp\n\tand tcc_gimple_stmt.\n\t(tree_code_size): Update documentation.  Use sizeof (tree) rather\n\tthan sizeof (char *).\n\t(tree_size): Likewise.  Add case for tcc_vl_exp.\n\t(tree_node_structure): Add case for tcc_vl_exp.\n\t(contains_placeholder_p): Likewise.\n\t(substitute_in_expr): Likewise.\n\t(substitute_placeholder_in_expr): Likewise.\n\t(stabilize_reference_1): Likewise.\n\t(build3_stat): Remove logic for CALL_EXPRs.  Replace with assertion\n\tto diagnose breakage of this interface for constructing CALL_EXPRs.\n\t(build_nt): Add similar assertion here.\n\t(build_nt_call_list): New.\n\t(simple_cst_equal) <CALL_EXPR>: Rewrite to use new accessors.\n\t(iterative_hash_expr): Use TREE_OPERAND_LENGTH instead of\n\tTREE_CODE_LENGTH.\n\t(get_callee_fndecl): Use new CALL_EXPR accessors.\n\t(tree_operand_check_failed): Change parameters to pass entire node\n\tinstead of its code, so that we can call TREE_OPERAND_LENGTH on it.\n\t(process_call_operands): New.\n\t(build_vl_exp_stat): New.\n\t(build_call_list): New.\n\t(build_call_nary): New.\n\t(build_call_valist): New.\n\t(build_call_array): New.\n\t(walk_tree): Use TREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\t(call_expr_arglist): New.\n\n\t* tree.def (CALL_EXPR): Change representation of CALL_EXPRs to use\n\ttcc_vl_exp instead of a fixed-size tcc_expression.\n\n\t* doc/c-tree.texi (CALL_EXPR): Document new representation and\n\taccessors for CALL_EXPRs.\n\t(AGGR_INIT_EXPR): Likewise.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* builtins.c (c_strlen): Return NULL_TREE instead of 0.\n\t(expand_builtin_nonlocal_goto): Change parameter to be entire\n\tCALL_EXPR instead of an arglist.  Use new CALL_EXPR accessors.\n\t(expand_builtin_prefetch): Likewise.\n\t(expand_builtin_classify_type): Likewise.\n\t(mathfn_built_in): Return NULL_TREE instead of 0.\n\t(expand_errno_check): Use new CALL_EXPR accessors.\n\t(expand_builtin_mathfn): Use new CALL_EXPR accessors and constructors.\n\tReturn NULL_RTX instead of 0.\n\t(expand_builtin_mathfn_2): Likewise.\n\t(expand_builtin_mathfn_3): Likewise.\n\t(expand_builtin_interclass_mathfn): Likewise.\n\t(expand_builtin_sincos): Likewise.\n\t(expand_builtin_cexpi): Likewise.\n\t(expand_builtin_int_roundingfn): Likewise.\n\t(expand_builtin_int_roundingfn_2): Likewise.\n\t(expand_builtin_pow): Likewise.\n\t(expand_builtin_powi): Likewise.\n\t(expand_builtin_strlen): Pass entire CALL_EXPR as parameter instead\n\tof arglist, fixing callers appropriately.  Use new CALL_EXPR\n\taccessors and constructors.  Return NULL_RTX instead of 0.\n\t(expand_builtin_strstr): Likewise.\n\t(expand_builtin_strchr): Likewise.\n\t(expand_builtin_strrchr): Likewise.\n\t(expand_builtin_strpbrk): Likewise.\n\t(expand_builtin_memcpy): Likewise.\n\t(expand_builtin_mempcpy): Likewise.\n\t(expand_builtin_mempcpy_args): New.\n\t(expand_builtin_memmove): Similarly to expand_builtin_mempcpy.\n\t(expand_builtin_memmove_args): New.\n\t(expand_builtin_bcopy): Similarly to expand_builtin_mempcpy.\n\t(expand_movstr): Likewise.\n\t(expand_builtin_strcpy): Likewise.\n\t(expand_builtin_strcpy_args): New.\n\t(expand_builtin_stpcpy): Similarly to expand_builtin_strcpy.\n\t(expand_builtin_strncpy): Likewise.\n\t(expand_builtin_memset): Likewise.\n\t(expand_builtin_memset_args): New.\n\t(expand_builtin_bzero): Similarly to expand_builtin_memset.\n\t(expand_builtin_memcmp): Likewise.\n\t(expand_builtin_strcmp): Likewise.\n\t(expand_builtin_strncmp): Likewise.\n\t(expand_builtin_strcat): Likewise.\n\t(expand_builtin_strncat): Likewise.\n\t(expand_builtin_strspn): Likewise.\n\t(expand_builtin_strcspn): Likewise.\n\t(expand_builtin_args_info): Likewise.\n\t(expand_builtin_va_start): Likewise.\n\t(gimplify_va_arg_expr): Likewise.\n\t(expand_builtin_va_end): Likewise.\n\t(expand_builtin_va_copy): Likewise.\n\t(expand_builtin_frame_address): Likewise.\n\t(expand_builtin_alloca): Likewise.\n\t(expand_builtin_bswap): Likewise.\n\t(expand_builtin_unop): Likewise.\n\t(expand_builtin_fputs): Likewise.\n\t(expand_builtin_expect): Likewise.\n\t(expand_builtin_fabs): Likewise.\n\t(expand_builtin_copysign): Likewise.\n\t(expand_builtin_printf): Likewise.\n\t(expand_builtin_fprintf): Likewise.\n\t(expand_builtin_sprintf): Likewise.\n\t(expand_builtin_init_trampoline): Likewise.\n\t(expand_builtin_signbit): Likewise.\n\t(expand_builtin_fork_or_exec): Likewise.\n\t(expand_builtin_sync_operation): Likewise.\n\t(expand_builtin_compare_and_swap): Likewise.\n\t(expand_builtin_lock_test_and_set): Likewise.\n\t(expand_builtin_lock_release): Likewise.\n\t(expand_builtin): Likewise.\n\t(builtin_mathfn_code): Likewise.\n\n\t(fold_builtin_constant_p): Pass call arguments individually instead\n\tof as an arglist, fixing callers appropriately.  Use new CALL_EXPR\n\taccessors and constructors.  Return NULL_TREE instead of 0.\n\t(fold_builtin_expect): Likewise.\n\t(fold_builtin_classify_type): Likewise.\n\t(fold_builtin_strlen): Likewise.\n\t(fold_builtin_nan): Likewise.\n\t(integer_valued_real_p): Likewise.\n\t(fold_trunc_transparent_mathfn): Likewise.\n\t(fold_fixed_mathfn): Likewise.\n\t(fold_builtin_cabs): Likewise.\n\t(fold_builtin_sqrt): Likewise.\n\t(fold_builtin_cbrt): Likewise.\n\t(fold_builtin_cos): Likewise.\n\t(fold_builtin_cosh): Likewise.\n\t(fold_builtin_tan): Likewise.\n\t(fold_builtin_sincos): Likewise.\n\t(fold_builtin_cexp): Likewise.\n\t(fold_builtin_trunc): Likewise.\n\t(fold_builtin_floor): Likewise.\n\t(fold_builtin_ceil): Likewise.\n\t(fold_builtin_round): Likewise.\n\t(fold_builtin_int_roundingfn): Likewise.\n\t(fold_builtin_bitop): Likewise.\n\t(fold_builtin_bswap): Likewise.\n\t(fold_builtin_logarithm): Likewise.\n\t(fold_builtin_hypot): Likewise.\n\t(fold_builtin_pow): Likewise.\n\t(fold_builtin_powi): Likewise.\n\t(fold_builtin_exponent): Likewise.\n\t(fold_builtin_memset): Likewise.\n\t(fold_builtin_bzero): Likewise.\n\t(fold_builtin_memory_op): Likewise.\n\t(fold_builtin_bcopy): Deleted; call site changed to invoke\n\tfold_builtin_memory_op directly.\n\t(fold_builtin_strcpy): Similarly as for fold_builtin_memory_op.\n\t(fold_builtin_strncpy): Likewise.\n\t(fold_builtin_memcmp): Likewise.\n\t(fold_builtin_strcmp): Likewise.\n\t(fold_builtin_strncmp): Likewise.\n\t(fold_builtin_signbit): Likewise.\n\t(fold_builtin_copysign): Likewise.\n\t(fold_builtin_isascii): Likewise.\n\t(fold_builtin_toascii): Likewise.\n\t(fold_builtin_isdigit): Likewise.\n\t(fold_builtin_fabs): Likewise.\n\t(fold_builtin_abs): Likewise.\n\t(fold_builtin_fmin_fmax): Likewise.\n\t(fold_builtin_carg): Likewise.\n\t(fold_builtin_classify): Likewise.\n\t(fold_builtin_unordered_cmp): Likewise.\n\n\t(fold_builtin_0, fold_builtin_2, fold_builtin_3, fold_builtin_4):\n\tNew functions split out from fold_builtin_1.\n\t(fold_builtin_n): New.\n\t(fold_builtin_varargs): New.\n\t(fold_builtin): Deleted.  Most callers changed to use fold_call_expr\n\tinstead.\n\t(fold_call_expr): New.\n\t(build_function_call_expr): Rewrite to use new helper function.\n\t(fold_builtin_call_list): New.\n\t(build_call_expr): New.\n\t(fold_builtin_call_valist): New.\n\t(rewrite_call_expr): New.\n\t(validate_arg): New.\n\t(validate_arglist): Change parameter to be entire CALL_EXPR instead\n\tof an arglist.  Change return type to bool.  Use new CALL_EXPR\n\taccessors.\n\n\t(fold_builtin_strstr):  Pass call arguments individually instead\n\tof as an arglist, fixing callers appropriately.  Use new CALL_EXPR\n\taccessors and constructors.  Return NULL_TREE instead of 0.\n\t(fold_builtin_strchr): Likewise.\n\t(fold_builtin_strrchr): Likewise.\n\t(fold_builtin_strpbrk): Likewise.\n\t(fold_builtin_strcat): Likewise.\n\t(fold_builtin_strncat): Likewise.\n\t(fold_builtin_strspn): Likewise.\n\t(fold_builtin_strcspn): Likewise.\n\t(fold_builtin_fputs): Likewise.\n\t(fold_builtin_next_arg): Likewise.\n\t(fold_builtin_sprintf): Likewise.\n\n\t(expand_builtin_object_size): Use new CALL_EXPR accessors.  Use\n\tNULL_RTX instead of 0.\n\t(expand_builtin_memory_chk): Likewise.\n\t(maybe_emit_chk_warning): Likewise.\n\t(maybe_emit_sprintf_chk_warning): Likewise.\n\n\t(fold_builtin_object_size): Pass call arguments individually instead\n\tof as an arglist, fixing callers appropriately.  Use new CALL_EXPR\n\taccessors and constructors.  Return NULL_TREE instead of 0.\n\t(fold_builtin_memory_chk): Likewise.\n\t(fold_builtin_stxcpy_chk): Likewise.\n\t(fold_builtin_strncpy_chk): Likewise.\n\t(fold_builtin_strcat_chk): Likewise.\n\t(fold_builtin_strcat_chk): Likewise.\n\t(fold_builtin_strncat_chk): Likewise.\n\t(fold_builtin_sprintf_chk): Likewise.\n\t(fold_builtin_snprintf_chk): Likewise.\n\t(fold_builtin_printf): Likewise.\n\t(fold_builtin_vprintf): Likewise.\n\n\t* fold-const.c (negate_expr_p): Use new CALL_EXPR accessors and\n\tconstructors.\n\t(operand_equal_p): Add separate tcc_vl_exp/CALL_EXPR case.\n\t(make_range): Use TREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\t(extract_muldiv_1): Add VL_EXP_CLASS_P case.\n\t(fold_mathfn_compare): Use new CALL_EXPR accessors and constructors.\n\t(fold_unary): Likewise.\n\t(fold_binary): Likewise.\n\t(fold_ternary): Remove CALL_EXPR case, since they are no longer\n\tternary expressions.\n\t(fold): Add logic for tcc_vl_exp.\n\t(fold_checksum_tree):  Make it know about tcc_vl_exp.  Use\n\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\t(fold_build3_stat): Add assertion to flag broken interface for\n\tconstructing CALL_EXPRs.\n\t(fold_build_call_list): New.\n\t(fold_build_call_list_initializer): New.\n\t(tree_expr_nonnegative_p): Use new CALL_EXPR accessors and\n\tconstructors.\n\t(fold_strip_sign_ops): Likewise.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* tree-dump.c (dequeue_and_dump) <CALL_EXPR>: Use new CALL_EXPR\n\taccessors and dump arguments explicitly.\n\n\t* tree-pretty-print.c (do_niy): Use TREE_OPERAND_LENGTH instead of\n\tTREE_CODE_LENGTH.\n\t(dump_generic_node): Use new CALL_EXPR accessors and walk arguments\n\texplicitly.\n\t(print_call_name): Use new CALL_EXPR accessors.\n\n\t* print-tree.c (print_node): Add case tcc_vl_exp.  Print\n\tCALL_EXPR arguments explicitly instead of as a list.  Use\n\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\n\t* tree-vrp.c (stmt_interesting_for_vrp): Use new CALL_EXPR accessors.\n\t(vrp_visit_stmt): Likewise.\n\n\t* tree-ssa-loop-im.c (outermost_invariant_loop_expr):  Make it\n\tknow about tcc_vl_exp.  Use TREE_OPERAND_LENGTH instead of\n\tTREE_CODE_LENGTH.\n\t(force_move_till_expr): Likewise.\n\n\t* targhooks.c (default_external_stack_protect_fail): Use\n\tbuild_call_expr instead of build_function_call_expr.\n\t(default_hidden_stack_protect_fail): Likewise.\n\n\t* tree-complex.c (expand_complex_libcall): Use build_call_expr to\n\tbuild the call.\n\n\t* cgraphbuild.c (build_cgraph_edges): Use new CALL_EXPR accessors\n\tand walk arguments explicitly.\n\n\t* tree-ssa-loop-niter.c (simplify_replace_tree): Use\n\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\t(expand_simple_operations): Likewise.\n\t(infer_loop_bounds_from_array): Use new CALL_EXPR accessors.\n\n\t* gengtype.c (adjust_field_tree_exp): Use TREE_OPERAND_LENGTH instead\n\tof TREE_CODE_LENGTH.\n\t(walk_type): Tweak walking of arrays not to blow up on CALL_EXPRs.\n\n\t* optabs.c (expand_widen_pattern-expr): Use TREE_OPERAND_LENGTH\n\tinstead of TREE_CODE_LENGTH.\n\n\t* value_prof.c (tree_ic): Use new CALL_EXPR accessors.\n\t(tree_ic_transform): Likewise.\n\t(interesting_stringop_to_profile_p): Pass entire CALL_EXPR as\n\tparameter instead of arglist.  Fix callers.\n\t(tree_stringop_fixed_value): Use new CALL_EXPR accessors.\n\t(tree_stringops_transform): Likewise.\n\t(tree_indirect_call_to_profile): Likewise.\n\t(tree_stringops_values_to_profile): Likewise.\n\n\t* tree-tailcall.c (find_tail_calls): Use new CALL_EXPR iterator.\n\t(eliminate_tail_call): Likewise.\n\n\t* ipa-cp.c (ipcp_update_callgraph): Use new CALL_EXPR accessors.\n\n\t* tree-scalar-evolution.c (chrec_contains_symbols_defined_in_loop):\n\tUse TREE_OPERAND_LENGTH and generalize to handle any number of\n\toperands.\n\t(instantiate_parameters_1): Can't handle tcc_vl_exp here.\n\n\t* omp-low.c (build_omp_barrier): Use build_call_expr.\n\t(lower_rec_input_clauses): Likewise.\n\t(lower_reduction_clauses): Likewise.\n\t(expand_parallel_call): Likewise.\n\t(maybe_catch_exception): Likewise.\n\t(expand_omp_for_generic): Likewise.\n\t(expand_omp_for_static_nochunk): Likewise.\n\t(expand_omp_sections): Likewise.\n\t(lower_omp_single_simple): Likewise.\n\t(lower_omp_single_copy): Likewise.\n\t(lower_omp_master): Likewise.\n\t(lower_omp_ordered): Likewise.\n\t(lower_omp_critical): Likewise.\n\n\t* ipa-reference.c (check-call): Use new CALL_EXPR iterator.\n\t(scan_for_static_refs): Create tcc_vl_exp case for CALL_EXPR.\n\n\t* tree-gimple.c (is_gimple_call_addr): Fix doc.\n\t(recalculate_side_effects): Use TREE_OPERAND_LENGTH instead of\n\tTREE_CODE_LENGTH.  Add tcc_vl_exp case.\n\n\t* tree-chrec.c (chrec_contains_symbols): Use TREE_OPERAND_LENGTH\n\tand generalize to handle any number of operands.\n\t(chrec_contains_undetermined): Likewise.\n\t(tree_contains_chrecs): Likewise.\n\t(evolution_function_is_invariant_rec_p): Use TREE_OPERAND_LENGTH.\n\n\t* cgraphunit.c (update_call_expr): Use new CALL_EXPR accessors.\n\n\t* tree-ssa-ccp.c (ccp_fold): Use new CALL_EXPR accessors.  Use\n\tfold_call_expr instead of fold_builtin.\n\t(ccp_fold_builtin): Likewise.  Update calls into builtins.c to\n\tmatch declarations there.\n\t(fold_stmt): Use new CALL_EXPR constructor and accessors.  Doc\n\tupdates.\n\n\t* tree-ssa-loop-ivopts.c (expr_invariant_in_loop_p): Use\n\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\n\t* ipa-pure-const.c (check_call): Use new CALL_EXPR accessors.\n\t(scan_function): Add case tcc_vl_exp for CALL_EXPR.\n\n\t* tree-stdarg.c (execute_optimize_stdarg): Use new CALL_EXPR\n\taccessors.\n\n\t* tree-ssa-math-opts.c (execute_cse_sincos_1): Use build_call_expr.\n\t(execute_cse_sincos): Use new CALL_EXPR accessors.\n\n\t* tree-ssa-alias.c (find_used_portions): Use new CALL_EXPR iterator.\n\n\t* gimple-low.c (lower_function_body): Use build_call_expr.\n\t(lower_builtin_setjmp): Likewise.\n\n\t* expr.c (emit_block_move_via_libcall): Use build_call_expr.\n\t(set_storage_via_libcall): Likewise.\n\t(safe_from_p): Add tcc_vl_exp case.  Use TREE_OPERAND_LENGTH\n\tinstead of TREE_CODE_LENGTH.\n\t(expand_expr_real_1): Use new CALL_EXPR accessors.\n\n\t* tree-browser.c (store_child_info): Use TREE_OPERAND_LENGTH and\n\tgeneralize to handle any number of operands.\n\t(TB_parent_eq): Likewise.\n\n\t* predict.c (expr_expected_value): Use new CALL_EXPR accessors.\n\t(strip_builtin_expect): Likewise.\n\n\t* function.c (gimplify_parameters): Use build_call_expr.\n\n\t* tree-vectorizer.c (vect_is_simple_reduction): Use TREE_OPERAND_LENGTH\n\tinstead of TREE_CODE_LENGTH.\n\n\t* ipa-type-escape.c (check_call): Use new CALL_EXPR iterators.\n\t(scan_for_refs): Add case tcc_vl_exp for CALL_EXPR.\n\n\t* tree-data-ref.c (get_references_in_stmt): Use new CALL_EXPR\n\titerators.\n\n\t* gimplify.c (build_stack_save_restore): Use build_call_expr.\n\t(gimplify_decl_expr): Likewise.\n\t(gimplify_call_expr): Use fold_call_expr instead of fold_builtin.\n\tUse new CALL_EXPR iterators.\n\t(gimplify_modify_expr_to_memcpy): Use build_call_expr.\n\t(gimplify_modify_expr_to_memset): Likewise.\n\t(gimplify_variable_sized_compare): Likewise.\n\t(gimplify_omp_atomic_fetch_op): Likewise.\n\t(gimplify_omp_atomic_pipeline): Likewise.\n\t(gimplify_omp_atomic_mutex): Likewise.\n\t(gimplify_function_tree): Likewise.\n\n\t* calls.c (alloca_call_p): Use new CALL_EXPR accessors.\n\t(call_expr_flags): Likewise.\n\t(expand_call): Likewise.\n\n\t* except.c (expand_builtin_eh_return_data_regno): Pass entire\n\tCALL_EXPR as parameter instead of arglist.  Use new CALL_EXPR \n        accessors.\n\n\t* coverage.c (create_coverage): Use build_call_expr.\n\n\t* tree-ssa-pre.c (expression_node_pool, list_node_pool): Delete.\n\t(temp_call_expr_obstack): New.\n\t(pool_copy_list): Delete.\n\t(temp_copy_call_expr): New.\n\t(phi_translate): Add case tcc_vl_exp for CALL_EXPR.  Use new\n\tCALL_EXPR accessors.  Get rid of special goo for copying argument\n\tlists and use temp_copy_call_expr instead.\n\t(valid_in_sets): Add case tcc_vl_exp for CALL_EXPR.  Use new\n\tCALL_EXPR accessors.\n\t(create_expression_by_pieces): Likewise.  Use build_call_array\n\tto construct the result instead of fold_build3.\n\t(create_value_expr_from): Add tcc_vl_exp.  Delete special goo for\n\tdealing with argument lists.\n\t(init_pre): Remove references to expression_node_pool and\n\tlist_node_pool.  Init temp_call_expr_obstack instead.\n\t(fini_pre): Remove references to expression_node_pool and\n\tlist_node_pool.\n\n\t* tree-sra.c (sra_walk_call_expr): Use new CALL_EXPR accessors\n\tand walk arguments explicitly instead of as a list.\n\n\t* tree-mudflap.c (mf_build_check_statement_for): Use build_call_expr.\n\t(mx_register_decls): Likewise.\n\t(mudflap_register_call): Likewise.\n\t(mudflap_finish_file): Likewise.\n\n\t* ipa-prop.c (ipa_callsite_compute_count): Use new CALL_EXPR accessors.\n\t(ipa_callsite_compute_param): Likewise.\n\n\t* tree-vect-patterns.c (vect_recog_pow_pattern): Use new CALL_EXPR\n\taccessors and constructor.\n\n\t* tree-nested.c (convert_nl_goto_reference): Use new CALL_EXPR\n\taccessors and constructor.\n\t(convert_tramp_reference): Likewise. \n\t(convert_call_expr): Likewise.\n\t(finalize_nesting_tree_1): Likewise.\n\n\t* tree-ssa.c (tree_ssa_useless_type_conversion): Use new CALL_EXPR\n\taccessors.\n\n\t* tree-ssa-loop-prefetch.c (issue_prefetch_ref): Use build_call_expr.\n\n\t* tree-inline.c (initialize_inlined_parameters): Pass entire\n\tCALL_EXPR as parameter instead of arglist.  Use new CALL_EXPR\n\taccessors.\n\t(estimate_num_insns_1): Use new CALL_EXPR accessors.\n\t(expand_call_inline): Tidy up call to initialize_inlined_parameters.\n\n\t* tree-vect-transform.c (vect_create_epilog_for_reduction):  Use\n\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\t(vectorizable_reduction): Likewise.\n\t(vectorizable_call): Use new CALL_EXPR iterators.\n\t(vectorizable_conversion): Use build_call_expr.\n\t(vectorizable_operation): Use TREE_OPERAND_LENGTH.\n\t(vect_gen_widened_results_half): Use build_call_expr.\n\t(vect_setup_realignment): Likewise.\n\t(vectorizable_live_operation): Use TREE_OPERAND_LENGTH.\n\n\t* tree-object-size.c (alloc_object_size): Use new CALL_EXPR accessors.\n\t(pass_through_call): Likewise.\n\t(compute_object_sizes): Likewise.  Use fold_call_expr instead of\n\tfold_builtin.\n\n\t* tree-profile.c (tree_gen_interval_profiler): Use build_call_expr.\n\t(tree_gen_pow2_profiler): Likewise.\n\t(tree_gen_one_value_profiler): Likewise.\n\t(tree_gen_ic_func_profiler): Likewise.\n\t(tree_gen_average_profiler): Likewise.\n\t(tree_gen_ior_profiler): Likewise.\n\n\t* tree-ssa-structalias.c (get_constraint_for): Add case tcc_vl_exp.\n\t(find_func_aliases): Use new CALL_EXPR accessors.  Add case\n\ttcc_vl_exp.  Use TREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n\n\t* tree-ssa-reassoc.c (get_rank): Use TREE_OPERAND_LENGTH instead\n\tof TREE_CODE_LENGTH.\n\n\t* stmt.c (warn_if_unused_value): Use TREE_OPERAND_LENGTH instead\n\tof TREE_CODE_LENGTH.\n\n\t* convert.c (convert_to_real): Use new CALL_EXPR accessors and\n\tconstructor.\n\t(convert_to_integer): Likewise.\n\n\t* tree-ssa-operands.c (get_call_expr_operands): Use new CALL_EXPR\n\taccessors.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* config/alpha/alpha.c (alpha_expand_builtin): Use new CALL_EXPR\n\taccessors.\n\t* config/frv/frv.c (frv_expand_builtin): Likewise.\n\t* config/s390/s390.c (s390_expand_builtin): Likewise.\n\n\t* config/sparc/sparc.c (sparc_gimplify_va_arg): Use build_call_expr.\n\t(sparc_expand_builtin): Use new CALL_EXPR accessors.\n\n\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Likewise.\n\t(ix86_expand_binop_builtin): Pass entire CALL_EXPR as parameter\n\tinstead of arglist.  Use new CALL_EXPR accessors on it.  Fix callers.\n\t(ix86_expand_store_builtin): Likewise.\n\t(ix86_expand_unop_builtin): Likewise.\n\t(ix86_expand_unop1_builtin): Likewise.\n\t(ix86_expand_sse_compare): Likewise.\n\t(ix86_expand_sse_comi): Likewise.\n\t(ix86_expand_vec_init_builtin): Likewise.\n\t(ix86_expand_vec_ext_builtin): Likewise.\n\t(ix86_expand_vec_set_builtin): Likewise.\n\t(ix86_expand_builtin): Use new CALL_EXPR accessors.\n\n\t* config/sh/sh.c (sh_expand_builtin): Use new CALL_EXPR accessors.\n\t* config/c4x/c4x.c (c4x_expand_builtin): Likewise.\n\n\t* config/iq2000/iq2000.c (expand_one_builtin): Pass entire CALL_EXPR\n\tinstead of arglist.  Use new CALL_EXPR accessors.  Fix callers.\n\t(iq2000_expand_builtin): Use new CALL_EXPR accessors.\n\n\t* config/rs6000/rs6000-c.c (altivec_build_resolved_builtin): Use\n\tbuild_call_expr.\n\t* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Likewise.\n\t(rs6000_expand_unop_builtin): Pass entire CALL_EXPR instead of\n\targlist.  Use new CALL_EXPR accessors.  Fix callers.\n\t(altivec_expand_abs_builtin): Likewise.\n\t(rs6000_expand_binop_builtin): Likewise.\n\t(altivec_expand_predicate_builtin): Likewise.\n\t(altivec_expand_lv_builtin): Likewise.\n\t(spe_expand_stv_builtin): Likewise.\n\t(altivec_expand_stv_builtin): Likewise.\n\t(rs6000_expand_ternop_builtin): Likewise.\n\t(altivec_expand_ld_builtin): Use new CALL_EXPR accessors.\n\t(altivec_expand_st_builtin): Likewise.\n\t(altivec_expand_dst_builtin): Likewise.\n\t(altivec_expand_vec_init_builtin): Pass entire CALL_EXPR instead of\n\targlist.  Use new CALL_EXPR accessors.  Fix callers.\n\t(altivec_expand_vec_set_builtin): Likewise.\n\t(altivec_expand_vec_ext_builtin): Likewise.\n\t(altivec_expand_builtin): Use new CALL_EXPR accessors.\n\t(spe_expand_builtin): Likewise.\n\t(spe_expand_predicate_builtin): Pass entire CALL_EXPR instead of\n\targlist.  Use new CALL_EXPR accessors.  Fix callers.\n\t(spe_expand_evsel_builtin): Likewise.\n\t(rs6000_expand_builtin): Use new CALL_EXPR accessors.  VCFUX and\n\tFCFSX cases must construct whole new CALL_EXPR, not just arglist.\n\n\t* config/arm/arm.c (arm_expand_binop_builtin): Pass entire CALL_EXPR\n\tinstead of arglist.  Use new CALL_EXPR accessors.  Fix callers.\n\t(arm_expand_unop_builtin): Likewise.\n\t(arm_expand_builtin): Use new CALL_EXPR accessors.\n\n\t* config/mips/mips.c (mips_expand_builtin):  Use new CALL_EXPR\n\taccessors.\n\n\t* config/bfin/bfin.c (bfin_expand_binop_builtin): Pass entire CALL_EXPR\n\tinstead of arglist.  Use new CALL_EXPR accessors.  Fix callers.\n\t(bfin_expand_unop_builtin): Likewise.\n\t(bfin_expand_builtin): Use new CALL_EXPR accessors.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* c-semantics.c (build_stmt): Add internal diagnostic check.\n\n\t* c-pretty-print.c (pp_c_postfix_expression): Use new CALL_EXPR\n\taccessors.  Print arguments explicitly instead of as a list.\n\n\t* c-typeck.c (build_function_call): Use new CALL_EXPR constructors.\n\n\t* c-omp.c (c_finish_omp_barrier): Use build_call_expr.\n\t(c_finish_omp_flish): Likewise.\n\n\t* c-common.c (verify_tree): Use new CALL_EXPR accessors.  Traverse\n\targuments explicitly instead of as a list.  Use TREE_OPERAND_LENGTH\n\tinstead of TREE_CODE_LENGTH.\n\t(check_function_arguments_recurse): Use new CALL_EXPR accessors.\n\t(c_warn_unused_result): Likewise.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* cp-tree.def (AGGR_INIT_EXPR): Adjust documentation.\n\tChange class to tcc_vl_exp.\n\n\t* call.c (build_call): Use build_call_list instead \n\tof build3. \n\t(build_over_call): Likewise.\n\t(build_new_method_call): Use build_min_non_dep_call_list \n\tinstead of build_min_non_dep.\n\n\t* error.c (dump_call_expr_args): New function.\n\t(dump_aggr_init_expr_args): New function.\n\t(dump_expr) <AGGR_INIT_EXPR, CALL_EXPR, INDIRECT_REF>: Use them. \n\tUpdate to use new CALL_EXPR and AGGR_INIT_EXPR accessor macros.\n\n\t* cvt.c (convert_to_void): Use build_call_array instead\n\tof build3; use new AGGR_INIT_EXPR accessor macros.\n\n\t* mangle.c (write_expression): Use TREE_OPERAND_LENGTH\n\tinstead of TREE_CODE_LENGTH.\n\n\t* dump.c (cp_dump_tree) <AGGR_INIT_EXPR>: Update to use new\n\tAGGR_INIT_EXPR accessor macros.\n\n\t* cp-gimplify.c (cp_gimplify_init_expr): Use \n\tAGGR_INIT_EXPR_SLOT to set the slot operand.\n\n\t* cp-tree.h (AGGR_INIT_EXPR_FN): New macro.\n\t(AGGR_INIT_EXPR_SLOT): New macro.\n\t(AGGR_INIT_EXPR_ARG): New macro.\n\t(aggr_init_expr_nargs): New macro.\n\t(AGGR_INIT_EXPR_ARGP): New macro.\n\t(aggr_init_expr_arg_iterator): New.\n\t(init_aggr_init_expr_arg_iterator): New.\n\t(next_aggr_init_expr_arg): New.\n\t(first_aggr_init_expr_arg): New.\n\t(more_aggr_init_expr_args_p): New.\n\t(FOR_EACH_AGGR_INIT_EXPR_ARG): New.\n\t(stabilize_aggr_init): New declaration.\n\t(build_min_non_dep_call_list): Likewise.\n\n\t* tree.c (process_aggr_init_operands): New function.\n\t(build_aggr_init_array) New function.\n\t(build_cplus_new): Update to use new CALL_EXPR and\n\tAGGR_INIT_EXPR accessor macros. Replace use of build3 with\n\tbuild_aggr_init_array.\n\t(build_min_non_dep_call_list) New function.\n\t(build_min_nt): Assert input code parameter is not a variable\n\tlength expression class.\n\t(build_min, build_min_non_dep): Likewise.\n\t(cp_tree_equal) <CALL_EXPR>: Iterate through the arguments\n\tto check for equality instead of recursing. Handle tcc_vl_exp\n\ttree code classes.\n\t(stabilize_call): Update to only handle CALL_EXPRs, not \n\tAGGR_INIT_EXPRs; use new CALL_EXPR accessor macros.\n\t(stabilize_aggr_init): New function.\n\t(stabilize_init): Use it.\n\n\t* cxx-pretty-print.c (pp_cxx_postfix_expression)\n\t<AGGR_INIT_EXPR, CALL_EXPR>: Update to use new CALL_EXPR and\n\tAGGR_INIT_EXPR accessor macros and argument iterators.\n\t\n\t* pt.c (tsubst_copy) <CALL_EXPR>: Replace build_nt with\n\tbuild_vl_exp. Iterate through the operands, recursively \n\tprocessing each one.\n\t(tsubst_copy_and_build) <CALL_EXPR>: Update to use new\n\tCALL_EXPR accessor macros.\n\t(value_dependent_expression_p) <default>: Handle tcc_vl_exp\n\ttree code classes. Use TREE_OPERAND_LENGTH instead of \n\tTREE_CODE_LENGTH.\n\n\t* semantics.c (finish_call_expr): Use build_nt_call_list\n\tinstead of build_nt.\n\t(simplify_aggr_init_expr): Update to use new AGGR_INIT_EXPR \n\taccessor macros. Use build_call_array to construct the \n\tCALL_EXPR node instead of build3\n\t\n\t* decl2.c (build_offset_ref_call_from_tree): Use \n\tbuild_nt_call_list and build_min_non_dep_call_list instead\n\tof build_min_nt and build_min_non_dep.\n\n\t* parser.c (cp_parser_postfix_expression) <CPP_OPEN_PAREN>:\n\tUse build_nt_call_list instead of build_min_nt.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* java-tree.h (BUILD_MONITOR_ENTER): Use build_call_nary instead\n\tof build3.\n\t(BUILD_MONITOR_EXIT): Likewise.\n\n\t* java-gimplify.c (java_gimplify_component_ref): Use build_call_expr.\n\t(java_gimplify_modify_expr): Likewise.\n\n\t* class.c (cache_this_class_ref): Use build_call_expr.\n\t(build_static_field_ref): Likewise.\n\t(emit_indirect_register_classes): Likewise.\n\t(emit_register_classes): Likewise.\n\n\t* resource.c (write_resource_constructor): Use build_call_expr.\n\n\t* builtins.c (builtin_creator_function): Change interpretation of\n\tthe second parameter to be the whole CALL_EXPR instead of the arglist.\n\t(max_builtin): Tweak parameter list.  Use new CALL_EXPR accessors.\n\t(min_builtin): Likewise.\n\t(abs_builtin): Likewise.\n\t(java_build_function_call_expr): Likewise.\n\t(convert_real): Likewise.\n\t(UNMARSHAL3): Likewise.\n\t(UNMARSHAL4): Likewise.\n\t(UNMARSHAL5): Likewise.\n\t(build_arglist_for_builtin): Delete.  Fix callers to use\n\tbuild_call_expr instead.\n\t(putObject_builtin): Tweak parameter list.  Use new CALL_EXPR\n\taccessors.\n\t(compareAndSwapInt_builtin): Likewise.\n\t(compareAndSwapLong_builtin): Likewise.\n\t(compareAndSwapObject_builtin): Likewise.\n\t(putVolatile_builtin): Likewise.\n\t(getVolatile_builtin): Likewise.\n\t(VMSupportsCS8_builtin): Likewise.\n\t(check_for_builtin): Pass entire CALL_EXPR to builtin expander\n\tinstead of arglist.\n\n\t* expr.c (build_java_athrow): Use build_call_nary instead of build3.\n\t(build_java_throw_out_of_bounds_exception): Likewise.\n\t(java_check_reference): Likewise.\n\t(build_java_arraystore_check): Likewise.\n\t(build_newarray): Likewise.\n\t(build_anewarray): Likewise.\n\t(expand_java_multinewarray): Use build_call_list instead of build3.\n\t(build_java_monitor): Use build_call_nary instead of build3.\n\t(java_create_object): Likewise.\n\t(expand_java_NEW): Likewise.\n\t(build_instanceof): Likewise.\n\t(expand_java_CHECKCAST): Likewise.\n\t(build_java_soft_divmod): Likewise.\n\t(build_java_binop): Likewise.\n\t(build_field_ref): Likewise.\n\t(build_class_init): Likewise.\n\t(rewrite_arglist_getcaller): Use build_call_expr.\n\t(build_invokeinterface):  Use build_call_nary instead of build3.\n\t(expand_invoke): Use build_call_list instead of build3.\n\t(build_jni_stub): Use build_call_nary, build_call_list, or\n\tbuild_call_expr instead\tof build3.\n\t(expand_java_field_op): Use build_call_expr instead of build3.\n\t(force_evaluation_order): Use new CALL_EXPR accessors.\n\n\t* lang.c (java_get_callee_fndecl): Use new CALL_EXPR accessors.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* objc-act.c (receiver_is_class_object): Use new CALL_EXPR accessors.\n\t(objc_get_callee_fndecl): Likewise.\n\n2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Brooks Moses  <brooks.moses@codesourcery.com>\n\t    Lee Millward  <lee.millward@codesourcery.com>\n\n\t* trans-expr.c (gfc_conv_power_op): Use build_call_expr.\n\t(gfc_conv_string_tmp): Likewise.\n\t(gfc_conv_concat_op): Likewise.\n\t(gfc_build_compare_string): Likewise.\n\t(gfc_conv_function_call): Use build_call_list instead of build3.\n\n\t* trans-array.c (gfc_trans_allocate_array_storage): Use\n\tbuild_call_expr.\n\t(gfc_grow_array): Likewise.\n\t(gfc_trans_array_ctor_element): Likewise.\n\t(gfc_trans_array_constructor_value): Likewise.\n\t(gfc_array_allocate): Likewise.\n\t(gfc_array_deallocate): Likewise.\n\t(gfc_trans_auto_array_allocation): Likewise.\n\t(gfc_trans_dummy_array_bias): Likewise.\n\t(gfc_conv_array_parameter): Likewise.\n\t(gfc_trans_dealloc_allocated): Likewise.\n\t(gfc_duplicate_allocatable): Likewise.\n\n\t* trans-openmp.c (gfc_trans_omp_barrier): Use build_call_expr.\n\t(gfc_trans_omp_flush): Likewise.\n\n\t* trans-stmt.c (gfc_conv_elementel_dependencies): Use build_call_expr.\n\t(gfc_trans_pause): Likewise.\n\t(gfc_trans_stop): Likewise.\n\t(gfc_trans_character_select): Likewise.\n\t(gfc_do_allocate): Likewise.\n\t(gfc_trans_assign_need_temp): Likewise.\n\t(gfc_trans_pointer_assign_need_temp): Likewise.\n\t(gfc_trans_forall_1): Likewise.\n\t(gfc_trans_where_2): Likewise.\n\t(gfc_trans_allocate): Likewise.\n\t(gfc_trans_deallocate): Likewise.\n\n\t* trans.c (gfc_trans_runtime_check): Use build_call_expr.\n\n\t* trans-io.c (gfc_trans_open): Use build_call_expr.\n\t(gfc_trans_close): Likewise.\n\t(build_filepos): Likewise.\n\t(gfc_trans_inquire): Likewise.\n\t(NML_FIRST_ARG): Delete.\n\t(NML_ADD_ARG): Delete.\n\t(transfer_namelist_element): Use build_call_expr.\n\t(build_dt): Likewise.\n\t(gfc_trans_dt_end): Likewise.\n\t(transfer_expr): Likewise.\n\t(transfer_array-desc): Likewise.\n\n\t* trans-decl.c (gfc_generate_function_code): Use build_call_expr.\n\t(gfc_generate_constructors): Likewise.\n\n\t* trans-intrinsic.c (gfc_conv_intrinsic_ctime): Use build_call_expr.\n\t(gfc_conv_intrinsic_fdate): Likewise.\n\t(gfc_conv_intrinsic_ttynam): Likewise.\n\t(gfc_conv_intrinsic_array_transfer): Likewise.\n\t(gfc_conv_associated): Likewise.\n\t(gfc_conv_intrinsic_si_kind): Likewise.\n\t(gfc_conv_intrinsic_trim): Likewise.\n\t(gfc_conv_intrinsic_repeat: Likewise.\n\t(gfc_conv_intrinsic_iargc): Likewise.\n\nCo-Authored-By: Brooks Moses <brooks.moses@codesourcery.com>\nCo-Authored-By: Lee Millward <lee.millward@codesourcery.com>\n\nFrom-SVN: r122018", "tree": {"sha": "4c9dae557e2aa52bff7b845dd7b1270c19be7a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c9dae557e2aa52bff7b845dd7b1270c19be7a2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5039610b9630459799b24f64fb9ffdd810b8eee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5039610b9630459799b24f64fb9ffdd810b8eee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5039610b9630459799b24f64fb9ffdd810b8eee9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5039610b9630459799b24f64fb9ffdd810b8eee9/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc90f45b24a668f465d50a4db2253c7b84cd1c2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc90f45b24a668f465d50a4db2253c7b84cd1c2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc90f45b24a668f465d50a4db2253c7b84cd1c2d"}], "stats": {"total": 10537, "additions": 5817, "deletions": 4720}, "files": [{"sha": "22af3fdef3f497dfc2460298d2a830b225722c71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1,3 +1,639 @@\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* tree.h (enum tree_code_class): Add tcc_vl_exp.\n+\t(VL_EXP_CLASS_P): New.\n+\t(TREE_OPERAND_CHECK): Use TREE_OPERAND_LENGTH instead of\n+\tTREE_CODE_LENGTH.\n+\t(TREE_OPERAND_CHECK_CODE): Likewise.\n+\t(GIMPLE_STMT_OPERAND_CHECK): Likewise.\n+\t(TREE_RTL_OPERAND_CHECK): Likewise.\n+\t(tree_operand_check_failed): Make second parameter the whole tree\n+\tinstead of its code.  Fixed callers.\n+\t(VL_EXP_CHECK): New.\n+\t(TREE_OPERAND_LENGTH): New.\n+\t(VL_EXP_OPERAND_LENGTH): New.\n+\t(CALL_EXPR_FN): New.\n+\t(CALL_EXPR_STATIC_CHAIN): New.\n+\t(CALL_EXPR_ARGS): New.\n+\t(CALL_EXPR_ARG): New.\n+\t(call_expr_nargs): New.\n+\t(CALL_EXPR_ARGP): New.\n+\t(build_nt_call_list): Declare.\n+\t(build_vl_exp_stat): Declare.\n+\t(build_vl_exp): New.\n+\t(build_call_list): Declare.\n+\t(build_call_nary): Declare.\n+\t(build_call_valist): Declare.\n+\t(build_call_array): Declare.\n+\t(call_expr_arg): Declare.\n+\t(call_expr_argp): Declare.\n+\t(call_expr_arglist): Declare.\n+\t(fold_build_call_list): Declare.\n+\t(fold_build_call_list_initializer): Declare.\n+\t(fold_call_expr): Declare to replace fold_builtin.\n+\t(fold_builtin_fputs): Update to agree with modified definition.\n+\t(fold_builtin_strcpy): Likewise.\n+\t(fold_builtin_strncpy): Likewise.\n+\t(fold_builtin_memory_chk): Likewise.\n+\t(fold_builtin_stxcpy_chk): Likewise.\n+\t(fold_builtin_strncpy_chk): Likewise.\n+\t(fold_builtin_next_arg): Likewise.\n+\t(fold_build_call_expr): Declare.\n+\t(fold_builtin_call_list): Declare.\n+\t(fold_builtin_call_valist): Declare.\n+\t(build_call_expr): Declare.\n+\t(validate_arglist): Update to agree with modified definition.\n+\t(tree_operand_length): New.\n+\t(call_expr_arg_iterator): New.\n+\t(init_call_expr_arg_iterator): New.\n+\t(next_call_expr_arg): New.\n+\t(first_call_expr_arg): New.\n+\t(more_call_expr_args_p): New.\n+\t(FOR_EACH_CALL_EXPR_ARG): New.\n+\n+\t* tree.c (tree_code_class_string): Add entries for tcc_vl_exp\n+\tand tcc_gimple_stmt.\n+\t(tree_code_size): Update documentation.  Use sizeof (tree) rather\n+\tthan sizeof (char *).\n+\t(tree_size): Likewise.  Add case for tcc_vl_exp.\n+\t(tree_node_structure): Add case for tcc_vl_exp.\n+\t(contains_placeholder_p): Likewise.\n+\t(substitute_in_expr): Likewise.\n+\t(substitute_placeholder_in_expr): Likewise.\n+\t(stabilize_reference_1): Likewise.\n+\t(build3_stat): Remove logic for CALL_EXPRs.  Replace with assertion\n+\tto diagnose breakage of this interface for constructing CALL_EXPRs.\n+\t(build_nt): Add similar assertion here.\n+\t(build_nt_call_list): New.\n+\t(simple_cst_equal) <CALL_EXPR>: Rewrite to use new accessors.\n+\t(iterative_hash_expr): Use TREE_OPERAND_LENGTH instead of\n+\tTREE_CODE_LENGTH.\n+\t(get_callee_fndecl): Use new CALL_EXPR accessors.\n+\t(tree_operand_check_failed): Change parameters to pass entire node\n+\tinstead of its code, so that we can call TREE_OPERAND_LENGTH on it.\n+\t(process_call_operands): New.\n+\t(build_vl_exp_stat): New.\n+\t(build_call_list): New.\n+\t(build_call_nary): New.\n+\t(build_call_valist): New.\n+\t(build_call_array): New.\n+\t(walk_tree): Use TREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\t(call_expr_arglist): New.\n+\n+\t* tree.def (CALL_EXPR): Change representation of CALL_EXPRs to use\n+\ttcc_vl_exp instead of a fixed-size tcc_expression.\n+\n+\t* doc/c-tree.texi (CALL_EXPR): Document new representation and\n+\taccessors for CALL_EXPRs.\n+\t(AGGR_INIT_EXPR): Likewise.\n+\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* builtins.c (c_strlen): Return NULL_TREE instead of 0.\n+\t(expand_builtin_nonlocal_goto): Change parameter to be entire\n+\tCALL_EXPR instead of an arglist.  Use new CALL_EXPR accessors.\n+\t(expand_builtin_prefetch): Likewise.\n+\t(expand_builtin_classify_type): Likewise.\n+\t(mathfn_built_in): Return NULL_TREE instead of 0.\n+\t(expand_errno_check): Use new CALL_EXPR accessors.\n+\t(expand_builtin_mathfn): Use new CALL_EXPR accessors and constructors.\n+\tReturn NULL_RTX instead of 0.\n+\t(expand_builtin_mathfn_2): Likewise.\n+\t(expand_builtin_mathfn_3): Likewise.\n+\t(expand_builtin_interclass_mathfn): Likewise.\n+\t(expand_builtin_sincos): Likewise.\n+\t(expand_builtin_cexpi): Likewise.\n+\t(expand_builtin_int_roundingfn): Likewise.\n+\t(expand_builtin_int_roundingfn_2): Likewise.\n+\t(expand_builtin_pow): Likewise.\n+\t(expand_builtin_powi): Likewise.\n+\t(expand_builtin_strlen): Pass entire CALL_EXPR as parameter instead\n+\tof arglist, fixing callers appropriately.  Use new CALL_EXPR\n+\taccessors and constructors.  Return NULL_RTX instead of 0.\n+\t(expand_builtin_strstr): Likewise.\n+\t(expand_builtin_strchr): Likewise.\n+\t(expand_builtin_strrchr): Likewise.\n+\t(expand_builtin_strpbrk): Likewise.\n+\t(expand_builtin_memcpy): Likewise.\n+\t(expand_builtin_mempcpy): Likewise.\n+\t(expand_builtin_mempcpy_args): New.\n+\t(expand_builtin_memmove): Similarly to expand_builtin_mempcpy.\n+\t(expand_builtin_memmove_args): New.\n+\t(expand_builtin_bcopy): Similarly to expand_builtin_mempcpy.\n+\t(expand_movstr): Likewise.\n+\t(expand_builtin_strcpy): Likewise.\n+\t(expand_builtin_strcpy_args): New.\n+\t(expand_builtin_stpcpy): Similarly to expand_builtin_strcpy.\n+\t(expand_builtin_strncpy): Likewise.\n+\t(expand_builtin_memset): Likewise.\n+\t(expand_builtin_memset_args): New.\n+\t(expand_builtin_bzero): Similarly to expand_builtin_memset.\n+\t(expand_builtin_memcmp): Likewise.\n+\t(expand_builtin_strcmp): Likewise.\n+\t(expand_builtin_strncmp): Likewise.\n+\t(expand_builtin_strcat): Likewise.\n+\t(expand_builtin_strncat): Likewise.\n+\t(expand_builtin_strspn): Likewise.\n+\t(expand_builtin_strcspn): Likewise.\n+\t(expand_builtin_args_info): Likewise.\n+\t(expand_builtin_va_start): Likewise.\n+\t(gimplify_va_arg_expr): Likewise.\n+\t(expand_builtin_va_end): Likewise.\n+\t(expand_builtin_va_copy): Likewise.\n+\t(expand_builtin_frame_address): Likewise.\n+\t(expand_builtin_alloca): Likewise.\n+\t(expand_builtin_bswap): Likewise.\n+\t(expand_builtin_unop): Likewise.\n+\t(expand_builtin_fputs): Likewise.\n+\t(expand_builtin_expect): Likewise.\n+\t(expand_builtin_fabs): Likewise.\n+\t(expand_builtin_copysign): Likewise.\n+\t(expand_builtin_printf): Likewise.\n+\t(expand_builtin_fprintf): Likewise.\n+\t(expand_builtin_sprintf): Likewise.\n+\t(expand_builtin_init_trampoline): Likewise.\n+\t(expand_builtin_signbit): Likewise.\n+\t(expand_builtin_fork_or_exec): Likewise.\n+\t(expand_builtin_sync_operation): Likewise.\n+\t(expand_builtin_compare_and_swap): Likewise.\n+\t(expand_builtin_lock_test_and_set): Likewise.\n+\t(expand_builtin_lock_release): Likewise.\n+\t(expand_builtin): Likewise.\n+\t(builtin_mathfn_code): Likewise.\n+\n+\t(fold_builtin_constant_p): Pass call arguments individually instead\n+\tof as an arglist, fixing callers appropriately.  Use new CALL_EXPR\n+\taccessors and constructors.  Return NULL_TREE instead of 0.\n+\t(fold_builtin_expect): Likewise.\n+\t(fold_builtin_classify_type): Likewise.\n+\t(fold_builtin_strlen): Likewise.\n+\t(fold_builtin_nan): Likewise.\n+\t(integer_valued_real_p): Likewise.\n+\t(fold_trunc_transparent_mathfn): Likewise.\n+\t(fold_fixed_mathfn): Likewise.\n+\t(fold_builtin_cabs): Likewise.\n+\t(fold_builtin_sqrt): Likewise.\n+\t(fold_builtin_cbrt): Likewise.\n+\t(fold_builtin_cos): Likewise.\n+\t(fold_builtin_cosh): Likewise.\n+\t(fold_builtin_tan): Likewise.\n+\t(fold_builtin_sincos): Likewise.\n+\t(fold_builtin_cexp): Likewise.\n+\t(fold_builtin_trunc): Likewise.\n+\t(fold_builtin_floor): Likewise.\n+\t(fold_builtin_ceil): Likewise.\n+\t(fold_builtin_round): Likewise.\n+\t(fold_builtin_int_roundingfn): Likewise.\n+\t(fold_builtin_bitop): Likewise.\n+\t(fold_builtin_bswap): Likewise.\n+\t(fold_builtin_logarithm): Likewise.\n+\t(fold_builtin_hypot): Likewise.\n+\t(fold_builtin_pow): Likewise.\n+\t(fold_builtin_powi): Likewise.\n+\t(fold_builtin_exponent): Likewise.\n+\t(fold_builtin_memset): Likewise.\n+\t(fold_builtin_bzero): Likewise.\n+\t(fold_builtin_memory_op): Likewise.\n+\t(fold_builtin_bcopy): Deleted; call site changed to invoke\n+\tfold_builtin_memory_op directly.\n+\t(fold_builtin_strcpy): Similarly as for fold_builtin_memory_op.\n+\t(fold_builtin_strncpy): Likewise.\n+\t(fold_builtin_memcmp): Likewise.\n+\t(fold_builtin_strcmp): Likewise.\n+\t(fold_builtin_strncmp): Likewise.\n+\t(fold_builtin_signbit): Likewise.\n+\t(fold_builtin_copysign): Likewise.\n+\t(fold_builtin_isascii): Likewise.\n+\t(fold_builtin_toascii): Likewise.\n+\t(fold_builtin_isdigit): Likewise.\n+\t(fold_builtin_fabs): Likewise.\n+\t(fold_builtin_abs): Likewise.\n+\t(fold_builtin_fmin_fmax): Likewise.\n+\t(fold_builtin_carg): Likewise.\n+\t(fold_builtin_classify): Likewise.\n+\t(fold_builtin_unordered_cmp): Likewise.\n+\n+\t(fold_builtin_0, fold_builtin_2, fold_builtin_3, fold_builtin_4):\n+\tNew functions split out from fold_builtin_1.\n+\t(fold_builtin_n): New.\n+\t(fold_builtin_varargs): New.\n+\t(fold_builtin): Deleted.  Most callers changed to use fold_call_expr\n+\tinstead.\n+\t(fold_call_expr): New.\n+\t(build_function_call_expr): Rewrite to use new helper function.\n+\t(fold_builtin_call_list): New.\n+\t(build_call_expr): New.\n+\t(fold_builtin_call_valist): New.\n+\t(rewrite_call_expr): New.\n+\t(validate_arg): New.\n+\t(validate_arglist): Change parameter to be entire CALL_EXPR instead\n+\tof an arglist.  Change return type to bool.  Use new CALL_EXPR\n+\taccessors.\n+\n+\t(fold_builtin_strstr):  Pass call arguments individually instead\n+\tof as an arglist, fixing callers appropriately.  Use new CALL_EXPR\n+\taccessors and constructors.  Return NULL_TREE instead of 0.\n+\t(fold_builtin_strchr): Likewise.\n+\t(fold_builtin_strrchr): Likewise.\n+\t(fold_builtin_strpbrk): Likewise.\n+\t(fold_builtin_strcat): Likewise.\n+\t(fold_builtin_strncat): Likewise.\n+\t(fold_builtin_strspn): Likewise.\n+\t(fold_builtin_strcspn): Likewise.\n+\t(fold_builtin_fputs): Likewise.\n+\t(fold_builtin_next_arg): Likewise.\n+\t(fold_builtin_sprintf): Likewise.\n+\n+\t(expand_builtin_object_size): Use new CALL_EXPR accessors.  Use\n+\tNULL_RTX instead of 0.\n+\t(expand_builtin_memory_chk): Likewise.\n+\t(maybe_emit_chk_warning): Likewise.\n+\t(maybe_emit_sprintf_chk_warning): Likewise.\n+\n+\t(fold_builtin_object_size): Pass call arguments individually instead\n+\tof as an arglist, fixing callers appropriately.  Use new CALL_EXPR\n+\taccessors and constructors.  Return NULL_TREE instead of 0.\n+\t(fold_builtin_memory_chk): Likewise.\n+\t(fold_builtin_stxcpy_chk): Likewise.\n+\t(fold_builtin_strncpy_chk): Likewise.\n+\t(fold_builtin_strcat_chk): Likewise.\n+\t(fold_builtin_strcat_chk): Likewise.\n+\t(fold_builtin_strncat_chk): Likewise.\n+\t(fold_builtin_sprintf_chk): Likewise.\n+\t(fold_builtin_snprintf_chk): Likewise.\n+\t(fold_builtin_printf): Likewise.\n+\t(fold_builtin_vprintf): Likewise.\n+\n+\t* fold-const.c (negate_expr_p): Use new CALL_EXPR accessors and\n+\tconstructors.\n+\t(operand_equal_p): Add separate tcc_vl_exp/CALL_EXPR case.\n+\t(make_range): Use TREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\t(extract_muldiv_1): Add VL_EXP_CLASS_P case.\n+\t(fold_mathfn_compare): Use new CALL_EXPR accessors and constructors.\n+\t(fold_unary): Likewise.\n+\t(fold_binary): Likewise.\n+\t(fold_ternary): Remove CALL_EXPR case, since they are no longer\n+\tternary expressions.\n+\t(fold): Add logic for tcc_vl_exp.\n+\t(fold_checksum_tree):  Make it know about tcc_vl_exp.  Use\n+\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\t(fold_build3_stat): Add assertion to flag broken interface for\n+\tconstructing CALL_EXPRs.\n+\t(fold_build_call_list): New.\n+\t(fold_build_call_list_initializer): New.\n+\t(tree_expr_nonnegative_p): Use new CALL_EXPR accessors and\n+\tconstructors.\n+\t(fold_strip_sign_ops): Likewise.\n+\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* tree-dump.c (dequeue_and_dump) <CALL_EXPR>: Use new CALL_EXPR\n+\taccessors and dump arguments explicitly.\n+\n+\t* tree-pretty-print.c (do_niy): Use TREE_OPERAND_LENGTH instead of\n+\tTREE_CODE_LENGTH.\n+\t(dump_generic_node): Use new CALL_EXPR accessors and walk arguments\n+\texplicitly.\n+\t(print_call_name): Use new CALL_EXPR accessors.\n+\n+\t* print-tree.c (print_node): Add case tcc_vl_exp.  Print\n+\tCALL_EXPR arguments explicitly instead of as a list.  Use\n+\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\n+\t* tree-vrp.c (stmt_interesting_for_vrp): Use new CALL_EXPR accessors.\n+\t(vrp_visit_stmt): Likewise.\n+\n+\t* tree-ssa-loop-im.c (outermost_invariant_loop_expr):  Make it\n+\tknow about tcc_vl_exp.  Use TREE_OPERAND_LENGTH instead of\n+\tTREE_CODE_LENGTH.\n+\t(force_move_till_expr): Likewise.\n+\n+\t* targhooks.c (default_external_stack_protect_fail): Use\n+\tbuild_call_expr instead of build_function_call_expr.\n+\t(default_hidden_stack_protect_fail): Likewise.\n+\n+\t* tree-complex.c (expand_complex_libcall): Use build_call_expr to\n+\tbuild the call.\n+\n+\t* cgraphbuild.c (build_cgraph_edges): Use new CALL_EXPR accessors\n+\tand walk arguments explicitly.\n+\n+\t* tree-ssa-loop-niter.c (simplify_replace_tree): Use\n+\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\t(expand_simple_operations): Likewise.\n+\t(infer_loop_bounds_from_array): Use new CALL_EXPR accessors.\n+\n+\t* gengtype.c (adjust_field_tree_exp): Use TREE_OPERAND_LENGTH instead\n+\tof TREE_CODE_LENGTH.\n+\t(walk_type): Tweak walking of arrays not to blow up on CALL_EXPRs.\n+\n+\t* optabs.c (expand_widen_pattern-expr): Use TREE_OPERAND_LENGTH\n+\tinstead of TREE_CODE_LENGTH.\n+\n+\t* value_prof.c (tree_ic): Use new CALL_EXPR accessors.\n+\t(tree_ic_transform): Likewise.\n+\t(interesting_stringop_to_profile_p): Pass entire CALL_EXPR as\n+\tparameter instead of arglist.  Fix callers.\n+\t(tree_stringop_fixed_value): Use new CALL_EXPR accessors.\n+\t(tree_stringops_transform): Likewise.\n+\t(tree_indirect_call_to_profile): Likewise.\n+\t(tree_stringops_values_to_profile): Likewise.\n+\n+\t* tree-tailcall.c (find_tail_calls): Use new CALL_EXPR iterator.\n+\t(eliminate_tail_call): Likewise.\n+\n+\t* ipa-cp.c (ipcp_update_callgraph): Use new CALL_EXPR accessors.\n+\n+\t* tree-scalar-evolution.c (chrec_contains_symbols_defined_in_loop):\n+\tUse TREE_OPERAND_LENGTH and generalize to handle any number of\n+\toperands.\n+\t(instantiate_parameters_1): Can't handle tcc_vl_exp here.\n+\n+\t* omp-low.c (build_omp_barrier): Use build_call_expr.\n+\t(lower_rec_input_clauses): Likewise.\n+\t(lower_reduction_clauses): Likewise.\n+\t(expand_parallel_call): Likewise.\n+\t(maybe_catch_exception): Likewise.\n+\t(expand_omp_for_generic): Likewise.\n+\t(expand_omp_for_static_nochunk): Likewise.\n+\t(expand_omp_sections): Likewise.\n+\t(lower_omp_single_simple): Likewise.\n+\t(lower_omp_single_copy): Likewise.\n+\t(lower_omp_master): Likewise.\n+\t(lower_omp_ordered): Likewise.\n+\t(lower_omp_critical): Likewise.\n+\n+\t* ipa-reference.c (check-call): Use new CALL_EXPR iterator.\n+\t(scan_for_static_refs): Create tcc_vl_exp case for CALL_EXPR.\n+\n+\t* tree-gimple.c (is_gimple_call_addr): Fix doc.\n+\t(recalculate_side_effects): Use TREE_OPERAND_LENGTH instead of\n+\tTREE_CODE_LENGTH.  Add tcc_vl_exp case.\n+\n+\t* tree-chrec.c (chrec_contains_symbols): Use TREE_OPERAND_LENGTH\n+\tand generalize to handle any number of operands.\n+\t(chrec_contains_undetermined): Likewise.\n+\t(tree_contains_chrecs): Likewise.\n+\t(evolution_function_is_invariant_rec_p): Use TREE_OPERAND_LENGTH.\n+\n+\t* cgraphunit.c (update_call_expr): Use new CALL_EXPR accessors.\n+\n+\t* tree-ssa-ccp.c (ccp_fold): Use new CALL_EXPR accessors.  Use\n+\tfold_call_expr instead of fold_builtin.\n+\t(ccp_fold_builtin): Likewise.  Update calls into builtins.c to\n+\tmatch declarations there.\n+\t(fold_stmt): Use new CALL_EXPR constructor and accessors.  Doc\n+\tupdates.\n+\n+\t* tree-ssa-loop-ivopts.c (expr_invariant_in_loop_p): Use\n+\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\n+\t* ipa-pure-const.c (check_call): Use new CALL_EXPR accessors.\n+\t(scan_function): Add case tcc_vl_exp for CALL_EXPR.\n+\n+\t* tree-stdarg.c (execute_optimize_stdarg): Use new CALL_EXPR\n+\taccessors.\n+\n+\t* tree-ssa-math-opts.c (execute_cse_sincos_1): Use build_call_expr.\n+\t(execute_cse_sincos): Use new CALL_EXPR accessors.\n+\n+\t* tree-ssa-alias.c (find_used_portions): Use new CALL_EXPR iterator.\n+\n+\t* gimple-low.c (lower_function_body): Use build_call_expr.\n+\t(lower_builtin_setjmp): Likewise.\n+\n+\t* expr.c (emit_block_move_via_libcall): Use build_call_expr.\n+\t(set_storage_via_libcall): Likewise.\n+\t(safe_from_p): Add tcc_vl_exp case.  Use TREE_OPERAND_LENGTH\n+\tinstead of TREE_CODE_LENGTH.\n+\t(expand_expr_real_1): Use new CALL_EXPR accessors.\n+\n+\t* tree-browser.c (store_child_info): Use TREE_OPERAND_LENGTH and\n+\tgeneralize to handle any number of operands.\n+\t(TB_parent_eq): Likewise.\n+\n+\t* predict.c (expr_expected_value): Use new CALL_EXPR accessors.\n+\t(strip_builtin_expect): Likewise.\n+\n+\t* function.c (gimplify_parameters): Use build_call_expr.\n+\n+\t* tree-vectorizer.c (vect_is_simple_reduction): Use TREE_OPERAND_LENGTH\n+\tinstead of TREE_CODE_LENGTH.\n+\n+\t* ipa-type-escape.c (check_call): Use new CALL_EXPR iterators.\n+\t(scan_for_refs): Add case tcc_vl_exp for CALL_EXPR.\n+\n+\t* tree-data-ref.c (get_references_in_stmt): Use new CALL_EXPR\n+\titerators.\n+\n+\t* gimplify.c (build_stack_save_restore): Use build_call_expr.\n+\t(gimplify_decl_expr): Likewise.\n+\t(gimplify_call_expr): Use fold_call_expr instead of fold_builtin.\n+\tUse new CALL_EXPR iterators.\n+\t(gimplify_modify_expr_to_memcpy): Use build_call_expr.\n+\t(gimplify_modify_expr_to_memset): Likewise.\n+\t(gimplify_variable_sized_compare): Likewise.\n+\t(gimplify_omp_atomic_fetch_op): Likewise.\n+\t(gimplify_omp_atomic_pipeline): Likewise.\n+\t(gimplify_omp_atomic_mutex): Likewise.\n+\t(gimplify_function_tree): Likewise.\n+\n+\t* calls.c (alloca_call_p): Use new CALL_EXPR accessors.\n+\t(call_expr_flags): Likewise.\n+\t(expand_call): Likewise.\n+\n+\t* except.c (expand_builtin_eh_return_data_regno): Pass entire\n+\tCALL_EXPR as parameter instead of arglist.  Use new CALL_EXPR \n+        accessors.\n+\n+\t* coverage.c (create_coverage): Use build_call_expr.\n+\n+\t* tree-ssa-pre.c (expression_node_pool, list_node_pool): Delete.\n+\t(temp_call_expr_obstack): New.\n+\t(pool_copy_list): Delete.\n+\t(temp_copy_call_expr): New.\n+\t(phi_translate): Add case tcc_vl_exp for CALL_EXPR.  Use new\n+\tCALL_EXPR accessors.  Get rid of special goo for copying argument\n+\tlists and use temp_copy_call_expr instead.\n+\t(valid_in_sets): Add case tcc_vl_exp for CALL_EXPR.  Use new\n+\tCALL_EXPR accessors.\n+\t(create_expression_by_pieces): Likewise.  Use build_call_array\n+\tto construct the result instead of fold_build3.\n+\t(create_value_expr_from): Add tcc_vl_exp.  Delete special goo for\n+\tdealing with argument lists.\n+\t(init_pre): Remove references to expression_node_pool and\n+\tlist_node_pool.  Init temp_call_expr_obstack instead.\n+\t(fini_pre): Remove references to expression_node_pool and\n+\tlist_node_pool.\n+\n+\t* tree-sra.c (sra_walk_call_expr): Use new CALL_EXPR accessors\n+\tand walk arguments explicitly instead of as a list.\n+\n+\t* tree-mudflap.c (mf_build_check_statement_for): Use build_call_expr.\n+\t(mx_register_decls): Likewise.\n+\t(mudflap_register_call): Likewise.\n+\t(mudflap_finish_file): Likewise.\n+\n+\t* ipa-prop.c (ipa_callsite_compute_count): Use new CALL_EXPR accessors.\n+\t(ipa_callsite_compute_param): Likewise.\n+\n+\t* tree-vect-patterns.c (vect_recog_pow_pattern): Use new CALL_EXPR\n+\taccessors and constructor.\n+\n+\t* tree-nested.c (convert_nl_goto_reference): Use new CALL_EXPR\n+\taccessors and constructor.\n+\t(convert_tramp_reference): Likewise. \n+\t(convert_call_expr): Likewise.\n+\t(finalize_nesting_tree_1): Likewise.\n+\n+\t* tree-ssa.c (tree_ssa_useless_type_conversion): Use new CALL_EXPR\n+\taccessors.\n+\n+\t* tree-ssa-loop-prefetch.c (issue_prefetch_ref): Use build_call_expr.\n+\n+\t* tree-inline.c (initialize_inlined_parameters): Pass entire\n+\tCALL_EXPR as parameter instead of arglist.  Use new CALL_EXPR\n+\taccessors.\n+\t(estimate_num_insns_1): Use new CALL_EXPR accessors.\n+\t(expand_call_inline): Tidy up call to initialize_inlined_parameters.\n+\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction):  Use\n+\tTREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\t(vectorizable_reduction): Likewise.\n+\t(vectorizable_call): Use new CALL_EXPR iterators.\n+\t(vectorizable_conversion): Use build_call_expr.\n+\t(vectorizable_operation): Use TREE_OPERAND_LENGTH.\n+\t(vect_gen_widened_results_half): Use build_call_expr.\n+\t(vect_setup_realignment): Likewise.\n+\t(vectorizable_live_operation): Use TREE_OPERAND_LENGTH.\n+\n+\t* tree-object-size.c (alloc_object_size): Use new CALL_EXPR accessors.\n+\t(pass_through_call): Likewise.\n+\t(compute_object_sizes): Likewise.  Use fold_call_expr instead of\n+\tfold_builtin.\n+\n+\t* tree-profile.c (tree_gen_interval_profiler): Use build_call_expr.\n+\t(tree_gen_pow2_profiler): Likewise.\n+\t(tree_gen_one_value_profiler): Likewise.\n+\t(tree_gen_ic_func_profiler): Likewise.\n+\t(tree_gen_average_profiler): Likewise.\n+\t(tree_gen_ior_profiler): Likewise.\n+\n+\t* tree-ssa-structalias.c (get_constraint_for): Add case tcc_vl_exp.\n+\t(find_func_aliases): Use new CALL_EXPR accessors.  Add case\n+\ttcc_vl_exp.  Use TREE_OPERAND_LENGTH instead of TREE_CODE_LENGTH.\n+\n+\t* tree-ssa-reassoc.c (get_rank): Use TREE_OPERAND_LENGTH instead\n+\tof TREE_CODE_LENGTH.\n+\n+\t* stmt.c (warn_if_unused_value): Use TREE_OPERAND_LENGTH instead\n+\tof TREE_CODE_LENGTH.\n+\n+\t* convert.c (convert_to_real): Use new CALL_EXPR accessors and\n+\tconstructor.\n+\t(convert_to_integer): Likewise.\n+\n+\t* tree-ssa-operands.c (get_call_expr_operands): Use new CALL_EXPR\n+\taccessors.\n+\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* config/alpha/alpha.c (alpha_expand_builtin): Use new CALL_EXPR\n+\taccessors.\n+\t* config/frv/frv.c (frv_expand_builtin): Likewise.\n+\t* config/s390/s390.c (s390_expand_builtin): Likewise.\n+\n+\t* config/sparc/sparc.c (sparc_gimplify_va_arg): Use build_call_expr.\n+\t(sparc_expand_builtin): Use new CALL_EXPR accessors.\n+\n+\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Likewise.\n+\t(ix86_expand_binop_builtin): Pass entire CALL_EXPR as parameter\n+\tinstead of arglist.  Use new CALL_EXPR accessors on it.  Fix callers.\n+\t(ix86_expand_store_builtin): Likewise.\n+\t(ix86_expand_unop_builtin): Likewise.\n+\t(ix86_expand_unop1_builtin): Likewise.\n+\t(ix86_expand_sse_compare): Likewise.\n+\t(ix86_expand_sse_comi): Likewise.\n+\t(ix86_expand_vec_init_builtin): Likewise.\n+\t(ix86_expand_vec_ext_builtin): Likewise.\n+\t(ix86_expand_vec_set_builtin): Likewise.\n+\t(ix86_expand_builtin): Use new CALL_EXPR accessors.\n+\n+\t* config/sh/sh.c (sh_expand_builtin): Use new CALL_EXPR accessors.\n+\t* config/c4x/c4x.c (c4x_expand_builtin): Likewise.\n+\n+\t* config/iq2000/iq2000.c (expand_one_builtin): Pass entire CALL_EXPR\n+\tinstead of arglist.  Use new CALL_EXPR accessors.  Fix callers.\n+\t(iq2000_expand_builtin): Use new CALL_EXPR accessors.\n+\n+\t* config/rs6000/rs6000-c.c (altivec_build_resolved_builtin): Use\n+\tbuild_call_expr.\n+\t* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Likewise.\n+\t(rs6000_expand_unop_builtin): Pass entire CALL_EXPR instead of\n+\targlist.  Use new CALL_EXPR accessors.  Fix callers.\n+\t(altivec_expand_abs_builtin): Likewise.\n+\t(rs6000_expand_binop_builtin): Likewise.\n+\t(altivec_expand_predicate_builtin): Likewise.\n+\t(altivec_expand_lv_builtin): Likewise.\n+\t(spe_expand_stv_builtin): Likewise.\n+\t(altivec_expand_stv_builtin): Likewise.\n+\t(rs6000_expand_ternop_builtin): Likewise.\n+\t(altivec_expand_ld_builtin): Use new CALL_EXPR accessors.\n+\t(altivec_expand_st_builtin): Likewise.\n+\t(altivec_expand_dst_builtin): Likewise.\n+\t(altivec_expand_vec_init_builtin): Pass entire CALL_EXPR instead of\n+\targlist.  Use new CALL_EXPR accessors.  Fix callers.\n+\t(altivec_expand_vec_set_builtin): Likewise.\n+\t(altivec_expand_vec_ext_builtin): Likewise.\n+\t(altivec_expand_builtin): Use new CALL_EXPR accessors.\n+\t(spe_expand_builtin): Likewise.\n+\t(spe_expand_predicate_builtin): Pass entire CALL_EXPR instead of\n+\targlist.  Use new CALL_EXPR accessors.  Fix callers.\n+\t(spe_expand_evsel_builtin): Likewise.\n+\t(rs6000_expand_builtin): Use new CALL_EXPR accessors.  VCFUX and\n+\tFCFSX cases must construct whole new CALL_EXPR, not just arglist.\n+\n+\t* config/arm/arm.c (arm_expand_binop_builtin): Pass entire CALL_EXPR\n+\tinstead of arglist.  Use new CALL_EXPR accessors.  Fix callers.\n+\t(arm_expand_unop_builtin): Likewise.\n+\t(arm_expand_builtin): Use new CALL_EXPR accessors.\n+\n+\t* config/mips/mips.c (mips_expand_builtin):  Use new CALL_EXPR\n+\taccessors.\n+\n+\t* config/bfin/bfin.c (bfin_expand_binop_builtin): Pass entire CALL_EXPR\n+\tinstead of arglist.  Use new CALL_EXPR accessors.  Fix callers.\n+\t(bfin_expand_unop_builtin): Likewise.\n+\t(bfin_expand_builtin): Use new CALL_EXPR accessors.\n+\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* c-semantics.c (build_stmt): Add internal diagnostic check.\n+\n+\t* c-pretty-print.c (pp_c_postfix_expression): Use new CALL_EXPR\n+\taccessors.  Print arguments explicitly instead of as a list.\n+\n+\t* c-typeck.c (build_function_call): Use new CALL_EXPR constructors.\n+\n+\t* c-omp.c (c_finish_omp_barrier): Use build_call_expr.\n+\t(c_finish_omp_flish): Likewise.\n+\n+\t* c-common.c (verify_tree): Use new CALL_EXPR accessors.  Traverse\n+\targuments explicitly instead of as a list.  Use TREE_OPERAND_LENGTH\n+\tinstead of TREE_CODE_LENGTH.\n+\t(check_function_arguments_recurse): Use new CALL_EXPR accessors.\n+\t(c_warn_unused_result): Likewise.\n+\n 2007-02-15  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c/26494"}, {"sha": "ac1e1b4a0584d902acfe7a52fa6610128293fa1b", "filename": "gcc/builtins.c", "status": "modified", "additions": 2267, "deletions": 2258, "changes": 4525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9"}, {"sha": "d9a826d1d96980c5ce19a012ff4cb43b067b81c3", "filename": "gcc/c-common.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1576,16 +1576,23 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n       /* We need to warn about conflicts among arguments and conflicts between\n \t args and the function address.  Side effects of the function address,\n \t however, are not ordered by the sequence point of the call.  */\n-      tmp_before = tmp_nosp = tmp_list2 = tmp_list3 = 0;\n-      verify_tree (TREE_OPERAND (x, 0), &tmp_before, &tmp_nosp, NULL_TREE);\n-      if (TREE_OPERAND (x, 1))\n-\tverify_tree (TREE_OPERAND (x, 1), &tmp_list2, &tmp_list3, NULL_TREE);\n-      merge_tlist (&tmp_list3, tmp_list2, 0);\n-      add_tlist (&tmp_before, tmp_list3, NULL_TREE, 0);\n-      add_tlist (&tmp_before, tmp_nosp, NULL_TREE, 0);\n-      warn_for_collisions (tmp_before);\n-      add_tlist (pbefore_sp, tmp_before, NULL_TREE, 0);\n-      return;\n+      {\n+\tcall_expr_arg_iterator iter;\n+\ttree arg;\n+\ttmp_before = tmp_nosp = 0; \n+\tverify_tree (CALL_EXPR_FN (x), &tmp_before, &tmp_nosp, NULL_TREE);\n+\tFOR_EACH_CALL_EXPR_ARG (arg, iter, x)\n+\t  {\n+\t    tmp_list2 = tmp_list3 = 0;\n+\t    verify_tree (arg, &tmp_list2, &tmp_list3, NULL_TREE);\n+\t    merge_tlist (&tmp_list3, tmp_list2, 0);\n+\t    add_tlist (&tmp_before, tmp_list3, NULL_TREE, 0);\n+\t  }\n+\tadd_tlist (&tmp_before, tmp_nosp, NULL_TREE, 0);\n+\twarn_for_collisions (tmp_before);\n+\tadd_tlist (pbefore_sp, tmp_before, NULL_TREE, 0);\n+\treturn;\n+      }\n \n     case TREE_LIST:\n       /* Scan all the list, e.g. indices of multi dimensional array.  */\n@@ -1645,7 +1652,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n       else if (IS_EXPR_CODE_CLASS (cl))\n \t{\n \t  int lp;\n-\t  int max = TREE_CODE_LENGTH (TREE_CODE (x));\n+\t  int max = TREE_OPERAND_LENGTH (x);\n \t  for (lp = 0; lp < max; lp++)\n \t    {\n \t      tmp_before = tmp_nosp = 0;\n@@ -5940,7 +5947,7 @@ check_function_arguments_recurse (void (*callback)\n \n   if (TREE_CODE (param) == CALL_EXPR)\n     {\n-      tree type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (param, 0)));\n+      tree type = TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (param)));\n       tree attrs;\n       bool found_format_arg = false;\n \n@@ -5953,10 +5960,11 @@ check_function_arguments_recurse (void (*callback)\n \t   attrs = TREE_CHAIN (attrs))\n \tif (is_attribute_p (\"format_arg\", TREE_PURPOSE (attrs)))\n \t  {\n-\t    tree inner_args;\n+\t    tree inner_arg;\n \t    tree format_num_expr;\n \t    int format_num;\n \t    int i;\n+\t    call_expr_arg_iterator iter;\n \n \t    /* Extract the argument number, which was previously checked\n \t       to be valid.  */\n@@ -5967,14 +5975,13 @@ check_function_arguments_recurse (void (*callback)\n \n \t    format_num = TREE_INT_CST_LOW (format_num_expr);\n \n-\t    for (inner_args = TREE_OPERAND (param, 1), i = 1;\n-\t\t inner_args != 0;\n-\t\t inner_args = TREE_CHAIN (inner_args), i++)\n+\t    for (inner_arg = first_call_expr_arg (param, &iter), i = 1;\n+\t\t inner_arg != 0;\n+\t\t inner_arg = next_call_expr_arg (&iter), i++)\n \t      if (i == format_num)\n \t\t{\n \t\t  check_function_arguments_recurse (callback, ctx,\n-\t\t\t\t\t\t    TREE_VALUE (inner_args),\n-\t\t\t\t\t\t    param_num);\n+\t\t\t\t\t\t    inner_arg, param_num);\n \t\t  found_format_arg = true;\n \t\t  break;\n \t\t}\n@@ -6191,7 +6198,7 @@ c_warn_unused_result (tree *top_p)\n \tftype = TREE_TYPE (fdecl);\n       else\n \t{\n-\t  ftype = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t  ftype = TREE_TYPE (CALL_EXPR_FN (t));\n \t  /* Look past pointer-to-function to the function type itself.  */\n \t  ftype = TREE_TYPE (ftype);\n \t}"}, {"sha": "115d7811d1ef1aa6ae3bcf7da46d289fb0713858", "filename": "gcc/c-omp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -76,7 +76,7 @@ c_finish_omp_barrier (void)\n   tree x;\n \n   x = built_in_decls[BUILT_IN_GOMP_BARRIER];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (x, 0);\n   add_stmt (x);\n }\n \n@@ -150,7 +150,7 @@ c_finish_omp_flush (void)\n   tree x;\n \n   x = built_in_decls[BUILT_IN_SYNCHRONIZE];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (x, 0);\n   add_stmt (x);\n }\n "}, {"sha": "b69f0da29ff21fe445d8178809fbdc21b20bc78e", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1270,9 +1270,20 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case CALL_EXPR:\n-      pp_postfix_expression (pp, TREE_OPERAND (e, 0));\n-      pp_c_call_argument_list (pp, TREE_OPERAND (e, 1));\n-      break;\n+      {\n+\tcall_expr_arg_iterator iter;\n+\ttree arg;\n+\tpp_postfix_expression (pp, CALL_EXPR_FN (e));\n+\tpp_c_left_paren (pp);\n+\tFOR_EACH_CALL_EXPR_ARG (arg, iter, e)\n+\t  {\n+\t    pp_expression (pp, arg);\n+\t    if (more_call_expr_args_p (&iter))\n+\t      pp_separate_with (pp, ',');\n+\t  }\n+\tpp_c_right_paren (pp);\n+\tbreak;\n+      }\n \n     case UNORDERED_EXPR:\n       pp_c_identifier (pp, flag_isoc99\n@@ -1419,7 +1430,8 @@ pp_c_constructor_elts (c_pretty_printer *pp, VEC(constructor_elt,gc) *v)\n     }\n }\n \n-/* Print out an expression-list in parens, as in a function call.  */\n+/* Print out an expression-list in parens, as if it were the argument\n+   list to a function.  */\n \n void\n pp_c_call_argument_list (c_pretty_printer *pp, tree t)"}, {"sha": "7b1f83b358c2dbabf421cba9a6ffea7777eaeea4", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -115,6 +115,9 @@ build_stmt (enum tree_code code, ...)\n   va_list p;\n   bool side_effects;\n \n+  /* This function cannot be used to construct variably-sized nodes.  */\n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n   va_start (p, code);\n \n   ret = make_node (code);"}, {"sha": "f6ba19e2842505dcddc73b262d9f7e7e7454f12d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2330,17 +2330,17 @@ build_function_call (tree function, tree params)\n \n   if (require_constant_value)\n     {\n-      result = fold_build3_initializer (CALL_EXPR, TREE_TYPE (fntype),\n-\t\t\t\t\tfunction, coerced_params, NULL_TREE);\n-\n+      result = fold_build_call_list_initializer (TREE_TYPE (fntype),\n+\t\t\t\t\t\t function,\n+\t\t\t\t\t\t coerced_params);\n       if (TREE_CONSTANT (result)\n \t  && (name == NULL_TREE\n \t      || strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10) != 0))\n \tpedwarn_init (\"initializer element is not constant\");\n     }\n   else\n-    result = fold_build3 (CALL_EXPR, TREE_TYPE (fntype),\n-\t\t\t  function, coerced_params, NULL_TREE);\n+    result = fold_build_call_list (TREE_TYPE (fntype),\n+\t\t\t\t   function, coerced_params);\n \n   if (VOID_TYPE_P (TREE_TYPE (result)))\n     return result;"}, {"sha": "d84eb51aa3631a1dea087021cbbed626bcee814b", "filename": "gcc/calls.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -553,11 +553,10 @@ bool\n alloca_call_p (tree exp)\n {\n   if (TREE_CODE (exp) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t  == FUNCTION_DECL)\n-      && (special_function_p (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t      0) & ECF_MAY_BE_ALLOCA))\n+      && TREE_CODE (CALL_EXPR_FN (exp)) == ADDR_EXPR\n+      && (TREE_CODE (TREE_OPERAND (CALL_EXPR_FN (exp), 0)) == FUNCTION_DECL)\n+      && (special_function_p (TREE_OPERAND (CALL_EXPR_FN (exp), 0), 0)\n+\t  & ECF_MAY_BE_ALLOCA))\n     return true;\n   return false;\n }\n@@ -626,7 +625,7 @@ call_expr_flags (tree t)\n     flags = flags_from_decl_or_type (decl);\n   else\n     {\n-      t = TREE_TYPE (TREE_OPERAND (t, 0));\n+      t = TREE_TYPE (CALL_EXPR_FN (t));\n       if (t && TREE_CODE (t) == POINTER_TYPE)\n \tflags = flags_from_decl_or_type (TREE_TYPE (t));\n       else\n@@ -1280,7 +1279,8 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n    compute and return the final value for MUST_PREALLOCATE.  */\n \n static int\n-finalize_must_preallocate (int must_preallocate, int num_actuals, struct arg_data *args, struct args_size *args_size)\n+finalize_must_preallocate (int must_preallocate, int num_actuals, \n+\t\t\t   struct arg_data *args, struct args_size *args_size)\n {\n   /* See if we have or want to preallocate stack space.\n \n@@ -1809,7 +1809,7 @@ shift_return_value (enum machine_mode mode, bool left_p, rtx value)\n   return true;\n }\n \n-/* Generate all the code for a function call\n+/* Generate all the code for a CALL_EXPR exp\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n    If the value is stored in TARGET then TARGET is returned.\n@@ -1822,7 +1822,8 @@ expand_call (tree exp, rtx target, int ignore)\n   static int currently_expanding_call = 0;\n \n   /* List of actual parameters.  */\n-  tree actparms = TREE_OPERAND (exp, 1);\n+  /* FIXME: rewrite this so that it doesn't cons up a TREE_LIST.  */\n+  tree actparms = CALL_EXPR_ARGS (exp);\n   /* RTX for the function to be called.  */\n   rtx funexp;\n   /* Sequence of insns to perform a normal \"call\".  */\n@@ -1923,8 +1924,8 @@ expand_call (tree exp, rtx target, int ignore)\n   int old_stack_pointer_delta = 0;\n \n   rtx call_fusage;\n-  tree p = TREE_OPERAND (exp, 0);\n-  tree addr = TREE_OPERAND (exp, 0);\n+  tree p = CALL_EXPR_FN (exp);\n+  tree addr = CALL_EXPR_FN (exp);\n   int i;\n   /* The alignment of the stack, in bits.  */\n   unsigned HOST_WIDE_INT preferred_stack_boundary;\n@@ -2585,8 +2586,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t once we have started filling any specific hard regs.  */\n       precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n \n-      if (TREE_OPERAND (exp, 2))\n-\tstatic_chain_value = expand_normal (TREE_OPERAND (exp, 2));\n+      if (CALL_EXPR_STATIC_CHAIN (exp))\n+\tstatic_chain_value = expand_normal (CALL_EXPR_STATIC_CHAIN (exp));\n       else\n \tstatic_chain_value = 0;\n "}, {"sha": "ec4e356c8c271bf3c731fa20bc37f08cc0b78450", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -131,15 +131,18 @@ build_cgraph_edges (void)\n \n \tif (call && (decl = get_callee_fndecl (call)))\n \t  {\n+\t    int i;\n+\t    int n = call_expr_nargs (call);\n \t    int freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n \t\t\t: bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n \t    if (freq > CGRAPH_FREQ_MAX)\n \t      freq = CGRAPH_FREQ_MAX;\n \t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n \t\t\t\tbb->count, freq,\n \t\t\t\tbb->loop_depth);\n-\t    walk_tree (&TREE_OPERAND (call, 1),\n-\t\t       record_reference, node, visited_nodes);\n+\t    for (i = 0; i < n; i++)\n+\t      walk_tree (&CALL_EXPR_ARG (call, i),\n+\t\t\t record_reference, node, visited_nodes);\n \t    if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n \t      walk_tree (&GIMPLE_STMT_OPERAND (stmt, 0),\n \t\t\t record_reference, node, visited_nodes);"}, {"sha": "16c34aecfeb5b72c68a01f54a36ead22ff46d1a8", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1402,7 +1402,7 @@ update_call_expr (struct cgraph_node *new_version)\n   for (e = new_version->callers; e; e = e->next_caller)\n     /* Update the call expr on the edges\n        to call the new version.  */\n-    TREE_OPERAND (TREE_OPERAND (get_call_expr_in (e->call_stmt), 0), 0) = new_version->decl;\n+    TREE_OPERAND (CALL_EXPR_FN (get_call_expr_in (e->call_stmt)), 0) = new_version->decl;\n }\n \n "}, {"sha": "dcaa647047aba6fcaa9fd886546b1b49e246696b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -6500,9 +6500,10 @@ alpha_expand_builtin (tree exp, rtx target,\n {\n #define MAX_ARGS 2\n \n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg;\n+  call_expr_arg_iterator iter;\n   enum insn_code icode;\n   rtx op[MAX_ARGS], pat;\n   int arity;\n@@ -6516,13 +6517,11 @@ alpha_expand_builtin (tree exp, rtx target,\n \n   nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n \n-  for (arglist = TREE_OPERAND (exp, 1), arity = 0;\n-       arglist;\n-       arglist = TREE_CHAIN (arglist), arity++)\n+  arity = 0;\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n     {\n       const struct insn_operand_data *insn_op;\n \n-      tree arg = TREE_VALUE (arglist);\n       if (arg == error_mark_node)\n \treturn NULL_RTX;\n       if (arity > MAX_ARGS)\n@@ -6534,6 +6533,7 @@ alpha_expand_builtin (tree exp, rtx target,\n \n       if (!(*insn_op->predicate) (op[arity], insn_op->mode))\n \top[arity] = copy_to_mode_reg (insn_op->mode, op[arity]);\n+      arity++;\n     }\n \n   if (nonvoid)"}, {"sha": "5c47533e6aaa2c4f901c1f51f0ed64911c122338", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -13341,11 +13341,11 @@ safe_vector_operand (rtx x, enum machine_mode mode)\n \n static rtx\n arm_expand_binop_builtin (enum insn_code icode,\n-\t\t\t  tree arglist, rtx target)\n+\t\t\t  tree exp, rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n@@ -13380,10 +13380,10 @@ arm_expand_binop_builtin (enum insn_code icode,\n \n static rtx\n arm_expand_unop_builtin (enum insn_code icode,\n-\t\t\t tree arglist, rtx target, int do_load)\n+\t\t\t tree exp, rtx target, int do_load)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -13425,8 +13425,7 @@ arm_expand_builtin (tree exp,\n {\n   const struct builtin_description * d;\n   enum insn_code    icode;\n-  tree              fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree              arglist = TREE_OPERAND (exp, 1);\n+  tree              fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   tree              arg0;\n   tree              arg1;\n   tree              arg2;\n@@ -13455,8 +13454,8 @@ arm_expand_builtin (tree exp,\n \t       : fcode == ARM_BUILTIN_TEXTRMUH ? CODE_FOR_iwmmxt_textrmuh\n \t       : CODE_FOR_iwmmxt_textrmw);\n \n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       tmode = insn_data[icode].operand[0].mode;\n@@ -13487,9 +13486,9 @@ arm_expand_builtin (tree exp,\n       icode = (fcode == ARM_BUILTIN_TINSRB ? CODE_FOR_iwmmxt_tinsrb\n \t       : fcode == ARM_BUILTIN_TINSRH ? CODE_FOR_iwmmxt_tinsrh\n \t       : CODE_FOR_iwmmxt_tinsrw);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -13519,24 +13518,24 @@ arm_expand_builtin (tree exp,\n       return target;\n \n     case ARM_BUILTIN_SETWCX:\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = force_reg (SImode, expand_normal (arg0));\n       op1 = expand_normal (arg1);\n       emit_insn (gen_iwmmxt_tmcr (op1, op0));\n       return 0;\n \n     case ARM_BUILTIN_GETWCX:\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       op0 = expand_normal (arg0);\n       target = gen_reg_rtx (SImode);\n       emit_insn (gen_iwmmxt_tmrc (target, op0));\n       return target;\n \n     case ARM_BUILTIN_WSHUFH:\n       icode = CODE_FOR_iwmmxt_wshufh;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       tmode = insn_data[icode].operand[0].mode;\n@@ -13562,13 +13561,13 @@ arm_expand_builtin (tree exp,\n       return target;\n \n     case ARM_BUILTIN_WSADB:\n-      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadb, arglist, target);\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadb, exp, target);\n     case ARM_BUILTIN_WSADH:\n-      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadh, arglist, target);\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadh, exp, target);\n     case ARM_BUILTIN_WSADBZ:\n-      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadbz, arglist, target);\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadbz, exp, target);\n     case ARM_BUILTIN_WSADHZ:\n-      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadhz, arglist, target);\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadhz, exp, target);\n \n       /* Several three-argument builtins.  */\n     case ARM_BUILTIN_WMACS:\n@@ -13589,9 +13588,9 @@ arm_expand_builtin (tree exp,\n \t       : fcode == ARM_BUILTIN_TMIATB ? CODE_FOR_iwmmxt_tmiatb\n \t       : fcode == ARM_BUILTIN_TMIATT ? CODE_FOR_iwmmxt_tmiatt\n \t       : CODE_FOR_iwmmxt_walign);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -13630,11 +13629,11 @@ arm_expand_builtin (tree exp,\n \n   for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n     if (d->code == (const enum arm_builtins) fcode)\n-      return arm_expand_binop_builtin (d->icode, arglist, target);\n+      return arm_expand_binop_builtin (d->icode, exp, target);\n \n   for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n     if (d->code == (const enum arm_builtins) fcode)\n-      return arm_expand_unop_builtin (d->icode, arglist, target, 0);\n+      return arm_expand_unop_builtin (d->icode, exp, target, 0);\n \n   /* @@@ Should really do something sensible here.  */\n   return NULL_RTX;"}, {"sha": "7f964638742178b5be401365b105ec93580cbf51", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -4617,12 +4617,12 @@ safe_vector_operand (rtx x, enum machine_mode mode)\n    if this is a normal binary op, or one of the MACFLAG_xxx constants.  */\n \n static rtx\n-bfin_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target,\n+bfin_expand_binop_builtin (enum insn_code icode, tree exp, rtx target,\n \t\t\t   int macflag)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n   rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n   enum machine_mode op0mode = GET_MODE (op0);\n@@ -4675,11 +4675,11 @@ bfin_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target,\n /* Subroutine of bfin_expand_builtin to take care of unop insns.  */\n \n static rtx\n-bfin_expand_unop_builtin (enum insn_code icode, tree arglist,\n+bfin_expand_unop_builtin (enum insn_code icode, tree exp,\n \t\t\t  rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n   enum machine_mode op0mode = GET_MODE (op0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n@@ -4725,8 +4725,7 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n   size_t i;\n   enum insn_code icode;\n   const struct builtin_description *d;\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree arg0, arg1, arg2;\n   rtx op0, op1, op2, accvec, pat, tmp1, tmp2;\n@@ -4743,7 +4742,7 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \n     case BFIN_BUILTIN_DIFFHL_2X16:\n     case BFIN_BUILTIN_DIFFLH_2X16:\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n       icode = (fcode == BFIN_BUILTIN_DIFFHL_2X16\n \t       ? CODE_FOR_subhilov2hi3 : CODE_FOR_sublohiv2hi3);\n@@ -4768,8 +4767,8 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       return target;\n \n     case BFIN_BUILTIN_CPLX_MUL_16:\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n       op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n       accvec = gen_reg_rtx (V2PDImode);\n@@ -4795,9 +4794,9 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \n     case BFIN_BUILTIN_CPLX_MAC_16:\n     case BFIN_BUILTIN_CPLX_MSU_16:\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n       op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n       op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n@@ -4838,12 +4837,12 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \n   for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n     if (d->code == fcode)\n-      return bfin_expand_binop_builtin (d->icode, arglist, target,\n+      return bfin_expand_binop_builtin (d->icode, exp, target,\n \t\t\t\t\td->macflag);\n \n   for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n     if (d->code == fcode)\n-      return bfin_expand_unop_builtin (d->icode, arglist, target);\n+      return bfin_expand_unop_builtin (d->icode, exp, target);\n \n   gcc_unreachable ();\n }"}, {"sha": "ce0f706c2a8e531eb1a7de86409fbbb7c91801d5", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -4395,24 +4395,23 @@ c4x_expand_builtin (tree exp, rtx target,\n \t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    int ignore ATTRIBUTE_UNUSED)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree arglist = TREE_OPERAND (exp, 1);\n   tree arg0, arg1;\n   rtx r0, r1;\n \n   switch (fcode)\n     {\n     case C4X_BUILTIN_FIX:\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n       if (! target || ! register_operand (target, QImode))\n \ttarget = gen_reg_rtx (QImode);\n       emit_insn (gen_fixqfqi_clobber (target, r0));\n       return target;\n \n     case C4X_BUILTIN_FIX_ANSI:\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n       if (! target || ! register_operand (target, QImode))\n \ttarget = gen_reg_rtx (QImode);\n@@ -4422,8 +4421,8 @@ c4x_expand_builtin (tree exp, rtx target,\n     case C4X_BUILTIN_MPYI:\n       if (! TARGET_C3X)\n \tbreak;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       r0 = expand_expr (arg0, NULL_RTX, QImode, 0);\n       r1 = expand_expr (arg1, NULL_RTX, QImode, 0);\n       if (! target || ! register_operand (target, QImode))\n@@ -4434,7 +4433,7 @@ c4x_expand_builtin (tree exp, rtx target,\n     case C4X_BUILTIN_TOIEEE:\n       if (TARGET_C3X)\n \tbreak;\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n       if (! target || ! register_operand (target, QFmode))\n \ttarget = gen_reg_rtx (QFmode);\n@@ -4444,7 +4443,7 @@ c4x_expand_builtin (tree exp, rtx target,\n     case C4X_BUILTIN_FRIEEE:\n       if (TARGET_C3X)\n \tbreak;\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n       if (register_operand (r0, QFmode))\n \t{\n@@ -4460,7 +4459,7 @@ c4x_expand_builtin (tree exp, rtx target,\n     case C4X_BUILTIN_RCPF:\n       if (TARGET_C3X)\n \tbreak;\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n       if (! target || ! register_operand (target, QFmode))\n \ttarget = gen_reg_rtx (QFmode);"}, {"sha": "b8701a527d71e3c917b24d823c144957e511f182", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -9216,8 +9216,9 @@ frv_expand_builtin (tree exp,\n                     enum machine_mode mode ATTRIBUTE_UNUSED,\n                     int ignore ATTRIBUTE_UNUSED)\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  /* FIXME:  Pass the CALL_EXPR directly instead of consing up an arglist.  */\n+  tree arglist = CALL_EXPR_ARGS (exp);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned fcode = (unsigned)DECL_FUNCTION_CODE (fndecl);\n   unsigned i;\n   struct builtin_description *d;"}, {"sha": "ff5766c84b335fd8acfea134fe9ef5a3d86d5085", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 113, "deletions": 115, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2695,7 +2695,7 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n     func = decl;\n   else\n     {\n-      func = TREE_TYPE (TREE_OPERAND (exp, 0));\n+      func = TREE_TYPE (CALL_EXPR_FN (exp));\n       if (POINTER_TYPE_P (func))\n         func = TREE_TYPE (func);\n     }\n@@ -2730,7 +2730,7 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n       tree type;\n \n       /* We're looking at the CALL_EXPR, we need the type of the function.  */\n-      type = TREE_OPERAND (exp, 0);\t\t/* pointer expression */\n+      type = CALL_EXPR_FN (exp);\t\t/* pointer expression */\n       type = TREE_TYPE (type);\t\t\t/* pointer type */\n       type = TREE_TYPE (type);\t\t\t/* function type */\n \n@@ -17254,11 +17254,11 @@ safe_vector_operand (rtx x, enum machine_mode mode)\n /* Subroutine of ix86_expand_builtin to take care of binop insns.  */\n \n static rtx\n-ix86_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n+ix86_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat, xops[3];\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n@@ -17322,11 +17322,11 @@ ix86_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n /* Subroutine of ix86_expand_builtin to take care of stores.  */\n \n static rtx\n-ix86_expand_store_builtin (enum insn_code icode, tree arglist)\n+ix86_expand_store_builtin (enum insn_code icode, tree exp)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n@@ -17347,11 +17347,11 @@ ix86_expand_store_builtin (enum insn_code icode, tree arglist)\n /* Subroutine of ix86_expand_builtin to take care of unop insns.  */\n \n static rtx\n-ix86_expand_unop_builtin (enum insn_code icode, tree arglist,\n+ix86_expand_unop_builtin (enum insn_code icode, tree exp,\n \t\t\t  rtx target, int do_load)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -17383,10 +17383,10 @@ ix86_expand_unop_builtin (enum insn_code icode, tree arglist,\n    sqrtss, rsqrtss, rcpss.  */\n \n static rtx\n-ix86_expand_unop1_builtin (enum insn_code icode, tree arglist, rtx target)\n+ix86_expand_unop1_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op1, op0 = expand_normal (arg0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -17417,12 +17417,12 @@ ix86_expand_unop1_builtin (enum insn_code icode, tree arglist, rtx target)\n /* Subroutine of ix86_expand_builtin to take care of comparison insns.  */\n \n static rtx\n-ix86_expand_sse_compare (const struct builtin_description *d, tree arglist,\n+ix86_expand_sse_compare (const struct builtin_description *d, tree exp,\n \t\t\t rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2;\n@@ -17469,12 +17469,12 @@ ix86_expand_sse_compare (const struct builtin_description *d, tree arglist,\n /* Subroutine of ix86_expand_builtin to take care of comi insns.  */\n \n static rtx\n-ix86_expand_sse_comi (const struct builtin_description *d, tree arglist,\n+ix86_expand_sse_comi (const struct builtin_description *d, tree exp,\n \t\t      rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2;\n@@ -17549,23 +17549,22 @@ get_element_number (tree vec_type, tree arg)\n    these sorts of instructions.  */\n \n static rtx\n-ix86_expand_vec_init_builtin (tree type, tree arglist, rtx target)\n+ix86_expand_vec_init_builtin (tree type, tree exp, rtx target)\n {\n   enum machine_mode tmode = TYPE_MODE (type);\n   enum machine_mode inner_mode = GET_MODE_INNER (tmode);\n   int i, n_elt = GET_MODE_NUNITS (tmode);\n   rtvec v = rtvec_alloc (n_elt);\n \n   gcc_assert (VECTOR_MODE_P (tmode));\n+  gcc_assert (call_expr_nargs (exp) == n_elt);\n \n-  for (i = 0; i < n_elt; ++i, arglist = TREE_CHAIN (arglist))\n+  for (i = 0; i < n_elt; ++i)\n     {\n-      rtx x = expand_normal (TREE_VALUE (arglist));\n+      rtx x = expand_normal (CALL_EXPR_ARG (exp, i));\n       RTVEC_ELT (v, i) = gen_lowpart (inner_mode, x);\n     }\n \n-  gcc_assert (arglist == NULL);\n-\n   if (!target || !register_operand (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n@@ -17578,15 +17577,15 @@ ix86_expand_vec_init_builtin (tree type, tree arglist, rtx target)\n    had a language-level syntax for referencing vector elements.  */\n \n static rtx\n-ix86_expand_vec_ext_builtin (tree arglist, rtx target)\n+ix86_expand_vec_ext_builtin (tree exp, rtx target)\n {\n   enum machine_mode tmode, mode0;\n   tree arg0, arg1;\n   int elt;\n   rtx op0;\n \n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n \n   op0 = expand_normal (arg0);\n   elt = get_element_number (TREE_TYPE (arg0), arg1);\n@@ -17610,16 +17609,16 @@ ix86_expand_vec_ext_builtin (tree arglist, rtx target)\n    a language-level syntax for referencing vector elements.  */\n \n static rtx\n-ix86_expand_vec_set_builtin (tree arglist)\n+ix86_expand_vec_set_builtin (tree exp)\n {\n   enum machine_mode tmode, mode1;\n   tree arg0, arg1, arg2;\n   int elt;\n   rtx op0, op1;\n \n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n+  arg2 = CALL_EXPR_ARG (exp, 2);\n \n   tmode = TYPE_MODE (TREE_TYPE (arg0));\n   mode1 = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n@@ -17654,8 +17653,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   const struct builtin_description *d;\n   size_t i;\n   enum insn_code icode;\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   tree arg0, arg1, arg2, arg3;\n   rtx op0, op1, op2, op3, pat;\n   enum machine_mode tmode, mode0, mode1, mode2, mode3, mode4;\n@@ -17677,9 +17675,9 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t       ? CODE_FOR_mmx_maskmovq\n \t       : CODE_FOR_sse2_maskmovdqu);\n       /* Note the arg order is different from the operand order.  */\n-      arg1 = TREE_VALUE (arglist);\n-      arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg0 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg1 = CALL_EXPR_ARG (exp, 0);\n+      arg2 = CALL_EXPR_ARG (exp, 1);\n+      arg0 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -17703,17 +17701,17 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return 0;\n \n     case IX86_BUILTIN_SQRTSS:\n-      return ix86_expand_unop1_builtin (CODE_FOR_sse_vmsqrtv4sf2, arglist, target);\n+      return ix86_expand_unop1_builtin (CODE_FOR_sse_vmsqrtv4sf2, exp, target);\n     case IX86_BUILTIN_RSQRTSS:\n-      return ix86_expand_unop1_builtin (CODE_FOR_sse_vmrsqrtv4sf2, arglist, target);\n+      return ix86_expand_unop1_builtin (CODE_FOR_sse_vmrsqrtv4sf2, exp, target);\n     case IX86_BUILTIN_RCPSS:\n-      return ix86_expand_unop1_builtin (CODE_FOR_sse_vmrcpv4sf2, arglist, target);\n+      return ix86_expand_unop1_builtin (CODE_FOR_sse_vmrcpv4sf2, exp, target);\n \n     case IX86_BUILTIN_LOADUPS:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse_movups, arglist, target, 1);\n+      return ix86_expand_unop_builtin (CODE_FOR_sse_movups, exp, target, 1);\n \n     case IX86_BUILTIN_STOREUPS:\n-      return ix86_expand_store_builtin (CODE_FOR_sse_movups, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movups, exp);\n \n     case IX86_BUILTIN_LOADHPS:\n     case IX86_BUILTIN_LOADLPS:\n@@ -17723,8 +17721,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t       : fcode == IX86_BUILTIN_LOADLPS ? CODE_FOR_sse_loadlps\n \t       : fcode == IX86_BUILTIN_LOADHPD ? CODE_FOR_sse2_loadhpd\n \t       : CODE_FOR_sse2_loadlpd);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       tmode = insn_data[icode].operand[0].mode;\n@@ -17747,8 +17745,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_STORELPS:\n       icode = (fcode == IX86_BUILTIN_STOREHPS ? CODE_FOR_sse_storehps\n \t       : CODE_FOR_sse_storelps);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       mode0 = insn_data[icode].operand[0].mode;\n@@ -17764,12 +17762,12 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return const0_rtx;\n \n     case IX86_BUILTIN_MOVNTPS:\n-      return ix86_expand_store_builtin (CODE_FOR_sse_movntv4sf, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movntv4sf, exp);\n     case IX86_BUILTIN_MOVNTQ:\n-      return ix86_expand_store_builtin (CODE_FOR_sse_movntdi, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse_movntdi, exp);\n \n     case IX86_BUILTIN_LDMXCSR:\n-      op0 = expand_normal (TREE_VALUE (arglist));\n+      op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n       target = assign_386_stack_local (SImode, SLOT_TEMP);\n       emit_move_insn (target, op0);\n       emit_insn (gen_sse_ldmxcsr (target));\n@@ -17785,9 +17783,9 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       icode = (fcode == IX86_BUILTIN_SHUFPS\n \t       ? CODE_FOR_sse_shufps\n \t       : CODE_FOR_sse2_shufpd);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -17825,8 +17823,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t       : fcode == IX86_BUILTIN_PSHUFLW ? CODE_FOR_sse2_pshuflw\n \t       : fcode == IX86_BUILTIN_PSHUFD ? CODE_FOR_sse2_pshufd\n \t       : CODE_FOR_mmx_pshufw);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       tmode = insn_data[icode].operand[0].mode;\n@@ -17855,8 +17853,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_PSRLDQI128:\n       icode = (  fcode == IX86_BUILTIN_PSLLDQI128 ? CODE_FOR_sse2_ashlti3\n \t       : CODE_FOR_sse2_lshrti3);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       tmode = insn_data[icode].operand[0].mode;\n@@ -17885,86 +17883,86 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return NULL_RTX;\n \n     case IX86_BUILTIN_PAVGUSB:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_uavgv8qi3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_uavgv8qi3, exp, target);\n \n     case IX86_BUILTIN_PF2ID:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_pf2id, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_pf2id, exp, target, 0);\n \n     case IX86_BUILTIN_PFACC:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_haddv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_haddv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFADD:\n-     return ix86_expand_binop_builtin (CODE_FOR_mmx_addv2sf3, arglist, target);\n+     return ix86_expand_binop_builtin (CODE_FOR_mmx_addv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFCMPEQ:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_eqv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_eqv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFCMPGE:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_gev2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_gev2sf3, exp, target);\n \n     case IX86_BUILTIN_PFCMPGT:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_gtv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_gtv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFMAX:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_smaxv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_smaxv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFMIN:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_sminv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_sminv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFMUL:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_mulv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_mulv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFRCP:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_rcpv2sf2, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_rcpv2sf2, exp, target, 0);\n \n     case IX86_BUILTIN_PFRCPIT1:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_rcpit1v2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_rcpit1v2sf3, exp, target);\n \n     case IX86_BUILTIN_PFRCPIT2:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_rcpit2v2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_rcpit2v2sf3, exp, target);\n \n     case IX86_BUILTIN_PFRSQIT1:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_rsqit1v2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_rsqit1v2sf3, exp, target);\n \n     case IX86_BUILTIN_PFRSQRT:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_rsqrtv2sf2, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_rsqrtv2sf2, exp, target, 0);\n \n     case IX86_BUILTIN_PFSUB:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_subv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_subv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFSUBR:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_subrv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_subrv2sf3, exp, target);\n \n     case IX86_BUILTIN_PI2FD:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_floatv2si2, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_floatv2si2, exp, target, 0);\n \n     case IX86_BUILTIN_PMULHRW:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_pmulhrwv4hi3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_pmulhrwv4hi3, exp, target);\n \n     case IX86_BUILTIN_PF2IW:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_pf2iw, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_pf2iw, exp, target, 0);\n \n     case IX86_BUILTIN_PFNACC:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_hsubv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_hsubv2sf3, exp, target);\n \n     case IX86_BUILTIN_PFPNACC:\n-      return ix86_expand_binop_builtin (CODE_FOR_mmx_addsubv2sf3, arglist, target);\n+      return ix86_expand_binop_builtin (CODE_FOR_mmx_addsubv2sf3, exp, target);\n \n     case IX86_BUILTIN_PI2FW:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_pi2fw, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_pi2fw, exp, target, 0);\n \n     case IX86_BUILTIN_PSWAPDSI:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_pswapdv2si2, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_pswapdv2si2, exp, target, 0);\n \n     case IX86_BUILTIN_PSWAPDSF:\n-      return ix86_expand_unop_builtin (CODE_FOR_mmx_pswapdv2sf2, arglist, target, 0);\n+      return ix86_expand_unop_builtin (CODE_FOR_mmx_pswapdv2sf2, exp, target, 0);\n \n     case IX86_BUILTIN_SQRTSD:\n-      return ix86_expand_unop1_builtin (CODE_FOR_sse2_vmsqrtv2df2, arglist, target);\n+      return ix86_expand_unop1_builtin (CODE_FOR_sse2_vmsqrtv2df2, exp, target);\n     case IX86_BUILTIN_LOADUPD:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse2_movupd, arglist, target, 1);\n+      return ix86_expand_unop_builtin (CODE_FOR_sse2_movupd, exp, target, 1);\n     case IX86_BUILTIN_STOREUPD:\n-      return ix86_expand_store_builtin (CODE_FOR_sse2_movupd, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse2_movupd, exp);\n \n     case IX86_BUILTIN_MFENCE:\n \temit_insn (gen_sse2_mfence ());\n@@ -17974,7 +17972,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \treturn 0;\n \n     case IX86_BUILTIN_CLFLUSH:\n-\targ0 = TREE_VALUE (arglist);\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n \top0 = expand_normal (arg0);\n \ticode = CODE_FOR_sse2_clflush;\n \tif (! (*insn_data[icode].operand[0].predicate) (op0, Pmode))\n@@ -17984,21 +17982,21 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \treturn 0;\n \n     case IX86_BUILTIN_MOVNTPD:\n-      return ix86_expand_store_builtin (CODE_FOR_sse2_movntv2df, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse2_movntv2df, exp);\n     case IX86_BUILTIN_MOVNTDQ:\n-      return ix86_expand_store_builtin (CODE_FOR_sse2_movntv2di, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse2_movntv2di, exp);\n     case IX86_BUILTIN_MOVNTI:\n-      return ix86_expand_store_builtin (CODE_FOR_sse2_movntsi, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse2_movntsi, exp);\n \n     case IX86_BUILTIN_LOADDQU:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse2_movdqu, arglist, target, 1);\n+      return ix86_expand_unop_builtin (CODE_FOR_sse2_movdqu, exp, target, 1);\n     case IX86_BUILTIN_STOREDQU:\n-      return ix86_expand_store_builtin (CODE_FOR_sse2_movdqu, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse2_movdqu, exp);\n \n     case IX86_BUILTIN_MONITOR:\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -18015,8 +18013,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return 0;\n \n     case IX86_BUILTIN_MWAIT:\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       if (!REG_P (op0))\n@@ -18027,7 +18025,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return 0;\n \n     case IX86_BUILTIN_LDDQU:\n-      return ix86_expand_unop_builtin (CODE_FOR_sse3_lddqu, arglist,\n+      return ix86_expand_unop_builtin (CODE_FOR_sse3_lddqu, exp,\n \t\t\t\t       target, 1);\n \n     case IX86_BUILTIN_PALIGNR:\n@@ -18042,9 +18040,9 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t  icode = CODE_FOR_ssse3_palignrti;\n \t  mode = V2DImode;\n \t}\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n       op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n       op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n@@ -18077,18 +18075,18 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return target;\n \n     case IX86_BUILTIN_MOVNTSD:\n-      return ix86_expand_store_builtin (CODE_FOR_sse4a_vmmovntv2df, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse4a_vmmovntv2df, exp);\n \n     case IX86_BUILTIN_MOVNTSS:\n-      return ix86_expand_store_builtin (CODE_FOR_sse4a_vmmovntv4sf, arglist);\n+      return ix86_expand_store_builtin (CODE_FOR_sse4a_vmmovntv4sf, exp);\n \n     case IX86_BUILTIN_INSERTQ:\n     case IX86_BUILTIN_EXTRQ:\n       icode = (fcode == IX86_BUILTIN_EXTRQ\n                ? CODE_FOR_sse4a_extrq\n                : CODE_FOR_sse4a_insertq);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       tmode = insn_data[icode].operand[0].mode;\n@@ -18110,9 +18108,9 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n     case IX86_BUILTIN_EXTRQI:\n       icode = CODE_FOR_sse4a_extrqi;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -18144,10 +18142,10 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n     case IX86_BUILTIN_INSERTQI:\n       icode = CODE_FOR_sse4a_insertqi;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-      arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      arg2 = CALL_EXPR_ARG (exp, 2);\n+      arg3 = CALL_EXPR_ARG (exp, 3);\n       op0 = expand_normal (arg0);\n       op1 = expand_normal (arg1);\n       op2 = expand_normal (arg2);\n@@ -18187,7 +18185,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_VEC_INIT_V2SI:\n     case IX86_BUILTIN_VEC_INIT_V4HI:\n     case IX86_BUILTIN_VEC_INIT_V8QI:\n-      return ix86_expand_vec_init_builtin (TREE_TYPE (exp), arglist, target);\n+      return ix86_expand_vec_init_builtin (TREE_TYPE (exp), exp, target);\n \n     case IX86_BUILTIN_VEC_EXT_V2DF:\n     case IX86_BUILTIN_VEC_EXT_V2DI:\n@@ -18196,11 +18194,11 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_VEC_EXT_V8HI:\n     case IX86_BUILTIN_VEC_EXT_V2SI:\n     case IX86_BUILTIN_VEC_EXT_V4HI:\n-      return ix86_expand_vec_ext_builtin (arglist, target);\n+      return ix86_expand_vec_ext_builtin (exp, target);\n \n     case IX86_BUILTIN_VEC_SET_V8HI:\n     case IX86_BUILTIN_VEC_SET_V4HI:\n-      return ix86_expand_vec_set_builtin (arglist);\n+      return ix86_expand_vec_set_builtin (exp);\n \n     default:\n       break;\n@@ -18214,18 +18212,18 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t    || d->icode == CODE_FOR_sse_vmmaskcmpv4sf3\n \t    || d->icode == CODE_FOR_sse2_maskcmpv2df3\n \t    || d->icode == CODE_FOR_sse2_vmmaskcmpv2df3)\n-\t  return ix86_expand_sse_compare (d, arglist, target);\n+\t  return ix86_expand_sse_compare (d, exp, target);\n \n-\treturn ix86_expand_binop_builtin (d->icode, arglist, target);\n+\treturn ix86_expand_binop_builtin (d->icode, exp, target);\n       }\n \n   for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n     if (d->code == fcode)\n-      return ix86_expand_unop_builtin (d->icode, arglist, target, 0);\n+      return ix86_expand_unop_builtin (d->icode, exp, target, 0);\n \n   for (i = 0, d = bdesc_comi; i < ARRAY_SIZE (bdesc_comi); i++, d++)\n     if (d->code == fcode)\n-      return ix86_expand_sse_comi (d, arglist, target);\n+      return ix86_expand_sse_comi (d, exp, target);\n \n   gcc_unreachable ();\n }"}, {"sha": "a86dd40e2da3650a1f5f030cc246102d8c31bd9a", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2569,11 +2569,11 @@ void_ftype_int_int_int\n   def_builtin (\"__builtin_syscall\", void_ftype, IQ2000_BUILTIN_SYSCALL);\n }\n \n-/* Builtin for ICODE having ARGCOUNT args in ARGLIST where each arg\n+/* Builtin for ICODE having ARGCOUNT args in EXP where each arg\n    has an rtx CODE.  */\n \n static rtx\n-expand_one_builtin (enum insn_code icode, rtx target, tree arglist,\n+expand_one_builtin (enum insn_code icode, rtx target, tree exp,\n \t\t    enum rtx_code *code, int argcount)\n {\n   rtx pat;\n@@ -2585,8 +2585,7 @@ expand_one_builtin (enum insn_code icode, rtx target, tree arglist,\n   mode[0] = insn_data[icode].operand[0].mode;\n   for (i = 0; i < argcount; i++)\n     {\n-      arg[i] = TREE_VALUE (arglist);\n-      arglist = TREE_CHAIN (arglist);\n+      arg[i] = CALL_EXPR_ARG (exp, i);\n       op[i] = expand_expr (arg[i], NULL_RTX, VOIDmode, 0);\n       mode[i] = insn_data[icode].operand[i].mode;\n       if (code[i] == CONST_INT && GET_CODE (op[i]) != CONST_INT)\n@@ -2655,8 +2654,7 @@ iq2000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       int ignore ATTRIBUTE_UNUSED)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   int fcode = DECL_FUNCTION_CODE (fndecl);\n   enum rtx_code code [5];\n \n@@ -2671,162 +2669,162 @@ iq2000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       break;\n       \n     case IQ2000_BUILTIN_ADO16:\n-      return expand_one_builtin (CODE_FOR_ado16, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_ado16, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_RAM:\n       code[1] = CONST_INT;\n       code[2] = CONST_INT;\n       code[3] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_ram, target, arglist, code, 4);\n+      return expand_one_builtin (CODE_FOR_ram, target, exp, code, 4);\n       \n     case IQ2000_BUILTIN_CHKHDR:\n-      return expand_one_builtin (CODE_FOR_chkhdr, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_chkhdr, target, exp, code, 2);\n       \n     case IQ2000_BUILTIN_PKRL:\n-      return expand_one_builtin (CODE_FOR_pkrl, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_pkrl, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_CFC0:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_cfc0, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_cfc0, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_CFC1:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_cfc1, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_cfc1, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_CFC2:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_cfc2, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_cfc2, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_CFC3:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_cfc3, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_cfc3, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_CTC0:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_ctc0, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_ctc0, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_CTC1:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_ctc1, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_ctc1, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_CTC2:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_ctc2, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_ctc2, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_CTC3:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_ctc3, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_ctc3, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_MFC0:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mfc0, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_mfc0, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_MFC1:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mfc1, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_mfc1, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_MFC2:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mfc2, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_mfc2, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_MFC3:\n       code[0] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mfc3, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_mfc3, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_MTC0:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mtc0, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_mtc0, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_MTC1:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mtc1, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_mtc1, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_MTC2:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mtc2, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_mtc2, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_MTC3:\n       code[1] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mtc3, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_mtc3, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUR:\n-      return expand_one_builtin (CODE_FOR_lur, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_lur, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_RB:\n-      return expand_one_builtin (CODE_FOR_rb, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_rb, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_RX:\n-      return expand_one_builtin (CODE_FOR_rx, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_rx, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_SRRD:\n-      return expand_one_builtin (CODE_FOR_srrd, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_srrd, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_SRWR:\n-      return expand_one_builtin (CODE_FOR_srwr, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_srwr, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_WB:\n-      return expand_one_builtin (CODE_FOR_wb, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_wb, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_WX:\n-      return expand_one_builtin (CODE_FOR_wx, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_wx, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUC32L:\n-      return expand_one_builtin (CODE_FOR_luc32l, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_luc32l, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUC64:\n-      return expand_one_builtin (CODE_FOR_luc64, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_luc64, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUC64L:\n-      return expand_one_builtin (CODE_FOR_luc64l, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_luc64l, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUK:\n-      return expand_one_builtin (CODE_FOR_luk, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_luk, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LULCK:\n-      return expand_one_builtin (CODE_FOR_lulck, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_lulck, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_LUM32:\n-      return expand_one_builtin (CODE_FOR_lum32, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_lum32, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUM32L:\n-      return expand_one_builtin (CODE_FOR_lum32l, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_lum32l, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUM64:\n-      return expand_one_builtin (CODE_FOR_lum64, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_lum64, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LUM64L:\n-      return expand_one_builtin (CODE_FOR_lum64l, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_lum64l, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_LURL:\n-      return expand_one_builtin (CODE_FOR_lurl, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_lurl, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_MRGB:\n       code[2] = CONST_INT;\n-      return expand_one_builtin (CODE_FOR_mrgb, target, arglist, code, 3);\n+      return expand_one_builtin (CODE_FOR_mrgb, target, exp, code, 3);\n \n     case IQ2000_BUILTIN_SRRDL:\n-      return expand_one_builtin (CODE_FOR_srrdl, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_srrdl, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_SRULCK:\n-      return expand_one_builtin (CODE_FOR_srulck, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_srulck, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_SRWRU:\n-      return expand_one_builtin (CODE_FOR_srwru, target, arglist, code, 2);\n+      return expand_one_builtin (CODE_FOR_srwru, target, exp, code, 2);\n \n     case IQ2000_BUILTIN_TRAPQFL:\n-      return expand_one_builtin (CODE_FOR_trapqfl, target, arglist, code, 0);\n+      return expand_one_builtin (CODE_FOR_trapqfl, target, exp, code, 0);\n \n     case IQ2000_BUILTIN_TRAPQNE:\n-      return expand_one_builtin (CODE_FOR_trapqne, target, arglist, code, 0);\n+      return expand_one_builtin (CODE_FOR_trapqne, target, exp, code, 0);\n \n     case IQ2000_BUILTIN_TRAPREL:\n-      return expand_one_builtin (CODE_FOR_traprel, target, arglist, code, 1);\n+      return expand_one_builtin (CODE_FOR_traprel, target, exp, code, 1);\n \n     case IQ2000_BUILTIN_WBU:\n-      return expand_one_builtin (CODE_FOR_wbu, target, arglist, code, 3);\n+      return expand_one_builtin (CODE_FOR_wbu, target, exp, code, 3);\n \n     case IQ2000_BUILTIN_SYSCALL:\n-      return expand_one_builtin (CODE_FOR_syscall, target, arglist, code, 0);\n+      return expand_one_builtin (CODE_FOR_syscall, target, exp, code, 0);\n     }\n   \n   return NULL_RTX;"}, {"sha": "7112cc363d241c091da000e882a28f2ac9c4a7bb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -10336,8 +10336,10 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   const struct builtin_description *bdesc;\n   const struct bdesc_map *m;\n \n-  fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  arglist = TREE_OPERAND (exp, 1);\n+  fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  /* FIXME: Rewrite this to use the CALL_EXPR directly instead of consing\n+     up an arglist.  */\n+  arglist = CALL_EXPR_ARGS (exp);\n   fcode = DECL_FUNCTION_CODE (fndecl);\n \n   bdesc = NULL;"}, {"sha": "1845eda584a68a0f16a5d923926ff9e8b4ef1aeb", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2436,7 +2436,8 @@ altivec_build_resolved_builtin (tree *args, int n,\n   tree impl_fndecl = rs6000_builtin_decls[desc->overloaded_code];\n   tree ret_type = rs6000_builtin_type (desc->ret_type);\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (impl_fndecl));\n-  tree arglist = NULL_TREE, arg_type[3];\n+  tree arg_type[3];\n+  tree call;\n \n   int i;\n   for (i = 0; i < n; i++)\n@@ -2463,13 +2464,30 @@ altivec_build_resolved_builtin (tree *args, int n,\n \t\t\t     build_int_cst (NULL_TREE, 2));\n     }\n \n-  while (--n >= 0)\n-    arglist = tree_cons (NULL_TREE,\n-\t\t\t fold_convert (arg_type[n], args[n]),\n-\t\t\t arglist);\n-\n-  return fold_convert (ret_type,\n-\t\t       build_function_call_expr (impl_fndecl, arglist));\n+  switch (n)\n+    {\n+    case 0:\n+      call = build_call_expr (impl_fndecl, 0);\n+      break;\n+    case 1:\n+      call = build_call_expr (impl_fndecl, 1,\n+\t\t\t      fold_convert (arg_type[0], args[0]));\n+      break;\n+    case 2:\n+      call = build_call_expr (impl_fndecl, 2,\n+\t\t\t      fold_convert (arg_type[0], args[0]),\n+\t\t\t      fold_convert (arg_type[1], args[1]));\n+      break;\n+    case 3:\n+      call = build_call_expr (impl_fndecl, 3,\n+\t\t\t      fold_convert (arg_type[0], args[0]),\n+\t\t\t      fold_convert (arg_type[1], args[1]),\n+\t\t\t      fold_convert (arg_type[2], args[2]));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return fold_convert (ret_type, call);\n }\n \n /* Implementation of the resolve_overloaded_builtin target hook, to"}, {"sha": "5389c318cf4d8eba8bf85445f023607b81286a3e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 111, "deletions": 127, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -6294,12 +6294,8 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       tree tmp = create_tmp_var (type, \"va_arg_tmp\");\n       tree dest_addr = build_fold_addr_expr (tmp);\n \n-      tree copy = build_function_call_expr\n-\t(implicit_built_in_decls[BUILT_IN_MEMCPY],\n-\t tree_cons (NULL_TREE, dest_addr,\n-\t\t    tree_cons (NULL_TREE, addr,\n-\t\t\t       tree_cons (NULL_TREE, size_int (rsize * 4),\n-\t\t\t\t\t  NULL_TREE))));\n+      tree copy = build_call_expr (implicit_built_in_decls[BUILT_IN_MEMCPY],\n+\t\t\t\t   3, dest_addr, addr, size_int (rsize * 4));\n \n       gimplify_and_add (copy, pre_p);\n       addr = dest_addr;\n@@ -6934,10 +6930,10 @@ static struct builtin_description bdesc_1arg[] =\n };\n \n static rtx\n-rs6000_expand_unop_builtin (enum insn_code icode, tree arglist, rtx target)\n+rs6000_expand_unop_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -6983,10 +6979,10 @@ rs6000_expand_unop_builtin (enum insn_code icode, tree arglist, rtx target)\n }\n \n static rtx\n-altivec_expand_abs_builtin (enum insn_code icode, tree arglist, rtx target)\n+altivec_expand_abs_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat, scratch1, scratch2;\n-  tree arg0 = TREE_VALUE (arglist);\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -7015,11 +7011,11 @@ altivec_expand_abs_builtin (enum insn_code icode, tree arglist, rtx target)\n }\n \n static rtx\n-rs6000_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n+rs6000_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n@@ -7089,12 +7085,12 @@ rs6000_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n \n static rtx\n altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode,\n-\t\t\t\t  tree arglist, rtx target)\n+\t\t\t\t  tree exp, rtx target)\n {\n   rtx pat, scratch;\n-  tree cr6_form = TREE_VALUE (arglist);\n-  tree arg0 = TREE_VALUE (TREE_CHAIN (arglist));\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree cr6_form = CALL_EXPR_ARG (exp, 0);\n+  tree arg0 = CALL_EXPR_ARG (exp, 1);\n+  tree arg1 = CALL_EXPR_ARG (exp, 2);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   enum machine_mode tmode = SImode;\n@@ -7165,11 +7161,11 @@ altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode,\n }\n \n static rtx\n-altivec_expand_lv_builtin (enum insn_code icode, tree arglist, rtx target)\n+altivec_expand_lv_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat, addr;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode0 = Pmode;\n   enum machine_mode mode1 = Pmode;\n@@ -7211,11 +7207,11 @@ altivec_expand_lv_builtin (enum insn_code icode, tree arglist, rtx target)\n }\n \n static rtx\n-spe_expand_stv_builtin (enum insn_code icode, tree arglist)\n+spe_expand_stv_builtin (enum insn_code icode, tree exp)\n {\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  tree arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n@@ -7244,11 +7240,11 @@ spe_expand_stv_builtin (enum insn_code icode, tree arglist)\n }\n \n static rtx\n-altivec_expand_stv_builtin (enum insn_code icode, tree arglist)\n+altivec_expand_stv_builtin (enum insn_code icode, tree exp)\n {\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  tree arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n@@ -7285,12 +7281,12 @@ altivec_expand_stv_builtin (enum insn_code icode, tree arglist)\n }\n \n static rtx\n-rs6000_expand_ternop_builtin (enum insn_code icode, tree arglist, rtx target)\n+rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  tree arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n@@ -7348,8 +7344,7 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree arglist, rtx target)\n static rtx\n altivec_expand_ld_builtin (tree exp, rtx target, bool *expandedp)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree arg0;\n   enum machine_mode tmode, mode0;\n@@ -7377,7 +7372,7 @@ altivec_expand_ld_builtin (tree exp, rtx target, bool *expandedp)\n \n   *expandedp = true;\n \n-  arg0 = TREE_VALUE (arglist);\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n   op0 = expand_normal (arg0);\n   tmode = insn_data[icode].operand[0].mode;\n   mode0 = insn_data[icode].operand[1].mode;\n@@ -7402,8 +7397,7 @@ static rtx\n altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t\t   bool *expandedp)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree arg0, arg1;\n   enum machine_mode mode0, mode1;\n@@ -7429,8 +7423,8 @@ altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       return NULL_RTX;\n     }\n \n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n   op0 = expand_normal (arg0);\n   op1 = expand_normal (arg1);\n   mode0 = insn_data[icode].operand[0].mode;\n@@ -7454,8 +7448,7 @@ static rtx\n altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t\t    bool *expandedp)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree arg0, arg1, arg2;\n   enum machine_mode mode0, mode1, mode2;\n@@ -7470,9 +7463,9 @@ altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n   for (i = 0; i < ARRAY_SIZE (bdesc_dst); i++, d++)\n     if (d->code == fcode)\n       {\n-\targ0 = TREE_VALUE (arglist);\n-\targ1 = TREE_VALUE (TREE_CHAIN (arglist));\n-\targ2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\targ0 = CALL_EXPR_ARG (exp, 0);\n+\targ1 = CALL_EXPR_ARG (exp, 1);\n+\targ2 = CALL_EXPR_ARG (exp, 2);\n \top0 = expand_normal (arg0);\n \top1 = expand_normal (arg1);\n \top2 = expand_normal (arg2);\n@@ -7512,23 +7505,22 @@ altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \n /* Expand vec_init builtin.  */\n static rtx\n-altivec_expand_vec_init_builtin (tree type, tree arglist, rtx target)\n+altivec_expand_vec_init_builtin (tree type, tree exp, rtx target)\n {\n   enum machine_mode tmode = TYPE_MODE (type);\n   enum machine_mode inner_mode = GET_MODE_INNER (tmode);\n   int i, n_elt = GET_MODE_NUNITS (tmode);\n   rtvec v = rtvec_alloc (n_elt);\n \n   gcc_assert (VECTOR_MODE_P (tmode));\n-\n-  for (i = 0; i < n_elt; ++i, arglist = TREE_CHAIN (arglist))\n+  gcc_assert (n_elt == call_expr_nargs (exp));\n+  \n+  for (i = 0; i < n_elt; ++i)\n     {\n-      rtx x = expand_normal (TREE_VALUE (arglist));\n+      rtx x = expand_normal (CALL_EXPR_ARG (exp, i));\n       RTVEC_ELT (v, i) = gen_lowpart (inner_mode, x);\n     }\n \n-  gcc_assert (arglist == NULL);\n-\n   if (!target || !register_operand (target, tmode))\n     target = gen_reg_rtx (tmode);\n \n@@ -7556,16 +7548,16 @@ get_element_number (tree vec_type, tree arg)\n \n /* Expand vec_set builtin.  */\n static rtx\n-altivec_expand_vec_set_builtin (tree arglist)\n+altivec_expand_vec_set_builtin (tree exp)\n {\n   enum machine_mode tmode, mode1;\n   tree arg0, arg1, arg2;\n   int elt;\n   rtx op0, op1;\n \n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n+  arg2 = CALL_EXPR_ARG (exp, 2);\n \n   tmode = TYPE_MODE (TREE_TYPE (arg0));\n   mode1 = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n@@ -7588,15 +7580,15 @@ altivec_expand_vec_set_builtin (tree arglist)\n \n /* Expand vec_ext builtin.  */\n static rtx\n-altivec_expand_vec_ext_builtin (tree arglist, rtx target)\n+altivec_expand_vec_ext_builtin (tree exp, rtx target)\n {\n   enum machine_mode tmode, mode0;\n   tree arg0, arg1;\n   int elt;\n   rtx op0;\n \n-  arg0 = TREE_VALUE (arglist);\n-  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg0 = CALL_EXPR_ARG (exp, 0);\n+  arg1 = CALL_EXPR_ARG (exp, 1);\n \n   op0 = expand_normal (arg0);\n   elt = get_element_number (TREE_TYPE (arg0), arg1);\n@@ -7624,8 +7616,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n   struct builtin_description_predicates *dp;\n   size_t i;\n   enum insn_code icode;\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   tree arg0;\n   rtx op0, pat;\n   enum machine_mode tmode, mode0;\n@@ -7656,15 +7647,15 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n   switch (fcode)\n     {\n     case ALTIVEC_BUILTIN_STVX:\n-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx, arglist);\n+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx, exp);\n     case ALTIVEC_BUILTIN_STVEBX:\n-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvebx, arglist);\n+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvebx, exp);\n     case ALTIVEC_BUILTIN_STVEHX:\n-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvehx, arglist);\n+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvehx, exp);\n     case ALTIVEC_BUILTIN_STVEWX:\n-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvewx, arglist);\n+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvewx, exp);\n     case ALTIVEC_BUILTIN_STVXL:\n-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvxl, arglist);\n+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvxl, exp);\n \n     case ALTIVEC_BUILTIN_MFVSCR:\n       icode = CODE_FOR_altivec_mfvscr;\n@@ -7683,7 +7674,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n \n     case ALTIVEC_BUILTIN_MTVSCR:\n       icode = CODE_FOR_altivec_mtvscr;\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       op0 = expand_normal (arg0);\n       mode0 = insn_data[icode].operand[0].mode;\n \n@@ -7705,7 +7696,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n \n     case ALTIVEC_BUILTIN_DSS:\n       icode = CODE_FOR_altivec_dss;\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       STRIP_NOPS (arg0);\n       op0 = expand_normal (arg0);\n       mode0 = insn_data[icode].operand[0].mode;\n@@ -7731,19 +7722,19 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_VEC_INIT_V8HI:\n     case ALTIVEC_BUILTIN_VEC_INIT_V16QI:\n     case ALTIVEC_BUILTIN_VEC_INIT_V4SF:\n-      return altivec_expand_vec_init_builtin (TREE_TYPE (exp), arglist, target);\n+      return altivec_expand_vec_init_builtin (TREE_TYPE (exp), exp, target);\n \n     case ALTIVEC_BUILTIN_VEC_SET_V4SI:\n     case ALTIVEC_BUILTIN_VEC_SET_V8HI:\n     case ALTIVEC_BUILTIN_VEC_SET_V16QI:\n     case ALTIVEC_BUILTIN_VEC_SET_V4SF:\n-      return altivec_expand_vec_set_builtin (arglist);\n+      return altivec_expand_vec_set_builtin (exp);\n \n     case ALTIVEC_BUILTIN_VEC_EXT_V4SI:\n     case ALTIVEC_BUILTIN_VEC_EXT_V8HI:\n     case ALTIVEC_BUILTIN_VEC_EXT_V16QI:\n     case ALTIVEC_BUILTIN_VEC_EXT_V4SF:\n-      return altivec_expand_vec_ext_builtin (arglist, target);\n+      return altivec_expand_vec_ext_builtin (exp, target);\n \n     default:\n       break;\n@@ -7754,39 +7745,39 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n   d = (struct builtin_description *) bdesc_abs;\n   for (i = 0; i < ARRAY_SIZE (bdesc_abs); i++, d++)\n     if (d->code == fcode)\n-      return altivec_expand_abs_builtin (d->icode, arglist, target);\n+      return altivec_expand_abs_builtin (d->icode, exp, target);\n \n   /* Expand the AltiVec predicates.  */\n   dp = (struct builtin_description_predicates *) bdesc_altivec_preds;\n   for (i = 0; i < ARRAY_SIZE (bdesc_altivec_preds); i++, dp++)\n     if (dp->code == fcode)\n       return altivec_expand_predicate_builtin (dp->icode, dp->opcode,\n-\t\t\t\t\t       arglist, target);\n+\t\t\t\t\t       exp, target);\n \n   /* LV* are funky.  We initialized them differently.  */\n   switch (fcode)\n     {\n     case ALTIVEC_BUILTIN_LVSL:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvsl,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     case ALTIVEC_BUILTIN_LVSR:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvsr,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     case ALTIVEC_BUILTIN_LVEBX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvebx,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     case ALTIVEC_BUILTIN_LVEHX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvehx,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     case ALTIVEC_BUILTIN_LVEWX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvewx,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     case ALTIVEC_BUILTIN_LVXL:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     case ALTIVEC_BUILTIN_LVX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx,\n-\t\t\t\t\targlist, target);\n+\t\t\t\t\texp, target);\n     default:\n       break;\n       /* Fall through.  */\n@@ -7832,8 +7823,7 @@ static struct builtin_description bdesc_2arg_spe[] =\n static rtx\n spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   tree arg1, arg0;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   enum insn_code icode;\n@@ -7854,7 +7844,7 @@ spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case SPE_BUILTIN_EVSTWHO:\n     case SPE_BUILTIN_EVSTWWE:\n     case SPE_BUILTIN_EVSTWWO:\n-      arg1 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arg1 = CALL_EXPR_ARG (exp, 2);\n       if (TREE_CODE (arg1) != INTEGER_CST\n \t  || TREE_INT_CST_LOW (arg1) & ~0x1f)\n \t{\n@@ -7871,59 +7861,59 @@ spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n     {\n     case SPE_BUILTIN_EVSPLATFI:\n       return rs6000_expand_unop_builtin (CODE_FOR_spe_evsplatfi,\n-\t\t\t\t\t arglist, target);\n+\t\t\t\t\t exp, target);\n     case SPE_BUILTIN_EVSPLATI:\n       return rs6000_expand_unop_builtin (CODE_FOR_spe_evsplati,\n-\t\t\t\t\t arglist, target);\n+\t\t\t\t\t exp, target);\n     default:\n       break;\n     }\n \n   d = (struct builtin_description *) bdesc_2arg_spe;\n   for (i = 0; i < ARRAY_SIZE (bdesc_2arg_spe); ++i, ++d)\n     if (d->code == fcode)\n-      return rs6000_expand_binop_builtin (d->icode, arglist, target);\n+      return rs6000_expand_binop_builtin (d->icode, exp, target);\n \n   d = (struct builtin_description *) bdesc_spe_predicates;\n   for (i = 0; i < ARRAY_SIZE (bdesc_spe_predicates); ++i, ++d)\n     if (d->code == fcode)\n-      return spe_expand_predicate_builtin (d->icode, arglist, target);\n+      return spe_expand_predicate_builtin (d->icode, exp, target);\n \n   d = (struct builtin_description *) bdesc_spe_evsel;\n   for (i = 0; i < ARRAY_SIZE (bdesc_spe_evsel); ++i, ++d)\n     if (d->code == fcode)\n-      return spe_expand_evsel_builtin (d->icode, arglist, target);\n+      return spe_expand_evsel_builtin (d->icode, exp, target);\n \n   switch (fcode)\n     {\n     case SPE_BUILTIN_EVSTDDX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstddx, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstddx, exp);\n     case SPE_BUILTIN_EVSTDHX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstdhx, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstdhx, exp);\n     case SPE_BUILTIN_EVSTDWX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstdwx, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstdwx, exp);\n     case SPE_BUILTIN_EVSTWHEX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwhex, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwhex, exp);\n     case SPE_BUILTIN_EVSTWHOX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwhox, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwhox, exp);\n     case SPE_BUILTIN_EVSTWWEX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwex, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwex, exp);\n     case SPE_BUILTIN_EVSTWWOX:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwox, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwox, exp);\n     case SPE_BUILTIN_EVSTDD:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstdd, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstdd, exp);\n     case SPE_BUILTIN_EVSTDH:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstdh, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstdh, exp);\n     case SPE_BUILTIN_EVSTDW:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstdw, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstdw, exp);\n     case SPE_BUILTIN_EVSTWHE:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwhe, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwhe, exp);\n     case SPE_BUILTIN_EVSTWHO:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwho, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwho, exp);\n     case SPE_BUILTIN_EVSTWWE:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwe, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwe, exp);\n     case SPE_BUILTIN_EVSTWWO:\n-      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwo, arglist);\n+      return spe_expand_stv_builtin (CODE_FOR_spe_evstwwo, exp);\n     case SPE_BUILTIN_MFSPEFSCR:\n       icode = CODE_FOR_spe_mfspefscr;\n       tmode = insn_data[icode].operand[0].mode;\n@@ -7940,7 +7930,7 @@ spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n       return target;\n     case SPE_BUILTIN_MTSPEFSCR:\n       icode = CODE_FOR_spe_mtspefscr;\n-      arg0 = TREE_VALUE (arglist);\n+      arg0 = CALL_EXPR_ARG (exp, 0);\n       op0 = expand_normal (arg0);\n       mode0 = insn_data[icode].operand[0].mode;\n \n@@ -7963,12 +7953,12 @@ spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n }\n \n static rtx\n-spe_expand_predicate_builtin (enum insn_code icode, tree arglist, rtx target)\n+spe_expand_predicate_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat, scratch, tmp;\n-  tree form = TREE_VALUE (arglist);\n-  tree arg0 = TREE_VALUE (TREE_CHAIN (arglist));\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree form = CALL_EXPR_ARG (exp, 0);\n+  tree arg0 = CALL_EXPR_ARG (exp, 1);\n+  tree arg1 = CALL_EXPR_ARG (exp, 2);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n@@ -8071,13 +8061,13 @@ spe_expand_predicate_builtin (enum insn_code icode, tree arglist, rtx target)\n */\n \n static rtx\n-spe_expand_evsel_builtin (enum insn_code icode, tree arglist, rtx target)\n+spe_expand_evsel_builtin (enum insn_code icode, tree exp, rtx target)\n {\n   rtx pat, scratch;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  tree arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-  tree arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  tree arg2 = CALL_EXPR_ARG (exp, 2);\n+  tree arg3 = CALL_EXPR_ARG (exp, 3);\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n@@ -8131,8 +8121,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t       int ignore ATTRIBUTE_UNUSED)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   struct builtin_description *d;\n   size_t i;\n@@ -8150,7 +8139,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       gcc_assert (TARGET_ALTIVEC);\n \n-      arg = TREE_VALUE (arglist);\n+      arg = CALL_EXPR_ARG (exp, 0);\n       gcc_assert (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE);\n       op = expand_expr (arg, NULL_RTX, Pmode, EXPAND_NORMAL);\n       addr = memory_address (mode, op);\n@@ -8178,20 +8167,15 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       return target;\n     }\n-  \n+\n+  /* FIXME: There's got to be a nicer way to handle this case than\n+     constructing a new CALL_EXPR.  */\n   if (fcode == ALTIVEC_BUILTIN_VCFUX\n       || fcode == ALTIVEC_BUILTIN_VCFSX)\n     {\n-      if (!TREE_CHAIN (arglist)) \n-\t{\n-\t  tree t, arg0;\n-\t  t = NULL_TREE;\n-\t  t = tree_cons (NULL_TREE, integer_zero_node, t);\n-\t  arg0 = TREE_VALUE (arglist);\n-\t  t = tree_cons (NULL_TREE, arg0, t);\n-\t  arglist = t;\n-\t  TREE_OPERAND (exp, 1) = t;\n-\t}\n+      if (call_expr_nargs (exp) == 1)\n+\texp = build_call_nary (TREE_TYPE (exp), CALL_EXPR_FN (exp),\n+\t\t\t       2, CALL_EXPR_ARG (exp, 0), integer_zero_node);\n     }   \n \n   if (TARGET_ALTIVEC)\n@@ -8215,19 +8199,19 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   d = (struct builtin_description *) bdesc_1arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_unop_builtin (d->icode, arglist, target);\n+      return rs6000_expand_unop_builtin (d->icode, exp, target);\n \n   /* Handle simple binary operations.  */\n   d = (struct builtin_description *) bdesc_2arg;\n   for (i = 0; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_binop_builtin (d->icode, arglist, target);\n+      return rs6000_expand_binop_builtin (d->icode, exp, target);\n \n   /* Handle simple ternary operations.  */\n   d = (struct builtin_description *) bdesc_3arg;\n   for (i = 0; i < ARRAY_SIZE  (bdesc_3arg); i++, d++)\n     if (d->code == fcode)\n-      return rs6000_expand_ternop_builtin (d->icode, arglist, target);\n+      return rs6000_expand_ternop_builtin (d->icode, exp, target);\n \n   gcc_unreachable ();\n }"}, {"sha": "26484664b54105170d859170b500e08f7826a5ec", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -8210,13 +8210,14 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   unsigned int const *code_for_builtin =\n     TARGET_64BIT ? code_for_builtin_64 : code_for_builtin_31;\n \n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree arglist = TREE_OPERAND (exp, 1);\n   enum insn_code icode;\n   rtx op[MAX_ARGS], pat;\n   int arity;\n   bool nonvoid;\n+  tree arg;\n+  call_expr_arg_iterator iter;\n \n   if (fcode >= S390_BUILTIN_max)\n     internal_error (\"bad builtin fcode\");\n@@ -8226,13 +8227,11 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n   nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n \n-  for (arglist = TREE_OPERAND (exp, 1), arity = 0;\n-       arglist;\n-       arglist = TREE_CHAIN (arglist), arity++)\n+  arity = 0;\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n     {\n       const struct insn_operand_data *insn_op;\n \n-      tree arg = TREE_VALUE (arglist);\n       if (arg == error_mark_node)\n \treturn NULL_RTX;\n       if (arity > MAX_ARGS)\n@@ -8244,6 +8243,7 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       if (!(*insn_op->predicate) (op[arity], insn_op->mode))\n \top[arity] = copy_to_mode_reg (insn_op->mode, op[arity]);\n+      arity++;\n     }\n \n   if (nonvoid)"}, {"sha": "96a00f6cc6bf41fea397de2c4abee24e602a1931", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -9904,8 +9904,7 @@ static rtx\n sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t   enum machine_mode mode ATTRIBUTE_UNUSED, int ignore)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   const struct builtin_description *d = &bdesc[fcode];\n   enum insn_code icode = d->icode;\n@@ -9938,10 +9937,9 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       if (! signature_args[signature][i])\n \tbreak;\n-      arg = TREE_VALUE (arglist);\n+      arg = CALL_EXPR_ARG (exp, i - 1);\n       if (arg == error_mark_node)\n \treturn const0_rtx;\n-      arglist = TREE_CHAIN (arglist);\n       if (signature_args[signature][i] & 8)\n \t{\n \t  opmode = ptr_mode;"}, {"sha": "45bc9e187e5f1ddf4d782c50b417f82415801601", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -5701,12 +5701,10 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       tree tmp = create_tmp_var (type, \"va_arg_tmp\");\n       tree dest_addr = build_fold_addr_expr (tmp);\n \n-      tree copy = build_function_call_expr\n-\t(implicit_built_in_decls[BUILT_IN_MEMCPY],\n-\t tree_cons (NULL_TREE, dest_addr,\n-\t\t    tree_cons (NULL_TREE, addr,\n-\t\t\t       tree_cons (NULL_TREE, size_int (rsize),\n-\t\t\t\t\t  NULL_TREE))));\n+      tree copy = build_call_expr (implicit_built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t\t   dest_addr,\n+\t\t\t\t   addr,\n+\t\t\t\t   size_int (rsize));\n \n       gimplify_and_add (copy, pre_p);\n       addr = dest_addr;\n@@ -7985,8 +7983,9 @@ static rtx\n sparc_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t      enum machine_mode tmode, int ignore ATTRIBUTE_UNUSED)\n {\n-  tree arglist;\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int icode = DECL_FUNCTION_CODE (fndecl);\n   rtx pat, op[4];\n   enum machine_mode mode[4];\n@@ -8001,11 +8000,8 @@ sparc_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   else\n     op[arg_count] = target;\n \n-  for (arglist = TREE_OPERAND (exp, 1); arglist;\n-       arglist = TREE_CHAIN (arglist))\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n     {\n-      tree arg = TREE_VALUE (arglist);\n-\n       arg_count++;\n       mode[arg_count] = insn_data[icode].operand[arg_count].mode;\n       op[arg_count] = expand_normal (arg);"}, {"sha": "77dfa405ddfccbda99048472615af6cc898a767b", "filename": "gcc/configure", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -16014,70 +16014,70 @@ echo \"${ECHO_T}$gcc_cv_ld_pie\" >&6\n echo \"$as_me:$LINENO: checking linker EH-compatible garbage collection of sections\" >&5\n echo $ECHO_N \"checking linker EH-compatible garbage collection of sections... $ECHO_C\" >&6\n gcc_cv_ld_eh_gc_sections=no\n-if test $in_tree_ld = yes ; then\n-  if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 17 -o \"$gcc_cv_gld_major_version\" -gt 2 \\\n-     && test $in_tree_ld_is_elf = yes; then\n-    gcc_cv_ld_eh_gc_sections=yes\n-  fi\n-elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then\n-  cat > conftest.s <<EOF\n-\t.section\t.text\n-.globl _start\n-        .type _start, @function\n-_start:\n-\t.long foo\n-\t.size _start, .-_start\n-\t.section\t.text.foo,\"ax\",@progbits\n-\t.type foo, @function\n-foo:\n-\t.long 0\n-\t.size foo, .-foo\n-\t.section\t.gcc_except_table.foo,\"a\",@progbits\n-.L0:\n-\t.long 0\n-\t.section\t.eh_frame,\"a\",@progbits\n-\t.long .L0\n-EOF\n-  if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n-    if $gcc_cv_ld -o conftest conftest.o --entry=_start --gc-sections 2>&1 \\\n-\t | grep \"gc-sections option ignored\" > /dev/null; then\n-      gcc_cv_ld_eh_gc_sections=no\n-    elif $gcc_cv_objdump -h conftest | grep gcc_except_table > /dev/null; then\n-      gcc_cv_ld_eh_gc_sections=yes\n-      # If no COMDAT groups, the compiler will emit .gnu.linkonce.t. sections.\n-      if test x$gcc_cv_as_comdat_group != xyes; then\n-\tgcc_cv_ld_eh_gc_sections=no\n-\tcat > conftest.s <<EOF\n-\t.section\t.text\n-.globl _start\n-        .type _start, @function\n-_start:\n-\t.long foo\n-\t.size _start, .-_start\n-\t.section\t.gnu.linkonce.t.foo,\"ax\",@progbits\n-\t.type foo, @function\n-foo:\n-\t.long 0\n-\t.size foo, .-foo\n-\t.section\t.gcc_except_table.foo,\"a\",@progbits\n-.L0:\n-\t.long 0\n-\t.section\t.eh_frame,\"a\",@progbits\n-\t.long .L0\n-EOF\n-\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n-\t  if $gcc_cv_ld -o conftest conftest.o --entry=_start --gc-sections 2>&1 \\\n-\t       | grep \"gc-sections option ignored\" > /dev/null; then\n-\t    gcc_cv_ld_eh_gc_sections=no\n-\t  elif $gcc_cv_objdump -h conftest | grep gcc_except_table > /dev/null; then\n-\t    gcc_cv_ld_eh_gc_sections=yes\n-\t  fi\n-\tfi\n-      fi\n-    fi\n-  fi\n-  rm -f conftest.s conftest.o conftest\n-fi\n+#if test $in_tree_ld = yes ; then\n+#  if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 17 -o \"$gcc_cv_gld_major_version\" -gt 2 \\\n+#     && test $in_tree_ld_is_elf = yes; then\n+#    gcc_cv_ld_eh_gc_sections=yes\n+#  fi\n+#elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x -a x$gcc_cv_objdump != x ; then\n+#  cat > conftest.s <<EOF\n+#\t.section\t.text\n+#.globl _start\n+#        .type _start, @function\n+#_start:\n+#\t.long foo\n+#\t.size _start, .-_start\n+#\t.section\t.text.foo,\"ax\",@progbits\n+#\t.type foo, @function\n+#foo:\n+#\t.long 0\n+#\t.size foo, .-foo\n+#\t.section\t.gcc_except_table.foo,\"a\",@progbits\n+#.L0:\n+#\t.long 0\n+#\t.section\t.eh_frame,\"a\",@progbits\n+#\t.long .L0\n+#EOF\n+#  if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+#    if $gcc_cv_ld -o conftest conftest.o --entry=_start --gc-sections 2>&1 \\\n+#\t | grep \"gc-sections option ignored\" > /dev/null; then\n+#      gcc_cv_ld_eh_gc_sections=no\n+#    elif $gcc_cv_objdump -h conftest | grep gcc_except_table > /dev/null; then\n+#      gcc_cv_ld_eh_gc_sections=yes\n+#      # If no COMDAT groups, the compiler will emit .gnu.linkonce.t. sections.\n+#      if test x$gcc_cv_as_comdat_group != xyes; then\n+#\tgcc_cv_ld_eh_gc_sections=no\n+#\tcat > conftest.s <<EOF\n+#\t.section\t.text\n+#.globl _start\n+#        .type _start, @function\n+#_start:\n+#\t.long foo\n+#\t.size _start, .-_start\n+#\t.section\t.gnu.linkonce.t.foo,\"ax\",@progbits\n+#\t.type foo, @function\n+#foo:\n+#\t.long 0\n+#\t.size foo, .-foo\n+#\t.section\t.gcc_except_table.foo,\"a\",@progbits\n+#.L0:\n+#\t.long 0\n+#\t.section\t.eh_frame,\"a\",@progbits\n+#\t.long .L0\n+#EOF\n+#\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+#\t  if $gcc_cv_ld -o conftest conftest.o --entry=_start --gc-sections 2>&1 \\\n+#\t       | grep \"gc-sections option ignored\" > /dev/null; then\n+#\t    gcc_cv_ld_eh_gc_sections=no\n+#\t  elif $gcc_cv_objdump -h conftest | grep gcc_except_table > /dev/null; then\n+#\t    gcc_cv_ld_eh_gc_sections=yes\n+#\t  fi\n+#\tfi\n+#      fi\n+#    fi\n+#  fi\n+#  rm -f conftest.s conftest.o conftest\n+#fi\n case \"$target\" in\n   hppa*-*-linux*)\n     # ??? This apparently exposes a binutils bug with PC-relative relocations."}, {"sha": "b6c6d0fcf750c85c29195cc1032e36ef2e4422b4", "filename": "gcc/convert.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -173,7 +173,7 @@ convert_to_real (tree type, tree expr)\n \t  CASE_MATHFN (Y1)\n #undef CASE_MATHFN\n \t    {\n-\t      tree arg0 = strip_float_extensions (TREE_VALUE (TREE_OPERAND (expr, 1)));\n+\t      tree arg0 = strip_float_extensions (CALL_EXPR_ARG (expr, 0));\n \t      tree newtype = type;\n \n \t      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode from\n@@ -188,13 +188,12 @@ convert_to_real (tree type, tree expr)\n \t\t  && (TYPE_MODE (newtype) == TYPE_MODE (double_type_node)\n \t\t      || TYPE_MODE (newtype) == TYPE_MODE (float_type_node)))\n \t        {\n-\t\t  tree arglist;\n \t\t  tree fn = mathfn_built_in (newtype, fcode);\n \n \t\t  if (fn)\n \t\t  {\n-\t\t    arglist = build_tree_list (NULL_TREE, fold (convert_to_real (newtype, arg0)));\n-\t\t    expr = build_function_call_expr (fn, arglist);\n+\t\t    tree arg = fold (convert_to_real (newtype, arg0));\n+\t\t    expr = build_call_expr (fn, 1, arg);\n \t\t    if (newtype == type)\n \t\t      return expr;\n \t\t  }\n@@ -225,18 +224,14 @@ convert_to_real (tree type, tree expr)\n \n       if (fn)\n \t{\n-\t  tree arg\n-\t    = strip_float_extensions (TREE_VALUE (TREE_OPERAND (expr, 1)));\n+\t  tree arg = strip_float_extensions (CALL_EXPR_ARG (expr, 0));\n \n \t  /* Make sure (type)arg0 is an extension, otherwise we could end up\n \t     changing (float)floor(double d) into floorf((float)d), which is\n \t     incorrect because (float)d uses round-to-nearest and can round\n \t     up to the next integer.  */\n \t  if (TYPE_PRECISION (type) >= TYPE_PRECISION (TREE_TYPE (arg)))\n-\t    return\n-\t      build_function_call_expr (fn,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t  fold (convert_to_real (type, arg))));\n+\t    return build_call_expr (fn, 1, fold (convert_to_real (type, arg)));\n \t}\n     }\n \n@@ -434,19 +429,15 @@ convert_to_integer (tree type, tree expr)\n \t  break;\n \n \tCASE_FLT_FN (BUILT_IN_TRUNC):\n-\t  {\n-\t    tree arglist = TREE_OPERAND (s_expr, 1);\n-\t    return convert_to_integer (type, TREE_VALUE (arglist));\n-\t  }\n+\t  return convert_to_integer (type, CALL_EXPR_ARG (s_expr, 0));\n \n \tdefault:\n \t  break;\n \t}\n       \n       if (fn)\n         {\n-\t  tree arglist = TREE_OPERAND (s_expr, 1);\n-\t  tree newexpr = build_function_call_expr (fn, arglist);\n+\t  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));\n \t  return convert_to_integer (type, newexpr);\n \t}\n     }"}, {"sha": "aaec5edf667d56eba0ef56e6ee2518a3d41eb89a", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -949,8 +949,7 @@ create_coverage (void)\n   /* Generate a call to __gcov_init(&gcov_info).  */\n   body = NULL;\n   t = build_fold_addr_expr (gcov_info);\n-  t = tree_cons (NULL, t, NULL);\n-  t = build_function_call_expr (gcov_init, t);\n+  t = build_call_expr (gcov_init, 1, t);\n   append_to_statement_list (t, &body);\n \n   /* Generate a constructor to run it.  */"}, {"sha": "16df0f7da4fee1f80e86807b00b245f25aa7487f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1,3 +1,90 @@\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* cp-tree.def (AGGR_INIT_EXPR): Adjust documentation.\n+\tChange class to tcc_vl_exp.\n+\n+\t* call.c (build_call): Use build_call_list instead \n+\tof build3. \n+\t(build_over_call): Likewise.\n+\t(build_new_method_call): Use build_min_non_dep_call_list \n+\tinstead of build_min_non_dep.\n+\n+\t* error.c (dump_call_expr_args): New function.\n+\t(dump_aggr_init_expr_args): New function.\n+\t(dump_expr) <AGGR_INIT_EXPR, CALL_EXPR, INDIRECT_REF>: Use them. \n+\tUpdate to use new CALL_EXPR and AGGR_INIT_EXPR accessor macros.\n+\n+\t* cvt.c (convert_to_void): Use build_call_array instead\n+\tof build3; use new AGGR_INIT_EXPR accessor macros.\n+\n+\t* mangle.c (write_expression): Use TREE_OPERAND_LENGTH\n+\tinstead of TREE_CODE_LENGTH.\n+\n+\t* dump.c (cp_dump_tree) <AGGR_INIT_EXPR>: Update to use new\n+\tAGGR_INIT_EXPR accessor macros.\n+\n+\t* cp-gimplify.c (cp_gimplify_init_expr): Use \n+\tAGGR_INIT_EXPR_SLOT to set the slot operand.\n+\n+\t* cp-tree.h (AGGR_INIT_EXPR_FN): New macro.\n+\t(AGGR_INIT_EXPR_SLOT): New macro.\n+\t(AGGR_INIT_EXPR_ARG): New macro.\n+\t(aggr_init_expr_nargs): New macro.\n+\t(AGGR_INIT_EXPR_ARGP): New macro.\n+\t(aggr_init_expr_arg_iterator): New.\n+\t(init_aggr_init_expr_arg_iterator): New.\n+\t(next_aggr_init_expr_arg): New.\n+\t(first_aggr_init_expr_arg): New.\n+\t(more_aggr_init_expr_args_p): New.\n+\t(FOR_EACH_AGGR_INIT_EXPR_ARG): New.\n+\t(stabilize_aggr_init): New declaration.\n+\t(build_min_non_dep_call_list): Likewise.\n+\n+\t* tree.c (process_aggr_init_operands): New function.\n+\t(build_aggr_init_array) New function.\n+\t(build_cplus_new): Update to use new CALL_EXPR and\n+\tAGGR_INIT_EXPR accessor macros. Replace use of build3 with\n+\tbuild_aggr_init_array.\n+\t(build_min_non_dep_call_list) New function.\n+\t(build_min_nt): Assert input code parameter is not a variable\n+\tlength expression class.\n+\t(build_min, build_min_non_dep): Likewise.\n+\t(cp_tree_equal) <CALL_EXPR>: Iterate through the arguments\n+\tto check for equality instead of recursing. Handle tcc_vl_exp\n+\ttree code classes.\n+\t(stabilize_call): Update to only handle CALL_EXPRs, not \n+\tAGGR_INIT_EXPRs; use new CALL_EXPR accessor macros.\n+\t(stabilize_aggr_init): New function.\n+\t(stabilize_init): Use it.\n+\n+\t* cxx-pretty-print.c (pp_cxx_postfix_expression)\n+\t<AGGR_INIT_EXPR, CALL_EXPR>: Update to use new CALL_EXPR and\n+\tAGGR_INIT_EXPR accessor macros and argument iterators.\n+\t\n+\t* pt.c (tsubst_copy) <CALL_EXPR>: Replace build_nt with\n+\tbuild_vl_exp. Iterate through the operands, recursively \n+\tprocessing each one.\n+\t(tsubst_copy_and_build) <CALL_EXPR>: Update to use new\n+\tCALL_EXPR accessor macros.\n+\t(value_dependent_expression_p) <default>: Handle tcc_vl_exp\n+\ttree code classes. Use TREE_OPERAND_LENGTH instead of \n+\tTREE_CODE_LENGTH.\n+\n+\t* semantics.c (finish_call_expr): Use build_nt_call_list\n+\tinstead of build_nt.\n+\t(simplify_aggr_init_expr): Update to use new AGGR_INIT_EXPR \n+\taccessor macros. Use build_call_array to construct the \n+\tCALL_EXPR node instead of build3\n+\t\n+\t* decl2.c (build_offset_ref_call_from_tree): Use \n+\tbuild_nt_call_list and build_min_non_dep_call_list instead\n+\tof build_min_nt and build_min_non_dep.\n+\n+\t* parser.c (cp_parser_postfix_expression) <CPP_OPEN_PAREN>:\n+\tUse build_nt_call_list instead of build_min_nt.\n+\n 2007-02-15  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/28943"}, {"sha": "b1b5a8e827757ba2e6e165f2e44e8d4502e618e8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -336,7 +336,7 @@ build_call (tree function, tree parms)\n \t\t\t\t     TREE_VALUE (tmp), t);\n \t}\n \n-  function = build3 (CALL_EXPR, result_type, function, parms, NULL_TREE);\n+  function = build_call_list (result_type, function, parms);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n   TREE_NOTHROW (function) = nothrow;\n \n@@ -4740,7 +4740,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       tree expr;\n       tree return_type;\n       return_type = TREE_TYPE (TREE_TYPE (fn));\n-      expr = build3 (CALL_EXPR, return_type, fn, args, NULL_TREE);\n+      expr = build_call_list (return_type, fn, args);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n       if (!VOID_TYPE_P (return_type))\n@@ -5122,7 +5122,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   lookup_fn = build1 (ADDR_EXPR,\n \t\t      build_pointer_type (TREE_TYPE (java_iface_lookup_fn)),\n \t\t      java_iface_lookup_fn);\n-  return build3 (CALL_EXPR, ptr_type_node, lookup_fn, lookup_args, NULL_TREE);\n+  return build_call_list (ptr_type_node, lookup_fn, lookup_args);\n }\n \n /* Returns the value to use for the in-charge parameter when making a\n@@ -5533,10 +5533,10 @@ build_new_method_call (tree instance, tree fns, tree args,\n     }\n \n   if (processing_template_decl && call != error_mark_node)\n-    call = (build_min_non_dep\n-\t    (CALL_EXPR, call,\n+    call = (build_min_non_dep_call_list\n+\t    (call,\n \t     build_min_nt (COMPONENT_REF, orig_instance, orig_fns, NULL_TREE),\n-\t     orig_args, NULL_TREE));\n+\t     orig_args));\n \n  /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);"}, {"sha": "aa1b0ed73c9f7d65088dd06418b382d33132ff90", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -410,7 +410,7 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   if (TREE_CODE (sub) == AGGR_INIT_EXPR)\n     {\n       gimplify_expr (&to, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n-      TREE_OPERAND (sub, 2) = to;\n+      AGGR_INIT_EXPR_SLOT (sub) = to;\n       *expr_p = from;\n \n       /* The initialization is now a side-effect, so the container can"}, {"sha": "bcc6b54223cedf08c652e1aa703427ff86254bf1", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -74,10 +74,12 @@ DEFTREECODE (MEMBER_REF, \"member_ref\", tcc_reference, 2)\n    operator converts to.  Operand is expression to be converted.  */\n DEFTREECODE (TYPE_EXPR, \"type_expr\", tcc_expression, 1)\n \n-/* For AGGR_INIT_EXPR, operand 0 is function which performs initialization,\n-   operand 1 is argument list to initialization function,\n-   and operand 2 is the slot which was allocated for this expression.  */\n-DEFTREECODE (AGGR_INIT_EXPR, \"aggr_init_expr\", tcc_expression, 3)\n+/* AGGR_INIT_EXPRs have a variably-sized representation similar to\n+   that of CALL_EXPRs.  Operand 0 is an INTEGER_CST node containing the\n+   operand count, operand 1 is the function which performs initialization,\n+   operand 2 is the slot which was allocated for this expression, and\n+   the remaining operands are the arguments to the initialization function.  */\n+DEFTREECODE (AGGR_INIT_EXPR, \"aggr_init_expr\", tcc_vl_exp, 3)\n \n /* A throw expression.  operand 0 is the expression, if there was one,\n    else it is NULL_TREE.  */"}, {"sha": "b3857815c2a2933da7904e59d942743fe45aff16", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2331,6 +2331,85 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define AGGR_INIT_VIA_CTOR_P(NODE) \\\n   TREE_LANG_FLAG_0 (AGGR_INIT_EXPR_CHECK (NODE))\n \n+/* AGGR_INIT_EXPR accessors.  These are equivalent to the CALL_EXPR\n+   accessors, except for AGGR_INIT_EXPR_SLOT (which takes the place of\n+   CALL_EXPR_STATIC_CHAIN).  */\n+\n+#define AGGR_INIT_EXPR_FN(NODE) TREE_OPERAND (AGGR_INIT_EXPR_CHECK (NODE), 1)\n+#define AGGR_INIT_EXPR_SLOT(NODE) \\\n+  TREE_OPERAND (AGGR_INIT_EXPR_CHECK (NODE), 2)\n+#define AGGR_INIT_EXPR_ARG(NODE, I) \\\n+  TREE_OPERAND (AGGR_INIT_EXPR_CHECK (NODE), (I) + 3)\n+#define aggr_init_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH(NODE) - 3)\n+\n+/* AGGR_INIT_EXPR_ARGP returns a pointer to the argument vector for NODE.\n+   We can't use &AGGR_INIT_EXPR_ARG (NODE, 0) because that will complain if\n+   the argument count is zero when checking is enabled.  Instead, do\n+   the pointer arithmetic to advance past the 3 fixed operands in a\n+   AGGR_INIT_EXPR.  That produces a valid pointer to just past the end of\n+   the operand array, even if it's not valid to dereference it.  */\n+#define AGGR_INIT_EXPR_ARGP(NODE) \\\n+  (&(TREE_OPERAND (AGGR_INIT_EXPR_CHECK (NODE), 0)) + 3)\n+\n+/* Abstract iterators for AGGR_INIT_EXPRs.  */\n+\n+/* Structure containing iterator state.  */\n+typedef struct aggr_init_expr_arg_iterator_d GTY (())\n+{\n+  tree t;\t/* the aggr_init_expr */\n+  int n;\t/* argument count */\n+  int i;\t/* next argument index */\n+} aggr_init_expr_arg_iterator;\n+\n+/* Initialize the abstract argument list iterator object ITER with the\n+   arguments from AGGR_INIT_EXPR node EXP.  */\n+static inline void\n+init_aggr_init_expr_arg_iterator (tree exp,\n+\t\t\t\t       aggr_init_expr_arg_iterator *iter)\n+{\n+  iter->t = exp;\n+  iter->n = aggr_init_expr_nargs (exp);\n+  iter->i = 0;\n+}\n+\n+/* Return the next argument from abstract argument list iterator object ITER,\n+   and advance its state.  Return NULL_TREE if there are no more arguments.  */\n+static inline tree\n+next_aggr_init_expr_arg (aggr_init_expr_arg_iterator *iter)\n+{\n+  tree result;\n+  if (iter->i >= iter->n)\n+    return NULL_TREE;\n+  result = AGGR_INIT_EXPR_ARG (iter->t, iter->i);\n+  iter->i++;\n+  return result;\n+}\n+\n+/* Initialize the abstract argument list iterator object ITER, then advance\n+   past and return the first argument.  Useful in for expressions, e.g.\n+     for (arg = first_aggr_init_expr_arg (exp, &iter); arg;\n+          arg = next_aggr_init_expr_arg (&iter))   */\n+static inline tree\n+first_aggr_init_expr_arg (tree exp, aggr_init_expr_arg_iterator *iter)\n+{\n+  init_aggr_init_expr_arg_iterator (exp, iter);\n+  return next_aggr_init_expr_arg (iter);\n+}\n+\n+/* Test whether there are more arguments in abstract argument list iterator\n+   ITER, without changing its state.  */\n+static inline bool\n+more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n+{\n+  return (iter->i < iter->n);\n+}\n+\n+/* Iterate through each argument ARG of AGGR_INIT_EXPR CALL, using variable\n+   ITER (of type aggr_init_expr_arg_iterator) to hold the iteration state.  */\n+#define FOR_EACH_AGGR_INIT_EXPR_ARG(arg, iter, call)\t\t\t\\\n+  for ((arg) = first_aggr_init_expr_arg ((call), &(iter)); (arg);\t\\\n+       (arg) = next_aggr_init_expr_arg (&(iter)))\n+\n /* The TYPE_MAIN_DECL for a class template type is a TYPE_DECL, not a\n    TEMPLATE_DECL.  This macro determines whether or not a given class\n    type is really a template type, as opposed to an instantiation or\n@@ -4375,6 +4454,7 @@ extern void lang_check_failed\t\t\t(const char *, int,\n \t\t\t\t\t\t const char *) ATTRIBUTE_NORETURN;\n extern tree stabilize_expr\t\t\t(tree, tree *);\n extern void stabilize_call\t\t\t(tree, tree *);\n+extern void stabilize_aggr_init\t\t\t(tree, tree *);\n extern bool stabilize_init\t\t\t(tree, tree *);\n extern tree add_stmt_to_compound\t\t(tree, tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree);\n@@ -4390,6 +4470,7 @@ extern bool builtin_valid_in_constant_expr_p    (tree);\n extern tree build_min\t\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_nt\t\t\t(enum tree_code, ...);\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n+extern tree build_min_non_dep_call_list\t\t(tree, tree, tree);\n extern tree build_cplus_new\t\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n extern tree build_cplus_array_type\t\t(tree, tree);"}, {"sha": "497179b3bbc5e3244e2a8ad7643b3ff302a83fc7", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -902,9 +902,11 @@ convert_to_void (tree expr, const char *implicit)\n \t  if (TREE_CODE (init) == AGGR_INIT_EXPR\n \t      && !AGGR_INIT_VIA_CTOR_P (init))\n \t    {\n-\t      tree fn = TREE_OPERAND (init, 0);\n-\t      expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n-\t\t\t     fn, TREE_OPERAND (init, 1), NULL_TREE);\n+\t      tree fn = AGGR_INIT_EXPR_FN (init);\n+\t      expr = build_call_array (TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n+\t\t\t\t       fn,\n+\t\t\t\t       aggr_init_expr_nargs (init),\n+\t\t\t\t       AGGR_INIT_EXPR_ARGP (init));\n \t    }\n \t}\n       break;"}, {"sha": "5c13362df9545a10e090c5cc7a6021aeb33c44c3", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -412,9 +412,11 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n     case AGGR_INIT_EXPR:\n     case CALL_EXPR:\n       {\n-\ttree fun = TREE_OPERAND (t, 0);\n-\ttree args = TREE_OPERAND (t, 1);\n+\ttree fun = (code == AGGR_INIT_EXPR ? AGGR_INIT_EXPR_FN (t)\n+\t\t\t\t\t   : CALL_EXPR_FN (t));\n \ttree saved_scope = pp->enclosing_scope;\n+\tbool skipfirst = false;\n+\ttree arg;\n \n \tif (TREE_CODE (fun) == ADDR_EXPR)\n \t  fun = TREE_OPERAND (fun, 0);\n@@ -427,9 +429,11 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n \t  ;\n \telse if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun))\n \t  {\n-\t    tree object = code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t)\n-\t      ? TREE_OPERAND (t, 2)\n-\t      : TREE_VALUE (args);\n+\t    tree object = (code == AGGR_INIT_EXPR\n+\t\t\t   ? (AGGR_INIT_VIA_CTOR_P (t)\n+\t\t\t      ? AGGR_INIT_EXPR_SLOT (t)\n+\t\t\t      : AGGR_INIT_EXPR_ARG (t, 0))\n+\t\t\t   : CALL_EXPR_ARG (t, 0));\n \n \t    while (TREE_CODE (object) == NOP_EXPR)\n \t      object = TREE_OPERAND (object, 0);\n@@ -447,18 +451,49 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n \t\tpp_cxx_postfix_expression (pp, object);\n \t\tpp_cxx_arrow (pp);\n \t      }\n-\t    args = TREE_CHAIN (args);\n+\t    skipfirst = true;\n \t    pp->enclosing_scope = strip_pointer_operator (TREE_TYPE (object));\n \t  }\n \n \tpp_cxx_postfix_expression (pp, fun);\n \tpp->enclosing_scope = saved_scope;\n-\tpp_cxx_call_argument_list (pp, args);\n+\tpp_cxx_left_paren (pp);\n+\tif (code == AGGR_INIT_EXPR)\n+\t  {\n+\t    aggr_init_expr_arg_iterator iter;\n+\t    FOR_EACH_AGGR_INIT_EXPR_ARG (arg, iter, t)\n+\t      {\n+\t\tif (skipfirst)\n+\t\t  skipfirst = false;\n+\t\telse\n+\t\t  {\n+\t\t    pp_cxx_expression (pp, arg);\n+\t\t    if (more_aggr_init_expr_args_p (&iter))\n+\t\t      pp_cxx_separate_with (pp, ',');\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    call_expr_arg_iterator iter;\n+\t    FOR_EACH_CALL_EXPR_ARG (arg, iter, t)\n+\t      {\n+\t\tif (skipfirst)\n+\t\t  skipfirst = false;\n+\t\telse\n+\t\t  {\n+\t\t    pp_cxx_expression (pp, arg);\n+\t\t    if (more_call_expr_args_p (&iter))\n+\t\t      pp_cxx_separate_with (pp, ',');\n+\t\t  }\n+\t      }\n+\t  }\n+\tpp_cxx_right_paren (pp);\n       }\n       if (code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t))\n \t{\n \t  pp_cxx_separate_with (pp, ',');\n-\t  pp_cxx_postfix_expression (pp, TREE_OPERAND (t, 2));\n+\t  pp_cxx_postfix_expression (pp, AGGR_INIT_EXPR_SLOT (t));\n \t}\n       break;\n "}, {"sha": "68917b68bd9d52d42fd1f20d62a45ba91c1cb7e6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -3401,7 +3401,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \t\t  || TREE_CODE (fn) == MEMBER_REF);\n       if (type_dependent_expression_p (fn)\n \t  || any_type_dependent_arguments_p (args))\n-\treturn build_min_nt (CALL_EXPR, fn, args, NULL_TREE);\n+\treturn build_nt_call_list (fn, args);\n \n       /* Transform the arguments and add the implicit \"this\"\n \t parameter.  That must be done before the FN is transformed\n@@ -3431,7 +3431,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \n   expr = build_function_call (fn, args);\n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (CALL_EXPR, expr, orig_fn, orig_args, NULL_TREE);\n+    return build_min_non_dep_call_list (expr, orig_fn, orig_args);\n   return expr;\n }\n "}, {"sha": "de569f2d894f6c3bed8ac44bb5c1dfa69275d53e", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -388,10 +388,21 @@ cp_dump_tree (void* dump_info, tree t)\n       break;\n \n     case AGGR_INIT_EXPR:\n-      dump_int (di, \"ctor\", AGGR_INIT_VIA_CTOR_P (t));\n-      dump_child (\"fn\", TREE_OPERAND (t, 0));\n-      dump_child (\"args\", TREE_OPERAND (t, 1));\n-      dump_child (\"decl\", TREE_OPERAND (t, 2));\n+      {\n+\tint i = 0;\n+\ttree arg;\n+\taggr_init_expr_arg_iterator iter;\n+\tdump_int (di, \"ctor\", AGGR_INIT_VIA_CTOR_P (t));\n+\tdump_child (\"fn\", AGGR_INIT_EXPR_FN (t));\n+\tFOR_EACH_AGGR_INIT_EXPR_ARG (arg, iter, t)\n+\t  {\n+\t    char buffer[32];\n+\t    sprintf (buffer, \"%u\", i);\n+\t    dump_child (buffer, arg);\n+\t    i++;\n+\t  }\n+\tdump_child (\"decl\", AGGR_INIT_EXPR_SLOT (t));\n+      }\n       break;\n \n     case HANDLER:"}, {"sha": "6a0eed5e16b13c8ab720a97449cbd546c4f85331", "filename": "gcc/cp/error.c", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -66,6 +66,8 @@ static void dump_aggr_type (tree, int);\n static void dump_type_prefix (tree, int);\n static void dump_type_suffix (tree, int);\n static void dump_function_name (tree, int);\n+static void dump_call_expr_args (tree, int, bool);\n+static void dump_aggr_init_expr_args (tree, int, bool);\n static void dump_expr_list (tree, int);\n static void dump_global_iord (tree);\n static void dump_parameters (tree, int);\n@@ -1265,6 +1267,55 @@ dump_template_parms (tree info, int primary, int flags)\n   pp_cxx_end_template_argument_list (cxx_pp);\n }\n \n+/* Print out the arguments of CALL_EXPR T as a parenthesized list using\n+   flags FLAGS.  Skip over the first argument if SKIPFIRST is true.  */\n+\n+static void\n+dump_call_expr_args (tree t, int flags, bool skipfirst)\n+{\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+  \n+  pp_cxx_left_paren (cxx_pp);\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, t)\n+    {\n+      if (skipfirst)\n+\tskipfirst = false;\n+      else\n+\t{\n+\t  dump_expr (arg, flags | TFF_EXPR_IN_PARENS);\n+\t  if (more_call_expr_args_p (&iter))\n+\t    pp_separate_with_comma (cxx_pp);\n+\t}\n+    }\n+  pp_cxx_right_paren (cxx_pp);\n+}\n+\n+/* Print out the arguments of AGGR_INIT_EXPR T as a parenthesized list\n+   using flags FLAGS.  Skip over the first argument if SKIPFIRST is\n+   true.  */\n+\n+static void\n+dump_aggr_init_expr_args (tree t, int flags, bool skipfirst)\n+{\n+  tree arg;\n+  aggr_init_expr_arg_iterator iter;\n+  \n+  pp_cxx_left_paren (cxx_pp);\n+  FOR_EACH_AGGR_INIT_EXPR_ARG (arg, iter, t)\n+    {\n+      if (skipfirst)\n+\tskipfirst = false;\n+      else\n+\t{\n+\t  dump_expr (arg, flags | TFF_EXPR_IN_PARENS);\n+\t  if (more_aggr_init_expr_args_p (&iter))\n+\t    pp_separate_with_comma (cxx_pp);\n+\t}\n+    }\n+  pp_cxx_right_paren (cxx_pp);\n+}\n+\n /* Print out a list of initializers (subr of dump_expr).  */\n \n static void\n@@ -1387,8 +1438,8 @@ dump_expr (tree t, int flags)\n       {\n \ttree fn = NULL_TREE;\n \n-\tif (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n-\t  fn = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\tif (TREE_CODE (AGGR_INIT_EXPR_FN (t)) == ADDR_EXPR)\n+\t  fn = TREE_OPERAND (AGGR_INIT_EXPR_FN (t), 0);\n \n \tif (fn && TREE_CODE (fn) == FUNCTION_DECL)\n \t  {\n@@ -1398,18 +1449,15 @@ dump_expr (tree t, int flags)\n \t      dump_decl (fn, 0);\n \t  }\n \telse\n-\t  dump_expr (TREE_OPERAND (t, 0), 0);\n+\t  dump_expr (AGGR_INIT_EXPR_FN (t), 0);\n       }\n-      pp_cxx_left_paren (cxx_pp);\n-      if (TREE_OPERAND (t, 1))\n-\tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-      pp_cxx_right_paren (cxx_pp);\n+      dump_aggr_init_expr_args (t, flags, false);\n       break;\n \n     case CALL_EXPR:\n       {\n-\ttree fn = TREE_OPERAND (t, 0);\n-\ttree args = TREE_OPERAND (t, 1);\n+\ttree fn = CALL_EXPR_FN (t);\n+\tbool skipfirst = false;\n \n \tif (TREE_CODE (fn) == ADDR_EXPR)\n \t  fn = TREE_OPERAND (fn, 0);\n@@ -1420,7 +1468,7 @@ dump_expr (tree t, int flags)\n \n \tif (TREE_TYPE (fn) != NULL_TREE && NEXT_CODE (fn) == METHOD_TYPE)\n \t  {\n-\t    tree ob = TREE_VALUE (args);\n+\t    tree ob = CALL_EXPR_ARG (t, 0);\n \t    if (TREE_CODE (ob) == ADDR_EXPR)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n@@ -1432,12 +1480,10 @@ dump_expr (tree t, int flags)\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n \t\tpp_arrow (cxx_pp);\n \t      }\n-\t    args = TREE_CHAIN (args);\n+\t    skipfirst = true;\n \t  }\n \tdump_expr (fn, flags | TFF_EXPR_IN_PARENS);\n-\tpp_cxx_left_paren (cxx_pp);\n-\tdump_expr_list (args, flags);\n-\tpp_cxx_right_paren (cxx_pp);\n+\tdump_call_expr_args (t, flags, skipfirst);\n       }\n       break;\n \n@@ -1581,10 +1627,8 @@ dump_expr (tree t, int flags)\n \t{\n \t  t = TREE_OPERAND (t, 0);\n \t  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n-\t  dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-\t  pp_cxx_left_paren (cxx_pp);\n-\t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-\t  pp_cxx_right_paren (cxx_pp);\n+\t  dump_expr (CALL_EXPR_FN (t), flags | TFF_EXPR_IN_PARENS);\n+\t  dump_call_expr_args (t, flags, true);\n \t}\n       else\n \t{"}, {"sha": "94d7ed5e92c1384c69ab97a01087dfc72aa76723", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2206,7 +2206,7 @@ write_expression (tree expr)\n \t  break;\n \n \tdefault:\n-\t  for (i = 0; i < TREE_CODE_LENGTH (code); ++i)\n+\t  for (i = 0; i < TREE_OPERAND_LENGTH (expr); ++i)\n \t    {\n \t      tree operand = TREE_OPERAND (expr, i);\n \t      /* As a GNU extension, the middle operand of a"}, {"sha": "b8af4d288bd939b8949a4442d883947eef06d496", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -4443,8 +4443,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t\t\t|| any_type_dependent_arguments_p (args)))\n \t\t  {\n \t\t    postfix_expression\n-\t\t      = build_min_nt (CALL_EXPR, postfix_expression,\n-\t\t\t\t      args, NULL_TREE);\n+\t\t      = build_nt_call_list (postfix_expression, args);\n \t\t    break;\n \t\t  }\n "}, {"sha": "31ad46c505282007a539c6876ee38d77e6022fda", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -8350,12 +8350,15 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t NULL_TREE, NULL_TREE);\n \n     case CALL_EXPR:\n-      return build_nt (code,\n-\t\t       tsubst_copy (TREE_OPERAND (t, 0), args,\n-\t\t\t\t    complain, in_decl),\n-\t\t       tsubst_copy (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t    in_decl),\n-\t\t       NULL_TREE);\n+      {\n+\tint n = VL_EXP_OPERAND_LENGTH (t);\n+\ttree result = build_vl_exp (CALL_EXPR, n);\n+\tint i;\n+\tfor (i = 0; i < n; i++)\n+\t  TREE_OPERAND (t, i) = tsubst_copy (TREE_OPERAND (t, i), args,\n+\t\t\t\t\t     complain, in_decl);\n+\treturn result;\n+      }\n \n     case COND_EXPR:\n     case MODOP_EXPR:\n@@ -9271,7 +9274,7 @@ tsubst_copy_and_build (tree t,\n \tbool qualified_p;\n \tbool koenig_p;\n \n-\tfunction = TREE_OPERAND (t, 0);\n+\tfunction = CALL_EXPR_FN (t);\n \t/* When we parsed the expression,  we determined whether or\n \t   not Koenig lookup should be performed.  */\n \tkoenig_p = KOENIG_LOOKUP_P (t);\n@@ -9304,7 +9307,8 @@ tsubst_copy_and_build (tree t,\n \t      qualified_p = true;\n \t  }\n \n-\tcall_args = RECUR (TREE_OPERAND (t, 1));\n+\t/* FIXME:  Rewrite this so as not to construct an arglist.  */\n+\tcall_args = RECUR (CALL_EXPR_ARGS (t));\n \n \t/* We do not perform argument-dependent lookup if normal\n \t   lookup finds a non-function, in accordance with the\n@@ -13064,9 +13068,10 @@ value_dependent_expression_p (tree expression)\n \t\t      (TREE_OPERAND (expression, 1))));\n \n \tcase tcc_expression:\n+\tcase tcc_vl_exp:\n \t  {\n \t    int i;\n-\t    for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (expression)); ++i)\n+\t    for (i = 0; i < TREE_OPERAND_LENGTH (expression); ++i)\n \t      /* In some cases, some of the operands may be missing.\n \t\t (For example, in the case of PREDECREMENT_EXPR, the\n \t\t amount to increment by may be missing.)  That doesn't"}, {"sha": "3df045e733d8aa7a27b35289210aeda5c7376f93", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1789,7 +1789,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       if (type_dependent_expression_p (fn)\n \t  || any_type_dependent_arguments_p (args))\n \t{\n-\t  result = build_nt (CALL_EXPR, fn, args, NULL_TREE);\n+\t  result = build_nt_call_list (fn, args);\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  return result;\n \t}\n@@ -1846,7 +1846,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       if (processing_template_decl)\n \t{\n \t  if (type_dependent_expression_p (object))\n-\t    return build_nt (CALL_EXPR, orig_fn, orig_args, NULL_TREE);\n+\t    return build_nt_call_list (orig_fn, orig_args);\n \t  object = build_non_dependent_expr (object);\n \t}\n \n@@ -1890,8 +1890,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \n   if (processing_template_decl)\n     {\n-      result = build3 (CALL_EXPR, TREE_TYPE (result), orig_fn,\n-\t\t       orig_args, NULL_TREE);\n+      result = build_call_list (TREE_TYPE (result), orig_fn, orig_args);\n       KOENIG_LOOKUP_P (result) = koenig_p;\n     }\n   return result;\n@@ -2975,9 +2974,8 @@ simplify_aggr_init_expr (tree *tp)\n   tree aggr_init_expr = *tp;\n \n   /* Form an appropriate CALL_EXPR.  */\n-  tree fn = TREE_OPERAND (aggr_init_expr, 0);\n-  tree args = TREE_OPERAND (aggr_init_expr, 1);\n-  tree slot = TREE_OPERAND (aggr_init_expr, 2);\n+  tree fn = AGGR_INIT_EXPR_FN (aggr_init_expr);\n+  tree slot = AGGR_INIT_EXPR_SLOT (aggr_init_expr);\n   tree type = TREE_TYPE (slot);\n \n   tree call_expr;\n@@ -2995,23 +2993,20 @@ simplify_aggr_init_expr (tree *tp)\n       style = arg;\n     }\n \n+  call_expr = build_call_array (TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n+\t\t\t\tfn,\n+\t\t\t\taggr_init_expr_nargs (aggr_init_expr),\n+\t\t\t\tAGGR_INIT_EXPR_ARGP (aggr_init_expr));\n+\n   if (style == ctor)\n     {\n       /* Replace the first argument to the ctor with the address of the\n \t slot.  */\n-      tree addr;\n-\n-      args = TREE_CHAIN (args);\n       cxx_mark_addressable (slot);\n-      addr = build1 (ADDR_EXPR, build_pointer_type (type), slot);\n-      args = tree_cons (NULL_TREE, addr, args);\n+      CALL_EXPR_ARG (call_expr, 0) =\n+\tbuild1 (ADDR_EXPR, build_pointer_type (type), slot);\n     }\n-\n-  call_expr = build3 (CALL_EXPR,\n-\t\t      TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n-\t\t      fn, args, NULL_TREE);\n-\n-  if (style == arg)\n+  else if (style == arg)\n     {\n       /* Just mark it addressable here, and leave the rest to\n \t expand_call{,_inline}.  */"}, {"sha": "7c5a4dc5bddd969b4fde7883432db1f73bf576e4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 149, "deletions": 23, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -261,8 +261,55 @@ build_local_temp (tree type)\n   return slot;\n }\n \n-/* INIT is a CALL_EXPR which needs info about its target.\n-   TYPE is the type that this initialization should appear to have.\n+/* Set various status flags when building an AGGR_INIT_EXPR object T.  */\n+\n+static void\n+process_aggr_init_operands (tree t)\n+{\n+  bool side_effects;\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+  if (!side_effects)\n+    {\n+      int i, n;\n+      n = TREE_OPERAND_LENGTH (t);\n+      for (i = 1; i < n; i++)\n+\t{\n+\t  tree op = TREE_OPERAND (t, i);\n+\t  if (op && TREE_SIDE_EFFECTS (op))\n+\t    {\n+\t      side_effects = 1;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  TREE_SIDE_EFFECTS (t) = side_effects;\n+}\n+\n+/* Build an AGGR_INIT_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE,\n+   FN, and SLOT.  NARGS is the number of call arguments which are specified\n+   as a tree array ARGS.  */\n+\n+static tree\n+build_aggr_init_array (tree return_type, tree fn, tree slot, int nargs,\n+\t\t       tree *args)\n+{\n+  tree t;\n+  int i;\n+\n+  t = build_vl_exp (AGGR_INIT_EXPR, nargs + 3);\n+  TREE_TYPE (t) = return_type;\n+  AGGR_INIT_EXPR_FN (t) = fn;\n+  AGGR_INIT_EXPR_SLOT (t) = slot;\n+  for (i = 0; i < nargs; i++)\n+    AGGR_INIT_EXPR_ARG (t, i) = args[i];\n+  process_aggr_init_operands (t);\n+  return t;\n+}\n+\n+/* INIT is a CALL_EXPR or AGGR_INIT_EXPR which needs info about its\n+   target.  TYPE is the type that this initialization should appear to\n+   have.\n \n    Build an encapsulation of the initialization to perform\n    and return it so that it can be processed by language-independent\n@@ -280,10 +327,13 @@ build_cplus_new (tree type, tree init)\n      abstract class.  */\n   abstract_virtuals_error (NULL_TREE, type);\n \n-  if (TREE_CODE (init) != CALL_EXPR && TREE_CODE (init) != AGGR_INIT_EXPR)\n+  if (TREE_CODE (init) == CALL_EXPR)\n+    fn = CALL_EXPR_FN (init);\n+  else if (TREE_CODE (init) == AGGR_INIT_EXPR)\n+    fn = AGGR_INIT_EXPR_FN (init);\n+  else\n     return convert (type, init);\n \n-  fn = TREE_OPERAND (init, 0);\n   is_ctor = (TREE_CODE (fn) == ADDR_EXPR\n \t     && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n \t     && DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0)));\n@@ -303,8 +353,14 @@ build_cplus_new (tree type, tree init)\n      type, don't mess with AGGR_INIT_EXPR.  */\n   if (is_ctor || TREE_ADDRESSABLE (type))\n     {\n-      rval = build3 (AGGR_INIT_EXPR, void_type_node, fn,\n-\t\t     TREE_OPERAND (init, 1), slot);\n+      if (TREE_CODE(init) == CALL_EXPR)\n+\trval = build_aggr_init_array (void_type_node, fn, slot,\n+\t\t\t\t      call_expr_nargs (init),\n+\t\t\t\t      CALL_EXPR_ARGP (init));\n+      else\n+\trval = build_aggr_init_array (void_type_node, fn, slot,\n+\t\t\t\t      aggr_init_expr_nargs (init),\n+\t\t\t\t      AGGR_INIT_EXPR_ARGP (init));\n       TREE_SIDE_EFFECTS (rval) = 1;\n       AGGR_INIT_VIA_CTOR_P (rval) = is_ctor;\n     }\n@@ -1420,6 +1476,8 @@ build_min_nt (enum tree_code code, ...)\n   int i;\n   va_list p;\n \n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n   va_start (p, code);\n \n   t = make_node (code);\n@@ -1435,6 +1493,7 @@ build_min_nt (enum tree_code code, ...)\n   return t;\n }\n \n+\n /* Similar to `build', but for template definitions.  */\n \n tree\n@@ -1445,6 +1504,8 @@ build_min (enum tree_code code, tree tt, ...)\n   int i;\n   va_list p;\n \n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n   va_start (p, tt);\n \n   t = make_node (code);\n@@ -1475,6 +1536,8 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n   int i;\n   va_list p;\n \n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n   va_start (p, non_dep);\n \n   t = make_node (code);\n@@ -1497,6 +1560,19 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n   return t;\n }\n \n+/* Similar to `build_call_list', but for template definitions of non-dependent\n+   expressions. NON_DEP is the non-dependent expression that has been\n+   built.  */\n+\n+tree\n+build_min_non_dep_call_list (tree non_dep, tree fn, tree arglist)\n+{\n+  tree t = build_nt_call_list (fn, arglist);\n+  TREE_TYPE (t) = TREE_TYPE (non_dep);\n+  TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (non_dep);\n+  return t;\n+}\n+\n tree\n get_type_decl (tree t)\n {\n@@ -1615,9 +1691,20 @@ cp_tree_equal (tree t1, tree t2)\n       return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n \n     case CALL_EXPR:\n-      if (!cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n-\treturn false;\n-      return cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+      {\n+\ttree arg1, arg2;\n+\tcall_expr_arg_iterator iter1, iter2;\n+\tif (!cp_tree_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))\n+\t  return false;\n+\tfor (arg1 = first_call_expr_arg (t1, &iter1),\n+\t       arg2 = first_call_expr_arg (t2, &iter2);\n+\t     arg1 && arg2;\n+\t     arg1 = next_call_expr_arg (&iter1),\n+\t       arg2 = next_call_expr_arg (&iter2))\n+\t  if (!cp_tree_equal (arg1, arg2))\n+\t    return false;\n+\treturn (arg1 || arg2);\n+      }\n \n     case TARGET_EXPR:\n       {\n@@ -1747,12 +1834,18 @@ cp_tree_equal (tree t1, tree t2)\n     case tcc_binary:\n     case tcc_comparison:\n     case tcc_expression:\n+    case tcc_vl_exp:\n     case tcc_reference:\n     case tcc_statement:\n       {\n-\tint i;\n+\tint i, n;\n+\n+\tn = TREE_OPERAND_LENGTH (t1);\n+\tif (TREE_CODE_CLASS (code1) == tcc_vl_exp\n+\t    && n != TREE_OPERAND_LENGTH (t2))\n+\t  return false;\n \n-\tfor (i = 0; i < TREE_CODE_LENGTH (code1); ++i)\n+\tfor (i = 0; i < n; ++i)\n \t  if (!cp_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i)))\n \t    return false;\n \n@@ -2438,21 +2531,49 @@ void\n stabilize_call (tree call, tree *initp)\n {\n   tree inits = NULL_TREE;\n-  tree t;\n+  int i;\n+  int nargs = call_expr_nargs (call);\n \n   if (call == error_mark_node)\n     return;\n \n-  gcc_assert (TREE_CODE (call) == CALL_EXPR\n-\t      || TREE_CODE (call) == AGGR_INIT_EXPR);\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n \n-  for (t = TREE_OPERAND (call, 1); t; t = TREE_CHAIN (t))\n-    if (TREE_SIDE_EFFECTS (TREE_VALUE (t)))\n-      {\n-\ttree init;\n-\tTREE_VALUE (t) = stabilize_expr (TREE_VALUE (t), &init);\n-\tinits = add_stmt_to_compound (inits, init);\n-      }\n+  for (i = 0; i < nargs; i++)\n+    {\n+      tree init;\n+      CALL_EXPR_ARG (call, i) =\n+\tstabilize_expr (CALL_EXPR_ARG (call, i), &init);\n+      inits = add_stmt_to_compound (inits, init);\n+    }\n+\n+  *initp = inits;\n+}\n+\n+/* Like stabilize_expr, but for an AGGR_INIT_EXPR whose arguments we want\n+   to pre-evaluate.  CALL is modified in place to use the pre-evaluated\n+   arguments, while, upon return, *INITP contains an expression to\n+   compute the arguments.  */\n+\n+void\n+stabilize_aggr_init (tree call, tree *initp)\n+{\n+  tree inits = NULL_TREE;\n+  int i;\n+  int nargs = aggr_init_expr_nargs (call);\n+\n+  if (call == error_mark_node)\n+    return;\n+\n+  gcc_assert (TREE_CODE (call) == AGGR_INIT_EXPR);\n+\n+  for (i = 0; i < nargs; i++)\n+    {\n+      tree init;\n+      AGGR_INIT_EXPR_ARG (call, i) =\n+\tstabilize_expr (AGGR_INIT_EXPR_ARG (call, i), &init);\n+      inits = add_stmt_to_compound (inits, init);\n+    }\n \n   *initp = inits;\n }\n@@ -2499,13 +2620,18 @@ stabilize_init (tree init, tree *initp)\n   if (TREE_CODE (t) == COND_EXPR)\n     return false;\n \n-  if (TREE_CODE (t) == CALL_EXPR\n-      || TREE_CODE (t) == AGGR_INIT_EXPR)\n+  if (TREE_CODE (t) == CALL_EXPR)\n     {\n       stabilize_call (t, initp);\n       return true;\n     }\n \n+  if (TREE_CODE (t) == AGGR_INIT_EXPR)\n+    {\n+      stabilize_aggr_init (t, initp);\n+      return true;\n+    }\n+\n   /* The initialization is being performed via a bitwise copy -- and\n      the item copied may have side effects.  */\n   return TREE_SIDE_EFFECTS (init);"}, {"sha": "4bf0905712484241d13f3cb3f3838690094b4d96", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2474,19 +2474,39 @@ argument does cause side-effects.\n \n @item CALL_EXPR\n These nodes are used to represent calls to functions, including\n-non-static member functions.  The first operand is a pointer to the\n+non-static member functions.  @code{CALL_EXPR}s are implemented as\n+expression nodes with a variable number of operands.  Rather than using\n+@code{TREE_OPERAND} to extract them, it is preferable to use the\n+specialized accessor macros and functions that operate specifically on\n+@code{CALL_EXPR} nodes.\n+\n+@code{CALL_EXPR_FN} returns a pointer to the\n function to call; it is always an expression whose type is a\n-@code{POINTER_TYPE}.  The second argument is a @code{TREE_LIST}.  The\n-arguments to the call appear left-to-right in the list.  The\n-@code{TREE_VALUE} of each list node contains the expression\n-corresponding to that argument.  (The value of @code{TREE_PURPOSE} for\n-these nodes is unspecified, and should be ignored.)  For non-static\n+@code{POINTER_TYPE}.\n+\n+The number of arguments to the call is returned by @code{call_expr_nargs},\n+while the arguments themselves can be accessed with the @code{CALL_EXPR_ARG} \n+macro.  The arguments are zero-indexed and numbered left-to-right.  \n+You can iterate over the arguments using @code{FOR_EACH_CALL_EXPR_ARG}, as in:\n+\n+@smallexample\n+tree call, arg;\n+call_expr_arg_iterator iter;\n+FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+  /* arg is bound to successive arguments of call.  */\n+  ...;\n+@end smallexample\n+\n+For non-static\n member functions, there will be an operand corresponding to the\n @code{this} pointer.  There will always be expressions corresponding to\n all of the arguments, even if the function is declared with default\n arguments and some arguments are not explicitly provided at the call\n sites.\n \n+@code{CALL_EXPR}s also have a @code{CALL_EXPR_STATIC_CHAIN} operand that\n+is used to implement nested functions.  This operand is otherwise null.\n+\n @item STMT_EXPR\n These nodes are used to represent GCC's statement-expression extension.\n The statement-expression extension allows code like this:\n@@ -2613,15 +2633,14 @@ cleanups.\n An @code{AGGR_INIT_EXPR} represents the initialization as the return\n value of a function call, or as the result of a constructor.  An\n @code{AGGR_INIT_EXPR} will only appear as a full-expression, or as the\n-second operand of a @code{TARGET_EXPR}.  The first operand to the\n-@code{AGGR_INIT_EXPR} is the address of a function to call, just as in\n-a @code{CALL_EXPR}.  The second operand are the arguments to pass that\n-function, as a @code{TREE_LIST}, again in a manner similar to that of\n-a @code{CALL_EXPR}.\n+second operand of a @code{TARGET_EXPR}.  @code{AGGR_INIT_EXPR}s have\n+a representation similar to that of @code{CALL_EXPR}s.  You can use\n+the @code{AGGR_INIT_EXPR_FN} and @code{AGGR_INIT_EXPR_ARG} macros to access\n+the function to call and the arguments to pass.\n \n If @code{AGGR_INIT_VIA_CTOR_P} holds of the @code{AGGR_INIT_EXPR}, then\n-the initialization is via a constructor call.  The address of the third\n-operand of the @code{AGGR_INIT_EXPR}, which is always a @code{VAR_DECL},\n+the initialization is via a constructor call.  The address of the\n+@code{AGGR_INIT_EXPR_SLOT} operand, which is always a @code{VAR_DECL},\n is taken, and this value replaces the first argument in the argument\n list.\n "}, {"sha": "915059c39717524fb7c455907d36811103988400", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2867,9 +2867,9 @@ expand_builtin_unwind_init (void)\n }\n \n rtx\n-expand_builtin_eh_return_data_regno (tree arglist)\n+expand_builtin_eh_return_data_regno (tree exp)\n {\n-  tree which = TREE_VALUE (arglist);\n+  tree which = CALL_EXPR_ARG (exp, 0);\n   unsigned HOST_WIDE_INT iwhich;\n \n   if (TREE_CODE (which) != INTEGER_CST)"}, {"sha": "1c2ff13fa17ddd0d1d197f9e7d862e37e800009f", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1355,7 +1355,7 @@ rtx\n emit_block_move_via_libcall (rtx dst, rtx src, rtx size, bool tailcall)\n {\n   rtx dst_addr, src_addr;\n-  tree call_expr, arg_list, fn, src_tree, dst_tree, size_tree;\n+  tree call_expr, fn, src_tree, dst_tree, size_tree;\n   enum machine_mode size_mode;\n   rtx retval;\n \n@@ -1386,14 +1386,7 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size, bool tailcall)\n   size_tree = make_tree (sizetype, size);\n \n   fn = emit_block_move_libcall_fn (true);\n-  arg_list = tree_cons (NULL_TREE, size_tree, NULL_TREE);\n-  arg_list = tree_cons (NULL_TREE, src_tree, arg_list);\n-  arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);\n-\n-  /* Now we have to build up the CALL_EXPR itself.  */\n-  call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t      call_expr, arg_list, NULL_TREE);\n+  call_expr = build_call_expr (fn, 3, dst_tree, src_tree, size_tree);\n   CALL_EXPR_TAILCALL (call_expr) = tailcall;\n \n   retval = expand_normal (call_expr);\n@@ -2576,7 +2569,7 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n rtx\n set_storage_via_libcall (rtx object, rtx size, rtx val, bool tailcall)\n {\n-  tree call_expr, arg_list, fn, object_tree, size_tree, val_tree;\n+  tree call_expr, fn, object_tree, size_tree, val_tree;\n   enum machine_mode size_mode;\n   rtx retval;\n \n@@ -2602,14 +2595,8 @@ set_storage_via_libcall (rtx object, rtx size, rtx val, bool tailcall)\n   val_tree = make_tree (integer_type_node, val);\n \n   fn = clear_storage_libcall_fn (true);\n-  arg_list = tree_cons (NULL_TREE, size_tree, NULL_TREE);\n-  arg_list = tree_cons (NULL_TREE, val_tree, arg_list);\n-  arg_list = tree_cons (NULL_TREE, object_tree, arg_list);\n-\n-  /* Now we have to build up the CALL_EXPR itself.  */\n-  call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t      call_expr, arg_list, NULL_TREE);\n+  call_expr = build_call_expr (fn, 3,\n+\t\t\t       object_tree, integer_zero_node, size_tree);\n   CALL_EXPR_TAILCALL (call_expr) = tailcall;\n \n   retval = expand_normal (call_expr);\n@@ -6225,6 +6212,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n \n     case tcc_expression:\n     case tcc_reference:\n+    case tcc_vl_exp:\n       /* Now do code-specific tests.  EXP_RTL is set to any rtx we find in\n \t the expression.  If it is set, we conflict iff we are that rtx or\n \t both are in memory.  Otherwise, we check all operands of the\n@@ -6287,7 +6275,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n       if (exp_rtl)\n \tbreak;\n \n-      nops = TREE_CODE_LENGTH (TREE_CODE (exp));\n+      nops = TREE_OPERAND_LENGTH (exp);\n       for (i = 0; i < nops; i++)\n \tif (TREE_OPERAND (exp, i) != 0\n \t    && ! safe_from_p (x, TREE_OPERAND (exp, i), 0))\n@@ -7769,12 +7757,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+      if (TREE_CODE (CALL_EXPR_FN (exp)) == ADDR_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (CALL_EXPR_FN (exp), 0))\n \t      == FUNCTION_DECL)\n-\t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n+\t  && DECL_BUILT_IN (TREE_OPERAND (CALL_EXPR_FN (exp), 0)))\n \t{\n-\t  if (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t  if (DECL_BUILT_IN_CLASS (TREE_OPERAND (CALL_EXPR_FN (exp), 0))\n \t      == BUILT_IN_FRONTEND)\n \t    return lang_hooks.expand_expr (exp, original_target,\n \t\t\t\t\t   tmode, modifier,"}, {"sha": "0aca93c386afd0f5240662baaf790aa1201391c0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 194, "deletions": 154, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1195,7 +1195,7 @@ negate_expr_p (tree t)\n     case CALL_EXPR:\n       /* Negate -f(x) as f(-x).  */\n       if (negate_mathfn_p (builtin_mathfn_code (t)))\n-\treturn negate_expr_p (TREE_VALUE (TREE_OPERAND (t, 1)));\n+\treturn negate_expr_p (CALL_EXPR_ARG (t, 0));\n       break;\n \n     case RSHIFT_EXPR:\n@@ -1382,14 +1382,13 @@ fold_negate_expr (tree t)\n     case CALL_EXPR:\n       /* Negate -f(x) as f(-x).  */\n       if (negate_mathfn_p (builtin_mathfn_code (t))\n-\t  && negate_expr_p (TREE_VALUE (TREE_OPERAND (t, 1))))\n+\t  && negate_expr_p (CALL_EXPR_ARG (t, 0)))\n \t{\n-\t  tree fndecl, arg, arglist;\n+\t  tree fndecl, arg;\n \n \t  fndecl = get_callee_fndecl (t);\n-\t  arg = negate_expr (TREE_VALUE (TREE_OPERAND (t, 1)));\n-\t  arglist = build_tree_list (NULL_TREE, arg);\n-\t  return build_function_call_expr (fndecl, arglist);\n+\t  arg = negate_expr (CALL_EXPR_ARG (t, 0));\n+\t  return build_call_expr (fndecl, 1, arg);\n \t}\n       break;\n \n@@ -2929,10 +2928,18 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t      TREE_OPERAND (arg1, 0), flags));\n \n+\tdefault:\n+\t  return 0;\n+\t}\n+\n+    case tcc_vl_exp:\n+      switch (TREE_CODE (arg0))\n+\t{\n \tcase CALL_EXPR:\n \t  /* If the CALL_EXPRs call different functions, then they\n \t     clearly can not be equal.  */\n-\t  if (!OP_SAME (0))\n+\t  if (! operand_equal_p (CALL_EXPR_FN (arg0), CALL_EXPR_FN (arg1),\n+\t\t\t\t flags))\n \t    return 0;\n \n \t  {\n@@ -2945,25 +2952,22 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t      return 0;\n \t  }\n \n-\t  /* Now see if all the arguments are the same.  operand_equal_p\n-\t     does not handle TREE_LIST, so we walk the operands here\n-\t     feeding them to operand_equal_p.  */\n-\t  arg0 = TREE_OPERAND (arg0, 1);\n-\t  arg1 = TREE_OPERAND (arg1, 1);\n-\t  while (arg0 && arg1)\n-\t    {\n-\t      if (! operand_equal_p (TREE_VALUE (arg0), TREE_VALUE (arg1),\n-\t\t\t\t     flags))\n+\t  /* Now see if all the arguments are the same.  */\n+\t  {\n+\t    call_expr_arg_iterator iter0, iter1;\n+\t    tree a0, a1;\n+\t    for (a0 = first_call_expr_arg (arg0, &iter0),\n+\t\t   a1 = first_call_expr_arg (arg1, &iter1);\n+\t\t a0 && a1;\n+\t\t a0 = next_call_expr_arg (&iter0),\n+\t\t   a1 = next_call_expr_arg (&iter1))\n+\t      if (! operand_equal_p (a0, a1, flags))\n \t\treturn 0;\n \n-\t      arg0 = TREE_CHAIN (arg0);\n-\t      arg1 = TREE_CHAIN (arg1);\n-\t    }\n-\n-\t  /* If we get here and both argument lists are exhausted\n-\t     then the CALL_EXPRs are equal.  */\n-\t  return ! (arg0 || arg1);\n-\n+\t    /* If we get here and both argument lists are exhausted\n+\t       then the CALL_EXPRs are equal.  */\n+\t    return ! (a0 || a1);\n+\t  }\n \tdefault:\n \t  return 0;\n \t}\n@@ -4035,7 +4039,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n \n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n \t{\n-\t  if (TREE_CODE_LENGTH (code) > 0)\n+\t  if (TREE_OPERAND_LENGTH (exp) > 0)\n \t    arg0 = TREE_OPERAND (exp, 0);\n \t  if (TREE_CODE_CLASS (code) == tcc_comparison\n \t      || TREE_CODE_CLASS (code) == tcc_unary\n@@ -4044,7 +4048,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n \t  if (TREE_CODE_CLASS (code) == tcc_binary\n \t      || TREE_CODE_CLASS (code) == tcc_comparison\n \t      || (TREE_CODE_CLASS (code) == tcc_expression\n-\t\t  && TREE_CODE_LENGTH (code) > 1))\n+\t\t  && TREE_OPERAND_LENGTH (exp) > 1))\n \t    arg1 = TREE_OPERAND (exp, 1);\n \t}\n \n@@ -5677,6 +5681,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n       if ((COMPARISON_CLASS_P (op0)\n \t   || UNARY_CLASS_P (op0)\n \t   || BINARY_CLASS_P (op0)\n+\t   || VL_EXP_CLASS_P (op0)\n \t   || EXPRESSION_CLASS_P (op0))\n \t  /* ... and is unsigned, and its type is smaller than ctype,\n \t     then we cannot pass through as widening.  */\n@@ -6151,7 +6156,7 @@ fold_mathfn_compare (enum built_in_function fcode, enum tree_code code,\n \n   if (BUILTIN_SQRT_P (fcode))\n     {\n-      tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+      tree arg = CALL_EXPR_ARG (arg0, 0);\n       enum machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n \n       c = TREE_REAL_CST (arg1);\n@@ -7970,8 +7975,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t      CASE_FLT_FN (BUILT_IN_CEXPI):\n \t        fn = mathfn_built_in (type, BUILT_IN_COS);\n \t\tif (fn)\n-\t          return build_function_call_expr (fn,\n-\t\t\t\t\t\t   TREE_OPERAND (arg0, 1));\n+\t          return build_call_expr (fn, 1, CALL_EXPR_ARG (arg0, 0));\n \t\tbreak;\n \n \t      default:\n@@ -8013,8 +8017,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t      CASE_FLT_FN (BUILT_IN_CEXPI):\n \t        fn = mathfn_built_in (type, BUILT_IN_SIN);\n \t\tif (fn)\n-\t\t  return build_function_call_expr (fn,\n-\t\t\t\t\t\t   TREE_OPERAND (arg0, 1));\n+\t          return build_call_expr (fn, 1, CALL_EXPR_ARG (arg0, 0));\n \t\tbreak;\n \n \t      default:\n@@ -9807,9 +9810,9 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      /* Optimizations of root(...)*root(...).  */\n \t      if (fcode0 == fcode1 && BUILTIN_ROOT_P (fcode0))\n \t\t{\n-\t\t  tree rootfn, arg, arglist;\n-\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t\t  tree rootfn, arg;\n+\t\t  tree arg00 = CALL_EXPR_ARG (arg0, 0);\n+\t\t  tree arg10 = CALL_EXPR_ARG (arg1, 0);\n \n \t\t  /* Optimize sqrt(x)*sqrt(x) as x.  */\n \t\t  if (BUILTIN_SQRT_P (fcode0)\n@@ -9818,55 +9821,45 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t    return arg00;\n \n \t          /* Optimize root(x)*root(y) as root(x*y).  */\n-\t\t  rootfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t  rootfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n \t\t  arg = fold_build2 (MULT_EXPR, type, arg00, arg10);\n-\t\t  arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  return build_function_call_expr (rootfn, arglist);\n+\t\t  return build_call_expr (rootfn, 1, arg);\n \t\t}\n \n \t      /* Optimize expN(x)*expN(y) as expN(x+y).  */\n \t      if (fcode0 == fcode1 && BUILTIN_EXPONENT_P (fcode0))\n \t\t{\n-\t\t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t  tree expfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n \t\t  tree arg = fold_build2 (PLUS_EXPR, type,\n-\t\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t\t  tree arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  return build_function_call_expr (expfn, arglist);\n+\t\t\t\t\t  CALL_EXPR_ARG (arg0, 0),\n+\t\t\t\t\t  CALL_EXPR_ARG (arg1, 0));\n+\t\t  return build_call_expr (expfn, 1, arg);\n \t\t}\n \n \t      /* Optimizations of pow(...)*pow(...).  */\n \t      if ((fcode0 == BUILT_IN_POW && fcode1 == BUILT_IN_POW)\n \t\t  || (fcode0 == BUILT_IN_POWF && fcode1 == BUILT_IN_POWF)\n \t\t  || (fcode0 == BUILT_IN_POWL && fcode1 == BUILT_IN_POWL))\n \t\t{\n-\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n-\t\t\t\t\t\t\t\t     1)));\n-\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n-\t\t\t\t\t\t\t\t     1)));\n+\t\t  tree arg00 = CALL_EXPR_ARG (arg0, 0);\n+\t\t  tree arg01 = CALL_EXPR_ARG (arg0, 1);\n+\t\t  tree arg10 = CALL_EXPR_ARG (arg1, 0);\n+\t\t  tree arg11 = CALL_EXPR_ARG (arg1, 1);\n \n \t\t  /* Optimize pow(x,y)*pow(z,y) as pow(x*z,y).  */\n \t\t  if (operand_equal_p (arg01, arg11, 0))\n \t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t      tree powfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n \t\t      tree arg = fold_build2 (MULT_EXPR, type, arg00, arg10);\n-\t\t      tree arglist = tree_cons (NULL_TREE, arg,\n-\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\t arg01));\n-\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t      return build_call_expr (powfn, 2, arg, arg01);\n \t\t    }\n \n \t\t  /* Optimize pow(x,y)*pow(x,z) as pow(x,y+z).  */\n \t\t  if (operand_equal_p (arg00, arg10, 0))\n \t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t      tree powfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n \t\t      tree arg = fold_build2 (PLUS_EXPR, type, arg01, arg11);\n-\t\t      tree arglist = tree_cons (NULL_TREE, arg00,\n-\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\t arg));\n-\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t      return build_call_expr (powfn, 2, arg00, arg);\n \t\t    }\n \t\t}\n \n@@ -9877,38 +9870,34 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t   || (fcode0 == BUILT_IN_COS && fcode1 == BUILT_IN_TAN)\n \t\t   || (fcode0 == BUILT_IN_COSF && fcode1 == BUILT_IN_TANF)\n \t\t   || (fcode0 == BUILT_IN_COSL && fcode1 == BUILT_IN_TANL))\n-\t\t  && operand_equal_p (TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t      TREE_VALUE (TREE_OPERAND (arg1, 1)), 0))\n+\t\t  && operand_equal_p (CALL_EXPR_ARG (arg0, 0),\n+\t\t\t\t      CALL_EXPR_ARG (arg1, 0), 0))\n \t\t{\n \t\t  tree sinfn = mathfn_built_in (type, BUILT_IN_SIN);\n \n \t\t  if (sinfn != NULL_TREE)\n-\t\t    return build_function_call_expr (sinfn,\n-\t\t\t\t\t\t     TREE_OPERAND (arg0, 1));\n+\t\t    return build_call_expr (sinfn, 1, CALL_EXPR_ARG (arg0, 0));\n \t\t}\n \n \t      /* Optimize x*pow(x,c) as pow(x,c+1).  */\n \t      if (fcode1 == BUILT_IN_POW\n \t\t  || fcode1 == BUILT_IN_POWF\n \t\t  || fcode1 == BUILT_IN_POWL)\n \t\t{\n-\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n-\t\t\t\t\t\t\t\t     1)));\n+\t\t  tree arg10 = CALL_EXPR_ARG (arg1, 0);\n+\t\t  tree arg11 = CALL_EXPR_ARG (arg1, 1);\n \t\t  if (TREE_CODE (arg11) == REAL_CST\n \t\t      && !TREE_OVERFLOW (arg11)\n \t\t      && operand_equal_p (arg0, arg10, 0))\n \t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n+\t\t      tree powfn = TREE_OPERAND (CALL_EXPR_FN (arg1), 0);\n \t\t      REAL_VALUE_TYPE c;\n-\t\t      tree arg, arglist;\n+\t\t      tree arg;\n \n \t\t      c = TREE_REAL_CST (arg11);\n \t\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n \t\t      arg = build_real (type, c);\n-\t\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t\t      arglist = tree_cons (NULL_TREE, arg0, arglist);\n-\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t      return build_call_expr (powfn, 2, arg0, arg);\n \t\t    }\n \t\t}\n \n@@ -9917,23 +9906,20 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  || fcode0 == BUILT_IN_POWF\n \t\t  || fcode0 == BUILT_IN_POWL)\n \t\t{\n-\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n-\t\t\t\t\t\t\t\t     1)));\n+\t\t  tree arg00 = CALL_EXPR_ARG (arg0, 0);\n+\t\t  tree arg01 = CALL_EXPR_ARG (arg0, 1);\n \t\t  if (TREE_CODE (arg01) == REAL_CST\n \t\t      && !TREE_OVERFLOW (arg01)\n \t\t      && operand_equal_p (arg1, arg00, 0))\n \t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t      tree powfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n \t\t      REAL_VALUE_TYPE c;\n-\t\t      tree arg, arglist;\n+\t\t      tree arg;\n \n \t\t      c = TREE_REAL_CST (arg01);\n \t\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n \t\t      arg = build_real (type, c);\n-\t\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t\t      arglist = tree_cons (NULL_TREE, arg1, arglist);\n-\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t      return build_call_expr (powfn, 2, arg1, arg);\n \t\t    }\n \t\t}\n \n@@ -9946,9 +9932,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  if (powfn)\n \t\t    {\n \t\t      tree arg = build_real (type, dconst2);\n-\t\t      tree arglist = build_tree_list (NULL_TREE, arg);\n-\t\t      arglist = tree_cons (NULL_TREE, arg0, arglist);\n-\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t      return build_call_expr (powfn, 2, arg0, arg);\n \t\t    }\n \t\t}\n \t    }\n@@ -10480,29 +10464,27 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  if (((fcode0 == BUILT_IN_SIN && fcode1 == BUILT_IN_COS)\n \t       || (fcode0 == BUILT_IN_SINF && fcode1 == BUILT_IN_COSF)\n \t       || (fcode0 == BUILT_IN_SINL && fcode1 == BUILT_IN_COSL))\n-\t      && operand_equal_p (TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg1, 1)), 0))\n+\t      && operand_equal_p (CALL_EXPR_ARG (arg0, 0),\n+\t\t\t\t  CALL_EXPR_ARG (arg1, 0), 0))\n \t    {\n \t      tree tanfn = mathfn_built_in (type, BUILT_IN_TAN);\n \n \t      if (tanfn != NULL_TREE)\n-\t\treturn build_function_call_expr (tanfn,\n-\t\t\t\t\t\t TREE_OPERAND (arg0, 1));\n+\t\treturn build_call_expr (tanfn, 1, CALL_EXPR_ARG (arg0, 0));\n \t    }\n \n \t  /* Optimize cos(x)/sin(x) as 1.0/tan(x).  */\n \t  if (((fcode0 == BUILT_IN_COS && fcode1 == BUILT_IN_SIN)\n \t       || (fcode0 == BUILT_IN_COSF && fcode1 == BUILT_IN_SINF)\n \t       || (fcode0 == BUILT_IN_COSL && fcode1 == BUILT_IN_SINL))\n-\t      && operand_equal_p (TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg1, 1)), 0))\n+\t      && operand_equal_p (CALL_EXPR_ARG (arg0, 0),\n+\t\t\t\t  CALL_EXPR_ARG (arg1, 0), 0))\n \t    {\n \t      tree tanfn = mathfn_built_in (type, BUILT_IN_TAN);\n \n \t      if (tanfn != NULL_TREE)\n \t\t{\n-\t\t  tree tmp = TREE_OPERAND (arg0, 1);\n-\t\t  tmp = build_function_call_expr (tanfn, tmp);\n+\t\t  tree tmp = build_call_expr (tanfn, 1, CALL_EXPR_ARG (arg0, 0));\n \t\t  return fold_build2 (RDIV_EXPR, type,\n \t\t\t\t      build_real (type, dconst1), tmp);\n \t\t}\n@@ -10514,8 +10496,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n  \t       || (fcode0 == BUILT_IN_SINF && fcode1 == BUILT_IN_TANF)\n  \t       || (fcode0 == BUILT_IN_SINL && fcode1 == BUILT_IN_TANL)))\n \t    {\n-\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree arg01 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n+\t      tree arg01 = CALL_EXPR_ARG (arg1, 0);\n \n \t      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00)))\n \t\t  && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg00)))\n@@ -10524,8 +10506,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  tree cosfn = mathfn_built_in (type, BUILT_IN_COS);\n \n \t\t  if (cosfn != NULL_TREE)\n-\t\t    return build_function_call_expr (cosfn,\n-\t\t\t\t\t\t     TREE_OPERAND (arg0, 1));\n+\t\t    return build_call_expr (cosfn, 1, arg00);\n \t\t}\n \t    }\n \n@@ -10535,8 +10516,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n  \t       || (fcode0 == BUILT_IN_TANF && fcode1 == BUILT_IN_SINF)\n  \t       || (fcode0 == BUILT_IN_TANL && fcode1 == BUILT_IN_SINL)))\n \t    {\n-\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree arg01 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n+\t      tree arg01 = CALL_EXPR_ARG (arg1, 0);\n \n \t      if (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg00)))\n \t\t  && ! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg00)))\n@@ -10546,8 +10527,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t\t  if (cosfn != NULL_TREE)\n \t\t    {\n-\t\t      tree tmp = TREE_OPERAND (arg0, 1);\n-\t\t      tmp = build_function_call_expr (cosfn, tmp);\n+\t\t      tree tmp = build_call_expr (cosfn, 1, arg00);\n \t\t      return fold_build2 (RDIV_EXPR, type,\n \t\t\t\t\t  build_real (type, dconst1),\n \t\t\t\t\t  tmp);\n@@ -10560,33 +10540,29 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      || fcode0 == BUILT_IN_POWF\n \t      || fcode0 == BUILT_IN_POWL)\n \t    {\n-\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n+\t      tree arg00 = CALL_EXPR_ARG (arg0, 0);\n+\t      tree arg01 = CALL_EXPR_ARG (arg0, 1);\n \t      if (TREE_CODE (arg01) == REAL_CST\n \t\t  && !TREE_OVERFLOW (arg01)\n \t\t  && operand_equal_p (arg1, arg00, 0))\n \t\t{\n-\t\t  tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t  tree powfn = TREE_OPERAND (CALL_EXPR_FN (arg0), 0);\n \t\t  REAL_VALUE_TYPE c;\n-\t\t  tree arg, arglist;\n+\t\t  tree arg;\n \n \t\t  c = TREE_REAL_CST (arg01);\n \t\t  real_arithmetic (&c, MINUS_EXPR, &c, &dconst1);\n \t\t  arg = build_real (type, c);\n-\t\t  arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  arglist = tree_cons (NULL_TREE, arg1, arglist);\n-\t\t  return build_function_call_expr (powfn, arglist);\n+\t\t  return build_call_expr (powfn, 2, arg1, arg);\n \t\t}\n \t    }\n \n \t  /* Optimize x/expN(y) into x*expN(-y).  */\n \t  if (BUILTIN_EXPONENT_P (fcode1))\n \t    {\n-\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t      tree arg = negate_expr (TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t      tree arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t\t      fold_convert (type, arg));\n-\t      arg1 = build_function_call_expr (expfn, arglist);\n+\t      tree expfn = TREE_OPERAND (CALL_EXPR_FN (arg1), 0);\n+\t      tree arg = negate_expr (CALL_EXPR_ARG (arg1, 0));\n+\t      arg1 = build_call_expr (expfn, 1, fold_convert (type, arg));\n \t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n \t    }\n \n@@ -10595,13 +10571,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      || fcode1 == BUILT_IN_POWF\n \t      || fcode1 == BUILT_IN_POWL)\n \t    {\n-\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t      tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t      tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1, 1)));\n+\t      tree powfn = TREE_OPERAND (CALL_EXPR_FN (arg1), 0);\n+\t      tree arg10 = CALL_EXPR_ARG (arg1, 0);\n+\t      tree arg11 = CALL_EXPR_ARG (arg1, 1);\n \t      tree neg11 = fold_convert (type, negate_expr (arg11));\n-\t      tree arglist = tree_cons (NULL_TREE, arg10,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, neg11));\n-\t      arg1 = build_function_call_expr (powfn, arglist);\n+\t      arg1 = build_call_expr (powfn, 2, arg10, neg11);\n \t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n \t    }\n \t}\n@@ -11386,16 +11360,14 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && integer_zerop (arg1))\n \t{\n \t  tree fndecl = get_callee_fndecl (arg0);\n-\t  tree arglist;\n \n \t  if (fndecl\n \t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRLEN\n-\t      && (arglist = TREE_OPERAND (arg0, 1))\n-\t      && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE\n-\t      && ! TREE_CHAIN (arglist))\n+\t      && call_expr_nargs (arg0) == 1\n+\t      && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (arg0, 0))) == POINTER_TYPE)\n \t    {\n-\t      tree iref = build_fold_indirect_ref (TREE_VALUE (arglist));\n+\t      tree iref = build_fold_indirect_ref (CALL_EXPR_ARG (arg0, 0));\n \t      return fold_build2 (code, type, iref,\n \t\t\t\t  build_int_cst (TREE_TYPE (iref), 0));\n \t    }\n@@ -12376,12 +12348,9 @@ fold_ternary (enum tree_code code, tree type, tree op0, tree op1, tree op2)\n       return NULL_TREE;\n \n     case CALL_EXPR:\n-      /* Check for a built-in function.  */\n-      if (TREE_CODE (op0) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (op0, 0)) == FUNCTION_DECL\n-\t  && DECL_BUILT_IN (TREE_OPERAND (op0, 0)))\n-\treturn fold_builtin (TREE_OPERAND (op0, 0), op1, false);\n-      return NULL_TREE;\n+      /* CALL_EXPRs used to be ternary exprs.  Catch any mistaken uses\n+\t of fold_ternary on them.  */\n+      gcc_unreachable ();\n \n     case BIT_FIELD_REF:\n       if (TREE_CODE (arg0) == VECTOR_CST\n@@ -12439,6 +12408,18 @@ fold (tree expr)\n   if (kind == tcc_constant)\n     return t;\n \n+  /* CALL_EXPR-like objects with variable numbers of operands are\n+     treated specially.  */\n+  if (kind == tcc_vl_exp)\n+    {\n+      if (code == CALL_EXPR)\n+\t{\n+\t  tem = fold_call_expr (expr, false);\n+\t  return tem ? tem : expr;\n+\t}\n+      return expr;\n+    }\n+\n   if (IS_EXPR_CODE_CLASS (kind)\n       || IS_GIMPLE_STMT_CODE_CLASS (kind))\n     {\n@@ -12632,7 +12613,8 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n     case tcc_unary:\n     case tcc_binary:\n     case tcc_statement:\n-      len = TREE_CODE_LENGTH (code);\n+    case tcc_vl_exp:\n+      len = TREE_OPERAND_LENGTH (expr);\n       for (i = 0; i < len; ++i)\n \tfold_checksum_tree (TREE_OPERAND (expr, i), ctx, ht);\n       break;\n@@ -12811,7 +12793,8 @@ fold_build3_stat (enum tree_code code, tree type, tree op0, tree op1, tree op2\n   md5_finish_ctx (&ctx, checksum_before_op2);\n   htab_empty (ht);\n #endif\n-  \n+\n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n   tem = fold_ternary (code, type, op0, op1, op2);\n   if (!tem)\n     tem =  build3_stat (code, type, op0, op1, op2 PASS_MEM_STAT);\n@@ -12844,6 +12827,57 @@ fold_build3_stat (enum tree_code code, tree type, tree op0, tree op1, tree op2\n   return tem;\n }\n \n+/* Fold a CALL_EXPR expression of type TYPE with operands FN and ARGLIST\n+   and a null static chain.\n+   Return a folded expression if successful.  Otherwise, return a CALL_EXPR\n+   of type TYPE from the given operands as constructed by build_call_list.  */\n+\n+tree\n+fold_build_call_list (tree type, tree fn, tree arglist)\n+{\n+  tree tem;\n+#ifdef ENABLE_FOLD_CHECKING\n+  unsigned char checksum_before_fn[16],\n+                checksum_before_arglist[16],\n+\t\tchecksum_after_fn[16],\n+\t\tchecksum_after_arglist[16];\n+  struct md5_ctx ctx;\n+  htab_t ht;\n+\n+  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (fn, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum_before_fn);\n+  htab_empty (ht);\n+\n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (arglist, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum_before_arglist);\n+  htab_empty (ht);\n+#endif\n+\n+  tem = fold_builtin_call_list (type, fn, arglist);\n+      \n+#ifdef ENABLE_FOLD_CHECKING\n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (fn, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum_after_fn);\n+  htab_empty (ht);\n+\n+  if (memcmp (checksum_before_fn, checksum_after_fn, 16))\n+    fold_check_failed (fn, tem);\n+  \n+  md5_init_ctx (&ctx);\n+  fold_checksum_tree (arglist, &ctx, ht);\n+  md5_finish_ctx (&ctx, checksum_after_arglist);\n+  htab_delete (ht);\n+\n+  if (memcmp (checksum_before_arglist, checksum_after_arglist, 16))\n+    fold_check_failed (arglist, tem);\n+#endif\n+  return tem;\n+}\n+\n /* Perform constant folding and related simplification of initializer\n    expression EXPR.  These behave identically to \"fold_buildN\" but ignore\n    potential run-time traps and exceptions that fold must preserve.  */\n@@ -12904,6 +12938,18 @@ fold_build3_initializer (enum tree_code code, tree type, tree op0, tree op1,\n   return result;\n }\n \n+tree\n+fold_build_call_list_initializer (tree type, tree fn, tree arglist)\n+{\n+  tree result;\n+  START_FOLD_INIT;\n+\n+  result = fold_build_call_list (type, fn, arglist);\n+\n+  END_FOLD_INIT;\n+  return result;\n+}\n+\n #undef START_FOLD_INIT\n #undef END_FOLD_INIT\n \n@@ -13223,7 +13269,6 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n     case CALL_EXPR:\n       {\n \ttree fndecl = get_callee_fndecl (t);\n-\ttree arglist = TREE_OPERAND (t, 1);\n \tif (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n \t  switch (DECL_FUNCTION_CODE (fndecl))\n \t    {\n@@ -13251,7 +13296,7 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t      /* sqrt(-0.0) is -0.0.  */\n \t      if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (t))))\n \t\treturn true;\n-\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_ASINH):\n@@ -13282,52 +13327,49 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t    CASE_FLT_FN (BUILT_IN_TANH):\n \t    CASE_FLT_FN (BUILT_IN_TRUNC):\n \t      /* True if the 1st argument is nonnegative.  */\n-\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_FMAX):\n \t      /* True if the 1st OR 2nd arguments are nonnegative.  */\n-\t      return (tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t      return (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t\t     strict_overflow_p)\n-\t\t      || (tree_expr_nonnegative_warnv_p\n-\t\t\t  (TREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\t   strict_overflow_p)));\n+\t\t      || (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 1),\n+\t\t\t\t\t\t\t strict_overflow_p)));\n \n \t    CASE_FLT_FN (BUILT_IN_FMIN):\n \t      /* True if the 1st AND 2nd arguments are nonnegative.  */\n-\t      return (tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t      return (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t\t     strict_overflow_p)\n-\t\t      && (tree_expr_nonnegative_warnv_p\n-\t\t\t  (TREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\t   strict_overflow_p)));\n+\t\t      && (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 1),\n+\t\t\t\t\t\t\t strict_overflow_p)));\n \n \t    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n \t      /* True if the 2nd argument is nonnegative.  */\n-\t      return (tree_expr_nonnegative_warnv_p\n-\t\t      (TREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t       strict_overflow_p));\n+\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 1),\n+\t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_POWI):\n \t      /* True if the 1st argument is nonnegative or the second\n \t\t argument is an even integer.  */\n-\t      if (TREE_CODE (TREE_VALUE (TREE_CHAIN (arglist))) == INTEGER_CST)\n+\t      if (TREE_CODE (CALL_EXPR_ARG (t, 1)) == INTEGER_CST)\n \t\t{\n-\t\t  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\t\t  tree arg1 = CALL_EXPR_ARG (t, 1);\n \t\t  if ((TREE_INT_CST_LOW (arg1) & 1) == 0)\n \t\t    return true;\n \t\t}\n-\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_POW):\n \t      /* True if the 1st argument is nonnegative or the second\n \t\t argument is an even integer valued real.  */\n-\t      if (TREE_CODE (TREE_VALUE (TREE_CHAIN (arglist))) == REAL_CST)\n+\t      if (TREE_CODE (CALL_EXPR_ARG (t, 1)) == REAL_CST)\n \t\t{\n \t\t  REAL_VALUE_TYPE c;\n \t\t  HOST_WIDE_INT n;\n \n-\t\t  c = TREE_REAL_CST (TREE_VALUE (TREE_CHAIN (arglist)));\n+\t\t  c = TREE_REAL_CST (CALL_EXPR_ARG (t, 1));\n \t\t  n = real_to_integer (&c);\n \t\t  if ((n & 1) == 0)\n \t\t    {\n@@ -13338,7 +13380,7 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t\t\treturn true;\n \t\t    }\n \t\t}\n-\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t\t    strict_overflow_p);\n \n \t    default:\n@@ -14336,19 +14378,17 @@ fold_strip_sign_ops (tree exp)\n \t{\n \tCASE_FLT_FN (BUILT_IN_COPYSIGN):\n \t  /* Strip copysign function call, return the 1st argument. */\n-\t  arg0 = TREE_VALUE (TREE_OPERAND (exp, 1));\n-\t  arg1 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (exp, 1)));\n+\t  arg0 = CALL_EXPR_ARG (exp, 0);\n+\t  arg1 = CALL_EXPR_ARG (exp, 1);\n \t  return omit_one_operand (TREE_TYPE (exp), arg0, arg1);\n \n \tdefault:\n \t  /* Strip sign ops from the argument of \"odd\" math functions.  */\n \t  if (negate_mathfn_p (fcode))\n             {\n-\t      arg0 = fold_strip_sign_ops (TREE_VALUE (TREE_OPERAND (exp, 1)));\n+\t      arg0 = fold_strip_sign_ops (CALL_EXPR_ARG (exp, 0));\n \t      if (arg0)\n-\t\treturn build_function_call_expr (get_callee_fndecl (exp),\n-\t\t\t\t\t\t build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\t  arg0));\n+\t\treturn build_call_expr (get_callee_fndecl (exp), 1, arg0);\n \t    }\n \t  break;\n \t}"}, {"sha": "796c8b9a06bf92e36e27dbb5c63717a3c290e7f8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1,3 +1,68 @@\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* trans-expr.c (gfc_conv_power_op): Use build_call_expr.\n+\t(gfc_conv_string_tmp): Likewise.\n+\t(gfc_conv_concat_op): Likewise.\n+\t(gfc_build_compare_string): Likewise.\n+\t(gfc_conv_function_call): Use build_call_list instead of build3.\n+\n+\t* trans-array.c (gfc_trans_allocate_array_storage): Use\n+\tbuild_call_expr.\n+\t(gfc_grow_array): Likewise.\n+\t(gfc_trans_array_ctor_element): Likewise.\n+\t(gfc_trans_array_constructor_value): Likewise.\n+\t(gfc_array_allocate): Likewise.\n+\t(gfc_array_deallocate): Likewise.\n+\t(gfc_trans_auto_array_allocation): Likewise.\n+\t(gfc_trans_dummy_array_bias): Likewise.\n+\t(gfc_conv_array_parameter): Likewise.\n+\t(gfc_trans_dealloc_allocated): Likewise.\n+\t(gfc_duplicate_allocatable): Likewise.\n+\n+\t* trans-openmp.c (gfc_trans_omp_barrier): Use build_call_expr.\n+\t(gfc_trans_omp_flush): Likewise.\n+\n+\t* trans-stmt.c (gfc_conv_elementel_dependencies): Use build_call_expr.\n+\t(gfc_trans_pause): Likewise.\n+\t(gfc_trans_stop): Likewise.\n+\t(gfc_trans_character_select): Likewise.\n+\t(gfc_do_allocate): Likewise.\n+\t(gfc_trans_assign_need_temp): Likewise.\n+\t(gfc_trans_pointer_assign_need_temp): Likewise.\n+\t(gfc_trans_forall_1): Likewise.\n+\t(gfc_trans_where_2): Likewise.\n+\t(gfc_trans_allocate): Likewise.\n+\t(gfc_trans_deallocate): Likewise.\n+\n+\t* trans.c (gfc_trans_runtime_check): Use build_call_expr.\n+\n+\t* trans-io.c (gfc_trans_open): Use build_call_expr.\n+\t(gfc_trans_close): Likewise.\n+\t(build_filepos): Likewise.\n+\t(gfc_trans_inquire): Likewise.\n+\t(NML_FIRST_ARG): Delete.\n+\t(NML_ADD_ARG): Delete.\n+\t(transfer_namelist_element): Use build_call_expr.\n+\t(build_dt): Likewise.\n+\t(gfc_trans_dt_end): Likewise.\n+\t(transfer_expr): Likewise.\n+\t(transfer_array-desc): Likewise.\n+\n+\t* trans-decl.c (gfc_generate_function_code): Use build_call_expr.\n+\t(gfc_generate_constructors): Likewise.\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_ctime): Use build_call_expr.\n+\t(gfc_conv_intrinsic_fdate): Likewise.\n+\t(gfc_conv_intrinsic_ttynam): Likewise.\n+\t(gfc_conv_intrinsic_array_transfer): Likewise.\n+\t(gfc_conv_associated): Likewise.\n+\t(gfc_conv_intrinsic_si_kind): Likewise.\n+\t(gfc_conv_intrinsic_trim): Likewise.\n+\t(gfc_conv_intrinsic_repeat: Likewise.\n+\t(gfc_conv_intrinsic_iargc): Likewise.\n+\n 2007-02-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/30779"}, {"sha": "64ea9d6f436247b701feecf904b31579a0104020", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -501,7 +501,6 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n                                   bool dynamic, bool dealloc)\n {\n   tree tmp;\n-  tree args;\n   tree desc;\n   bool onstack;\n \n@@ -534,15 +533,13 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n       else\n \t{\n \t  /* Allocate memory to hold the data.  */\n-\t  args = gfc_chainon_list (NULL_TREE, size);\n-\n \t  if (gfc_index_integer_kind == 4)\n \t    tmp = gfor_fndecl_internal_malloc;\n \t  else if (gfc_index_integer_kind == 8)\n \t    tmp = gfor_fndecl_internal_malloc64;\n \t  else\n \t    gcc_unreachable ();\n-\t  tmp = build_function_call_expr (tmp, args);\n+\t  tmp = build_call_expr (tmp, 1, size);\n \t  tmp = gfc_evaluate_now (tmp, pre);\n \t  gfc_conv_descriptor_data_set (pre, desc, tmp);\n \t}\n@@ -559,8 +556,7 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n       /* Free the temporary.  */\n       tmp = gfc_conv_descriptor_data_get (desc);\n       tmp = fold_convert (pvoid_type_node, tmp);\n-      tmp = gfc_chainon_list (NULL_TREE, tmp);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, tmp);\n       gfc_add_expr_to_block (post, tmp);\n     }\n }\n@@ -829,7 +825,7 @@ gfc_get_iteration_count (tree start, tree end, tree step)\n static void\n gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n {\n-  tree args;\n+  tree arg0, arg1;\n   tree tmp;\n   tree size;\n   tree ubound;\n@@ -844,14 +840,12 @@ gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n   gfc_add_modify_expr (pblock, ubound, tmp);\n \n   /* Get the value of the current data pointer.  */\n-  tmp = gfc_conv_descriptor_data_get (desc);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n+  arg0 = gfc_conv_descriptor_data_get (desc);\n \n   /* Calculate the new array size.  */\n   size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n   tmp = build2 (PLUS_EXPR, gfc_array_index_type, ubound, gfc_index_one_node);\n-  tmp = build2 (MULT_EXPR, gfc_array_index_type, tmp, size);\n-  args = gfc_chainon_list (args, tmp);\n+  arg1 = build2 (MULT_EXPR, gfc_array_index_type, tmp, size);\n \n   /* Pick the appropriate realloc function.  */\n   if (gfc_index_integer_kind == 4)\n@@ -862,7 +856,7 @@ gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n     gcc_unreachable ();\n \n   /* Set the new data pointer.  */\n-  tmp = build_function_call_expr (tmp, args);\n+  tmp = build_call_expr (tmp, 2, arg0, arg1);\n   gfc_conv_descriptor_data_set (pblock, desc, tmp);\n }\n \n@@ -971,7 +965,6 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t\t\t      tree offset, gfc_se * se, gfc_expr * expr)\n {\n   tree tmp;\n-  tree args;\n \n   gfc_conv_expr (se, expr);\n \n@@ -993,11 +986,8 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t  tmp = gfc_build_addr_expr (pchar_type_node, tmp);\n \t  /* We know the temporary and the value will be the same length,\n \t     so can use memcpy.  */\n-\t  args = gfc_chainon_list (NULL_TREE, tmp);\n-\t  args = gfc_chainon_list (args, se->expr);\n-\t  args = gfc_chainon_list (args, se->string_length);\n-\t  tmp = built_in_decls[BUILT_IN_MEMCPY];\n-\t  tmp = build_function_call_expr (tmp, args);\n+\t  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t\t tmp, se->expr, se->string_length);\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t}\n     }\n@@ -1206,11 +1196,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \n \t      size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n \t      bound = build_int_cst (NULL_TREE, n * size);\n-\t      tmp = gfc_chainon_list (NULL_TREE, tmp);\n-\t      tmp = gfc_chainon_list (tmp, init);\n-\t      tmp = gfc_chainon_list (tmp, bound);\n-\t      tmp = build_function_call_expr (built_in_decls[BUILT_IN_MEMCPY],\n-\t\t\t\t\t     tmp);\n+\t      tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t\t     tmp, init, bound);\n \t      gfc_add_expr_to_block (&body, tmp);\n \n \t      *poffset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n@@ -3491,13 +3478,11 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   else\n     gcc_unreachable ();\n \n-  tmp = NULL_TREE;\n   /* The allocate_array variants take the old pointer as first argument.  */\n   if (allocatable_array)\n-    tmp = gfc_chainon_list (tmp, pointer);\n-  tmp = gfc_chainon_list (tmp, size);\n-  tmp = gfc_chainon_list (tmp, pstat);\n-  tmp = build_function_call_expr (allocate, tmp);\n+    tmp = build_call_expr (allocate, 3, pointer, size, pstat);\n+  else\n+    tmp = build_call_expr (allocate, 2, size, pstat);\n   tmp = build2 (MODIFY_EXPR, void_type_node, pointer, tmp);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -3533,9 +3518,7 @@ gfc_array_deallocate (tree descriptor, tree pstat)\n   STRIP_NOPS (var);\n \n   /* Parameter is the address of the data component.  */\n-  tmp = gfc_chainon_list (NULL_TREE, var);\n-  tmp = gfc_chainon_list (tmp, pstat);\n-  tmp = build_function_call_expr (gfor_fndecl_deallocate, tmp);\n+  tmp = build_call_expr (gfor_fndecl_deallocate, 2, var, pstat);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -3826,15 +3809,13 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n \n   /* Allocate memory to hold the data.  */\n-  tmp = gfc_chainon_list (NULL_TREE, size);\n-\n   if (gfc_index_integer_kind == 4)\n     fndecl = gfor_fndecl_internal_malloc;\n   else if (gfc_index_integer_kind == 8)\n     fndecl = gfor_fndecl_internal_malloc64;\n   else\n     gcc_unreachable ();\n-  tmp = build_function_call_expr (fndecl, tmp);\n+  tmp = build_call_expr (fndecl, 1, size);\n   tmp = fold (convert (TREE_TYPE (decl), tmp));\n   gfc_add_modify_expr (&block, decl, tmp);\n \n@@ -3850,8 +3831,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   /* Free the temporary.  */\n   tmp = convert (pvoid_type_node, decl);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+  tmp = build_call_expr (gfor_fndecl_internal_free, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -4020,8 +4000,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       gcc_assert (integer_onep (GFC_TYPE_ARRAY_STRIDE (type, 0)));\n       /* A library call to repack the array if necessary.  */\n       tmp = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-      tmp = gfc_chainon_list (NULL_TREE, tmp);\n-      stmt_unpacked = build_function_call_expr (gfor_fndecl_in_pack, tmp);\n+      stmt_unpacked = build_call_expr (gfor_fndecl_in_pack, 1, tmp);\n \n       stride = gfc_index_one_node;\n     }\n@@ -4203,15 +4182,12 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       if (sym->attr.intent != INTENT_IN)\n \t{\n \t  /* Copy the data back.  */\n-\t  tmp = gfc_chainon_list (NULL_TREE, dumdesc);\n-\t  tmp = gfc_chainon_list (tmp, tmpdesc);\n-\t  tmp = build_function_call_expr (gfor_fndecl_in_unpack, tmp);\n+\t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, dumdesc, tmpdesc);\n \t  gfc_add_expr_to_block (&cleanup, tmp);\n \t}\n \n       /* Free the temporary.  */\n-      tmp = gfc_chainon_list (NULL_TREE, tmpdesc);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, tmpdesc);\n       gfc_add_expr_to_block (&cleanup, tmp);\n \n       stmt = gfc_finish_block (&cleanup);\n@@ -4778,23 +4754,19 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n     {\n       desc = se->expr;\n       /* Repack the array.  */\n-      tmp = gfc_chainon_list (NULL_TREE, desc);\n-      ptr = build_function_call_expr (gfor_fndecl_in_pack, tmp);\n+      ptr = build_call_expr (gfor_fndecl_in_pack, 1, desc);\n       ptr = gfc_evaluate_now (ptr, &se->pre);\n       se->expr = ptr;\n \n       gfc_start_block (&block);\n \n       /* Copy the data back.  */\n-      tmp = gfc_chainon_list (NULL_TREE, desc);\n-      tmp = gfc_chainon_list (tmp, ptr);\n-      tmp = build_function_call_expr (gfor_fndecl_in_unpack, tmp);\n+      tmp = build_call_expr (gfor_fndecl_in_unpack, 2, desc, ptr);\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* Free the temporary.  */\n       tmp = convert (pvoid_type_node, ptr);\n-      tmp = gfc_chainon_list (NULL_TREE, tmp);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, tmp);\n       gfc_add_expr_to_block (&block, tmp);\n \n       stmt = gfc_finish_block (&block);\n@@ -4836,9 +4808,7 @@ gfc_trans_dealloc_allocated (tree descriptor)\n   /* Call array_deallocate with an int* present in the second argument.\n      Although it is ignored here, it's presence ensures that arrays that\n      are already deallocated are ignored.  */\n-  tmp = gfc_chainon_list (NULL_TREE, var);\n-  tmp = gfc_chainon_list (tmp, ptr);\n-  tmp = build_function_call_expr (gfor_fndecl_deallocate, tmp);\n+  tmp = build_call_expr (gfor_fndecl_deallocate, 2, var, ptr);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -4880,7 +4850,6 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n   tree tmp;\n   tree size;\n   tree nelems;\n-  tree args;\n   tree null_cond;\n   tree null_data;\n   stmtblock_t block;\n@@ -4897,11 +4866,10 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n \t\t      TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n \n   /* Allocate memory to the destination.  */\n-  tmp = gfc_chainon_list (NULL_TREE, size);\n   if (gfc_index_integer_kind == 4)\n-    tmp = build_function_call_expr (gfor_fndecl_internal_malloc, tmp);\n+    tmp = build_call_expr (gfor_fndecl_internal_malloc, 1, size);\n   else if (gfc_index_integer_kind == 8)\n-    tmp = build_function_call_expr (gfor_fndecl_internal_malloc64, tmp);\n+    tmp = build_call_expr (gfor_fndecl_internal_malloc64, 1, size);\n   else\n     gcc_unreachable ();\n   tmp = fold (convert (TREE_TYPE (gfc_conv_descriptor_data_get (src)),\n@@ -4910,13 +4878,9 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n \n   /* We know the temporary and the value will be the same length,\n      so can use memcpy.  */\n-  tmp = gfc_conv_descriptor_data_get (dest);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = gfc_conv_descriptor_data_get (src);\n-  args = gfc_chainon_list (args, tmp);\n-  args = gfc_chainon_list (args, size);\n   tmp = built_in_decls[BUILT_IN_MEMCPY];\n-  tmp = build_function_call_expr (tmp, args);\n+  tmp = build_call_expr (tmp, 3, gfc_conv_descriptor_data_get (dest),\n+  \t\t\t gfc_conv_descriptor_data_get (src), size);\n   gfc_add_expr_to_block (&block, tmp);\n   tmp = gfc_finish_block (&block);\n "}, {"sha": "d001ad9eba6c8fc6d1b33b94eadf1e8be2e17a0a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -3135,23 +3135,16 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   if (sym->attr.is_main_program)\n     {\n-      tree arglist, gfc_int4_type_node;\n-\n-      gfc_int4_type_node = gfc_get_int_type (4);\n-      arglist = gfc_chainon_list (NULL_TREE,\n-\t\t\t\t  build_int_cst (gfc_int4_type_node,\n-\t\t\t\t\t\t gfc_option.warn_std));\n-      arglist = gfc_chainon_list (arglist,\n-\t\t\t\t  build_int_cst (gfc_int4_type_node,\n-\t\t\t\t\t\t gfc_option.allow_std));\n-      arglist = gfc_chainon_list (arglist,\n-\t\t\t\t  build_int_cst (gfc_int4_type_node,\n-\t\t\t\t\t\t pedantic));\n-      arglist = gfc_chainon_list (arglist,\n-\t\t\t\t  build_int_cst (gfc_int4_type_node,\n-\t\t\t\t\t\t gfc_option.flag_dump_core));\n-\n-      tmp = build_function_call_expr (gfor_fndecl_set_std, arglist);\n+      tree gfc_int4_type_node = gfc_get_int_type (4);\n+      tmp = build_call_expr (gfor_fndecl_set_std, 3,\n+\t\t\t     build_int_cst (gfc_int4_type_node,\n+\t\t\t\t\t    gfc_option.warn_std),\n+\t\t\t     build_int_cst (gfc_int4_type_node,\n+\t\t\t\t\t    gfc_option.allow_std),\n+\t\t\t     build_int_cst (gfc_int4_type_node,\n+\t\t\t\t\t    pedantic),\n+\t\t\t     build_int_cst (gfc_int4_type_node,\n+\t\t\t\t\t    gfc_option.flag_dump_core));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n@@ -3160,13 +3153,10 @@ gfc_generate_function_code (gfc_namespace * ns)\n      needed.  */\n   if (sym->attr.is_main_program && gfc_option.fpe != 0)\n     {\n-      tree arglist, gfc_c_int_type_node;\n-\n-      gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n-      arglist = gfc_chainon_list (NULL_TREE,\n-\t\t\t\t  build_int_cst (gfc_c_int_type_node,\n-\t\t\t\t\t\t gfc_option.fpe));\n-      tmp = build_function_call_expr (gfor_fndecl_set_fpe, arglist);\n+      tree gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n+      tmp = build_call_expr (gfor_fndecl_set_fpe, 1,\n+\t\t\t     build_int_cst (gfc_c_int_type_node,\n+\t\t\t\t\t    gfc_option.fpe));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n@@ -3175,13 +3165,10 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   if (sym->attr.is_main_program && gfc_option.convert != CONVERT_NATIVE)\n     {\n-      tree arglist, gfc_c_int_type_node;\n-\n-      gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n-      arglist = gfc_chainon_list (NULL_TREE,\n-\t\t\t\t  build_int_cst (gfc_c_int_type_node,\n-\t\t\t\t\t\t gfc_option.convert));\n-      tmp = build_function_call_expr (gfor_fndecl_set_convert, arglist);\n+      tree gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n+      tmp = build_call_expr (gfor_fndecl_set_convert, 1,\n+\t\t\t     build_int_cst (gfc_c_int_type_node,\n+\t\t\t\t\t    gfc_option.convert));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n@@ -3190,26 +3177,22 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   if (sym->attr.is_main_program && gfc_option.record_marker != 0)\n     {\n-      tree arglist, gfc_c_int_type_node;\n-\n-      gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n-      arglist = gfc_chainon_list (NULL_TREE,\n-\t\t\t\t  build_int_cst (gfc_c_int_type_node,\n-\t\t\t\t\t\t gfc_option.record_marker));\n-      tmp = build_function_call_expr (gfor_fndecl_set_record_marker, arglist);\n+      tree gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n+      tmp = build_call_expr (gfor_fndecl_set_record_marker, 1,\n+\t\t\t     build_int_cst (gfc_c_int_type_node,\n+\t\t\t\t\t    gfc_option.record_marker));\n       gfc_add_expr_to_block (&body, tmp);\n-\n     }\n \n   if (sym->attr.is_main_program && gfc_option.max_subrecord_length != 0)\n     {\n-      tree arglist, gfc_c_int_type_node;\n+      tree gfc_c_int_type_node;\n \n       gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n-      arglist = gfc_chainon_list (NULL_TREE,\n-\t\t\t\t  build_int_cst (gfc_c_int_type_node,\n-\t\t\t\t\t\t gfc_option.max_subrecord_length));\n-      tmp = build_function_call_expr (gfor_fndecl_set_max_subrecord_length, arglist);\n+      tmp = build_call_expr (gfor_fndecl_set_max_subrecord_length,\n+\t\t\t     1,\n+\t\t\t     build_int_cst (gfc_c_int_type_node,\n+\t\t\t\t\t    gfc_option.max_subrecord_length));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n@@ -3374,8 +3357,7 @@ gfc_generate_constructors (void)\n \n   for (; gfc_static_ctors; gfc_static_ctors = TREE_CHAIN (gfc_static_ctors))\n     {\n-      tmp =\n-\tbuild_function_call_expr (TREE_VALUE (gfc_static_ctors), NULL_TREE);\n+      tmp = build_call_expr (TREE_VALUE (gfc_static_ctors), 0);\n       DECL_SAVED_TREE (fndecl) = build_stmt (EXPR_STMT, tmp);\n     }\n "}, {"sha": "839d768318e7b9ff5a663fb8ee63df4d81581c1f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 27, "deletions": 57, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -748,7 +748,6 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n   gfc_se lse;\n   gfc_se rse;\n   tree fndecl;\n-  tree tmp;\n \n   gfc_init_se (&lse, se);\n   gfc_conv_expr_val (&lse, expr->value.op.op1);\n@@ -887,9 +886,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n       break;\n     }\n \n-  tmp = gfc_chainon_list (NULL_TREE, lse.expr);\n-  tmp = gfc_chainon_list (tmp, rse.expr);\n-  se->expr = build_function_call_expr (fndecl, tmp);\n+  se->expr = build_call_expr (fndecl, 2, lse.expr, rse.expr);\n }\n \n \n@@ -900,7 +897,6 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n {\n   tree var;\n   tree tmp;\n-  tree args;\n \n   gcc_assert (TREE_TYPE (len) == gfc_charlen_type_node);\n \n@@ -918,15 +914,13 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n     {\n       /* Allocate a temporary to hold the result.  */\n       var = gfc_create_var (type, \"pstr\");\n-      args = gfc_chainon_list (NULL_TREE, len);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_malloc, args);\n+      tmp = build_call_expr (gfor_fndecl_internal_malloc, 1, len);\n       tmp = convert (type, tmp);\n       gfc_add_modify_expr (&se->pre, var, tmp);\n \n       /* Free the temporary afterwards.  */\n       tmp = convert (pvoid_type_node, var);\n-      args = gfc_chainon_list (NULL_TREE, tmp);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, tmp);\n       gfc_add_expr_to_block (&se->post, tmp);\n     }\n \n@@ -945,7 +939,6 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   tree len;\n   tree type;\n   tree var;\n-  tree args;\n   tree tmp;\n \n   gcc_assert (expr->value.op.op1->ts.type == BT_CHARACTER\n@@ -974,14 +967,10 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   var = gfc_conv_string_tmp (se, type, len);\n \n   /* Do the actual concatenation.  */\n-  args = NULL_TREE;\n-  args = gfc_chainon_list (args, len);\n-  args = gfc_chainon_list (args, var);\n-  args = gfc_chainon_list (args, lse.string_length);\n-  args = gfc_chainon_list (args, lse.expr);\n-  args = gfc_chainon_list (args, rse.string_length);\n-  args = gfc_chainon_list (args, rse.expr);\n-  tmp = build_function_call_expr (gfor_fndecl_concat_string, args);\n+  tmp = build_call_expr (gfor_fndecl_concat_string, 6,\n+\t\t\t len, var,\n+\t\t\t lse.string_length, lse.expr,\n+\t\t\t rse.string_length, rse.expr);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Add the cleanup for the operands.  */\n@@ -1205,17 +1194,9 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2)\n       tmp = fold_build2 (MINUS_EXPR, type, sc1, sc2);\n     }\n    else\n-    {\n-      tmp = NULL_TREE;\n-      tmp = gfc_chainon_list (tmp, len1);\n-      tmp = gfc_chainon_list (tmp, str1);\n-      tmp = gfc_chainon_list (tmp, len2);\n-      tmp = gfc_chainon_list (tmp, str2);\n-\n-      /* Build a call for the comparison.  */\n-      tmp = build_function_call_expr (gfor_fndecl_compare_string, tmp);\n-    }\n-\n+     /* Build a call for the comparison.  */\n+     tmp = build_call_expr (gfor_fndecl_compare_string, 4,\n+\t\t\t    len1, str1, len2, str2);\n   return tmp;\n }\n \n@@ -1281,7 +1262,7 @@ gfc_conv_operator_assign (gfc_se *lse, gfc_se *rse, gfc_symbol *sym)\n   gfc_init_se (&se, NULL);\n   gfc_conv_function_val (&se, sym);\n   tmp = TREE_TYPE (TREE_TYPE (TREE_TYPE (se.expr)));\n-  tmp = build3 (CALL_EXPR, tmp, se.expr, args, NULL_TREE);\n+  tmp = build_call_list (tmp, se.expr, args);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &lse->post);\n@@ -2407,8 +2388,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     }\n \n   fntype = TREE_TYPE (TREE_TYPE (se->expr));\n-  se->expr = build3 (CALL_EXPR, TREE_TYPE (fntype), se->expr,\n-\t\t     arglist, NULL_TREE);\n+  se->expr = build_call_list (TREE_TYPE (fntype), se->expr, arglist);\n \n   /* If we have a pointer function, but we don't want a pointer, e.g.\n      something like\n@@ -2542,26 +2522,21 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   \n   /* Truncate string if source is too long.  */\n   cond2 = fold_build2 (GE_EXPR, boolean_type_node, slen, dlen);\n-  tmp2 = gfc_chainon_list (NULL_TREE, dest);\n-  tmp2 = gfc_chainon_list (tmp2, src);\n-  tmp2 = gfc_chainon_list (tmp2, dlen);\n-  tmp2 = build_function_call_expr (built_in_decls[BUILT_IN_MEMMOVE], tmp2);\n+  tmp2 = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE],\n+\t\t\t  3, dest, src, dlen);\n \n   /* Else copy and pad with spaces.  */\n-  tmp3 = gfc_chainon_list (NULL_TREE, dest);\n-  tmp3 = gfc_chainon_list (tmp3, src);\n-  tmp3 = gfc_chainon_list (tmp3, slen);\n-  tmp3 = build_function_call_expr (built_in_decls[BUILT_IN_MEMMOVE], tmp3);\n+  tmp3 = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE],\n+\t\t\t  3, dest, src, slen);\n \n   tmp4 = fold_build2 (PLUS_EXPR, pchar_type_node, dest,\n \t\t      fold_convert (pchar_type_node, slen));\n-  tmp4 = gfc_chainon_list (NULL_TREE, tmp4);\n-  tmp4 = gfc_chainon_list (tmp4, build_int_cst\n-\t\t\t\t   (gfc_get_int_type (gfc_c_int_kind),\n-\t\t\t\t    lang_hooks.to_target_charset (' ')));\n-  tmp4 = gfc_chainon_list (tmp4, fold_build2 (MINUS_EXPR, TREE_TYPE(dlen),\n-\t\t\t\t\t      dlen, slen));\n-  tmp4 = build_function_call_expr (built_in_decls[BUILT_IN_MEMSET], tmp4);\n+  tmp4 = build_call_expr (built_in_decls[BUILT_IN_MEMSET], 3,\n+\t\t\t  tmp4, \n+\t\t\t  build_int_cst (gfc_get_int_type (gfc_c_int_kind),\n+\t\t\t\t\t lang_hooks.to_target_charset (' ')),\n+\t\t\t  fold_build2 (MINUS_EXPR, TREE_TYPE(dlen),\n+\t\t\t\t       dlen, slen));\n \n   gfc_init_block (&tempblock);\n   gfc_add_expr_to_block (&tempblock, tmp3);\n@@ -3585,7 +3560,7 @@ static tree\n gfc_trans_zero_assign (gfc_expr * expr)\n {\n   tree dest, len, type;\n-  tree tmp, args;\n+  tree tmp;\n   gfc_symbol *sym;\n \n   sym = expr->symtree->n.sym;\n@@ -3613,10 +3588,8 @@ gfc_trans_zero_assign (gfc_expr * expr)\n   len = fold_convert (size_type_node, len);\n \n   /* Construct call to __builtin_memset.  */\n-  args = build_tree_list (NULL_TREE, len);\n-  args = tree_cons (NULL_TREE, integer_zero_node, args);\n-  args = tree_cons (NULL_TREE, dest, args);\n-  tmp = build_function_call_expr (built_in_decls[BUILT_IN_MEMSET], args);\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMSET],\n+\t\t\t 3, dest, integer_zero_node, len);\n   return fold_convert (void_type_node, tmp);\n }\n \n@@ -3627,7 +3600,7 @@ gfc_trans_zero_assign (gfc_expr * expr)\n static tree\n gfc_build_memcpy_call (tree dst, tree src, tree len)\n {\n-  tree tmp, args;\n+  tree tmp;\n \n   /* Convert arguments to the correct types.  */\n   if (!POINTER_TYPE_P (TREE_TYPE (dst)))\n@@ -3643,10 +3616,7 @@ gfc_build_memcpy_call (tree dst, tree src, tree len)\n   len = fold_convert (size_type_node, len);\n \n   /* Construct call to __builtin_memcpy.  */\n-  args = build_tree_list (NULL_TREE, len);\n-  args = tree_cons (NULL_TREE, src, args);\n-  args = tree_cons (NULL_TREE, dst, args);\n-  tmp = build_function_call_expr (built_in_decls[BUILT_IN_MEMCPY], args);\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3, dst, src, len);\n   return fold_convert (void_type_node, tmp);\n }\n "}, {"sha": "e6bc46f228d10aee5a65c5268821efd03851b549", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -164,6 +164,8 @@ real_compnt_info;\n enum rounding_mode { RND_ROUND, RND_TRUNC, RND_CEIL, RND_FLOOR };\n \n /* Evaluate the arguments to an intrinsic function.  */\n+/* FIXME: This function and its callers should be rewritten so that it's\n+   not necessary to cons up a list to hold the arguments.  */\n \n static tree\n gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n@@ -1273,8 +1275,7 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   /* Free the temporary afterwards, if necessary.  */\n   cond = build2 (GT_EXPR, boolean_type_node, len,\n \t\t build_int_cst (TREE_TYPE (len), 0));\n-  arglist = gfc_chainon_list (NULL_TREE, var);\n-  tmp = build_function_call_expr (gfor_fndecl_internal_free, arglist);\n+  tmp = build_call_expr (gfor_fndecl_internal_free, 1, var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n \n@@ -1309,8 +1310,7 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   /* Free the temporary afterwards, if necessary.  */\n   cond = build2 (GT_EXPR, boolean_type_node, len,\n \t\t build_int_cst (TREE_TYPE (len), 0));\n-  arglist = gfc_chainon_list (NULL_TREE, var);\n-  tmp = build_function_call_expr (gfor_fndecl_internal_free, arglist);\n+  tmp = build_call_expr (gfor_fndecl_internal_free, 1, var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n \n@@ -1347,8 +1347,7 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   /* Free the temporary afterwards, if necessary.  */\n   cond = build2 (GT_EXPR, boolean_type_node, len,\n \t\t build_int_cst (TREE_TYPE (len), 0));\n-  arglist = gfc_chainon_list (NULL_TREE, var);\n-  tmp = build_function_call_expr (gfor_fndecl_internal_free, arglist);\n+  tmp = build_call_expr (gfor_fndecl_internal_free, 1, var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n \n@@ -2809,7 +2808,6 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   tree lower;\n   tree stride;\n   tree stmt;\n-  tree args;\n   gfc_actual_arglist *arg;\n   gfc_se argse;\n   gfc_ss *ss;\n@@ -2850,15 +2848,13 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t      && arg->expr->ref->u.ar.type == AR_FULL))\n \t{\n \t  tmp = build_fold_addr_expr (argse.expr);\n-\t  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-\t  source = build_function_call_expr (gfor_fndecl_in_pack, tmp);\n+\t  source = build_call_expr (gfor_fndecl_in_pack, 1, tmp);\n \t  source = gfc_evaluate_now (source, &argse.pre);\n \n \t  /* Free the temporary.  */\n \t  gfc_start_block (&block);\n \t  tmp = convert (pvoid_type_node, source);\n-\t  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-\t  tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+\t  tmp = build_call_expr (gfor_fndecl_internal_free, 1, tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t  stmt = gfc_finish_block (&block);\n \n@@ -2998,13 +2994,11 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\t       info, tmp, false, true, false);\n \n   /* Use memcpy to do the transfer.  */\n-  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = fold_convert (pvoid_type_node, source);\n-  args = gfc_chainon_list (args, source);\n-  args = gfc_chainon_list (args, size_bytes);\n-  tmp = built_in_decls[BUILT_IN_MEMCPY];\n-  tmp = build_function_call_expr (tmp, args);\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY],\n+\t\t\t 3,\n+\t\t\t gfc_conv_descriptor_data_get (info->descriptor),\n+\t\t\t fold_convert (pvoid_type_node, source),\n+\t\t\t size_bytes);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   se->expr = info->descriptor;\n@@ -3024,7 +3018,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   tree type;\n   tree ptr;\n   gfc_ss *ss;\n-  tree tmpdecl, tmp, args;\n+  tree tmpdecl, tmp;\n \n   /* Get a pointer to the source.  */\n   arg = expr->value.function.actual;\n@@ -3059,13 +3053,10 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n       /* Use memcpy to do the transfer.  */\n       tmp = build1 (ADDR_EXPR, build_pointer_type (type), tmpdecl);\n-      tmp = fold_convert (pvoid_type_node, tmp);\n-      args = gfc_chainon_list (NULL_TREE, tmp);\n-      tmp = fold_convert (pvoid_type_node, ptr);\n-      args = gfc_chainon_list (args, tmp);\n-      args = gfc_chainon_list (args, moldsize);\n-      tmp = built_in_decls[BUILT_IN_MEMCPY];\n-      tmp = build_function_call_expr (tmp, args);\n+      tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t     fold_convert (pvoid_type_node, tmp),\n+\t\t\t     fold_convert (pvoid_type_node, ptr),\n+\t\t\t     moldsize);\n       gfc_add_expr_to_block (&se->pre, tmp);\n \n       se->expr = tmpdecl;\n@@ -3112,7 +3103,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n   gfc_se arg2se;\n   tree tmp2;\n   tree tmp;\n-  tree args, fndecl;\n+  tree fndecl;\n   tree nonzero_charlen;\n   tree nonzero_arraylen;\n   gfc_ss *ss1, *ss2;\n@@ -3185,18 +3176,15 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \n           /* A pointer to an array, call library function _gfor_associated.  */\n           gcc_assert (ss2 != gfc_ss_terminator);\n-          args = NULL_TREE;\n           arg1se.want_pointer = 1;\n           gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n-          args = gfc_chainon_list (args, arg1se.expr);\n \n           arg2se.want_pointer = 1;\n           gfc_conv_expr_descriptor (&arg2se, arg2->expr, ss2);\n           gfc_add_block_to_block (&se->pre, &arg2se.pre);\n           gfc_add_block_to_block (&se->post, &arg2se.post);\n-          args = gfc_chainon_list (args, arg2se.expr);\n           fndecl = gfor_fndecl_associated;\n-          se->expr = build_function_call_expr (fndecl, args);\n+          se->expr = build_call_expr (fndecl, 2, arg1se.expr, arg2se.expr);\n \t  se->expr = build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t     se->expr, nonzero_arraylen);\n \n@@ -3287,8 +3275,7 @@ gfc_conv_intrinsic_si_kind (gfc_se * se, gfc_expr * expr)\n   args = gfc_conv_intrinsic_function_args (se, expr);\n   args = TREE_VALUE (args);\n   args = build_fold_addr_expr (args);\n-  args = tree_cons (NULL_TREE, args, NULL_TREE);\n-  se->expr = build_function_call_expr (gfor_fndecl_si_kind, args);\n+  se->expr = build_call_expr (gfor_fndecl_si_kind, 1, args);\n }\n \n /* Generate code for SELECTED_REAL_KIND (P, R) intrinsic function.  */\n@@ -3351,8 +3338,7 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   /* Free the temporary afterwards, if necessary.  */\n   cond = build2 (GT_EXPR, boolean_type_node, len,\n \t\t build_int_cst (TREE_TYPE (len), 0));\n-  arglist = gfc_chainon_list (NULL_TREE, var);\n-  tmp = build_function_call_expr (gfor_fndecl_internal_free, arglist);\n+  tmp = build_call_expr (gfor_fndecl_internal_free, 1, var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n \n@@ -3370,7 +3356,6 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   tree tmp;\n   tree len;\n   tree args;\n-  tree arglist;\n   tree ncopies;\n   tree var;\n   tree type;\n@@ -3395,12 +3380,9 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   var = gfc_conv_string_tmp (se, build_pointer_type (type), len);\n \n   /* Create the argument list and generate the function call.  */\n-  arglist = NULL_TREE;\n-  arglist = gfc_chainon_list (arglist, var);\n-  arglist = gfc_chainon_list (arglist, TREE_VALUE (args));\n-  arglist = gfc_chainon_list (arglist, TREE_VALUE (TREE_CHAIN (args)));\n-  arglist = gfc_chainon_list (arglist, ncopies);\n-  tmp = build_function_call_expr (gfor_fndecl_string_repeat, arglist);\n+  tmp = build_call_expr (gfor_fndecl_string_repeat, 4, var,\n+\t\t\t TREE_VALUE (args),\n+\t\t\t TREE_VALUE (TREE_CHAIN (args)), ncopies);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   se->expr = var;\n@@ -3419,7 +3401,7 @@ gfc_conv_intrinsic_iargc (gfc_se * se, gfc_expr * expr)\n \n   /* Call the library function.  This always returns an INTEGER(4).  */\n   fndecl = gfor_fndecl_iargc;\n-  tmp = build_function_call_expr (fndecl, NULL_TREE);\n+  tmp = build_call_expr (fndecl, 0);\n \n   /* Convert it to the required type.  */\n   type = gfc_typenode_for_spec (&expr->ts);"}, {"sha": "951d4651869e3e0b3ea2be81978af3bd33fd1cc2", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 22, "deletions": 44, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -835,8 +835,7 @@ gfc_trans_open (gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = build_fold_addr_expr (var);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (iocall[IOCALL_OPEN], tmp);\n+  tmp = build_call_expr (iocall[IOCALL_OPEN], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -888,8 +887,7 @@ gfc_trans_close (gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = build_fold_addr_expr (var);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (iocall[IOCALL_CLOSE], tmp);\n+  tmp = build_call_expr (iocall[IOCALL_CLOSE], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -939,8 +937,7 @@ build_filepos (tree function, gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = build_fold_addr_expr (var);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (function, tmp);\n+  tmp = build_call_expr (function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1125,8 +1122,7 @@ gfc_trans_inquire (gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = build_fold_addr_expr (var);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (iocall[IOCALL_INQUIRE], tmp);\n+  tmp = build_call_expr (iocall[IOCALL_INQUIRE], 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1248,8 +1244,6 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n    call to iocall[IOCALL_SET_NML_VAL].  For derived type variable, recursively\n    generate calls to iocall[IOCALL_SET_NML_VAL] for each component.  */\n \n-#define NML_FIRST_ARG(a) args = gfc_chainon_list (NULL_TREE, a)\n-#define NML_ADD_ARG(a) args = gfc_chainon_list (args, a)\n #define IARG(i) build_int_cst (gfc_array_index_type, i)\n \n static void\n@@ -1263,7 +1257,6 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   tree dt = NULL;\n   tree string;\n   tree tmp;\n-  tree args;\n   tree dtype;\n   tree dt_parm_addr;\n   int n_dim; \n@@ -1329,31 +1322,27 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n      (address, name, type, kind or string_length, dtype)  */\n \n   dt_parm_addr = build_fold_addr_expr (dt_parm);\n-  NML_FIRST_ARG (dt_parm_addr);\n-  NML_ADD_ARG (addr_expr);\n-  NML_ADD_ARG (string);\n-  NML_ADD_ARG (IARG (ts->kind));\n \n   if (ts->type == BT_CHARACTER)\n-    NML_ADD_ARG (ts->cl->backend_decl);\n+    tmp = ts->cl->backend_decl;\n   else\n-    NML_ADD_ARG (build_int_cst (gfc_charlen_type_node, 0));\n-\n-  NML_ADD_ARG (dtype);\n-  tmp = build_function_call_expr (iocall[IOCALL_SET_NML_VAL], args);\n+    tmp = build_int_cst (gfc_charlen_type_node, 0);\n+  tmp = build_call_expr (iocall[IOCALL_SET_NML_VAL], 6,\n+\t\t\t dt_parm_addr, addr_expr, string,\n+\t\t\t IARG (ts->kind), tmp, dtype);\n   gfc_add_expr_to_block (block, tmp);\n \n   /* If the object is an array, transfer rank times:\n      (null pointer, name, stride, lbound, ubound)  */\n \n   for ( n_dim = 0 ; n_dim < rank ; n_dim++ )\n     {\n-      NML_FIRST_ARG (dt_parm_addr);\n-      NML_ADD_ARG (IARG (n_dim));\n-      NML_ADD_ARG (GFC_TYPE_ARRAY_STRIDE (dt, n_dim));\n-      NML_ADD_ARG (GFC_TYPE_ARRAY_LBOUND (dt, n_dim));\n-      NML_ADD_ARG (GFC_TYPE_ARRAY_UBOUND (dt, n_dim));\n-      tmp = build_function_call_expr (iocall[IOCALL_SET_NML_VAL_DIM], args);\n+      tmp = build_call_expr (iocall[IOCALL_SET_NML_VAL_DIM], 5,\n+\t\t\t     dt_parm_addr,\n+\t\t\t     IARG (n_dim),\n+\t\t\t     GFC_TYPE_ARRAY_STRIDE (dt, n_dim),\n+\t\t\t     GFC_TYPE_ARRAY_LBOUND (dt, n_dim),\n+\t\t\t     GFC_TYPE_ARRAY_UBOUND (dt, n_dim));\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n@@ -1377,8 +1366,6 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n }\n \n #undef IARG\n-#undef NML_ADD_ARG\n-#undef NML_FIRST_ARG\n \n /* Create a data transfer statement.  Not all of the fields are valid\n    for both reading and writing, but improper use has been filtered\n@@ -1509,8 +1496,7 @@ build_dt (tree function, gfc_code * code)\n     set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = build_fold_addr_expr (var);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (function, tmp);\n+  tmp = build_call_expr (function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   gfc_add_block_to_block (&block, &post_block);\n@@ -1590,8 +1576,7 @@ gfc_trans_dt_end (gfc_code * code)\n     }\n \n   tmp = build_fold_addr_expr (dt_parm);\n-  tmp = gfc_chainon_list (NULL_TREE, tmp);\n-  tmp = build_function_call_expr (function, tmp);\n+  tmp = build_call_expr (function, 1, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, dt_post_end_block);\n   gfc_init_block (dt_post_end_block);\n@@ -1702,7 +1687,7 @@ transfer_array_component (tree expr, gfc_component * cm)\n static void\n transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n {\n-  tree args, tmp, function, arg2, field, expr;\n+  tree tmp, function, arg2, field, expr;\n   gfc_component *c;\n   int kind;\n \n@@ -1777,11 +1762,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n     }\n \n   tmp = build_fold_addr_expr (dt_parm);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n-  args = gfc_chainon_list (args, addr_expr);\n-  args = gfc_chainon_list (args, arg2);\n-\n-  tmp = build_function_call_expr (function, args);\n+  tmp = build_call_expr (function, 3, tmp, addr_expr, arg2);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   gfc_add_block_to_block (&se->pre, &se->post);\n \n@@ -1794,7 +1775,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n static void\n transfer_array_desc (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n {\n-  tree args, tmp, charlen_arg, kind_arg;\n+  tree tmp, charlen_arg, kind_arg;\n \n   if (ts->type == BT_CHARACTER)\n     charlen_arg = se->string_length;\n@@ -1804,11 +1785,8 @@ transfer_array_desc (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n   kind_arg = build_int_cst (NULL_TREE, ts->kind);\n \n   tmp = build_fold_addr_expr (dt_parm);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n-  args = gfc_chainon_list (args, addr_expr);\n-  args = gfc_chainon_list (args, kind_arg);\n-  args = gfc_chainon_list (args, charlen_arg);\n-  tmp = build_function_call_expr (iocall[IOCALL_X_ARRAY], args);\n+  tmp = build_call_expr (iocall[IOCALL_X_ARRAY], 4,\n+\t\t\t tmp, addr_expr, kind_arg, charlen_arg);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   gfc_add_block_to_block (&se->pre, &se->post);\n }"}, {"sha": "49368661591ebb3f8f4a69a259f5e965418e6dac", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -875,7 +875,7 @@ static tree\n gfc_trans_omp_barrier (void)\n {\n   tree decl = built_in_decls [BUILT_IN_GOMP_BARRIER];\n-  return build_function_call_expr (decl, NULL);\n+  return build_call_expr (decl, 0);\n }\n \n static tree\n@@ -1054,7 +1054,7 @@ static tree\n gfc_trans_omp_flush (void)\n {\n   tree decl = built_in_decls [BUILT_IN_SYNCHRONIZE];\n-  return build_function_call_expr (decl, NULL);\n+  return build_call_expr (decl, 0);\n }\n \n static tree"}, {"sha": "cdc8dc6c6694b826bcd6b946a2b8b993401c3069", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 22, "deletions": 51, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -295,9 +295,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  gfc_add_modify_expr (&se->pre, info->offset, offset);\n \n \t  /* Copy the result back using unpack.  */\n-\t  tmp = gfc_chainon_list (NULL_TREE, parmse.expr);\n-\t  tmp = gfc_chainon_list (tmp, data);\n-\t  tmp = build_function_call_expr (gfor_fndecl_in_unpack, tmp);\n+\t  tmp = build_call_expr (gfor_fndecl_in_unpack, 2, parmse.expr, data);\n \t  gfc_add_expr_to_block (&se->post, tmp);\n \n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n@@ -470,9 +468,7 @@ gfc_trans_pause (gfc_code * code)\n {\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n   gfc_se se;\n-  tree args;\n   tree tmp;\n-  tree fndecl;\n \n   /* Start a new block for this statement.  */\n   gfc_init_se (&se, NULL);\n@@ -482,18 +478,15 @@ gfc_trans_pause (gfc_code * code)\n   if (code->expr == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n-      args = gfc_chainon_list (NULL_TREE, tmp);\n-      fndecl = gfor_fndecl_pause_numeric;\n+      tmp = build_call_expr (gfor_fndecl_pause_numeric, 1, tmp);\n     }\n   else\n     {\n       gfc_conv_expr_reference (&se, code->expr);\n-      args = gfc_chainon_list (NULL_TREE, se.expr);\n-      args = gfc_chainon_list (args, se.string_length);\n-      fndecl = gfor_fndecl_pause_string;\n+      tmp = build_call_expr (gfor_fndecl_pause_string, 2,\n+\t\t\t     se.expr, se.string_length);\n     }\n \n-  tmp = build_function_call_expr (fndecl, args);\n   gfc_add_expr_to_block (&se.pre, tmp);\n \n   gfc_add_block_to_block (&se.pre, &se.post);\n@@ -510,9 +503,7 @@ gfc_trans_stop (gfc_code * code)\n {\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n   gfc_se se;\n-  tree args;\n   tree tmp;\n-  tree fndecl;\n \n   /* Start a new block for this statement.  */\n   gfc_init_se (&se, NULL);\n@@ -522,18 +513,15 @@ gfc_trans_stop (gfc_code * code)\n   if (code->expr == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n-      args = gfc_chainon_list (NULL_TREE, tmp);\n-      fndecl = gfor_fndecl_stop_numeric;\n+      tmp = build_call_expr (gfor_fndecl_stop_numeric, 1, tmp);\n     }\n   else\n     {\n       gfc_conv_expr_reference (&se, code->expr);\n-      args = gfc_chainon_list (NULL_TREE, se.expr);\n-      args = gfc_chainon_list (args, se.string_length);\n-      fndecl = gfor_fndecl_stop_string;\n+      tmp = build_call_expr (gfor_fndecl_stop_string, 2,\n+\t\t\t     se.expr, se.string_length);\n     }\n \n-  tmp = build_function_call_expr (fndecl, args);\n   gfc_add_expr_to_block (&se.pre, tmp);\n \n   gfc_add_block_to_block (&se.pre, &se.post);\n@@ -1308,7 +1296,7 @@ gfc_trans_logical_select (gfc_code * code)\n static tree\n gfc_trans_character_select (gfc_code *code)\n {\n-  tree init, node, end_label, tmp, type, args, *labels;\n+  tree init, node, end_label, tmp, type, *labels;\n   tree case_label;\n   stmtblock_t block, body;\n   gfc_case *cp, *d;\n@@ -1449,25 +1437,19 @@ gfc_trans_character_select (gfc_code *code)\n   DECL_INITIAL (tmp) = init;\n   init = tmp;\n \n-  /* Build an argument list for the library call */\n+  /* Build the library call */\n   init = gfc_build_addr_expr (pvoid_type_node, init);\n-  args = gfc_chainon_list (NULL_TREE, init);\n-\n-  tmp = build_int_cst (NULL_TREE, n);\n-  args = gfc_chainon_list (args, tmp);\n-\n   tmp = gfc_build_addr_expr (pvoid_type_node, end_label);\n-  args = gfc_chainon_list (args, tmp);\n \n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_reference (&se, code->expr);\n \n-  args = gfc_chainon_list (args, se.expr);\n-  args = gfc_chainon_list (args, se.string_length);\n-\n   gfc_add_block_to_block (&block, &se.pre);\n \n-  tmp = build_function_call_expr (gfor_fndecl_select_string, args);\n+  tmp = build_call_expr (gfor_fndecl_select_string, 5,\n+\t\t\t init, build_int_cst (NULL_TREE, n),\n+\t\t\t tmp, se.expr, se.string_length);\n+\t\t\t \n   case_label = gfc_create_var (TREE_TYPE (tmp), \"case_label\");\n   gfc_add_modify_expr (&block, case_label, tmp);\n \n@@ -1687,7 +1669,6 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n   tree tmpvar;\n   tree type;\n   tree tmp;\n-  tree args;\n \n   if (INTEGER_CST_P (size))\n     {\n@@ -1710,14 +1691,13 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n       tmpvar = gfc_create_var (build_pointer_type (type), \"temp\");\n       *pdata = convert (pvoid_type_node, tmpvar);\n \n-      args = gfc_chainon_list (NULL_TREE, bytesize);\n       if (gfc_index_integer_kind == 4)\n \ttmp = gfor_fndecl_internal_malloc;\n       else if (gfc_index_integer_kind == 8)\n \ttmp = gfor_fndecl_internal_malloc64;\n       else\n \tgcc_unreachable ();\n-      tmp = build_function_call_expr (tmp, args);\n+      tmp = build_call_expr (tmp, 1, bytesize);\n       tmp = convert (TREE_TYPE (tmpvar), tmp);\n       gfc_add_modify_expr (pblock, tmpvar, tmp);\n     }\n@@ -2229,8 +2209,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   if (ptemp1)\n     {\n       /* Free the temporary.  */\n-      tmp = gfc_chainon_list (NULL_TREE, ptemp1);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, ptemp1);\n       gfc_add_expr_to_block (block, tmp);\n     }\n }\n@@ -2388,8 +2367,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   /* Free the temporary.  */\n   if (ptemp1)\n     {\n-      tmp = gfc_chainon_list (NULL_TREE, ptemp1);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, ptemp1);\n       gfc_add_expr_to_block (block, tmp);\n     }\n }\n@@ -2724,8 +2702,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   if (pmask)\n     {\n       /* Free the temporary for the mask.  */\n-      tmp = gfc_chainon_list (NULL_TREE, pmask);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, pmask);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   if (maskindex)\n@@ -3322,16 +3299,14 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n   /* If we allocated a pending mask array, deallocate it now.  */\n   if (ppmask)\n     {\n-      tree args = gfc_chainon_list (NULL_TREE, ppmask);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, ppmask);\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n   /* If we allocated a current mask array, deallocate it now.  */\n   if (pcmask)\n     {\n-      tree args = gfc_chainon_list (NULL_TREE, pcmask);\n-      tmp = build_function_call_expr (gfor_fndecl_internal_free, args);\n+      tmp = build_call_expr (gfor_fndecl_internal_free, 1, pcmask);\n       gfc_add_expr_to_block (block, tmp);\n     }\n }\n@@ -3617,9 +3592,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  if (expr->ts.type == BT_CHARACTER && tmp == NULL_TREE)\n \t    tmp = se.string_length;\n \n-\t  parm = gfc_chainon_list (NULL_TREE, tmp);\n-\t  parm = gfc_chainon_list (parm, pstat);\n-\t  tmp = build_function_call_expr (gfor_fndecl_allocate, parm);\n+\t  tmp = build_call_expr (gfor_fndecl_allocate, 2, tmp, pstat);\n \t  tmp = build2 (MODIFY_EXPR, void_type_node, se.expr, tmp);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n@@ -3685,7 +3658,7 @@ gfc_trans_deallocate (gfc_code * code)\n   gfc_se se;\n   gfc_alloc *al;\n   gfc_expr *expr;\n-  tree apstat, astat, parm, pstat, stat, tmp;\n+  tree apstat, astat, pstat, stat, tmp;\n   stmtblock_t block;\n \n   gfc_start_block (&block);\n@@ -3748,9 +3721,7 @@ gfc_trans_deallocate (gfc_code * code)\n \ttmp = gfc_array_deallocate (se.expr, pstat);\n       else\n \t{\n-\t  parm = gfc_chainon_list (NULL_TREE, se.expr);\n-\t  parm = gfc_chainon_list (parm, pstat);\n-\t  tmp = build_function_call_expr (gfor_fndecl_deallocate, parm);\n+\t  tmp = build_call_expr (gfor_fndecl_deallocate, 2, se.expr, pstat);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  tmp = build2 (MODIFY_EXPR, void_type_node,"}, {"sha": "59b2dec335e1981f27b7642dc0296cb3421e19fd", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -318,7 +318,7 @@ gfc_trans_runtime_check (tree cond, const char * msgid, stmtblock_t * pblock,\n   stmtblock_t block;\n   tree body;\n   tree tmp;\n-  tree args;\n+  tree arg;\n   char * message;\n   int line;\n \n@@ -342,11 +342,10 @@ gfc_trans_runtime_check (tree cond, const char * msgid, stmtblock_t * pblock,\n     asprintf (&message, \"%s (in file '%s', around line %d)\", _(msgid),\n \t      gfc_source_file, input_line + 1);\n \n-  tmp = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const(message));\n+  arg = gfc_build_addr_expr (pchar_type_node, gfc_build_cstring_const(message));\n   gfc_free(message);\n-  args = gfc_chainon_list (NULL_TREE, tmp);\n \n-  tmp = build_function_call_expr (gfor_fndecl_runtime_error, args);\n+  tmp = build_call_expr (gfor_fndecl_runtime_error, 1, arg);\n   gfc_add_expr_to_block (&block, tmp);\n \n   body = gfc_finish_block (&block);\n@@ -359,9 +358,8 @@ gfc_trans_runtime_check (tree cond, const char * msgid, stmtblock_t * pblock,\n     {\n       /* Tell the compiler that this isn't likely.  */\n       cond = fold_convert (long_integer_type_node, cond);\n-      tmp = gfc_chainon_list (NULL_TREE, cond);\n-      tmp = gfc_chainon_list (tmp, build_int_cst (long_integer_type_node, 0));\n-      cond = build_function_call_expr (built_in_decls[BUILT_IN_EXPECT], tmp);\n+      tmp = build_int_cst (long_integer_type_node, 0);\n+      cond = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);\n \n       tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt ());"}, {"sha": "57911bebdc260a5cbea8bb3f0045a4d8109679c7", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -3203,16 +3203,15 @@ gimplify_parameters (void)\n \t\t}\n \t      else\n \t\t{\n-\t\t  tree ptr_type, addr, args;\n+\t\t  tree ptr_type, addr;\n \n \t\t  ptr_type = build_pointer_type (type);\n \t\t  addr = create_tmp_var (ptr_type, get_name (parm));\n \t\t  DECL_IGNORED_P (addr) = 0;\n \t\t  local = build_fold_indirect_ref (addr);\n \n-\t\t  args = tree_cons (NULL, DECL_SIZE_UNIT (parm), NULL);\n \t\t  t = built_in_decls[BUILT_IN_ALLOCA];\n-\t\t  t = build_function_call_expr (t, args);\n+\t\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (parm));\n \t\t  t = fold_convert (ptr_type, t);\n \t\t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n \t\t  gimplify_and_add (t, &stmts);"}, {"sha": "09d8ada47197cc3cc95d526a31acda75247da351", "filename": "gcc/gengtype.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -719,7 +719,7 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n \n   flds = create_field (NULL, t, \"\");\n   flds->opt = create_option (nodot, \"length\",\n-\t\t\t     \"TREE_CODE_LENGTH (TREE_CODE ((tree) &%0))\");\n+\t\t\t     \"TREE_OPERAND_LENGTH ((tree) &%0)\");\n   flds->opt = create_option (flds->opt, \"default\", \"\");\n \n   return new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n@@ -1746,16 +1746,27 @@ walk_type (type_p t, struct walk_type_data *d)\n \tif (t->u.a.p->kind == TYPE_SCALAR)\n \t  break;\n \n+\t/* When walking an array, compute the length and store it in a\n+\t   local variable before walking the array elements, instead of\n+\t   recomputing the length expression each time through the loop.\n+\t   This is necessary to handle tcc_vl_exp objects like CALL_EXPR,\n+\t   where the length is stored in the first array element,\n+\t   because otherwise that operand can get overwritten on the\n+\t   first iteration.  */\n \toprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n \td->indent += 2;\n \toprintf (d->of, \"%*ssize_t i%d;\\n\", d->indent, \"\", loopcounter);\n-\toprintf (d->of, \"%*sfor (i%d = 0; i%d != (size_t)(\", d->indent, \"\",\n-\t\t loopcounter, loopcounter);\n+\toprintf (d->of, \"%*ssize_t l%d = (size_t)(\",\n+\t\t d->indent, \"\", loopcounter);\n \tif (length)\n \t  output_escaped_param (d, length, \"length\");\n \telse\n \t  oprintf (d->of, \"%s\", t->u.a.len);\n-\toprintf (d->of, \"); i%d++) {\\n\", loopcounter);\n+\toprintf (d->of, \");\\n\");\n+\t\n+\toprintf (d->of, \"%*sfor (i%d = 0; i%d != l%d; i%d++) {\\n\",\n+\t\t d->indent, \"\",\n+\t\t loopcounter, loopcounter, loopcounter, loopcounter);\n \td->indent += 2;\n \td->val = newval = xasprintf (\"%s[i%d]\", oldval, loopcounter);\n \td->used_length = 1;"}, {"sha": "ac5266a3334c5ef3ae370703f6f5785991fe4b03", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -134,10 +134,9 @@ lower_function_body (void)\n       /* Build 'DISP_VAR = __builtin_setjmp_dispatcher (DISP_LABEL);'\n \t and insert.  */\n       disp_var = create_tmp_var (ptr_type_node, \"setjmpvar\");\n-      t = build_addr (disp_label, current_function_decl);\n-      arg = tree_cons (NULL, t, NULL);\n+      arg = build_addr (disp_label, current_function_decl);\n       t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];\n-      t = build_function_call_expr (t,arg);\n+      t = build_call_expr (t, 1, arg);\n       x = build2 (GIMPLE_MODIFY_STMT, void_type_node, disp_var, t);\n \n       /* Build 'goto DISP_VAR;' and insert.  */\n@@ -663,12 +662,9 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n     dest = NULL_TREE;\n \n   /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */\n-  t = build_addr (next_label, current_function_decl);\n-  arg = tree_cons (NULL, t, NULL);\n-  t = TREE_VALUE (GENERIC_TREE_OPERAND (stmt, 1));\n-  arg = tree_cons (NULL, t, arg);\n+  arg = build_addr (next_label, current_function_decl);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];\n-  t = build_function_call_expr (t, arg);\n+  t = build_call_expr (t, 2, CALL_EXPR_ARG (stmt, 0), arg);\n   SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n   tsi_link_before (tsi, t, TSI_SAME_STMT);\n \n@@ -689,10 +685,9 @@ lower_builtin_setjmp (tree_stmt_iterator *tsi)\n   tsi_link_before (tsi, t, TSI_SAME_STMT);\n \n   /* Build '__builtin_setjmp_receiver (NEXT_LABEL)' and insert.  */\n-  t = build_addr (next_label, current_function_decl);\n-  arg = tree_cons (NULL, t, NULL);\n+  arg = build_addr (next_label, current_function_decl);\n   t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];\n-  t = build_function_call_expr (t, arg);\n+  t = build_call_expr (t, 1, arg);\n   SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n   tsi_link_before (tsi, t, TSI_SAME_STMT);\n "}, {"sha": "2d02617ccb404e3657b076c4a3ffc72932432c0f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 46, "deletions": 71, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1040,14 +1040,13 @@ build_stack_save_restore (tree *save, tree *restore)\n   tree save_call, tmp_var;\n \n   save_call =\n-      build_function_call_expr (implicit_built_in_decls[BUILT_IN_STACK_SAVE],\n-\t\t\t\tNULL_TREE);\n+    build_call_expr (implicit_built_in_decls[BUILT_IN_STACK_SAVE], 0);\n   tmp_var = create_tmp_var (ptr_type_node, \"saved_stack\");\n \n   *save = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, tmp_var, save_call);\n   *restore =\n-    build_function_call_expr (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n-\t\t\t      tree_cons (NULL_TREE, tmp_var, NULL_TREE));\n+    build_call_expr (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n+\t\t     1, tmp_var);\n }\n \n /* Gimplify a BIND_EXPR.  Just voidify and recurse.  */\n@@ -1233,7 +1232,7 @@ gimplify_decl_expr (tree *stmt_p)\n \t  /* This is a variable-sized decl.  Simplify its size and mark it\n \t     for deferred expansion.  Note that mudflap depends on the format\n \t     of the emitted code: see mx_register_decls().  */\n-\t  tree t, args, addr, ptr_type;\n+\t  tree t, addr, ptr_type;\n \n \t  gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n \t  gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n@@ -1250,9 +1249,8 @@ gimplify_decl_expr (tree *stmt_p)\n \t  SET_DECL_VALUE_EXPR (decl, t);\n \t  DECL_HAS_VALUE_EXPR_P (decl) = 1;\n \n-\t  args = tree_cons (NULL, DECL_SIZE_UNIT (decl), NULL);\n \t  t = built_in_decls[BUILT_IN_ALLOCA];\n-\t  t = build_function_call_expr (t, args);\n+\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (decl));\n \t  t = fold_convert (ptr_type, t);\n \t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n \n@@ -2031,8 +2029,8 @@ static enum gimplify_status\n gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n {\n   tree decl;\n-  tree arglist;\n   enum gimplify_status ret;\n+  int i, nargs;\n \n   gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);\n \n@@ -2056,8 +2054,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   decl = get_callee_fndecl (*expr_p);\n   if (decl && DECL_BUILT_IN (decl))\n     {\n-      tree arglist = TREE_OPERAND (*expr_p, 1);\n-      tree new = fold_builtin (decl, arglist, !want_value);\n+      tree new = fold_call_expr (*expr_p, !want_value);\n \n       if (new && new != *expr_p)\n \t{\n@@ -2071,62 +2068,56 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n       if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n \t  && DECL_FUNCTION_CODE (decl) == BUILT_IN_VA_START)\n         {\n-\t  if (!arglist || !TREE_CHAIN (arglist))\n+\t  if (call_expr_nargs (*expr_p) < 2)\n \t    {\n \t      error (\"too few arguments to function %<va_start%>\");\n \t      *expr_p = build_empty_stmt ();\n \t      return GS_OK;\n \t    }\n \t  \n-\t  if (fold_builtin_next_arg (TREE_CHAIN (arglist)))\n+\t  if (fold_builtin_next_arg (*expr_p, true))\n \t    {\n \t      *expr_p = build_empty_stmt ();\n \t      return GS_OK;\n \t    }\n \t  /* Avoid gimplifying the second argument to va_start, which needs\n \t     to be the plain PARM_DECL.  */\n-\t  return gimplify_arg (&TREE_VALUE (TREE_OPERAND (*expr_p, 1)), pre_p);\n+\t  return gimplify_arg (&CALL_EXPR_ARG (*expr_p, 0), pre_p);\n \t}\n     }\n \n   /* There is a sequence point before the call, so any side effects in\n      the calling expression must occur before the actual call.  Force\n      gimplify_expr to use an internal post queue.  */\n-  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, NULL,\n+  ret = gimplify_expr (&CALL_EXPR_FN (*expr_p), pre_p, NULL,\n \t\t       is_gimple_call_addr, fb_rvalue);\n \n-  if (PUSH_ARGS_REVERSED)\n-    TREE_OPERAND (*expr_p, 1) = nreverse (TREE_OPERAND (*expr_p, 1));\n-  for (arglist = TREE_OPERAND (*expr_p, 1); arglist;\n-       arglist = TREE_CHAIN (arglist))\n+  nargs = call_expr_nargs (*expr_p);\n+\n+  for (i = (PUSH_ARGS_REVERSED ? nargs - 1 : 0);\n+       PUSH_ARGS_REVERSED ? i >= 0 : i < nargs;\n+       PUSH_ARGS_REVERSED ? i-- : i++)\n     {\n       enum gimplify_status t;\n \n-      t = gimplify_arg (&TREE_VALUE (arglist), pre_p);\n+      t = gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p);\n \n       if (t == GS_ERROR)\n \tret = GS_ERROR;\n     }\n-  if (PUSH_ARGS_REVERSED)\n-    TREE_OPERAND (*expr_p, 1) = nreverse (TREE_OPERAND (*expr_p, 1));\n \n   /* Try this again in case gimplification exposed something.  */\n   if (ret != GS_ERROR)\n     {\n-      decl = get_callee_fndecl (*expr_p);\n-      if (decl && DECL_BUILT_IN (decl))\n-\t{\n-\t  tree arglist = TREE_OPERAND (*expr_p, 1);\n-\t  tree new = fold_builtin (decl, arglist, !want_value);\n+      tree new = fold_call_expr (*expr_p, !want_value);\n \n-\t  if (new && new != *expr_p)\n-\t    {\n-\t      /* There was a transformation of this call which computes the\n-\t\t same value, but in a more efficient way.  Return and try\n-\t\t again.  */\n-\t      *expr_p = new;\n-\t      return GS_OK;\n-\t    }\n+      if (new && new != *expr_p)\n+\t{\n+\t  /* There was a transformation of this call which computes the\n+\t     same value, but in a more efficient way.  Return and try\n+\t     again.  */\n+\t  *expr_p = new;\n+\t  return GS_OK;\n \t}\n     }\n \n@@ -2561,20 +2552,16 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, fallback_t fallback)\n static enum gimplify_status\n gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value)\n {\n-  tree args, t, to, to_ptr, from;\n+  tree t, to, to_ptr, from, from_ptr;\n \n   to = GENERIC_TREE_OPERAND (*expr_p, 0);\n   from = GENERIC_TREE_OPERAND (*expr_p, 1);\n \n-  args = tree_cons (NULL, size, NULL);\n-\n-  t = build_fold_addr_expr (from);\n-  args = tree_cons (NULL, t, args);\n+  from_ptr = build_fold_addr_expr (from);\n \n   to_ptr = build_fold_addr_expr (to);\n-  args = tree_cons (NULL, to_ptr, args);\n   t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-  t = build_function_call_expr (t, args);\n+  t = build_call_expr (t, 3, to_ptr, from_ptr, size);\n \n   if (want_value)\n     {\n@@ -2593,18 +2580,13 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value)\n static enum gimplify_status\n gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value)\n {\n-  tree args, t, to, to_ptr;\n+  tree t, to, to_ptr;\n \n   to = GENERIC_TREE_OPERAND (*expr_p, 0);\n \n-  args = tree_cons (NULL, size, NULL);\n-\n-  args = tree_cons (NULL, integer_zero_node, args);\n-\n   to_ptr = build_fold_addr_expr (to);\n-  args = tree_cons (NULL, to_ptr, args);\n   t = implicit_built_in_decls[BUILT_IN_MEMSET];\n-  t = build_function_call_expr (t, args);\n+  t = build_call_expr (t, 3, to_ptr, integer_zero_node, size);\n \n   if (want_value)\n     {\n@@ -3687,18 +3669,15 @@ gimplify_variable_sized_compare (tree *expr_p)\n {\n   tree op0 = TREE_OPERAND (*expr_p, 0);\n   tree op1 = TREE_OPERAND (*expr_p, 1);\n-  tree args, t, dest;\n-\n-  t = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n-  t = unshare_expr (t);\n-  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, op0);\n-  args = tree_cons (NULL, t, NULL);\n-  t = build_fold_addr_expr (op1);\n-  args = tree_cons (NULL, t, args);\n+  tree t, arg, dest, src;\n+\n+  arg = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n+  arg = unshare_expr (arg);\n+  arg = SUBSTITUTE_PLACEHOLDER_IN_EXPR (arg, op0);\n+  src = build_fold_addr_expr (op1);\n   dest = build_fold_addr_expr (op0);\n-  args = tree_cons (NULL, dest, args);\n   t = implicit_built_in_decls[BUILT_IN_MEMCMP];\n-  t = build_function_call_expr (t, args);\n+  t = build_call_expr (t, 3, dest, src, arg);\n   *expr_p\n     = build2 (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), t, integer_zero_node);\n \n@@ -5122,7 +5101,7 @@ static enum gimplify_status\n gimplify_omp_atomic_fetch_op (tree *expr_p, tree addr, tree rhs, int index)\n {\n   enum built_in_function base;\n-  tree decl, args, itype;\n+  tree decl, itype;\n   enum insn_code *optab;\n \n   /* Check for one of the supported fetch-op operations.  */\n@@ -5167,9 +5146,7 @@ gimplify_omp_atomic_fetch_op (tree *expr_p, tree addr, tree rhs, int index)\n   if (optab[TYPE_MODE (itype)] == CODE_FOR_nothing)\n     return GS_UNHANDLED;\n \n-  args = tree_cons (NULL, fold_convert (itype, rhs), NULL);\n-  args = tree_cons (NULL, addr, args);\n-  *expr_p = build_function_call_expr (decl, args);\n+  *expr_p = build_call_expr (decl, 2, addr, fold_convert (itype, rhs));\n   return GS_OK;\n }\n \n@@ -5234,7 +5211,7 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n \t\t\t      tree rhs, int index)\n {\n   tree oldval, oldival, oldival2, newval, newival, label;\n-  tree type, itype, cmpxchg, args, x, iaddr;\n+  tree type, itype, cmpxchg, x, iaddr;\n \n   cmpxchg = built_in_decls[BUILT_IN_VAL_COMPARE_AND_SWAP_N + index + 1];\n   type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (addr)));\n@@ -5295,10 +5272,8 @@ gimplify_omp_atomic_pipeline (tree *expr_p, tree *pre_p, tree addr,\n \t      fold_convert (itype, oldival));\n   gimplify_and_add (x, pre_p);\n \n-  args = tree_cons (NULL, fold_convert (itype, newival), NULL);\n-  args = tree_cons (NULL, fold_convert (itype, oldival), args);\n-  args = tree_cons (NULL, iaddr, args);\n-  x = build_function_call_expr (cmpxchg, args);\n+  x = build_call_expr (cmpxchg, 3, iaddr, fold_convert (itype, oldival),\n+\t\t       fold_convert (itype, newival));\n   if (oldval == oldival)\n     x = fold_convert (type, x);\n   x = build2 (GIMPLE_MODIFY_STMT, void_type_node, oldival, x);\n@@ -5342,15 +5317,15 @@ gimplify_omp_atomic_mutex (tree *expr_p, tree *pre_p, tree addr, tree rhs)\n   tree t;\n \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_START];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (t, 0);\n   gimplify_and_add (t, pre_p);\n \n   t = build_fold_indirect_ref (addr);\n   t = build2 (GIMPLE_MODIFY_STMT, void_type_node, t, rhs);\n   gimplify_and_add (t, pre_p);\n   \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (t, 0);\n   gimplify_and_add (t, pre_p);\n \n   *expr_p = NULL;\n@@ -6458,13 +6433,13 @@ gimplify_function_tree (tree fndecl)\n       x = DECL_SAVED_TREE (fndecl);\n       append_to_statement_list (x, &TREE_OPERAND (tf, 0));\n       x = implicit_built_in_decls[BUILT_IN_PROFILE_FUNC_EXIT];\n-      x = build_function_call_expr (x, NULL);\n+      x = build_call_expr (x, 0);\n       append_to_statement_list (x, &TREE_OPERAND (tf, 1));\n \n       bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n       TREE_SIDE_EFFECTS (bind) = 1;\n       x = implicit_built_in_decls[BUILT_IN_PROFILE_FUNC_ENTER];\n-      x = build_function_call_expr (x, NULL);\n+      x = build_call_expr (x, 0);\n       append_to_statement_list (x, &BIND_EXPR_BODY (bind));\n       append_to_statement_list (tf, &BIND_EXPR_BODY (bind));\n "}, {"sha": "6d3d9e89dc6168a0fc34fb8cc2bf8f16dd78748f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -925,8 +925,8 @@ ipcp_update_callgraph (void)\n \t    if (ipcp_redirect (cs))\n \t      {\n \t\tcgraph_redirect_edge_callee (cs, orig_callee);\n-\t\tTREE_OPERAND (TREE_OPERAND\n-\t\t\t      (get_call_expr_in (cs->call_stmt), 0), 0) =\n+\t\tTREE_OPERAND (CALL_EXPR_FN (get_call_expr_in (cs->call_stmt)),\n+\t\t\t      0) =\n \t\t  orig_callee->decl;\n \t      }\n \t  }"}, {"sha": "c5643142b701d0adf895a8947a56c4be820c9709", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -419,15 +419,11 @@ void\n ipa_callsite_compute_count (struct cgraph_edge *cs)\n {\n   tree call_tree;\n-  tree arg;\n   int arg_num;\n \n   call_tree = get_call_expr_in (ipa_callsite_tree (cs));\n   gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n-  arg = TREE_OPERAND (call_tree, 1);\n-  arg_num = 0;\n-  for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n-    arg_num++;\n+  arg_num = call_expr_nargs (call_tree);\n   ipa_callsite_param_count_set (cs, arg_num);\n }\n \n@@ -445,38 +441,35 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n   struct cgraph_node *mt;\n   tree parm_decl;\n   struct function *curr_cfun;\n+  call_expr_arg_iterator iter;\n \n   if (ipa_callsite_param_count (cs) == 0)\n     return;\n   ipa_callsite_param_map_create (cs);\n   call_tree = get_call_expr_in (ipa_callsite_tree (cs));\n   gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n-  arg = TREE_OPERAND (call_tree, 1);\n   arg_num = 0;\n \n-  for (; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, call_tree)\n     {\n       /* If the formal parameter was passed as argument, we store \n          FORMAL_IPATYPE and its index in the caller as the jump function \n          of this argument.  */\n-      if ((TREE_CODE (TREE_VALUE (arg)) == SSA_NAME\n-\t   && TREE_CODE (SSA_NAME_VAR (TREE_VALUE (arg))) == PARM_DECL)\n-\t  || TREE_CODE (TREE_VALUE (arg)) == PARM_DECL)\n+      if ((TREE_CODE (arg) == SSA_NAME\n+\t   && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL)\n+\t  || TREE_CODE (arg) == PARM_DECL)\n \t{\n \t  mt = ipa_callsite_caller (cs);\n-\t  parm_decl =\n-\t    TREE_CODE (TREE_VALUE (arg)) ==\n-\t    PARM_DECL ? TREE_VALUE (arg) : SSA_NAME_VAR (TREE_VALUE (arg));\n+\t  parm_decl = TREE_CODE (arg) == PARM_DECL ? arg : SSA_NAME_VAR (arg);\n           \n \t  i = ipa_method_tree_map (mt, parm_decl);\n-\t  if (TREE_CODE (TREE_VALUE (arg)) == SSA_NAME \n-\t      && IS_VALID_TREE_MAP_INDEX (i)) \n+\t  if (TREE_CODE (arg) == SSA_NAME && IS_VALID_TREE_MAP_INDEX (i)) \n \t    {\n-              curr_cfun = DECL_STRUCT_FUNCTION (mt->decl);\n+\t      curr_cfun = DECL_STRUCT_FUNCTION (mt->decl);\n \t      if (!gimple_default_def (curr_cfun, parm_decl) \n-\t          || gimple_default_def (curr_cfun, parm_decl) != TREE_VALUE (arg))\n+\t          || gimple_default_def (curr_cfun, parm_decl) != arg)\n \t\t    ipa_method_modify_set (mt, i, true); \n-            }\n+\t    }\n \t  if (!IS_VALID_TREE_MAP_INDEX (i) || ipa_method_is_modified (mt, i))\n \t    ipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n \t  else\n@@ -488,22 +481,20 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n       /* If a constant value was passed as argument, \n          we store CONST_IPATYPE and its value as the jump function \n          of this argument.  */\n-      else if (TREE_CODE (TREE_VALUE (arg)) == INTEGER_CST\n-\t       || TREE_CODE (TREE_VALUE (arg)) == REAL_CST)\n+      else if (TREE_CODE (arg) == INTEGER_CST\n+\t       || TREE_CODE (arg) == REAL_CST)\n \t{\n \t  ipa_callsite_param_set_type (cs, arg_num, CONST_IPATYPE);\n-\t  ipa_callsite_param_set_info_type (cs, arg_num,\n-\t\t\t\t\t    TREE_VALUE (arg));\n+\t  ipa_callsite_param_set_info_type (cs, arg_num, arg);\n \t}\n       /* This is for the case of Fortran. If the address of a const_decl \n          was passed as argument then we store \n          CONST_IPATYPE_REF/CONST_IPATYPE_REF and the constant \n          value as the jump function corresponding to this argument.  */\n-      else if (TREE_CODE (TREE_VALUE (arg)) == ADDR_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (TREE_VALUE (arg), 0)) ==\n-\t       CONST_DECL)\n+      else if (TREE_CODE (arg) == ADDR_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (arg, 0)) == CONST_DECL)\n \t{\n-\t  cst_decl = TREE_OPERAND (TREE_VALUE (arg), 0);\n+\t  cst_decl = TREE_OPERAND (arg, 0);\n \t  if (TREE_CODE (DECL_INITIAL (cst_decl)) == INTEGER_CST\n \t      || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST)\n \t    {"}, {"sha": "1be8ef1a1c3791acc6e5f25d5bd31850d501e120", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -316,20 +316,15 @@ get_asm_expr_operands (funct_state local, tree stmt)\n static void\n check_call (funct_state local, tree call_expr) \n {\n-  int flags = call_expr_flags(call_expr);\n-  tree operand_list = TREE_OPERAND (call_expr, 1);\n+  int flags = call_expr_flags (call_expr);\n   tree operand;\n+  call_expr_arg_iterator iter;\n   tree callee_t = get_callee_fndecl (call_expr);\n   struct cgraph_node* callee;\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n \n-  for (operand = operand_list;\n-       operand != NULL_TREE;\n-       operand = TREE_CHAIN (operand))\n-    {\n-      tree argument = TREE_VALUE (operand);\n-      check_rhs_var (local, argument);\n-    }\n+  FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n+    check_rhs_var (local, operand);\n   \n   /* The const and pure flags are set by a variety of places in the\n      compiler (including here).  If someone has already set the flags\n@@ -452,7 +447,14 @@ scan_function (tree *tp,\n \t      case ADDR_EXPR:\n \t\tcheck_rhs_var (local, rhs);\n \t\tbreak;\n-\t      case CALL_EXPR: \n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t    break;\n+\t  case tcc_vl_exp:\n+\t    switch (TREE_CODE (rhs)) \n+\t      {\n+\t      case CALL_EXPR:\n \t\tcheck_call (local, rhs);\n \t\tbreak;\n \t      default:"}, {"sha": "af6dac7c9dbfba5ee256bfdf5bcefa9544062e1e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -436,18 +436,13 @@ static void\n check_call (ipa_reference_local_vars_info_t local, tree call_expr) \n {\n   int flags = call_expr_flags (call_expr);\n-  tree operand_list = TREE_OPERAND (call_expr, 1);\n   tree operand;\n   tree callee_t = get_callee_fndecl (call_expr);\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n+  call_expr_arg_iterator iter;\n \n-  for (operand = operand_list;\n-       operand != NULL_TREE;\n-       operand = TREE_CHAIN (operand))\n-    {\n-      tree argument = TREE_VALUE (operand);\n-      check_rhs_var (local, argument);\n-    }\n+  FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n+    check_rhs_var (local, operand);\n \n   if (callee_t)\n     {\n@@ -534,7 +529,14 @@ scan_for_static_refs (tree *tp,\n \t      case ADDR_EXPR:\n \t\tcheck_rhs_var (local, rhs);\n \t\tbreak;\n-\t      case CALL_EXPR: \n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t    break;\n+\t  case tcc_vl_exp:\n+\t    switch (TREE_CODE (rhs))\n+\t      {\n+\t      case CALL_EXPR:\n \t\tcheck_call (local, rhs);\n \t\tbreak;\n \t      default:"}, {"sha": "8c7253e6f0112119806ca48e3a6c9fad8e0f4b80", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1011,20 +1011,14 @@ static bool\n check_call (tree call_expr) \n {\n   int flags = call_expr_flags(call_expr);\n-  tree operand_list = TREE_OPERAND (call_expr, 1);\n   tree operand;\n   tree callee_t = get_callee_fndecl (call_expr);\n-  tree argument;\n   struct cgraph_node* callee;\n   enum availability avail = AVAIL_NOT_AVAILABLE;\n+  call_expr_arg_iterator iter;\n \n-  for (operand = operand_list;\n-       operand != NULL_TREE;\n-       operand = TREE_CHAIN (operand))\n-    {\n-      tree argument = TREE_VALUE (operand);\n-      check_rhs_var (argument);\n-    }\n+  FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n+    check_rhs_var (operand);\n   \n   if (callee_t)\n     {\n@@ -1037,17 +1031,16 @@ check_call (tree call_expr)\n \t parameters.  */\n       if (TYPE_ARG_TYPES (TREE_TYPE (callee_t)))\n \t{\n-\t  operand = operand_list;\n-\t  for (arg_type = TYPE_ARG_TYPES (TREE_TYPE (callee_t));\n+\t  for (arg_type = TYPE_ARG_TYPES (TREE_TYPE (callee_t)),\n+\t\t operand = first_call_expr_arg (call_expr, &iter);\n \t       arg_type && TREE_VALUE (arg_type) != void_type_node;\n-\t       arg_type = TREE_CHAIN (arg_type))\n+\t       arg_type = TREE_CHAIN (arg_type),\n+\t\t operand = next_call_expr_arg (&iter))\n \t    {\n \t      if (operand)\n \t\t{\n-\t\t  argument = TREE_VALUE (operand);\n \t\t  last_arg_type = TREE_VALUE(arg_type);\n-\t\t  check_cast (last_arg_type, argument);\n-\t\t  operand = TREE_CHAIN (operand);\n+\t\t  check_cast (last_arg_type, operand);\n \t\t}\n \t      else \n \t\t/* The code reaches here for some unfortunate\n@@ -1061,17 +1054,16 @@ check_call (tree call_expr)\n \t  /* FIXME - According to Geoff Keating, we should never\n \t     have to do this; the front ends should always process\n \t     the arg list from the TYPE_ARG_LIST. */\n-\t  operand = operand_list;\n-\t  for (arg_type = DECL_ARGUMENTS (callee_t); \n+\t  for (arg_type = DECL_ARGUMENTS (callee_t),\n+\t\t operand = first_call_expr_arg (call_expr, &iter);\n \t       arg_type;\n-\t       arg_type = TREE_CHAIN (arg_type))\n+\t       arg_type = TREE_CHAIN (arg_type),\n+\t\t operand = next_call_expr_arg (&iter))\n \t    {\n \t      if (operand)\n \t\t{\n-\t\t  argument = TREE_VALUE (operand);\n \t\t  last_arg_type = TREE_TYPE(arg_type);\n-\t\t  check_cast (last_arg_type, argument);\n-\t\t  operand = TREE_CHAIN (operand);\n+\t\t  check_cast (last_arg_type, operand);\n \t\t} \n \t      else \n \t\t/* The code reaches here for some unfortunate\n@@ -1086,19 +1078,18 @@ check_call (tree call_expr)\n       arg_type = last_arg_type;\n       for (;\n \t   operand != NULL_TREE;\n-\t   operand = TREE_CHAIN (operand))\n+\t   operand = next_call_expr_arg (&iter))\n \t{\n-\t  argument = TREE_VALUE (operand);\n \t  if (arg_type)\n-\t    check_cast (arg_type, argument);\n+\t    check_cast (arg_type, operand);\n \t  else \n \t    {\n \t      /* The code reaches here for some unfortunate\n \t\t builtin functions that do not have a list of\n \t\t argument types.  Most of these functions have\n \t\t been marked as having their parameters not\n \t\t escape, but for the rest, the type is doomed.  */\n-\t      tree type = get_canon_type (TREE_TYPE (argument), false, false);\n+\t      tree type = get_canon_type (TREE_TYPE (operand), false, false);\n \t      mark_interesting_type (type, FULL_ESCAPE);\n \t    }\n \t}\n@@ -1114,12 +1105,9 @@ check_call (tree call_expr)\n     {\n       /* If this is a direct call to an external function, mark all of\n \t the parameter and return types.  */\n-      for (operand = operand_list;\n-\t   operand != NULL_TREE;\n-\t   operand = TREE_CHAIN (operand))\n+      FOR_EACH_CALL_EXPR_ARG (operand, iter, call_expr)\n \t{\n-\t  tree type = \n-\t    get_canon_type (TREE_TYPE (TREE_VALUE (operand)), false, false);\n+\t  tree type = get_canon_type (TREE_TYPE (operand), false, false);\n \t  mark_interesting_type (type, EXPOSED_PARAMETER);\n     }\n \t  \n@@ -1257,7 +1245,14 @@ scan_for_refs (tree *tp, int *walk_subtrees, void *data)\n \t\tlook_for_casts (lhs, TREE_OPERAND (rhs, 0));\n \t\tcheck_rhs_var (rhs);\n \t\tbreak;\n-\t      case CALL_EXPR: \n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t    break;\n+\t  case tcc_vl_exp:\n+\t    switch (TREE_CODE (rhs))\n+\t      {\n+\t      case CALL_EXPR:\n \t\t/* If this is a call to malloc, squirrel away the\n \t\t   result so we do mark the resulting cast as being\n \t\t   bad.  */"}, {"sha": "39fe758bf484eb9235f7f22f00e68957dec945e4", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1,3 +1,70 @@\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* java-tree.h (BUILD_MONITOR_ENTER): Use build_call_nary instead\n+\tof build3.\n+\t(BUILD_MONITOR_EXIT): Likewise.\n+\n+\t* java-gimplify.c (java_gimplify_component_ref): Use build_call_expr.\n+\t(java_gimplify_modify_expr): Likewise.\n+\n+\t* class.c (cache_this_class_ref): Use build_call_expr.\n+\t(build_static_field_ref): Likewise.\n+\t(emit_indirect_register_classes): Likewise.\n+\t(emit_register_classes): Likewise.\n+\n+\t* resource.c (write_resource_constructor): Use build_call_expr.\n+\n+\t* builtins.c (builtin_creator_function): Change interpretation of\n+\tthe second parameter to be the whole CALL_EXPR instead of the arglist.\n+\t(max_builtin): Tweak parameter list.  Use new CALL_EXPR accessors.\n+\t(min_builtin): Likewise.\n+\t(abs_builtin): Likewise.\n+\t(java_build_function_call_expr): Likewise.\n+\t(convert_real): Likewise.\n+\t(UNMARSHAL3): Likewise.\n+\t(UNMARSHAL4): Likewise.\n+\t(UNMARSHAL5): Likewise.\n+\t(build_arglist_for_builtin): Delete.  Fix callers to use\n+\tbuild_call_expr instead.\n+\t(putObject_builtin): Tweak parameter list.  Use new CALL_EXPR\n+\taccessors.\n+\t(compareAndSwapInt_builtin): Likewise.\n+\t(compareAndSwapLong_builtin): Likewise.\n+\t(compareAndSwapObject_builtin): Likewise.\n+\t(putVolatile_builtin): Likewise.\n+\t(getVolatile_builtin): Likewise.\n+\t(VMSupportsCS8_builtin): Likewise.\n+\t(check_for_builtin): Pass entire CALL_EXPR to builtin expander\n+\tinstead of arglist.\n+\n+\t* expr.c (build_java_athrow): Use build_call_nary instead of build3.\n+\t(build_java_throw_out_of_bounds_exception): Likewise.\n+\t(java_check_reference): Likewise.\n+\t(build_java_arraystore_check): Likewise.\n+\t(build_newarray): Likewise.\n+\t(build_anewarray): Likewise.\n+\t(expand_java_multinewarray): Use build_call_list instead of build3.\n+\t(build_java_monitor): Use build_call_nary instead of build3.\n+\t(java_create_object): Likewise.\n+\t(expand_java_NEW): Likewise.\n+\t(build_instanceof): Likewise.\n+\t(expand_java_CHECKCAST): Likewise.\n+\t(build_java_soft_divmod): Likewise.\n+\t(build_java_binop): Likewise.\n+\t(build_field_ref): Likewise.\n+\t(build_class_init): Likewise.\n+\t(rewrite_arglist_getcaller): Use build_call_expr.\n+\t(build_invokeinterface):  Use build_call_nary instead of build3.\n+\t(expand_invoke): Use build_call_list instead of build3.\n+\t(build_jni_stub): Use build_call_nary, build_call_list, or\n+\tbuild_call_expr instead\tof build3.\n+\t(expand_java_field_op): Use build_call_expr instead of build3.\n+\t(force_evaluation_order): Use new CALL_EXPR accessors.\n+\n+\t* lang.c (java_get_callee_fndecl): Use new CALL_EXPR accessors.\n+\n 2007-02-15  David Daney  <ddaney@avtrex.com>\n \n \t* Make-lang.in (JAVA_MANFILES): Add doc/gc-analyze.1."}, {"sha": "cfbab665192dfaafca4a9ebe64ce2189fa4712a0", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 89, "deletions": 110, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -60,7 +60,8 @@ static tree VMSupportsCS8_builtin (tree, tree);\n /* Functions of this type are used to inline a given call.  Such a\n    function should either return an expression, if the call is to be\n    inlined, or NULL_TREE if a real call should be emitted.  Arguments\n-   are method return type and arguments to call.  */\n+   are method return type and the original CALL_EXPR containing the\n+   arguments to the call.  */\n typedef tree builtin_creator_function (tree, tree);\n \n /* Hold a char*, before initialization, or a tree, after\n@@ -130,50 +131,73 @@ static GTY(()) struct builtin_record java_builtins[] =\n /* Internal functions which implement various builtin conversions.  */\n \n static tree\n-max_builtin (tree method_return_type, tree method_arguments)\n+max_builtin (tree method_return_type, tree orig_call)\n {\n   /* MAX_EXPR does not handle -0.0 in the Java style.  */\n   if (TREE_CODE (method_return_type) == REAL_TYPE)\n     return NULL_TREE;\n   return fold_build2 (MAX_EXPR, method_return_type,\n-\t\t      TREE_VALUE (method_arguments),\n-\t\t      TREE_VALUE (TREE_CHAIN (method_arguments)));\n+\t\t      CALL_EXPR_ARG (orig_call, 0),\n+\t\t      CALL_EXPR_ARG (orig_call, 1));\n }\n \n static tree\n-min_builtin (tree method_return_type, tree method_arguments)\n+min_builtin (tree method_return_type, tree orig_call)\n {\n   /* MIN_EXPR does not handle -0.0 in the Java style.  */\n   if (TREE_CODE (method_return_type) == REAL_TYPE)\n     return NULL_TREE;\n   return fold_build2 (MIN_EXPR, method_return_type,\n-\t\t      TREE_VALUE (method_arguments),\n-\t\t      TREE_VALUE (TREE_CHAIN (method_arguments)));\n+\t\t      CALL_EXPR_ARG (orig_call, 0),\n+\t\t      CALL_EXPR_ARG (orig_call, 1));\n }\n \n static tree\n-abs_builtin (tree method_return_type, tree method_arguments)\n+abs_builtin (tree method_return_type, tree orig_call)\n {\n   return fold_build1 (ABS_EXPR, method_return_type,\n-\t\t      TREE_VALUE (method_arguments));\n+\t\t      CALL_EXPR_ARG (orig_call, 0));\n }\n \n-/* Mostly copied from ../builtins.c.  */\n+/* Construct a new call to FN using the arguments from ORIG_CALL.  */\n+\n static tree\n-java_build_function_call_expr (tree fn, tree arglist)\n+java_build_function_call_expr (tree fn, tree orig_call)\n {\n-  tree call_expr;\n-\n-  call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  return fold_build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t      call_expr, arglist, NULL_TREE);\n+  int nargs = call_expr_nargs (orig_call);\n+  switch (nargs)\n+    {\n+      /* Although we could handle the 0-3 argument cases using the general\n+\t logic in the default case, splitting them out permits folding to\n+\t be performed without constructing a temporary CALL_EXPR.  */\n+    case 0:\n+      return build_call_expr (fn, 0);\n+    case 1:\n+      return build_call_expr (fn, 1, CALL_EXPR_ARG (orig_call, 0));\n+    case 2:\n+      return build_call_expr (fn, 2,\n+\t\t\t      CALL_EXPR_ARG (orig_call, 0),\n+\t\t\t      CALL_EXPR_ARG (orig_call, 1));\n+    case 3:\n+      return build_call_expr (fn, 3,\n+\t\t\t      CALL_EXPR_ARG (orig_call, 0),\n+\t\t\t      CALL_EXPR_ARG (orig_call, 1),\n+\t\t\t      CALL_EXPR_ARG (orig_call, 2));\n+    default:\n+      {\n+\ttree fntype = TREE_TYPE (fn);\n+\tfn = build1 (ADDR_EXPR, build_pointer_type (fntype), fn);\n+\treturn fold (build_call_array (TREE_TYPE (fntype),\n+\t\t\t\t       fn, nargs, CALL_EXPR_ARGP (orig_call)));\n+      }\n+    }\n }\n \n static tree\n-convert_real (tree method_return_type, tree method_arguments)\n+convert_real (tree method_return_type, tree orig_call)\n {\n   return build1 (VIEW_CONVERT_EXPR, method_return_type,\n-\t\t TREE_VALUE (method_arguments));\n+\t\t CALL_EXPR_ARG (orig_call, 0));\n }\n \n \f\n@@ -191,76 +215,51 @@ convert_real (tree method_return_type, tree method_arguments)\n */\n \n \n-/* Macros to unmarshal arguments from a TREE_LIST into a few\n+/* Macros to unmarshal arguments from a CALL_EXPR into a few\n    variables.  We also convert the offset arg from a long to an\n    integer that is the same size as a pointer.  */\n \n-#define UNMARSHAL3(METHOD_ARGUMENTS)\t\t\t\t\t\\\n+#define UNMARSHAL3(METHOD_CALL)\t\t\t\t\t\\\n tree this_arg, obj_arg, offset_arg;\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  tree chain = METHOD_ARGUMENTS;\t\t\t\t\t\\\n-  this_arg = TREE_VALUE (chain);\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n-  obj_arg = TREE_VALUE (chain);\t\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n+  tree orig_method_call = METHOD_CALL;\t\t\t\t\t\\\n+  this_arg = CALL_EXPR_ARG (orig_method_call, 0);\t\t\t\\\n+  obj_arg = CALL_EXPR_ARG (orig_method_call, 1);\t\t\t\\\n   offset_arg = fold_convert (java_type_for_size (POINTER_SIZE, 0),\t\\\n-\t\t\t     TREE_VALUE (chain));\t\t\t\\\n+\t\t\t     CALL_EXPR_ARG (orig_method_call, 2));\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-#define UNMARSHAL4(METHOD_ARGUMENTS)\t\t\t\t\t\\\n+#define UNMARSHAL4(METHOD_CALL)\t\t\t\t\t\\\n tree value_type, this_arg, obj_arg, offset_arg, value_arg;\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  tree chain = METHOD_ARGUMENTS;\t\t\t\t\t\\\n-  this_arg = TREE_VALUE (chain);\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n-  obj_arg = TREE_VALUE (chain);\t\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n+  tree orig_method_call = METHOD_CALL;\t\t\t\t\t\\\n+  this_arg = CALL_EXPR_ARG (orig_method_call, 0);\t\t\t\\\n+  obj_arg = CALL_EXPR_ARG (orig_method_call, 1);\t\t\t\\\n   offset_arg = fold_convert (java_type_for_size (POINTER_SIZE, 0),\t\\\n-\t\t\t     TREE_VALUE (chain));\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n-  value_arg = TREE_VALUE (chain);\t\t\t\t\t\\\n+\t\t\t     CALL_EXPR_ARG (orig_method_call, 2));\t\\\n+  value_arg = CALL_EXPR_ARG (orig_method_call, 3);\t\t\t\\\n   value_type = TREE_TYPE (value_arg);\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-#define UNMARSHAL5(METHOD_ARGUMENTS)\t\t\t\t\t\\\n+#define UNMARSHAL5(METHOD_CALL)\t\t\t\t\t\\\n tree value_type, this_arg, obj_arg, offset_arg, expected_arg, value_arg; \\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  tree chain = METHOD_ARGUMENTS;\t\t\t\t\t\\\n-  this_arg = TREE_VALUE (chain);\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n-  obj_arg = TREE_VALUE (chain);\t\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n+  tree orig_method_call = METHOD_CALL;\t\t\t\t\t\\\n+  this_arg = CALL_EXPR_ARG (orig_method_call, 0);\t\t\t\\\n+  obj_arg = CALL_EXPR_ARG (orig_method_call, 1);\t\t\t\\\n   offset_arg = fold_convert (java_type_for_size (POINTER_SIZE, 0),\t\\\n-\t\t\t     TREE_VALUE (chain));\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n-  expected_arg = TREE_VALUE (chain);\t\t\t\t\t\\\n-  chain = TREE_CHAIN (chain);\t\t\t\t\t\t\\\n-  value_arg = TREE_VALUE (chain);\t\t\t\t\t\\\n+\t\t\t     CALL_EXPR_ARG (orig_method_call, 2));\t\\\n+  expected_arg = CALL_EXPR_ARG (orig_method_call, 3);\t\t\t\\\n+  value_arg = CALL_EXPR_ARG (orig_method_call, 4);\t\t\t\\\n   value_type = TREE_TYPE (value_arg);\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-/* Construct an arglist from a call.  */\n-\n-static tree\n-build_arglist_for_builtin (tree arg, ...)\n-{\n-  va_list ap;\n-  tree nextarg;\n-  tree newarglist = build_tree_list (NULL_TREE, arg);\n-\n-  va_start(ap, arg);\n-  while ((nextarg = va_arg(ap, tree)))\n-    newarglist = tree_cons (NULL_TREE, nextarg, newarglist);\n-\n-  return nreverse (newarglist);\n-}\n-\n /* Add an address to an offset, forming a sum.  */\n \n static tree\n@@ -286,10 +285,10 @@ build_check_this (tree stmt, tree this_arg)\n \n static tree\n putObject_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t   tree method_arguments)\n+\t\t   tree orig_call)\n {\n   tree addr, stmt;\n-  UNMARSHAL4 (method_arguments);\n+  UNMARSHAL4 (orig_call);\n \n   addr = build_addr_sum (value_type, obj_arg, offset_arg);\n   stmt = fold_build2 (MODIFY_EXPR, value_type,\n@@ -302,22 +301,18 @@ putObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \n static tree\n compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n-\t\t\t   tree method_arguments)\n+\t\t\t   tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (int_type_node);\n   if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n       || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n     {\n-      tree newarglist, addr, stmt;\n-      UNMARSHAL5 (method_arguments);\n+      tree addr, stmt;\n+      UNMARSHAL5 (orig_call);\n \n       addr = build_addr_sum (int_type_node, obj_arg, offset_arg);\n-\n-      newarglist \n-\t= build_arglist_for_builtin (addr, expected_arg, value_arg, NULL_TREE);\n-      stmt = (build_function_call_expr\n-\t      (built_in_decls[BUILT_IN_BOOL_COMPARE_AND_SWAP_4],\n-\t       newarglist));\n+      stmt = build_call_expr (built_in_decls[BUILT_IN_BOOL_COMPARE_AND_SWAP_4],\n+\t\t\t      3, addr, expected_arg, value_arg);\n \n       return build_check_this (stmt, this_arg);\n     }\n@@ -326,50 +321,42 @@ compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \n static tree\n compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n-\t\t\t    tree method_arguments)\n+\t\t\t    tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n   if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n       || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n     {\n-      tree newarglist, addr, stmt;\n-      UNMARSHAL5 (method_arguments);\n+      tree addr, stmt;\n+      UNMARSHAL5 (orig_call);\n \n       addr = build_addr_sum (long_type_node, obj_arg, offset_arg);\n-\n-      newarglist \n-\t= build_arglist_for_builtin (addr, expected_arg, value_arg, NULL_TREE);\n-      stmt = (build_function_call_expr\n-\t      (built_in_decls[BUILT_IN_BOOL_COMPARE_AND_SWAP_8],\n-\t       newarglist));\n+      stmt = build_call_expr (built_in_decls[BUILT_IN_BOOL_COMPARE_AND_SWAP_8],\n+\t\t\t      3, addr, expected_arg, value_arg);\n \n       return build_check_this (stmt, this_arg);\n     }\n   return NULL_TREE;\n }\n static tree\n compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t\t      tree method_arguments)\n+\t\t\t      tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (ptr_type_node);\n   if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n       || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n   {\n-    tree newarglist, addr, stmt;\n+    tree addr, stmt;\n     int builtin;\n \n-    UNMARSHAL5 (method_arguments);\n+    UNMARSHAL5 (orig_call);\n     builtin = (POINTER_SIZE == 32 \n \t       ? BUILT_IN_BOOL_COMPARE_AND_SWAP_4 \n \t       : BUILT_IN_BOOL_COMPARE_AND_SWAP_8);\n \n     addr = build_addr_sum (value_type, obj_arg, offset_arg);\n-\n-    newarglist \n-      = build_arglist_for_builtin (addr, expected_arg, value_arg, NULL_TREE);\n-    stmt = (build_function_call_expr\n-\t    (built_in_decls[builtin],\n-\t     newarglist));\n+    stmt = build_call_expr (built_in_decls[builtin],\n+\t\t\t    3, addr, expected_arg, value_arg);\n \n     return build_check_this (stmt, this_arg);\n   }\n@@ -378,20 +365,17 @@ compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \n static tree\n putVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t     tree method_arguments)\n+\t\t     tree orig_call)\n {\n-  tree newarglist, addr, stmt, modify_stmt;\n-  UNMARSHAL4 (method_arguments);\n+  tree addr, stmt, modify_stmt;\n+  UNMARSHAL4 (orig_call);\n   \n   addr = build_addr_sum (value_type, obj_arg, offset_arg);\n   addr \n     = fold_convert (build_pointer_type (build_type_variant (value_type, 0, 1)),\n \t\t    addr);\n   \n-  newarglist = NULL_TREE;\n-  stmt = (build_function_call_expr\n-\t  (built_in_decls[BUILT_IN_SYNCHRONIZE],\n-\t   newarglist));\n+  stmt = build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n   modify_stmt = fold_build2 (MODIFY_EXPR, value_type,\n \t\t\t     build_java_indirect_ref (value_type, addr,\n \t\t\t\t\t\t      flag_check_references),\n@@ -404,20 +388,17 @@ putVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \n static tree\n getVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t     tree method_arguments)\n+\t\t     tree orig_call)\n {\n-  tree newarglist, addr, stmt, modify_stmt, tmp;\n-  UNMARSHAL3 (method_arguments);\n+  tree addr, stmt, modify_stmt, tmp;\n+  UNMARSHAL3 (orig_call);\n   \n   addr = build_addr_sum (method_return_type, obj_arg, offset_arg);\n   addr \n     = fold_convert (build_pointer_type (build_type_variant \n \t\t\t\t\t(method_return_type, 0, 1)), addr);\n   \n-  newarglist = NULL_TREE;\n-  stmt = (build_function_call_expr\n-\t  (built_in_decls[BUILT_IN_SYNCHRONIZE],\n-\t   newarglist));\n+  stmt = build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n   \n   tmp = build_decl (VAR_DECL, NULL, method_return_type);\n   DECL_IGNORED_P (tmp) = 1;\n@@ -437,7 +418,7 @@ getVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \n static tree\n VMSupportsCS8_builtin (tree method_return_type, \n-\t\t       tree method_arguments ATTRIBUTE_UNUSED)\n+\t\t       tree orig_call ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n   gcc_assert (method_return_type == boolean_type_node);\n@@ -596,7 +577,6 @@ check_for_builtin (tree method, tree call)\n   if (optimize && TREE_CODE (call) == CALL_EXPR)\n     {\n       int i;\n-      tree method_arguments = TREE_OPERAND (call, 1);\n       tree method_class = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));\n       tree method_name = DECL_NAME (method);\n       tree method_return_type = TREE_TYPE (TREE_TYPE (method));\n@@ -611,8 +591,7 @@ check_for_builtin (tree method, tree call)\n \t      if (java_builtins[i].creator != NULL)\n \t\t{\n \t\t  tree result\n-\t\t    = (*java_builtins[i].creator) (method_return_type,\n-\t\t\t\t\t\t   method_arguments);\n+\t\t    = (*java_builtins[i].creator) (method_return_type, call);\n \t\t  return result == NULL_TREE ? call : result;\n \t\t}\n \n@@ -623,7 +602,7 @@ check_for_builtin (tree method, tree call)\n \t      fn = built_in_decls[java_builtins[i].builtin_code];\n \t      if (fn == NULL_TREE)\n \t\treturn call;\n-\t      return java_build_function_call_expr (fn, method_arguments);\n+\t      return java_build_function_call_expr (fn, call);\n \t    }\n \t}\n     }"}, {"sha": "85cdeb49e1e4d793ab5fe90cbeb6b123d75df6c5", "filename": "gcc/java/class.c", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1039,10 +1039,8 @@ cache_this_class_ref (tree fndecl)\n       && ! DECL_CLINIT_P (fndecl)\n       && ! CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (fndecl))))\n     {\n-      tree init = build3 (CALL_EXPR, void_type_node,\n-\t\t\t  build_address_of (soft_initclass_node),\n-\t\t\t  build_tree_list (NULL_TREE, this_classdollar),\n-\t\t\t  NULL_TREE);\n+      tree init = build_call_expr (soft_initclass_node, 1,\n+\t\t\t\t   this_classdollar);\n       java_add_stmt (init);\n     }\n }\n@@ -1177,20 +1175,16 @@ build_static_field_ref (tree fdecl)\n \n       int cpool_index = alloc_constant_fieldref (output_class, fdecl);\n       tree cache_entry = build_fieldref_cache_entry (cpool_index, fdecl);\n-      tree test \n-\t= build3 (CALL_EXPR, boolean_type_node, \n-\t\t  build_address_of (built_in_decls[BUILT_IN_EXPECT]),\n-\t\t  tree_cons (NULL_TREE, build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t\t\tcache_entry, null_pointer_node),\n-\t\t\t     build_tree_list (NULL_TREE, boolean_false_node)),\n-\t\t  NULL_TREE);\n+      tree test\n+        = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2,\n+\t\t\t   build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t   cache_entry, null_pointer_node),\n+\t\t\t   boolean_false_node);\n       tree cpool_index_cst = build_int_cst (NULL_TREE, cpool_index);\n       tree init\n-\t= build3 (CALL_EXPR, ptr_type_node,\n-\t\t  build_address_of (soft_resolvepoolentry_node),\n-\t\t  tree_cons (NULL_TREE, build_class_ref (output_class),\n-\t\t\t     build_tree_list (NULL_TREE, cpool_index_cst)),\n-\t\t  NULL_TREE);\n+\t= build_call_expr (soft_resolvepoolentry_node, 2,\n+\t\t\t   build_class_ref (output_class),\n+\t\t\t   cpool_index_cst);\n       init = build2 (MODIFY_EXPR, ptr_type_node, cache_entry, init);\n       init = build3 (COND_EXPR, ptr_type_node, test, init, cache_entry);\n       init = fold_convert (build_pointer_type (TREE_TYPE (fdecl)), init);\n@@ -2693,8 +2687,7 @@ emit_indirect_register_classes (tree *list_p)\n   TREE_PUBLIC (t) = 1;\n   DECL_EXTERNAL (t) = 1;\n   register_class_fn = t;\n-  t = tree_cons (NULL, reg_class_list, NULL);\n-  t = build_function_call_expr (register_class_fn, t);\n+  t = build_call_expr (register_class_fn, 1, reg_class_list);\n   append_to_statement_list (t, list_p);\n }\n \n@@ -2759,8 +2752,7 @@ emit_register_classes (tree *list_p)\n       for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n \t{\n \t  t = build_fold_addr_expr (klass);\n-\t  t = tree_cons (NULL, t, NULL);\n-\t  t = build_function_call_expr (register_class_fn, t);\n+\t  t = build_call_expr (register_class_fn, 1, t);\n \t  append_to_statement_list (t, list_p);\n \t}\n     }"}, {"sha": "46300efd07a50411bf7358115928c3900086ee77", "filename": "gcc/java/expr.c", "status": "modified", "additions": 110, "deletions": 160, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -716,11 +716,9 @@ build_java_athrow (tree node)\n {\n   tree call;\n \n-  call = build3 (CALL_EXPR,\n-\t\t void_type_node,\n-\t\t build_address_of (throw_node),\n-\t\t build_tree_list (NULL_TREE, node),\n-\t\t NULL_TREE);\n+  call = build_call_nary (void_type_node,\n+\t\t\t  build_address_of (throw_node),\n+\t\t\t  1, node);\n   TREE_SIDE_EFFECTS (call) = 1;\n   java_add_stmt (call);\n   java_stack_pop (stack_pointer);\n@@ -799,9 +797,9 @@ encode_newarray_type (tree type)\n static tree\n build_java_throw_out_of_bounds_exception (tree index)\n {\n-  tree node = build3 (CALL_EXPR, int_type_node,\n-\t\t      build_address_of (soft_badarrayindex_node), \n-\t\t      build_tree_list (NULL_TREE, index), NULL_TREE);\n+  tree node = build_call_nary (int_type_node,\n+\t\t\t       build_address_of (soft_badarrayindex_node),\n+\t\t\t       1, index);\n   TREE_SIDE_EFFECTS (node) = 1;\t/* Allows expansion within ANDIF */\n   return (node);\n }\n@@ -850,9 +848,9 @@ java_check_reference (tree expr, int check)\n       expr = build3 (COND_EXPR, TREE_TYPE (expr),\n \t\t     build2 (EQ_EXPR, boolean_type_node,\n \t\t\t     expr, null_pointer_node),\n-\t\t     build3 (CALL_EXPR, void_type_node, \n-\t\t\t     build_address_of (soft_nullpointer_node),\n-\t\t\t     NULL_TREE, NULL_TREE),\n+\t\t     build_call_nary (void_type_node, \n+\t\t\t\t      build_address_of (soft_nullpointer_node),\n+\t\t\t\t      0),\n \t\t     expr);\n     }\n \n@@ -1014,11 +1012,9 @@ build_java_arraystore_check (tree array, tree object)\n     }\n \n   /* Build an invocation of _Jv_CheckArrayStore */\n-  check = build3 (CALL_EXPR, void_type_node,\n-\t\t  build_address_of (soft_checkarraystore_node),\n-\t\t  tree_cons (NULL_TREE, array,\n-\t\t\t     build_tree_list (NULL_TREE, object)),\n-\t\t  NULL_TREE);\n+  check = build_call_nary (void_type_node,\n+\t\t\t   build_address_of (soft_checkarraystore_node),\n+\t\t\t   2, array, object);\n   TREE_SIDE_EFFECTS (check) = 1;\n \n   return check;\n@@ -1060,12 +1056,9 @@ build_newarray (int atype_value, tree length)\n      some work.  */\n   type_arg = build_class_ref (prim_type);\n \n-  return build3 (CALL_EXPR, promote_type (type),\n-\t\t build_address_of (soft_newarray_node),\n-\t\t tree_cons (NULL_TREE, \n-\t\t\t    type_arg,\n-\t\t\t    build_tree_list (NULL_TREE, length)),\n-\t\t NULL_TREE);\n+  return build_call_nary (promote_type (type),\n+\t\t\t  build_address_of (soft_newarray_node),\n+\t\t\t  2, type_arg, length);\n }\n \n /* Generates anewarray from a given CLASS_TYPE. Gets from the stack the size\n@@ -1079,13 +1072,12 @@ build_anewarray (tree class_type, tree length)\n \t\t\t     host_integerp (length, 0)\n \t\t\t     ? tree_low_cst (length, 0) : -1);\n \n-  return build3 (CALL_EXPR, promote_type (type),\n-\t\t build_address_of (soft_anewarray_node),\n-\t\t tree_cons (NULL_TREE, length,\n-\t\t\t    tree_cons (NULL_TREE, build_class_ref (class_type),\n-\t\t\t\t       build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\tnull_pointer_node))),\n-\t\t NULL_TREE);\n+  return build_call_nary (promote_type (type),\n+\t\t\t  build_address_of (soft_anewarray_node),\n+\t\t\t  3,\n+\t\t\t  length,\n+\t\t\t  build_class_ref (class_type),\n+\t\t\t  null_pointer_node);\n }\n \n /* Return a node the evaluates 'new TYPE[LENGTH]'. */\n@@ -1112,14 +1104,15 @@ expand_java_multianewarray (tree class_type, int ndim)\n   for( i = 0; i < ndim; i++ )\n     args = tree_cons (NULL_TREE, pop_value (int_type_node), args);\n \n-  push_value (build3 (CALL_EXPR,\n-\t\t      promote_type (class_type),\n-\t\t      build_address_of (soft_multianewarray_node),\n-\t\t      tree_cons (NULL_TREE, build_class_ref (class_type),\n-\t\t\t\t tree_cons (NULL_TREE, \n-\t\t\t\t\t    build_int_cst (NULL_TREE, ndim),\n-\t\t\t\t\t    args)),\n-\t\t      NULL_TREE));\n+  args = tree_cons (NULL_TREE,\n+\t\t    build_class_ref (class_type),\n+\t\t    tree_cons (NULL_TREE, \n+\t\t\t       build_int_cst (NULL_TREE, ndim),\n+\t\t\t       args));\n+\n+  push_value (build_call_list (promote_type (class_type),\n+\t\t\t       build_address_of (soft_multianewarray_node),\n+\t\t\t       args));\n }\n \n /*  ARRAY[INDEX] <- RHS. build_java_check_indexed_type makes sure that\n@@ -1246,11 +1239,9 @@ expand_java_array_length (void)\n static tree\n build_java_monitor (tree call, tree object)\n {\n-  return build3 (CALL_EXPR,\n-\t\t void_type_node,\n-\t\t build_address_of (call),\n-\t\t build_tree_list (NULL_TREE, object),\n-\t\t NULL_TREE);\n+  return build_call_nary (void_type_node,\n+\t\t\t  build_address_of (call),\n+\t\t\t  1, object);\n }\n \n /* Emit code for one of the PUSHC instructions. */\n@@ -1347,10 +1338,9 @@ java_create_object (tree type)\n \t\t     ? alloc_object_node\n \t\t     : alloc_no_finalizer_node);\n   \n-  return build3 (CALL_EXPR, promote_type (type),\n-\t\t build_address_of (alloc_node),\n-\t\t build_tree_list (NULL_TREE, build_class_ref (type)),\n-\t\t NULL_TREE);\n+  return build_call_nary (promote_type (type),\n+\t\t\t  build_address_of (alloc_node),\n+\t\t\t  1, build_class_ref (type));\n }\n \n static void\n@@ -1363,10 +1353,9 @@ expand_java_NEW (tree type)\n   if (! CLASS_LOADED_P (type))\n     load_class (type, 1);\n   safe_layout_class (type);\n-  push_value (build3 (CALL_EXPR, promote_type (type),\n-\t\t      build_address_of (alloc_node),\n-\t\t      build_tree_list (NULL_TREE, build_class_ref (type)),\n-\t\t      NULL_TREE));\n+  push_value (build_call_nary (promote_type (type),\n+\t\t\t       build_address_of (alloc_node),\n+\t\t\t       1, build_class_ref (type)));\n }\n \n /* This returns an expression which will extract the class of an\n@@ -1445,12 +1434,9 @@ build_instanceof (tree value, tree type)\n     }\n   else\n     {\n-      expr = build3 (CALL_EXPR, itype,\n-\t\t     build_address_of (soft_instanceof_node),\n-\t\t     tree_cons (NULL_TREE, value,\n-\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t build_class_ref (type))),\n-\t\t     NULL_TREE);\n+      expr = build_call_nary (itype,\n+\t\t\t      build_address_of (soft_instanceof_node),\n+\t\t\t      2, value, build_class_ref (type));\n     }\n   TREE_SIDE_EFFECTS (expr) = TREE_SIDE_EFFECTS (value);\n   return expr;\n@@ -1468,11 +1454,9 @@ static void\n expand_java_CHECKCAST (tree type)\n {\n   tree value = pop_value (ptr_type_node);\n-  value = build3 (CALL_EXPR, promote_type (type),\n-\t\t  build_address_of (soft_checkcast_node),\n-\t\t  tree_cons (NULL_TREE, build_class_ref (type),\n-\t\t\t     build_tree_list (NULL_TREE, value)),\n-\t\t  NULL_TREE);\n+  value = build_call_nary (promote_type (type),\n+\t\t\t   build_address_of (soft_checkcast_node),\n+\t\t\t   2, build_class_ref (type), value);\n   push_value (value);\n }\n \n@@ -1527,12 +1511,7 @@ build_java_soft_divmod (enum tree_code op, tree type, tree op1, tree op2)\n     }\n \n   gcc_assert (call);\n-  call = build3 (CALL_EXPR, type,\n-\t\t build_address_of (call),\n-\t\t tree_cons (NULL_TREE, arg1,\n-\t\t\t    build_tree_list (NULL_TREE, arg2)),\n-\t\t NULL_TREE);\n-\t  \n+  call = build_call_nary (type, build_address_of (call), 2, arg1, arg2);\n   return call;\n }\n \n@@ -1595,11 +1574,9 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n \t      arg1 = convert (double_type_node, arg1);\n \t      arg2 = convert (double_type_node, arg2);\n \t    }\n-\t  call = build3 (CALL_EXPR, double_type_node,\n-\t\t\t build_address_of (soft_fmod_node),\n-\t\t\t tree_cons (NULL_TREE, arg1,\n-\t\t\t\t    build_tree_list (NULL_TREE, arg2)),\n-\t\t\t NULL_TREE);\n+\t  call = build_call_nary (double_type_node,\n+\t\t\t\t  build_address_of (soft_fmod_node),\n+\t\t\t\t  2, arg1, arg2);\n \t  if (type != double_type_node)\n \t    call = convert (type, call);\n \t  return call;\n@@ -1759,10 +1736,9 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \t      = build3 (COND_EXPR, TREE_TYPE (field_offset),\n \t\t\tbuild2 (EQ_EXPR, boolean_type_node,\n \t\t\t\tfield_offset, integer_zero_node),\n-\t\t\tbuild3 (CALL_EXPR, void_type_node, \n-\t\t\t\tbuild_address_of (soft_nosuchfield_node),\n-\t\t\t\tbuild_tree_list (NULL_TREE, otable_index), \n-\t\t\t\tNULL_TREE),\n+\t\t\tbuild_call_nary (void_type_node, \n+\t\t\t\t\t build_address_of (soft_nosuchfield_node),\n+\t\t\t\t\t 1, otable_index),\n \t\t\tfield_offset);\n \t  \n \t  field_offset = fold (convert (sizetype, field_offset));\n@@ -1998,10 +1974,9 @@ build_class_init (tree clas, tree expr)\n \n   if (always_initialize_class_p)\n     {\n-      init = build3 (CALL_EXPR, void_type_node,\n-\t\t     build_address_of (soft_initclass_node),\n-\t\t     build_tree_list (NULL_TREE, build_class_ref (clas)),\n-\t\t     NULL_TREE);\n+      init = build_call_nary (void_type_node,\n+\t\t\t      build_address_of (soft_initclass_node),\n+\t\t\t      1, build_class_ref (clas));\n       TREE_SIDE_EFFECTS (init) = 1;\n     }\n   else\n@@ -2031,10 +2006,9 @@ build_class_init (tree clas, tree expr)\n \t  *init_test_decl = decl;\n \t}\n \n-      init = build3 (CALL_EXPR, void_type_node,\n-\t\t     build_address_of (soft_initclass_node),\n-\t\t     build_tree_list (NULL_TREE, build_class_ref (clas)),\n-\t\t     NULL_TREE);\n+      init = build_call_nary (void_type_node,\n+\t\t\t      build_address_of (soft_initclass_node),\n+\t\t\t      1, build_class_ref (clas));\n       TREE_SIDE_EFFECTS (init) = 1;\n       init = build3 (COND_EXPR, void_type_node,\n \t\t     build2 (EQ_EXPR, boolean_type_node, \n@@ -2084,9 +2058,8 @@ static tree\n rewrite_arglist_getcaller (tree arglist)\n {\n   tree retaddr \n-    = (build_function_call_expr \n-       (built_in_decls[BUILT_IN_RETURN_ADDRESS],\n-\tbuild_tree_list (NULL_TREE, integer_zero_node)));\n+    = build_call_expr (built_in_decls[BUILT_IN_RETURN_ADDRESS],\n+\t\t       1, integer_zero_node);\n   \n   DECL_INLINE (current_function_decl) = 0;\n \n@@ -2356,7 +2329,6 @@ static GTY(()) tree class_ident;\n tree\n build_invokeinterface (tree dtable, tree method)\n {\n-  tree lookup_arg;\n   tree interface;\n   tree idx;\n \n@@ -2401,13 +2373,9 @@ build_invokeinterface (tree dtable, tree method)\n       interface = build_class_ref (interface);\n     }\n \t\t\t\t     \t\t\t  \n-  lookup_arg = tree_cons (NULL_TREE, dtable,\n-\t\t\t  tree_cons (NULL_TREE, interface,\n-\t\t\t\t     build_tree_list (NULL_TREE, idx)));\n-\n-  return build3 (CALL_EXPR, ptr_type_node, \n-\t\t build_address_of (soft_lookupinterfacemethod_node),\n-\t\t lookup_arg, NULL_TREE);\n+  return build_call_nary (ptr_type_node, \n+\t\t\t  build_address_of (soft_lookupinterfacemethod_node),\n+\t\t\t  3, dtable, interface, idx);\n }\n   \n /* Expand one of the invoke_* opcodes.\n@@ -2590,8 +2558,7 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n   else\n     func = build1 (NOP_EXPR, build_pointer_type (method_type), func);\n \n-  call = build3 (CALL_EXPR, TREE_TYPE (method_type),\n-\t\t func, arg_list, NULL_TREE);\n+  call = build_call_list (TREE_TYPE (method_type), func, arg_list);\n   TREE_SIDE_EFFECTS (call) = 1;\n   call = check_for_builtin (method, call);\n \n@@ -2616,7 +2583,8 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n tree\n build_jni_stub (tree method)\n {\n-  tree jnifunc, call, args, body, lookup_arg, method_sig, arg_types;\n+  tree jnifunc, call, args, body, method_sig, arg_types;\n+  tree jniarg0, jniarg1, jniarg2, jniarg3;\n   tree jni_func_type, tem;\n   tree env_var, res_var = NULL_TREE, block;\n   tree method_args, res_type;\n@@ -2671,10 +2639,9 @@ build_jni_stub (tree method)\n \n   /* Compute the local `env' by calling _Jv_GetJNIEnvNewFrame.  */\n   body = build2 (MODIFY_EXPR, ptr_type_node, env_var,\n-\t\t build3 (CALL_EXPR, ptr_type_node,\n-\t\t\t build_address_of (soft_getjnienvnewframe_node),\n-\t\t\t build_tree_list (NULL_TREE, klass),\n-\t\t\t NULL_TREE));\n+\t\t build_call_nary (ptr_type_node,\n+\t\t\t\t  build_address_of (soft_getjnienvnewframe_node),\n+\t\t\t\t  1, klass));\n   CAN_COMPLETE_NORMALLY (body) = 1;\n \n   /* All the arguments to this method become arguments to the\n@@ -2713,18 +2680,14 @@ build_jni_stub (tree method)\n   /* We call _Jv_LookupJNIMethod to find the actual underlying\n      function pointer.  _Jv_LookupJNIMethod will throw the appropriate\n      exception if this function is not found at runtime.  */\n-  tem = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, args_size));\n   method_sig = build_java_signature (TREE_TYPE (method));\n-  lookup_arg = tree_cons (NULL_TREE,\n-                          build_utf8_ref (unmangle_classname\n-                                          (IDENTIFIER_POINTER (method_sig),\n-                                           IDENTIFIER_LENGTH (method_sig))), \n-                          tem);\n-  tem = DECL_NAME (method);\n-  lookup_arg\n-    = tree_cons (NULL_TREE, klass,\n-\t\t tree_cons (NULL_TREE, build_utf8_ref (tem), lookup_arg));\n-  \n+  jniarg0 = klass;\n+  jniarg1 = build_utf8_ref (DECL_NAME (method));\n+  jniarg2 = build_utf8_ref (unmangle_classname\n+\t\t\t    (IDENTIFIER_POINTER (method_sig),\n+\t\t\t     IDENTIFIER_LENGTH (method_sig)));\n+  jniarg3 = build_int_cst (NULL_TREE, args_size);\n+\n   tem = build_function_type (TREE_TYPE (TREE_TYPE (method)), arg_types);\n \n #ifdef MODIFY_JNI_METHOD_CALL\n@@ -2736,16 +2699,18 @@ build_jni_stub (tree method)\n   jnifunc = build3 (COND_EXPR, ptr_type_node,\n \t\t    meth_var, meth_var,\n \t\t    build2 (MODIFY_EXPR, ptr_type_node, meth_var,\n-\t\t\t    build3 (CALL_EXPR, ptr_type_node,\n-\t\t\t\t    build_address_of\n-\t\t\t\t      (soft_lookupjnimethod_node),\n-\t\t\t\t    lookup_arg, NULL_TREE)));\n+\t\t\t    build_call_nary (ptr_type_node,\n+\t\t\t\t\t     build_address_of\n+\t\t\t\t\t       (soft_lookupjnimethod_node),\n+\t\t\t\t\t     4,\n+\t\t\t\t\t     jniarg0, jniarg1,\n+\t\t\t\t\t     jniarg2, jniarg3)));\n \n   /* Now we make the actual JNI call via the resulting function\n      pointer.    */\n-  call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (method)),\n-\t\t build1 (NOP_EXPR, jni_func_type, jnifunc),\n-\t\t args, NULL_TREE);\n+  call = build_call_list (TREE_TYPE (TREE_TYPE (method)),\n+\t\t\t  build1 (NOP_EXPR, jni_func_type, jnifunc),\n+\t\t\t  args);\n \n   /* If the JNI call returned a result, capture it here.  If we had to\n      unwrap JNI object results, we would do that here.  */\n@@ -2754,10 +2719,9 @@ build_jni_stub (tree method)\n       /* If the call returns an object, it may return a JNI weak\n \t reference, in which case we must unwrap it.  */\n       if (! JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_TYPE (method))))\n-\tcall = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (method)),\n-\t\t       build_address_of (soft_unwrapjni_node),\n-\t\t       build_tree_list (NULL_TREE, call),\n-\t\t       NULL_TREE);\n+\tcall = build_call_nary (TREE_TYPE (TREE_TYPE (method)),\n+\t\t\t\tbuild_address_of (soft_unwrapjni_node),\n+\t\t\t\t1, call);\n       call = build2 (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (method)),\n \t\t     res_var, call);\n     }\n@@ -2769,10 +2733,9 @@ build_jni_stub (tree method)\n   TREE_SIDE_EFFECTS (body) = 1;\n \n   /* Now free the environment we allocated.  */\n-  call = build3 (CALL_EXPR, ptr_type_node,\n-\t\t build_address_of (soft_jnipopsystemframe_node),\n-\t\t build_tree_list (NULL_TREE, env_var),\n-\t\t NULL_TREE);\n+  call = build_call_nary (ptr_type_node,\n+\t\t\t  build_address_of (soft_jnipopsystemframe_node),\n+\t\t\t  1, env_var);\n   TREE_SIDE_EFFECTS (call) = 1;\n   CAN_COMPLETE_NORMALLY (call) = 1;\n   body = build2 (COMPOUND_EXPR, void_type_node, body, call);\n@@ -2805,11 +2768,8 @@ build_jni_stub (tree method)\n       && (! METHOD_PRIVATE (method)\n           || INNER_CLASS_P (DECL_CONTEXT (method))))\n     {\n-      tree init = build3 (CALL_EXPR, void_type_node,\n-\t\t\t  build_address_of (soft_initclass_node),\n-\t\t\t  build_tree_list (NULL_TREE, \n-\t\t\t\t\t   klass),\n-\t\t\t  NULL_TREE);\n+      tree init = build_call_expr (soft_initclass_node, 1, \n+\t\t\t\t   klass);\n       body = build2 (COMPOUND_EXPR, void_type_node, init, body);\n       TREE_SIDE_EFFECTS (body) = 1;\n     }\n@@ -2943,11 +2903,8 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n \t\t\t    field_ref, new_value);\n \n       if (TREE_THIS_VOLATILE (field_decl))\n-\tjava_add_stmt \n-\t  (build3 \n-\t   (CALL_EXPR, void_type_node,\n-\t    build_address_of (built_in_decls[BUILT_IN_SYNCHRONIZE]),\n-\t    NULL_TREE, NULL_TREE));\n+\tjava_add_stmt\n+\t  (build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0));\n       \t  \n       java_add_stmt (modify_expr);\n     }\n@@ -2965,10 +2922,7 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n \n       if (TREE_THIS_VOLATILE (field_decl))\n \tjava_add_stmt \n-\t  (build3 \n-\t   (CALL_EXPR, void_type_node,\n-\t    build_address_of (built_in_decls[BUILT_IN_SYNCHRONIZE]),\n-\t    NULL_TREE, NULL_TREE));\n+\t  (build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0));\n \n       push_value (temp);\n     }      \n@@ -3725,40 +3679,36 @@ force_evaluation_order (tree node)\n \t  && TREE_CODE (TREE_OPERAND (node, 0)) == CALL_EXPR\n \t  && TREE_CODE (TREE_OPERAND (node, 1)) == SAVE_EXPR)) \n     {\n-      tree arg, cmp;\n+      tree call, cmp;\n+      int i, nargs;\n \n-      arg = node;\n-      \n-      /* Position arg properly, account for wrapped around ctors. */\n+      /* Account for wrapped around ctors.  */\n       if (TREE_CODE (node) == COMPOUND_EXPR)\n-        arg = TREE_OPERAND (node, 0);\n-      \n-      arg = TREE_OPERAND (arg, 1);\n-      \n-      /* An empty argument list is ok, just ignore it.  */\n-      if (!arg)\n-\treturn node;\n+        call = TREE_OPERAND (node, 0);\n+      else\n+\tcall = node;\n \n-      /* Not having a list of arguments here is an error. */ \n-      gcc_assert (TREE_CODE (arg) == TREE_LIST);\n+      nargs = call_expr_nargs (call);\n \n       /* This reverses the evaluation order. This is a desired effect. */\n-      for (cmp = NULL_TREE; arg; arg = TREE_CHAIN (arg))\n+      for (i = 0, cmp = NULL_TREE; i < nargs; i++)\n \t{\n+\t  tree arg = CALL_EXPR_ARG (call, i);\n \t  /* Promote types smaller than integer.  This is required by\n \t     some ABIs.  */\n-\t  tree type = TREE_TYPE (TREE_VALUE (arg));\n+\t  tree type = TREE_TYPE (arg);\n \t  tree saved;\n \t  if (targetm.calls.promote_prototypes (type)\n \t      && INTEGRAL_TYPE_P (type)\n \t      && INT_CST_LT_UNSIGNED (TYPE_SIZE (type),\n \t\t\t\t      TYPE_SIZE (integer_type_node)))\n-\t    TREE_VALUE (arg) = fold_convert (integer_type_node, TREE_VALUE (arg));\n+\t    arg = fold_convert (integer_type_node, arg);\n \n-\t  saved = save_expr (force_evaluation_order (TREE_VALUE (arg)));\n+\t  saved = save_expr (force_evaluation_order (arg));\n \t  cmp = (cmp == NULL_TREE ? saved :\n \t\t build2 (COMPOUND_EXPR, void_type_node, cmp, saved));\n-\t  TREE_VALUE (arg) = saved;\n+\n+\t  CALL_EXPR_ARG (call, i) = saved;\n \t}\n       \n       if (cmp && TREE_CODE (cmp) == COMPOUND_EXPR)"}, {"sha": "eeda04c3363b0d6051aae25103968949d3f6e081", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -212,10 +212,7 @@ java_gimplify_component_ref (tree *expr_p, tree *pre_p, tree *post_p)\n     if (stat == GS_ERROR)\n       return stat;\n \n-    sync_expr \n-      = build3 (CALL_EXPR, void_type_node,\n-\t\tbuild_address_of (built_in_decls[BUILT_IN_SYNCHRONIZE]),\n-\t\tNULL_TREE, NULL_TREE);\n+    sync_expr = build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n     TREE_SIDE_EFFECTS (sync_expr) = 1;\n     *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),\n \t\t      sync_expr, *expr_p);\n@@ -255,10 +252,8 @@ java_gimplify_modify_expr (tree *modify_expr_p, tree *pre_p, tree *post_p)\n       */\n   \n       enum gimplify_status stat;\n-      tree sync_expr \n-\t= build3 (CALL_EXPR, void_type_node,\n-\t\t  build_address_of (built_in_decls[BUILT_IN_SYNCHRONIZE]),\n-\t\t  NULL_TREE, NULL_TREE);\n+      tree sync_expr =\n+\tbuild_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n       TREE_SIDE_EFFECTS (sync_expr) = 1;\n \n       stat = gimplify_expr (&rhs, pre_p, post_p,"}, {"sha": "4a413712fe2d0548485a0ee0a2c70601dcc472ec", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1626,20 +1626,18 @@ extern tree *type_map;\n \n #define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build3 (CALL_EXPR, int_type_node,\t\t\t\t\\\n-\t\t      build_address_of (soft_monitorenter_node),\t\\\n-\t\t      build_tree_list (NULL_TREE, (ARG)),\t \t\\\n-\t\t      NULL_TREE);\t\t\t\t\t\\\n+    (WHERE) = build_call_nary (int_type_node,\t\t\t\t\\\n+\t\t\t       build_address_of (soft_monitorenter_node), \\\n+\t\t\t       1, (ARG));\t\t\t\t\\\n     TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\t\\\n   }\n \n-#define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build3 (CALL_EXPR, int_type_node,\t\t\t\\\n-\t\t      build_address_of (soft_monitorexit_node),\t\\\n-\t\t      build_tree_list (NULL_TREE, (ARG)),\t\\\n-\t\t      NULL_TREE);\t\t\t\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n+#define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build_call_nary (int_type_node,\t\t\t\t\\\n+\t\t\t       build_address_of (soft_monitorexit_node), \\\n+\t\t\t       1, (ARG));\t\t\t\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\t\\\n   }\n \n /* True when we can perform static class initialization optimization */"}, {"sha": "b1912cc1128f15717622b95c446e8fa458b7f973", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -989,7 +989,7 @@ java_get_callee_fndecl (tree call_expr)\n \n   if (TREE_CODE (call_expr) != CALL_EXPR)\n     return NULL;\n-  method = TREE_OPERAND (call_expr, 0);\n+  method = CALL_EXPR_FN (call_expr);\n   STRIP_NOPS (method);\n   if (TREE_CODE (method) != ARRAY_REF)\n     return NULL;"}, {"sha": "91bbdc5c30defb8efed476cfaaff15d8c5e8c89b", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -116,8 +116,7 @@ write_resource_constructor (tree *list_p)\n   for (iter = nreverse (resources); iter ; iter = TREE_CHAIN (iter))\n     {\n       t = build_fold_addr_expr (TREE_VALUE (iter));\n-      t = tree_cons (NULL, t, NULL);\n-      t = build_function_call_expr (register_resource_fn, t);\n+      t = build_call_expr (register_resource_fn, 1, t);\n       append_to_statement_list (t, list_p);\n     }\n }"}, {"sha": "0341c5f358b4dffd1f8c6cdad479acd60672aecf", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1,3 +1,10 @@\n+2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Brooks Moses  <brooks.moses@codesourcery.com>\n+\t    Lee Millward  <lee.millward@codesourcery.com>\n+\n+\t* objc-act.c (receiver_is_class_object): Use new CALL_EXPR accessors.\n+\t(objc_get_callee_fndecl): Likewise.\n+\n 2007-01-23  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR objc/27438"}, {"sha": "6dd6a464ce0f68e530042ca10c38fee24484a03d", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -6131,7 +6131,7 @@ receiver_is_class_object (tree receiver, int self, int super)\n   /* The receiver is a function call that returns an id.  Check if\n      it is a call to objc_getClass, if so, pick up the class name.  */\n   if (TREE_CODE (receiver) == CALL_EXPR\n-      && (exp = TREE_OPERAND (receiver, 0))\n+      && (exp = CALL_EXPR_FN (receiver))\n       && TREE_CODE (exp) == ADDR_EXPR\n       && (exp = TREE_OPERAND (exp, 0))\n       && TREE_CODE (exp) == FUNCTION_DECL\n@@ -6141,9 +6141,7 @@ receiver_is_class_object (tree receiver, int self, int super)\n       && TREE_TYPE (exp) == TREE_TYPE (objc_get_class_decl)\n       && !strcmp (IDENTIFIER_POINTER (DECL_NAME (exp)), TAG_GETCLASS)\n       /* We have a call to objc_get_class/objc_getClass!  */\n-      && (arg = TREE_OPERAND (receiver, 1))\n-      && TREE_CODE (arg) == TREE_LIST\n-      && (arg = TREE_VALUE (arg)))\n+      && (arg = CALL_EXPR_ARG (receiver, 0)))\n     {\n       STRIP_NOPS (arg);\n       if (TREE_CODE (arg) == ADDR_EXPR\n@@ -9517,7 +9515,7 @@ objc_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n tree\n objc_get_callee_fndecl (tree call_expr)\n {\n-  tree addr = TREE_OPERAND (call_expr, 0);\n+  tree addr = CALL_EXPR_FN (call_expr);\n   if (TREE_CODE (addr) != OBJ_TYPE_REF)\n     return 0;\n "}, {"sha": "bb7ecc0e9b39f45376e437632882423e37d7a045", "filename": "gcc/omp-low.c", "status": "modified", "additions": 58, "deletions": 90, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1427,10 +1427,7 @@ scan_omp (tree *stmt_p, omp_context *ctx)\n static void\n build_omp_barrier (tree *stmt_list)\n {\n-  tree t;\n-\n-  t = built_in_decls[BUILT_IN_GOMP_BARRIER];\n-  t = build_function_call_expr (t, NULL);\n+  tree t = build_call_expr (built_in_decls[BUILT_IN_GOMP_BARRIER], 0);\n   gimplify_and_add (t, stmt_list);\n }\n \n@@ -1604,7 +1601,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\t\t omp_context *ctx)\n {\n   tree_stmt_iterator diter;\n-  tree c, dtor, copyin_seq, x, args, ptr;\n+  tree c, dtor, copyin_seq, x, ptr;\n   bool copyin_by_ref = false;\n   bool lastprivate_firstprivate = false;\n   int pass;\n@@ -1676,9 +1673,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t      gcc_assert (DECL_P (ptr));\n \n \t      x = TYPE_SIZE_UNIT (TREE_TYPE (new_var));\n-\t      args = tree_cons (NULL, x, NULL);\n-\t      x = built_in_decls[BUILT_IN_ALLOCA];\n-\t      x = build_function_call_expr (x, args);\n+\t      x = build_call_expr (built_in_decls[BUILT_IN_ALLOCA], 1, x);\n \t      x = fold_convert (TREE_TYPE (ptr), x);\n \t      x = build2 (GIMPLE_MODIFY_STMT, void_type_node, ptr, x);\n \t      gimplify_and_add (x, ilist);\n@@ -1710,9 +1705,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\t}\n \t      else\n \t\t{\n-\t\t  args = tree_cons (NULL, x, NULL);\n-\t\t  x = built_in_decls[BUILT_IN_ALLOCA];\n-\t\t  x = build_function_call_expr (x, args);\n+\t\t  x = build_call_expr (built_in_decls[BUILT_IN_ALLOCA], 1, x);\n \t\t  x = fold_convert (TREE_TYPE (new_var), x);\n \t\t}\n \n@@ -1815,8 +1808,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n      but it certainly is to C++ operator=.  */\n   if (copyin_seq)\n     {\n-      x = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n-      x = build_function_call_expr (x, NULL);\n+      x = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n       x = build2 (NE_EXPR, boolean_type_node, x,\n \t\t  build_int_cst (TREE_TYPE (x), 0));\n       x = build3 (COND_EXPR, void_type_node, x, copyin_seq, NULL);\n@@ -1969,14 +1961,12 @@ lower_reduction_clauses (tree clauses, tree *stmt_list, omp_context *ctx)\n \t}\n     }\n \n-  x = built_in_decls[BUILT_IN_GOMP_ATOMIC_START];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (built_in_decls[BUILT_IN_GOMP_ATOMIC_START], 0);\n   gimplify_and_add (x, stmt_list);\n \n   gimplify_and_add (sub_list, stmt_list);\n \n-  x = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (built_in_decls[BUILT_IN_GOMP_ATOMIC_END], 0);\n   gimplify_and_add (x, stmt_list);\n }\n \n@@ -2155,7 +2145,7 @@ static void\n expand_parallel_call (struct omp_region *region, basic_block bb,\n \t\t      tree entry_stmt, tree ws_args)\n {\n-  tree t, args, val, cond, c, list, clauses;\n+  tree t, t1, t2, val, cond, c, list, clauses;\n   block_stmt_iterator si;\n   int start_ix;\n \n@@ -2261,34 +2251,34 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n     }\n \n   list = NULL_TREE;\n-  args = tree_cons (NULL, val, NULL);\n   t = OMP_PARALLEL_DATA_ARG (entry_stmt);\n   if (t == NULL)\n-    t = null_pointer_node;\n+    t1 = null_pointer_node;\n   else\n-    t = build_fold_addr_expr (t);\n-  args = tree_cons (NULL, t, args);\n-  t = build_fold_addr_expr (OMP_PARALLEL_FN (entry_stmt));\n-  args = tree_cons (NULL, t, args);\n+    t1 = build_fold_addr_expr (t);\n+  t2 = build_fold_addr_expr (OMP_PARALLEL_FN (entry_stmt));\n \n   if (ws_args)\n-    args = chainon (args, ws_args);\n+    {\n+      tree args = tree_cons (NULL, t2,\n+\t\t\t     tree_cons (NULL, t1,\n+\t\t\t\t\ttree_cons (NULL, val, ws_args)));\n+      t = build_function_call_expr (built_in_decls[start_ix], args);\n+    }\n+  else\n+    t = build_call_expr (built_in_decls[start_ix], 3, t2, t1, val);\n \n-  t = built_in_decls[start_ix];\n-  t = build_function_call_expr (t, args);\n   gimplify_and_add (t, &list);\n \n   t = OMP_PARALLEL_DATA_ARG (entry_stmt);\n   if (t == NULL)\n     t = null_pointer_node;\n   else\n     t = build_fold_addr_expr (t);\n-  args = tree_cons (NULL, t, NULL);\n-  t = build_function_call_expr (OMP_PARALLEL_FN (entry_stmt), args);\n+  t = build_call_expr (OMP_PARALLEL_FN (entry_stmt), 1, t);\n   gimplify_and_add (t, &list);\n \n-  t = built_in_decls[BUILT_IN_GOMP_PARALLEL_END];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_PARALLEL_END], 0);\n   gimplify_and_add (t, &list);\n \n   si = bsi_last (bb);\n@@ -2313,10 +2303,7 @@ maybe_catch_exception (tree *stmt_p)\n   if (lang_protect_cleanup_actions)\n     t = lang_protect_cleanup_actions ();\n   else\n-    {\n-      t = built_in_decls[BUILT_IN_TRAP];\n-      t = build_function_call_expr (t, NULL);\n-    }\n+    t = build_call_expr (built_in_decls[BUILT_IN_TRAP], 0);\n   f = build2 (EH_FILTER_EXPR, void_type_node, NULL, NULL);\n   EH_FILTER_MUST_NOT_THROW (f) = 1;\n   gimplify_and_add (t, &EH_FILTER_FAILURE (f));\n@@ -2583,7 +2570,7 @@ expand_omp_for_generic (struct omp_region *region,\n {\n   tree l0, l1, l2 = NULL, l3 = NULL;\n   tree type, istart0, iend0, iend;\n-  tree t, args, list;\n+  tree t, list;\n   basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb;\n   basic_block l2_bb = NULL, l3_bb = NULL;\n   block_stmt_iterator si;\n@@ -2621,25 +2608,24 @@ expand_omp_for_generic (struct omp_region *region,\n   gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n   if (!in_combined_parallel)\n     {\n+      tree t0, t1, t2, t3, t4;\n       /* If this is not a combined parallel loop, emit a call to\n \t GOMP_loop_foo_start in ENTRY_BB.  */\n       list = alloc_stmt_list ();\n-      t = build_fold_addr_expr (iend0);\n-      args = tree_cons (NULL, t, NULL);\n-      t = build_fold_addr_expr (istart0);\n-      args = tree_cons (NULL, t, args);\n+      t4 = build_fold_addr_expr (iend0);\n+      t3 = build_fold_addr_expr (istart0);\n+      t2 = fold_convert (long_integer_type_node, fd->step);\n+      t1 = fold_convert (long_integer_type_node, fd->n2);\n+      t0 = fold_convert (long_integer_type_node, fd->n1);\n       if (fd->chunk_size)\n \t{\n \t  t = fold_convert (long_integer_type_node, fd->chunk_size);\n-\t  args = tree_cons (NULL, t, args);\n+\t  t = build_call_expr (built_in_decls[start_fn], 6,\n+\t\t\t       t0, t1, t2, t, t3, t4);\n \t}\n-      t = fold_convert (long_integer_type_node, fd->step);\n-      args = tree_cons (NULL, t, args);\n-      t = fold_convert (long_integer_type_node, fd->n2);\n-      args = tree_cons (NULL, t, args);\n-      t = fold_convert (long_integer_type_node, fd->n1);\n-      args = tree_cons (NULL, t, args);\n-      t = build_function_call_expr (built_in_decls[start_fn], args);\n+      else\n+\tt = build_call_expr (built_in_decls[start_fn], 5,\n+\t\t\t     t0, t1, t2, t3, t4);\n       t = get_formal_tmp_var (t, &list);\n       if (cont_bb)\n \t{\n@@ -2697,11 +2683,9 @@ expand_omp_for_generic (struct omp_region *region,\n   /* Emit code to get the next parallel iteration in L2_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = build_fold_addr_expr (iend0);\n-  args = tree_cons (NULL, t, NULL);\n-  t = build_fold_addr_expr (istart0);\n-  args = tree_cons (NULL, t, args);\n-  t = build_function_call_expr (built_in_decls[next_fn], args);\n+  t = build_call_expr (built_in_decls[next_fn], 2,\n+\t\t       build_fold_addr_expr (istart0),\n+\t\t       build_fold_addr_expr (iend0));\n   t = get_formal_tmp_var (t, &list);\n   t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l0),\n \t      build_and_jump (&l3));\n@@ -2716,7 +2700,7 @@ expand_omp_for_generic (struct omp_region *region,\n     t = built_in_decls[BUILT_IN_GOMP_LOOP_END_NOWAIT];\n   else\n     t = built_in_decls[BUILT_IN_GOMP_LOOP_END];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (t, 0);\n   bsi_insert_after (&si, t, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n \n@@ -2795,13 +2779,11 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   /* Iteration space partitioning goes in ENTRY_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS], 0);\n   t = fold_convert (type, t);\n   nthreads = get_formal_tmp_var (t, &list);\n   \n-  t = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n   t = fold_convert (type, t);\n   threadid = get_formal_tmp_var (t, &list);\n \n@@ -2972,13 +2954,11 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n   list = alloc_stmt_list ();\n \n-  t = built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS], 0);\n   t = fold_convert (type, t);\n   nthreads = get_formal_tmp_var (t, &list);\n   \n-  t = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n   t = fold_convert (type, t);\n   threadid = get_formal_tmp_var (t, &list);\n \n@@ -3224,9 +3204,8 @@ expand_omp_sections (struct omp_region *region)\n       /* If we are not inside a combined parallel+sections region,\n \t call GOMP_sections_start.  */\n       t = build_int_cst (unsigned_type_node, len);\n-      t = tree_cons (NULL, t, NULL);\n       u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n-      t = build_function_call_expr (u, t);\n+      t = build_call_expr (u, 1, t);\n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n     }\n@@ -3284,8 +3263,7 @@ expand_omp_sections (struct omp_region *region)\n   make_edge (l0_bb, default_bb, 0);\n \n   si = bsi_start (default_bb);\n-  t = built_in_decls[BUILT_IN_TRAP];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_TRAP], 0);\n   bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n   /* Code to get the next section goes in L1_BB.  */\n@@ -3294,8 +3272,7 @@ expand_omp_sections (struct omp_region *region)\n       si = bsi_last (l1_bb);\n       gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n \n-      t = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n-      t = build_function_call_expr (t, NULL);\n+      t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT], 0);\n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n       bsi_remove (&si, true);\n@@ -3309,7 +3286,7 @@ expand_omp_sections (struct omp_region *region)\n \tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END_NOWAIT];\n       else\n \tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END];\n-      t = build_function_call_expr (t, NULL);\n+      t = build_call_expr (t, 0);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n       bsi_remove (&si, true);\n     }\n@@ -3680,8 +3657,7 @@ lower_omp_single_simple (tree single_stmt, tree *pre_p)\n {\n   tree t;\n \n-  t = built_in_decls[BUILT_IN_GOMP_SINGLE_START];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_START], 0);\n   t = build3 (COND_EXPR, void_type_node, t,\n \t      OMP_SINGLE_BODY (single_stmt), NULL);\n   gimplify_and_add (t, pre_p);\n@@ -3720,7 +3696,7 @@ lower_omp_single_simple (tree single_stmt, tree *pre_p)\n static void\n lower_omp_single_copy (tree single_stmt, tree *pre_p, omp_context *ctx)\n {\n-  tree ptr_type, t, args, l0, l1, l2, copyin_seq;\n+  tree ptr_type, t, l0, l1, l2, copyin_seq;\n \n   ctx->sender_decl = create_tmp_var (ctx->record_type, \".omp_copy_o\");\n \n@@ -3731,8 +3707,7 @@ lower_omp_single_copy (tree single_stmt, tree *pre_p, omp_context *ctx)\n   l1 = create_artificial_label ();\n   l2 = create_artificial_label ();\n \n-  t = built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START];\n-  t = build_function_call_expr (t, NULL);\n+  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START], 0);\n   t = fold_convert (ptr_type, t);\n   t = build2 (GIMPLE_MODIFY_STMT, void_type_node, ctx->receiver_decl, t);\n   gimplify_and_add (t, pre_p);\n@@ -3753,9 +3728,7 @@ lower_omp_single_copy (tree single_stmt, tree *pre_p, omp_context *ctx)\n \t\t\t      &copyin_seq, ctx);\n \n   t = build_fold_addr_expr (ctx->sender_decl);\n-  args = tree_cons (NULL, t, NULL);\n-  t = built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_END];\n-  t = build_function_call_expr (t, args);\n+  t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_END], 1, t);\n   gimplify_and_add (t, pre_p);\n \n   t = build_and_jump (&l2);\n@@ -3828,8 +3801,7 @@ lower_omp_master (tree *stmt_p, omp_context *ctx)\n \n   append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));\n \n-  x = built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n   x = build2 (EQ_EXPR, boolean_type_node, x, integer_zero_node);\n   x = build3 (COND_EXPR, void_type_node, x, NULL, build_and_jump (&lab));\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n@@ -3868,17 +3840,15 @@ lower_omp_ordered (tree *stmt_p, omp_context *ctx)\n \n   append_to_statement_list (stmt, &BIND_EXPR_BODY (bind));\n \n-  x = built_in_decls[BUILT_IN_GOMP_ORDERED_START];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (built_in_decls[BUILT_IN_GOMP_ORDERED_START], 0);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n \n   lower_omp (&OMP_ORDERED_BODY (stmt), ctx);\n   maybe_catch_exception (&OMP_ORDERED_BODY (stmt));\n   append_to_statement_list (OMP_ORDERED_BODY (stmt), &BIND_EXPR_BODY (bind));\n   OMP_ORDERED_BODY (stmt) = NULL;\n \n-  x = built_in_decls[BUILT_IN_GOMP_ORDERED_END];\n-  x = build_function_call_expr (x, NULL);\n+  x = build_call_expr (built_in_decls[BUILT_IN_GOMP_ORDERED_END], 0);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n \n   x = make_node (OMP_RETURN);\n@@ -3909,7 +3879,7 @@ lower_omp_critical (tree *stmt_p, omp_context *ctx)\n   name = OMP_CRITICAL_NAME (stmt);\n   if (name)\n     {\n-      tree decl, args;\n+      tree decl;\n       splay_tree_node n;\n \n       if (!critical_name_mutexes)\n@@ -3939,21 +3909,19 @@ lower_omp_critical (tree *stmt_p, omp_context *ctx)\n       else\n \tdecl = (tree) n->value;\n \n-      args = tree_cons (NULL, build_fold_addr_expr (decl), NULL);\n       lock = built_in_decls[BUILT_IN_GOMP_CRITICAL_NAME_START];\n-      lock = build_function_call_expr (lock, args);\n+      lock = build_call_expr (lock, 1, build_fold_addr_expr (decl));\n \n-      args = tree_cons (NULL, build_fold_addr_expr (decl), NULL);\n       unlock = built_in_decls[BUILT_IN_GOMP_CRITICAL_NAME_END];\n-      unlock = build_function_call_expr (unlock, args);\n+      unlock = build_call_expr (unlock, 1, build_fold_addr_expr (decl));\n     }\n   else\n     {\n       lock = built_in_decls[BUILT_IN_GOMP_CRITICAL_START];\n-      lock = build_function_call_expr (lock, NULL);\n+      lock = build_call_expr (lock, 0);\n \n       unlock = built_in_decls[BUILT_IN_GOMP_CRITICAL_END];\n-      unlock = build_function_call_expr (unlock, NULL);\n+      unlock = build_call_expr (unlock, 0);\n     }\n \n   push_gimplify_context ();"}, {"sha": "6a78b3785ac618d0368b2c999ba3048a5f5308f2", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -410,7 +410,7 @@ expand_widen_pattern_expr (tree exp, rtx op0, rtx op1, rtx wide_op, rtx target,\n   rtx temp;\n   rtx pat;\n   rtx xop0, xop1, wxop;\n-  int nops = TREE_CODE_LENGTH (TREE_CODE (exp));\n+  int nops = TREE_OPERAND_LENGTH (exp);\n \n   oprnd0 = TREE_OPERAND (exp, 0);\n   tmode0 = TYPE_MODE (TREE_TYPE (oprnd0));"}, {"sha": "df5d31059539598b55a23c23c73b7b4d5675c99a", "filename": "gcc/predict.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -913,16 +913,14 @@ expr_expected_value (tree expr, bitmap visited)\n       if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n \t  && DECL_FUNCTION_CODE (decl) == BUILT_IN_EXPECT)\n \t{\n-\t  tree arglist = TREE_OPERAND (expr, 1);\n \t  tree val;\n \n-\t  if (arglist == NULL_TREE\n-\t      || TREE_CHAIN (arglist) == NULL_TREE)\n-\t    return NULL; \n-\t  val = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (expr, 1)));\n+\t  if (call_expr_nargs (expr) != 2)\n+\t    return NULL;\n+\t  val = CALL_EXPR_ARG (expr, 0);\n \t  if (TREE_CONSTANT (val))\n \t    return val;\n-\t  return TREE_VALUE (TREE_CHAIN (TREE_OPERAND (expr, 1)));\n+\t  return CALL_EXPR_ARG (expr, 1);\n \t}\n     }\n   if (BINARY_CLASS_P (expr) || COMPARISON_CLASS_P (expr))\n@@ -965,17 +963,17 @@ strip_builtin_expect (void)\n \t{\n \t  tree stmt = bsi_stmt (bi);\n \t  tree fndecl;\n-\t  tree arglist;\n+\t  tree call;\n \n \t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t      && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == CALL_EXPR\n-\t      && (fndecl = get_callee_fndecl (GIMPLE_STMT_OPERAND (stmt, 1)))\n+\t      && (call = GIMPLE_STMT_OPERAND (stmt, 1))\n+\t      && TREE_CODE (call) == CALL_EXPR\n+\t      && (fndecl = get_callee_fndecl (call))\n \t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t      && (arglist = TREE_OPERAND (GIMPLE_STMT_OPERAND (stmt, 1), 1))\n-\t      && TREE_CHAIN (arglist))\n+\t      && call_expr_nargs (call) == 2)\n \t    {\n-\t      GIMPLE_STMT_OPERAND (stmt, 1) = TREE_VALUE (arglist);\n+\t      GIMPLE_STMT_OPERAND (stmt, 1) = CALL_EXPR_ARG (call, 0);\n \t      update_stmt (stmt);\n \t    }\n \t}"}, {"sha": "7eef3a386d2a2fdd0cf3e4ffb9462ac2019cc3d1", "filename": "gcc/print-tree.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -661,6 +661,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n     case tcc_binary:\n     case tcc_reference:\n     case tcc_statement:\n+    case tcc_vl_exp:\n       if (TREE_CODE (node) == BIT_FIELD_REF && BIT_FIELD_REF_UNSIGNED (node))\n \tfputs (\" unsigned\", file);\n       if (TREE_CODE (node) == BIND_EXPR)\n@@ -670,17 +671,34 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  print_node (file, \"block\", TREE_OPERAND (node, 2), indent + 4);\n \t  break;\n \t}\n-\n-      len = TREE_CODE_LENGTH (TREE_CODE (node));\n-\n-      for (i = 0; i < len; i++)\n+      if (TREE_CODE (node) == CALL_EXPR)\n \t{\n-\t  char temp[10];\n-\n-\t  sprintf (temp, \"arg %d\", i);\n-\t  print_node (file, temp, TREE_OPERAND (node, i), indent + 4);\n+\t  call_expr_arg_iterator iter;\n+\t  tree arg;\n+\t  print_node (file, \"fn\", CALL_EXPR_FN (node), indent + 4);\n+\t  print_node (file, \"static_chain\", CALL_EXPR_STATIC_CHAIN (node),\n+\t\t      indent + 4);\n+\t  i = 0;\n+\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n+\t    {\n+\t      char temp[10];\n+\t      sprintf (temp, \"arg %d\", i);\n+\t      print_node (file, temp, arg, indent + 4);\n+\t      i++;\n+\t    }\n \t}\n+      else\n+\t{\n+\t  len = TREE_OPERAND_LENGTH (node);\n \n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      char temp[10];\n+\t      \n+\t      sprintf (temp, \"arg %d\", i);\n+\t      print_node (file, temp, TREE_OPERAND (node, i), indent + 4);\n+\t    }\n+\t}\n       print_node (file, \"chain\", TREE_CHAIN (node), indent + 4);\n       break;\n "}, {"sha": "9578293d7ae996ededd82b5acccfca332df32151", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1477,7 +1477,7 @@ warn_if_unused_value (tree exp, location_t locus)\n       /* If this is an expression which has no operands, there is no value\n \t to be unused.  There are no such language-independent codes,\n \t but front ends may define such.  */\n-      if (EXPRESSION_CLASS_P (exp) && TREE_CODE_LENGTH (TREE_CODE (exp)) == 0)\n+      if (EXPRESSION_CLASS_P (exp) && TREE_OPERAND_LENGTH (exp) == 0)\n \treturn 0;\n \n     warn:"}, {"sha": "982fcdb188ed030f1d2edb1b041dc794bb566087", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -432,7 +432,7 @@ default_external_stack_protect_fail (void)\n       stack_chk_fail_decl = t;\n     }\n \n-  return build_function_call_expr (t, NULL_TREE);\n+  return build_call_expr (t, 0);\n }\n \n tree\n@@ -465,7 +465,7 @@ default_hidden_stack_protect_fail (void)\n       stack_chk_fail_decl = t;\n     }\n \n-  return build_function_call_expr (t, NULL_TREE);\n+  return build_call_expr (t, 0);\n #endif\n }\n "}, {"sha": "51f8200f313f07884129292aa41dd899b1cbe158", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 13, "deletions": 74, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -730,45 +730,16 @@ store_child_info (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   node = *tp;\n \n   /* 'node' is the parent of 'TREE_OPERAND (node, *)'.  */\n-  if (EXPRESSION_CLASS_P (node))\n+  if (EXPR_P (node))\n     {\n-\n-#define STORE_CHILD(N) do {                                                \\\n-  tree op = TREE_OPERAND (node, N);                                        \\\n-  slot = htab_find_slot (TB_up_ht, op, INSERT);                               \\\n-  *slot = (void *) node;                                                   \\\n-} while (0)\n-\n-      switch (TREE_CODE_LENGTH (TREE_CODE (node)))\n+      int n = TREE_OPERAND_LENGTH (node);\n+      int i;\n+      for (i = 0; i < n; i++)\n \t{\n-\tcase 4:\n-\t  STORE_CHILD (0);\n-\t  STORE_CHILD (1);\n-\t  STORE_CHILD (2);\n-\t  STORE_CHILD (3);\n-\t  break;\n-\n-\tcase 3:\n-\t  STORE_CHILD (0);\n-\t  STORE_CHILD (1);\n-\t  STORE_CHILD (2);\n-\t  break;\n-\n-\tcase 2:\n-\t  STORE_CHILD (0);\n-\t  STORE_CHILD (1);\n-\t  break;\n-\n-\tcase 1:\n-\t  STORE_CHILD (0);\n-\t  break;\n-\n-\tcase 0:\n-\tdefault:\n-\t  /* No children: nothing to do.  */\n-\t  break;\n+\t  tree op = TREE_OPERAND (node, i);\n+\t  slot = htab_find_slot (TB_up_ht, op, INSERT);\n+\t  *slot = (void *) node;\n \t}\n-#undef STORE_CHILD\n     }\n \n   /* Never stop walk_tree.  */\n@@ -787,46 +758,14 @@ TB_parent_eq (const void *p1, const void *p2)\n   if (p1 == NULL || p2 == NULL)\n     return 0;\n \n-  if (EXPRESSION_CLASS_P (parent))\n+  if (EXPR_P (parent))\n     {\n-\n-#define TEST_CHILD(N) do {               \\\n-  if (node == TREE_OPERAND (parent, N))  \\\n-    return 1;                            \\\n-} while (0)\n-\n-    switch (TREE_CODE_LENGTH (TREE_CODE (parent)))\n-      {\n-      case 4:\n-\tTEST_CHILD (0);\n-\tTEST_CHILD (1);\n-\tTEST_CHILD (2);\n-\tTEST_CHILD (3);\n-\tbreak;\n-\n-      case 3:\n-\tTEST_CHILD (0);\n-\tTEST_CHILD (1);\n-\tTEST_CHILD (2);\n-\tbreak;\n-\n-      case 2:\n-\tTEST_CHILD (0);\n-\tTEST_CHILD (1);\n-\tbreak;\n-\n-      case 1:\n-\tTEST_CHILD (0);\n-\tbreak;\n-\n-      case 0:\n-      default:\n-\t/* No children: nothing to do.  */\n-\tbreak;\n-      }\n-#undef TEST_CHILD\n+      int n = TREE_OPERAND_LENGTH (parent);\n+      int i;\n+      for (i = 0; i < n; i++)\n+\tif (node == TREE_OPERAND (parent, i))\n+\t  return 1;\n     }\n-\n   return 0;\n }\n "}, {"sha": "119a35b97c28d943ee476552a890a1043f7315bc", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -860,6 +860,8 @@ is_multivariate_chrec (tree chrec)\n bool \n chrec_contains_symbols (tree chrec)\n {\n+  int i, n;\n+\n   if (chrec == NULL_TREE)\n     return false;\n   \n@@ -871,53 +873,31 @@ chrec_contains_symbols (tree chrec)\n       || TREE_CODE (chrec) == RESULT_DECL\n       || TREE_CODE (chrec) == FIELD_DECL)\n     return true;\n-  \n-  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n-    {\n-    case 3:\n-      if (chrec_contains_symbols (TREE_OPERAND (chrec, 2)))\n-\treturn true;\n-      \n-    case 2:\n-      if (chrec_contains_symbols (TREE_OPERAND (chrec, 1)))\n-\treturn true;\n-      \n-    case 1:\n-      if (chrec_contains_symbols (TREE_OPERAND (chrec, 0)))\n-\treturn true;\n-      \n-    default:\n-      return false;\n-    }\n+\n+  n = TREE_OPERAND_LENGTH (chrec);\n+  for (i = 0; i < n; i++)\n+    if (chrec_contains_symbols (TREE_OPERAND (chrec, i)))\n+      return true;\n+  return false;\n }\n \n /* Determines whether the chrec contains undetermined coefficients.  */\n \n bool \n chrec_contains_undetermined (tree chrec)\n {\n+  int i, n;\n+\n   if (chrec == chrec_dont_know\n       || chrec == chrec_not_analyzed_yet\n       || chrec == NULL_TREE)\n     return true;\n-  \n-  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n-    {\n-    case 3:\n-      if (chrec_contains_undetermined (TREE_OPERAND (chrec, 2)))\n-\treturn true;\n-      \n-    case 2:\n-      if (chrec_contains_undetermined (TREE_OPERAND (chrec, 1)))\n-\treturn true;\n-      \n-    case 1:\n-      if (chrec_contains_undetermined (TREE_OPERAND (chrec, 0)))\n-\treturn true;\n-      \n-    default:\n-      return false;\n-    }\n+\n+  n = TREE_OPERAND_LENGTH (chrec);\n+  for (i = 0; i < n; i++)\n+    if (chrec_contains_undetermined (TREE_OPERAND (chrec, i)))\n+      return true;\n+  return false;\n }\n \n /* Determines whether the tree EXPR contains chrecs, and increment\n@@ -927,6 +907,8 @@ chrec_contains_undetermined (tree chrec)\n bool\n tree_contains_chrecs (tree expr, int *size)\n {\n+  int i, n;\n+\n   if (expr == NULL_TREE)\n     return false;\n \n@@ -936,23 +918,11 @@ tree_contains_chrecs (tree expr, int *size)\n   if (tree_is_chrec (expr))\n     return true;\n \n-  switch (TREE_CODE_LENGTH (TREE_CODE (expr)))\n-    {\n-    case 3:\n-      if (tree_contains_chrecs (TREE_OPERAND (expr, 2), size))\n-\treturn true;\n-      \n-    case 2:\n-      if (tree_contains_chrecs (TREE_OPERAND (expr, 1), size))\n-\treturn true;\n-      \n-    case 1:\n-      if (tree_contains_chrecs (TREE_OPERAND (expr, 0), size))\n-\treturn true;\n-      \n-    default:\n-      return false;\n-    }\n+  n = TREE_OPERAND_LENGTH (expr);\n+  for (i = 0; i < n; i++)\n+    if (tree_contains_chrecs (TREE_OPERAND (expr, i), size))\n+      return true;\n+  return false;\n }\n \n /* Recursive helper function.  */\n@@ -978,7 +948,7 @@ evolution_function_is_invariant_rec_p (tree chrec, int loopnum)\n       return true;\n     }\n \n-  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n+  switch (TREE_OPERAND_LENGTH (chrec))\n     {\n     case 2:\n       if (!evolution_function_is_invariant_rec_p (TREE_OPERAND (chrec, 1),"}, {"sha": "fce124eb595e08fecd097b88016ca08f17867762", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -885,12 +885,7 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n {\n   enum machine_mode mode;\n   enum built_in_function bcode;\n-  tree args, fn, stmt, type;\n-\n-  args = tree_cons (NULL, bi, NULL);\n-  args = tree_cons (NULL, br, args);\n-  args = tree_cons (NULL, ai, args);\n-  args = tree_cons (NULL, ar, args);\n+  tree fn, stmt, type;\n \n   stmt = bsi_stmt (*bsi);\n   type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 1));\n@@ -905,8 +900,7 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n     gcc_unreachable ();\n   fn = built_in_decls[bcode];\n \n-  GIMPLE_STMT_OPERAND (stmt, 1)\n-    = build3 (CALL_EXPR, type, build_fold_addr_expr (fn), args, NULL);\n+  GIMPLE_STMT_OPERAND (stmt, 1) = build_call_expr (fn, 4, ar, ai, br, bi);\n   update_stmt (stmt);\n \n   if (gimple_in_ssa_p (cfun))"}, {"sha": "b84f36be660aad6141fd8787e30e379649b13953", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -4249,7 +4249,8 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n {\n   bool clobbers_memory = false;\n   data_ref_loc *ref;\n-  tree *op0, *op1, args, call;\n+  tree *op0, *op1, arg, call;\n+  call_expr_arg_iterator iter;\n \n   *references = NULL;\n \n@@ -4290,9 +4291,9 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n \n   if (call)\n     {\n-      for (args = TREE_OPERAND (call, 1); args; args = TREE_CHAIN (args))\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n \t{\n-\t  op0 = &TREE_VALUE (args);\n+\t  op0 = &arg;\n \t  if (DECL_P (*op0)\n \t      || REFERENCE_CLASS_P (*op0))\n \t    {"}, {"sha": "73edcc891cf5d87b261feba84e47b91291414b91", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -607,8 +607,19 @@ dequeue_and_dump (dump_info_p di)\n       break;\n \n     case CALL_EXPR:\n-      dump_child (\"fn\", TREE_OPERAND (t, 0));\n-      dump_child (\"args\", TREE_OPERAND (t, 1));\n+      {\n+\tint i = 0;\n+\ttree arg;\n+\tcall_expr_arg_iterator iter;\n+\tdump_child (\"fn\", CALL_EXPR_FN (t));\n+\tFOR_EACH_CALL_EXPR_ARG (arg, iter, t)\n+\t  {\n+\t    char buffer[32];\n+\t    sprintf (buffer, \"%u\", i);\n+\t    dump_child (buffer, arg);\n+\t    i++;\n+\t  }\n+      }\n       break;\n \n     case CONSTRUCTOR:"}, {"sha": "5530afb231dd3eadceb87f1d664ce10068095b5d", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -420,7 +420,7 @@ is_gimple_cast (tree t)\n           || TREE_CODE (t) == FIX_TRUNC_EXPR);\n }\n \n-/* Return true if T is a valid op0 of a CALL_EXPR.  */\n+/* Return true if T is a valid function operand of a CALL_EXPR.  */\n \n bool\n is_gimple_call_addr (tree t)\n@@ -474,7 +474,7 @@ void\n recalculate_side_effects (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n-  int len = TREE_CODE_LENGTH (code);\n+  int len = TREE_OPERAND_LENGTH (t);\n   int i;\n \n   switch (TREE_CODE_CLASS (code))\n@@ -502,6 +502,7 @@ recalculate_side_effects (tree t)\n     case tcc_unary:       /* a unary arithmetic expression */\n     case tcc_binary:      /* a binary arithmetic expression */\n     case tcc_reference:   /* a reference */\n+    case tcc_vl_exp:        /* a function call */\n       TREE_SIDE_EFFECTS (t) = TREE_THIS_VOLATILE (t);\n       for (i = 0; i < len; ++i)\n \t{"}, {"sha": "4e6e3dee5ff3b549b591876b0d1f2709af8757e0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1430,33 +1430,35 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n }\n \n /* Generate code to initialize the parameters of the function at the\n-   top of the stack in ID from the ARGS (presented as a TREE_LIST).  */\n+   top of the stack in ID from the CALL_EXPR EXP.  */\n \n static void\n-initialize_inlined_parameters (copy_body_data *id, tree args, tree static_chain,\n+initialize_inlined_parameters (copy_body_data *id, tree exp,\n \t\t\t       tree fn, basic_block bb)\n {\n   tree parms;\n   tree a;\n   tree p;\n   tree vars = NULL_TREE;\n   int argnum = 0;\n+  call_expr_arg_iterator iter;\n+  tree static_chain = CALL_EXPR_STATIC_CHAIN (exp);\n \n   /* Figure out what the parameters are.  */\n   parms = DECL_ARGUMENTS (fn);\n \n   /* Loop through the parameter declarations, replacing each with an\n      equivalent VAR_DECL, appropriately initialized.  */\n-  for (p = parms, a = args; p;\n-       a = a ? TREE_CHAIN (a) : a, p = TREE_CHAIN (p))\n+  for (p = parms, a = first_call_expr_arg (exp, &iter); p;\n+       a = next_call_expr_arg (&iter), p = TREE_CHAIN (p))\n     {\n       tree value;\n \n       ++argnum;\n \n       /* Find the initializer.  */\n       value = lang_hooks.tree_inlining.convert_parm_for_inlining\n-\t      (p, a ? TREE_VALUE (a) : NULL_TREE, fn, argnum);\n+\t      (p, a, fn, argnum);\n \n       setup_one_parameter (id, p, value, fn, bb, &vars);\n     }\n@@ -2172,7 +2174,6 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case CALL_EXPR:\n       {\n \ttree decl = get_callee_fndecl (x);\n-\ttree arg;\n \n \tcost = d->weights->call_cost;\n \tif (decl && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n@@ -2195,11 +2196,14 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \t   that does use function declaration to figure out the arguments.  */\n \tif (!decl)\n \t  {\n-\t    for (arg = TREE_OPERAND (x, 1); arg; arg = TREE_CHAIN (arg))\n-\t      d->count += estimate_move_cost (TREE_TYPE (TREE_VALUE (arg)));\n+\t    tree a;\n+\t    call_expr_arg_iterator iter;\n+\t    FOR_EACH_CALL_EXPR_ARG (a, iter, x)\n+\t      d->count += estimate_move_cost (TREE_TYPE (a));\n \t  }\n \telse\n \t  {\n+\t    tree arg;\n \t    for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n \t      d->count += estimate_move_cost (TREE_TYPE (arg));\n \t  }\n@@ -2337,7 +2341,6 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   tree use_retvar;\n   tree fn;\n   splay_tree st;\n-  tree args;\n   tree return_slot;\n   tree modify_dest;\n   location_t saved_location;\n@@ -2495,15 +2498,12 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   id->decl_map = splay_tree_new (splay_tree_compare_pointers,\n \t\t\t\t NULL, NULL);\n \n-  /* Initialize the parameters.  */\n-  args = TREE_OPERAND (t, 1);\n-\n   /* Record the function we are about to inline.  */\n   id->src_fn = fn;\n   id->src_node = cg_edge->callee;\n   id->src_cfun = DECL_STRUCT_FUNCTION (fn);\n \n-  initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);\n+  initialize_inlined_parameters (id, t, fn, bb);\n \n   if (DECL_INITIAL (fn))\n     add_lexical_block (id->block, remap_blocks (DECL_INITIAL (fn), id));"}, {"sha": "e6b64687858af5fcb6eb1ff19eeba9fb0e81ef3c", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 44, "deletions": 66, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -656,20 +656,13 @@ mf_build_check_statement_for (tree base, tree limit,\n      refresh *_l vars.\n \n      This is the body of the conditional.  */\n-  \n-  u = tree_cons (NULL_TREE,\n-                 mf_file_function_line_tree (locus == NULL ? UNKNOWN_LOCATION\n-                                             : *locus),\n-                 NULL_TREE);\n-  u = tree_cons (NULL_TREE, dirflag, u);\n+\n+  u = mf_file_function_line_tree (locus == NULL ? UNKNOWN_LOCATION : *locus);\n   /* NB: we pass the overall [base..limit] range to mf_check.  */\n-  u = tree_cons (NULL_TREE, \n-                 fold_build2 (PLUS_EXPR, integer_type_node,\n-\t\t\t      fold_build2 (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n-\t\t\t      integer_one_node),\n-                 u);\n-  u = tree_cons (NULL_TREE, mf_base, u);\n-  t = build_function_call_expr (mf_check_fndecl, u);\n+  v = fold_build2 (PLUS_EXPR, integer_type_node,\n+\t\t   fold_build2 (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n+\t\t   integer_one_node);\n+  t = build_call_expr (mf_check_fndecl, 4, mf_base, v, dirflag, u);\n   gimplify_to_stmt_list (&t);\n   head = tsi_start (t);\n   tsi = tsi_last (t);\n@@ -996,48 +989,38 @@ mx_register_decls (tree decl, tree *stmt_list)\n           && ! TREE_STATIC (decl))\n         {\n           tree size = NULL_TREE, variable_name;\n-          tree unregister_fncall, unregister_fncall_params;\n-          tree register_fncall, register_fncall_params;\n+          tree unregister_fncall, unregister_fncall_param;\n+          tree register_fncall, register_fncall_param;\n \n \t  size = convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (decl)));\n \n-          /* (& VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK) */\n-          unregister_fncall_params =\n-            tree_cons (NULL_TREE,\n-                       convert (ptr_type_node,\n-                                mf_mark (build1 (ADDR_EXPR,\n-                                                 build_pointer_type (TREE_TYPE (decl)),\n-                                                 decl))),\n-                       tree_cons (NULL_TREE, \n-                                  size,\n-                                  tree_cons (NULL_TREE,\n-\t\t\t\t\t     /* __MF_TYPE_STACK */\n-                                             build_int_cst (NULL_TREE, 3),\n-                                             NULL_TREE)));\n-          /* __mf_unregister (...) */\n-          unregister_fncall = build_function_call_expr (mf_unregister_fndecl,\n-                                                        unregister_fncall_params);\n-\n-          /* (& VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK, \"name\") */\n+\n+          unregister_fncall_param =\n+\t    convert (ptr_type_node,\n+\t\t     mf_mark (build1 (ADDR_EXPR,\n+\t\t\t\t      build_pointer_type (TREE_TYPE (decl)),\n+\t\t\t\t      decl)));\n+          /* __mf_unregister (&VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK) */\n+          unregister_fncall = build_call_expr (mf_unregister_fndecl, 3,\n+\t\t\t\t\t       unregister_fncall_param,\n+\t\t\t\t\t       size,\n+\t\t\t\t\t       build_int_cst (NULL_TREE, 3));\n+\n+\n           variable_name = mf_varname_tree (decl);\n-          register_fncall_params =\n-            tree_cons (NULL_TREE,\n-                   convert (ptr_type_node,\n-                            mf_mark (build1 (ADDR_EXPR,\n-                                             build_pointer_type (TREE_TYPE (decl)),\n-                                             decl))),\n-                       tree_cons (NULL_TREE,\n-                                  size,\n-                                  tree_cons (NULL_TREE,\n-\t\t\t\t\t     /* __MF_TYPE_STACK */\n-                                             build_int_cst (NULL_TREE, 3),\n-                                             tree_cons (NULL_TREE,\n-                                                        variable_name,\n-                                                        NULL_TREE))));\n-\n-          /* __mf_register (...) */\n-          register_fncall = build_function_call_expr (mf_register_fndecl,\n-                                                      register_fncall_params);\n+          register_fncall_param =\n+\t    convert (ptr_type_node,\n+\t\t     mf_mark (build1 (ADDR_EXPR,\n+\t\t\t\t      build_pointer_type (TREE_TYPE (decl)),\n+\t\t\t\t      decl)));\n+          /* __mf_register (&VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK,\n+\t                    \"name\") */\n+\t  register_fncall = build_call_expr (mf_register_fndecl, 4,\n+\t\t\t\t\t     register_fncall_param,\n+\t\t\t\t\t     size,\n+\t\t\t\t\t     build_int_cst (NULL_TREE, 3),\n+\t\t\t\t\t     variable_name);\n+\n \n           /* Accumulate the two calls.  */\n           /* ??? Set EXPR_LOCATION.  */\n@@ -1172,21 +1155,17 @@ static GTY (()) tree enqueued_call_stmt_chain;\n static void\n mudflap_register_call (tree obj, tree object_size, tree varname)\n {\n-  tree arg, args, call_stmt;\n-\n-  args = tree_cons (NULL_TREE, varname, NULL_TREE);\n-\n-  arg = build_int_cst (NULL_TREE, 4); /* __MF_TYPE_STATIC */\n-  args = tree_cons (NULL_TREE, arg, args);\n-\n-  arg = convert (size_type_node, object_size);\n-  args = tree_cons (NULL_TREE, arg, args);\n+  tree arg, call_stmt;\n \n   arg = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (obj)), obj);\n   arg = convert (ptr_type_node, arg);\n-  args = tree_cons (NULL_TREE, arg, args);\n \n-  call_stmt = build_function_call_expr (mf_register_fndecl, args);\n+  call_stmt = build_call_expr (mf_register_fndecl, 4,\n+\t\t\t       arg,\n+\t\t\t       convert (size_type_node, object_size),\n+\t\t\t       /* __MF_TYPE_STATIC */\n+\t\t\t       build_int_cst (NULL_TREE, 4), \n+\t\t\t       varname);\n \n   append_to_statement_list (call_stmt, &enqueued_call_stmt_chain);\n }\n@@ -1243,16 +1222,15 @@ mudflap_finish_file (void)\n \n   /* Insert a call to __mf_init.  */\n   {\n-    tree call2_stmt = build_function_call_expr (mf_init_fndecl, NULL_TREE);\n+    tree call2_stmt = build_call_expr (mf_init_fndecl, 0);\n     append_to_statement_list (call2_stmt, &ctor_statements);\n   }\n   \n   /* If appropriate, call __mf_set_options to pass along read-ignore mode.  */\n   if (flag_mudflap_ignore_reads)\n     {\n-      tree arg = tree_cons (NULL_TREE, \n-                            mf_build_string (\"-ignore-reads\"), NULL_TREE);\n-      tree call_stmt = build_function_call_expr (mf_set_options_fndecl, arg);\n+      tree arg = mf_build_string (\"-ignore-reads\");\n+      tree call_stmt = build_call_expr (mf_set_options_fndecl, 1, arg);\n       append_to_statement_list (call_stmt, &ctor_statements);\n     }\n "}, {"sha": "0713773f761839778c8a97e504cb35ca380936f4", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1437,7 +1437,7 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info, *i;\n-  tree t = *tp, label, new_label, target_context, x, arg, field;\n+  tree t = *tp, label, new_label, target_context, x, field;\n   void **slot;\n \n   *walk_subtrees = 0;\n@@ -1475,11 +1475,8 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n   x = get_frame_field (info, target_context, field, &wi->tsi);\n   x = build_addr (x, target_context);\n   x = tsi_gimplify_val (info, x, &wi->tsi);\n-  arg = tree_cons (NULL, x, NULL);\n-  x = build_addr (new_label, target_context);\n-  arg = tree_cons (NULL, x, arg);\n-  x = implicit_built_in_decls[BUILT_IN_NONLOCAL_GOTO];\n-  x = build_function_call_expr (x, arg);\n+  x = build_call_expr (implicit_built_in_decls[BUILT_IN_NONLOCAL_GOTO], 2,\n+\t\t       build_addr (new_label, target_context), x);\n \n   SET_EXPR_LOCUS (x, EXPR_LOCUS (tsi_stmt (wi->tsi)));\n   *tsi_stmt_ptr (wi->tsi) = x;\n@@ -1537,7 +1534,7 @@ convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info, *i;\n-  tree t = *tp, decl, target_context, x, arg;\n+  tree t = *tp, decl, target_context, x;\n \n   *walk_subtrees = 0;\n   switch (TREE_CODE (t))\n@@ -1573,12 +1570,11 @@ convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n       x = get_frame_field (info, target_context, x, &wi->tsi);\n       x = build_addr (x, target_context);\n       x = tsi_gimplify_val (info, x, &wi->tsi);\n-      arg = tree_cons (NULL, x, NULL);\n \n       /* Do machine-specific ugliness.  Normally this will involve\n \t computing extra alignment, but it can really be anything.  */\n-      x = implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE];\n-      x = build_function_call_expr (x, arg);\n+      x = build_call_expr (implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE],\n+\t\t\t   1, x);\n       x = init_tmp_var (info, x, &wi->tsi);\n \n       /* Cast back to the proper function type.  */\n@@ -1591,7 +1587,12 @@ convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n     case CALL_EXPR:\n       /* Only walk call arguments, lest we generate trampolines for\n \t direct calls.  */\n-      walk_tree (&TREE_OPERAND (t, 1), convert_tramp_reference, wi, NULL);\n+      {\n+\tint nargs = call_expr_nargs (t);\n+\tint i;\n+\tfor (i = 0; i < nargs; i++)\n+\t  walk_tree (&CALL_EXPR_ARG (t, i), convert_tramp_reference, wi, NULL);\n+      }\n       break;\n \n     default:\n@@ -1626,7 +1627,7 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n       target_context = decl_function_context (decl);\n       if (target_context && !DECL_NO_STATIC_CHAIN (decl))\n \t{\n-\t  TREE_OPERAND (t, 2)\n+\t  CALL_EXPR_STATIC_CHAIN (t)\n \t    = get_static_chain (info, target_context, &wi->tsi);\n \t  info->static_chain_added\n \t    |= (1 << (info->context != target_context));\n@@ -1777,29 +1778,25 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n       struct nesting_info *i;\n       for (i = root->inner; i ; i = i->next)\n \t{\n-\t  tree arg, x, field;\n+\t  tree arg1, arg2, arg3, x, field;\n \n \t  field = lookup_tramp_for_decl (root, i->context, NO_INSERT);\n \t  if (!field)\n \t    continue;\n \n \t  if (DECL_NO_STATIC_CHAIN (i->context))\n-\t    x = null_pointer_node;\n+\t    arg3 = null_pointer_node;\n \t  else\n-\t    x = build_addr (root->frame_decl, context);\n-\t  arg = tree_cons (NULL, x, NULL);\n+\t    arg3 = build_addr (root->frame_decl, context);\n \n-\t  x = build_addr (i->context, context);\n-\t  arg = tree_cons (NULL, x, arg);\n+\t  arg2 = build_addr (i->context, context);\n \n \t  x = build3 (COMPONENT_REF, TREE_TYPE (field),\n \t\t      root->frame_decl, field, NULL_TREE);\n-\t  x = build_addr (x, context);\n-\t  arg = tree_cons (NULL, x, arg);\n+\t  arg1 = build_addr (x, context);\n \n \t  x = implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE];\n-\t  x = build_function_call_expr (x, arg);\n-\n+\t  x = build_call_expr (x, 3, arg1, arg2, arg3);\n \t  append_to_statement_list (x, &stmt_list);\n \t}\n     }"}, {"sha": "f1852ca5a7ba7357cad581cf2bc3232ea8e122ea", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -228,49 +228,41 @@ addr_object_size (tree ptr, int object_size_type)\n static unsigned HOST_WIDE_INT\n alloc_object_size (tree call, int object_size_type)\n {\n-  tree callee, arglist, a, bytes = NULL_TREE;\n-  unsigned int arg_mask = 0;\n+  tree callee, bytes = NULL_TREE;\n \n   gcc_assert (TREE_CODE (call) == CALL_EXPR);\n \n   callee = get_callee_fndecl (call);\n-  arglist = TREE_OPERAND (call, 1);\n   if (callee\n       && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (callee))\n       {\n       case BUILT_IN_MALLOC:\n       case BUILT_IN_ALLOCA:\n-\targ_mask = 1;\n+\tif (call_expr_nargs (call) == 1\n+\t    && TREE_CODE (CALL_EXPR_ARG (call, 0)) == INTEGER_CST)\n+\t  bytes = fold_convert (sizetype, CALL_EXPR_ARG (call, 0));\n \tbreak;\n       /*\n       case BUILT_IN_REALLOC:\n-\targ_mask = 2;\n+\tif (call_expr_nargs (call) == 2\n+\t    && TREE_CODE (CALL_EXPR_ARG (call, 1)) == INTEGER_CST)\n+\t  bytes = fold_convert (sizetype, CALL_EXPR_ARG (call, 1));\n \tbreak;\n \t*/\n       case BUILT_IN_CALLOC:\n-\targ_mask = 3;\n+\tif (call_expr_nargs (call) == 2\n+\t    && TREE_CODE (CALL_EXPR_ARG (call, 0)) == INTEGER_CST\n+\t    && TREE_CODE (CALL_EXPR_ARG (call, 1)) == INTEGER_CST)\n+\t  bytes = size_binop (MULT_EXPR,\n+\t\t\t      fold_convert (sizetype, CALL_EXPR_ARG (call, 0)),\n+\t\t\t      fold_convert (sizetype, CALL_EXPR_ARG (call, 1)));\n \tbreak;\n       default:\n \tbreak;\n       }\n \n-  for (a = arglist; arg_mask && a; arg_mask >>= 1, a = TREE_CHAIN (a))\n-    if (arg_mask & 1)\n-      {\n-\ttree arg = TREE_VALUE (a);\n-\n-\tif (TREE_CODE (arg) != INTEGER_CST)\n-\t  break;\n-\n-\tif (! bytes)\n-\t  bytes = fold_convert (sizetype, arg);\n-\telse\n-\t  bytes = size_binop (MULT_EXPR, bytes,\n-\t\t\t      fold_convert (sizetype, arg));\n-      }\n-\n-  if (! arg_mask && bytes && host_integerp (bytes, 1))\n+  if (bytes && host_integerp (bytes, 1))\n     return tree_low_cst (bytes, 1);\n \n   return unknown[object_size_type];\n@@ -285,7 +277,6 @@ static tree\n pass_through_call (tree call)\n {\n   tree callee = get_callee_fndecl (call);\n-  tree arglist = TREE_OPERAND (call, 1);\n \n   if (callee\n       && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n@@ -305,8 +296,8 @@ pass_through_call (tree call)\n       case BUILT_IN_STRNCPY_CHK:\n       case BUILT_IN_STRCAT_CHK:\n       case BUILT_IN_STRNCAT_CHK:\n-\tif (arglist)\n-\t  return TREE_VALUE (arglist);\n+\tif (call_expr_nargs (call) >= 1)\n+\t  return CALL_EXPR_ARG (call, 0);\n \tbreak;\n       default:\n \tbreak;\n@@ -1043,17 +1034,13 @@ compute_object_sizes (void)\n \t    continue;\n \n \t  init_object_sizes ();\n-\t  result = fold_builtin (callee, TREE_OPERAND (call, 1), false);\n+\t  result = fold_call_expr (call, false);\n \t  if (!result)\n \t    {\n-\t      tree arglist = TREE_OPERAND (call, 1);\n-\n-\t      if (arglist != NULL\n-\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n-\t\t  && TREE_CHAIN (arglist) != NULL\n-\t\t  && TREE_CHAIN (TREE_CHAIN (arglist)) == NULL)\n+\t      if (call_expr_nargs (call) == 2\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (call, 0))))\n \t\t{\n-\t\t  tree ost = TREE_VALUE (TREE_CHAIN (arglist));\n+\t\t  tree ost = CALL_EXPR_ARG (call, 1);\n \n \t\t  if (host_integerp (ost, 1))\n \t\t    {"}, {"sha": "8d5ca276ae83f06bb428623d4a37b65da764ed3c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -74,7 +74,7 @@ do_niy (pretty_printer *buffer, tree node)\n \n   if (EXPR_P (node))\n     {\n-      len = TREE_CODE_LENGTH (TREE_CODE (node));\n+      len = TREE_OPERAND_LENGTH (node);\n       for (i = 0; i < len; ++i)\n \t{\n \t  newline_and_indent (buffer, 2);\n@@ -1173,12 +1173,22 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       /* Print parameters.  */\n       pp_space (buffer);\n       pp_character (buffer, '(');\n-      op1 = TREE_OPERAND (node, 1);\n-      if (op1)\n-\tdump_generic_node (buffer, op1, spc, flags, false);\n+      {\n+\ttree arg;\n+\tcall_expr_arg_iterator iter;\n+\tFOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n+\t  {\n+\t    dump_generic_node (buffer, arg, spc, flags, false);\n+\t    if (more_call_expr_args_p (&iter))\n+\t      {\n+\t\tpp_character (buffer, ',');\n+\t\tpp_space (buffer);\n+\t      }\n+\t  }\n+      }\n       pp_character (buffer, ')');\n \n-      op1 = TREE_OPERAND (node, 2);\n+      op1 = CALL_EXPR_STATIC_CHAIN (node);\n       if (op1)\n \t{\n \t  pp_string (buffer, \" [static-chain: \");\n@@ -2528,7 +2538,7 @@ print_call_name (pretty_printer *buffer, tree node)\n \n   gcc_assert (TREE_CODE (node) == CALL_EXPR);\n \n-  op0 = TREE_OPERAND (node, 0);\n+  op0 = CALL_EXPR_FN (node);\n \n   if (TREE_CODE (op0) == NON_LVALUE_EXPR)\n     op0 = TREE_OPERAND (op0, 0);"}, {"sha": "b8e54d468e2a9f9ceaa32b4682069234628dc7dc", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -203,20 +203,16 @@ tree_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n   tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n-  tree args, call, val;\n+  tree call, val;\n   tree start = build_int_cst_type (integer_type_node, value->hdata.intvl.int_start);\n   tree steps = build_int_cst_type (unsigned_type_node, value->hdata.intvl.steps);\n   \n   ref_ptr = force_gimple_operand_bsi (&bsi,\n \t\t\t\t      build_addr (ref, current_function_decl),\n \t\t\t\t      true, NULL_TREE);\n   val = prepare_instrumented_value (&bsi, value);\n-  args = tree_cons (NULL_TREE, ref_ptr,\n-\t\t    tree_cons (NULL_TREE, val,\n-\t\t\t       tree_cons (NULL_TREE, start,\n-\t\t\t\t\t  tree_cons (NULL_TREE, steps,\n-\t\t\t\t\t\t     NULL_TREE))));\n-  call = build_function_call_expr (tree_interval_profiler_fn, args);\n+  call = build_call_expr (tree_interval_profiler_fn, 4,\n+\t\t\t  ref_ptr, val, start, steps);\n   bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n@@ -230,16 +226,13 @@ tree_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n   tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n-  tree args, call, val;\n+  tree call, val;\n   \n   ref_ptr = force_gimple_operand_bsi (&bsi,\n \t\t\t\t      build_addr (ref, current_function_decl),\n \t\t\t\t      true, NULL_TREE);\n   val = prepare_instrumented_value (&bsi, value);\n-  args = tree_cons (NULL_TREE, ref_ptr,\n-\t\t    tree_cons (NULL_TREE, val,\n-\t\t\t       NULL_TREE));\n-  call = build_function_call_expr (tree_pow2_profiler_fn, args);\n+  call = build_call_expr (tree_pow2_profiler_fn, 2, ref_ptr, val);\n   bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n@@ -253,16 +246,13 @@ tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n   tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n-  tree args, call, val;\n+  tree call, val;\n   \n   ref_ptr = force_gimple_operand_bsi (&bsi,\n \t\t\t\t      build_addr (ref, current_function_decl),\n \t\t\t\t      true, NULL_TREE);\n   val = prepare_instrumented_value (&bsi, value);\n-  args = tree_cons (NULL_TREE, ref_ptr,\n-\t\t    tree_cons (NULL_TREE, val,\n-\t\t\t       NULL_TREE));\n-  call = build_function_call_expr (tree_one_value_profiler_fn, args);\n+  call = build_call_expr (tree_one_value_profiler_fn, 2, ref_ptr, val);\n   bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n@@ -320,7 +310,7 @@ tree_gen_ic_func_profiler (void)\n   basic_block bb;\n   edge_iterator ei;\n   tree stmt1;\n-  tree args, tree_uid, cur_func;\n+  tree tree_uid, cur_func;\n \n   if (flag_unit_at_a_time)\n     {\n@@ -339,13 +329,11 @@ tree_gen_ic_func_profiler (void)\n \t\t\t\t\t\t       current_function_decl),\n \t\t\t\t\t   true, NULL_TREE);\n       tree_uid = build_int_cst (gcov_type_node, c_node->pid);\n-      args = tree_cons (NULL_TREE, ic_gcov_type_ptr_var,\n-\t\t\ttree_cons (NULL_TREE, tree_uid,\n-\t\t\t\t   tree_cons (NULL_TREE, cur_func,\n-\t\t\t\t\t      tree_cons (NULL_TREE, \n-\t\t\t\t\t\t\t ic_void_ptr_var,\n-\t\t\t\t\t\t\t NULL_TREE))));\n-      stmt1 = build_function_call_expr (tree_indirect_call_profiler_fn, args);\n+      stmt1 = build_call_expr (tree_indirect_call_profiler_fn, 4,\n+\t\t\t       ic_gcov_type_ptr_var,\n+\t\t\t       tree_uid,\n+\t\t\t       cur_func,\n+\t\t\t       ic_void_ptr_var);\n       bsi_insert_after (&bsi, stmt1, BSI_SAME_STMT);\n     }\n }\n@@ -377,14 +365,13 @@ tree_gen_average_profiler (histogram_value value, unsigned tag, unsigned base)\n   tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n-  tree args, call, val;\n+  tree call, val;\n   \n   ref_ptr = force_gimple_operand_bsi (&bsi,\n \t\t\t\t      build_addr (ref, current_function_decl),\n \t\t\t\t      true, NULL_TREE);\n   val = prepare_instrumented_value (&bsi, value);\n-  args = tree_cons (NULL_TREE, ref_ptr, tree_cons (NULL_TREE, val, NULL_TREE));\n-  call = build_function_call_expr (tree_average_profiler_fn, args);\n+  call = build_call_expr (tree_average_profiler_fn, 2, ref_ptr, val);\n   bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n@@ -398,14 +385,13 @@ tree_gen_ior_profiler (histogram_value value, unsigned tag, unsigned base)\n   tree stmt = value->hvalue.stmt;\n   block_stmt_iterator bsi = bsi_for_stmt (stmt);\n   tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n-  tree args, call, val;\n+  tree call, val;\n   \n   ref_ptr = force_gimple_operand_bsi (&bsi,\n \t\t\t\t      build_addr (ref, current_function_decl),\n \t\t\t\t      true, NULL_TREE);\n   val = prepare_instrumented_value (&bsi, value);\n-  args = tree_cons (NULL_TREE, ref_ptr, tree_cons (NULL_TREE, val, NULL_TREE));\n-  call = build_function_call_expr (tree_ior_profiler_fn, args);\n+  call = build_call_expr (tree_ior_profiler_fn, 2, ref_ptr, val);\n   bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n "}, {"sha": "9b0df6fb38017cd2eb61a041719884f2c111b144", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -357,6 +357,8 @@ find_var_scev_info (tree var)\n bool \n chrec_contains_symbols_defined_in_loop (tree chrec, unsigned loop_nb)\n {\n+  int i, n;\n+\n   if (chrec == NULL_TREE)\n     return false;\n \n@@ -386,26 +388,12 @@ chrec_contains_symbols_defined_in_loop (tree chrec, unsigned loop_nb)\n       return false;\n     }\n \n-  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n-    {\n-    case 3:\n-      if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, 2), \n-\t\t\t\t\t\t  loop_nb))\n-\treturn true;\n-\n-    case 2:\n-      if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, 1), \n-\t\t\t\t\t\t  loop_nb))\n-\treturn true;\n-\n-    case 1:\n-      if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, 0), \n-\t\t\t\t\t\t  loop_nb))\n-\treturn true;\n-\n-    default:\n-      return false;\n-    }\n+  n = TREE_OPERAND_LENGTH (chrec);\n+  for (i = 0; i < n; i++)\n+    if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, i), \n+\t\t\t\t\t\tloop_nb))\n+      return true;\n+  return false;\n }\n \n /* Return true when PHI is a loop-phi-node.  */\n@@ -2317,6 +2305,7 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       break;\n     }\n \n+  gcc_assert (!VL_EXP_CLASS_P (chrec));\n   switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n     {\n     case 3:"}, {"sha": "1ecbb3994aa1cd7978fa0ff2c6317ed731d57322", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -867,7 +867,10 @@ static void\n sra_walk_call_expr (tree expr, block_stmt_iterator *bsi,\n \t\t    const struct sra_walk_fns *fns)\n {\n-  sra_walk_tree_list (TREE_OPERAND (expr, 1), bsi, false, fns);\n+  int i;\n+  int nargs = call_expr_nargs (expr);\n+  for (i = 0; i < nargs; i++)\n+    sra_walk_expr (&CALL_EXPR_ARG (expr, i), bsi, false, fns);\n }\n \n /* Walk the inputs and outputs of an ASM_EXPR looking for scalarizable"}, {"sha": "e3cdaf9d590a7a8dde978245fc0b0ce0752b5e28", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -3080,11 +3080,13 @@ find_used_portions (tree *tp, int *walk_subtrees, void *lhs_p)\n       break;\n     case CALL_EXPR:\n       {\n-\ttree *arg;\n-\tfor (arg = &TREE_OPERAND (*tp, 1); *arg; arg = &TREE_CHAIN (*arg))\n+\tint i;\n+\tint nargs = call_expr_nargs (*tp);\n+\tfor (i = 0; i < nargs; i++)\n \t  {\n-\t    if (TREE_CODE (TREE_VALUE (*arg)) != ADDR_EXPR)\n-              find_used_portions (&TREE_VALUE (*arg), walk_subtrees, NULL);\n+\t    tree *arg = &CALL_EXPR_ARG (*tp, i);\n+\t    if (TREE_CODE (*arg) != ADDR_EXPR)\n+              find_used_portions (arg, walk_subtrees, NULL);\n \t  }\n \t*walk_subtrees = 0;\n \treturn NULL_TREE;"}, {"sha": "673415c1ca051c14411b5e7e22b4466e65e0117d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -939,15 +939,13 @@ ccp_fold (tree stmt)\n   /* We may be able to fold away calls to builtin functions if their\n      arguments are constants.  */\n   else if (code == CALL_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == ADDR_EXPR\n-\t   && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0))\n-\t       == FUNCTION_DECL)\n-\t   && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0)))\n+\t   && TREE_CODE (CALL_EXPR_FN (rhs)) == ADDR_EXPR\n+ \t   && TREE_CODE (TREE_OPERAND (CALL_EXPR_FN (rhs), 0)) == FUNCTION_DECL\n+ \t   && DECL_BUILT_IN (TREE_OPERAND (CALL_EXPR_FN (rhs), 0)))\n     {\n       if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_USE))\n \t{\n \t  tree *orig, var;\n-\t  tree fndecl, arglist;\n \t  size_t i = 0;\n \t  ssa_op_iter iter;\n \t  use_operand_p var_p;\n@@ -959,9 +957,7 @@ ccp_fold (tree stmt)\n \n \t  /* Substitute operands with their values and try to fold.  */\n \t  replace_uses_in (stmt, NULL, const_val);\n-\t  fndecl = get_callee_fndecl (rhs);\n-\t  arglist = TREE_OPERAND (rhs, 1);\n-\t  retval = fold_builtin (fndecl, arglist, false);\n+\t  retval = fold_call_expr (rhs, false);\n \n \t  /* Restore operands to their original form.  */\n \t  i = 0;\n@@ -2219,18 +2215,18 @@ static tree\n ccp_fold_builtin (tree stmt, tree fn)\n {\n   tree result, val[3];\n-  tree callee, arglist, a;\n+  tree callee, a;\n   int arg_mask, i, type;\n   bitmap visited;\n   bool ignore;\n+  call_expr_arg_iterator iter;\n+  int nargs;\n \n   ignore = TREE_CODE (stmt) != GIMPLE_MODIFY_STMT;\n \n   /* First try the generic builtin folder.  If that succeeds, return the\n      result directly.  */\n-  callee = get_callee_fndecl (fn);\n-  arglist = TREE_OPERAND (fn, 1);\n-  result = fold_builtin (callee, arglist, ignore);\n+  result = fold_call_expr (fn, ignore);\n   if (result)\n     {\n       if (ignore)\n@@ -2239,12 +2235,14 @@ ccp_fold_builtin (tree stmt, tree fn)\n     }\n \n   /* Ignore MD builtins.  */\n+  callee = get_callee_fndecl (fn);\n   if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_MD)\n     return NULL_TREE;\n \n   /* If the builtin could not be folded, and it has no argument list,\n      we're done.  */\n-  if (!arglist)\n+  nargs = call_expr_nargs (fn);\n+  if (nargs == 0)\n     return NULL_TREE;\n \n   /* Limit the work only for builtins we know how to simplify.  */\n@@ -2287,15 +2285,17 @@ ccp_fold_builtin (tree stmt, tree fn)\n   visited = BITMAP_ALLOC (NULL);\n \n   memset (val, 0, sizeof (val));\n-  for (i = 0, a = arglist;\n-       arg_mask;\n-       i++, arg_mask >>= 1, a = TREE_CHAIN (a))\n-    if (arg_mask & 1)\n-      {\n-\tbitmap_clear (visited);\n-\tif (!get_maxval_strlen (TREE_VALUE (a), &val[i], visited, type))\n-\t  val[i] = NULL_TREE;\n-      }\n+  init_call_expr_arg_iterator (fn, &iter);\n+  for (i = 0; arg_mask; i++, arg_mask >>= 1)\n+    {\n+      a = next_call_expr_arg (&iter);\n+      if (arg_mask & 1)\n+\t{\n+\t  bitmap_clear (visited);\n+\t  if (!get_maxval_strlen (a, &val[i], visited, type))\n+\t    val[i] = NULL_TREE;\n+\t}\n+    }\n \n   BITMAP_FREE (visited);\n \n@@ -2317,23 +2317,32 @@ ccp_fold_builtin (tree stmt, tree fn)\n       break;\n \n     case BUILT_IN_STRCPY:\n-      if (val[1] && is_gimple_val (val[1]))\n-\tresult = fold_builtin_strcpy (callee, arglist, val[1]);\n+      if (val[1] && is_gimple_val (val[1]) && nargs == 2)\n+\tresult = fold_builtin_strcpy (callee,\n+\t\t\t\t      CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t      CALL_EXPR_ARG (fn, 1),\n+\t\t\t\t      val[1]);\n       break;\n \n     case BUILT_IN_STRNCPY:\n-      if (val[1] && is_gimple_val (val[1]))\n-\tresult = fold_builtin_strncpy (callee, arglist, val[1]);\n+      if (val[1] && is_gimple_val (val[1]) && nargs == 3)\n+\tresult = fold_builtin_strncpy (callee,\n+\t\t\t\t       CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t       CALL_EXPR_ARG (fn, 1),\n+\t\t\t\t       CALL_EXPR_ARG (fn, 2),\n+\t\t\t\t       val[1]);\n       break;\n \n     case BUILT_IN_FPUTS:\n-      result = fold_builtin_fputs (arglist,\n+      result = fold_builtin_fputs (CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t   CALL_EXPR_ARG (fn, 1),\n \t\t\t\t   TREE_CODE (stmt) != GIMPLE_MODIFY_STMT, 0,\n \t\t\t\t   val[0]);\n       break;\n \n     case BUILT_IN_FPUTS_UNLOCKED:\n-      result = fold_builtin_fputs (arglist,\n+      result = fold_builtin_fputs (CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t   CALL_EXPR_ARG (fn, 1),\n \t\t\t\t   TREE_CODE (stmt) != GIMPLE_MODIFY_STMT, 1,\n \t\t\t\t   val[0]);\n       break;\n@@ -2343,26 +2352,39 @@ ccp_fold_builtin (tree stmt, tree fn)\n     case BUILT_IN_MEMMOVE_CHK:\n     case BUILT_IN_MEMSET_CHK:\n       if (val[2] && is_gimple_val (val[2]))\n-\tresult = fold_builtin_memory_chk (callee, arglist, val[2], ignore,\n+\tresult = fold_builtin_memory_chk (callee,\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 1),\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 2),\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 3),\n+\t\t\t\t\t  val[2], ignore,\n \t\t\t\t\t  DECL_FUNCTION_CODE (callee));\n       break;\n \n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY_CHK:\n       if (val[1] && is_gimple_val (val[1]))\n-\tresult = fold_builtin_stxcpy_chk (callee, arglist, val[1], ignore,\n+\tresult = fold_builtin_stxcpy_chk (callee,\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 1),\n+\t\t\t\t\t  CALL_EXPR_ARG (fn, 2),\n+\t\t\t\t\t  val[1], ignore,\n \t\t\t\t\t  DECL_FUNCTION_CODE (callee));\n       break;\n \n     case BUILT_IN_STRNCPY_CHK:\n       if (val[2] && is_gimple_val (val[2]))\n-\tresult = fold_builtin_strncpy_chk (arglist, val[2]);\n+\tresult = fold_builtin_strncpy_chk (CALL_EXPR_ARG (fn, 0),\n+\t\t\t\t\t   CALL_EXPR_ARG (fn, 1),\n+\t\t\t\t\t   CALL_EXPR_ARG (fn, 2),\n+\t\t\t\t\t   CALL_EXPR_ARG (fn, 3),\n+\t\t\t\t\t   val[2]);\n       break;\n \n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n       if (val[1] && is_gimple_val (val[1]))\n-\tresult = fold_builtin_snprintf_chk (arglist, val[1],\n+\tresult = fold_builtin_snprintf_chk (fn, val[1],\n \t\t\t\t\t    DECL_FUNCTION_CODE (callee));\n       break;\n \n@@ -2398,9 +2420,7 @@ fold_stmt (tree *stmt_p)\n      then we may need to fold instances of *&VAR into VAR, etc.  */\n   if (walk_tree (stmt_p, fold_stmt_r, &fold_stmt_r_data, NULL))\n     {\n-      *stmt_p\n-\t= build_function_call_expr (implicit_built_in_decls[BUILT_IN_TRAP],\n-\t\t\t\t    NULL);\n+      *stmt_p = build_call_expr (implicit_built_in_decls[BUILT_IN_TRAP], 0);\n       return true;\n     }\n \n@@ -2428,8 +2448,8 @@ fold_stmt (tree *stmt_p)\n \t     copying EH region info to the new node.  Easier to just do it\n \t     here where we can just smash the call operand. Also\n \t     CALL_EXPR_RETURN_SLOT_OPT needs to be handled correctly and\n-\t     copied, fold_ternary does not have not information. */\n-\t  callee = TREE_OPERAND (rhs, 0);\n+\t     copied, fold_call_expr does not have not information. */\n+\t  callee = CALL_EXPR_FN (rhs);\n \t  if (TREE_CODE (callee) == OBJ_TYPE_REF\n \t      && lang_hooks.fold_obj_type_ref\n \t      && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR\n@@ -2447,7 +2467,7 @@ fold_stmt (tree *stmt_p)\n \t      t = lang_hooks.fold_obj_type_ref (callee, t);\n \t      if (t)\n \t\t{\n-\t\t  TREE_OPERAND (rhs, 0) = t;\n+\t\t  CALL_EXPR_FN (rhs) = t;\n \t\t  changed = true;\n \t\t}\n \t    }"}, {"sha": "f1db0376fd1d2d53038f3737524b500d1d2e5469", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -342,10 +342,11 @@ outermost_invariant_loop_expr (tree expr, struct loop *loop)\n   if (class != tcc_unary\n       && class != tcc_binary\n       && class != tcc_expression\n+      && class != tcc_vl_exp\n       && class != tcc_comparison)\n     return NULL;\n \n-  nops = TREE_CODE_LENGTH (TREE_CODE (expr));\n+  nops = TREE_OPERAND_LENGTH (expr);\n   for (i = 0; i < nops; i++)\n     {\n       aloop = outermost_invariant_loop_expr (TREE_OPERAND (expr, i), loop);\n@@ -817,10 +818,11 @@ force_move_till_expr (tree expr, struct loop *orig_loop, struct loop *loop)\n   if (class != tcc_unary\n       && class != tcc_binary\n       && class != tcc_expression\n+      && class != tcc_vl_exp\n       && class != tcc_comparison)\n     return;\n \n-  nops = TREE_CODE_LENGTH (TREE_CODE (expr));\n+  nops = TREE_OPERAND_LENGTH (expr);\n   for (i = 0; i < nops; i++)\n     force_move_till_expr (TREE_OPERAND (expr, i), orig_loop, loop);\n }"}, {"sha": "8ca7e51122f5468bbc47c5491dca712cf50675c3", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1272,7 +1272,7 @@ expr_invariant_in_loop_p (struct loop *loop, tree expr)\n   if (!EXPR_P (expr) && !GIMPLE_STMT_P (expr))\n     return false;\n \n-  len = TREE_CODE_LENGTH (TREE_CODE (expr));\n+  len = TREE_OPERAND_LENGTH (expr);\n   for (i = 0; i < len; i++)\n     if (!expr_invariant_in_loop_p (loop, TREE_OPERAND (expr, i)))\n       return false;"}, {"sha": "47267ac594ead6579bb3e947d1ad656f6f27349e", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -655,7 +655,7 @@ simplify_replace_tree (tree expr, tree old, tree new)\n   if (!EXPR_P (expr) && !GIMPLE_STMT_P (expr))\n     return expr;\n \n-  n = TREE_CODE_LENGTH (TREE_CODE (expr));\n+  n = TREE_OPERAND_LENGTH (expr);\n   for (i = 0; i < n; i++)\n     {\n       e = TREE_OPERAND (expr, i);\n@@ -691,7 +691,7 @@ expand_simple_operations (tree expr)\n   code = TREE_CODE (expr);\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n     {\n-      n = TREE_CODE_LENGTH (code);\n+      n = TREE_OPERAND_LENGTH (expr);\n       for (i = 0; i < n; i++)\n \t{\n \t  e = TREE_OPERAND (expr, i);\n@@ -1882,11 +1882,12 @@ infer_loop_bounds_from_array (struct loop *loop, tree stmt)\n   call = get_call_expr_in (stmt);\n   if (call)\n     {\n-      tree args;\n+      tree arg;\n+      call_expr_arg_iterator iter;\n \n-      for (args = TREE_OPERAND (call, 1); args; args = TREE_CHAIN (args))\n-\tif (REFERENCE_CLASS_P (TREE_VALUE (args)))\n-\t  infer_loop_bounds_from_ref (loop, stmt, TREE_VALUE (args));\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n+\tif (REFERENCE_CLASS_P (arg))\n+\t  infer_loop_bounds_from_ref (loop, stmt, arg);\n     }\n }\n "}, {"sha": "e0612b9a56e8fea3d9fcea88aedf4fe57bd91fd2", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -815,7 +815,7 @@ static void\n issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n {\n   HOST_WIDE_INT delta;\n-  tree addr, addr_base, prefetch, params, write_p;\n+  tree addr, addr_base, prefetch, write_p;\n   block_stmt_iterator bsi;\n   unsigned n_prefetches, ap;\n \n@@ -839,11 +839,8 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n       addr = force_gimple_operand_bsi (&bsi, unshare_expr (addr), true, NULL);\n \n       /* Create the prefetch instruction.  */\n-      params = tree_cons (NULL_TREE, addr,\n-\t\t\t  tree_cons (NULL_TREE, write_p, NULL_TREE));\n-\n-      prefetch = build_function_call_expr (built_in_decls[BUILT_IN_PREFETCH],\n-\t\t\t\t\t   params);\n+      prefetch = build_call_expr (built_in_decls[BUILT_IN_PREFETCH],\n+\t\t\t\t  2, addr, write_p);\n       bsi_insert_before (&bsi, prefetch, BSI_SAME_STMT);\n     }\n }"}, {"sha": "1861f3e298c00de6cda4699adea939cfb78d5645", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -606,7 +606,7 @@ execute_cse_sincos_1 (tree name)\n   if (!fndecl)\n     return;\n   res = make_rename_temp (TREE_TYPE (TREE_TYPE (fndecl)), \"sincostmp\");\n-  call = build_function_call_expr (fndecl, build_tree_list (NULL_TREE, name));\n+  call = build_call_expr (fndecl, 1, name);\n   stmt = build2 (GIMPLE_MODIFY_STMT, NULL_TREE, res, call);\n   def_stmt = SSA_NAME_DEF_STMT (name);\n   if (bb_for_stmt (def_stmt) == top_bb\n@@ -684,7 +684,7 @@ execute_cse_sincos (void)\n \t\tCASE_FLT_FN (BUILT_IN_SIN):\n \t\tCASE_FLT_FN (BUILT_IN_CEXPI):\n \t\t  arg = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t\t  arg = TREE_VALUE (TREE_OPERAND (arg, 1));\n+\t\t  arg = CALL_EXPR_ARG (arg, 0);\n \t\t  if (TREE_CODE (arg) == SSA_NAME)\n \t\t    execute_cse_sincos_1 (arg);\n \t\t  break;"}, {"sha": "be9cd6b9a247d44f3bef5e1e1a60e83c98f1d78b", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1871,8 +1871,8 @@ add_call_read_ops (tree stmt, tree callee)\n static void\n get_call_expr_operands (tree stmt, tree expr)\n {\n-  tree op;\n   int call_flags = call_expr_flags (expr);\n+  int i, nargs;\n   stmt_ann_t ann = stmt_ann (stmt);\n \n   ann->references_memory = true;\n@@ -1894,12 +1894,12 @@ get_call_expr_operands (tree stmt, tree expr)\n     }\n \n   /* Find uses in the called function.  */\n-  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_use);\n-\n-  for (op = TREE_OPERAND (expr, 1); op; op = TREE_CHAIN (op))\n-    get_expr_operands (stmt, &TREE_VALUE (op), opf_use);\n+  get_expr_operands (stmt, &CALL_EXPR_FN (expr), opf_use);\n+  nargs = call_expr_nargs (expr);\n+  for (i = 0; i < nargs; i++)\n+    get_expr_operands (stmt, &CALL_EXPR_ARG (expr, i), opf_use);\n \n-  get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_use);\n+  get_expr_operands (stmt, &CALL_EXPR_STATIC_CHAIN (expr), opf_use);\n }\n \n "}, {"sha": "b39c9e8e9f30c85336d13370e5e8e21bc8889c28", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 97, "deletions": 189, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-iterator.h\"\n #include \"real.h\"\n #include \"alloc-pool.h\"\n+#include \"obstack.h\"\n #include \"tree-pass.h\"\n #include \"flags.h\"\n #include \"bitmap.h\"\n@@ -387,11 +388,15 @@ static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n static alloc_pool reference_node_pool;\n static alloc_pool comparison_node_pool;\n-static alloc_pool expression_node_pool;\n-static alloc_pool list_node_pool;\n static alloc_pool modify_expr_node_pool;\n static bitmap_obstack grand_bitmap_obstack;\n \n+/* We can't use allocation pools to hold temporary CALL_EXPR objects, since\n+   they are not of fixed size.  Instead, use an obstack.  */\n+\n+static struct obstack temp_call_expr_obstack;\n+\n+\n /* To avoid adding 300 temporary variables when we only need one, we\n    only create one temporary variable, on demand, and build ssa names\n    off that.  We do have to change the variable if the types don't\n@@ -881,32 +886,12 @@ fully_constant_expression (tree t)\n   return t;\n }\n \n-/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.\n-   For example, this can copy a list made of TREE_LIST nodes.\n-   Allocates the nodes in list_node_pool*/\n+/* Make a temporary copy of a CALL_EXPR object NODE.  */\n \n static tree\n-pool_copy_list (tree list)\n+temp_copy_call_expr (tree node)\n {\n-  tree head;\n-  tree prev, next;\n-\n-  if (list == 0)\n-    return 0;\n-  head = (tree) pool_alloc (list_node_pool);\n-\n-  memcpy (head, list, tree_size (list));\n-  prev = head;\n-\n-  next = TREE_CHAIN (list);\n-  while (next)\n-    {\n-      TREE_CHAIN (prev) = (tree) pool_alloc (list_node_pool);\n-      memcpy (TREE_CHAIN (prev), next, tree_size (next));\n-      prev = TREE_CHAIN (prev);\n-      next = TREE_CHAIN (next);\n-    }\n-  return head;\n+  return (tree) obstack_copy (&temp_call_expr_obstack, node, tree_size (node));\n }\n \n /* Translate the vuses in the VUSES vector backwards through phi nodes\n@@ -1005,60 +990,52 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n     case tcc_expression:\n+      return NULL;\n+\n+    case tcc_vl_exp:\n       {\n \tif (TREE_CODE (expr) != CALL_EXPR)\n \t  return NULL;\n \telse\n \t  {\n-\t    tree oldop0 = TREE_OPERAND (expr, 0);\n-\t    tree oldval0 = oldop0;\n-\t    tree oldarglist = TREE_OPERAND (expr, 1);\n-\t    tree oldop2 = TREE_OPERAND (expr, 2);\n-\t    tree oldval2 = oldop2;\n-\t    tree newop0;\n-\t    tree newarglist;\n-\t    tree newop2 = NULL;\n-\t    tree oldwalker;\n-\t    tree newwalker;\n-\t    tree newexpr;\n+\t    tree oldfn = CALL_EXPR_FN (expr);\n+\t    tree oldsc = CALL_EXPR_STATIC_CHAIN (expr);\n+\t    tree newfn, newsc = NULL;\n+\t    tree newexpr = NULL_TREE;\n \t    tree vh = get_value_handle (expr);\n-\t    bool listchanged = false;\n \t    bool invariantarg = false;\n+\t    int i, nargs;\n \t    VEC (tree, gc) *vuses = VALUE_HANDLE_VUSES (vh);\n \t    VEC (tree, gc) *tvuses;\n \n-\t    /* Call expressions are kind of weird because they have an\n-\t       argument list.  We don't want to value number the list\n-\t       as one value number, because that doesn't make much\n-\t       sense, and just breaks the support functions we call,\n-\t       which expect TREE_OPERAND (call_expr, 2) to be a\n-\t       TREE_LIST. */\n-\t    oldval0 = find_leader_in_sets (oldop0, set1, set2);\n-\t    newop0 = phi_translate (oldval0, set1, set2, pred, phiblock);\n-\t    if (newop0 == NULL)\n+\t    newfn = phi_translate (find_leader_in_sets (oldfn, set1, set2),\n+\t\t\t\t   set1, set2, pred, phiblock);\n+\t    if (newfn == NULL)\n \t      return NULL;\n-\t    if (oldop2)\n+\t    if (newfn != oldfn)\n \t      {\n-\t\toldop2 = find_leader_in_sets (oldop2, set1, set2);\n-\t\tnewop2 = phi_translate (oldop2, set1, set2, pred, phiblock);\n-\t\tif (newop2 == NULL)\n+\t\tnewexpr = temp_copy_call_expr (expr);\n+\t\tCALL_EXPR_FN (newexpr) = get_value_handle (newfn);\n+\t      }\n+\t    if (oldsc)\n+\t      {\n+\t\tnewsc = phi_translate (find_leader_in_sets (oldsc, set1, set2),\n+\t\t\t\t       set1, set2, pred, phiblock);\n+\t\tif (newsc == NULL)\n \t\t  return NULL;\n+\t\tif (newsc != oldsc)\n+\t\t  {\n+\t\t    if (!newexpr)\n+\t\t      newexpr = temp_copy_call_expr (expr);\n+\t\t    CALL_EXPR_STATIC_CHAIN (newexpr) = get_value_handle (newsc);\n+\t\t  }\n \t      }\n \n-\t    /* phi translate the argument list piece by piece.\n-\n-\t      We could actually build the list piece by piece here,\n-\t      but it's likely to not be worth the memory we will save,\n-\t      unless you have millions of call arguments.  */\n-\n-\t    newarglist = pool_copy_list (oldarglist);\n-\t    for (oldwalker = oldarglist, newwalker = newarglist;\n-\t\t oldwalker && newwalker;\n-\t\t oldwalker = TREE_CHAIN (oldwalker),\n-\t\t   newwalker = TREE_CHAIN (newwalker))\n+\t    /* phi translate the argument list piece by piece.  */\n+\t    nargs = call_expr_nargs (expr);\n+\t    for (i = 0; i < nargs; i++)\n \t      {\n-\n-\t\ttree oldval = TREE_VALUE (oldwalker);\n+\t\ttree oldval = CALL_EXPR_ARG (expr, i);\n \t\ttree newval;\n \t\tif (oldval)\n \t\t  {\n@@ -1081,40 +1058,36 @@ phi_translate (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t      return NULL;\n \t\t    if (newval != oldval)\n \t\t      {\n-\t\t\tlistchanged = true;\n \t\t\tinvariantarg |= is_gimple_min_invariant (newval);\n-\t\t\tTREE_VALUE (newwalker) = get_value_handle (newval);\n+\t\t\tif (!newexpr)\n+\t\t\t  newexpr = temp_copy_call_expr (expr);\n+\t\t\tCALL_EXPR_ARG (newexpr, i) = get_value_handle (newval);\n \t\t      }\n \t\t  }\n \t      }\n \n \t    /* In case of new invariant args we might try to fold the call\n \t       again.  */\n-\t    if (invariantarg)\n+\t    if (invariantarg && !newsc)\n \t      {\n-\t\ttree tmp = fold_ternary (CALL_EXPR, TREE_TYPE (expr),\n-\t\t\t\t\t newop0, newarglist, newop2);\n-\t\tif (tmp)\n+\t\ttree tmp1 = build_call_array (TREE_TYPE (expr),\n+\t\t\t\t\t      newfn, call_expr_nargs (newexpr),\n+\t\t\t\t\t      CALL_EXPR_ARGP (newexpr));\n+\t\ttree tmp2 = fold (tmp1);\n+\t\tif (tmp2 != tmp1)\n \t\t  {\n-\t\t    STRIP_TYPE_NOPS (tmp);\n-\t\t    if (is_gimple_min_invariant (tmp))\n-\t\t      return tmp;\n+\t\t    STRIP_TYPE_NOPS (tmp2);\n+\t\t    if (is_gimple_min_invariant (tmp2))\n+\t\t      return tmp2;\n \t\t  }\n \t      }\n \n-\t    if (listchanged)\n-\t      vn_lookup_or_add (newarglist, NULL);\n-\n \t    tvuses = translate_vuses_through_block (vuses, phiblock, pred);\n+\t    if (vuses != tvuses && ! newexpr)\n+ \t      newexpr = temp_copy_call_expr (expr);\n \n-\t    if (listchanged || (newop0 != oldop0) || (oldop2 != newop2)\n-\t\t|| vuses != tvuses)\n+ \t    if (newexpr)\n \t      {\n-\t\tnewexpr = (tree) pool_alloc (expression_node_pool);\n-\t\tmemcpy (newexpr, expr, tree_size (expr));\n-\t\tTREE_OPERAND (newexpr, 0) = newop0 == oldop0 ? oldval0 : get_value_handle (newop0);\n-\t\tTREE_OPERAND (newexpr, 1) = listchanged ? newarglist : oldarglist;\n-\t\tTREE_OPERAND (newexpr, 2) = newop2 == oldop2 ? oldval2 : get_value_handle (newop2);\n \t\tnewexpr->base.ann = NULL;\n \t\tvn_lookup_or_add_with_vuses (newexpr, tvuses);\n \t\texpr = newexpr;\n@@ -1498,22 +1471,25 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, tree expr,\n       }\n \n     case tcc_expression:\n+      return false;\n+\n+    case tcc_vl_exp:\n       {\n \tif (TREE_CODE (expr) == CALL_EXPR)\n \t  {\n-\t    tree op0 = TREE_OPERAND (expr, 0);\n-\t    tree arglist = TREE_OPERAND (expr, 1);\n-\t    tree op2 = TREE_OPERAND (expr, 2);\n-\n-\t    /* Check the non-list operands first.  */\n-\t    if (!union_contains_value (set1, set2, op0)\n-\t\t|| (op2 && !union_contains_value (set1, set2, op2)))\n+\t    tree fn = CALL_EXPR_FN (expr);\n+\t    tree sc = CALL_EXPR_STATIC_CHAIN (expr);\n+\t    tree arg;\n+\t    call_expr_arg_iterator iter;\n+\n+\t    /* Check the non-argument operands first.  */\n+\t    if (!union_contains_value (set1, set2, fn)\n+\t\t|| (sc && !union_contains_value (set1, set2, sc)))\n \t      return false;\n \n \t    /* Now check the operands.  */\n-\t    for (; arglist; arglist = TREE_CHAIN (arglist))\n+\t    FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n \t      {\n-\t\ttree arg = TREE_VALUE (arglist);\n \t\tif (!union_contains_value (set1, set2, arg))\n \t\t  return false;\n \t      }\n@@ -2512,39 +2488,35 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n-    case tcc_expression:\n+    case tcc_vl_exp:\n       {\n-\ttree op0, op2;\n-\ttree arglist;\n-\ttree genop0, genop2;\n-\ttree genarglist;\n-\ttree walker, genwalker;\n+\ttree fn, sc;\n+\ttree genfn;\n+\tint i, nargs;\n+\ttree *buffer;\n \n \tgcc_assert (TREE_CODE (expr) == CALL_EXPR);\n-\tgenop2 = NULL;\n \n-\top0 = TREE_OPERAND (expr, 0);\n-\targlist = TREE_OPERAND (expr, 1);\n-\top2 = TREE_OPERAND (expr, 2);\n+\tfn = CALL_EXPR_FN (expr);\n+\tsc = CALL_EXPR_STATIC_CHAIN (expr);\n+\n+\tgenfn = find_or_generate_expression (block, fn, stmts);\n \n-\tgenop0 = find_or_generate_expression (block, op0, stmts);\n-\tgenarglist = copy_list (arglist);\n-\tfor (walker = arglist, genwalker = genarglist;\n-\t     genwalker && walker;\n-\t     genwalker = TREE_CHAIN (genwalker), walker = TREE_CHAIN (walker))\n+\tnargs = call_expr_nargs (expr);\n+\tbuffer = alloca (nargs * sizeof (tree));\n+\n+\tfor (i = 0; i < nargs; i++)\n \t  {\n-\t    TREE_VALUE (genwalker)\n-\t      = find_or_generate_expression (block, TREE_VALUE (walker),\n-\t\t\t\t\t     stmts);\n+\t    tree arg = CALL_EXPR_ARG (expr, i);\n+\t    buffer[i] = find_or_generate_expression (block, arg, stmts);\n \t  }\n \n-\tif (op2)\n-\t  genop2 = find_or_generate_expression (block, op2, stmts);\n-\tfolded = fold_build3 (TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t\t      genop0, genarglist, genop2);\n+\tfolded = build_call_array (TREE_TYPE (expr), genfn, nargs, buffer);\n+\tif (sc)\n+\t  CALL_EXPR_STATIC_CHAIN (folded) =\n+\t    find_or_generate_expression (block, sc, stmts);\n+\tfolded = fold (folded);\n \tbreak;\n-\n-\n       }\n       break;\n     case tcc_reference:\n@@ -3236,6 +3208,7 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \t      || TREE_CODE_CLASS (code) == tcc_comparison\n \t      || TREE_CODE_CLASS (code) == tcc_reference\n \t      || TREE_CODE_CLASS (code) == tcc_expression\n+\t      || TREE_CODE_CLASS (code) == tcc_vl_exp\n \t      || TREE_CODE_CLASS (code) == tcc_exceptional\n \t      || TREE_CODE_CLASS (code) == tcc_declaration);\n \n@@ -3247,64 +3220,18 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n     pool = binary_node_pool;\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n     pool = comparison_node_pool;\n-  else if (TREE_CODE_CLASS (code) == tcc_exceptional)\n-    {\n-      gcc_assert (code == TREE_LIST);\n-      pool = list_node_pool;\n-    }\n   else\n-    {\n-      gcc_assert (code == CALL_EXPR);\n-      pool = expression_node_pool;\n-    }\n+    gcc_assert (code == CALL_EXPR);\n \n-  vexpr = (tree) pool_alloc (pool);\n-  memcpy (vexpr, expr, tree_size (expr));\n-\n-  /* This case is only for TREE_LIST's that appear as part of\n-     CALL_EXPR's.  Anything else is a bug, but we can't easily verify\n-     this, hence this comment.  TREE_LIST is not handled by the\n-     general case below because they don't have a fixed length, or\n-     operands, so you can't access purpose/value/chain through\n-     TREE_OPERAND macros.  */\n-\n-  if (code == TREE_LIST)\n+  if (code == CALL_EXPR)\n+    vexpr = temp_copy_call_expr (expr);\n+  else\n     {\n-      tree op = NULL_TREE;\n-      tree temp = NULL_TREE;\n-      if (TREE_CHAIN (vexpr))\n-\ttemp = create_value_expr_from (TREE_CHAIN (vexpr), block, stmt);\n-      TREE_CHAIN (vexpr) = temp ? temp : TREE_CHAIN (vexpr);\n-\n-\n-      /* Recursively value-numberize reference ops.  */\n-      if (REFERENCE_CLASS_P (TREE_VALUE (vexpr)))\n-\t{\n-\t  tree tempop;\n-\t  op = TREE_VALUE (vexpr);\n-\t  tempop = create_value_expr_from (op, block, stmt);\n-\t  op = tempop ? tempop : op;\n-\n-\t  TREE_VALUE (vexpr)  = vn_lookup_or_add (op, stmt);\n-\t}\n-      else\n-\t{\n-\t  op = TREE_VALUE (vexpr);\n-\t  TREE_VALUE (vexpr) = vn_lookup_or_add (TREE_VALUE (vexpr), NULL);\n-\t}\n-      /* This is the equivalent of inserting op into EXP_GEN like we\n-\t do below */\n-      if (!is_undefined_value (op))\n-\tbitmap_value_insert_into_set (EXP_GEN (block), op);\n-\n-      efi = find_existing_value_expr (vexpr, stmt);\n-      if (efi)\n-\treturn efi;\n-      get_or_alloc_expression_id (vexpr);\n-      return vexpr;\n+      vexpr = (tree) pool_alloc (pool);\n+      memcpy (vexpr, expr, tree_size (expr));\n     }\n \n-  for (i = 0; i < TREE_CODE_LENGTH (code); i++)\n+  for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     {\n       tree val, op;\n \n@@ -3319,20 +3246,6 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n \t  op = tempop ? tempop : op;\n \t  val = vn_lookup_or_add (op, stmt);\n \t}\n-      else if (TREE_CODE (op) == TREE_LIST)\n-\t{\n-\t  tree tempop;\n-\n-\t  gcc_assert (TREE_CODE (expr) == CALL_EXPR);\n-\t  tempop = create_value_expr_from (op, block, stmt);\n-\n-\t  op = tempop ? tempop : op;\n-\t  vn_lookup_or_add (op, NULL);\n-\t  /* Unlike everywhere else, we do *not* want to replace the\n-\t     TREE_LIST itself with a value number, because support\n-\t     functions we call will blow up.  */\n-\t  val = op;\n-\t}\n       else\n \t/* Create a value handle for OP and add it to VEXPR.  */\n \tval = vn_lookup_or_add (op, NULL);\n@@ -4100,15 +4013,12 @@ init_pre (bool do_fre)\n \t\t\t\t       tree_code_size (NEGATE_EXPR), 30);\n   reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n \t\t\t\t\t   tree_code_size (ARRAY_REF), 30);\n-  expression_node_pool = create_alloc_pool (\"Expression tree nodes\",\n-\t\t\t\t\t    tree_code_size (CALL_EXPR), 30);\n-  list_node_pool = create_alloc_pool (\"List tree nodes\",\n-\t\t\t\t      tree_code_size (TREE_LIST), 30);\n   comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n \t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n   modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n \t\t\t\t\t     tree_code_size (GIMPLE_MODIFY_STMT),\n-\t\t\t\t\t     30);\n+  \t\t\t\t\t     30);\n+  obstack_init (&temp_call_expr_obstack);\n   modify_expr_template = NULL;\n \n   FOR_ALL_BB (bb)\n@@ -4140,8 +4050,6 @@ fini_pre (bool do_fre)\n   free_alloc_pool (binary_node_pool);\n   free_alloc_pool (reference_node_pool);\n   free_alloc_pool (unary_node_pool);\n-  free_alloc_pool (list_node_pool);\n-  free_alloc_pool (expression_node_pool);\n   free_alloc_pool (comparison_node_pool);\n   free_alloc_pool (modify_expr_node_pool);\n   htab_delete (phi_translate_table);"}, {"sha": "32a66eb00153e30426f2e7e26e276211bb4bae5e", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -233,6 +233,7 @@ get_rank (tree e)\n       tree rhs;\n       long rank, maxrank;\n       int i;\n+      int n;\n \n       if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n \t  && SSA_NAME_IS_DEFAULT_DEF (e))\n@@ -256,12 +257,13 @@ get_rank (tree e)\n       rank = 0;\n       maxrank = bb_rank[bb_for_stmt(stmt)->index];\n       rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-      if (TREE_CODE_LENGTH (TREE_CODE (rhs)) == 0)\n+      n = TREE_OPERAND_LENGTH (rhs);\n+      if (n == 0)\n \trank = MAX (rank, get_rank (rhs));\n       else\n \t{\n \t  for (i = 0;\n-\t       i < TREE_CODE_LENGTH (TREE_CODE (rhs))\n+\t       i < n\n \t\t && TREE_OPERAND (rhs, i)\n \t\t && rank != maxrank;\n \t       i++)"}, {"sha": "a6a2a68c3caa104e07df6ca312e74603b9733423", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -2512,6 +2512,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n   switch (TREE_CODE_CLASS (TREE_CODE (t)))\n     {\n     case tcc_expression:\n+    case tcc_vl_exp:\n       {\n \tswitch (TREE_CODE (t))\n \t  {\n@@ -3339,7 +3340,8 @@ find_func_aliases (tree origt)\n     {\n       tree lhsop;\n       tree rhsop;\n-      tree arglist;\n+      tree arg;\n+      call_expr_arg_iterator iter;\n       varinfo_t fi;\n       int i = 1;\n       tree decl;\n@@ -3364,17 +3366,15 @@ find_func_aliases (tree origt)\n \t}\n       else\n \t{\n-\t  decl = TREE_OPERAND (rhsop, 0);\n+\t  decl = CALL_EXPR_FN (rhsop);\n \t  fi = get_vi_for_tree (decl);\n \t}\n \n       /* Assign all the passed arguments to the appropriate incoming\n \t parameters of the function.  */\n-      arglist = TREE_OPERAND (rhsop, 1);\n \n-      for (;arglist; arglist = TREE_CHAIN (arglist))\n-\t{\n-\t  tree arg = TREE_VALUE (arglist);\n+      FOR_EACH_CALL_EXPR_ARG (arg, iter, rhsop)\n+ \t{\n \t  struct constraint_expr lhs ;\n \t  struct constraint_expr *rhsp;\n \n@@ -3455,6 +3455,7 @@ find_func_aliases (tree origt)\n \t\t  case tcc_constant:\n \t\t  case tcc_exceptional:\n \t\t  case tcc_expression:\n+\t\t  case tcc_vl_exp:\n \t\t  case tcc_unary:\n \t\t      {\n \t\t\tunsigned int j;\n@@ -3488,7 +3489,7 @@ find_func_aliases (tree origt)\n \t\t     to process expressions other than simple operands\n \t\t     (e.g. INDIRECT_REF, ADDR_EXPR, CALL_EXPR).  */\n \t\t  default:\n-\t\t    for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (rhsop)); i++)\n+\t\t    for (i = 0; i < TREE_OPERAND_LENGTH (rhsop); i++)\n \t\t      {\n \t\t\ttree op = TREE_OPERAND (rhsop, i);\n \t\t\tunsigned int j;"}, {"sha": "e7cd4a17c2ecfbb4c0dfe465e107e33c2d77101a", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -935,10 +935,12 @@ tree_ssa_useless_type_conversion (tree expr)\n   if (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR\n       || TREE_CODE (expr) == VIEW_CONVERT_EXPR\n       || TREE_CODE (expr) == NON_LVALUE_EXPR)\n-    return tree_ssa_useless_type_conversion_1 (TREE_TYPE (expr),\n-\t\t\t\t\t       TREE_TYPE (TREE_OPERAND (expr,\n-\t\t\t\t\t\t\t\t\t0)));\n-\n+    /* FIXME: Use of GENERIC_TREE_TYPE here is a temporary measure to work\n+       around known bugs with GIMPLE_MODIFY_STMTs appearing in places\n+       they shouldn't.  See PR 30391.  */\n+    return tree_ssa_useless_type_conversion_1\n+      (TREE_TYPE (expr),\n+       GENERIC_TREE_TYPE (TREE_OPERAND (expr, 0)));\n \n   return false;\n }"}, {"sha": "44227e8b0f9fb9ef8efbe533e01a0344d702bcbf", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -660,7 +660,7 @@ execute_optimize_stdarg (void)\n \t    }\n \n \t  si.va_start_count++;\n-\t  ap = TREE_VALUE (TREE_OPERAND (call, 1));\n+\t  ap = CALL_EXPR_ARG (call, 0);\n \n \t  if (TREE_CODE (ap) != ADDR_EXPR)\n \t    {"}, {"sha": "7889cbb864481b3821d67ccc3f8bf8fee353262a", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -374,7 +374,7 @@ propagate_through_phis (tree var, edge e)\n static void\n find_tail_calls (basic_block bb, struct tailcall **ret)\n {\n-  tree ass_var, ret_var, stmt, func, param, args, call = NULL_TREE;\n+  tree ass_var, ret_var, stmt, func, param, call = NULL_TREE;\n   block_stmt_iterator bsi, absi;\n   bool tail_recursion;\n   struct tailcall *nw;\n@@ -433,11 +433,13 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   func = get_callee_fndecl (call);\n   if (func == current_function_decl)\n     {\n-      for (param = DECL_ARGUMENTS (func), args = TREE_OPERAND (call, 1);\n-\t   param && args;\n-\t   param = TREE_CHAIN (param), args = TREE_CHAIN (args))\n+      call_expr_arg_iterator iter;\n+      tree arg;\n+      for (param = DECL_ARGUMENTS (func),\n+\t     arg = first_call_expr_arg (call, &iter);\n+\t   param && arg;\n+\t   param = TREE_CHAIN (param), arg = next_call_expr_arg (&iter))\n \t{\n-\t  tree arg = TREE_VALUE (args);\n \t  if (param != arg)\n \t    {\n \t      /* Make sure there are no problems with copying.  The parameter\n@@ -460,7 +462,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t\tbreak;\n \t    }\n \t}\n-      if (!args && !param)\n+      if (!arg && !param)\n \ttail_recursion = true;\n     }\n \n@@ -714,7 +716,9 @@ arg_needs_copy_p (tree param)\n static void\n eliminate_tail_call (struct tailcall *t)\n {\n-  tree param, stmt, args, rslt, call;\n+  tree param, stmt, rslt, call;\n+  tree arg;\n+  call_expr_arg_iterator iter;\n   basic_block bb, first;\n   edge e;\n   tree phi;\n@@ -769,17 +773,16 @@ eliminate_tail_call (struct tailcall *t)\n   /* Add phi node entries for arguments.  The ordering of the phi nodes should\n      be the same as the ordering of the arguments.  */\n   for (param = DECL_ARGUMENTS (current_function_decl),\n-       args = TREE_OPERAND (stmt, 1),\n-       phi = phi_nodes (first);\n+\t arg = first_call_expr_arg (stmt, &iter),\n+\t phi = phi_nodes (first);\n        param;\n-       param = TREE_CHAIN (param),\n-       args = TREE_CHAIN (args))\n+       param = TREE_CHAIN (param), arg = next_call_expr_arg (&iter))\n     {\n       if (!arg_needs_copy_p (param))\n \tcontinue;\n       gcc_assert (param == SSA_NAME_VAR (PHI_RESULT (phi)));\n \n-      add_phi_arg (phi, TREE_VALUE (args), e);\n+      add_phi_arg (phi, arg, e);\n       phi = PHI_CHAIN (phi);\n     }\n "}, {"sha": "30741952b7fe392562fa23b2388e0004ae965cf4", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -434,7 +434,7 @@ vect_recog_pow_pattern (tree last_stmt, tree *type_in, tree *type_out)\n {\n   tree expr;\n   tree type;\n-  tree fn, arglist, base, exp;\n+  tree fn, base, exp;\n \n   if (TREE_CODE (last_stmt) != GIMPLE_MODIFY_STMT)\n     return NULL;\n@@ -446,15 +446,14 @@ vect_recog_pow_pattern (tree last_stmt, tree *type_in, tree *type_out)\n     return NULL_TREE;\n \n   fn = get_callee_fndecl (expr);\n-  arglist = TREE_OPERAND (expr, 1);\n   switch (DECL_FUNCTION_CODE (fn))\n     {\n     case BUILT_IN_POWIF:\n     case BUILT_IN_POWI:\n     case BUILT_IN_POWF:\n     case BUILT_IN_POW:\n-      base = TREE_VALUE (arglist);\n-      exp = TREE_VALUE (TREE_CHAIN (arglist));\n+      base = CALL_EXPR_ARG (expr, 0);\n+      exp = CALL_EXPR_ARG (expr, 1);\n       if (TREE_CODE (exp) != REAL_CST\n \t  && TREE_CODE (exp) != INTEGER_CST)\n         return NULL_TREE;\n@@ -484,11 +483,10 @@ vect_recog_pow_pattern (tree last_stmt, tree *type_in, tree *type_out)\n       && REAL_VALUES_EQUAL (TREE_REAL_CST (exp), dconsthalf))\n     {\n       tree newfn = mathfn_built_in (TREE_TYPE (base), BUILT_IN_SQRT);\n-      tree newarglist = build_tree_list (NULL_TREE, base);\n       *type_in = get_vectype_for_scalar_type (TREE_TYPE (base));\n       if (*type_in)\n \t{\n-\t  newfn = build_function_call_expr (newfn, newarglist);\n+\t  newfn = build_call_expr (newfn, 1, base);\n \t  if (vectorizable_function (newfn, *type_in, *type_in) != NULL_TREE)\n \t    return newfn;\n \t}"}, {"sha": "bcb248d1d33eb5167ecd269bf6030eee06545132", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1143,7 +1143,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   tree operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   int op_type;\n   \n-  op_type = TREE_CODE_LENGTH (TREE_CODE (operation));\n+  op_type = TREE_OPERAND_LENGTH (operation);\n   reduction_op = TREE_OPERAND (operation, op_type-1);\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n   mode = TYPE_MODE (vectype);\n@@ -1557,7 +1557,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   operation = GIMPLE_STMT_OPERAND (stmt, 1);\n   code = TREE_CODE (operation);\n-  op_type = TREE_CODE_LENGTH (code);\n+  op_type = TREE_OPERAND_LENGTH (operation);\n   if (op_type != binary_op && op_type != ternary_op)\n     return false;\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n@@ -1803,13 +1803,14 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree vec_dest;\n   tree scalar_dest;\n   tree operation;\n-  tree args, type;\n+  tree op, type;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt), prev_stmt_info;\n   tree vectype_out, vectype_in;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree fndecl, rhs, new_temp, def, def_stmt, rhs_type, lhs_type;\n   enum vect_def_type dt[2];\n   int ncopies, j, nargs;\n+  call_expr_arg_iterator iter;\n \n   /* Is STMT a vectorizable call?   */\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n@@ -1824,15 +1825,15 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   /* Process function arguments.  */\n   rhs_type = NULL_TREE;\n-  for (args = TREE_OPERAND (operation, 1), nargs = 0;\n-       args; args = TREE_CHAIN (args), ++nargs)\n+  nargs = 0;\n+  FOR_EACH_CALL_EXPR_ARG (op, iter, operation)\n     {\n-      tree op = TREE_VALUE (args);\n+      ++nargs;\n \n       /* Bail out if the function has more than two arguments, we\n \t do not have interesting builtin functions to vectorize with\n \t more than two arguments.  */\n-      if (nargs >= 2)\n+      if (nargs > 2)\n \treturn false;\n \n       /* We can only handle calls with arguments of the same type.  */\n@@ -1911,11 +1912,13 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       int n;\n \n       /* Build argument list for the vectorized call.  */\n+      /* FIXME: Rewrite this so that it doesn't construct a temporary\n+\t  list.  */\n       vargs = NULL_TREE;\n-      for (args = TREE_OPERAND (operation, 1), n = 0;\n-\t   args; args = TREE_CHAIN (args), ++n)\n+      n = -1;\n+      FOR_EACH_CALL_EXPR_ARG (op, iter, operation)\n \t{\n-\t  tree op = TREE_VALUE (args);\n+\t  ++n;\n \n \t  if (j == 0)\n \t    vec_oprnd[n] = vect_get_vec_def_for_operand (op, stmt, NULL);\n@@ -1979,7 +1982,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   int ncopies, j;\n   tree vectype_out, vectype_in;\n   tree rhs_type, lhs_type;\n-  tree builtin_decl, params;\n+  tree builtin_decl;\n   stmt_vec_info prev_stmt_info;\n \n   /* Is STMT a vectorizable conversion?   */\n@@ -2073,11 +2076,10 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n \tvec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n       else\n \tvec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n-      params = build_tree_list (NULL_TREE, vec_oprnd0);\n \n       builtin_decl =\n \ttargetm.vectorize.builtin_conversion (code, vectype_in);\n-      new_stmt = build_function_call_expr (builtin_decl, params);\n+      new_stmt = build_call_expr (builtin_decl, 1, vec_oprnd0);\n \n       /* Arguments are ready. create the new vector stmt.  */\n       new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n@@ -2272,7 +2274,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   optab = optab_for_tree_code (code, vectype);\n \n   /* Support only unary or binary operations.  */\n-  op_type = TREE_CODE_LENGTH (code);\n+  op_type = TREE_OPERAND_LENGTH (operation);\n   if (op_type != unary_op && op_type != binary_op)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2642,7 +2644,6 @@ vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n                                tree vec_dest, block_stmt_iterator *bsi,\n \t\t\t       tree stmt)\n { \n-  tree vec_params;\n   tree expr; \n   tree new_stmt; \n   tree new_temp; \n@@ -2653,10 +2654,10 @@ vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n   if (code == CALL_EXPR) \n     {  \n       /* Target specific support  */ \n-      vec_params = build_tree_list (NULL_TREE, vec_oprnd0); \n-      if (op_type == binary_op) \n-        vec_params = tree_cons (NULL_TREE, vec_oprnd1, vec_params); \n-      expr = build_function_call_expr (decl, vec_params); \n+      if (op_type == binary_op)\n+\texpr = build_call_expr (decl, 2, vec_oprnd0, vec_oprnd1);\n+      else\n+\texpr = build_call_expr (decl, 1, vec_oprnd0);\n     } \n   else \n     { \n@@ -3378,10 +3379,9 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n   if (targetm.vectorize.builtin_mask_for_load)\n     {\n       tree builtin_decl;\n-      tree params = build_tree_list (NULL_TREE, init_addr);\n \n       builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n-      new_stmt = build_function_call_expr (builtin_decl, params);\n+      new_stmt = build_call_expr (builtin_decl, 1, init_addr);\n       vec_dest = vect_create_destination_var (scalar_dest, \n \t\t\t\t\t      TREE_TYPE (new_stmt));\n       new_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, vec_dest,\n@@ -4011,7 +4011,6 @@ vectorizable_live_operation (tree stmt,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   int i;\n-  enum tree_code code;\n   int op_type;\n   tree op;\n   tree def, def_stmt;\n@@ -4027,9 +4026,7 @@ vectorizable_live_operation (tree stmt,\n     return false;\n \n   operation = GIMPLE_STMT_OPERAND (stmt, 1);\n-  code = TREE_CODE (operation);\n-\n-  op_type = TREE_CODE_LENGTH (code);\n+  op_type = TREE_OPERAND_LENGTH (operation);\n \n   /* FORNOW: support only if all uses are invariant. This means\n      that the scalar operations can remain in place, unvectorized."}, {"sha": "fab57234ed9b8466a2d2475eb4d10fb263b70913", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1975,7 +1975,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n       return NULL_TREE;\n     }\n \n-  op_type = TREE_CODE_LENGTH (code);\n+  op_type = TREE_OPERAND_LENGTH (operation);\n   if (op_type != binary_op)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "b3223a5e59bcdbe54cf18228173a5580ab538710", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -3747,9 +3747,9 @@ stmt_interesting_for_vrp (tree stmt)\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n \t  && ((TREE_CODE (rhs) == CALL_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (rhs, 0)) == ADDR_EXPR\n-\t       && DECL_P (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0))\n-\t       && DECL_IS_BUILTIN (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0)))\n+\t       && TREE_CODE (CALL_EXPR_FN (rhs)) == ADDR_EXPR\n+\t       && DECL_P (TREE_OPERAND (CALL_EXPR_FN (rhs), 0))\n+\t       && DECL_IS_BUILTIN (TREE_OPERAND (CALL_EXPR_FN (rhs), 0)))\n \t      || ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS)))\n \treturn true;\n     }\n@@ -4242,9 +4242,9 @@ vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n \t for deriving ranges, with the obvious exception of calls to\n \t builtin functions.  */\n       if ((TREE_CODE (rhs) == CALL_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == ADDR_EXPR\n-\t   && DECL_P (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0))\n-\t   && DECL_IS_BUILTIN (TREE_OPERAND (TREE_OPERAND (rhs, 0), 0)))\n+\t   && TREE_CODE (CALL_EXPR_FN (rhs)) == ADDR_EXPR\n+\t   && DECL_P (TREE_OPERAND (CALL_EXPR_FN (rhs), 0))\n+\t   && DECL_IS_BUILTIN (TREE_OPERAND (CALL_EXPR_FN (rhs), 0)))\n \t  || ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n \treturn vrp_visit_assignment (stmt, output_p);\n     }"}, {"sha": "842e1d032ca8b6faeb808a211a5ce5519717e7eb", "filename": "gcc/tree.c", "status": "modified", "additions": 278, "deletions": 38, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -66,7 +66,9 @@ const char *const tree_code_class_strings[] =\n   \"unary\",\n   \"binary\",\n   \"statement\",\n+  \"vl_exp\",\n   \"expression\",\n+  \"gimple_stmt\"\n };\n \n /* obstack.[ch] explicitly declined to prototype this.  */\n@@ -337,8 +339,8 @@ decl_assembler_name_equal (tree decl, tree asmname)\n }\n \n /* Compute the number of bytes occupied by a tree with code CODE.\n-   This function cannot be used for TREE_VEC, PHI_NODE, or STRING_CST\n-   codes, which are of variable length.  */\n+   This function cannot be used for nodes that have variable sizes,\n+   including TREE_VEC, PHI_NODE, STRING_CST, and CALL_EXPR.  */\n size_t\n tree_code_size (enum tree_code code)\n {\n@@ -386,7 +388,7 @@ tree_code_size (enum tree_code code)\n     case tcc_unary:       /* a unary arithmetic expression */\n     case tcc_binary:      /* a binary arithmetic expression */\n       return (sizeof (struct tree_exp)\n-\t      + (TREE_CODE_LENGTH (code) - 1) * sizeof (char *));\n+\t      + (TREE_CODE_LENGTH (code) - 1) * sizeof (tree));\n \n     case tcc_gimple_stmt:\n       return (sizeof (struct gimple_stmt)\n@@ -434,7 +436,7 @@ tree_code_size (enum tree_code code)\n }\n \n /* Compute the number of bytes occupied by NODE.  This routine only\n-   looks at TREE_CODE, except for PHI_NODE and TREE_VEC nodes.  */\n+   looks at TREE_CODE, except for those nodes that have variable sizes.  */\n size_t\n tree_size (tree node)\n {\n@@ -451,7 +453,7 @@ tree_size (tree node)\n \n     case TREE_VEC:\n       return (sizeof (struct tree_vec)\n-\t      + (TREE_VEC_LENGTH (node) - 1) * sizeof(char *));\n+\t      + (TREE_VEC_LENGTH (node) - 1) * sizeof (tree));\n \n     case STRING_CST:\n       return TREE_STRING_LENGTH (node) + offsetof (struct tree_string, str) + 1;\n@@ -462,7 +464,11 @@ tree_size (tree node)\n \t        * sizeof (tree));\n \n     default:\n-      return tree_code_size (code);\n+      if (TREE_CODE_CLASS (code) == tcc_vl_exp)\n+\treturn (sizeof (struct tree_exp)\n+\t\t+ (VL_EXP_OPERAND_LENGTH (node) - 1) * sizeof (tree));\n+      else\n+\treturn tree_code_size (code);\n     }\n }\n \n@@ -2166,6 +2172,7 @@ tree_node_structure (tree t)\n     case tcc_binary:\n     case tcc_expression:\n     case tcc_statement:\n+    case tcc_vl_exp:\n       return TS_EXP;\n     case tcc_gimple_stmt:\n       return TS_GIMPLE_STATEMENT;\n@@ -2247,9 +2254,6 @@ contains_placeholder_p (tree exp)\n \t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1))\n \t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 2)));\n \n-\tcase CALL_EXPR:\n-\t  return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1));\n-\n \tdefault:\n \t  break;\n \t}\n@@ -2265,6 +2269,22 @@ contains_placeholder_p (tree exp)\n \t  return 0;\n \t}\n \n+    case tcc_vl_exp:\n+      switch (code)\n+\t{\n+\tcase CALL_EXPR:\n+\t  {\n+\t    tree arg;\n+\t    call_expr_arg_iterator iter;\n+\t    FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+\t      if (CONTAINS_PLACEHOLDER_P (arg))\n+\t\treturn 1;\n+\t    return 0;\n+\t  }\n+\tdefault:\n+\t  return 0;\n+\t}\n+\n     default:\n       return 0;\n     }\n@@ -2472,6 +2492,27 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t  }\n \tbreak;\n \n+      case tcc_vl_exp:\n+\t{\n+\t  tree copy = NULL_TREE;\n+\t  int i;\n+\t  int n = TREE_OPERAND_LENGTH (exp);\n+\t  for (i = 1; i < n; i++)\n+\t    {\n+\t      tree op = TREE_OPERAND (exp, i);\n+\t      tree newop = SUBSTITUTE_IN_EXPR (op, f, r);\n+\t      if (newop != op)\n+\t\t{\n+\t\t  copy = copy_node (exp);\n+\t\t  TREE_OPERAND (copy, i) = newop;\n+\t\t}\n+\t    }\n+\t  if (copy)\n+\t    new = fold (copy);\n+\t  else\n+\t    return exp;\n+\t}\n+\n       default:\n \tgcc_unreachable ();\n       }\n@@ -2503,6 +2544,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t\t  : (REFERENCE_CLASS_P (elt)\n \t\t     || UNARY_CLASS_P (elt)\n \t\t     || BINARY_CLASS_P (elt)\n+\t\t     || VL_EXP_CLASS_P (elt)\n \t\t     || EXPRESSION_CLASS_P (elt))\n \t\t  ? TREE_OPERAND (elt, 0) : 0))\n \tif (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n@@ -2515,6 +2557,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t\t  : (REFERENCE_CLASS_P (elt)\n \t\t     || UNARY_CLASS_P (elt)\n \t\t     || BINARY_CLASS_P (elt)\n+\t\t     || VL_EXP_CLASS_P (elt)\n \t\t     || EXPRESSION_CLASS_P (elt))\n \t\t  ? TREE_OPERAND (elt, 0) : 0))\n \tif (POINTER_TYPE_P (TREE_TYPE (elt))\n@@ -2602,6 +2645,28 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t  }\n \tbreak;\n \n+      case tcc_vl_exp:\n+\t{\n+\t  tree copy = NULL_TREE;\n+\t  int i;\n+\t  int n = TREE_OPERAND_LENGTH (exp);\n+\t  for (i = 1; i < n; i++)\n+\t    {\n+\t      tree op = TREE_OPERAND (exp, i);\n+\t      tree newop = SUBSTITUTE_PLACEHOLDER_IN_EXPR (op, obj);\n+\t      if (newop != op)\n+\t\t{\n+\t\t  if (!copy)\n+\t\t    copy = copy_node (exp);\n+\t\t  TREE_OPERAND (copy, i) = newop;\n+\t\t}\n+\t    }\n+\t  if (copy)\n+\t    return fold (copy);\n+\t  else\n+\t    return exp;\n+\t}\n+\n       default:\n \tgcc_unreachable ();\n       }\n@@ -2727,6 +2792,7 @@ stabilize_reference_1 (tree e)\n     case tcc_statement:\n     case tcc_expression:\n     case tcc_reference:\n+    case tcc_vl_exp:\n       /* If the expression has side-effects, then encase it in a SAVE_EXPR\n \t so that it will only be evaluated once.  */\n       /* The reference (r) and comparison (<) classes could be handled as\n@@ -3074,6 +3140,7 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   tree t;\n \n   gcc_assert (TREE_CODE_LENGTH (code) == 3);\n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n \n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n@@ -3084,26 +3151,6 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   PROCESS_ARG(1);\n   PROCESS_ARG(2);\n \n-  if (code == CALL_EXPR && !side_effects)\n-    {\n-      tree node;\n-      int i;\n-\n-      /* Calls have side-effects, except those to const or\n-\t pure functions.  */\n-      i = call_expr_flags (t);\n-      if (!(i & (ECF_CONST | ECF_PURE)))\n-\tside_effects = 1;\n-\n-      /* And even those have side-effects if their arguments do.  */\n-      else for (node = arg1; node; node = TREE_CHAIN (node))\n-\tif (TREE_SIDE_EFFECTS (TREE_VALUE (node)))\n-\t  {\n-\t    side_effects = 1;\n-\t    break;\n-\t  }\n-    }\n-\n   TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n     = (TREE_CODE_CLASS (code) == tcc_reference\n@@ -3209,6 +3256,8 @@ build_nt (enum tree_code code, ...)\n   int i;\n   va_list p;\n \n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n   va_start (p, code);\n \n   t = make_node (code);\n@@ -3220,6 +3269,23 @@ build_nt (enum tree_code code, ...)\n   va_end (p);\n   return t;\n }\n+\n+/* Similar to build_nt, but for creating a CALL_EXPR object with\n+   ARGLIST passed as a list.  */\n+\n+tree\n+build_nt_call_list (tree fn, tree arglist)\n+{\n+  tree t;\n+  int i;\n+\n+  t = build_vl_exp (CALL_EXPR, list_length (arglist) + 3);\n+  CALL_EXPR_FN (t) = fn;\n+  CALL_EXPR_STATIC_CHAIN (t) = NULL_TREE;\n+  for (i = 0; arglist; arglist = TREE_CHAIN (arglist), i++)\n+    CALL_EXPR_ARG (t, i) = TREE_VALUE (arglist);\n+  return t;\n+}\n \f\n /* Create a DECL_... node of code CODE, name NAME and data type TYPE.\n    We do NOT enter this node in any sort of symbol table.\n@@ -4916,11 +4982,26 @@ simple_cst_equal (tree t1, tree t2)\n       return simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n \n     case CALL_EXPR:\n-      cmp = simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+      cmp = simple_cst_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2));\n       if (cmp <= 0)\n \treturn cmp;\n-      return\n-\tsimple_cst_list_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+      if (call_expr_nargs (t1) != call_expr_nargs (t2))\n+\treturn 0;\n+      {\n+\ttree arg1, arg2;\n+\tcall_expr_arg_iterator iter1, iter2;\n+\tfor (arg1 = first_call_expr_arg (t1, &iter1),\n+\t       arg2 = first_call_expr_arg (t2, &iter2);\n+\t     arg1 && arg2;\n+\t     arg1 = next_call_expr_arg (&iter1),\n+\t       arg2 = next_call_expr_arg (&iter2))\n+\t  {\n+\t    cmp = simple_cst_equal (arg1, arg2);\n+\t    if (cmp <= 0)\n+\t      return cmp;\n+\t  }\n+\treturn arg1 == arg2;\n+      }\n \n     case TARGET_EXPR:\n       /* Special case: if either target is an unallocated VAR_DECL,\n@@ -5184,7 +5265,7 @@ iterative_hash_expr (tree t, hashval_t val)\n \t      val = iterative_hash_hashval_t (two, val);\n \t    }\n \t  else\n-\t    for (i = TREE_CODE_LENGTH (code) - 1; i >= 0; --i)\n+\t    for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n \t      val = iterative_hash_expr (TREE_OPERAND (t, i), val);\n \t}\n       return val;\n@@ -6246,7 +6327,7 @@ get_callee_fndecl (tree call)\n \n   /* The first operand to the CALL is the address of the function\n      called.  */\n-  addr = TREE_OPERAND (call, 0);\n+  addr = CALL_EXPR_FN (call);\n \n   STRIP_NOPS (addr);\n \n@@ -6665,15 +6746,16 @@ phi_node_elt_check_failed (int idx, int len, const char *file, int line,\n }\n \n /* Similar to above, except that the check is for the bounds of the operand\n-   vector of an expression node.  */\n+   vector of an expression node EXP.  */\n \n void\n-tree_operand_check_failed (int idx, enum tree_code code, const char *file,\n+tree_operand_check_failed (int idx, tree exp, const char *file,\n \t\t\t   int line, const char *function)\n {\n+  int code = TREE_CODE (exp);\n   internal_error\n     (\"tree check: accessed operand %d of %s with %d operands in %s, at %s:%d\",\n-     idx + 1, tree_code_name[code], TREE_CODE_LENGTH (code),\n+     idx + 1, tree_code_name[code], TREE_OPERAND_LENGTH (exp),\n      function, trim_filename (file), line);\n }\n \n@@ -7305,6 +7387,149 @@ build_omp_clause (enum omp_clause_code code)\n   return t;\n }\n \n+/* Set various status flags when building a CALL_EXPR object T.  */\n+\n+static void\n+process_call_operands (tree t)\n+{\n+  bool side_effects;\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+  if (!side_effects)\n+    {\n+      int i, n;\n+      n = TREE_OPERAND_LENGTH (t);\n+      for (i = 1; i < n; i++)\n+\t{\n+\t  tree op = TREE_OPERAND (t, i);\n+\t  if (op && TREE_SIDE_EFFECTS (op))\n+\t    {\n+\t      side_effects = 1;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  if (!side_effects)\n+    {\n+      int i;\n+\n+      /* Calls have side-effects, except those to const or\n+\t pure functions.  */\n+      i = call_expr_flags (t);\n+      if (!(i & (ECF_CONST | ECF_PURE)))\n+\tside_effects = 1;\n+    }\n+  TREE_SIDE_EFFECTS (t) = side_effects;\n+}\n+\n+/* Build a tcc_vl_exp object with code CODE and room for LEN operands.  LEN\n+   includes the implicit operand count in TREE_OPERAND 0, and so must be >= 1.\n+   Except for the CODE and operand count field, other storage for the\n+   object is initialized to zeros.  */\n+\n+tree\n+build_vl_exp_stat (enum tree_code code, int len MEM_STAT_DECL)\n+{\n+  tree t;\n+  int length = (len - 1) * sizeof (tree) + sizeof (struct tree_exp);\n+\n+  gcc_assert (TREE_CODE_CLASS (code) == tcc_vl_exp);\n+  gcc_assert (len >= 1);\n+\n+#ifdef GATHER_STATISTICS\n+  tree_node_counts[(int) e_kind]++;\n+  tree_node_sizes[(int) e_kind] += length;\n+#endif\n+\n+  t = ggc_alloc_zone_pass_stat (length, &tree_zone);\n+\n+  memset (t, 0, length);\n+\n+  TREE_SET_CODE (t, code);\n+\n+  /* Can't use TREE_OPERAND to store the length because if checking is\n+     enabled, it will try to check the length before we store it.  :-P  */\n+  t->exp.operands[0] = build_int_cst (sizetype, len);\n+\n+  return t;\n+}\n+\n+\n+/* Build a CALL_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE\n+   and FN and a null static chain slot.  ARGLIST is a TREE_LIST of the\n+   arguments.  */\n+\n+tree\n+build_call_list (tree return_type, tree fn, tree arglist)\n+{\n+  tree t;\n+  int i;\n+\n+  t = build_vl_exp (CALL_EXPR, list_length (arglist) + 3);\n+  TREE_TYPE (t) = return_type;\n+  CALL_EXPR_FN (t) = fn;\n+  CALL_EXPR_STATIC_CHAIN (t) = NULL_TREE;\n+  for (i = 0; arglist; arglist = TREE_CHAIN (arglist), i++)\n+    CALL_EXPR_ARG (t, i) = TREE_VALUE (arglist);\n+  process_call_operands (t);\n+  return t;\n+}\n+\n+/* Build a CALL_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE and\n+   FN and a null static chain slot.  NARGS is the number of call arguments\n+   which are specified as \"...\" arguments.  */\n+\n+tree\n+build_call_nary (tree return_type, tree fn, int nargs, ...)\n+{\n+  tree ret;\n+  va_list args;\n+  va_start (args, nargs);\n+  ret = build_call_valist (return_type, fn, nargs, args);\n+  va_end (args);\n+  return ret;\n+}\n+\n+/* Build a CALL_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE and\n+   FN and a null static chain slot.  NARGS is the number of call arguments\n+   which are specified as a va_list ARGS.  */\n+\n+tree\n+build_call_valist (tree return_type, tree fn, int nargs, va_list args)\n+{\n+  tree t;\n+  int i;\n+\n+  t = build_vl_exp (CALL_EXPR, nargs + 3);\n+  TREE_TYPE (t) = return_type;\n+  CALL_EXPR_FN (t) = fn;\n+  CALL_EXPR_STATIC_CHAIN (t) = NULL_TREE;\n+  for (i = 0; i < nargs; i++)\n+    CALL_EXPR_ARG (t, i) = va_arg (args, tree);\n+  process_call_operands (t);\n+  return t;\n+}\n+\n+/* Build a CALL_EXPR of class tcc_vl_exp with the indicated RETURN_TYPE and\n+   FN and a null static chain slot.  NARGS is the number of call arguments\n+   which are specified as a tree array ARGS.  */\n+\n+tree\n+build_call_array (tree return_type, tree fn, int nargs, tree *args)\n+{\n+  tree t;\n+  int i;\n+\n+  t = build_vl_exp (CALL_EXPR, nargs + 3);\n+  TREE_TYPE (t) = return_type;\n+  CALL_EXPR_FN (t) = fn;\n+  CALL_EXPR_STATIC_CHAIN (t) = NULL_TREE;\n+  for (i = 0; i < nargs; i++)\n+    CALL_EXPR_ARG (t, i) = args[i];\n+  process_call_operands (t);\n+  return t;\n+}\n+\n \n /* Returns true if it is possible to prove that the index of\n    an array access REF (an ARRAY_REF expression) falls into the\n@@ -7988,7 +8213,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n \t  int i, len;\n \n \t  /* Walk over all the sub-trees of this operand.  */\n-\t  len = TREE_CODE_LENGTH (code);\n+\t  len = TREE_OPERAND_LENGTH (*tp);\n \n \t  /* Go through the subtrees.  We need to do this in forward order so\n \t     that the scope of a FOR_EXPR is handled properly.  */\n@@ -8081,4 +8306,19 @@ generic_tree_type (tree node)\n   return &TREE_TYPE (node);\n }\n \n+/* Build and return a TREE_LIST of arguments in the CALL_EXPR exp.\n+   FIXME: don't use this function.  It exists for compatibility with\n+   the old representation of CALL_EXPRs where a list was used to hold the\n+   arguments.  Places that currently extract the arglist from a CALL_EXPR\n+   ought to be rewritten to use the CALL_EXPR itself.  */\n+tree\n+call_expr_arglist (tree exp)\n+{\n+  tree arglist = NULL_TREE;\n+  int i;\n+  for (i = call_expr_nargs (exp) - 1; i >= 0; i--)\n+    arglist = tree_cons (NULL_TREE, CALL_EXPR_ARG (exp, i), arglist);\n+  return arglist;\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "1789de839adf8facc6d6472a92c7a6e1a2d5237f", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -523,11 +523,13 @@ DEFTREECODE (VEC_COND_EXPR, \"vec_cond_expr\", tcc_expression, 3)\n    nodes for the function.  */\n DEFTREECODE (BIND_EXPR, \"bind_expr\", tcc_expression, 3)\n \n-/* Function call.  Operand 0 is the function.\n-   Operand 1 is the argument list, a list of expressions\n-   made out of a chain of TREE_LIST nodes.\n-   Operand 2 is the static chain argument, or NULL.  */\n-DEFTREECODE (CALL_EXPR, \"call_expr\", tcc_expression, 3)\n+/* Function call.  CALL_EXPRs are represented by variably-sized expression\n+   nodes.  There are at least three fixed operands.  Operand 0 is an\n+   INTEGER_CST node containing the total operand count, the number of\n+   arguments plus 3.  Operand 1 is the function, while operand 2 is\n+   is static chain argument, or NULL.  The remaining operands are the\n+   arguments to the call.  */\n+DEFTREECODE (CALL_EXPR, \"call_expr\", tcc_vl_exp, 3)\n \n /* Specify a value to compute along with its corresponding cleanup.\n    Operand 0 is the cleanup expression."}, {"sha": "2df9aabc8f376b105b863b2b1428982244a05b91", "filename": "gcc/tree.h", "status": "modified", "additions": 144, "deletions": 18, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -64,6 +64,8 @@ enum tree_code_class {\n   tcc_binary,      /* A binary arithmetic expression.  */\n   tcc_statement,   /* A statement expression, which have side effects\n \t\t      but usually no interesting value.  */\n+  tcc_vl_exp,      /* A function call or other expression with a\n+\t\t      variable-length operand vector.  */\n   tcc_expression,  /* Any other expression.  */\n   tcc_gimple_stmt  /* A GIMPLE statement.  */\n };\n@@ -149,6 +151,12 @@ extern const enum tree_code_class tree_code_type[];\n #define STATEMENT_CLASS_P(CODE)\\\n \t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_statement)\n \n+/* Nonzero if CODE represents a function call-like expression with a\n+   variable-length operand vector.  */\n+\n+#define VL_EXP_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_vl_exp)\n+\n /* Nonzero if CODE represents any other expression.  */\n \n #define EXPRESSION_CLASS_P(CODE)\\\n@@ -779,8 +787,8 @@ enum tree_node_structure_enum {\n     const int __i = (I);\t\t\t\t\t\t\\\n     if (GIMPLE_TUPLE_P (__t))\t\t\t\t\t\t\\\n       gcc_unreachable ();\t\t\t\t\t\t\\\n-    if (__i < 0 || __i >= TREE_CODE_LENGTH (TREE_CODE (__t)))\t\t\\\n-      tree_operand_check_failed (__i, TREE_CODE (__t),\t\t\t\\\n+    if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\t\t\t\\\n+      tree_operand_check_failed (__i, __t,\t\t\t\t\\\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n@@ -789,17 +797,17 @@ enum tree_node_structure_enum {\n     const int __i = (I);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != CODE)\t\t\t\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, (CODE), 0);\\\n-    if (__i < 0 || __i >= TREE_CODE_LENGTH (CODE))\t\t\t\\\n-      tree_operand_check_failed (__i, (CODE),\t\t\t\t\\\n+    if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\t\t\t\\\n+      tree_operand_check_failed (__i, __t,\t\t\t\t\\\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n /* Special checks for GIMPLE_STMT_OPERANDs.  */\n #define GIMPLE_STMT_OPERAND_CHECK(T, I) __extension__\t\t\t\\\n (*({const tree __t = GIMPLE_STMT_CHECK (T);\t\t\t\t\\\n     const int __i = (I);\t\t\t\t\t\t\\\n-    if (__i < 0 || __i >= TREE_CODE_LENGTH (TREE_CODE (__t)))\t\t\\\n-      tree_operand_check_failed (__i, TREE_CODE (__t),\t\t\t\\\n+    if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\t\t\t\\\n+      tree_operand_check_failed (__i, __t,\t\t\t\t\\\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->gstmt.operands[__i]; }))\n \n@@ -809,8 +817,8 @@ enum tree_node_structure_enum {\n     const int __i = (I);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != (CODE))\t\t\t\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, (CODE), 0); \\\n-    if (__i < 0 || __i >= TREE_CODE_LENGTH ((CODE)))\t\t\t\\\n-      tree_operand_check_failed (__i, (CODE),\t\t\t\t\\\n+    if (__i < 0 || __i >= TREE_OPERAND_LENGTH (__t))\t\t\t\\\n+      tree_operand_check_failed (__i, __t,\t\t\t\t\\\n \t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n     &__t->exp.operands[__i]; }))\n \n@@ -864,7 +872,7 @@ extern void tree_vec_elt_check_failed (int, int, const char *,\n extern void phi_node_elt_check_failed (int, int, const char *,\n \t\t\t\t       int, const char *)\n     ATTRIBUTE_NORETURN;\n-extern void tree_operand_check_failed (int, enum tree_code,\n+extern void tree_operand_check_failed (int, tree,\n \t\t\t\t       const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n extern void omp_clause_check_failed (const tree, const char *, int,\n@@ -924,6 +932,7 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n #define DECL_NON_COMMON_CHECK(T) CONTAINS_STRUCT_CHECK (T, TS_DECL_NON_COMMON)\n #define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_constant)\n #define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_statement)\n+#define VL_EXP_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_vl_exp)\n #define FUNC_OR_METHOD_CHECK(T)\tTREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)\n #define PTR_OR_REF_CHECK(T)\tTREE_CHECK2 (T, POINTER_TYPE, REFERENCE_TYPE)\n \n@@ -1497,8 +1506,17 @@ struct tree_constructor GTY(())\n \t\t\t\t && integer_zerop (TREE_OPERAND (NODE, 0)))\n \n /* In ordinary expression nodes.  */\n+#define TREE_OPERAND_LENGTH(NODE) tree_operand_length (NODE)\n #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n \n+/* In a tcc_vl_exp node, operand 0 is an INT_CST node holding the operand\n+   length.  Its value includes the length operand itself; that is,\n+   the minimum valid length is 1.\n+   Note that we have to bypass the use of TREE_OPERAND to access\n+   that field to avoid infinite recursion in expanding the macros.  */\n+#define VL_EXP_OPERAND_LENGTH(NODE) \\\n+  ((int)TREE_INT_CST_LOW (VL_EXP_CHECK (NODE)->exp.operands[0]))\n+\n /* In gimple statements.  */\n #define GIMPLE_STMT_OPERAND(NODE, I) GIMPLE_STMT_OPERAND_CHECK (NODE, I)\n #define GIMPLE_STMT_LOCUS(NODE) (GIMPLE_STMT_CHECK (NODE)->gstmt.locus)\n@@ -1613,6 +1631,23 @@ struct tree_constructor GTY(())\n #define ASSERT_EXPR_VAR(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 0)\n #define ASSERT_EXPR_COND(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 1)\n \n+/* CALL_EXPR accessors.\n+ */\n+#define CALL_EXPR_FN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 1)\n+#define CALL_EXPR_STATIC_CHAIN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 2)\n+#define CALL_EXPR_ARGS(NODE) call_expr_arglist (NODE)\n+#define CALL_EXPR_ARG(NODE, I) TREE_OPERAND (CALL_EXPR_CHECK (NODE), (I) + 3)\n+#define call_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH(NODE) - 3)\n+\n+/* CALL_EXPR_ARGP returns a pointer to the argument vector for NODE.\n+   We can't use &CALL_EXPR_ARG (NODE, 0) because that will complain if\n+   the argument count is zero when checking is enabled.  Instead, do\n+   the pointer arithmetic to advance past the 3 fixed operands in a\n+   CALL_EXPR.  That produces a valid pointer to just past the end of the\n+   operand array, even if it's not valid to dereference it.  */\n+#define CALL_EXPR_ARGP(NODE) \\\n+  (&(TREE_OPERAND (CALL_EXPR_CHECK (NODE), 0)) + 3)\n+\n /* OpenMP directive and clause accessors.  */\n \n #define OMP_BODY(NODE) \\\n@@ -3641,6 +3676,7 @@ extern tree maybe_get_identifier (const char *);\n /* Construct various types of nodes.  */\n \n extern tree build_nt (enum tree_code, ...);\n+extern tree build_nt_call_list (tree, tree);\n \n extern tree build0_stat (enum tree_code, tree MEM_STAT_DECL);\n #define build0(c,t) build0_stat (c,t MEM_STAT_INFO)\n@@ -3691,6 +3727,14 @@ extern void annotate_with_locus (tree, location_t);\n extern tree build_empty_stmt (void);\n extern tree build_omp_clause (enum omp_clause_code);\n \n+extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n+#define build_vl_exp(c,n) build_vl_exp_stat (c,n MEM_STAT_INFO)\n+\n+extern tree build_call_list (tree, tree, tree);\n+extern tree build_call_nary (tree, tree, int, ...);\n+extern tree build_call_valist (tree, tree, int, va_list);\n+extern tree build_call_array (tree, tree, int, tree*);\n+\n /* Construct various nodes representing data types.  */\n \n extern tree make_signed_type (int);\n@@ -4288,6 +4332,9 @@ extern tree upper_bound_in_type (tree, tree);\n extern tree lower_bound_in_type (tree, tree);\n extern int operand_equal_for_phi_arg_p (tree, tree);\n extern bool empty_body_p (tree);\n+extern tree call_expr_arg (tree, int);\n+extern tree *call_expr_argp (tree, int);\n+extern tree call_expr_arglist (tree);\n \f\n /* In stmt.c */\n \n@@ -4329,6 +4376,8 @@ extern tree fold_build3_stat (enum tree_code, tree, tree, tree, tree MEM_STAT_DE\n extern tree fold_build1_initializer (enum tree_code, tree, tree);\n extern tree fold_build2_initializer (enum tree_code, tree, tree, tree);\n extern tree fold_build3_initializer (enum tree_code, tree, tree, tree, tree);\n+extern tree fold_build_call_list (tree, tree, tree);\n+extern tree fold_build_call_list_initializer (tree, tree, tree);\n extern tree fold_convert (tree, tree);\n extern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n extern tree fold_ignored_result (tree);\n@@ -4413,26 +4462,30 @@ extern bool tree_expr_nonzero_p (tree);\n extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n \n /* In builtins.c */\n-extern tree fold_builtin (tree, tree, bool);\n-extern tree fold_builtin_fputs (tree, bool, bool, tree);\n-extern tree fold_builtin_strcpy (tree, tree, tree);\n-extern tree fold_builtin_strncpy (tree, tree, tree);\n-extern tree fold_builtin_memory_chk (tree, tree, tree, bool,\n+extern tree fold_call_expr (tree, bool);\n+extern tree fold_builtin_fputs (tree, tree, bool, bool, tree);\n+extern tree fold_builtin_strcpy (tree, tree, tree, tree);\n+extern tree fold_builtin_strncpy (tree, tree, tree, tree, tree);\n+extern tree fold_builtin_memory_chk (tree, tree, tree, tree, tree, tree, bool,\n \t\t\t\t     enum built_in_function);\n-extern tree fold_builtin_stxcpy_chk (tree, tree, tree, bool,\n+extern tree fold_builtin_stxcpy_chk (tree, tree, tree, tree, tree, bool,\n \t\t\t\t     enum built_in_function);\n-extern tree fold_builtin_strncpy_chk (tree, tree);\n+extern tree fold_builtin_strncpy_chk (tree, tree, tree, tree, tree);\n extern tree fold_builtin_snprintf_chk (tree, tree, enum built_in_function);\n-extern bool fold_builtin_next_arg (tree);\n+extern bool fold_builtin_next_arg (tree, bool);\n extern enum built_in_function builtin_mathfn_code (tree);\n extern tree build_function_call_expr (tree, tree);\n+extern tree fold_build_call_expr (tree, tree, tree, tree);\n+extern tree fold_builtin_call_list (tree, tree, tree);\n+extern tree fold_builtin_call_valist (tree, tree, int, va_list);\n+extern tree build_call_expr (tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree strip_float_extensions (tree);\n extern tree c_strlen (tree, int);\n extern tree std_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);\n extern tree build_string_literal (int, const char *);\n-extern int validate_arglist (tree, ...);\n+extern bool validate_arglist (tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern int get_pointer_alignment (tree, unsigned int);\n \n@@ -4786,4 +4839,77 @@ extern unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n \n void init_inline_once (void);\n \n+/* Compute the number of operands in an expression node NODE.  For \n+   tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,\n+   otherwise it is looked up from the node's code.  */\n+static inline int\n+tree_operand_length (tree node)\n+{\n+  if (VL_EXP_CLASS_P (node))\n+    return VL_EXP_OPERAND_LENGTH (node);\n+  else\n+    return TREE_CODE_LENGTH (TREE_CODE (node));\n+}\n+\n+/* Abstract iterators for CALL_EXPRs.  These static inline definitions\n+   have to go towards the end of tree.h so that union tree_node is fully\n+   defined by this point.  */\n+\n+/* Structure containing iterator state.  */\n+typedef struct call_expr_arg_iterator_d GTY (())\n+{\n+  tree t;\t/* the call_expr */\n+  int n;\t/* argument count */\n+  int i;\t/* next argument index */\n+} call_expr_arg_iterator;\n+\n+/* Initialize the abstract argument list iterator object ITER with the\n+   arguments from CALL_EXPR node EXP.  */\n+static inline void\n+init_call_expr_arg_iterator (tree exp, call_expr_arg_iterator *iter)\n+{\n+  iter->t = exp;\n+  iter->n = call_expr_nargs (exp);\n+  iter->i = 0;\n+}\n+\n+/* Return the next argument from abstract argument list iterator object ITER,\n+   and advance its state.  Return NULL_TREE if there are no more arguments.  */\n+static inline tree\n+next_call_expr_arg (call_expr_arg_iterator *iter)\n+{\n+  tree result;\n+  if (iter->i >= iter->n)\n+    return NULL_TREE;\n+  result = CALL_EXPR_ARG (iter->t, iter->i);\n+  iter->i++;\n+  return result;\n+}\n+\n+/* Initialize the abstract argument list iterator object ITER, then advance\n+   past and return the first argument.  Useful in for expressions, e.g.\n+     for (arg = first_call_expr_arg (exp, &iter); arg;\n+          arg = next_call_expr_arg (&iter))   */\n+static inline tree\n+first_call_expr_arg (tree exp, call_expr_arg_iterator *iter)\n+{\n+  init_call_expr_arg_iterator (exp, iter);\n+  return next_call_expr_arg (iter);\n+}\n+\n+/* Test whether there are more arguments in abstract argument list iterator\n+   ITER, without changing its state.  */\n+static inline bool\n+more_call_expr_args_p (const call_expr_arg_iterator *iter)\n+{\n+  return (iter->i < iter->n);\n+}\n+\n+\n+/* Iterate through each argument ARG of CALL_EXPR CALL, using variable ITER\n+   (of type call_expr_arg_iterator) to hold the iteration state.  */\n+#define FOR_EACH_CALL_EXPR_ARG(arg, iter, call)\t\t\t\\\n+  for ((arg) = first_call_expr_arg ((call), &(iter)); (arg);\t\\\n+       (arg) = next_call_expr_arg (&(iter)))\n+\n #endif  /* GCC_TREE_H  */"}, {"sha": "908481e4a981c7a212eb6401fb0e788ebe41aea2", "filename": "gcc/value-prof.c", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5039610b9630459799b24f64fb9ffdd810b8eee9/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=5039610b9630459799b24f64fb9ffdd810b8eee9", "patch": "@@ -1073,7 +1073,7 @@ tree_ic (tree stmt, tree call, struct cgraph_node* direct_call,\n   tmpv = create_tmp_var (optype, \"PROF\");\n   tmp1 = create_tmp_var (optype, \"PROF\");\n   stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv, \n-\t\t  unshare_expr (TREE_OPERAND (call, 0)));\n+\t\t  unshare_expr (CALL_EXPR_FN (call)));\n   stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, \n \t\t  fold_convert (optype, build_addr (direct_call->decl, \n \t\t\t\t\t\t    current_function_decl)));\n@@ -1089,8 +1089,8 @@ tree_ic (tree stmt, tree call, struct cgraph_node* direct_call,\n   label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n   stmt1 = unshare_expr (stmt);\n   new_call = get_call_expr_in (stmt1);\n-  TREE_OPERAND (new_call, 0) = build_addr (direct_call->decl, \n-\t\t\t\t\t   current_function_decl);\n+  CALL_EXPR_FN (new_call) = build_addr (direct_call->decl, \n+\t\t\t\t\tcurrent_function_decl);\n   bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb2end = stmt1;\n@@ -1165,7 +1165,7 @@ tree_ic_transform (tree stmt)\n   if (!call || TREE_CODE (call) != CALL_EXPR)\n     return false;\n \n-  callee = TREE_OPERAND (call, 0);\n+  callee = CALL_EXPR_FN (call);\n \n   if (TREE_CODE (callee) == ADDR_EXPR)\n     return false;\n@@ -1205,9 +1205,9 @@ tree_ic_transform (tree stmt)\n   return true;\n }\n \n-/* Return true if the stringop FNDECL with ARGLIST shall be profiled.  */\n+/* Return true if the stringop CALL with FNDECL shall be profiled.  */\n static bool\n-interesting_stringop_to_profile_p (tree fndecl, tree arglist)\n+interesting_stringop_to_profile_p (tree fndecl, tree call)\n {\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n \n@@ -1219,18 +1219,18 @@ interesting_stringop_to_profile_p (tree fndecl, tree arglist)\n     {\n      case BUILT_IN_MEMCPY:\n      case BUILT_IN_MEMPCPY:\n-\treturn validate_arglist (arglist,\n-\t\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n-\t\t\t\t VOID_TYPE);\n+       return validate_arglist (call,\n+\t\t\t\tPOINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t\tVOID_TYPE);\n      case BUILT_IN_MEMSET:\n-\treturn validate_arglist (arglist,\n-\t\t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE,\n-\t\t\t\t VOID_TYPE);\n+       return validate_arglist (call,\n+\t\t\t\tPOINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE,\n+\t\t\t\tVOID_TYPE);\n      case BUILT_IN_BZERO:\n-        return validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE,\n-\t\t\t\t VOID_TYPE);\n+       return validate_arglist (call, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t\tVOID_TYPE);\n      default:\n-\tgcc_unreachable ();\n+       gcc_unreachable ();\n     }\n }\n \n@@ -1256,8 +1256,7 @@ tree_stringop_fixed_value (tree stmt, tree value, int prob, gcov_type count,\n   edge e12, e13, e23, e24, e34;\n   block_stmt_iterator bsi;\n   tree call = get_call_expr_in (stmt);\n-  tree arglist = TREE_OPERAND (call, 1);\n-  tree blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree blck_size = CALL_EXPR_ARG (call, 2);\n   tree optype = TREE_TYPE (blck_size);\n   int region;\n \n@@ -1295,8 +1294,7 @@ tree_stringop_fixed_value (tree stmt, tree value, int prob, gcov_type count,\n   label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n   stmt1 = unshare_expr (stmt);\n   call = get_call_expr_in (stmt1);\n-  arglist = TREE_OPERAND (call, 1);\n-  TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))) = value;\n+  CALL_EXPR_ARG (call, 2) = value;\n   bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   region = lookup_stmt_eh_region (stmt);\n@@ -1342,7 +1340,6 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n   tree stmt = bsi_stmt (*bsi);\n   tree call = get_call_expr_in (stmt);\n   tree fndecl;\n-  tree arglist;\n   tree blck_size;\n   enum built_in_function fcode;\n   histogram_value histogram;\n@@ -1359,14 +1356,13 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n   if (!fndecl)\n     return false;\n   fcode = DECL_FUNCTION_CODE (fndecl);\n-  arglist = TREE_OPERAND (call, 1);\n-  if (!interesting_stringop_to_profile_p (fndecl, arglist))\n+  if (!interesting_stringop_to_profile_p (fndecl, call))\n     return false;\n \n   if (fcode == BUILT_IN_BZERO)\n-    blck_size = TREE_VALUE (TREE_CHAIN (arglist));\n+    blck_size = CALL_EXPR_ARG (call, 1);\n   else\n-    blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+    blck_size = CALL_EXPR_ARG (call, 2);\n   if (TREE_CODE (blck_size) == INTEGER_CST)\n     return false;\n \n@@ -1386,20 +1382,20 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n   if (check_counter (stmt, \"value\", all, bb_for_stmt (stmt)->count))\n     return false;\n   prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n-  dest = TREE_VALUE (arglist);\n+  dest = CALL_EXPR_ARG (call, 0);\n   dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n   switch (fcode)\n     {\n     case BUILT_IN_MEMCPY:\n     case BUILT_IN_MEMPCPY:\n-      src = TREE_VALUE (TREE_CHAIN (arglist));\n+      src = CALL_EXPR_ARG (call, 1);\n       src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n       if (!can_move_by_pieces (val, MIN (dest_align, src_align)))\n \treturn false;\n       break;\n     case BUILT_IN_MEMSET:\n       if (!can_store_by_pieces (val, builtin_memset_read_str,\n-\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t\tCALL_EXPR_ARG (call, 1),\n \t\t\t\tdest_align))\n \treturn false;\n       break;\n@@ -1561,7 +1557,7 @@ tree_indirect_call_to_profile (tree stmt, histogram_values *values)\n   if (!call || TREE_CODE (call) != CALL_EXPR)\n     return;\n \n-  callee = TREE_OPERAND (call, 0);\n+  callee = CALL_EXPR_FN (call);\n   \n   if (TREE_CODE (callee) == ADDR_EXPR)\n     return;\n@@ -1582,7 +1578,6 @@ tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n {\n   tree call = get_call_expr_in (stmt);\n   tree fndecl;\n-  tree arglist;\n   tree blck_size;\n   tree dest;\n   enum built_in_function fcode;\n@@ -1593,16 +1588,15 @@ tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n   if (!fndecl)\n     return;\n   fcode = DECL_FUNCTION_CODE (fndecl);\n-  arglist = TREE_OPERAND (call, 1);\n \n-  if (!interesting_stringop_to_profile_p (fndecl, arglist))\n+  if (!interesting_stringop_to_profile_p (fndecl, call))\n     return;\n \n-  dest = TREE_VALUE (arglist);\n+  dest = CALL_EXPR_ARG (call, 0);\n   if (fcode == BUILT_IN_BZERO)\n-    blck_size = TREE_VALUE (TREE_CHAIN (arglist));\n+    blck_size = CALL_EXPR_ARG (call, 1);\n   else\n-    blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+    blck_size = CALL_EXPR_ARG (call, 2);\n \n   if (TREE_CODE (blck_size) != INTEGER_CST)\n     {"}]}