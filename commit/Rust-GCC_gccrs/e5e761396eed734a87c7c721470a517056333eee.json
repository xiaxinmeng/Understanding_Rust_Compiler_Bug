{"sha": "e5e761396eed734a87c7c721470a517056333eee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlNzYxMzk2ZWVkNzM0YTg3YzdjNzIxNDcwYTUxNzA1NjMzM2VlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-07T00:59:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-07T00:59:58Z"}, "message": "(struct temp_slot): Add new field, ADDRESS.\n\n(assign_stack_temp): Initialize it to zero.\n(find_temp_slot_from_address, update_temp_slot_address): New functions.\n(preserve_temp_slots): Use find_temp_slot_from_address.\n\nFrom-SVN: r6496", "tree": {"sha": "df66ac9fe4d1a5302331b11125942c0a6a33f23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df66ac9fe4d1a5302331b11125942c0a6a33f23d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e761396eed734a87c7c721470a517056333eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e761396eed734a87c7c721470a517056333eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e761396eed734a87c7c721470a517056333eee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e761396eed734a87c7c721470a517056333eee/comments", "author": null, "committer": null, "parents": [{"sha": "d11c20c4e4eb42bc5c8cfb656dcb39992a9cb90c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11c20c4e4eb42bc5c8cfb656dcb39992a9cb90c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11c20c4e4eb42bc5c8cfb656dcb39992a9cb90c"}], "stats": {"total": 69, "additions": 61, "deletions": 8}, "files": [{"sha": "361bbf86e149b2ae72c14fe085612df0ce4b4f47", "filename": "gcc/function.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e761396eed734a87c7c721470a517056333eee/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e761396eed734a87c7c721470a517056333eee/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e5e761396eed734a87c7c721470a517056333eee", "patch": "@@ -364,6 +364,9 @@ struct temp_slot\n   struct temp_slot *next;\n   /* The rtx to used to reference the slot. */\n   rtx slot;\n+  /* The rtx used to represent the address if not the address of the\n+     slot above.  May be an EXPR_LIST if multiple addresses exist.  */\n+  rtx address;\n   /* The size, in units, of the slot.  */\n   int size;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n@@ -785,6 +788,7 @@ assign_stack_temp (mode, size, keep)\n \t      p->slot = gen_rtx (MEM, BLKmode,\n \t\t\t\t plus_constant (XEXP (best_p->slot, 0),\n \t\t\t\t\t\trounded_size));\n+\t      p->address = 0;\n \t      p->next = temp_slots;\n \t      temp_slots = p;\n \n@@ -798,15 +802,15 @@ assign_stack_temp (mode, size, keep)\n       p = best_p;\n     }\n \t      \n-\n   /* If we still didn't find one, make a new temporary.  */\n   if (p == 0)\n     {\n       p = (struct temp_slot *) oballoc (sizeof (struct temp_slot));\n       p->size = size;\n       /* If the temp slot mode doesn't indicate the alignment,\n \t use the largest possible, so no one will be disappointed.  */\n-      p->slot = assign_stack_local (mode, size, mode == BLKmode ? -1 : 0); \n+      p->slot = assign_stack_local (mode, size, mode == BLKmode ? -1 : 0);\n+      p->address = 0;\n       p->next = temp_slots;\n       temp_slots = p;\n     }\n@@ -879,6 +883,55 @@ combine_temp_slots ()\n   rtx_free (free_pointer);\n }\n \f\n+/* Find the temp slot corresponding to the object at address X.  */\n+\n+static struct temp_slot *\n+find_temp_slot_from_address (x)\n+     rtx x;\n+{\n+  struct temp_slot *p;\n+  rtx next;\n+\n+  for (p = temp_slots; p; p = p->next)\n+    {\n+      if (! p->in_use)\n+\tcontinue;\n+      else if (XEXP (p->slot, 0) == x\n+\t       || p->address == x)\n+\treturn p;\n+\n+      else if (p->address != 0 && GET_CODE (p->address) == EXPR_LIST)\n+\tfor (next = p->address; next; next = XEXP (next, 1))\n+\t  if (XEXP (next, 0) == x)\n+\t    return p;\n+    }\n+\n+  return 0;\n+}\n+      \n+/* Indicate that NEW is an alternate way of refering to the temp slot\n+   that previous was known by OLD.  */\n+\n+void\n+update_temp_slot_address (old, new)\n+     rtx old, new;\n+{\n+  struct temp_slot *p = find_temp_slot_from_address (old);\n+\n+  /* If none, return.  Else add NEW as an alias.  */\n+  if (p == 0)\n+    return;\n+  else if (p->address == 0)\n+    p->address = new;\n+  else\n+    {\n+      if (GET_CODE (p->address) != EXPR_LIST)\n+\tp->address = gen_rtx (EXPR_LIST, VOIDmode, p->address, NULL_RTX);\n+\n+      p->address = gen_rtx (EXPR_LIST, VOIDmode, new, p->address);\n+    }\n+}\n+\n /* If X could be a reference to a temporary slot, mark that slot as belonging\n    to the to one level higher.  If X matched one of our slots, just mark that\n    one.  Otherwise, we can't easily predict which it is, so upgrade all of\n@@ -899,12 +952,12 @@ preserve_temp_slots (x)\n     return;\n \n   /* First see if we can find a match.  */\n-  for (p = temp_slots; p; p = p->next)\n-    if (p->in_use && x == p->slot)\n-      {\n-\tp->level--;\n-\treturn;\n-      }\n+  p = find_temp_slot_from_address (XEXP (x, 0));\n+  if (p != 0)\n+    {\n+      p->level--;\n+      return;\n+    }\n \n   /* Otherwise, preserve all non-kept slots at this level.  */\n   for (p = temp_slots; p; p = p->next)"}]}