{"sha": "ad12460bed01fc26b69eaa8292986d19f6e24cb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQxMjQ2MGJlZDAxZmMyNmI2OWVhYTgyOTI5ODZkMTlmNmUyNGNiNQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2007-02-02T16:21:18Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2007-02-02T16:21:18Z"}, "message": "pointer-set.c (insert_aux): Only return insertion slot.\n\n2007-02-02  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* pointer-set.c (insert_aux): Only return insertion slot.\n\t(pointer_set_insert): Adjust.\n\t(pointer_set_traverse, struct pointer_map_t, pointer_map_create,\n\tpointer_map_destroy, pointer_map_insert, pointer_map_contains,\n\tpointer_map_traverse): New.\n\t* pointer-set.h (pointer_set_traverse, struct pointer_map_t,\n\tpointer_map_create,  pointer_map_destroy, pointer_map_insert,\n\tpointer_map_contains, pointer_map_traverse): Declare.\n\nFrom-SVN: r121507", "tree": {"sha": "97448ca0855bf51affb027c103796bd44462c67f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97448ca0855bf51affb027c103796bd44462c67f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad12460bed01fc26b69eaa8292986d19f6e24cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad12460bed01fc26b69eaa8292986d19f6e24cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad12460bed01fc26b69eaa8292986d19f6e24cb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad12460bed01fc26b69eaa8292986d19f6e24cb5/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4969f3ea0b7fdd4f6d5e41be99c5d8ce9a0231c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4969f3ea0b7fdd4f6d5e41be99c5d8ce9a0231c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4969f3ea0b7fdd4f6d5e41be99c5d8ce9a0231c1"}], "stats": {"total": 202, "additions": 177, "deletions": 25}, "files": [{"sha": "60b82d36382f71fc7e8ab01e0ee9324f11f65c93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12460bed01fc26b69eaa8292986d19f6e24cb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12460bed01fc26b69eaa8292986d19f6e24cb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad12460bed01fc26b69eaa8292986d19f6e24cb5", "patch": "@@ -1,3 +1,14 @@\n+2007-02-02  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* pointer-set.c (insert_aux): Only return insertion slot.\n+\t(pointer_set_insert): Adjust.\n+\t(pointer_set_traverse, struct pointer_map_t, pointer_map_create,\n+\tpointer_map_destroy, pointer_map_insert, pointer_map_contains,\n+\tpointer_map_traverse): New.\n+\t* pointer-set.h (pointer_set_traverse, struct pointer_map_t,\n+\tpointer_map_create,  pointer_map_destroy, pointer_map_insert,\n+\tpointer_map_contains, pointer_map_traverse): Declare.\n+\n 2007-02-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/30473"}, {"sha": "6c39ebf8ce0a4f5243e40020240fff754d92b4d8", "filename": "gcc/pointer-set.c", "status": "modified", "additions": 155, "deletions": 24, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12460bed01fc26b69eaa8292986d19f6e24cb5/gcc%2Fpointer-set.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12460bed01fc26b69eaa8292986d19f6e24cb5/gcc%2Fpointer-set.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.c?ref=ad12460bed01fc26b69eaa8292986d19f6e24cb5", "patch": "@@ -22,13 +22,12 @@ Boston, MA 02110-1301, USA.  */\n #include \"system.h\"\n #include \"pointer-set.h\"\n \n-/* A pointer sets is represented as a simple open-addressing hash\n+/* A pointer set is represented as a simple open-addressing hash\n    table.  Simplifications: The hash code is based on the value of the\n    pointer, not what it points to.  The number of buckets is always a\n    power of 2.  Null pointers are a reserved value.  Deletion is not\n-   supported.  There is no mechanism for user control of hash\n-   function, equality comparison, initial size, or resizing policy.\n-*/\n+   supported (yet).  There is no mechanism for user control of hash\n+   function, equality comparison, initial size, or resizing policy.  */\n \n struct pointer_set_t\n {\n@@ -114,22 +113,16 @@ pointer_set_contains (struct pointer_set_t *pset, void *p)\n     }\n }\n \n-/* Subroutine of pointer_set_insert.  Inserts P into an empty\n-   element of SLOTS, an array of length N_SLOTS.  Returns nonzero\n-   if P was already present in N_SLOTS.  */\n-static int\n+/* Subroutine of pointer_set_insert.  Return the insertion slot for P into\n+   an empty element of SLOTS, an array of length N_SLOTS.  */\n+static inline size_t\n insert_aux (void *p, void **slots, size_t n_slots, size_t log_slots)\n {\n   size_t n = hash1 (p, n_slots, log_slots);\n   while (true)\n     {\n-      if (slots[n] == p)\n-\treturn 1;\n-      else if (slots[n] == 0)\n-\t{\n-\t  slots[n] = p;\n-\t  return 0;\n-\t}\n+      if (slots[n] == p || slots[n] == 0)\n+\treturn n;\n       else\n \t{\n \t  ++n;\n@@ -144,12 +137,10 @@ insert_aux (void *p, void **slots, size_t n_slots, size_t log_slots)\n int\n pointer_set_insert (struct pointer_set_t *pset, void *p)\n {\n-  if (insert_aux (p, pset->slots, pset->n_slots, pset->log_slots))\n-    return 1;\n-      \n-  /* We've inserted a new element.  Expand the table if necessary to keep\n-     the load factor small.  */\n-  ++pset->n_elements;\n+  size_t n;\n+\n+  /* For simplicity, expand the set even if P is already there.  This can be\n+     superfluous but can happen at most once.  */\n   if (pset->n_elements > pset->n_slots / 4)\n     {\n       size_t new_log_slots = pset->log_slots + 1;\n@@ -158,9 +149,10 @@ pointer_set_insert (struct pointer_set_t *pset, void *p)\n       size_t i;\n \n       for (i = 0; i < pset->n_slots; ++i)\n-\t{\n-\t  if (pset->slots[i])\n-\t    insert_aux (pset->slots[i], new_slots, new_n_slots, new_log_slots);\n+        {\n+\t  void *value = pset->slots[i];\n+\t  n = insert_aux (value, new_slots, new_n_slots, new_log_slots);\n+\t  new_slots[n] = value;\n \t}\n \n       XDELETEVEC (pset->slots);\n@@ -169,5 +161,144 @@ pointer_set_insert (struct pointer_set_t *pset, void *p)\n       pset->slots = new_slots;\n     }\n \n+  n = insert_aux (p, pset->slots, pset->n_slots, pset->log_slots);\n+  if (pset->slots[n])\n+    return 1;\n+\n+  pset->slots[n] = p;\n+  ++pset->n_elements;\n   return 0;\n }\n+\n+/* Pass each pointer in PSET to the function in FN, together with the fixed\n+   parameter DATA.  If FN returns false, the iteration stops.  */\n+\n+void pointer_set_traverse (struct pointer_set_t *pset,\n+\t\t\t   bool (*fn) (void *, void *), void *data)\n+{\n+  size_t i;\n+  for (i = 0; i < pset->n_slots; ++i)\n+    if (pset->slots[i] && !fn (pset->slots[i], data))\n+      break;\n+}\n+\n+\f\n+/* A pointer map is represented the same way as a pointer_set, so\n+   the hash code is based on the address of the key, rather than\n+   its contents.  Null keys are a reserved value.  Deletion is not\n+   supported (yet).  There is no mechanism for user control of hash\n+   function, equality comparison, initial size, or resizing policy.  */\n+\n+struct pointer_map_t\n+{\n+  size_t log_slots;\n+  size_t n_slots;\t\t/* n_slots = 2^log_slots */\n+  size_t n_elements;\n+\n+  void **keys;\n+  void **values;\n+};\n+\n+/* Allocate an empty pointer map.  */\n+struct pointer_map_t *\n+pointer_map_create (void)\n+{\n+  struct pointer_map_t *result = XNEW (struct pointer_map_t);\n+\n+  result->n_elements = 0;\n+  result->log_slots = 8;\n+  result->n_slots = (size_t) 1 << result->log_slots;\n+\n+  result->keys = XCNEWVEC (void *, result->n_slots);\n+  result->values = XCNEWVEC (void *, result->n_slots);\n+  return result;\n+}\n+\n+/* Reclaims all memory associated with PMAP.  */\n+void pointer_map_destroy (struct pointer_map_t *pmap)\n+{\n+  XDELETEVEC (pmap->keys);\n+  XDELETEVEC (pmap->values);\n+  XDELETE (pmap);\n+}\n+\n+/* Returns a pointer to the value to which P maps, if PMAP contains P.  P\n+   must be nonnull.  Return NULL if PMAP does not contain P.\n+\n+   Collisions are resolved by linear probing.  */\n+void **\n+pointer_map_contains (struct pointer_map_t *pmap, void *p)\n+{\n+  size_t n = hash1 (p, pmap->n_slots, pmap->log_slots);\n+\n+  while (true)\n+    {\n+      if (pmap->keys[n] == p)\n+\treturn &pmap->values[n];\n+      else if (pmap->keys[n] == 0)\n+\treturn NULL;\n+      else\n+       {\n+         ++n;\n+         if (n == pmap->n_slots)\n+           n = 0;\n+       }\n+    }\n+}\n+\n+/* Inserts P into PMAP if it wasn't already there.  Returns a pointer\n+   to the value.  P must be nonnull.  */\n+void **\n+pointer_map_insert (struct pointer_map_t *pmap, void *p)\n+{\n+  size_t n;\n+\n+  /* For simplicity, expand the map even if P is already there.  This can be\n+     superfluous but can happen at most once.  */\n+  if (pmap->n_elements > pmap->n_slots / 4)\n+    {\n+      size_t new_log_slots = pmap->log_slots + 1;\n+      size_t new_n_slots = pmap->n_slots * 2;\n+      void **new_keys = XCNEWVEC (void *, new_n_slots);\n+      void **new_values = XCNEWVEC (void *, new_n_slots);\n+      size_t i;\n+\n+      for (i = 0; i < pmap->n_slots; ++i)\n+\tif (pmap->keys[i])\n+\t  {\n+\t    void *key = pmap->keys[i];\n+\t    n = insert_aux (key, new_keys, new_n_slots, new_log_slots);\n+\t    new_keys[n] = key;\n+\t    new_values[n] = pmap->values[i];\n+\t  }\n+\n+      XDELETEVEC (pmap->keys);\n+      XDELETEVEC (pmap->values);\n+      pmap->n_slots = new_n_slots;\n+      pmap->log_slots = new_log_slots;\n+      pmap->keys = new_keys;\n+      pmap->values = new_values;\n+    }\n+\n+  n = insert_aux (p, pmap->keys, pmap->n_slots, pmap->log_slots);\n+  if (!pmap->keys[n])\n+    {\n+      ++pmap->n_elements;\n+      pmap->keys[n] = p;\n+    }\n+\n+  return &pmap->values[n];\n+}\n+\n+/* Pass each pointer in PMAP to the function in FN, together with the pointer\n+   to the value and the fixed parameter DATA.  If FN returns false, the\n+   iteration stops.  */\n+\n+void pointer_map_traverse (struct pointer_map_t *pmap,\n+\t\t\t   bool (*fn) (void *, void **, void *), void *data)\n+{\n+  size_t i;\n+  for (i = 0; i < pmap->n_slots; ++i)\n+    if (pmap->keys[i] && !fn (pmap->keys[i], &pmap->values[i], data))\n+      break;\n+}"}, {"sha": "55d080eb5eb3a8dfc8bc2630a216b3860ff2cfa5", "filename": "gcc/pointer-set.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12460bed01fc26b69eaa8292986d19f6e24cb5/gcc%2Fpointer-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12460bed01fc26b69eaa8292986d19f6e24cb5/gcc%2Fpointer-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.h?ref=ad12460bed01fc26b69eaa8292986d19f6e24cb5", "patch": "@@ -22,11 +22,21 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define POINTER_SET_H\n \n struct pointer_set_t;\n-\n struct pointer_set_t *pointer_set_create (void);\n void pointer_set_destroy (struct pointer_set_t *pset);\n \n int pointer_set_contains (struct pointer_set_t *pset, void *p);\n int pointer_set_insert (struct pointer_set_t *pset, void *p);\n+void pointer_set_traverse (struct pointer_set_t *, bool (*) (void *, void *),\n+\t\t\t   void *);\n+\n+struct pointer_map_t;\n+struct pointer_map_t *pointer_map_create (void);\n+void pointer_map_destroy (struct pointer_map_t *pmap);\n+\n+void **pointer_map_contains (struct pointer_map_t *pmap, void *p);\n+void **pointer_map_insert (struct pointer_map_t *pmap, void *p);\n+void pointer_map_traverse (struct pointer_map_t *,\n+\t\t\t   bool (*) (void *, void **, void *), void *);\n \n #endif  /* POINTER_SET_H  */"}]}