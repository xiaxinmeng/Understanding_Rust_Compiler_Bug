{"sha": "0052da204e85630c973a0ad13b49e403abe1d5d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1MmRhMjA0ZTg1NjMwYzk3M2EwYWQxM2I0OWU0MDNhYmUxZDVkMw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2010-09-09T09:47:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T09:47:53Z"}, "message": "sem_ch3.adb (Derive_Subprogram): The code that checks if a dispatching primitive covers some interface primitive...\n\n2010-09-09  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Derive_Subprogram): The code that checks if a\n\tdispatching primitive covers some interface primitive is incomplete.\n\tReplace such code by the invocation of a new subprogram that provides\n\tthis functionality.\n\t* sem_ch6.ads (Is_Interface_Conformant): Add missing documentation.\n\t* sem_ch6.adb (Check_Missing_Return): Minor reformating\n\t(Check_Convention): Complete if-statement conditition when reporting\n\terrors (to avoid assertion failure).\n\t* sem_ch13.adb (Make_Null_Procedure_Specs): This routine was previously\n\tlocated in exp_ch3. Relocated inside Analyze_Freeze_Entity.\n\t(Analyze_Freeze_Entity): Invoke routine that adds the spec of non\n\toverridden null interface primitives.\n\t* sem_type.adb (Is_Ancestor): If the parent of the partial view of a\n\tprivate type is an interface then use the parent of its full view to\n\tclimb to its ancestor type.\n\t* sem_disp.ads, sem_disp.adb (Covers_Some_Interface): New subprogram.\n\t(Check_Dispatching_Operation): Extend assertion to handle wrappers of\n\tnull interface primitives.\n\t(Is_Null_Interface_Primitive): New subprogram.\n\t* exp_ch3.adb (Make_Null_Procedure_Specs): Removed.\n\t(Expand_Freeze_Record_Type): Do not generate specs of null interface\n\tsubprograms because they are now generated by Analyze_Freeze_Entity.\n\nFrom-SVN: r164059", "tree": {"sha": "582bff1f7c1e5aea268c3bbccb6aa355adcb63cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/582bff1f7c1e5aea268c3bbccb6aa355adcb63cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0052da204e85630c973a0ad13b49e403abe1d5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0052da204e85630c973a0ad13b49e403abe1d5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0052da204e85630c973a0ad13b49e403abe1d5d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0052da204e85630c973a0ad13b49e403abe1d5d3/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498d1b808eea93dc9e08db1e8a7f9af4dc3bcb90"}], "stats": {"total": 439, "additions": 274, "deletions": 165}, "files": [{"sha": "2a3e1a561530e7a013f385d433689eb037a31ec4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -1,3 +1,28 @@\n+2010-09-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Derive_Subprogram): The code that checks if a\n+\tdispatching primitive covers some interface primitive is incomplete.\n+\tReplace such code by the invocation of a new subprogram that provides\n+\tthis functionality.\n+\t* sem_ch6.ads (Is_Interface_Conformant): Add missing documentation.\n+\t* sem_ch6.adb (Check_Missing_Return): Minor reformating\n+\t(Check_Convention): Complete if-statement conditition when reporting\n+\terrors (to avoid assertion failure).\n+\t* sem_ch13.adb (Make_Null_Procedure_Specs): This routine was previously\n+\tlocated in exp_ch3. Relocated inside Analyze_Freeze_Entity.\n+\t(Analyze_Freeze_Entity): Invoke routine that adds the spec of non\n+\toverridden null interface primitives.\n+\t* sem_type.adb (Is_Ancestor): If the parent of the partial view of a\n+\tprivate type is an interface then use the parent of its full view to\n+\tclimb to its ancestor type.\n+\t* sem_disp.ads, sem_disp.adb (Covers_Some_Interface): New subprogram.\n+\t(Check_Dispatching_Operation): Extend assertion to handle wrappers of\n+\tnull interface primitives.\n+\t(Is_Null_Interface_Primitive): New subprogram.\n+\t* exp_ch3.adb (Make_Null_Procedure_Specs): Removed.\n+\t(Expand_Freeze_Record_Type): Do not generate specs of null interface\n+\tsubprograms because they are now generated by Analyze_Freeze_Entity.\n+\n 2010-09-09  Robert Dewar  <dewar@adacore.com>\n \n \t* a-calfor.adb, sem_ch3.adb: Minor reformatting."}, {"sha": "ae4213c3aa645bcfb97c5094b6475f4cfe575239", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -312,14 +312,6 @@ package body Exp_Ch3 is\n    --  invoking the inherited subprogram's parent subprogram and extended\n    --  with a null association list.\n \n-   procedure Make_Null_Procedure_Specs\n-     (Tag_Typ   : Entity_Id;\n-      Decl_List : out List_Id);\n-   --  Ada 2005 (AI-251): Makes specs for null procedures associated with any\n-   --  null procedures inherited from an interface type that have not been\n-   --  overridden. Only one null procedure will be created for a given set of\n-   --  inherited null procedures with homographic profiles.\n-\n    function Predef_Spec_Or_Body\n      (Loc      : Source_Ptr;\n       Tag_Typ  : Entity_Id;\n@@ -5886,7 +5878,6 @@ package body Exp_Ch3 is\n \n       Wrapper_Decl_List   : List_Id := No_List;\n       Wrapper_Body_List   : List_Id := No_List;\n-      Null_Proc_Decl_List : List_Id := No_List;\n \n    --  Start of processing for Expand_Freeze_Record_Type\n \n@@ -6089,20 +6080,6 @@ package body Exp_Ch3 is\n                Insert_List_Before_And_Analyze (N, Wrapper_Decl_List);\n             end if;\n \n-            --  Ada 2005 (AI-251): For a nonabstract type extension, build\n-            --  null procedure declarations for each set of homographic null\n-            --  procedures that are inherited from interface types but not\n-            --  overridden. This is done to ensure that the dispatch table\n-            --  entry associated with such null primitives are properly filled.\n-\n-            if Ada_Version >= Ada_05\n-              and then Etype (Def_Id) /= Def_Id\n-              and then not Is_Abstract_Type (Def_Id)\n-            then\n-               Make_Null_Procedure_Specs (Def_Id, Null_Proc_Decl_List);\n-               Insert_Actions (N, Null_Proc_Decl_List);\n-            end if;\n-\n             Set_Is_Frozen (Def_Id);\n             Set_All_DT_Position (Def_Id);\n \n@@ -8021,118 +7998,6 @@ package body Exp_Ch3 is\n       end if;\n    end Make_Eq_If;\n \n-   -------------------------------\n-   -- Make_Null_Procedure_Specs --\n-   -------------------------------\n-\n-   procedure Make_Null_Procedure_Specs\n-     (Tag_Typ   : Entity_Id;\n-      Decl_List : out List_Id)\n-   is\n-      Loc : constant Source_Ptr := Sloc (Tag_Typ);\n-\n-      Formal         : Entity_Id;\n-      Formal_List    : List_Id;\n-      New_Param_Spec : Node_Id;\n-      Parent_Subp    : Entity_Id;\n-      Prim_Elmt      : Elmt_Id;\n-      Proc_Decl      : Node_Id;\n-      Subp           : Entity_Id;\n-\n-      function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean;\n-      --  Returns True if E is a null procedure that is an interface primitive\n-\n-      ---------------------------------\n-      -- Is_Null_Interface_Primitive --\n-      ---------------------------------\n-\n-      function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean is\n-      begin\n-         return Comes_From_Source (E)\n-           and then Is_Dispatching_Operation (E)\n-           and then Ekind (E) = E_Procedure\n-           and then Null_Present (Parent (E))\n-           and then Is_Interface (Find_Dispatching_Type (E));\n-      end Is_Null_Interface_Primitive;\n-\n-   --  Start of processing for Make_Null_Procedure_Specs\n-\n-   begin\n-      Decl_List := New_List;\n-      Prim_Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n-      while Present (Prim_Elmt) loop\n-         Subp := Node (Prim_Elmt);\n-\n-         --  If a null procedure inherited from an interface has not been\n-         --  overridden, then we build a null procedure declaration to\n-         --  override the inherited procedure.\n-\n-         Parent_Subp := Alias (Subp);\n-\n-         if Present (Parent_Subp)\n-           and then Is_Null_Interface_Primitive (Parent_Subp)\n-         then\n-            Formal_List := No_List;\n-            Formal := First_Formal (Subp);\n-\n-            if Present (Formal) then\n-               Formal_List := New_List;\n-\n-               while Present (Formal) loop\n-\n-                  --  Copy the parameter spec including default expressions\n-\n-                  New_Param_Spec :=\n-                    New_Copy_Tree (Parent (Formal), New_Sloc => Loc);\n-\n-                  --  Generate a new defining identifier for the new formal.\n-                  --  required because New_Copy_Tree does not duplicate\n-                  --  semantic fields (except itypes).\n-\n-                  Set_Defining_Identifier (New_Param_Spec,\n-                    Make_Defining_Identifier (Sloc (Formal),\n-                      Chars => Chars (Formal)));\n-\n-                  --  For controlling arguments we must change their\n-                  --  parameter type to reference the tagged type (instead\n-                  --  of the interface type)\n-\n-                  if Is_Controlling_Formal (Formal) then\n-                     if Nkind (Parameter_Type (Parent (Formal)))\n-                       = N_Identifier\n-                     then\n-                        Set_Parameter_Type (New_Param_Spec,\n-                          New_Occurrence_Of (Tag_Typ, Loc));\n-\n-                     else pragma Assert\n-                            (Nkind (Parameter_Type (Parent (Formal)))\n-                               = N_Access_Definition);\n-                        Set_Subtype_Mark (Parameter_Type (New_Param_Spec),\n-                          New_Occurrence_Of (Tag_Typ, Loc));\n-                     end if;\n-                  end if;\n-\n-                  Append (New_Param_Spec, Formal_List);\n-\n-                  Next_Formal (Formal);\n-               end loop;\n-            end if;\n-\n-            Proc_Decl :=\n-              Make_Subprogram_Declaration (Loc,\n-                Make_Procedure_Specification (Loc,\n-                  Defining_Unit_Name =>\n-                    Make_Defining_Identifier (Loc, Chars (Subp)),\n-                  Parameter_Specifications => Formal_List,\n-                  Null_Present => True));\n-            Append_To (Decl_List, Proc_Decl);\n-            Analyze (Proc_Decl);\n-         end if;\n-\n-         Next_Elmt (Prim_Elmt);\n-      end loop;\n-   end Make_Null_Procedure_Specs;\n-\n    -------------------------------------\n    -- Make_Predefined_Primitive_Specs --\n    -------------------------------------"}, {"sha": "8744911244d3e3b75d6139fef09d9eec314b663b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -44,6 +44,7 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -2356,6 +2357,106 @@ package body Sem_Ch13 is\n    procedure Analyze_Freeze_Entity (N : Node_Id) is\n       E : constant Entity_Id := Entity (N);\n \n+      function Make_Null_Procedure_Specs (Tag_Typ : Entity_Id) return List_Id;\n+      --  Ada 2005 (AI-251): Makes specs for null procedures associated with\n+      --  null procedures inherited from interface types that have not been\n+      --  overridden. Only one null procedure will be created for a given\n+      --  set of inherited null procedures with homographic profiles.\n+\n+      -------------------------------\n+      -- Make_Null_Procedure_Specs --\n+      -------------------------------\n+\n+      function Make_Null_Procedure_Specs (Tag_Typ : Entity_Id) return List_Id\n+      is\n+         Decl_List      : constant List_Id    := New_List;\n+         Loc            : constant Source_Ptr := Sloc (Tag_Typ);\n+         Formal         : Entity_Id;\n+         Formal_List    : List_Id;\n+         New_Param_Spec : Node_Id;\n+         Parent_Subp    : Entity_Id;\n+         Prim_Elmt      : Elmt_Id;\n+         Proc_Decl      : Node_Id;\n+         Subp           : Entity_Id;\n+\n+      begin\n+         Prim_Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+         while Present (Prim_Elmt) loop\n+            Subp := Node (Prim_Elmt);\n+\n+            --  If a null procedure inherited from an interface has not been\n+            --  overridden, then we build a null procedure declaration to\n+            --  override the inherited procedure.\n+\n+            Parent_Subp := Alias (Subp);\n+\n+            if Present (Parent_Subp)\n+              and then Is_Null_Interface_Primitive (Parent_Subp)\n+            then\n+               Formal_List := No_List;\n+               Formal := First_Formal (Subp);\n+\n+               if Present (Formal) then\n+                  Formal_List := New_List;\n+\n+                  while Present (Formal) loop\n+\n+                     --  Copy the parameter spec including default expressions\n+\n+                     New_Param_Spec :=\n+                       New_Copy_Tree (Parent (Formal), New_Sloc => Loc);\n+\n+                     --  Generate a new defining identifier for the new formal.\n+                     --  required because New_Copy_Tree does not duplicate\n+                     --  semantic fields (except itypes).\n+\n+                     Set_Defining_Identifier (New_Param_Spec,\n+                       Make_Defining_Identifier (Sloc (Formal),\n+                         Chars => Chars (Formal)));\n+\n+                     --  For controlling arguments we must change their\n+                     --  parameter type to reference the tagged type (instead\n+                     --  of the interface type)\n+\n+                     if Is_Controlling_Formal (Formal) then\n+                        if Nkind (Parameter_Type (Parent (Formal)))\n+                          = N_Identifier\n+                        then\n+                           Set_Parameter_Type (New_Param_Spec,\n+                             New_Occurrence_Of (Tag_Typ, Loc));\n+\n+                        else pragma Assert\n+                               (Nkind (Parameter_Type (Parent (Formal)))\n+                                  = N_Access_Definition);\n+                           Set_Subtype_Mark (Parameter_Type (New_Param_Spec),\n+                             New_Occurrence_Of (Tag_Typ, Loc));\n+                        end if;\n+                     end if;\n+\n+                     Append (New_Param_Spec, Formal_List);\n+\n+                     Next_Formal (Formal);\n+                  end loop;\n+               end if;\n+\n+               Proc_Decl :=\n+                 Make_Subprogram_Declaration (Loc,\n+                   Make_Procedure_Specification (Loc,\n+                     Defining_Unit_Name =>\n+                       Make_Defining_Identifier (Loc, Chars (Subp)),\n+                     Parameter_Specifications => Formal_List,\n+                     Null_Present => True));\n+               Append_To (Decl_List, Proc_Decl);\n+            end if;\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+\n+         return Decl_List;\n+      end Make_Null_Procedure_Specs;\n+\n+   --  Start of processing for Analyze_Freeze_Entity\n+\n    begin\n       --  For tagged types covering interfaces add internal entities that link\n       --  the primitives of the interfaces with the primitives that cover them.\n@@ -2374,6 +2475,21 @@ package body Sem_Ch13 is\n         and then not Is_Interface (E)\n         and then Has_Interfaces (E)\n       then\n+         --  Add specs of non-overridden null interface primitives. During\n+         --  semantic analysis this is required to ensure consistency of the\n+         --  contents of the list of primitives of the tagged type. Routine\n+         --  Add_Internal_Interface_Entities will take care of adding to such\n+         --  list the internal entities that link each interface primitive with\n+         --  the primitive of Tagged_Type that covers it; hence these specs\n+         --  must be added before invoking Add_Internal_Interface_Entities.\n+         --  In the expansion this consistency is required to ensure that the\n+         --  dispatch table slots associated with non-overridden null interface\n+         --  primitives are properly filled.\n+\n+         if not Is_Abstract_Type (E) then\n+            Insert_Actions (N, Make_Null_Procedure_Specs (E));\n+         end if;\n+\n          --  This would be a good common place to call the routine that checks\n          --  overriding of interface primitives (and thus factorize calls to\n          --  Check_Abstract_Overriding located at different contexts in the"}, {"sha": "c99cdfe4eb832d8f4f502e5a95772d00b8a3c069", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -12284,34 +12284,13 @@ package body Sem_Ch3 is\n          end if;\n       end Set_Derived_Name;\n \n-      --  Local variables\n-\n-      Parent_Overrides_Interface_Primitive : Boolean := False;\n-\n    --  Start of processing for Derive_Subprogram\n \n    begin\n       New_Subp :=\n          New_Entity (Nkind (Parent_Subp), Sloc (Derived_Type));\n       Set_Ekind (New_Subp, Ekind (Parent_Subp));\n \n-      --  Check whether the parent overrides an interface primitive\n-\n-      if Is_Overriding_Operation (Parent_Subp) then\n-         declare\n-            E : Entity_Id := Parent_Subp;\n-         begin\n-            while Present (Overridden_Operation (E)) loop\n-               E := Ultimate_Alias (Overridden_Operation (E));\n-            end loop;\n-\n-            Parent_Overrides_Interface_Primitive :=\n-              Is_Dispatching_Operation (E)\n-                and then Present (Find_Dispatching_Type (E))\n-                and then Is_Interface (Find_Dispatching_Type (E));\n-         end;\n-      end if;\n-\n       --  Check whether the inherited subprogram is a private operation that\n       --  should be inherited but not yet made visible. Such subprograms can\n       --  become visible at a later point (e.g., the private part of a public\n@@ -12380,7 +12359,10 @@ package body Sem_Ch3 is\n       --  overrides an interface primitive because interface primitives\n       --  must be visible in the partial view of the parent (RM 7.3 (7.3/2))\n \n-      elsif Parent_Overrides_Interface_Primitive then\n+      elsif Ada_Version >= Ada_05\n+         and then Is_Dispatching_Operation (Parent_Subp)\n+         and then Covers_Some_Interface (Parent_Subp)\n+      then\n          Set_Derived_Name;\n \n       --  Otherwise, the type is inheriting a private operation, so enter"}, {"sha": "7c6704c41783f25e1f1c0cdf73bff4b476fda47e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -1714,7 +1714,7 @@ package body Sem_Ch6 is\n            and then Present (Spec_Id)\n            and then No_Return (Spec_Id)\n          then\n-               Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n+            Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n          end if;\n       end Check_Missing_Return;\n \n@@ -4037,7 +4037,9 @@ package body Sem_Ch6 is\n                   Error_Msg_Name_2 := Get_Convention_Name (Convention (Op));\n                   Error_Msg_Sloc   := Sloc (Op);\n \n-                  if Comes_From_Source (Op) then\n+                  if Comes_From_Source (Op)\n+                    or else No (Alias (Op))\n+                  then\n                      if not Is_Overriding_Operation (Op) then\n                         Error_Msg_N (\"\\\\primitive % defined #\", Typ);\n                      else"}, {"sha": "057544cd1a5eea4f9a978e56f1653dcd815bcb3b", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -183,9 +183,9 @@ package Sem_Ch6 is\n      (Tagged_Type : Entity_Id;\n       Iface_Prim  : Entity_Id;\n       Prim        : Entity_Id) return Boolean;\n-   --  Returns true if both primitives have a matching name and they are also\n-   --  type conformant. Special management is done for functions returning\n-   --  interfaces.\n+   --  Returns true if both primitives have a matching name, they are type\n+   --  conformant, and Prim is defined in the scope of Tagged_Type. Special\n+   --  management is done for functions returning interfaces.\n \n    function Mode_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,"}, {"sha": "69846939621bb2c0a45e8588a05d1334b2eb1928", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -91,6 +91,81 @@ package body Sem_Disp is\n       Append_Unique_Elmt (New_Op, List);\n    end Add_Dispatching_Operation;\n \n+   ---------------------------\n+   -- Covers_Some_Interface --\n+   ---------------------------\n+\n+   function Covers_Some_Interface (Prim : Entity_Id) return Boolean is\n+      Tagged_Type : constant Entity_Id := Find_Dispatching_Type (Prim);\n+      Elmt        : Elmt_Id;\n+      E           : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Dispatching_Operation (Prim));\n+\n+      --  Although this is a dispatching primitive we must check if its\n+      --  dispatching type is available because it may be the primitive\n+      --  of a private type not defined as tagged in its partial view.\n+\n+      if Present (Tagged_Type) and then Has_Interfaces (Tagged_Type) then\n+\n+         --  If the tagged type is frozen then the internal entities associated\n+         --  with interfaces are available in the list of primitives of the\n+         --  tagged type and can be used to speed up this search.\n+\n+         if Is_Frozen (Tagged_Type) then\n+            Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n+            while Present (Elmt) loop\n+               E := Node (Elmt);\n+\n+               if Present (Interface_Alias (E))\n+                 and then Alias (E) = Prim\n+               then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+\n+         --  Otherwise we must collect all the interface primitives and check\n+         --  if the Prim will override some interface primitive.\n+\n+         else\n+            declare\n+               Ifaces_List : Elist_Id;\n+               Iface_Elmt  : Elmt_Id;\n+               Iface       : Entity_Id;\n+               Iface_Prim  : Entity_Id;\n+\n+            begin\n+               Collect_Interfaces (Tagged_Type, Ifaces_List);\n+               Iface_Elmt := First_Elmt (Ifaces_List);\n+               while Present (Iface_Elmt) loop\n+                  Iface := Node (Iface_Elmt);\n+\n+                  Elmt := First_Elmt (Primitive_Operations (Iface));\n+                  while Present (Elmt) loop\n+                     Iface_Prim := Node (Elmt);\n+\n+                     if Chars (E) = Chars (Prim)\n+                       and then Is_Interface_Conformant\n+                                  (Tagged_Type, Iface_Prim, Prim)\n+                     then\n+                        return True;\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+\n+                  Next_Elmt (Iface_Elmt);\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Covers_Some_Interface;\n+\n    -------------------------------\n    -- Check_Controlling_Formals --\n    -------------------------------\n@@ -794,7 +869,10 @@ package body Sem_Disp is\n          --     type by Make_Controlling_Function_Wrappers. However, attribute\n          --     Is_Dispatching_Operation must be set to true.\n \n-         --  2. Subprograms associated with stream attributes (built by\n+         --  2. Ada 2005 (AI-251): Wrapper procedures of null interface\n+         --     primitives.\n+\n+         --  3. Subprograms associated with stream attributes (built by\n          --     New_Stream_Subprogram)\n \n          if Present (Old_Subp)\n@@ -805,9 +883,17 @@ package body Sem_Disp is\n              ((Ekind (Subp) = E_Function\n                 and then Is_Dispatching_Operation (Old_Subp)\n                 and then Is_Null_Extension (Base_Type (Etype (Subp))))\n+               or else\n+                (Ekind (Subp) = E_Procedure\n+                  and then Is_Dispatching_Operation (Old_Subp)\n+                  and then Present (Alias (Old_Subp))\n+                  and then Is_Null_Interface_Primitive\n+                             (Ultimate_Alias (Old_Subp)))\n                or else Get_TSS_Name (Subp) = TSS_Stream_Read\n                or else Get_TSS_Name (Subp) = TSS_Stream_Write);\n \n+            Check_Controlling_Formals (Tagged_Type, Subp);\n+            Override_Dispatching_Operation (Tagged_Type, Old_Subp, Subp);\n             Set_Is_Dispatching_Operation (Subp);\n          end if;\n \n@@ -1602,6 +1688,19 @@ package body Sem_Disp is\n       end if;\n    end Is_Dynamically_Tagged;\n \n+   ---------------------------------\n+   -- Is_Null_Interface_Primitive --\n+   ---------------------------------\n+\n+   function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean is\n+   begin\n+      return Comes_From_Source (E)\n+        and then Is_Dispatching_Operation (E)\n+        and then Ekind (E) = E_Procedure\n+        and then Null_Present (Parent (E))\n+        and then Is_Interface (Find_Dispatching_Type (E));\n+   end Is_Null_Interface_Primitive;\n+\n    --------------------------\n    -- Is_Tag_Indeterminate --\n    --------------------------"}, {"sha": "1888a6854abfc77c45c11b331b1f8eb49beba5b2", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -66,6 +66,11 @@ package Sem_Disp is\n    --  of \"OldSubp\" is adjusted to point to the inherited procedure of the\n    --  full view because it is always this one which has to be called.\n \n+   function Covers_Some_Interface (Prim : Entity_Id) return Boolean;\n+   --  Returns true if Prim covers some interface primitive of its associated\n+   --  tagged type. The tagged type of Prim must be frozen when this function\n+   --  is invoked.\n+\n    function Find_Controlling_Arg (N : Node_Id) return Node_Id;\n    --  Returns the actual controlling argument if N is dynamically tagged,\n    --  and Empty if it is not dynamically tagged.\n@@ -87,6 +92,9 @@ package Sem_Disp is\n    --  an expression of a class_Wide type, or a call to a function with\n    --  controlling result where at least one operand is dynamically tagged.\n \n+   function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean;\n+   --  Returns True if E is a null procedure that is an interface primitive\n+\n    function Is_Tag_Indeterminate (N : Node_Id) return Boolean;\n    --  An expression is tag-indeterminate if it is a call that dispatches\n    --  on result, and all controlling operands are also indeterminate."}, {"sha": "083f4c8bd2c01457dadc4a5dbf52b3eedc8887d8", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0052da204e85630c973a0ad13b49e403abe1d5d3/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=0052da204e85630c973a0ad13b49e403abe1d5d3", "patch": "@@ -2619,7 +2619,19 @@ package body Sem_Type is\n                return True;\n \n             elsif Etype (Par) /= Par then\n-               Par := Etype (Par);\n+\n+               --  If this is a private type and its parent is an interface\n+               --  then use the parent of the full view (which is a type that\n+               --  implements such interface)\n+\n+               if Is_Private_Type (Par)\n+                 and then Is_Interface (Etype (Par))\n+                 and then Present (Full_View (Par))\n+               then\n+                  Par := Etype (Full_View (Par));\n+               else\n+                  Par := Etype (Par);\n+               end if;\n             else\n                return False;\n             end if;"}]}