{"sha": "990124c35cd60cd23e0b70fc84cfb75311e80276", "node_id": "C_kwDOANBUbNoAKDk5MDEyNGMzNWNkNjBjZDIzZTBiNzBmYzg0Y2ZiNzUzMTFlODAyNzY", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-08-20T20:58:27Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-08-22T19:29:10Z"}, "message": "pru: Optimize 64-bit logical operations\n\nThe earlyclobber in the pattern yields inefficient code due to\nunnecessarily generated moves.  Optimize by removing the earlyclobber\nfor two special alternatives:\n  - If OP2 is a small constant integer.\n  - If the logical bit operation has only two operands.\n\ngcc/ChangeLog:\n\n\t* config/pru/pru.md (pru_<code>di3): New alternative for\n\ttwo operands but without earlyclobber.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/pru/bitop-di.c: New test.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "7fe10eacaf165e21eaa5acbd4da87a68b43bb398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fe10eacaf165e21eaa5acbd4da87a68b43bb398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/990124c35cd60cd23e0b70fc84cfb75311e80276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/990124c35cd60cd23e0b70fc84cfb75311e80276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/990124c35cd60cd23e0b70fc84cfb75311e80276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/990124c35cd60cd23e0b70fc84cfb75311e80276/comments", "author": null, "committer": null, "parents": [{"sha": "151effa22106a81f5835bb2dab7b95130f8fe2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151effa22106a81f5835bb2dab7b95130f8fe2ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151effa22106a81f5835bb2dab7b95130f8fe2ef"}], "stats": {"total": 64, "additions": 58, "deletions": 6}, "files": [{"sha": "144cd35d8098284ac5c8b95625a6e31186e174da", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990124c35cd60cd23e0b70fc84cfb75311e80276/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990124c35cd60cd23e0b70fc84cfb75311e80276/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=990124c35cd60cd23e0b70fc84cfb75311e80276", "patch": "@@ -786,15 +786,42 @@\n     operands[2] = force_reg (DImode, operands[2]);\n })\n \n+;; 64-bit pattern for logical operations.\n (define_insn \"pru_<code>di3\"\n-  [(set (match_operand:DI 0 \"register_operand\"\t\t\"=&r,&r\")\n+  [(set (match_operand:DI 0 \"register_operand\"\t\t\"=r,&r,r\")\n \t  (LOGICAL_BITOP:DI\n-\t    (match_operand:DI 1 \"register_operand\"\t\"%r,r\")\n-\t    (match_operand:DI 2 \"reg_or_ubyte_operand\"\t\"r,I\")))]\n+\t    (match_operand:DI 1 \"register_operand\"\t\"%0,r,r\")\n+\t    (match_operand:DI 2 \"reg_or_ubyte_operand\"\t\"r,r,I\")))]\n   \"\"\n-  \"@\n-   <logical_bitop_asm>\\\\t%F0, %F1, %F2\\;<logical_bitop_asm>\\\\t%N0, %N1, %N2\n-   <logical_bitop_asm>\\\\t%F0, %F1, %2\\;<logical_bitop_asm>\\\\t%N0, %N1, 0\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REGNO (operands[0]) == (REGNO (operands[2]) + 4))\n+\treturn \"<logical_bitop_asm>\\\\t%N0, %N0, %N2\\;\"\n+\t       \"<logical_bitop_asm>\\\\t%F0, %F0, %F2\";\n+      else\n+\treturn \"<logical_bitop_asm>\\\\t%F0, %F0, %F2\\;\"\n+\t       \"<logical_bitop_asm>\\\\t%N0, %N0, %N2\";\n+    case 1:\n+      /* With the three-register variant there is no way to handle the case\n+\t when OP0 overlaps both OP1 and OP2.  Example:\n+\t     OP0_lo == OP1_hi\n+\t     OP0_hi == OP2_lo\n+\t Hence this variant's OP0 must be marked as an earlyclobber.  */\n+      return \"<logical_bitop_asm>\\\\t%F0, %F1, %F2\\;\"\n+\t     \"<logical_bitop_asm>\\\\t%N0, %N1, %N2\";\n+    case 2:\n+      if (REGNO (operands[0]) == (REGNO (operands[1]) + 4))\n+\treturn \"<logical_bitop_asm>\\\\t%N0, %N1, 0\\;\"\n+\t       \"<logical_bitop_asm>\\\\t%F0, %F1, %2\";\n+      else\n+\treturn \"<logical_bitop_asm>\\\\t%F0, %F1, %2\\;\"\n+\t       \"<logical_bitop_asm>\\\\t%N0, %N1, 0\";\n+    default:\n+      gcc_unreachable ();\n+  }\n+}\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length\" \"8\")])\n "}, {"sha": "4290cdbc759fd32a57bc27844b23a653c68d618c", "filename": "gcc/testsuite/gcc.target/pru/bitop-di.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/990124c35cd60cd23e0b70fc84cfb75311e80276/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fbitop-di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/990124c35cd60cd23e0b70fc84cfb75311e80276/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fbitop-di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fbitop-di.c?ref=990124c35cd60cd23e0b70fc84cfb75311e80276", "patch": "@@ -0,0 +1,25 @@\n+/* 64-bit logical bit operations.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+unsigned long long\n+test_xor_di (unsigned long long val1, unsigned long long val2)\n+{\n+  /* { dg-final { scan-assembler \"xor\\\\tr14, r14, r16\" } } */\n+  return val1 ^ val2;\n+}\n+\n+unsigned long long\n+test_and_di (unsigned long long val1, unsigned long long val2)\n+{\n+  /* { dg-final { scan-assembler \"and\\\\tr14, r14, r16\" } } */\n+  return val1 & val2;\n+}\n+\n+unsigned long long\n+test_ior_di (unsigned long long val1, unsigned long long val2)\n+{\n+  /* { dg-final { scan-assembler \"or\\\\tr14, r14, r16\" } } */\n+  return val1 | val2;\n+}"}]}