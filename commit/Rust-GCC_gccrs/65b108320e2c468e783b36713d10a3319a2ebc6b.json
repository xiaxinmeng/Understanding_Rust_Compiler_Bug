{"sha": "65b108320e2c468e783b36713d10a3319a2ebc6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjViMTA4MzIwZTJjNDY4ZTc4M2IzNjcxM2QxMGEzMzE5YTJlYmM2Yg==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2005-06-16T08:29:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:29:44Z"}, "message": "gnatsym.adb: Adapt to modification of package Symbols...\n\n2005-06-14  Vincent Celier  <celier@adacore.com>\n\n\t* gnatsym.adb: Adapt to modification of package Symbols: procedure\n\tProcess is now in package Processing.\n\n\t* symbols.ads, symbols.adb:\n\t(Processing): New package, containing procedure Process\n\n\t* symbols-vms-alpha.adb:\n\tReplaced by symbols-vms.adb and symbols-processing-vms-alpha.adb\n\n\t* symbols-vms.adb, symbols-processing-vms-alpha.adb,\n\tsymbols-processing-vms-ia64.adb: New files.\n\nFrom-SVN: r101018", "tree": {"sha": "1ca1dce2c860624d8d9d125aa9c44483752fcbda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ca1dce2c860624d8d9d125aa9c44483752fcbda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65b108320e2c468e783b36713d10a3319a2ebc6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b108320e2c468e783b36713d10a3319a2ebc6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b108320e2c468e783b36713d10a3319a2ebc6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b108320e2c468e783b36713d10a3319a2ebc6b/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df0db19f6982f910d61e99e61e98d4a7340db696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0db19f6982f910d61e99e61e98d4a7340db696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df0db19f6982f910d61e99e61e98d4a7340db696"}], "stats": {"total": 918, "additions": 686, "deletions": 232}, "files": [{"sha": "23ed29457f42b2902d05a0b4e71333895b5c04a3", "filename": "gcc/ada/gnatsym.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fgnatsym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fgnatsym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatsym.adb?ref=65b108320e2c468e783b36713d10a3319a2ebc6b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -253,7 +253,7 @@ begin\n             Write_Line (\"\"\"\");\n          end if;\n \n-         Process (Object_Files.Table (Object_File).all, Success);\n+         Processing.Process (Object_Files.Table (Object_File).all, Success);\n       end loop;\n \n       --  Finalize the object file"}, {"sha": "c73bb087dbf68db08887c6831a81e050ac4f1524", "filename": "gcc/ada/symbols-processing-vms-alpha.adb", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb?ref=65b108320e2c468e783b36713d10a3319a2ebc6b", "patch": "@@ -0,0 +1,235 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y M B O L S . P R O C E S S I N G                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the VMS Alpha version of this package\n+\n+separate (Symbols)\n+package body Processing is\n+\n+   type Number is mod 2**16;\n+   --  16 bits unsigned number for number of characters\n+\n+   GSD : constant Number := 10;\n+   --  Code for the Global Symbol Definition section\n+\n+   C_SYM : constant Number := 1;\n+   --  Code for a Symbol subsection\n+\n+   V_DEF_Mask  : constant Number := 2**1;\n+   V_NORM_Mask : constant Number := 2**6;\n+\n+   B : Byte;\n+\n+   Number_Of_Characters : Natural := 0;\n+   --  The number of characters of each section\n+\n+   --  The following variables are used by procedure Process when reading an\n+   --  object file.\n+\n+   Code   : Number := 0;\n+   Length : Natural := 0;\n+\n+   Dummy : Number;\n+\n+   Nchars : Natural := 0;\n+   Flags  : Number  := 0;\n+\n+   Symbol : String (1 .. 255);\n+   LSymb  : Natural;\n+\n+   procedure Get (N : out Number);\n+   --  Read two bytes from the object file LSB first as unsigned 16 bit number\n+\n+   procedure Get (N : out Natural);\n+   --  Read two bytes from the object file, LSByte first, as a Natural\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get (N : out Number) is\n+      C : Byte;\n+      LSByte : Number;\n+   begin\n+      Read (File, C);\n+      LSByte := Byte'Pos (C);\n+      Read (File, C);\n+      N := LSByte + (256 * Byte'Pos (C));\n+   end Get;\n+\n+   procedure Get (N : out Natural) is\n+      Result : Number;\n+   begin\n+      Get (Result);\n+      N := Natural (Result);\n+   end Get;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   procedure Process\n+     (Object_File : String;\n+      Success     : out Boolean)\n+   is\n+   begin\n+      --  Open the object file with Byte_IO. Return with Success = False if\n+      --  this fails.\n+\n+      begin\n+         Open (File, In_File, Object_File);\n+      exception\n+         when others =>\n+            Put_Line\n+              (\"*** Unable to open object file \"\"\" & Object_File & \"\"\"\");\n+            Success := False;\n+            return;\n+      end;\n+\n+      --  Assume that the object file has a correct format\n+\n+      Success := True;\n+\n+      --  Get the different sections one by one from the object file\n+\n+      while not End_Of_File (File) loop\n+\n+         Get (Code);\n+         Get (Number_Of_Characters);\n+         Number_Of_Characters := Number_Of_Characters - 4;\n+\n+         --  If this is not a Global Symbol Definition section, skip to the\n+         --  next section.\n+\n+         if Code /= GSD then\n+\n+            for J in 1 .. Number_Of_Characters loop\n+               Read (File, B);\n+            end loop;\n+\n+         else\n+\n+            --  Skip over the next 4 bytes\n+\n+            Get (Dummy);\n+            Get (Dummy);\n+            Number_Of_Characters := Number_Of_Characters - 4;\n+\n+            --  Get each subsection in turn\n+\n+            loop\n+               Get (Code);\n+               Get (Nchars);\n+               Get (Dummy);\n+               Get (Flags);\n+               Number_Of_Characters := Number_Of_Characters - 8;\n+               Nchars := Nchars - 8;\n+\n+               --  If this is a symbol and the V_DEF flag is set, get the\n+               --  symbol.\n+\n+               if Code = C_SYM and then ((Flags and V_DEF_Mask) /= 0) then\n+                  --  First, reach the symbol length\n+\n+                  for J in 1 .. 25 loop\n+                     Read (File, B);\n+                     Nchars := Nchars - 1;\n+                     Number_Of_Characters := Number_Of_Characters - 1;\n+                  end loop;\n+\n+                  Length := Byte'Pos (B);\n+                  LSymb := 0;\n+\n+                  --  Get the symbol characters\n+\n+                  for J in 1 .. Nchars loop\n+                     Read (File, B);\n+                     Number_Of_Characters := Number_Of_Characters - 1;\n+                     if Length > 0 then\n+                        LSymb := LSymb + 1;\n+                        Symbol (LSymb) := B;\n+                        Length := Length - 1;\n+                     end if;\n+                  end loop;\n+\n+                  --  Create the new Symbol\n+\n+                  declare\n+                     S_Data : Symbol_Data;\n+                  begin\n+                     S_Data.Name := new String'(Symbol (1 .. LSymb));\n+\n+                     --  The symbol kind (Data or Procedure) depends on the\n+                     --  V_NORM flag.\n+\n+                     if (Flags and V_NORM_Mask) = 0 then\n+                        S_Data.Kind := Data;\n+\n+                     else\n+                        S_Data.Kind := Proc;\n+                     end if;\n+\n+                     --  Put the new symbol in the table\n+\n+                     Symbol_Table.Increment_Last (Complete_Symbols);\n+                     Complete_Symbols.Table\n+                       (Symbol_Table.Last (Complete_Symbols)) := S_Data;\n+                  end;\n+\n+               else\n+                  --  As it is not a symbol subsection, skip to the next\n+                  --  subsection.\n+\n+                  for J in 1 .. Nchars loop\n+                     Read (File, B);\n+                     Number_Of_Characters := Number_Of_Characters - 1;\n+                  end loop;\n+               end if;\n+\n+               --  Exit the GSD section when number of characters reaches 0\n+\n+               exit when Number_Of_Characters = 0;\n+            end loop;\n+         end if;\n+      end loop;\n+\n+      --  The object file has been processed, close it\n+\n+      Close (File);\n+\n+   exception\n+      --  For any exception, output an error message, close the object file\n+      --  and return with Success = False.\n+\n+      when X : others =>\n+         Put_Line (\"unexpected exception raised while processing \"\"\"\n+                   & Object_File & \"\"\"\");\n+         Put_Line (Exception_Information (X));\n+         Close (File);\n+         Success := False;\n+   end Process;\n+\n+end Processing;"}, {"sha": "66f7bdd53393d60be8bab06c9d03d758a02fd9e4", "filename": "gcc/ada/symbols-processing-vms-ia64.adb", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb?ref=65b108320e2c468e783b36713d10a3319a2ebc6b", "patch": "@@ -0,0 +1,367 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y M B O L S . P R O C E S S I N G                   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the VMS/IA64 version of this package\n+\n+with Ada.IO_Exceptions;\n+\n+with Ada.Unchecked_Deallocation;\n+\n+separate (Symbols)\n+package body Processing is\n+\n+   type String_Array is array (Positive range <>) of String_Access;\n+   type Strings_Ptr is access String_Array;\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (String_Array, Strings_Ptr);\n+\n+   type Section_Header is record\n+      Shname   : Integer;\n+      Shtype   : Integer;\n+      Shoffset : Integer;\n+      Shsize   : Integer;\n+      Shlink   : Integer;\n+   end record;\n+\n+   type Section_Header_Array is array (Natural range <>) of Section_Header;\n+   type Section_Header_Ptr is access Section_Header_Array;\n+\n+   procedure Free is\n+     new Ada.Unchecked_Deallocation (Section_Header_Array, Section_Header_Ptr);\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   procedure Process\n+     (Object_File : String;\n+      Success     : out Boolean)\n+   is\n+      B : Byte;\n+      H : Integer;\n+      W : Integer;\n+\n+      Str : String (1 .. 1000) := (others => ' ');\n+      Str_Last : Natural;\n+\n+      Strings : Strings_Ptr;\n+\n+      Shoff : Integer;\n+      Shnum : Integer;\n+      Shentsize : Integer;\n+\n+      Shname   : Integer;\n+      Shtype   : Integer;\n+      Shoffset : Integer;\n+      Shsize   : Integer;\n+      Shlink   : Integer;\n+\n+      Symtab_Index       : Natural := 0;\n+      String_Table_Index : Natural := 0;\n+\n+      End_Symtab : Integer;\n+\n+      Stname : Integer;\n+      Stinfo : Character;\n+      Sttype : Integer;\n+      Stbind : Integer;\n+      Stshndx : Integer;\n+\n+      Section_Headers : Section_Header_Ptr;\n+\n+      Offset   : Natural := 0;\n+\n+      procedure Get_Byte (B : out Byte);\n+      procedure Get_Half (H : out Integer);\n+      procedure Get_Word (W : out Integer);\n+      procedure Reset;\n+\n+      procedure Get_Byte (B : out Byte) is\n+      begin\n+         Byte_IO.Read (File, B);\n+         Offset := Offset + 1;\n+      end Get_Byte;\n+\n+      procedure Get_Half (H : out Integer) is\n+         C1, C2 : Character;\n+      begin\n+         Get_Byte (C1); Get_Byte (C2);\n+         H :=\n+           Integer'(Character'Pos (C2)) * 256 + Integer'(Character'Pos (C1));\n+      end Get_Half;\n+\n+      procedure Get_Word (W : out Integer) is\n+         H1, H2 : Integer;\n+      begin\n+         Get_Half (H1); Get_Half (H2);\n+         W := H2 * 256 * 256 + H1;\n+      end Get_Word;\n+\n+      procedure Reset is\n+      begin\n+         Offset := 0;\n+         Byte_IO.Reset (File);\n+      end Reset;\n+\n+   begin\n+      --  Open the object file with Byte_IO. Return with Success = False if\n+      --  this fails.\n+\n+      begin\n+         Open (File, In_File, Object_File);\n+      exception\n+         when others =>\n+            Put_Line\n+              (\"*** Unable to open object file \"\"\" & Object_File & \"\"\"\");\n+            Success := False;\n+            return;\n+      end;\n+\n+      --  Assume that the object file has a correct format\n+\n+      Success := True;\n+\n+      --  Skip ELF identification\n+\n+      while Offset < 16 loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      --  Skip e_type\n+\n+      Get_Half (H);\n+\n+      --  Skip e_machine\n+\n+      Get_Half (H);\n+\n+      --  Skip e_version\n+\n+      Get_Word (W);\n+\n+      --  Skip e_entry\n+\n+      for J in 1 .. 8 loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      --  Skip e_phoff\n+\n+      for J in 1 .. 8 loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      Get_Word (Shoff);\n+\n+      --  Skip upper half of Shoff\n+\n+      for J in 1 .. 4 loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      --  Skip e_flags\n+\n+      Get_Word (W);\n+\n+      --  Skip e_ehsize\n+\n+      Get_Half (H);\n+\n+      --  Skip e_phentsize\n+\n+      Get_Half (H);\n+\n+      --  Skip e_phnum\n+\n+      Get_Half (H);\n+\n+      Get_Half (Shentsize);\n+\n+      Get_Half (Shnum);\n+\n+      Section_Headers := new Section_Header_Array (0 .. Shnum - 1);\n+\n+      --  Go to Section Headers\n+\n+      while Offset < Shoff loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      --  Reset Symtab_Index\n+\n+      Symtab_Index := 0;\n+\n+      for J in Section_Headers'Range loop\n+         --  Get the data for each Section Header\n+\n+         Get_Word (Shname);\n+         Get_Word (Shtype);\n+\n+         for K in 1 .. 16 loop\n+            Get_Byte (B);\n+         end loop;\n+\n+         Get_Word (Shoffset);\n+         Get_Word (W);\n+\n+         Get_Word (Shsize);\n+         Get_Word (W);\n+\n+         Get_Word (Shlink);\n+\n+         while (Offset - Shoff) mod Shentsize /= 0 loop\n+            Get_Byte (B);\n+         end loop;\n+\n+         --  If this is the Symbol Table Section Header, record its index\n+\n+         if Shtype = 2 then\n+            Symtab_Index := J;\n+         end if;\n+\n+         Section_Headers (J) := (Shname, Shtype, Shoffset, Shsize, Shlink);\n+      end loop;\n+\n+      if Symtab_Index = 0 then\n+         Success := False;\n+         return;\n+      end if;\n+\n+      End_Symtab :=\n+        Section_Headers (Symtab_Index).Shoffset +\n+        Section_Headers (Symtab_Index).Shsize;\n+\n+      String_Table_Index := Section_Headers (Symtab_Index).Shlink;\n+      Strings :=\n+        new String_Array (1 .. Section_Headers (String_Table_Index).Shsize);\n+\n+      --  Go get the String Table section for the Symbol Table\n+\n+      Reset;\n+\n+      while Offset < Section_Headers (String_Table_Index).Shoffset loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      Offset := 0;\n+\n+      Get_Byte (B);  --  zero\n+\n+      while Offset < Section_Headers (String_Table_Index).Shsize loop\n+         Str_Last := 0;\n+\n+         loop\n+            Get_Byte (B);\n+            if B /= ASCII.NUL then\n+               Str_Last := Str_Last + 1;\n+               Str (Str_Last) := B;\n+\n+            else\n+               Strings (Offset - Str_Last - 1) :=\n+                 new String'(Str (1 .. Str_Last));\n+               exit;\n+            end if;\n+         end loop;\n+      end loop;\n+\n+      --  Go get the Symbol Table\n+\n+      Reset;\n+\n+      while Offset < Section_Headers (Symtab_Index).Shoffset loop\n+         Get_Byte (B);\n+      end loop;\n+\n+      while Offset < End_Symtab loop\n+         Get_Word (Stname);\n+         Get_Byte (Stinfo);\n+         Get_Byte (B);\n+         Get_Half (Stshndx);\n+         for J in 1 .. 4 loop\n+            Get_Word (W);\n+         end loop;\n+\n+         Sttype := Integer'(Character'Pos (Stinfo)) mod 16;\n+         Stbind := Integer'(Character'Pos (Stinfo)) / 16;\n+\n+         if (Sttype = 1 or else Sttype = 2)\n+              and then Stbind /= 0\n+              and then Stshndx /= 0\n+         then\n+            declare\n+               S_Data : Symbol_Data;\n+            begin\n+               S_Data.Name := new String'(Strings (Stname).all);\n+\n+               if Sttype = 1 then\n+                  S_Data.Kind := Data;\n+\n+               else\n+                  S_Data.Kind := Proc;\n+               end if;\n+\n+               --  Put the new symbol in the table\n+\n+               Symbol_Table.Increment_Last (Complete_Symbols);\n+               Complete_Symbols.Table\n+                 (Symbol_Table.Last (Complete_Symbols)) := S_Data;\n+            end;\n+         end if;\n+      end loop;\n+\n+      --  The object file has been processed, close it\n+\n+      Close (File);\n+\n+      --  Free the allocated memory\n+\n+      Free (Section_Headers);\n+\n+      for J in Strings'Range loop\n+         if Strings (J) /= null then\n+            Free (Strings (J));\n+         end if;\n+      end loop;\n+\n+      Free (Strings);\n+\n+   exception\n+      --  For any exception, output an error message, close the object file\n+      --  and return with Success = False.\n+\n+      when Ada.IO_Exceptions.End_Error =>\n+         Close (File);\n+\n+      when X : others =>\n+         Put_Line (\"unexpected exception raised while processing \"\"\"\n+                   & Object_File & \"\"\"\");\n+         Put_Line (Exception_Information (X));\n+         Close (File);\n+         Success := False;\n+   end Process;\n+\n+end Processing;"}, {"sha": "6dcb4a4de42e70c5b6b048ccc65f87172ffdcb9e", "filename": "gcc/ada/symbols-vms.adb", "status": "renamed", "additions": 46, "deletions": 211, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-vms.adb?ref=65b108320e2c468e783b36713d10a3319a2ebc6b", "patch": "@@ -36,7 +36,8 @@ package body Symbols is\n    Symbol_Vector   : constant String := \"SYMBOL_VECTOR=(\";\n    Equal_Data      : constant String := \"=DATA)\";\n    Equal_Procedure : constant String := \"=PROCEDURE)\";\n-   Gsmatch         : constant String := \"gsmatch=lequal,\";\n+   Gsmatch         : constant String := \"gsmatch=\";\n+   Gsmatch_Lequal  : constant String := \"gsmatch=lequal,\";\n \n    Symbol_File_Name : String_Access := null;\n    --  Name of the symbol file\n@@ -69,50 +70,12 @@ package body Symbols is\n    package Byte_IO is new Ada.Sequential_IO (Byte);\n    use Byte_IO;\n \n-   type Number is mod 2**16;\n-   --  16 bits unsigned number for number of characters\n-\n-   GSD : constant Number := 10;\n-   --  Code for the Global Symbol Definition section\n-\n-   C_SYM : constant Number := 1;\n-   --  Code for a Symbol subsection\n-\n-   V_DEF_Mask  : constant Number := 2**1;\n-   V_NORM_Mask : constant Number := 2**6;\n-\n    File : Byte_IO.File_Type;\n    --  Each object file is read as a stream of bytes (characters)\n \n-   B : Byte;\n-\n-   Number_Of_Characters : Natural := 0;\n-   --  The number of characters of each section\n-\n-   --  The following variables are used by procedure Process when reading an\n-   --  object file.\n-\n-   Code   : Number := 0;\n-   Length : Natural := 0;\n-\n-   Dummy : Number;\n-\n-   Nchars : Natural := 0;\n-   Flags  : Number  := 0;\n-\n-   Symbol : String (1 .. 255);\n-   LSymb  : Natural;\n-\n    function Equal (Left, Right : Symbol_Data) return Boolean;\n    --  Test for equality of symbols\n \n-   procedure Get (N : out Number);\n-   --  Read two bytes from the object file LSB first as unsigned 16 bit number\n-\n-   procedure Get (N : out Natural);\n-   --  Read two bytes from the object file, LSByte first, as a Natural\n-\n-\n    function Image (N : Integer) return String;\n    --  Returns the image of N, without the initial space\n \n@@ -129,27 +92,6 @@ package body Symbols is\n              Left.Present = Right.Present;\n    end Equal;\n \n-   ---------\n-   -- Get --\n-   ---------\n-\n-   procedure Get (N : out Number) is\n-      C : Byte;\n-      LSByte : Number;\n-   begin\n-      Read (File, C);\n-      LSByte := Byte'Pos (C);\n-      Read (File, C);\n-      N := LSByte + (256 * Byte'Pos (C));\n-   end Get;\n-\n-   procedure Get (N : out Natural) is\n-      Result : Number;\n-   begin\n-      Get (Result);\n-      N := Natural (Result);\n-   end Get;\n-\n    -----------\n    -- Image --\n    -----------\n@@ -343,7 +285,7 @@ package body Symbols is\n                   return;\n                end if;\n \n-            --  Lines with \"gsmatch=equal,<Major_ID>,<Minor_Id>\n+            --  Lines with \"gsmatch=lequal,\" or \"gsmatch=equal,\"\n \n             elsif Last > Gsmatch'Length\n               and then Line (1 .. Gsmatch'Length) = Gsmatch\n@@ -355,19 +297,41 @@ package body Symbols is\n                   ID     : Integer;\n \n                begin\n+                  --  First, look for the first coma\n+\n                   loop\n-                     if Line (Finish) not in '0' .. '9'\n-                       or else Finish >= Last - 1\n-                     then\n+                     if Start >= Last - 1 then\n                         OK := False;\n                         exit;\n-                     end if;\n \n-                     exit when Line (Finish + 1) = ',';\n+                     elsif Line (Start) = ',' then\n+                        Start := Start + 1;\n+                        exit;\n \n-                     Finish := Finish + 1;\n+                     else\n+                        Start := Start + 1;\n+                     end if;\n                   end loop;\n \n+                  Finish := Start;\n+\n+                  --  If the comma is found, get the Major and the Minor IDs\n+\n+                  if OK then\n+                     loop\n+                        if Line (Finish) not in '0' .. '9'\n+                          or else Finish >= Last - 1\n+                        then\n+                           OK := False;\n+                           exit;\n+                        end if;\n+\n+                        exit when Line (Finish + 1) = ',';\n+\n+                        Finish := Finish + 1;\n+                     end loop;\n+                  end if;\n+\n                   if OK then\n                      ID := Integer'Value (Line (Start .. Finish));\n                      OK := ID /= 0;\n@@ -445,150 +409,11 @@ package body Symbols is\n       end if;\n    end Initialize;\n \n-   -------------\n-   -- Process --\n-   -------------\n-\n-   procedure Process\n-     (Object_File : String;\n-      Success     : out Boolean)\n-   is\n-   begin\n-      --  Open the object file with Byte_IO. Return with Success = False if\n-      --  this fails.\n-\n-      begin\n-         Open (File, In_File, Object_File);\n-      exception\n-         when others =>\n-            Put_Line\n-              (\"*** Unable to open object file \"\"\" & Object_File & \"\"\"\");\n-            Success := False;\n-            return;\n-      end;\n-\n-      --  Assume that the object file has a correct format\n-\n-      Success := True;\n-\n-      --  Get the different sections one by one from the object file\n-\n-      while not End_Of_File (File) loop\n-\n-         Get (Code);\n-         Get (Number_Of_Characters);\n-         Number_Of_Characters := Number_Of_Characters - 4;\n-\n-         --  If this is not a Global Symbol Definition section, skip to the\n-         --  next section.\n-\n-         if Code /= GSD then\n-\n-            for J in 1 .. Number_Of_Characters loop\n-               Read (File, B);\n-            end loop;\n-\n-         else\n-\n-            --  Skip over the next 4 bytes\n-\n-            Get (Dummy);\n-            Get (Dummy);\n-            Number_Of_Characters := Number_Of_Characters - 4;\n-\n-            --  Get each subsection in turn\n-\n-            loop\n-               Get (Code);\n-               Get (Nchars);\n-               Get (Dummy);\n-               Get (Flags);\n-               Number_Of_Characters := Number_Of_Characters - 8;\n-               Nchars := Nchars - 8;\n-\n-               --  If this is a symbol and the V_DEF flag is set, get the\n-               --  symbol.\n-\n-               if Code = C_SYM and then ((Flags and V_DEF_Mask) /= 0) then\n-                  --  First, reach the symbol length\n-\n-                  for J in 1 .. 25 loop\n-                     Read (File, B);\n-                     Nchars := Nchars - 1;\n-                     Number_Of_Characters := Number_Of_Characters - 1;\n-                  end loop;\n-\n-                  Length := Byte'Pos (B);\n-                  LSymb := 0;\n-\n-                  --  Get the symbol characters\n-\n-                  for J in 1 .. Nchars loop\n-                     Read (File, B);\n-                     Number_Of_Characters := Number_Of_Characters - 1;\n-                     if Length > 0 then\n-                        LSymb := LSymb + 1;\n-                        Symbol (LSymb) := B;\n-                        Length := Length - 1;\n-                     end if;\n-                  end loop;\n-\n-                  --  Create the new Symbol\n-\n-                  declare\n-                     S_Data : Symbol_Data;\n-                  begin\n-                     S_Data.Name := new String'(Symbol (1 .. LSymb));\n-\n-                     --  The symbol kind (Data or Procedure) depends on the\n-                     --  V_NORM flag.\n-\n-                     if (Flags and V_NORM_Mask) = 0 then\n-                        S_Data.Kind := Data;\n-\n-                     else\n-                        S_Data.Kind := Proc;\n-                     end if;\n-\n-                     --  Put the new symbol in the table\n-\n-                     Symbol_Table.Increment_Last (Complete_Symbols);\n-                     Complete_Symbols.Table\n-                       (Symbol_Table.Last (Complete_Symbols)) := S_Data;\n-                  end;\n-\n-               else\n-                  --  As it is not a symbol subsection, skip to the next\n-                  --  subsection.\n-\n-                  for J in 1 .. Nchars loop\n-                     Read (File, B);\n-                     Number_Of_Characters := Number_Of_Characters - 1;\n-                  end loop;\n-               end if;\n-\n-               --  Exit the GSD section when number of characters reaches 0\n-\n-               exit when Number_Of_Characters = 0;\n-            end loop;\n-         end if;\n-      end loop;\n-\n-      --  The object file has been processed, close it\n-\n-      Close (File);\n-\n-   exception\n-      --  For any exception, output an error message, close the object file\n-      --  and return with Success = False.\n+   ----------------\n+   -- Processing --\n+   ----------------\n \n-      when X : others =>\n-         Put_Line (\"unexpected exception raised while processing \"\"\"\n-                   & Object_File & \"\"\"\");\n-         Put_Line (Exception_Information (X));\n-         Close (File);\n-         Success := False;\n-   end Process;\n+   package body Processing is separate;\n \n    --------------\n    -- Finalize --\n@@ -668,6 +493,11 @@ package body Symbols is\n                   Success := False;\n                   return;\n \n+               --  Any symbol that is undefined in the reference symbol file\n+               --  triggers an increase of the Major ID, because the new\n+               --  version of the library is no longer compatible with\n+               --  existing executables.\n+\n                elsif Soft_Major_ID then\n                   Major_ID := Major_ID + 1;\n                   Minor_ID := 0;\n@@ -677,6 +507,11 @@ package body Symbols is\n \n                Original_Symbols.Table (Index_1).Present := False;\n                Free (Original_Symbols.Table (Index_1).Name);\n+\n+               if Soft_Minor_ID then\n+                  Minor_ID := Minor_ID + 1;\n+                  Soft_Minor_ID := False;\n+               end if;\n             end if;\n          end loop;\n \n@@ -738,7 +573,7 @@ package body Symbols is\n \n             --  Put the version IDs\n \n-            Put (File, Gsmatch);\n+            Put (File, Gsmatch_Lequal);\n             Put (File, Image (Major_ID));\n             Put (File, ',');\n             Put_Line  (File, Image (Minor_ID));", "previous_filename": "gcc/ada/symbols-vms-alpha.adb"}, {"sha": "6f021b904f2e59ddf1a0d22230d19567dc4ef470", "filename": "gcc/ada/symbols.adb", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols.adb?ref=65b108320e2c468e783b36713d10a3319a2ebc6b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003 Free Software Foundation, Inc.               --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,18 +54,26 @@ package body Symbols is\n       Success := False;\n    end Initialize;\n \n-   -------------\n-   -- Process --\n-   -------------\n+   ----------------\n+   -- Processing --\n+   ----------------\n \n-   procedure Process\n-     (Object_File : String;\n-      Success     : out Boolean)\n-   is\n-      pragma Unreferenced (Object_File);\n-   begin\n-      Success := False;\n-   end Process;\n+   package body Processing is\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process\n+        (Object_File : String;\n+         Success     : out Boolean)\n+      is\n+         pragma Unreferenced (Object_File);\n+      begin\n+         Success := False;\n+      end Process;\n+\n+   end Processing;\n \n    --------------\n    -- Finalize --"}, {"sha": "049751b652d1dc1193ce6ca1e72ec9a2b7e340cf", "filename": "gcc/ada/symbols.ads", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b108320e2c468e783b36713d10a3319a2ebc6b/gcc%2Fada%2Fsymbols.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols.ads?ref=65b108320e2c468e783b36713d10a3319a2ebc6b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2003-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,7 @@ package Symbols is\n       --  all symbols are already found in the reference file or with an\n       --  incremented minor ID, if not.\n \n-       Controlled,\n+      Controlled,\n       --  Fail if symbols are not the same as those in the reference file\n \n       Restricted);\n@@ -86,11 +86,20 @@ package Symbols is\n    --  Processing any object file. Depending on the platforms and the\n    --  circumstances, additional messages may be issued if Quiet is False.\n \n-   procedure Process\n-     (Object_File : String;\n-      Success     : out Boolean);\n-   --  Get the symbols from an object file. Success is set to True if the\n-   --  object file exists and has the expected format.\n+   package Processing is\n+\n+   --  This package, containing a single visible procedure Process, exists so\n+   --  that it can be a subunits, for some platforms (such as VMS Alpha and\n+   --  IA64), the body of package Symbols is common, while the subunit\n+   --  Processing is not.\n+\n+      procedure Process\n+        (Object_File : String;\n+         Success     : out Boolean);\n+      --  Get the symbols from an object file. Success is set to True if the\n+      --  object file exists and has the expected format.\n+\n+   end Processing;\n \n    procedure Finalize\n      (Quiet   : Boolean;"}]}