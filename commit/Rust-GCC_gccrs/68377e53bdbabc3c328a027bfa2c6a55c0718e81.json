{"sha": "68377e53bdbabc3c328a027bfa2c6a55c0718e81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzNzdlNTNiZGJhYmMzYzMyOGEwMjdiZmEyYzZhNTVjMDcxOGU4MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-11-19T10:05:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-11-19T10:05:54Z"}, "message": "cgraph.c (cgraph_create_indirect_edge): Use get_polymorphic_call_info.\n\n\n\t* cgraph.c (cgraph_create_indirect_edge): Use get_polymorphic_call_info.\n\t* cgraph.h (cgraph_indirect_call_info): Add outer_type, maybe_in_construction\n\tand maybe_derived_type.\n\t* ipa-utils.h (ipa_polymorphic_call_context): New structure.\n\t(ipa_dummy_polymorphic_call_context): New global var.\n\t(possible_polymorphic_call_targets): Add context paramter.\n\t(dump_possible_polymorphic_call_targets): Likewise; update\n\twrappers.\n\t(possible_polymorphic_call_target_p): Likewise.\n\t(get_polymorphic_call_info): New function.\n\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): New function.\n\t(add_type_duplicate): Remove forgotten debug output.\n\t(method_class_type): Add sanity check.\n\t(maybe_record_node): Add FINALP parameter.\n\t(record_binfo): Add OUTER_TYPE and OFFSET; walk the inner\n\tby info by get_binfo_at_offset.\n\t(possible_polymorphic_call_targets_1): Add OUTER_TYPE/OFFSET parameters;\n\tpass them to record-binfo.\n\t(polymorphic_call_target_d): Add context and FINAL.\n\t(polymorphic_call_target_hasher::hash): Hash context.\n\t(polymorphic_call_target_hasher::equal): Compare context.\n\t(free_polymorphic_call_targets_hash):\n\t(get_class_context): New function.\n\t(contains_type_p): New function.\n\t(get_polymorphic_call_info): New function.\n\t(walk_bases): New function.\n\t(possible_polymorphic_call_targets): Add context parameter; honnor it.\n\t(dump_possible_polymorphic_call_targets): Dump context.\n\t(possible_polymorphic_call_target_p): Add context.\n\t(update_type_inheritance_graph): Update comment.s\n\t(ipa_set_jf_known_type): Assert that compoentn type is known.\n\t(ipa_note_param_call): Do not tamper with offsets.\n\t(ipa_analyze_indirect_call_uses): When offset is being changed; clear\n\touter type.\n\t(update_indirect_edges_after_inlining): Likewise.\n\t(ipa_write_indirect_edge_info): Stream new fields.\n\t(ipa_read_indirect_edge_info): Stream in new fields.\n\n\t* ipa/devirt9.C: Verify that the optimization happens already before.\n\twhole-program.\n\nFrom-SVN: r205019", "tree": {"sha": "c0b5c5a3a1faceb961648fb593887aa1fdf1fc1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0b5c5a3a1faceb961648fb593887aa1fdf1fc1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68377e53bdbabc3c328a027bfa2c6a55c0718e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68377e53bdbabc3c328a027bfa2c6a55c0718e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68377e53bdbabc3c328a027bfa2c6a55c0718e81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68377e53bdbabc3c328a027bfa2c6a55c0718e81/comments", "author": null, "committer": null, "parents": [{"sha": "d345bb301ad3ebfce372ce11cc9a6adc35e79e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d345bb301ad3ebfce372ce11cc9a6adc35e79e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d345bb301ad3ebfce372ce11cc9a6adc35e79e8b"}], "stats": {"total": 768, "additions": 669, "deletions": 99}, "files": [{"sha": "68075c14dc2b2b3075391755133b0fbcda8de19f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -1,3 +1,43 @@\n+2013-11-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_create_indirect_edge): Use get_polymorphic_call_info.\n+\t* cgraph.h (cgraph_indirect_call_info): Add outer_type, maybe_in_construction\n+\tand maybe_derived_type.\n+\t* ipa-utils.h (ipa_polymorphic_call_context): New structure.\n+\t(ipa_dummy_polymorphic_call_context): New global var.\n+\t(possible_polymorphic_call_targets): Add context paramter.\n+\t(dump_possible_polymorphic_call_targets): Likewise; update\n+\twrappers.\n+\t(possible_polymorphic_call_target_p): Likewise.\n+\t(get_polymorphic_call_info): New function.\n+\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): New function.\n+\t(add_type_duplicate): Remove forgotten debug output.\n+\t(method_class_type): Add sanity check.\n+\t(maybe_record_node): Add FINALP parameter.\n+\t(record_binfo): Add OUTER_TYPE and OFFSET; walk the inner\n+\tby info by get_binfo_at_offset.\n+\t(possible_polymorphic_call_targets_1): Add OUTER_TYPE/OFFSET parameters;\n+\tpass them to record-binfo.\n+\t(polymorphic_call_target_d): Add context and FINAL.\n+\t(polymorphic_call_target_hasher::hash): Hash context.\n+\t(polymorphic_call_target_hasher::equal): Compare context.\n+\t(free_polymorphic_call_targets_hash):\n+\t(get_class_context): New function.\n+\t(contains_type_p): New function.\n+\t(get_polymorphic_call_info): New function.\n+\t(walk_bases): New function.\n+\t(possible_polymorphic_call_targets): Add context parameter; honnor it.\n+\t(dump_possible_polymorphic_call_targets): Dump context.\n+\t(possible_polymorphic_call_target_p): Add context.\n+\t(update_type_inheritance_graph): Update comment.s\n+\t(ipa_set_jf_known_type): Assert that compoentn type is known.\n+\t(ipa_note_param_call): Do not tamper with offsets.\n+\t(ipa_analyze_indirect_call_uses): When offset is being changed; clear\n+\touter type.\n+\t(update_indirect_edges_after_inlining): Likewise.\n+\t(ipa_write_indirect_edge_info): Stream new fields.\n+\t(ipa_read_indirect_edge_info): Stream in new fields.\n+\n 2013-11-19  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-pretty-print.c (dump_generic_node): Print class type of"}, {"sha": "996f1b660900ad47f6a65ce670522b6311e531c8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -959,16 +959,26 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n       && (target = gimple_call_fn (call_stmt))\n       && virtual_method_call_p (target))\n     {\n-      tree type = obj_type_ref_class (target);\n+      tree otr_type;\n+      HOST_WIDE_INT otr_token;\n+      ipa_polymorphic_call_context context;\n \n+      get_polymorphic_call_info (caller->decl,\n+\t\t\t\t target,\n+\t\t\t\t &otr_type, &otr_token,\n+\t\t\t\t &context);\n \n       /* Only record types can have virtual calls.  */\n-      gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n+      gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);\n+      edge->indirect_info->polymorphic = true;\n       edge->indirect_info->param_index = -1;\n-      edge->indirect_info->otr_token\n-\t = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n-      edge->indirect_info->otr_type = type;\n-      edge->indirect_info->polymorphic = 1;\n+      edge->indirect_info->otr_token = otr_token;\n+      edge->indirect_info->otr_type = otr_type;\n+      edge->indirect_info->outer_type = context.outer_type;\n+      edge->indirect_info->offset = context.offset;\n+      edge->indirect_info->maybe_in_construction\n+\t = context.maybe_in_construction;\n+      edge->indirect_info->maybe_derived_type = context.maybe_derived_type;\n     }\n \n   edge->next_callee = caller->indirect_calls;"}, {"sha": "f81b7b533ff86eee635e617abf5decafa5f782eb", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -434,7 +434,7 @@ struct GTY(()) cgraph_indirect_call_info\n   /* OBJ_TYPE_REF_TOKEN of a polymorphic call (if polymorphic is set).  */\n   HOST_WIDE_INT otr_token;\n   /* Type of the object from OBJ_TYPE_REF_OBJECT. */\n-  tree otr_type;\n+  tree otr_type, outer_type;\n   /* Index of the parameter that is called.  */\n   int param_index;\n   /* ECF flags determined from the caller.  */\n@@ -455,6 +455,8 @@ struct GTY(()) cgraph_indirect_call_info\n   /* When the previous bit is set, this one determines whether the destination\n      is loaded from a parameter passed by reference. */\n   unsigned by_ref : 1;\n+  unsigned int maybe_in_construction : 1;\n+  unsigned int maybe_derived_type : 1;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {"}, {"sha": "99fbfe7455a02915db755ce4cd666f68f8454f3d", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 532, "deletions": 83, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -121,6 +121,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"ipa-inline.h\"\n #include \"diagnostic.h\"\n+#include \"tree-dfa.h\"\n+\n+/* Dummy polymorphic call context.  */\n+\n+const ipa_polymorphic_call_context ipa_dummy_polymorphic_call_context\n+   = {0, NULL, false, true};\n \n /* Pointer set of all call targets appearing in the cache.  */\n static pointer_set_t *cached_polymorphic_call_targets;\n@@ -292,8 +298,6 @@ add_type_duplicate (odr_type val, tree type)\n \t    inform (DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n \t\t    \"a type with the same name but different layout is \"\n \t\t    \"defined in another translation unit\");\n-\t    debug_tree (BINFO_VTABLE (TYPE_BINFO (type)));\n-\t    debug_tree (BINFO_VTABLE (TYPE_BINFO (val->type)));\n \t  if (cgraph_dump_file)\n \t    {\n \t      fprintf (cgraph_dump_file, \"ODR violation or merging or ODR type bug?\\n\");\n@@ -522,6 +526,7 @@ tree\n method_class_type (tree t)\n {\n   tree first_parm_type = TREE_VALUE (TYPE_ARG_TYPES (t));\n+  gcc_assert (TREE_CODE (t) == METHOD_TYPE);\n \n   return TREE_TYPE (first_parm_type);\n }\n@@ -555,34 +560,50 @@ build_type_inheritance_graph (void)\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n \n-/* If TARGET has associated node, record it in the NODES array.  */\n+/* If TARGET has associated node, record it in the NODES array.\n+   if TARGET can not be inserted (for example because its body was\n+   already removed and there is no way to refer to it), clear COMPLETEP.  */\n \n static void\n maybe_record_node (vec <cgraph_node *> &nodes,\n-\t\t   tree target, pointer_set_t *inserted)\n+\t\t   tree target, pointer_set_t *inserted,\n+\t\t   bool *completep)\n {\n   struct cgraph_node *target_node;\n   enum built_in_function fcode;\n \n-  if (target\n+  if (!target\n       /* Those are used to mark impossible scenarios.  */\n-      && (fcode = DECL_FUNCTION_CODE (target))\n-\t  != BUILT_IN_UNREACHABLE\n-      && fcode != BUILT_IN_TRAP\n-      && !pointer_set_insert (inserted, target)\n-      && (target_node = cgraph_get_node (target)) != NULL\n+      || (fcode = DECL_FUNCTION_CODE (target))\n+\t  == BUILT_IN_UNREACHABLE\n+      || fcode == BUILT_IN_TRAP)\n+    return;\n+\n+  target_node = cgraph_get_node (target);\n+\n+  if (target_node != NULL\n       && (TREE_PUBLIC (target)\n \t  || target_node->definition)\n       && symtab_real_symbol_p (target_node))\n     {\n-      pointer_set_insert (cached_polymorphic_call_targets,\n-\t\t\t  target_node);\n-      nodes.safe_push (target_node);\n+      gcc_assert (!target_node->global.inlined_to);\n+      gcc_assert (symtab_real_symbol_p (target_node));\n+      if (!pointer_set_insert (inserted, target))\n+\t{\n+\t  pointer_set_insert (cached_polymorphic_call_targets,\n+\t\t\t      target_node);\n+\t  nodes.safe_push (target_node);\n+\t}\n     }\n+  else if (completep\n+\t   && !type_in_anonymous_namespace_p\n+\t\t (method_class_type (TREE_TYPE (target))))\n+    *completep = true;\n }\n \n-/* See if BINFO's type match OTR_TYPE.  If so, lookup method\n-   in vtable of TYPE_BINFO and insert method to NODES array.\n+/* See if BINFO's type match OUTER_TYPE.  If so, lookup \n+   BINFO of subtype of OTR_TYPE at OFFSET and in that BINFO find\n+   method in vtable and insert method to NODES array.\n    Otherwise recurse to base BINFOs.\n    This match what get_binfo_at_offset does, but with offset\n    being unknown.\n@@ -593,35 +614,39 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n    otherwise it is binfo of BINFO's type.\n \n    MATCHED_VTABLES tracks virtual tables we already did lookup\n-   for virtual function in.\n+   for virtual function in. INSERTED tracks nodes we already\n+   inserted.\n \n    ANONYMOUS is true if BINFO is part of anonymous namespace.\n   */\n \n static void\n-record_binfo (vec <cgraph_node *> &nodes,\n-\t      tree binfo,\n-\t      tree otr_type,\n-\t      tree type_binfo,\n-\t      HOST_WIDE_INT otr_token,\n-\t      pointer_set_t *inserted,\n-\t      pointer_set_t *matched_vtables,\n-\t      bool anonymous)\n+record_target_from_binfo (vec <cgraph_node *> &nodes,\n+\t\t\t  tree binfo,\n+\t\t\t  tree otr_type,\n+\t\t\t  tree type_binfo,\n+\t\t\t  HOST_WIDE_INT otr_token,\n+\t\t\t  tree outer_type,\n+\t\t\t  HOST_WIDE_INT offset,\n+\t\t\t  pointer_set_t *inserted,\n+\t\t\t  pointer_set_t *matched_vtables,\n+\t\t\t  bool anonymous)\n {\n   tree type = BINFO_TYPE (binfo);\n   int i;\n   tree base_binfo;\n \n   gcc_checking_assert (BINFO_VTABLE (type_binfo));\n \n-  if (types_same_for_odr (type, otr_type)\n-      && !pointer_set_insert (matched_vtables, BINFO_VTABLE (type_binfo)))\n+  if (types_same_for_odr (type, outer_type))\n     {\n+      tree inner_binfo = get_binfo_at_offset (type_binfo,\n+\t\t\t\t\t      offset, otr_type);\n       /* For types in anonymous namespace first check if the respective vtable\n \t is alive. If not, we know the type can't be called.  */\n       if (!flag_ltrans && anonymous)\n \t{\n-\t  tree vtable = BINFO_VTABLE (type_binfo);\n+\t  tree vtable = BINFO_VTABLE (inner_binfo);\n \t  struct varpool_node *vnode;\n \n \t  if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n@@ -630,22 +655,27 @@ record_binfo (vec <cgraph_node *> &nodes,\n \t  if (!vnode || !vnode->definition)\n \t    return;\n \t}\n-      tree target = gimple_get_virt_method_for_binfo (otr_token, type_binfo);\n-      if (target)\n-\tmaybe_record_node (nodes, target, inserted);\n+      gcc_assert (inner_binfo);\n+      if (!pointer_set_insert (matched_vtables, BINFO_VTABLE (inner_binfo)))\n+\t{\n+\t  tree target = gimple_get_virt_method_for_binfo (otr_token, inner_binfo);\n+\t  if (target)\n+\t    maybe_record_node (nodes, target, inserted, NULL);\n+\t}\n       return;\n     }\n \n   /* Walk bases.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     /* Walking bases that have no virtual method is pointless excercise.  */\n     if (polymorphic_type_binfo_p (base_binfo))\n-      record_binfo (nodes, base_binfo, otr_type,\n-\t\t    /* In the case of single inheritance, the virtual table\n-\t\t       is shared with the outer type.  */\n-\t\t    BINFO_VTABLE (base_binfo) ? base_binfo : type_binfo,\n-\t\t    otr_token, inserted,\n-\t\t    matched_vtables, anonymous);\n+      record_target_from_binfo (nodes, base_binfo, otr_type,\n+\t\t\t\t/* In the case of single inheritance,\n+\t\t\t\t   the virtual table is shared with\n+\t\t\t\t   the outer type.  */\n+\t\t\t\tBINFO_VTABLE (base_binfo) ? base_binfo : type_binfo,\n+\t\t\t\totr_token, outer_type, offset, inserted,\n+\t\t\t\tmatched_vtables, anonymous);\n }\n      \n /* Lookup virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n@@ -659,19 +689,23 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n \t\t\t\t     pointer_set_t *matched_vtables,\n \t\t\t\t     tree otr_type,\n \t\t\t\t     odr_type type,\n-\t\t\t\t     HOST_WIDE_INT otr_token)\n+\t\t\t\t     HOST_WIDE_INT otr_token,\n+\t\t\t\t     tree outer_type,\n+\t\t\t\t     HOST_WIDE_INT offset)\n {\n   tree binfo = TYPE_BINFO (type->type);\n   unsigned int i;\n \n-  record_binfo (nodes, binfo, otr_type, binfo, otr_token, inserted,\n-\t        matched_vtables, type->anonymous_namespace);\n+  record_target_from_binfo (nodes, binfo, otr_type, binfo, otr_token,\n+\t\t\t    outer_type, offset,\n+\t\t\t    inserted, matched_vtables,\n+\t\t\t    type->anonymous_namespace);\n   for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,\n \t\t\t\t\t otr_type,\n \t\t\t\t\t type->derived_types[i],\n-\t\t\t\t\t otr_token);\n+\t\t\t\t\t otr_token, outer_type, offset);\n }\n \n /* Cache of queries for polymorphic call targets.\n@@ -682,9 +716,11 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n \n struct polymorphic_call_target_d\n {\n-  odr_type type;\n   HOST_WIDE_INT otr_token;\n+  ipa_polymorphic_call_context context;\n+  odr_type type;\n   vec <cgraph_node *> targets;\n+  bool final;\n };\n \n /* Polymorphic call target cache helpers.  */\n@@ -703,8 +739,17 @@ struct polymorphic_call_target_hasher\n inline hashval_t\n polymorphic_call_target_hasher::hash (const value_type *odr_query)\n {\n-  return iterative_hash_hashval_t (odr_query->type->id,\n-\t\t\t\t   odr_query->otr_token);\n+  hashval_t hash;\n+\n+  hash = iterative_hash_host_wide_int\n+\t  (odr_query->otr_token,\n+\t   odr_query->type->id);\n+  hash = iterative_hash_hashval_t (TYPE_UID (odr_query->context.outer_type),\n+\t\t\t\t   hash);\n+  hash = iterative_hash_host_wide_int (odr_query->context.offset, hash);\n+  return iterative_hash_hashval_t\n+\t    (((int)odr_query->context.maybe_in_construction << 1)\n+\t     | (int)odr_query->context.maybe_derived_type, hash);\n }\n \n /* Compare cache entries T1 and T2.  */\n@@ -713,7 +758,12 @@ inline bool\n polymorphic_call_target_hasher::equal (const value_type *t1,\n \t\t\t\t       const compare_type *t2)\n {\n-  return t1->type == t2->type && t1->otr_token == t2->otr_token;\n+  return (t1->type == t2->type && t1->otr_token == t2->otr_token\n+\t  && t1->context.offset == t2->context.offset\n+\t  && t1->context.outer_type == t2->context.outer_type\n+\t  && t1->context.maybe_in_construction\n+\t      == t2->context.maybe_in_construction\n+\t  && t1->context.maybe_derived_type == t2->context.maybe_derived_type);\n }\n \n /* Remove entry in polymorphic call target cache hash.  */\n@@ -754,6 +804,337 @@ devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n     free_polymorphic_call_targets_hash ();\n }\n \n+/* CONTEXT->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n+   is contained at CONTEXT->OFFSET.  Walk the memory representation of\n+   CONTEXT->OUTER_TYPE and find the outermost class type that match\n+   EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update CONTEXT\n+   to represent it.\n+\n+   For example when CONTEXT represents type\n+   class A\n+     {\n+       int a;\n+       class B b;\n+     }\n+   and we look for type at offset sizeof(int), we end up with B and offset 0.\n+   If the same is produced by multiple inheritance, we end up with A and offset\n+   sizeof(int). \n+\n+   If we can not find corresponding class, give up by setting\n+   CONTEXT->OUTER_TYPE to EXPECTED_TYPE and CONTEXT->OFFSET to NULL. \n+   Return true when lookup was sucesful.  */\n+\n+static bool\n+get_class_context (ipa_polymorphic_call_context *context,\n+\t\t   tree expected_type)\n+{\n+  tree type = context->outer_type;\n+  HOST_WIDE_INT offset = context->offset;\n+\n+  /* Find the sub-object the constant actually refers to and mark whether it is\n+     an artificial one (as opposed to a user-defined one).  */\n+  while (true)\n+    {\n+      HOST_WIDE_INT pos, size;\n+      tree fld;\n+\n+      /* On a match, just return what we found.  */\n+      if (TREE_CODE (type) == TREE_CODE (expected_type)\n+\t  && types_same_for_odr (type, expected_type))\n+\t{\n+\t  gcc_assert (offset == 0);\n+\t  return true;\n+\t}\n+\n+      /* Walk fields and find corresponding on at OFFSET.  */\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+\t    {\n+\t      if (TREE_CODE (fld) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      pos = int_bit_position (fld);\n+\t      size = tree_to_uhwi (DECL_SIZE (fld));\n+\t      if (pos <= offset && (pos + size) > offset)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!fld)\n+\t    goto give_up;\n+\n+\t  type = TREE_TYPE (fld);\n+\t  offset -= pos;\n+\t  /* DECL_ARTIFICIAL represents a basetype.  */\n+\t  if (!DECL_ARTIFICIAL (fld))\n+\t    {\n+\t      context->outer_type = type;\n+\t      context->offset = offset;\n+\t      /* As soon as we se an field containing the type,\n+\t\t we know we are not looking for derivations.  */\n+\t      context->maybe_derived_type = false;\n+\t    }\n+\t}\n+      else if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  tree subtype = TREE_TYPE (type);\n+\n+\t  /* Give up if we don't know array size.  */\n+\t  if (!tree_fits_shwi_p (TYPE_SIZE (subtype))\n+\t      || !tree_to_shwi (TYPE_SIZE (subtype)) <= 0)\n+\t    goto give_up;\n+\t  offset = offset % tree_to_shwi (TYPE_SIZE (subtype));\n+\t  type = subtype;\n+\t  context->outer_type = type;\n+\t  context->offset = offset;\n+\t  context->maybe_derived_type = false;\n+\t}\n+      /* Give up on anything else.  */\n+      else\n+\tgoto give_up;\n+    }\n+\n+  /* If we failed to find subtype we look for, give up and fall back to the\n+     most generic query.  */\n+give_up:\n+  context->outer_type = expected_type;\n+  context->offset = 0;\n+  context->maybe_derived_type = true;\n+  return false;\n+}\n+\n+/* Return true if OUTER_TYPE contains OTR_TYPE at OFFSET.  */\n+\n+static bool\n+contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n+\t\t tree otr_type)\n+{\n+  ipa_polymorphic_call_context context = {offset, outer_type,\n+\t\t\t\t\t  false, true};\n+  return get_class_context (&context, otr_type);\n+}\n+\n+/* Given REF call in FNDECL, determine class of the polymorphic\n+   call (OTR_TYPE), its token (OTR_TOKEN) and CONTEXT.\n+   Return pointer to object described by the context  */\n+\n+tree\n+get_polymorphic_call_info (tree fndecl,\n+\t\t\t   tree ref,\n+\t\t\t   tree *otr_type,\n+\t\t\t   HOST_WIDE_INT *otr_token,\n+\t\t\t   ipa_polymorphic_call_context *context)\n+{\n+  tree base_pointer;\n+  *otr_type = obj_type_ref_class (ref);\n+  *otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (ref));\n+\n+  /* Set up basic info in case we find nothing interesting in the analysis.  */\n+  context->outer_type = *otr_type;\n+  context->offset = 0;\n+  base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n+  context->maybe_derived_type = true;\n+  context->maybe_in_construction = false;\n+\n+  /* Walk SSA for outer object.  */\n+  do \n+    {\n+      if (TREE_CODE (base_pointer) == SSA_NAME\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n+\t  && SSA_NAME_DEF_STMT (base_pointer)\n+\t  && gimple_assign_single_p (SSA_NAME_DEF_STMT (base_pointer)))\n+\t{\n+\t  base_pointer = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (base_pointer));\n+\t  STRIP_NOPS (base_pointer);\n+\t}\n+      else if (TREE_CODE (base_pointer) == ADDR_EXPR)\n+\t{\n+\t  HOST_WIDE_INT size, max_size;\n+\t  HOST_WIDE_INT offset2;\n+\t  tree base = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n+\t\t\t\t\t       &offset2, &size, &max_size);\n+\n+\t  /* If this is a varying address, punt.  */\n+\t  if ((TREE_CODE (base) == MEM_REF || DECL_P (base))\n+\t      && max_size != -1\n+\t      && max_size == size)\n+\t    {\n+\t      /* We found dereference of a pointer.  Type of the pointer\n+\t\t and MEM_REF is meaningless, but we can look futher.  */\n+\t      if (TREE_CODE (base) == MEM_REF)\n+\t\t{\n+\t\t  base_pointer = TREE_OPERAND (base, 0);\n+\t\t  context->offset\n+\t\t     += offset2 + mem_ref_offset (base).low * BITS_PER_UNIT;\n+\t\t  context->outer_type = NULL;\n+\t\t}\n+\t      /* We found base object.  In this case the outer_type\n+\t\t is known.  */\n+\t      else if (DECL_P (base))\n+\t\t{\n+\t\t  context->outer_type = TREE_TYPE (base);\n+\t\t  gcc_assert (!POINTER_TYPE_P (context->outer_type));\n+\n+\t\t  /* Only type inconsistent programs can have otr_type that is\n+\t\t     not part of outer type.  */\n+\t\t  if (!contains_type_p (context->outer_type,\n+\t\t\t\t\tcontext->offset, *otr_type))\n+\t\t    return base_pointer;\n+\t\t  context->offset += offset2;\n+\t\t  base_pointer = NULL;\n+\t\t  /* Make very conservative assumption that all objects\n+\t\t     may be in construction. \n+\t\t     TODO: ipa-prop already contains code to tell better. \n+\t\t     merge it later.  */\n+\t\t  context->maybe_in_construction = true;\n+\t\t  context->maybe_derived_type = false;\n+\t\t  return base_pointer;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+      else if (TREE_CODE (base_pointer) == POINTER_PLUS_EXPR\n+\t       && tree_fits_uhwi_p (TREE_OPERAND (base_pointer, 1)))\n+\t{\n+\t  context->offset += tree_to_shwi (TREE_OPERAND (base_pointer, 1))\n+\t\t    * BITS_PER_UNIT;\n+\t  base_pointer = TREE_OPERAND (base_pointer, 0);\n+\t}\n+      else\n+\tbreak;\n+    }\n+  while (true);\n+\n+  /* Try to determine type of the outer object.  */\n+  if (TREE_CODE (base_pointer) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n+      && TREE_CODE (SSA_NAME_VAR (base_pointer)) == PARM_DECL)\n+    {\n+      /* See if parameter is THIS pointer of a method.  */\n+      if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE\n+\t  && SSA_NAME_VAR (base_pointer) == DECL_ARGUMENTS (fndecl))\n+\t{\n+\t  context->outer_type = TREE_TYPE (TREE_TYPE (base_pointer));\n+\t  gcc_assert (TREE_CODE (context->outer_type) == RECORD_TYPE);\n+\n+\t  /* Dynamic casting has possibly upcasted the type\n+\t     in the hiearchy.  In this case outer type is less\n+\t     informative than inner type and we should forget\n+\t     about it.  */\n+\t  if (!contains_type_p (context->outer_type, context->offset,\n+\t\t\t\t*otr_type))\n+\t    {\n+\t      context->outer_type = NULL;\n+\t      return base_pointer;\n+\t    }\n+\n+\t  /* If the function is constructor or destructor, then\n+\t     the type is possibly in consturction, but we know\n+\t     it is not derived type.  */\n+\t  if (DECL_CXX_CONSTRUCTOR_P (fndecl)\n+\t      || DECL_CXX_DESTRUCTOR_P (fndecl))\n+\t    {\n+\t      context->maybe_in_construction = true;\n+\t      context->maybe_derived_type = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      context->maybe_derived_type = true;\n+\t      context->maybe_in_construction = false;\n+\t    }\n+\t  return base_pointer;\n+\t}\n+      /* Non-PODs passed by value are really passed by invisible\n+\t reference.  In this case we also know the type of the\n+\t object.  */\n+      if (DECL_BY_REFERENCE (SSA_NAME_VAR (base_pointer)))\n+\t{\n+\t  context->outer_type = TREE_TYPE (TREE_TYPE (base_pointer));\n+\t  gcc_assert (!POINTER_TYPE_P (context->outer_type));\n+\t  /* Only type inconsistent programs can have otr_type that is\n+\t     not part of outer type.  */\n+\t  if (!contains_type_p (context->outer_type, context->offset,\n+\t\t\t        *otr_type))\n+\t    { \n+\t      context->outer_type = NULL;\n+\t      gcc_unreachable ();\n+\t      return base_pointer;\n+\t    }\n+\t  context->maybe_derived_type = false;\n+\t  context->maybe_in_construction = false;\n+          return base_pointer;\n+\t}\n+    }\n+  /* TODO: There are multiple ways to derive a type.  For instance\n+     if BASE_POINTER is passed to an constructor call prior our refernece.\n+     We do not make this type of flow sensitive analysis yet.  */\n+  return base_pointer;\n+}\n+\n+/* Walk bases of OUTER_TYPE that contain OTR_TYPE at OFFSET.\n+   Lookup their respecitve virtual methods for OTR_TOKEN and OTR_TYPE\n+   and insert them to NODES.\n+\n+   MATCHED_VTABLES and INSERTED is used to avoid duplicated work.  */\n+\n+static void\n+record_targets_from_bases (tree otr_type,\n+\t\t\t   HOST_WIDE_INT otr_token,\n+\t\t\t   tree outer_type,\n+\t\t\t   HOST_WIDE_INT offset,\n+\t\t\t   vec <cgraph_node *> nodes,\n+\t\t\t   pointer_set_t *inserted,\n+\t\t\t   pointer_set_t *matched_vtables,\n+\t\t\t   bool *completep)\n+{\n+  while (true)\n+    {\n+      HOST_WIDE_INT pos, size;\n+      tree base_binfo;\n+      tree fld;\n+\n+      if (types_same_for_odr (outer_type, otr_type))\n+\treturn;\n+\n+      for (fld = TYPE_FIELDS (outer_type); fld; fld = DECL_CHAIN (fld))\n+\t{\n+\t  if (TREE_CODE (fld) != FIELD_DECL)\n+\t    continue;\n+\n+\t  pos = int_bit_position (fld);\n+\t  size = tree_to_shwi (DECL_SIZE (fld));\n+\t  if (pos <= offset && (pos + size) > offset)\n+\t    break;\n+\t}\n+      /* Within a class type we should always find correcponding fields.  */\n+      gcc_assert (fld && TREE_CODE (TREE_TYPE (fld)) == RECORD_TYPE);\n+\n+      /* Nonbasetypes should have been stripped by outer_class_type.  */\n+      gcc_assert (DECL_ARTIFICIAL (fld));\n+\n+      outer_type = TREE_TYPE (fld);\n+      offset -= pos;\n+\n+      base_binfo = get_binfo_at_offset (TYPE_BINFO (outer_type),\n+\t\t\t\t\toffset, otr_type);\n+      gcc_assert (base_binfo);\n+      if (!pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo)))\n+\t{\n+\t  tree target = gimple_get_virt_method_for_binfo (otr_token, base_binfo);\n+\t  if (target)\n+\t    maybe_record_node (nodes, target, inserted, completep);\n+\t  /* The only way method in anonymous namespace can become unreferable\n+\t     is that it has been fully optimized out.  */\n+\t  else if (flag_ltrans || !type_in_anonymous_namespace_p (outer_type))\n+\t    *completep = false;\n+\t  pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo));\n+\t}\n+    }\n+}\n+\n /* When virtual table is removed, we may need to flush the cache.  */\n \n static void\n@@ -767,8 +1148,14 @@ devirt_variable_node_removal_hook (struct varpool_node *n,\n }\n \n /* Return vector containing possible targets of polymorphic call of type\n-   OTR_TYPE caling method OTR_TOKEN with OFFSET.  If FINALp is non-NULL,\n-   store true if the list is complette. \n+   OTR_TYPE caling method OTR_TOKEN within type of OTR_OUTER_TYPE and OFFSET.\n+   If INCLUDE_BASES is true, walk also base types of OUTER_TYPES containig\n+   OTR_TYPE and include their virtual method.  This is useful for types\n+   possibly in construction or destruction where the virtual table may\n+   temporarily change to one of base types.  INCLUDE_DERIVER_TYPES make\n+   us to walk the inheritance graph for all derivations.\n+\n+   If COMPLETEP is non-NULL, store true if the list is complette. \n    CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n    in the target cache.  If user needs to visit every target list\n    just once, it can memoize them.\n@@ -780,32 +1167,44 @@ devirt_variable_node_removal_hook (struct varpool_node *n,\n vec <cgraph_node *>\n possible_polymorphic_call_targets (tree otr_type,\n \t\t\t           HOST_WIDE_INT otr_token,\n-\t\t\t           bool *finalp,\n+\t\t\t\t   ipa_polymorphic_call_context context,\n+\t\t\t           bool *completep,\n \t\t\t           void **cache_token)\n {\n   static struct cgraph_node_hook_list *node_removal_hook_holder;\n   pointer_set_t *inserted;\n   pointer_set_t *matched_vtables;\n   vec <cgraph_node *> nodes=vNULL;\n-  odr_type type;\n+  odr_type type, outer_type;\n   polymorphic_call_target_d key;\n   polymorphic_call_target_d **slot;\n   unsigned int i;\n   tree binfo, target;\n+  bool final;\n \n-  if (finalp)\n-    *finalp = false;\n+  type = get_odr_type (otr_type, true);\n \n-  type = get_odr_type (otr_type, false);\n-  /* If we do not have type in our hash it means we never seen any method\n-     in it.  */\n-  if (!type)\n-    return nodes;\n+  /* Lookup the outer class type we want to walk.  */\n+  if (context.outer_type)\n+    get_class_context (&context, otr_type);\n \n-  /* For anonymous namespace types we can attempt to build full type.\n-     All derivations must be in this unit.  */\n-  if (type->anonymous_namespace && finalp && !flag_ltrans)\n-    *finalp = true;\n+  /* We now canonicalize our query, so we do not need extra hashtable entries.  */\n+\n+  /* Without outer type, we have no use for offset.  Just do the\n+     basic search from innter type  */\n+  if (!context.outer_type)\n+    {\n+      context.outer_type = otr_type;\n+      context.offset = 0;\n+    }\n+  /* We need to update our hiearchy if the type does not exist.  */\n+  outer_type = get_odr_type (context.outer_type, true);\n+  /* If outer and inner type match, there are no bases to see.  */\n+  if (type == outer_type)\n+    context.maybe_in_construction = false;\n+  /* If the type is final, there are no derivations.  */\n+  if (TYPE_FINAL_P (outer_type->type))\n+    context.maybe_derived_type = false;\n \n   /* Initialize query cache.  */\n   if (!cached_polymorphic_call_targets)\n@@ -824,43 +1223,75 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* Lookup cached answer.  */\n   key.type = type;\n   key.otr_token = otr_token;\n+  key.context = context;\n   slot = polymorphic_call_target_hash.find_slot (&key, INSERT);\n   if (cache_token)\n    *cache_token = (void *)*slot;\n   if (*slot)\n-    return (*slot)->targets;\n+    {\n+      if (completep)\n+\t*completep = (*slot)->final;\n+      return (*slot)->targets;\n+    }\n+\n+  final = true;\n \n   /* Do actual search.  */\n   timevar_push (TV_IPA_VIRTUAL_CALL);\n   *slot = XCNEW (polymorphic_call_target_d);\n   if (cache_token)\n-   *cache_token = (void *)*slot;\n+    *cache_token = (void *)*slot;\n   (*slot)->type = type;\n   (*slot)->otr_token = otr_token;\n+  (*slot)->context = context;\n \n   inserted = pointer_set_create ();\n   matched_vtables = pointer_set_create ();\n \n   /* First see virtual method of type itself.  */\n \n-  binfo = TYPE_BINFO (type->type);\n+  binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n+\t\t\t       context.offset, otr_type);\n   target = gimple_get_virt_method_for_binfo (otr_token, binfo);\n   if (target)\n-    maybe_record_node (nodes, target, inserted);\n+    {\n+      maybe_record_node (nodes, target, inserted, &final);\n+\n+      /* In the case we get final method, we don't need \n+\t to walk derivations.  */\n+      if (DECL_FINAL_P (target))\n+\tcontext.maybe_derived_type = false;\n+    }\n+  /* The only way method in anonymous namespace can become unreferable\n+     is that it has been fully optimized out.  */\n+  else if (flag_ltrans || !type->anonymous_namespace)\n+    final = false;\n   pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n \n-  /* TODO: If method is final, we can stop here and signaize that\n-     list is final.  We need C++ FE to pass our info about final\n-     methods and classes.  */\n+  /* Next walk bases, if asked to.  */\n+  if (context.maybe_in_construction)\n+    record_targets_from_bases (otr_type, otr_token, outer_type->type,\n+\t\t\t       context.offset, nodes, inserted,\n+\t\t\t       matched_vtables, &final);\n \n-  /* Walk recursively all derived types.  Here we need to lookup proper basetype\n-     via their BINFO walk that is done by record_binfo  */\n-  for (i = 0; i < type->derived_types.length (); i++)\n-    possible_polymorphic_call_targets_1 (nodes, inserted,\n-\t\t\t\t\t matched_vtables,\n-\t\t\t\t\t otr_type, type->derived_types[i],\n-\t\t\t\t\t otr_token);\n+  /* Finally walk recursively all derived types.  */\n+  if (context.maybe_derived_type)\n+    {\n+      /* For anonymous namespace types we can attempt to build full type.\n+\t All derivations must be in this unit (unless we see partial unit).  */\n+      if (!type->anonymous_namespace || flag_ltrans)\n+\tfinal = false;\n+      for (i = 0; i < outer_type->derived_types.length(); i++)\n+\tpossible_polymorphic_call_targets_1 (nodes, inserted,\n+\t\t\t\t\t     matched_vtables,\n+\t\t\t\t\t     otr_type, outer_type->derived_types[i],\n+\t\t\t\t\t     otr_token, outer_type->type,\n+\t\t\t\t\t     context.offset);\n+    }\n   (*slot)->targets = nodes;\n+  (*slot)->final = final;\n+  if (completep)\n+    *completep = final;\n \n   pointer_set_destroy (inserted);\n   pointer_set_destroy (matched_vtables);\n@@ -872,8 +1303,9 @@ possible_polymorphic_call_targets (tree otr_type,\n \n void\n dump_possible_polymorphic_call_targets (FILE *f,\n-\t\t\t\t    tree otr_type,\n-\t\t\t\t    HOST_WIDE_INT otr_token)\n+\t\t\t\t\ttree otr_type,\n+\t\t\t\t\tHOST_WIDE_INT otr_token,\n+\t\t\t\t\tconst ipa_polymorphic_call_context &ctx)\n {\n   vec <cgraph_node *> targets;\n   bool final;\n@@ -883,16 +1315,25 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   if (!type)\n     return;\n   targets = possible_polymorphic_call_targets (otr_type, otr_token,\n+\t\t\t\t\t       ctx,\n \t\t\t\t\t       &final);\n-  fprintf (f, \"Targets of polymorphic call of type %i \", type->id);\n+  fprintf (f, \"  Targets of polymorphic call of type %i:\", type->id);\n   print_generic_expr (f, type->type, TDF_SLIM);\n-  fprintf (f, \" token %i%s:\",\n-\t   (int)otr_token,\n-\t   final ? \" (full list)\" : \" (partial list, may call to other unit)\");\n+  fprintf (f, \" token %i\\n\"\n+\t   \"    Contained in type:\",\n+\t   (int)otr_token);\n+  print_generic_expr (f, ctx.outer_type, TDF_SLIM);\n+  fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\"\n+\t   \"    %s%s%s\\n      \",\n+\t   ctx.offset,\n+\t   final ? \"This is full list.\" :\n+\t   \"This is partial list; extra targets may be defined in other units.\",\n+\t   ctx.maybe_in_construction ? \" (base types included)\" : \"\",\n+\t   ctx.maybe_derived_type ? \" (derived types included)\" : \"\");\n   for (i = 0; i < targets.length (); i++)\n     fprintf (f, \" %s/%i\", targets[i]->name (),\n \t     targets[i]->order);\n-  fprintf (f, \"\\n\");\n+  fprintf (f, \"\\n\\n\");\n }\n \n \n@@ -902,17 +1343,25 @@ dump_possible_polymorphic_call_targets (FILE *f,\n bool\n possible_polymorphic_call_target_p (tree otr_type,\n \t\t\t\t    HOST_WIDE_INT otr_token,\n+\t\t\t\t    const ipa_polymorphic_call_context &ctx,\n \t\t\t\t    struct cgraph_node *n)\n {\n   vec <cgraph_node *> targets;\n   unsigned int i;\n+  enum built_in_function fcode;\n   bool final;\n \n+  if (TREE_CODE (TREE_TYPE (n->decl)) == FUNCTION_TYPE\n+      && ((fcode = DECL_FUNCTION_CODE (n->decl))\n+\t  == BUILT_IN_UNREACHABLE\n+          || fcode == BUILT_IN_TRAP))\n+    return true;\n+\n   if (!odr_hash.is_created ())\n     return true;\n-  targets = possible_polymorphic_call_targets (otr_type, otr_token, &final);\n+  targets = possible_polymorphic_call_targets (otr_type, otr_token, ctx, &final);\n   for (i = 0; i < targets.length (); i++)\n-    if (n == targets[i])\n+    if (symtab_semantically_equivalent_p (n, targets[i]))\n       return true;\n \n   /* At a moment we allow middle end to dig out new external declarations\n@@ -935,7 +1384,7 @@ update_type_inheritance_graph (void)\n     return;\n   free_polymorphic_call_targets_hash ();\n   timevar_push (TV_IPA_INHERITANCE);\n-  /* We reconstruct the graph starting of types of all methods seen in the\n+  /* We reconstruct the graph starting from types of all methods seen in the\n      the unit.  */\n   FOR_EACH_FUNCTION (n)\n     if (DECL_VIRTUAL_P (n->decl)"}, {"sha": "65f9da12e986e698dcd0d2203ee8ce7cd5dfc2be", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -386,6 +386,7 @@ ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n   jfunc->value.known_type.offset = offset,\n   jfunc->value.known_type.base_type = base_type;\n   jfunc->value.known_type.component_type = component_type;\n+  gcc_assert (component_type);\n }\n \n /* Set JFUNC to be a copy of another jmp (to be used by jump function\n@@ -1739,8 +1740,6 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n \n   cs = cgraph_edge (node, stmt);\n   cs->indirect_info->param_index = param_index;\n-  cs->indirect_info->offset = 0;\n-  cs->indirect_info->polymorphic = 0;\n   cs->indirect_info->agg_contents = 0;\n   cs->indirect_info->member_ptr = 0;\n   return cs;\n@@ -1837,6 +1836,8 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n \t\t\t\t   NULL, &by_ref))\n     {\n       struct cgraph_edge *cs = ipa_note_param_call (node, index, call);\n+      if (cs->indirect_info->offset != offset)\n+\tcs->indirect_info->outer_type = NULL;\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->by_ref = by_ref;\n@@ -1934,6 +1935,8 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n       && parm_preserved_before_stmt_p (&parms_ainfo[index], call, rec))\n     {\n       struct cgraph_edge *cs = ipa_note_param_call (node, index, call);\n+      if (cs->indirect_info->offset != offset)\n+\tcs->indirect_info->outer_type = NULL;\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->member_ptr = 1;\n@@ -2770,6 +2773,8 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  else\n \t    {\n \t      ici->param_index = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t      if (ipa_get_jf_ancestor_offset (jfunc))\n+\t        ici->outer_type = NULL;\n \t      ici->offset += ipa_get_jf_ancestor_offset (jfunc);\n \t    }\n \t}\n@@ -4084,12 +4089,15 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   bp_pack_value (&bp, ii->agg_contents, 1);\n   bp_pack_value (&bp, ii->member_ptr, 1);\n   bp_pack_value (&bp, ii->by_ref, 1);\n+  bp_pack_value (&bp, ii->maybe_in_construction, 1);\n+  bp_pack_value (&bp, ii->maybe_derived_type, 1);\n   streamer_write_bitpack (&bp);\n \n   if (ii->polymorphic)\n     {\n       streamer_write_hwi (ob, ii->otr_token);\n       stream_write_tree (ob, ii->otr_type, true);\n+      stream_write_tree (ob, ii->outer_type, true);\n     }\n }\n \n@@ -4111,10 +4119,13 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   ii->agg_contents = bp_unpack_value (&bp, 1);\n   ii->member_ptr = bp_unpack_value (&bp, 1);\n   ii->by_ref = bp_unpack_value (&bp, 1);\n+  ii->maybe_in_construction = bp_unpack_value (&bp, 1);\n+  ii->maybe_derived_type = bp_unpack_value (&bp, 1);\n   if (ii->polymorphic)\n     {\n       ii->otr_token = (HOST_WIDE_INT) streamer_read_hwi (ib);\n       ii->otr_type = stream_read_tree (ib, data_in);\n+      ii->outer_type = stream_read_tree (ib, data_in);\n     }\n }\n "}, {"sha": "b52742517ca9f10804637786e2aa5defe9ecf756", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -34,6 +34,21 @@ struct ipa_dfs_info {\n   PTR aux;\n };\n \n+/* Context of polymorphic call.  This is used by ipa-devirt walkers of the\n+   type inheritance graph.  */\n+struct ipa_polymorphic_call_context {\n+  /* The called object appears in an object of type OUTER_TYPE\n+     at offset OFFSET.  */\n+  HOST_WIDE_INT offset;\n+  tree outer_type;\n+  /* True if outer object may be in construction or destruction.  */\n+  bool maybe_in_construction;\n+  /* True if outer object may be of derived type.  */\n+  bool maybe_derived_type;\n+};\n+\n+/* Context representing \"I know nothing\".  */\n+extern const ipa_polymorphic_call_context ipa_dummy_polymorphic_call_context;\n \n /* In ipa-utils.c  */\n void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);\n@@ -59,13 +74,19 @@ void build_type_inheritance_graph (void);\n void update_type_inheritance_graph (void);\n vec <cgraph_node *>\n possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n+\t\t\t\t   ipa_polymorphic_call_context,\n \t\t\t\t   bool *final = NULL,\n \t\t\t\t   void **cache_token = NULL);\n odr_type get_odr_type (tree, bool insert = false);\n-void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT);\n+void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t\t     const ipa_polymorphic_call_context &);\n bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n+\t\t\t\t         const ipa_polymorphic_call_context &,\n \t\t\t\t\t struct cgraph_node *n);\n tree method_class_type (tree);\n+tree get_polymorphic_call_info (tree, tree, tree *,\n+\t\t\t\tHOST_WIDE_INT *,\n+\t\t\t\tipa_polymorphic_call_context *);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If FINALP is non-NULL, store true if the list is complette. \n@@ -83,8 +104,27 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n \t\t\t\t   void **cache_token = NULL)\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n+  ipa_polymorphic_call_context context = {e->indirect_info->offset,\n+\t\t\t\t\t  e->indirect_info->outer_type,\n+\t\t\t\t\t  e->indirect_info->maybe_in_construction,\n+\t\t\t\t\t  e->indirect_info->maybe_derived_type};\n   return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n \t\t\t\t\t    e->indirect_info->otr_token,\n+\t\t\t\t\t    context,\n+\t\t\t\t\t    final, cache_token);\n+}\n+\n+/* Same as above but taking OBJ_TYPE_REF as an parameter.  */\n+\n+inline vec <cgraph_node *>\n+possible_polymorphic_call_targets (tree call,\n+\t\t\t\t   bool *final = NULL,\n+\t\t\t\t   void **cache_token = NULL)\n+{\n+  return possible_polymorphic_call_targets (obj_type_ref_class (call),\n+\t\t\t\t\t    tree_to_uhwi\n+\t\t\t\t\t      (OBJ_TYPE_REF_TOKEN (call)),\n+\t\t\t\t\t    ipa_dummy_polymorphic_call_context,\n \t\t\t\t\t    final, cache_token);\n }\n \n@@ -94,8 +134,13 @@ inline void\n dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n+  ipa_polymorphic_call_context context = {e->indirect_info->offset,\n+\t\t\t\t\t  e->indirect_info->outer_type,\n+\t\t\t\t\t  e->indirect_info->maybe_in_construction,\n+\t\t\t\t\t  e->indirect_info->maybe_derived_type};\n   dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n-\t\t\t\t\t  e->indirect_info->otr_token);\n+\t\t\t\t\t  e->indirect_info->otr_token,\n+\t\t\t\t\t  context);\n }\n \n /* Return true if N can be possibly target of a polymorphic call of\n@@ -105,8 +150,13 @@ inline bool\n possible_polymorphic_call_target_p (struct cgraph_edge *e,\n \t\t\t\t    struct cgraph_node *n)\n {\n+  ipa_polymorphic_call_context context = {e->indirect_info->offset,\n+\t\t\t\t\t  e->indirect_info->outer_type,\n+\t\t\t\t\t  e->indirect_info->maybe_in_construction,\n+\t\t\t\t\t  e->indirect_info->maybe_derived_type};\n   return possible_polymorphic_call_target_p (e->indirect_info->otr_type,\n-\t\t\t\t\t     e->indirect_info->otr_token, n);\n+\t\t\t\t\t     e->indirect_info->otr_token,\n+\t\t\t\t\t     context, n);\n }\n \n /* Return true if N can be possibly target of a polymorphic call of\n@@ -118,7 +168,8 @@ possible_polymorphic_call_target_p (tree call,\n {\n   return possible_polymorphic_call_target_p (obj_type_ref_class (call),\n \t\t\t\t\t     tree_to_uhwi\n-\t\t\t\t\t\t(OBJ_TYPE_REF_TOKEN (call)),\n+\t\t\t\t\t       (OBJ_TYPE_REF_TOKEN (call)),\n+\t\t\t\t\t     ipa_dummy_polymorphic_call_context,\n \t\t\t\t\t     n);\n }\n #endif  /* GCC_IPA_UTILS_H  */"}, {"sha": "cbe540766be42d892e2e19e74ca84718fdecb417", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -1,3 +1,8 @@\n+2013-11-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa/devirt9.C: Verify that the optimization happens already before.\n+\twhole-program.\n+\n 2013-11-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/57517"}, {"sha": "d828a8a1cfd308814e86b6adc4cd1c05d1242edb", "filename": "gcc/testsuite/g++.dg/ipa/devirt-9.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68377e53bdbabc3c328a027bfa2c6a55c0718e81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-9.C?ref=68377e53bdbabc3c328a027bfa2c6a55c0718e81", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-inline\"  } */\n+/* { dg-options \"-O2 -fdump-ipa-whole-program\"  } */\n double foo ();\n struct B\n {\n@@ -27,5 +27,7 @@ bar ()\n   static C c;\n   c.c1 (60, (int) foo ());\n }\n-/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target\"  \"inline\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* We optimize out this call just after early passes.  Unfortunately\n+   this unreachable removal is not logged in dump file.  */\n+/* { dg-final { scan-ipa-dump 1 \"OBJ_TYPE_REF\"  \"whole-program\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"whole-program\" } } */"}]}